Number of bits per plane
      72,                               // Screen Frequency, in Hertz.
      330,                              // Horizontal size of screen in mm
      240,                              // Vertical size of screen in mm
      8,                                // # of Red bits in non-palette modes
      8,                                // # of Green bits in non-palette modes
      8,                                // # of Blue bits in non-palette modes
      0x00000000,                       // Mask for Red bits in non-palette modes
      0x00000000,                       // Mask for Green bits in non-palette modes
      0x00000000,                       // Mask for Blue bits in non-palette modes
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
      VIDEO_MODE_MANAGED_PALETTE,       // Mode flags
      0L, 0L
    }
},
{
  18,                                   // Number of entries in the mode set structure
  (P9000_ID | P9100_ID),
  v800_600_60,                          // Ptr to the default video parms
  FALSE,
    {                                   // containing the video parms.
      sizeof(VIDEO_MODE_INFORMATION),   // Size of the mode info struct
      m800_600_16_60,                   // Index used to set this mode
      800,                              // X Resolution, in pixels
      600,                              // Y Resolution, in pixels
      800 * 2,                          // physical scanline byte length
      1,                                // Number of video memory planes
      16,                               // Number of bits per plane
      60,                               // Screen Frequency, in Hertz.
      330,                              // Horizontal size of screen in mm
      240,                              // Vertical size of screen in mm
      5,                                // # of Red bits in non-palette modes
      5,                                // # of Green bits in non-palette modes
      5,                                // # of Blue bits in non-palette modes
      0x00007C00,                       // Mask for Red bits in non-palette modes
      0x000003E0,                       // Mask for Green bits in non-palette modes
      0x0000001F,                       // Mask for Blue bits in non-palette modes
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,   // Mode flags
      0L, 0L
    }
},
{
  18,                                   // Number of entries in the mode set structure
  (P9000_ID | P9100_ID),
  v800_600_72,                          // Ptr to the default video parms
  FALSE,
    {                                   // containing the video parms.
      sizeof(VIDEO_MODE_INFORMATION),   // Size of the mode info struct
      m800_600_16_72,                   // Index used to set this mode
      800,                              // X Resolution, in pixels
      600,                              // Y Resolution, in pixels
      800 * 2,                          // physical scanline byte length
      1,                                // Number of video memory planes
      16,                               // Number of bits per plane
      72,                               // Screen Frequency, in Hertz.
      330,                              // Horizontal size of screen in mm
      240,                              // Vertical size of screen in mm
      5,                                // # of Red bits in non-palette modes
      5,                                // # of Green bits in non-palette modes
      5,                                // # of Blue bits in non-palette modes
      0x00007C00,                       // Mask for Red bits in non-palette modes
      0x000003E0,                       // Mask for Green bits in non-palette modes
      0x0000001F,                       // Mask for Blue bits in non-palette modes
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,   // Mode flags
      0L, 0L
    }
},
{
  18,                                   // Number of entries in the struct
  P9100_ID,
  v800_600_60,                          // Ptr to the default video parms
  FALSE,
    {                                   // containing the video parms.
      sizeof(VIDEO_MODE_INFORMATION),   // Size of the mode info struct
      m800_600_24_60,                   // Index used to set this mode
      800,                              // X Resolution, in pixels
      600,                              // Y Resolution, in pixels
      800 * 3,                          // physical scanline byte length
      1,                                // Number of video memory planes
      24,                               // Number of bits per plane
      60,                               // Screen Frequency, in Hertz.
      330,                              // Horizontal size of screen in mm
      240,                              // Vertical size of screen in mm
      8,                                // # of Red bits in non-palette modes
      8,                                // # of Green bits in non-palette modes
      8,                                // # of Blue bits in non-palette modes
      0x00FF0000,                       // Mask for Red bits in non-palette modes
      0x0000FF00,                       // Mask for Green bits in non-palette modes
      0x000000FF,                       // Mask for Blue bits in non-palette modes
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
      0L, 0L
    }                                   // Mode flags
},
{
  18,                                   // Number of entries in the struct
  P9100_ID,
  v800_600_72,                          // Ptr to the default video parms
  FALSE,
    {                                   // containing the video parms.
      sizeof(VIDEO_MODE_INFORMATION),   // Size of the mode info struct
      m800_600_24_72,                   // Index used to set this mode
      800,                              // X Resolution, in pixels
      600,                              // Y Resolution, in pixels
      800 * 3,                          // physical scanline byte length
      1,                                // Number of video memory planes
      24,                               // Number of bits per plane
      72,                               // Screen Frequency, in Hertz.
      330,                              // Horizontal size of screen in mm
      240,                              // Vertical size of screen in mm
      8,                                // # of Red bits in non-palette modes
      8,                                // # of Green bits in non-palette modes
      8,                                // # of Blue bits in non-palette modes
      0x00FF0000,                       // Mask for Red bits in non-palette modes
      0x0000FF00,                       // Mask for Green bits in non-palette modes
      0x000000FF,                       // Mask for Blue bits in non-palette modes
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
      0L, 0L
    }                                   // Mode flags
},
{
  18,                                   // Number of entries in the struct
  (P9000_ID | P9100_ID),
  v800_600_60,                          // Ptr to the default video parms
  FALSE,
    {                                   // containing the video parms.
      sizeof(VIDEO_MODE_INFORMATION),   // Size of the mode info struct
      m800_600_32_60,                   // Index used to set this mode
      800,                              // X Resolution, in pixels
      600,                              // Y Resolution, in pixels
      800 * 4,                          // physical scanline byte length
      1,                                // Number of video memory planes
      32,                               // Number of bits per plane
      60,                               // Screen Frequency, in Hertz.
      330,                              // Horizontal size of screen in mm
      240,                              // Vertical size of screen in mm
      8,                                // # of Red bits in non-palette modes
      8,                                // # of Green bits in non-palette modes
      8,                                // # of Blue bits in non-palette modes
      0x00FF0000,                       // Mask for Red bits in non-palette modes
      0x0000FF00,                       // Mask for Green bits in non-palette modes
      0x000000FF,                       // Mask for Blue bits in non-palette modes
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
      0L, 0L
    }                                   // Mode flags
},
{
  18,                                   // Number of entries in the struct
  (P9000_ID | P9100_ID),
  v800_600_72,                          // Ptr to the default video parms
  FALSE,
    {                                   // containing the video parms.
      sizeof(VIDEO_MODE_INFORMATION),   // Size of the mode info struct
      m800_600_32_72,                   // Index used to set this mode
      800,                              // X Resolution, in pixels
      600,                              // Y Resolution, in pixels
      800 * 4,                          // physical scanline byte length
      1,                                // Number of video memory planes
      32,                               // Number of bits per plane
      72,                               // Screen Frequency, in Hertz.
      330,                              // Horizontal size of screen in mm
      240,                              // Vertical size of screen in mm
      8,                                // # of Red bits in non-palette modes
      8,                                // # of Green bits in non-palette modes
      8,                                // # of Blue bits in non-palette modes
      0x00FF0000,                       // Mask for Red bits in non-palette modes
      0x0000FF00,                       // Mask for Green bits in non-palette modes
      0x000000FF,                       // Mask for Blue bits in non-palette modes
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
      0L, 0L
    }                                   // Mode flags
},
{
  18,                                   // Number of entries in the struct
  (P9000_ID | P9100_ID),
  v1K_768_60,                           // Ptr to the default video parms
  FALSE,
    {                                   // containing the video parms.
      sizeof(VIDEO_MODE_INFORMATION),   // Size of the mode info struct
      m1K_768_8_60,                     // Index used to set this mode
      1024,                             // X Resolution, in pixels
      768,                              // Y Resolution, in pixels
      1024,                             // physical scanline byte length
      1,                                // Number of video memory planes
      8,                                // Number of bits per plane
      60,                               // Screen Frequency, in Hertz.
      330,                              // Horizontal size of screen in mm
      240,                              // Vertical size of screen in mm
      8,                                // # of Red bits in non-palette modes
      8,                                // # of Green bits in non-palette modes
      8,                                // # of Blue bits in non-palette modes
      0x00000000,                       // Mask for Red bits in non-palette modes
      0x00000000,                       // Mask for Green bits in non-palette modes
      0x00000000,                       // Mask for Blue bits in non-palette modes
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
      VIDEO_MODE_MANAGED_PALETTE,       // Mode flags
      0L, 0L
    }
},
{
  18,                                   // Number of entries in the struct
  (P9000_ID | P9100_ID),
  v1K_768_70,                           // Ptr to the default video parms
  FALSE,
    {                                   // containing the video parms.
      sizeof(VIDEO_MODE_INFORMATION),   // Size of the mode info struct
      m1K_768_8_70,                     // Index used to set this mode
      1024,                             // X Resolution, in pixels
      768,                              // Y Resolution, in pixels
      1024,                             // physical scanline byte length
      1,                                // Number of video memory planes
      8,                                // Number of bits per plane
      70,                               // Screen Frequency, in Hertz.
      330,                              // Horizontal size of screen in mm
      240,                              // Vertical size of screen in mm
      8,                                // # of Red bits in non-palette modes
      8,                                // # of Green bits in non-palette modes
      8,                                // # of Blue bits in non-palette modes
      0x00000000,                       // Mask for Red bits in non-palette modes
      0x00000000,                       // Mask for Green bits in non-palette modes
      0x00000000,                       // Mask for Blue bits in non-palette modes
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
      VIDEO_MODE_MANAGED_PALETTE,       // Mode flags
      0L, 0L
    }
},
{
  18,                                   // Number of entries in the struct
  (P9000_ID | P9100_ID),
  v1K_768_60,                           // Ptr to the default video parms
  FALSE,
    {                                   // containing the video parms.
      sizeof(VIDEO_MODE_INFORMATION),   // Size of the mode info struct
      m1K_768_16_60,                    // Index used to set this mode
      1024,                             // X Resolution, in pixels
      768,                              // Y Resolution, in pixels
      1024 * 2,                         // physical scanline byte length
      1,                                // Number of video memory planes
      16,                               // Number of bits per plane
      60,                               // Screen Frequency, in Hertz.
      330,                              // Horizontal size of screen in mm
      240,                              // Vertical size of screen in mm
      5,                                // # of Red bits in non-palette modes
      5,                                // # of Green bits in non-palette modes
      5,                                // # of Blue bits in non-palette modes
      0x00007C00,                       // Mask for Red bits in non-palette modes
      0x000003E0,                       // Mask for Green bits in non-palette modes
      0x0000001F,                       // Mask for Blue bits in non-palette modes
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
      0L, 0L
    }                                   // Mode flags
},
{
  18,                                   // Number of entries in the struct
  (P9000_ID | P9100_ID),
  v1K_768_70,                           // Ptr to the default video parms
  FALSE,
    {                                   // containing the video parms.
      sizeof(VIDEO_MODE_INFORMATION),   // Size of the mode info struct
      m1K_768_16_70,                    // Index used to set this mode
      1024,                             // X Resolution, in pixels
      768,                              // Y Resolution, in pixels
      1024 * 2,                         // physical scanline byte length
      1,                                // Number of video memory planes
      16,                               // Number of bits per plane
      70,                               // Screen Frequency, in Hertz.
      330,                              // Horizontal size of screen in mm
      240,                              // Vertical size of screen in mm
      5,                                // # of Red bits in non-palette modes
      5,                                // # of Green bits in non-palette modes
      5,                                // # of Blue bits in non-palette modes
      0x00007C00,                       // Mask for Red bits in non-palette modes
      0x000003E0,                       // Mask for Green bits in non-palette modes
      0x0000001F,                       // Mask for Blue bits in non-palette modes
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
      0L, 0L
    }                                   // Mode flags
},

{
  18,                                   // Number of entries in the struct
  P9100_ID,
  v1K_768_60,                           // Ptr to the default video parms
  FALSE,
    {                                   // containing the video parms.
      sizeof(VIDEO_MODE_INFORMATION),   // Size of the mode info struct
      m1K_768_24_60,                    // Index used to set this mode
      1024,                             // X Resolution, in pixels
      768,                              // Y Resolution, in pixels
      1024 * 3,                         // physical scanline byte length
      1,                                // Number of video memory planes
      24,                               // Number of bits per plane
      60,                               // Screen Frequency, in Hertz.
      330,                              // Horizontal size of screen in mm
      240,                              // Vertical size of screen in mm
      8,                                // # of Red bits in non-palette modes
      8,                                // # of Green bits in non-palette modes
      8,                                // # of Blue bits in non-palette modes
      0x00FF0000,                       // Mask for Red bits in non-palette modes
      0x0000FF00,                       // Mask for Green bits in non-palette modes
      0x000000FF,                       // Mask for Blue bits in non-palette modes
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
      0L, 0L
    }                                   // Mode flags
},
{
  18,                                   // Number of entries in the struct
  P9100_ID,
  v1K_768_70,                           // Ptr to the default video parms
  FALSE,
    {                                   // containing the video parms.
      sizeof(VIDEO_MODE_INFORMATION),   // Size of the mode info struct
      m1K_768_24_70,                    // Index used to set this mode
      1024,                             // X Resolution, in pixels
      768,                              // Y Resolution, in pixels
      1024 * 3,                         // physical scanline byte length
      1,                                // Number of video memory planes
      24,                               // Number of bits per plane
      70,                               // Screen Frequency, in Hertz.
      330,                              // Horizontal size of screen in mm
      240,                              // Vertical size of screen in mm
      8,                                // # of Red bits in non-palette modes
      8,                                // # of Green bits in non-palette modes
      8,                                // # of Blue bits in non-palette modes
      0x00FF0000,                       // Mask for Red bits in non-palette modes
      0x0000FF00,                       // Mask for Green bits in non-palette modes
      0x000000FF,                       // Mask for Blue bits in non-palette modes
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
      0L, 0L
    }                                   // Mode flags
},
{
  18,                                   // Number of entries in the struct
  P9100_ID,
  v1K_768_60,                           // Ptr to the default video parms
  FALSE,
    {                                   // containing the video parms.
      sizeof(VIDEO_MODE_INFORMATION),   // Size of the mode info struct
      m1K_768_32_60,                    // Index used to set this mode
      1024,                             // X Resolution, in pixels
      768,                              // Y Resolution, in pixels
      1024 * 4,                         // physical scanline byte length
      1,                                // Number of video memory planes
      32,                               // Number of bits per plane
      60,                               // Screen Frequency, in Hertz.
      330,                              // Horizontal size of screen in mm
      240,                              // Vertical size of screen in mm
      8,                                // # of Red bits in non-palette modes
      8,                                // # of Green bits in non-palette modes
      8,                                // # of Blue bits in non-palette modes
      0x00FF0000,                       // Mask for Red bits in non-palette modes
      0x0000FF00,                       // Mask for Green bits in non-palette modes
      0x000000FF,                       // Mask for Blue bits in non-palette modes
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
      0L, 0L
    }                                   // Mode flags
},
{
  18,                                   // Number of entries in the struct
  P9100_ID,
  v1K_768_70,                           // Ptr to the default video parms
  FALSE,
    {                                   // containing the video parms.
      sizeof(VIDEO_MODE_INFORMATION),   // Size of the mode info struct
      m1K_768_32_70,                    // Index used to set this mode
      1024,                             // X Resolution, in pixels
      768,                              // Y Resolution, in pixels
      1024 * 4,                         // physical scanline byte length
      1,                                // Number of video memory planes
      32,                               // Number of bits per plane
      70,                               // Screen Frequency, in Hertz.
      330,                              // Horizontal size of screen in mm
      240,                              // Vertical size of screen in mm
      8,                                // # of Red bits in non-palette modes
      8,                                // # of Green bits in non-palette modes
      8,                                // # of Blue bits in non-palette modes
      0x00FF0000,                       // Mask for Red bits in non-palette modes
      0x0000FF00,                       // Mask for Green bits in non-palette modes
      0x000000FF,                       // Mask for Blue bits in non-palette modes
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
      0L, 0L
    }                                   // Mode flags
},


{
  18,                                   // Number of entries in the struct
  P9000_ID,
  v1280_1K_55,                          // Ptr to the default video parms
  FALSE,
    {                                   // containing the video parms.
      sizeof(VIDEO_MODE_INFORMATION),   // Size of the mode info struct
      m1280_1K_8_55,                    // Index used to set this mode
      1280,                             // X Resolution, in pixels
      1024,                             // Y Resolution, in pixels
      1280,                             // physical scanline byte length
      1,                                // Number of video memory planes
      8,                                // Number of bits per plane
      55,                               // Screen Frequency, in Hertz.
      330,                              // Horizontal size of screen in mm
      240,                              // Vertical size of screen in mm
      8,                                // # of Red bits in non-palette modes
      8,                                // # of Green bits in non-palette modes
      8,                                // # of Blue bits in non-palette modes
      0x00000000,                       // Mask for Red bits in non-palette modes
      0x00000000,                       // Mask for Green bits in non-palette modes
      0x00000000,                       // Mask for Blue bits in non-palette modes
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
      VIDEO_MODE_MANAGED_PALETTE,       // Mode flags
      0L, 0L
    }
},

{
  18,                                   // Number of entries in the struct
  (P9000_ID | P9100_ID),
  v1280_1K_60,                          // Ptr to the default video parms
  FALSE,
    {                                   // containing the video parms.
      sizeof(VIDEO_MODE_INFORMATION),   // Size of the mode info struct
      m1280_1K_8_60,                    // Index used to set this mode
      1280,                             // X Resolution, in pixels
      1024,                             // Y Resolution, in pixels
      1280,                             // physical scanline byte length
      1,                                // Number of video memory planes
      8,                                // Number of bits per plane
      60,                               // Screen Frequency, in Hertz.
      330,                              // Horizontal size of screen in mm
      240,                              // Vertical size of screen in mm
      8,                                // # of Red bits in non-palette modes
      8,                                // # of Green bits in non-palette modes
      8,                                // # of Blue bits in non-palette modes
      0x00000000,                       // Mask for Red bits in non-palette modes
      0x00000000,                       // Mask for Green bits in non-palette modes
      0x00000000,                       // Mask for Blue bits in non-palette modes
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
      VIDEO_MODE_MANAGED_PALETTE,       // Mode flags
      0L, 0L
    }
},
{
  18,                                   // Number of entries in the struct
  (P9000_ID | P9100_ID),
  v1280_1K_74,                          // Ptr to the default video parms
  FALSE,
    {                                   // containing the video parms.
      sizeof(VIDEO_MODE_INFORMATION),   // Size of the mode info struct
      m1280_1K_8_74,                    // Index used to set this mode
      1280,                             // X Resolution, in pixels
      1024,                             // Y Resolution, in pixels
      1280,                             // physical scanline byte length
      1,                                // Number of video memory planes
      8,                                // Number of bits per plane
      74,                               // Screen Frequency, in Hertz.
      330,                              // Horizontal size of screen in mm
      240,                              // Vertical size of screen in mm
      8,                                // # of Red bits in non-palette modes
      8,                                // # of Green bits in non-palette modes
      8,                                // # of Blue bits in non-palette modes
      0x00000000,                       // Mask for Red bits in non-palette modes
      0x00000000,                       // Mask for Green bits in non-palette modes
      0x00000000,                       // Mask for Blue bits in non-palette modes
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
      VIDEO_MODE_MANAGED_PALETTE,       // Mode flags
      0L, 0L
    }
},
{
  18,                                   // Number of entries in the struct
  (P9000_ID | P9100_ID),
  v1280_1K_75,                          // Ptr to the default video parms
  FALSE,
    {                                   // containing the video parms.
      sizeof(VIDEO_MODE_INFORMATION),   // Size of the mode info struct
      m1280_1K_8_75,                    // Index used to set this mode
      1280,                             // X Resolution, in pixels
      1024,                             // Y Resolution, in pixels
      1280,                             // physical scanline byte length
      1,                                // Number of video memory planes
      8,                                // Number of bits per plane
      75,                               // Screen Frequency, in Hertz.
      330,                              // Horizontal size of screen in mm
      240,                              // Vertical size of screen in mm
      8,                                // # of Red bits in non-palette modes
      8,                                // # of Green bits in non-palette modes
      8,                                // # of Blue bits in non-palette modes
      0x00000000,                       // Mask for Red bits in non-palette modes
      0x00000000,                       // Mask for Green bits in non-palette modes
      0x00000000,                       // Mask for Blue bits in non-palette modes
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
      VIDEO_MODE_MANAGED_PALETTE,       // Mode flags
      0L, 0L
    }
},
{
  18,                                   // Number of entries in the struct
  P9100_ID,
  v1280_1K_60,                          // Ptr to the default video parms
  FALSE,
    {                                   // containing the video parms.
      sizeof(VIDEO_MODE_INFORMATION),   // Size of the mode info struct
      m1280_1K_16_60,                   // Index used to set this mode
      1280,                             // X Resolution, in pixels
      1024,                             // Y Resolution, in pixels
      1280 * 2,                         // physical scanline byte length
      1,                                // Number of video memory planes
      16,                               // Number of bits per plane
      60,                               // Screen Frequency, in Hertz.
      330,                              // Horizontal size of screen in mm
      240,                              // Vertical size of screen in mm
      5,                                // # of Red bits in non-palette modes
      5,                                // # of Green bits in non-palette modes
      5,                                // # of Blue bits in non-palette modes
      0x00007C00,                       // Mask for Red bits in non-palette modes
      0x000003E0,                       // Mask for Green bits in non-palette modes
      0x0000001F,                       // Mask for Blue bits in non-palette modes
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
      0L, 0L
    }
},
{
  18,                                   // Number of entries in the struct
  P9100_ID,
  v1280_1K_74,                          // Ptr to the default video parms
  FALSE,
    {                                   // containing the video parms.
      sizeof(VIDEO_MODE_INFORMATION),   // Size of the mode info struct
      m1280_1K_16_74,                   // Index used to set this mode
      1280,                             // X Resolution, in pixels
      1024,                             // Y Resolution, in pixels
      1280 * 2,                         // physical scanline byte length
      1,                                // Number of video memory planes
      16,                               // Number of bits per plane
      74,                               // Screen Frequency, in Hertz.
      330,                              // Horizontal size of screen in mm
      240,                              // Vertical size of screen in mm
      5,                                // # of Red bits in non-palette modes
      5,                                // # of Green bits in non-palette modes
      5,                                // # of Blue bits in non-palette modes
      0x00007C00,                       // Mask for Red bits in non-palette modes
      0x000003E0,                       // Mask for Green bits in non-palette modes
      0x0000001F,                       // Mask for Blue bits in non-palette modes
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
      0L, 0L
    }
},
{
  18,                                   // Number of entries in the struct
  P9100_ID,
  v1280_1K_75,                          // Ptr to the default video parms
  FALSE,
    {                                   // containing the video parms.
      sizeof(VIDEO_MODE_INFORMATION),   // Size of the mode info struct
      m1280_1K_16_75,                   // Index used to set this mode
      1280,                             // X Resolution, in pixels
      1024,                             // Y Resolution, in pixels
      1280 * 2,                         // physical scanline byte length
      1,                                // Number of video memory planes
      16,                               // Number of bits per plane
      75,                               // Screen Frequency, in Hertz.
      330,                              // Horizontal size of screen in mm
      240,                              // Vertical size of screen in mm
      5,                                // # of Red bits in non-palette modes
      5,                                // # of Green bits in non-palette modes
      5,                                // # of Blue bits in non-palette modes
      0x00007C00,                       // Mask for Red bits in non-palette modes
      0x000003E0,                       // Mask for Green bits in non-palette modes
      0x0000001F,                       // Mask for Blue bits in non-palette modes
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
      0L, 0L
    }
},
{
  18,                                   // Number of entries in the struct
  P9100_ID,
  v1280_1K_60,                          // Ptr to the default video parms
  FALSE,
    {                                   // containing the video parms.
      sizeof(VIDEO_MODE_INFORMATION),   // Size of the mode info struct
      m1280_1K_24_60,                   // Index used to set this mode
      1280,                             // X Resolution, in pixels
      1024,                             // Y Resolution, in pixels
      1280 * 3,                         // physical scanline byte length
      1,                                // Number of video memory planes
      24,                               // Number of bits per plane
      60,                               // Screen Frequency, in Hertz.
      330,                              // Horizontal size of screen in mm
      240,                              // Vertical size of screen in mm
      8,                                // # of Red bits in non-palette modes
      8,                                // # of Green bits in non-palette modes
      8,                                // # of Blue bits in non-palette modes
      0x00FF0000,                       // Mask for Red bits in non-palette modes
      0x0000FF00,                       // Mask for Green bits in non-palette modes
      0x000000FF,                       // Mask for Blue bits in non-palette modes
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, // Mode flags
      0L, 0L
    }
},
{
  18,                                   // Number of entries in the struct
  P9100_ID,
  v1280_1K_74,                          // Ptr to the default video parms
  FALSE,
    {                                   // containing the video parms.
      sizeof(VIDEO_MODE_INFORMATION),   // Size of the mode info struct
      m1280_1K_24_74,                   // Index used to set this mode
      1280,                             // X Resolution, in pixels
      1024,                             // Y Resolution, in pixels
      1280 * 3,                         // physical scanline byte length
      1,                                // Number of video memory planes
      24,                               // Number of bits per plane
      74,                               // Screen Frequency, in Hertz.
      330,                              // Horizontal size of screen in mm
      240,                              // Vertical size of screen in mm
      8,                                // # of Red bits in non-palette modes
      8,                                // # of Green bits in non-palette modes
      8,                                // # of Blue bits in non-palette modes
      0x00FF0000,                       // Mask for Red bits in non-palette modes
      0x0000FF00,                       // Mask for Green bits in non-palette modes
      0x000000FF,                       // Mask for Blue bits in non-palette modes
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, // Mode flags
      0L, 0L
    }
},
{
  18,                                   // Number of entries in the struct
  P9100_ID,
  v1280_1K_75,                          // Ptr to the default video parms
  FALSE,
    {                                   // containing the video parms.
      sizeof(VIDEO_MODE_INFORMATION),   // Size of the mode info struct
      m1280_1K_24_75,                   // Index used to set this mode
      1280,                             // X Resolution, in pixels
      1024,                             // Y Resolution, in pixels
      1280 * 3,                         // physical scanline byte length
      1,                                // Number of video memory planes
      24,                               // Number of bits per plane
      75,                               // Screen Frequency, in Hertz.
      330,                              // Horizontal size of screen in mm
      240,                              // Vertical size of screen in mm
      8,                                // # of Red bits in non-palette modes
      8,                                // # of Green bits in non-palette modes
      8,                                // # of Blue bits in non-palette modes
      0x00FF0000,                       // Mask for Red bits in non-palette modes
      0x0000FF00,                       // Mask for Green bits in non-palette modes
      0x000000FF,                       // Mask for Blue bits in non-palette modes
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, // Mode flags
      0L, 0L
    }
},
{
  18,                                   // Number of entries in the struct
  (P9000_ID | P9100_ID),
  v1600_1200_60,                        // Ptr to the default video parms
  FALSE,
    {                                   // containing the video parms.
      sizeof(VIDEO_MODE_INFORMATION),   // Size of the mode info struct
      m1600_1200_8_60,                  // Index used to set this mode
      1600,                             // X Resolution, in pixels
      1200,                             // Y Resolution, in pixels
      1600,                             // physical scanline byte length
      1,                                // Number of video memory planes
      8,                                // Number of bits per plane
      60,                               // Screen Frequency, in Hertz.
      330,                              // Horizontal size of screen in mm
      240,                              // Vertical size of screen in mm
      8,                                // # of Red bits in non-palette modes
      8,                                // # of Green bits in non-palette modes
      8,                                // # of Blue bits in non-palette modes
      0x00000000,                       // Mask for Red bits in non-palette modes
      0x00000000,                       // Mask for Green bits in non-palette modes
      0x00000000,                       // Mask for Blue bits in non-palette modes
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
      VIDEO_MODE_MANAGED_PALETTE,       // Mode flags
      0L, 0L
    }
},
{
  18,                                   // Number of entries in the struct
  P9100_ID,
  v1600_1200_60,                        // Ptr to the default video parms
  FALSE,
    {                                   // containing the video parms.
      sizeof(VIDEO_MODE_INFORMATION),   // Size of the mode info struct
      m1600_1200_16_60,                 // Index used to set this mode
      1600,                             // X Resolution, in pixels
      1200,                             // Y Resolution, in pixels
      1600 * 2,                         // physical scanline byte length
      1,                                // Number of video memory planes
      16,                               // Number of bits per plane
      60,                               // Screen Frequency, in Hertz.
      330,                              // Horizontal size of screen in mm
      240,                              // Vertical size of screen in mm
      5,                                // # of Red bits in non-palette modes
      5,                                // # of Green bits in non-palette modes
      5,                                // # of Blue bits in non-palette modes
      0x00007C00,                       // Mask for Red bits in non-palette modes
      0x000003E0,                       // Mask for Green bits in non-palette modes
      0x0000001F,                       // Mask for Blue bits in non-palette modes
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
      0L, 0L
    }
}
};

//
// Dummy variables used as destination reads of the P9 VRTC register reads.
// They are used to detect vertical retrace.
//

ULONG   ulStrtScan;
ULONG   ulCurScan;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\mini\p91clock.c ===
/*++

    Copyright (c) 1993, 1994  Weitek Corporation
    
    Module Name:
    
        clock.c
    
    Abstract:
    
        This module contains clock generator specific functions for the
        Weitek P9 miniport device driver.
    
    Environment:
    
        Kernel mode
    
    Revision History may be found at the end of this file.

--*/

#include "p9.h"
#include "p9gbl.h"
#include "clock.h"
#include "vga.h"
#include "ibm525.h"
#include "p91regs.h"


extern UCHAR
ReadIBM525(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    USHORT index
    );

extern VOID
WriteIBM525(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    USHORT index,
    UCHAR value
    );

extern UCHAR
ReadP9ConfigRegister(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    UCHAR regnum
    );

extern VOID
WriteP9ConfigRegister(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    UCHAR regnum,
    UCHAR jValue
    );

extern ULONG
Read9100FreqSel(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );


VOID
Write525PLL(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    USHORT usFreq
    );

VOID
Write9100FreqSel(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG cs
    );


VOID
P91WriteICD(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG data
    );

VOID
P90WriteICD(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG data
    );




VOID
ProgramClockSynth(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    USHORT usFrequency, 
    BOOLEAN bSetMemclk,
    BOOLEAN bUseClockDoubler
    )

/*++

Routine Description:

    Program a custom frequency into a clock synthesizer.  Either MEMCLK
    or Pixel clock, determined by bSetMemclk.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.
    usFrequency = Frequency in Mhz, (this shoud be kept in the registry),
    bSetMemclk == TRUE == MEMCLK.

Return Value:

    None.

--*/

{

    VideoDebugPrint((2, "ProgramClockSynth - Entry\n"));

    switch (HwDeviceExtension->p91State.usClockID)
    {
        case CLK_ID_ICD2061A:

            VideoDebugPrint((2, "ProgramClockSynth: Clock = CLK_ID_ICD2061A\n"));

            if ((HwDeviceExtension->Dac.bRamdacUsePLL) && 
                (HwDeviceExtension->Dac.usRamdacID == DAC_ID_IBM525) && (!bSetMemclk))
            {

                VideoDebugPrint((2, "ProgramClockSynth: DAC_ID_IBM525\n"));
                VideoDebugPrint((2, "ProgramClockSynth: PLL Freq = %d\n", usFrequency));
                                  
                Write525PLL(HwDeviceExtension, usFrequency);

                //
                // Check if there is an override value for the PLL Reference 
                // Divider.  If so, set the reference frequency accordingly...
                //

                if (HwDeviceExtension->VideoData.ul525RefClkCnt != 0xFFFFFFFF)
                {
                    VideoDebugPrint((2, "ProgramClockSynth: 525RefClkCnt = %ld\n",
                                     HwDeviceExtension->VideoData.ul525RefClkCnt * 200L));

                    usFrequency = (USHORT) (HwDeviceExtension->VideoData.ul525RefClkCnt * 200L);
                }
                else
                {
                    //
                    // Set reference frequency to 5000 Mhz...
                    //

                    usFrequency = 5000; 
                }
                    VideoDebugPrint((2, "ProgramClockSynth: 525 Ref Frequency = %d\n", usFrequency));
            }

            DevSetClock(HwDeviceExtension,
                        usFrequency,
                        bSetMemclk,
                        bUseClockDoubler);

            //
            // Select custom frequency
            //

            Write9100FreqSel(HwDeviceExtension, ICD2061_EXTSEL9100);

            break;

        case CLK_ID_FIXED_MEMCLK:

            //
            // People using the IBM RGB525 RAMDAC with a fixed
            // external oscillator will be using the RGB525's internal
            // PLL. So the MEMCLK cannot be changed, and the pixel
            // clock must be programmed through the RAMDAC.
            // NOTE: This code will work even if the RAMDAC's
            // internal PLL is bypassed and an external oscillator
            // is used.
            //
            // NOTE: We don't print out any kind of error message
            // if an attempt is made to program the memory clock
            // frequency.
            //
            // We assume that the reference frequency is 50 MHz.
            //

            VideoDebugPrint((2, "ProgramClockSynth: Clock = CLK_ID_FIXED_MEMCLKC\n"));

            if ((HwDeviceExtension->Dac.usRamdacID == DAC_ID_IBM525) &&
                (!bSetMemclk))
            {
                Write525PLL(HwDeviceExtension, usFrequency);
            }

            if ((HwDeviceExtension->Dac.bRamdacUsePLL) && 
                (HwDeviceExtension->Dac.usRamdacID == DAC_ID_IBM525) &&
                (!bSetMemclk))
            {
                VideoDebugPrint((2, "ERROR: Trying to select a pixclk with RGB525 disabled.\n"));
            }

            break;
    }       

    VideoDebugPrint((2, "ProgramClockSynth - Exit\n"));


} // End of ProgramClockSynth()




VOID
DevSetClock(
        PHW_DEVICE_EXTENSION HwDeviceExtension,
        USHORT usFrequency,
        BOOLEAN bSetMemclk,
        BOOLEAN bUseClockDoubler
        )

/*++

Routine Description:

    Set the frequency synthesizer to the proper state for the current
    video mode.

Arguments:

    usFrequency == frequency.
    bUseClockDoubler == TRUE == use clock doubler if appropriate.

Return Value:

    None.

--*/

{
    USHORT ftab[16]=
    {
        5100,5320,5850,6070,6440,6680,7350,7560,8090,
        8320,9150,10000,12000,12000,12000,12000
    };

    USHORT  ref = 5727;         // reference freq 2*14.31818 *100*2
    int        i = 0;              // index preset field
    int        m = 0;              // power of 2 divisor field
    int        p;                    // multiplier field
    int        q;                    // divisor field
    int        qs;                    // starting q to prevent integer overflow
    int        bestq = 0;            // best q so far
    int        bestp = 0;            // best p so far
    int        bestd = 10000;        // distance to best combination so far
    int        curd;                // current distance
    int        curf;                // current frequency
    int        j;                    // loop counter
    ULONG      data;

    VideoDebugPrint((2, "DevSetClock - Entry\n"));

    if (usFrequency == 0)                    // Prevent 0 from hanging us!
        usFrequency = 3150;


    if ((usFrequency > HwDeviceExtension->Dac.ulMaxClkFreq) &&
        (bUseClockDoubler) &&
        (HwDeviceExtension->Dac.usRamdacID != DAC_ID_IBM525))
    {
        //
        // Enable the DAC clock doubler mode.
        //

        HwDeviceExtension->Dac.DACSetClkDblMode(HwDeviceExtension);
                                // 2x Clock multiplier enabled
        usFrequency /= 2;       // Use 1/2 the freq.
    }
    else
    {
        //
        // Disable the DAC clock doubler mode.
        //

        HwDeviceExtension->Dac.DACClrClkDblMode(HwDeviceExtension);
    }

    while(usFrequency < 5000)            // if they need a small frequency,
    {
        m += 1;                    // the hardware can divide by 2 to-the m
        usFrequency *= 2;                // so try for a higher frequency
    }

    for (j = 0; j < 16; j++)       // find the range that best fits this frequency
    {
        if (usFrequency < ftab[j])        // when you find the frequency
        {
            i = j;                 // remember the table index
            break;                 // and stop looking.
        }
    }

    for (p = 0; p < 128; p++)    // try all possible frequencies!
    {
        //well, start q high to avoid overflow

        qs = div32(mul32((SHORT) ref, (SHORT) (p+3)), 0x7fff);

        for (q = qs; q < 128; q++)
        {                         
            //
            // calculate how good each frequency is
            //

            curf = div32(mul32((SHORT) ref, (SHORT) (p+3)), (SHORT) ((q + 2) << 1));
            curd = usFrequency - curf;

            if (curd < 0)
            {
                curd = -curd;           // always calc a positive distance
            }

            if (curd < bestd)            // if it's best of all so far
               {
                bestd = curd;            // then remember everything about it
                bestp = p;                // but especially the multiplier
                bestq = q;                // and divisor
             }
        }
    }

    data = ((((long) i) << 17) | (((long) bestp) << 10) | (m << 7) | bestq);

    VideoDebugPrint((2, "ProgramClockSynth: usFrequency = %d\n", usFrequency));
    VideoDebugPrint((2, "ProgramClockSynth: data = %lx\n", data));

    if (bSetMemclk)
    {
        data = data | IC_MREG; // Memclk
    }
    else
    {
        data = data | IC_REG2; // Pixclk
    }

    if (IS_DEV_P9100)
    {
        P91WriteICD(HwDeviceExtension, data);
    }
    else
    {
        P90WriteICD(HwDeviceExtension, data);
    }

    VideoDebugPrint((2, "DevSetClock - Exit\n"));

    return;

} // End of DevSetClock()


VOID P91WriteICD(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG data
    )

/*++

Routine Description:

    Program the ICD2061a Frequency Synthesizer.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.
    data - Data to be written.

Return Value:

    None.

--*/

{
    int     i;
    ULONG   savestate;

    //
    // Note: We might have to disable interrupts to preclude the ICD's
    // watchdog timer from expiring resulting in the ICD resetting to the
    // idle state.
    //
    savestate = Read9100FreqSel(HwDeviceExtension);

    //
    // First, send the "Unlock sequence" to the clock chip.
    // Raise the data bit and send 5 unlock bits.
    //
    Write9100FreqSel(HwDeviceExtension, ICD2061_DATA9100);
    for (i = 0; i < 5; i++)                       // send at least 5 unlock bits
    {
        //
        // Hold the data while lowering and raising the clock
        //
        Write9100FreqSel(HwDeviceExtension, ICD2061_DATA9100);
        Write9100FreqSel(HwDeviceExtension, ICD2061_DATA9100 | 
                         ICD2061_CLOCK9100);
    }

    // 
    // Then turn the data clock off and turn the clock on one more time...
    //
    Write9100FreqSel(HwDeviceExtension, 0);
    Write9100FreqSel(HwDeviceExtension, ICD2061_CLOCK9100);

    //
    // Now send the start bit: Leave data off, adn lower the clock.
    //
    Write9100FreqSel(HwDeviceExtension, 0);

    // 
    // Leave data off and raise the clock.
    //
    Write9100FreqSel(HwDeviceExtension, ICD2061_CLOCK9100);

    //
    // Localbus position for hacking bits out
    // Next, send the 24 data bits.
    //
    for (i = 0; i < 24; i++)
    {
        //
        // Leaving the clock high, raise the inverse of the data bit
          //
        Write9100FreqSel(HwDeviceExtension,
                        ((~data << ICD2061_DATASHIFT9100) & 
                          ICD2061_DATA9100) | ICD2061_CLOCK9100);

        //
        // Leaving the inverse data in place, lower the clock.
          //
        Write9100FreqSel(HwDeviceExtension, 
                        (~data << ICD2061_DATASHIFT9100) & ICD2061_DATA9100);

        //
        // Leaving the clock low, rais the data bit.
        //
          Write9100FreqSel(HwDeviceExtension,
                        (data << ICD2061_DATASHIFT9100) & ICD2061_DATA9100);

        //
        // Leaving the data bit in place, raise the clock.
        //
          Write9100FreqSel(HwDeviceExtension,
                        ((data << ICD2061_DATASHIFT9100) & ICD2061_DATA9100)
                        | ICD2061_CLOCK9100);

        data >>= 1;                 // get the next bit of the data
    }

    //
    // Leaving the clock high, raise the data bit.
    //
    Write9100FreqSel(HwDeviceExtension,
                    ICD2061_CLOCK9100 | ICD2061_DATA9100);

    //
    // Leaving the data high, drop the clock low, then high again.
    //
    Write9100FreqSel(HwDeviceExtension, ICD2061_DATA9100);    
    Write9100FreqSel(HwDeviceExtension, 
                     ICD2061_CLOCK9100 | ICD2061_DATA9100);
    
    //
    // Note: if interrupts were disabled, enable them here.
    // before restoring the
    // original value or the ICD
    // will freak out.
    Write9100FreqSel(HwDeviceExtension, savestate);  // restore orig register value

    return;

} // End of WriteICD()


VOID
P90WriteICD(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG data
    )

/*++

Routine Description:

    Program the ICD2061a Frequency Synthesizer for the Power 9000.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.
    data - Data to be written.

Return Value:

    None.

--*/

{
    int     i;
    int     oldstate, savestate;

    savestate = RD_ICD();
    oldstate = savestate & ~(MISCD | MISCC);

    // First, send the "Unlock sequence" to the clock chip.

    WR_ICD(oldstate | MISCD);       // raise the data bit

    for (i = 0;i < 5;i++)                       // send at least 5 unlock bits
    {
        WR_ICD(oldstate | MISCD);  // hold the data on while
        WR_ICD(oldstate | MISCD | MISCC);   // lowering and raising the clock
    }

    WR_ICD(oldstate);   // then turn the data and clock off
    WR_ICD(oldstate | MISCC);   // and turn the clock on one more time.

    // now send the start bit:
    WR_ICD(oldstate);   // leave data off, and lower the clock
    WR_ICD(oldstate | MISCC);   // leave data off, and raise the clock

    // localbus position for hacking bits out
    // Next, send the 24 data bits.
    for (i = 0; i < 24; i++)
    {
        // leaving the clock high, raise the inverse of the data bit

        WR_ICD(oldstate | ((~(((short) data) << 3)) & MISCD) | MISCC);

        // leaving the inverse data in place, lower the clock

        WR_ICD(oldstate | (~(((short) data) << 3)) & MISCD);

        // leaving the clock low, rais the data bit

        WR_ICD(oldstate | (((short) data) << 3) & MISCD);

        // leaving the data bit in place, raise the clock

        WR_ICD(oldstate | ((((short)data) << 3) & MISCD) | MISCC);

        data >>= 1;                 // get the next bit of the data
    }

    // leaving the clock high, raise the data bit
    WR_ICD(oldstate | MISCD | MISCC);

    // leaving the data high, drop the clock low, then high again
    WR_ICD(oldstate | MISCD);
    WR_ICD(oldstate | MISCD | MISCC);
    WR_ICD(oldstate | MISCD | MISCC);   // Seem to need a delay

    // before restoring the
    // original value or the ICD
    // will freak out.

    WR_ICD(savestate);  // restore original register value

    return;

} // End of P90WriteICD()


VOID
Write9100FreqSel(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG cs
    )
     
/*++

Routine Description:

    Write to the P9100 clock select register preserving the video coprocessor
    enable bit.

    Statically:
         Bits [1:0] go to frequency select
    Dynamically:
         Bit 1: data
         Bit 0: clock

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.
    Clock select value to write.

Return Value:

    None.

--*/

{
    //
    // Set the frequency select bits in the P9100 configuration
    //

   WriteP9ConfigRegister(HwDeviceExtension,
                         P91_CONFIG_CKSEL, 
                         (UCHAR) ((cs << 2) |
                         HwDeviceExtension->p91State.bVideoPowerEnabled));
   return;

} // End of Write9100FreqSel()

ULONG
Read9100FreqSel(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )
     
/*++

Routine Description:

    Read from the P9100 clock select register.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    None.

--*/

{
    //
    // Since the frequency select bits are in the P9100 configuration
    // space, you have to treat VL and PCI differently.
    //
   return((ULONG)(ReadP9ConfigRegister(HwDeviceExtension, P91_CONFIG_CKSEL)
          >> 2) & 0x03);

} // End of Read9100FreqSel()

VOID
Write525PLL(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    USHORT usFreq
    )

/*++

Routine Description:

    This function programs the IBM RGB525 Ramdac to generate and use the
    specified frequency as its pixel clock frequency.

Arguments:

    Frequency.

Return Value:

    None.

--*/

{
    USHORT    usDesiredFreq;
    USHORT    usOutputFreq;
    USHORT    usRoundedFreq;
    USHORT    usVCODivCount;
    ULONG        ulValue;

    VideoDebugPrint((2, "Write525PLL------\n"));

    usOutputFreq = usFreq;

    //
    // Calculate the DF and VCO Divide count for the specified output
    // frequency. The calculations are based on the following table:
    //
    //     DF | VCO Divide Count  | Frequency Range     | Step (MHz)
    //    ----+-------------------+---------------------+------------
    //     00 |   (4 x VF) - 65   |  16.25 -  32.00 MHz |    0.25
    //     01 |   (2 x VF) - 65   |  32.50 -  64.00 MHz |    0.50
    //     10 |        VF  - 65   |  65.00 - 128.00 MHz |    1.00
    //     11 |   (VF / 2) - 65   | 130.00 - 250.00 MHz |    2.00
    //    -----------------------------------------------------------
    //     VF = Desired Video Frequency
    //    -----------------------------------------------------------
    //
    if ((usOutputFreq >= IBM525_DF0_LOW) &&
        (usOutputFreq <= IBM525_DF0_HIGH))
    {
        //
        // The requested frequency is in the DF0 frequency range.
        //

        usDesiredFreq = IBM525_FREQ_DF_0;
  
        //
        // Round the requested frequency to the nearest frequency step
        // boundry.
        //

        usRoundedFreq = (usOutputFreq / IBM525_DF0_STEP) * IBM525_DF0_STEP;
        if ((usOutputFreq - usRoundedFreq) >= (IBM525_DF0_STEP / 2))
        {
            //
            // Round up.
            //
            usRoundedFreq += IBM525_DF0_STEP;
        }
  
        //
        // Calculate the VCO Divide Count register value for the requested
        // frequency.
        //

        usVCODivCount = ((usRoundedFreq * 4) - 6500) / 100;
     }
     else if ((usOutputFreq >= IBM525_DF1_LOW) &&
              (usOutputFreq <= IBM525_DF1_HIGH))
     {
        //
        // The requested frequency is in the DF1 frequency range.
        //

        usDesiredFreq = IBM525_FREQ_DF_1;
  
        //
        // Round the requested frequency to the nearest frequency step
        // boundry.
        //

        usRoundedFreq = (usOutputFreq / IBM525_DF1_STEP) * IBM525_DF1_STEP;
        if ((usOutputFreq - usRoundedFreq) >= (IBM525_DF1_STEP / 2))
        {
           //
           // Round up.
           //
           usRoundedFreq += IBM525_DF1_STEP;
        }
  
        //
        // Calculate the VCO Divide Count register value for the requested
        // frequency.
        //

        usVCODivCount = ((usRoundedFreq * 2) - 6500) / 100;
     }
     else if ((usOutputFreq >= IBM525_DF2_LOW) &&
              (usOutputFreq <= IBM525_DF2_HIGH))
     {
        //
        // The requested frequency is in the DF2 frequency range.
        //

        usDesiredFreq = IBM525_FREQ_DF_2;
    
        //
        // Round the requested frequency to the nearest frequency step
        // boundry.
        //

        usRoundedFreq = (usOutputFreq / IBM525_DF2_STEP) * IBM525_DF2_STEP;
        if ((usOutputFreq - usRoundedFreq) >= (IBM525_DF2_STEP / 2))
        {
           //
           // Round up.
           //
           usRoundedFreq += IBM525_DF2_STEP;
        }
   
        //
        // Calculate the VCO Divide Count register value for the requested
        // frequency.
        //

        usVCODivCount = (usRoundedFreq - 6500) / 100;
    }
    else if ((usOutputFreq >= IBM525_DF3_LOW) &&
             (usOutputFreq <= IBM525_DF3_HIGH))
    {
        //
        // The requested frequency is in the DF3 frequency range.
        //

        usDesiredFreq = IBM525_FREQ_DF_3;
   
        //
        // Round the requested frequency to the nearest frequency step
        // boundry.
        //

        usRoundedFreq = (usOutputFreq / IBM525_DF3_STEP) * IBM525_DF3_STEP;
        if ((usOutputFreq - usRoundedFreq) >= (IBM525_DF3_STEP / 2))
        {
           //
           // Round up.
           //
           usRoundedFreq += IBM525_DF3_STEP;
        }
   
        //
        // Calculate the VCO Divide Count register value for the requested
        // frequency.
        //

        usVCODivCount = ((usRoundedFreq / 2) - 6500) / 100;
    }
    else
    {
        //
        // The requested frequency is not supported...
        //

        VideoDebugPrint((2, "Write525PLL: Freq %d is not supported!\n", usFreq));
    }
 
    VideoDebugPrint((2, "Write525PLL: usRoundedFreq = %d\n", usRoundedFreq));
    VideoDebugPrint((2, "Write525PLL: usVCODivCount = %d\n", usVCODivCount));
 
    //
    // Setup for writing to the PLL Reference Divider register.
    //
 
    //
    // Check if there is an override value for the PLL Reference Divider.
    //
    if (HwDeviceExtension->VideoData.ul525RefClkCnt != 0xFFFFFFFF)
    {
        //
        // Program REFCLK to the specified override...
        //
        WriteIBM525(HwDeviceExtension,
                    RGB525_FIXED_PLL_REF_DIV,
                    (UCHAR) HwDeviceExtension->VideoData.ul525RefClkCnt);
 
        VideoDebugPrint((2, "ProgramClockSynth: 525RefClkCnt = %lx\n",
                             HwDeviceExtension->VideoData.ul525RefClkCnt));
    }
    else
    {
        //
        // Program REFCLK to a fixed 50MHz.
        //
        WriteIBM525(HwDeviceExtension, RGB525_FIXED_PLL_REF_DIV,
                                      IBM525_PLLD_50MHZ);
    }

    //
    // Set up for programming frequency register 9.
    //
 
    //
    // Check if there is an override value for the VCO Divide Count Register.
    //

    if (HwDeviceExtension->VideoData.ul525VidClkFreq != 0xFFFFFFFF)
    {
       //
       // Program the VCO Divide count register to the specified override...
       //

       WriteIBM525(HwDeviceExtension,
                   RGB525_F9,    
                   (UCHAR) HwDeviceExtension->VideoData.ul525VidClkFreq);
    }
    else
    {
       //
       // No override value, so use the calculated value.
       //

       WriteIBM525(HwDeviceExtension,
                   RGB525_F9,    
                   (UCHAR) (usDesiredFreq | usVCODivCount));
    }

    //
    // Program PLL Control Register 2.
    //

    WriteIBM525(HwDeviceExtension, RGB525_PLL_CTL2,    IBM525_PLL2_F9_REG);
 
    //
    // Program PLL Control Register 1.
    //

    WriteIBM525(HwDeviceExtension, RGB525_PLL_CTL1,    
                                   (IBM525_PLL1_REFCLK_INPUT |
                                   IBM525_PLL1_INT_FS) );
 
    //
    // Program DAC Operation Register.
    //

    WriteIBM525(HwDeviceExtension, RGB525_DAC_OPER,    IBM525_DO_DSR_FAST);
 
    //
    // Program Miscellaneous Control Register 1.
    //

    WriteIBM525(HwDeviceExtension, RGB525_MISC_CTL1, IBM525_MC1_VRAM_64_BITS);
 
    //
    // Program Miscellaneous Clock Control Register.  
    //

    ulValue = ReadIBM525(HwDeviceExtension, RGB525_MISC_CLOCK_CTL);
 
    //
    // Now decide how to divide the PLL clock output.
    //
    if (!HwDeviceExtension->Dac.bRamdacDivides)
    {
       if (HwDeviceExtension->usBitsPixel == 24)
       {
          //
          // 24 Bpp = 3 Byte Per Pixel
          //
          // At 24 Bpp, divide the clock by 8.
          //
          ulValue |= IBM525_MCC_PLL_DIV_8  | IBM525_MCC_PLL_ENABLE;
       }
       else
       {
          //
          // Don't divide the clock when the P9100 is doing the dividing.
          //
          ulValue |= IBM525_MCC_PLL_DIV_1  | IBM525_MCC_PLL_ENABLE;
       }
    }
    else
    {
        switch (HwDeviceExtension->usBitsPixel)
        {
            //
            // 8 Bpp = 1 Byte Per Pixel
            //

            case 8:
            {
               //
               // At 8 Bpp, divide the clock by 8.
               //
               ulValue |= IBM525_MCC_PLL_DIV_8  | IBM525_MCC_PLL_ENABLE;
               break;
            }
    
            //
            // 16 Bpp = 2 Byte Per Pixel
            //

            case 15:
            case 16:
            {
               //
               // At 16 Bpp, divide the clock by 4.
               //
               ulValue |= IBM525_MCC_PLL_DIV_4  | IBM525_MCC_PLL_ENABLE;
               break;
            }
    
            //
            // 24 Bpp = 3 Byte Per Pixel
            //

            case 24:
            {
               //
               // At 24 Bpp, divide the clock by 8.
               //
               ulValue |= IBM525_MCC_PLL_DIV_8  | IBM525_MCC_PLL_ENABLE;
               break;
            }
    
            //
            // 32 Bpp = 4 Byte Per Pixel
            //

            case 32:
            {
               //
               // At 32 Bpp, divide the clock by 2.
               //
               ulValue |= IBM525_MCC_PLL_DIV_2  | IBM525_MCC_PLL_ENABLE;
               break;
            }
        }
    }
  
    WriteIBM525(HwDeviceExtension,
                RGB525_MISC_CLOCK_CTL,
                (UCHAR) ulValue);
  
    return;

} // End of Write525PLL()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\mini\p9100.c ===
/*++

Copyright (c) 1993, 1994  Weitek Corporation

Module Name:

    p9100.c

Abstract:

    This module contains the code specific to the Weitek P9100.

Environment:

    Kernel mode

Revision History may be found at the end of this file.

--*/

#include "p9.h"
#include "p9gbl.h"
#include "p91regs.h"
#include "vga.h"
#include "wtkp9xvl.h"



VOID
InitP9100(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    Initialize the P9100.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    None.

--*/
{
    VideoDebugPrint((2, "InitP9100------\n"));

    P9_WR_REG(P91_INTERRUPT_EN, 0x00000080L); //INTERRUPT-EN = disabled
    P9_WR_REG(P91_PREHRZC,      0x00000000L); //PREHRZC = 0
    P9_WR_REG(P91_PREVRTC,      0x00000000L); //PREVRTC = 0

    //
    // Initialize the P9100 registers.
    //
    P9_WR_REG(P91_RFPERIOD,     0x00000186L); //RFPERIOD =
    P9_WR_REG(P91_RLMAX,        0x000000FAL); //RLMAX =
    P9_WR_REG(P91_DE_PMASK,     0xFFFFFFFFL); //allow writing in all 8 planes
    P9_WR_REG(P91_DE_DRAW_MODE, P91_WR_INSIDE_WINDOW | P91_DE_DRAW_BUFF_0);
    P9_WR_REG(P91_PE_W_OFF_XY,  0x00000000L); //disable any co-ord offset

    return;
}


VOID
P91_WriteTiming(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

     Initializes the P9100 Crtc timing registers.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    None.

--*/

{
    int num, den, bpp;
    ULONG ulValueRead, ulValueWritten;
    ULONG ulHRZSR;
    ULONG ulHRZBR;
    ULONG ulHRZBF;
    ULONG ulHRZT;

    VideoDebugPrint((2, "P91_WriteTiming - Entry\n"));

    bpp = HwDeviceExtension->usBitsPixel / 8; // Need bytes per pixel

    //
    // 24-bit color
    //

    if (bpp == 3)
    {
        num = 3;
        den = HwDeviceExtension->Dac.usRamdacWidth/8;
    }
    else
    {
        num = 1;
        den = HwDeviceExtension->Dac.usRamdacWidth/(bpp * 8);
    }


//
// Calculate HRZSR.
//
    ulHRZSR = (ULONG) (HwDeviceExtension->VideoData.hsyncp /
                                            (ULONG) den) * (ULONG) num;

    ulHRZSR -= HwDeviceExtension->p91State.ulBlnkDlyAdj;

//
// Calculate HRZBR.
//
    ulHRZBR = (ULONG) ((HwDeviceExtension->VideoData.hsyncp +
                      HwDeviceExtension->VideoData.hbp) / (ULONG) den) *
                      (ULONG) num;

    ulHRZBR -= HwDeviceExtension->p91State.ulBlnkDlyAdj;

//    ulHRZBR -= 4;

    ulHRZBF = (ULONG) ( (HwDeviceExtension->VideoData.hsyncp+
                               HwDeviceExtension->VideoData.hbp+
                               HwDeviceExtension->VideoData.XSize) / (ULONG) den) * (ULONG) num;

//
// Calculate HRZBF.
//
    ulHRZBF -= HwDeviceExtension->p91State.ulBlnkDlyAdj;

//    ulHRZBF -= 4;

    ulHRZT = (ULONG) ( (HwDeviceExtension->VideoData.hsyncp+
                               HwDeviceExtension->VideoData.hbp+
                               HwDeviceExtension->VideoData.XSize+
                               HwDeviceExtension->VideoData.hfp) /
                                            (ULONG) den) * (ULONG) num;
    --ulHRZT;

//
//      Changes requested by Rober Embry, Jan 26 Spec.
//

   if (HwDeviceExtension->Dac.ulDacId == DAC_ID_BT489)
   {
      //
      // Fix for fussy screen problem, Per Sam Jenson
      //
      ulHRZT = 2 * (ulHRZT>>1) + 1;
   }

   if ((HwDeviceExtension->Dac.ulDacId  == DAC_ID_BT489)  ||
       (HwDeviceExtension->Dac.ulDacId  == DAC_ID_BT485))
   {
      if (bpp == 1)
      {
         ulHRZBR -= 12 * num / den;
         ulHRZBF -= 12 * num / den;
      }
      else
      {
         ulHRZBR -= 9 * num / den;
         ulHRZBF -= 9 * num / den;
      }
   }

//
// By robert embry  12/1/94
//
// The hardware configuration (Power 9100 version and DAC type) affects
// the minimum horizontal back porch timing that a board can support.
// The most flexible (able to support the smallest back porch)
// configuration is with Power 9100 A4 with the IBM or ATT DAC.
//
// The Power 9100 A2 increases the front porch minimum by one.
// The Brooktree DAC increases the front porch minimum by one, also.
//
// Configuration                       Min. Back Porch
// -----------------                   ---------------
// P9100 A4, IBM/ATT DAC               40 pixels (5 CRTC clocks)
// P9100 A2, IBM/ATT DAC               48 pixels (6 CRTC clocks)
// P9100 A4, BT485/9 DAC               48 pixels (6 CRTC clocks)
// P9100 A2, BT485/9 DAC               56 pixels (7 CRTC clocks)
//
// Since we want one P9x00RES.DAT file AND we don't want to penalize the
// most common configuration, the driver needs to choose the best fit
// when the P9x00RES.DAT file specifies a set of parameters that are not
// supported.
//
// Algorithm for BEST FIT:
//
// First, time must be taken from something else.  Either by shortening
// the pulse width or the front porch (shifts line to right.)  The
// largest value of the two is decreased, sync pulse if equal.
//
// A given P9x00RES.DAT file will result in valid register values
// in one hardware configuration, but not in another.  This code
// adjusts these register values so the P9x00RES.DAT file parameters
// work for all boards, but not necesarily giving the requested timing.
// The P9100 A4 silicon with an IBM or ATT DAC is the best case.
// When the P9100 A2 or a Brooktree DAC is present then the
// minimum supportable horizontal back porch is enlarged.
//
// psuedo BASIC code:
//
// This is parameter checking code for the Power 9100's hrzSR and hrzBR
// registers.  The following equation must be satisfied: hrzSR < hrzBR.
//
// If this equation is violated in the presence of the Power 9100 A2
// silicon or a non-pipelined DAC (BT485/9) then these register values
// are modified.
//
// This code should go just before the registers are written.
// The register values may need to be modified by up to 2 counts.
//
// IF (DacType=BT485 OR DacType=BT485A OR DacType=BT489 OR _
//     SiliconVerion=A2) THEN {
//     WHILE hrzSR >= hrzBR {
//       IF hsp>hfp THEN DECR hrzSR  _           ;shrink sync pulse width
//                  ELSE INCR hrzBR :INCR hrzBF   ;shorten front porch
//                          } }
//
    if ((HwDeviceExtension->Dac.ulDacId == DAC_ID_BT489)        ||
       (HwDeviceExtension->Dac.ulDacId  == DAC_ID_BT485)        ||
       (HwDeviceExtension->p91State.usRevisionID < WTK_9100_REV3))
    {
       while (ulHRZSR >= ulHRZBR)
       {
          if (HwDeviceExtension->VideoData.hsyncp >
              HwDeviceExtension->VideoData.hfp)
          {
             ulHRZSR--;
          }
          else
          {
             ulHRZBR++;
             ulHRZBF++;
          }
       }
    }

    //
    // Write to the video timing registers
    //

    do
    {
        P9_WR_REG(P91_HRZSR, ulHRZSR);
        ulValueRead = (ULONG) P9_RD_REG(P91_HRZSR);
    } while (ulValueRead != ulHRZSR);

    do
    {
        P9_WR_REG(P91_HRZBR, ulHRZBR);
        ulValueRead = (ULONG) P9_RD_REG(P91_HRZBR);
    } while (ulValueRead != ulHRZBR);

    do
    {
        P9_WR_REG(P91_HRZBF, ulHRZBF);
        ulValueRead = (ULONG) P9_RD_REG(P91_HRZBF);
    } while (ulValueRead != ulHRZBF);

    do
    {
        P9_WR_REG(P91_HRZT, ulHRZT);
        ulValueRead = (ULONG) P9_RD_REG(P91_HRZT);
    } while (ulValueRead != ulHRZT);

    ulValueWritten = (ULONG)  HwDeviceExtension->VideoData.vsp;

    do
    {
        P9_WR_REG(P91_VRTSR, ulValueWritten);
        ulValueRead = (ULONG) P9_RD_REG(P91_VRTSR);
    } while (ulValueRead != ulValueWritten);

    ulValueWritten = (ULONG) HwDeviceExtension->VideoData.vsp+
                        HwDeviceExtension->VideoData.vbp;
    do
    {
        P9_WR_REG(P91_VRTBR, ulValueWritten);
        ulValueRead = (ULONG) P9_RD_REG(P91_VRTBR);
    } while (ulValueRead != ulValueWritten);

    ulValueWritten = (ULONG) HwDeviceExtension->VideoData.vsp+
                        HwDeviceExtension->VideoData.vbp+
                        HwDeviceExtension->VideoData.YSize;
    do
    {
        P9_WR_REG(P91_VRTBF, ulValueWritten);
        ulValueRead = (ULONG) P9_RD_REG(P91_VRTBF);
    } while (ulValueRead != ulValueWritten);

    ulValueWritten =  (ULONG) HwDeviceExtension->VideoData.vsp+
                        HwDeviceExtension->VideoData.vbp+
                        HwDeviceExtension->VideoData.YSize+
                        HwDeviceExtension->VideoData.vfp;
    do
    {
        P9_WR_REG(P91_VRTT, ulValueWritten);
        ulValueRead = (ULONG) P9_RD_REG(P91_VRTT);
    } while (ulValueRead != ulValueWritten);

    VideoDebugPrint((2, "P91_WriteTiming - Exit\n"));

    return;

} // End of P91_WriteTimings()




VOID
P91_SysConf(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

   Syscon converts the ->XSize value into the correct bits in
   the System Configuration Register and writes the register
   (This register contains the XSize of the display.)

   Half-word and byte swapping are set via bits: 12 & 13;
   The shift control fields are set to the size of the scanline in bytes;
   And pixel size is set to bits per pixel.

   XSize and ulFrameBufferSize must be set prior to entering this routine.
   This routine also initializes the clipping registers.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    None.

--*/

{
    int i, j, iBytesPerPixel; // loop counters
    long  sysval;         // swap bytes and words for little endian PC
    int  xtem = (int) HwDeviceExtension->VideoData.XSize;
    long  ClipMax;        // clipping register value for NotBusy to restore

     iBytesPerPixel =  (int) HwDeviceExtension->usBitsPixel / 8; // Calc Bytes/pixel
     xtem *= iBytesPerPixel;

   VideoDebugPrint((2, "P91_SysConf------\n"));

    //
    // The following sets up the System Configuration Register
    // for BPP with byte and half-word swapping.  This swapping
    // is usually what is needed since the frame-buffer is stored
    // in big endian pixel format and the 80x86 software usually
    // expects little endian pixel format.
    //
    if (iBytesPerPixel == 1)
        sysval = SYSCFG_BPP_8;
    else if (iBytesPerPixel == 2)
        sysval = SYSCFG_BPP_16;
    else if (iBytesPerPixel == 3)
        sysval = SYSCFG_BPP_24;
    else // if (iBytesPerPixel == 4)
        sysval = SYSCFG_BPP_32;

    //
    // Now set the Shift3, Shift0, Shift1 & Shift2 multipliers.
    //
    // Each field in the sysconfig can only set a limited
    // range of bits in the size.
    //

    if (xtem & 0x1c00) // 7168
    {
        //
        // Look at all the bits for shift control 3
        //
        j=3;
        for (i=4096;i>=1024;i>>=1)
        {
            //
            // If this bit is on...
            //
            if (i & xtem)
            {
                //
                // Use this field to set it and
                // remove the bit from the size. Each
                // field can only set one bit.
                //
                sysval |= ((long)j)<<29;
                xtem &= ~i;
                break;
            }
            j=j-1;
        }
    }

    if (xtem & 0xf80)   // each field in the sysconreg can only set
    {                   // a limited range of bits in the size
        j = 7;          // each field is 3 bits wide
        //
        // Look at all the bits for shift control 0
        //
        for (i = 2048; i >= 128;i >>= 1)        // look at all the bits field 3 can effect
        {
                if (i & xtem)                   // if this bit is on,
                {
                    sysval |= ((long) j) << 20; // use this field to set it
                    xtem &= ~i;                 // and remove the bit from the size
                    break;                      // each field can only set one bit
                }
                j -=  1;
        }
    }

    if (xtem & 0x7C0)                      // do the same thing for field 2
    {
        //
        // Do the same thing for shift control 1
        //
        j = 6;                            // each field is 3 bits wide
        for (i = 1024; i >= 64; i >>= 1)  // look at all the bits field 2 can effect
        {
                if (i & xtem)             // if this bit is on,
                {
                    sysval |= ((long)j)<<17; // use this field to set it
                    xtem &= ~i;              // and remove the bit from the size
                    break;                   // each field can only set one bit
                }
                j -= 1;
        }
    }

    if (xtem & 0x3E0)                        // do the same thing for field 1
    {
        j = 5;                               // each field is 3 bits wide
        //
        // do the same thing for shift control 2
        //
        for (i = 512; i >= 32;i >>= 1)      // look at all the bits field 1 can effect
        {
                if (i & xtem)               // if this bit is on,
                {
                    sysval |= ((long) j) << 14; // use this field to set it
                    xtem &= ~i;                // and remove the bit from the size
                    break;                     // each field can only set one bit
                }
                j -= 1;
        }
    }

    //
    // If there are bits left, it is an illegal x size. This just means
    // that we cannot handle it because we have not implemented a
    // full multiplier. However, the vast majority of screen sizes can be
    // expressed as a sum of few powers of two.
    //
    if (xtem != 0)                     // if there are bits left, it is an
        return;                        // illegal x size.

   VideoDebugPrint((2, "P91_SysConf:sysval = 0x%lx\n", sysval));

   P9_WR_REG(P91_SYSCONFIG, sysval);   // send data to the register

   xtem = (int) (HwDeviceExtension->VideoData.XSize * (ULONG) iBytesPerPixel);
   //
   // Now calculate and set the max clipping to allow access to all of
   // the extra memory.
   //
   // There are two sets of clipping registers.  The first takes the
   // horizontal diemnsion in pixels and the vertical dimension in
   // scanlines.
   //
   ClipMax=((long) HwDeviceExtension->VideoData.XSize - 1L) << 16 |
   (div32(HwDeviceExtension->FrameLength, (USHORT) xtem) - 1L);

   P9_WR_REG(P91_DE_P_W_MIN, 0L);
   P9_WR_REG(P91_DE_P_W_MAX, ClipMax);

   //
   // The second set takes the horizontal dimension in bytes and the
   // vertical dimension in scanlines.
   //
   ClipMax=((long) xtem -1L) << 16 |
   (div32(HwDeviceExtension->FrameLength, (USHORT) xtem) - 1L);   // calc and set max

   P9_WR_REG(P91_DE_B_W_MIN, 0L);
   P9_WR_REG(P91_DE_B_W_MAX, ClipMax);

   return;

} // End of P91_SysConf()

#define RESTORE_DAC     1
//#define SAVE_INDEX_REGS     1
 /***************************************************************************\
 *                                                                           *
 * Save & Restore VGA registers routines                                     *
 *                                                                           *
 * this is to avoid "blind" boot end                                         *
 *                                                                           *
 \***************************************************************************/

void P91SaveVGARegs(PHW_DEVICE_EXTENSION HwDeviceExtension,VGA_REGS * SaveVGARegisters)
{
UCHAR ucIndex ;
ULONG ulIndex ;
UCHAR   temp;

#ifdef SAVE_INDEX_REGS
// Save index registers.

temp = VGA_RD_REG(0x004);
VideoDebugPrint((1, "Save, 3c4:%x\n", temp));

temp = VGA_RD_REG(0x00e);
VideoDebugPrint((1, "Save, 3ce:%x\n", temp));

temp = VGA_RD_REG(0x014);
VideoDebugPrint((1, "Save, 3d4:%x\n", temp));
#endif


/* Miscellaneous Output Register: [3C2]w, [3CC]r */
SaveVGARegisters->MiscOut = VGA_RD_REG(0x00C) ;

/* CRT Controller Registers 0-18: index [3D4], data [3D5] */
for (ucIndex = 0 ; ucIndex < 0x18 ; ucIndex ++)
        {
          VGA_WR_REG(0x014 ,ucIndex) ;
          SaveVGARegisters->CR[ucIndex] = VGA_RD_REG(0x015) ;
        }

/* Sequencer Registers 1-4: index [3C4], data [3C5] */
for (ucIndex = 1 ; ucIndex < 4 ; ucIndex ++)
        {
          VGA_WR_REG(0x004 ,ucIndex) ;
          SaveVGARegisters->SR[ucIndex] = VGA_RD_REG(0x005) ;
        }

/* Graphics Controller Registers 0-8: index [3CE], data [3CF] */
for (ucIndex = 0 ; ucIndex < 8 ; ucIndex ++)
          {
          VGA_WR_REG(0x00E ,ucIndex) ;
          SaveVGARegisters->GR[ucIndex] = VGA_RD_REG(0x00F) ;
          }

/* Attribute Controller Registers 0-14: index and data [3C0]w, [3C1]r */
VGA_RD_REG(0x01A) ; /* set toggle to index mode */
for (ucIndex = 0 ; ucIndex < 0x14 ; ucIndex ++)
        {
          VGA_WR_REG(0x000 ,ucIndex) ; /* write index */
          SaveVGARegisters->AR[ucIndex] = VGA_RD_REG(0x001) ; /* read data */
          VGA_WR_REG(0x000 ,SaveVGARegisters->AR[ucIndex]) ; /* toggle */
        }

#ifdef RESTORE_DAC
//Look-Up Table: Read Index [3C7]w, Write Index [3C8], Data [3C9]
VGA_WR_REG(0x007 ,0) ; //set read index to 0
for (ulIndex = 0 ; ulIndex < (3 * 256) ; ulIndex ++)
         {
         SaveVGARegisters->LUT[ulIndex] = VGA_RD_REG(0x009) ;
         }
#endif //RESTORE_DAC
}


void P91RestoreVGAregs(PHW_DEVICE_EXTENSION HwDeviceExtension,VGA_REGS  * SaveVGARegisters)
{
UCHAR ucIndex ;
ULONG ulIndex ;
UCHAR   temp;

WriteP9ConfigRegister(HwDeviceExtension,P91_CONFIG_MODE,0x2);
/* Put the VGA back in color mode for our PROM */
VGA_WR_REG(MISCOUT ,1) ;

/* Enable VGA Registers: [3C3] = 1 */
VGA_WR_REG(0x003 ,1) ;

/* Miscellaneous Output Register: [3C2]w, [3CC]r */
VGA_WR_REG(0x002 ,SaveVGARegisters->MiscOut) ;

/* Enable CR0-CR7: CR11[7] = 0 */
VGA_WR_REG(0x014 ,0x11) ;
VGA_WR_REG(0x015 ,SaveVGARegisters->CR[0x11] & 0x7F) ;

/* CRT Controller Registers 0-18: index [3D4], data [3D5] */
for (ucIndex = 0 ; ucIndex < 0x18 ; ucIndex ++)
                  {
                    VGA_WR_REG(0x014 ,ucIndex) ;
                    VGA_WR_REG(0x015 ,SaveVGARegisters->CR[ucIndex]) ;
                  }

/* Synchronous Reset: SR0 = 1 */
VGA_WR_REG(0x004 ,0) ;
VGA_WR_REG(0x005 ,1) ;

/* ClockMode: SR1 */
VGA_WR_REG(0x004 ,1) ;
VGA_WR_REG(0x005 ,SaveVGARegisters->SR[1]) ;

/* Non Reset Mode: SR0 = 0 */
VGA_WR_REG(0x004 ,0) ;
VGA_WR_REG(0x005 ,0) ;

/* Sequencer Registers 2-4: index [3C4], data [3C5] */
for (ucIndex = 2 ; ucIndex < 4 ; ucIndex ++)
                  {
                    VGA_WR_REG(0x004 ,ucIndex) ;
                    VGA_WR_REG(0x005 ,SaveVGARegisters->SR[ucIndex]) ;
                  }

/* Graphics Controller Regs 0-8: index [3CE], data [3CF] */
VGA_WR_REG(0x00E ,1) ;
VGA_WR_REG(0x00F ,0x0F) ; /* enable all 4 planes for GR0 */
for (ucIndex = 0 ; ucIndex < 8 ; ucIndex ++)
                  {
                    VGA_WR_REG(0x00E ,ucIndex) ;
                    VGA_WR_REG(0x00F ,SaveVGARegisters->GR[ucIndex]) ;
                  }

/* Attrib Controller Regs 0-14:index and data [3C0]w,[3C1]r */
VGA_RD_REG(0x01A) ; /* set toggle to index mode */
for (ucIndex = 0 ; ucIndex < 0x14 ; ucIndex ++)
                  {
                    VGA_WR_REG(0x000 ,ucIndex) ; /* write index */
                    VGA_WR_REG(0x000 ,SaveVGARegisters->AR[ucIndex]) ;
                                                 /* write data */
                  }
VGA_WR_REG(0x000 ,0x20) ; /* set index[5] to 1 */

#ifdef SAVE_INDEX_REGS
// Restore index registers.

VGA_WR_REG(0x004, 0x002);
temp = VGA_RD_REG(0x004);
VideoDebugPrint((1, "Restore: 3c4:%x\n", temp));

VGA_WR_REG(0x00e, 0x005);
temp = VGA_RD_REG(0x00e);
VideoDebugPrint((1, "Restore: 3ce:%x\n", temp));

VGA_WR_REG(0x014, 0x0011);
temp = VGA_RD_REG(0x014);
VideoDebugPrint((1, "Restore: 3d4:%x\n", temp));
#endif

#ifdef RESTORE_DAC

 //Look-Up Table:
 //Read Index [3C7]w, Write Index [3C8], Data [3C9]
 VGA_WR_REG(0x008 ,0) ; // set write index to 0
 for (ulIndex = 0 ; ulIndex < (3 * 256) ; ulIndex ++)
                  {
                    VGA_WR_REG(0x009 ,SaveVGARegisters->LUT[ulIndex]) ;
                  }
#endif //RESTORE_DAC
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\mini\p91bt489.c ===
/*++

Copyright (c) 1993, 1994  Weitek Corporation

Module Name:

    p91bt489.c

Abstract:

    This module contains code specific to the Bt489 DAC on P9x0x adapters.

Environment:

    Kernel mode

Revision History may be found at the end of this file.

--*/

#include "p9.h"
#include "p9gbl.h"
#include "p9000.h"
#include "bt485.h"
#include "p91regs.h"
#include "p91dac.h"


#define PIX_PORT_15 0x30

//
// external functions in p91bt485.c
//

extern UCHAR
ReadDAC(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG ulIndex
    );

extern VOID
WriteDAC(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG ulIndex,
    UCHAR ucValue
    );

//
// Bt489 DAC specific functions.
//

VOID
P91Bt489SetPalette(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG *pPal,
    ULONG StartIndex,
    ULONG Count
    );

VOID
P91Bt489SetPointerPos(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG   ptlX,
    ULONG   ptlY
    );

VOID
P91Bt489SetPointerShape(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUCHAR  pHWCursorShape
    );

VOID
P91Bt489PointerOn(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
P91Bt489PointerOff(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
P91Bt489ClearPalette(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

BOOLEAN
P91Bt489SetMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
P91Bt489RestoreMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
P91Bt489SetClkDoubler(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
P91Bt489ClrClkDoubler(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

//
// Define the DAC support routines structure for the Bt489 DAC.
//

DAC P91Bt489 = {
    DAC_ID_BT489,
    NUM_DAC_REGS,
    P91Bt489SetMode,
    P91Bt489RestoreMode,
    P91Bt489SetPalette,
    P91Bt489ClearPalette,
    P91Bt489PointerOn,
    P91Bt489PointerOff,
    P91Bt489SetPointerPos,
    P91Bt489SetPointerShape,
    CLK489_MAX_FREQ,
    P91Bt489SetClkDoubler,
    P91Bt489ClrClkDoubler,
    DAC_ID_BT489,
    64,
    FALSE,
    FALSE,
    TRUE                // TRUE == Supports 24BPP
};


VOID
P91Bt489SetPalette(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG *pPal,
    ULONG StartIndex,
    ULONG Count
    )

/*++

Routine Description:

    Sets the Device palette

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    pPal - Pointer to the array of pallete entries.

    StartIndex - Specifies the first pallete entry provided in pPal.

    Count - Number of palette entries in pPal

Return Value:

    None.

--*/

{
    UCHAR  *pBytePal;

    PAL_WR_ADDR((UCHAR) StartIndex);

    pBytePal = (PUCHAR) pPal;

    //
    // Load the palette with RGB values. The input palette has 4 bytes
    // per entry, the last of which is ignored.
    //

    while (Count--)
    {
        PAL_WR_DATA(*pBytePal++);
        PAL_WR_DATA(*pBytePal++);
        PAL_WR_DATA(*pBytePal++);
        pBytePal++;
    }
}


VOID
P91Bt489SetPointerPos(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG   ptlX,
    ULONG   ptlY
    )

/*++

Routine Description:

    Move Hardware Pointer.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    ptlX, ptlY - Requested X,Y position for the pointer.

Return Value:

    TRUE

--*/

{

    //
    // Strip off the invalid bits and update the cursor position regs.
    //

    WR_CURS_POS_X(((ptlX + CURSOR_WIDTH) & 0xFFF));
    WR_CURS_POS_Y(((ptlY + CURSOR_HEIGHT) & 0xFFF));

    return;
}


VOID
P91Bt489SetPointerShape(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUCHAR  pHWCursorShape
    )

/*++

Routine Description:

    Sets the hardware cursor shape.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    pHWCursorShape - Pointer to the cursor bitmap.

Return Value:

    None.

--*/

{
    ULONG   iCount;

    //
    // The # of bytes of cursor bitmap data to send *= 2 for and/xor mask
    // *= 8 for 8bit/byte
    // *= 2 for 2 loops
    //

    ULONG iLoop  = (CURSOR_WIDTH * CURSOR_HEIGHT * 2) / (8 * 2);

    //
    // AND mask will be loaded to plane 1.
    //

    PAL_WR_ADDR(0x80);

    iCount = iLoop;

    WAIT_FOR_RETRACE();

    while (iCount--)
    {
        WR_CURS_DATA(*pHWCursorShape++);
    }

    //
    // XOR mask will be loaded to plane 0.
    //

    PAL_WR_ADDR(0x00);

    iCount = iLoop;

    WAIT_FOR_RETRACE();

    while (iCount--)
    {
        WR_CURS_DATA(*pHWCursorShape++);
    }

    return;
}


VOID
P91Bt489PointerOn(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

  Turn on the hardware cursor.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    None.

--*/

{


    //
    // Turn the cursor on only if it was disabled.
    //

    if (!CURS_IS_ON())
    {
        WAIT_FOR_RETRACE();
        CURS_ON();
    }

    return;
}


VOID
P91Bt489PointerOff(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

  Turn off the hardware cursor.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    None.

--*/

{


    //
    // Turn the cursor off only if it was enabled.
    //

    if (CURS_IS_ON())
    {
        WAIT_FOR_RETRACE();
        CURS_OFF();
    }

    return;
}


VOID
P91Bt489ClearPalette(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    Clears the palette to all 0's

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    None.

--*/

{
    int Count;

    //
    // Calculate the number of palette entries. It is assumed that the
    // caller has already determined that the current mode makes use
    // of the palette,
    //

    Count = 1 << HwDeviceExtension->usBitsPixel;

    //
    // Fill the palette with RGB values of 0.
    //

    while (Count--)
    {
        PAL_WR_DATA(0);
        PAL_WR_DATA(0);
        PAL_WR_DATA(0);
    }

    return;
}


BOOLEAN
P91Bt489SetMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    Initializes the DAC for the current mode.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    None.

--*/
{
    USHORT  usLoadClock;
    UCHAR   ucCurState;

    VideoDebugPrint((1, "P91Bt489SetMode----------\n"));

    // Added per code received from R. Embry

    WriteDAC(HwDeviceExtension, PIXEL_MSK_REG, 0xff);

    //
    // Enable 8bit dacs, allow access to Command Register 3.
    //

    //
    // Enable accesses to CMD_REG_3.  For the Power 9100, to access command
    // register 3, you must have CR07 TRUE and you must load a one into
    // the address register.
    //
    if (IS_DEV_P9100)
       P9_WR_REG(P9100_RAMWRITE, 0x01);

    WriteDAC(HwDeviceExtension, CMD_REG_0, ENB_CMD_REG_3 | MODE_8_BIT);

    //
    // Set the DAC Pixel port value for the current bit depth.
    // Note: The BT485 does not support 24bpp mode.
    //

    switch (HwDeviceExtension->usBitsPixel)
    {
        case 8:
            WriteDAC(HwDeviceExtension, CMD_REG_1, PIX_PORT_8);
                        WR_CMD_REG_4( CR4_MUX_81 );
            break;

        case 16: // This is really 555, not 565...
            WriteDAC(HwDeviceExtension, CMD_REG_1, PIX_PORT_15);
                        WR_CMD_REG_4( CR4_MUX_41 );
            break;

            case 24:
                    WriteDAC(HwDeviceExtension, CMD_REG_1, PIX_PORT_32);
                        WR_CMD_REG_4(CR4_MUX_24BPP);
                    break;

        case 32:
            WriteDAC(HwDeviceExtension, CMD_REG_1, PIX_PORT_32);
                        WR_CMD_REG_4( CR4_MUX_21 );
            break;

        default:

        //
        // Oops..invalid BPP value. Use 8BPP value for now.
        //

            WriteDAC(HwDeviceExtension, CMD_REG_1, PIX_PORT_8);
                        WR_CMD_REG_4( CR4_MUX_81 );
            break;
    };

    // This code added per R. Embry from ECR 2/95

    usLoadClock = (USHORT) ((HwDeviceExtension->VideoData.dotfreq1 /
                            HwDeviceExtension->Dac.usRamdacWidth) *
                            HwDeviceExtension->usBitsPixel);

    if ( usLoadClock > 4850 )
        {
        ucCurState = SCLK_INV;  // Bt489 - invert SCLK if in forbidden region
    }
    else
        {
        ucCurState = 0;
        }

    //
    // Select P9x00 video clock, disable cursor
    //

    WriteDAC( HwDeviceExtension, CMD_REG_2,
         (UCHAR)(ucCurState | ((PORTSEL_MSKD | PCLK1_SEL) & DIS_CURS)) );

    //
    // Select 32x32x2 cursor mode, and clock doubler mode if neccessary.
    //

    RD_CMD_REG_3(ucCurState);

    if (HwDeviceExtension->VideoData.dotfreq1 >
        HwDeviceExtension->Dac.ulMaxClkFreq)
    {
        //
        // Enable the DAC clock doubler mode.
        //

        HwDeviceExtension->Dac.DACSetClkDblMode(HwDeviceExtension);
    }
    else
    {
        //
        // Disable the DAC clock doubler mode.
        //

        HwDeviceExtension->Dac.DACClrClkDblMode(HwDeviceExtension);
    }

    //
    // Set the pixel read mask.
    //

    WriteDAC(HwDeviceExtension, PIXEL_MSK_REG, 0xff);

    //
    // Set cursor colors 1 and 2.
    //

    WriteDAC(HwDeviceExtension, CURS_CLR_ADDR, 1);
    WriteDAC(HwDeviceExtension, CURS_CLR_DATA, 0x00);
    WriteDAC(HwDeviceExtension, CURS_CLR_DATA, 0x00);
    WriteDAC(HwDeviceExtension, CURS_CLR_DATA, 0x00);
    WriteDAC(HwDeviceExtension, CURS_CLR_DATA, 0xFF);
    WriteDAC(HwDeviceExtension, CURS_CLR_DATA, 0xFF);
    WriteDAC(HwDeviceExtension, CURS_CLR_DATA, 0xFF);

    return(TRUE);
}


VOID
P91Bt489RestoreMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

routine description:

    Restore the DAC to its pristine state.

arguments:

    hwdeviceextension - pointer to the miniport driver's device extension.


return value:

--*/

{
    UCHAR   ucCurState;

    VideoDebugPrint((1, "P91Bt489RestoreMode----------\n"));

    //
    // Enable accesses to CMD_REG_3.  For the Power 9100, to access command
    // register 3, you must have CR07 TRUE and you must load a one into
    // the address register.
    //
    if (IS_DEV_P9100)
    {
       // Added per code received from R. Embry

       WriteDAC(HwDeviceExtension, CMD_REG_0, ENB_CMD_REG_3);
       P9_WR_REG(P9100_RAMWRITE, 0x02);
       WR_CMD_REG_3(0x00);

           // end added code

       P9_WR_REG(P9100_RAMWRITE, 0x01);
       WriteDAC(HwDeviceExtension, CMD_REG_0, ENB_CMD_REG_3);

//       ucCurState = ReadDAC(HwDeviceExtension, CMD_REG_1);
//       ucCurState = ReadDAC(HwDeviceExtension, CMD_REG_2);

//       RD_CMD_REG_3(ucCurState);
//       RD_CMD_REG_4(ucCurState);

       WR_CMD_REG_4(0x00);      // zero out cmd reg 4 on Bt489

       WriteDAC(HwDeviceExtension, CMD_REG_0, 0x00);
        WriteDAC(HwDeviceExtension, CMD_REG_1, 0x00);
        WriteDAC(HwDeviceExtension, CMD_REG_2, 0x00);
         return;
    }

    WriteDAC(HwDeviceExtension, CMD_REG_0, ENB_CMD_REG_3);

    //
    // Set pixel port for 8bit pixels.
    //

    WriteDAC(HwDeviceExtension, CMD_REG_1, PIX_PORT_8);

    //
    // Select VGA video clock, disable cursor.
    //

    WriteDAC(HwDeviceExtension, (ULONG) CMD_REG_2,
            (UCHAR)(ReadDAC(HwDeviceExtension, (ULONG) CMD_REG_2) & DIS_CURS));

    //
    // Select 32x32 cursor, clear clock doubler bit.
    //

    RD_CMD_REG_3(ucCurState);
    WR_CMD_REG_3(ucCurState & (~(DAC_CLK_2X | DAC_CLK_2X_489) & CUR_MODE_32));

    //
    // Set pixel read mask.
    //

    WriteDAC(HwDeviceExtension, PIXEL_MSK_REG, 0xff);
     return;
}


VOID
P91Bt489SetClkDoubler(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

routine description:

    Enable the DAC's internal clock doubler.

arguments:

    hwdeviceextension - pointer to the miniport driver's device extension.


return value:

--*/

{
    UCHAR   ucCurState;

    VideoDebugPrint((1, "P91Bt489SetClkDoubler----------\n"));
    RD_CMD_REG_3(ucCurState);
                                                                                // per os/2 driver, write undocumented bit too
        if (HwDeviceExtension->usBitsPixel == 24 )
    {
        WR_CMD_REG_3(ucCurState | (DAC_CLK_2X | DAC_CLK_2X_489));
    }
    else
        {
        WR_CMD_REG_3(ucCurState | DAC_CLK_2X);
    }
    return;
}


VOID
P91Bt489ClrClkDoubler(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

routine description:

    Disable the DAC's internal clock doubler.

arguments:

    hwdeviceextension - pointer to the miniport driver's device extension.


return value:

--*/
{
    UCHAR   ucCurState;

    VideoDebugPrint((1, "P91Bt489ClrClkDoubler----------\n"));
    RD_CMD_REG_3(ucCurState);
    WR_CMD_REG_3(ucCurState & ~(DAC_CLK_2X | DAC_CLK_2X_489));
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\mini\vga.h ===
/*++

Copyright (c) 1993  Weitek Corporation

Module Name:

    vga.h

Abstract:

    This module contains VGA specific definitions for the Weitek P9
    miniport device driver.

Environment:

    Kernel mode

Revision History may be found at the end of this file.

--*/

//
// VGA Miscellaneous Output Register
//

#define MISCIN              0x0c        // Misc Output Read Register
#define MISCOUT             0x02        // Misc Output Write Register

#define MISCC               0x04        //
#define MISCD               0x08

#define SEQ_INDEX_PORT      0x04
#define SEQ_DATA_PORT       0x05
#define SEQ_MISC_CRLOCK     0x20
#define SEQ_OUTCNTL_INDEX   0x12
#define SEQ_MISC_INDEX      0x11

#define VESAVideoSelectRegIndex 0x012
#define VLPolarity 0x20
#define VLEnable   0x10

#define VGA_FREQ    2832                // Default VGA Video Freq in dHz

//
// Base address of VGA memory range and video memory size. 
//

#define MEM_VGA_ADDR        0xA0000
#define MEM_VGA_SIZE        0x20000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\mini\wtkp90vl.c ===
/*++

Copyright (c) 1993  Weitek Corporation

Module Name:

    wtkp90vl.c

Abstract:

    This module contains OEM specific functions for the Weitek P9000
    VL evaluation board.

Environment:

    Kernel mode

Revision History may be found at the end of this file.

--*/


#include "p9.h"
#include "p9gbl.h"
#include "p9000.h"
#include "vga.h"

//
// Default memory addresses for the P9 registers/frame buffer.
//

#define MemBase         0xC0000000

//
// Bit to write to the sequencer control register to enable/disable P9
// video output.
//

#define P9_VIDEO_ENB   0x10

//
// Define the bit in the sequencer control register which determines
// the sync polarities. For Weitek board, 1 = positive.
//

#define HSYNC_POL_MASK  0x20

//
// OEM specific static data.
//

//
// List of valid base addresses for different Weitek based designs.
//
#define NUM_WTK_ADDRS   10
ULONG   ulWtkAddrRanges[] =
{
    0x4000000L,
    0x8000000L,
    0xD000000L,
    0xE000000L,
    0xF000000L,
    0x80000000L,
    0xC0000000L,
    0xD0000000L,
    0xE0000000L,
    0xF0000000L
};


//
// VLDefDACRegRange contains info about the memory/io space ranges
// used by the DAC.
//

VIDEO_ACCESS_RANGE VLDefDACRegRange[] =
{
     {
        0x03C8,                         // Low address
        0x00000000,                     // Hi address
        0x01,                           // length
        1,                              // Is range in i/o space?
        1,                              // Range should be visible
        1                               // Range should be shareable
     },
     {
        0x03C9,                         // Low address
        0x00000000,                     // Hi address
        0x01,                           // length
        1,                              // Is range in i/o space?
        1,                              // Range should be visible
        1                               // Range should be shareable
     },
     {
        0x03C6,                         // Low address
        0x00000000,                     // Hi address
        0x01,                           // length
        1,                              // Is range in i/o space?
        1,                              // Range should be visible
        1                               // Range should be shareable
     },
     {
        0x03C7,                         // Low address
        0x00000000,                     // Hi address
        0x01,                           // length
        1,                              // Is range in i/o space?
        1,                              // Range should be visible
        1                               // Range should be shareable
     },
     {
        0x43C8,                         // Low address
        0x00000000,                     // Hi address
        0x01,                           // length
        1,                              // Is range in i/o space?
        1,                              // Range should be visible
        1                               // Range should be shareable
     },
     {
        0x43C9,                         // Low address
        0x00000000,                     // Hi address
        0x01,                           // length
        1,                              // Is range in i/o space?
        1,                              // Range should be visible
        1                               // Range should be shareable
     },
     {
        0x43C6,                         // Low address
        0x00000000,                     // Hi address
        0x01,                           // length
        1,                              // Is range in i/o space?
        1,                              // Range should be visible
        1                               // Range should be shareable
     },
     {
        0x43C7,                         // Low address
        0x00000000,                     // Hi address
        0x01,                           // length
        1,                              // Is range in i/o space?
        1,                              // Range should be visible
        1                               // Range should be shareable
     },
     {
        0x83C8,                         // Low address
        0x00000000,                     // Hi address
        0x01,                           // length
        1,                              // Is range in i/o space?
        1,                              // Range should be visible
        1                               // Range should be shareable
     },
     {
        0x83C9,                         // Low address
        0x00000000,                     // Hi address
        0x01,                           // length
        1,                              // Is range in i/o space?
        1,                              // Range should be visible
        1                               // Range should be shareable
     },
     {
        0x83C6,                         // Low address
        0x00000000,                     // Hi address
        0x01,                           // length
        1,                              // Is range in i/o space?
        1,                              // Range should be visible
        1                               // Range should be shareable
     },
     {
        0x83C7,                         // Low address
        0x00000000,                     // Hi address
        0x01,                           // length
        1,                              // Is range in i/o space?
        1,                              // Range should be visible
        1                               // Range should be shareable
     },
     {
        0xC3C8,                         // Low address
        0x00000000,                     // Hi address
        0x01,                           // length
        1,                              // Is range in i/o space?
        1,                              // Range should be visible
        1                               // Range should be shareable
     },
     {
        0xC3C9,                         // Low address
        0x00000000,                     // Hi address
        0x01,                           // length
        1,                              // Is range in i/o space?
        1,                              // Range should be visible
        1                               // Range should be shareable
     },
     {
        0xC3C6,                         // Low address
        0x00000000,                     // Hi address
        0x01,                           // length
        1,                              // Is range in i/o space?
        1,                              // Range should be visible
        1                               // Range should be shareable
     },
     {
        0xC3C7,                         // Low address
        0x00000000,                     // Hi address
        0x01,                           // length
        1,                              // Is range in i/o space?
        1,                              // Range should be visible
        1                               // Range should be shareable
     }
};


BOOLEAN
VLGetBaseAddr(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    Perform board detection and if present return the P9000 base address.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

TRUE    - Board found, P9 and Frame buffer address info was placed in
the device extension.

FALSE   - Board not found.

--*/
{
    SHORT               i;

    //
    // Only the viper p9000 works on the Siemens boxes
    //

    if_SIEMENS_VLB()
    {
        return FALSE;
    }

    if (HwDeviceExtension->P9PhysAddr.LowPart == 0)
    {
        //
        // The base address was not found in the registry, so copy the
        // default address into the device extension.
        //

        HwDeviceExtension->P9PhysAddr.LowPart = MemBase;
    }

    if (!VLP90CoprocDetect(HwDeviceExtension,
                           HwDeviceExtension->P9PhysAddr.LowPart))
    {
        //
        // Scan all possible base addresses to see if the coprocessor is
        // present.
        //

        BOOLEAN bFound;

        bFound = FALSE;
        for (i = 0; i < NUM_WTK_ADDRS && !bFound; i++)
        {
            if (ulWtkAddrRanges[i] +
                HwDeviceExtension->P9CoprocInfo.CoprocRegOffset !=
                HwDeviceExtension->CoprocPhyAddr.LowPart)
            {
                if (VLP90CoprocDetect(HwDeviceExtension,
                                        ulWtkAddrRanges[i]))
                {
                    HwDeviceExtension->P9PhysAddr.LowPart =
                        ulWtkAddrRanges[i];
                    bFound = TRUE;
                    break;
                }
            }
        }
        if (!bFound)
        {
            return(FALSE);
        }
    }

    //
    // Copy the DAC register access ranges to the global access range
    // structure.
    //

    VideoPortMoveMemory(&DriverAccessRanges[NUM_DRIVER_ACCESS_RANGES],
                            VLDefDACRegRange,
                            HwDeviceExtension->Dac.cDacRegs *
                            sizeof(VIDEO_ACCESS_RANGE));
    return(TRUE);
}


BOOLEAN
VLP90CoprocDetect(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG   ulCoprocPhyAddr
    )

/*++

Routine Description:

    Perform P9000 coprocessor detection.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.
    ulCoprocPhyAddr - The physical base address used for detection.

Return Values:

TRUE    - Coprocessor found.
FALSE   - Coprocessor not found.

--*/
{
    VIDEO_ACCESS_RANGE  VLAccessRange;
    ULONG               ulTestPat = 0xFFFFFFFF;
    ULONG               ulTemp;

    //
    // Set up the access range so we can map the coprocessor address space.
    //

    VLAccessRange.RangeInIoSpace = FALSE;
    VLAccessRange.RangeVisible = TRUE;
    VLAccessRange.RangeShareable = TRUE;
    VLAccessRange.RangeStart.LowPart = ulCoprocPhyAddr +
        HwDeviceExtension->P9CoprocInfo.CoprocRegOffset;
    VLAccessRange.RangeStart.HighPart = 0;
    VLAccessRange.RangeLength = HwDeviceExtension->P9CoprocInfo.CoprocLength;

    //
    //
    // Check to see if another miniport driver has allocated any of the
    // coprocessor's address space.
    //

    if (VideoPortVerifyAccessRanges(HwDeviceExtension,
                                    1L,
                                    &VLAccessRange) != NO_ERROR)
    {
        return(FALSE);
    }

    //
    // Get a virtual address for the coprocessor's address space.
    //


    if ((HwDeviceExtension->Coproc =
                VideoPortGetDeviceBase(HwDeviceExtension,
                                        VLAccessRange.RangeStart,
                                        VLAccessRange.RangeLength,
                                        VLAccessRange.RangeInIoSpace)) == 0)
    {
            return(FALSE);
    }

    //
    // Write a test value to the location of the coprocessor's clipping
    // window min register and attempt to read it back.
    //

    P9_WR_REG(WMIN, ulTestPat);
    ulTemp = P9_RD_REG(WMIN);
    VideoPortFreeDeviceBase(HwDeviceExtension, HwDeviceExtension->Coproc);

    //
    // The value read back from the clipping window min reg will have the
    // high order 3 bits of each word clear.
    //

    if (ulTemp == (ulTestPat & P9_COORD_MASK))
    {
        //
        // Coprocessor is present.
        //

        return(TRUE);
    }
    else
    {
        //
        // Coprocessor is absent.
        //

        return(FALSE);
    }
}


VOID
VLSetMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    This routine sets the video mode. Different OEM adapter implementations
    require that initialization operations be performed in a certain
    order. This routine uses the standard order which addresses most
    implementations (VL, Ajax, Weitek PCI, Tulip).

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    None.

--*/

{
    //
    // Set the dot clock.
    //

    DevSetClock(HwDeviceExtension,
                (USHORT) HwDeviceExtension->VideoData.dotfreq1,
                FALSE,
                TRUE);

    //
    // If this mode uses the palette, clear it to all 0s.
    //

    if (P9Modes[HwDeviceExtension->CurrentModeNumber].modeInformation.AttributeFlags
        && VIDEO_MODE_PALETTE_DRIVEN)
    {
        HwDeviceExtension->Dac.DACClearPalette(HwDeviceExtension);
    }

    //
    // Save the value in the VGA's Misc Output register.
    //

    HwDeviceExtension->MiscRegState = VGA_RD_REG(MISCIN);

    //
    // Initialize the DAC.
    //

    HwDeviceExtension->Dac.DACInit(HwDeviceExtension);

    //
    // Enable P9 video.
    //

    HwDeviceExtension->AdapterDesc.P9EnableVideo(HwDeviceExtension);

}


VOID
VLEnableP9(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

Perform the OEM specific tasks necessary to enable P9000 Video. These
include memory mapping, setting the sync polarities, and enabling the
P9000 video output.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    None.

--*/

{

    USHORT  holdit;

    //
    // Select external frequency.
    //

    VGA_WR_REG(MISCOUT, VGA_RD_REG(MISCIN) | (MISCD | MISCC));

    //
    // If this is a Weitek VGA, unlock it.
    //

    if (HwDeviceExtension->AdapterDesc.bWtk5x86)
    {
        UnlockVGARegs(HwDeviceExtension);
    }

    VGA_WR_REG(SEQ_INDEX_PORT, SEQ_OUTCNTL_INDEX);
    holdit = VGA_RD_REG(SEQ_DATA_PORT);

    //
    // Set the sync polarity. First clear the sync polarity bits.
    //

    holdit &= ~HSYNC_POL_MASK;

    if (HwDeviceExtension->VideoData.hp == POSITIVE)
    {
        holdit |= HSYNC_POL_MASK;
    }

    holdit |= P9_VIDEO_ENB;
    VGA_WR_REG(SEQ_DATA_PORT, holdit);

    //
    // If this is a Weitek VGA, lock it.
    //

    if (HwDeviceExtension->AdapterDesc.bWtk5x86)
    {
        LockVGARegs(HwDeviceExtension);
    }

    return;
}


BOOLEAN
VLDisableP9(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:


Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.
    pPal - Pointer to the array of pallete entries.
    StartIndex - Specifies the first pallete entry provided in pPal.
    Count - Number of palette entries in pPal

Return Value:

    TRUE, indicating *no* int10 is needed to complete the switch

--*/

{
    USHORT holdit;

    //
    // If this is a Weitek VGA, unlock it.
    //

    if (HwDeviceExtension->AdapterDesc.bWtk5x86)
    {
        UnlockVGARegs(HwDeviceExtension);
    }

    VGA_WR_REG(SEQ_INDEX_PORT, SEQ_OUTCNTL_INDEX);
    holdit = VGA_RD_REG(SEQ_DATA_PORT);

    //
    //  Disable P9000 video output.
    //

    holdit &= ~P9_VIDEO_ENB;
    VGA_WR_REG(SEQ_INDEX_PORT, SEQ_OUTCNTL_INDEX);
    VGA_WR_REG(SEQ_DATA_PORT, holdit);

    //
    // Restore clock select bits.
    //

    VGA_WR_REG(MISCOUT, HwDeviceExtension->MiscRegState);

    //
    // If this is a Weitek VGA, lock it.
    //

    if (HwDeviceExtension->AdapterDesc.bWtk5x86)
    {
        LockVGARegs(HwDeviceExtension);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\mini\viper.c ===
/*++

Copyright (c) 1993  Weitek Corporation

Module Name:

    viper.c

Abstract:

    This module contains OEM specific functions for the Diamond Viper
    board.

Environment:

    Kernel mode

Revision History may be found at the end of this file.

--*/

#include "p9.h"
#include "p9gbl.h"
#include "p9000.h"
#include "viper.h"
#include "vga.h"
#include "p9errlog.h"


#define REJECT_ON_BIOS_VERSION  0

//
// OEM specific static data.
//

//
// This structure is used to match the possible physical address
// mappings with the value to be written to the sequencer control
// register.

typedef struct
{
    PHYSICAL_ADDRESS    BaseMemAddr;
    USHORT              RegValue;
} MEM_RANGE;

MEM_RANGE   ViperMemRange[] =
{
    { 0x0A0000000, 0L, MEM_AXXX },
    { 0x080000000, 0L, MEM_8XXX },
    { 0x020000000, 0L, MEM_2XXX },
    { 0x01D000000, 0L, MEM_AXXX }
};

LONG NumMemRanges = sizeof(ViperMemRange) / sizeof(MEM_RANGE);


#ifdef REJECT_ON_BIOS_VERSION

/*++
 ** bRejectOnBiosVersion
 *
 *  FILENAME: D:\nt351.nc\weitek\p9x\mini\viper.c
 *
 *  PARAMETERS:         PHW_DEVICE_EXTENSION HwDeviceExtension
 *                                      PUCHAR  pjBios                  linear address of the BIOS
 *                                      ULONG   ulBiosLength    lengh of the BIOS
 *
 *  DESCRIPTION:        Scan the Bios,
 *
 *  RETURNS:            TRUE    to reject supporting this card.
 *                                      FALSE   to support this card.
 *
 *
 --*/
BOOLEAN
bRejectOnBiosVersion(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUCHAR      pjBiosAddr,
    ULONG       ulBiosLength)
{

        // Add the strings you want to detect for rejection to this array

        static  PUCHAR aszBiosVersion[] = {
                "VIPER VLB  Vers. 1",
                "VIPER VLB  Vers. 2",
                NULL
        };

        LONG    i;
        BOOLEAN bFound = FALSE;

        for (i = 0; aszBiosVersion[i] != 0; i++)
        {

            if (VideoPortScanRom(HwDeviceExtension,
                                 (PUCHAR) pjBiosAddr,
                                 VGA_BIOS_LEN,
                                 aszBiosVersion[i]))
            {
                        bFound = TRUE;
                        break;
            }
        }

        if (bFound == TRUE)
        {
                VideoPortLogError(HwDeviceExtension,
                                                  NULL,
                                                  P9_DOWN_LEVEL_BIOS,
                                                  i);
                VideoDebugPrint((1, "P9X - Down Level Bios\n"));
        }


        // We will always boot, we'll just warn the user that bad things may happen

        return (FALSE);


}



#endif // REJECT_ON_BIOS_VERSION

#define P9001_REV_ID            0x08


BOOLEAN
ViperGetBaseAddr(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    Perform board detection and if present return the P9000 base address.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

TRUE    - Board found, P9 and Frame buffer address info was placed in
the device extension.

FALSE   - Board not found.

--*/
{
    VP_STATUS           status;
    SHORT               i;
    PUCHAR              pucBiosAddr;
    BOOLEAN             bValid = FALSE;
    ULONG               ulTemp;

    VIDEO_ACCESS_RANGE  BiosAccessRange =
     {
        VGA_BIOS_ADDR,                      // Low address
        0x00000000,                     // Hi address
        VGA_BIOS_LEN,                           // length
        0,                              // Is range in i/o space?
        1,                              // Range should be visible
        1                               // Range should be shareable
     };

    if (HwDeviceExtension->MachineType == SIEMENS_P9100_VLB)
        return FALSE;


    //
    //  More PnP goofing around: Try to detect a PCI card here. If successful,
    //  fail finding a VLB Viper, since we won't support both a PCI and VLB
    //  viper on the same machine as of NT5. We love PnP.
    //

    if (VideoPortGetBusData(HwDeviceExtension,
                            PCIConfiguration,
                            HwDeviceExtension->PciSlotNum,
                            &ulTemp,    //bogus name
                            P9001_REV_ID,
                            sizeof(ulTemp)))
    {
        VideoDebugPrint((1, "VPGetBusData succeeded???, line %d\n", __LINE__));
        return(FALSE);
    }

    //
    // Determine if a Viper card is installed by scanning the VGA BIOS ROM
    // memory space.
    //

    //
    // Map in the BIOS' memory space. If it can't be mapped,
    // return an error.
    //

    if (HwDeviceExtension->MachineType == SIEMENS)
    {
        BiosAccessRange.RangeStart.LowPart += 0x10000000L;
    }

    if (VideoPortVerifyAccessRanges(HwDeviceExtension,
                                    1,
                                    &BiosAccessRange) != NO_ERROR)
    {
        return(FALSE);
    }

    if ((pucBiosAddr =
        VideoPortGetDeviceBase(HwDeviceExtension,
                               BiosAccessRange.RangeStart,
                               BiosAccessRange.RangeLength,
                               FALSE)) == 0)
    {
        return(FALSE);
    }

    if (!VideoPortScanRom(HwDeviceExtension,
                         pucBiosAddr,
                         VGA_BIOS_LEN,
                         VIPER_VL_ID_STR))
    {
        VideoPortFreeDeviceBase(HwDeviceExtension, pucBiosAddr);
        return(FALSE);
    }

#ifdef REJECT_ON_BIOS_VERSION

    if (bRejectOnBiosVersion(HwDeviceExtension, pucBiosAddr, VGA_BIOS_LEN))
       return (FALSE);

#endif // REJECT_ON_BIOS_VERSION

    VideoPortFreeDeviceBase(HwDeviceExtension, pucBiosAddr);

    //
    // For now, pretend we have a Weitek 5x86 VGA. Later we may call the
    // Viper BIOS to determine which type of BIOS is installed.
    //

    HwDeviceExtension->AdapterDesc.bWtk5x86 = TRUE;

    //
    // Copy the DAC register access ranges to the global access range
    // structure.
    //

    VideoPortMoveMemory(&DriverAccessRanges[NUM_DRIVER_ACCESS_RANGES],
                            VLDefDACRegRange,
                            HwDeviceExtension->Dac.cDacRegs *
                            sizeof(VIDEO_ACCESS_RANGE));

    //
    // A value for the P9 base address may have beens found in the registry,
    // and it is now stored in the device extension. Ensure the address
    // value is valid for the Viper card. Then use it to compute
    // the starting address of the P9000 registers and frame buffer,
    // and store it in the device extension.
    //

    for (i = 0; i < NumMemRanges; i++)
    {
        if (HwDeviceExtension->P9PhysAddr.LowPart ==
            ViperMemRange[i].BaseMemAddr.LowPart)
        {
            bValid = TRUE;
            break;
        }
    }

    //
    // If the address value is invalid, or was not found in the registry,
    // use the default.
    //

    if (!bValid)
    {
        HwDeviceExtension->P9PhysAddr.LowPart = MemBase;
    }

    return(TRUE);
}


VOID
ViperEnableP9(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

Perform the OEM specific tasks necessary to enable the P9000. These
include memory mapping, setting the sync polarities, and enabling the
P9000 video output.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    None.

--*/

{

    USHORT  holdit;

    //
    // Select external frequency.
    //

    VGA_WR_REG(MISCOUT, VGA_RD_REG(MISCIN) | (MISCD | MISCC));

    //
    // If this is a Weitek VGA, unlock it.
    //

    if (HwDeviceExtension->AdapterDesc.bWtk5x86)
    {
        UnlockVGARegs(HwDeviceExtension);
    }

    VGA_WR_REG(SEQ_INDEX_PORT, SEQ_OUTCNTL_INDEX);
    holdit = VGA_RD_REG(SEQ_DATA_PORT);

    //
    // Set the sync polarity. First clear the sync polarity bits.
    //

    holdit &= ~POL_MASK;

    //
    // Viper controls h and v sync polarities independently. Set the
    // vertical sync polarity.
    //

    if (HwDeviceExtension->VideoData.vp == POSITIVE)
    {
        holdit |= VSYNC_POL_MASK;
    }

    //
    // Disable VGA video output.
    //

    holdit &= VGA_VIDEO_DIS;

    if (HwDeviceExtension->VideoData.hp == POSITIVE)
    {
        holdit |= HSYNC_POL_MASK;
    }

    holdit |= P9_VIDEO_ENB;
    VGA_WR_REG(SEQ_DATA_PORT, holdit);

    //
    // If this is a Weitek VGA, lock it.
    //

    if (HwDeviceExtension->AdapterDesc.bWtk5x86)
    {
        LockVGARegs(HwDeviceExtension);
    }

    return;
}


BOOLEAN
ViperDisableP9(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:


Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.
    pPal - Pointer to the array of pallete entries.
    StartIndex - Specifies the first pallete entry provided in pPal.
    Count - Number of palette entries in pPal

Return Value:

    TRUE, indicating *no* int10 is needed to complete the switch

--*/

{
    USHORT holdit;

    //
    // If this is a Weitek VGA, unlock it.
    //

    if (HwDeviceExtension->AdapterDesc.bWtk5x86)
    {
        UnlockVGARegs(HwDeviceExtension);
    }

    VGA_WR_REG(SEQ_INDEX_PORT, SEQ_OUTCNTL_INDEX);
    holdit = VGA_RD_REG(SEQ_DATA_PORT);

    //
    //  Disable P9000 video output.
    //

    holdit &= P9_VIDEO_DIS;

    //
    // VGA output enable is a seperate register bit for the Viper board.
    //

    holdit |= VGA_VIDEO_ENB;

    VGA_WR_REG(SEQ_INDEX_PORT, SEQ_OUTCNTL_INDEX);
    VGA_WR_REG(SEQ_DATA_PORT, holdit);

    //
    // Restore clock select bits.
    //

    VGA_WR_REG(MISCOUT, HwDeviceExtension->MiscRegState);

    //
    // If this is a Weitek VGA, lock it.
    //

    if (HwDeviceExtension->AdapterDesc.bWtk5x86)
    {
        LockVGARegs(HwDeviceExtension);
    }

    return TRUE;
}


BOOLEAN
ViperEnableMem(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:
    Enables the P9000 memory at the physical base address stored in the
    device extension.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    None.

--*/

{
    USHORT  holdit;
    SHORT   i;

    //
    // If this is a Weitek VGA, unlock it.
    //

    if (HwDeviceExtension->AdapterDesc.bWtk5x86)
    {
        UnlockVGARegs(HwDeviceExtension);
    }

    //
    // Read the contents of the sequencer memory address register.
    //

    VGA_WR_REG(SEQ_INDEX_PORT, SEQ_OUTCNTL_INDEX);
    holdit = VGA_RD_REG(SEQ_DATA_PORT);

    //
    // Clear out any address bits which are set.
    //

    holdit &= ADDR_SLCT_MASK;

    //
    // Map the P9000 to the address specified in the device extension.
    //

    for (i = 0; i < NumMemRanges; i++ )
    {
        if (ViperMemRange[i].BaseMemAddr.LowPart ==
                HwDeviceExtension->P9PhysAddr.LowPart)
        {
            holdit |= ViperMemRange[i].RegValue;
            break;
        }
    }

    VGA_WR_REG(SEQ_DATA_PORT, holdit);

    //
    // If this is a Weitek VGA, lock it.
    //

    if (HwDeviceExtension->AdapterDesc.bWtk5x86)
    {
        LockVGARegs(HwDeviceExtension);
    }

    return(TRUE);

}


VOID
ViperSetMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    This routine sets the video mode. Different OEM adapter implementations
    require that initialization operations be performed in a certain
    order. This routine uses the standard order which addresses most
    implementations (Viper VL and VIPER PCI).

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    None.

--*/

{

    //
    // Save the value in the VGA's Misc Output register.
    //

    HwDeviceExtension->MiscRegState = VGA_RD_REG(MISCIN);

    //
    // Enable the Vipers Memory Map.
    //

    HwDeviceExtension->AdapterDesc.P9EnableMem(HwDeviceExtension);

    //
    // Enable P9000 video.
    //

    HwDeviceExtension->AdapterDesc.P9EnableVideo(HwDeviceExtension);

    //
    // Initialize the DAC.
    //

    HwDeviceExtension->Dac.DACInit(HwDeviceExtension);


    //
    // Set the dot clock.
    //

    DevSetClock(HwDeviceExtension,
                (USHORT) HwDeviceExtension->VideoData.dotfreq1,
                FALSE,
                TRUE);

    //
    // If this mode uses the palette, clear it to all 0s.
    //

    if (P9Modes[HwDeviceExtension->CurrentModeNumber].modeInformation.AttributeFlags
        && VIDEO_MODE_PALETTE_DRIVEN)
    {
        HwDeviceExtension->Dac.DACClearPalette(HwDeviceExtension);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\mini\pci.h ===
/*++

Copyright (c) 1993  Weitek Corporation

Module Name:

    pci.h

Abstract:

    This module contains PCI definitions for the Weitek P9 miniport
    device driver.

Environment:

    Kernel mode

Revision History may be found at the end of this file.

--*/

//
// Local function prototypes defined in PCI.C.
//

BOOLEAN
PciFindDevice(
    IN      PHW_DEVICE_EXTENSION    HwDeviceExtension,
    IN      USHORT                  usDeviceId,
    IN      USHORT                  usVendorId,
    IN OUT  PULONG                  pulSlotNum
    );

//
// Externals used by the PCI routines.
//

extern  VIDEO_ACCESS_RANGE  VLDefDACRegRange[];

#if 0

//
// Define P9 register/frame buffer addresses using the OEM's default
// base address.
//

#define MemBase             0xA0000000

#endif

//
// Bit to write to the sequencer control register to enable/disable P9
// video output.
//

#define P9_VIDEO_ENB   0x10
#define P9_VIDEO_DIS   ~P9_VIDEO_ENB

//
// Define the bit in the sequencer control register which determines
// the sync polarities. For Weitek board, 1 = positive.
//

#define HSYNC_POL_MASK  0x20
#define POL_MASK        HSYNC_POL_MASK
#define VIPER_HSYNC_POL_MASK  0x40
#define VIPER_VSYNC_POL_MASK  0x80

//
// Defines which are specific to the Weitek PCI Implementation.
//

#define WTK_VENDOR_ID   (USHORT) 0x100E
#define WTK_9001_ID     (USHORT) 0x9001
#define WTK_9002_ID     (USHORT) 0x9002

#define P9001_IO_RANGE  0x1000 // 4K worth of IO ports.

#define WTK_9100_ID     (USHORT) 0x9100 

//
// Weitek P9001 specific configuration space registers.
//

#define P9001_CMD_REG           0x04
#define P9001_REV_ID            0x08
#define P9001_BASE_ADDR         0x10
#define P9001_REG_BASE          0x14
#define P9001_BIOS_BASE_ADDR    0x30
#define WTK_VGA_PRESENT         0x300

//
// Weitek P9002 specific registers/definitions.
//

#define P9002_VGA_ID    0x30l
#define OAK_VGA         1l
#define TRIDENT_VGA     2l
#define WTK_VGA         3l
#define VGA_MSK         3l

//
// Viper PCI ID String to search for ROM BIOS.
//

#define VIPER_ID_STR    "VIPER"
#define BIOS_RANGE_LEN   0x8000

//
// Misc PCI definitions.
//

#define PCI_BIOS_ENB    0x01l           // Bit def to enable the adapter BIOS
#define PCI_BIOS_DIS    ~PCI_BIOS_ENB   // Bit def to disable the adapter BIOS
#define P9001_IO_ENB    0x01            // Bit def to enable IO space
#define P9001_MEM_ENB   0x02            // Bit def to enable mem space

//
// The following block defines the base address for each of the RS registers
// defined in the Bt485 spec. The IO addresses given below are used to map
// the DAC registers to a series of virtual addresses which are kept
// in the device extension. OEMs should change these definitions as
// appropriate for their implementation.
//

#define RS_0_PCI_9001_ADDR    0x03c8
#define RS_1_PCI_9001_ADDR    0x03c9
#define RS_2_PCI_9001_ADDR    0x03c6
#define RS_3_PCI_9001_ADDR    0x03c7
#define RS_4_PCI_9001_ADDR    0x0400
#define RS_5_PCI_9001_ADDR    0x0401
#define RS_6_PCI_9001_ADDR    0x0402
#define RS_7_PCI_9001_ADDR    0x0403
#define RS_8_PCI_9001_ADDR    0x0800
#define RS_9_PCI_9001_ADDR    0x0801
#define RS_A_PCI_9001_ADDR    0x0802
#define RS_B_PCI_9001_ADDR    0x0803
#define RS_C_PCI_9001_ADDR    0x0C00
#define RS_D_PCI_9001_ADDR    0x0C01
#define RS_E_PCI_9001_ADDR    0x0C02
#define RS_F_PCI_9001_ADDR    0x0C03

#define RS_0_PCI_9002_ADDR    0x03c8
#define RS_1_PCI_9002_ADDR    0x03c9
#define RS_2_PCI_9002_ADDR    0x03c6
#define RS_3_PCI_9002_ADDR    0x03c7
#define RS_4_PCI_9002_ADDR    0x0040
#define RS_5_PCI_9002_ADDR    0x0041
#define RS_6_PCI_9002_ADDR    0x0042
#define RS_7_PCI_9002_ADDR    0x0043
#define RS_8_PCI_9002_ADDR    0x0080
#define RS_9_PCI_9002_ADDR    0x0081
#define RS_A_PCI_9002_ADDR    0x0082
#define RS_B_PCI_9002_ADDR    0x0083
#define RS_C_PCI_9002_ADDR    0x00C0
#define RS_D_PCI_9002_ADDR    0x00C1
#define RS_E_PCI_9002_ADDR    0x00C2
#define RS_F_PCI_9002_ADDR    0x00C3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\mini\vga.c ===
/*++

Copyright (c) 1993  Weitek Corporation

Module Name:

    vga.c

Abstract:

    This module contains VGA specific functions for the Weitek P9
    miniport device driver.

Environment:

    Kernel mode

Revision History may be found at the end of this file.

--*/

#include "p9.h"
#include "p9gbl.h"
#include "vga.h"


VOID
LockVGARegs(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:


Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.
    pPal - Pointer to the array of pallete entries.
    StartIndex - Specifies the first pallete entry provided in pPal.
    Count - Number of palette entries in pPal

Return Value:

    None.

--*/

{

//
// *** Don't lock it for ease of debug ***
//
// VGA_WR_REG(SEQ_INDEX_PORT, SEQ_MISC_INDEX);
// VGA_WR_REG(SEQ_DATA_PORT, VGA_RD_REG(SEQ_DATA_PORT) | SEQ_MISC_CRLOCK);
   return;
   }


VOID
UnlockVGARegs(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:


Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.
    pPal - Pointer to the array of pallete entries.
    StartIndex - Specifies the first pallete entry provided in pPal.
    Count - Number of palette entries in pPal

Return Value:

    None.

--*/

{
   USHORT holdit;

   VGA_WR_REG(SEQ_INDEX_PORT, SEQ_MISC_INDEX);
   holdit = VGA_RD_REG(SEQ_DATA_PORT);
   VGA_WR_REG(SEQ_DATA_PORT, holdit);
   VGA_WR_REG(SEQ_DATA_PORT, holdit);
   holdit = VGA_RD_REG(SEQ_DATA_PORT);
   VGA_WR_REG(SEQ_DATA_PORT, holdit & ~(SEQ_MISC_CRLOCK));

   return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\mini\pci.c ===
/*++

Copyright (c) 1993  Weitek Corporation

Module Name:

    pci.c

Abstract:

    This module contains PCI code for the Weitek P9 miniport device driver.

Environment:

    Kernel mode

Revision History may be found at the end of this file.

--*/

#include "p9.h"
#include "p9gbl.h"
#include "p9000.h"
#include "pci.h"
#include "vga.h"
#include "p91regs.h"

//
// OEM specific static data.
//

extern VOID
VLSetModeP91(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );


extern VOID VLEnableP91(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VIDEO_ACCESS_RANGE Pci9001DefDACRegRange[] =
{
     {
        RS_0_PCI_9001_ADDR,                       // Low address
        0x00000000,                     // Hi address
            0x01,                           // length
            1,                              // Is range in i/o space?
            1,                              // Range should be visible
            1                               // Range should be shareable
     },
     {
        RS_1_PCI_9001_ADDR,                           // Low address
        0x00000000,                     // Hi address
            0x01,                           // length
            1,                              // Is range in i/o space?
            1,                              // Range should be visible
            1                               // Range should be shareable
     },
     {
        RS_2_PCI_9001_ADDR,                           // Low address
        0x00000000,                     // Hi address
            0x01,                           // length
            1,                              // Is range in i/o space?
            1,                              // Range should be visible
            1                               // Range should be shareable
     },
     {
        RS_3_PCI_9001_ADDR,                           // Low address
        0x00000000,                     // Hi address
            0x01,                           // length
            1,                              // Is range in i/o space?
            1,                              // Range should be visible
            1                               // Range should be shareable
     },
     {
        RS_4_PCI_9001_ADDR,                           // Low address
        0x00000000,                     // Hi address
            0x01,                           // length
            1,                              // Is range in i/o space?
            1,                              // Range should be visible
            1                               // Range should be shareable
     },
     {
        RS_5_PCI_9001_ADDR,                           // Low address
        0x00000000,                     // Hi address
            0x01,                           // length
            1,                              // Is range in i/o space?
            1,                              // Range should be visible
            1                               // Range should be shareable
     },
     {
        RS_6_PCI_9001_ADDR,                           // Low address
        0x00000000,                     // Hi address
            0x01,                           // length
            1,                              // Is range in i/o space?
            1,                              // Range should be visible
            1                               // Range should be shareable
     },
     {
        RS_7_PCI_9001_ADDR,                           // Low address
        0x00000000,                     // Hi address
            0x01,                           // length
            1,                              // Is range in i/o space?
            1,                              // Range should be visible
            1                               // Range should be shareable
     },
     {
        RS_8_PCI_9001_ADDR,                           // Low address
        0x00000000,                     // Hi address
            0x01,                           // length
            1,                              // Is range in i/o space?
            1,                              // Range should be visible
            1                               // Range should be shareable
     },
     {
        RS_9_PCI_9001_ADDR,                           // Low address
        0x00000000,                     // Hi address
            0x01,                           // length
            1,                              // Is range in i/o space?
            1,                              // Range should be visible
            1                               // Range should be shareable
     },
     {
        RS_A_PCI_9001_ADDR,                           // Low address
        0x00000000,                     // Hi address
            0x01,                           // length
            1,                              // Is range in i/o space?
            1,                              // Range should be visible
            1                               // Range should be shareable
     },
     {
        RS_B_PCI_9001_ADDR,                           // Low address
        0x00000000,                     // Hi address
            0x01,                           // length
            1,                              // Is range in i/o space?
            1,                              // Range should be visible
            1                               // Range should be shareable
     },
     {
        RS_C_PCI_9001_ADDR,                      // Low address
        0x00000000,                     // Hi address
            0x01,                           // length
            1,                              // Is range in i/o space?
            1,                              // Range should be visible
            1                               // Range should be shareable
     },
     {
        RS_D_PCI_9001_ADDR,                      // Low address
        0x00000000,                     // Hi address
            0x01,                           // length
            1,                              // Is range in i/o space?
            1,                              // Range should be visible
            1                               // Range should be shareable
     },
     {
        RS_E_PCI_9001_ADDR,                      // Low address
        0x00000000,                     // Hi address
            0x01,                           // length
            1,                              // Is range in i/o space?
            1,                              // Range should be visible
            1                               // Range should be shareable
     },
     {
        RS_F_PCI_9001_ADDR,                      // Low address
        0x00000000,                     // Hi address
            0x01,                           // length
            1,                              // Is range in i/o space?
            1,                              // Range should be visible
            1                               // Range should be shareable
     }
};

VIDEO_ACCESS_RANGE Pci9002DefDACRegRange[] =
{
     {
        RS_0_PCI_9002_ADDR,                       // Low address
        0x00000000,                     // Hi address
            0x01,                           // length
            1,                              // Is range in i/o space?
            1,                              // Range should be visible
            1                               // Range should be shareable
     },
     {
        RS_1_PCI_9002_ADDR,                           // Low address
        0x00000000,                     // Hi address
            0x01,                           // length
            1,                              // Is range in i/o space?
            1,                              // Range should be visible
            1                               // Range should be shareable
     },
     {
        RS_2_PCI_9002_ADDR,                           // Low address
        0x00000000,                     // Hi address
            0x01,                           // length
            1,                              // Is range in i/o space?
            1,                              // Range should be visible
            1                               // Range should be shareable
     },
     {
        RS_3_PCI_9002_ADDR,                           // Low address
        0x00000000,                     // Hi address
            0x01,                           // length
            1,                              // Is range in i/o space?
            1,                              // Range should be visible
            1                               // Range should be shareable
     },
     {
        RS_4_PCI_9002_ADDR,                           // Low address
        0x00000000,                     // Hi address
            0x01,                           // length
            1,                              // Is range in i/o space?
            1,                              // Range should be visible
            1                               // Range should be shareable
     },
     {
        RS_5_PCI_9002_ADDR,                           // Low address
        0x00000000,                     // Hi address
            0x01,                           // length
            1,                              // Is range in i/o space?
            1,                              // Range should be visible
            1                               // Range should be shareable
     },
     {
        RS_6_PCI_9002_ADDR,                           // Low address
        0x00000000,                     // Hi address
            0x01,                           // length
            1,                              // Is range in i/o space?
            1,                              // Range should be visible
            1                               // Range should be shareable
     },
     {
        RS_7_PCI_9002_ADDR,                           // Low address
        0x00000000,                     // Hi address
            0x01,                           // length
            1,                              // Is range in i/o space?
            1,                              // Range should be visible
            1                               // Range should be shareable
     },
     {
        RS_8_PCI_9002_ADDR,                           // Low address
        0x00000000,                     // Hi address
            0x01,                           // length
            1,                              // Is range in i/o space?
            1,                              // Range should be visible
            1                               // Range should be shareable
     },
     {
        RS_9_PCI_9002_ADDR,                           // Low address
        0x00000000,                     // Hi address
            0x01,                           // length
            1,                              // Is range in i/o space?
            1,                              // Range should be visible
            1                               // Range should be shareable
     },
     {
        RS_A_PCI_9002_ADDR,                           // Low address
        0x00000000,                     // Hi address
            0x01,                           // length
            1,                              // Is range in i/o space?
            1,                              // Range should be visible
            1                               // Range should be shareable
     },
     {
        RS_B_PCI_9002_ADDR,                           // Low address
        0x00000000,                     // Hi address
            0x01,                           // length
            1,                              // Is range in i/o space?
            1,                              // Range should be visible
            1                               // Range should be shareable
     },
     {
        RS_C_PCI_9002_ADDR,                      // Low address
        0x00000000,                     // Hi address
            0x01,                           // length
            1,                              // Is range in i/o space?
            1,                              // Range should be visible
            1                               // Range should be shareable
     },
     {
        RS_D_PCI_9002_ADDR,                      // Low address
        0x00000000,                     // Hi address
            0x01,                           // length
            1,                              // Is range in i/o space?
            1,                              // Range should be visible
            1                               // Range should be shareable
     },
     {
        RS_E_PCI_9002_ADDR,                      // Low address
        0x00000000,                     // Hi address
            0x01,                           // length
            1,                              // Is range in i/o space?
            1,                              // Range should be visible
            1                               // Range should be shareable
     },
     {
        RS_F_PCI_9002_ADDR,                      // Low address
        0x00000000,                     // Hi address
            0x01,                           // length
            1,                              // Is range in i/o space?
            1,                              // Range should be visible
            1                               // Range should be shareable
     }
};

 /******************************************************************************
 ** bIntergraphBoard
 *
 *  PARAMETERS: HwDeviceExtension
 *
 *  DESCRIPTION:    Determine if we're trying to init an Intergraph Board
 *
 *  RETURNS:    TRUE  - if this is an Intergraph Board
 *              FALSE - if this is not an Intergraph Board
 *
 *  CREATED:    02/20/95    13:33:23
 *
 *  BY: c-jeffn
 *
 *  copyright (c) 1995, Newman Consulting
 *
 ******************************************************************************/
BOOLEAN
bIntergraphBoard(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )
{
    ULONG   ulRet;
    UCHAR   jConfig66, jOEMId, *pjOEMId;
    VP_STATUS   vpStatus;
    VIDEO_ACCESS_RANGE  AccessRange;
    BOOLEAN bRet;

    VideoDebugPrint((2, "P9!bIntergraphBoard - Entry\n"));

    // Note that the P9100 must be in native mode before this function
    // is called.

    bRet = FALSE;

    // Test to see if the P9100 indicates external io device is there
 	// If not, can't be Intergraph board

    if ( (HwDeviceExtension->p91State.ulPuConfig & P91_PUC_EXT_IO) == 0 )
        goto exit;
        	
    // Set Bit 4 of Config 66.  This will allow access to the Intergraph
    // Specific registers.

    jConfig66 = 0x10;
    ulRet = VideoPortSetBusData(HwDeviceExtension,
                                PCIConfiguration,
                                HwDeviceExtension->PciSlotNum,
                                &jConfig66,
                                0x42,
                                sizeof (UCHAR));
    if (ulRet != 1)
    {
        VideoDebugPrint((2, "P9!bIntergraphBoard - failed VideoPortSetBusData\n"));
        VideoDebugPrint((2, "\tulRet: %x\n", ulRet));
        goto exit;
    }

    //       Check P9100 register 0x208 for ID in native mode

    ulRet = P9_RD_REG(P91_EXT_IO_ID);    // Get the external io id value
	jOEMId = (UCHAR)(ulRet >> 16);		 // per Weitek programmer's manual

    if (jOEMId == 0xFE)					 // This is the id assigned to Intergraph
        bRet = TRUE;

    // Need to reset Config register 66 bit 4.

    jConfig66 = 0x00;
    ulRet = VideoPortSetBusData(HwDeviceExtension,
                                PCIConfiguration,
                                HwDeviceExtension->PciSlotNum,
                                &jConfig66,
                                0x42,
                                sizeof (UCHAR));

exit:
    VideoDebugPrint((2, "P9!bIntergraphBoard - Exit: %x\n", bRet));

    return (bRet);

}

//
//  this thing was 0. PNP forces fix since the system now put the IO
//  resources at index 1 in the VIDEO_ACCESS_RANGE returned via
//  VideoPortGetAccessRanges().
//

#define IO_ACCESS_INDEX         1
#define VGABIOS_ACCESS_INDEX    2

BOOLEAN
PciGetBaseAddr(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    Perform board detection and if present return the P9 base address.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

TRUE    - Board found, P9 and Frame buffer address info was placed in
the device extension. PCI extended base address was placed in the
device extension.

FALSE   - Board not found.

--*/
{

    VIDEO_ACCESS_RANGE  PciAccessRange[3];
    PVIDEO_ACCESS_RANGE DefaultDACRegRange;
    ULONG               ulTempAddr;
    PUCHAR              pucBiosAddr;
    PUCHAR              pucBoardAddr;
    ULONG               ulTemp;
    LONG                i;
    VP_STATUS           status;

    ULONG               wcpID;

    VideoPortZeroMemory(PciAccessRange, 3 * sizeof(VIDEO_ACCESS_RANGE));

    VideoDebugPrint((2, "PciGetbaseAddr() ENTRY\n"));

    //
    // Only the viper p9000 works on the Siemens boxes
    //

    if (HwDeviceExtension->MachineType == SIEMENS
    ||  HwDeviceExtension->MachineType == SIEMENS_P9100_VLB)
    {
        VideoDebugPrint((1, "PciGetbaseAddr() Failed, line %d\n", __LINE__));
        return FALSE;
    }

    //
    // See if the PCI HAL can locate a Weitek 9001 PCI Board.
    //

    //
    // First check for a P9100
    //

    if (PciFindDevice(HwDeviceExtension,
                      WTK_9100_ID,
                      WTK_VENDOR_ID,
                      &HwDeviceExtension->PciSlotNum))
    {
        wcpID = P9100_ID;
        HwDeviceExtension->usBusType = PCI;

        // Just a hack to get things working.
        // NOTE: !!! WE should really do the detection.

        HwDeviceExtension->p91State.bVideoPowerEnabled = FALSE;

        // Now make sure we are looking for a P9100, if were not
        // then fail.

        if (HwDeviceExtension->P9CoprocInfo.CoprocId != P9100_ID)
        {
            VideoDebugPrint((1, "Not a 9100, even though PCIFindDevice() thinks it is\n"));
            return(FALSE);
        }

#ifdef	_MIPS_
                //
                // SNI platform recognition and specific stuff
                //
        {

        extern VP_STATUS                GetCPUIdCallback(
               PVOID                    HwDeviceExtension,
               PVOID                    Context,
               VIDEO_DEVICE_DATA_TYPE   DeviceDataType,
               PVOID                    Identifier,
               ULONG                    IdentifierLength,
               PVOID                    ConfigurationData,
               ULONG                    ConfigurationDataLength,
               PVOID                    ComponentInformation,
               ULONG                    ComponentInformationLength
		);
        if(VideoPortIsCpu(L"RM200PCI")
        || VideoPortIsCpu(L"RM300PCI")
        || VideoPortIsCpu(L"RM300PCI MP")
        || VideoPortIsCpu(L"RM400PCI")
        || VideoPortIsCpu(L"RM4x0PCI"))
                {
                // adjust the VGA physical address with the E/ISA I/O space
                DriverAccessRanges[1].RangeStart.LowPart += 0x14000000 ;
                        HwDeviceExtension->MachineType = SIEMENS_P9100_PCi;
                }
        }
#endif
    }
    else if (PciFindDevice(HwDeviceExtension,
                      WTK_9001_ID,
                      WTK_VENDOR_ID,
                      &HwDeviceExtension->PciSlotNum))
    {
        wcpID = P9000_ID;

        // Now make sure we are looking for a P9000, if were not
        // then fail.

        if (HwDeviceExtension->P9CoprocInfo.CoprocId != P9000_ID)
        {
            VideoDebugPrint((1, "PciGetbaseAddr() Failed !P9000, line %d\n", __LINE__));
            return(FALSE);
        }
        VideoDebugPrint((2, "PciGetbaseAddr() This is a P900X\n"));

        //
        // Read the config space to determine if
        // this is Rev 1 or 2. This will determine at which addresses
        // the DAC registers are mapped.
        //

        if (!VideoPortGetBusData(HwDeviceExtension,
                                 PCIConfiguration,
                                 HwDeviceExtension->PciSlotNum,
                                 &ulTemp,
                                 P9001_REV_ID,
                                 sizeof(ulTemp)))
        {
            VideoDebugPrint((1, "PciGetbaseAddr() Failed, DAC weirdness, line %d\n", __LINE__));
            return(FALSE);
        }

        //
        // Got the 9001 rev id. Choose the appropriate table of DAC register
        // addresses.
        //

        switch((UCHAR) (ulTemp))
        {
            case 1 :
                VideoDebugPrint((2, "PciGetbaseAddr(), DAC id is 1\n"));
                //
                // This is a Rev 1 9001, which uses the standard VL DAC
                // Addresses. All known rev 1 implementations use the
                // Weitek 5286 VGA chip.
                //

                DefaultDACRegRange = VLDefDACRegRange;
                HwDeviceExtension->AdapterDesc.bWtk5x86 = TRUE;
                break;

            case 2 :
            default:
                VideoDebugPrint((2, "PciGetbaseAddr(), DAC id is 2 or default\n"));
                //
                // This is a Rev 2 9001. Set up the table of DAC register
                // offsets accordingly.
                //

                DefaultDACRegRange = Pci9001DefDACRegRange;

                //
                // A Rev 2 9001 is present. Get the BIOS ROM address from the
                // PCI configuration space so we can do a ROM scan to
                // determine if this is a Viper PCI adapter.
                //

                PciAccessRange[IO_ACCESS_INDEX].RangeStart.LowPart = 0;
                PciAccessRange[IO_ACCESS_INDEX].RangeStart.HighPart = 0;

                if (VideoPortGetBusData(HwDeviceExtension,
                                        PCIConfiguration,
                                        HwDeviceExtension->PciSlotNum,
                                        &PciAccessRange[IO_ACCESS_INDEX].RangeStart.LowPart,
                                        P9001_BIOS_BASE_ADDR,
                                        sizeof(ULONG)) == 0)
                {
                    VideoDebugPrint((1, "PciGetbaseAddr() Failed. ROM bios not P9001, line %d\n", __LINE__));
                    return FALSE;
                }

                if (PciAccessRange[IO_ACCESS_INDEX].RangeStart.LowPart)
                {
                    //
                    // We found an address for the BIOS.  Verify it.
                    //
                    // Set up the access range so we can map out the BIOS ROM
                    // space. This will allow us to scan the ROM and detect the
                    // presence of a Viper PCI adapter.
                    //

                    PciAccessRange[IO_ACCESS_INDEX].RangeInIoSpace = FALSE;
                    PciAccessRange[IO_ACCESS_INDEX].RangeVisible = TRUE;
                    PciAccessRange[IO_ACCESS_INDEX].RangeShareable = TRUE;
                    PciAccessRange[IO_ACCESS_INDEX].RangeLength = 0x1000;

                    //
                    // Check to see if another miniport driver has allocated the
                    // BIOS' memory space.
                    //

                    if (VideoPortVerifyAccessRanges(HwDeviceExtension,
                                                    1L,
                                                    PciAccessRange) != NO_ERROR)
                    {
                        PciAccessRange[IO_ACCESS_INDEX].RangeStart.LowPart = 0;
                    }
                }


                if (PciAccessRange[IO_ACCESS_INDEX].RangeStart.LowPart == 0)
                {
                    status = VideoPortGetAccessRanges(HwDeviceExtension,
                                                      0,
                                                      NULL,
                                                      3,
                                                      PciAccessRange,
                                                      NULL,
                                                      NULL,
                                                      &HwDeviceExtension->PciSlotNum);

                    if (status != NO_ERROR)
                    {
                        VideoDebugPrint((1, "PciGetbaseAddr() Failed, GetAccessRanges(), line %d, status:%x\n", __LINE__, status));
                        return(FALSE);
                    }
                }

                //
                // Map in the BIOS' memory space. If it can't be mapped,
                // return an error.
                //

                PciAccessRange[VGABIOS_ACCESS_INDEX].RangeStart.LowPart  = 0xC0000;
                PciAccessRange[VGABIOS_ACCESS_INDEX].RangeStart.HighPart = 0x0000;
                PciAccessRange[VGABIOS_ACCESS_INDEX].RangeLength         = BIOS_RANGE_LEN;
                PciAccessRange[VGABIOS_ACCESS_INDEX].RangeInIoSpace      = FALSE;

                VideoDebugPrint((1, "PciGetbaseAddr() about to get BIOS address, line %d, status:%x\n", __LINE__, status));
                if ((pucBiosAddr =
                        VideoPortGetDeviceBase(HwDeviceExtension,
                                               PciAccessRange[VGABIOS_ACCESS_INDEX].RangeStart,
                                               PciAccessRange[VGABIOS_ACCESS_INDEX].RangeLength,
                                               PciAccessRange[VGABIOS_ACCESS_INDEX].RangeInIoSpace)) == 0)
                {
                    VideoDebugPrint((1, "PciGetbaseAddr() Failed on VGA bios, line %d\n", __LINE__));
                    return(FALSE);
                }

                //
                // Enable the Adapter BIOS.
                //

                ulTemp = PciAccessRange[VGABIOS_ACCESS_INDEX].RangeStart.LowPart | PCI_BIOS_ENB;

                VideoDebugPrint((1, "PciGetbaseAddr() about to enable bios, line %d, status:%x\n", __LINE__, status));
                VideoPortSetBusData(HwDeviceExtension,
                                    PCIConfiguration,
                                    HwDeviceExtension->PciSlotNum,
                                    &ulTemp,
                                    P9001_BIOS_BASE_ADDR,
                                    sizeof(ULONG));

                VideoDebugPrint((1, "PciGetbaseAddr() about to scan rom, line %d, status:%x\n", __LINE__, status));
                if (VideoPortScanRom(HwDeviceExtension,
                                     pucBiosAddr,
                                     BIOS_RANGE_LEN,
                                     VIPER_ID_STR))
                {
                    //
                    // A Viper PCI is present, use the Viper set mode,
                    // enable/disable video function pointers, and clk
                    // divisor values. Also, Viper PCI does not
                    // use a Weitek VGA.
                    //

                    HwDeviceExtension->AdapterDesc.OEMSetMode = ViperSetMode;
                    HwDeviceExtension->AdapterDesc.P9EnableVideo =
                        ViperPciP9Enable;
                    HwDeviceExtension->AdapterDesc.P9DisableVideo =
                        ViperPciP9Disable;
                    HwDeviceExtension->AdapterDesc.iClkDiv = 4;
                    HwDeviceExtension->AdapterDesc.bWtk5x86 = FALSE;
                }
                else
                {
                    //
                    // All non-Viper Rev 2 implementations use a Weitek
                    // 5286 VGA chip.
                    //

                    HwDeviceExtension->AdapterDesc.bWtk5x86 = TRUE;

                }

                //
                // Restore the BIOS register to it's original value.
                //

                VideoDebugPrint((1, "PciGetbaseAddr() about to restore, line %d, status:%x\n", __LINE__, status));
                VideoPortSetBusData(HwDeviceExtension,
                                    PCIConfiguration,
                                    HwDeviceExtension->PciSlotNum,
                                    &ulTempAddr,
                                    P9001_BIOS_BASE_ADDR,
                                    sizeof(ULONG));

                VideoPortFreeDeviceBase(HwDeviceExtension, (PVOID) pucBiosAddr);

                break;
        }

    }
    else if (PciFindDevice(HwDeviceExtension,   // Search for a Weitek 9002.
                           WTK_9002_ID,
                           WTK_VENDOR_ID,
                           &HwDeviceExtension->PciSlotNum))
    {
        wcpID = P9000_ID;

        // Now make sure we are looking for a P9000, if were not
        // then fail.

        if (HwDeviceExtension->P9CoprocInfo.CoprocId != P9000_ID)
        {
            VideoDebugPrint((1, "PciGetbaseAddr() Failed, not a P9002, line %d\n", __LINE__));
            return(FALSE);
        }

        //
        // Found a 9002 board. Set up the table of DAC addresses
        // accordingly.
        //

        DefaultDACRegRange = Pci9002DefDACRegRange;
    }
    else
    {
        //
        // No Weitek PCI devices were found, return an error.
        //

        VideoDebugPrint((1, "PciGetbaseAddr() Failed, line %d\n", __LINE__));
        return(FALSE);
    }

    //
    // Get the base address of the adapter.
    // Some machines rely on the address not changing - if the address changes
    // the machine randomly appears to corrupt memory.
    // So use the pre-configured address if it is available.
    //

    HwDeviceExtension->P9PhysAddr.LowPart = 0;

    VideoPortGetBusData(HwDeviceExtension,
                        PCIConfiguration,
                        HwDeviceExtension->PciSlotNum,
                        &HwDeviceExtension->P9PhysAddr.LowPart,
                        P9001_BASE_ADDR,
                        sizeof(ULONG));

    if (HwDeviceExtension->P9PhysAddr.LowPart == 0)
    {
        IO_RESOURCE_DESCRIPTOR ioResource = {
            IO_RESOURCE_PREFERRED,
            CmResourceTypeMemory,
            CmResourceShareDeviceExclusive,
            0,
            CM_RESOURCE_MEMORY_READ_WRITE,
            0,
            {
              RESERVE_PCI_ADDRESS_SPACE,  // Length
              RESERVE_PCI_ADDRESS_SPACE,  // Alignment
              { 0x10000000, 0 },          // Minimum start address
              { 0xefffffff, 0}            // Maximum end address
            }
        };

        status = VideoPortGetAccessRanges(HwDeviceExtension,
                                          1,
                                          &ioResource,
                                          3,
                                          PciAccessRange,
                                          NULL,
                                          NULL,
                                          &HwDeviceExtension->PciSlotNum);

        if (status == NO_ERROR)
        {
            HwDeviceExtension->P9PhysAddr = PciAccessRange[IO_ACCESS_INDEX].RangeStart;

            //
            // Save the physical base address in the PCI config space.
            //

            VideoPortSetBusData(HwDeviceExtension,
                                PCIConfiguration,
                                HwDeviceExtension->PciSlotNum,
                                &HwDeviceExtension->P9PhysAddr.LowPart,
                                P9001_BASE_ADDR,
                                sizeof(ULONG));
        }
    }

    if (HwDeviceExtension->P9PhysAddr.LowPart == 0)
    {
        VideoDebugPrint((1, "PciGetbaseAddr() Failed, line %d\n", __LINE__));
        return(FALSE);
    }

    //
    // The P9100 can access the DAC directly, so no I/O space needs to be
    // allocated for DAC access.
    //

    if (wcpID == P9000_ID)
    {
        status = VideoPortGetAccessRanges(HwDeviceExtension,
                                          0,
                                          NULL,
                                          3,
                                          PciAccessRange,
                                          NULL,
                                          NULL,
                                          &HwDeviceExtension->PciSlotNum);

        if (status == NO_ERROR)
        {
            HwDeviceExtension->P9001PhysicalAddress = PciAccessRange[IO_ACCESS_INDEX].RangeStart;
        }
        else
        {
            VideoDebugPrint((1, "VideoPortGetAccessRanges() Failed with status %x, line %d\n", status, __LINE__));
            return(FALSE);
        }

        //
        // If this is a 9002 board, map in and read the VGA id register.
        //

        if (DefaultDACRegRange == Pci9002DefDACRegRange)
        {
            //
            // Set up the access range so we can map out the VGA ID register.
            //

            PciAccessRange[IO_ACCESS_INDEX].RangeInIoSpace      = TRUE;
            PciAccessRange[IO_ACCESS_INDEX].RangeVisible        = TRUE;
            PciAccessRange[IO_ACCESS_INDEX].RangeShareable      = TRUE;
            PciAccessRange[IO_ACCESS_INDEX].RangeLength         = 1;

            PciAccessRange[IO_ACCESS_INDEX].RangeStart          =
                HwDeviceExtension->P9001PhysicalAddress;
            PciAccessRange[IO_ACCESS_INDEX].RangeStart.LowPart += P9002_VGA_ID;

            //
            // Map in the VGA ID register. If it can't be mapped,
            // we can't determine the VGA type, so just use the default.
            //

            if ((pucBoardAddr =
                    VideoPortGetDeviceBase(HwDeviceExtension,
                                           PciAccessRange[IO_ACCESS_INDEX].RangeStart,
                                           PciAccessRange[IO_ACCESS_INDEX].RangeLength,
                                           PciAccessRange[IO_ACCESS_INDEX].RangeInIoSpace)) != 0)
            {
                HwDeviceExtension->AdapterDesc.bWtk5x86 =
                    (UCHAR)((VideoPortReadPortUchar(pucBoardAddr) & VGA_MSK) == WTK_VGA);

                VideoPortFreeDeviceBase(HwDeviceExtension,
                                        (PVOID) pucBoardAddr);
            }
            else
            {
                //
                // Assume this is a 5x86 VGA.
                //

                HwDeviceExtension->AdapterDesc.bWtk5x86 = TRUE;
            }
        }

        //
        // Compute the actual DAC register addresses relative to the PCI
        // base address.
        //

        for (i = 0; i < HwDeviceExtension->Dac.cDacRegs; i++)
        {
            //
            // If this is not a palette addr or data register, and the board
            // is not using the standard VL addresses, compute the register
            // address relative to the register base address.
            //

            if ((i > 3) && (DefaultDACRegRange != VLDefDACRegRange))
            {
                DefaultDACRegRange[i].RangeStart.LowPart +=
                    HwDeviceExtension->P9001PhysicalAddress.LowPart;

            }
        }

        //
        // Copy the DAC register access range into the global list of access
        // ranges.
        //

        VideoPortMoveMemory(&DriverAccessRanges[NUM_DRIVER_ACCESS_RANGES],
                            DefaultDACRegRange,
                            sizeof(VIDEO_ACCESS_RANGE) *
                            HwDeviceExtension->Dac.cDacRegs);

        //
        // This is a hack. Initialize an additional access range to map out
        // the entire 4K range of contiguous IO space starting at PCI_REG_BASE.
        // apparently the 9001 decodes accesses over this entire range rather
        // than the individual register offsets within this range.
        //
        //
        // Set up the access range so we can map the entire 4k IO range.
        //

        PciAccessRange[IO_ACCESS_INDEX].RangeInIoSpace = TRUE;
        PciAccessRange[IO_ACCESS_INDEX].RangeVisible   = TRUE;
        PciAccessRange[IO_ACCESS_INDEX].RangeShareable = TRUE;
        PciAccessRange[IO_ACCESS_INDEX].RangeLength    = P9001_IO_RANGE;
        PciAccessRange[IO_ACCESS_INDEX].RangeStart     = HwDeviceExtension->P9001PhysicalAddress;

        VideoDebugPrint((1, "PciAccessRange[VGABIOS_ACCESS_INDEX].RangeStart.LowPart:%x\n",
                             PciAccessRange[VGABIOS_ACCESS_INDEX].RangeStart.LowPart));

        VideoPortMoveMemory(&DriverAccessRanges[NUM_DRIVER_ACCESS_RANGES +
                                                NUM_DAC_ACCESS_RANGES],
                            &PciAccessRange[IO_ACCESS_INDEX],
                            sizeof(VIDEO_ACCESS_RANGE));

    } // end of "if (wcpID == P9000_ID)" block.

    return(TRUE);

}


BOOLEAN
PciFindDevice(
    IN      PHW_DEVICE_EXTENSION    HwDeviceExtension,
    IN      USHORT                  usDeviceId,
    IN      USHORT                  usVendorId,
    IN OUT  PULONG                  pulSlotNum
    )

/*++

Routine Description:

    Attempts to find a PCI device which matches the passed device id, vendor
    id and index.

Arguments:

    HwDeviceExtension - Pointer to the device extension.
    usDeviceId - PCI Device Id.
    usVendorId - PCI Vendor Id.
    pulSlotNum - Input -> Starting Slot Number
                 Output -> If found, the slot number of the matching device.

Return Value:

    TRUE if device found.

--*/
{
    ULONG   pciBuffer;
    PCI_SLOT_NUMBER slotData;
    PPCI_COMMON_CONFIG  pciData;

    //
    //
    // typedef struct _PCI_SLOT_NUMBER {
    //     union {
    //         struct {
    //             ULONG   DeviceNumber:5;
    //             ULONG   FunctionNumber:3;
    //             ULONG   Reserved:24;
    //         } bits;
    //         ULONG   AsULONG;
    //     } u;
    // } PCI_SLOT_NUMBER, *PPCI_SLOT_NUMBER;
    //

    slotData.u.AsULONG = 0;

    pciData = (PPCI_COMMON_CONFIG) &pciBuffer;

    //
    // Look at each device.
    //

    *pulSlotNum = 0;

    slotData.u.bits.DeviceNumber = *pulSlotNum;

    slotData.u.bits.FunctionNumber = 0;

    if (VideoPortGetBusData(HwDeviceExtension,
                            PCIConfiguration,
                            slotData.u.AsULONG,
                            (PVOID) pciData,
                            0,
                            sizeof(ULONG)) == 0)
    {
        //
        // Out of functions. Go to next PCI bus.
        //

        return(FALSE);
    }


    if (pciData->VendorID == PCI_INVALID_VENDORID)
    {
        //
        // No PCI device, or no more functions on device
        // move to next PCI device.
        //

        return(FALSE);
    }


    if (pciData->VendorID == usVendorId &&
        pciData->DeviceID == usDeviceId)
    {
        *pulSlotNum = slotData.u.AsULONG;
        return(TRUE);
    }

    //
    // No matching PCI device was found.
    //

    return(FALSE);
}


BOOLEAN
PciP9MemEnable(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

Enable the physical memory and IO resources for PCI adapters.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    None.

--*/

{
   ULONG    ulTemp;

    //
    // Read the PCI command register to determine if the memory/io
    // resources are enabled. If not, enable them.
    //

    if (!VideoPortGetBusData(HwDeviceExtension,
                             PCIConfiguration,
                             HwDeviceExtension->PciSlotNum,
                             &ulTemp,
                             P9001_CMD_REG,
                             sizeof(ulTemp)))
    {
        return(FALSE);
    }
    else if (!(ulTemp & (P9001_MEM_ENB | P9001_IO_ENB)))
    {
        ulTemp |= (P9001_MEM_ENB | P9001_IO_ENB);

        if (!VideoPortSetBusData(HwDeviceExtension,
                                 PCIConfiguration,
                                 HwDeviceExtension->PciSlotNum,
                                 &ulTemp,
                                 P9001_CMD_REG,
                                 sizeof(ulTemp)))
        {
            return(FALSE);
        }
    }
    return(TRUE);
}


VOID
ViperPciP9Enable(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

Perform the OEM specific tasks necessary to enable the P9. These
include memory mapping, setting the sync polarities, and enabling the
P9 video output.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    None.

--*/

{

    USHORT  holdit;

    //
    // Select external frequency, and clear the polarity bits.
    //

    holdit = VGA_RD_REG(MISCIN) | (MISCD | MISCC);
    holdit &= ~(VIPER_HSYNC_POL_MASK | VIPER_VSYNC_POL_MASK);

    //
    // Viper controls h and v sync polarities independently.
    //

    if (HwDeviceExtension->VideoData.vp == POSITIVE)
    {
        holdit |= VIPER_VSYNC_POL_MASK;
    }

    if (HwDeviceExtension->VideoData.hp == POSITIVE)
    {
        holdit |= VIPER_HSYNC_POL_MASK;
    }

    VGA_WR_REG(MISCOUT, holdit);

    //
    // If this is a Weitek VGA, unlock the VGA.
    //

    if (HwDeviceExtension->AdapterDesc.bWtk5x86)
    {
        UnlockVGARegs(HwDeviceExtension);
    }

    //
    // Enable P9 Video.
    //

    VGA_WR_REG(SEQ_INDEX_PORT, SEQ_OUTCNTL_INDEX);
    VGA_WR_REG(SEQ_DATA_PORT, (VGA_RD_REG(SEQ_DATA_PORT)) | P9_VIDEO_ENB);

    //
    // If this is a Weitek VGA, lock the VGA sequencer registers.
    //

    if (HwDeviceExtension->AdapterDesc.bWtk5x86)
    {
        LockVGARegs(HwDeviceExtension);
    }

    return;
}


BOOLEAN
ViperPciP9Disable(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:


Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.
    pPal - Pointer to the array of pallete entries.
    StartIndex - Specifies the first pallete entry provided in pPal.
    Count - Number of palette entries in pPal

Return Value:

    TRUE, indicating no int10 is needed to complete the switch

--*/

{

    //
    //  Unlock the VGA extended regs to disable P9 video output.
    //

    //
    // If this is a Weitek VGA, unlock the VGA.
    //

    if (HwDeviceExtension->AdapterDesc.bWtk5x86)
    {
        UnlockVGARegs(HwDeviceExtension);
    }

    VGA_WR_REG(SEQ_INDEX_PORT, SEQ_OUTCNTL_INDEX);
    VGA_WR_REG(SEQ_DATA_PORT, (VGA_RD_REG(SEQ_DATA_PORT)) & P9_VIDEO_DIS);

    //
    // Restore clock select bits.
    //

    VGA_WR_REG(MISCOUT, HwDeviceExtension->MiscRegState);

    //
    // If this is a Weitek VGA, lock the VGA sequencer registers.
    //

    if (HwDeviceExtension->AdapterDesc.bWtk5x86)
    {
        LockVGARegs(HwDeviceExtension);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\mini\viper.h ===
/*++

Copyright (c) 1993  Weitek Corporation

Module Name:

    viper.h

Abstract:

    This module contains definitions for the Diamond Viper VL board.

Environment:

    Kernel mode

Revision History may be found at the end of this file.

--*/

//
// Viper uses the same DAC addresses as the Weitek VL cards.
//

extern  VIDEO_ACCESS_RANGE VLDefDACRegRange[];

//
// Default memory base address for the Viper.
//

#define MemBase         0x80000000

//
// Bit to write to the sequencer control register to enable/disable P9
// video output.
//

#define P9_VIDEO_ENB   0x10
#define P9_VIDEO_DIS   ~P9_VIDEO_ENB


//
// Define the bits in the sequencer control register which determine
// H and V sync polarties. For Viper, 1 = negative.
//

#define HSYNC_POL_MASK  0x20
#define VSYNC_POL_MASK  0x40
#define POL_MASK        (HSYNC_POL_MASK | VSYNC_POL_MASK)

//
// Bit to in the sequencer control register to enable VGA output
// for the Viper board.
//

#define VGA_VIDEO_ENB     0x80
#define VGA_VIDEO_DIS     ~VGA_VIDEO_ENB

//
// These defines represents the values to be written to the
// VGA sequencer control register for the possible memory mappings for
// the Diamond Viper board. Whew!
//

#define MEM_DISABLED 0x00
#define MEM_AXXX     0x01
#define MEM_2XXX     0x02
#define MEM_8XXX     0x03

//
// Value to mask off the memory address select bits in the sequencer
// control register.
//

#define ADDR_SLCT_MASK ~0x03

//
// Defines used to scan the VGA ROM in order to auto-detect a Viper card.
//

#define VIPER_VL_ID_STR    "VIPER"
#define VIPER_ID_STR    "VIPER"
#define VGA_BIOS_ADDR   0xC0000L
#define VGA_BIOS_LEN   0x8000L
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\mini\p9gbl.h ===
/*++

Copyright (c) 1993  Weitek Corporation

Module Name:

    p9gbl.h

Abstract:

    This module contains external definitions of the global data used by the
    Weitek P9 miniport device driver.

Environment:

    Kernel mode

Revision History may be found at the end of this file.

--*/

//
// Number of adapter types that this driver supports.
//

#define NUM_OEM_ADAPTERS    8

//
// DAC data structures for all DACs supported by this driver.
//

extern  DAC Bt485;
extern  DAC P91Bt485;
extern  DAC P91Bt489;
extern  DAC Ibm525;

//
// P9 Coprocessor Info structures for all P9 family coprocessors supported
// by this driver.
//

extern  P9_COPROC   P9000Info;
extern  P9_COPROC   P9100Info;

//
// DriverAccessRanges are used to verify access to the P9 coprocessor and
// VGA registers.
//

#define NUM_DRIVER_ACCESS_RANGES    2
#define NUM_DAC_ACCESS_RANGES       16
#define NUM_MISC_ACCESS_RANGES      3

extern VIDEO_ACCESS_RANGE DriverAccessRanges[NUM_DRIVER_ACCESS_RANGES +
                                                NUM_DAC_ACCESS_RANGES +
                                                NUM_MISC_ACCESS_RANGES];

//
// P9 mode information Tables.
//

extern P9INITDATA P9Modes[mP9ModeCount];

//
// The structure containing Access Ranges for the DAC registers.
//

extern VIDEO_ACCESS_RANGE  DACRegisterAccessRange[];

//
// List of P9 adapters.
//

extern P9ADAPTER    OEMAdapter[NUM_OEM_ADAPTERS];

//
// Global data defined in P9GBL.C.
//

extern  ULONG   ulStrtScan;
extern  ULONG   ulCurScan;


//
// Global Function Prototypes.
//

//
// Misc. function prototypes defined in P9GBL.C.
//

long mul32(
    short op1,
    short op2
    );

int div32(
    long op1,
    short op2
    );

//
// P9000 specific function prototypes defined in P9000.C.
//

VOID
Init8720(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
WriteTiming(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
SysConf(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
P9000SizeMem(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

//
// P9100 specific function prototypes defined in P91supp.c
//

VOID
P91SizeVideoMemory(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );


//
// VGA specific function prototypes defined in VGA.C.
//

VOID
LockVGARegs(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
UnlockVGARegs(
    PHW_DEVICE_EXTENSION HwDeviceExtension
     );

//
// Clock generator function prototype.
//

VOID
DevSetClock(
        PHW_DEVICE_EXTENSION HwDeviceExtension,
        USHORT usFrequency,
        BOOLEAN bSetMemclk,
        BOOLEAN bUseClockDoubler
        );

//
// PCI function prototypes defined in PCI.C.
//

BOOLEAN
PciGetBaseAddr(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

BOOLEAN
PciP9MemEnable(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
ViperPciP9Enable(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

BOOLEAN
ViperPciP9Disable(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

//
// Weitek P9000 VL specific function prototypes defined in WTKP90VL.C
//

BOOLEAN
VLGetBaseAddr(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
VLEnableP9(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

BOOLEAN
VLDisableP9(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
VLSetMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

BOOLEAN
VLP90CoprocDetect(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG   ulCoprocPhyAddr
    );

//
// Diamond Viper specific function prototypes defined in WTKP90VL.C
//

BOOLEAN
ViperGetBaseAddr(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
ViperSetMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
ViperEnableP9(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

BOOLEAN
ViperDisableP9(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

BOOLEAN
ViperEnableMem(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

//
// Weitek P9100 VL specific function prototypes defined in WTKP91VL.C
//

VOID
VLSetModeP91(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );


VOID VLEnableP91(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

BOOLEAN
VLDisableP91(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );


BOOLEAN
VLGetBaseAddrP91(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\mini\wtkp91vl.c ===
/*++

Copyright (c) 1993, 1994  Weitek Corporation

Module Name:

    wtkp91vl.c

Abstract:

    This module contains OEM specific functions for the Weitek P9100
    VL evaluation board.

Environment:

    Kernel mode

Revision History may be found at the end of this file.

--*/


#include "p9.h"
#include "p9gbl.h"
#include "wtkp9xvl.h"
#include "bt485.h"
#include "vga.h"
#include "p91regs.h"
#include "p91dac.h"
#include "pci.h"
#include "p9000.h"


/***********************************************************************
 *
 **********************************************************************/
VOID vDumpPCIConfig(PHW_DEVICE_EXTENSION HwDeviceExtension,
                    PUCHAR psz)
{
    ULONG   i, j;
    ULONG   ulPciData[64];

    VideoDebugPrint((1, "\n%s\n", psz));


    VideoPortGetBusData(HwDeviceExtension,
                             PCIConfiguration,
                             HwDeviceExtension->PciSlotNum,
                             (PVOID) ulPciData,
                             0,
                             sizeof(ulPciData));

    for (i = 0, j = 0; i < (64 / 4); i++)
    {
        VideoDebugPrint((1,
                "0x%04.4x\t %08.8x, %08.8x, %08.8x, %08.8x\n",
                j * sizeof(ULONG),
                ulPciData[j], ulPciData[j+1],
                ulPciData[j+2], ulPciData[j+3]));

        j += 4;
    }
}




BOOLEAN
VLGetBaseAddrP91(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    Perform board detection and if present return the P9100 base address.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

TRUE    - Board found, P9100 and Frame buffer address info was placed in
the device extension.

FALSE   - Board not found.

--*/
{
    VP_STATUS           status;
    VIDEO_ACCESS_RANGE  VLAccessRange;
    USHORT              usTemp;


    VideoDebugPrint((1, "VLGetBaseAddrP91 - Entry\n"));

    //
    // Only the viper p9000 works on the Siemens boxes
    //

    if (HwDeviceExtension->MachineType == SIEMENS)
    {
        return FALSE;
    }

    //
    // Always use the defined address for the p9100
    //

    if (HwDeviceExtension->MachineType != SIEMENS_P9100_VLB)
    {
        HwDeviceExtension->P9PhysAddr.LowPart = MemBase;
    }

    //
    // Set the bus-type for accessing the VLB configuration space...
    //

    HwDeviceExtension->usBusType = VESA;

    //
    // Now, detect the board
    //

    //
    //
    // OEM Notice:
    //
    // Here we assume that the configuration space will always
    // be mapped to 0x9100 for VL cards. Since this is determined
    // by pull-down resistors on the VL cards this is probably
    // a safe assumption. If anyone decides to use a different
    // address then we should scan for the P9100 chip. The danger
    // with scanning is that it is potentially destructive.
    //
    // Note that we cannot read the power-up configuration register
    // until we setup addressability for the VESA local bus adapter.
    //
    // Also, on VESA LB you must read the VL configuration registers
    // using byte port reads.
    //

    VLAccessRange.RangeInIoSpace      = TRUE;
    VLAccessRange.RangeVisible        = TRUE;
    VLAccessRange.RangeShareable      = TRUE;
    VLAccessRange.RangeStart.LowPart  = P91_CONFIG_INDEX;

    if (HwDeviceExtension->MachineType == SIEMENS_P9100_VLB)
    {
        VLAccessRange.RangeStart.LowPart |=
                ((DriverAccessRanges[1].RangeStart.LowPart & 0xff000000)) ;
    }

    VLAccessRange.RangeStart.HighPart = 0;
    VLAccessRange.RangeLength         = P91_CONFIG_CKSEL+1;


    if (VideoPortVerifyAccessRanges(HwDeviceExtension,
                                    1,
                                    &VLAccessRange) != NO_ERROR)
    {
       return(FALSE);
    }

    VideoDebugPrint((1, "VLGetBaseAddrP91: RangeStart = %lx\n",
                         VLAccessRange.RangeStart));

    VideoDebugPrint((1, "VLGetBaseAddrP91: RangeLength = %lx\n",
                         VLAccessRange.RangeLength));

    if ((HwDeviceExtension->ConfigAddr =
            VideoPortGetDeviceBase(HwDeviceExtension,
                                   VLAccessRange.RangeStart,
                                   VLAccessRange.RangeLength,
                                   VLAccessRange.RangeInIoSpace)) == 0)
    {

      return(FALSE);

    }

    // Verify that we can write to the index registers...
    //

    VideoPortWritePortUchar(
          (PUCHAR) HwDeviceExtension->ConfigAddr, 0x55);

    if (VideoPortReadPortUchar(
            (PUCHAR) HwDeviceExtension->ConfigAddr) != 0x55)
    {
        VideoDebugPrint((1, "VLGetBaseAddrP91: Could not access VESA LB Config space!\n"));
        VideoDebugPrint((1, "VLGetBaseAddrP91: Wrote: 0x55, Read: %lx\n",
        VideoPortReadPortUchar((PUCHAR) HwDeviceExtension->ConfigAddr)));
        return(FALSE);
    }

    //
    // Verify Vendor ID...
    //

    usTemp  = ReadP9ConfigRegister(HwDeviceExtension,
                                     P91_CONFIG_VENDOR_HIGH) << 8;

    usTemp |= ReadP9ConfigRegister(HwDeviceExtension,
                                     P91_CONFIG_VENDOR_LOW);

    if (usTemp != WTK_VENDOR_ID)
    {
        VideoDebugPrint((1, "Invalid Vendor ID: %x\n", usTemp));
        return(FALSE);
    }

    //
    // Verify Device ID...
    //

    usTemp  = ReadP9ConfigRegister(HwDeviceExtension,
                                     P91_CONFIG_DEVICE_HIGH) << 8;
    usTemp |= ReadP9ConfigRegister(HwDeviceExtension,
                                     P91_CONFIG_DEVICE_LOW);

    if (usTemp !=  WTK_9100_ID)
    {
        VideoDebugPrint((1, "Invalid Device ID: %x\n", usTemp));
        return(FALSE);
    }

    //
    // Now program the P9100 to respond to the requested physical address...
    //

    if (HwDeviceExtension->MachineType != SIEMENS_P9100_VLB)
    {
       WriteP9ConfigRegister(HwDeviceExtension, P91_CONFIG_WBASE,
        (UCHAR)(((HwDeviceExtension->P9PhysAddr.LowPart >> 24) & 0xFF)));
    }
    else
    {
        //
        // The physical address base put on the VL-bus (in its memory space)
        // is always set to zero by the FirmWare (in the MapVLBase register).
        //

        WriteP9ConfigRegister (HwDeviceExtension ,P91_CONFIG_WBASE ,0) ;

    }


    VideoDebugPrint((1, "VLGetBaseAddrP91: Found a P9100 VLB Adapter!\n"));
    return(TRUE);
}


VOID
VLSetModeP91(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    This routine sets the video mode. Different OEM adapter implementations
    require that initialization operations be performed in a certain
    order. This routine uses the standard order which addresses most
    implementations (VL, Ajax, Weitek PCI, Tulip).

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    None.

--*/

{
    VideoDebugPrint((2, "VLSetModeP91 - Entry\n"));

    //
    // Enable P9100 video if not already enabled.
    //

    if (!HwDeviceExtension->p91State.bEnabled)
        HwDeviceExtension->AdapterDesc.P9EnableVideo(HwDeviceExtension);

    //
    // If this mode uses the palette, clear it to all 0s.
    //

    if (P9Modes[HwDeviceExtension->CurrentModeNumber].modeInformation.AttributeFlags
        & VIDEO_MODE_PALETTE_DRIVEN)
    {
        HwDeviceExtension->Dac.DACClearPalette(HwDeviceExtension);
    }

    VideoDebugPrint((2, "VLSetModeP91 - Exit\n"));


} // End of VLSetModeP91()


VOID
VLEnableP91(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

    Routine Description:

        Perform the OEM specific tasks necessary to enable P9100 Video. These
        include memory mapping, setting the sync polarities, and enabling the
        P9100 video output.

    Arguments:

        HwDeviceExtension - Pointer to the miniport driver's device extension.

    Return Value:

        None.

--*/

{
    USHORT usMemClkInUse;

    VideoDebugPrint((2, "VLEnableP91 - Entry\n"));

    //
    // Enable native mode to: No RAMDAC shadowing, memory & I/O enabled.
    //

    if (HwDeviceExtension->usBusType == VESA)
    {
        WriteP9ConfigRegister(HwDeviceExtension, P91_CONFIG_CONFIGURATION, 3);
    }

    WriteP9ConfigRegister(HwDeviceExtension, P91_CONFIG_MODE, 0); // Native mode

    //
    // Only initialize the P9100 once...
    //

    if (!HwDeviceExtension->p91State.bInitialized)
    {

        HwDeviceExtension->p91State.bInitialized = TRUE;

        //
        // Now read the power-up configuration register to determine the actual
        // board-options.
        //

        HwDeviceExtension->p91State.ulPuConfig = P9_RD_REG(P91_PU_CONFIG);

#if 0
        vDumpPCIConfig(HwDeviceExtension, "VLEnableP91, just after reading P91_PU_CONFIG");
#endif
        //
        // Determine the VRAM type:
        //

        HwDeviceExtension->p91State.bVram256 =
            (HwDeviceExtension->p91State.ulPuConfig & P91_PUC_MEMORY_DEPTH)
            ? FALSE : TRUE;

        //
        // Determine the type of Clock Synthesizer:
        //

        switch((HwDeviceExtension->p91State.ulPuConfig &
                P91_PUC_FREQ_SYNTH_TYPE) >> P91_PUC_SYNTH_SHIFT_CNT)
        {
            case CLK_ID_ICD2061A:

                HwDeviceExtension->p91State.usClockID = CLK_ID_ICD2061A;
                break;

            case CLK_ID_FIXED_MEMCLK:

                HwDeviceExtension->p91State.usClockID = CLK_ID_FIXED_MEMCLK;
                break;

            default:        // Set to ICD2061a & complain... (but continue)

                HwDeviceExtension->p91State.usClockID = CLK_ID_ICD2061A;
                VideoDebugPrint((1, "Unrecognized frequency synthesizer; Assuming ICD2061A.\n"));
                break;
        }

        //
        // Determine the type of RAMDAC:
        //

        switch((HwDeviceExtension->p91State.ulPuConfig &
                P91_PUC_RAMDAC_TYPE) >> P91_PUC_RAMDAC_SHIFT_CNT)
        {
            case DAC_ID_BT485:

                HwDeviceExtension->Dac.usRamdacID    = DAC_ID_BT485;
                HwDeviceExtension->Dac.usRamdacWidth = 32;
                HwDeviceExtension->Dac.bRamdacUsePLL = FALSE;
                break;

            case DAC_ID_BT489:

                HwDeviceExtension->Dac.usRamdacID    = DAC_ID_BT489;
                HwDeviceExtension->Dac.usRamdacWidth = 64;
                HwDeviceExtension->Dac.bRamdacUsePLL = FALSE;
                break;

            case DAC_ID_IBM525:

                HwDeviceExtension->Dac.usRamdacID    = DAC_ID_IBM525;
                HwDeviceExtension->Dac.usRamdacWidth = 64;
                HwDeviceExtension->Dac.bRamdacUsePLL = TRUE; // Assume PLL
                break;

            default:        // Set to BT485 & complain... (but continue)

                HwDeviceExtension->Dac.usRamdacID    = DAC_ID_BT485;
                HwDeviceExtension->Dac.usRamdacWidth = 32;
                HwDeviceExtension->Dac.bRamdacUsePLL = FALSE;
                VideoDebugPrint((1, "Unrecognized RAMDAC specified; Assuming BT485.\n"));
                break;
        }

        //
        // Read and store P9100 revision ID for later reference...
        //

        P9_WR_REG(P91_SYSCONFIG, 0x00000000);
        HwDeviceExtension->p91State.usRevisionID  = (USHORT)
                                      (P9_RD_REG(P91_SYSCONFIG) & 0x00000007);

    }

    //
    // Now program the detected hardware...
    //

    //
    // A1/A2 silicon SPLIT SHIFT TRANSFER BUG FIX
    //
    // This is the main logic for the split shift transfer bug software work
    // around. The current assumption is that the RAMDAC will always be doing
    // the dividing of the clock.
    //

    HwDeviceExtension->Dac.bRamdacDivides = TRUE;

    HwDeviceExtension->Dac.DACRestore(HwDeviceExtension);

    //
    // First setup the MEMCLK frequency...
    //

    usMemClkInUse = (HwDeviceExtension->p91State.usRevisionID ==
                              WTK_9100_REV1) ? DEF_P9100_REV1_MEMCLK :
                                               DEF_P9100_MEMCLK;

    // Program MEMCLK

    ProgramClockSynth(HwDeviceExtension, usMemClkInUse, TRUE, FALSE);

    //
    // Next setup the pixel clock frequency.  We have to handle potential
    // clock multiplicaiton by the RAMDAC.  On the BT485 if the dotfreq
    // is greater than the maximum clock freq then we will adjust the
    // dot frequency to program the clock with.
    //

    //
    // Program Pix clk
    //

    ProgramClockSynth(HwDeviceExtension,
                      (USHORT) HwDeviceExtension->VideoData.dotfreq1,
                      FALSE,
                      TRUE);

    //
    // Determine size of Vram (ulFrameBufferSize)...
    //

    if (HwDeviceExtension->p91State.bVram256)
    {
        if (HwDeviceExtension->p91State.ulFrameBufferSize == 0x0400000)
        {
            P9_WR_REG(P91_MEM_CONFIG, 0x00000007);
        }
        else
        {
            P9_WR_REG(P91_MEM_CONFIG, 0x00000005);
        }
    }
    else
    {
        P9_WR_REG(P91_MEM_CONFIG, 0x00000003);
    }

#if 0

    //
    // Here we will attempt to attempt to free the virtual address space
    // for the initial frame buffer setting, and we will attempt to re-map
    // the frambuffer into system virtual address space to reflect the
    // actual size of the framebuffer.
    //

    VideoPortFreeDeviceBase(HwDeviceExtension, HwDeviceExtension->FrameAddress);

    // Set the actual size

    DriverAccessRanges[2].RangeLength = HwDeviceExtension->p91State.ulFrameBufferSize;

    if ( (HwDeviceExtension->FrameAddress = (PVOID)
             VideoPortGetDeviceBase(HwDeviceExtension,
                         DriverAccessRanges[2].RangeStart,
                         DriverAccessRanges[2].RangeLength,
                         DriverAccessRanges[2].RangeInIoSpace)) == 0)
    {
        return;
    }

#endif

    //
    // Setup actual framebuffer length...
    //

    HwDeviceExtension->FrameLength =
                            HwDeviceExtension->p91State.ulFrameBufferSize;

    //
    // Init system config & clipping registers...
    //

    P91_SysConf(HwDeviceExtension);

    //
    // Calculate memconfig and srtctl register values...
    //

    CalcP9100MemConfig(HwDeviceExtension);

    //
    // Now apply the AND and OR masks specified in the mode information
    // structure.
    //
    // Note:  It is assumed that if these values are not specified in the .DAT
    //        file, then they will be initialized as 0xFFFFFFFF for the AND
    //        mask and 0x00000000 for the OR mask.
    //
    // Only the blank_edge (bit 19) and the blnkdly (bits 27-28) are valid
    // fields for override.
    //
    // Apply the AND mask to clear the specified bits.
    //

    HwDeviceExtension->p91State.ulMemConfVal &=
                       ((ULONG) HwDeviceExtension->VideoData.ulMemCfgClr |
                      ~((ULONG) P91_MC_BLANK_EDGE_MSK    |
                        (ULONG) P91_MC_BLNKDLY_MSK));

    //
    // Apply the OR mask to set the specified bits.
    //

    HwDeviceExtension->p91State.ulMemConfVal |=
                       ((ULONG) HwDeviceExtension->VideoData.ulMemCfgSet &
                       ((ULONG) P91_MC_BLANK_EDGE_MSK     |
                        (ULONG) P91_MC_BLNKDLY_MSK));

    //
    // Load the video timing registers...
    //

    P91_WriteTiming(HwDeviceExtension);

    //
    // Setup the RAMDAC to the current mode...
    //

    HwDeviceExtension->Dac.DACInit(HwDeviceExtension);

    //
    // Setup MEMCONFIG and SRTCTL regs
    //

    SetupVideoBackend(HwDeviceExtension);

    //
    // Set the native-mode enabled flag...
    //

    HwDeviceExtension->p91State.bEnabled = TRUE;

#ifdef _MIPS_
    if(HwDeviceExtension->MachineType == SIEMENS_P9100_VLB) {
    // SNI specific
        // First point:
        // Od: 27-11-95 The vram_miss_adj/vram_read_adj/vram_read_sample bits
    // are documented to be set to 1 by WEITECK or risk some troubles...
    // anyway, on our Mips/VL architecture, it helps hardfully when
    // they are cleared; otherwhise, we lost about 1 bit every 1500 Kilo bytes
    // during largescreen to host transfers...
    // Any Way we feel it confortable because it should speed up our graphics...
           {
           ULONG    ulMemConfig;

    // 1/ read the value programmed by CalcP9100MemConfig
           ulMemConfig = P9_RD_REG(P91_MEM_CONFIG);

        // 2/ clear the 3 read-delaies bits
           ulMemConfig &= ~(P91_MC_MISS_ADJ_1|P91_MC_READ_ADJ_1
                           |P91_MC_READ_SMPL_ADJ_1);

        // 3/ write it back
           P9_WR_REG(P91_MEM_CONFIG, ulMemConfig);
           }

        // Second point:
    // Od: 2/10/95B: with large resolution, the frame buffer will overlap
    // with the good old ROM Bios, around xC0000 to xE0000, x=8,9,...
    // since ROM relocation does NOT run on VLB systems (hard wired..)
    // we relocate the frame buffer instead:
       {
       unsigned char * HiOrderByteReg, HiOrderByteVal;

    // to achieve that goal,

    // 1/ we ask the P9100 to respond to 8xxxxxxxx address rather than 0xxxxxxxx

       HiOrderByteVal=0x80;     // Od: why not ?
       WriteP9ConfigRegister(HwDeviceExtension,P91_CONFIG_WBASE,HiOrderByteVal);

    // 2/ we tell the mother board to set the high order byte for each
    //    related addresses

       {
           extern VP_STATUS                     GetCPUIdCallback(
                  PVOID                         HwDeviceExtension,
                  PVOID                         Context,
                  VIDEO_DEVICE_DATA_TYPE        DeviceDataType,
                  PVOID                         Identifier,
                  ULONG                         IdentifierLength,
                  PVOID                         ConfigurationData,
                  ULONG                         ConfigurationDataLength,
                  PVOID                         ComponentInformation,
                  ULONG                         ComponentInformationLength
           );

       if(VideoPortIsCpu(L"RM200"))
                HiOrderByteReg = (unsigned char *) 0xBFCC0000;
       else
       if(VideoPortIsCpu(L"RM400-MT"))
                {
                HiOrderByteReg = (unsigned char *) 0xBC010000;
                HiOrderByteVal = ~HiOrderByteVal;
                }
       else
       if(VideoPortIsCpu(L"RM400-T")
       || VideoPortIsCpu(L"RM400-T MP"))
                {
                HiOrderByteReg = (unsigned char *) 0xBC0C0000;
                HiOrderByteVal = ~HiOrderByteVal;
                }
       }

       *HiOrderByteReg = HiOrderByteVal;

    // NOTE that at this point (Dll ending up init by enabling the surface),
    // we will not be able to switch back to VGA;
       }
    }
#endif  // SIEMENS_P9100_VLB

    VideoDebugPrint((2, "VLEnableP91 - Exit\n"));

    return;

} // End of VLEnableP91()




BOOLEAN
VLDisableP91(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

    Routine Description:

        Disables native mode (switches to emulation mode (VGA)) and does
        an INT10 for mode 3.  Note that this will also reset the DAC to
        VGA mode/3.

    Arguments:

        HwDeviceExtension - Pointer to the miniport driver's device extension.
        pPal - Pointer to the array of pallete entries.
        StartIndex - Specifies the first pallete entry provided in pPal.
        Count - Number of palette entries in pPal

    Return Value:

        FALSE, indicating an int10 modeset needs to be done to complete the
        switch.

--*/

{
    VideoDebugPrint((2, "VLDisableP91 - Entry\n"));

    //
    // Disable native-mode (set emulation-mode) only if native-mode is
    // already enabled...
    //

    if (!HwDeviceExtension->p91State.bEnabled)
        return (HwDeviceExtension->MachineType != SIEMENS_P9100_VLB) ?
                        TRUE                    :       FALSE;

    //
    // Set emulation-mode (VGA)...
    //

    WriteP9ConfigRegister(HwDeviceExtension, P91_CONFIG_MODE, 0x02);

    //
    // Set enabled flag
    //

    HwDeviceExtension->p91State.bEnabled = FALSE;


    VideoDebugPrint((2, "VLDisableP91 - Exit\n"));

    return (HwDeviceExtension->MachineType != SIEMENS_P9100_VLB) ?
                       FALSE              :        TRUE;

} // End of VLDisableP91()


UCHAR
ReadP9ConfigRegister(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    UCHAR regnum
    )

/*++

    Routine Description:

        Reads and returns value from the specified VLB or PCI configuration space.

    Arguments:

        regnum - register to read.

    Return Value:

        Returns specified registers 8-bit value.

--*/

{
    ULONG ulTemp;

    VideoDebugPrint((2, "ReadP9ConfigRegister - Entry\n"));

    ulTemp = 0;

    switch (HwDeviceExtension->usBusType)
    {
        case VESA:

            //
            // Select the register, and return the value.
            //

            VideoPortWritePortUchar((PUCHAR) HwDeviceExtension->ConfigAddr, regnum);

            ulTemp = VideoPortReadPortUchar((PUCHAR) HwDeviceExtension->ConfigAddr + 4L);

            break;

        case PCI:

            if (!VideoPortGetBusData(HwDeviceExtension,
                                     PCIConfiguration,
                                     HwDeviceExtension->PciSlotNum,
                                     &ulTemp,
                                     regnum,
                                     sizeof(ulTemp)))
            {
                VideoDebugPrint((1, "ReadP9ConfigRegister: Cannot read from PCI Config Space!\n"));
            }

            break;

      default:

            VideoDebugPrint((1, "ReadP9ConfigRegister: Unknown bus-type!\n"));
            ulTemp = 0;
            break;
    }

    VideoDebugPrint((2, "ReadP9ConfigRegister - Exit\n"));

    return ((UCHAR) ulTemp);

} // End of ReadP9ConfigRegister()


VOID
WriteP9ConfigRegister(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    UCHAR regnum,
    UCHAR jValue
    )

/*++

    Routine Description:

        Writes the specified value to the specified register within the VLB
        or PCI configuration space.

    Arguments:

        regnum - desired register,
        value  - value to write.

    Return Value:

        None.

--*/

{
    VideoDebugPrint((3, "WriteP9ConfigRegister - Entry\n"));

    switch (HwDeviceExtension->usBusType)
    {
        case VESA:

            //
            // Select the register, and write the value.
            //

            VideoPortWritePortUchar((PUCHAR) HwDeviceExtension->ConfigAddr, regnum);
            VideoPortWritePortUchar((PUCHAR) HwDeviceExtension->ConfigAddr+4L, jValue);

            break;

        case PCI:

            if (!VideoPortSetBusData(HwDeviceExtension,
                                     PCIConfiguration,
                                     HwDeviceExtension->PciSlotNum,
                                     &jValue,
                                     regnum,
                                     1))
            {
                VideoDebugPrint((1, "WriteP9ConfigRegister: Cannot write to PCI Config Space!\n"));
            }

            break;

        default:

            VideoDebugPrint((1, "ERROR: WriteP9ConfigRegister - Unknown bus-type!\n"));
            break;
    }

    VideoDebugPrint((3, "WriteP9ConfigRegister - Exit\n"));


} // End of WriteP9ConfigRegister()


VOID
SetupVideoBackend(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

    Routine Description:

       Program the MEMCONFIG and SRTCTL registers (see comments). For the
       Power 9100 only.

    Arguments:

        HwDeviceExtension - Pointer to the miniport driver's device extension.

    Return Value:

        None.

--*/

{
    ULONG    ulSRTCTL2;

    VideoDebugPrint((2, "SetupVideoBackend - Entry\n"));

    //
    // Program the MEMCONFIG and SRTCTL registers
    //
    // There are two main modes in which the video backend can operate:
    // One is a mode in which the P9100 gets the pixel clock (pixclk) and
    // divides it to generate the RAMDAC load clock, and the other is
    // a mode in which the RAMDAC divides the clock and supplies it through
    // the divpixclk input.
    //
    // If you are using the mode where the RAMDAC provides the divided clock
    // then you must make sure that the RAMDAC is generating the divided clock
    // before you switch MEMCONFIG to use the divided clock. Otherwise, you
    // run the risk of hanging the P9100 since certain synchronizers depend
    // upon a video clock to operate. For instance: when you write to a video
    // register you must have a video clock running or the P9100 will not be
    // able to complete the write, and it will hang the system.
    //
    // Note that the Ramdac should always divide the pixclk in 24(bits)pp mode.
    //

    //
    // The SRTCTL2 register controls the sync polarities and can also force
    // the syncs high or low for the monitor power-down modes.
    //

    ulSRTCTL2 = 0L;

    ulSRTCTL2 |= (HwDeviceExtension->VideoData.hp) ? P91_HSYNC_HIGH_TRUE :
                                                     P91_HSYNC_LOW_TRUE;

    ulSRTCTL2 |= (HwDeviceExtension->VideoData.vp) ? P91_VSYNC_HIGH_TRUE :
                                                     P91_VSYNC_LOW_TRUE;

    P9_WR_REG(P91_MEM_CONFIG, HwDeviceExtension->p91State.ulMemConfVal);
    P9_WR_REG(P91_SRTCTL, HwDeviceExtension->p91State.ulSrctlVal);
    P9_WR_REG(P91_SRTCTL2, ulSRTCTL2);


    VideoDebugPrint((2, "SetupVideoBackend: ulMemConfVal = %lx\n",
                        HwDeviceExtension->p91State.ulMemConfVal));
    VideoDebugPrint((2, "SetupVideoBackend: ulSrctlVal = %lx\n",
                        HwDeviceExtension->p91State.ulSrctlVal));
    VideoDebugPrint((2, "SetupVideoBackend: ulSRTCTL2 = %lx\n", ulSRTCTL2));
    VideoDebugPrint((2, "SetupVideoBackend: dotfreq1 = %ld\n",
                        HwDeviceExtension->VideoData.dotfreq1));
    VideoDebugPrint((2, "SetupVideoBackend: XSize = %ld\n",
                        HwDeviceExtension->VideoData.XSize));
    VideoDebugPrint((2, "SetupVideoBackend: YSize = %ld\n",
                        HwDeviceExtension->VideoData.YSize));
    VideoDebugPrint((2, "SetupVideoBackend: usBitsPixel = %ld\n",
                        HwDeviceExtension->usBitsPixel));
    VideoDebugPrint((2, "SetupVideoBackend: iClkDiv = %ld\n",
                        HwDeviceExtension->AdapterDesc.iClkDiv));
    VideoDebugPrint((2, "SetupVideoBackend: bRamdacDivides: %d\n",
                         HwDeviceExtension->Dac.bRamdacDivides));
    VideoDebugPrint((2, "SetupVideoBackend: bRamdacUsePLL: %d\n",
                         HwDeviceExtension->Dac.bRamdacUsePLL));
    VideoDebugPrint((2, "SetupVideoBackend: usRevisionID: %d\n",
                         HwDeviceExtension->p91State.usRevisionID));
    VideoDebugPrint((2, "SetupVideoBackend: usBlnkDlyAdj: %d\n",
                         HwDeviceExtension->p91State.ulBlnkDlyAdj));


    VideoDebugPrint((2, "SetupVideoBackend - Exit\n"));

    return;

} // End of SetupVideoBackend()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\weitek\mini\wtkp9xvl.h ===
/*++

Copyright (c) 1993  Weitek Corporation

Module Name:

    wtkp9xvl.h

Abstract:

    This module contains definitions for the Weitek P9000 VL evaluation
    board.

Environment:

    Kernel mode

Revision History may be found at the end of this file.

--*/

//
// Default memory addresses for the P9100 registers/frame buffer.
//

#define P91_MemBase         0xC0000000 // default physical address

//
// Default memory addresses for the P9000 registers/frame buffer.
//

#define MemBase             0x80000000

//
// Bit to write to the sequencer control register to enable/disable P9
// video output.
//

#define P9_VIDEO_ENB   0x10
#define P9_VIDEO_DIS   ~P9_VIDEO_ENB

//
// Define the bit in the sequencer control register which determines
// the sync polarities. For Weitek board, 1 = positive.
//

#define HSYNC_POL_MASK  0x20
#define POL_MASK        HSYNC_POL_MASK

extern ULONG P91_Bt485_DAC_Regs[];

VOID
P91_WriteTiming(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
CalcP9100MemConfig (
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
P91_SysConf(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
ProgramClockSynth(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    USHORT usFrequency,
    BOOLEAN bSetMemclk,
    BOOLEAN bUseClockDoubler
    );

VOID
SetupVideoBackend(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
WriteP9ConfigRegister(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    UCHAR regnum,
    UCHAR jValue
    );

UCHAR
ReadP9ConfigRegister(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    UCHAR regnum
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\watchdog\object.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    object.c

Abstract:

    This is the NT Watchdog driver implementation.

Author:

    Michael Maciesowicz (mmacie) 02-May-2001

Environment:

    Kernel mode only.

Notes:

Revision History:

--*/

#include "wd.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, WdFlushRegistryKey)
#pragma alloc_text (PAGE, WdInitializeObject)
#endif


//
// Exports.
//

WATCHDOGAPI
VOID
WdCompleteEvent(
    IN PVOID pWatch,
    IN PKTHREAD pThread
    )

/*++

Routine Description:

    This function *MUST* be called from client handler for watchdog timeout event
    before exiting. It removes references from watchdog and thread objects.
    It also reenables watchdog event generation for deferred watchdog objects.

Arguments:

    pWatch - Points to WATCHDOG_OBJECT.

    pThread - Points to KTHREAD object for spinning thread.

Return Value:

    None.

--*/

{
    //
    // Note: pThread is NULL for recovery events.
    //

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT_WATCHDOG_OBJECT(pWatch);

    //
    // Resume event generation for deferred watchdog.
    //

    if (WdDeferredWatchdog == ((PWATCHDOG_OBJECT)pWatch)->ObjectType)
    {
        InterlockedExchange(&(((PDEFERRED_WATCHDOG)pWatch)->Trigger), 0);
    }

    //
    // Drop reference counts.
    //

    if (NULL != pThread)
    {
        ObDereferenceObject(pThread);
    }

    WdDereferenceObject(pWatch);

    return;
}   // WdCompleteEvent()

WATCHDOGAPI
VOID
WdDereferenceObject(
    IN PVOID pWatch
    )

/*++

Routine Description:

    This function decreases reference count of watchdog object.
    If remaining count is zero we will remove object here, since it's
    been freed already.

Arguments:

    pWatch - Points to WATCHDOG_OBJECT.

Return Value:

    None.

--*/

{
    PWATCHDOG_OBJECT pWatchdogObject;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT_WATCHDOG_OBJECT(pWatch);

    pWatchdogObject = (PWATCHDOG_OBJECT)pWatch;

    ASSERT(pWatchdogObject->ReferenceCount > 0);

    //
    // Drop reference count and remove the object if fully dereferenced.
    //

    if (InterlockedDecrement(&(pWatchdogObject->ReferenceCount)) == 0)
    {
        //
        // Object already freed - remove it now.
        //

        WdRemoveObject(pWatchdogObject);
    }

    return;
}   // WdDereferenceObject()

WATCHDOGAPI
PDEVICE_OBJECT
WdGetDeviceObject(
    IN PVOID pWatch
    )

/*++

Routine Description:

    This function return pointer to device object associated with watchdog object.
    This function increases reference count on DEVICE_OBJECT so the caller must call
    ObDereferenceObject() once DEVICE_OBJECT pointer is not needed any more.

Arguments:

    pWatch - Points to WATCHDOG_OBJECT.

Return Value:

    Pointer to DEVICE_OBJECT.

--*/

{
    PDEVICE_OBJECT pDeviceObject;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT_WATCHDOG_OBJECT(pWatch);

    pDeviceObject = ((PWATCHDOG_OBJECT)pWatch)->DeviceObject;
    ASSERT(NULL != pDeviceObject);

    ObReferenceObject(pDeviceObject);
    return pDeviceObject;
}   // WdGetDeviceObject()

WATCHDOGAPI
WD_EVENT_TYPE
WdGetLastEvent(
    IN PVOID pWatch
    )

/*++

Routine Description:

    This function return last event associated with watchdog object.

Arguments:

    pWatch - Points to WATCHDOG_OBJECT.

Return Value:

    Last event type.

--*/

{
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT_WATCHDOG_OBJECT(pWatch);

    return ((PWATCHDOG_OBJECT)pWatch)->LastEvent;
}   // WdGetLastEvent()

WATCHDOGAPI
PDEVICE_OBJECT
WdGetLowestDeviceObject(
    IN PVOID pWatch
    )

/*++

Routine Description:

    This function return pointer to the lowest (most likely PDO) DEVICE_OBJECT
    associated with watchdog object. This function increases reference count on
    returned DEVICE_OBJECT - the caller must call ObDereferenceObject() once
    DEVICE_OBJECT pointer is not needed any more.

Arguments:

    pWatch - Points to WATCHDOG_OBJECT.

Return Value:

    Pointer to DEVICE_OBJECT.

--*/

{
    PDEVICE_OBJECT pDeviceObject;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT_WATCHDOG_OBJECT(pWatch);

    //
    // Note: No need to bump reference count here, it is always done when
    // watchdog object is created.
    //

    pDeviceObject = ((PWATCHDOG_OBJECT)pWatch)->DeviceObject;
    ASSERT(NULL != pDeviceObject);

    //
    // Now get the pointer to the lowest device object in the stack.
    // Note: This call automatically bumps a reference count on returned object.
    //

    pDeviceObject = IoGetDeviceAttachmentBaseRef(pDeviceObject);
    ASSERT(NULL != pDeviceObject);

    return pDeviceObject;
}   // WdGetLowestDeviceObject()

WATCHDOGAPI
VOID
WdReferenceObject(
    IN PVOID pWatch
    )

/*++

Routine Description:

    This function increases reference count of watchdog object.

Arguments:

    pWatch - Points to WATCHDOG_OBJECT.

Return Value:

    None.

--*/

{
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT_WATCHDOG_OBJECT(pWatch);

    if (InterlockedIncrement(&(((PWATCHDOG_OBJECT)pWatch)->ReferenceCount)) == 1)
    {
        //
        // Somebody referenced removed object.
        //

        ASSERT(FALSE);
    }

    //
    // Check for overflow.
    //

    ASSERT(((PWATCHDOG_OBJECT)pWatch)->ReferenceCount > 0);

    return;
}   // WdReferenceObject()

//
// Non-exports.
//

NTSTATUS
WdFlushRegistryKey(
    IN PVOID pWatch,
    IN PCWSTR pwszKeyName
    )

/*++

Routine Description:

    This function forces a registry key to be committed to disk.

Arguments:

    pWatch - Points to WATCHDOG_OBJECT.

    pwszKeyName - Points to key name string.

Return Value:

    Status code.

--*/
{
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING unicodeKeyName;
    HANDLE keyHandle;
    NTSTATUS ntStatus;

    PAGED_CODE();
    UNREFERENCED_PARAMETER(pWatch);
    ASSERT(NULL != pwszKeyName);

    RtlInitUnicodeString(&unicodeKeyName, pwszKeyName);

    InitializeObjectAttributes(&objectAttributes,
                               &unicodeKeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    ntStatus = ZwOpenKey(&keyHandle,
                         KEY_READ | KEY_WRITE,
                         &objectAttributes);

    if (NT_SUCCESS(ntStatus))
    {
        ntStatus = ZwFlushKey(keyHandle);
        ZwClose(keyHandle);
    }

    return ntStatus;
}   // WdFlushRegistryKey()

VOID
WdInitializeObject(
    IN PVOID pWatch,
    IN PDEVICE_OBJECT pDeviceObject,
    IN WD_OBJECT_TYPE objectType,
    IN WD_TIME_TYPE timeType,
    IN ULONG ulTag
    )

/*++

Routine Description:

    This function initializes watchdog object.

Arguments:

    pWatch - Points to WATCHDOG_OBJECT.

    pDeviceObject - Points to DEVICE_OBJECT associated with watchdog.

    objectType - Type of watchdog object.

    timeType - Kernel, User, Both thread time to monitor.

    ulTag - A tag identifying owner.

Return Value:

    None.

--*/

{
    PWATCHDOG_OBJECT pWatchdogObject;

    PAGED_CODE();
    ASSERT(NULL != pWatch);
    ASSERT(NULL != pDeviceObject);
    ASSERT((objectType == WdStandardWatchdog) || (objectType == WdDeferredWatchdog));
    ASSERT((timeType >= WdKernelTime) && (timeType <= WdFullTime));

    pWatchdogObject = (PWATCHDOG_OBJECT)pWatch;

    //
    // Set initial state of watchdog object.
    //

    pWatchdogObject->ObjectType = objectType;
    pWatchdogObject->ReferenceCount = 1;
    pWatchdogObject->OwnerTag = ulTag;
    pWatchdogObject->DeviceObject = pDeviceObject;
    pWatchdogObject->TimeType = timeType;
    pWatchdogObject->LastEvent = WdNoEvent;
    pWatchdogObject->LastQueuedThread = NULL;

    //
    // Bump reference count on device object.
    //

    ObReferenceObject(pDeviceObject);

    //
    // Initialize encapsulated KSPIN_LOCK object.
    //

    KeInitializeSpinLock(&(pWatchdogObject->SpinLock));

    return;
}   // WdInitializeObject()

VOID
WdRemoveObject(
    IN PVOID pWatch
    )

/*++

Routine Description:

    This function unconditionally removes watchdog object.

Arguments:

    pWatch - Points to WATCHDOG_OBJECT.

Return Value:

    None.

--*/

{
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT_WATCHDOG_OBJECT(pWatch);
    ASSERT(0 == ((PWATCHDOG_OBJECT)pWatch)->ReferenceCount);

    //
    // Drop reference count on device object.
    //

    ObDereferenceObject(((PWATCHDOG_OBJECT)pWatch)->DeviceObject);

    //
    // We are freeing non-paged pool, it's OK to be at IRQL <= DISPATCH_LEVEL.
    //

    ExFreePool(pWatch);

    return;
}   // WdRemoveObject()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\watchdog\dwd.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    dwd.c

Abstract:

    This is the NT Watchdog driver implementation.

Author:

    Michael Maciesowicz (mmacie) 05-May-2000

Environment:

    Kernel mode only.

Notes:

Revision History:

--*/

#include "wd.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, WdAllocateDeferredWatchdog)
#endif


WATCHDOGAPI
PDEFERRED_WATCHDOG
WdAllocateDeferredWatchdog(
    IN PDEVICE_OBJECT pDeviceObject,
    IN WD_TIME_TYPE timeType,
    IN ULONG ulTag
    )

/*++

Routine Description:

    This function allocates storage and initializes
    a deferred watchdog object.

Arguments:

    pDeviceObject - Points to DEVICE_OBJECT associated with watchdog.

    timeType - Kernel, User, Both thread time to monitor.

    ulTag - A tag identifying owner.

Return Value:

    Pointer to allocated deferred watchdog object or NULL.

--*/

{
    PDEFERRED_WATCHDOG pWatch;

    PAGED_CODE();
    ASSERT(NULL != pDeviceObject);
    ASSERT((timeType >= WdKernelTime) && (timeType <= WdFullTime));

    //
    // Allocate storage for deferred watchdog from non-paged pool.
    //

    pWatch = (PDEFERRED_WATCHDOG)ExAllocatePoolWithTag(NonPagedPool, sizeof (DEFERRED_WATCHDOG), ulTag);

    //
    // Set initial state of deferred watchdog.
    //

    if (NULL != pWatch)
    {
        //
        // Set initial state of watchdog.
        //

        WdInitializeObject(pWatch,
                           pDeviceObject,
                           WdDeferredWatchdog,
                           timeType,
                           ulTag);

        pWatch->Period = 0;
        pWatch->SuspendCount = 0;
        pWatch->InCount = 0;
        pWatch->OutCount = 0;
        pWatch->LastInCount = 0;
        pWatch->LastOutCount = 0;
        pWatch->LastKernelTime = 0;
        pWatch->LastUserTime = 0;
        pWatch->TimeIncrement = KeQueryTimeIncrement();
        pWatch->Trigger = 0;
        pWatch->Started = FALSE;
        pWatch->Thread = NULL;
        pWatch->ClientDpc = NULL;

        //
        // Initialize encapsulated DPC object.
        //

        KeInitializeDpc(&(pWatch->TimerDpc), WdDeferredWatchdogDpcCallback, pWatch);

        //
        // Initialize encapsulated timer object.
        //

        KeInitializeTimerEx(&(pWatch->Timer), NotificationTimer);
    }

    return pWatch;
}   // WdAllocateDeferredWatchdog()

WATCHDOGAPI
VOID
WdFreeDeferredWatchdog(
    PDEFERRED_WATCHDOG pWatch
)

/*++

Routine Description:

    This function deallocates storage for deferred watchdog object.
    It will also stop started deferred watchdog if needed.

Arguments:

    pWatch - Supplies a pointer to a watchdog object.

Return Value:

    None.

--*/

{
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT(NULL != pWatch);
    ASSERT(pWatch->Header.ReferenceCount > 0);

    //
    // Stop deferred watch just in case somebody forgot.
    // If the watch is stopped already then this is a no-op.
    //

    WdStopDeferredWatch(pWatch);

    //
    // Drop reference count and remove the object if fully dereferenced.
    //

    if (InterlockedDecrement(&(pWatch->Header.ReferenceCount)) == 0)
    {
        WdRemoveObject(pWatch);
    }

    return;
}   // WdFreeDeferredWatchdog()

WATCHDOGAPI
VOID
WdStartDeferredWatch(
    IN PDEFERRED_WATCHDOG pWatch,
    IN PKDPC pDpc,
    IN LONG lPeriod
    )

/*++

Routine Description:

    This function starts deferred watchdog poller.

Arguments:

    pWatch - Supplies a pointer to a deferred watchdog object.

    pDpc - Supplies a pointer to a control object of type DPC.

    ulPeriod - Supplies maximum time in millisecondes that thread
    can spend in the monitored section. If this time expires a DPC
    will we queued.

Return Value:

    None.

--*/

{
    KIRQL oldIrql;
    LARGE_INTEGER liDueTime;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT(NULL != pWatch);
    ASSERT(NULL != pDpc);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KeAcquireSpinLock(&(pWatch->Header.SpinLock), &oldIrql);

    WD_DBG_SUSPENDED_WARNING(pWatch, "WdStartDeferredWatch");

    //
    // We shouldn't hot swap DPCs without stopping first.
    //

    ASSERT((NULL == pWatch->ClientDpc) || (pDpc == pWatch->ClientDpc));

    pWatch->Period = lPeriod;
    pWatch->InCount = 0;
    pWatch->OutCount = 0;
    pWatch->LastInCount = 0;
    pWatch->LastOutCount = 0;
    pWatch->LastKernelTime = 0;
    pWatch->LastUserTime = 0;
    pWatch->Trigger = 0;
    pWatch->Started = TRUE;
    pWatch->Thread = NULL;
    pWatch->ClientDpc = pDpc;

    //
    // Unlock the dispatcher database and lower IRQL to its previous value.
    //

    KeReleaseSpinLock(&(pWatch->Header.SpinLock), oldIrql);

    //
    // Set first fire to lPeriod.
    //

    liDueTime.QuadPart = -(lPeriod * 1000 * 10);

    KeSetTimerEx(&(pWatch->Timer), liDueTime, lPeriod, &(pWatch->TimerDpc));

    return;
}   // WdStartDeferredWatch()

WATCHDOGAPI
VOID
WdStopDeferredWatch(
    IN PDEFERRED_WATCHDOG pWatch
    )

/*++

Routine Description:

    This function stops deferred watchdog poller.

Arguments:

    pWatch - Supplies a pointer to a watchdog object.

Return Value:

    None.

--*/

{
    KIRQL oldIrql;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT(NULL != pWatch);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KeAcquireSpinLock(&(pWatch->Header.SpinLock), &oldIrql);

    WD_DBG_SUSPENDED_WARNING(pWatch, "WdStopDeferredWatch");

    if (TRUE == pWatch->Started)
    {
        KeCancelTimer(&(pWatch->Timer));

        //
        // Make sure we don't have client's DPC pending.
        //

        if (NULL != pWatch->ClientDpc)
        {
            if (KeRemoveQueueDpc(pWatch->ClientDpc) == TRUE)
            {
                //
                // Was in queue - call WdCompleteEvent() here since DPC won't be delivered.
                //

                WdCompleteEvent(pWatch, pWatch->Header.LastQueuedThread);
            }
        }

        pWatch->Period = 0;
        pWatch->InCount = 0;
        pWatch->OutCount = 0;
        pWatch->LastInCount = 0;
        pWatch->LastOutCount = 0;
        pWatch->LastKernelTime = 0;
        pWatch->LastUserTime = 0;
        pWatch->Trigger = 0;
        pWatch->Started = FALSE;
        pWatch->Thread = NULL;
        pWatch->ClientDpc = NULL;
        pWatch->Header.LastEvent = WdNoEvent;
        pWatch->Header.LastQueuedThread = NULL;
    }

    //
    // Unlock the dispatcher database and lower IRQL to its previous value.
    //

    KeReleaseSpinLock(&(pWatch->Header.SpinLock), oldIrql);

    return;
}   // WdStopDeferredWatch()

WATCHDOGAPI
VOID
FASTCALL
WdSuspendDeferredWatch(
    IN PDEFERRED_WATCHDOG pWatch
    )

/*++

Routine Description:

    This function suspends deferred watchdog poller.

Arguments:

    pWatch - Supplies a pointer to a watchdog object.

Return Value:

    None.

--*/

{
    ASSERT(NULL != pWatch);
    ASSERT((ULONG)(pWatch->SuspendCount) < (ULONG)(-1));

    InterlockedIncrement(&(pWatch->SuspendCount));

    return;
}   // WdSuspendDeferredWatch()

WATCHDOGAPI
VOID
FASTCALL
WdResumeDeferredWatch(
    IN PDEFERRED_WATCHDOG pWatch,
    IN BOOLEAN bIncremental
    )

/*++

Routine Description:

    This function resumes deferred watchdog poller.

Arguments:

    pWatch - Supplies a pointer to a watchdog object.

    bIncremental - If TRUE the watchdog will resume only when
        SuspendCount reaches 0, if FALSE watchdog resumes
        immediately and SuspendCount is forced to 0.

Return Value:

    None.

--*/

{
    ASSERT(NULL != pWatch);

    if (TRUE == bIncremental)
    {
        //
        // Make sure we won't roll under.
        //

        if (InterlockedDecrement(&(pWatch->SuspendCount)) == -1)
        {
            InterlockedIncrement(&(pWatch->SuspendCount));
        }
    }
    else
    {
        InterlockedExchange(&(pWatch->SuspendCount), 0);
    }

    return;
}   // WdSuspendDeferredWatch()

WATCHDOGAPI
VOID
FASTCALL
WdResetDeferredWatch(
    IN PDEFERRED_WATCHDOG pWatch
    )

/*++

Routine Description:

    This function resets deferred watchdog poller, i.e. it starts
    timeout measurement from the scratch if we are in the monitored
    section.
    Note: If the watchdog is suspened it will remain suspended.

Arguments:

    pWatch - Supplies a pointer to a watchdog object.

Return Value:

    None.

--*/

{
    KIRQL oldIrql;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT(NULL != pWatch);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KeAcquireSpinLock(&(pWatch->Header.SpinLock), &oldIrql);

    pWatch->InCount = 0;
    pWatch->OutCount = 0;
    pWatch->Trigger = 0;

    //
    // Unlock the dispatcher database and lower IRQL to its previous value.
    //

    KeReleaseSpinLock(&(pWatch->Header.SpinLock), oldIrql);

    return;
}   // WdResetDeferredWatch()

WATCHDOGAPI
VOID
FASTCALL
WdEnterMonitoredSection(
    IN PDEFERRED_WATCHDOG pWatch
    )

/*++

Routine Description:

    This function starts monitoring of the code section for time-out
    condition.

    Note: To minimize an overhead it is caller's resposibility to make
    sure thread remains valid when we are in the monitored section.

Arguments:

    pWatch - Supplies a pointer to a deferred watchdog object.

Return Value:

    None.

--*/

{
    PKTHREAD pThread;
    KIRQL oldIrql;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT(NULL != pWatch);
    ASSERT(pWatch->Started);

    //
    // We have to remove this warning, I hope temporarily, since win32k
    // is calling this entry point now with suspended watchdog.
    //
    // WD_DBG_SUSPENDED_WARNING(pWatch, "WdEnterMonitoredSection");
    //

    pThread = KeGetCurrentThread();

    if (pThread != pWatch->Thread)
    {
        //
        // Raise IRQL to dispatcher level and lock dispatcher database.
        //

        KeAcquireSpinLock(&(pWatch->Header.SpinLock), &oldIrql);

        //
        // We shouldn't swap threads in the monitored section.
        //

        ASSERT(pWatch->OutCount == pWatch->InCount);

        pWatch->Trigger = 0;
        pWatch->Thread = pThread;

        //
        // Unlock the dispatcher database and lower IRQL to its previous value.
        //

        KeReleaseSpinLock(&(pWatch->Header.SpinLock), oldIrql);
    }

    InterlockedIncrement(&(pWatch->InCount));

	return;
}   // WdEnterMonitoredSection()

WATCHDOGAPI
VOID
FASTCALL
WdExitMonitoredSection(
    IN PDEFERRED_WATCHDOG pWatch
    )

/*++

Routine Description:

    This function stops monitoring of the code section for time-out
    condition.

Arguments:

    pWatch - Supplies a pointer to a deferred watchdog object.

Return Value:

    None.

--*/

{
    ASSERT(NULL != pWatch);
    ASSERT((pWatch->OutCount < pWatch->InCount) ||
        ((pWatch->OutCount > 0) && (pWatch->InCount < 0)));

    //
    // We have to remove this warning, I hope temporarily, since win32k
    // is calling this entry point now with suspended watchdog.
    //
    // WD_DBG_SUSPENDED_WARNING(pWatch, "WdExitMonitoredSection");
    //

    InterlockedIncrement(&(pWatch->OutCount));

    return;
}   // WdExitMonitoredSection()

VOID
WdDeferredWatchdogDpcCallback(
    IN PKDPC pDpc,
    IN PVOID pDeferredContext,
    IN PVOID pSystemArgument1,
    IN PVOID pSystemArgument2
    )

/*++

Routine Description:

    This function is a DPC callback routine for timer object embedded in the
    deferred watchdog object. It checks thread time and if the wait condition
    is satisfied it queues original (client) DPC.

Arguments:

    pDpc - Supplies a pointer to a DPC object.

    pDeferredContext - Supplies a pointer to a deferred watchdog object.

    pSystemArgument1/2 - Supply time when embedded KTIMER expired.

Return Value:

    None.

--*/

{
    PDEFERRED_WATCHDOG pWatch;
    LARGE_INTEGER liThreadTime;
    ULONG ulKernelTime;
    ULONG ulUserTime;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    ASSERT(NULL != pDeferredContext);

    pWatch = (PDEFERRED_WATCHDOG)pDeferredContext;

    //
    // Lock dispatcher database.
    //

    KeAcquireSpinLockAtDpcLevel(&(pWatch->Header.SpinLock));

    if (NULL != pWatch->Thread)
    {
        switch (pWatch->Trigger)
        {
        case 0:

            //
            // Everything fine so far, check if we are suspended.
            //

            if (pWatch->SuspendCount)
            {
                //
                // We're suspended - do nothing.
                //

                break;
            }

            //
            // Check if the last event was a timeout event.
            //

            if (WdTimeoutEvent == pWatch->Header.LastEvent)
            {
                //
                // Check if we made any progress.
                //

                if ((pWatch->InCount != pWatch->LastInCount) ||
                    (pWatch->OutCount != pWatch->LastOutCount) ||
                    (pWatch->InCount == pWatch->OutCount))
                {
                    //
                    // We recovered - update event type and queue client DPC.
                    //

                    pWatch->Header.LastEvent = WdRecoveryEvent;

                    if (NULL != pWatch->ClientDpc)
                    {
                        //
                        // Bump up references to objects we're going to touch in client DPC.
                        //

                        WdReferenceObject(pWatch);

                        //
                        // Queue client DPC.
                        //
                        // Note: In case of recovery the thread associated with watchdog
                        // object may be deleted by the time we get here. We can't pass it
                        // down to client DPC - we're passing NULL instead.
                        //

                        if (KeInsertQueueDpc(pWatch->ClientDpc, NULL, pWatch) == TRUE)
                        {
                            //
                            // Keep track of qeueued thread in case we cancel this DPC.
                            //

                            pWatch->Header.LastQueuedThread = NULL;

                            //
                            // Make sure we queue DPC only once per event.
                            //

                            pWatch->Trigger = 2;
                        }
                        else
                        {
                            //
                            // This should never happen.
                            //

                            WdDereferenceObject(pWatch);
                        }
                    }
                }
            }

            //
            // Check if we are in the monitored section.
            //

            if (pWatch->InCount == pWatch->OutCount)
            {
                //
                // We're outside monitored section - we're fine.
                //

                break;
            }

            //
            // We're inside monitored section - bump up trigger indicator,
            // and take snapshots of counters and thread's time.
            //

            pWatch->Trigger = 1;
            pWatch->LastInCount = pWatch->InCount;
            pWatch->LastOutCount = pWatch->OutCount;
            pWatch->LastKernelTime = KeQueryRuntimeThread(pWatch->Thread, &(pWatch->LastUserTime));
            break;

        case 1:

            //
            // We were in the monitored section last time.
            //
            
            //
            // Check if we're out or suspended.
            //

            if ((pWatch->InCount == pWatch->OutCount) || pWatch->SuspendCount)
            {
                //
                // We're outside monitored section or suspended - we're fine.
                // Reset trigger counter and get out of here.
                //

                pWatch->Trigger = 0;
                break;
            }

            //
            // Check if we made any progress, if so reset snapshots.
            //

            if ((pWatch->InCount != pWatch->LastInCount) ||
                (pWatch->OutCount != pWatch->LastOutCount))
            {
                pWatch->Trigger = 1;
                pWatch->LastInCount = pWatch->InCount;
                pWatch->LastOutCount = pWatch->OutCount;
                pWatch->LastKernelTime = KeQueryRuntimeThread(pWatch->Thread, &(pWatch->LastUserTime));
                break;
            }

            //
            // Check if we're stuck long enough.
            //

            ulKernelTime = KeQueryRuntimeThread(pWatch->Thread, &ulUserTime);

            switch (pWatch->Header.TimeType)
            {
            case WdKernelTime:

                liThreadTime.QuadPart = ulKernelTime;

                //
                // Handle counter rollovers.
                //

                if (ulKernelTime < pWatch->LastKernelTime)
                {
                    liThreadTime.QuadPart += (ULONG)(-1) - pWatch->LastKernelTime + 1;
                }

                liThreadTime.QuadPart -= pWatch->LastKernelTime;

                break;

            case WdUserTime:

                liThreadTime.QuadPart = ulUserTime;

                //
                // Handle counter rollovers.
                //

                if (ulUserTime < pWatch->LastUserTime)
                {
                    liThreadTime.QuadPart += (ULONG)(-1) - pWatch->LastUserTime + 1;
                }

                liThreadTime.QuadPart -= pWatch->LastUserTime;

                break;

            case WdFullTime:

                liThreadTime.QuadPart = ulKernelTime + ulUserTime;

                //
                // Handle counter rollovers.
                //

                if (ulKernelTime < pWatch->LastKernelTime)
                {
                    liThreadTime.QuadPart += (ULONG)(-1) - pWatch->LastKernelTime + 1;
                }

                if (ulUserTime < pWatch->LastUserTime)
                {
                    liThreadTime.QuadPart += (ULONG)(-1) - pWatch->LastUserTime + 1;
                }

                liThreadTime.QuadPart -= (pWatch->LastKernelTime + pWatch->LastUserTime);

                break;

            default:

                ASSERT(FALSE);
                liThreadTime.QuadPart = 0;
                break;
            }

            //
            // Convert to milliseconds.
            //

            liThreadTime.QuadPart *= pWatch->TimeIncrement;
            liThreadTime.QuadPart /= 10000;

            if (liThreadTime.QuadPart >= pWatch->Period)
            {
                //
                // We've been stuck long enough - update event type and queue client DPC.
                //

                pWatch->Header.LastEvent = WdTimeoutEvent;

                if (NULL != pWatch->ClientDpc)
                {
                    //
                    // Bump up references to objects we're going to touch in client DPC.
                    //

                    ObReferenceObject(pWatch->Thread);
                    WdReferenceObject(pWatch);

                    //
                    // Queue client DPC.
                    //

                    if (KeInsertQueueDpc(pWatch->ClientDpc, pWatch->Thread, pWatch) == TRUE)
                    {
                        //
                        // Keep track of qeueued thread in case we cancel this DPC.
                        //

                        pWatch->Header.LastQueuedThread = pWatch->Thread;

                        //
                        // Make sure we queue DPC only once per event.
                        //

                        pWatch->Trigger = 2;
                    }
                    else
                    {
                        //
                        // This should never happen.
                        //

                        ObDereferenceObject(pWatch->Thread);
                        WdDereferenceObject(pWatch);
                    }
                }
            }

            break;

        case 2:

            //
            // We have event posted waiting for completion. Nothing to do.
            //

            break;

        default:

            //
            // This should never happen.
            //

            ASSERT(FALSE);
            pWatch->Trigger = 0;
            break;
        }
    }

    //
    // Unlock the dispatcher database.
    //

    KeReleaseSpinLockFromDpcLevel(&(pWatch->Header.SpinLock));

    return;
}   // WdDeferredWatchdogDpcCallback()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\watchdog\gdisup.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    gdisup.c

Abstract:

    This is the NT Watchdog driver implementation.

Author:

    Michael Maciesowicz (mmacie) 05-May-2000

Environment:

    Kernel mode only.

Notes:

    This module cannot be moved to win32k since routines defined here can
    be called at any time and it is possible that win32k may not be mapped
    into running process space at this time (e.g. TS session).

Revision History:

--*/

//
// TODO: This module needs major rework.
//
// 1. We should eliminate all global variables from here and move them into
// GDI context structure.
//
// 2. We should extract generic logging routines
// (e.g. WdWriteErrorLogEntry(pdo, className), WdWriteEventToRegistry(...),
// WdBreakPoint(...) so we can use them for any device class, not just Display.
//
// 3. We should use IoAllocateWorkItem - we could drop some globals then.
//

#include "wd.h"

#include "ntiodump.h"

//
// Undocumented export from kernel to create Minidump 
//

ULONG
KeCapturePersistentThreadState(
    PCONTEXT pContext,
    PETHREAD pThread,
    ULONG ulBugCheckCode,
    ULONG_PTR ulpBugCheckParam1,
    ULONG_PTR ulpBugCheckParam2,
    ULONG_PTR ulpBugCheckParam3,
    ULONG_PTR ulpBugCheckParam4,
    PVOID pvDump
    );

NTSTATUS
PsSetContextThread(
    IN PETHREAD Thread,
    IN PCONTEXT ThreadContext,
    IN KPROCESSOR_MODE Mode
    );

NTSTATUS
PsGetContextThread(
    IN PETHREAD Thread,
    IN OUT PCONTEXT ThreadContext,
    IN KPROCESSOR_MODE Mode
    );

typedef enum _KAPC_ENVIRONMENT {
    OriginalApcEnvironment,
    AttachedApcEnvironment,
    CurrentApcEnvironment,
    InsertApcEnvironment
} KAPC_ENVIRONMENT;

NTKERNELAPI
VOID
KeInitializeApc (
    IN PRKAPC Apc,
    IN PRKTHREAD Thread,
    IN KAPC_ENVIRONMENT Environment,
    IN PKKERNEL_ROUTINE KernelRoutine,
    IN PKRUNDOWN_ROUTINE RundownRoutine OPTIONAL,
    IN PKNORMAL_ROUTINE NormalRoutine OPTIONAL,
    IN KPROCESSOR_MODE ProcessorMode OPTIONAL,
    IN PVOID NormalContext OPTIONAL
    );

NTKERNELAPI
BOOLEAN
KeInsertQueueApc (
    IN PRKAPC Apc,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2,
    IN KPRIORITY Increment
    );

#define WD_HANDLER_IDLE             0
#define WD_HANDLER_BUSY                     1
#define WD_GDI_STRESS_BREAK_POINT_DELAY     15

typedef struct _BUGCHECK_DATA
{
    ULONG ulBugCheckCode;
    ULONG_PTR ulpBugCheckParameter1;
    ULONG_PTR ulpBugCheckParameter2;
    ULONG_PTR ulpBugCheckParameter3;
    ULONG_PTR ulpBugCheckParameter4;
} BUGCHECK_DATA, *PBUGCHECK_DATA;

VOID
WdBugCheckStuckDriver(
    IN PVOID Context
    );

VOID
VpNotifyEaData(
    PDEVICE_OBJECT DeviceObject,
    PVOID pvDump
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, WdBugCheckStuckDriver)
#endif

#if defined(_IA64_)
#define PSR_RI      41
#define PSR_CPL     32

typedef struct _FRAME_MARKER {
    union {
        struct {
            ULONGLONG sof : 7;
            ULONGLONG sol : 7;
            ULONGLONG sor : 4;
            ULONGLONG rrbgr : 7;
            ULONGLONG rrbfr : 7;
            ULONGLONG rrbpr : 6;
        } f;
        ULONGLONG Ulong64;
    } u;
} FRAME_MARKER;
#endif

BOOLEAN
WdDisableRecovery = FALSE;

BUGCHECK_DATA
g_WdBugCheckData = {0, 0, 0, 0, 0};

WORK_QUEUE_ITEM
g_WdWorkQueueItem;

LONG 
g_lDisplayHandlerState = WD_HANDLER_IDLE;

//
// TODO:
//
// This structure is defined in ntexapi.h.  Find a way to include
// this here.
//

typedef struct _PIMAGE_EXPORT_DIRECTORY IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;

typedef struct _SYSTEM_GDI_DRIVER_INFORMATION {
    UNICODE_STRING DriverName;
    PVOID ImageAddress;
    PVOID SectionPointer;
    PVOID EntryPoint;
    PIMAGE_EXPORT_DIRECTORY ExportSectionPointer;
    ULONG ImageLength;
} SYSTEM_GDI_DRIVER_INFORMATION, *PSYSTEM_GDI_DRIVER_INFORMATION;

typedef enum _HARDERROR_RESPONSE_OPTION {
     OptionAbortRetryIgnore,
     OptionOk,
     OptionOkCancel,
     OptionRetryCancel,
     OptionYesNo,
     OptionYesNoCancel,
     OptionShutdownSystem,
     OptionOkNoWait,
     OptionCancelTryContinue
} HARDERROR_RESPONSE_OPTION;

NTKERNELAPI
NTSTATUS
ExRaiseHardError(
    IN NTSTATUS ErrorStatus,
    IN ULONG NumberOfParameters,
    IN ULONG UnicodeStringParameterMask,
    IN PULONG_PTR Parameters,
    IN ULONG ValidResponseOptions,
    OUT PULONG Response
    );

//
// TODO:
//
// Find a way to share the same LDEV structure used by GDI.
//

typedef struct _LDEV {

    struct _LDEV   *pldevNext;      // link to the next LDEV in list
    struct _LDEV   *pldevPrev;      // link to the previous LDEV in list

    PSYSTEM_GDI_DRIVER_INFORMATION pGdiDriverInfo; // Driver module handle.

} LDEV, *PLDEV;

//
// TODO:
//
// this structure is defined here, and in gre\os.cxx.  We need to find
// the proper .h file to put it in.
//

typedef struct _WATCHDOG_DPC_CONTEXT
{
    PLDEV *ppldevDrivers;
    HANDLE hDriver;
    UNICODE_STRING DisplayDriverName;
} WATCHDOG_DPC_CONTEXT, *PWATCHDOG_DPC_CONTEXT;

WATCHDOGAPI
VOID
WdDdiWatchdogDpcCallback(
    IN PKDPC pDpc,
    IN PVOID pDeferredContext,
    IN PVOID pSystemArgument1,
    IN PVOID pSystemArgument2
    )

/*++

Routine Description:

    This function is a DPC callback routine for GDI watchdog. It is only
    called when GDI watchdog times out before it is cancelled. It schedules
    a work item to bugcheck the machine in the context of system worker
    thread.

Arguments:

    pDpc - Supplies a pointer to a DPC object.

    pDeferredContext - Supplies a pointer to a GDI defined context.

    pSystemArgument1 - Supplies a pointer to a spinning thread object (PKTHREAD).

    pSystemArgument2 - Supplies a pointer to a watchdog object (PDEFERRED_WATCHDOG).

Return Value:

    None.

--*/

{
    //
    // Make sure we handle only one event at the time.
    //
    // Note: Timeout and recovery events for the same watchdog object are
    // synchronized already in timer DPC.
    //

    if (InterlockedCompareExchange(&g_lDisplayHandlerState,
                                   WD_HANDLER_BUSY,
                                   WD_HANDLER_IDLE) == WD_HANDLER_IDLE)
    {
        g_WdBugCheckData.ulBugCheckCode = THREAD_STUCK_IN_DEVICE_DRIVER;
        g_WdBugCheckData.ulpBugCheckParameter1 = (ULONG_PTR)(pSystemArgument1);
        g_WdBugCheckData.ulpBugCheckParameter2 = (ULONG_PTR)(pSystemArgument2);
        g_WdBugCheckData.ulpBugCheckParameter3 = (ULONG_PTR)(pDeferredContext);
        g_WdBugCheckData.ulpBugCheckParameter4++;

        ExInitializeWorkItem(&g_WdWorkQueueItem, WdBugCheckStuckDriver, &g_WdBugCheckData);
        ExQueueWorkItem(&g_WdWorkQueueItem, CriticalWorkQueue);
    }
    else
    {
        //
        // Resume watchdog event processing.
        //

        WdCompleteEvent(pSystemArgument2, (PKTHREAD)pSystemArgument1);
    }

    return;
}   // WdDdiWatchdogDpcCallback()

#define MAKESOFTWAREEXCEPTION(Severity, Facility, Exception) \
    ((ULONG) ((Severity << 30) | (1 << 29) | (Facility << 16) | (Exception)))

#define SE_THREAD_STUCK MAKESOFTWAREEXCEPTION(3,0,1)

VOID
RaiseExceptionInThread(
    VOID
    )

{
    ExRaiseStatus(SE_THREAD_STUCK);
}

typedef struct _WATCHDOG_CONTEXT_DATA
{
    PKEVENT pInjectionEvent;
    PKTHREAD pThread;
    PLDEV *ppldevDrivers;
    PWATCHDOG_DPC_CONTEXT pWatchdogContext;
    BOOLEAN bRecoveryAttempted;
    PBUGCHECK_DATA pBugCheckData;
    PVOID pvDump;
    ULONG ulDumpSize;
} WATCHDOG_CONTEXT_DATA, *PWATCHDOG_CONTEXT_DATA;

VOID
WatchdogKernelApc(
    IN PKAPC Apc,
    OUT PKNORMAL_ROUTINE *NormalRoutine,
    IN OUT PVOID NormalContext,
    IN OUT PVOID *SystemArgument1,
    IN OUT PVOID *SystemArgument2
    )

{
    PKEVENT pInjectionEvent;
    CONTEXT Context;
    PWATCHDOG_CONTEXT_DATA pContextData = (PWATCHDOG_CONTEXT_DATA) *SystemArgument1;
    ULONG_PTR ImageStart;
    ULONG_PTR ImageStop;
    PETHREAD pThread;
    NTSTATUS Status;
    PLDEV pldev;

    UNREFERENCED_PARAMETER (Apc);
    UNREFERENCED_PARAMETER (NormalRoutine);

    pInjectionEvent = pContextData->pInjectionEvent;
    pldev = *pContextData->ppldevDrivers;

    pThread = PsGetCurrentThread();

    //
    // Initialize the context.
    //

    memset(&Context, 0, sizeof(Context));
    Context.ContextFlags = CONTEXT_FULL;

    //
    // get the kernel context for this thread
    //

    if (NT_SUCCESS(PsGetContextThread(pThread, &Context, KernelMode))) {

        //
        // Capture the context so we can use it in a minidump.
        //

        pContextData->ulDumpSize = KeCapturePersistentThreadState(
                                        &Context,
                                        pThread,
                                        pContextData->pBugCheckData->ulBugCheckCode,
                                        pContextData->pBugCheckData->ulpBugCheckParameter1,
                                        pContextData->pBugCheckData->ulpBugCheckParameter2,
                                        pContextData->pBugCheckData->ulpBugCheckParameter3,
                                        pContextData->pBugCheckData->ulpBugCheckParameter4,
                                        pContextData->pvDump);
        //
        // We can safely touch the pldev's (which live in session space)
        // because this thread came from a process that has the session
        // space mapped in.
        //
    
        while (pldev) {
    
            if (pldev->pGdiDriverInfo) {
    
                ImageStart = (ULONG_PTR)pldev->pGdiDriverInfo->ImageAddress;
                ImageStop = ImageStart + (ULONG_PTR)pldev->pGdiDriverInfo->ImageLength - 1;
    
                //
                // Modify the context to inject a fault into the thread
                // when it starts running again (after APC returns)
                //
    
#if defined(_X86_)
                if ((Context.Eip >= ImageStart) && (Context.Eip <= ImageStop)) {
                    Context.Eip = (ULONG)RaiseExceptionInThread;
    
                    //
                    // set the modified context record
                    //
        
                    Context.ContextFlags = CONTEXT_CONTROL;
                    PsSetContextThread(pThread, &Context, KernelMode);
                    pContextData->bRecoveryAttempted = TRUE;
                    break;
                }
#elif defined(_IA64_)
                if ((Context.StIIP >= ImageStart) && (Context.StIIP <= ImageStop)) {
    
                    FRAME_MARKER Cfm;
    
                    PULONGLONG pullTemp = (PULONGLONG)RaiseExceptionInThread;
    
                    //
                    // Set the return address
                    //
    
                    Context.BrRp = Context.StIIP;
    
                    //
                    // Update the frame markers
                    //
    
                    Context.RsPFS = Context.StIFS & 0x3FFFFFFFFFi64;
                    Context.RsPFS |= (Context.ApEC & (0x3fi64 << 52));
                    Context.RsPFS |= (((Context.StIPSR >> PSR_CPL) & 0x3) << 62);
    
                    Cfm.u.Ulong64 = Context.StIFS;
                    Cfm.u.f.sof -= Cfm.u.f.sol;
                    Cfm.u.f.sol = 0;
                    Cfm.u.f.sor = 0;
                    Cfm.u.f.rrbgr = 0;
                    Cfm.u.f.rrbfr = 0;
                    Cfm.u.f.rrbpr = 0;
    
                    Context.StIFS = Cfm.u.Ulong64;
                    Context.StIFS |= 0x8000000000000000;
    
                    //
                    // Emulate the call
                    //
    
                    Context.StIIP = *pullTemp;
                    Context.IntGp = *(pullTemp+1);
                    Context.StIPSR &= ~((ULONGLONG) 3 << PSR_RI);
    
                    //
                    // set the modified context record
                    //
    
                    Context.ContextFlags = CONTEXT_CONTROL;
                    PsSetContextThread(pThread, &Context, KernelMode);
                    pContextData->bRecoveryAttempted = TRUE;
                    break;
                }
#endif
            }
    
            pldev = pldev->pldevNext;
        }
        
        //
        // Notify the videoprt of the device object, and context of the
        // thread causing the EA.
        //

        VpNotifyEaData(pContextData->pWatchdogContext->hDriver, 
                       pContextData->ulDumpSize ? pContextData->pvDump : NULL);
    
        //
        // Single our event so the caller knows we did something
        //        

        KeSetEvent(pInjectionEvent, 0, FALSE);
    }
}

BOOLEAN
WatchdogInjectExceptionIntoThread(
    PKTHREAD pThread,
    PWATCHDOG_DPC_CONTEXT pWdContext
    )

{
    KAPC Apc;
    KEVENT InjectionEvent;
    WATCHDOG_CONTEXT_DATA ContextData;
    
    
    //
    // Prepare all needed data for minidump creation
    //
    
    RtlZeroMemory(&ContextData, sizeof(ContextData));

    ContextData.pThread = pThread;
    ContextData.pInjectionEvent = &InjectionEvent;
    ContextData.ppldevDrivers = pWdContext->ppldevDrivers;
    ContextData.pWatchdogContext = pWdContext;
    ContextData.bRecoveryAttempted = FALSE;
    
    ContextData.pvDump = ExAllocatePoolWithTag(PagedPool,
                                               TRIAGE_DUMP_SIZE + 0x1000, // XXX olegk - why 1000? why not 2*TRIAGE_DUMP_SIZE?
                                               WD_TAG);
    
    ContextData.pBugCheckData = &g_WdBugCheckData;

    KeInitializeEvent(&InjectionEvent, NotificationEvent, FALSE);

    KeInitializeApc(&Apc,
                    pThread,
                    OriginalApcEnvironment,
                    WatchdogKernelApc,
                    NULL,
                    NULL,
                    KernelMode,
                    NULL);

    if (KeInsertQueueApc(&Apc, &ContextData, NULL, 0)) 
    {
        KeWaitForSingleObject(&InjectionEvent,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

	//
	// We need this wait because ContextData.bRecoveryAttempted is
	// set in the APC and we need to wait on the result.
	//

	KeClearEvent(&InjectionEvent);
    }

    return ContextData.bRecoveryAttempted;
}

VOID
WdBugCheckStuckDriver(
    IN PVOID pContext
    )

/*++

Routine Description:

    This function is a worker callback routine for GDI watchdog DPC.

Arguments:

    pContext - Supplies a pointer to a watchdog defined context.

Return Value:

    None.

--*/

{
    static BOOLEAN s_bFirstTime = TRUE;
    static BOOLEAN s_bDbgBreak = FALSE;
    static BOOLEAN s_bEventLogged = FALSE;
    static ULONG s_ulTrapOnce = WD_DEFAULT_TRAP_ONCE;
    static ULONG s_ulDisableBugcheck = WD_DEFAULT_DISABLE_BUGCHECK;
    static ULONG s_ulBreakPointDelay = WD_GDI_STRESS_BREAK_POINT_DELAY;
    static ULONG s_ulCurrentBreakPointDelay = WD_GDI_STRESS_BREAK_POINT_DELAY;
    static ULONG s_ulBreakCount = 0;
    static ULONG s_ulEventCount = 0;
    static ULONG s_ulEaRecovery = 0;
    static ULONG s_ulFullRecovery = 0;

    PBUGCHECK_DATA pBugCheckData;
    PKTHREAD pThread;
    PDEFERRED_WATCHDOG pWatch;
    PUNICODE_STRING pUnicodeDriverName;
    PDEVICE_OBJECT pFdo;
    PDEVICE_OBJECT pPdo;
    NTSTATUS ntStatus;
    WD_EVENT_TYPE lastEvent;
    PWATCHDOG_DPC_CONTEXT WatchdogContext;
    BOOLEAN Recovered = FALSE;

    PAGED_CODE();
    ASSERT(NULL != pContext);

    pBugCheckData = (PBUGCHECK_DATA)pContext;
    WatchdogContext = (PWATCHDOG_DPC_CONTEXT)pBugCheckData->ulpBugCheckParameter3;
    pThread = (PKTHREAD)(pBugCheckData->ulpBugCheckParameter1);
    pWatch = (PDEFERRED_WATCHDOG)(pBugCheckData->ulpBugCheckParameter2);
    pUnicodeDriverName = &WatchdogContext->DisplayDriverName;

    //
    // Note: pThread is NULL for recovery events.
    //

    ASSERT(NULL != pWatch);
    ASSERT(NULL != pUnicodeDriverName);

    pFdo = WdGetDeviceObject(pWatch);
    pPdo = WdGetLowestDeviceObject(pWatch);

    ASSERT(NULL != pFdo);
    ASSERT(NULL != pPdo);

    lastEvent = WdGetLastEvent(pWatch);

    ASSERT((WdTimeoutEvent == lastEvent) || (WdRecoveryEvent == lastEvent));

    //
    // Grab configuration data from the registry on first timeout.
    //

    if (TRUE == s_bFirstTime)
    {
        ULONG ulDefaultTrapOnce = WD_DEFAULT_TRAP_ONCE;
        ULONG ulDefaultDisableBugcheck = WD_DEFAULT_DISABLE_BUGCHECK;
        ULONG ulDefaultBreakPointDelay = WD_GDI_STRESS_BREAK_POINT_DELAY;
        ULONG ulDefaultBreakCount = 0;
        ULONG ulDefaultEventCount = 0;
        ULONG ulDefaultEaRecovery = 0;
        ULONG ulDefaultFullRecovery = 0;

        RTL_QUERY_REGISTRY_TABLE queryTable[] =
        {
            {NULL, RTL_QUERY_REGISTRY_DIRECT, L"TrapOnce", &s_ulTrapOnce, REG_DWORD, &ulDefaultTrapOnce, 4},
            {NULL, RTL_QUERY_REGISTRY_DIRECT, L"DisableBugcheck", &s_ulDisableBugcheck, REG_DWORD, &ulDefaultDisableBugcheck, 4},
            {NULL, RTL_QUERY_REGISTRY_DIRECT, L"BreakPointDelay", &s_ulBreakPointDelay, REG_DWORD, &ulDefaultBreakPointDelay, 4},
            {NULL, RTL_QUERY_REGISTRY_DIRECT, L"BreakCount", &s_ulBreakCount, REG_DWORD, &ulDefaultBreakCount, 4},
            {NULL, RTL_QUERY_REGISTRY_DIRECT, L"EventCount", &s_ulEventCount, REG_DWORD, &ulDefaultEventCount, 4},
            {NULL, RTL_QUERY_REGISTRY_DIRECT, L"EaRecovery", &s_ulEaRecovery, REG_DWORD, &ulDefaultEaRecovery, 4},
            {NULL, RTL_QUERY_REGISTRY_DIRECT, L"FullRecovery", &s_ulFullRecovery, REG_DWORD, &ulDefaultFullRecovery, 4},
            {NULL, 0, NULL}
        };

        //
        // Get configurable values and accumulated statistics from registry.
        //

        RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                               WD_KEY_WATCHDOG_DISPLAY,
                               queryTable,
                               NULL,
                               NULL);

        //
        // Rolling down counter to workaround GDI slowness in some stress cases.
        //

        s_ulCurrentBreakPointDelay = s_ulBreakPointDelay;

#if !defined(_X86_)

        //
        // For now, don't try to recover on non-x86 platforms
        //

        s_ulEaRecovery = FALSE;
#endif

    }

    //
    // Handle current event.
    //

    if (WdTimeoutEvent == lastEvent)
    {
        //
        // Timeout.
        //

        ULONG ulDebuggerNotPresent;
        BOOLEAN bBreakIn;

        ASSERT(NULL != pThread);

        ulDebuggerNotPresent = 1;
        bBreakIn = FALSE;

        if ((TRUE == KD_DEBUGGER_ENABLED) && (FALSE == KD_DEBUGGER_NOT_PRESENT))
        {
            //
            // Give a chance to debug a spinning code if kernel debugger is connected.
            //

            ulDebuggerNotPresent = 0;

            if ((0 == s_ulTrapOnce) || (FALSE == s_bDbgBreak))
            {
                //
                // Print out info to debugger and break in if we timed out enought times already.
                // Hopefuly one day GDI becomes fast enough and we won't have to set any delays.
                //

                if (0 == s_ulCurrentBreakPointDelay)
                {
                    s_ulCurrentBreakPointDelay = s_ulBreakPointDelay;

                    DbgPrint("\n");
                    DbgPrint("*******************************************************************************\n");
                    DbgPrint("*                                                                             *\n");
                    DbgPrint("*  The watchdog detected a timeout condition. We broke into the debugger to   *\n");
                    DbgPrint("*  allow a chance for debugging this failure.                                 *\n");
                    DbgPrint("*                                                                             *\n");
                    DbgPrint("*  Normally the system will try to recover from this failure and return to a  *\n");
                    DbgPrint("*  VGA graphics mode.  To disable the recovery feature edit the videoprt      *\n");
                    DbgPrint("*  variable VpDisableRecovery.  This will allow you to debug your driver.     *\n");
                    DbgPrint("*  i.e. execute ed watchdog!WdDisableRecovery 1.                              *\n");
                    DbgPrint("*                                                                             *\n");
                    DbgPrint("*  Intercepted bugcheck code and arguments are listed below this message.     *\n");
                    DbgPrint("*  You can use them the same way as you would in case of the actual break,    *\n");
                    DbgPrint("*  i.e. execute .thread Arg1 then kv to identify an offending thread.         *\n");
                    DbgPrint("*                                                                             *\n");
                    DbgPrint("*******************************************************************************\n");
                    DbgPrint("\n");
                    DbgPrint("*** Intercepted Fatal System Error: 0x%08X\n", pBugCheckData->ulBugCheckCode);
                    DbgPrint("    (0x%p,0x%p,0x%p,0x%p)\n\n",
                    pBugCheckData->ulpBugCheckParameter1,
                    pBugCheckData->ulpBugCheckParameter2,
                    pBugCheckData->ulpBugCheckParameter3,
                    pBugCheckData->ulpBugCheckParameter4);
                    DbgPrint("Driver at fault: %ws\n\n", pUnicodeDriverName->Buffer);

                    bBreakIn = TRUE;
                    s_bDbgBreak = TRUE;
                    s_ulBreakCount++;
                }
                else
                {
                    DbgPrint("Watchdog: Timeout in %ws. Break in %d\n",
                             pUnicodeDriverName->Buffer,
                             s_ulCurrentBreakPointDelay);

                    s_ulCurrentBreakPointDelay--;
                }
            }

            //
            // Make sure we won't bugcheck if we have kernel debugger connected.
            //

            s_ulDisableBugcheck = 1;
        }
        else if (0 == s_ulDisableBugcheck)
        {
            s_ulBreakCount++;
        }

        //
        // Log error (only once unless we recover).
        //

        if ((FALSE == s_bEventLogged) && ((TRUE == bBreakIn) || ulDebuggerNotPresent))
        {
            PIO_ERROR_LOG_PACKET pIoErrorLogPacket;
            ULONG ulPacketSize;
            USHORT usNumberOfStrings;
            PWCHAR wszDeviceClass = L"display";
            ULONG ulClassSize = sizeof (L"display");

            ulPacketSize = sizeof (IO_ERROR_LOG_PACKET);
            usNumberOfStrings = 0;

            //
            // For event log message:
            //
            // %1 = fixed device description (this is set by event log itself)
            // %2 = string 1 = device class starting in lower case
            // %3 = string 2 = driver name
            //

            if ((ulPacketSize + ulClassSize) <= ERROR_LOG_MAXIMUM_SIZE)
            {
                ulPacketSize += ulClassSize;
                usNumberOfStrings++;

                //
                // We're looking at MaximumLength since it includes terminating UNICODE_NULL.
                //

                if ((ulPacketSize + pUnicodeDriverName->MaximumLength) <= ERROR_LOG_MAXIMUM_SIZE)
                {
                    ulPacketSize += pUnicodeDriverName->MaximumLength;
                    usNumberOfStrings++;
                }
            }

            pIoErrorLogPacket = IoAllocateErrorLogEntry(pFdo, (UCHAR)ulPacketSize);

            if (pIoErrorLogPacket)
            {
                pIoErrorLogPacket->MajorFunctionCode = 0;
                pIoErrorLogPacket->RetryCount = 0;
                pIoErrorLogPacket->DumpDataSize = 0;
                pIoErrorLogPacket->NumberOfStrings = usNumberOfStrings;
                pIoErrorLogPacket->StringOffset = (USHORT)FIELD_OFFSET(IO_ERROR_LOG_PACKET, DumpData);
                pIoErrorLogPacket->EventCategory = 0;
                pIoErrorLogPacket->ErrorCode = IO_ERR_THREAD_STUCK_IN_DEVICE_DRIVER;
                pIoErrorLogPacket->UniqueErrorValue = 0;
                pIoErrorLogPacket->FinalStatus = STATUS_SUCCESS;
                pIoErrorLogPacket->SequenceNumber = 0;
                pIoErrorLogPacket->IoControlCode = 0;
                pIoErrorLogPacket->DeviceOffset.QuadPart = 0;

                if (usNumberOfStrings > 0)
                {
                    RtlCopyMemory(&(pIoErrorLogPacket->DumpData[0]),
                                  wszDeviceClass,
                                  ulClassSize);

                    if (usNumberOfStrings > 1)
                    {
                        RtlCopyMemory((PUCHAR)&(pIoErrorLogPacket->DumpData[0]) + ulClassSize,
                                      pUnicodeDriverName->Buffer,
                                      pUnicodeDriverName->MaximumLength);
                    }
                }

                IoWriteErrorLogEntry(pIoErrorLogPacket);

                s_bEventLogged = TRUE;
            }
        }

        //
        // Write reliability info into registry. Setting ShutdownEventPending will trigger winlogon
        // to run savedump where we're doing our boot-time handling of watchdog events for DrWatson.
        //
        // Note: We are only allowed to set ShutdownEventPending, savedump is the only component
        // allowed to clear this value. Even if we recover from watchdog timeout we'll keep this
        // value set, savedump will be able to figure out if we recovered or not.
        //

        if (TRUE == s_bFirstTime)
        {
            ULONG ulValue = 1;

            //
            // Set ShutdownEventPending flag.
            //

            ntStatus = RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                             WD_KEY_RELIABILITY,
                                             L"ShutdownEventPending",
                                             REG_DWORD,
                                             &ulValue,
                                             sizeof (ulValue));

            if(NT_SUCCESS(ntStatus))
            {
                WdFlushRegistryKey(pWatch, WD_KEY_RELIABILITY);
            }
            else
            {
                //
                // Reliability key should be always reliable there.
                //

                ASSERT(FALSE);
            }
        }

        //
        // Write watchdog event info into registry.
        //

        if ((0 == s_ulTrapOnce) || (TRUE == s_bFirstTime))
        {
            //
            // Is Watchdog\Display key already there?
            //

            ntStatus = RtlCheckRegistryKey(RTL_REGISTRY_ABSOLUTE,
                                           WD_KEY_WATCHDOG_DISPLAY);

            if (!NT_SUCCESS(ntStatus))
            {
                //
                // Is Watchdog key already there?
                //

                ntStatus = RtlCheckRegistryKey(RTL_REGISTRY_ABSOLUTE,
                                               WD_KEY_WATCHDOG);

                if (!NT_SUCCESS(ntStatus))
                {
                    //
                    // Create a new key.
                    //

                    ntStatus = RtlCreateRegistryKey(RTL_REGISTRY_ABSOLUTE,
                                                    WD_KEY_WATCHDOG);
                }

                if (NT_SUCCESS(ntStatus))
                {
                    //
                    // Create a new key.
                    //

                    ntStatus = RtlCreateRegistryKey(RTL_REGISTRY_ABSOLUTE,
                                                    WD_KEY_WATCHDOG_DISPLAY);
                }
            }

            if (NT_SUCCESS(ntStatus))
            {
                PVOID pvPropertyBuffer;
                ULONG ulLength;
                ULONG ulValue;

                //
                // Set values maintained by watchdog.
                //

                ulValue = 1;

                RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                      WD_KEY_WATCHDOG_DISPLAY,
                                      L"EventFlag",
                                      REG_DWORD,
                                      &ulValue,
                                      sizeof (ulValue));

                s_ulEventCount++;

                RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                      WD_KEY_WATCHDOG_DISPLAY,
                                      L"EventCount",
                                      REG_DWORD,
                                      &s_ulEventCount,
                                      sizeof (s_ulEventCount));

                RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                      WD_KEY_WATCHDOG_DISPLAY,
                                      L"BreakCount",
                                      REG_DWORD,
                                      &s_ulBreakCount,
                                      sizeof (s_ulBreakCount));

                ulValue = !s_ulDisableBugcheck;

                RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                      WD_KEY_WATCHDOG_DISPLAY,
                                      L"BugcheckTriggered",
                                      REG_DWORD,
                                      &ulValue,
                                      sizeof (ulValue));

                RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                      WD_KEY_WATCHDOG_DISPLAY,
                                      L"DebuggerNotPresent",
                                      REG_DWORD,
                                      &ulDebuggerNotPresent,
                                      sizeof (ulDebuggerNotPresent));

                RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                      WD_KEY_WATCHDOG_DISPLAY,
                                      L"DriverName",
                                      REG_SZ,
                                      pUnicodeDriverName->Buffer,
                                      pUnicodeDriverName->MaximumLength);

                //
                // Delete other values in case allocation or property read fails.
                //

                RtlDeleteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                       WD_KEY_WATCHDOG_DISPLAY,
                                       L"DeviceClass");

                RtlDeleteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                       WD_KEY_WATCHDOG_DISPLAY,
                                       L"DeviceDescription");

                RtlDeleteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                       WD_KEY_WATCHDOG_DISPLAY,
                                       L"DeviceFriendlyName");

                RtlDeleteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                       WD_KEY_WATCHDOG_DISPLAY,
                                       L"HardwareID");

                RtlDeleteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                       WD_KEY_WATCHDOG_DISPLAY,
                                       L"Manufacturer");

                //
                // Allocate buffer for device properties reads.
                //
                // Note: Legacy devices don't have PDOs and we can't query properties
                // for them. Calling IoGetDeviceProperty() with FDO upsets Verifier.
                // In legacy case lowest device object is the same as FDO, we check
                // against this and if this is the case we won't allocate property
                // buffer and we'll skip the next block.
                //

                if (pFdo != pPdo)
                {
                    pvPropertyBuffer = ExAllocatePoolWithTag(PagedPool,
                                                             WD_MAX_PROPERTY_SIZE,
                                                             WD_TAG);
                }
                else
                {
                    pvPropertyBuffer = NULL;
                }

                if (pvPropertyBuffer)
                {
                    //
                    // Read and save device properties.
                    //

                    ntStatus = IoGetDeviceProperty(pPdo,
                                                   DevicePropertyClassName,
                                                   WD_MAX_PROPERTY_SIZE,
                                                   pvPropertyBuffer,
                                                   &ulLength);

                    if (NT_SUCCESS(ntStatus))
                    {
                        RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                              WD_KEY_WATCHDOG_DISPLAY,
                                              L"DeviceClass",
                                              REG_SZ,
                                              pvPropertyBuffer,
                                              ulLength);
                    }

                    ntStatus = IoGetDeviceProperty(pPdo,
                                                   DevicePropertyDeviceDescription,
                                                   WD_MAX_PROPERTY_SIZE,
                                                   pvPropertyBuffer,
                                                   &ulLength);

                    if (NT_SUCCESS(ntStatus))
                    {
                        RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                              WD_KEY_WATCHDOG_DISPLAY,
                                              L"DeviceDescription",
                                              REG_SZ,
                                              pvPropertyBuffer,
                                              ulLength);
                    }

                    ntStatus = IoGetDeviceProperty(pPdo,
                                                   DevicePropertyFriendlyName,
                                                   WD_MAX_PROPERTY_SIZE,
                                                   pvPropertyBuffer,
                                                   &ulLength);

                    if (NT_SUCCESS(ntStatus))
                    {
                        RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                              WD_KEY_WATCHDOG_DISPLAY,
                                              L"DeviceFriendlyName",
                                              REG_SZ,
                                              pvPropertyBuffer,
                                              ulLength);
                    }

                    ntStatus = IoGetDeviceProperty(pPdo,
                                                   DevicePropertyHardwareID,
                                                   WD_MAX_PROPERTY_SIZE,
                                                   pvPropertyBuffer,
                                                   &ulLength);

                    if (NT_SUCCESS(ntStatus))
                    {
                        RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                              WD_KEY_WATCHDOG_DISPLAY,
                                              L"HardwareID",
                                              REG_MULTI_SZ,
                                              pvPropertyBuffer,
                                              ulLength);
                    }

                    ntStatus = IoGetDeviceProperty(pPdo,
                                                   DevicePropertyManufacturer,
                                                   WD_MAX_PROPERTY_SIZE,
                                                   pvPropertyBuffer,
                                                   &ulLength);

                    if (NT_SUCCESS(ntStatus))
                    {
                        RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                              WD_KEY_WATCHDOG_DISPLAY,
                                              L"Manufacturer",
                                              REG_SZ,
                                              pvPropertyBuffer,
                                              ulLength);
                    }

                    //
                    // Release property buffer.
                    //

                    ExFreePool(pvPropertyBuffer);
                    pvPropertyBuffer = NULL;
                }

                if (TRUE == s_bFirstTime)
                {
                    //
                    // Knock down Shutdown flag. Videoprt always sets this value upon receiving
                    // IRP_MN_SHUTDOWN. If the value is not there on the next boot we will know
                    // that user rebooted dirty.
                    //
                    // TODO: Drop it (and the stuff in videoprt) once we have NtQueryLastShutDownType()
                    // API implemented.
                    //

                    ulValue = 0;

                    RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                          WD_KEY_WATCHDOG_DISPLAY,
                                          L"Shutdown",
                                          REG_DWORD,
                                          &ulValue,
                                          sizeof (ulValue));
                }
            }

            //
            // Flush registry in case we're going to break in / bugcheck or if this is first time.
            //

            if ((TRUE == s_bFirstTime) || (TRUE == bBreakIn) || (0 == s_ulDisableBugcheck))
            {
                WdFlushRegistryKey(pWatch, WD_KEY_WATCHDOG_DISPLAY);
            }
        }

        //
        // Notify the videoprt of the device object causing the failure.
        //
    
        VpNotifyEaData(WatchdogContext->hDriver, NULL);

        //
        // Bugcheck machine without kernel debugger connected and with bugcheck EA enabled.
        // Bugcheck EA is enabled on SKUs below Server.
        //

        if (1 == ulDebuggerNotPresent)
        {
	    if (s_ulEaRecovery)
            {
                Recovered = WatchdogInjectExceptionIntoThread(pThread, WatchdogContext);
            }
    
    
            if ((0 == s_ulDisableBugcheck) && (FALSE == Recovered))
            {
                KeBugCheckEx(pBugCheckData->ulBugCheckCode,
                             pBugCheckData->ulpBugCheckParameter1,
                             pBugCheckData->ulpBugCheckParameter2,
                             (ULONG_PTR)pUnicodeDriverName,
                             pBugCheckData->ulpBugCheckParameter4);
            }
        }
        else
        {
            if (TRUE == bBreakIn)
            {
                DbgBreakPoint();
    
                if (s_ulEaRecovery && (WdDisableRecovery == FALSE))
                {
		    Recovered = WatchdogInjectExceptionIntoThread(pThread, WatchdogContext);
                }
            }
        }
    }
    else
    {
	//
	// Recovery - knock down EventFlag in registry and update statics.
	//

	RtlDeleteRegistryValue(RTL_REGISTRY_ABSOLUTE,
			       WD_KEY_WATCHDOG_DISPLAY,
			       L"EventFlag");

        s_bEventLogged = FALSE;
        s_ulCurrentBreakPointDelay = s_ulBreakPointDelay;
    }

    //
    // Reenable event processing in this module.
    //

    s_bFirstTime = FALSE;
    InterlockedExchange(&g_lDisplayHandlerState, WD_HANDLER_IDLE);

    //
    // Dereference objects and resume watchdog event processing.
    //

    ObDereferenceObject(pFdo);
    ObDereferenceObject(pPdo);
    WdCompleteEvent(pWatch, pThread);

    //
    // If we Recovered then raise a hard error notifing the user
    // of the situation.  We do this here because the raise hard error
    // is synchronous and waits for user input.  So we'll raise the hard
    // error after everything else is done.
    //

    if (Recovered) {

	static ULONG ulHardErrorInProgress = FALSE;

	//
	// If we hang and recover several times, don't allow more than
	// one dialog to appear on the screen.	Only allow the dialog
	// to pop up again, after the user has hit "ok".
	//

	if (InterlockedCompareExchange(&ulHardErrorInProgress,
				       TRUE,
				       FALSE) == FALSE) {

	    ULONG Response;

	    ExRaiseHardError(0xC0000415, //STATUS_HUNG_DISPLAY_DRIVER_THREAD
			     1,
			     1,
			     (PULONG_PTR)&pUnicodeDriverName,
			     OptionOk,
			     &Response);

	    InterlockedExchange(&ulHardErrorInProgress, FALSE);
	}
    }

    return;
}   // WdBugCheckStuckDriver()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\watchdog\watchdog.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    watchdog.c

Abstract:

    This is the NT Watchdog driver implementation.

Author:

    Michael Maciesowicz (mmacie) 05-May-2000

Environment:

    Kernel mode only.

Notes:

Revision History:

--*/

#include "wd.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text (INIT, DriverEntry)
#pragma alloc_text (PAGE, WdAllocateWatchdog)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT pDriverObject,
    IN PUNICODE_STRING wszRegistryPath
    )

/*++

Routine Description:

    Temporary entry point needed to initialize the watchdog driver.
    This function is never called because we are loaded as a DLL
    by other drivers.

Arguments:

    pDriverObject   - Not used.
    wszRegistryPath - Not used.

Return Value:

   STATUS_SUCCESS

--*/

{
    UNREFERENCED_PARAMETER(pDriverObject);
    UNREFERENCED_PARAMETER(wszRegistryPath);
    ASSERT(FALSE);

    return STATUS_SUCCESS;
}   // DriverEntry()

WATCHDOGAPI
PWATCHDOG
WdAllocateWatchdog(
    IN PDEVICE_OBJECT pDeviceObject,
    IN WD_TIME_TYPE timeType,
    IN ULONG ulTag
    )

/*++

Routine Description:

    This function allocates storage and initializes
    a watchdog object.

Arguments:

    pDeviceObject - Points to DEVICE_OBJECT associated with watchdog.

    timeType - Kernel, User, Both thread time to monitor.

    ulTag - A tag identifying owner.

Return Value:

    Pointer to allocated watchdog object or NULL.

--*/

{
    PWATCHDOG pWatch;

    PAGED_CODE();
    ASSERT((timeType >= WdKernelTime) && (timeType <= WdFullTime));

    //
    // Allocate storage for watchdog object from non-paged pool.
    //

    pWatch = (PWATCHDOG)ExAllocatePoolWithTag(NonPagedPool, sizeof (WATCHDOG), ulTag);

    //
    // Set initial state of watchdog object.
    //

    if (NULL != pWatch)
    {
        //
        // Set initial state of watchdog.
        //

        WdInitializeObject(pWatch,
                           pDeviceObject,
                           WdStandardWatchdog,
                           timeType,
                           ulTag);

        pWatch->StartCount = 0;
        pWatch->SuspendCount = 0;
        pWatch->LastKernelTime = 0;
        pWatch->LastUserTime = 0;
        pWatch->TimeIncrement = KeQueryTimeIncrement();
        pWatch->DueTime.QuadPart = 0;
        pWatch->InitialDueTime.QuadPart = 0;
        pWatch->Thread = NULL;
        pWatch->ClientDpc = NULL;

        //
        // Initialize encapsulated timer object.
        //

        KeInitializeTimerEx(&(pWatch->Timer), NotificationTimer);

        //
        // Initialize encapsulated DPC object.
        //

        KeInitializeDpc(&(pWatch->TimerDpc), WdWatchdogDpcCallback, pWatch);
    }

    return pWatch;
}   // WdAllocateWatchdog()

WATCHDOGAPI
VOID
WdFreeWatchdog(
    PWATCHDOG pWatch
)

/*++

Routine Description:

    This function deallocates storage for watchdog object.
    It will also stop started watchdog if needed.

Arguments:

    pWatch - Supplies a pointer to a watchdog object.

Return Value:

    None.

--*/

{
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT(NULL != pWatch);
    ASSERT(pWatch->Header.ReferenceCount > 0);

    //
    // Stop watch just in case somebody forgot.
    // If the watch is stopped already then this is a no-op.
    //

    WdStopWatch(pWatch, FALSE);

    if (InterlockedDecrement(&(pWatch->Header.ReferenceCount)) == 0)
    {
        WdRemoveObject(pWatch);
    }

    return;
}   // WdFreeWatchdog()

WATCHDOGAPI
VOID
WdStartWatch(
    IN PWATCHDOG pWatch,
    IN LARGE_INTEGER liDueTime,
    IN PKDPC pDpc
    )

/*++

Routine Description:

    This function sets a watchdog to expire at a specified time. This
    function also increments start count of the watchdog object, to allow
    nested calls to Set / Cancel functions.

    Note: To minimize an overhead it is caller's resposibility to make
    sure thread remains valid when we are in the monitored section.

Arguments:

    pWatch - Supplies a pointer to a watchdog object.

    liDueTime - Supplies relative time at which the timer is to expire.
        This time is in the 100ns units.

    pDpc - Supplies a pointer to a control object of type DPC.

Return Value:

    None.

--*/

{
    PKTHREAD pThread;
    KIRQL oldIrql;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT(NULL != pWatch);
    ASSERT(NULL != pDpc);

    //
    // Make sure we use a relative DueTime.
    //

    if (liDueTime.QuadPart > 0)
    {
        liDueTime.QuadPart = -liDueTime.QuadPart;
    }

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KeAcquireSpinLock(&(pWatch->Header.SpinLock), &oldIrql);

    WD_DBG_SUSPENDED_WARNING(pWatch, "WdStartWatch");

    if (pWatch->StartCount < (ULONG)(-1))
    {
        pWatch->StartCount++;
    }
    else
    {
        ASSERT(FALSE);
    }

    //
    // We shouldn't hot swap DPCs without stopping first.
    //

    ASSERT((NULL == pWatch->ClientDpc) || (pDpc == pWatch->ClientDpc));

    pThread = KeGetCurrentThread();

    //
    // We shouldn't swap threads in the monitored section.
    //

    ASSERT((pWatch->StartCount == 1) || (pThread == pWatch->Thread));

    pWatch->Thread = pThread;
    pWatch->ClientDpc = pDpc;
    pWatch->DueTime.QuadPart = liDueTime.QuadPart;
    pWatch->InitialDueTime.QuadPart = liDueTime.QuadPart;
    pWatch->LastKernelTime = KeQueryRuntimeThread(pThread, &(pWatch->LastUserTime));

    //
    // Make sure ULONG counters won't overflow.
    //

    if (liDueTime.QuadPart < -WD_MAX_WAIT)
    {
        liDueTime.QuadPart = -WD_MAX_WAIT;
    }

    if (0 == pWatch->SuspendCount)
    {
        KeSetTimerEx(&(pWatch->Timer), liDueTime, 0, &(pWatch->TimerDpc));
    }

    //
    // Unlock the dispatcher database and lower IRQL to its previous value.
    //

    KeReleaseSpinLock(&(pWatch->Header.SpinLock), oldIrql);

	return;
}   // WdStartWatch()

WATCHDOGAPI
VOID
WdStopWatch(
    IN PWATCHDOG pWatch,
    IN BOOLEAN bIncremental
    )

/*++

Routine Description:

    This function cancels a watchdog that was previously set to expire
    at a specified time. If the watchdog is not currently set, then
    no operation is performed.

Arguments:

    pWatch - Supplies a pointer to a watchdog object.

    bIncremental - If TRUE the watchdog will be cancelled only when
        ReferenceCounter reaches 0, if FALSE watchdog is cancelled
        immediately and ReferenceCounter is forced to 0.

Return Value:

    None.

--*/

{
    KIRQL oldIrql;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT(NULL != pWatch);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KeAcquireSpinLock(&(pWatch->Header.SpinLock), &oldIrql);

    WD_DBG_SUSPENDED_WARNING(pWatch, "WdStopWatch");

    if (pWatch->StartCount > 0)
    {
        if (TRUE == bIncremental)
        {
            pWatch->StartCount--;
        }
        else
        {
            pWatch->StartCount = 0;
        }

        if (0 == pWatch->StartCount)
        {
            //
            // Cancel encapsulated timer object.
            //

            KeCancelTimer(&(pWatch->Timer));

            //
            // Make sure we don't have client's DPC pending.
            //

            if (NULL != pWatch->ClientDpc)
            {
                if (KeRemoveQueueDpc(pWatch->ClientDpc) == TRUE)
                {
                    //
                    // Was in queue - call WdCompleteEvent() here since DPC won't be delivered.
                    //

                    WdCompleteEvent(pWatch, pWatch->Header.LastQueuedThread);
                }
            }

            //
            // Set initial state of timer per thread.
            //

            pWatch->LastKernelTime = 0;
            pWatch->LastUserTime = 0;
            pWatch->DueTime.QuadPart = 0;
            pWatch->InitialDueTime.QuadPart = 0;
            pWatch->Thread = NULL;
            pWatch->ClientDpc = NULL;
            pWatch->Header.LastEvent = WdNoEvent;
            pWatch->Header.LastQueuedThread = NULL;
        }
    }

    //
    // Unlock the dispatcher database and lower IRQL to its previous value.
    //

    KeReleaseSpinLock(&(pWatch->Header.SpinLock), oldIrql);

	return;
}   // WdStopWatch()

WATCHDOGAPI
VOID
WdSuspendWatch(
    IN PWATCHDOG pWatch
    )

/*++

Routine Description:

    This function suspends watchdog.

Arguments:

    pWatch - Supplies a pointer to a watchdog object.

Return Value:

    None.

--*/

{
    KIRQL oldIrql;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT(NULL != pWatch);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KeAcquireSpinLock(&(pWatch->Header.SpinLock), &oldIrql);

    ASSERT(pWatch->SuspendCount < (ULONG)(-1));

    //
    // If we are suspended for the first time and we have timer running
    // we havo to stop a timer.
    //

    if ((0 == pWatch->SuspendCount) && pWatch->StartCount)
    {
        KeCancelTimer(&(pWatch->Timer));
    }

    pWatch->SuspendCount++;

    //
    // Unlock the dispatcher database and lower IRQL to its previous value.
    //

    KeReleaseSpinLock(&(pWatch->Header.SpinLock), oldIrql);

    return;
}   // WdSuspendWatch()

WATCHDOGAPI
VOID
WdResumeWatch(
    IN PWATCHDOG pWatch,
    IN BOOLEAN bIncremental
    )

/*++

Routine Description:

    This function resumes watchdog.

Arguments:

    pWatch - Supplies a pointer to a watchdog object.

    bIncremental - If TRUE the watchdog will resume only when
        SuspendCount reaches 0, if FALSE watchdog resumes
        immediately and SuspendCount is forced to 0.

Return Value:

    None.

--*/

{
    KIRQL oldIrql;
    BOOLEAN bResumed = FALSE;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT(NULL != pWatch);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KeAcquireSpinLock(&(pWatch->Header.SpinLock), &oldIrql);

    if (TRUE == bIncremental)
    {
        if (pWatch->SuspendCount)
        {
            pWatch->SuspendCount--;

            if (0 == pWatch->SuspendCount)
            {
                bResumed = TRUE;
            }
        }
    }
    else
    {
        if (pWatch->SuspendCount)
        {
            pWatch->SuspendCount = 0;
            bResumed = TRUE;
        }
    }

    //
    // If we had a timer running, and we are resuming for the first time,
    // and still have some due time left, we'll have to restart timer.
    //

    if (pWatch->StartCount && (TRUE == bResumed) && (0 != pWatch->DueTime.QuadPart))
    {
        LARGE_INTEGER liDueTime;

        //
        // Refresh currect time.
        //

        pWatch->LastKernelTime = KeQueryRuntimeThread(pWatch->Thread, &(pWatch->LastUserTime));

        //
        // Make sure ULONG counters won't overflow.
        //

        liDueTime.QuadPart = pWatch->DueTime.QuadPart;

        if (liDueTime.QuadPart < -WD_MAX_WAIT)
        {
            liDueTime.QuadPart = -WD_MAX_WAIT;
        }

        KeSetTimerEx(&(pWatch->Timer), liDueTime, 0, &(pWatch->TimerDpc));
    }

    //
    // Unlock the dispatcher database and lower IRQL to its previous value.
    //

    KeReleaseSpinLock(&(pWatch->Header.SpinLock), oldIrql);

    return;
}   // WdSuspendWatch()

WATCHDOGAPI
VOID
WdResetWatch(
    IN PWATCHDOG pWatch
    )

/*++

Routine Description:

    This function resets a started watchdog, i.e. it restarts timeout
    measurement from the scratch.
    Note: If the watchdog is suspened it will remain suspended.

Arguments:

    pWatch - Supplies a pointer to a watchdog object.

Return Value:

    None.

--*/

{
    KIRQL oldIrql;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT(NULL != pWatch);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KeAcquireSpinLock(&(pWatch->Header.SpinLock), &oldIrql);

    if (pWatch->StartCount)
    {
        LARGE_INTEGER liDueTime;

        pWatch->DueTime.QuadPart = pWatch->InitialDueTime.QuadPart;
        pWatch->LastKernelTime = KeQueryRuntimeThread(pWatch->Thread, &(pWatch->LastUserTime));

        //
        // Make sure ULONG counters won't overflow.
        //

        liDueTime.QuadPart = pWatch->DueTime.QuadPart;

        if (liDueTime.QuadPart < -WD_MAX_WAIT)
        {
            liDueTime.QuadPart = -WD_MAX_WAIT;
        }

        if (0 == pWatch->SuspendCount)
        {
            KeSetTimerEx(&(pWatch->Timer), liDueTime, 0, &(pWatch->TimerDpc));
        }
    }

    //
    // Unlock the dispatcher database and lower IRQL to its previous value.
    //

    KeReleaseSpinLock(&(pWatch->Header.SpinLock), oldIrql);

    return;
}   // WdResetWatch()

VOID
WdWatchdogDpcCallback(
    IN PKDPC pDpc,
    IN PVOID pContext,
    IN PVOID pSystemArgument1,
    IN PVOID pSystemArgument2
    )

/*++

Routine Description:

    This function is a DPC callback routine for timer object embedded in the
    watchdog object. It checks thread time and if the wait condition is
    satisfied it queues original (client) DPC. In case if the wait condition
    is not yet satisfied it call KeSetTimerEx().

Arguments:

    pDpc - Supplies a pointer to a DPC object.

    pContext - Supplies a pointer to a watchdog object.

    pSystemArgument1/2 - Supply time when embedded KTIMER expired.

Return Value:

    None.

--*/

{
    PWATCHDOG pWatch;
    ULARGE_INTEGER uliThreadTime;
    LARGE_INTEGER liDelta;
    ULONG ulKernelTime;
    ULONG ulUserTime;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    ASSERT(NULL != pContext);

    pWatch = (PWATCHDOG)pContext;

    KeAcquireSpinLockAtDpcLevel(&(pWatch->Header.SpinLock));

    ASSERT(0 == pWatch->SuspendCount);

    //
    // Get thread's current time stamps.
    //

    ulKernelTime = KeQueryRuntimeThread(pWatch->Thread, &ulUserTime);

    switch (pWatch->Header.TimeType)
    {
    case WdKernelTime:

        uliThreadTime.QuadPart = ulKernelTime;

        //
        // Handle counter rollovers.
        //

        if (ulKernelTime < pWatch->LastKernelTime)
        {
            uliThreadTime.QuadPart += (ULONG)(-1) - pWatch->LastKernelTime + 1;
        }

        liDelta.QuadPart = uliThreadTime.QuadPart - pWatch->LastKernelTime;

        break;

    case WdUserTime:

        uliThreadTime.QuadPart = ulUserTime;

        //
        // Handle counter rollovers.
        //

        if (ulUserTime < pWatch->LastUserTime)
        {
            uliThreadTime.QuadPart += (ULONG)(-1) - pWatch->LastUserTime + 1;
        }

        liDelta.QuadPart = uliThreadTime.QuadPart - pWatch->LastUserTime;

        break;

    case WdFullTime:

        uliThreadTime.QuadPart = ulKernelTime + ulUserTime;

        //
        // Handle counter rollovers.
        //

        if (ulKernelTime < pWatch->LastKernelTime)
        {
            uliThreadTime.QuadPart += (ULONG)(-1) - pWatch->LastKernelTime + 1;
        }

        if (ulUserTime < pWatch->LastUserTime)
        {
            uliThreadTime.QuadPart += (ULONG)(-1) - pWatch->LastUserTime + 1;
        }

        liDelta.QuadPart = uliThreadTime.QuadPart - (pWatch->LastKernelTime +
            pWatch->LastUserTime);

        break;

    default:

        ASSERT(FALSE);
        liDelta.QuadPart = 0;
        break;
    }

    liDelta.QuadPart *= pWatch->TimeIncrement;

    //
    // Update time values stored in timer per thread object to current values.
    //

    pWatch->LastKernelTime = ulKernelTime;
    pWatch->LastUserTime = ulUserTime;
    pWatch->DueTime.QuadPart += liDelta.QuadPart;

    if (pWatch->DueTime.QuadPart >= 0)
    {
        //
        // We're done waiting - update event type and queue client DPC if defined.
        //

        pWatch->Header.LastEvent = WdTimeoutEvent;

        if (NULL != pWatch->ClientDpc)
        {
            //
            // Bump up references to objects we're going to touch in client DPC.
            //

            ObReferenceObject(pWatch->Thread);
            WdReferenceObject(pWatch);

            if (KeInsertQueueDpc(pWatch->ClientDpc, pWatch->Thread, pWatch) == FALSE)
            {
                //
                // Already in queue, drop references.
                //

                ObDereferenceObject(pWatch->Thread);
                WdDereferenceObject(pWatch);
            }
            else
            {
                //
                // Keep track of qeueued thread in case we cancel this DPC.
                //

                pWatch->Header.LastQueuedThread = pWatch->Thread;
            }
        }

        //
        // Make sure due time is zero (in case of suspend / resume).
        //

        pWatch->DueTime.QuadPart = 0;
    }
    else
    {
        //
        // Not there yet - wait some more.
        //

        liDelta.QuadPart = pWatch->DueTime.QuadPart;

        //
        // Make sure ULONG counters won't overflow.
        //

        if (liDelta.QuadPart < -WD_MAX_WAIT) 
        {
            liDelta.QuadPart = -WD_MAX_WAIT;
        }

        KeSetTimerEx(&(pWatch->Timer), liDelta, 0, &(pWatch->TimerDpc));
    }

    KeReleaseSpinLockFromDpcLevel(&(pWatch->Header.SpinLock));

    return;
}   // WdWatchdogDpcCallback()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\watchdog\wd.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    wd.h

Abstract:

    This is the NT Watchdog driver implementation.

Author:

    Michael Maciesowicz (mmacie) 05-May-2000

Environment:

    Kernel mode only.

Notes:

Revision History:

--*/

#ifndef _WD_H_
#define _WD_H_

#include "ntddk.h"
#include "watchdog.h"

#define WD_MAX_WAIT                     ((LONG)((ULONG)(-1) / 4))
#define WD_KEY_WATCHDOG                 L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Watchdog"
#define WD_KEY_WATCHDOG_DISPLAY         L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Watchdog\\Display"
#define WD_KEY_RELIABILITY              L"\\Registry\\Machine\\Software\\Microsoft\\Windows\\CurrentVersion\\Reliability"
#define WD_TAG                          'godW'  // Wdog
#define WD_MAX_PROPERTY_SIZE            4096

//
// Define default configuration values - these can be overwriten via registry
// in RTL_REGISTRY_CONTROL\Watchdog\DeviceClass key.
//

#define WD_DEFAULT_TRAP_ONCE            0
#define WD_DEFAULT_DISABLE_BUGCHECK     0
#define WD_DEFAULT_BREAK_POINT_DELAY    0

#if DBG

#define WD_DBG_SUSPENDED_WARNING(pWd, szRoutine)                                    \
{                                                                                   \
    if ((pWd)->SuspendCount)                                                        \
    {                                                                               \
        DbgPrint("watchdog!%s: WARNING! Called while suspended!\n", (szRoutine));   \
        DbgPrint("watchdog!%s: Watchdog %p\n", (szRoutine), (pWd));                 \
    }                                                                               \
}

#else

#define WD_DBG_SUSPENDED_WARNING(pWd, szRoutine)   NULL

#endif  // DBG

#define ASSERT_WATCHDOG_OBJECT(pWd)                                                 \
    ASSERT((NULL != (pWd)) &&                                                       \
    (WdStandardWatchdog == ((PWATCHDOG_OBJECT)(pWd))->ObjectType) ||                \
    (WdDeferredWatchdog == ((PWATCHDOG_OBJECT)(pWd))->ObjectType))

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  pDriverObject,
    IN PUNICODE_STRING wszRegistryPath
    );

VOID
WdDeferredWatchdogDpcCallback(
    IN PKDPC pDpc,
    IN PVOID pDeferredContext,
    IN PVOID pSystemArgument1,
    IN PVOID pSystemArgument2
    );

NTSTATUS
WdFlushRegistryKey(
    IN PVOID pWatch,
    IN PCWSTR pwszKeyName
    );

VOID
WdInitializeObject(
    IN PVOID pWatch,
    IN PDEVICE_OBJECT pDeviceObject,
    IN WD_OBJECT_TYPE objectType,
    IN WD_TIME_TYPE timeType,
    IN ULONG ulTag
    );

VOID
WdRemoveObject(
    IN PVOID pWatch
    );

VOID
WdWatchdogDpcCallback(
    IN PKDPC pDpc,
    IN PVOID pDeferredContext,
    IN PVOID pSystemArgument1,
    IN PVOID pSystemArgument2
    );

//
// Internal ntos API (this is declared in ntifs.h but it's hard to include it here).
//
// TODO: Fix it later.
//

PDEVICE_OBJECT
IoGetDeviceAttachmentBaseRef(
    IN PDEVICE_OBJECT pDeviceObject
    );

#endif  // _WD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\inc\aligned.h ===
/*++

    Copyright (c) 1997-2000 Microsoft Corporation.  All rights reserved.

Module Name:

    aligned.h

Abstract:

    Various macros for validating alignment.

Author:

    Dale Sather (DaleSat) 24-Mar-1997

--*/

#ifndef _ALIGNED_
#define _ALIGNED_




#define SIZEOF_FIELD(structure,field)                   \
    sizeof(((structure *) 0)->field)

#define OFFSETOF_FIELD(structure,field)                 \
    ((ULONG)&(((structure *) 0)->field))




#define VALID_QWORD_ALIGNMENT(base)                     \
    ((ULONG)(base) % sizeof(ULONGLONG) == 0)

#define VALID_DWORD_ALIGNMENT(base)                     \
    ((ULONG)(base) % sizeof(ULONG) == 0)

#define VALID_WORD_ALIGNMENT(base)                      \
    ((ULONG)(base) % sizeof(USHORT) == 0)

#define VALID_ALIGNMENT(size,base)                      \
    (   ((size) >= sizeof(ULONGLONG))                   \
    ?   VALID_QWORD_ALIGNMENT(base)                     \
    :   (   ((size) >= sizeof(ULONG))                   \
        ?   VALID_DWORD_ALIGNMENT(base)                 \
        :   (   ((size) >= sizeof(USHORT))              \
            ?   VALID_WORD_ALIGNMENT(base)              \
            :   TRUE                                    \
            )                                           \
        )                                               \
    )

#define VALID_FIELD_ALIGNMENT(structure,field)          \
    VALID_ALIGNMENT(                                    \
        SIZEOF_FIELD(structure,field),                  \
        OFFSETOF_FIELD(structure,field)                 \
        )




#define ASSERT_VALID_QWORD_ALIGNMENT(base)              \
    ASSERT(VALID_QWORD_ALIGNMENT(base))

#define ASSERT_VALID_DWORD_ALIGNMENT(base)              \
    ASSERT(VALID_DWORD_ALIGNMENT(base))

#define ASSERT_VALID_WORD_ALIGNMENT(base)               \
    ASSERT(VALID_WORD_ALIGNMENT(base))

#define ASSERT_VALID_ALIGNMENT(size,base)               \
    ASSERT(VALID_ALIGNMENT(size,base))

#define ASSERT_VALID_FIELD_ALIGNMENT(structure,field)   \
    ASSERT(VALID_FIELD_ALIGNMENT(structure,field))

#define ASSERT_VALID_MEMBER_ALIGNMENT(member)           \
    ASSERT(VALID_ALIGNMENT(sizeof(member),&(member)))




#endif  // _ALIGNED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\inc\ksshellp.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation.  All rights reserved.

Module Name:

    ksshellp.h

Abstract:

    Internal header file for KSShell for PortCls

--*/

#if !defined( _KSSHELLP_ )

#define _KSSHELLP_

#ifdef __cplusplus
extern "C" {
#endif

#include "ks.h"
#undef INTERFACE

#ifndef KsShellStandardConnect
#define KsShellStandardConnect KspShellStandardConnect
#endif // !KsShellStandardConnect

#ifndef KsShellTransferKsIrp
#define KsShellTransferKsIrp KspShellTransferKsIrp
#endif // !KsShellTransferKsIrp


typedef interface IKsShellTransport *PIKSSHELLTRANSPORT;

typedef struct {
    LIST_ENTRY ListEntry;
    KSPIN_LOCK SpinLock;
} INTERLOCKEDLIST_HEAD, *PINTERLOCKEDLIST_HEAD;

#define InitializeInterlockedListHead(h) \
    InitializeListHead(&(h)->ListEntry); \
    KeInitializeSpinLock(&(h)->SpinLock)

#define KsInitializeWorkSinkItem(WorkItem,Object)\
    ExInitializeWorkItem(\
        WorkItem,\
        KsWorkSinkItemWorker,\
        static_cast<PIKSWORKSINK>(Object));

#undef INTERFACE
#define INTERFACE IKsShellTransport
DECLARE_INTERFACE_(IKsShellTransport,IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    STDMETHOD_(NTSTATUS,TransferKsIrp)(THIS_
        IN PIRP Irp,
        OUT PIKSSHELLTRANSPORT* NextTransport
        ) PURE;

    STDMETHOD_(void,Connect)(THIS_
        IN PIKSSHELLTRANSPORT NewTransport OPTIONAL,
        OUT PIKSSHELLTRANSPORT *OldTransport OPTIONAL,
        IN KSPIN_DATAFLOW DataFlow
        ) PURE;

    STDMETHOD_(NTSTATUS,SetDeviceState)(THIS_
        IN KSSTATE NewState,
        IN KSSTATE OldState,
        OUT PIKSSHELLTRANSPORT* NextTransport
        ) PURE;

    STDMETHOD_(void,SetResetState)(THIS_
        IN KSRESET ksReset,
        OUT PIKSSHELLTRANSPORT* NextTransport
        ) PURE;
#if DBG
    STDMETHOD_(void,DbgRollCall)(THIS_
        IN  ULONG NameMaxSize,
        OUT PCHAR Name,
        OUT PIKSSHELLTRANSPORT* NextTransport,
        OUT PIKSSHELLTRANSPORT* PrevTransport
        ) PURE;
#endif
};
#undef INTERFACE

#if DBG
#define IMP_IKsShellTransport\
    STDMETHODIMP_(NTSTATUS)\
    TransferKsIrp(\
        IN PIRP pIrp,\
        OUT PIKSSHELLTRANSPORT* NextTransport\
        );\
    STDMETHODIMP_(void)\
    Connect(\
        IN PIKSSHELLTRANSPORT NewTransport OPTIONAL,\
        OUT PIKSSHELLTRANSPORT *OldTransport OPTIONAL,\
        IN KSPIN_DATAFLOW DataFlow\
        );\
    STDMETHODIMP_(NTSTATUS)\
    SetDeviceState(\
        IN KSSTATE NewState,\
        IN KSSTATE OldState,\
        OUT PIKSSHELLTRANSPORT* NextTransport\
        );\
    STDMETHODIMP_(void)\
    SetResetState(\
        IN KSRESET ksReset,\
        OUT PIKSSHELLTRANSPORT* NextTransport\
        );\
    STDMETHODIMP_(void)\
    DbgRollCall(\
        IN  ULONG NameMaxSize,\
        OUT PCHAR Name,\
        OUT PIKSSHELLTRANSPORT* NextTransport,\
        OUT PIKSSHELLTRANSPORT* PrevTransport\
        )
#else
#define IMP_IKsShellTransport\
    STDMETHODIMP_(NTSTATUS)\
    TransferKsIrp(\
        IN PIRP pIrp,\
        OUT PIKSSHELLTRANSPORT* NextTransport\
        );\
    STDMETHODIMP_(void)\
    Connect(\
        IN PIKSSHELLTRANSPORT NewTransport OPTIONAL,\
        OUT PIKSSHELLTRANSPORT *OldTransport OPTIONAL,\
        IN KSPIN_DATAFLOW DataFlow\
        );\
    STDMETHODIMP_(NTSTATUS)\
    SetDeviceState(\
        IN KSSTATE NewState,\
        IN KSSTATE OldState,\
        OUT PIKSSHELLTRANSPORT* NextTransport\
        );\
    STDMETHODIMP_(void)\
    SetResetState(\
        IN KSRESET ksReset,\
        OUT PIKSSHELLTRANSPORT* NextTransport\
        )
#endif

#undef INTERFACE
#define INTERFACE IKsWorkSink
DECLARE_INTERFACE_(IKsWorkSink,IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    STDMETHOD_(void,Work)(THIS
        ) PURE;
};
#undef INTERFACE

typedef IKsWorkSink *PIKSWORKSINK;

#define IMP_IKsWorkSink\
    STDMETHODIMP_(void)\
    Work(\
        void\
    )

DEFINE_GUID(IID_IKsShellTransport,
0x3ef6ee40, 0xd41, 0x11d2, 0xbe, 0xda, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x57);
#if defined(__cplusplus) && _MSC_VER >= 1100
struct __declspec(uuid("3EF6EE40-0D41-11d2-BEDA-00C04F8EF457")) IKsShellTransport;
#endif
DEFINE_GUID(IID_IKsWorkSink,
0x3ef6ee4f, 0xd41, 0x11d2, 0xbe, 0xda, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x57);
#if defined(__cplusplus) && _MSC_VER >= 1100
struct __declspec(uuid("3EF6EE4F-0D41-11d2-BEDA-00C04F8EF457")) IKsWorkSink;
#endif

#define KSPSHELL_BACKCONNECT KSPIN_DATAFLOW(0x80)
#define KSPSHELL_BACKCONNECT_IN KSPIN_DATAFLOW(KSPIN_DATAFLOW_IN | KSPSHELL_BACKCONNECT)
#define KSPSHELL_BACKCONNECT_OUT KSPIN_DATAFLOW(KSPIN_DATAFLOW_OUT | KSPSHELL_BACKCONNECT)

NTSTATUS
KspShellCreateRequestor(
    OUT PIKSSHELLTRANSPORT* TransportInterface,
    IN ULONG ProbeFlags,
    IN ULONG StreamHeaderSize OPTIONAL,
    IN ULONG FrameSize,
    IN ULONG FrameCount, 
    IN PDEVICE_OBJECT NextDeviceObject,
    IN PFILE_OBJECT AllocatorFileObject OPTIONAL
    );

#if DBG
void
DbgPrintCircuit(
    IN PIKSSHELLTRANSPORT Transport
    );
#endif

void
KspShellStandardConnect(
    IN PIKSSHELLTRANSPORT NewTransport OPTIONAL,
    IN PIKSSHELLTRANSPORT *OldTransport OPTIONAL,
    IN KSPIN_DATAFLOW DataFlow,
    IN PIKSSHELLTRANSPORT ThisTransport,
    IN PIKSSHELLTRANSPORT* SourceTransport,
    IN PIKSSHELLTRANSPORT* SinkTransport
    );

NTSTATUS
KspShellTransferKsIrp(
    IN PIKSSHELLTRANSPORT NewTransport,
    IN PIRP Irp
    );

void
KsWorkSinkItemWorker(
    IN PVOID Context
    );

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _KSSHELLP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\inc\kso.h ===
/*****************************************************************************
 * kso.h - WDM Streaming object support
 *****************************************************************************
 * Copyright (c) 1997-2000 Microsoft Corporation.  All rights reserved.
 */

#ifndef _KSO_H_
#define _KSO_H_

#include "punknown.h"
#ifdef __cplusplus
extern "C"
{
#include <wdm.h>
}
#else
#include <wdm.h>
#endif

#include <windef.h>
#define NOBITMAP
#include <mmreg.h>
#undef NOBITMAP
#include <ks.h>





/*****************************************************************************
 * Interface IDs
 */

DEFINE_GUID(IID_IIrpTarget,
0xb4c90a60, 0x5791, 0x11d0, 0x86, 0xf9, 0x0, 0xa0, 0xc9, 0x11, 0xb5, 0x44);
DEFINE_GUID(IID_IIrpTargetFactory,
0xb4c90a62, 0x5791, 0x11d0, 0x86, 0xf9, 0x0, 0xa0, 0xc9, 0x11, 0xb5, 0x44);





/*****************************************************************************
 * Interfaces
 */

/*****************************************************************************
 * IIrpTargetFactory
 *****************************************************************************
 * Interface for objects that create IrpTargets.
 */
#if !defined(DEFINE_ABSTRACT_IRPTARGETFACTORY)

#define DEFINE_ABSTRACT_IRPTARGETFACTORY()                      \
    STDMETHOD_(NTSTATUS,NewIrpTarget)                           \
    (   THIS_                                                   \
        OUT     struct IIrpTarget **IrpTarget,                  \
        OUT     BOOLEAN *           ReferenceParent,            \
        IN      PUNKNOWN            OuterUnknown    OPTIONAL,   \
        IN      POOL_TYPE           PoolType,                   \
        IN      PDEVICE_OBJECT      DeviceObject,               \
        IN      PIRP                Irp,                        \
        OUT     PKSOBJECT_CREATE    ObjectCreate                \
    )   PURE;

#endif //!defined(DEFINE_ABSTRACT_IRPTARGETFACTORY)


DECLARE_INTERFACE_(IIrpTargetFactory,IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()           //  For IUnknown

    DEFINE_ABSTRACT_IRPTARGETFACTORY()  //  For IIrpTargetFactory
};

typedef IIrpTargetFactory *PIRPTARGETFACTORY;

#define IMP_IIrpTargetFactory\
    STDMETHODIMP_(NTSTATUS) NewIrpTarget\
    (   OUT     struct IIrpTarget **IrpTarget,\
        OUT     BOOLEAN *           ReferenceParent,\
        IN      PUNKNOWN            OuterUnknown    OPTIONAL,\
        IN      POOL_TYPE           PoolType,\
        IN      PDEVICE_OBJECT      DeviceObject,\
        IN      PIRP                Irp,\
        OUT     PKSOBJECT_CREATE    ObjectCreate\
    )

/*****************************************************************************
 * IIrpTarget
 *****************************************************************************
 * Interface common to all IRP targets.
 */
#if !defined(DEFINE_ABSTRACT_IRPTARGET)

#define DEFINE_ABSTRACT_IRPTARGET()                             \
    STDMETHOD_(NTSTATUS,DeviceIoControl)                        \
    (   THIS_                                                   \
        IN      PDEVICE_OBJECT      DeviceObject,               \
        IN      PIRP                Irp                         \
    )   PURE;                                                   \
    STDMETHOD_(NTSTATUS,Read)                                   \
    (   THIS_                                                   \
        IN      PDEVICE_OBJECT      DeviceObject,               \
        IN      PIRP                Irp                         \
    )   PURE;                                                   \
    STDMETHOD_(NTSTATUS,Write)                                  \
    (   THIS_                                                   \
        IN      PDEVICE_OBJECT      DeviceObject,               \
        IN      PIRP                Irp                         \
    )   PURE;                                                   \
    STDMETHOD_(NTSTATUS,Flush)                                  \
    (   THIS_                                                   \
        IN      PDEVICE_OBJECT      DeviceObject,               \
        IN      PIRP                Irp                         \
    )   PURE;                                                   \
    STDMETHOD_(NTSTATUS,Close)                                  \
    (   THIS_                                                   \
        IN      PDEVICE_OBJECT      DeviceObject,               \
        IN      PIRP                Irp                         \
    )   PURE;                                                   \
    STDMETHOD_(NTSTATUS,QuerySecurity)                          \
    (   THIS_                                                   \
        IN      PDEVICE_OBJECT      DeviceObject,               \
        IN      PIRP                Irp                         \
    )   PURE;                                                   \
    STDMETHOD_(NTSTATUS,SetSecurity)                            \
    (   THIS_                                                   \
        IN      PDEVICE_OBJECT      DeviceObject,               \
        IN      PIRP                Irp                         \
    )   PURE;                                                   \
    STDMETHOD_(BOOLEAN,FastDeviceIoControl)                     \
    (   THIS_                                                   \
        IN      PFILE_OBJECT        FileObject,                 \
        IN      BOOLEAN             Wait,                       \
        IN      PVOID               InputBuffer     OPTIONAL,   \
        IN      ULONG               InputBufferLength,          \
        OUT     PVOID               OutputBuffer    OPTIONAL,   \
        IN      ULONG               OutputBufferLength,         \
        IN      ULONG               IoControlCode,              \
        OUT     PIO_STATUS_BLOCK    IoStatus,                   \
        IN      PDEVICE_OBJECT      DeviceObject                \
    )   PURE;                                                   \
    STDMETHOD_(BOOLEAN,FastRead)                                \
    (   THIS_                                                   \
        IN      PFILE_OBJECT        FileObject,                 \
        IN      PLARGE_INTEGER      FileOffset,                 \
        IN      ULONG               Length,                     \
        IN      BOOLEAN             Wait,                       \
        IN      ULONG               LockKey,                    \
        OUT     PVOID               Buffer,                     \
        OUT     PIO_STATUS_BLOCK    IoStatus,                   \
        IN      PDEVICE_OBJECT      DeviceObject                \
    )   PURE;                                                   \
    STDMETHOD_(BOOLEAN,FastWrite)                               \
    (   THIS_                                                   \
        IN      PFILE_OBJECT        FileObject,                 \
        IN      PLARGE_INTEGER      FileOffset,                 \
        IN      ULONG               Length,                     \
        IN      BOOLEAN             Wait,                       \
        IN      ULONG               LockKey,                    \
        IN      PVOID               Buffer,                     \
        OUT     PIO_STATUS_BLOCK    IoStatus,                   \
        IN      PDEVICE_OBJECT      DeviceObject                \
    )   PURE;
#endif //!defined(DEFINE_ABSTRACT_IRPTARGET)

DECLARE_INTERFACE_(IIrpTarget,IIrpTargetFactory)
{
    DEFINE_ABSTRACT_UNKNOWN()           //  For IUnknown

    DEFINE_ABSTRACT_IRPTARGETFACTORY()  //  For IIrpTargetFactory

    DEFINE_ABSTRACT_IRPTARGET()         //  For IIrpTarget
};

typedef IIrpTarget *PIRPTARGET;

#define IMP_IIrpTarget\
    IMP_IIrpTargetFactory;\
    STDMETHODIMP_(NTSTATUS) DeviceIoControl            \
    (                                       \
        IN  PDEVICE_OBJECT  DeviceObject,   \
        IN  PIRP            Irp             \
    );                                      \
    STDMETHODIMP_(NTSTATUS) Read                       \
    (                                       \
        IN  PDEVICE_OBJECT  DeviceObject,   \
        IN  PIRP            Irp             \
    );                                      \
    STDMETHODIMP_(NTSTATUS) Write                      \
    (                                       \
        IN  PDEVICE_OBJECT  DeviceObject,   \
        IN  PIRP            Irp             \
    );                                      \
    STDMETHODIMP_(NTSTATUS) Flush                      \
    (                                       \
        IN  PDEVICE_OBJECT  DeviceObject,   \
        IN  PIRP            Irp             \
    );                                      \
    STDMETHODIMP_(NTSTATUS) Close                      \
    (                                       \
        IN  PDEVICE_OBJECT  DeviceObject,   \
        IN  PIRP            Irp             \
    );                                      \
    STDMETHODIMP_(NTSTATUS) QuerySecurity              \
    (                                       \
        IN  PDEVICE_OBJECT  DeviceObject,   \
        IN  PIRP            Irp             \
    );                                      \
    STDMETHODIMP_(NTSTATUS) SetSecurity                \
    (                                       \
        IN  PDEVICE_OBJECT  DeviceObject,   \
        IN  PIRP            Irp             \
    );                                      \
    STDMETHODIMP_(BOOLEAN) FastDeviceIoControl                  \
    (                                                           \
        IN      PFILE_OBJECT        FileObject,                 \
        IN      BOOLEAN             Wait,                       \
        IN      PVOID               InputBuffer     OPTIONAL,   \
        IN      ULONG               InputBufferLength,          \
        OUT     PVOID               OutputBuffer    OPTIONAL,   \
        IN      ULONG               OutputBufferLength,         \
        IN      ULONG               IoControlCode,              \
        OUT     PIO_STATUS_BLOCK    IoStatus,                   \
        IN      PDEVICE_OBJECT      DeviceObject                \
    );                                                          \
    STDMETHODIMP_(BOOLEAN) FastRead                             \
    (                                                           \
        IN      PFILE_OBJECT        FileObject,                 \
        IN      PLARGE_INTEGER      FileOffset,                 \
        IN      ULONG               Length,                     \
        IN      BOOLEAN             Wait,                       \
        IN      ULONG               LockKey,                    \
        OUT     PVOID               Buffer,                     \
        OUT     PIO_STATUS_BLOCK    IoStatus,                   \
        IN      PDEVICE_OBJECT      DeviceObject                \
    );                                                          \
    STDMETHODIMP_(BOOLEAN) FastWrite                            \
    (                                                           \
        IN      PFILE_OBJECT        FileObject,                 \
        IN      PLARGE_INTEGER      FileOffset,                 \
        IN      ULONG               Length,                     \
        IN      BOOLEAN             Wait,                       \
        IN      ULONG               LockKey,                    \
        IN      PVOID               Buffer,                     \
        OUT     PIO_STATUS_BLOCK    IoStatus,                   \
        IN      PDEVICE_OBJECT      DeviceObject                \
    )



/*****************************************************************************
 * Functions
 */

/*****************************************************************************
 * KsoSetMajorFunctionHandler()
 *****************************************************************************
 * Sets up the handler for a major function.
 */
NTSTATUS
KsoSetMajorFunctionHandler
(
    IN      PDRIVER_OBJECT  pDriverObject,
    IN      ULONG           ulMajorFunction
);

/*****************************************************************************
 * KsoDispatchIrp()
 *****************************************************************************
 * Dispatch an IRP.
 */
NTSTATUS
KsoDispatchIrp
(
    IN      PDEVICE_OBJECT  pDeviceObject,
    IN      PIRP            pIrp
);

/*****************************************************************************
 * KsoDispatchCreate()
 *****************************************************************************
 * Handles object create IRPs using the IIrpTargetFactory interface pointer
 * in the Context field of the create item.
 */
NTSTATUS
KsoDispatchCreate
(
    IN      PDEVICE_OBJECT  pDeviceObject,
    IN      PIRP            pIrp
);

/*****************************************************************************
 * KsoDispatchCreateWithGenericFactory()
 *****************************************************************************
 * Handles object create IRPs using the IIrpTarget interface pointer in the
 * device or object context.
 */
NTSTATUS
KsoDispatchCreateWithGenericFactory
(
    IN      PDEVICE_OBJECT  pDeviceObject,
    IN      PIRP            pIrp
);

/*****************************************************************************
 * AddIrpTargetFactoryToDevice()
 *****************************************************************************
 * Adds an IrpTargetFactory to a device's create items list.
 */
NTSTATUS
NTAPI
AddIrpTargetFactoryToDevice
(
    IN      PDEVICE_OBJECT          pDeviceObject,
    IN      PIRPTARGETFACTORY       pIrpTargetFactory,
    IN      PWCHAR                  pwcObjectClass,
    IN      PSECURITY_DESCRIPTOR    pSecurityDescriptor OPTIONAL
);

/*****************************************************************************
 * AddIrpTargetFactoryToObject()
 *****************************************************************************
 * Adds an IrpTargetFactory to a objects's create items list.
 */
NTSTATUS
NTAPI
AddIrpTargetFactoryToObject
(
    IN      PFILE_OBJECT            pFileObject,
    IN      PIRPTARGETFACTORY       pIrpTargetFactory,
    IN      PWCHAR                  pwcObjectClass,
    IN      PSECURITY_DESCRIPTOR    pSecurityDescriptor OPTIONAL
);

/*****************************************************************************
 * KsoGetIrpTargetFromIrp()
 *****************************************************************************
 * Extracts the IrpTarget pointer from an IRP.
 */
PIRPTARGET
NTAPI
KsoGetIrpTargetFromIrp
(
    IN  PIRP    Irp
);

/*****************************************************************************
 * KsoGetIrpTargetFromFileObject()
 *****************************************************************************
 * Extracts the IrpTarget pointer from a FileObject pointer.
 */
 
PIRPTARGET
NTAPI
KsoGetIrpTargetFromFileObject(
    IN PFILE_OBJECT FileObject
    );





/*****************************************************************************
 * Macros
 */

#define DEFINE_INVALID_CREATE(Class)                            \
STDMETHODIMP_(NTSTATUS) Class::NewIrpTarget                                \
(                                                               \
    OUT     PIRPTARGET *        IrpTarget,                      \
    OUT     BOOLEAN *           ReferenceParent,                \
    IN      PUNKNOWN            OuterUnknown,                   \
    IN      POOL_TYPE           PoolType,                       \
    IN      PDEVICE_OBJECT      DeviceObject,                   \
    IN      PIRP                Irp,                            \
    OUT     PKSOBJECT_CREATE    ObjectCreate                    \
)                                                               \
{                                                               \
    return STATUS_INVALID_DEVICE_REQUEST;                       \
}

#define DEFINE_INVALID_DEVICEIOCONTROL(Class)                   \
STDMETHODIMP_(NTSTATUS) Class::DeviceIoControl                             \
(                                                               \
    IN      PDEVICE_OBJECT  DeviceObject,                       \
    IN      PIRP            Irp                                 \
)                                                               \
{                                                               \
    return KsDispatchInvalidDeviceRequest(DeviceObject,Irp);    \
}

#define DEFINE_INVALID_READ(Class)                              \
STDMETHODIMP_(NTSTATUS) Class::Read                                        \
(                                                               \
    IN      PDEVICE_OBJECT  DeviceObject,                       \
    IN      PIRP            Irp                                 \
)                                                               \
{                                                               \
    return KsDispatchInvalidDeviceRequest(DeviceObject,Irp);    \
}

#define DEFINE_INVALID_WRITE(Class)                             \
STDMETHODIMP_(NTSTATUS) Class::Write                                       \
(                                                               \
    IN      PDEVICE_OBJECT  DeviceObject,                       \
    IN      PIRP            Irp                                 \
)                                                               \
{                                                               \
    return KsDispatchInvalidDeviceRequest(DeviceObject,Irp);    \
}

#define DEFINE_INVALID_FLUSH(Class)                             \
STDMETHODIMP_(NTSTATUS) Class::Flush                                       \
(                                                               \
    IN      PDEVICE_OBJECT  DeviceObject,                       \
    IN      PIRP            Irp                                 \
)                                                               \
{                                                               \
    return KsDispatchInvalidDeviceRequest(DeviceObject,Irp);    \
}

#define DEFINE_INVALID_CLOSE(Class)                             \
STDMETHODIMP_(NTSTATUS) Class::Close                                       \
(                                                               \
    IN      PDEVICE_OBJECT  DeviceObject,                       \
    IN      PIRP            Irp                                 \
)                                                               \
{                                                               \
    return KsDispatchInvalidDeviceRequest(DeviceObject,Irp);    \
}

#define DEFINE_INVALID_QUERYSECURITY(Class)                     \
STDMETHODIMP_(NTSTATUS) Class::QuerySecurity                               \
(                                                               \
    IN      PDEVICE_OBJECT  DeviceObject,                       \
    IN      PIRP            Irp                                 \
)                                                               \
{                                                               \
    return KsDispatchInvalidDeviceRequest(DeviceObject,Irp);    \
}

#define DEFINE_INVALID_SETSECURITY(Class)                       \
STDMETHODIMP_(NTSTATUS) Class::SetSecurity                                 \
(                                                               \
    IN      PDEVICE_OBJECT  DeviceObject,                       \
    IN      PIRP            Irp                                 \
)                                                               \
{                                                               \
    return KsDispatchInvalidDeviceRequest(DeviceObject,Irp);    \
}

#define DEFINE_INVALID_FASTDEVICEIOCONTROL(Class)               \
STDMETHODIMP_(BOOLEAN) Class::FastDeviceIoControl               \
(                                                               \
        IN      PFILE_OBJECT        FileObject,                 \
        IN      BOOLEAN             Wait,                       \
        IN      PVOID               InputBuffer     OPTIONAL,   \
        IN      ULONG               InputBufferLength,          \
        OUT     PVOID               OutputBuffer    OPTIONAL,   \
        IN      ULONG               OutputBufferLength,         \
        IN      ULONG               IoControlCode,              \
        OUT     PIO_STATUS_BLOCK    IoStatus,                   \
        IN      PDEVICE_OBJECT      DeviceObject                \
)                                                               \
{                                                               \
    return FALSE;                                               \
}

#define DEFINE_INVALID_FASTREAD(Class)                          \
STDMETHODIMP_(BOOLEAN) Class::FastRead                          \
(                                                               \
        IN      PFILE_OBJECT        FileObject,                 \
        IN      PLARGE_INTEGER      FileOffset,                 \
        IN      ULONG               Length,                     \
        IN      BOOLEAN             Wait,                       \
        IN      ULONG               LockKey,                    \
        OUT     PVOID               Buffer,                     \
        OUT     PIO_STATUS_BLOCK    IoStatus,                   \
        IN      PDEVICE_OBJECT      DeviceObject                \
)                                                               \
{                                                               \
    return FALSE;                                               \
}

#define DEFINE_INVALID_FASTWRITE(Class)                         \
STDMETHODIMP_(BOOLEAN) Class::FastWrite                         \
(                                                               \
        IN      PFILE_OBJECT        FileObject,                 \
        IN      PLARGE_INTEGER      FileOffset,                 \
        IN      ULONG               Length,                     \
        IN      BOOLEAN             Wait,                       \
        IN      ULONG               LockKey,                    \
        IN      PVOID               Buffer,                     \
        OUT     PIO_STATUS_BLOCK    IoStatus,                   \
        IN      PDEVICE_OBJECT      DeviceObject                \
)                                                               \
{                                                               \
    return FALSE;                                               \
}

#if 0
// 1)   Cut and paste these.
// 2)   Delete the ones that are implemented.
// 3)   Substitute the class name.
DEFINE_INVALID_DEVICEIOCONTROL(Class);
DEFINE_INVALID_READ(Class);
DEFINE_INVALID_WRITE(Class);
DEFINE_INVALID_FLUSH(Class);
DEFINE_INVALID_CLOSE(Class);
DEFINE_INVALID_QUERYSECURITY(Class);
DEFINE_INVALID_SETSECURITY(Class);
DEFINE_INVALID_FASTDEVICEIOCONTROL(Class);
DEFINE_INVALID_FASTREAD(Class);
DEFINE_INVALID_FASTWRITE(Class);
#endif





#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\inc\portclsp.h ===
/*****************************************************************************
 * portclsp.h - WDM Streaming port class driver definitions for port drivers
 *****************************************************************************
 * Copyright (c) 1996-2000 Microsoft Corporation.  All Rights Reserved.
 */

#ifndef _PORTCLSP_H_
#define _PORTCLSP_H_

#include "kso.h"
#define PC_NEW_NAMES
#define PC_IMPLEMENTATION
#include "portcls.h"
#include "ksshellp.h"


#ifdef UNDER_NT

#ifdef __cplusplus
extern "C" {
#endif

NTKERNELAPI
ULONG
KeGetRecommendedSharedDataAlignment (
    VOID
    );

#ifdef __cplusplus
}
#endif

#else // UNDER_NT

#define KeGetRecommendedSharedDataAlignment() 0x40

#endif


PKSPIN_LOCK
GetServiceGroupSpinLock (
    PSERVICEGROUP pServiceGroup
    );


#define DRM_PORTCLS

#if DBG
#define kEnableDebugLogging 1
#endif

#if     kEnableDebugLogging

#define kNumDebugLogEntries 256
#define kNumULONG_PTRsPerEntry  4
#define DebugLog PcDebugLog

extern ULONG_PTR *gPcDebugLog;
extern DWORD      gPcDebugLogIndex;

void PcDebugLog(ULONG_PTR param1,ULONG_PTR param2,ULONG_PTR param3,ULONG_PTR param4);

#else   //  !kEnableDebugLogging
#define DebugLog (void)
#endif  //  !kEnableDebugLogging





/*****************************************************************************
 * Structures.
 */

/*****************************************************************************
 * PORT_DRIVER
 *****************************************************************************
 * This structure describes a port driver.  This is just a hack until we get
 * real object servers running.
 * TODO:  Create real object servers and put port drivers in 'em.
 */
typedef struct
{
    const GUID *            ClassId;
    PFNCREATEINSTANCE       Create;
}
PORT_DRIVER, *PPORT_DRIVER;





/*****************************************************************************
 * Interface identifiers.
 */

DEFINE_GUID(IID_ISubdevice,
0xb4c90a61, 0x5791, 0x11d0, 0x86, 0xf9, 0x0, 0xa0, 0xc9, 0x11, 0xb5, 0x44);
DEFINE_GUID(IID_IIrpStream,
0xb4c90a70, 0x5791, 0x11d0, 0x86, 0xf9, 0x0, 0xa0, 0xc9, 0x11, 0xb5, 0x44);
DEFINE_GUID(IID_IIrpStreamSubmit,
0xb4c90a71, 0x5791, 0x11d0, 0x86, 0xf9, 0x0, 0xa0, 0xc9, 0x11, 0xb5, 0x44);
DEFINE_GUID(IID_IIrpStreamVirtual,
0xb4c90a72, 0x5791, 0x11d0, 0x86, 0xf9, 0x0, 0xa0, 0xc9, 0x11, 0xb5, 0x44);
DEFINE_GUID(IID_IIrpStreamPhysical,
0xb4c90a73, 0x5791, 0x11d0, 0x86, 0xf9, 0x0, 0xa0, 0xc9, 0x11, 0xb5, 0x44);
DEFINE_GUID(IID_IIrpStreamNotify,
0xb4c90a74, 0x5791, 0x11d0, 0x86, 0xf9, 0x0, 0xa0, 0xc9, 0x11, 0xb5, 0x44);
DEFINE_GUID(IID_IIrpStreamNotifyPhysical,
0xb4c90a75, 0x5791, 0x11d0, 0x86, 0xf9, 0x0, 0xa0, 0xc9, 0x11, 0xb5, 0x44);





/*****************************************************************************
 * Types
 */

/*****************************************************************************
 * PROPERTY_TABLE
 *****************************************************************************
 * Table of properties for KS consumption.
 */
typedef struct
{
    ULONG           PropertySetCount;
    PKSPROPERTY_SET PropertySets;
    BOOLEAN         StaticSets;
    PBOOLEAN        StaticItems;    // NULL means all item tables are static.
}
PROPERTY_TABLE, *PPROPERTY_TABLE;

/*****************************************************************************
 * EVENT_TABLE
 *****************************************************************************
 * Table of events for KS consumption.
 */
typedef struct
{
    ULONG           EventSetCount;
    PKSEVENT_SET    EventSets;
    BOOLEAN         StaticSets;
    PBOOLEAN        StaticItems;    // NULL means all item tables are static.
}
EVENT_TABLE, *PEVENT_TABLE;

/*****************************************************************************
 * PIN_CINSTANCES
 *****************************************************************************
 * This structure stores instance information for a pin.
 */
typedef struct
{
    ULONG   FilterPossible;
    ULONG   FilterNecessary;
    ULONG   GlobalPossible;
    ULONG   GlobalCurrent;
}
PIN_CINSTANCES, *PPIN_CINSTANCES;

/*****************************************************************************
 * SUBDEVICE_DESCRIPTOR
 *****************************************************************************
 * This structure describes a filter.
 */
typedef struct
{
    ULONG                   PinCount;
    PKSTOPOLOGY             Topology;
    PKSPIN_DESCRIPTOR       PinDescriptors;
    PPIN_CINSTANCES         PinInstances;
    PROPERTY_TABLE          FilterPropertyTable;
    PPROPERTY_TABLE         PinPropertyTables;
    EVENT_TABLE             FilterEventTable;
    PEVENT_TABLE            PinEventTables;
}
SUBDEVICE_DESCRIPTOR, *PSUBDEVICE_DESCRIPTOR;

/*****************************************************************************
 * PROPERTY_CONTEXT
 *****************************************************************************
 * Context for property handling.
 */
typedef struct
{
    struct ISubdevice *     pSubdevice;
    PSUBDEVICE_DESCRIPTOR   pSubdeviceDescriptor;
    PPCFILTER_DESCRIPTOR    pPcFilterDescriptor;
    PUNKNOWN                pUnknownMajorTarget;
    PUNKNOWN                pUnknownMinorTarget;
    ULONG                   ulNodeId;
    PULONG                  pulPinInstanceCounts;
}
PROPERTY_CONTEXT, *PPROPERTY_CONTEXT;

/*****************************************************************************
 * INTERLOCKED_LIST
 *****************************************************************************
 * A LIST_ENTRY with a SPIN_LOCK.
 */
typedef struct
{
    LIST_ENTRY  List;
    KSPIN_LOCK  ListLock;
} INTERLOCKED_LIST, *PINTERLOCKED_LIST;

/*****************************************************************************
 * EVENT_CONTEXT
 *****************************************************************************
 * Context for event handling.
 */
typedef struct
{
    PPROPERTY_CONTEXT   pPropertyContext;
    PINTERLOCKED_LIST   pEventList;
    ULONG               ulPinId;
    ULONG               ulEventSetCount;
    const KSEVENT_SET*  pEventSets;
} EVENT_CONTEXT, *PEVENT_CONTEXT;

/*****************************************************************************
 * PCEVENT_ENTRY
 *****************************************************************************
 * An event entry with attached node and pin ids.
 */
typedef struct
{
    KSEVENT_ENTRY           EventEntry;
    const PCEVENT_ITEM *    EventItem;
    PUNKNOWN                pUnknownMajorTarget;
    PUNKNOWN                pUnknownMinorTarget;
    ULONG                   PinId;
    ULONG                   NodeId;
} PCEVENT_ENTRY, *PPCEVENT_ENTRY;

typedef struct
{
    GUID*           Set;
    ULONG           EventId;
    BOOL            PinEvent;
    ULONG           PinId;
    BOOL            NodeEvent;
    ULONG           NodeId;
    BOOL            ContextInUse;
} EVENT_DPC_CONTEXT,*PEVENT_DPC_CONTEXT;

/*****************************************************************************
 * IRPSTREAM_POSITION
 *****************************************************************************
 * Position descriptor for IrpStream.
 */
typedef struct
{
    ULONGLONG   ullCurrentExtent;           // Current Extent - Maximum stream position

    ULONGLONG   ullMappingPosition;         // Mapping Position - The current mapping position
    ULONGLONG   ullUnmappingPosition;       // Unmapping Position - The current unmapping position

    ULONGLONG   ullStreamPosition;          // Stream Position - The current stream position
    ULONGLONG   ullStreamOffset;            // Stream Base Position - The offset between stream and unmapping position

    ULONGLONG   ullPhysicalOffset;          // Physical Offset - Used by clock to adjust for starvation

    ULONG       ulMappingPacketSize;        // Size of current mapping packet
    ULONG       ulMappingOffset;            // Offset into mapping packet that is currently mapped
    ULONG       ulUnmappingPacketSize;      // Size of current unmapping packet
    ULONG       ulUnmappingOffset;          // Offset into unmapping packet that is currently unmapped

    BOOLEAN     bLoopedInterface;           // Pin interface is KSINTERFACE_STANDARD_LOOPED_STREAMING ?
    BOOLEAN     bMappingPacketLooped;       // Mapping packet is KSSTREAM_HEADER_OPTIONSF_LOOPEDDATA ?
    BOOLEAN     bUnmappingPacketLooped;     // Unmapping packet is KSSTREAM_HEADER_OPTIONSF_LOOPEDDATA ?
}
IRPSTREAM_POSITION, *PIRPSTREAM_POSITION;





/*****************************************************************************
 * Interfaces.
 */

/*****************************************************************************
 * ISubdevice
 *****************************************************************************
 * Interface for subdevices.
 */
#if !defined(DEFINE_ABSTRACT_SUBDEVICE)

#define DEFINE_ABSTRACT_SUBDEVICE()                         \
    STDMETHOD_(void,ReleaseChildren)                        \
    (   THIS                                                \
    )   PURE;                                               \
    STDMETHOD_(NTSTATUS,GetDescriptor)                      \
    (   THIS_                                               \
        OUT     const SUBDEVICE_DESCRIPTOR **   Descriptor  \
    )   PURE;                                               \
    STDMETHOD_(NTSTATUS,DataRangeIntersection)              \
    (   THIS_                                               \
        IN      ULONG           PinId,                      \
        IN      PKSDATARANGE    DataRange,                  \
        IN      PKSDATARANGE    MatchingDataRange,          \
        IN      ULONG           OutputBufferLength,         \
        OUT     PVOID           ResultantFormat   OPTIONAL, \
        OUT     PULONG          ResultantFormatLength       \
    )   PURE;                                               \
    STDMETHOD_(void,PowerChangeNotify)                      \
    (   THIS_                                               \
        IN      POWER_STATE     PowerState                  \
    )   PURE;                                               \
    STDMETHOD_(void,PinCount)                               \
    (   THIS_                                               \
        IN      ULONG           PinId,                      \
        IN  OUT PULONG          FilterNecessary,            \
        IN  OUT PULONG          FilterCurrent,              \
        IN  OUT PULONG          FilterPossible,             \
        IN  OUT PULONG          GlobalCurrent,              \
        IN  OUT PULONG          GlobalPossible              \
    )   PURE;

#endif //!defined(DEFINE_ABSTRACT_SUBDEVICE)

DECLARE_INTERFACE_(ISubdevice,IIrpTargetFactory)
{
    DEFINE_ABSTRACT_UNKNOWN()           //  For IUnknown

    DEFINE_ABSTRACT_IRPTARGETFACTORY()  //  For IIrpTargetFactory

    DEFINE_ABSTRACT_SUBDEVICE()         //  For ISubdevice

};

typedef ISubdevice *PSUBDEVICE;

#define IMP_ISubdevice_\
    STDMETHODIMP_(void)\
    ReleaseChildren\
    (   void\
    );\
    STDMETHODIMP_(NTSTATUS)\
    GetDescriptor\
    (   OUT     const SUBDEVICE_DESCRIPTOR **   Descriptor\
    );\
    STDMETHODIMP_(NTSTATUS)\
    DataRangeIntersection\
    (   IN      ULONG           PinId,\
        IN      PKSDATARANGE    DataRange,\
        IN      PKSDATARANGE    MatchingDataRange,\
        IN      ULONG           OutputBufferLength,\
        OUT     PVOID           ResultantFormat     OPTIONAL,\
        OUT     PULONG          ResultantFormatLength\
    );\
    STDMETHODIMP_(void)\
    PowerChangeNotify\
    (   IN      POWER_STATE     PowerState\
    );\
    STDMETHODIMP_(void)\
    PinCount\
    (   IN      ULONG           PinId,\
        IN  OUT PULONG          FilterNecessary,\
        IN  OUT PULONG          FilterCurrent,\
        IN  OUT PULONG          FilterPossible,\
        IN  OUT PULONG          GlobalCurrent,\
        IN  OUT PULONG          GlobalPossible\
    )

#define IMP_ISubdevice\
    IMP_IIrpTargetFactory;\
    IMP_ISubdevice_


/*****************************************************************************
 * IIrpStreamNotify
 *****************************************************************************
 * Irp stream notification interface (IrpStream sources this).
 */
DECLARE_INTERFACE_(IIrpStreamNotify,IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    STDMETHOD_(void,IrpSubmitted)
    (   THIS_
        IN      PIRP        Irp,
        IN      BOOLEAN     WasExhausted
    )   PURE;

    STDMETHOD_(NTSTATUS,GetPosition)
    (   THIS_
        IN OUT  PIRPSTREAM_POSITION pIrpStreamPosition
    ) PURE;
};

typedef IIrpStreamNotify *PIRPSTREAMNOTIFY;

#define IMP_IIrpStreamNotify\
    STDMETHODIMP_(void)\
    IrpSubmitted\
    (   IN      PIRP        pIrp\
    ,   IN      BOOLEAN     bWasExhausted\
    );\
    STDMETHODIMP_(NTSTATUS)\
    GetPosition\
    (   IN OUT  PIRPSTREAM_POSITION pIrpStreamPosition\
    )

/*****************************************************************************
 * IIrpStreamNotifyPhysical
 *****************************************************************************
 * Irp stream notification interface (IrpStream sources this).
 */
DECLARE_INTERFACE_(IIrpStreamNotifyPhysical,IIrpStreamNotify)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    //  For IIrpStreamNotify
    STDMETHOD_(void,IrpSubmitted)
    (   THIS_
        IN      PIRP        Irp,
        IN      BOOLEAN     WasExhausted
    )   PURE;

    STDMETHOD_(NTSTATUS,GetPosition)
    (   THIS_
        IN OUT  PIRPSTREAM_POSITION pIrpStreamPosition
    ) PURE;

    //  For IIrpStreamNotifyPhysical
    STDMETHOD_(void,MappingsCancelled)
    (   THIS_
        IN      PVOID           FirstTag,
        IN      PVOID           LastTag,
        OUT     PULONG          MappingsCancelled
    )   PURE;
};

typedef IIrpStreamNotifyPhysical *PIRPSTREAMNOTIFYPHYSICAL;

#define IMP_IIrpStreamNotifyPhysical_\
    STDMETHODIMP_(void)\
    MappingsCancelled\
    (   IN      PVOID           FirstTag\
    ,   IN      PVOID           LastTag\
    ,   OUT     PULONG          MappingsCancelled\
    )

#define IMP_IIrpStreamNotifyPhysical\
    IMP_IIrpStreamNotify;\
    IMP_IIrpStreamNotifyPhysical_

/*****************************************************************************
 * IIrpStreamSubmit
 *****************************************************************************
 * Irp stream submission interface.
 */
DECLARE_INTERFACE_(IIrpStreamSubmit,IKsShellTransport)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    // for IKsShellTransport
    STDMETHOD_(NTSTATUS,TransferKsIrp)(THIS_
        IN PIRP Irp,
        OUT PIKSSHELLTRANSPORT* NextTransport
        ) PURE;

    STDMETHOD_(void,Connect)(THIS_
        IN PIKSSHELLTRANSPORT NewTransport OPTIONAL,
        OUT PIKSSHELLTRANSPORT *OldTransport OPTIONAL,
        IN KSPIN_DATAFLOW DataFlow
        ) PURE;

    STDMETHOD_(NTSTATUS,SetDeviceState)(THIS_
        IN KSSTATE NewState,
        IN KSSTATE OldState,
        OUT PIKSSHELLTRANSPORT* NextTransport
        ) PURE;

    STDMETHOD_(void,SetResetState)(THIS_
        IN KSRESET ksReset,
        OUT PIKSSHELLTRANSPORT* NextTransport
        ) PURE;
#if DBG
    STDMETHOD_(void,DbgRollCall)(THIS_
        IN  ULONG NameMaxSize,
        OUT PCHAR Name,
        OUT PIKSSHELLTRANSPORT* NextTransport,
        OUT PIKSSHELLTRANSPORT* PrevTransport
        ) PURE;
#endif

    // for IIrpStreamSubmit
    STDMETHOD_(NTSTATUS,GetPosition)
    (   THIS_
        IN OUT  PIRPSTREAM_POSITION pIrpStreamPosition
    )   PURE;
};

typedef IIrpStreamSubmit *PIRPSTREAMSUBMIT;

#define IMP_IIrpStreamSubmit\
    IMP_IKsShellTransport;\
    STDMETHODIMP_(NTSTATUS)\
    GetPosition\
    (   IN OUT  PIRPSTREAM_POSITION pIrpStreamPosition\
    )

/*****************************************************************************
 * IRPSTREAMPACKETINFO
 *****************************************************************************
 * Structure for information regarding an IrpStream packet.
 */
typedef struct
{
    KSSTREAM_HEADER Header;
    ULONGLONG       InputPosition;
    ULONGLONG       OutputPosition;
    ULONG           CurrentOffset;
} IRPSTREAMPACKETINFO, *PIRPSTREAMPACKETINFO;

/*****************************************************************************
 * IIrpStream
 *****************************************************************************
 * Irp stream primary interface.
 */
DECLARE_INTERFACE_(IIrpStream,IIrpStreamSubmit)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    // for IKsShellTransport
    STDMETHOD_(NTSTATUS,TransferKsIrp)(THIS_
        IN PIRP Irp,
        OUT PIKSSHELLTRANSPORT* NextTransport
        ) PURE;

    STDMETHOD_(void,Connect)(THIS_
        IN PIKSSHELLTRANSPORT NewTransport OPTIONAL,
        OUT PIKSSHELLTRANSPORT *OldTransport OPTIONAL,
        IN KSPIN_DATAFLOW DataFlow
        ) PURE;

    STDMETHOD_(NTSTATUS,SetDeviceState)(THIS_
        IN KSSTATE NewState,
        IN KSSTATE OldState,
        OUT PIKSSHELLTRANSPORT* NextTransport
        ) PURE;

    STDMETHOD_(void,SetResetState)(THIS_
        IN KSRESET ksReset,
        OUT PIKSSHELLTRANSPORT* NextTransport
        ) PURE;
#if DBG
    STDMETHOD_(void,DbgRollCall)(THIS_
        IN  ULONG NameMaxSize,
        OUT PCHAR Name,
        OUT PIKSSHELLTRANSPORT* NextTransport,
        OUT PIKSSHELLTRANSPORT* PrevTransport
        ) PURE;
#endif

    // for IIrpStreamSubmit
    STDMETHOD_(NTSTATUS,GetPosition)
    (   THIS_
        IN OUT  PIRPSTREAM_POSITION pIrpStreamPosition
    )   PURE;

    // for IIrpStream
    STDMETHOD_(NTSTATUS,Init)
    (   THIS_
        IN      BOOLEAN             WriteOperation,
        IN      PKSPIN_CONNECT      PinConnect,
        IN      PDEVICE_OBJECT      DeviceObject    OPTIONAL,
        IN      PADAPTER_OBJECT     AdapterObject   OPTIONAL
    )   PURE;

    STDMETHOD_(void,CancelAllIrps)
    (   THIS_
        IN BOOL ClearPositionCounters
    )   PURE;

    STDMETHOD_(void,TerminatePacket)
    (   THIS
    )   PURE;

    STDMETHOD_(NTSTATUS,ChangeOptionsFlags)
    (   THIS_
        IN      ULONG    MappingOrMask,
        IN      ULONG    MappingAndMask,
        IN      ULONG    UnmappingOrMask,
        IN      ULONG    UnmappingAndMask
    )   PURE;

    STDMETHOD_(NTSTATUS,GetPacketInfo)
    (   THIS_
        OUT     PIRPSTREAMPACKETINFO    Mapping     OPTIONAL,
        OUT     PIRPSTREAMPACKETINFO    Unmapping   OPTIONAL
    )   PURE;

    STDMETHOD_(NTSTATUS,SetPacketOffsets)
    (   THIS_
        IN      ULONG   MappingOffset,
        IN      ULONG   UnmappingOffset
    )   PURE;
};

typedef IIrpStream *PIRPSTREAM;

#define IMP_IIrpStream_\
    STDMETHODIMP_(NTSTATUS)\
    Init\
    (   IN      BOOLEAN             WriteOperation,\
        IN      PKSPIN_CONNECT      PinConnect,\
        IN      PDEVICE_OBJECT      DeviceObject    OPTIONAL,\
        IN      PADAPTER_OBJECT     AdapterObject   OPTIONAL\
    );\
    STDMETHODIMP_(void)\
    CancelAllIrps\
    (   IN BOOL ClearPositionCounters\
    );\
    STDMETHODIMP_(void)\
    TerminatePacket\
    (   void\
    );\
    STDMETHODIMP_(NTSTATUS)\
    ChangeOptionsFlags\
    (   IN      ULONG    MappingOrMask,\
        IN      ULONG    MappingAndMask,\
        IN      ULONG    UnmappingOrMask,\
        IN      ULONG    UnmappingAndMask\
    );\
    STDMETHODIMP_(NTSTATUS)\
    GetPacketInfo\
    (   OUT     PIRPSTREAMPACKETINFO    Mapping     OPTIONAL,\
        OUT     PIRPSTREAMPACKETINFO    Unmapping   OPTIONAL\
    );\
    STDMETHODIMP_(NTSTATUS)\
    SetPacketOffsets\
    (   IN      ULONG   MappingOffset,\
        IN      ULONG   UnmappingOffset\
    )

#define IMP_IIrpStream\
    IMP_IIrpStreamSubmit;\
    IMP_IIrpStream_

/*****************************************************************************
 * IIrpStreamVirtual
 *****************************************************************************
 * Irp stream virtual mapping interface.
 */
DECLARE_INTERFACE_(IIrpStreamVirtual,IIrpStream)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    // for IKsShellTransport
    STDMETHOD_(NTSTATUS,TransferKsIrp)(THIS_
        IN PIRP Irp,
        OUT PIKSSHELLTRANSPORT* NextTransport
        ) PURE;

    STDMETHOD_(void,Connect)(THIS_
        IN PIKSSHELLTRANSPORT NewTransport OPTIONAL,
        OUT PIKSSHELLTRANSPORT *OldTransport OPTIONAL,
        IN KSPIN_DATAFLOW DataFlow
        ) PURE;

    STDMETHOD_(NTSTATUS,SetDeviceState)(THIS_
        IN KSSTATE NewState,
        IN KSSTATE OldState,
        OUT PIKSSHELLTRANSPORT* NextTransport
        ) PURE;

    STDMETHOD_(void,SetResetState)(THIS_
        IN KSRESET ksReset,
        OUT PIKSSHELLTRANSPORT* NextTransport
        ) PURE;
#if DBG
    STDMETHOD_(void,DbgRollCall)(THIS_
        IN  ULONG NameMaxSize,
        OUT PCHAR Name,
        OUT PIKSSHELLTRANSPORT* NextTransport,
        OUT PIKSSHELLTRANSPORT* PrevTransport
        ) PURE;
#endif

    // for IIrpStreamSubmit
    STDMETHOD_(NTSTATUS,GetPosition)
    (   THIS_
        IN OUT  PIRPSTREAM_POSITION pIrpStreamPosition
    )   PURE;

    // for IIrpStream
    STDMETHOD_(NTSTATUS,Init)
    (   THIS_
        IN      BOOLEAN             WriteOperation,
        IN      PKSPIN_CONNECT      PinConnect,
        IN      PDEVICE_OBJECT      DeviceObject    OPTIONAL,
        IN      PADAPTER_OBJECT     AdapterObject   OPTIONAL
    )   PURE;

    STDMETHOD_(void,CancelAllIrps)
    (   THIS_
        IN BOOL ClearPositionCounters
    )   PURE;

    STDMETHOD_(void,TerminatePacket)
    (   THIS
    )   PURE;

    STDMETHOD_(NTSTATUS,ChangeOptionsFlags)
    (   THIS_
        IN      ULONG    MappingOrMask,
        IN      ULONG    MappingAndMask,
        IN      ULONG    UnmappingOrMask,
        IN      ULONG    UnmappingAndMask
    )   PURE;

    STDMETHOD_(NTSTATUS,GetPacketInfo)
    (   THIS_
        OUT     PIRPSTREAMPACKETINFO    Mapping     OPTIONAL,
        OUT     PIRPSTREAMPACKETINFO    Unmapping   OPTIONAL
    )   PURE;

    STDMETHOD_(NTSTATUS,SetPacketOffsets)
    (   THIS_
        IN      ULONG   MappingOffset,
        IN      ULONG   UnmappingOffset
    )   PURE;

    //  For IIrpStreamVirtual
    STDMETHOD_(void,RegisterNotifySink)
    (   THIS_
        IN      PIRPSTREAMNOTIFY    NotificationSink    OPTIONAL
    )   PURE;

    STDMETHOD_(void,GetLockedRegion)
    (   THIS_
        OUT     PULONG      ByteCount,
        OUT     PVOID *     SystemAddress
    )   PURE;

    STDMETHOD_(void,ReleaseLockedRegion)
    (   THIS_
        IN      ULONG       ByteCount
    )   PURE;

    STDMETHOD_(void,Copy)
    (   THIS_
        IN      BOOLEAN     WriteOperation,
        IN      ULONG       RequestedSize,
        OUT     PULONG      ActualSize,
        IN OUT  PVOID       Buffer
    )   PURE;

    STDMETHOD_(void,Complete)
    (   THIS_
        IN      ULONG       RequestedSize,
        OUT     PULONG      ActualSize
    )   PURE;

    STDMETHOD_(PKSPIN_LOCK,GetIrpStreamPositionLock)
    (   THIS
    )   PURE;

};

typedef IIrpStreamVirtual *PIRPSTREAMVIRTUAL;

#define IMP_IIrpStreamVirtual_\
    STDMETHODIMP_(void)\
    RegisterNotifySink\
    (   IN      PIRPSTREAMNOTIFY    NotificationSink    OPTIONAL\
    );\
    STDMETHODIMP_(void)\
    GetLockedRegion\
    (   OUT     PULONG      ByteCount,\
        OUT     PVOID *     SystemAddress\
    );\
    STDMETHODIMP_(void)\
    ReleaseLockedRegion\
    (   IN      ULONG       ByteCount\
    );\
    STDMETHODIMP_(void)\
    Copy\
    (   IN      BOOLEAN     WriteOperation,\
        IN      ULONG       RequestedSize,\
        OUT     PULONG      ActualSize,\
        IN OUT  PVOID       Buffer\
    );\
    STDMETHODIMP_(void)\
    Complete\
    (   IN      ULONG       RequestedSize,\
        OUT     PULONG      ActualSize\
    );\
    STDMETHODIMP_(PKSPIN_LOCK)\
    GetIrpStreamPositionLock\
    (\
    )

#define IMP_IIrpStreamVirtual\
    IMP_IIrpStream;\
    IMP_IIrpStreamVirtual_

/*****************************************************************************
 * IIrpStreamPhysical
 *****************************************************************************
 * Irp stream physical mapping interface.
 */
DECLARE_INTERFACE_(IIrpStreamPhysical,IIrpStream)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    // for IKsShellTransport
    STDMETHOD_(NTSTATUS,TransferKsIrp)(THIS_
        IN PIRP Irp,
        OUT PIKSSHELLTRANSPORT* NextTransport
        ) PURE;

    STDMETHOD_(void,Connect)(THIS_
        IN PIKSSHELLTRANSPORT NewTransport OPTIONAL,
        OUT PIKSSHELLTRANSPORT *OldTransport OPTIONAL,
        IN KSPIN_DATAFLOW DataFlow
        ) PURE;

    STDMETHOD_(NTSTATUS,SetDeviceState)(THIS_
        IN KSSTATE NewState,
        IN KSSTATE OldState,
        OUT PIKSSHELLTRANSPORT* NextTransport
        ) PURE;

    STDMETHOD_(void,SetResetState)(THIS_
        IN KSRESET ksReset,
        OUT PIKSSHELLTRANSPORT* NextTransport
        ) PURE;
#if DBG
    STDMETHOD_(void,DbgRollCall)(THIS_
        IN  ULONG NameMaxSize,
        OUT PCHAR Name,
        OUT PIKSSHELLTRANSPORT* NextTransport,
        OUT PIKSSHELLTRANSPORT* PrevTransport
        ) PURE;
#endif

    // for IIrpStreamSubmit
    STDMETHOD_(NTSTATUS,GetPosition)
    (   THIS_
        IN OUT  PIRPSTREAM_POSITION pIrpStreamPosition
    )   PURE;

    // for IIrpStream
    STDMETHOD_(NTSTATUS,Init)
    (   THIS_
        IN      BOOLEAN             WriteOperation,
        IN      PKSPIN_CONNECT      PinConnect,
        IN      PDEVICE_OBJECT      DeviceObject    OPTIONAL,
        IN      PADAPTER_OBJECT     AdapterObject   OPTIONAL
    )   PURE;

    STDMETHOD_(void,CancelAllIrps)
    (   THIS_
        IN BOOL ClearPositionCounters
    )   PURE;

    STDMETHOD_(void,TerminatePacket)
    (   THIS
    )   PURE;

    STDMETHOD_(NTSTATUS,ChangeOptionsFlags)
    (   THIS_
        IN      ULONG    MappingOrMask,
        IN      ULONG    MappingAndMask,
        IN      ULONG    UnmappingOrMask,
        IN      ULONG    UnmappingAndMask
    )   PURE;

    STDMETHOD_(NTSTATUS,GetPacketInfo)
    (   THIS_
        OUT     PIRPSTREAMPACKETINFO    Mapping     OPTIONAL,
        OUT     PIRPSTREAMPACKETINFO    Unmapping   OPTIONAL
    )   PURE;

    STDMETHOD_(NTSTATUS,SetPacketOffsets)
    (   THIS_
        IN      ULONG   MappingOffset,
        IN      ULONG   UnmappingOffset
    )   PURE;

    //  For IIrpStreamPhysical
    STDMETHOD_(void,RegisterPhysicalNotifySink)
    (   THIS_
        IN      PIRPSTREAMNOTIFYPHYSICAL    NotificationSink    OPTIONAL
    )   PURE;

    STDMETHOD_(void,GetMapping)
    (   THIS_
        IN      PVOID               Tag,
        OUT     PPHYSICAL_ADDRESS   PhysicalAddress,
        OUT     PVOID *             VirtualAddress,
        OUT     PULONG              ByteCount,
        OUT     PULONG              Flags
#define MAPPING_FLAG_END_OF_PACKET 0x00000001
    )   PURE;

    STDMETHOD_(void,ReleaseMapping)
    (   THIS_
        IN      PVOID               Tag
    )   PURE;
};

typedef IIrpStreamPhysical *PIRPSTREAMPHYSICAL;

#define IMP_IIrpStreamPhysical_\
    STDMETHODIMP_(void)\
    RegisterPhysicalNotifySink\
    (   IN      PIRPSTREAMNOTIFYPHYSICAL    NotificationSink    OPTIONAL\
    );\
    STDMETHODIMP_(void)\
    GetMapping\
    (   IN      PVOID               Tag,\
        OUT     PPHYSICAL_ADDRESS   PhysicalAddress,\
        OUT     PVOID *             VirtualAddress,\
        OUT     PULONG              ByteCount,\
        OUT     PULONG              Flags\
    );\
    STDMETHODIMP_(void)\
    ReleaseMapping\
    (   IN      PVOID               Tag\
    )

#define IMP_IIrpStreamPhysical\
    IMP_IIrpStream;\
    IMP_IIrpStreamPhysical_



#define IMP_IPortClsVersion \
        STDMETHODIMP_(DWORD) GetVersion() { return kVersionWinXPSP1; };


/*****************************************************************************
 * PcCreateSubdeviceDescriptor()
 *****************************************************************************
 * Creates a subdevice descriptor.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcCreateSubdeviceDescriptor
(
    IN      PPCFILTER_DESCRIPTOR    FilterDescriptor,
    IN      ULONG                   CategoriesCount,
    IN      GUID *                  Categories,
    IN      ULONG                   StreamInterfacesCount,
    IN      PKSPIN_INTERFACE        StreamInterfaces,
    IN      ULONG                   FilterPropertySetCount,
    IN      PKSPROPERTY_SET         FilterPropertySets,
    IN      ULONG                   FilterEventSetCount,
    IN      PKSEVENT_SET            FilterEventSets,
    IN      ULONG                   PinPropertySetCount,
    IN      PKSPROPERTY_SET         PinPropertySets,
    IN      ULONG                   PinEventSetCount,
    IN      PKSEVENT_SET            PinEventSets,
    OUT     PSUBDEVICE_DESCRIPTOR * OutDescriptor
);

/*****************************************************************************
 * PcDeleteSubdeviceDescriptor()
 *****************************************************************************
 * Deletes a subdevice descriptor.
 */
PORTCLASSAPI
void
NTAPI
PcDeleteSubdeviceDescriptor
(
    IN      PSUBDEVICE_DESCRIPTOR   pSubdeviceDescriptor
);

/*****************************************************************************
 * PcValidateConnectRequest()
 *****************************************************************************
 * Validate attempt to create a pin.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcValidateConnectRequest
(
    IN      PIRP                    pIrp,
    IN      PSUBDEVICE_DESCRIPTOR   pSubdeviceDescriptor,
    OUT     PKSPIN_CONNECT *        ppKsPinConnect
);

/*****************************************************************************
 * PcValidatePinCount()
 *****************************************************************************
 * Validate pin count.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcValidatePinCount
(   IN      ULONG                   ulPinId,
    IN      PSUBDEVICE_DESCRIPTOR   pSubdeviceDescriptor,
    IN      PULONG                  pulPinInstanceCounts
);

/*****************************************************************************
 * PcTerminateConnection()
 *****************************************************************************
 * Decrement instance counts associated with a pin.
 */
PORTCLASSAPI
void
NTAPI
PcTerminateConnection
(
    IN      PSUBDEVICE_DESCRIPTOR   pSubdeviceDescriptor,
    IN      PULONG                  pulPinInstanceCounts,
    IN      ULONG                   ulPinId
);

/*****************************************************************************
 * PcVerifyFilterIsReady()
 *****************************************************************************
 * Verify necessary pins are connected.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcVerifyFilterIsReady
(
    IN      PSUBDEVICE_DESCRIPTOR   pSubdeviceDescriptor,
    IN      PULONG                  pulPinInstanceCounts
);

/*****************************************************************************
 * PcAddToPropertyTable()
 *****************************************************************************
 * Adds a PROPERTYITEM property table to a PROPERTY_TABLE structure.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcAddToPropertyTable
(
    IN OUT  PPROPERTY_TABLE         PropertyTable,
    IN      ULONG                   PropertyItemCount,
    IN      const PCPROPERTY_ITEM * PropertyItems,
    IN      ULONG                   PropertyItemSize,
    IN      BOOLEAN                 NodeTable
);

/*****************************************************************************
 * PcFreePropertyTable()
 *****************************************************************************
 * Frees allocated memory in a PROPERTY_TABLE structure.
 */
PORTCLASSAPI
void
NTAPI
PcFreePropertyTable
(
    IN      PPROPERTY_TABLE         PropertyTable
);

/*****************************************************************************
 * PcHandlePropertyWithTable()
 *****************************************************************************
 * Uses a property table to handle a property request IOCTL.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcHandlePropertyWithTable
(
    IN      PIRP                    pIrp,
    IN      ULONG                   ulPropertySetsCount,
    IN      const KSPROPERTY_SET*   pKsPropertySet,
    IN      PPROPERTY_CONTEXT       pPropertyContext
);

/*****************************************************************************
 * PcPinPropertyHandler()
 *****************************************************************************
 * Property handler for pin properties on the filter.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcPinPropertyHandler
(
    IN      PIRP        pIrp,
    IN      PKSP_PIN    pKsPPin,
    IN OUT  PVOID       pvData
);

/*****************************************************************************
 * PcAddToEventTable()
 *****************************************************************************
 * Adds a EVENTITEM event table to an EVENT_TABLE structure.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcAddToEventTable
(
    IN OUT  PEVENT_TABLE            EventTable,
    IN      ULONG                   EventItemCount,
    IN      const PCEVENT_ITEM *    EventItems,
    IN      ULONG                   EventItemSize,
    IN      BOOLEAN                 NodeTable
);

/*****************************************************************************
 * PcFreeEventTable()
 *****************************************************************************
 * Frees allocated memory in an EVENT_TABLE structure.
 */
PORTCLASSAPI
void
NTAPI
PcFreeEventTable
(
    IN      PEVENT_TABLE            EventTable
);

/*****************************************************************************
 * PcHandleEnableEventWithTable()
 *****************************************************************************
 * Uses an event table to handle a KS enable event IOCTL.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcHandleEnableEventWithTable
(
    IN      PIRP                    pIrp,
    IN      PEVENT_CONTEXT          pContext
);

/*****************************************************************************
 * PcHandleDisableEventWithTable()
 *****************************************************************************
 * Uses an event table to handle a KS disable event IOCTL.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcHandleDisableEventWithTable
(
    IN      PIRP                    pIrp,
    IN      PEVENT_CONTEXT          pContext
);

/*****************************************************************************
 * PcGenerateEventList()
 *****************************************************************************
 * Walks an event list and generates desired events.
 */
PORTCLASSAPI
void
NTAPI
PcGenerateEventList
(
    IN      PINTERLOCKED_LIST   EventList,
    IN      GUID*               Set     OPTIONAL,
    IN      ULONG               EventId,
    IN      BOOL                PinEvent,
    IN      ULONG               PinId,
    IN      BOOL                NodeEvent,
    IN      ULONG               NodeId
);

/*****************************************************************************
 * PcGenerateEventDeferredRoutine()
 *****************************************************************************
 * This DPC routine is used when GenerateEventList is called at greater
 * that DISPATCH_LEVEL.
 */
PORTCLASSAPI
void
NTAPI
PcGenerateEventDeferredRoutine
(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,       // PEVENT_DPC_CONTEXT
    IN PVOID SystemArgument1,       // PINTERLOCKED_LIST
    IN PVOID SystemArgument2
);

/*****************************************************************************
 * PcNewIrpStreamVirtual()
 *****************************************************************************
 * Creates and initializes an IrpStream object with a virtual access
 * interface.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcNewIrpStreamVirtual
(
    OUT     PIRPSTREAMVIRTUAL * OutIrpStreamVirtual,
    IN      PUNKNOWN            OuterUnknown            OPTIONAL,
    IN      BOOLEAN             WriteOperation,
    IN      PKSPIN_CONNECT      PinConnect,
    IN      PDEVICE_OBJECT      DeviceObject
);

/*****************************************************************************
 * PcNewIrpStreamPhysical()
 *****************************************************************************
 * Creates and initializes an IrpStream object with a physical access
 * interface.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcNewIrpStreamPhysical
(
    OUT     PIRPSTREAMPHYSICAL *    OutIrpStreamPhysical,
    IN      PUNKNOWN                OuterUnknown            OPTIONAL,
    IN      BOOLEAN                 WriteOperation,
    IN      PKSPIN_CONNECT          PinConnect,
    IN      PDEVICE_OBJECT          DeviceObject,
    IN      PADAPTER_OBJECT         AdapterObject
);

/*****************************************************************************
 * PcDmaSlaveDescription()
 *****************************************************************************
 * Fills in a DMA device description for a slave device based on a resource.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcDmaSlaveDescription
(
    IN      PRESOURCELIST       ResourceList,
    IN      ULONG               ResourceIndex,
    IN      BOOLEAN             DemandMode,
    IN      BOOLEAN             AutoInitialize,
    IN      DMA_SPEED           DmaSpeed,
    IN      ULONG               MaximumLength,
    IN      ULONG               DmaPort,
    OUT     PDEVICE_DESCRIPTION DeviceDescription
);

/*****************************************************************************
 * PcDmaMasterDescription()
 *****************************************************************************
 * Fills in a DMA device description for a master device based on a resource
 * list.
 */
PORTCLASSAPI
void
NTAPI
PcDmaMasterDescription
(
    IN      PRESOURCELIST       ResourceList        OPTIONAL,
    IN      BOOLEAN             ScatterGather,
    IN      BOOLEAN             Dma32BitAddresses,
    IN      BOOLEAN             IgnoreCount,
    IN      BOOLEAN             Dma64BitAddresses,
    IN      DMA_WIDTH           DmaWidth,
    IN      DMA_SPEED           DmaSpeed,
    IN      ULONG               MaximumLength,
    IN      ULONG               DmaPort,
    OUT     PDEVICE_DESCRIPTION DeviceDescription
);

/*****************************************************************************
 * PcCaptureFormat()
 *****************************************************************************
 * Capture a data format in an allocated buffer, possibly changing offensive
 * formats.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcCaptureFormat
(
    OUT     PKSDATAFORMAT *         ppKsDataFormatOut,
    IN      PKSDATAFORMAT           pKsDataFormatIn,
    IN      PSUBDEVICE_DESCRIPTOR   pSubdeviceDescriptor,
    IN      ULONG                   ulPinId
);

/*****************************************************************************
 * PcAcquireFormatResources()
 *****************************************************************************
 * Acquire resources specified in a format.
 */
PORTCLASSAPI
void
NTAPI
PcAcquireFormatResources
(
    IN      PKSDATAFORMAT           pKsDataFormatIn,
    IN      PSUBDEVICE_DESCRIPTOR   pSubdeviceDescriptor,
    IN      ULONG                   ulPinId,
    IN      PPROPERTY_CONTEXT       pPropertyContext
);

NTSTATUS
KspShellCreateRequestor(
    OUT PIKSSHELLTRANSPORT* TransportInterface,
    IN ULONG ProbeFlags,
    IN ULONG StreamHeaderSize OPTIONAL,
    IN ULONG FrameSize,
    IN ULONG FrameCount,
    IN PDEVICE_OBJECT NextDeviceObject,
    IN PFILE_OBJECT AllocatorFileObject OPTIONAL
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\inc\perf.h ===
//---------------------------------------------------------------------------
//
//  Module:   perf.d
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//
//  History:   Date       Author      Comment
//             --------------------------------------------------------------
//             01/02/01   ArthurZ     Created
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1995-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include <wmistr.h>
#include <evntrace.h>

extern ULONG TraceEnable;

#define PerfInstrumentationEnabled() (TraceEnable != 0)

#define NULL_INSTANCE_ID 0

#define KMIXER_SOURCE_GLITCH 2
#define PORTCLS_SOURCE_GLITCH 3

#define PERFGLITCH_PORTCLSOK        0
#define PERFGLITCH_PORTCLSGLITCH    1

VOID
PerfRegisterProvider (
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
PerfUnregisterProvider (
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
PerfWmiDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
PerfLogInsertSilenceGlitch (
    IN ULONG_PTR InstanceId,
    IN ULONG Type,
    IN LONGLONG CurrentTime,
    IN LONGLONG PreviousTime
    );

VOID
PerfLogDMAGlitch (
    IN ULONG_PTR InstanceId,
    IN ULONG Type,
    IN LONGLONG CurrentTime,
    IN LONGLONG PreviousTime
    );

//---------------------------------------------------------------------------
//  End of File: perf.c
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\main\irpstrm.cpp ===
/*****************************************************************************
 * irpstrm.cpp - IRP stream object implementation
 *****************************************************************************
 * Copyright (c) 1997-2000 Microsoft Corporation.  All rights reserved.
 */

#ifndef PC_KDEXT
#include "private.h"





VOID
IrpStreamCancelRoutine
(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
);

#if DBG

#define DbgAcquireMappingIrp(a,b)   AcquireMappingIrp(a,b)
#define DbgAcquireUnmappingIrp(a)   AcquireUnmappingIrp(a)

#else

#define DbgAcquireMappingIrp(a,b)   AcquireMappingIrp(b)
#define DbgAcquireUnmappingIrp(a)   AcquireUnmappingIrp()

#endif
#endif  // PC_KDEXT



#define WHOLE_MDL_THRESHOLD   (PAGE_SIZE * 16)
#define PRE_OFFSET_THRESHOLD  ((PAGE_SIZE / 4) * 3)
#define POST_OFFSET_THRESHOLD (PAGE_SIZE / 4)
#define MAX_PAGES_PER_MDL     16
#define POOL_TAG_IRPSTREAM_IRP_CONTEXT 'sIcP'


#define MAPPING_QUEUE_SIZE  128   // maximum entries in the mapping queue
#define MAX_MAPPINGS        15    // maximum mappings per IoMapTransfer call
                                  //   (this results in at most 16 map registers)

/*****************************************************************************
 * PACKET_HEADER
 *****************************************************************************
 * Extension of KSSTREAM_HEADER containing a pointer to the matching MDL and
 * progress indicators for locking, mapping and unmapping.
 *
 * Invariants:  BytesTotal >= MapPosition >= UnmapPosition
 *
 * It is true of MapPosition and UnmapPosition that at most one packet in an 
 * IrpStream may have a value for the field that is not zero or BytesTotal.  
 * If there is such a packet, all packets preceding it have 0 in that field 
 * and all packets following have BytesTotal in that field.  The two fields 
 * form two progress indicators showing the position in the IrpStream that is
 * currently being mapped or unmapped.
 *
 * When both the BytesX are equal, the packet is ready for completion.  When
 * this is true of all packets in an IRP, the IRP is ready for completion.
 *
 * InputPosition and OutputPosition are used to locate the packet in the
 * stream.  InputPosition refers to the byte position of the packet on the
 * input side.  This means that looped packets are counted only once in this
 * context.  OutputPosition refers to the byte position of the packet on the
 * output side.  This means that looped packets are counted as many times as
 * they are 'played'.
 */
typedef struct PACKET_HEADER_
{
    PKSSTREAM_HEADER        StreamHeader;
    PMDL                    MdlAddress;
    ULONG                   BytesTotal;
    ULONG                   MapPosition;
    ULONG                   UnmapPosition;
    ULONG                   MapCount;
    ULONGLONG               InputPosition;
    ULONGLONG               OutputPosition;
    BOOLEAN                 IncrementMapping;
    BOOLEAN                 IncrementUnmapping;
    struct PACKET_HEADER_ * Next;
}
PACKET_HEADER, *PPACKET_HEADER;

typedef struct
{
#if (DBG)
    ULONG                   IrpLabel;
    ULONG                   Reserved;
#endif
    PEPROCESS               SubmissionProcess;
    PVOID                   IrpStream;
    PPACKET_HEADER          LockingPacket;
    PPACKET_HEADER          MappingPacket;
    PPACKET_HEADER          UnmappingPacket;
    PACKET_HEADER           Packets[1]; // variable
}
IRP_CONTEXT, *PIRP_CONTEXT;

typedef struct
{
    PHYSICAL_ADDRESS    PhysicalAddress;
    PIRP                Irp;
    PPACKET_HEADER      PacketHeader;
    PVOID               VirtualAddress;
    ULONG               ByteCount;
    ULONG               Flags;
    PVOID               MapRegisterBase;
    PVOID               Tag;
    ULONG               MappingStatus;
    PVOID               SubpacketVa;
    ULONG               SubpacketBytes;
}
MAPPING_QUEUE_ENTRY, *PMAPPING_QUEUE_ENTRY;

#define MAPPING_STATUS_EMPTY        0x0000
#define MAPPING_STATUS_MAPPED       0x0001
#define MAPPING_STATUS_DELIVERED    0x0002
#define MAPPING_STATUS_REVOKED      0x0004

#define MAPPING_FLAG_END_OF_SUBPACKET   0x0002

#define PPACKET_HEADER_LOOP PPACKET_HEADER(1)

#define CAST_LVALUE(type,lvalue) (*((type*)&(lvalue)))

#define FLINK_IRP_STORAGE(Irp)              \
    CAST_LVALUE(PLIST_ENTRY,(Irp)->Tail.Overlay.ListEntry.Flink)
#define BLINK_IRP_STORAGE(Irp)              \
    CAST_LVALUE(PLIST_ENTRY,(Irp)->Tail.Overlay.ListEntry.Blink)
#define FIRST_STREAM_HEADER_IRP_STORAGE(Irp)       \
    CAST_LVALUE(PKSSTREAM_HEADER,(Irp)->AssociatedIrp.SystemBuffer)
#define IRP_CONTEXT_IRP_STORAGE(Irp)       \
    CAST_LVALUE(PIRP_CONTEXT,IoGetCurrentIrpStackLocation(Irp)->    \
                Parameters.Others.Argument4)

/*****************************************************************************
 * CIrpStream
 *****************************************************************************
 * Irp stream implementation.
 */
class CIrpStream : public IIrpStreamVirtual,
                   public IIrpStreamPhysical,
                   public CUnknown
{
private:
    PIKSSHELLTRANSPORT m_TransportSink;
    PIKSSHELLTRANSPORT m_TransportSource;

    KSSTATE     m_ksState;
    
    BOOLEAN     m_Flushing;
    BOOLEAN     JustInTime;
    BOOLEAN     WriteOperation;
    BOOLEAN     WasExhausted;

    ULONG       ProbeFlags;
    PIRP        LockedIrp;

    KSPIN_LOCK  m_kSpinLock;
    KSPIN_LOCK  m_RevokeLock;
    KSPIN_LOCK	m_irpStreamPositionLock;

    IRPSTREAM_POSITION  m_irpStreamPosition;

    ULONGLONG   InputPosition;
    ULONGLONG   OutputPosition;

    PADAPTER_OBJECT BusMasterAdapterObject;
    PDEVICE_OBJECT  FunctionalDeviceObject;

    PIRPSTREAMNOTIFY            Notify;
    PIRPSTREAMNOTIFYPHYSICAL    NotifyPhysical;


    //
    // Master spin lock taken when acquiring an IRP.
    //
    KIRQL       m_kIrqlOld;

    LIST_ENTRY  PreLockQueue;
    KSPIN_LOCK  PreLockQueueLock;
    LIST_ENTRY  LockedQueue;
    KSPIN_LOCK  LockedQueueLock;
    LIST_ENTRY  MappedQueue;
    KSPIN_LOCK  MappedQueueLock;
    
    struct
    {
        PMAPPING_QUEUE_ENTRY    Array;
        ULONG                   Head;
        ULONG                   Tail;
        ULONG                   Get;
    }   MappingQueue;

#if (DBG)
    ULONG       MappingsOutstanding;
    ULONG       MappingsQueued;

    ULONG       IrpLabel;
    ULONG       IrpLabelToComplete;

    ULONGLONG   timeStep;
    ULONG       irpCompleteCount;

    PCHAR       MappingIrpOwner;
    PCHAR       UnmappingIrpOwner;
#endif

    PIRP AcquireMappingIrp
    (
#if DBG
        IN      PCHAR       Owner,
#endif
        IN      BOOLEAN     NotifyExhausted
    );

    PIRP AcquireUnmappingIrp
    (
#if DBG
        IN      PCHAR   Owner
#endif
    );

    void ReleaseMappingIrp
    (
        IN      PIRP            Irp,
        IN      PPACKET_HEADER  PacketHeader    OPTIONAL
    );

    void ReleaseUnmappingIrp
    (
        IN      PIRP            Irp,
        IN      PPACKET_HEADER  PacketHeader    OPTIONAL
    );

    NTSTATUS EnqueueMapping
    (
        IN      PHYSICAL_ADDRESS    PhysicalAddress,
        IN      PIRP                Irp,
        IN      PPACKET_HEADER      PacketHeader,
        IN      PVOID               VirtualAddress,
        IN      ULONG               ByteCount,
        IN      ULONG               Flags,
        IN      PVOID               MapRegisterBase,
        IN      ULONG               MappingStatus,
        IN      PVOID               SubpacketVa,
        IN      ULONG               SubpacketBytes
    );

    PMAPPING_QUEUE_ENTRY GetQueuedMapping
    (   void
    );

    PMAPPING_QUEUE_ENTRY DequeueMapping
    (   void
    );

    void
    CancelMappings
    (
        IN      PIRP    pIrp
    );

    void DbgQueues
    (   void
    );

    void
    ForwardIrpsInQueue
    (
        IN PLIST_ENTRY Queue,
        IN PKSPIN_LOCK SpinLock
    );

public:
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CIrpStream);
    ~CIrpStream();

    IMP_IIrpStreamVirtual;
    IMP_IIrpStreamPhysical_;

    PRKTHREAD m_CancelAllIrpsThread;

    /*************************************************************************
     * Friends
     */
    friend
    IO_ALLOCATION_ACTION
    CallbackFromIoAllocateAdapterChannel
    (
        IN      PDEVICE_OBJECT  DeviceObject,
        IN      PIRP            Reserved,
        IN      PVOID           MapRegisterBase,
        IN      PVOID           VoidContext
    );

    friend
    VOID
    IrpStreamCancelRoutine
    (
        IN      PDEVICE_OBJECT   DeviceObject,
        IN      PIRP             Irp
    );

#ifdef PC_KDEXT
    //  Debugger extension routines
    friend
    VOID
    PCKD_AcquireDeviceData
    (
        PDEVICE_CONTEXT     DeviceContext,
        PLIST_ENTRY         SubdeviceList,
        ULONG               Flags
    );
    friend
    VOID
    PCKD_AcquireIrpStreamData
    (
        PVOID           CurrentPinEntry,
        CIrpStream     *RemoteIrpStream,
        CIrpStream     *LocalIrpStream    
    );
#endif
};

/*****************************************************************************
 * CALLBACK_CONTEXT
 *****************************************************************************
 * Context for IoAllocateAdapterChannel() callback.
 */
typedef struct
{
    CIrpStream *    IrpStream;
    // Used for BusMasterAdapterObject, WriteOperation, ApplyMappingConstraints(), EnqueueMapping()
    PPACKET_HEADER  PacketHeader;
    // Used for MdlAddress, MapRegisterBase (out)
    // Queue references this also
    PIRP            Irp;
    // Used for mapping cancellation
    KEVENT          Event;
    // Used for partial mappings
    ULONG           BytesThisMapping;
    // Used for partial mappings
    BOOL            LastSubPacket;
}
CALLBACK_CONTEXT, *PCALLBACK_CONTEXT;




#ifndef PC_KDEXT
/*****************************************************************************
 * Factory.
 */

#pragma code_seg("PAGE")

/*****************************************************************************
 * CreateIrpStream()
 *****************************************************************************
 * Creates an IrpStream object.
 */
NTSTATUS
CreateIrpStream
(
    OUT     PUNKNOWN *  Unknown,
    IN      REFCLSID,
    IN      PUNKNOWN    UnknownOuter    OPTIONAL,
    IN      POOL_TYPE   PoolType
)
{
    PAGED_CODE();

    ASSERT(Unknown);

    _DbgPrintF(DEBUGLVL_LIFETIME,("Creating IRPSTREAM"));

    STD_CREATE_BODY_( CIrpStream,
                      Unknown,
                      UnknownOuter,
                      PoolType,
                      PIRPSTREAMVIRTUAL );
}

/*****************************************************************************
 * PcNewIrpStreamVirtual()
 *****************************************************************************
 * Creates and initializes an IrpStream object with a virtual access
 * interface.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcNewIrpStreamVirtual
(
    OUT     PIRPSTREAMVIRTUAL * OutIrpStreamVirtual,
    IN      PUNKNOWN            OuterUnknown    OPTIONAL,
    IN      BOOLEAN             WriteOperation,
    IN      PKSPIN_CONNECT      PinConnect,
    IN      PDEVICE_OBJECT      DeviceObject
)
{
    PAGED_CODE();

    ASSERT(OutIrpStreamVirtual);
    ASSERT(PinConnect);
    ASSERT(DeviceObject);

    PUNKNOWN    unknown;
    NTSTATUS    ntStatus = CreateIrpStream( &unknown,
                                            GUID_NULL,
                                            OuterUnknown,
                                            NonPagedPool );

    if(NT_SUCCESS(ntStatus))
    {
        PIRPSTREAMVIRTUAL irpStream;
        ntStatus = unknown->QueryInterface( IID_IIrpStreamVirtual,
                                            (PVOID *) &irpStream );

        if(NT_SUCCESS(ntStatus))
        {
            ntStatus = irpStream->Init( WriteOperation,
                                        PinConnect,
                                        DeviceObject,
                                        NULL );

            if(NT_SUCCESS(ntStatus))
            {
                *OutIrpStreamVirtual = irpStream;
            }
            else
            {
                irpStream->Release();
            }
        }

        unknown->Release();
    }

    return ntStatus;
}

/*****************************************************************************
 * PcNewIrpStreamPhysical()
 *****************************************************************************
 * Creates and initializes an IrpStream object with a physical access
 * interface.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcNewIrpStreamPhysical
(
    OUT     PIRPSTREAMPHYSICAL *    OutIrpStreamPhysical,
    IN      PUNKNOWN                OuterUnknown    OPTIONAL,
    IN      BOOLEAN                 WriteOperation,
    IN      PKSPIN_CONNECT          PinConnect,
    IN      PDEVICE_OBJECT          DeviceObject,
    IN      PADAPTER_OBJECT         AdapterObject
)
{
    PAGED_CODE();

    ASSERT(OutIrpStreamPhysical);
    ASSERT(DeviceObject);
    ASSERT(AdapterObject);

    PUNKNOWN    unknown;
    NTSTATUS    ntStatus = CreateIrpStream( &unknown,
                                            GUID_NULL,
                                            OuterUnknown,
                                            NonPagedPool );

    if(NT_SUCCESS(ntStatus))
    {
        PIRPSTREAMPHYSICAL irpStream;
        ntStatus = unknown->QueryInterface( IID_IIrpStreamPhysical,
                                            (PVOID *) &irpStream );

        if(NT_SUCCESS(ntStatus))
        {
            ntStatus = irpStream->Init( WriteOperation,
                                        PinConnect,
                                        DeviceObject,
                                        AdapterObject );

            if(NT_SUCCESS(ntStatus))
            {
                *OutIrpStreamPhysical = irpStream;
            }
            else
            {
                irpStream->Release();
            }
        }

        unknown->Release();
    }

    return ntStatus;
}





/*****************************************************************************
 * Member functions.
 */

/*****************************************************************************
 * CIrpStream::~CIrpStream()
 *****************************************************************************
 * Destructor.
 */
CIrpStream::
~CIrpStream
(   void
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_LIFETIME,("Destroying IRPSTREAM (0x%08x)",this));

    CancelAllIrps( TRUE );  // reset position counters

    if(Notify)
    {
        Notify->Release();
    }

    if(NotifyPhysical)
    {
        NotifyPhysical->Release();
    }

    if(MappingQueue.Array)
    {
        ExFreePool(MappingQueue.Array);
    }
}

/*****************************************************************************
 * CIrpStream::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.
 */
STDMETHODIMP_(NTSTATUS)
CIrpStream::
NonDelegatingQueryInterface
(
    REFIID  Interface,
    PVOID * Object
)
{
    PAGED_CODE();

    ASSERT(Object);

    if(IsEqualGUIDAligned(Interface,IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(PIRPSTREAMVIRTUAL(this)));
    }
    else
        if(IsEqualGUIDAligned(Interface,IID_IIrpStreamSubmit))
    {
        *Object = PVOID(PIRPSTREAMSUBMIT(PIRPSTREAMVIRTUAL(this)));
    }
    else
        if(IsEqualGUIDAligned(Interface,IID_IIrpStream))
    {
        *Object = PVOID(PIRPSTREAM(PIRPSTREAMVIRTUAL(this)));
    }
    else
        if(IsEqualGUIDAligned(Interface,IID_IKsShellTransport))
    {
        *Object = PVOID(PIKSSHELLTRANSPORT(PIRPSTREAMVIRTUAL(this)));
    }
    else
        if(IsEqualGUIDAligned(Interface,IID_IIrpStreamVirtual))
    {
        // Only valid if not configured for physical access.
        if(BusMasterAdapterObject)
        {
            *Object = NULL;
        }
        else
        {
            *Object = QICAST(PIRPSTREAMVIRTUAL);
        }
    }
    else
        if(IsEqualGUIDAligned(Interface,IID_IIrpStreamPhysical))
    {
        // Only valid if configured for physical access or uninitialized.
        if(BusMasterAdapterObject || (ProbeFlags == 0))
        {
            *Object = QICAST(PIRPSTREAMPHYSICAL);
        }
        else
        {
            *Object = NULL;
        }
    }
    else
    {
        *Object = NULL;
    }

    if(*Object)
    {
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

/*****************************************************************************
 * GetPartialMdlCountForMdl()
 *****************************************************************************
 * Determine number of partial MDLs that are required for a source MDL.
 */
ULONG
GetPartialMdlCountForMdl
(
    IN      PVOID   Va,
    IN      ULONG   Size
)
{
    ULONG result = 1;

    if(Size > WHOLE_MDL_THRESHOLD)
    {
        ULONG pageCount = ADDRESS_AND_SIZE_TO_SPAN_PAGES(Va,Size);

        if(BYTE_OFFSET(Va) > PRE_OFFSET_THRESHOLD)
        {
            pageCount--;
        }

        if(BYTE_OFFSET(PVOID(PBYTE(Va) + Size - 1)) < POST_OFFSET_THRESHOLD)
        {
            pageCount--;
        }

        result = (pageCount + MAX_PAGES_PER_MDL - 1) / MAX_PAGES_PER_MDL;
    }

    return result;
}

STDMETHODIMP_(NTSTATUS)
CIrpStream::
TransferKsIrp
(
    IN PIRP Irp,
    OUT PIKSSHELLTRANSPORT* NextTransport
)

/*++

Routine Description:

    This routine handles the arrival of a streaming IRP via the shell 
    transport.

Arguments:

    Irp -
        Contains a pointer to the streaming IRP submitted to the queue.

    NextTransport -
        Contains a pointer to a location at which to deposit a pointer
        to the next transport interface to receive the IRP.  May be set
        to NULL indicating the IRP should not be forwarded further.

Return Value:

    STATUS_SUCCESS, STATUS_PENDING or some error status.

--*/

{
    ASSERT(Irp);
    ASSERT(NextTransport);
    ASSERT(m_TransportSink);
    ASSERT(m_TransportSource);

    //
    // Shunt IRPs to the next object if we are not ready.
    //
    if(m_Flushing || (m_ksState == KSSTATE_STOP) || Irp->Cancel || 
       ! NT_SUCCESS(Irp->IoStatus.Status))
    {
        *NextTransport = m_TransportSink;
        return STATUS_SUCCESS;
    }

    //
    // Not smart enough to do this yet.
    //
    *NextTransport = NULL;

    //
    // Prepare the IRP using KS's handiest function.
    //
    NTSTATUS ntStatus;

    if(ProbeFlags)
    {
        ntStatus = KsProbeStreamIrp( Irp,
                                     ProbeFlags,
                                     sizeof(KSSTREAM_HEADER) );
    }
    else
    {
        ntStatus = STATUS_SUCCESS;
    }

    PIRP_CONTEXT irpContext;
    if(NT_SUCCESS(ntStatus))
    {
        ntStatus = STATUS_PENDING;

        ULONG packetCount = 0;

        //
        // Count the number of 'packet headers' we will be needing.
        //
        PKSSTREAM_HEADER streamHeader = FIRST_STREAM_HEADER_IRP_STORAGE(Irp);

        if( (!streamHeader->DataUsed && WriteOperation) ||
            (!streamHeader->FrameExtent && !WriteOperation) )
        {
            //
            // At least one for the Irp context.
            //
            packetCount = 1;
        }
        else
        {
            for(PMDL mdl = Irp->MdlAddress; mdl; mdl = mdl->Next, streamHeader++)
            {
                if(JustInTime)
                {
                    packetCount += GetPartialMdlCountForMdl( 
#ifdef UNDER_NT
                                                             MmGetSystemAddressForMdlSafe(mdl,HighPagePriority),
#else
                                                             MmGetSystemAddressForMdl(mdl),
#endif
                                                             ( WriteOperation ? 
                                                               streamHeader->DataUsed :
                                                               streamHeader->FrameExtent ) );
                }
                else
                {
                    packetCount++;
                }
            }
        }

        irpContext = PIRP_CONTEXT( ExAllocatePoolWithTag( NonPagedPool,
                                                          ( sizeof(IRP_CONTEXT) +
                                                            ( sizeof(PACKET_HEADER) *
                                                              (packetCount - 1) ) ),
                                                          POOL_TAG_IRPSTREAM_IRP_CONTEXT ) );

        if(irpContext)
        {
            IRP_CONTEXT_IRP_STORAGE(Irp) = irpContext;
        }
        else
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if(NT_SUCCESS(ntStatus))
    {
        irpContext->SubmissionProcess = IoGetCurrentProcess();

        irpContext->LockingPacket =
        irpContext->MappingPacket =
        irpContext->UnmappingPacket = &irpContext->Packets[0];

        irpContext->IrpStream = PVOID(this);

#if (DBG)
        irpContext->IrpLabel = IrpLabel++;
#endif

        PKSSTREAM_HEADER    streamHeader    = FIRST_STREAM_HEADER_IRP_STORAGE(Irp);
        PPACKET_HEADER      packetHeader    = &irpContext->Packets[0];
        PPACKET_HEADER      firstLooped     = NULL;
        PPACKET_HEADER      prevLooped      = NULL;

        if( (!streamHeader->DataUsed && WriteOperation) ||
            (!streamHeader->FrameExtent && !WriteOperation) )
        {
            RtlZeroMemory( packetHeader, sizeof( PACKET_HEADER ) );
            packetHeader->MapCount          = 1;
            packetHeader->StreamHeader      = streamHeader;
            packetHeader->InputPosition     = InputPosition;
            packetHeader->OutputPosition    = OutputPosition;
        }
        else
        {
            for(PMDL mdl = Irp->MdlAddress;
               mdl && NT_SUCCESS(ntStatus);
               mdl = mdl->Next, streamHeader++)
            {
                ULONG bytesRemaining = ( WriteOperation ?
                                         streamHeader->DataUsed :
                                         streamHeader->FrameExtent );

                m_irpStreamPosition.ullCurrentExtent += bytesRemaining;

                BOOLEAN createPartials = ( JustInTime &&
                                           ( bytesRemaining > WHOLE_MDL_THRESHOLD ) );

                ULONG   currentOffset   = MmGetMdlByteOffset(mdl);
#ifdef UNDER_NT
                PVOID   currentVA       = MmGetSystemAddressForMdlSafe(mdl,HighPagePriority);
#else
                PVOID   currentVA       = MmGetSystemAddressForMdl(mdl);
#endif

                while(bytesRemaining)
                {
                    PMDL    partialMdl;
                    ULONG   partialMdlSize;

                    if(! createPartials)
                    {
                        partialMdl      = mdl;
                        partialMdlSize  = bytesRemaining;
                    }
                    else
                    {
                        ASSERT(!"Trying to create partials");
#if 0
                        partialMdlSize = MAX_PAGES_PER_MDL * PAGE_SIZE;

                        if(currentOffset)
                        {
                            //
                            // Handle initial offset.
                            //
                            partialMdlSize -= currentOffset;

                            if(currentOffset > PRE_OFFSET_THRESHOLD)
                            {
                                partialMdlSize += PAGE_SIZE;
                            }

                            currentOffset = 0;
                        }
                        else
                            if(partialMdlSize > bytesRemaining)
                        {
                            partialMdlSize = bytesRemaining;
                        }

                        ASSERT(partialMdlSize <= bytesRemaining);

                        partialMdl = IoAllocateMdl( currentVA,
                                                    partialMdlSize,
                                                    FALSE,
                                                    FALSE,
                                                    NULL );

                        if(partialMdl)
                        {
                            IoBuildPartialMdl( mdl,
                                               partialMdl,
                                               currentVA,
                                               partialMdlSize );
                        }
                        else
                        {
                            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                            break;
                        }
#endif
                    }

                    bytesRemaining -= partialMdlSize;
                    currentVA = PVOID(PBYTE(currentVA) + partialMdlSize);

                    if(   streamHeader->OptionsFlags
                          &   KSSTREAM_HEADER_OPTIONSF_LOOPEDDATA
                      )
                    {
                        if(prevLooped)
                        {
                            // Point the previous looped packet to this one.
                            prevLooped->Next = packetHeader;
                        }
                        else
                        {
                            // No previous looped packet.
                            firstLooped = packetHeader;
                        }

                        prevLooped = packetHeader;
                    }


                    packetHeader->StreamHeader      = streamHeader;
                    packetHeader->MdlAddress        = partialMdl;
                    packetHeader->BytesTotal        = partialMdlSize;
                    packetHeader->MapPosition       = 0;
                    packetHeader->UnmapPosition     = 0;
                    packetHeader->MapCount          =
                    (packetHeader == &irpContext->Packets[0]) ? 1 : 0;
                    packetHeader->IncrementMapping =
                    packetHeader->IncrementUnmapping =
                    (mdl->Next != NULL) || bytesRemaining;
                    packetHeader->Next              = firstLooped;

                    packetHeader->InputPosition     = InputPosition;
                    packetHeader->OutputPosition    = OutputPosition;

                    InputPosition += packetHeader->BytesTotal;

                    packetHeader++;
                }
            }
        }

        _DbgPrintF(DEBUGLVL_BLAB,("AddIrp() IRP %d 0x%8x",IrpLabel,Irp));

        IoMarkIrpPending(Irp);

        if(JustInTime)
        {
            // PreLockQueue feeds JustInTime thread.
            KsAddIrpToCancelableQueue( &PreLockQueue,
                                       &PreLockQueueLock,
                                       Irp,
                                       KsListEntryTail,
                                       KsCancelRoutine );
        }
        else
        {
            // IRP is locked down in advance and ready to map.
            KsAddIrpToCancelableQueue( &LockedQueue,
                                       &LockedQueueLock,
                                       Irp,
                                       KsListEntryTail,
                                       IrpStreamCancelRoutine );
        }
    }

    if(NT_SUCCESS(ntStatus))
    {
        // need to change WasExhausted BEFORE notifying the sink since
        // notifying the sink may result in starvation again.
        BOOLEAN TempWasExhausted = WasExhausted;
        WasExhausted = FALSE;

        if(Notify)
        {
            Notify->IrpSubmitted(Irp,TempWasExhausted);
        }
        else
            if(NotifyPhysical)
        {
            NotifyPhysical->IrpSubmitted(Irp,TempWasExhausted);
        }

        ntStatus = STATUS_PENDING;
    }

    return ntStatus;
}

#pragma code_seg()

/*****************************************************************************
 * CIrpStream::GetPosition()
 *****************************************************************************
 * Gets the current position.
 */
STDMETHODIMP_(NTSTATUS)
CIrpStream::
GetPosition
(
    OUT     PIRPSTREAM_POSITION pIrpStreamPosition
)
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    KIRQL oldIrql;

    KeAcquireSpinLock(&m_irpStreamPositionLock, &oldIrql );
    *pIrpStreamPosition = m_irpStreamPosition;

    //
    // Assume stream position and unmapping position are the same.
    //
    pIrpStreamPosition->ullStreamPosition = pIrpStreamPosition->ullUnmappingPosition;

    //
    // Assume no physical offset.
    //
    pIrpStreamPosition->ullPhysicalOffset = 0;

    //
    // Give the notification sink a chance to modify the position.
    //
    if(Notify)
    {
        ntStatus = Notify->GetPosition(pIrpStreamPosition);
    }
    else
        if(NotifyPhysical)
    {
        ntStatus = NotifyPhysical->GetPosition(pIrpStreamPosition);
    }

    KeReleaseSpinLock(&m_irpStreamPositionLock, oldIrql);
    return ntStatus;
}

#pragma code_seg("PAGE")


STDMETHODIMP_(void)
CIrpStream::
Connect
(
    IN PIKSSHELLTRANSPORT NewTransport OPTIONAL,
    OUT PIKSSHELLTRANSPORT *OldTransport OPTIONAL,
    IN KSPIN_DATAFLOW DataFlow
)

/*++

Routine Description:

    This routine establishes a shell transport connect.

Arguments:

Return Value:

--*/
{
    _DbgPrintF(DEBUGLVL_BLAB,("CIrpStream::Connect"));

    PAGED_CODE();

    KsShellStandardConnect( NewTransport,
                            OldTransport,
                            DataFlow,
                            PIKSSHELLTRANSPORT(PIRPSTREAMVIRTUAL(this)),
                            &m_TransportSource,
                            &m_TransportSink);
}


STDMETHODIMP_(NTSTATUS)
CIrpStream::
SetDeviceState
(
    IN KSSTATE NewState,
    IN KSSTATE OldState,
    OUT PIKSSHELLTRANSPORT* NextTransport
)
/*++

Routine Description:

    This routine handles notification that the device state has changed.

Arguments:

Return Value:

--*/
{
    _DbgPrintF(DEBUGLVL_BLAB,("CIrpStream::SetDeviceState"));

    PAGED_CODE();

    ASSERT(NextTransport);

    if(m_ksState != NewState)
    {
        m_ksState = NewState;

        _DbgPrintF(DEBUGLVL_VERBOSE,("#### IrpStream%p.SetDeviceState:  from %d to %d (%d,%d)",this,OldState,NewState,IsListEmpty(&LockedQueue),IsListEmpty(&MappedQueue)));

        if(NewState > OldState)
        {
            *NextTransport = m_TransportSink;
        }
        else
        {
            *NextTransport = m_TransportSource;
        }

        if(NewState == KSSTATE_STOP)
        {
            if(! WriteOperation)
            {
                TerminatePacket();
            }

            CancelAllIrps(TRUE);
        }

        //
        // Adjust the active pin count
        //
        if( (NewState == KSSTATE_RUN) && (OldState != KSSTATE_RUN) )
        {
            UpdateActivePinCount( PDEVICE_CONTEXT(FunctionalDeviceObject->DeviceExtension),
                                  TRUE );

            // Adjust the stream base position
            if(NotifyPhysical)
            {
                NTSTATUS ntStatus = NotifyPhysical->GetPosition(&m_irpStreamPosition);
                if( NT_SUCCESS(ntStatus) )
                {
                    m_irpStreamPosition.ullStreamOffset = m_irpStreamPosition.ullStreamPosition -
                                                          m_irpStreamPosition.ullUnmappingPosition;
                }
            }
        }
        else
        {
            if( (NewState != KSSTATE_RUN) && (OldState == KSSTATE_RUN) )
            {
                UpdateActivePinCount( PDEVICE_CONTEXT(FunctionalDeviceObject->DeviceExtension),
                                      FALSE );
            }
        }

    }
    else
    {
        *NextTransport = NULL;
    }

    return STATUS_SUCCESS;
}


STDMETHODIMP_(void)
CIrpStream::
SetResetState
(
    IN  KSRESET ksReset,
    OUT PIKSSHELLTRANSPORT* NextTransport
)
/*++

Routine Description:

    This routine handles notification that the reset state has changed.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("CIrpStream::SetResetState"));

    PAGED_CODE();

    ASSERT(NextTransport);

    //
    // Take no action if we were already in this state.
    //
    if(m_Flushing != (ksReset == KSRESET_BEGIN))
    {
        //
        // Tell the caller to forward the state change to our sink.
        //
        *NextTransport = m_TransportSink;

        //
        // Set our local copy of the state.
        //
        m_Flushing = (ksReset == KSRESET_BEGIN);

        //
        // Flush the queues if we are beginning a reset.
        //
        if(m_Flushing)
        {
            CancelAllIrps(TRUE);
        }
    }
    else
    {
        *NextTransport = NULL;
    }
}

/*****************************************************************************
 * CIrpStream::Init()
 *****************************************************************************
 * Initializes the object.
 */
STDMETHODIMP_(NTSTATUS)
CIrpStream::
Init
(
    IN      BOOLEAN         WriteOperation_,
    IN      PKSPIN_CONNECT  PinConnect,
    IN      PDEVICE_OBJECT  DeviceObject,
    IN      PADAPTER_OBJECT AdapterObject   OPTIONAL
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_LIFETIME,("Initializing IRPSTREAM (0x%08x)",this));

    ASSERT(DeviceObject);

    NTSTATUS ntStatus = STATUS_SUCCESS;

#if (DBG)
    timeStep = PcGetTimeInterval(0);
    irpCompleteCount = 0;
#endif

    m_ksState = KSSTATE_STOP;
    m_irpStreamPosition.bLoopedInterface =
        ( PinConnect->Interface.Id == KSINTERFACE_STANDARD_LOOPED_STREAMING );

    InputPosition           = 0;
    OutputPosition          = 0;
    WriteOperation          = WriteOperation_;
    JustInTime              = FALSE;
    FunctionalDeviceObject  = DeviceObject;
    BusMasterAdapterObject  = AdapterObject;
    ProbeFlags              = (( WriteOperation ?
                                 KSPROBE_STREAMWRITE :
                                 KSPROBE_STREAMREAD ) |
                               KSPROBE_ALLOCATEMDL );
    WasExhausted            = TRUE;
#if (DBG)
    MappingsOutstanding     = 0;
    MappingsQueued          = 0;
#endif

    KeInitializeSpinLock(&m_kSpinLock);
    KeInitializeSpinLock(&m_RevokeLock);
    KeInitializeSpinLock(&m_irpStreamPositionLock);

    m_CancelAllIrpsThread = NULL;

    if(JustInTime)
    {
        InitializeListHead(&PreLockQueue);
        KeInitializeSpinLock(&PreLockQueueLock);
    }
    else
    {
        ProbeFlags |= KSPROBE_PROBEANDLOCK | KSPROBE_SYSTEMADDRESS;
    }

    InitializeListHead(&LockedQueue);
    KeInitializeSpinLock(&LockedQueueLock);

    InitializeListHead(&MappedQueue);
    KeInitializeSpinLock(&MappedQueueLock);

    //
    // Source pins don't need to probe because the requestor does it for us.
    //
    if(PinConnect->PinToHandle)
    {
        ProbeFlags = 0;
    }

    // allocate the mapping array
    if(BusMasterAdapterObject)
    {
        MappingQueue.Array = PMAPPING_QUEUE_ENTRY( ExAllocatePoolWithTag( NonPagedPool,
                                                                          sizeof(MAPPING_QUEUE_ENTRY) * MAPPING_QUEUE_SIZE,
                                                                          'qMcP' ) );

        if(! MappingQueue.Array)
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    return ntStatus;
}

#pragma code_seg()

void
CIrpStream::
ForwardIrpsInQueue
(
    IN PLIST_ENTRY Queue,
    IN PKSPIN_LOCK SpinLock
)

/*++

Routine Description:

    This routine forwards all the IRPs in a queue via the shell transport.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("CIrpStream::ForwardIrpsInQueue"));

    ASSERT(Queue);
    ASSERT(SpinLock);

    while(1)
    {
        PIRP irp = KsRemoveIrpFromCancelableQueue( Queue,
                                                   SpinLock,
                                                   KsListEntryHead,
                                                   KsAcquireAndRemoveOnlySingleItem );

        if(! irp)
        {
            break;
        }

        // TODO:  what about revoking the mappings?

        //
        // Forward the IRP to the next object.
        //
        if( IRP_CONTEXT_IRP_STORAGE(irp) )
        {
            _DbgPrintF(DEBUGLVL_VERBOSE,("ForwardIrpsInQueue Freeing non-null context (0x%08x) for IRP (0x%08x)",IRP_CONTEXT_IRP_STORAGE(irp),irp));
            ExFreePool(IRP_CONTEXT_IRP_STORAGE(irp));
            IRP_CONTEXT_IRP_STORAGE(irp) = NULL;
        }

        KsShellTransferKsIrp(m_TransportSink,irp);
    }
}

/*****************************************************************************
 * CIrpStream::CancelAllIrps()
 *****************************************************************************
 * Cancel all IRPs.
 */
STDMETHODIMP_(void)
CIrpStream::CancelAllIrps
(
    IN BOOL ClearPositionCounters
)
{
    _DbgPrintF(DEBUGLVL_VERBOSE,("CIrpStream::CancelAllIrps ClearPositionCounters=%s",ClearPositionCounters ? "TRUE" : "FALSE"));

    KIRQL kIrqlOldRevoke;
    KIRQL kIrqlOldMaster;

    // grab the revoke spinlock (must always grab this BEFORE the master spinlock)
    KeAcquireSpinLock(&m_RevokeLock, &kIrqlOldRevoke);

    // grab the master spinlock
    KeAcquireSpinLock(&m_kSpinLock, &kIrqlOldMaster);

    // remember this so we won't re-acquire the two locks at CancelMapping in this context 
    m_CancelAllIrpsThread = KeGetCurrentThread();

    if(ProbeFlags)
    {
        if(JustInTime)
        {
            KsCancelIo( &PreLockQueue,
                        &PreLockQueueLock );
        }

        KsCancelIo( &LockedQueue,
                    &LockedQueueLock );

        KsCancelIo( &MappedQueue,
                    &MappedQueueLock );

    }
    else
    {
        ForwardIrpsInQueue( &MappedQueue,
                            &MappedQueueLock );

        ForwardIrpsInQueue( &LockedQueue,
                            &LockedQueueLock );

        if(JustInTime)
        {
            ForwardIrpsInQueue( &PreLockQueue,
                                &PreLockQueueLock );
        }
    }

    //
    // clear the input and output position counts
    //
    BOOLEAN bLooped = m_irpStreamPosition.bLoopedInterface;
    ULONGLONG ullStreamOffset = m_irpStreamPosition.ullStreamOffset;
    RtlZeroMemory(&m_irpStreamPosition,sizeof(m_irpStreamPosition));
    m_irpStreamPosition.bLoopedInterface = bLooped;
    m_irpStreamPosition.ullStreamOffset = ullStreamOffset;

    if(ClearPositionCounters)
    {
        InputPosition = 0;
        OutputPosition = 0;
    }
    
    // release the spinlocks, master first
    m_CancelAllIrpsThread = NULL;
    KeReleaseSpinLock(&m_kSpinLock, kIrqlOldMaster);
    KeReleaseSpinLock(&m_RevokeLock, kIrqlOldRevoke);
}

/*****************************************************************************
 * CIrpStream::TerminatePacket()
 *****************************************************************************
 * Bypasses all reamining mappings for the current packet.
 */
STDMETHODIMP_(void)
CIrpStream::
TerminatePacket
(   void
)
{
    if(BusMasterAdapterObject)
    {
        // TODO:  What do we do for PCI?
    }
    else
    {
        PIRP irp = DbgAcquireUnmappingIrp("TerminatePacket");
        if(irp)
        {
            PPACKET_HEADER packetHeader = IRP_CONTEXT_IRP_STORAGE(irp)->UnmappingPacket;

            //
            // The mapping window should be closed.
            //
            if( (packetHeader->MapCount == 1) &&
                (packetHeader->MapPosition == packetHeader->UnmapPosition) &&
                (packetHeader->MapPosition != 0) )
            {
                //
                // Adjust for unused extent.
                //
                if(m_irpStreamPosition.ullCurrentExtent != ULONGLONG(-1))
                {
                    m_irpStreamPosition.ullCurrentExtent +=
                    packetHeader->UnmapPosition;
                    m_irpStreamPosition.ullCurrentExtent -=
                    packetHeader->BytesTotal;
                }

                //
                // We are not at the start of the packet, and this packet
                // should be terminated.  The adjusted BytesTotal will get
                // copied back into DataUsed in the stream header.
                //
                packetHeader->BytesTotal = packetHeader->UnmapPosition;
            }
            else
            {
                //
                // We are at the start of the packet or the packet window is
                // not closed.
                //
                packetHeader = NULL;
            }

            ReleaseUnmappingIrp(irp,packetHeader);
        }
    }
}

/*****************************************************************************
 * CIrpStream::ChangeOptionsFlags()
 *****************************************************************************
 * Change the flags for the current mapping and unmapping IRPs.
 *
 * "Mapping" IRP is the packet currently submitted to the device
 * "Unmapping" IRP is the packet currently completed by the device
 */

STDMETHODIMP_(NTSTATUS)
CIrpStream::
ChangeOptionsFlags
(
    IN  ULONG   MappingOrMask,
    IN  ULONG   MappingAndMask,
    IN  ULONG   UnmappingOrMask,
    IN  ULONG   UnmappingAndMask
)
{
    PIRP            pIrp;
    PPACKET_HEADER  pPacketHeader;
    ULONG           oldOptionsFlags;
    NTSTATUS        ntStatus = STATUS_SUCCESS;

    if((MappingOrMask) || (~MappingAndMask))
    {
        pIrp = DbgAcquireMappingIrp("ChangeOptionsFlags",FALSE);
        if(pIrp)
        {
            pPacketHeader = IRP_CONTEXT_IRP_STORAGE(pIrp)->MappingPacket;
            if((pPacketHeader) && (pPacketHeader->StreamHeader))
            {
                oldOptionsFlags = pPacketHeader->StreamHeader->OptionsFlags;
                oldOptionsFlags |= MappingOrMask;
                oldOptionsFlags &= MappingAndMask;
                pPacketHeader->StreamHeader->OptionsFlags = oldOptionsFlags;
            }
            else
                ntStatus = STATUS_UNSUCCESSFUL;
            ReleaseMappingIrp(pIrp,NULL);
        }
        else
        {
            ntStatus = STATUS_UNSUCCESSFUL;
        }
    }

    if((UnmappingOrMask) || (~UnmappingAndMask))
    {
        pIrp = DbgAcquireUnmappingIrp("ChangeOptionsFlags");
        if(pIrp)
        {
            pPacketHeader = IRP_CONTEXT_IRP_STORAGE(pIrp)->UnmappingPacket;
            if((pPacketHeader) && (pPacketHeader->StreamHeader))
            {
                oldOptionsFlags = pPacketHeader->StreamHeader->OptionsFlags;
                oldOptionsFlags |= UnmappingOrMask;
                oldOptionsFlags &= UnmappingAndMask;
                pPacketHeader->StreamHeader->OptionsFlags = oldOptionsFlags;
            }
            else
                ntStatus = STATUS_UNSUCCESSFUL;
            ReleaseUnmappingIrp(pIrp,NULL);
        }
        else
        {
            ntStatus = STATUS_UNSUCCESSFUL;
        }
    }

    return ntStatus;
}

/*****************************************************************************
 * CIrpStream::GetPacketInfo()
 *****************************************************************************
 * Get information about the current packet.
 *
 * "Mapping" information is the packet information currently
 *      submitted to the device
 * "Unmapping" information is the packet information currently 
 *      completed by the device
 *
 * OutputPosition is the unrolled position of the stream, e.g. the total
 *      number of bytes to the device.
 * InputPosition is the position within the data not include the unrolled
 *      loops.
 */

STDMETHODIMP_(NTSTATUS)
CIrpStream::
GetPacketInfo
(
    OUT     PIRPSTREAMPACKETINFO    Mapping     OPTIONAL,
    OUT     PIRPSTREAMPACKETINFO    Unmapping   OPTIONAL
)
{
    NTSTATUS ntStatus = STATUS_SUCCESS;

    if(Mapping)
    {
        PIRP irp = DbgAcquireMappingIrp("GetPacketInfo",FALSE);

        if(irp)
        {
            PPACKET_HEADER packetHeader =
            IRP_CONTEXT_IRP_STORAGE(irp)->MappingPacket;

            Mapping->Header         = *packetHeader->StreamHeader;
            Mapping->InputPosition  = packetHeader->InputPosition;
            Mapping->OutputPosition = packetHeader->OutputPosition;
            Mapping->CurrentOffset  = packetHeader->MapPosition;

            ReleaseMappingIrp(irp,NULL);
        }
        else
        {
            RtlZeroMemory(&Mapping->Header,sizeof(KSSTREAM_HEADER));
            Mapping->InputPosition  = InputPosition;
            Mapping->OutputPosition = OutputPosition;
            Mapping->CurrentOffset  = 0;
        }
    }

    if(NT_SUCCESS(ntStatus) && Unmapping)
    {
        PIRP irp = DbgAcquireUnmappingIrp("GetPacketInfo");

        if(irp)
        {
            PPACKET_HEADER packetHeader =
            IRP_CONTEXT_IRP_STORAGE(irp)->MappingPacket;

            Unmapping->Header         = *packetHeader->StreamHeader;
            Unmapping->InputPosition  = packetHeader->InputPosition;
            Unmapping->OutputPosition = packetHeader->OutputPosition;
            Unmapping->CurrentOffset  = packetHeader->UnmapPosition;

            ReleaseUnmappingIrp(irp,NULL);
        }
        else
        {
            RtlZeroMemory(&Unmapping->Header,sizeof(KSSTREAM_HEADER));
            Unmapping->InputPosition  = InputPosition;
            Unmapping->OutputPosition = OutputPosition;
            Unmapping->CurrentOffset  = 0;
        }
    }

    return ntStatus;
}

/*****************************************************************************
 * CIrpStream::SetPacketOffsets()
 *****************************************************************************
 * Set packet mapping and unmapping offsets to a specified value.
 */
STDMETHODIMP_(NTSTATUS)
CIrpStream::
SetPacketOffsets
(
    IN      ULONG   MappingOffset,
    IN      ULONG   UnmappingOffset
)
{
    NTSTATUS ntStatus;
    KIRQL    oldIrql;

    // grab the revoke spinlock BEFORE getting the irp (which will grab the
    // master spinlock) so that we don't deadlock
    KeAcquireSpinLock(&m_RevokeLock, &oldIrql);

    //
    // For physical mapping, all mappings must be cancelled.
    //
    CancelMappings(NULL);

    PIRP irp = DbgAcquireMappingIrp("SetPacketOffsets",FALSE);

    if(irp)
    {
        PPACKET_HEADER packetHeader = IRP_CONTEXT_IRP_STORAGE(irp)->MappingPacket;

        packetHeader->MapPosition = MappingOffset;
        packetHeader->UnmapPosition = UnmappingOffset;

        m_irpStreamPosition.ulMappingOffset     = MappingOffset;
        m_irpStreamPosition.ullMappingPosition  = MappingOffset;

        m_irpStreamPosition.ulUnmappingOffset   = UnmappingOffset;
        m_irpStreamPosition.ullUnmappingPosition= UnmappingOffset;

        //
        // Make sure we have good packet sizes.  Normally, the packet sizes
        // are recorded in m_irpStreamPosition when the packets are accessed
        // (e.g. through GetLockedRegion or Complete).  This is generally
        // cool because the offsets are zero until this happens anyway.  In
        // this case, we have non-zero offsets and the possibility that the
        // packet has not been accessed yet, hence no valid packet sizes.
        // Here's some code to fix that.
        //
        if(m_irpStreamPosition.ulMappingPacketSize == 0)
        {
            m_irpStreamPosition.ulMappingPacketSize =
            packetHeader->BytesTotal;
        }

        if(m_irpStreamPosition.ulUnmappingPacketSize == 0)
        {
            m_irpStreamPosition.ulUnmappingPacketSize =
            packetHeader->BytesTotal;
        }

        // Adjust the stream base position
        if(NotifyPhysical)
        {
            NTSTATUS ntStatus2 = NotifyPhysical->GetPosition(&m_irpStreamPosition);
            if( NT_SUCCESS(ntStatus2) )
            {
                m_irpStreamPosition.ullStreamOffset = m_irpStreamPosition.ullStreamPosition -
                                                      m_irpStreamPosition.ullUnmappingPosition;
            }
        }

        ReleaseMappingIrp(irp,NULL);

        KeReleaseSpinLock(&m_RevokeLock, oldIrql);

        // kick the notify sink
        if(Notify)
        {
            Notify->IrpSubmitted(NULL,TRUE);
        }
        else
            if(NotifyPhysical)
        {
            NotifyPhysical->IrpSubmitted(NULL,TRUE);
        }

        ntStatus = STATUS_SUCCESS;
    }
    else
    {
        KeReleaseSpinLock(&m_RevokeLock, oldIrql);

        ntStatus = STATUS_UNSUCCESSFUL;
    }

    return ntStatus;
}

#pragma code_seg("PAGE")

/*****************************************************************************
 * CIrpStream::RegisterNotifySink()
 *****************************************************************************
 * Registers a notification sink.
 */
STDMETHODIMP_(void)
CIrpStream::
RegisterNotifySink
(
    IN      PIRPSTREAMNOTIFY    NotificationSink    OPTIONAL
)
{
    PAGED_CODE();

    if(Notify)
    {
        Notify->Release();
    }

    Notify = NotificationSink;

    if(Notify)
    {
        Notify->AddRef();
    }
}

#pragma code_seg()

/*****************************************************************************
 * CIrpStream::GetLockedRegion()
 *****************************************************************************
 * Get a locked contiguous region of the IRP stream.  This region must be
 * released using ReleaseLockedRegion() within a few microseconds.
 */
STDMETHODIMP_(void)
CIrpStream::
GetLockedRegion
(
    OUT     PULONG      ByteCount,
    OUT     PVOID *     SystemAddress
)
{
    ASSERT(ByteCount);
    ASSERT(SystemAddress);

    BOOL            Done;
    PIRP            irp;
    PPACKET_HEADER  packetHeader;

    Done = FALSE;

    //
    // Find an IRP that has requires some work...
    //
    do 
    {
        irp = DbgAcquireMappingIrp("GetLockedRegion",TRUE);
        Done = TRUE;
        if(irp)
        {
            packetHeader = IRP_CONTEXT_IRP_STORAGE(irp)->MappingPacket;
            //
            // If packetHeader->BytesTotal is 0, then this packet is completed.
            //
            if(! packetHeader->BytesTotal)
            {
                packetHeader->OutputPosition = OutputPosition;
                ReleaseMappingIrp(irp,packetHeader);
                irp = NULL;
                Done = FALSE;
            }
        }
    }
    while(!Done);

    if(irp)
    {
        ASSERT(! LockedIrp);

        LockedIrp = irp;

        //
        // Record new mapping packet information in the position structure.
        //
        if(packetHeader->MapPosition == 0)
        {
            packetHeader->OutputPosition = OutputPosition;
            m_irpStreamPosition.ulMappingOffset = 0;
            m_irpStreamPosition.ulMappingPacketSize =
            packetHeader->BytesTotal;
            m_irpStreamPosition.bMappingPacketLooped =
            (   (   packetHeader->StreamHeader->OptionsFlags
                    &   KSSTREAM_HEADER_OPTIONSF_LOOPEDDATA
                )
                !=  0
            );
        }

        *ByteCount = packetHeader->BytesTotal - packetHeader->MapPosition;
        if(*ByteCount)
        {
            *SystemAddress = PVOID(
#ifdef UNDER_NT
                                   PBYTE(MmGetSystemAddressForMdlSafe(packetHeader->MdlAddress,HighPagePriority))
#else
            PBYTE(MmGetSystemAddressForMdl(packetHeader->MdlAddress))
#endif
                                   + packetHeader->MapPosition );
        }
        else
        {
            *SystemAddress = NULL;
            LockedIrp = NULL;
            ReleaseMappingIrp(irp,NULL);
        }   
    }
    else
    {
        *ByteCount = 0;
        *SystemAddress = NULL;
    }
}

/*****************************************************************************
 * CIrpStream::ReleaseLockedRegion()
 *****************************************************************************
 * Releases the region previously obtained with GetLockedRegion().
 */
STDMETHODIMP_(void)
CIrpStream::
ReleaseLockedRegion
(
    IN      ULONG       ByteCount
)
{
    if(LockedIrp)
    {
        PIRP irp = LockedIrp;

        LockedIrp = NULL;

        PPACKET_HEADER packetHeader =
        IRP_CONTEXT_IRP_STORAGE(irp)->MappingPacket;

        ULONG bytes = packetHeader->BytesTotal - packetHeader->MapPosition;
        if(bytes > ByteCount)
        {
            bytes = ByteCount;
        }

        packetHeader->MapPosition += bytes;
        m_irpStreamPosition.ullMappingPosition += bytes;
        m_irpStreamPosition.ulMappingOffset += bytes;

        if(packetHeader->MapPosition == packetHeader->BytesTotal)
        {
            OutputPosition += packetHeader->BytesTotal;
        }
        else
        {
            // ReleaseMappingIrp() wants only completed headers.
            packetHeader = NULL;
        }

        ReleaseMappingIrp(irp,packetHeader);
    }
}

/*****************************************************************************
 * CIrpStream::Copy()
 *****************************************************************************
 * Copy to or from locked-down memory.
 */
STDMETHODIMP_(void)
CIrpStream::
Copy
(
    IN      BOOLEAN     WriteOperation,
    IN      ULONG       RequestedSize,
    OUT     PULONG      ActualSize,
    IN OUT  PVOID       Buffer
)
{
    ASSERT(ActualSize);
    ASSERT(Buffer);

    PBYTE buffer    = PBYTE(Buffer);
    ULONG remaining = RequestedSize;

    ULONG loopMax = 10000;
    while(remaining)
    {
        ASSERT(loopMax--);
        ULONG   byteCount;
        PVOID   systemAddress;

        GetLockedRegion( &byteCount,
                         &systemAddress );

        if(! byteCount)
        {
            break;
        }

        if(byteCount > remaining)
        {
            byteCount = remaining;
        }

        if(WriteOperation)
        {
            RtlCopyMemory(PVOID(buffer),systemAddress,byteCount);
        }
        else
        {
            RtlCopyMemory(systemAddress,PVOID(buffer),byteCount);
        }

        ReleaseLockedRegion(byteCount);

        buffer      += byteCount;
        remaining   -= byteCount;
    }

    *ActualSize = RequestedSize - remaining;
}

/*****************************************************************************
 * CIrpStream::GetIrpStreamPositionLock()
 *****************************************************************************
 *  So we protect access to m_IrpStreamPosition
 */
STDMETHODIMP_(PKSPIN_LOCK)
CIrpStream::GetIrpStreamPositionLock()
{
   return &m_irpStreamPositionLock;
}
 

/*****************************************************************************
 * CIrpStream::Complete()
 *****************************************************************************
 * Complete.
 */
STDMETHODIMP_(void)
CIrpStream::
Complete
(
    IN      ULONG       RequestedSize,
    OUT     PULONG      ActualSize
)
{
    ASSERT(ActualSize);

    if(RequestedSize == 0)
    {
        *ActualSize = 0;
        return;
    }

    ULONG   remaining = RequestedSize;
    PIRP    irp;

    ULONG loopMax = 10000;
    while(irp = DbgAcquireUnmappingIrp("Complete"))
    {
        ASSERT(loopMax--);

        PPACKET_HEADER packetHeader = IRP_CONTEXT_IRP_STORAGE(irp)->UnmappingPacket;

        ULONG unmapped;

        //
        // Record new unmapping packet information in the position structure.
        //
        if(packetHeader->UnmapPosition == 0)
        {
            m_irpStreamPosition.ulUnmappingOffset = 0;
            m_irpStreamPosition.ulUnmappingPacketSize = packetHeader->BytesTotal;
            m_irpStreamPosition.bUnmappingPacketLooped = ((packetHeader->StreamHeader->OptionsFlags &
                                                           KSSTREAM_HEADER_OPTIONSF_LOOPEDDATA) !=  0 );
        }

        if(packetHeader->MapCount == 1)
        {
            unmapped = packetHeader->MapPosition - packetHeader->UnmapPosition;
        }
        else
        {
            unmapped = packetHeader->BytesTotal - packetHeader->UnmapPosition;
        }

        if(unmapped > remaining)
        {
            unmapped = remaining;
        }

        remaining -= unmapped;

        if(unmapped == 0)
        {
            _DbgPrintF(DEBUGLVL_VERBOSE,("CIrpStream::Complete unmapping zero-length segment"));
            _DbgPrintF(DEBUGLVL_VERBOSE,("CIrpStream::Complete packetHeader->MapCount      = %d",packetHeader->MapCount));
            _DbgPrintF(DEBUGLVL_VERBOSE,("CIrpStream::Complete packetHeader->UnmapPosition = %d",packetHeader->UnmapPosition));
            _DbgPrintF(DEBUGLVL_VERBOSE,("CIrpStream::Complete packetHeader->MapPosition   = %d",packetHeader->MapPosition));
            _DbgPrintF(DEBUGLVL_VERBOSE,("CIrpStream::Complete packetHeader->BytesTotal    = %d",packetHeader->BytesTotal));
            _DbgPrintF(DEBUGLVL_VERBOSE,("CIrpStream::Complete remaining                   = %d",remaining));
        }

        if(JustInTime)
        {
            // TODO:  Unlock the bytes.
        }

        packetHeader->UnmapPosition += unmapped;
        m_irpStreamPosition.ullUnmappingPosition += unmapped;
        m_irpStreamPosition.ulUnmappingOffset += unmapped;

        if(packetHeader->UnmapPosition != packetHeader->BytesTotal)
        {
            // ReleaseUnmappingIrp() wants only completed headers.
            packetHeader = NULL;
        }

        ReleaseUnmappingIrp(irp,packetHeader);

        //
        // If all IRP processing is completed (e.g., the packet header
        // has data, but the processing loop has completed the requested
        // length) then break from this loop.
        //
        if(!remaining && unmapped)
        {
            break;
        }

        //
        // If we have unmapped everything that was mapped in the packet but
        // not all of the packet bytes, kick out of the loop
        //
        if( !unmapped && !packetHeader )
        {
            break;
        }
    }

    *ActualSize = RequestedSize - remaining;
}

#pragma code_seg("PAGE")

/*****************************************************************************
 * CIrpStream::RegisterPhysicalNotifySink()
 *****************************************************************************
 * Registers a notification sink.
 */
STDMETHODIMP_(void)
CIrpStream::
RegisterPhysicalNotifySink
(
    IN      PIRPSTREAMNOTIFYPHYSICAL    NotificationSink    OPTIONAL
)
{
    PAGED_CODE();

    if(NotifyPhysical)
    {
        NotifyPhysical->Release();
    }

    NotifyPhysical = NotificationSink;

    if(NotifyPhysical)
    {
        NotifyPhysical->AddRef();
    }
}

#pragma code_seg()

/*****************************************************************************
 * CIrpStream::GetMapping()
 *****************************************************************************
 * Gets a mapping.
 */
STDMETHODIMP_(void)
CIrpStream::
GetMapping
(
    IN      PVOID               Tag,
    OUT     PPHYSICAL_ADDRESS   PhysicalAddress,
    OUT     PVOID *             VirtualAddress,
    OUT     PULONG              ByteCount,
    OUT     PULONG              Flags
)
{
    ASSERT(PhysicalAddress);
    ASSERT(VirtualAddress);
    ASSERT(ByteCount);
    ASSERT(Flags);

    KIRQL   OldIrql;

    //Acquire the revoke spinlock
    KeAcquireSpinLock(&m_RevokeLock, &OldIrql);

    PMAPPING_QUEUE_ENTRY entry = GetQueuedMapping();

    // skip over any revoked mappings
    while( (NULL != entry) && (entry->MappingStatus == MAPPING_STATUS_REVOKED) )
    {
        entry = GetQueuedMapping();
    }

    if(! entry)
    {
        PIRP irp = DbgAcquireMappingIrp("GetMapping",TRUE);

        if(irp)
        {
            PPACKET_HEADER packetHeader = IRP_CONTEXT_IRP_STORAGE(irp)->MappingPacket;

            // update mapping packet info
            m_irpStreamPosition.ulMappingPacketSize = packetHeader->BytesTotal;
            m_irpStreamPosition.bMappingPacketLooped = ( ( packetHeader->StreamHeader->OptionsFlags &
                                                           KSSTREAM_HEADER_OPTIONSF_LOOPEDDATA ) != 0 );
            m_irpStreamPosition.ulMappingOffset = packetHeader->MapPosition;

            //
            // Deal with one-shot buffer.
            //
            if( packetHeader->MapPosition &&
                ( packetHeader->MapPosition == packetHeader->BytesTotal ) )
            {
                ReleaseMappingIrp(irp,NULL);
            }
            else
            {
                // grab the global DMA lock that serializes IoAllocateAdapter calls (we're already at DISPATCH_LEVEL)
                KeAcquireSpinLockAtDpcLevel( PDEVICE_CONTEXT(FunctionalDeviceObject->DeviceExtension)->DriverDmaLock );

                ULONG BytesToMap = packetHeader->BytesTotal - packetHeader->MapPosition;

                ULONG   BytesThisMapping = BytesToMap > (PAGE_SIZE * MAX_MAPPINGS) ?
                                           (PAGE_SIZE * MAX_MAPPINGS) :
                                           BytesToMap;

                _DbgPrintF(DEBUGLVL_VERBOSE,("GetMapping mapping a new packet (0x%08x)",BytesThisMapping));

                packetHeader->OutputPosition = OutputPosition;

                ULONG mapRegisterCount = ( BytesThisMapping ?
                                           ADDRESS_AND_SIZE_TO_SPAN_PAGES( PUCHAR(MmGetMdlVirtualAddress( packetHeader->MdlAddress )) +
                                                                           packetHeader->MapPosition,
                                                                           BytesThisMapping ) :
                                           0 );

                if(mapRegisterCount != 0)
                {
                    CALLBACK_CONTEXT callbackContext;

                    callbackContext.IrpStream    = this;
                    callbackContext.PacketHeader = packetHeader;
                    callbackContext.Irp          = irp;
                    KeInitializeEvent(&callbackContext.Event,NotificationEvent,FALSE);
                    callbackContext.BytesThisMapping = BytesThisMapping;
                    callbackContext.LastSubPacket    = (BytesThisMapping == BytesToMap);

                    // note - we're already at DISPATCH_LEVEL (we're holding spinlocks)
                    NTSTATUS ntStatus = IoAllocateAdapterChannel( BusMasterAdapterObject,
                                                                  FunctionalDeviceObject,
                                                                  mapRegisterCount,
                                                                  CallbackFromIoAllocateAdapterChannel,
                                                                  PVOID(&callbackContext) );

                    if(NT_SUCCESS(ntStatus))
                    {
                        NTSTATUS        WaitStatus;
                        LARGE_INTEGER   ZeroTimeout = RtlConvertLongToLargeInteger(0);
                        ULONG           RetryCount = 0;

                        while( RetryCount++ < 10000 )
                        {
                            // Wait for the scatter/gather processing to be completed.
                            WaitStatus = KeWaitForSingleObject( &callbackContext.Event,
                                                                Suspended,
                                                                KernelMode,
                                                                FALSE,
                                                                &ZeroTimeout );
    
                            if( WaitStatus == STATUS_SUCCESS )
                            {
                                entry = GetQueuedMapping();
                                break;
                            }
                        }
    
                    } else
                    {
                        ReleaseMappingIrp( irp, NULL );
                        KeReleaseSpinLockFromDpcLevel( PDEVICE_CONTEXT(FunctionalDeviceObject->DeviceExtension)->DriverDmaLock );
                        _DbgPrintF(DEBUGLVL_TERSE,("IoAllocateAdapterChannel FAILED (0x%08x)",ntStatus));
                    }
                } else
                {
                    ReleaseMappingIrp( irp,NULL );
                    KeReleaseSpinLockFromDpcLevel( PDEVICE_CONTEXT(FunctionalDeviceObject->DeviceExtension)->DriverDmaLock );
                }
            }
        } else
        {
            _DbgPrintF(DEBUGLVL_VERBOSE,("GetMapping() unable to get an IRP"));
        }
    }

    if(entry)
    {
        // it had better be mapped...
        ASSERT( entry->MappingStatus == MAPPING_STATUS_MAPPED );

        entry->Tag            = Tag;
        entry->MappingStatus  = MAPPING_STATUS_DELIVERED;

        *PhysicalAddress      = entry->PhysicalAddress;
        *VirtualAddress       = entry->VirtualAddress;
        *ByteCount            = entry->ByteCount;
        *Flags                = (entry->Flags & (MAPPING_FLAG_END_OF_PACKET | MAPPING_FLAG_END_OF_SUBPACKET)) ?
                                MAPPING_FLAG_END_OF_PACKET : 0;

        m_irpStreamPosition.ullMappingPosition += entry->ByteCount;
        m_irpStreamPosition.ulMappingOffset += entry->ByteCount;

#if (DBG)
        MappingsOutstanding++;
#endif
    }
    else
    {
        WasExhausted = TRUE;
        *ByteCount = 0;
    }

    KeReleaseSpinLock(&m_RevokeLock, OldIrql);
}

/*****************************************************************************
 * CIrpStream::ReleaseMapping()
 *****************************************************************************
 * Releases a mapping obtained through GetMapping().
 */
STDMETHODIMP_(void)
CIrpStream::
ReleaseMapping
(
    IN      PVOID   Tag
)
{
    KIRQL   OldIrql;

    //Acquire the revoke spinlock
    KeAcquireSpinLock(&m_RevokeLock, &OldIrql);

    PMAPPING_QUEUE_ENTRY entry = DequeueMapping();

    while( (NULL != entry) && (entry->MappingStatus != MAPPING_STATUS_DELIVERED) )
    {
        entry->MappingStatus = MAPPING_STATUS_EMPTY;
        entry->Tag = PVOID(-1);

        entry = DequeueMapping();
    }

    // check if we found and entry
    if( !entry )
    {
        KeReleaseSpinLock(&m_RevokeLock, OldIrql);

        _DbgPrintF(DEBUGLVL_VERBOSE,("ReleaseMapping failed to find a mapping to release"));
        return;
    }

    //
    // Due to race conditions between portcls and the WDM driver, the driver
    // might first release the second mapping and then the first mapping in
    // the row.
    // By design, it doesn't make sense for a audio driver to play "in the
    // middle" of a stream and release mappings there. The only exception
    // where mappings might not be released in order how the driver got them
    // is mentioned above.
    // Since we know that, we don't need to search for the right mapping!
    //
    
    // mark the entry as empty
    entry->MappingStatus = MAPPING_STATUS_EMPTY;
    entry->Tag = PVOID(-1);

#if (DBG)
    MappingsOutstanding--;
#endif

    // get the unmapping irp
    PIRP irp = DbgAcquireUnmappingIrp("ReleaseMapping");

    if( irp )
    {
        PPACKET_HEADER packetHeader = IRP_CONTEXT_IRP_STORAGE(irp)->UnmappingPacket;

        // update position info
        packetHeader->UnmapPosition += entry->ByteCount;
            m_irpStreamPosition.ulUnmappingPacketSize = packetHeader->BytesTotal;
        m_irpStreamPosition.ulUnmappingOffset = packetHeader->UnmapPosition;
        m_irpStreamPosition.ullUnmappingPosition += entry->ByteCount;
            m_irpStreamPosition.bUnmappingPacketLooped = ( ( packetHeader->StreamHeader->OptionsFlags &
                                                             KSSTREAM_HEADER_OPTIONSF_LOOPEDDATA ) != 0 );

        // check if this is the last mapping in the packet or subpacket
        if( ( entry->Flags & MAPPING_FLAG_END_OF_PACKET ) ||
            ( entry->Flags & MAPPING_FLAG_END_OF_SUBPACKET) )
        {
            // Flush the DMA adapter buffers.
            IoFlushAdapterBuffers( BusMasterAdapterObject,
                                   packetHeader->MdlAddress,
                                   entry->MapRegisterBase,
                                   entry->SubpacketVa,
                                   entry->SubpacketBytes,
                                   WriteOperation );
    
            IoFreeMapRegisters( BusMasterAdapterObject,
                                entry->MapRegisterBase,
                                ADDRESS_AND_SIZE_TO_SPAN_PAGES(entry->SubpacketVa,entry->SubpacketBytes) );
        }

        // release the unmapping irp and only pass the packet header if the packet is completed
        ReleaseUnmappingIrp(irp, (entry->Flags & MAPPING_FLAG_END_OF_PACKET) ? packetHeader : NULL);
    }

    KeReleaseSpinLock(&m_RevokeLock, OldIrql);
}

/*****************************************************************************
 * CallbackFromIoAllocateAdapterChannel()
 *****************************************************************************
 * Callback from IoAllocateAdapterChannel to create scatter/gather entries.
 */
static
IO_ALLOCATION_ACTION
CallbackFromIoAllocateAdapterChannel
(
    IN      PDEVICE_OBJECT  DeviceObject,
    IN      PIRP            Reserved,
    IN      PVOID           MapRegisterBase,
    IN      PVOID           VoidContext
)
{
    ASSERT(DeviceObject);
    ASSERT(VoidContext);

    PCALLBACK_CONTEXT context = PCALLBACK_CONTEXT(VoidContext);

    PIRP Irp = context->Irp;

    PUCHAR virtualAddress = PUCHAR(MmGetMdlVirtualAddress(context->PacketHeader->MdlAddress));

#ifdef UNDER_NT
    PUCHAR entryVA = PUCHAR(MmGetSystemAddressForMdlSafe(context->PacketHeader->MdlAddress,HighPagePriority));
#else
    PUCHAR entryVA = PUCHAR(MmGetSystemAddressForMdl(context->PacketHeader->MdlAddress));
#endif

    ULONG bytesRemaining = context->BytesThisMapping;

    ULONG flags = context->LastSubPacket ? MAPPING_FLAG_END_OF_PACKET : MAPPING_FLAG_END_OF_SUBPACKET;

    //
    // Consider mapping offset in case we have set position.
    //
    virtualAddress  += context->PacketHeader->MapPosition;
    entryVA         += context->PacketHeader->MapPosition;

    PVOID subpacketVa = virtualAddress;

    while(bytesRemaining)
    {
        ULONG segmentLength = bytesRemaining;

        // Create one mapping.
        PHYSICAL_ADDRESS physicalAddress = IoMapTransfer( context->IrpStream->BusMasterAdapterObject,
                                                          context->PacketHeader->MdlAddress,
                                                          MapRegisterBase,
                                                          virtualAddress,
                                                          &segmentLength,
                                                          context->IrpStream->WriteOperation );

        bytesRemaining -= segmentLength;
        virtualAddress += segmentLength;

        // enqueue the mapping
        while(segmentLength)
        {
            NTSTATUS ntStatus;

            // TODO: break up large mappings based on hardware constraints

            ntStatus = context->IrpStream->EnqueueMapping( physicalAddress,
                                                           Irp,
                                                           context->PacketHeader,
                                                           PVOID(entryVA),
                                                           segmentLength,
                                                           ((bytesRemaining == 0) ? flags : 0),
                                                           MapRegisterBase,
                                                           MAPPING_STATUS_MAPPED,
                                                           ((bytesRemaining == 0) ? subpacketVa : NULL),
                                                           ((bytesRemaining == 0) ? context->BytesThisMapping : 0 ) );
            if( NT_SUCCESS(ntStatus) )
            {
                entryVA += segmentLength;
                physicalAddress.LowPart += segmentLength;

                segmentLength = 0;
            }
            else
            {
                // TODO: deal properly with a full mapping queue
                ASSERT(!"MappingQueue FULL");
            }
        }
    }

    context->PacketHeader->MapPosition += context->BytesThisMapping;
    context->IrpStream->OutputPosition += context->BytesThisMapping;

    context->IrpStream->ReleaseMappingIrp(context->Irp,
        ((context->PacketHeader->MapPosition == context->PacketHeader->BytesTotal) ? context->PacketHeader : NULL));

    KeSetEvent(&context->Event,0,FALSE);

    KeReleaseSpinLock( PDEVICE_CONTEXT(context->IrpStream->FunctionalDeviceObject->DeviceExtension)->DriverDmaLock, KeGetCurrentIrql() );

    return DeallocateObjectKeepRegisters;
}

/*****************************************************************************
 * CIrpStream::AcquireMappingIrp()
 *****************************************************************************
 * Acquire the IRP in which mapping is currently occuring.
 */
PIRP
CIrpStream::
AcquireMappingIrp
(
#if DBG
    IN      PCHAR   Owner,
#endif
    IN      BOOLEAN NotifyExhausted
)
{
    KIRQL kIrqlOld;
    KeAcquireSpinLock(&m_kSpinLock,&kIrqlOld);
    m_kIrqlOld = kIrqlOld;

    PIRP irp = KsRemoveIrpFromCancelableQueue( &LockedQueue,
                                               &LockedQueueLock,
                                               KsListEntryHead,
                                               KsAcquireOnlySingleItem );

    if(! irp)
    {
        KeReleaseSpinLock(&m_kSpinLock,kIrqlOld);
    }

#if DBG
    if(irp)
    {
        _DbgPrintF(DEBUGLVL_BLAB,("AcquireMappingIrp() %d 0x%8x",IRP_CONTEXT_IRP_STORAGE(irp)->IrpLabel,irp));
        MappingIrpOwner = Owner;
    }
    else
    {
        _DbgPrintF(DEBUGLVL_BLAB,("AcquireMappingIrp() NO MAPPING IRP AVAILABLE"));
    }
    DbgQueues();
#endif

    return irp;
}

/*****************************************************************************
 * CIrpStream::AcquireUnmappingIrp()
 *****************************************************************************
 * Acquire the IRP in which unmapping is currently occuring.
 */
PIRP
CIrpStream::
AcquireUnmappingIrp
(
#if DBG
    IN      PCHAR   Owner
#endif
)
{
    KIRQL kIrqlOld;
    KeAcquireSpinLock(&m_kSpinLock,&kIrqlOld);
    m_kIrqlOld = kIrqlOld;

    // The IRP that we should be unmapping is at the head of the mapped queue
    // if it is completely mapped.  Otherwise it's at the head of the locked
    // queue, and the mapped queue is empty.

    // Acquire the head IRP in the locked queue just in case.
    PIRP lockedIrp = KsRemoveIrpFromCancelableQueue( &LockedQueue,
                                                     &LockedQueueLock,
                                                     KsListEntryHead,
                                                     KsAcquireOnlySingleItem );

    // Acquire the head IRP in the mapped queue.
    PIRP irp = KsRemoveIrpFromCancelableQueue( &MappedQueue,
                                               &MappedQueueLock,
                                               KsListEntryHead,
                                               KsAcquireOnlySingleItem );

    if(irp)
    {
        // Don't need the IRP from the locked queue.
        if(lockedIrp)
        {
            KsReleaseIrpOnCancelableQueue( lockedIrp,
                                           IrpStreamCancelRoutine );
        }
    }
    else
        if(IsListEmpty(&MappedQueue))
    {
        // Mapped queue is empty, try locked queue.
        if(lockedIrp)
        {
            irp = lockedIrp;
        }
    }
    else
    {
        // There's a busy IRP in the mapped queue.
        if(lockedIrp)
        {
            KsReleaseIrpOnCancelableQueue( lockedIrp,
                                           IrpStreamCancelRoutine );
        }
    }

    if(! irp)
    {
        KeReleaseSpinLock(&m_kSpinLock,kIrqlOld);
    }

#if DBG
    if(irp)
    {
        _DbgPrintF(DEBUGLVL_BLAB,("AcquireUnmappingIrp() %d 0x%8x",IRP_CONTEXT_IRP_STORAGE(irp)->IrpLabel,irp));
        UnmappingIrpOwner = Owner;
    }
    else
    {
        _DbgPrintF(DEBUGLVL_BLAB,("AcquireUnmappingIrp() NO UNMAPPING IRP AVAILABLE"));
    }
    DbgQueues();
#endif

    return irp;
}

/*****************************************************************************
 * CIrpStream::ReleaseMappingIrp()
 *****************************************************************************
 * Releases the mapping IRP previously acquired through AcqureMappingIrp(),
 * possibly handling the completion of a packet.
 */
void
CIrpStream::
ReleaseMappingIrp
(
    IN      PIRP            pIrp,
    IN      PPACKET_HEADER  pPacketHeader   OPTIONAL
)
{
    ASSERT(pIrp);

    if(pPacketHeader)
    {
        if(pPacketHeader->IncrementMapping)
        {
            pPacketHeader->IncrementMapping = FALSE;
            pPacketHeader++;
        }
        else
        {
            PPACKET_HEADER prevPacketHeader = pPacketHeader;

            pPacketHeader = pPacketHeader->Next;

            //
            // If looping back, stop if there is another IRP.
            //
            if( pPacketHeader &&
                (pPacketHeader <= prevPacketHeader) &&
                (FLINK_IRP_STORAGE(pIrp) != &LockedQueue) )
            {
                pPacketHeader = NULL;
            }
        }

        if(pPacketHeader)
        {
            // Use next packet header next time.
            IRP_CONTEXT_IRP_STORAGE(pIrp)->MappingPacket = pPacketHeader;

            pPacketHeader->MapCount++;
            pPacketHeader->MapPosition = 0;
            m_irpStreamPosition.ulMappingOffset = 0;
            m_irpStreamPosition.ulMappingPacketSize = pPacketHeader->BytesTotal;
            m_irpStreamPosition.bMappingPacketLooped = ( ( pPacketHeader->StreamHeader->OptionsFlags &
                                                           KSSTREAM_HEADER_OPTIONSF_LOOPEDDATA ) != 0 );

            KsReleaseIrpOnCancelableQueue( pIrp,
                                           IrpStreamCancelRoutine );
        }
        else if( m_irpStreamPosition.bLoopedInterface && (FLINK_IRP_STORAGE(pIrp) == &LockedQueue) )
        {
            //
            // Completed one-shot with looped interface and there are no more
            // packets.  Just hang out here.
            //
            KsReleaseIrpOnCancelableQueue( pIrp,
                                           IrpStreamCancelRoutine );
        }
        else
        {
            //
            // IRP is completely mapped.
            //

            //
            // See if we need to initiate unmapping.
            //
            BOOL bKickUnmapping = FALSE;

            if(IsListEmpty(&MappedQueue))
            {
                pPacketHeader = IRP_CONTEXT_IRP_STORAGE(pIrp)->UnmappingPacket;

                bKickUnmapping = ( pPacketHeader->UnmapPosition ==  pPacketHeader->BytesTotal );
            }

            //
            // Add the IRP to the mapped queued.
            //
            KsRemoveSpecificIrpFromCancelableQueue(pIrp);
            KsAddIrpToCancelableQueue( &MappedQueue,
                                       &MappedQueueLock,
                                       pIrp,
                                       KsListEntryTail,
                                       IrpStreamCancelRoutine );

            if(bKickUnmapping)
            {
                //
                // Unmap the completed header.
                //
                PIRP pIrpRemoved = KsRemoveIrpFromCancelableQueue( &MappedQueue,
                                                                   &MappedQueueLock,
                                                                   KsListEntryHead,
                                                                   KsAcquireOnlySingleItem );

                ASSERT(pIrpRemoved == pIrp);

                ReleaseUnmappingIrp( pIrp, IRP_CONTEXT_IRP_STORAGE(pIrp)->UnmappingPacket );

                return; // ReleaseUnmappingIrp() releases the spinlock.
            }
        }
    }
    else
    {
        KsReleaseIrpOnCancelableQueue( pIrp,
                                       IrpStreamCancelRoutine );
    }

    KeReleaseSpinLock(&m_kSpinLock,m_kIrqlOld);
}

/*****************************************************************************
 * CIrpStream::ReleaseUnmappingIrp()
 *****************************************************************************
 * Releases the unmapping IRP acquired through AcquireUnmappingIrp(),
 * possibly handling the completion of a packet.
 */
void
CIrpStream::
ReleaseUnmappingIrp
(
    IN      PIRP            pIrp,
    IN      PPACKET_HEADER  pPacketHeader   OPTIONAL
)
{
    ASSERT(pIrp);

    //
    // Loop until there are no more packets completely unmapped.
    //
    while(1)
    {
        //
        // If we don't have a newly unmapped packet, just release.
        //
        if(! pPacketHeader)
        {
            KsReleaseIrpOnCancelableQueue( pIrp,
                                           IrpStreamCancelRoutine );
            break;
        }

        //
        // Loop 'til we find the next packet in the IRP if there is one.
        //
        while(1)
        {
            //
            // Copy back total byte count into data used for capture.
            // It's a no-op for render.
            //
            pPacketHeader->StreamHeader->DataUsed = pPacketHeader->BytesTotal;

            pPacketHeader->MapCount--;

            if(pPacketHeader->IncrementUnmapping)
            {
                pPacketHeader->IncrementUnmapping = FALSE;
                pPacketHeader++;
            }
            else
            {
                pPacketHeader = pPacketHeader->Next;
                if(! pPacketHeader)
                {
                    break;
                }
                else
                    if(pPacketHeader->MapCount == 0)
                {
                    pPacketHeader = NULL;
                    break;
                }
            }

            //
            // Loop only if this is a zero-length packet.
            //
            if(pPacketHeader->BytesTotal)
            {
                break;
            }
        }

        if(pPacketHeader)
        {
            //
            // Use next packet header next time.
            //
            IRP_CONTEXT_IRP_STORAGE(pIrp)->UnmappingPacket = pPacketHeader;

            pPacketHeader->UnmapPosition = 0;
            pPacketHeader = NULL;
        }
        else
        {
            //
            // Remove the IRP from the queue.
            //
            KsRemoveSpecificIrpFromCancelableQueue(pIrp);

            //
            // Done with IRP...free the context memory we allocated
            //
            if( IRP_CONTEXT_IRP_STORAGE(pIrp) )
            {
                ExFreePool( IRP_CONTEXT_IRP_STORAGE(pIrp) );
                IRP_CONTEXT_IRP_STORAGE(pIrp) = NULL;
            } else
            {
                ASSERT( !"Freeing IRP with no context");
            }

            //
            // Indicate in the IRP how much data we have captured.
            //
            if(! WriteOperation)
            {
                pIrp->IoStatus.Information = IoGetCurrentIrpStackLocation(pIrp)->
                                             Parameters.DeviceIoControl.OutputBufferLength;
            }

            //
            // Mark it happy.
            //
            pIrp->IoStatus.Status = STATUS_SUCCESS;

            //
            // Pass it to the next transport sink.
            //
            ASSERT(m_TransportSink);
            KsShellTransferKsIrp(m_TransportSink,pIrp);

            //
            // Acquire the head IRP in the mapped queue.
            //
            pIrp = KsRemoveIrpFromCancelableQueue( &MappedQueue,
                                                   &MappedQueueLock,
                                                   KsListEntryHead,
                                                   KsAcquireOnlySingleItem );

            //
            // No IRP.  Outta here.
            //
            if(! pIrp)
            {
                break;
            }

            //
            // See if we need to complete this packet.
            //
            pPacketHeader = IRP_CONTEXT_IRP_STORAGE(pIrp)->UnmappingPacket;

            if(pPacketHeader->UnmapPosition != pPacketHeader->BytesTotal)
            {
                pPacketHeader = NULL;
            }
        }
    }

    KeReleaseSpinLock(&m_kSpinLock,m_kIrqlOld);
}

/*****************************************************************************
 * CIrpStream::EnqueueMapping()
 *****************************************************************************
 * Add a mapping to the mapping queue.
 */
NTSTATUS
CIrpStream::
EnqueueMapping
(
    IN      PHYSICAL_ADDRESS    PhysicalAddress,
    IN      PIRP                Irp,
    IN      PPACKET_HEADER      PacketHeader,
    IN      PVOID               VirtualAddress,
    IN      ULONG               ByteCount,
    IN      ULONG               Flags,
    IN      PVOID               MapRegisterBase,
    IN      ULONG               MappingStatus,
    IN      PVOID               SubpacketVa,
    IN      ULONG               SubpacketBytes
)
{
    NTSTATUS ntStatus = STATUS_SUCCESS;

    if( (MappingQueue.Tail + 1 == MappingQueue.Head) ||
        ( (MappingQueue.Tail + 1 == MAPPING_QUEUE_SIZE) &&
          (MappingQueue.Head == 0) ) )
    {
        // mapping queue looks full.  check to see if we can move the head to make
        // room.
        if( (MappingQueue.Array[MappingQueue.Head].MappingStatus != MAPPING_STATUS_MAPPED) &&
            (MappingQueue.Array[MappingQueue.Head].MappingStatus != MAPPING_STATUS_DELIVERED) )
        {
            PMAPPING_QUEUE_ENTRY entry = DequeueMapping();

            ASSERT(entry);
            if (entry)
            {
                entry->MappingStatus = MAPPING_STATUS_EMPTY;                        
            }
            else
            {
                ntStatus = STATUS_UNSUCCESSFUL;
            }
        }
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE,("EnqueueMapping MappingQueue FULL! (0x%08x)",this));
            ntStatus = STATUS_UNSUCCESSFUL;
        }
    }

    if (NT_SUCCESS(ntStatus))
    {
        MappingQueue.Array[MappingQueue.Tail].PhysicalAddress  = PhysicalAddress;
        MappingQueue.Array[MappingQueue.Tail].Irp              = Irp;
        MappingQueue.Array[MappingQueue.Tail].PacketHeader     = PacketHeader;
        MappingQueue.Array[MappingQueue.Tail].VirtualAddress   = VirtualAddress;
        MappingQueue.Array[MappingQueue.Tail].ByteCount        = ByteCount;
        MappingQueue.Array[MappingQueue.Tail].Flags            = Flags;
        MappingQueue.Array[MappingQueue.Tail].MapRegisterBase  = MapRegisterBase;
        MappingQueue.Array[MappingQueue.Tail].MappingStatus    = MappingStatus;
        MappingQueue.Array[MappingQueue.Tail].SubpacketVa      = SubpacketVa;
        MappingQueue.Array[MappingQueue.Tail].SubpacketBytes   = SubpacketBytes;

#if (DBG)
        MappingsQueued++;
#endif

        if(++MappingQueue.Tail == MAPPING_QUEUE_SIZE)
        {
            MappingQueue.Tail = 0;
        }
    }
    return ntStatus;
}

/*****************************************************************************
 * CIrpStream::GetQueuedMapping()
 *****************************************************************************
 * Get a queued mapping from the mapping queue.
 */
PMAPPING_QUEUE_ENTRY
CIrpStream::
GetQueuedMapping
(   void
)
{
    PMAPPING_QUEUE_ENTRY result;

    if(MappingQueue.Get == MappingQueue.Tail)
    {
        result = NULL;
    }
    else
    {
        result = &MappingQueue.Array[MappingQueue.Get];

        if(++MappingQueue.Get == MAPPING_QUEUE_SIZE)
        {
            MappingQueue.Get = 0;
        }
    }

    return result;
}

/*****************************************************************************
 * CIrpStream::DequeueMapping()
 *****************************************************************************
 * Remove a mapping from the mapping queue.
 */
PMAPPING_QUEUE_ENTRY
CIrpStream::
DequeueMapping
(   void
)
{
    PMAPPING_QUEUE_ENTRY result;

    if(MappingQueue.Head == MappingQueue.Tail)
    {
        result = NULL;
    }
    else
    {
        result = &MappingQueue.Array[MappingQueue.Head];

#if (DBG)
        MappingsQueued--;
#endif

        if(++MappingQueue.Head == MAPPING_QUEUE_SIZE)
        {
            MappingQueue.Head = 0;
        }
    }

    return result;
}

/*****************************************************************************
 * IrpStreamCancelRoutine()
 *****************************************************************************
 * Do cancellation.
 */
VOID
IrpStreamCancelRoutine
(
    IN      PDEVICE_OBJECT   DeviceObject,
    IN      PIRP             Irp
)
{
    ASSERT(DeviceObject);
    ASSERT(Irp);

    _DbgPrintF(DEBUGLVL_VERBOSE,("CancelRoutine Cancelling IRP: 0x%08x",Irp));

    //
    // Mark the IRP cancelled and call the standard routine.  Doing the
    // marking first has the effect of not completing the IRP in the standard
    // routine.  The standard routine removes the IRP from the queue and
    // releases the cancel spin lock.
    //
    Irp->IoStatus.Status = STATUS_CANCELLED;
    KsCancelRoutine(DeviceObject,Irp);

    // TODO:  Search the mapping queue for mappings to revoke.
    // TODO:  Free associated map registers.

    if (IRP_CONTEXT_IRP_STORAGE(Irp))
    {
        // get the IrpStream context
        CIrpStream *that = (CIrpStream *)(PIRP_CONTEXT(IRP_CONTEXT_IRP_STORAGE(Irp))->IrpStream);

        //
        // if we get here from CancelAllIrps we are assured that the spinlocks
        // are held properly.  if we get here from an arbitrary irp cancellation we won't
        // have either the revoke or the mapping spinlock held.  In that case we need to
        // grab both locks here and release them after the CancelMappings call.
        //
        if ( that->m_CancelAllIrpsThread == KeGetCurrentThread()) {
	        that->CancelMappings(Irp);
	    } else {

        //
        // If we get here from CancelAllIrps we are assured that the spinlocks
        // are held properly.  However, if we get here from an arbitrary irp 
        // cancellation, we won't hold either the revoke or the mapping spinlock.  
        // In that case, we need to grab both locks around CancelMappings().
        //
        
        	KIRQL kIrqlOldRevoke;
        
	        // must always grab revoke lock BEFORE master lock
    	    KeAcquireSpinLock(&that->m_RevokeLock, &kIrqlOldRevoke);
        	KeAcquireSpinLockAtDpcLevel(&that->m_kSpinLock);

	        that->CancelMappings(Irp);

    	    // release the spinlocks, master first
	        KeReleaseSpinLockFromDpcLevel(&that->m_kSpinLock);
    	    KeReleaseSpinLock(&that->m_RevokeLock, kIrqlOldRevoke);
		}
		
        // Free the context memory we allocated
        ExFreePool(IRP_CONTEXT_IRP_STORAGE(Irp));
        IRP_CONTEXT_IRP_STORAGE(Irp) = NULL;        
    }
    else
    {
        ASSERT( !"Freeing IRP with no context");
    }

    IoCompleteRequest(Irp,IO_NO_INCREMENT);
}

/*****************************************************************************
 * CIrpStream::CancelMappings()
 *****************************************************************************
 * Cancel mappings for an IRP or all IRPs.
 */
void
CIrpStream::
CancelMappings
(
    IN      PIRP    pIrp
)
{
    // NOTE: the revoke and master spinlocks must be held before calling this routine

    // check only if we have a non-empty mapping queue
    if( (MappingQueue.Array) &&
        (MappingQueue.Head != MappingQueue.Tail) )
    {
        ULONG   ulPosition      = MappingQueue.Head;
        ULONG   ulFirst         = ULONG(-1);
        ULONG   ulLast          = ULONG(-1);
        ULONG   ulMappingCount  = 0;

        // walk mapping queue from head to tail
        while( ulPosition != MappingQueue.Tail )
        {
            // get the mapping queue entry
            PMAPPING_QUEUE_ENTRY entry = &MappingQueue.Array[ulPosition];

            // check if this mapping belongs to the irp(s) being cancelled
            if( (NULL == pIrp) || (entry->Irp == pIrp) )
            {
                // check if the mapping has been delivered
                if( entry->MappingStatus == MAPPING_STATUS_DELIVERED )
                {
                    _DbgPrintF(DEBUGLVL_VERBOSE,("CancelMappings %d needs revoking",ulPosition));

                    // keep track of this for the driver revoke call
                    if( ulFirst == ULONG(-1) )
                    {
                        ulFirst = ulPosition;
                    }

                    ulLast = ulPosition;
                    ulMappingCount++;
                }

                // is this the last mapping in a packet (and not previously revoked)?
                if( ( ( entry->Flags & MAPPING_FLAG_END_OF_PACKET ) ||
                      ( entry->Flags & MAPPING_FLAG_END_OF_SUBPACKET) ) &&
                    ( entry->MappingStatus != MAPPING_STATUS_REVOKED ) )
                {
                    // do we need to revoke anything in the driver?
                    if( ulMappingCount )
                    {
                        ULONG   ulRevoked = ulMappingCount; // init to how many we are asking for

                        // revoke mappings in the driver
                        if( NotifyPhysical )
                        {
                            _DbgPrintF(DEBUGLVL_VERBOSE,("CancelMappings REVOKING (%d)",ulMappingCount));
                            
                            NotifyPhysical->MappingsCancelled( MappingQueue.Array[ulFirst].Tag,
                                                               MappingQueue.Array[ulLast].Tag,
                                                               &ulRevoked );

#if (DBG)
                            MappingsOutstanding -= ulRevoked;
#endif
                        }

                        // check if all were revoked
                        if( ulRevoked != ulMappingCount )
                        {
                            _DbgPrintF(DEBUGLVL_TERSE,("Mappings not fully revoked (%d of %d)",
                                                       ulRevoked,
                                                       ulMappingCount));
                        }

                        // reset the revoke tracking
                        ulFirst = ULONG(-1);
                        ulLast = ULONG(-1);
                        ulMappingCount = 0;
                    }

                    // get the packet header
                    PPACKET_HEADER header = entry->PacketHeader;

                    // release the mappings in this subpacket
                    if( ( header ) &&
                        ( entry->SubpacketVa ) &&
                        ( entry->SubpacketBytes ) )
                    {
                        // flush and free the mappings and map registers

                        IoFlushAdapterBuffers( BusMasterAdapterObject,
                                               header->MdlAddress,
                                               entry->MapRegisterBase,
                                               entry->SubpacketVa,
                                               entry->SubpacketBytes,
                                               WriteOperation );

                        IoFreeMapRegisters( BusMasterAdapterObject,
                                            entry->MapRegisterBase,
                                            ADDRESS_AND_SIZE_TO_SPAN_PAGES( entry->SubpacketVa,
                                                                            entry->SubpacketBytes ) );

                        if( entry->Flags & MAPPING_FLAG_END_OF_PACKET )
                        {
                            // decrement the map count if this is the end of a packet
                            header->MapCount--;
                        }
                    }
                    else
                    {
                        _DbgPrintF(DEBUGLVL_TERSE,("Mapping entry with EOP flag set and NULL packet header"));
                    }
                }

                // mark the mapping as revoked
                entry->MappingStatus = MAPPING_STATUS_REVOKED;
            }

            // move on to the next entry
            if( ++ulPosition == MAPPING_QUEUE_SIZE )
            {
                ulPosition = 0;
            }
        }
    }
}

#if (DBG)
/*****************************************************************************
 * CIrpStream::DbgQueues()
 *****************************************************************************
 * Show the queues.
 */
void
CIrpStream::
DbgQueues
(   void
)
{
    PLIST_ENTRY entry = LockedQueue.Flink;

    _DbgPrintF(DEBUGLVL_BLAB,("DbgQueues() LockedQueue"));
    while(entry != &LockedQueue)
    {
        PIRP irp = PIRP(CONTAINING_RECORD(entry,IRP,Tail.Overlay.ListEntry));

        _DbgPrintF(DEBUGLVL_BLAB,("    %d 0x%8x",IRP_CONTEXT_IRP_STORAGE(irp)->IrpLabel,irp));

        entry = entry->Flink;
    }

    entry = MappedQueue.Flink;

    _DbgPrintF(DEBUGLVL_BLAB,("DbgQueues() MappedQueue"));
    while(entry != &MappedQueue)
    {
        PIRP irp = PIRP(CONTAINING_RECORD(entry,IRP,Tail.Overlay.ListEntry));

        _DbgPrintF(DEBUGLVL_BLAB,("    %d 0x%8x",IRP_CONTEXT_IRP_STORAGE(irp)->IrpLabel,irp));

        entry = entry->Flink;
    }
}


#include "stdio.h"


STDMETHODIMP_(void)
CIrpStream::
DbgRollCall
(
    IN ULONG MaxNameSize,
    OUT PCHAR Name,
    OUT PIKSSHELLTRANSPORT* NextTransport,
    OUT PIKSSHELLTRANSPORT* PrevTransport
)

/*++

Routine Description:

    This routine produces a component name and the transport pointers.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("CIrpStream::DbgRollCall"));

    PAGED_CODE();

    ASSERT(Name);
    ASSERT(NextTransport);
    ASSERT(PrevTransport);

    ULONG references = AddRef() - 1; Release();

    _snprintf(Name,MaxNameSize,"IrpStream%p refs=%d\n",this,references);
    *NextTransport = m_TransportSink;
    *PrevTransport = m_TransportSource;
}


#endif  // DBG

#endif  // PC_KDEXT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\main\callback.cpp ===
/*****************************************************************************
 * callback.cpp - Generic unload safe callbacks (where possible)
 *****************************************************************************
 * Copyright (c) 1999-2000 Microsoft Corporation.  All rights reserved.
 */

#include "private.h"

#if COMPILED_FOR_WDM110
VOID
EnqueuedIoWorkItemCallback(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PVOID           Context
    );
#else
VOID
EnqueuedWorkItemCallback(
    IN  PVOID   Context
    );
#endif

VOID
EnqueuedDpcCallback(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

#pragma code_seg()

NTSTATUS
CallbackEnqueue(
    IN OUT  PVOID                   *pCallbackHandle OPTIONAL,
    IN      PFNQUEUED_CALLBACK      CallbackRoutine,
    IN      PDEVICE_OBJECT          DeviceObject,
    IN      PVOID                   Context,
    IN      KIRQL                   Irql,
    IN      ULONG                   Flags
    )
{
    PQUEUED_CALLBACK_ITEM pQueuedCallbackItem;

    //
    // Check the flags we understand. If it's not understood, and this is the
    // class of flags support is required for, bail immediately.
    //
    if ((Flags & (~EQCM_SUPPORTED_FLAGS)) & EQCM_SUPPORT_OR_FAIL_FLAGS) {

        return STATUS_NOT_SUPPORTED;
    }

    if ((Irql != PASSIVE_LEVEL) && (Irql != DISPATCH_LEVEL)) {

        ASSERT(0);
        return STATUS_NOT_SUPPORTED;
    }

    if (Flags & EQCF_REUSE_HANDLE) {

        ASSERT(pCallbackHandle);
        pQueuedCallbackItem = (PQUEUED_CALLBACK_ITEM) *pCallbackHandle;

        //
        // Shouldn't already be enqueued.
        //
        ASSERT(pQueuedCallbackItem->Enqueued == 0);

    } else {

        pQueuedCallbackItem = (PQUEUED_CALLBACK_ITEM) ExAllocatePoolWithTag(
            ((KeGetCurrentIrql() == PASSIVE_LEVEL) && (Irql == PASSIVE_LEVEL)) ?
                PagedPool : NonPagedPool,
            sizeof(QUEUED_CALLBACK_ITEM),
            'bCcP'
            );  //  'PcCb'

        if (pQueuedCallbackItem) {

            pQueuedCallbackItem->ReentrancyCount = 0;
#if COMPILED_FOR_WDM110

            pQueuedCallbackItem->IoWorkItem = IoAllocateWorkItem(
                DeviceObject
                );

            if (pQueuedCallbackItem->IoWorkItem == NULL) {

                ExFreePool(pQueuedCallbackItem);
                pQueuedCallbackItem = NULL;
            }
#endif
        }
    }

    if (ARGUMENT_PRESENT(pCallbackHandle)) {
        *pCallbackHandle = pQueuedCallbackItem;
    }

    if (pQueuedCallbackItem) {

        pQueuedCallbackItem->QueuedCallback = CallbackRoutine;
        pQueuedCallbackItem->DeviceObject   = DeviceObject;
        pQueuedCallbackItem->Context        = Context;
        pQueuedCallbackItem->Flags          = Flags;
        pQueuedCallbackItem->Irql           = Irql;
        pQueuedCallbackItem->Enqueued       = 1;

        if ((!(Flags&EQCF_DIFFERENT_THREAD_REQUIRED)) &&
            (KeGetCurrentIrql() == Irql)&&
            (pQueuedCallbackItem->ReentrancyCount < MAX_THREAD_REENTRANCY)) {

            pQueuedCallbackItem->ReentrancyCount++;
#if COMPILED_FOR_WDM110
            EnqueuedIoWorkItemCallback(DeviceObject, (PVOID) pQueuedCallbackItem);
#else // COMPILED_FOR_WDM110
            EnqueuedWorkItemCallback(pQueuedCallbackItem);
#endif // COMPILED_FOR_WDM110

        } else {

            pQueuedCallbackItem->ReentrancyCount = 0;

            if (Irql == PASSIVE_LEVEL) {

#if COMPILED_FOR_WDM110
                IoQueueWorkItem(
                    pQueuedCallbackItem->IoWorkItem,
                    EnqueuedIoWorkItemCallback,
                    DelayedWorkQueue,
                    pQueuedCallbackItem
                    );
#else // COMPILED_FOR_WDM110
                ExInitializeWorkItem( &pQueuedCallbackItem->WorkItem,
                                      EnqueuedWorkItemCallback,
                                      pQueuedCallbackItem );

                ExQueueWorkItem(&pQueuedCallbackItem->WorkItem,DelayedWorkQueue);
#endif // COMPILED_FOR_WDM110

            } else {

                ASSERT(Irql == DISPATCH_LEVEL);
                KeInitializeDpc(
                    &pQueuedCallbackItem->Dpc,
                    EnqueuedDpcCallback,
                    pQueuedCallbackItem
                    );

                KeInsertQueueDpc(
                    &pQueuedCallbackItem->Dpc,
                     NULL,
                     NULL
                     );
            }
        }

        return STATUS_SUCCESS;

    } else {

        return STATUS_INSUFFICIENT_RESOURCES;
    }
}

NTSTATUS
CallbackCancel(
    IN      PVOID   pCallbackHandle
    )
{
    PQUEUED_CALLBACK_ITEM   pQueuedCallbackItem;

    pQueuedCallbackItem = (PQUEUED_CALLBACK_ITEM) pCallbackHandle;

    if (InterlockedExchange(&pQueuedCallbackItem->Enqueued, 0) == 1) {

        //
        // We got it. If it's DPC, also try to yank it from the queue.
        //
        if (pQueuedCallbackItem->Irql == DISPATCH_LEVEL) {

            KeRemoveQueueDpc(&pQueuedCallbackItem->Dpc);
        }

        return STATUS_SUCCESS;
    } else {

        //
        // Caller beat us to it...
        //
        return STATUS_UNSUCCESSFUL;
    }
}

VOID
CallbackFree(
    IN      PVOID   pCallbackHandle
    )
{
    PQUEUED_CALLBACK_ITEM   pQueuedCallbackItem;

    pQueuedCallbackItem = (PQUEUED_CALLBACK_ITEM) pCallbackHandle;

    ASSERT(pQueuedCallbackItem->Enqueued == 0);

#if COMPILED_FOR_WDM110
    IoFreeWorkItem(pQueuedCallbackItem->IoWorkItem);
#endif // COMPILED_FOR_WDM110
    ExFreePool(pQueuedCallbackItem);
}

VOID
EnqueuedDpcCallback(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
{
    PQUEUED_CALLBACK_ITEM   pQueuedCallbackItem;
    QUEUED_CALLBACK_RETURN  returnValue;
    NTSTATUS                ntStatus;

    pQueuedCallbackItem = (PQUEUED_CALLBACK_ITEM) DeferredContext;

    if (InterlockedExchange(&pQueuedCallbackItem->Enqueued, 0) == 1) {

        returnValue = pQueuedCallbackItem->QueuedCallback(
            pQueuedCallbackItem->DeviceObject,
            pQueuedCallbackItem->Context
            );

    } else {

        returnValue = QUEUED_CALLBACK_RETAIN;
    }

    switch(returnValue) {

        case QUEUED_CALLBACK_FREE:

            CallbackFree((PVOID) pQueuedCallbackItem);
            break;

        case QUEUED_CALLBACK_RETAIN:

            //
            // Nothing to do in this case, in fact we don't dare touch anything
            // in the structure lest it be already freed.
            //
            break;

        case QUEUED_CALLBACK_REISSUE:

            //
            // Re-enqueue it with the same handle to avoid reallocation.
            //
            ntStatus = CallbackEnqueue(
                (PVOID *) &pQueuedCallbackItem,
                pQueuedCallbackItem->QueuedCallback,
                pQueuedCallbackItem->DeviceObject,
                pQueuedCallbackItem->Context,
                pQueuedCallbackItem->Irql,
                pQueuedCallbackItem->Flags | EQCF_REUSE_HANDLE
                );

            ASSERT(NT_SUCCESS(ntStatus));
            break;

        default:
            ASSERT(0);
            break;
    }
}

#pragma code_seg("PAGE")

#if COMPILED_FOR_WDM110
VOID
EnqueuedIoWorkItemCallback(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PVOID           Context
    )
#else
VOID
EnqueuedWorkItemCallback(
    IN  PVOID   Context
    )
#endif
{
    PQUEUED_CALLBACK_ITEM   pQueuedCallbackItem;
    QUEUED_CALLBACK_RETURN  returnValue;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    pQueuedCallbackItem = (PQUEUED_CALLBACK_ITEM) Context;

#if COMPILED_FOR_WDM110
    ASSERT(pQueuedCallbackItem->DeviceObject == DeviceObject);
#endif // COMPILED_FOR_WDM110

    if (InterlockedExchange(&pQueuedCallbackItem->Enqueued, 0) == 1) {

        returnValue = pQueuedCallbackItem->QueuedCallback(
            pQueuedCallbackItem->DeviceObject,
            pQueuedCallbackItem->Context
            );

    } else {

        returnValue = QUEUED_CALLBACK_RETAIN;
    }

    switch(returnValue) {

        case QUEUED_CALLBACK_FREE:

            CallbackFree((PVOID) pQueuedCallbackItem);
            break;

        case QUEUED_CALLBACK_RETAIN:

            //
            // Nothing to do in this case, in fact we don't dare touch anything
            // in the structure lest it be already freed.
            //
            break;

        case QUEUED_CALLBACK_REISSUE:

            //
            // Re-enqueue it with the same handle to avoid reallocation.
            //
            ntStatus = CallbackEnqueue(
                (PVOID *) &pQueuedCallbackItem,
                pQueuedCallbackItem->QueuedCallback,
                pQueuedCallbackItem->DeviceObject,
                pQueuedCallbackItem->Context,
                pQueuedCallbackItem->Irql,
                pQueuedCallbackItem->Flags | EQCF_REUSE_HANDLE
                );

            ASSERT(NT_SUCCESS(ntStatus));
            break;

        default:
            ASSERT(0);
            break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\main\event.cpp ===
/*****************************************************************************
 * event.cpp - event support
 *****************************************************************************
 * Copyright (c) 1997-2000 Microsoft Corporation.  All rights reserved.
 */

#include "private.h"





/*****************************************************************************
 * Functions
 */

#pragma code_seg("PAGE")

/*****************************************************************************
 * PcHandleEnableEventWithTable()
 *****************************************************************************
 * Uses an event table to handle a KS enable event IOCTL.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcHandleEnableEventWithTable
(   
    IN      PIRP                    pIrp,
    IN      PEVENT_CONTEXT          pContext
)
{
    PAGED_CODE();
    
    ASSERT(pIrp);
    ASSERT(pContext);

    PIO_STACK_LOCATION  IrpStack;
    ULONG               InputBufferLength;
    NTSTATUS            ntStatus = STATUS_SUCCESS;

    _DbgPrintF(DEBUGLVL_BLAB,("PcHandleEnableEventWithTable"));

    // deal with possible node events
    IrpStack = IoGetCurrentIrpStackLocation( pIrp );
    InputBufferLength = IrpStack->Parameters.DeviceIoControl.InputBufferLength;

    if( InputBufferLength >= sizeof(KSE_NODE) )
    {
        ULONG Flags;

        __try {
            // validate the pointers if we don't trust the client
            if( pIrp->RequestorMode != KernelMode )
            {
                ProbeForRead(   IrpStack->Parameters.DeviceIoControl.Type3InputBuffer, 
                                InputBufferLength, 
                                sizeof(BYTE));
            }

            // get the flags
            Flags = ((PKSEVENT)IrpStack->Parameters.DeviceIoControl.Type3InputBuffer)->Flags;

            if( Flags & KSEVENT_TYPE_TOPOLOGY )
            {
                // get the node id
                pContext->pPropertyContext->ulNodeId =
                    ((PKSE_NODE)IrpStack->Parameters.DeviceIoControl.Type3InputBuffer)->NodeId;

                // mask off the flag bit
                ((PKSEVENT)IrpStack->Parameters.DeviceIoControl.Type3InputBuffer)->Flags &= ~KSEVENT_TYPE_TOPOLOGY;
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            ntStatus = GetExceptionCode ();
        }
    }

    if (NT_SUCCESS(ntStatus))
    {
        pIrp->Tail.Overlay.DriverContext[3] = pContext;

        ntStatus = KsEnableEvent( pIrp,
                                  pContext->ulEventSetCount,
                                  pContext->pEventSets,
                                  NULL,
                                  KSEVENTS_NONE,
                                  NULL );

        // restore ulNodeId
        pContext->pPropertyContext->ulNodeId = ULONG(-1);
    }

    return ntStatus;
}

/*****************************************************************************
 * PcHandleDisableEventWithTable()
 *****************************************************************************
 * Uses an event table to handle a KS disable event IOCTL.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcHandleDisableEventWithTable
(   
    IN      PIRP                    pIrp,
    IN      PEVENT_CONTEXT          pContext
)
{
    PAGED_CODE();

    ASSERT(pIrp);
    ASSERT(pContext);

    _DbgPrintF(DEBUGLVL_VERBOSE,("PcHandleDisableEventWithTable"));

    pIrp->Tail.Overlay.DriverContext[3] = pContext;

    return KsDisableEvent( pIrp,
                           &(pContext->pEventList->List),
                           KSEVENTS_SPINLOCK,
                           &(pContext->pEventList->ListLock) );
}

/*****************************************************************************
 * EventItemAddHandler()
 *****************************************************************************
 * KS-sytle event handler that handles Adds using the 
 * PCEVENT_ITEM mechanism. Note that filter and pin events in the port do not
 * utilize this AddHandler, only events exposed by the miniport.
 */
NTSTATUS
EventItemAddHandler
(
    IN PIRP                     pIrp,
    IN PKSEVENTDATA             pEventData,
    IN PKSEVENT_ENTRY           pEventEntry
)
{
    PAGED_CODE();

    ASSERT(pIrp);
    
    NTSTATUS ntStatus = STATUS_SUCCESS;

    _DbgPrintF(DEBUGLVL_VERBOSE,("EventItemAddHandler"));

    // get the IRP stack location
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation( pIrp );

    // get the event context
    PEVENT_CONTEXT pContext = PEVENT_CONTEXT(pIrp->Tail.Overlay.DriverContext[3]);

    // get the instance size
    ULONG ulInstanceSize = irpSp->Parameters.DeviceIoControl.InputBufferLength;
    ULONG AlignedBufferLength = (irpSp->Parameters.DeviceIoControl.OutputBufferLength + 
                                 FILE_QUAD_ALIGNMENT) &
                                 ~FILE_QUAD_ALIGNMENT;

    //
    // Setup event request structure
    //
    PPCEVENT_REQUEST pPcEventRequest = new(NonPagedPool,'rEcP') PCEVENT_REQUEST;

    if( !pPcEventRequest )
    {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        //
        // Copy target information from the context structure
        //
        pPcEventRequest->MajorTarget    = pContext->pPropertyContext->pUnknownMajorTarget;
        pPcEventRequest->MinorTarget    = pContext->pPropertyContext->pUnknownMinorTarget;
        pPcEventRequest->Node           = pContext->pPropertyContext->ulNodeId;
        pPcEventRequest->EventItem      = NULL;

        // get the filter descriptor
        PPCFILTER_DESCRIPTOR pPcFilterDescriptor = pContext->pPropertyContext->pPcFilterDescriptor;

        if( ULONG(-1) == pPcEventRequest->Node )
        {
            if( !pPcEventRequest->MinorTarget )
            {
                //
                // FILTER EVENT
                //

                if( ( pPcFilterDescriptor ) &&
                    ( pPcFilterDescriptor->AutomationTable ) )
                {
                    // search the filter's automation table for the event
    
                    const PCAUTOMATION_TABLE *pPcAutomationTable =
                        pPcFilterDescriptor->AutomationTable;
    
                    const PCEVENT_ITEM *pPcEventItem = pPcAutomationTable->Events;
    
                    for(ULONG ul = pPcAutomationTable->EventCount; ul--; )
                    {
                        if( IsEqualGUIDAligned( *pPcEventItem->Set,
                                                *pEventEntry->EventSet->Set ) &&
                            pPcEventItem->Id == pEventEntry->EventItem->EventId )
                        {
                            pPcEventRequest->EventItem = pPcEventItem;
                            break;
                        }
    
                        pPcEventItem = PPCEVENT_ITEM( PBYTE(pPcEventItem) + pPcAutomationTable->EventItemSize);
                    }
                }
            }
            else
            {
                //
                // PIN EVENT
                //

                // validate the pin id
                if( ( pPcFilterDescriptor ) &&
                    ( pContext->ulPinId < pPcFilterDescriptor->PinCount ) &&
                    ( pPcFilterDescriptor->Pins[pContext->ulPinId].AutomationTable ) )
                {
                    // search the pin's automation table for the event
                    
                    const PCAUTOMATION_TABLE *pPcAutomationTable =
                        pPcFilterDescriptor->Pins[pContext->ulPinId].AutomationTable;
    
                    const PCEVENT_ITEM *pPcEventItem = pPcAutomationTable->Events;
    
                    for(ULONG ul = pPcAutomationTable->EventCount; ul--; )
                    {
                        if( IsEqualGUIDAligned( *pPcEventItem->Set,
                                                *pEventEntry->EventSet->Set ) &&
                            pPcEventItem->Id == pEventEntry->EventItem->EventId )
                        {
                            pPcEventRequest->EventItem = pPcEventItem;
                            break;
                        }
    
                        pPcEventItem = PPCEVENT_ITEM( PBYTE(pPcEventItem) + pPcAutomationTable->EventItemSize);
                    }
                }
            }
        }
        else
        {
            //
            //  NODE EVENT
            //

            // validate the node id
            if( ( pPcFilterDescriptor ) &&
                ( pPcEventRequest->Node < pPcFilterDescriptor->NodeCount ) &&
                ( pPcFilterDescriptor->Nodes[pPcEventRequest->Node].AutomationTable ) )
            {
                // search the node's automation table for the event

                const PCAUTOMATION_TABLE *pPcAutomationTable =
                    pPcFilterDescriptor->Nodes[pPcEventRequest->Node].AutomationTable;

                const PCEVENT_ITEM *pPcEventItem = pPcAutomationTable->Events;

                for(ULONG ul = pPcAutomationTable->EventCount; ul--; )
                {
                    if( IsEqualGUIDAligned( *pPcEventItem->Set,
                                            *pEventEntry->EventSet->Set ) &&
                        pPcEventItem->Id == pEventEntry->EventItem->EventId )
                    {
                        pPcEventRequest->EventItem = pPcEventItem;
                        break;
                    }

                    pPcEventItem = PPCEVENT_ITEM( PBYTE(pPcEventItem) + pPcAutomationTable->EventItemSize);
                }
            }
        }

        if( NT_SUCCESS(ntStatus) )
        {
            //
            // call the handler if we have an event item with a handler
            if( pPcEventRequest->EventItem &&
                pPcEventRequest->EventItem->Handler )
            {
                PPCEVENT_ENTRY(pEventEntry)->EventItem = pPcEventRequest->EventItem;
                PPCEVENT_ENTRY(pEventEntry)->PinId = pContext->ulPinId;
                PPCEVENT_ENTRY(pEventEntry)->NodeId = pPcEventRequest->Node;
                PPCEVENT_ENTRY(pEventEntry)->pUnknownMajorTarget = pPcEventRequest->MajorTarget;
                PPCEVENT_ENTRY(pEventEntry)->pUnknownMinorTarget = pPcEventRequest->MinorTarget;

                pPcEventRequest->Verb       = PCEVENT_VERB_ADD;
                pPcEventRequest->Irp        = pIrp;
                pPcEventRequest->EventEntry = pEventEntry;

    
                //
                // call the handler
                //
                ntStatus = pPcEventRequest->EventItem->Handler( pPcEventRequest );
            }
            else
            {
                ntStatus = STATUS_NOT_FOUND;
            }
        }

        //
        // delete the request structure unless we are pending
        //
        if( ntStatus != STATUS_PENDING )
        {
            delete pPcEventRequest;
        }
        else
        {
            //
            // only requests with IRPs can be pending
            //
            ASSERT(pIrp);
        }
    }

    return ntStatus;
}

/*****************************************************************************
 * EventItemSupportHandler()
 *****************************************************************************
 * KS-sytle event handler that handles Supports using the 
 * PCEVENT_ITEM mechanism.
 */
NTSTATUS
EventItemSupportHandler
(
    IN PIRP                 pIrp,
    IN PKSIDENTIFIER        pRequest,
    IN OUT PVOID            pData   OPTIONAL
)
{
    PAGED_CODE();

    ASSERT(pIrp);
    ASSERT(pRequest);

    NTSTATUS ntStatus = STATUS_SUCCESS;

    _DbgPrintF(DEBUGLVL_BLAB,("EventItemSupportHandler"));

    // get the IRP stack location
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation( pIrp );

    // get the property/event context
    PEVENT_CONTEXT pContext = PEVENT_CONTEXT(pIrp->Tail.Overlay.DriverContext[3]);

    // get the instance size
    ULONG ulInstanceSize = irpSp->Parameters.DeviceIoControl.InputBufferLength;

    //
    // Setup event request structure
    //
    PPCEVENT_REQUEST pPcEventRequest = new(NonPagedPool,'rEcP') PCEVENT_REQUEST;

    if( !pPcEventRequest )
    {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        //
        // Copy target information from the context structure
        //
        pPcEventRequest->MajorTarget    = pContext->pPropertyContext->pUnknownMajorTarget;
        pPcEventRequest->MinorTarget    = pContext->pPropertyContext->pUnknownMinorTarget;
        pPcEventRequest->Node           = pContext->pPropertyContext->ulNodeId;
        pPcEventRequest->EventItem      = NULL;

        // get the filter descriptor
        PPCFILTER_DESCRIPTOR pPcFilterDescriptor = pContext->pPropertyContext->pPcFilterDescriptor;

        if( ULONG(-1) == pPcEventRequest->Node )
        {
            if( !pPcEventRequest->MinorTarget )
            {
                //
                // FILTER EVENT
                //

                if( ( pPcFilterDescriptor ) &&
                    ( pPcFilterDescriptor->AutomationTable ) )
                {
                    // search the filter's automation table for the event
    
                    const PCAUTOMATION_TABLE *pPcAutomationTable =
                        pPcFilterDescriptor->AutomationTable;
    
                    const PCEVENT_ITEM *pPcEventItem = pPcAutomationTable->Events;
    
                    for(ULONG ul = pPcAutomationTable->EventCount; ul--; )
                    {
                        if( IsEqualGUIDAligned( *pPcEventItem->Set,
                                                pRequest->Set ) &&
                            pPcEventItem->Id == pRequest->Id )
                        {
                            pPcEventRequest->EventItem = pPcEventItem;
                            break;
                        }
    
                        pPcEventItem = PPCEVENT_ITEM( PBYTE(pPcEventItem) + pPcAutomationTable->EventItemSize);
                    }
                }
            }
            else
            {
                //
                // PIN EVENT
                //

                // validate the pin id
                if( ( pPcFilterDescriptor ) &&
                    ( pContext->ulPinId < pPcFilterDescriptor->PinCount ) &&
                    ( pPcFilterDescriptor->Pins[pContext->ulPinId].AutomationTable ) )
                {
                    // search the pin's automation table for the event
                    
                    const PCAUTOMATION_TABLE *pPcAutomationTable =
                        pPcFilterDescriptor->Pins[pContext->ulPinId].AutomationTable;
    
                    const PCEVENT_ITEM *pPcEventItem = pPcAutomationTable->Events;
    
                    for(ULONG ul = pPcAutomationTable->EventCount; ul--; )
                    {
                        if( IsEqualGUIDAligned( *pPcEventItem->Set,
                                                pRequest->Set ) &&
                            pPcEventItem->Id == pRequest->Id )
                        {
                            pPcEventRequest->EventItem = pPcEventItem;
                            break;
                        }
    
                        pPcEventItem = PPCEVENT_ITEM( PBYTE(pPcEventItem) + pPcAutomationTable->EventItemSize);
                    }
                }
            }
        }
        else
        {
            //
            //  NODE EVENT
            //

            // validate the node id
            if( ( pPcFilterDescriptor ) &&
                ( pPcEventRequest->Node < pPcFilterDescriptor->NodeCount ) &&
                ( pPcFilterDescriptor->Nodes[pPcEventRequest->Node].AutomationTable ) )
            {
                // search the node's automation table for the event

                const PCAUTOMATION_TABLE *pPcAutomationTable =
                    pPcFilterDescriptor->Nodes[pPcEventRequest->Node].AutomationTable;

                const PCEVENT_ITEM *pPcEventItem = pPcAutomationTable->Events;

                for(ULONG ul = pPcAutomationTable->EventCount; ul--; )
                {
                    if( IsEqualGUIDAligned( *pPcEventItem->Set,
                                            pRequest->Set ) &&
                        pPcEventItem->Id == pRequest->Id )
                    {
                        pPcEventRequest->EventItem = pPcEventItem;
                        break;
                    }

                    pPcEventItem = PPCEVENT_ITEM( PBYTE(pPcEventItem) + pPcAutomationTable->EventItemSize);
                }
            }
        }

        if(NT_SUCCESS(ntStatus))
        {
            //
            // call the handler if we have an event item with a handler
            //
            if( pPcEventRequest->EventItem &&
                pPcEventRequest->EventItem->Handler )
            {
                pPcEventRequest->Verb       = PCEVENT_VERB_SUPPORT;
                pPcEventRequest->Irp        = pIrp;
                pPcEventRequest->EventEntry = NULL;
    
                //
                // call the handler
                //
                ntStatus = pPcEventRequest->EventItem->Handler( pPcEventRequest );
            }
            else
            {
                ntStatus = STATUS_NOT_FOUND;
            }
        }

        //
        // delete the request structure unless we are pending
        //
        if( ntStatus != STATUS_PENDING )
        {
            delete pPcEventRequest;
        }
        else
        {
            //
            // only requests with IRPs can be pending
            //
            ASSERT(pIrp);
        }
    }

    return ntStatus;
}

#pragma code_seg()
/*****************************************************************************
 * EventItemRemoveHandler()
 *****************************************************************************
 *
 */
void
EventItemRemoveHandler
(
    IN  PFILE_OBJECT    pFileObject,
    IN  PKSEVENT_ENTRY  pEventEntry    
)
{
    ASSERT(pFileObject);
    ASSERT(pEventEntry);

    _DbgPrintF(DEBUGLVL_VERBOSE,("EventItemRemoveHandler"));

    PPCEVENT_ENTRY pPcEventEntry = PPCEVENT_ENTRY(pEventEntry);

    //
    // Setup event request structure
    //
    PPCEVENT_REQUEST pPcEventRequest = new(NonPagedPool,'rEcP') PCEVENT_REQUEST;

    if( pPcEventRequest )
    {
        //
        // Fill out the event request for the miniport
        //
        pPcEventRequest->MajorTarget    = pPcEventEntry->pUnknownMajorTarget;
        pPcEventRequest->MinorTarget    = pPcEventEntry->pUnknownMinorTarget;
        pPcEventRequest->Node           = pPcEventEntry->NodeId;
        pPcEventRequest->EventItem      = pPcEventEntry->EventItem;
        pPcEventRequest->Verb           = PCEVENT_VERB_REMOVE;
        pPcEventRequest->Irp            = NULL;
        pPcEventRequest->EventEntry     = pEventEntry;

        if( ( pPcEventEntry->EventItem ) &&
            ( pPcEventEntry->EventItem->Handler ) )
        {
            pPcEventEntry->EventItem->Handler( pPcEventRequest );
        }

        delete pPcEventRequest;
    }

    RemoveEntryList( &(pEventEntry->ListEntry) );
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * PcCompletePendingEventRequest()
 *****************************************************************************
 * Completes a pending event request.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcCompletePendingEventRequest
(
    IN      PPCEVENT_REQUEST    EventRequest,
    IN      NTSTATUS            NtStatus
)
{
    PAGED_CODE();

    ASSERT(EventRequest);
    ASSERT(NtStatus != STATUS_PENDING);

    if (!NT_ERROR(NtStatus))
    {
        EventRequest->Irp->IoStatus.Information = 0;
    }

    EventRequest->Irp->IoStatus.Status = NtStatus;
    IoCompleteRequest(EventRequest->Irp,IO_NO_INCREMENT);

    delete EventRequest;

    return STATUS_SUCCESS;
}

/*****************************************************************************
 * PcFreeEventTable()
 *****************************************************************************
 * Frees allocated memory in a EVENT_TABLE structure.
 */
PORTCLASSAPI
void
NTAPI
PcFreeEventTable
(
    IN      PEVENT_TABLE         EventTable
)
{
    _DbgPrintF(DEBUGLVL_VERBOSE,("PcFreeEventTable"));

    PAGED_CODE();

    ASSERT(EventTable);

    ASSERT((!EventTable->EventSets) == (!EventTable->EventSetCount));
    //  EventSets and EventSetCount must be non-NULL/non-zero, or NULL/zero

    ASSERT(EventTable->StaticSets == (!EventTable->StaticItems));
    //  StaticSets and StaticItems must be TRUE/NULL, or FALSE/non-null

    PBOOLEAN     staticItem = EventTable->StaticItems;
    if (staticItem)
    {
        PKSEVENT_SET eventSet   = EventTable->EventSets;
        if (eventSet)
        {
            for( ULONG count = EventTable->EventSetCount; 
                 count--; 
                 eventSet++, staticItem++)
            {
                if ((! *staticItem) && eventSet->EventItem)
                {
                    ExFreePool(PVOID(eventSet->EventItem));
                }
            }
        }
        ExFreePool(EventTable->StaticItems);
        EventTable->StaticItems = NULL;
    }

    if (EventTable->EventSets && !EventTable->StaticSets)
    {
        EventTable->EventSetCount = 0;
        ExFreePool(EventTable->EventSets);
        EventTable->EventSets = NULL;
    }
    EventTable->StaticSets = TRUE;
}

/*****************************************************************************
 * PcAddToEventTable()
 *****************************************************************************
 * Adds an EVENT_ITEM event table to a EVENT_TABLE structure.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcAddToEventTable
(
    IN OUT  PEVENT_TABLE            EventTable,
    IN      ULONG                   EventItemCount,
    IN      const PCEVENT_ITEM *    EventItems,
    IN      ULONG                   EventItemSize,
    IN      BOOLEAN                 NodeTable
)
{
    PAGED_CODE();

    ASSERT(EventTable);
    ASSERT(EventItems);
    ASSERT(EventItemSize >= sizeof(PCEVENT_ITEM));

    _DbgPrintF(DEBUGLVL_VERBOSE,("PcAddToEventTable"));

#define ADVANCE(item) (item = PPCEVENT_ITEM(PBYTE(item) + EventItemSize))

    ASSERT((!EventTable->EventSets) == (!EventTable->EventSetCount));
    //  values must be non-NULL/non-zero, or NULL/zero.
    
    //
    // Determine how many sets we will end up with.
    //
    ULONG setCount = EventTable->EventSetCount;
    const PCEVENT_ITEM *item = EventItems;
    for (ULONG count = EventItemCount; count--; ADVANCE(item))
    {
        BOOLEAN countThis = TRUE;

        //
        // See if it's already in the table.
        //
        PKSEVENT_SET eventSet = EventTable->EventSets;
        for 
        (   ULONG count2 = EventTable->EventSetCount; 
            count2--; 
            eventSet++
        )
        {
            if (IsEqualGUIDAligned(*item->Set,*eventSet->Set))
            {
                countThis = FALSE;
                break;
            }
        }

        if (countThis)
        {
            //
            // See if it's appeared in the list previously.
            //
            for 
            (
                const PCEVENT_ITEM *prevItem = EventItems; 
                prevItem != item; 
                ADVANCE(prevItem)
            )
            {
                if (IsEqualGUIDAligned(*item->Set,*prevItem->Set))
                {
                    countThis = FALSE;
                    break;
                }
            }
        }

        if (countThis)
        {
            setCount++;
        }
    }

    NTSTATUS ntStatus = STATUS_SUCCESS;

    //
    // Make a new set table.
    //
    ASSERT(setCount);
    ASSERT(setCount >= EventTable->EventSetCount);
    //
    // Allocate memory required for the set table.
    //
    PKSEVENT_SET newTable = 
        PKSEVENT_SET
        (
            ExAllocatePoolWithTag
            (
                NonPagedPool,
                sizeof(KSEVENT_SET) * setCount,
                'tEcP'
            )
        );

    //
    // Allocate memory for the static items flags.
    //
    PBOOLEAN newStaticItems = NULL;
    if (newTable)
    {
        newStaticItems = 
            PBOOLEAN
            (
                ExAllocatePoolWithTag
                (
                    PagedPool,
                    sizeof(BOOLEAN) * setCount,
                    'bScP'
                )
            );

        if (! newStaticItems)
        {
            ExFreePool(newTable);
            newTable = NULL;
        }
    }

    if (newTable)
    {
        //
        // Initialize the new set table.
        //
        RtlZeroMemory
        (
            PVOID(newTable),
            sizeof(KSEVENT_SET) * setCount
        );

        if (EventTable->EventSetCount != 0)
        {
            RtlCopyMemory
            (
                PVOID(newTable),
                PVOID(EventTable->EventSets),
                sizeof(KSEVENT_SET) * EventTable->EventSetCount
            );
        }

        //
        // Initialize the new static items flags.
        //
        RtlFillMemory
        (
            PVOID(newStaticItems),
            sizeof(BOOLEAN) * setCount,
            0xff
        );

        if (EventTable->StaticItems && EventTable->EventSetCount)
        {
            //
            // Flags existed before...copy them.
            //
            RtlCopyMemory
            (
                PVOID(newStaticItems),
                PVOID(EventTable->StaticItems),
                sizeof(BOOLEAN) * EventTable->EventSetCount
            );
        }

        //
        // Assign set GUIDs to the new set entries.
        //
        PKSEVENT_SET addHere = 
            newTable + EventTable->EventSetCount;

        const PCEVENT_ITEM *item2 = EventItems;
        for (ULONG count = EventItemCount; count--; ADVANCE(item2))
        {
            BOOLEAN addThis = TRUE;

            //
            // See if it's already in the table.
            //
            for( PKSEVENT_SET eventSet = newTable;
                 eventSet != addHere;
                 eventSet++)
            {
                if (IsEqualGUIDAligned(*item2->Set,*eventSet->Set))
                {
                    addThis = FALSE;
                    break;
                }
            }

            if (addThis)
            {
                addHere->Set = item2->Set;
                addHere++;
            }
        }

        ASSERT(addHere == newTable + setCount);

        //
        // Free old allocated tables.
        //
        if (EventTable->EventSets && (!EventTable->StaticSets))
        {
            ExFreePool(EventTable->EventSets);
        }
        if (EventTable->StaticItems)
        {
            ExFreePool(EventTable->StaticItems);
        }

        //
        // Install the new tables.
        //
        EventTable->EventSetCount   = setCount;
        EventTable->EventSets       = newTable;
        EventTable->StaticSets      = FALSE;
        EventTable->StaticItems     = newStaticItems;
    }
    else
    {
        //  if allocations fail, return error and 
        //  keep sets and items as they were.
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Now we have an event set table that contains all the sets we need.
    //
    if (NT_SUCCESS(ntStatus))
    {
        //
        // For each set...
        //
        PKSEVENT_SET    eventSet    = EventTable->EventSets;
        PBOOLEAN        staticItem  = EventTable->StaticItems;
        for 
        (   ULONG count = EventTable->EventSetCount; 
            count--; 
            eventSet++, staticItem++
        )
        {
            //
            // Check to see how many new items we have.
            //
            ULONG itemCount = eventSet->EventsCount;
            const PCEVENT_ITEM *item2 = EventItems;
            for (ULONG count2 = EventItemCount; count2--; ADVANCE(item2))
            {
                if (IsEqualGUIDAligned(*item2->Set,*eventSet->Set))
                {
                    itemCount++;
                }
            }

            ASSERT(itemCount >= eventSet->EventsCount);
            if (itemCount != eventSet->EventsCount)
            {
                //
                // Allocate memory required for the items table.
                //
                PKSEVENT_ITEM newTable2 = 
                    PKSEVENT_ITEM
                    (
                        ExAllocatePoolWithTag
                        (
                            NonPagedPool,
                            sizeof(KSEVENT_ITEM) * itemCount,
                            'iEcP'
                        )
                    );

                if (! newTable2)
                {
                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                    break;
                }

                //
                // Initialize the table.
                //
                RtlZeroMemory
                (
                    PVOID(newTable2),
                    sizeof(KSEVENT_ITEM) * itemCount
                );

                if (eventSet->EventsCount)
                {
                    RtlCopyMemory
                    (
                        PVOID(newTable2),
                        PVOID(eventSet->EventItem),
                        sizeof(KSEVENT_ITEM) * eventSet->EventsCount
                    );
                }

                //
                // Create the new items.
                //
                PKSEVENT_ITEM addHere = 
                    newTable2 + eventSet->EventsCount;

                item2 = EventItems;
                for (count2 = EventItemCount; count2--; ADVANCE(item2))
                {
                    if (IsEqualGUIDAligned(*item2->Set,*eventSet->Set))
                    {
                        addHere->EventId            = item2->Id;
                        addHere->DataInput          = sizeof( KSEVENTDATA );
                        addHere->ExtraEntryData     = sizeof( PCEVENT_ENTRY ) - sizeof( KSEVENT_ENTRY );
                        addHere->AddHandler         = EventItemAddHandler;
                        addHere->RemoveHandler      = EventItemRemoveHandler;
                        addHere->SupportHandler     = EventItemSupportHandler;                        
                        addHere++;
                    }
                }

                ASSERT(addHere == newTable2 + itemCount);

                //
                // Free old allocated table.
                //
                if (eventSet->EventItem && ! *staticItem)
                {
                    ExFreePool(PVOID(eventSet->EventItem));
                }

                //
                // Install the new tables.
                //
                eventSet->EventsCount = itemCount;
                eventSet->EventItem    = newTable2;
                *staticItem = FALSE;
            }
        }
    }
    return ntStatus;
}


#pragma code_seg()
/*****************************************************************************
 * PcGenerateEventList()
 *****************************************************************************
 * Walks an event list and generates desired events.
 */
PORTCLASSAPI
void
NTAPI
PcGenerateEventList
(
    IN      PINTERLOCKED_LIST   EventList,
    IN      GUID*               Set     OPTIONAL,
    IN      ULONG               EventId,
    IN      BOOL                PinEvent,
    IN      ULONG               PinId,
    IN      BOOL                NodeEvent,
    IN      ULONG               NodeId
)
{
    ASSERT(EventList);

    KIRQL           oldIrql;
    PLIST_ENTRY     ListEntry;
    PKSEVENT_ENTRY  EventEntry;

    if( EventList )
    {
        ASSERT( KeGetCurrentIrql() <= DISPATCH_LEVEL );

        // acquire the event list lock
        KeAcquireSpinLock( &(EventList->ListLock), &oldIrql );

        // only walk a non-empty list
        if( !IsListEmpty( &(EventList->List) ) )
        {
            for( ListEntry = EventList->List.Flink;
                 ListEntry != &(EventList->List);
                 ListEntry = ListEntry->Flink )
            {
                EventEntry = (PKSEVENT_ENTRY) CONTAINING_RECORD( ListEntry,
                                                                 KSEVENT_ENTRY,
                                                                 ListEntry );

                if( ( !Set
                      || 
                      IsEqualGUIDAligned( *Set, *(EventEntry->EventSet->Set) )
                    ) 
                    &&
                    ( EventId == EventEntry->EventItem->EventId
                    )
                    &&
                    ( !PinEvent
                      ||
                      ( PinId == PPCEVENT_ENTRY(EventEntry)->PinId )
                    )
                    &&
                    ( !NodeEvent
                      ||
                      ( NodeId == PPCEVENT_ENTRY(EventEntry)->NodeId )
                    )
                  )
                {
                    KsGenerateEvent( EventEntry );
                }
            }
        }

        // release the event list lock
        KeReleaseSpinLock( &(EventList->ListLock), oldIrql );
    }
}

/*****************************************************************************
 * PcGenerateEventDeferredRoutine()
 *****************************************************************************
 * This DPC routine is used when GenerateEventList is called at greater
 * that DISPATCH_LEVEL.
 */
PORTCLASSAPI
void
NTAPI
PcGenerateEventDeferredRoutine
(
    IN PKDPC Dpc,               
    IN PVOID DeferredContext,       // PEVENT_DPC_CONTEXT
    IN PVOID SystemArgument1,       // PINTERLOCKED_LIST
    IN PVOID SystemArgument2
)
{
    ASSERT(Dpc);
    ASSERT(DeferredContext);
    ASSERT(SystemArgument1);

    PEVENT_DPC_CONTEXT  Context = PEVENT_DPC_CONTEXT(DeferredContext);
    PINTERLOCKED_LIST   EventList = PINTERLOCKED_LIST(SystemArgument1);

    if( Context && EventList )
    {
        PcGenerateEventList( EventList,
                             Context->Set,
                             Context->EventId,
                             Context->PinEvent,
                             Context->PinId,
                             Context->NodeEvent,
                             Context->NodeId );

        Context->ContextInUse = FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\main\dma.cpp ===
/*****************************************************************************
 * dma.cpp - dma channel
 *****************************************************************************
 * Copyright (c) 1997-2000 Microsoft Corporation.  All rights reserved.
 */

#include "private.h"



/*****************************************************************************
 * IDmaChannelInit
 *****************************************************************************
 * Interface for dma channel with Init.
 */
DECLARE_INTERFACE_(IDmaChannelInit,IDmaChannelSlave)
{
    DEFINE_ABSTRACT_UNKNOWN()           // For IUnknown

    DEFINE_ABSTRACT_DMACHANNEL()        // For IDmaChannel

    DEFINE_ABSTRACT_DMACHANNELSLAVE()   // For IDmaChannelSlave

    STDMETHOD_(NTSTATUS,Init)
    (   THIS_
        IN      PDEVICE_DESCRIPTION DeviceDescription,
        IN      PDEVICE_OBJECT      DeviceObject
    )   PURE;
};

typedef IDmaChannelInit *PDMACHANNELINIT;

/*****************************************************************************
 * CDmaChannel
 *****************************************************************************
 * DMA channel implementation.
 */
class CDmaChannel
:   public IDmaChannelInit,
    public CUnknown
{
private:
    PDEVICE_OBJECT      m_DeviceObject;
    PDEVICE_OBJECT      m_PhysicalDeviceObject;
    BOOLEAN             m_Slave;
    BOOLEAN             m_WriteToDevice;
    BOOLEAN             m_ChannelActive;
    BOOLEAN             m_TimedOut;
    PDMA_ADAPTER        m_DmaAdapter;
    PMDL                m_Mdl;
    PVOID               m_MapRegisterBase;
    ULONG               m_MaxBufferSize;
    ULONG               m_AllocatedBufferSize;
    ULONG               m_UsedBufferSize;
    ULONG               m_MapSize;
    PVOID               m_VirtualAddress;
    PHYSICAL_ADDRESS    m_PhysicalAddress;
    PVOID               m_UserAddress;
    ULONG               m_TransferCount;
    KMUTEX              m_DMALock;

public:
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CDmaChannel);
    ~CDmaChannel();

    IMP_IDmaChannelSlave;

    STDMETHODIMP_(NTSTATUS) Init
    (
        IN      PDEVICE_DESCRIPTION DeviceDescription,
        IN      PDEVICE_OBJECT      DeviceObject
    );

    friend
    IO_ALLOCATION_ACTION
    AllocateAdapterCallback
    (
        IN      PDEVICE_OBJECT  DeviceObject,
        IN      PIRP            Irp,
        IN      PVOID           MapRegisterBase,
        IN      PVOID           Context
    );
};

/*****************************************************************************
 * Factory
 */

#pragma code_seg("PAGE")

/*****************************************************************************
 * CreateDmaChannel()
 *****************************************************************************
 * Creates a DMA channel.
 */
NTSTATUS
CreateDmaChannel
(
    OUT     PUNKNOWN *  Unknown,
    IN      REFCLSID,
    IN      PUNKNOWN    UnknownOuter    OPTIONAL,
    IN      POOL_TYPE   PoolType
)
{
    PAGED_CODE();

    ASSERT(Unknown);

    _DbgPrintF(DEBUGLVL_LIFETIME,("Creating DMA"));

    STD_CREATE_BODY_
    (
        CDmaChannel,
        Unknown,
        UnknownOuter,
        PoolType,
        PDMACHANNEL
    );
}

/*****************************************************************************
 * PcNewDmaChannel()
 *****************************************************************************
 * Creates a DMA channel.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcNewDmaChannel
(
    OUT     PDMACHANNEL *       OutDmaChannel,
    IN      PUNKNOWN            OuterUnknown        OPTIONAL,
    IN      POOL_TYPE           PoolType,
    IN      PDEVICE_DESCRIPTION DeviceDescription,
    IN      PDEVICE_OBJECT      DeviceObject        OPTIONAL
)
{
    PAGED_CODE();

    ASSERT(OutDmaChannel);
    ASSERT(DeviceDescription);

    PUNKNOWN    unknown;
    NTSTATUS    ntStatus =
        CreateDmaChannel
        (
            &unknown,
            GUID_NULL,
            OuterUnknown,
            PoolType
        );

    if (NT_SUCCESS(ntStatus))
    {
        PDMACHANNELINIT dmaChannel;
        ntStatus =
            unknown->QueryInterface
            (
                IID_IDmaChannel,
                (PVOID *) &dmaChannel
            );

        if (NT_SUCCESS(ntStatus))
        {
            ntStatus =
                dmaChannel->Init
                (
                    DeviceDescription,
                    DeviceObject
                );

            if (NT_SUCCESS(ntStatus))
            {
                *OutDmaChannel = dmaChannel;
            }
            else
            {
                dmaChannel->Release();
            }
        }

        unknown->Release();
    }

    return ntStatus;
}





/*****************************************************************************
 * Member functions
 */

#pragma code_seg()
/*****************************************************************************
 * CDmaChannel::~CDmaChannel()
 *****************************************************************************
 * Destructor.  
 * Must put in non-paged code for raising IRQL for calling put adapter.
 */
CDmaChannel::~CDmaChannel()
{
    ASSERT((KeGetCurrentIrql() < DISPATCH_LEVEL));
    KIRQL irqlOld;

    _DbgPrintF(DEBUGLVL_LIFETIME,("Destroying DMA (0x%08x)",this));

    FreeBuffer();

    if (m_DmaAdapter)
    {
        KeRaiseIrql(DISPATCH_LEVEL,&irqlOld);
        m_DmaAdapter->DmaOperations->PutDmaAdapter(m_DmaAdapter);
        KeLowerIrql(irqlOld);

        m_DmaAdapter = NULL;
    }
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CDmaChannel::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.
 */
STDMETHODIMP_(NTSTATUS)
CDmaChannel::
NonDelegatingQueryInterface
(
    REFIID  Interface,
    PVOID * Object
)
{
    PAGED_CODE();

    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface,IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(this));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IDmaChannel))
    {
        *Object = PVOID(PDMACHANNELINIT(this));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IDmaChannelSlave) && m_Slave)
    {
        *Object = PVOID(PDMACHANNELINIT(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

/*****************************************************************************
 * PcDmaSlaveDescription()
 *****************************************************************************
 * Fills in a DMA device description for a slave device based on a resource.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcDmaSlaveDescription
(
    IN      PRESOURCELIST       ResourceList,
    IN      ULONG               ResourceIndex,
    IN      BOOLEAN             DemandMode,
    IN      BOOLEAN             AutoInitialize,
    IN      DMA_SPEED           DmaSpeed,
    IN      ULONG               MaximumLength,
    IN      ULONG               DmaPort,
    OUT     PDEVICE_DESCRIPTION DeviceDescription
)
{
    PAGED_CODE();

    ASSERT(ResourceList);
    ASSERT(DeviceDescription);

    _DbgPrintF(DEBUGLVL_BLAB,("DmaSlaveDescription"));

    NTSTATUS ntStatus = STATUS_SUCCESS;

    PCM_PARTIAL_RESOURCE_DESCRIPTOR dmaDescriptor =
        ResourceList->FindTranslatedDma(ResourceIndex);

    if (! dmaDescriptor)
    {
        ntStatus = STATUS_INVALID_PARAMETER;
    }
    else
    {
        RtlZeroMemory(DeviceDescription,sizeof(DEVICE_DESCRIPTION));

        DeviceDescription->Version           = DEVICE_DESCRIPTION_VERSION;


        DeviceDescription->DmaChannel        = dmaDescriptor->u.Dma.Channel;
        DeviceDescription->DmaWidth          =
            (DeviceDescription->DmaChannel > 3) ? Width16Bits : Width8Bits;

        DeviceDescription->DemandMode        = DemandMode;
        DeviceDescription->AutoInitialize    = AutoInitialize;
        DeviceDescription->DmaSpeed          = DmaSpeed;
        DeviceDescription->MaximumLength     = MaximumLength;
        DeviceDescription->DmaPort           = DmaPort;

        // fill in default interface bus type, Init() will query PnP
        DeviceDescription->InterfaceType     = Isa;
    }

    return ntStatus;
}

/*****************************************************************************
 * PcDmaMasterDescription()
 *****************************************************************************
 * Fills in a DMA device description for a master device based on a resource
 * list.
 */
PORTCLASSAPI
void
NTAPI
PcDmaMasterDescription
(
    IN      PRESOURCELIST       ResourceList        OPTIONAL,
    IN      BOOLEAN             ScatterGather,
    IN      BOOLEAN             Dma32BitAddresses,
    IN      BOOLEAN             IgnoreCount,
    IN      BOOLEAN             Dma64BitAddresses,
    IN      DMA_WIDTH           DmaWidth,
    IN      DMA_SPEED           DmaSpeed,
    IN      ULONG               MaximumLength,
    IN      ULONG               DmaPort,
    OUT     PDEVICE_DESCRIPTION DeviceDescription
)
{
    PAGED_CODE();

    ASSERT(DeviceDescription);

    _DbgPrintF(DEBUGLVL_BLAB,("DmaMasterDescription"));

    ASSERT(DeviceDescription);

    RtlZeroMemory(DeviceDescription,sizeof(DEVICE_DESCRIPTION));

    DeviceDescription->Version           =
        IgnoreCount ? DEVICE_DESCRIPTION_VERSION1 : DEVICE_DESCRIPTION_VERSION;
    DeviceDescription->Master            = TRUE;
    DeviceDescription->ScatterGather     = ScatterGather;
    DeviceDescription->Dma32BitAddresses = Dma32BitAddresses;
    DeviceDescription->IgnoreCount       = IgnoreCount;
    DeviceDescription->Dma64BitAddresses = Dma64BitAddresses;
    DeviceDescription->DmaWidth          = DmaWidth;
    DeviceDescription->DmaSpeed          = DmaSpeed;
    DeviceDescription->MaximumLength     = MaximumLength;
    DeviceDescription->DmaPort           = DmaPort;

    // fill in default interface bus type, Init() will query PnP
    DeviceDescription->InterfaceType     = PCIBus;
}

/*****************************************************************************
 * CDmaChannel::Init()
 *****************************************************************************
 * Initializes the dma channel.
 */
STDMETHODIMP_(NTSTATUS)
CDmaChannel::
Init
(
    IN      PDEVICE_DESCRIPTION DeviceDescription,
    IN      PDEVICE_OBJECT      DeviceObject
)
{
    PAGED_CODE();

    ASSERT(DeviceDescription);
    ASSERT(DeviceObject);

    _DbgPrintF(DEBUGLVL_LIFETIME,("Initializing DMA (0x%08x)",this));

    PDEVICE_CONTEXT deviceContext =
        PDEVICE_CONTEXT(DeviceObject->DeviceExtension);

    PDEVICE_OBJECT PhysicalDeviceObject =
        deviceContext->PhysicalDeviceObject;

    m_DeviceObject = DeviceObject;
    m_PhysicalDeviceObject = PhysicalDeviceObject;
    m_Slave = !DeviceDescription->ScatterGather;
    m_ChannelActive = FALSE;

    KeInitializeMutex(&m_DMALock,0);

    // determine bus interface type
    INTERFACE_TYPE  InterfaceType;
    ULONG           BytesReturned;
    NTSTATUS ntStatus = IoGetDeviceProperty( m_PhysicalDeviceObject,
                                             DevicePropertyLegacyBusType,
                                             sizeof(INTERFACE_TYPE),
                                             &InterfaceType,
                                             &BytesReturned );
    if(NT_SUCCESS(ntStatus))
    {
        DeviceDescription->InterfaceType = InterfaceType;
    } else
    {
        // default values were already filled in by PcDmaSlaveDescription (Isa)
        // and PcDmaMasterDescription (PCIBus), so we'll just use those.
        ntStatus = STATUS_SUCCESS;
    }

    ULONG mapRegisters = DeviceDescription->MaximumLength / PAGE_SIZE + 1;
    m_DmaAdapter = IoGetDmaAdapter( PhysicalDeviceObject,
                                    DeviceDescription,
                                    &mapRegisters );

    if (! m_DmaAdapter)
    {
        ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
    }
    else
    if (! mapRegisters)
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("zero map registers"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        if (mapRegisters * PAGE_SIZE < DeviceDescription->MaximumLength)
        {
            m_MaxBufferSize = mapRegisters * PAGE_SIZE;
        }
        else
        {
            m_MaxBufferSize = DeviceDescription->MaximumLength;
        }
    }

    return ntStatus;
}

/*****************************************************************************
 * CDmaChannel::AllocateBuffer()
 *****************************************************************************
 * Allocate a buffer for this DMA channel.
 */
STDMETHODIMP_(NTSTATUS)
CDmaChannel::
AllocateBuffer
(
    IN      ULONG               BufferSize,
    IN      PPHYSICAL_ADDRESS   PhysicalAddressConstraint   OPTIONAL
)
{
    PAGED_CODE();

    if (!BufferSize)
    {
        _DbgPrintF(DEBUGLVL_TERSE,("AllocateBuffer: NULL BufferSize!"));
        return STATUS_INVALID_PARAMETER;
    }

    if (PhysicalAddressConstraint)
    {
        DebugLog((ULONG_PTR)0x02,(ULONG_PTR)BufferSize,(ULONG_PTR)PhysicalAddressConstraint->HighPart,(ULONG_PTR)PhysicalAddressConstraint->LowPart);

        if ( (BufferSize > PhysicalAddressConstraint->QuadPart + 1)
          || (PhysicalAddressConstraint->QuadPart & (PhysicalAddressConstraint->QuadPart + 1)))
        {
            ASSERT(BufferSize <= PhysicalAddressConstraint->QuadPart + 1);
            //  Physical address contraint should be power of 2 (minus 1)
            ASSERT(0 == (PhysicalAddressConstraint->QuadPart & (PhysicalAddressConstraint->QuadPart + 1)));
            return STATUS_INVALID_PARAMETER;
        }
    }
    else
    {
        DebugLog((ULONG_PTR)0x03,(ULONG_PTR)BufferSize,0,0);
    }
    DebugLog((ULONG_PTR)0x04,(ULONG_PTR)m_DmaAdapter,(ULONG_PTR)m_VirtualAddress,(ULONG_PTR)m_MaxBufferSize);

    ASSERT(! m_VirtualAddress);

    NTSTATUS ntStatus = STATUS_SUCCESS;

    if (BufferSize > m_MaxBufferSize)
    {
        ntStatus = STATUS_INVALID_PARAMETER;
    }
    else
    {
        m_UsedBufferSize = m_AllocatedBufferSize = BufferSize;

#define MAX_REJECTED 40
        ULONG               rejected = 0;
        PHYSICAL_ADDRESS    rejectedPA[MAX_REJECTED];
        PVOID               rejectedVA[MAX_REJECTED];
        ULONG               rejectedSize[MAX_REJECTED];
        ULONG               paBuffsize = BufferSize;
        ULONG               rumpAmount;
        BOOLEAN             matchingAllocation,alignmentFixup;

        matchingAllocation = TRUE;
        alignmentFixup = FALSE;

        while (! m_VirtualAddress)
        {
            PVOID virtualAddress =
                HalAllocateCommonBuffer
                (
                    m_DmaAdapter,
                    paBuffsize,
                    &m_PhysicalAddress,
                    FALSE
                );
            DebugLog((ULONG_PTR)0x11111111,(ULONG_PTR)virtualAddress,(ULONG_PTR)paBuffsize,(ULONG_PTR)m_PhysicalAddress.LowPart);


            if (! virtualAddress)
            {
                break;
            }

            if (PhysicalAddressConstraint)
            {
                PHYSICAL_ADDRESS    beginConstraint,endConstraint,endBuffer,nextConstraint;
                endBuffer.QuadPart = m_PhysicalAddress.QuadPart + paBuffsize;
                beginConstraint.QuadPart = m_PhysicalAddress.QuadPart & ~PhysicalAddressConstraint->QuadPart;
                endConstraint.QuadPart  = (m_PhysicalAddress.QuadPart + m_AllocatedBufferSize - 1)
                                        & ~PhysicalAddressConstraint->QuadPart;

                matchingAllocation = (paBuffsize == m_AllocatedBufferSize)
                                  && (beginConstraint.QuadPart == endConstraint.QuadPart);

                DebugLog((ULONG_PTR)m_PhysicalAddress.LowPart,(ULONG_PTR)endBuffer.LowPart,
                         (ULONG_PTR)beginConstraint.LowPart,  (ULONG_PTR)endConstraint.LowPart);

                nextConstraint.QuadPart = endConstraint.QuadPart + PhysicalAddressConstraint->QuadPart + 1;
                rumpAmount = (ULONG)((nextConstraint.QuadPart - endBuffer.QuadPart) & ~(PAGE_SIZE-1));
                DebugLog((ULONG_PTR)m_AllocatedBufferSize,(ULONG_PTR)rumpAmount,0,(ULONG_PTR)nextConstraint.LowPart);

                if (rumpAmount > m_AllocatedBufferSize)
                {
                    rumpAmount = m_AllocatedBufferSize;
                }
            }
            if  (matchingAllocation)
            {
                m_VirtualAddress = virtualAddress;
            }
            else
            {
                if (rejected == MAX_REJECTED)
                {
                    HalFreeCommonBuffer
                    (
                        m_DmaAdapter,
                        paBuffsize,
                        m_PhysicalAddress,
                        virtualAddress,
                        FALSE
                    );
                    DebugLog((ULONG_PTR)0x01111,(ULONG_PTR)m_VirtualAddress,(ULONG_PTR)m_PhysicalAddress.HighPart,(ULONG_PTR)m_PhysicalAddress.LowPart);
                    break;
                }

                rejectedPA[rejected] = m_PhysicalAddress;
                rejectedVA[rejected] = virtualAddress;
                rejectedSize[rejected] = paBuffsize;
                rejected++;
                alignmentFixup = (!alignmentFixup); //  get ready for next time, when we
                if (alignmentFixup)                 //  either fill the rest of this zone...
                {
                    paBuffsize = rumpAmount;
                }
                else                                //  ... or go back to being truthful
                {
                    paBuffsize = m_AllocatedBufferSize;
                }
            }
        }

        while (rejected--)
        {
            HalFreeCommonBuffer
            (
                m_DmaAdapter,
                rejectedSize[rejected],
                rejectedPA[rejected],
                rejectedVA[rejected],
                FALSE
            );
            DebugLog((ULONG_PTR)0x02222,(ULONG_PTR)rejectedVA[rejected],(ULONG_PTR)rejectedSize[rejected],(ULONG_PTR)rejectedPA[rejected].LowPart);
        }

        if (! m_VirtualAddress)
        {
            _DbgPrintF(DEBUGLVL_TERSE,("unable to allocate common buffer"));
            m_AllocatedBufferSize = 0;
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    DebugLog((ULONG_PTR)0x0b,(ULONG_PTR)ntStatus,(ULONG_PTR)m_PhysicalAddress.HighPart,(ULONG_PTR)m_PhysicalAddress.LowPart);
    DebugLog((ULONG_PTR)0x0c,(ULONG_PTR)m_VirtualAddress,(ULONG_PTR)m_DmaAdapter,(ULONG_PTR)m_AllocatedBufferSize);
    return ntStatus;
}

/*****************************************************************************
 * CDmaChannel::FreeBuffer()
 *****************************************************************************
 * Free the buffer for this DMA channel.
 */
STDMETHODIMP_(void)
CDmaChannel::
FreeBuffer
(   void
)
{
    PAGED_CODE();

    if (m_VirtualAddress)
    {
        if (m_Mdl)
        {
            IoFreeMdl(m_Mdl);
            m_Mdl = NULL;
        }

        HalFreeCommonBuffer
        (
            m_DmaAdapter,
            m_AllocatedBufferSize,
            m_PhysicalAddress,
            m_VirtualAddress,
            FALSE
        );
        DebugLog((ULONG_PTR)0x03333,(ULONG_PTR)m_VirtualAddress,(ULONG_PTR)m_PhysicalAddress.HighPart,(ULONG_PTR)m_PhysicalAddress.LowPart);

        m_VirtualAddress = NULL;
        m_PhysicalAddress.HighPart = 0;
        m_PhysicalAddress.LowPart = 0;
    }
}

#pragma code_seg()
/*****************************************************************************
 * AllocateAdapterCallback()
 *****************************************************************************
 * Fixed by MartinP 1/29/00 on suggestions from ForrestF.  
 * Removed spinlock and event.
 *
 */
static
IO_ALLOCATION_ACTION
AllocateAdapterCallback
(
    IN      PDEVICE_OBJECT  DeviceObject,
    IN      PIRP            Irp     OPTIONAL,
    IN      PVOID           MapRegisterBase,
    IN      PVOID           Context
)
{
    ASSERT(DeviceObject);
    ASSERT(MapRegisterBase);
    ASSERT(Context);

    CDmaChannel *that = (CDmaChannel *)Context;

    if( FALSE == that->m_TimedOut )
    {
        ULONG MapLength = that->m_MapSize;

        that->m_MapRegisterBase = MapRegisterBase;
                
        IoMapTransfer( that->m_DmaAdapter,
                       that->m_Mdl,
                       that->m_MapRegisterBase,
                       MmGetMdlVirtualAddress(that->m_Mdl),
                       &MapLength,
                       that->m_WriteToDevice );

        if (that->m_MapSize == MapLength)
        {
            that->m_ChannelActive = TRUE;
        } 
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE,("***** MapSize Requested (0x%x) != MapLength (0x%x)",that->m_MapSize,MapLength));
            that->m_TransferCount = 0;
        }
    }
    return KeepObject;
}

/*****************************************************************************
 * CDmaChannel::Start()
 *****************************************************************************
 * Fixed by MartinP 1/29/00 on suggestions from ForrestF.  Removed spinlock
 * and event, replaced by single mutex.  Must be in non-pageable code, since
 * IRQL is raised to DISPATCH_LEVEL.
 *
 */
STDMETHODIMP_(NTSTATUS)
CDmaChannel::
Start
(
    IN      ULONG       MapSize,
    IN      BOOLEAN     WriteToDevice
)
{
    ASSERT((KeGetCurrentIrql() < DISPATCH_LEVEL));
    ASSERT(MapSize <= m_AllocatedBufferSize);

    NTSTATUS ntStatus = STATUS_SUCCESS;

    // don't try to start a channel that is already started
    if( TRUE == m_ChannelActive )
    {
        ASSERT(!"Nested DMA Starts");
        return STATUS_UNSUCCESSFUL;
    }

    if (! m_Mdl)
    {
        if (m_VirtualAddress)
        {
            m_Mdl =
                IoAllocateMdl
                (
                    m_VirtualAddress,
                    m_MaxBufferSize,
                    FALSE,
                    FALSE,
                    NULL
                );

            if (m_Mdl)
            {
                MmBuildMdlForNonPagedPool(m_Mdl);
            }
            else
            {
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                _DbgPrintF(DEBUGLVL_TERSE, ("CDmaChannel::Start, IoAllocateMdl() == NULL"));
            }
        }
        else
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            _DbgPrintF(DEBUGLVL_TERSE, ("CDmaChannel::Start, m_VirtualAddress == NULL"));
        }
    }

    if (NT_SUCCESS(ntStatus))
    {
        m_WriteToDevice = WriteToDevice;
        m_MapSize = MapSize;

#if DBG
        if (m_TransferCount)
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("m_TransferCount == 0x%x in CDmaChannel::Start()",m_TransferCount));
        }
#endif

        m_TransferCount = MapSize;
        m_TimedOut = FALSE;

        //
        // Allocate an adapter channel.  When the system is ready,
        // we'll process in the callback and then continue after
        // the event is signalled.
        //
        // grab the global DMA lock that serializes IoAllocateAdapterChannel calls
        // setup for 10 second timeout (PASSIVE_LEVEL only!!)
        LARGE_INTEGER Timeout = RtlConvertLongToLargeInteger( -10L * 10000000L );

        ntStatus = KeWaitForMutexObject(    &m_DMALock,
                                            Executive,
                                            KernelMode,
                                            FALSE,
                                            &Timeout);

        if (STATUS_SUCCESS == ntStatus) //  STATUS_TIMEOUT is a success code
        {
            _DbgPrintF(DEBUGLVL_VERBOSE, ("allocating adapter channel"));

            //
            // IoAllocateAdapterChannel must be called at DISPATCH_LEVEL
            //
            KIRQL irqlOld;
            KeRaiseIrql(DISPATCH_LEVEL,&irqlOld);

            ntStatus = IoAllocateAdapterChannel( m_DmaAdapter,
                                                 m_DeviceObject,
                                                 BYTES_TO_PAGES(m_AllocatedBufferSize),
                                                 AllocateAdapterCallback,
                                                 PVOID(this) );
            KeLowerIrql(irqlOld);

            //  OK to continue on our merry way
            KeReleaseMutex(&m_DMALock,FALSE);

            if (!NT_SUCCESS(ntStatus))
            {
                _DbgPrintF(DEBUGLVL_TERSE,("Cannot allocate DMA adapter channel"));
                m_TransferCount = 0;
            }
        }
        else
        {
            ASSERT(ntStatus == STATUS_TIMEOUT);
            ntStatus = STATUS_UNSUCCESSFUL;
            _DbgPrintF(DEBUGLVL_VERBOSE, ("DMA lock timeout, can't allocate DMA channel"));
        }
    }

    return ntStatus;
}

/*****************************************************************************
 * CDmaChannel::Stop()
 *****************************************************************************
 * TODO
 */
STDMETHODIMP_(NTSTATUS)
CDmaChannel::
Stop
(   void
)
{
    ASSERT((KeGetCurrentIrql() <= DISPATCH_LEVEL));

    if (InterlockedExchange(PLONG(&m_TransferCount),0))
    {
        (void) IoFlushAdapterBuffers
        (
            m_DmaAdapter,
            m_Mdl,
            m_MapRegisterBase,
            m_VirtualAddress,
            m_AllocatedBufferSize,
            m_WriteToDevice
        );

        KIRQL irqlOld;
        KeRaiseIrql(DISPATCH_LEVEL,&irqlOld);
        IoFreeAdapterChannel(m_DmaAdapter);
        m_ChannelActive = FALSE;
        KeLowerIrql(irqlOld);
    }

    return STATUS_SUCCESS;
}

/*****************************************************************************
 * CDmaChannel::ReadCounter()
 *****************************************************************************
 * TODO
 */
STDMETHODIMP_(ULONG)
CDmaChannel::
ReadCounter
(   void
)
{
    ULONG ulResult = HalReadDmaCounter(m_DmaAdapter);

    if ( !m_ChannelActive )
    {
        ulResult = 0;
    } 
    else
    {
        if (ulResult == m_TransferCount)
        {
            ulResult = 0;
        }
        else if (ulResult > m_TransferCount)
        {
            _DbgPrintF(DEBUGLVL_TERSE,("HalReadDmaCounter returned value out of range (0x%x >= 0x%x)",ulResult,m_TransferCount));
            ulResult = 0;
        }
    }

    return ulResult;
}

/*****************************************************************************
 * CDmaChannel::TransferCount()
 *****************************************************************************
 * Return the amount of data to be transfered via DMA.
 */
STDMETHODIMP_(ULONG)
CDmaChannel::
TransferCount
(   void
)
{
    return m_TransferCount;
}

/*****************************************************************************
 * CDmaChannel::MaximumBufferSize()
 *****************************************************************************
 * Return the maximum size that can be allocated to this DMA buffer.
 */
STDMETHODIMP_(ULONG)
CDmaChannel::
MaximumBufferSize
(   void
)
{
    return m_MaxBufferSize;
}

/*****************************************************************************
 * CDmaChannel::AllocatedBufferSize()
 *****************************************************************************
 * Return the original size allocated to this DMA buffer -- the maximum value
 * that can be sent to SetBufferSize().
 */
STDMETHODIMP_(ULONG)
CDmaChannel::
AllocatedBufferSize
(   void
)
{
    return m_AllocatedBufferSize;
}

/*****************************************************************************
 * CDmaChannel::BufferSize()
 *****************************************************************************
 * Return the current size of the DMA buffer.
 */
STDMETHODIMP_(ULONG)
CDmaChannel::
BufferSize
(   void
)
{
    return m_UsedBufferSize;
}

/*****************************************************************************
 * CDmaChannel::SetBufferSize()
 *****************************************************************************
 * Change the size of the DMA buffer.  This cannot exceed the initial 
 * buffer size returned by AllocatedBufferSize().
 */
STDMETHODIMP_(void)
CDmaChannel::
SetBufferSize
(
    IN      ULONG   BufferSize
)
{
    ASSERT(BufferSize <= m_AllocatedBufferSize);

    m_UsedBufferSize = BufferSize;
}

/*****************************************************************************
 * CDmaChannel::SystemAddress()
 *****************************************************************************
 * Return the virtual address of this DMA buffer.
 */
STDMETHODIMP_(PVOID)
CDmaChannel::
SystemAddress
(   void
)
{
    return m_VirtualAddress;
}

/*****************************************************************************
 * CDmaChannel::PhysicalAddress()
 *****************************************************************************
 * Return the actual physical address of this DMA buffer.
 */
STDMETHODIMP_(PHYSICAL_ADDRESS)
CDmaChannel::
PhysicalAddress
(   void
)
{
    ASSERT(m_VirtualAddress);
    return m_PhysicalAddress;
}

/*****************************************************************************
 * CDmaChannel::GetAdapterObject()
 *****************************************************************************
 * Return the DMA adapter object (defined in wdm.h).
 */
STDMETHODIMP_(PADAPTER_OBJECT)
CDmaChannel::
GetAdapterObject
(   void
)
{
    return m_DmaAdapter;
}

STDMETHODIMP_(NTSTATUS)
CDmaChannel::WaitForTC(
    ULONG Timeout
    )
/*++

Routine Description:
    Waits for the DMA transfer to complete, else times out.

Arguments:
    Timeout - Specifies the timeout in microseconds to wait for the
        transfer to complete. This is rounded down to the nearest 10
        microsecond increment.
Return:
    STATUS_SUCCESS if the transfer completed, else an error code.

--*/

{
    ULONG    Count;

    if (Count = HalReadDmaCounter(m_DmaAdapter))
    {
        ULONG LastCount = Count;

        Timeout /= 10;

        while ((LastCount !=
                (Count = HalReadDmaCounter( m_DmaAdapter ))) && Timeout) 
        {
            LastCount = Count;
            KeStallExecutionProcessor( 10 );
            Timeout--;
        }
        return (Timeout > 0) ? STATUS_SUCCESS : STATUS_IO_TIMEOUT;
    }
    else
    {
        return STATUS_SUCCESS;
    }
}

/*****************************************************************************
 * CDmaChannel::CopyTo()
 *****************************************************************************
 * Copy data into the DMA buffer.  This can be overridden if a client needs
 * to massage the data on output.
 */
STDMETHODIMP_(void)
CDmaChannel::
CopyTo
(   IN      PVOID   Destination,
    IN      PVOID   Source,
    IN      ULONG   ByteCount
)
{
#ifndef _X86_
    RtlCopyMemory(Destination,Source,ByteCount);
#else
    //
    // Jeff says this is the way to go.
    //
    _asm {
        mov esi, Source
        mov ecx, ByteCount

        mov edi, Destination

		add edi, ecx
		neg ecx

		sub edi, 16
		jmp Next16

Loop16:
		mov eax, DWORD PTR [esi]
		mov ebx, DWORD PTR [esi+4]

		mov DWORD PTR [edi+ecx], eax
		mov DWORD PTR [edi+ecx+4], ebx
		
		mov eax, DWORD PTR [esi+8]
		mov ebx, DWORD PTR [esi+12]

		mov DWORD PTR [edi+ecx+8], eax
		mov DWORD PTR [edi+ecx+12], ebx

		add esi, 16
		
Next16:
		add ecx, 16
		jle Loop16

		sub ecx, 16
		jmp Next4

Loop4:
		mov eax, DWORD PTR [esi]
		add esi, 4

		mov DWORD PTR [edi+ecx+12], eax
		
Next4:
		add ecx, 4
		jle Loop4

		sub ecx, 4
		jz Done1

Final1:
		mov al, BYTE PTR [esi]
		inc esi

		mov BYTE PTR [edi+ecx+16], al
		inc ecx

		jnz Final1
Done1:
    }
#endif
}

/*****************************************************************************
 * CDmaChannel::CopyFrom()
 *****************************************************************************
 * Copy data out of the DMA buffer.  This can be overridden if a client needs
 * to massage the data on input.
 */
STDMETHODIMP_(void)
CDmaChannel::
CopyFrom
(   IN      PVOID   Destination,
    IN      PVOID   Source,
    IN      ULONG   ByteCount
)
{
    CopyTo(Destination,Source,ByteCount);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\main\minihelp.cpp ===
/*****************************************************************************
 * minihelp.c - services provided by the port class driver to miniports
 *****************************************************************************
 * Copyright (c) 1996-2000 Microsoft Corporation.  All rights reserved.
 *
 * 11/8/96 Dale Sather
 *
 */

#define _NO_SYS_GUID_OPERATOR_EQ_        // So operator == / != in guiddef.h isn't included
#include "private.h"
#include <kcom.h>

#ifdef DRM_PORTCLS
#include <drmk.h>
#endif  // DRM_PORTCLS


NTSTATUS
GetClassInfo
(
    IN      REFCLSID            ClassId,
    OUT     PFNCREATEINSTANCE * Create
);

#pragma code_seg("PAGE")

/*****************************************************************************
 * PcNewPort()
 *****************************************************************************
 * Creates an instance of a port driver.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcNewPort
(
    OUT     PPORT *     OutPort,
    IN      REFCLSID    ClassId
)
{
    PAGED_CODE();

    ASSERT(OutPort);

    //
    // Validate Parameters.
    //
    if (NULL == OutPort)
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("PcNewPort : Invalid Parameter."));
        return STATUS_INVALID_PARAMETER;
    }

    PUNKNOWN            unknown;
    PFNCREATEINSTANCE   create;

    NTSTATUS ntStatus =
        GetClassInfo
        (
            ClassId,
            &create
        );

    if (NT_SUCCESS(ntStatus))
    {
        ntStatus =
            create
            (
                &unknown,
                ClassId,
                NULL,
                NonPagedPool
            );

        if (NT_SUCCESS(ntStatus))
        {
            ntStatus = unknown->QueryInterface(IID_IPort,(PVOID *) OutPort);

            unknown->Release();
        }
    }
    else
    {
        ntStatus =
            KoCreateInstance
            (
                ClassId,
                NULL,
                CLSCTX_KERNEL_SERVER,
                IID_IPort,
                (PVOID *) OutPort
            );
    }

    return ntStatus;
}

/*****************************************************************************
 * PcNewMiniport()
 *****************************************************************************
 * Creates an instance of a miniport driver.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcNewMiniport
(
    OUT     PMINIPORT * OutMiniport,
    IN      REFCLSID    ClassId
)
{
    PAGED_CODE();

    ASSERT(OutMiniport);

    //
    // Validate Parameters.
    //
    if (NULL == OutMiniport)
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("PcNewMiniport : Invalid Parameter."));
        return STATUS_INVALID_PARAMETER;
    }

    PUNKNOWN            unknown;
    PFNCREATEINSTANCE   create;

    NTSTATUS ntStatus =
        GetClassInfo
        (
            ClassId,
            &create
        );

    if (NT_SUCCESS(ntStatus))
    {
        ntStatus =
            create
            (
                &unknown,
                ClassId,
                NULL,
                NonPagedPool
            );

        if (NT_SUCCESS(ntStatus))
        {
            ntStatus =
                unknown->QueryInterface
                (
                    IID_IMiniport,
                    (PVOID *) OutMiniport
                );

            unknown->Release();
        }
    }
    else
    {
        ntStatus =
            KoCreateInstance
            (
                ClassId,
                NULL,
                CLSCTX_KERNEL_SERVER,
                IID_IMiniport,
                (PVOID *) OutMiniport
            );
    }

    return ntStatus;
}

#pragma code_seg()

/*****************************************************************************
 * PcGetTimeInterval
 *****************************************************************************
 * Gets the system time interval
 */
PORTCLASSAPI
ULONGLONG
NTAPI
PcGetTimeInterval
(
    IN  ULONGLONG   Since
)
{
    LARGE_INTEGER deltaTime;
    KeQuerySystemTime(&deltaTime);
    return deltaTime.QuadPart - Since;
}


#pragma code_seg("PAGE")

#ifdef DRM_PORTCLS

PORTCLASSAPI
NTSTATUS
NTAPI
PcAddContentHandlers(IN ULONG ContentId,IN PVOID* paHandlers,IN ULONG NumHandlers)
{
    PAGED_CODE();
    return DrmAddContentHandlers(ContentId,paHandlers,NumHandlers);
}

PORTCLASSAPI
NTSTATUS
NTAPI
PcCreateContentMixed(IN  PULONG paContentId,IN ULONG cContentId,OUT PULONG pMixedContentId)
{
    PAGED_CODE();
    return DrmCreateContentMixed(paContentId,cContentId,pMixedContentId);
}

PORTCLASSAPI
NTSTATUS
NTAPI
PcDestroyContent(IN ULONG ContentId)
{
    PAGED_CODE();
    return DrmDestroyContent(ContentId);
}

PORTCLASSAPI
NTSTATUS
NTAPI
PcForwardContentToDeviceObject(IN ULONG ContentId,IN PVOID Reserved,IN PCDRMFORWARD DrmForward)
{
    PAGED_CODE();
    return DrmForwardContentToDeviceObject(ContentId,Reserved,DrmForward);
}

PORTCLASSAPI
NTSTATUS
NTAPI
PcForwardContentToFileObject(IN ULONG ContentId,IN PFILE_OBJECT FileObject)
{
    PAGED_CODE();
    return DrmForwardContentToFileObject(ContentId,FileObject);
}

PORTCLASSAPI 
NTSTATUS 
NTAPI
PcForwardContentToInterface(IN ULONG    ContentId,
                            IN PUNKNOWN pUnknown,
                            IN ULONG    NumMethods)
{
    PAGED_CODE();
    return DrmForwardContentToInterface(ContentId,pUnknown,NumMethods);
}

PORTCLASSAPI
NTSTATUS
NTAPI
PcGetContentRights(IN ULONG ContentId,OUT PDRMRIGHTS DrmRights)
{
    PAGED_CODE();
    return DrmGetContentRights(ContentId,DrmRights);
}


#else   // DRM_PORTCLS

PORTCLASSAPI
NTSTATUS
NTAPI
PcAddContentHandlers(IN ULONG ContentId,IN PVOID* paHandlers,IN ULONG NumHandlers)
{
    PAGED_CODE();
    return STATUS_UNSUCCESSFUL;
}

PORTCLASSAPI
NTSTATUS
NTAPI
PcCreateContentMixed(IN  PULONG paContentId,
                     IN  ULONG  cContentId,
                     OUT PULONG pMixedContentId)
{
    PAGED_CODE();
    return STATUS_UNSUCCESSFUL;
}

PORTCLASSAPI
NTSTATUS
NTAPI
PcDestroyContent(IN ULONG ContentId)
{
    PAGED_CODE();
    return STATUS_UNSUCCESSFUL;
}

PORTCLASSAPI
NTSTATUS
NTAPI
PcForwardContentToDeviceObject(IN ULONG ContentId,IN PDEVICE_OBJECT DeviceObject,IN PVOID Context)
{
    PAGED_CODE();
    return STATUS_UNSUCCESSFUL;
}

PORTCLASSAPI
NTSTATUS
NTAPI
PcForwardContentToFileObject(IN ULONG ContentId,IN PFILE_OBJECT FileObject)
{
    PAGED_CODE();
    return STATUS_UNSUCCESSFUL;
}

PORTCLASSAPI 
NTSTATUS 
NTAPI
PcForwardContentToInterface(IN ULONG    ContentId,
                            IN PUNKNOWN pUnknown,
                            IN ULONG    NumMethods)
{
    PAGED_CODE();
    return STATUS_UNSUCCESSFUL;
}

PORTCLASSAPI
NTSTATUS
NTAPI
PcGetContentRights(IN ULONG ContentId,OUT PDRMRIGHTS DrmRights)
{
    PAGED_CODE();
    return STATUS_UNSUCCESSFUL;
}

#endif  // DRM_PORTCLS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\main\kso.cpp ===
/*****************************************************************************
 * kso.cpp - KS object support (IrpTargets)
 *****************************************************************************
 * Copyright (c) 1997-2000 Microsoft Corporation.  All rights reserved.
 */

#include "private.h"
#include <swenum.h>


/*****************************************************************************
 * OBJECT_CONTEXT
 *****************************************************************************
 * Context structure for all file objects.
 */
typedef struct
{
    PVOID               pObjectHeader;
    PIRPTARGET          pIrpTarget;
    BOOLEAN             ReferenceParent;
}
OBJECT_CONTEXT, *POBJECT_CONTEXT;

DEFINE_KSDISPATCH_TABLE(
                       KsoDispatchTable,
                       DispatchDeviceIoControl,
                       DispatchRead,
                       DispatchWrite,
                       DispatchFlush,
                       DispatchClose,
                       DispatchQuerySecurity,
                       DispatchSetSecurity,
                       DispatchFastDeviceIoControl,
                       DispatchFastRead,
                       DispatchFastWrite );


#define CAST_LVALUE(type,lvalue) (*((type*)&(lvalue)))
#define IRPTARGET_FACTORY_IRP_STORAGE(Irp)       \
    CAST_LVALUE(PIRPTARGETFACTORY,IoGetCurrentIrpStackLocation(Irp)->    \
                Parameters.Others.Argument4)

#pragma code_seg("PAGE")

/*****************************************************************************
 * AddIrpTargetFactoryToDevice()
 *****************************************************************************
 * Adds an IrpTargetFactory to a device's create items list.
 */
NTSTATUS
    NTAPI
    AddIrpTargetFactoryToDevice
    (
    IN      PDEVICE_OBJECT          pDeviceObject,
    IN      PIRPTARGETFACTORY       pIrpTargetFactory,
    IN      PWCHAR                  pwcObjectClass,
    IN      PSECURITY_DESCRIPTOR    pSecurityDescriptor OPTIONAL
    )
{
    PAGED_CODE();

    ASSERT(pDeviceObject);
    ASSERT(pIrpTargetFactory);
    ASSERT(pwcObjectClass);

    PDEVICE_CONTEXT pDeviceContext  =
        PDEVICE_CONTEXT(pDeviceObject->DeviceExtension);

    NTSTATUS ntStatus =
        KsAddObjectCreateItemToDeviceHeader
        (
        pDeviceContext->pDeviceHeader,
        KsoDispatchCreate,
        pIrpTargetFactory,
        pwcObjectClass,
        pSecurityDescriptor
        );

    if (NT_SUCCESS(ntStatus))
    {
        pIrpTargetFactory->AddRef();
    }

    return ntStatus;
}

/*****************************************************************************
 * AddIrpTargetFactoryToObject()
 *****************************************************************************
 * Adds an IrpTargetFactory to a objects's create items list.
 */
NTSTATUS
    NTAPI
    AddIrpTargetFactoryToObject
    (
    IN      PFILE_OBJECT            pFileObject,
    IN      PIRPTARGETFACTORY       pIrpTargetFactory,
    IN      PWCHAR                  pwcObjectClass,
    IN      PSECURITY_DESCRIPTOR    pSecurityDescriptor
    )
{
    PAGED_CODE();

    ASSERT(pFileObject);
    ASSERT(pIrpTargetFactory);
    ASSERT(pwcObjectClass);

    POBJECT_CONTEXT pObjectContext  =
        POBJECT_CONTEXT(pFileObject->FsContext);

    NTSTATUS ntStatus =
        KsAddObjectCreateItemToObjectHeader
        (
        pObjectContext->pObjectHeader,
        KsoDispatchCreate,
        pIrpTargetFactory,
        pwcObjectClass,
        pSecurityDescriptor
        );

    if (NT_SUCCESS(ntStatus))
    {
        pIrpTargetFactory->AddRef();
    }

    return ntStatus;
}

#pragma code_seg()

/*****************************************************************************
 * KsoGetIrpTargetFromIrp()
 *****************************************************************************
 * Extracts the IrpTarget pointer from an IRP.
 */
PIRPTARGET
    NTAPI
    KsoGetIrpTargetFromIrp
    (
    IN  PIRP    Irp
    )
{
    ASSERT(Irp);

    return
        (
        POBJECT_CONTEXT
        (
        IoGetCurrentIrpStackLocation(Irp)
        ->  FileObject
        ->  FsContext
        )
        ->  pIrpTarget
        );
}

/*****************************************************************************
 * KsoGetIrpTargetFromFileObject()
 *****************************************************************************
 * Extracts the IrpTarget pointer from a FileObject pointer.
 */
PIRPTARGET
    NTAPI
    KsoGetIrpTargetFromFileObject(
                                 IN PFILE_OBJECT FileObject
                                 )
{
    ASSERT(FileObject);

    return POBJECT_CONTEXT( FileObject->FsContext )->pIrpTarget;
}


#pragma code_seg("PAGE")

IRPDISP
GetIrpDisposition(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  UCHAR           MinorFunction
    )
{
    PDEVICE_CONTEXT pDeviceContext =
        PDEVICE_CONTEXT(DeviceObject->DeviceExtension);

    //
    // If we're removed, or not accepting any calls, fail this.
    //
    if ((pDeviceContext->DeviceRemoveState == DeviceRemoved) ||
        (pDeviceContext->DeviceStopState == DeviceStopped)) {

        return IRPDISP_NOTREADY;
    }

    //
    // Similarly, ignore anything but closes if we were surprise removed.
    //
    if ((MinorFunction != IRP_MJ_CLOSE) &&
        (pDeviceContext->DeviceRemoveState == DeviceSurpriseRemoved)) {

        return IRPDISP_NOTREADY;
    }

    if ((MinorFunction == IRP_MJ_CREATE) && (pDeviceContext->PendCreates)) {

        return IRPDISP_QUEUE;
    }

    if ( (pDeviceContext->DeviceStopState == DevicePausedForRebalance) ||
         (pDeviceContext->DeviceStopState == DeviceStartPending) ||
         (!NT_SUCCESS(CheckCurrentPowerState(DeviceObject)))) {

        return IRPDISP_QUEUE;

    } else {

        return IRPDISP_PROCESS;
    }
}

/*****************************************************************************
 * DispatchCreate()
 *****************************************************************************
 * Handles a create IRP.
 */
NTSTATUS
    DispatchCreate
    (
    IN      PDEVICE_OBJECT      pDeviceObject,
    IN      PIRP                pIrp
    )
{
    PAGED_CODE();

    ASSERT(pDeviceObject);
    ASSERT(pIrp);

    PDEVICE_CONTEXT pDeviceContext = PDEVICE_CONTEXT(pDeviceObject->DeviceExtension);

    ASSERT(pDeviceContext);

    NTSTATUS ntStatus = STATUS_SUCCESS;
    IRPDISP  irpDisp;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("DispatchCreate"));

    IncrementPendingIrpCount(pDeviceContext);
    AcquireDevice(pDeviceContext);

    // check the device state
    irpDisp = GetIrpDisposition(pDeviceObject, IRP_MJ_CREATE);

    switch(irpDisp) {

        default:
            ASSERT(0);

            //
            // Fall through
            //

        case IRPDISP_NOTREADY:

            ntStatus = STATUS_DEVICE_NOT_READY;
            pIrp->IoStatus.Information = 0;
            CompleteIrp(pDeviceContext,pIrp,ntStatus);
            break;

        case IRPDISP_QUEUE:

            // pend the irp
            IoMarkIrpPending( pIrp );

            // add the IRP to the pended IRP queue
            KsAddIrpToCancelableQueue( &pDeviceContext->PendedIrpList,
                                       &pDeviceContext->PendedIrpLock,
                                       pIrp,
                                       KsListEntryTail,
                                       NULL );

            ntStatus = STATUS_PENDING;
            break;

        case IRPDISP_PROCESS:

            // dispatch the irp
            ntStatus = KsDispatchIrp(pDeviceObject,pIrp);
            break;
    }

    ReleaseDevice(pDeviceContext);

    return ntStatus;
}

/*****************************************************************************
 * xDispatchCreate()
 *****************************************************************************
 * Handles a create IRP.
 */
NTSTATUS
    xDispatchCreate
    (
    IN      PIRPTARGETFACTORY   pIrpTargetFactory,
    IN      PDEVICE_OBJECT      pDeviceObject,
    IN      PIRP                pIrp
    )
{
    PAGED_CODE();

    ASSERT(pIrpTargetFactory);
    ASSERT(pDeviceObject);
    ASSERT(pIrp);
    
    PDEVICE_CONTEXT pDeviceContext = PDEVICE_CONTEXT(pDeviceObject->DeviceExtension);

    ASSERT(pDeviceContext);

    NTSTATUS ntStatus = STATUS_SUCCESS;

    POBJECT_CONTEXT pObjectContext=NULL;
    BOOL bCreatedIrpTarget=FALSE;
    BOOL bReferencedBusObject=FALSE;
    KSOBJECT_CREATE ksObjectCreate;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("xDispatchCreate"));

        // If there no target, fail the IRP
        if (! pIrpTargetFactory )
        {
            ntStatus = STATUS_INVALID_DEVICE_REQUEST;
        }

    if (NT_SUCCESS(ntStatus))
    {
        // Allocate our context structure.
        pObjectContext = POBJECT_CONTEXT(ExAllocatePoolWithTag(NonPagedPool,sizeof(OBJECT_CONTEXT),'OosK'));
        if (!pObjectContext)
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (NT_SUCCESS(ntStatus))
    {
        ntStatus = KsReferenceSoftwareBusObject(pDeviceContext->pDeviceHeader);
        if (NT_SUCCESS(ntStatus))
        {
            bReferencedBusObject = TRUE;
        }
        else if (STATUS_NOT_IMPLEMENTED == ntStatus)
        {
            ntStatus = STATUS_SUCCESS;
        }
    }

    if (NT_SUCCESS(ntStatus))
    {
        // Tell the factory to create a new object.
        ksObjectCreate.CreateItemsCount = 0;
        ksObjectCreate.CreateItemsList = NULL;

        ntStatus = pIrpTargetFactory->NewIrpTarget(&pObjectContext->pIrpTarget,
                                                   &pObjectContext->ReferenceParent,
                                                   NULL,
                                                   NonPagedPool,
                                                   pDeviceObject,
                                                   pIrp,
                                                   &ksObjectCreate);

        // NewIrpTarget should not pend
        ASSERT(ntStatus != STATUS_PENDING);
    }

    if (NT_SUCCESS(ntStatus))
    {
        bCreatedIrpTarget=TRUE;

        // Allocate KS's header for this object.
        ntStatus = KsAllocateObjectHeader(&pObjectContext->pObjectHeader,
                                          ksObjectCreate.CreateItemsCount,
                                          ksObjectCreate.CreateItemsList,
                                          pIrp,
                                          &KsoDispatchTable);
    }

    PIO_STACK_LOCATION pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    if (NT_SUCCESS(ntStatus))
    {
        // Hook up the context to the file object.
        ASSERT(pObjectContext);
        pIrpSp->FileObject->FsContext = pObjectContext;

        // AddRef the parent file object if this is a child.
        if (pObjectContext->ReferenceParent && pIrpSp->FileObject->RelatedFileObject)
        {
            ObReferenceObject(pIrpSp->FileObject->RelatedFileObject);
        }

        InterlockedIncrement(PLONG(&pDeviceContext->ExistingObjectCount));
        _DbgPrintF(DEBUGLVL_VERBOSE,("xDispatchCreate  objects: %d",pDeviceContext->ExistingObjectCount));

        ASSERT(pIrpSp->FileObject->FsContext);
    }
    else
    {
        if (bCreatedIrpTarget)
        {
            pObjectContext->pIrpTarget->Release();
        }
        if (pObjectContext)
        {
            ExFreePool(pObjectContext);
        }
        pIrpSp->FileObject->FsContext = NULL;
        if (bReferencedBusObject)
        {
            KsDereferenceSoftwareBusObject(pDeviceContext->pDeviceHeader);
        }
    }
    ASSERT(ntStatus != STATUS_PENDING);

    pIrp->IoStatus.Information = 0;
    CompleteIrp(pDeviceContext,pIrp,ntStatus);
    return ntStatus;
}

/*****************************************************************************
 * CompletePendedIrps
 *****************************************************************************
 * This pulls pended irps off the queue and either fails them or passes them
 * back to KsoDispatchIrp.
 */
void
    CompletePendedIrps
    (
    IN      PDEVICE_OBJECT      pDeviceObject,
    IN      PDEVICE_CONTEXT     pDeviceContext,
    IN      COMPLETE_STYLE      CompleteStyle
    )
{
    ASSERT(pDeviceObject);
    ASSERT(pDeviceContext);

    _DbgPrintF(DEBUGLVL_VERBOSE,("Completing pended create IRPs..."));

    PIRP pIrp = KsRemoveIrpFromCancelableQueue( &pDeviceContext->PendedIrpList,
                                                &pDeviceContext->PendedIrpLock,
                                                KsListEntryHead,
                                                KsAcquireAndRemove );
    while ( pIrp )
    {
        if ( CompleteStyle == EMPTY_QUEUE_AND_FAIL )
        {
            // fail the IRP with STATUS_DEVICE_NOT_READY
            CompleteIrp( pDeviceContext,
                         pIrp,
                         STATUS_DEVICE_NOT_READY );
        }
        else
        {
            // pass the IRP back to the dispatchers
            KsoDispatchIrp( pDeviceObject,
                            pIrp );
        }

        // clean up the pending irp count
        DecrementPendingIrpCount( pDeviceContext );

        // get the next irp
        pIrp = KsRemoveIrpFromCancelableQueue( &pDeviceContext->PendedIrpList,
                                               &pDeviceContext->PendedIrpLock,
                                               KsListEntryHead,
                                               KsAcquireAndRemove );
    }
}

/*****************************************************************************
 * KsoDispatchCreate()
 *****************************************************************************
 * Handles object create IRPs using the IIrpTargetFactory interface pointer
 * in the Context field of the create item.
 */
NTSTATUS
    KsoDispatchCreate
    (
    IN      PDEVICE_OBJECT  pDeviceObject,
    IN      PIRP            pIrp
    )
{
    NTSTATUS    ntStatus;

    PAGED_CODE();

    ASSERT(pDeviceObject);
    ASSERT(pIrp);

    ntStatus = xDispatchCreate
                (
                PIRPTARGETFACTORY(KSCREATE_ITEM_IRP_STORAGE(pIrp)->Context),
                pDeviceObject,
                pIrp
                );

    return ntStatus;
}

/*****************************************************************************
 * KsoDispatchCreateWithGenericFactory()
 *****************************************************************************
 * Handles object create IRPs using the IIrpTarget interface pointer in the
 * device or object context.
 */
NTSTATUS
    KsoDispatchCreateWithGenericFactory
    (
    IN      PDEVICE_OBJECT  pDeviceObject,
    IN      PIRP            pIrp
    )
{
    PAGED_CODE();

    ASSERT(pDeviceObject);
    ASSERT(pIrp);

    PIRPTARGETFACTORY   pIrpTargetFactory;
    PFILE_OBJECT        pParentFileObject =
        IoGetCurrentIrpStackLocation(pIrp)->FileObject->RelatedFileObject;

    if (pParentFileObject)
    {
        // Get IrpTargetFactory from parent object context.
        pIrpTargetFactory =
            (   POBJECT_CONTEXT(pParentFileObject->FsContext)
                ->  pIrpTarget
            );
    }
    else
    {
        // Get IrpTargetFactory from device object context.
        pIrpTargetFactory =
            (   PDEVICE_CONTEXT(pDeviceObject->DeviceExtension)
                ->  pIrpTargetFactory
            );
    }

    return xDispatchCreate(pIrpTargetFactory,pDeviceObject,pIrp);
}

/*****************************************************************************
 * DispatchDeviceIoControl()
 *****************************************************************************
 * Dispatches device I/O control IRPs.
 */
NTSTATUS
    DispatchDeviceIoControl
    (
    IN      PDEVICE_OBJECT   pDeviceObject,
    IN      PIRP             pIrp
    )
{
    PAGED_CODE();

    ASSERT(pDeviceObject);
    ASSERT(pIrp);

    NTSTATUS ntStatus;
    IRPDISP  irpDisp;

    PDEVICE_CONTEXT pDeviceContext =
        PDEVICE_CONTEXT(pDeviceObject->DeviceExtension);

    IncrementPendingIrpCount(pDeviceContext);

    // check the device state
    irpDisp = GetIrpDisposition(pDeviceObject, IRP_MJ_DEVICE_CONTROL);

    switch(irpDisp) {

        default:
            ASSERT(0);

            //
            // Fall through
            //

        case IRPDISP_NOTREADY:

            _DbgPrintF(DEBUGLVL_TERSE,("FAILING DevIoCtl due to dev state"));

            ntStatus = STATUS_DEVICE_NOT_READY;

            pIrp->IoStatus.Information = 0;
            CompleteIrp(pDeviceContext,pIrp,ntStatus);
            break;

        case IRPDISP_QUEUE:

            ntStatus = STATUS_PENDING;
            pIrp->IoStatus.Status = ntStatus;
            IoMarkIrpPending( pIrp );

            // add the IRP to the pended IRP queue
            KsAddIrpToCancelableQueue( &pDeviceContext->PendedIrpList,
                                       &pDeviceContext->PendedIrpLock,
                                       pIrp,
                                       KsListEntryTail,
                                       NULL );

            ntStatus = STATUS_PENDING;
            break;

        case IRPDISP_PROCESS:

            // get the stack location
            PIO_STACK_LOCATION pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

            // get the object context
            POBJECT_CONTEXT pObjectContext = POBJECT_CONTEXT(pIrpStack->FileObject->FsContext);

            // if we have an IrpTarget, go ahead and dispatch.  Otherwise, pass off to KS.
            if( pObjectContext->pIrpTarget )
            {
                ntStatus = pObjectContext->pIrpTarget->DeviceIoControl( pDeviceObject, pIrp );
            } else
            {
                ntStatus = KsDispatchIrp( pDeviceObject, pIrp );
            }

            DecrementPendingIrpCount(pDeviceContext);
            break;
    }

    return ntStatus;
}

/*****************************************************************************
 * DispatchFastDeviceIoControl()
 *****************************************************************************
 * Dispatches fast device I/O control calls.
 */
BOOLEAN
    DispatchFastDeviceIoControl
    (
    IN      PFILE_OBJECT        FileObject,
    IN      BOOLEAN             Wait,
    IN      PVOID               InputBuffer     OPTIONAL,
    IN      ULONG               InputBufferLength,
    OUT     PVOID               OutputBuffer    OPTIONAL,
    IN      ULONG               OutputBufferLength,
    IN      ULONG               IoControlCode,
    OUT     PIO_STATUS_BLOCK    IoStatus,
    IN      PDEVICE_OBJECT      DeviceObject
    )
{
    PAGED_CODE();

    ASSERT(FileObject);
    ASSERT(IoStatus);
    ASSERT(DeviceObject);

    CheckCurrentPowerState( DeviceObject );

    return(POBJECT_CONTEXT(FileObject->FsContext)->pIrpTarget->FastDeviceIoControl(
            FileObject,
            Wait,
            InputBuffer,
            InputBufferLength,
            OutputBuffer,
            OutputBufferLength,
            IoControlCode,
            IoStatus,
                DeviceObject));
}

/*****************************************************************************
 * DispatchRead()
 *****************************************************************************
 * Dispatches read IRPs.
 */
NTSTATUS
    DispatchRead
    (
    IN      PDEVICE_OBJECT   pDeviceObject,
    IN      PIRP             pIrp
    )
{
    PAGED_CODE();

    ASSERT(pDeviceObject);
    ASSERT(pIrp);

    NTSTATUS ntStatus;
    IRPDISP  irpDisp;

    PDEVICE_CONTEXT pDeviceContext =
        PDEVICE_CONTEXT(pDeviceObject->DeviceExtension);

    IncrementPendingIrpCount(pDeviceContext);

    // check the device state
    irpDisp = GetIrpDisposition(pDeviceObject, IRP_MJ_READ);

    switch(irpDisp) {

        default:
            ASSERT(0);

            //
            // Fall through
            //

        case IRPDISP_NOTREADY:

            ntStatus = STATUS_DEVICE_NOT_READY;
            pIrp->IoStatus.Information = 0;
            CompleteIrp(pDeviceContext,pIrp,ntStatus);
            break;

        case IRPDISP_QUEUE:

            // pend the IRP
            ntStatus = STATUS_PENDING;
            pIrp->IoStatus.Status = ntStatus;
            IoMarkIrpPending( pIrp );

            // add the IRP to the pended IRP queue
            KsAddIrpToCancelableQueue( &pDeviceContext->PendedIrpList,
                                       &pDeviceContext->PendedIrpLock,
                                       pIrp,
                                       KsListEntryTail,
                                       NULL );
            break;

        case IRPDISP_PROCESS:

            // get the stack location
            PIO_STACK_LOCATION pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

            // get the object context
            POBJECT_CONTEXT pObjectContext = POBJECT_CONTEXT(pIrpStack->FileObject->FsContext);

            // if we have an IrpTarget, go ahead and dispatch.  Otherwise, pass off to KS.
            if( pObjectContext->pIrpTarget )
            {
                ntStatus = pObjectContext->pIrpTarget->Read( pDeviceObject, pIrp );
            } else
            {
                ntStatus = KsDispatchIrp( pDeviceObject, pIrp );
            }

            DecrementPendingIrpCount(pDeviceContext);
            break;
    }

    return ntStatus;
}

/*****************************************************************************
 * DispatchFastRead()
 *****************************************************************************
 * Dispatches fast read calls.
 */
BOOLEAN
    DispatchFastRead
    (
    IN      PFILE_OBJECT        FileObject,
    IN      PLARGE_INTEGER      FileOffset,
    IN      ULONG               Length,
    IN      BOOLEAN             Wait,
    IN      ULONG               LockKey,
    OUT     PVOID               Buffer,
    OUT     PIO_STATUS_BLOCK    IoStatus,
    IN      PDEVICE_OBJECT      DeviceObject
    )
{
    PAGED_CODE();

    ASSERT(FileObject);
    ASSERT(IoStatus);
    ASSERT(DeviceObject);

    CheckCurrentPowerState( DeviceObject );

    return
        (   POBJECT_CONTEXT(FileObject->FsContext)
            ->  pIrpTarget
            ->  FastRead
            (
            FileObject,
            FileOffset,
            Length,
            Wait,
            LockKey,
            Buffer,
            IoStatus,
            DeviceObject
            )
        );
}

/*****************************************************************************
 * DispatchWrite()
 *****************************************************************************
 * Dispatches write IRPs.
 */
NTSTATUS
    DispatchWrite
    (
    IN      PDEVICE_OBJECT   pDeviceObject,
    IN      PIRP             pIrp
    )
{
    PAGED_CODE();

    ASSERT(pDeviceObject);
    ASSERT(pIrp);

    NTSTATUS ntStatus;
    IRPDISP  irpDisp;

    PDEVICE_CONTEXT pDeviceContext =
        PDEVICE_CONTEXT(pDeviceObject->DeviceExtension);

    IncrementPendingIrpCount(pDeviceContext);

    // check the device state
    irpDisp = GetIrpDisposition(pDeviceObject, IRP_MJ_WRITE);

    switch(irpDisp) {

        default:
            ASSERT(0);

            //
            // Fall through
            //

        case IRPDISP_NOTREADY:

            ntStatus = STATUS_DEVICE_NOT_READY;
            pIrp->IoStatus.Information = 0;
            CompleteIrp(pDeviceContext,pIrp,ntStatus);
            break;

        case IRPDISP_QUEUE:

            // pend the IRP
            ntStatus = STATUS_PENDING;
            pIrp->IoStatus.Status = ntStatus;
            IoMarkIrpPending( pIrp );

            // add the IRP to the pended IRP queue
            KsAddIrpToCancelableQueue( &pDeviceContext->PendedIrpList,
                                       &pDeviceContext->PendedIrpLock,
                                       pIrp,
                                       KsListEntryTail,
                                       NULL );
            break;

        case IRPDISP_PROCESS:

            // get the stack location
            PIO_STACK_LOCATION pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

            // get the object context
            POBJECT_CONTEXT pObjectContext = POBJECT_CONTEXT(pIrpStack->FileObject->FsContext);

            // if we have an IrpTarget, go ahead and dispatch.  Otherwise, pass off to KS.
            if( pObjectContext->pIrpTarget )
            {
                ntStatus = pObjectContext->pIrpTarget->Write( pDeviceObject, pIrp );
            } else
            {
                ntStatus = KsDispatchIrp( pDeviceObject, pIrp );
            }

            DecrementPendingIrpCount(pDeviceContext);
            break;
    }

    return ntStatus;
}

/*****************************************************************************
 * DispatchFastWrite()
 *****************************************************************************
 * Dispatches fast write calls.
 */
BOOLEAN
    DispatchFastWrite
    (
    IN      PFILE_OBJECT        FileObject,
    IN      PLARGE_INTEGER      FileOffset,
    IN      ULONG               Length,
    IN      BOOLEAN             Wait,
    IN      ULONG               LockKey,
    IN      PVOID               Buffer,
    OUT     PIO_STATUS_BLOCK    IoStatus,
    IN      PDEVICE_OBJECT      DeviceObject
    )
{
    PAGED_CODE();

    ASSERT(FileObject);
    ASSERT(IoStatus);
    ASSERT(DeviceObject);

    CheckCurrentPowerState( DeviceObject );

    return
        (   POBJECT_CONTEXT(FileObject->FsContext)
            ->  pIrpTarget
            ->  FastWrite
            (
            FileObject,
            FileOffset,
            Length,
            Wait,
            LockKey,
            Buffer,
            IoStatus,
            DeviceObject
            )
        );
}

/*****************************************************************************
 * DispatchFlush()
 *****************************************************************************
 * Dispatches flush IRPs.
 */
NTSTATUS
    DispatchFlush
    (
    IN      PDEVICE_OBJECT   pDeviceObject,
    IN      PIRP             pIrp
    )
{
    PAGED_CODE();

    ASSERT(pDeviceObject);
    ASSERT(pIrp);

    NTSTATUS ntStatus;
    IRPDISP  irpDisp;

    PDEVICE_CONTEXT pDeviceContext =
        PDEVICE_CONTEXT(pDeviceObject->DeviceExtension);

    IncrementPendingIrpCount(pDeviceContext);

    // check the device state
    irpDisp = GetIrpDisposition(pDeviceObject, IRP_MJ_FLUSH_BUFFERS);

    switch(irpDisp) {

        default:
            ASSERT(0);

            //
            // Fall through
            //

        case IRPDISP_NOTREADY:

            ntStatus = STATUS_DEVICE_NOT_READY;
            pIrp->IoStatus.Information = 0;
            CompleteIrp(pDeviceContext,pIrp,ntStatus);
            break;

        case IRPDISP_QUEUE:

            // pend the IRP
            ntStatus = STATUS_PENDING;
            pIrp->IoStatus.Status = ntStatus;
            IoMarkIrpPending( pIrp );

            // add the IRP to the pended IRP queue
            KsAddIrpToCancelableQueue( &pDeviceContext->PendedIrpList,
                                       &pDeviceContext->PendedIrpLock,
                                       pIrp,
                                       KsListEntryTail,
                                       NULL );
            break;

        case IRPDISP_PROCESS:

            // get the stack location
            PIO_STACK_LOCATION pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

            // get the object context
            POBJECT_CONTEXT pObjectContext = POBJECT_CONTEXT(pIrpStack->FileObject->FsContext);

            // if we have an IrpTarget, go ahead and dispatch.  Otherwise, pass off to KS.
            if( pObjectContext->pIrpTarget )
            {
                ntStatus = pObjectContext->pIrpTarget->Flush( pDeviceObject, pIrp );
            } else
            {
                ntStatus = KsDispatchIrp( pDeviceObject, pIrp );
            }

            DecrementPendingIrpCount(pDeviceContext);
            break;
    }

    return ntStatus;
}

/*****************************************************************************
 * DispatchClose()
 *****************************************************************************
 * Dispatches close IRPs.
 */
NTSTATUS
    DispatchClose
    (
    IN      PDEVICE_OBJECT   pDeviceObject,
    IN      PIRP             pIrp
    )
{
    PAGED_CODE();

    ASSERT(pDeviceObject);
    ASSERT(pIrp);

    NTSTATUS ntStatus;
    IRPDISP  irpDisp;

    PDEVICE_CONTEXT pDeviceContext =
        PDEVICE_CONTEXT(pDeviceObject->DeviceExtension);

    IncrementPendingIrpCount(pDeviceContext);

    // check the device state
    irpDisp = GetIrpDisposition(pDeviceObject, IRP_MJ_CLOSE);

    switch(irpDisp) {

        default:
            ASSERT(0);

            //
            // Fall through
            //

        case IRPDISP_NOTREADY:

            _DbgPrintF(DEBUGLVL_TERSE,("-- FAILED due to dev state"));

            ntStatus = STATUS_DEVICE_NOT_READY;
            pIrp->IoStatus.Information = 0;

            CompleteIrp(pDeviceContext,pIrp,ntStatus);
            break;

        case IRPDISP_QUEUE:

            ntStatus = STATUS_PENDING;
            pIrp->IoStatus.Status = ntStatus;
            IoMarkIrpPending( pIrp );

            // add the IRP to the pended IRP queue
            KsAddIrpToCancelableQueue( &pDeviceContext->PendedIrpList,
                                       &pDeviceContext->PendedIrpLock,
                                       pIrp,
                                       KsListEntryTail,
                                       NULL );
            break;

        case IRPDISP_PROCESS:

            // get the stack location
            PIO_STACK_LOCATION pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

            // get the object context
            POBJECT_CONTEXT pObjectContext = POBJECT_CONTEXT(pIrpStack->FileObject->FsContext);

            // if we have an IrpTarget, go ahead and dispatch.  Otherwise, pass off to KS.
            if( pObjectContext->pIrpTarget )
            {
                // get the parent file object (if there is one)
                PFILE_OBJECT pFileObjectParent = pIrpStack->FileObject->RelatedFileObject;

                // dispatch the close to the IrpTarget
                ntStatus = pObjectContext->pIrpTarget->Close( pDeviceObject, pIrp );

                // release the IrpTarget
                pObjectContext->pIrpTarget->Release();

                // dereference the software bus object
                KsDereferenceSoftwareBusObject( pDeviceContext->pDeviceHeader );

                // free the object header
                KsFreeObjectHeader( pObjectContext->pObjectHeader );

                // dereference the parent file object
                if (pObjectContext->ReferenceParent && pFileObjectParent)
                {
                    ObDereferenceObject(pFileObjectParent);
                }

                // free the object context
                ExFreePool(pObjectContext);

            } else
            {
                ntStatus = KsDispatchIrp( pDeviceObject, pIrp );
            }

            // decrement object count
            ULONG newObjectCount = InterlockedDecrement(PLONG(&pDeviceContext->ExistingObjectCount));

            _DbgPrintF(DEBUGLVL_VERBOSE,("DispatchClose  objects: %d",newObjectCount));

            DecrementPendingIrpCount(pDeviceContext);
            break;
    }

    return ntStatus;
}

/*****************************************************************************
 * DispatchQuerySecurity()
 *****************************************************************************
 * Dispatches query security IRPs.
 */
NTSTATUS
    DispatchQuerySecurity
    (
    IN      PDEVICE_OBJECT   pDeviceObject,
    IN      PIRP             pIrp
    )
{
    PAGED_CODE();

    ASSERT(pDeviceObject);
    ASSERT(pIrp);

    NTSTATUS ntStatus;
    IRPDISP  irpDisp;

    PDEVICE_CONTEXT pDeviceContext =
        PDEVICE_CONTEXT(pDeviceObject->DeviceExtension);

    IncrementPendingIrpCount(pDeviceContext);

    // check the device state
    irpDisp = GetIrpDisposition(pDeviceObject, IRP_MJ_QUERY_SECURITY);

    switch(irpDisp) {

        default:
            ASSERT(0);

            //
            // Fall through
            //

        case IRPDISP_NOTREADY:

            ntStatus = STATUS_DEVICE_NOT_READY;
            pIrp->IoStatus.Information = 0;
            CompleteIrp(pDeviceContext,pIrp,ntStatus);
            break;

        case IRPDISP_QUEUE:

            ntStatus = STATUS_PENDING;
            pIrp->IoStatus.Status = ntStatus;
            IoMarkIrpPending( pIrp );

            // add the IRP to the pended IRP queue
            KsAddIrpToCancelableQueue( &pDeviceContext->PendedIrpList,
                                       &pDeviceContext->PendedIrpLock,
                                       pIrp,
                                       KsListEntryTail,
                                       NULL );
            break;

        case IRPDISP_PROCESS:

            // get the stack location
            PIO_STACK_LOCATION pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

            // get the object context
            POBJECT_CONTEXT pObjectContext = POBJECT_CONTEXT(pIrpStack->FileObject->FsContext);

            // if we have an IrpTarget, go ahead and dispatch.  Otherwise, pass off to KS.
            if( pObjectContext->pIrpTarget )
            {
                ntStatus = pObjectContext->pIrpTarget->QuerySecurity( pDeviceObject, pIrp );
            } else
            {
                ntStatus = KsDispatchIrp( pDeviceObject, pIrp );
            }

            DecrementPendingIrpCount(pDeviceContext);
    }

    return ntStatus;
}

/*****************************************************************************
 * DispatchSetSecurity()
 *****************************************************************************
 * Dispatches set security IRPs.
 */
NTSTATUS
    DispatchSetSecurity
    (
    IN      PDEVICE_OBJECT   pDeviceObject,
    IN      PIRP             pIrp
    )
{
    PAGED_CODE();

    ASSERT(pDeviceObject);
    ASSERT(pIrp);

    NTSTATUS ntStatus;
    IRPDISP  irpDisp;

    PDEVICE_CONTEXT pDeviceContext =
        PDEVICE_CONTEXT(pDeviceObject->DeviceExtension);

    IncrementPendingIrpCount(pDeviceContext);

    // check the device state
    irpDisp = GetIrpDisposition(pDeviceObject, IRP_MJ_SET_SECURITY);

    switch(irpDisp) {

        default:
            ASSERT(0);

            //
            // Fall through
            //

        case IRPDISP_NOTREADY:

            ntStatus = STATUS_DEVICE_NOT_READY;
            pIrp->IoStatus.Information = 0;
            CompleteIrp(pDeviceContext,pIrp,ntStatus);
            break;

        case IRPDISP_QUEUE:

            ntStatus = STATUS_PENDING;
            pIrp->IoStatus.Status = ntStatus;
            IoMarkIrpPending( pIrp );

            // add the IRP to the pended IRP queue
            KsAddIrpToCancelableQueue( &pDeviceContext->PendedIrpList,
                                       &pDeviceContext->PendedIrpLock,
                                       pIrp,
                                       KsListEntryTail,
                                       NULL );

            break;

        case IRPDISP_PROCESS:

            // get the stack location
            PIO_STACK_LOCATION pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

            // get the object context
            POBJECT_CONTEXT pObjectContext = POBJECT_CONTEXT(pIrpStack->FileObject->FsContext);

            // if we have an IrpTarget, go ahead and dispatch.  Otherwise, pass off to KS.
            if( pObjectContext->pIrpTarget )
            {
                ntStatus = pObjectContext->pIrpTarget->SetSecurity( pDeviceObject, pIrp );
            } else
            {
                ntStatus = KsDispatchIrp( pDeviceObject, pIrp );
            }

            DecrementPendingIrpCount(pDeviceContext);
            break;
    }

    return ntStatus;
}

/*****************************************************************************
 * KsoSetMajorFunctionHandler()
 *****************************************************************************
 * Sets up the handler for a major function.
 */
NTSTATUS
    KsoSetMajorFunctionHandler
    (
    IN      PDRIVER_OBJECT  pDriverObject,
    IN      ULONG           ulMajorFunction
    )
{
    PAGED_CODE();

    ASSERT(pDriverObject);

    NTSTATUS            ntStatus        = STATUS_SUCCESS;
    PDRIVER_DISPATCH    pDriverDispatch = NULL;

    switch (ulMajorFunction)
    {
    case IRP_MJ_CREATE:
        pDriverDispatch = DispatchCreate;
        break;

    case IRP_MJ_CLOSE:
        pDriverDispatch = DispatchClose;
        break;

    case IRP_MJ_FLUSH_BUFFERS:
        pDriverDispatch = DispatchFlush;
        break;

    case IRP_MJ_DEVICE_CONTROL:
        pDriverDispatch = DispatchDeviceIoControl;
        break;

    case IRP_MJ_READ:
        pDriverDispatch = DispatchRead;
        break;

    case IRP_MJ_WRITE:
        pDriverDispatch = DispatchWrite;
        break;

    case IRP_MJ_QUERY_SECURITY:
        pDriverDispatch = DispatchQuerySecurity;
        break;

    case IRP_MJ_SET_SECURITY:
        pDriverDispatch = DispatchSetSecurity;
        break;

    case IRP_MJ_DEVICE_CONTROL | KSDISPATCH_FASTIO:
        pDriverObject->FastIoDispatch->FastIoDeviceControl =
            DispatchFastDeviceIoControl;
        break;

    case IRP_MJ_READ | KSDISPATCH_FASTIO:
        pDriverObject->FastIoDispatch->FastIoRead =
            DispatchFastRead;
        break;

    case IRP_MJ_WRITE | KSDISPATCH_FASTIO:
        pDriverObject->FastIoDispatch->FastIoWrite =
            DispatchFastWrite;
        break;

    default:
        ntStatus = STATUS_INVALID_PARAMETER;
        break;
    }

    if (pDriverDispatch)
    {
        pDriverObject->MajorFunction[ulMajorFunction] = pDriverDispatch;
    }

    return ntStatus;
}

/*****************************************************************************
 * KsoDispatchIrp()
 *****************************************************************************
 * Dispatch an IRP.
 */
NTSTATUS
    KsoDispatchIrp
    (
    IN      PDEVICE_OBJECT  pDeviceObject,
    IN      PIRP            pIrp
    )
{
    PAGED_CODE();

    ASSERT(pDeviceObject);
    ASSERT(pIrp);

    NTSTATUS ntStatus;

    PDEVICE_CONTEXT pDeviceContext = PDEVICE_CONTEXT(pDeviceObject->DeviceExtension);

    ntStatus = PcValidateDeviceContext(pDeviceContext, pIrp);
    if (!NT_SUCCESS(ntStatus))
    {
        // Don't know what to do, but this is probably a PDO.
        // We'll try to make this right by completing the IRP
        // untouched (per PnP, WMI, and Power rules). Note 
        // that if this isn't a PDO, and isn't a portcls FDO, then 
        // the driver messed up by using Portcls as a filter (huh?)
        // In this case the verifier will fail us, WHQL will catch 
        // them, and the driver will be fixed. We'd be very surprised 
        // to see such a case.

        // Assume FDO, no PoStartNextPowerIrp as this isn't IRP_MJ_POWER
        ntStatus = pIrp->IoStatus.Status;
        IoCompleteRequest( pIrp, IO_NO_INCREMENT );
        return ntStatus;
    }

    if (IoGetCurrentIrpStackLocation(pIrp)->MajorFunction == IRP_MJ_CREATE) {
        //
        // Creates must be handled differently because portcls does not do
        // a KsSetMajorFunctionHandler on IRP_MJ_CREATE.
        //
        ntStatus = DispatchCreate(pDeviceObject,pIrp);
    } else {
        //
        // At this point, the object in question may or may not be a portcls 
        // object (it may be a Ks allocator, for instance).  Calling 
        // KsDispatchIrp() will dispatch the Irp as it normally would for a 
        // driver which does KsSetMajorFunctionHandler().  This will call 
        // through the object header to the appropriate dispatch function.  
        // For portcls objects, this is KsoDispatchTable above.  For Ks 
        // allocators, this will route the call to the correct function 
        // instead of going to the wrong dispatch routine here.
        //
        ntStatus = KsDispatchIrp(pDeviceObject,pIrp);
    }

    return ntStatus;

}

#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\main\perf.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   perf.c
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//
//  History:   Date       Author      Comment
//             --------------------------------------------------------------
//             12/12/00   ArthurZ     Created
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1995-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "private.h"
#include "perf.h"

#define PROC_REG_PATH L"System\\CurrentControlSet\\Services\\Portcls"

GUID ControlGuid =
{ 0x28cf047a, 0x2437, 0x4b24, 0xb6, 0x53, 0xb9, 0x44, 0x6a, 0x41, 0x9a, 0x69 };

GUID TraceGuid =
{ 0x9d447297, 0xc576, 0x4015, 0x87, 0xb5, 0xa5, 0xa6, 0x98, 0xfd, 0x4d, 0xd1 };

GUID TraceDMAGuid =
{ 0xf27b2e65, 0x15f0, 0x4d01, 0xab, 0xe2, 0xf7, 0x68, 0x5d, 0xf6, 0xe5, 0x72 };

ULONG TraceEnable;
TRACEHANDLE LoggerHandle;

typedef struct PERFINFO_AUDIOGLITCH {
    ULONGLONG   cycleCounter;
    ULONG       glitchType;
    LONGLONG    sampleTime;
    LONGLONG    previousTime;
    ULONG_PTR   instanceId;
} PERFINFO_AUDIOGLITCH, *PPERFINFO_AUDIOGLITCH;

typedef struct PERFINFO_WMI_AUDIOGLITCH {
    EVENT_TRACE_HEADER          header;
    PERFINFO_AUDIOGLITCH        data;
} PERFINFO_WMI_AUDIO_GLITCH, *PPERFINFO_WMI_AUDIOGLITCH;

///////////////////////////////////////////////////////////////////////////

VOID
PerfRegisterProvider (
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine registers this component as a WMI event tracing provider.

--*/

{
    IoWMIRegistrationControl (DeviceObject, WMIREG_ACTION_REGISTER);
}

///////////////////////////////////////////////////////////////////////////

VOID
PerfUnregisterProvider (
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine unregisters this component as a WMI event tracing provider.

--*/

{
    IoWMIRegistrationControl (DeviceObject, WMIREG_ACTION_DEREGISTER);
}

///////////////////////////////////////////////////////////////////////////

VOID
RegisterWmiGuids (
    IN PWMIREGINFO WmiRegInfo,
    IN ULONG RegInfoSize,
    IN PULONG ReturnSize
    )

/*++

Routine Description:

    This routine registers WMI event tracing streams.

--*/

{
    ULONG SizeNeeded;
    PWMIREGGUIDW WmiRegGuidPtr;
    ULONG status;
    ULONG GuidCount;
    ULONG RegistryPathSize;
    PUCHAR Temp;

    *ReturnSize = 0;
    GuidCount = 1;

    RegistryPathSize = sizeof (PROC_REG_PATH) - sizeof (WCHAR) + sizeof (USHORT);
    SizeNeeded = sizeof (WMIREGINFOW) + GuidCount * sizeof (WMIREGGUIDW) + RegistryPathSize;

    if (SizeNeeded > RegInfoSize) {
        *((PULONG)WmiRegInfo) = SizeNeeded;
        *ReturnSize = sizeof (ULONG);
        return;
    }

    RtlZeroMemory (WmiRegInfo, SizeNeeded);
    WmiRegInfo->BufferSize = SizeNeeded;
    WmiRegInfo->GuidCount = GuidCount;

    WmiRegGuidPtr = WmiRegInfo->WmiRegGuid;
    WmiRegGuidPtr->Guid = ControlGuid;
    WmiRegGuidPtr->Flags |= (WMIREG_FLAG_TRACED_GUID | WMIREG_FLAG_TRACE_CONTROL_GUID);

    Temp = (PUCHAR)(WmiRegGuidPtr + 1);
    WmiRegInfo->RegistryPath = PtrToUlong ((PVOID)(Temp - (PUCHAR)WmiRegInfo));
    *((PUSHORT)Temp) = (USHORT)(sizeof (PROC_REG_PATH) - sizeof (WCHAR));

    Temp += sizeof (USHORT);
    RtlCopyMemory (Temp, PROC_REG_PATH, sizeof (PROC_REG_PATH) - sizeof (WCHAR));

    *ReturnSize = SizeNeeded;
}

///////////////////////////////////////////////////////////////////////////

NTSTATUS
PcDispatchSystemControl
(
    IN      PDEVICE_OBJECT  pDeviceObject,
    IN      PIRP            pIrp
);

NTSTATUS
PerfWmiDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine handles IRP_MJ_SYSTEM_CONTROL calls. It processes
    WMI requests and passes everything else on to KS.

--*/

{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation (Irp);
    ULONG ReturnSize;
    PWNODE_HEADER Wnode;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    if ((PDEVICE_OBJECT)IrpSp->Parameters.WMI.ProviderId != DeviceObject) {
        return PcDispatchSystemControl(DeviceObject, Irp);
    }

    switch (IrpSp->MinorFunction) {

    case IRP_MN_REGINFO:
        RegisterWmiGuids ((PWMIREGINFO)IrpSp->Parameters.WMI.Buffer,
                          IrpSp->Parameters.WMI.BufferSize,
                          &ReturnSize);
        break;

    case IRP_MN_ENABLE_EVENTS:
        ReturnSize = 0;
        InterlockedExchange ((PLONG)&TraceEnable, 1);
        Wnode = (PWNODE_HEADER)IrpSp->Parameters.WMI.Buffer;
        if (IrpSp->Parameters.WMI.BufferSize >= sizeof (WNODE_HEADER)) {
            LoggerHandle = Wnode->HistoricalContext;
        }
        break;

    case IRP_MN_DISABLE_EVENTS:
        ReturnSize = 0;
        InterlockedExchange ((PLONG)&TraceEnable, 0);
        break;

    case IRP_MN_ENABLE_COLLECTION:
    case IRP_MN_DISABLE_COLLECTION:
        ReturnSize = 0;
        break;

    default:
        ntStatus = STATUS_NOT_SUPPORTED;
    }

    // Do not modify Irp Status if this WMI call is not
    // handled.
    //
    if (STATUS_NOT_SUPPORTED == ntStatus)
    {
        ntStatus = Irp->IoStatus.Status;
    }
    else
    {
        Irp->IoStatus.Status = ntStatus;
        Irp->IoStatus.Information =
            (NT_SUCCESS(ntStatus)) ? ReturnSize : 0;
    }

    IoCompleteRequest (Irp, IO_NO_INCREMENT);
    return ntStatus;
}

///////////////////////////////////////////////////////////////////////////
VOID
PerfLogGlitch (
    IN GUID Guid,
    IN ULONG_PTR InstanceId,
    IN ULONG Type,
    IN LONGLONG CurrentTime,
    IN LONGLONG PreviousTime
    )

/*++

Routine Description:

    This routine logs a WMI event tracing event with an audio glitch GUID
    and the supplied glitch type.

--*/

{
    PERFINFO_WMI_AUDIO_GLITCH Event;

    if (LoggerHandle == (TRACEHANDLE)NULL || TraceEnable == 0) {
        return;
    }

    RtlZeroMemory (&Event, sizeof (Event));
    Event.header.Size = sizeof (Event);
    Event.header.Flags = WNODE_FLAG_TRACED_GUID;
    Event.header.Guid = Guid;
    Event.data.glitchType = Type;
    Event.data.instanceId = InstanceId;
    Event.data.sampleTime = CurrentTime;
    Event.data.previousTime = PreviousTime;

    ((PWNODE_HEADER)&Event)->HistoricalContext = LoggerHandle;

    IoWMIWriteEvent ((PVOID)&Event);
}


VOID
PerfLogInsertSilenceGlitch (
    IN ULONG_PTR InstanceId,
    IN ULONG Type,
    IN LONGLONG CurrentTime,
    IN LONGLONG PreviousTime
    )

{
    PerfLogGlitch (TraceGuid,InstanceId,Type,CurrentTime,PreviousTime);
}

VOID
PerfLogDMAGlitch (
    IN ULONG_PTR InstanceId,
    IN ULONG Type,
    IN LONGLONG CurrentTime,
    IN LONGLONG PreviousTime
    )

{
    PerfLogGlitch (TraceDMAGuid,InstanceId,Type,CurrentTime,PreviousTime);
}

//---------------------------------------------------------------------------
//  End of File: perf.c
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\main\property.cpp ===
/*****************************************************************************
 * property.cpp - property support
 *****************************************************************************
 * Copyright (c) 1997-2000 Microsoft Corporation.  All rights reserved.
 */

#include "private.h"




/*****************************************************************************
 * Functions
 */

#pragma code_seg("PAGE")

/*****************************************************************************
 * PcHandlePropertyWithTable()
 *****************************************************************************
 * Uses a property table to handle a property request IOCTL.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcHandlePropertyWithTable
(   IN      PIRP                    pIrp
,   IN      ULONG                   ulPropertySetsCount
,   IN      const KSPROPERTY_SET*   pKsPropertySet
,   IN      PPROPERTY_CONTEXT       pPropertyContext
)
{
    ASSERT(pIrp);
    ASSERT(pPropertyContext);

    pIrp->Tail.Overlay.DriverContext[3] = pPropertyContext;

    NTSTATUS ntStatus =
        KsPropertyHandler
        (
            pIrp,
            ulPropertySetsCount,
            pKsPropertySet
        );

    return ntStatus;
}

/*****************************************************************************
 * PcDispatchProperty()
 *****************************************************************************
 * Dispatch a property via a PCPROPERTY_ITEM entry.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcDispatchProperty
(
    IN          PIRP                pIrp            OPTIONAL,
    IN          PPROPERTY_CONTEXT   pPropertyContext,
    IN const    KSPROPERTY_SET *    pKsPropertySet  OPTIONAL,
    IN          ULONG               ulIdentifierSize,
    IN          PKSIDENTIFIER       pKsIdentifier,
    IN OUT      PULONG              pulDataSize,
    IN OUT      PVOID               pvData          OPTIONAL
)
{
    PAGED_CODE();

    ASSERT(pPropertyContext);
    ASSERT(pKsIdentifier);
    ASSERT(pulDataSize);

    PPCPROPERTY_REQUEST pPcPropertyRequest = 
        new(NonPagedPool,'rPcP') PCPROPERTY_REQUEST;

    NTSTATUS ntStatus;
    if (! pPcPropertyRequest)
    {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        //
        // Copy target information from the context structure.
        //
        pPcPropertyRequest->MajorTarget = 
            pPropertyContext->pUnknownMajorTarget;
        pPcPropertyRequest->MinorTarget = 
            pPropertyContext->pUnknownMinorTarget;
        pPcPropertyRequest->Node = 
            pPropertyContext->ulNodeId;

        //
        // Determine the value size.
        //
        pPcPropertyRequest->ValueSize = *pulDataSize;

        //
        // If the node number is in the instance data, extract it.
        // TODO:  Remove this when node objects rule.
        //
        if  (   (pKsIdentifier->Flags & KSPROPERTY_TYPE_TOPOLOGY)
            &&  (pPcPropertyRequest->Node == ULONG(-1))
            )
        {
            //
            // Get the node id and remaining instance.
            //
            if  (ulIdentifierSize < sizeof(KSP_NODE))
            {
                delete pPcPropertyRequest;

                return STATUS_INVALID_BUFFER_SIZE;
            }

            PKSP_NODE pKsPNode = PKSP_NODE(pKsIdentifier);

            pPcPropertyRequest->Node = pKsPNode->NodeId;

            pPcPropertyRequest->InstanceSize = 
                ulIdentifierSize - sizeof(KSP_NODE);

            pPcPropertyRequest->Instance = 
                (   (pPcPropertyRequest->InstanceSize == 0) 
                ?   NULL 
                :   PVOID(pKsPNode + 1)
                );
        }
        else
        {
            //
            // No node in the instance...get generic instance if any.
            //
            pPcPropertyRequest->InstanceSize =
                ulIdentifierSize - sizeof(KSIDENTIFIER);

            pPcPropertyRequest->Instance = 
                (   (pPcPropertyRequest->InstanceSize == 0) 
                ?   NULL 
                :   PVOID(pKsIdentifier + 1)
                );
        }

        if (pKsPropertySet)
        {
            ASSERT(pKsPropertySet->PropertyItem);

            //
            // Find the property item in the KS-style list.
            //
#if (DBG)
            ULONG dbgCount = pKsPropertySet->PropertiesCount;
#endif
            for
            (   const KSPROPERTY_ITEM *pKsPropertyItem = 
                    pKsPropertySet->PropertyItem
            ;   pKsPropertyItem->PropertyId != pKsIdentifier->Id
            ;   pKsPropertyItem++
            )
            {
                ASSERT(--dbgCount);
            }

            //
            // The property item is stashed in the Relations field if this is not
            // a node property.  If it is, we have to find the node property in
            // the original list.
            //
            pPcPropertyRequest->PropertyItem = 
                PPCPROPERTY_ITEM(pKsPropertyItem->Relations);
        }
        else
        {
            //
            // No KS set was supplied.  We need to look in the original list
            // associated with the node.
            //
            pPcPropertyRequest->PropertyItem = NULL;
        }

        if (! pPcPropertyRequest->PropertyItem)
        {
            PPCFILTER_DESCRIPTOR pPcFilterDescriptor =
                pPropertyContext->pPcFilterDescriptor;

            if  (   pPcFilterDescriptor
                &&  (   pPcPropertyRequest->Node 
                    <   pPcFilterDescriptor->NodeCount
                    )
                &&  pPcFilterDescriptor->
                        Nodes[pPcPropertyRequest->Node].AutomationTable
                )
            {
                //
                // Valid node...search the original property item list.
                //
                const PCAUTOMATION_TABLE *pPcAutomationTable =
                    pPcFilterDescriptor->
                        Nodes[pPcPropertyRequest->Node].AutomationTable;

                const PCPROPERTY_ITEM *pPcPropertyItem = 
                    pPcAutomationTable->Properties;
                for (ULONG ul = pPcAutomationTable->PropertyCount; ul--; )
                {
                    if  (   IsEqualGUIDAligned
                            (   *pPcPropertyItem->Set
                            ,   pKsIdentifier->Set
                            )
                        &&  (pPcPropertyItem->Id == pKsIdentifier->Id)
                        )
                    {
                        pPcPropertyRequest->PropertyItem = pPcPropertyItem;
                        break;
                    }

                    pPcPropertyItem = 
                        PPCPROPERTY_ITEM
                        (   PBYTE(pPcPropertyItem) 
                        +   pPcAutomationTable->PropertyItemSize
                        );
                }
            }
            else
            {
                //
                // The node ID was invalid.
                //
                ntStatus = STATUS_NOT_FOUND;
            }
        }

        //
        // Call the handler if we have a property item with a handler.
        //
        if  (   pPcPropertyRequest->PropertyItem
            &&  pPcPropertyRequest->PropertyItem->Handler
            )
        {
            pPcPropertyRequest->Verb    = pKsIdentifier->Flags;
            pPcPropertyRequest->Value   = pvData;
            pPcPropertyRequest->Irp     = pIrp;

            //
            // Call the handler.
            //
            ntStatus =
                pPcPropertyRequest->PropertyItem->Handler
                (
                    pPcPropertyRequest
                );

            *pulDataSize = pPcPropertyRequest->ValueSize;
        }
        else
        {
            ntStatus = STATUS_NOT_FOUND;
        }

        //
        // Delete the request structure unless we are pending.
        //
        if (ntStatus != STATUS_PENDING)
        {
            delete pPcPropertyRequest;
        }
        else
        {
            //
            // Only requests with IRPs can be pending.
            //
            ASSERT(pIrp);
        }
    }

    return ntStatus;
}

/*****************************************************************************
 * PropertyItemPropertyHandler()
 *****************************************************************************
 * KS-sytle property handler that handles all properties using the 
 * PCPROPERTY_ITEM mechanism.
 */
NTSTATUS
PropertyItemPropertyHandler
(
    IN      PIRP            pIrp,
    IN      PKSIDENTIFIER   pKsIdentifier,
    IN OUT  PVOID           pvData      OPTIONAL
)
{
    PAGED_CODE();

    ASSERT(pIrp);
    ASSERT(pKsIdentifier);

    //
    // Extract various things from the IRP and dispatch the property.
    //
    PIO_STACK_LOCATION irpSp = 
        IoGetCurrentIrpStackLocation(pIrp);

    ULONG ulDataSize =
        irpSp->Parameters.DeviceIoControl.OutputBufferLength;

    NTSTATUS ntStatus =
        PcDispatchProperty
        (   pIrp
        ,   PPROPERTY_CONTEXT(pIrp->Tail.Overlay.DriverContext[3])
        ,   KSPROPERTY_SET_IRP_STORAGE(pIrp)
        ,   irpSp->Parameters.DeviceIoControl.InputBufferLength
        ,   pKsIdentifier
        ,   &ulDataSize
        ,   pvData
        );

    //
    // Inform the caller of the resulting status and size.
    // Pending IRPs must be IoMarkIrpPending()ed before the dispatch routine
    // returns.
    //
    if ((ntStatus != STATUS_PENDING) && !NT_ERROR(ntStatus))
    {
        pIrp->IoStatus.Information = ulDataSize;
    }

    return ntStatus;
}

/*****************************************************************************
 * PcCompletePendingPropertyRequest()
 *****************************************************************************
 * Completes a pending property request.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcCompletePendingPropertyRequest
(
    IN      PPCPROPERTY_REQUEST PropertyRequest,
    IN      NTSTATUS            NtStatus
)
{
    ASSERT(PropertyRequest);
    ASSERT(NtStatus != STATUS_PENDING);

    //
    // Validate Parameters.
    //
    if (NULL == PropertyRequest)
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("PcCompletePendingPropertyRequest : Invalid Parameter."));
        return STATUS_INVALID_PARAMETER;
    }

    if (!NT_ERROR(NtStatus))
    {
        PropertyRequest->Irp->IoStatus.Information = 
            PropertyRequest->ValueSize;
    }

    PropertyRequest->Irp->IoStatus.Status = NtStatus;
    IoCompleteRequest(PropertyRequest->Irp,IO_NO_INCREMENT);

    delete PropertyRequest;

    return STATUS_SUCCESS;
}

/*****************************************************************************
 * PcFreePropertyTable()
 *****************************************************************************
 * Frees allocated memory in a PROPERTY_TABLE structure.
 */
PORTCLASSAPI
void
NTAPI
PcFreePropertyTable
(
    IN      PPROPERTY_TABLE         PropertyTable
)
{
    _DbgPrintF(DEBUGLVL_VERBOSE,("PcFreePropertyTable"));

    PAGED_CODE();
    
    ASSERT(PropertyTable);
    
    ASSERT((!PropertyTable->PropertySets) == (!PropertyTable->PropertySetCount));
    //  PropertySets and PropertySetCount must be non-NULL/non-zero, or NULL/zero

    ASSERT(PropertyTable->StaticSets == (!PropertyTable->StaticItems));
    //  StaticSets and StaticItems must be TRUE/NULL, or FALSE/non-null

    PBOOLEAN    staticItem  = PropertyTable->StaticItems;
    if (staticItem)
    {
        PKSPROPERTY_SET propertySet = PropertyTable->PropertySets;
        if (propertySet)
        {
            for( ULONG count = PropertyTable->PropertySetCount; 
                 count--; 
                 propertySet++, staticItem++)
            {
                if ((! *staticItem) && propertySet->PropertyItem)
                {
                    ExFreePool(PVOID(propertySet->PropertyItem));
                }
            }
        }
        ExFreePool(PropertyTable->StaticItems);
        PropertyTable->StaticItems = NULL;
    }

    if (PropertyTable->PropertySets && !PropertyTable->StaticSets)
    {
        PropertyTable->PropertySetCount = 0;
        ExFreePool(PropertyTable->PropertySets);
        PropertyTable->PropertySets = NULL;
    }
    PropertyTable->StaticSets = TRUE;
}

/*****************************************************************************
 * PcAddToPropertyTable()
 *****************************************************************************
 * Adds a PROPERTY_ITEM property table to a PROPERTY_TABLE structure.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcAddToPropertyTable
(
    IN OUT  PPROPERTY_TABLE         PropertyTable,
    IN      ULONG                   PropertyItemCount,
    IN      const PCPROPERTY_ITEM * PropertyItems,
    IN      ULONG                   PropertyItemSize,
    IN      BOOLEAN                 NodeTable
)
{
    PAGED_CODE();

    ASSERT(PropertyTable);
    ASSERT(PropertyItems);
    ASSERT(PropertyItemSize >= sizeof(PCPROPERTY_ITEM));

    _DbgPrintF(DEBUGLVL_VERBOSE,("PcAddToEventTable"));

#define ADVANCE(item) (item = PPCPROPERTY_ITEM(PBYTE(item) + PropertyItemSize))

    ASSERT((!PropertyTable->PropertySets) == (!PropertyTable->PropertySetCount));
    //  values must be non-NULL/non-zero, or NULL/zero.
    
    //
    // Determine how many sets we will end up with.
    //
    ULONG setCount = PropertyTable->PropertySetCount;
    const PCPROPERTY_ITEM *item = PropertyItems;
    for (ULONG count = PropertyItemCount; count--; ADVANCE(item))
    {
        BOOLEAN countThis = TRUE;

        //
        // See if it's already in the table.
        //
        PKSPROPERTY_SET propertySet = PropertyTable->PropertySets;
        for 
        (   ULONG count2 = PropertyTable->PropertySetCount; 
            count2--; 
            propertySet++
        )
        {
            if (IsEqualGUIDAligned(*item->Set,*propertySet->Set))
            {
                countThis = FALSE;
                break;
            }
        }

        if (countThis)
        {
            //
            // See if it's appeared in the list previously.
            //
            for 
            (
                const PCPROPERTY_ITEM *prevItem = PropertyItems; 
                prevItem != item; 
                ADVANCE(prevItem)
            )
            {
                if (IsEqualGUIDAligned(*item->Set,*prevItem->Set))
                {
                    countThis = FALSE;
                    break;
                }
            }
        }

        if (countThis)
        {
            setCount++;
        }
    }

    NTSTATUS ntStatus = STATUS_SUCCESS;

    //
    // Make a new set table
    //
    ASSERT(setCount);
    ASSERT(setCount >= PropertyTable->PropertySetCount);
    //
    // Allocate memory required for the set table.
    //
    PKSPROPERTY_SET newTable = 
        PKSPROPERTY_SET
        (
            ExAllocatePoolWithTag
            (
                PagedPool,
                sizeof(KSPROPERTY_SET) * setCount,
                'tScP'
            )
        );

    //
    // Allocate memory for the static items flags.
    //
    PBOOLEAN newStaticItems = NULL;
    if (newTable)
    {
        newStaticItems = 
            PBOOLEAN
            (
                ExAllocatePoolWithTag
                (
                    PagedPool,
                    sizeof(BOOLEAN) * setCount,
                    'bScP'
                )
            );

        if (! newStaticItems)
        {
            ExFreePool(newTable);
            newTable = NULL;
        }
    }

    if (newTable)
    {
        //
        // Initialize the new set table.
        //
        RtlZeroMemory
        (
            PVOID(newTable),
            sizeof(KSPROPERTY_SET) * setCount
        );

        if (PropertyTable->PropertySetCount != 0)
        {
            RtlCopyMemory
            (
                PVOID(newTable),
                PVOID(PropertyTable->PropertySets),
                sizeof(KSPROPERTY_SET) * PropertyTable->PropertySetCount
            );
        }

        //
        // Initialize the new static items flags.
        //
        RtlFillMemory
        (
            PVOID(newStaticItems),
            sizeof(BOOLEAN) * setCount,
            0xff
        );

        if (PropertyTable->StaticItems && PropertyTable->PropertySetCount)
        {
            //
            // Flags existed before...copy them.
            //
            RtlCopyMemory
            (
                PVOID(newStaticItems),
                PVOID(PropertyTable->StaticItems),
                sizeof(BOOLEAN) * PropertyTable->PropertySetCount
            );
        }

        //
        // Assign set GUIDs to the new set entries.
        //
        PKSPROPERTY_SET addHere = 
            newTable + PropertyTable->PropertySetCount;

        const PCPROPERTY_ITEM *item2 = PropertyItems;
        for (ULONG count = PropertyItemCount; count--; ADVANCE(item2))
        {
            BOOLEAN addThis = TRUE;

            //
            // See if it's already in the table.
            //
            for( PKSPROPERTY_SET propertySet = newTable;
                 propertySet != addHere;
                 propertySet++)
            {
                if (IsEqualGUIDAligned(*item2->Set,*propertySet->Set))
                {
                    addThis = FALSE;
                    break;
                }
            }

            if (addThis)
            {
                addHere->Set = item2->Set;
                addHere++;
            }
        }

        ASSERT(addHere == newTable + setCount);

        //
        // Free old allocated tables.
        //
        if (PropertyTable->PropertySets && (!PropertyTable->StaticSets))
        {
            ExFreePool(PropertyTable->PropertySets);
        }
        if (PropertyTable->StaticItems)
        {
            ExFreePool(PropertyTable->StaticItems);
        }

        //
        // Install the new tables.
        //
        PropertyTable->PropertySetCount = setCount;
        PropertyTable->PropertySets     = newTable;
        PropertyTable->StaticSets       = FALSE;
        PropertyTable->StaticItems      = newStaticItems;
    }
    else
    {
        //  if allocations fail, return error and 
        //  keep sets and items as they were.
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Now we have a property set table that contains all the sets we need.
    //
    if (NT_SUCCESS(ntStatus))
    {
        //
        // For each set...
        //
        PKSPROPERTY_SET propertySet = PropertyTable->PropertySets;
        PBOOLEAN        staticItem  = PropertyTable->StaticItems;
        for 
        (   ULONG count = PropertyTable->PropertySetCount; 
            count--; 
            propertySet++, staticItem++
        )
        {
            //
            // Check to see how many new items we have.
            //
            ULONG itemCount = propertySet->PropertiesCount;
            const PCPROPERTY_ITEM *item2 = PropertyItems;
            for (ULONG count2 = PropertyItemCount; count2--; ADVANCE(item2))
            {
                if (IsEqualGUIDAligned(*item2->Set,*propertySet->Set))
                {
                    itemCount++;
                }
            }

            ASSERT(itemCount >= propertySet->PropertiesCount);
            if (itemCount != propertySet->PropertiesCount)
            {
                //
                // Allocate memory required for the items table.
                //
                PKSPROPERTY_ITEM newTable2 = 
                    PKSPROPERTY_ITEM
                    (
                        ExAllocatePoolWithTag
                        (
                            PagedPool,
                            sizeof(KSPROPERTY_ITEM) * itemCount,
                            'iScP'
                        )
                    );

                if (! newTable2)
                {
                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                    break;
                }

                //
                // Initialize the table.
                //
                RtlZeroMemory
                (
                    PVOID(newTable2),
                    sizeof(KSPROPERTY_ITEM) * itemCount
                );

                if (propertySet->PropertiesCount)
                {
                    RtlCopyMemory
                    (
                        PVOID(newTable2),
                        PVOID(propertySet->PropertyItem),
                        sizeof(KSPROPERTY_ITEM) * propertySet->PropertiesCount
                    );
                }

                //
                // Create the new items.
                //
                PKSPROPERTY_ITEM addHere = 
                    newTable2 + propertySet->PropertiesCount;

                item2 = PropertyItems;
                for (count2 = PropertyItemCount; count2--; ADVANCE(item2))
                {
                    if (IsEqualGUIDAligned(*item2->Set,*propertySet->Set))
                    {
                        addHere->PropertyId         = item2->Id;
                        addHere->GetPropertyHandler = 
                            (   (item2->Flags & PCPROPERTY_ITEM_FLAG_GET) 
                            ?   PropertyItemPropertyHandler 
                            :   NULL
                            );
                        addHere->MinProperty        = sizeof(KSPROPERTY);
                        addHere->MinData            = 0;
                        addHere->SetPropertyHandler = 
                            (   (item2->Flags & PCPROPERTY_ITEM_FLAG_SET) 
                            ?   PropertyItemPropertyHandler 
                            :   NULL
                            );
                        addHere->Values             = NULL;
                        addHere->RelationsCount     = 0;
                        addHere->Relations          =   
                            (   NodeTable
                            ?   NULL
                            :   PKSPROPERTY(item2)       // Secret hack!
                            );
                        addHere->SupportHandler     = 
                            (   (item2->Flags & PCPROPERTY_ITEM_FLAG_BASICSUPPORT) 
                            ?   PropertyItemPropertyHandler 
                            :   NULL
                            );
                        addHere->SerializedSize     = 
                            (   (item2->Flags & PCPROPERTY_ITEM_FLAG_SERIALIZE) 
                            ?   ULONG(-1) 
                            :   0
                            );
                        addHere++;
                    }
                }

                ASSERT(addHere == newTable2 + itemCount);

                //
                // Free old allocated table.
                //
                if (propertySet->PropertyItem && ! *staticItem)
                {
                    ExFreePool(PVOID(propertySet->PropertyItem));
                }

                //
                // Install the new tables.
                //
                propertySet->PropertiesCount = itemCount;
                propertySet->PropertyItem    = newTable2;
                *staticItem = FALSE;
            }
        }
    }
    return ntStatus;
}

/*****************************************************************************
 * GenerateFormatFromRange()
 *****************************************************************************
 * Determine the particular format, based on the intersection of these 
 * two specific data ranges.  First ask the miniport, then fall back to
 * our own algorithm if the miniport doesn't handle it.
 */
NTSTATUS 
GenerateFormatFromRange (
    IN PIRP Irp,
    IN ULONG PinId,
    IN PKSDATARANGE MyDataRange,
    IN PKSDATARANGE ClientDataRange,
    IN ULONG OutputBufferLength,
    OUT PVOID ResultantFormat   OPTIONAL,
    OUT PULONG ResultantFormatLength)
{
    BOOLEAN                         bSpecifier;
    NTSTATUS                        Status;
    ULONG                           RequiredSize;
    
    PPROPERTY_CONTEXT pPropertyContext = PPROPERTY_CONTEXT(Irp->Tail.Overlay.DriverContext[3]);
    ASSERT(pPropertyContext);

    PSUBDEVICE pSubdevice = pPropertyContext->pSubdevice;
    ASSERT(pSubdevice);

    //
    // Give the miniport a chance to fill in the format structure
    //    
    Status = pSubdevice->DataRangeIntersection (PinId,
                                                ClientDataRange,
                                                MyDataRange,
                                                OutputBufferLength,
                                                ResultantFormat,
                                                ResultantFormatLength);
    
    //
    // return if the miniport filled out the structure.
    //
    if (Status != STATUS_NOT_IMPLEMENTED)
    {
        return Status;
    }

    //
    // In case the miniport didn't implement the DataRangeIntersection,
    // we provide a default handler here.
    //
    
    //
    // Check if there is a wildcard somewhere.
    //
    if (IsEqualGUIDAligned (ClientDataRange->MajorFormat, KSDATAFORMAT_TYPE_WILDCARD) ||
        IsEqualGUIDAligned (ClientDataRange->SubFormat, KSDATAFORMAT_SUBTYPE_WILDCARD) ||
        IsEqualGUIDAligned (ClientDataRange->Specifier, KSDATAFORMAT_SPECIFIER_WILDCARD))
    {
        // If the miniport exposed a WILDCARD, then it must implement an 
        // intersection handler, because it must provide the specific 
        // ideal matching data range for that WILDCARD.
        //
        return STATUS_NO_MATCH;
    }

    if (!IsEqualGUIDAligned (ClientDataRange->Specifier, KSDATAFORMAT_SPECIFIER_NONE))
    {
        //
        // The miniport did not resolve this format. Let's handle the specifiers
        // that we know.
        //
        if (!IsEqualGUIDAligned (ClientDataRange->Specifier, KSDATAFORMAT_SPECIFIER_DSOUND) &&
            !IsEqualGUIDAligned (ClientDataRange->Specifier, KSDATAFORMAT_SPECIFIER_WAVEFORMATEX))
        {
            return STATUS_NO_MATCH;
        }
        
        bSpecifier = TRUE;
        
        //
        // The specifier here defines the format of ClientDataRange
        // and the format expected to be returned in ResultantFormat.
        //
        if (IsEqualGUIDAligned (ClientDataRange->Specifier, KSDATAFORMAT_SPECIFIER_DSOUND))
        {
            RequiredSize = sizeof (KSDATAFORMAT_DSOUND);
        } 
        else 
        {
            RequiredSize = sizeof (KSDATAFORMAT_WAVEFORMATEX);
        }            
    } 
    else 
    {
        bSpecifier = FALSE;
        RequiredSize = sizeof (KSDATAFORMAT);
    }
            
    //
    // Validate return buffer size, if the request is only for the
    // size of the resultant structure, return it now.
    //
    if (!OutputBufferLength) 
    {
        *ResultantFormatLength = RequiredSize;
        return STATUS_BUFFER_OVERFLOW;
    } 
    else if (OutputBufferLength < RequiredSize) 
    {
        return STATUS_BUFFER_TOO_SMALL;
    }
    
    // There was a specifier ...
    if (bSpecifier) 
    {     
        PKSDATARANGE_AUDIO  myAudioRange,clientAudioRange;
        PKSDATAFORMAT       resultantFormat;
        PWAVEFORMATEX       resultantWaveFormatEx;
        
        myAudioRange = (PKSDATARANGE_AUDIO) MyDataRange;
        clientAudioRange = (PKSDATARANGE_AUDIO) ClientDataRange;
        resultantFormat = (PKSDATAFORMAT)ResultantFormat;
        
        //
        // Fill out the dataformat and other general fields.
        //
        *resultantFormat = *ClientDataRange;
        resultantFormat->FormatSize = RequiredSize;
        *ResultantFormatLength = RequiredSize;
        
        //
        // Fill out the DSOUND specific structure
        //
        if (IsEqualGUIDAligned (ClientDataRange->Specifier, KSDATAFORMAT_SPECIFIER_DSOUND)) 
        {
            PKSDATAFORMAT_DSOUND    resultantDSoundFormat;
            
            resultantDSoundFormat = (PKSDATAFORMAT_DSOUND)ResultantFormat;
            
            _DbgPrintF (DEBUGLVL_VERBOSE, ("returning KSDATAFORMAT_DSOUND format intersection"));
            
            //
            // DSound format capabilities are not expressed 
            // this way in KS, so we express no capabilities. 
            //
            resultantDSoundFormat->BufferDesc.Flags = 0 ;
            resultantDSoundFormat->BufferDesc.Control = 0 ;
            resultantWaveFormatEx = &resultantDSoundFormat->BufferDesc.WaveFormatEx;
        }
        else 
        {
            _DbgPrintF (DEBUGLVL_VERBOSE, ("returning KSDATAFORMAT_WAVEFORMATEX format intersection"));
        
            resultantWaveFormatEx = (PWAVEFORMATEX)((PKSDATAFORMAT)ResultantFormat + 1);
        }
        
        //
        // Return a format that intersects the given audio range, 
        // using our maximum support as the "best" format.
        // 
        resultantWaveFormatEx->wFormatTag = WAVE_FORMAT_PCM;
        
        resultantWaveFormatEx->nChannels = (USHORT) min (
                        myAudioRange->MaximumChannels,clientAudioRange->MaximumChannels);
        
        resultantWaveFormatEx->nSamplesPerSec = min (
                        myAudioRange->MaximumSampleFrequency,clientAudioRange->MaximumSampleFrequency);
        
        resultantWaveFormatEx->wBitsPerSample = (USHORT) min (
                        myAudioRange->MaximumBitsPerSample,clientAudioRange->MaximumBitsPerSample);
        
        resultantWaveFormatEx->nBlockAlign = (resultantWaveFormatEx->wBitsPerSample * resultantWaveFormatEx->nChannels) / 8;
        resultantWaveFormatEx->nAvgBytesPerSec = (resultantWaveFormatEx->nSamplesPerSec * resultantWaveFormatEx->nBlockAlign);
        resultantWaveFormatEx->cbSize = 0;
        ((PKSDATAFORMAT) ResultantFormat)->SampleSize = resultantWaveFormatEx->nBlockAlign;
        
        _DbgPrintF (DEBUGLVL_VERBOSE, ("Channels = %d",    resultantWaveFormatEx->nChannels));
        _DbgPrintF (DEBUGLVL_VERBOSE, ("Samples/sec = %d", resultantWaveFormatEx->nSamplesPerSec));
        _DbgPrintF (DEBUGLVL_VERBOSE, ("Bits/sample = %d", resultantWaveFormatEx->wBitsPerSample));
    } 
    else 
    {    // There was no specifier. Return only the KSDATAFORMAT structure.
        //
        // Copy the data format structure.
        //
        _DbgPrintF (DEBUGLVL_VERBOSE, ("returning default format intersection"));
            
        RtlCopyMemory (ResultantFormat, ClientDataRange, sizeof (KSDATAFORMAT));
        *ResultantFormatLength = sizeof (KSDATAFORMAT);
    }
    
    return STATUS_SUCCESS;
}

/*****************************************************************************
 * ValidateTypeAndSpecifier()
 *****************************************************************************
 * Find the data range that best matches the client's data range, given our
 * entire list of data ranges.  This might include wildcard-based ranges.
 *
 */
NTSTATUS
ValidateTypeAndSpecifier(
    IN PIRP Irp,
    IN ULONG PinId,
    IN PKSDATARANGE ClientDataRange,
    IN ULONG MyDataRangesCount,
    IN const PKSDATARANGE * MyDataRanges,
    IN ULONG OutputBufferLength,
    OUT PVOID ResultantFormat,
    OUT PULONG ResultantFormatLength
    )
{
    NTSTATUS     ntStatus;
    PKSDATARANGE aClientDataRange;

    //
    // Check the size of the structure.
    //
    if (ClientDataRange->FormatSize < sizeof (KSDATARANGE))
    {
        _DbgPrintF (DEBUGLVL_TERSE, ("Validating ClientDataRange: size < KSDATARANGE!"));
        return STATUS_INVALID_PARAMETER;
    }
    
    //
    // We default to no match.
    //
    ntStatus = STATUS_NO_MATCH;

    //
    // Go through all the dataranges in the validate list until we get a SUCCESS.
    //
    for (; MyDataRangesCount--; MyDataRanges++)
    {
        PKSDATARANGE myDataRange = *MyDataRanges;

        //
        // Verify that the correct major format, subformat and specifier (or wildcards)
        // are in the intersection.
        //
        
        if ((!IsEqualGUIDAligned(ClientDataRange->MajorFormat,myDataRange->MajorFormat) &&
             !IsEqualGUIDAligned(ClientDataRange->MajorFormat,KSDATAFORMAT_TYPE_WILDCARD)) ||
            (!IsEqualGUIDAligned(ClientDataRange->SubFormat,myDataRange->SubFormat) &&
             !IsEqualGUIDAligned(ClientDataRange->SubFormat,KSDATAFORMAT_SUBTYPE_WILDCARD)) || 
            (!IsEqualGUIDAligned(ClientDataRange->Specifier,myDataRange->Specifier) &&
             !IsEqualGUIDAligned(ClientDataRange->Specifier,KSDATAFORMAT_SPECIFIER_WILDCARD)))
        {
            continue;   //  no match and no WILDCARD, try the next one
        }
        
        //
        //  if not WILDCARD, then we ask the miniport to match this one exactly,
        //  else we manufacture a range and ask the miniport for a match from that.
        //
        aClientDataRange = ClientDataRange;  //  assume no WILDCARD for now, we ask the miniport to match this
        
        //
        // Handle the wildcards.
        //
        if (IsEqualGUIDAligned (ClientDataRange->MajorFormat,KSDATAFORMAT_TYPE_WILDCARD) ||
            IsEqualGUIDAligned (ClientDataRange->SubFormat,  KSDATAFORMAT_SUBTYPE_WILDCARD) ||
            IsEqualGUIDAligned (ClientDataRange->Specifier,  KSDATAFORMAT_SPECIFIER_WILDCARD))
        {
            //
            // We pass a faked datarange for the specifiers we know or we pass to the
            // miniport it's own datarange.
            //
            // We know the specifiers waveformatex and dsound.
            //
            if (IsEqualGUIDAligned (myDataRange->Specifier, KSDATAFORMAT_SPECIFIER_WAVEFORMATEX) ||
                IsEqualGUIDAligned (myDataRange->Specifier, KSDATAFORMAT_SPECIFIER_DSOUND))
            {
                KSDATARANGE_AUDIO   dr;

                //
                // Take the complete datarange from the driver.
                //
                dr.DataRange = *myDataRange;
                
                //
                // Fill in a HUGE data range (it asked for WILDCARD, after all!)
                //
                dr.MaximumChannels = 0x1FFF0;
                dr.MinimumBitsPerSample = 1;
                dr.MaximumBitsPerSample = 0x1FFF0;
                dr.MinimumSampleFrequency = 1;
                dr.MaximumSampleFrequency = 0x1FFFFFF0;
                
                aClientDataRange = (PKSDATARANGE)&dr;
            }
            else
            {
                //
                // We don't know this non-wave format (in the list of formats we supposedly support).
                // The miniport specified this format, so it is OK to pass it down.
                //
                aClientDataRange = myDataRange;
            }
        }

        //
        // Make sure KSDATARANGE_AUDIO is used, then see if there is a possible match.
        //
        if (IsEqualGUIDAligned (aClientDataRange->Specifier, KSDATAFORMAT_SPECIFIER_WAVEFORMATEX) ||
            IsEqualGUIDAligned (aClientDataRange->Specifier, KSDATAFORMAT_SPECIFIER_DSOUND))
        {
            if (aClientDataRange->FormatSize < sizeof (KSDATARANGE_AUDIO))
            {
                //
                // The datarange structure passed has no KSDATARANGE_AUDIO.
                //
                _DbgPrintF (DEBUGLVL_TERSE, ("Validating PCM ValidDataRange: size < KSDATARANGE_AUDIO!"));
                continue;   // not large enough, try the next one
            }

            //
            // Verify that we have an intersection with the specified format and 
            // our audio format dictated by our specific requirements.
            //
            _DbgPrintF (DEBUGLVL_VERBOSE, ("validating KSDATARANGE_AUDIO"));

            if ((((PKSDATARANGE_AUDIO)aClientDataRange)->MinimumSampleFrequency >
                 ((PKSDATARANGE_AUDIO)myDataRange)->MaximumSampleFrequency) ||
                (((PKSDATARANGE_AUDIO)aClientDataRange)->MaximumSampleFrequency <
                 ((PKSDATARANGE_AUDIO)myDataRange)->MinimumSampleFrequency) ||
                (((PKSDATARANGE_AUDIO)aClientDataRange)->MinimumBitsPerSample >
                 ((PKSDATARANGE_AUDIO)myDataRange)->MaximumBitsPerSample) ||
                (((PKSDATARANGE_AUDIO)aClientDataRange)->MaximumBitsPerSample <
                 ((PKSDATARANGE_AUDIO)myDataRange)->MinimumBitsPerSample))
            {
                continue;
            }
        }
        
        ntStatus = GenerateFormatFromRange (Irp, 
                                            PinId, 
                                            myDataRange, 
                                            aClientDataRange,
                                            OutputBufferLength,
                                            ResultantFormat,
                                            ResultantFormatLength);
        if ( NT_SUCCESS(ntStatus) 
          || (ntStatus == STATUS_BUFFER_OVERFLOW) 
          || (ntStatus == STATUS_BUFFER_TOO_SMALL)) 
        {
            break;  //  We found a good one, or we failed.
                    //  Either way we must leave.
        }
    }
    
    return ntStatus;
}

/*****************************************************************************
 * PinIntersectHandler()
 *****************************************************************************
 * This function is a data range callback for use with 
 * PropertyHandler_PinIntersection
 */
NTSTATUS
PinIntersectHandler
(
    IN      PIRP            Irp,
    IN      PKSP_PIN        Pin,
    IN      PKSDATARANGE    DataRange,
    OUT     PVOID           Data
)
{
    NTSTATUS    Status;
    ULONG       OutputBufferLength;
    
    PAGED_CODE();

    ASSERT(Irp);
    ASSERT(Pin);
    ASSERT(DataRange);

    PPROPERTY_CONTEXT pPropertyContext =
        PPROPERTY_CONTEXT(Irp->Tail.Overlay.DriverContext[3]);
    ASSERT(pPropertyContext);

    PSUBDEVICE_DESCRIPTOR pSubdeviceDescriptor =
        pPropertyContext->pSubdeviceDescriptor;
    ASSERT(pSubdeviceDescriptor);
    ASSERT(pSubdeviceDescriptor->PinDescriptors);
    ASSERT(Pin->PinId < pSubdeviceDescriptor->PinCount);

    PKSPIN_DESCRIPTOR pinDescriptor =
        &pSubdeviceDescriptor->PinDescriptors[Pin->PinId];

    ASSERT(pinDescriptor);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[PinIntersectHandler]"));
    
    OutputBufferLength = 
        IoGetCurrentIrpStackLocation( Irp )->
            Parameters.DeviceIoControl.OutputBufferLength;

    Status = 
        ValidateTypeAndSpecifier( 
            Irp,
            Pin->PinId,
            DataRange,
            pinDescriptor->DataRangesCount,
            pinDescriptor->DataRanges,
            OutputBufferLength,
            Data,
            PULONG(&Irp->IoStatus.Information) );
    
    if (!NT_SUCCESS( Status )) {
        _DbgPrintF( 
            DEBUGLVL_VERBOSE, 
            ("ValidateTypeAndSpecifier() returned %08x", Status) );
    }
    
    return Status;
}

/*****************************************************************************
 * PinPhysicalConnection()
 *****************************************************************************
 * Handles physical connection property access for the pin.
 */
static
NTSTATUS
PinPhysicalConnection
(
    IN      PIRP            Irp,
    IN      PKSP_PIN        Pin,
    OUT     PVOID           Data
)
{
    PAGED_CODE();

    ASSERT(Irp);
    ASSERT(Pin);

    PPROPERTY_CONTEXT pPropertyContext =
        PPROPERTY_CONTEXT(Irp->Tail.Overlay.DriverContext[3]);
    ASSERT(pPropertyContext);

    PSUBDEVICE Subdevice =
        pPropertyContext->pSubdevice;
    ASSERT(Subdevice);

    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
    ASSERT(irpSp);
    ASSERT(irpSp->DeviceObject);

    PDEVICE_CONTEXT deviceContext = 
        PDEVICE_CONTEXT(irpSp->DeviceObject->DeviceExtension);

    NTSTATUS        ntStatus = STATUS_NOT_FOUND;
    ULONG           outPin;
    PUNICODE_STRING outUnicodeString = NULL;

    for
    (
        PLIST_ENTRY entry = deviceContext->PhysicalConnectionList.Flink;
        entry != &deviceContext->PhysicalConnectionList;
        entry = entry->Flink
    )
    {
        PPHYSICALCONNECTION connection = PPHYSICALCONNECTION(entry);

        if  (   (connection->FromSubdevice == Subdevice)
            &&  (connection->FromPin == Pin->PinId)
            )
        {
            outPin = connection->ToPin;

            if (connection->ToString)
            {
                outUnicodeString = connection->ToString;
            }
            else
            {
                ULONG ulIndex = 
                    SubdeviceIndex(irpSp->DeviceObject,connection->ToSubdevice);

                if (ulIndex != ULONG(-1))
                {
                    ntStatus = STATUS_SUCCESS;
                    outUnicodeString = &deviceContext->SymbolicLinkNames[ulIndex];
                }
            }
            break;
        }
        else
        if  (   (connection->ToSubdevice == Subdevice)
            &&  (connection->ToPin == Pin->PinId)
            )
        {
            outPin = connection->FromPin;

            if (connection->FromString)
            {
                outUnicodeString = connection->FromString;
            }
            else
            {
                ULONG ulIndex = 
                    SubdeviceIndex(irpSp->DeviceObject,connection->FromSubdevice);

                if (ulIndex != ULONG(-1))
                {
                    ntStatus = STATUS_SUCCESS;
                    outUnicodeString = &deviceContext->SymbolicLinkNames[ulIndex];
                }
            }
            break;
        }
    }

    if (!outUnicodeString)
    {
        ntStatus = STATUS_NOT_FOUND;
    }

    if (NT_SUCCESS(ntStatus))
    {
        ULONG outSize;
        outSize = FIELD_OFFSET(KSPIN_PHYSICALCONNECTION,SymbolicLinkName[0]);
        outSize += (outUnicodeString->Length + sizeof(UNICODE_NULL));

        //
        // Validate return buffer size.
        //
        ULONG outputBufferLength =
            IoGetCurrentIrpStackLocation(Irp)->
                Parameters.DeviceIoControl.OutputBufferLength;

        if (!outputBufferLength)
        {
            Irp->IoStatus.Information = outSize;
            ntStatus = STATUS_BUFFER_OVERFLOW;
        }
        else
        if (outputBufferLength < outSize)
        {
            ntStatus = STATUS_BUFFER_TOO_SMALL;
        }
        else
        {
            PKSPIN_PHYSICALCONNECTION out = PKSPIN_PHYSICALCONNECTION(Data);

            out->Size = outSize;
            out->Pin  = outPin;
            RtlCopyMemory
            (
                out->SymbolicLinkName,
                outUnicodeString->Buffer,
                outUnicodeString->Length
            );
            out->SymbolicLinkName[outUnicodeString->Length / sizeof(WCHAR)] = 0;
            Irp->IoStatus.Information = outSize;
        }
    }

    return ntStatus;
}

/*****************************************************************************
 * PinCountHandler()
 *****************************************************************************
 * Handles pin count access for the pin.
 */
void PinCountHandler
(   IN      PPROPERTY_CONTEXT   pPropertyContext,
    IN      ULONG               pinId
)
{
    PAGED_CODE();

    ASSERT(pPropertyContext);

    PSUBDEVICE_DESCRIPTOR pSubdeviceDescriptor = pPropertyContext->pSubdeviceDescriptor;
    ASSERT(pSubdeviceDescriptor);

    PSUBDEVICE Subdevice = pPropertyContext->pSubdevice;
    ASSERT(Subdevice);

    Subdevice->PinCount( pinId, &(pSubdeviceDescriptor->PinInstances[pinId].FilterNecessary),
                                &(pPropertyContext->pulPinInstanceCounts[pinId]),
                                &(pSubdeviceDescriptor->PinInstances[pinId].FilterPossible),
                                &(pSubdeviceDescriptor->PinInstances[pinId].GlobalCurrent),
                                &(pSubdeviceDescriptor->PinInstances[pinId].GlobalPossible) );
}

/*****************************************************************************
 * PcPinPropertyHandler()
 *****************************************************************************
 * Property handler for pin properties on the filter.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcPinPropertyHandler
(   IN      PIRP                    pIrp,
    IN      PKSP_PIN                pKsPPin,
    IN OUT  PVOID                   pvData
)
{
    PAGED_CODE();

    ASSERT(pIrp);
    ASSERT(pKsPPin);

    PPROPERTY_CONTEXT pPropertyContext =
        PPROPERTY_CONTEXT(pIrp->Tail.Overlay.DriverContext[3]);
    ASSERT(pPropertyContext);

    PSUBDEVICE_DESCRIPTOR pSubdeviceDescriptor =
        pPropertyContext->pSubdeviceDescriptor;
    ASSERT(pSubdeviceDescriptor);

    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;

    if 
    (   (pKsPPin->Property.Id != KSPROPERTY_PIN_CTYPES)
    &&  (pKsPPin->PinId >= pSubdeviceDescriptor->PinCount)
    )
    {
        ntStatus = STATUS_INVALID_PARAMETER;
    }
    else
    {
        switch (pKsPPin->Property.Id)
        {
        case KSPROPERTY_PIN_CTYPES:
        case KSPROPERTY_PIN_DATAFLOW:
        case KSPROPERTY_PIN_DATARANGES:
        case KSPROPERTY_PIN_INTERFACES:
        case KSPROPERTY_PIN_MEDIUMS:
        case KSPROPERTY_PIN_COMMUNICATION:
        case KSPROPERTY_PIN_CATEGORY:
        case KSPROPERTY_PIN_NAME:
            ntStatus =
                KsPinPropertyHandler
                (
                    pIrp,
                    PKSPROPERTY(pKsPPin),
                    pvData,
                    pSubdeviceDescriptor->PinCount,
                    pSubdeviceDescriptor->PinDescriptors
                );
            break;

        case KSPROPERTY_PIN_DATAINTERSECTION:
            ntStatus =
                KsPinDataIntersection
                ( 
                    pIrp,
                    pKsPPin,
                    pvData,
                    pSubdeviceDescriptor->PinCount,
                    pSubdeviceDescriptor->PinDescriptors,
                    PinIntersectHandler 
                );
            break;

        case KSPROPERTY_PIN_CINSTANCES:
            if (pPropertyContext->pulPinInstanceCounts)
            {
                PinCountHandler(pPropertyContext,pKsPPin->PinId);

                PKSPIN_CINSTANCES(pvData)->PossibleCount = 
                    pSubdeviceDescriptor->PinInstances[pKsPPin->PinId].FilterPossible;

                PKSPIN_CINSTANCES(pvData)->CurrentCount = 
                    pPropertyContext->pulPinInstanceCounts[pKsPPin->PinId];

                pIrp->IoStatus.Information = sizeof(KSPIN_CINSTANCES);

                ntStatus = STATUS_SUCCESS;
            }
            break;

        case KSPROPERTY_PIN_GLOBALCINSTANCES:
            if (pPropertyContext->pulPinInstanceCounts)
            {
                PinCountHandler(pPropertyContext,pKsPPin->PinId);
            }
            
            PKSPIN_CINSTANCES(pvData)->PossibleCount = 
                pSubdeviceDescriptor->PinInstances[pKsPPin->PinId].GlobalPossible;

            PKSPIN_CINSTANCES(pvData)->CurrentCount = 
                pSubdeviceDescriptor->PinInstances[pKsPPin->PinId].GlobalCurrent;

            pIrp->IoStatus.Information = sizeof(KSPIN_CINSTANCES);

            ntStatus = STATUS_SUCCESS;
            break;

        case KSPROPERTY_PIN_NECESSARYINSTANCES:
            if (pPropertyContext->pulPinInstanceCounts)
            {
                PinCountHandler(pPropertyContext,pKsPPin->PinId);

                *PULONG(pvData) = pSubdeviceDescriptor->PinInstances[pKsPPin->PinId].FilterNecessary;

                pIrp->IoStatus.Information = sizeof(ULONG);

                ntStatus = STATUS_SUCCESS;
            }
            break;

        case KSPROPERTY_PIN_PHYSICALCONNECTION:
            ntStatus =
                PinPhysicalConnection
                (
                    pIrp,
                    pKsPPin,
                    pvData
                );
            break;

        default:
            ntStatus = STATUS_NOT_FOUND;
            break;
        }
    }

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\main\registry.cpp ===
/*****************************************************************************
 * registry.cpp - registry key object implementation
 *****************************************************************************
 * Copyright (c) 1997-2000 Microsoft Corporation.  All rights reserved.
 */

#include "private.h"





/*****************************************************************************
 * Factory.
 */

#pragma code_seg("PAGE")

/*****************************************************************************
 * CreateRegistryKey()
 *****************************************************************************
 * Creates a registry key object.
 */
NTSTATUS
CreateRegistryKey
(
    OUT     PUNKNOWN *  Unknown,
    IN      REFCLSID,
    IN      PUNKNOWN    UnknownOuter    OPTIONAL,
    IN      POOL_TYPE   PoolType
)
{
    PAGED_CODE();

    ASSERT(Unknown);

    _DbgPrintF(DEBUGLVL_LIFETIME,("Creating REGISTRYKEY"));

    STD_CREATE_BODY
    (
        CRegistryKey,
        Unknown,
        UnknownOuter,
        PoolType
    );
}

/*****************************************************************************
 * PcNewRegistryKey()
 *****************************************************************************
 * Creates and initializes a registry key object.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcNewRegistryKey
(
    OUT     PREGISTRYKEY *      OutRegistryKey,
    IN      PUNKNOWN            OuterUnknown        OPTIONAL,
    IN      ULONG               RegistryKeyType,
    IN      ACCESS_MASK         DesiredAccess,
    IN      PVOID               DeviceObject        OPTIONAL,
    IN      PVOID               SubDevice           OPTIONAL,
    IN      POBJECT_ATTRIBUTES  ObjectAttributes    OPTIONAL,
    IN      ULONG               CreateOptions       OPTIONAL,
    OUT     PULONG              Disposition         OPTIONAL
)
{
    PAGED_CODE();

    ASSERT(OutRegistryKey);

    //
    // Validate Parameters.
    //
    if (NULL == OutRegistryKey)
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("PcNewRegistryKey : Invalid Parameter."));
        return STATUS_INVALID_PARAMETER;
    }

    PUNKNOWN    unknown;
    NTSTATUS    ntStatus =
        CreateRegistryKey
        (
            &unknown,
            GUID_NULL,
            OuterUnknown,
            PagedPool
        );

    if (NT_SUCCESS(ntStatus))
    {
        PREGISTRYKEYINIT RegistryKey;
        ntStatus =
            unknown->QueryInterface
            (
                IID_IRegistryKey,
                (PVOID *) &RegistryKey
            );

        if (NT_SUCCESS(ntStatus))
        {
            ntStatus = RegistryKey->Init( RegistryKeyType,
                                          DesiredAccess,
                                          PDEVICE_OBJECT(DeviceObject),
                                          PSUBDEVICE(SubDevice),
                                          ObjectAttributes,
                                          CreateOptions,
                                          Disposition );
            if (NT_SUCCESS(ntStatus))
            {
                *OutRegistryKey = RegistryKey;
            } else
            {
                RegistryKey->Release();
            }
        }

        unknown->Release();
    }

    return ntStatus;
}

/*****************************************************************************
 * Member functions.
 */

/*****************************************************************************
 * CRegistryKey::~CRegistryKey()
 *****************************************************************************
 * Destructor.
 */
CRegistryKey::
~CRegistryKey
(   void
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_LIFETIME,("Destroying REGISTRYKEY (0x%08x)",this));

    if ( FALSE == m_KeyDeleted )
    {
        ASSERT(m_KeyHandle);
        ZwClose(m_KeyHandle);
    }
    else 
    {
        ASSERT(!m_KeyHandle);
    }
}

/*****************************************************************************
 * CRegistryKey::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.
 */
STDMETHODIMP_(NTSTATUS)
CRegistryKey::
NonDelegatingQueryInterface
(
    REFIID  Interface,
    PVOID * Object
)
{
    PAGED_CODE();

    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface,IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(this));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IRegistryKey))
    {
        *Object = PVOID(PREGISTRYKEYINIT(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

/*****************************************************************************
 * CRegistryKey::Init()
 *****************************************************************************
 * Initializes a registry key object.
 */
STDMETHODIMP_(NTSTATUS)
CRegistryKey::
Init
(
    IN      ULONG               RegistryKeyType,
    IN      ACCESS_MASK         DesiredAccess,
    IN      PDEVICE_OBJECT      DeviceObject        OPTIONAL,
    IN      PSUBDEVICE          SubDevice           OPTIONAL,
    IN      POBJECT_ATTRIBUTES  ObjectAttributes    OPTIONAL,
    IN      ULONG               CreateOptions       OPTIONAL,
    OUT     PULONG              Disposition         OPTIONAL
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_LIFETIME,("Initializing REGISTRYKEY (0x%08x)",this));

    NTSTATUS ntStatus;

    m_KeyDeleted = TRUE;
    m_GeneralKey = FALSE;
    m_KeyHandle = NULL;

    switch(RegistryKeyType)
    {
        case GeneralRegistryKey:
            ASSERT(ObjectAttributes);

            ntStatus = ZwCreateKey( &m_KeyHandle,
                                    DesiredAccess,
                                    ObjectAttributes,
                                    0,
                                    NULL,
                                    CreateOptions,
                                    Disposition );
            if (NT_SUCCESS(ntStatus))
            {
                ASSERT(m_KeyHandle);
                m_GeneralKey = TRUE;
                m_KeyDeleted = FALSE;
            }
            else
            {
                ASSERT(!m_KeyHandle);
            }
            break;

        case DeviceRegistryKey:
        case DriverRegistryKey:
        case HwProfileRegistryKey:
            {
                ASSERT(DeviceObject);
    
                ULONG DevInstKeyType;
    
                if (RegistryKeyType == DeviceRegistryKey)
                {
                    DevInstKeyType = PLUGPLAY_REGKEY_DEVICE;
                } else if(RegistryKeyType == DriverRegistryKey)
                {
                    DevInstKeyType = PLUGPLAY_REGKEY_DRIVER;
                } else
                {
                    DevInstKeyType = PLUGPLAY_REGKEY_CURRENT_HWPROFILE;
                }
    
                PDEVICE_CONTEXT deviceContext =
                    PDEVICE_CONTEXT(DeviceObject->DeviceExtension);
                
                PDEVICE_OBJECT PhysicalDeviceObject = deviceContext->PhysicalDeviceObject;
                
                ntStatus = IoOpenDeviceRegistryKey( PhysicalDeviceObject,
                                                    DevInstKeyType,
                                                    DesiredAccess,
                                                    &m_KeyHandle );
                if (NT_SUCCESS(ntStatus))
                {
                    ASSERT(m_KeyHandle);
                    m_GeneralKey = FALSE;
                    m_KeyDeleted = FALSE;
                }
                else
                {
                    ASSERT(!m_KeyHandle);
                }
            }
            break;

        case DeviceInterfaceRegistryKey:
            {
                ASSERT(DeviceObject);
                ASSERT(SubDevice);

                ULONG Index = SubdeviceIndex( DeviceObject,
                                              SubDevice );

                if(Index != ULONG(-1))
                {
                    PDEVICE_CONTEXT deviceContext =
                        PDEVICE_CONTEXT(DeviceObject->DeviceExtension);

                    PUNICODE_STRING SymbolicLinkName = &deviceContext->SymbolicLinkNames[Index];
    
                    ntStatus = IoOpenDeviceInterfaceRegistryKey( SymbolicLinkName,
                                                                 DesiredAccess,
                                                                 &m_KeyHandle );

                    if (NT_SUCCESS(ntStatus))
                    {
                        ASSERT(m_KeyHandle);
                        m_GeneralKey = FALSE;
                        m_KeyDeleted = FALSE;
                    }
                    else
                    {
                        ASSERT(!m_KeyHandle);
                    }
                } else
                {
                    ntStatus = STATUS_INVALID_PARAMETER;
                }
            }

        default:
            ntStatus = STATUS_INVALID_PARAMETER;
            break;
    }

    return ntStatus;
}

/*****************************************************************************
 * CRegistryKey::QueryKey()
 *****************************************************************************
 * Queries a registry key.
 */
STDMETHODIMP_(NTSTATUS)
CRegistryKey::
QueryKey
(
    IN      KEY_INFORMATION_CLASS   KeyInformationClass,
    OUT     PVOID                   KeyInformation,
    IN      ULONG                   Length,
    OUT     PULONG                  ResultLength
)
{
    PAGED_CODE();

    NTSTATUS ntStatus;

    if ( m_KeyDeleted )
    {
        ntStatus = STATUS_INVALID_HANDLE;
        ASSERT(!m_KeyHandle);
    } 
    else
    {
        ASSERT(m_KeyHandle);
        ntStatus = ZwQueryKey( m_KeyHandle,
                               KeyInformationClass,
                               KeyInformation,
                               Length,
                               ResultLength );
    }

    return ntStatus;
}

/*****************************************************************************
 * CRegistryKey::EnumerateKey()
 *****************************************************************************
 * Enumerates a registry key.
 */
STDMETHODIMP_(NTSTATUS)
CRegistryKey::
EnumerateKey
(
    IN      ULONG                   Index,
    IN      KEY_INFORMATION_CLASS   KeyInformationClass,
    OUT     PVOID                   KeyInformation,
    IN      ULONG                   Length,
    OUT     PULONG                  ResultLength
)
{
    PAGED_CODE();

    NTSTATUS ntStatus;

    if ( m_KeyDeleted )
    {
        ntStatus = STATUS_INVALID_HANDLE;
        ASSERT(!m_KeyHandle);
    } 
    else
    {
        ASSERT(m_KeyHandle);
        ntStatus = ZwEnumerateKey( m_KeyHandle,
                                   Index,
                                   KeyInformationClass,
                                   KeyInformation,
                                   Length,
                                   ResultLength );
    }

    return ntStatus;
}

/*****************************************************************************
 * CRegistryKey::QueryValueKey()
 *****************************************************************************
 * Queries a registry value key.
 */
STDMETHODIMP_(NTSTATUS)
CRegistryKey::
QueryValueKey
(
    IN      PUNICODE_STRING             ValueName,
    IN      KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    OUT     PVOID                       KeyValueInformation,
    IN      ULONG                       Length,
    OUT     PULONG                      ResultLength
)
{
    PAGED_CODE();

    NTSTATUS ntStatus;

    if ( m_KeyDeleted )
    {
        ntStatus = STATUS_INVALID_HANDLE;
        ASSERT(!m_KeyHandle);
    } 
    else
    {
        ASSERT(m_KeyHandle);
        ntStatus = ZwQueryValueKey( m_KeyHandle,
                                    ValueName,
                                    KeyValueInformationClass,
                                    KeyValueInformation,
                                    Length,
                                    ResultLength );
    }

    return ntStatus;
}

/*****************************************************************************
 * CRegistryKey::EnumerateValueKey()
 *****************************************************************************
 * Enumerates a registry value key.
 */
STDMETHODIMP_(NTSTATUS)
CRegistryKey::
EnumerateValueKey
(
    IN      ULONG                       Index,
    IN      KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    OUT     PVOID                       KeyValueInformation,
    IN      ULONG                       Length,
    OUT     PULONG                      ResultLength
)
{
    PAGED_CODE();

    NTSTATUS ntStatus;

    if ( m_KeyDeleted )
    {
        ntStatus = STATUS_INVALID_HANDLE;
        ASSERT(!m_KeyHandle);
    } 
    else
    {
        ASSERT(m_KeyHandle);
        ntStatus = ZwEnumerateValueKey( m_KeyHandle,
                                        Index,
                                        KeyValueInformationClass,
                                        KeyValueInformation,
                                        Length,
                                        ResultLength );
    }

    return ntStatus;
}

/*****************************************************************************
 * CRegistryKey::SetValueKey()
 *****************************************************************************
 * Sets a registry value key.
 */
STDMETHODIMP_(NTSTATUS)
CRegistryKey::
SetValueKey
(
    IN      PUNICODE_STRING         ValueName   OPTIONAL,
    IN      ULONG                   Type,
    IN      PVOID                   Data,
    IN      ULONG                   DataSize
)
{
    PAGED_CODE();

    NTSTATUS ntStatus;

    if ( m_KeyDeleted )
    {
        ntStatus = STATUS_INVALID_HANDLE;
        ASSERT(!m_KeyHandle);
    } 
    else
    {
        ASSERT(m_KeyHandle);
        ntStatus = ZwSetValueKey( m_KeyHandle,
                                  ValueName,
                                  0,
                                  Type,
                                  Data,
                                  DataSize );
    }

    return ntStatus;
}

/*****************************************************************************
 * CRegistryKey::QueryRegistryValues()
 *****************************************************************************
 * Queries several registry values with a single call.
 */
STDMETHODIMP_(NTSTATUS)
CRegistryKey::
QueryRegistryValues
(
    IN      PRTL_QUERY_REGISTRY_TABLE   QueryTable,
    IN      PVOID                       Context OPTIONAL
)
{
    PAGED_CODE();

    ASSERT(QueryTable);

    NTSTATUS ntStatus;

    if ( m_KeyDeleted )
    {
        ntStatus = STATUS_INVALID_HANDLE;
        ASSERT(!m_KeyHandle);
    } 
    else
    {
        ASSERT(m_KeyHandle);
        ntStatus = RtlQueryRegistryValues( RTL_REGISTRY_HANDLE,
                                           PWSTR(m_KeyHandle),
                                           QueryTable,
                                           Context,
                                           NULL );
    }

    return ntStatus;
}


/*****************************************************************************
 * CRegistryKey::NewSubKey()
 *****************************************************************************
 * Opens/creates a subkey for an open registry key.
 */
STDMETHODIMP_(NTSTATUS)
CRegistryKey::
NewSubKey
(
    OUT     PREGISTRYKEY *      RegistrySubKey,
    IN      PUNKNOWN            OuterUnknown,
    IN      ACCESS_MASK         DesiredAccess,
    IN      PUNICODE_STRING     SubKeyName,
    IN      ULONG               CreateOptions,
    OUT     PULONG              Disposition     OPTIONAL
)
{
    PAGED_CODE();

    ASSERT(RegistrySubKey);
    ASSERT(SubKeyName);

    OBJECT_ATTRIBUTES ObjectAttributes;

    ASSERT(m_KeyHandle);
    InitializeObjectAttributes( &ObjectAttributes,
                                SubKeyName,
                                OBJ_INHERIT | OBJ_CASE_INSENSITIVE | OBJ_OPENIF,
                                m_KeyHandle,
                                NULL );

    
    return PcNewRegistryKey(    RegistrySubKey,
                                OuterUnknown,
                                GeneralRegistryKey,
                                DesiredAccess,
                                NULL,
                                NULL,
                                &ObjectAttributes,
                                CreateOptions,
                                Disposition );
}

/*****************************************************************************
 * CRegistryKey::DeleteKey()
 *****************************************************************************
 * Deletes a registry key.
 */
STDMETHODIMP_(NTSTATUS)
CRegistryKey::
DeleteKey
(
)
{
    PAGED_CODE();

    NTSTATUS ntStatus;

    if ( m_KeyDeleted )
    {
        ntStatus = STATUS_INVALID_HANDLE;
        ASSERT(!m_KeyHandle);
    } 
    else if ( FALSE == m_GeneralKey )
    {
        ntStatus = STATUS_ACCESS_DENIED;
    } 
    else
    {
        ASSERT(m_KeyHandle);
        ntStatus = ZwDeleteKey( m_KeyHandle );
        
        if(NT_SUCCESS( ntStatus ))
        {
            m_KeyDeleted = TRUE;
            m_KeyHandle = NULL;
        }
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE,("ZwDeleteKey failed for %x!!!",m_KeyHandle));
        }
    }
    return ntStatus;
}

/*****************************************************************************
 * PcGetDeviceProperty()
 *****************************************************************************
 * This wraps a call to IoGetDeviceProperty.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcGetDeviceProperty
(
    IN  PVOID                       DeviceObject,
    IN  DEVICE_REGISTRY_PROPERTY    DeviceProperty,
    IN  ULONG                       BufferLength,
    OUT PVOID                       PropertyBuffer,
    OUT PULONG                      ResultLength
)
{
    PDEVICE_CONTEXT deviceContext =
        PDEVICE_CONTEXT(PDEVICE_OBJECT(DeviceObject)->DeviceExtension);
    
    PDEVICE_OBJECT PhysicalDeviceObject = deviceContext->PhysicalDeviceObject;

    return IoGetDeviceProperty( PhysicalDeviceObject,
                                DeviceProperty,
                                BufferLength,
                                PropertyBuffer,
                                ResultLength );
}

#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\main\porttbl.cpp ===
/*****************************************************************************
 * porttbl.c - WDM port class driver port table
 *****************************************************************************
 * Copyright (c) 1996-2000 Microsoft Corporation.  All rights reserved.
 *
 * 11/19/96 Dale Sather
 *
 */

#define PUT_GUIDS_HERE
#include "private.h"



extern NTSTATUS CreateMiniportMidiUart(PUNKNOWN *Unknown,               REFCLSID  ClassID,
                                       PUNKNOWN  UnknownOuter OPTIONAL, POOL_TYPE PoolType);

extern NTSTATUS CreateMiniportDMusUART(PUNKNOWN *Unknown,               REFCLSID  ClassID,
                                       PUNKNOWN  UnknownOuter OPTIONAL, POOL_TYPE PoolType);

extern NTSTATUS CreateMiniportMidiFM(  PUNKNOWN *Unknown,               REFCLSID  ClassID,
                                       PUNKNOWN  UnknownOuter OPTIONAL, POOL_TYPE PoolType);

// ==============================================================================
// MiniportDrivers
// Structures which map the miniport class ID to the create functions.
// ==============================================================================
PORT_DRIVER
MiniportDriverUart =
{
    &CLSID_MiniportDriverUart,
    CreateMiniportMidiUart
};
PORT_DRIVER
MiniportDriverDMusUART =
{
    &CLSID_MiniportDriverDMusUART,
    CreateMiniportDMusUART
};
PORT_DRIVER
MiniportDriverFmSynth =
{
    &CLSID_MiniportDriverFmSynth,
    CreateMiniportMidiFM
};
PORT_DRIVER
MiniportDriverFmSynthWithVol =
// Same as above, but for miniport that also features volume node.
// Sausage McMuffin With Egg.
{
    &CLSID_MiniportDriverFmSynthWithVol,
    CreateMiniportMidiFM
};


extern PORT_DRIVER PortDriverWaveCyclic;
extern PORT_DRIVER PortDriverWavePci;
extern PORT_DRIVER PortDriverTopology;
extern PORT_DRIVER PortDriverMidi;
extern PORT_DRIVER PortDriverDMus;


PPORT_DRIVER PortDriverTable[] =
{
    &PortDriverWaveCyclic,
    &PortDriverWavePci,
    &PortDriverTopology,
    &PortDriverMidi,
    &PortDriverDMus,
    &MiniportDriverUart,
    &MiniportDriverFmSynth,
    &MiniportDriverFmSynthWithVol,
    &MiniportDriverDMusUART
};

#pragma code_seg("PAGE")

/*****************************************************************************
 * GetClassInfo()
 *****************************************************************************
 * Get information regarding a class.
 * TODO:  Eliminate this in favor of object servers.
 */
NTSTATUS
GetClassInfo
(
	IN	REFCLSID            ClassId,
    OUT PFNCREATEINSTANCE * Create
)
{
    PAGED_CODE();

    ASSERT(Create);

    PPORT_DRIVER *  portDriver = PortDriverTable;

    for
    (
        ULONG count = SIZEOF_ARRAY(PortDriverTable);
        count--;
        portDriver++
    )
    {
        if (IsEqualGUIDAligned(ClassId,*(*portDriver)->ClassId))
        {
            *Create = (*portDriver)->Create;
            return STATUS_SUCCESS;
        }
    }

    return STATUS_NOT_FOUND;
}

#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\main\portcls.cpp ===
/*****************************************************************************
 * portcls.cpp - WDM Streaming port class driver
 *****************************************************************************
 * Copyright (c) 1996-2000 Microsoft Corporation.  All rights reserved.
 */

#define KSDEBUG_INIT
#include "private.h"
#include "perf.h"

#ifdef TIME_BOMB
#include "..\..\..\timebomb\timebomb.c"
#endif

/*****************************************************************************
 * Referenced forward.
 */


NTSTATUS
DispatchPnp
(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
);

NTSTATUS
DispatchSystemControl
(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
);

#define PORTCLS_DRIVER_EXTENSION_ID 0x0ABADCAFE

/*****************************************************************************
 * Globals
 */


/*****************************************************************************
 * Functions.
 */

// TODO: put this someplace better?
int __cdecl
_purecall( void )
{
    ASSERT(!"Pure virtual function called");
    return 0;
}

#pragma code_seg("PAGE")

/*****************************************************************************
 * DriverEntry()
 *****************************************************************************
 * Never called.  All drivers must have one of these, so...
 */
extern "C"
NTSTATUS
DriverEntry
(
    IN      PDRIVER_OBJECT  DriverObject,
    IN      PUNICODE_STRING RegistryPath
)
{
    PAGED_CODE();

    ASSERT(! "Port Class DriverEntry was called");

//
//  Should never be called, but timebombing is added here for completeness.
//
#ifdef TIME_BOMB
    if (HasEvaluationTimeExpired())
    {
        _DbgPrintF(DEBUGLVL_TERSE,("This evaluation copy of PortCls has expired!!"));
        return STATUS_EVALUATION_EXPIRATION;
    }
#endif

    return STATUS_SUCCESS;
}

/*****************************************************************************
 * DllInitialize()
 *****************************************************************************
 * Entry point for export library drivers.
 */
extern "C"
NTSTATUS DllInitialize(PVOID foo)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE,("DllInitialize"));

#ifdef TIME_BOMB
    if (HasEvaluationTimeExpired())
    {
        _DbgPrintF(DEBUGLVL_TERSE,("This evaluation copy of PortCls has expired!!"));
        return STATUS_EVALUATION_EXPIRATION;
    }
#endif

#if kEnableDebugLogging

    if (!gPcDebugLog)
    {
        gPcDebugLog = (ULONG_PTR *)ExAllocatePoolWithTag(NonPagedPool,(kNumDebugLogEntries * kNumULONG_PTRsPerEntry * sizeof(ULONG_PTR)),'lDcP');   //  'PcDl'
        if (gPcDebugLog)
        {
            RtlZeroMemory(PVOID(gPcDebugLog),kNumDebugLogEntries * kNumULONG_PTRsPerEntry * sizeof(ULONG_PTR));
        }
        gPcDebugLogIndex = 0;
    }

    DebugLog(1,0,0,0);
#endif // kEnableDebugLogging

    return STATUS_SUCCESS;
}

/*****************************************************************************
 * DllUnload()
 *****************************************************************************
 * Allow unload.
 */
extern "C"
NTSTATUS
DllUnload
(   void
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE,("DllUnload"));

#if kEnableDebugLogging

    if (gPcDebugLog)
    {
        ExFreePool(gPcDebugLog);
        gPcDebugLog = NULL;
    }

#endif // kEnableDebugLogging

    return STATUS_SUCCESS;
}

#if kEnableDebugLogging

ULONG_PTR *gPcDebugLog = NULL;
DWORD      gPcDebugLogIndex = 0;

void PcDebugLog(ULONG_PTR param1,ULONG_PTR param2,ULONG_PTR param3,ULONG_PTR param4)
{
    if (gPcDebugLog)
    {
        gPcDebugLog[(gPcDebugLogIndex * kNumULONG_PTRsPerEntry)] = param1;
        gPcDebugLog[(gPcDebugLogIndex * kNumULONG_PTRsPerEntry) + 1] = param2;
        gPcDebugLog[(gPcDebugLogIndex * kNumULONG_PTRsPerEntry) + 2] = param3;
        gPcDebugLog[(gPcDebugLogIndex * kNumULONG_PTRsPerEntry) + 3] = param4;
        if (InterlockedIncrement(PLONG(&gPcDebugLogIndex)) >= kNumDebugLogEntries)
        {
            InterlockedExchange(PLONG(&gPcDebugLogIndex), 0);
        }
    }
}

#endif // kEnableDebugLogging

/*****************************************************************************
 * DupUnicodeString()
 *****************************************************************************
 * Duplicates a unicode string.
 */
NTSTATUS
DupUnicodeString
(
    OUT     PUNICODE_STRING *   ppUnicodeString,
    IN      PUNICODE_STRING     pUnicodeString  OPTIONAL
)
{
    PAGED_CODE();

    ASSERT(ppUnicodeString);

    NTSTATUS ntStatus = STATUS_SUCCESS;

    if (pUnicodeString)
    {
        PUNICODE_STRING pUnicodeStringNew =
            new(PagedPool,'sUcP') UNICODE_STRING;

        if (pUnicodeStringNew)
        {
            pUnicodeStringNew->Length        = pUnicodeString->Length;
            pUnicodeStringNew->MaximumLength = pUnicodeString->MaximumLength;

            if (pUnicodeString->Buffer)
            {
                pUnicodeStringNew->Buffer =
                    new(PagedPool,'sUcP')
                        WCHAR[pUnicodeString->MaximumLength / sizeof(WCHAR)];

                if (pUnicodeStringNew->Buffer)
                {
                    RtlCopyMemory
                    (
                        pUnicodeStringNew->Buffer,
                        pUnicodeString->Buffer,
                        pUnicodeString->Length
                    );

                    *ppUnicodeString = pUnicodeStringNew;
                }
                else
                {
                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                    delete pUnicodeStringNew;
                }
            }
            else
            {
                pUnicodeStringNew->Buffer = NULL;

                *ppUnicodeString = pUnicodeStringNew;
            }
        }
        else
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else
    {
        *ppUnicodeString = NULL;
    }

    return ntStatus;
}

/*****************************************************************************
 * DelUnicodeString()
 *****************************************************************************
 * Deletes a unicode string that was allocated using ExAllocatePool().
 */
VOID
DelUnicodeString
(
    IN      PUNICODE_STRING     pUnicodeString  OPTIONAL
)
{
    if (pUnicodeString)
    {
        if (pUnicodeString->Buffer)
        {
            delete [] pUnicodeString->Buffer;
        }

        delete pUnicodeString;
    }
}

VOID
KsoNullDriverUnload(
    IN PDRIVER_OBJECT   DriverObject
    )
/*++

Routine Description:

    Default function which drivers can use when they do not have anything to do
    in their unload function, but must still allow the device to be unloaded by
    its presence.

Arguments:

    DriverObject -
        Contains the driver object for this device.

Return Values:

    Nothing.

--*/
{
    _DbgPrintF(DEBUGLVL_VERBOSE,("KsoNullDriverUnload"));
    if (DriverObject->DeviceObject)
    {
        _DbgPrintF(DEBUGLVL_TERSE,("KsoNullDriverUnload  DEVICES EXIST"));
    }
}

/*****************************************************************************
 * PcInitializeAdapterDriver()
 *****************************************************************************
 * Initializes an adapter driver.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcInitializeAdapterDriver
(
    IN      PDRIVER_OBJECT      DriverObject,
    IN      PUNICODE_STRING     RegistryPathName,
    IN      PDRIVER_ADD_DEVICE  AddDevice
)
{
    PAGED_CODE();

    ASSERT(DriverObject);
    ASSERT(RegistryPathName);
    ASSERT(AddDevice);

    _DbgPrintF(DEBUGLVL_VERBOSE,("PcInitializeAdapterDriver"));

    //
    // Validate Parameters.
    //
    if (NULL == DriverObject ||
        NULL == RegistryPathName ||
        NULL == AddDevice)
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("PcInitializeAdapterDriver : Invalid Parameter."));
        return STATUS_INVALID_PARAMETER;
    }

    DriverObject->DriverExtension->AddDevice           = AddDevice;
    DriverObject->DriverUnload                         = KsoNullDriverUnload;

    DriverObject->MajorFunction[IRP_MJ_PNP]            = DispatchPnp;
    DriverObject->MajorFunction[IRP_MJ_POWER]          = DispatchPower;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = PerfWmiDispatch;
    DriverObject->MajorFunction[IRP_MJ_CREATE]         = DispatchCreate;

    KsSetMajorFunctionHandler(DriverObject,IRP_MJ_DEVICE_CONTROL);
    KsSetMajorFunctionHandler(DriverObject,IRP_MJ_READ);
    KsSetMajorFunctionHandler(DriverObject,IRP_MJ_WRITE);
    KsSetMajorFunctionHandler(DriverObject,IRP_MJ_FLUSH_BUFFERS);
    KsSetMajorFunctionHandler(DriverObject,IRP_MJ_CLOSE);
    KsSetMajorFunctionHandler(DriverObject,IRP_MJ_QUERY_SECURITY);
    KsSetMajorFunctionHandler(DriverObject,IRP_MJ_SET_SECURITY);

    return STATUS_SUCCESS;
}

/*****************************************************************************
 * PcDispatchIrp()
 *****************************************************************************
 * Dispatch an IRP.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcDispatchIrp
(
    IN      PDEVICE_OBJECT  pDeviceObject,
    IN      PIRP            pIrp
)
{
    PAGED_CODE();

    ASSERT(pDeviceObject);
    ASSERT(pIrp);

    NTSTATUS ntStatus;

    //
    // Validate parameters.
    //
    if (NULL == pDeviceObject ||
        NULL == pIrp)
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("PcDispatchIrp : Invalid Parameter"));

        ntStatus = STATUS_INVALID_PARAMETER;
        if (pIrp)
        {
            pIrp->IoStatus.Status = ntStatus;
            IoCompleteRequest( pIrp, IO_NO_INCREMENT );
        }

        return ntStatus;
    }

    switch (IoGetCurrentIrpStackLocation(pIrp)->MajorFunction)
    {
        case IRP_MJ_PNP:
            ntStatus = DispatchPnp(pDeviceObject,pIrp);
            break;
        case IRP_MJ_POWER:
            ntStatus = DispatchPower(pDeviceObject,pIrp);
            break;
        case IRP_MJ_SYSTEM_CONTROL:
            ntStatus = PerfWmiDispatch(pDeviceObject,pIrp);
            break;
        default:
            ntStatus = KsoDispatchIrp(pDeviceObject,pIrp);
            break;
    }

    return ntStatus;
}

#pragma code_seg()

/*****************************************************************************
 * AcquireDevice()
 *****************************************************************************
 * Acquire exclusive access to the device. This function has the semantics of
 * a mutex, ie the device must be released on the same thread it was acquired
 * from.
 */
VOID
AcquireDevice
(
    IN      PDEVICE_CONTEXT pDeviceContext
)
{
#ifdef UNDER_NT
    KeEnterCriticalRegion();
#endif

    KeWaitForSingleObject
    (
        &pDeviceContext->kEventDevice,
        Suspended,
        KernelMode,
        FALSE,
        NULL
    );
}

/*****************************************************************************
 * ReleaseDevice()
 *****************************************************************************
 * Release exclusive access to the device.
 */
VOID
ReleaseDevice
(
    IN      PDEVICE_CONTEXT pDeviceContext
)
{
    KeSetEvent(&pDeviceContext->kEventDevice,0,FALSE);

#ifdef UNDER_NT
    KeLeaveCriticalRegion();
#endif
}

/*****************************************************************************
 * IncrementPendingIrpCount()
 *****************************************************************************
 * Increment the pending IRP count for the device.
 */
VOID
IncrementPendingIrpCount
(
    IN      PDEVICE_CONTEXT pDeviceContext
)
{
    ASSERT(pDeviceContext);

    InterlockedIncrement(PLONG(&pDeviceContext->PendingIrpCount));
}

/*****************************************************************************
 * DecrementPendingIrpCount()
 *****************************************************************************
 * Decrement the pending IRP count for the device.
 */
VOID
DecrementPendingIrpCount
(
    IN      PDEVICE_CONTEXT pDeviceContext
)
{
    ASSERT(pDeviceContext);
    ASSERT(pDeviceContext->PendingIrpCount > 0);

    if (InterlockedDecrement(PLONG(&pDeviceContext->PendingIrpCount)) == 0)
    {
        KeSetEvent(&pDeviceContext->kEventRemove,0,FALSE);
    }
}

/*****************************************************************************
 * CompleteIrp()
 *****************************************************************************
 * Complete an IRP unless status is STATUS_PENDING.
 */
NTSTATUS
CompleteIrp
(
    IN      PDEVICE_CONTEXT pDeviceContext,
    IN      PIRP            pIrp,
    IN      NTSTATUS        ntStatus
)
{
    ASSERT(pDeviceContext);
    ASSERT(pIrp);

    if (ntStatus != STATUS_PENDING)
    {
        pIrp->IoStatus.Status = ntStatus;
        IoCompleteRequest(pIrp,IO_NO_INCREMENT);
        DecrementPendingIrpCount(pDeviceContext);
    }

    return ntStatus;
}

/*****************************************************************************
 * PcCompleteIrp()
 *****************************************************************************
 * Complete an IRP unless status is STATUS_PENDING.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcCompleteIrp
(
    IN      PDEVICE_OBJECT  pDeviceObject,
    IN      PIRP            pIrp,
    IN      NTSTATUS        ntStatus
)
{
    ASSERT(pDeviceObject);
    ASSERT(pIrp);

    if (NULL == pDeviceObject ||
        NULL == pIrp ||
        NULL == pDeviceObject->DeviceExtension)
    {
        // don't know what to do, so we'll fail the IRP
        ntStatus = STATUS_INVALID_PARAMETER;
        pIrp->IoStatus.Status = ntStatus;
        IoCompleteRequest( pIrp, IO_NO_INCREMENT );
        return ntStatus;
    }

    return
        CompleteIrp
        (
            PDEVICE_CONTEXT(pDeviceObject->DeviceExtension),
            pIrp,
            ntStatus
        );
}

#pragma code_seg("PAGE")
// shamelessly stolen from nt\private\ntos\ks\api.c
NTSTATUS QueryReferenceBusInterface(
    IN  PDEVICE_OBJECT PnpDeviceObject,
    OUT PBUS_INTERFACE_REFERENCE BusInterface
)
/*++

Routine Description:

    Queries the bus for the standard information interface.

Arguments:

    PnpDeviceObject -
        Contains the next device object on the Pnp stack.

    PhysicalDeviceObject -
        Contains the physical device object which was passed to the FDO during
        the Add Device.

    BusInterface -
        The place in which to return the Reference interface.

Return Value:

    Returns STATUS_SUCCESS if the interface was retrieved, else an error.

--*/
{
    NTSTATUS            Status;
    KEVENT              Event;
    IO_STATUS_BLOCK     IoStatusBlock;
    PIRP                Irp;
    PIO_STACK_LOCATION  IrpStackNext;

    PAGED_CODE();
    //
    // There is no file object associated with this Irp, so the event may be located
    // on the stack as a non-object manager object.
    //
    KeInitializeEvent(&Event, NotificationEvent, FALSE);
    Irp = IoBuildSynchronousFsdRequest(
                                      IRP_MJ_PNP,
                                      PnpDeviceObject,
                                      NULL,
                                      0,
                                      NULL,
                                      &Event,
                                      &IoStatusBlock);
    if (Irp)
    {
        Irp->RequestorMode = KernelMode;
        Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        IrpStackNext = IoGetNextIrpStackLocation(Irp);
        //
        // Create an interface query out of the Irp.
        //
        IrpStackNext->MinorFunction = IRP_MN_QUERY_INTERFACE;
        IrpStackNext->Parameters.QueryInterface.InterfaceType = (GUID*)&REFERENCE_BUS_INTERFACE;
        IrpStackNext->Parameters.QueryInterface.Size = sizeof(*BusInterface);
        IrpStackNext->Parameters.QueryInterface.Version = BUS_INTERFACE_REFERENCE_VERSION;
        IrpStackNext->Parameters.QueryInterface.Interface = (PINTERFACE)BusInterface;
        IrpStackNext->Parameters.QueryInterface.InterfaceSpecificData = NULL;
        Status = IoCallDriver(PnpDeviceObject, Irp);
        if (Status == STATUS_PENDING)
        {
            //
            // This waits using KernelMode, so that the stack, and therefore the
            // event on that stack, is not paged out.
            //
            KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);
            Status = IoStatusBlock.Status;
        }
    }
    else
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    return Status;
}

#pragma code_seg()
/*****************************************************************************
 * IoTimeoutRoutine()
 *****************************************************************************
 * Called by IoTimer for timeout purposes
 */
VOID
IoTimeoutRoutine
(
    IN  PDEVICE_OBJECT  pDeviceObject,
    IN  PVOID           pContext
)
{
    ASSERT(pDeviceObject);
    ASSERT(pContext);

    KIRQL               OldIrql;
    PDEVICE_CONTEXT     pDeviceContext = PDEVICE_CONTEXT(pContext);

    // grab the list spinlock
    KeAcquireSpinLock( &(pDeviceContext->TimeoutLock), &OldIrql );

    // walk the list if it's not empty
    if( !IsListEmpty( &(pDeviceContext->TimeoutList) ) )
    {
        PLIST_ENTRY         ListEntry;
        PTIMEOUTCALLBACK    pCallback;

        for( ListEntry = pDeviceContext->TimeoutList.Flink;
             ListEntry != &(pDeviceContext->TimeoutList);
             ListEntry = ListEntry->Flink )
        {
            pCallback = (PTIMEOUTCALLBACK) CONTAINING_RECORD( ListEntry,
                                                              TIMEOUTCALLBACK,
                                                              ListEntry );

            // call the callback
            pCallback->TimerRoutine(pDeviceObject,pCallback->Context);
        }
    }

    // release the spinlock
    KeReleaseSpinLock( &(pDeviceContext->TimeoutLock), OldIrql );
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * PcAddAdapterDevice()
 *****************************************************************************
 * Adds an adapter device.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcAddAdapterDevice
(
    IN      PDRIVER_OBJECT      DriverObject,
    IN      PDEVICE_OBJECT      PhysicalDeviceObject,
    IN      PCPFNSTARTDEVICE    StartDevice,
    IN      ULONG               MaxObjects,
    IN      ULONG               DeviceExtensionSize
)
{
    PAGED_CODE();

    ASSERT(DriverObject);
    ASSERT(PhysicalDeviceObject);
    ASSERT(StartDevice);
    ASSERT(MaxObjects);

    _DbgPrintF(DEBUGLVL_VERBOSE,("PcAddAdapterDevice"));

    //
    // Validate Parameters.
    //
    if (NULL == DriverObject ||
        NULL == PhysicalDeviceObject ||
        NULL == StartDevice ||
        0    == MaxObjects)
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("PcAddAdapterDevice : Invalid Parameter"));
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Extension size may be zero or >= required size.
    //
    if (DeviceExtensionSize == 0)
    {
        DeviceExtensionSize = sizeof(DEVICE_CONTEXT);
    }
    else
    if (DeviceExtensionSize < sizeof(DEVICE_CONTEXT))
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Create the device object.
    //
    PDEVICE_OBJECT pDeviceObject;
    NTSTATUS ntStatus = IoCreateDevice( DriverObject,
                                        DeviceExtensionSize,
                                        NULL,
                                        FILE_DEVICE_KS,
                                        FILE_DEVICE_SECURE_OPEN |
                                        FILE_AUTOGENERATED_DEVICE_NAME,
                                        FALSE,
                                        &pDeviceObject );

    if (NT_SUCCESS(ntStatus))
    {
        //
        // Initialize the device context.
        //
        PDEVICE_CONTEXT pDeviceContext = PDEVICE_CONTEXT(pDeviceObject->DeviceExtension);

        RtlZeroMemory(pDeviceContext,DeviceExtensionSize);

        pDeviceContext->Signature = PORTCLS_DEVICE_EXTENSION_SIGNATURE;

        pDeviceContext->MaxObjects            = MaxObjects;
        pDeviceContext->PhysicalDeviceObject  = PhysicalDeviceObject;
        pDeviceContext->CreateItems           =
            new(NonPagedPool,'iCcP') KSOBJECT_CREATE_ITEM[MaxObjects];
        pDeviceContext->SymbolicLinkNames     =
            new(NonPagedPool,'lScP') UNICODE_STRING[MaxObjects];
        pDeviceContext->StartDevice           = StartDevice;

        // set the current power states
        pDeviceContext->CurrentDeviceState = PowerDeviceUnspecified;
        pDeviceContext->CurrentSystemState = PowerSystemWorking;
        pDeviceContext->SystemStateHandle  = NULL;

        // set device stop/remove states
        pDeviceContext->DeviceStopState    = DeviceStartPending;

        pDeviceContext->DeviceRemoveState  = DeviceAdded;

        // Let's pause I/O during rebalance (as opposed to a full teardown)
        //
        // Blackcomb ISSUE
        //     Discovery  AdriaO  06/29/1999
        //             We aren't *quite* there yet.
        //     Commentary MartinP 11/28/2000
        //             So true.  Our problem: PortCls might be restarted
        //     with different resources, even one less IRQ or DMA channel,
        //     when rebalance completes.  In a way, this would require our
        //     stack to support dynamic graph changes, which it currently
        //     does not.  AdriaO suggests we implement something along the
        //     lines of "IsFilterCompatible(RESOURCE_LIST)".  It's too late
        //     for a change like this in Windows XP, let's fix this for
        //     Blackcomb and PortCls2.
        //
        pDeviceContext->PauseForRebalance  = FALSE;

        //
        // Initialize list of device interfaces.
        //
        InitializeListHead(&pDeviceContext->DeviceInterfaceList);

        //
        // Initialize list of physical connections.
        //
        InitializeListHead(&pDeviceContext->PhysicalConnectionList);

        //
        // Initialize list of pended IRPs.
        //
        InitializeListHead(&pDeviceContext->PendedIrpList);
        KeInitializeSpinLock(&pDeviceContext->PendedIrpLock);

        //
        // Initialize events for device synchronization and removal.
        //
        KeInitializeEvent(&pDeviceContext->kEventDevice,SynchronizationEvent,TRUE);
        KeInitializeEvent(&pDeviceContext->kEventRemove,SynchronizationEvent,FALSE);

        //
        // Set up the DPC for fast resume
        //
        KeInitializeDpc(&pDeviceContext->DevicePowerRequestDpc, DevicePowerRequestRoutine, pDeviceContext);

        //
        // Set the idle timeouts to the defaults.  Note that the
        // actual value will be read from the registry later.
        //
        pDeviceContext->ConservationIdleTime = DEFAULT_CONSERVATION_IDLE_TIME;
        pDeviceContext->PerformanceIdleTime = DEFAULT_PERFORMANCE_IDLE_TIME;
        pDeviceContext->IdleDeviceState = DEFAULT_IDLE_DEVICE_POWER_STATE;

        // setup the driver object DMA spinlock
        NTSTATUS ntStatus2 = IoAllocateDriverObjectExtension( DriverObject,
                                                              PVOID((DWORD_PTR)PORTCLS_DRIVER_EXTENSION_ID),
                                                              sizeof(KSPIN_LOCK),
                                                              (PVOID *)&pDeviceContext->DriverDmaLock );
        if( STATUS_SUCCESS == ntStatus2 )
        {
            // if we allocated it we need to initialize it
            KeInitializeSpinLock( pDeviceContext->DriverDmaLock );
        } else if( STATUS_OBJECT_NAME_COLLISION == ntStatus2 )
        {
            // we had a collision so it was alread allocated, just get the pointer and don't initialize
            pDeviceContext->DriverDmaLock = (PKSPIN_LOCK)IoGetDriverObjectExtension( DriverObject,
                                                                                     PVOID((DWORD_PTR)PORTCLS_DRIVER_EXTENSION_ID) );
        } else
        {
            // propagate the failure (STATUS_INSUFFICIENT_RESOURCES)
            ntStatus = ntStatus2;
        }

        if( NT_SUCCESS(ntStatus) )
        {
            if( ( !pDeviceContext->CreateItems ) || ( !pDeviceContext->SymbolicLinkNames) )
            {
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            } else
            {
            //
            // When this reaches zero, it'll be time to remove the device.
            //
            pDeviceContext->PendingIrpCount = 1;

            //
            // Initialize suspend and stop counts (used for debugging only)
            //
            pDeviceContext->SuspendCount = 0;
            pDeviceContext->StopCount = 0;

            //
            // Initialize the IoTimer
            //
            InitializeListHead(&pDeviceContext->TimeoutList);
            KeInitializeSpinLock(&pDeviceContext->TimeoutLock);
            pDeviceContext->IoTimeoutsOk = FALSE;
            if( NT_SUCCESS(IoInitializeTimer(pDeviceObject,IoTimeoutRoutine,pDeviceContext)) )
            {
                pDeviceContext->IoTimeoutsOk = TRUE;
            }

            //
            // Allocate the KS device header
            //
            ntStatus = KsAllocateDeviceHeader( &pDeviceContext->pDeviceHeader,
                                               MaxObjects,
                                               pDeviceContext->CreateItems );
            if( NT_SUCCESS(ntStatus) )
            {
                PDEVICE_OBJECT pReturnDevice = IoAttachDeviceToDeviceStack( pDeviceObject,
                                                                            PhysicalDeviceObject );

                if (! pReturnDevice)
                {
                    // free the KS device header
                    KsFreeDeviceHeader( pDeviceContext->pDeviceHeader );
                    pDeviceContext->pDeviceHeader = NULL;

                    ntStatus = STATUS_UNSUCCESSFUL;
                }
                else
                {
                    BUS_INTERFACE_REFERENCE BusInterface;

                    KsSetDevicePnpAndBaseObject(pDeviceContext->pDeviceHeader,
                                                pReturnDevice,
                                                pDeviceObject );

                    pDeviceContext->NextDeviceInStack = pReturnDevice;

                    //
                    // Here we try to detect the case where we really aren't
                    // an audio miniport, but rather helping out an swenum
                    // dude like dmusic. In the later case, we disallow
                    // (nonsensical) registration.
                    //
                    pDeviceContext->AllowRegisterDeviceInterface=TRUE;
                    if (NT_SUCCESS(QueryReferenceBusInterface(pReturnDevice,&BusInterface)))
                    {
                        BusInterface.Interface.InterfaceDereference( BusInterface.Interface.Context );
                        pDeviceContext->AllowRegisterDeviceInterface=FALSE;
                    }
                }


                pDeviceObject->Flags |= DO_DIRECT_IO;
                pDeviceObject->Flags |= DO_POWER_PAGABLE;
                pDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
            }
        }
        }

        if (!NT_SUCCESS(ntStatus))
        {
            if (pDeviceContext->CreateItems)
            {
                delete [] pDeviceContext->CreateItems;
            }

            if (pDeviceContext->SymbolicLinkNames)
            {
                delete [] pDeviceContext->SymbolicLinkNames;
            }

            IoDeleteDevice(pDeviceObject);
        }
        else
        {
            PerfRegisterProvider(pDeviceObject);
        }
    }
    else
    {
        _DbgPrintF(DEBUGLVL_TERSE,("PcAddAdapterDevice IoCreateDevice failed with status 0x%08x",ntStatus));
    }

    return ntStatus;
}

#pragma code_seg()

/*****************************************************************************
 * ForwardIrpCompletionRoutine()
 *****************************************************************************
 * Completion routine for ForwardIrp.
 */
static
NTSTATUS
ForwardIrpCompletionRoutine
(
    IN      PDEVICE_OBJECT  DeviceObject,
    IN      PIRP            Irp,
    IN      PVOID           Context
)
{
    ASSERT(DeviceObject);
    ASSERT(Irp);
    ASSERT(Context);

    KeSetEvent((PKEVENT) Context,0,FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

/*****************************************************************************
 * ForwardIrpAsynchronous()
 *****************************************************************************
 * Forward a PnP IRP to the PDO.  The IRP is completed at this level
 * regardless of the outcome, this function returns immediately regardless of
 * whether the IRP is pending in the lower driver, and
 * DecrementPendingIrpCount() is called in all cases.
 */
NTSTATUS
ForwardIrpAsynchronous
(
    IN      PDEVICE_CONTEXT pDeviceContext,
    IN      PIRP            pIrp
)
{
    ASSERT(pDeviceContext);
    ASSERT(pIrp);

    NTSTATUS ntStatus;

    if (pDeviceContext->DeviceRemoveState == DeviceRemoved)
    {
        _DbgPrintF(DEBUGLVL_VERBOSE,("ForwardIrpAsynchronous delete pending"));
        ntStatus = CompleteIrp(pDeviceContext,pIrp,STATUS_DELETE_PENDING);
    }
    else
    {
        _DbgPrintF(DEBUGLVL_VERBOSE,("ForwardIrpAsynchronous"));

        PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(pIrp);

        IoSkipCurrentIrpStackLocation(pIrp);

        if (irpSp->MajorFunction == IRP_MJ_POWER)
        {
            ntStatus = PoCallDriver(pDeviceContext->NextDeviceInStack,pIrp);
        }
        else
        {
            ntStatus = IoCallDriver(pDeviceContext->NextDeviceInStack,pIrp);
        }

        DecrementPendingIrpCount(pDeviceContext);
    }

    return ntStatus;
}

/*****************************************************************************
 * ForwardIrpSynchronous()
 *****************************************************************************
 * Forward a PnP IRP to the PDO.  The IRP is not completed at this level,
 * this function does not return until the lower driver has completed the IRP,
 * and DecrementPendingIrpCount() is not called.
 */
NTSTATUS
ForwardIrpSynchronous
(
    IN      PDEVICE_CONTEXT pDeviceContext,
    IN      PIRP            pIrp
)
{
    ASSERT(pDeviceContext);
    ASSERT(pIrp);

    NTSTATUS ntStatus;

    if (pDeviceContext->DeviceRemoveState == DeviceRemoved)
    {
        ntStatus = STATUS_DELETE_PENDING;

        _DbgPrintF(DEBUGLVL_VERBOSE,("ForwardIrpSynchronous delete pending"));
    }
    else
    {
        _DbgPrintF(DEBUGLVL_VERBOSE,("ForwardIrpSynchronous"));

        PIO_STACK_LOCATION irpStackPointer = IoGetCurrentIrpStackLocation(pIrp);

        // setup next stack location
        IoCopyCurrentIrpStackLocationToNext( pIrp );

        KEVENT kEvent;
        KeInitializeEvent(&kEvent,NotificationEvent,FALSE);

        IoSetCompletionRoutine
        (
            pIrp,
            ForwardIrpCompletionRoutine,
            &kEvent,                        // Context
            TRUE,                           // InvokeOnSuccess
            TRUE,                           // InvokeOnError
            TRUE                            // InvokeOnCancel
        );

        if (irpStackPointer->MajorFunction == IRP_MJ_POWER)
        {
            ntStatus = PoCallDriver(pDeviceContext->NextDeviceInStack,pIrp);
        }
        else
        {
            ntStatus = IoCallDriver(pDeviceContext->NextDeviceInStack,pIrp);
        }

        if (ntStatus == STATUS_PENDING)
        {
            LARGE_INTEGER Timeout = RtlConvertLongToLargeInteger( 0L );

            _DbgPrintF(DEBUGLVL_VERBOSE,("ForwardIrpSynchronous pending..."));
            KeWaitForSingleObject
            (
                &kEvent,
                Suspended,
                KernelMode,
                FALSE,
                (KeGetCurrentIrql() < DISPATCH_LEVEL) ? NULL : &Timeout
            );
            ntStatus = pIrp->IoStatus.Status;
            _DbgPrintF(DEBUGLVL_VERBOSE,("ForwardIrpSynchronous complete"));
        }
    }
    ASSERT(ntStatus != STATUS_PENDING);
    return ntStatus;
}

#pragma code_seg("PAGE")

/*****************************************************************************
 * PcForwardIrpSynchronous()
 *****************************************************************************
 * Forward a PnP IRP to the PDO.  The IRP is not completed at this level,
 * this function does not return until the lower driver has completed the IRP,
 * and DecrementPendingIrpCount() is not called.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcForwardIrpSynchronous
(
    IN      PDEVICE_OBJECT  DeviceObject,
    IN      PIRP            Irp
)
{
    ASSERT(DeviceObject);
    ASSERT(Irp);

    PAGED_CODE();

    //
    // Validate Parameters.
    //
    if (NULL == DeviceObject ||
        NULL == Irp)
    {
        // don't know what to do, so we'll fail the IRP
        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return STATUS_INVALID_PARAMETER;
    }

    return
        ForwardIrpSynchronous
        (
            PDEVICE_CONTEXT(DeviceObject->DeviceExtension),
            Irp
        );
}

/*****************************************************************************
 * DispatchSystemControl()
 *****************************************************************************
 * Device objects that do not handle this IRP should leave it untouched.
 */
NTSTATUS
PcDispatchSystemControl
(
    IN      PDEVICE_OBJECT  pDeviceObject,
    IN      PIRP            pIrp
)
{
    ASSERT(pDeviceObject);
    ASSERT(pIrp);

    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE,("DispatchSystemControl"));

    PDEVICE_CONTEXT pDeviceContext =
        PDEVICE_CONTEXT(pDeviceObject->DeviceExtension);

    NTSTATUS ntStatus = PcValidateDeviceContext(pDeviceContext, pIrp);
    if (!NT_SUCCESS(ntStatus))
    {
        // Don't know what to do, but this is probably a PDO.
        // We'll try to make this right by completing the IRP
        // untouched (per PnP, WMI, and Power rules). Note
        // that if this isn't a PDO, and isn't a portcls FDO, then
        // the driver messed up by using Portcls as a filter (huh?)
        // In this case the verifier will fail us, WHQL will catch
        // them, and the driver will be fixed. We'd be very surprised
        // to see such a case.

        // Assume FDO, no PoStartNextPowerIrp as this isn't IRP_MJ_POWER
        ntStatus = pIrp->IoStatus.Status;
        IoCompleteRequest( pIrp, IO_NO_INCREMENT );
        return ntStatus;
    }

    IncrementPendingIrpCount(pDeviceContext);

    return ForwardIrpAsynchronous(pDeviceContext,pIrp);
}

/*****************************************************************************
 * PnpStopDevice()
 *****************************************************************************
 * Stop the device.
 */
NTSTATUS
PnpStopDevice
(
    IN      PDEVICE_OBJECT  pDeviceObject,
    IN      PNPSTOP_STYLE   StopStyle
)
{
    PAGED_CODE();

    ASSERT(pDeviceObject);

    _DbgPrintF(DEBUGLVL_VERBOSE,("PnpStopDevice stopping"));

    PDEVICE_CONTEXT pDeviceContext = PDEVICE_CONTEXT(pDeviceObject->DeviceExtension);

    ASSERT(pDeviceContext);
    ASSERT(pDeviceContext->StartDevice);
    ASSERT(pDeviceContext->DeviceStopState != DeviceStopped);

    pDeviceContext->PendCreates = TRUE;
    pDeviceContext->StopCount++;

    if (StopStyle == STOPSTYLE_PAUSE_FOR_REBALANCE)
    {
        //
        // Blackcomb ISSUE
        //     Discovery  AdriaO  06/29/1999
        //         We don't support this quite yet (see above, in
        //         PcAddAdapterDevice, where PauseForRebalance is set false).
        //     Commentary MartinP 11/28/2000
        //         So true.  Our problem: PortCls might be restarted
        //     with different resources, even one less IRQ or DMA channel,
        //     when rebalance completes.  In a way, this would require our
        //     stack to support dynamic graph changes, which it currently
        //     does not.  AdriaO suggests we implement something along the
        //     lines of "IsFilterCompatible(RESOURCE_LIST)".  It's too late
        //     for a change like this in Windows XP, let's fix this for
        //     Blackcomb and PortCls2.
        //
        ASSERT(0);
        pDeviceContext->DeviceStopState = DevicePausedForRebalance;
    }
    else
    {
        pDeviceContext->DeviceStopState = DeviceStopped;
    }

    // stop the IoTimeout timer
    if( pDeviceContext->IoTimeoutsOk )
    {
        IoStopTimer( pDeviceObject );
    }

    POWER_STATE newPowerState;

    newPowerState.DeviceState = PowerDeviceD3;
    PoSetPowerState(pDeviceObject,
                    DevicePowerState,
                    newPowerState
                    );
    pDeviceContext->CurrentDeviceState = PowerDeviceD3;

    //
    // Delete all physical connections.
    //
    while (! IsListEmpty(&pDeviceContext->PhysicalConnectionList))
    {
        PPHYSICALCONNECTION pPhysicalConnection =
            (PPHYSICALCONNECTION)RemoveHeadList(&pDeviceContext->PhysicalConnectionList);

        ASSERT(pPhysicalConnection);
        ASSERT(pPhysicalConnection->FromSubdevice);
        ASSERT(pPhysicalConnection->ToSubdevice);

        if (pPhysicalConnection->FromSubdevice)
        {
            pPhysicalConnection->FromSubdevice->Release();
        }
        if (pPhysicalConnection->ToSubdevice)
        {
            pPhysicalConnection->ToSubdevice->Release();
        }
        if (pPhysicalConnection->FromString)
        {
            DelUnicodeString(pPhysicalConnection->FromString);
        }
        if (pPhysicalConnection->ToString)
        {
            DelUnicodeString(pPhysicalConnection->ToString);
        }

        delete pPhysicalConnection;
    }

    //
    // Disable and delete all the device interfaces.
    //
    while (! IsListEmpty(&pDeviceContext->DeviceInterfaceList))
    {
        PDEVICEINTERFACE pDeviceInterface =
            (PDEVICEINTERFACE)
                RemoveHeadList(&pDeviceContext->DeviceInterfaceList);

        ASSERT(pDeviceInterface);
        ASSERT(pDeviceInterface->SymbolicLinkName.Buffer);

        NTSTATUS ntStatus = STATUS_SUCCESS;
        if (pDeviceContext->AllowRegisterDeviceInterface)
        {
            ntStatus = IoSetDeviceInterfaceState(&pDeviceInterface->SymbolicLinkName,FALSE);
        }

#if DBG
        if (NT_SUCCESS(ntStatus))
        {
            _DbgPrintF(DEBUGLVL_VERBOSE,("PnpStopDevice disabled device interface %S",pDeviceInterface->SymbolicLinkName.Buffer));
        }
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE,("PnpStopDevice failed to disable device interface %S (0x%08x)",pDeviceInterface->SymbolicLinkName.Buffer,ntStatus));
        }
#endif

        RtlFreeUnicodeString(&pDeviceInterface->SymbolicLinkName);

        delete pDeviceInterface;
    }

    //
    // Clear the symbolic link names table.
    //
    RtlZeroMemory
        (   pDeviceContext->SymbolicLinkNames
            ,   sizeof(UNICODE_STRING) * pDeviceContext->MaxObjects
        );

    //
    // Unload each subdevice for this device.
    //
    PKSOBJECT_CREATE_ITEM pKsObjectCreateItem =
        pDeviceContext->CreateItems;
    for
             (   ULONG ul = pDeviceContext->MaxObjects;
         ul--;
             pKsObjectCreateItem++
             )
    {
        if (pKsObjectCreateItem->Create)
        {
            //
            // Zero the create function so we won't get creates.
            //
            pKsObjectCreateItem->Create = NULL;

            //
            // Release the subdevice referenced by this create item.
            //
            ASSERT(pKsObjectCreateItem->Context);
            PSUBDEVICE(pKsObjectCreateItem->Context)->ReleaseChildren();
            PSUBDEVICE(pKsObjectCreateItem->Context)->Release();
        }
    }

    //
    // If the Adapter registered a Power Management interface
    //
    if( NULL != pDeviceContext->pAdapterPower )
    {
        // Release it
        pDeviceContext->pAdapterPower->Release();
        pDeviceContext->pAdapterPower = NULL;
    }

    _DbgPrintF(DEBUGLVL_VERBOSE,("PnpStopDevice exiting"));
    return STATUS_SUCCESS;
}

/*****************************************************************************
 * PnpStartDevice()
 *****************************************************************************
 * Start the device in the PnP style.
 */
QUEUED_CALLBACK_RETURN
PnpStartDevice
(
    IN  PDEVICE_OBJECT  pDeviceObject,
    IN  PVOID           pNotUsed
)
{
    PAGED_CODE();

    ASSERT(pDeviceObject);
    _DbgPrintF(DEBUGLVL_VERBOSE,("PnpStartDevice starting (0x%X)",pDeviceObject));

    PDEVICE_CONTEXT pDeviceContext =
        PDEVICE_CONTEXT(pDeviceObject->DeviceExtension);

    ASSERT(pDeviceContext);
    ASSERT(pDeviceContext->StartDevice);
    ASSERT(pDeviceContext->DeviceStopState != DeviceStarted);
    ASSERT(pDeviceContext->DeviceRemoveState == DeviceAdded);

    pDeviceContext->DeviceStopState = DeviceStartPending;

    PIRP pIrp = pDeviceContext->IrpStart;
    ASSERT(pIrp);

    PIO_STACK_LOCATION pIrpStack =
        IoGetCurrentIrpStackLocation(pIrp);

    //
    // Encapsulate the resource lists.
    //
    PRESOURCELIST pResourceList;
    NTSTATUS ntStatus;
    BOOL bCompletePendedIrps=FALSE;

    // in case there is no resource list in IO_STACK_LOCATION, PcNewResourceList
    // just creates an empty resource list.
    ntStatus = PcNewResourceList
               (
               &pResourceList,
               NULL,
               PagedPool,
               pIrpStack->Parameters.StartDevice.AllocatedResourcesTranslated,
               pIrpStack->Parameters.StartDevice.AllocatedResources
               );

    if (NT_SUCCESS(ntStatus))
    {
        ASSERT(pResourceList);

        //
        // Acquire the device to prevent creates during interface registration.
        //
        AcquireDevice(pDeviceContext);

        //
        // Start the adapter.
        //
        ntStatus = pDeviceContext->StartDevice(pDeviceObject,
                                               pIrp,
                                               pResourceList);
        ASSERT(ntStatus != STATUS_PENDING);

        pResourceList->Release();

        pDeviceContext->DeviceStopState = DeviceStarted;

        if (NT_SUCCESS(ntStatus))
        {
            // Start is always an implicit power up
            POWER_STATE newPowerState;

            pDeviceContext->CurrentDeviceState = PowerDeviceD0;
            newPowerState.DeviceState = PowerDeviceD0;
            PoSetPowerState(pDeviceObject,
                            DevicePowerState,
                            newPowerState
                            );

            // start the IoTimeout timer
            if( pDeviceContext->IoTimeoutsOk )
            {
                IoStartTimer( pDeviceObject );
            }

            // allow create
            pDeviceContext->PendCreates = FALSE;

            // Can't actually complete pended irps until we call ReleaseDevice, or we might deadlock
            bCompletePendedIrps=TRUE;
        }
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE,("PnpStartDevice adapter failed to start (0x%08x)",ntStatus));

            // stop the device (note: this will set DeviceStopState back to DeviceStopped)
            PnpStopDevice(pDeviceObject, STOPSTYLE_DISABLE);
        }

        //
        // Release the device to allow creates.
        //
        ReleaseDevice(pDeviceContext);

        // Now we can complete pended irps
        if (bCompletePendedIrps)
        {
            CompletePendedIrps( pDeviceObject,
                                pDeviceContext,
                                EMPTY_QUEUE_AND_PROCESS );
        }
    }
    else
    {
        _DbgPrintF(DEBUGLVL_TERSE,("PnpStartDevice failed to create resource list object (0x%08x)",ntStatus));
    }

    CompleteIrp(pDeviceContext,pIrp,ntStatus);
    _DbgPrintF(DEBUGLVL_VERBOSE,("PnPStartDevice completing with 0x%X status for 0x%X",ntStatus,pDeviceObject));
    return QUEUED_CALLBACK_FREE;
}

/*****************************************************************************
 * PnpRemoveDevice()
 *****************************************************************************
 * Dispatch IRP_MJ_PNP/IRP_MN_REMOVE_DEVICE.
 */
NTSTATUS
PnpRemoveDevice
(
    IN      PDEVICE_OBJECT  pDeviceObject
)
{
    PAGED_CODE();

    ASSERT(pDeviceObject);

    _DbgPrintF(DEBUGLVL_VERBOSE,("PnpRemoveDevice"));

    PDEVICE_CONTEXT pDeviceContext =
        PDEVICE_CONTEXT(pDeviceObject->DeviceExtension);

    ASSERT( pDeviceContext );

    pDeviceContext->DeviceRemoveState = DeviceRemoved;

    if (InterlockedDecrement(PLONG(&pDeviceContext->PendingIrpCount)) != 0)
    {
        // setup for 15 second timeout (PASSIVE_LEVEL only!!)
        LARGE_INTEGER Timeout = RtlConvertLongToLargeInteger( -15L * 10000000L );

        _DbgPrintF(DEBUGLVL_VERBOSE,("PnpRemoveDevice pending irp count is %d, waiting up to 15 seconds",pDeviceContext->PendingIrpCount));

        KeWaitForSingleObject( &pDeviceContext->kEventRemove,
                               Executive,
                               KernelMode,
                               FALSE,
                               (PASSIVE_LEVEL == KeGetCurrentIrql()) ? &Timeout : NULL );
    }

    _DbgPrintF(DEBUGLVL_VERBOSE,("PnpRemoveDevice pending irp count is 0"));

    IoDetachDevice(pDeviceContext->NextDeviceInStack);

    _DbgPrintF(DEBUGLVL_VERBOSE,("PnpRemoveDevice detached"));

    if (pDeviceContext->CreateItems)
    {
        delete [] pDeviceContext->CreateItems;
    }

    if (pDeviceContext->SymbolicLinkNames)
    {
        delete [] pDeviceContext->SymbolicLinkNames;
    }

    PDRIVER_OBJECT pDriverObject = pDeviceObject->DriverObject;

    if (pDeviceObject->NextDevice)
    {
        _DbgPrintF(DEBUGLVL_VERBOSE,("PnpRemoveDevice there is a next device"));
    }

    if (pDriverObject->DeviceObject != pDeviceObject)
    {
        _DbgPrintF(DEBUGLVL_VERBOSE,("PnpRemoveDevice there is a previous device"));
    }

    IoDeleteDevice(pDeviceObject);
    _DbgPrintF(DEBUGLVL_VERBOSE,("PnpRemoveDevice device deleted"));

    PerfUnregisterProvider(pDeviceObject);

    if (pDriverObject->DeviceObject)
    {
        if (pDriverObject->DeviceObject != pDeviceObject)
        {
            _DbgPrintF(DEBUGLVL_VERBOSE,("PnpRemoveDevice driver object still has some other device object"));
        }
        else
        {
            _DbgPrintF(DEBUGLVL_VERBOSE,("PnpRemoveDevice driver object still has this device object"));
        }
    }

    return STATUS_SUCCESS;
}

/*****************************************************************************
 * DispatchPnp()
 *****************************************************************************
 * Supplying your PnP needs for over 20 min
 */
NTSTATUS
DispatchPnp
(
    IN      PDEVICE_OBJECT  pDeviceObject,
    IN      PIRP            pIrp
)
{
    PAGED_CODE();

    ASSERT(pDeviceObject);
    ASSERT(pIrp);

    NTSTATUS ntStatus = STATUS_SUCCESS;

    PIO_STACK_LOCATION pIrpStack =
        IoGetCurrentIrpStackLocation(pIrp);

    PDEVICE_CONTEXT pDeviceContext =
        PDEVICE_CONTEXT(pDeviceObject->DeviceExtension);

#if (DBG)
    static PCHAR aszMnNames[] =
    {
        "IRP_MN_START_DEVICE",
        "IRP_MN_QUERY_REMOVE_DEVICE",
        "IRP_MN_REMOVE_DEVICE",
        "IRP_MN_CANCEL_REMOVE_DEVICE",
        "IRP_MN_STOP_DEVICE",
        "IRP_MN_QUERY_STOP_DEVICE",
        "IRP_MN_CANCEL_STOP_DEVICE",

        "IRP_MN_QUERY_DEVICE_RELATIONS",
        "IRP_MN_QUERY_INTERFACE",
        "IRP_MN_QUERY_CAPABILITIES",
        "IRP_MN_QUERY_RESOURCES",
        "IRP_MN_QUERY_RESOURCE_REQUIREMENTS",
        "IRP_MN_QUERY_DEVICE_TEXT",
        "IRP_MN_FILTER_RESOURCE_REQUIREMENTS",
        "IRP_MN_UNKNOWN_0x0e",

        "IRP_MN_READ_CONFIG",
        "IRP_MN_WRITE_CONFIG",
        "IRP_MN_EJECT",
        "IRP_MN_SET_LOCK",
        "IRP_MN_QUERY_ID",
        "IRP_MN_QUERY_PNP_DEVICE_STATE",
        "IRP_MN_QUERY_BUS_INFORMATION",
        "IRP_MN_PAGING_NOTIFICATION",
        "IRP_MN_SURPRISE_REMOVAL"
    };
    if (pIrpStack->MinorFunction >= SIZEOF_ARRAY(aszMnNames))
    {
        _DbgPrintF(DEBUGLVL_VERBOSE,("DispatchPnp function 0x%02x",pIrpStack->MinorFunction));
    }
    else
    {
        _DbgPrintF(DEBUGLVL_VERBOSE,("DispatchPnp function %s",aszMnNames[pIrpStack->MinorFunction]));
    }
#endif

    ntStatus = PcValidateDeviceContext(pDeviceContext, pIrp);
    if (!NT_SUCCESS(ntStatus))
    {
        // Don't know what to do, but this is probably a PDO.
        // We'll try to make this right by completing the IRP
        // untouched (per PnP, WMI, and Power rules). Note
        // that if this isn't a PDO, and isn't a portcls FDO, then
        // the driver messed up by using Portcls as a filter (huh?)
        // In this case the verifier will fail us, WHQL will catch
        // them, and the driver will be fixed. We'd be very surprised
        // to see such a case.

        // Assume FDO, no PoStartNextPowerIrp as this isn't IRP_MJ_POWER
        ntStatus = pIrp->IoStatus.Status;
        IoCompleteRequest( pIrp, IO_NO_INCREMENT );
        return ntStatus;
    }

    IncrementPendingIrpCount(pDeviceContext);

    switch (pIrpStack->MinorFunction)
    {
    case IRP_MN_START_DEVICE:

        // if we are already started, something wrong happened
        if( pDeviceContext->DeviceStopState == DeviceStarted )
        {
            //
            // In theory, this is the path that would be exercized by non-stop
            // rebalance. As it's the Fdo's choice to do so via
            // IoInvalidateDeviceState(...), and as we don't do this, we should
            // never ever be here unless something really strange happened...
            //
            // ASSERT(0);

            // ntStatus = STATUS_INVALID_DEVICE_REQUEST;
            _DbgPrintF(DEBUGLVL_TERSE,("DispatchPnP IRP_MN_START_DEVICE received when already started"));
            //CompleteIrp( pDeviceContext, pIrp, ntStatus );

            ntStatus = ForwardIrpSynchronous(pDeviceContext,pIrp); // for some reason we get nested starts
            CompleteIrp( pDeviceContext, pIrp, ntStatus );
        } else {

            //
            // Forward request and start.
            //
            ntStatus = ForwardIrpSynchronous(pDeviceContext,pIrp);

            if (NT_SUCCESS(ntStatus))
            {
                    // Do a real start. Begin by pending the irp
                    IoMarkIrpPending(pIrp);
                    pDeviceContext->IrpStart = pIrp;

                    // queue the start work item
                    _DbgPrintF(DEBUGLVL_VERBOSE,("Queueing WorkQueueItemStart for 0x%X",pDeviceObject));

                    ntStatus = CallbackEnqueue(
                        &pDeviceContext->pWorkQueueItemStart,
                        PnpStartDevice,
                        pDeviceObject,
                        NULL,
                        PASSIVE_LEVEL,
                        EQCF_DIFFERENT_THREAD_REQUIRED
                        );

                    if (NT_SUCCESS(ntStatus)) {

                        ntStatus = STATUS_PENDING;

                    } else {

                        _DbgPrintF(DEBUGLVL_TERSE,("DispatchPnp failed to queue callback (%08x)",ntStatus));
                        CompleteIrp( pDeviceContext, pIrp, ntStatus );
                }
            }
            else
            {
                _DbgPrintF(DEBUGLVL_TERSE,("DispatchPnp parent failed to start (%08x)",ntStatus));
                CompleteIrp(pDeviceContext,pIrp,ntStatus);
            }
        }
        break;

    case IRP_MN_QUERY_STOP_DEVICE:
        //
        // Acquire the device to avoid race condition with Create
        //
        AcquireDevice( pDeviceContext );

        LONG handleCount;

        ntStatus = STATUS_SUCCESS;

        //
        // If we are tearing everything down, we must check for open handles,
        // otherwise we do a quick activity check.
        //
        handleCount = (pDeviceContext->PauseForRebalance) ?
            pDeviceContext->ActivePinCount :
            pDeviceContext->ExistingObjectCount;

        if ( handleCount != 0 ) {
            //
            // Sorry Joe User, we must fail this QUERY_STOP_DEVICE request
            //
            ntStatus = STATUS_DEVICE_BUSY;
            CompleteIrp( pDeviceContext, pIrp, ntStatus );
        }
        else {
            //
            // Pass down the query.
            //
            pIrp->IoStatus.Status = STATUS_SUCCESS;
            ntStatus = ForwardIrpSynchronous(pDeviceContext,pIrp);
            if (NT_SUCCESS(ntStatus)) {

                //
                // pend new creates, this'll keep the active counts from changing.
                //
                pDeviceContext->PendCreates = TRUE;
                _DbgPrintF(DEBUGLVL_VERBOSE,("DispatchPnp query STOP succeeded",ntStatus));

                pDeviceContext->DeviceStopState = DeviceStopPending;
            }
            else {
                _DbgPrintF(DEBUGLVL_VERBOSE,("DispatchPnp parent failed query STOP (0x%08x)",ntStatus));
            }
            CompleteIrp( pDeviceContext, pIrp, ntStatus );
        }

        ReleaseDevice( pDeviceContext );
        break ;

    case IRP_MN_CANCEL_STOP_DEVICE:
        //ASSERT( DeviceStopPending == pDeviceContext->DeviceStopState );

        if (pDeviceContext->DeviceStopState == DeviceStopPending)
        {
            pDeviceContext->DeviceStopState = DeviceStarted;
        }

        //
        // allow creates if in D0
        //
        if( NT_SUCCESS(CheckCurrentPowerState(pDeviceObject)) )
        {
            pDeviceContext->PendCreates = FALSE;

            //
            // Pull any pended irps off the pended irp list and
            // pass them back to PcDispatchIrp
            //
            CompletePendedIrps( pDeviceObject,
                                pDeviceContext,
                                EMPTY_QUEUE_AND_PROCESS );
        }

        // forward the irp
        pIrp->IoStatus.Status = STATUS_SUCCESS;
        ntStatus = ForwardIrpAsynchronous(pDeviceContext,pIrp);
        break ;

    case IRP_MN_STOP_DEVICE:

        if (pDeviceContext->PauseForRebalance &&
           (pDeviceContext->DeviceStopState == DeviceStopPending))
        {

            ntStatus = PnpStopDevice(pDeviceObject, STOPSTYLE_PAUSE_FOR_REBALANCE);

        }
        else
        {
            //
            // Either we've decided not to pause during rebalance, or this is
            // a "naked" stop on Win9x, which occurs when the OS wishes to
            // disable us.
            //

            //
            // Stopping us will change our state and tear everything down
            //
            if (pDeviceContext->DeviceStopState != DeviceStopped)
            {
                ntStatus = PnpStopDevice(pDeviceObject, STOPSTYLE_DISABLE);
            }
            else
            {
                _DbgPrintF(DEBUGLVL_VERBOSE,("DispatchPnp stop received in unstarted state"));
            }

            //
            // Now fail any pended irps.
            //
            CompletePendedIrps( pDeviceObject,
                                pDeviceContext,
                                EMPTY_QUEUE_AND_FAIL );
        }

        if (NT_SUCCESS(ntStatus))
        {
            // forward the irp
            pIrp->IoStatus.Status = STATUS_SUCCESS;
            ntStatus = ForwardIrpAsynchronous(pDeviceContext,pIrp);
        }
        else
        {
            CompleteIrp(pDeviceContext,pIrp,ntStatus);
        }
        break;

    case IRP_MN_QUERY_REMOVE_DEVICE:

        //
        // Acquire the device because we don't want to race with creates.
        //
        AcquireDevice(pDeviceContext);

        if ( pDeviceContext->ExistingObjectCount != 0 ) {

            //
            // Somebody has open handles on us, so fail the QUERY_REMOVE_DEVICE
            // request.
            //
            ntStatus = STATUS_DEVICE_BUSY;

        } else {

            //
            // Lookin good, pass down the query.
            //
            pIrp->IoStatus.Status = STATUS_SUCCESS;
            ntStatus = ForwardIrpSynchronous(pDeviceContext,pIrp);
            if (NT_SUCCESS(ntStatus))
            {
                //
                // Pend future creates.
                //
                pDeviceContext->PendCreates = TRUE;
                _DbgPrintF(DEBUGLVL_VERBOSE,("DispatchPnp query REMOVE succeeded",ntStatus));

                pDeviceContext->DeviceRemoveState = DeviceRemovePending;
            }
            else
            {
                _DbgPrintF(DEBUGLVL_VERBOSE,("DispatchPnp parent failed query REMOVE (0x%08x)",ntStatus));
            }
        }

        ReleaseDevice(pDeviceContext);

        CompleteIrp(pDeviceContext,pIrp,ntStatus);

        break;

    case IRP_MN_CANCEL_REMOVE_DEVICE:
        //ASSERT( DeviceRemovePending == pDeviceContext->DeviceRemoveState );

        pDeviceContext->DeviceRemoveState = DeviceAdded;

        //
        // allow creates if in D0
        //
        if( NT_SUCCESS(CheckCurrentPowerState(pDeviceObject)) )
        {
            pDeviceContext->PendCreates = FALSE;

            //
            // Pull any pended irps off the pended irp list and
            // pass them back to PcDispatchIrp
            //
            CompletePendedIrps( pDeviceObject,
                                pDeviceContext,
                                EMPTY_QUEUE_AND_PROCESS );
        }

        // forward the irp
        pIrp->IoStatus.Status = STATUS_SUCCESS;
        ntStatus = ForwardIrpAsynchronous(pDeviceContext,pIrp);
        break;

    case IRP_MN_SURPRISE_REMOVAL:
        //
        // Acquire the device
        //
        AcquireDevice(pDeviceContext);

        pDeviceContext->DeviceRemoveState = DeviceSurpriseRemoved;

        //
        // Release the device
        //
        ReleaseDevice(pDeviceContext);

        //
        // Fail any pended irps.
        //
        CompletePendedIrps( pDeviceObject,
                            pDeviceContext,
                            EMPTY_QUEUE_AND_FAIL );

        if (pDeviceContext->DeviceStopState != DeviceStopped)
        {
            PnpStopDevice(pDeviceObject, STOPSTYLE_DISABLE);
        }

        pIrp->IoStatus.Status = STATUS_SUCCESS;

        ntStatus = ForwardIrpAsynchronous( pDeviceContext, pIrp );

        break;

    case IRP_MN_REMOVE_DEVICE:

        //
        // Perform stop if required.
        //
        if (pDeviceContext->DeviceStopState != DeviceStopped)
        {
            _DbgPrintF(DEBUGLVL_VERBOSE,("DispatchPnp remove received in started state"));
            PnpStopDevice(pDeviceObject, STOPSTYLE_DISABLE);
        }

        //
        // Fail any pended irps.
        //
        CompletePendedIrps( pDeviceObject,
                            pDeviceContext,
                            EMPTY_QUEUE_AND_FAIL );

        //
        // Free device header, must be done before forwarding irp
        //
        if( pDeviceContext->pDeviceHeader )
        {
            KsFreeDeviceHeader(pDeviceContext->pDeviceHeader);
        }

        //
        // Forward the request.
        //
        pIrp->IoStatus.Status = STATUS_SUCCESS;
        ntStatus = ForwardIrpAsynchronous(pDeviceContext,pIrp);

        //
        // Remove the device.
        //
        PnpRemoveDevice(pDeviceObject);

        break;

    case IRP_MN_QUERY_CAPABILITIES:
        //
        //  Fill out power management / ACPI stuff
        //  for this device.
        //
        ntStatus = GetDeviceACPIInfo( pIrp, pDeviceObject );
        break;

    case IRP_MN_READ_CONFIG:
    case IRP_MN_WRITE_CONFIG:
    case IRP_MN_QUERY_DEVICE_RELATIONS:
    case IRP_MN_QUERY_INTERFACE:
    case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
        //
        // TODO:  Make sure functions listed below are ok left unhandled.
        //
    case IRP_MN_QUERY_RESOURCES:
    case IRP_MN_QUERY_DEVICE_TEXT:
    case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
    case IRP_MN_EJECT:
    case IRP_MN_SET_LOCK:
    case IRP_MN_QUERY_ID:
    case IRP_MN_QUERY_PNP_DEVICE_STATE:
    case IRP_MN_QUERY_BUS_INFORMATION:
//    case IRP_MN_PAGING_NOTIFICATION:
    default:
        ntStatus = ForwardIrpAsynchronous(pDeviceContext,pIrp);
        break;
    }

    return ntStatus;
}


/*****************************************************************************
 * SubdeviceIndex()
 *****************************************************************************
 * Returns the index of a subdevice in the create items list or ULONG(-1) if
 * not found.
 */
ULONG
SubdeviceIndex
(
    IN      PDEVICE_OBJECT  DeviceObject,
    IN      PSUBDEVICE      Subdevice
)
{
    ASSERT(DeviceObject);
    ASSERT(Subdevice);

    PDEVICE_CONTEXT pDeviceContext =
        PDEVICE_CONTEXT(DeviceObject->DeviceExtension);

    ASSERT(pDeviceContext);

    PKSOBJECT_CREATE_ITEM createItem =
        pDeviceContext->CreateItems;

    for
    (
        ULONG index = 0;
        index < pDeviceContext->MaxObjects;
        index++, createItem++
    )
    {
        if (PSUBDEVICE(createItem->Context) == Subdevice)
        {
            break;
        }
    }

    if (index == pDeviceContext->MaxObjects)
    {
        index = ULONG(-1);
    }

    return index;
}

/*****************************************************************************
 * PcRegisterSubdevice()
 *****************************************************************************
 * Registers a subdevice.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcRegisterSubdevice
(
    IN      PDEVICE_OBJECT  DeviceObject,
    IN      PWCHAR          Name,
    IN      PUNKNOWN        Unknown
)
{
    PAGED_CODE();

    ASSERT(DeviceObject);
    ASSERT(Name);
    ASSERT(Unknown);

    _DbgPrintF(DEBUGLVL_VERBOSE,("PcRegisterSubdevice %S",Name));

    //
    // Validate Parameters.
    //
    if (NULL == DeviceObject ||
        NULL == Name ||
        NULL == Unknown)
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("PcRegisterSubDevice : Invalid Parameter."));
        return STATUS_INVALID_PARAMETER;
    }

    PSUBDEVICE  pSubdevice;
    NTSTATUS    ntStatus =
        Unknown->QueryInterface
        (
        IID_ISubdevice,
        (PVOID *) &pSubdevice
        );

    if (NT_SUCCESS(ntStatus))
    {
        ntStatus =
            AddIrpTargetFactoryToDevice
            (
            DeviceObject,
                                                pSubdevice,
                                                Name,
            NULL        // TODO:  Security.
            );

        const SUBDEVICE_DESCRIPTOR *pSubdeviceDescriptor;
        if (NT_SUCCESS(ntStatus))
        {
            ntStatus = pSubdevice->GetDescriptor(&pSubdeviceDescriptor);
        }
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE,("PcRegisterSubdevice AddIrpTargetFactoryToDevice failed (0x%08x)",ntStatus));
        }

        if (NT_SUCCESS(ntStatus) && pSubdeviceDescriptor->Topology->CategoriesCount)
        {
            PDEVICE_CONTEXT pDeviceContext =
                PDEVICE_CONTEXT(DeviceObject->DeviceExtension);

            ULONG index = SubdeviceIndex(DeviceObject,pSubdevice);

            ASSERT(pSubdeviceDescriptor->Topology->Categories);
            ASSERT(pDeviceContext);

            UNICODE_STRING referenceString;
            RtlInitUnicodeString(&referenceString,Name);

            const GUID *pGuidCategories =
                pSubdeviceDescriptor->Topology->Categories;
            for
                     (   ULONG ul = pSubdeviceDescriptor->Topology->CategoriesCount
                         ;   ul--
                     ;   pGuidCategories++
                     )
            {
                UNICODE_STRING linkName;

                if (pDeviceContext->AllowRegisterDeviceInterface)
                {
                    ntStatus
                        = IoRegisterDeviceInterface
                          (
                          pDeviceContext->PhysicalDeviceObject,
                                                          pGuidCategories,
                                                          &referenceString,
                          &linkName
                          );

                    if (NT_SUCCESS(ntStatus))
                    {
                        ntStatus =
                            IoSetDeviceInterfaceState
                            (
                            &linkName,
                            TRUE
                            );

                        if (NT_SUCCESS(ntStatus))
                        {
                            _DbgPrintF(DEBUGLVL_VERBOSE,("PcRegisterSubdevice device interface %S set to state TRUE",linkName.Buffer));
                        }
                        else
                        {
                            _DbgPrintF(DEBUGLVL_TERSE,("PcRegisterSubdevice IoSetDeviceInterfaceState failed (0x%08x)",ntStatus));
                        }
                    }
                    else
                    {
                        _DbgPrintF(DEBUGLVL_TERSE,("PcRegisterSubdevice IoRegisterDeviceInterface failed (0x%08x)",ntStatus));
                    }
                }
                else
                {
                    linkName.Length = wcslen(Name) * sizeof(WCHAR);
                    linkName.MaximumLength = linkName.Length + sizeof(UNICODE_NULL);
                    linkName.Buffer = (PWSTR)ExAllocatePoolWithTag(PagedPool, linkName.MaximumLength,'NLcP');  //  'PcLN'
                    if (!linkName.Buffer)
                    {
                        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                    }
                    else
                    {
                        wcscpy(linkName.Buffer,Name);
                    }
                }

                if (NT_SUCCESS(ntStatus))
                {
                    //
                    // Save the first symbolic link name in the table.
                    //
                    if (! pDeviceContext->SymbolicLinkNames[index].Buffer)
                    {
                        pDeviceContext->SymbolicLinkNames[index] = linkName;
                    }

                    //
                    // Save the interface in a list for cleanup.
                    //
                    PDEVICEINTERFACE pDeviceInterface = new(PagedPool,'iDcP') DEVICEINTERFACE;
                    if (pDeviceInterface)
                    {
                        pDeviceInterface->Interface         = *pGuidCategories;
                        pDeviceInterface->SymbolicLinkName  = linkName;
                        pDeviceInterface->Subdevice         = pSubdevice;

                        InsertTailList
                            (
                            &pDeviceContext->DeviceInterfaceList,
                            &pDeviceInterface->ListEntry
                            );
                    }
                    else
                    {
                        _DbgPrintF(DEBUGLVL_TERSE,("PcRegisterSubdevice failed to allocate device interface structure for later cleanup"));
                        RtlFreeUnicodeString(&linkName);
                    }
                }
            }
        }

        pSubdevice->Release();
    }
    else
    {
        _DbgPrintF(DEBUGLVL_TERSE,("QI for IID_ISubdevice failed on UNKNOWN 0x%08x",pSubdevice));
    }

    return ntStatus;
}

/*****************************************************************************
 * RegisterPhysicalConnection_()
 *****************************************************************************
 * Registers a physical connection between subdevices or external devices.
 */
static
NTSTATUS
RegisterPhysicalConnection_
(
    IN      PDEVICE_OBJECT  pDeviceObject,
    IN      PUNKNOWN        pUnknownFrom        OPTIONAL,
    IN      PUNICODE_STRING pUnicodeStringFrom  OPTIONAL,
    IN      ULONG           ulFromPin,
    IN      PUNKNOWN        pUnknownTo          OPTIONAL,
    IN      PUNICODE_STRING pUnicodeStringTo    OPTIONAL,
    IN      ULONG           ulToPin
)
{
    PAGED_CODE();

    ASSERT(pDeviceObject);
    ASSERT(pUnknownFrom || pUnicodeStringFrom);
    ASSERT(pUnknownTo || pUnicodeStringTo);
    ASSERT(! (pUnknownFrom && pUnicodeStringFrom));
    ASSERT(! (pUnknownTo && pUnicodeStringTo));

    PDEVICE_CONTEXT pDeviceContext =
        PDEVICE_CONTEXT(pDeviceObject->DeviceExtension);

    ASSERT(pDeviceContext);

    PSUBDEVICE  pSubdeviceFrom  = NULL;
    PSUBDEVICE  pSubdeviceTo    = NULL;

    NTSTATUS ntStatus = STATUS_SUCCESS;

    if (pUnknownFrom)
    {
        ntStatus =
            pUnknownFrom->QueryInterface
            (
                IID_ISubdevice,
                (PVOID *) &pSubdeviceFrom
            );
    }
    else
    {
        ntStatus =
            DupUnicodeString
            (
                &pUnicodeStringFrom,
                pUnicodeStringFrom
            );
    }

    if (NT_SUCCESS(ntStatus))
    {
        if (pUnknownTo)
        {
            ntStatus =
                pUnknownTo->QueryInterface
                (
                    IID_ISubdevice,
                    (PVOID *) &pSubdeviceTo
                );
        }
        else
        {
            ntStatus =
                DupUnicodeString
                (
                    &pUnicodeStringTo,
                    pUnicodeStringTo
                );
        }
    }
    else
    {
        pUnicodeStringTo = NULL;
    }

    if (NT_SUCCESS(ntStatus))
    {
        PPHYSICALCONNECTION pPhysicalConnection =
            new(PagedPool,'cPcP') PHYSICALCONNECTION;

        if (pPhysicalConnection)
        {
            pPhysicalConnection->FromSubdevice   = pSubdeviceFrom;
            pPhysicalConnection->FromString      = pUnicodeStringFrom;
            pPhysicalConnection->FromPin         = ulFromPin;
            pPhysicalConnection->ToSubdevice     = pSubdeviceTo;
            pPhysicalConnection->ToString        = pUnicodeStringTo;
            pPhysicalConnection->ToPin           = ulToPin;

            if (pPhysicalConnection->FromSubdevice)
            {
                pPhysicalConnection->FromSubdevice->AddRef();
            }
            if (pPhysicalConnection->ToSubdevice)
            {
                pPhysicalConnection->ToSubdevice->AddRef();
            }

            //
            // So they don't get deleted.
            //
            pUnicodeStringFrom = NULL;
            pUnicodeStringTo = NULL;

            InsertTailList
            (
                &pDeviceContext->PhysicalConnectionList,
                &pPhysicalConnection->ListEntry
            );
        }
        else
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (pSubdeviceFrom)
    {
        pSubdeviceFrom->Release();
    }

    if (pSubdeviceTo)
    {
        pSubdeviceTo->Release();
    }

    if (pUnicodeStringFrom)
    {
        DelUnicodeString(pUnicodeStringFrom);
    }

    if (pUnicodeStringTo)
    {
        DelUnicodeString(pUnicodeStringTo);
    }

    return ntStatus;
}

/*****************************************************************************
 * PcRegisterPhysicalConnection()
 *****************************************************************************
 * Registers a physical connection between subdevices.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcRegisterPhysicalConnection
(
    IN      PDEVICE_OBJECT  pDeviceObject,
    IN      PUNKNOWN        pUnknownFrom,
    IN      ULONG           ulFromPin,
    IN      PUNKNOWN        pUnknownTo,
    IN      ULONG           ulToPin
)
{
    PAGED_CODE();

    ASSERT(pDeviceObject);
    ASSERT(pUnknownFrom);
    ASSERT(pUnknownTo);

    //
    // Validate Parameters.
    //
    if (NULL == pDeviceObject ||
        NULL == pUnknownFrom ||
        NULL == pUnknownTo)
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("PcRegisterPhysicalConnection : Invalid Parameter."));
        return STATUS_INVALID_PARAMETER;
    }

    return
        RegisterPhysicalConnection_
        (
            pDeviceObject,
            pUnknownFrom,
            NULL,
            ulFromPin,
            pUnknownTo,
            NULL,
            ulToPin
        );
}

/*****************************************************************************
 * PcRegisterPhysicalConnectionToExternal()
 *****************************************************************************
 * Registers a physical connection from a subdevice to an external device.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcRegisterPhysicalConnectionToExternal
(
    IN      PDEVICE_OBJECT  pDeviceObject,
    IN      PUNKNOWN        pUnknownFrom,
    IN      ULONG           ulFromPin,
    IN      PUNICODE_STRING pUnicodeStringTo,
    IN      ULONG           ulToPin
)
{
    PAGED_CODE();

    ASSERT(pDeviceObject);
    ASSERT(pUnknownFrom);
    ASSERT(pUnicodeStringTo);

    //
    // Validate Parameters.
    //
    if (NULL == pDeviceObject ||
        NULL == pUnknownFrom ||
        NULL == pUnicodeStringTo)
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("PcRegisterPhysicalConnectionToExternal : Invalid Parameter."));
        return STATUS_INVALID_PARAMETER;
    }

    return
        RegisterPhysicalConnection_
        (
            pDeviceObject,
            pUnknownFrom,
            NULL,
            ulFromPin,
            NULL,
            pUnicodeStringTo,
            ulToPin
        );
}

/*****************************************************************************
 * PcRegisterPhysicalConnectionFromExternal()
 *****************************************************************************
 * Registers a physical connection to a subdevice from an external device.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcRegisterPhysicalConnectionFromExternal
(
    IN      PDEVICE_OBJECT  pDeviceObject,
    IN      PUNICODE_STRING pUnicodeStringFrom,
    IN      ULONG           ulFromPin,
    IN      PUNKNOWN        pUnknownTo,
    IN      ULONG           ulToPin
)
{
    PAGED_CODE();

    ASSERT(pDeviceObject);
    ASSERT(pUnicodeStringFrom);
    ASSERT(pUnknownTo);

    //
    // Validate Parameters.
    //
    if (NULL == pDeviceObject ||
        NULL == pUnicodeStringFrom ||
        NULL == pUnknownTo)
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("PcRegisterPhysicalConnectionFromExternal : Invalid Parameter."));
        return STATUS_INVALID_PARAMETER;
    }

    return
        RegisterPhysicalConnection_
        (
            pDeviceObject,
            NULL,
            pUnicodeStringFrom,
            ulFromPin,
            pUnknownTo,
            NULL,
            ulToPin
        );
}

#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\main\porthelp.cpp ===
/*****************************************************************************
 * porthelp.cpp - WDM Streaming port class driver port helper functions
 *****************************************************************************
 * Copyright (c) 1996-2000 Microsoft Corporation.  All rights reserved.
 */

#include "private.h"




/*****************************************************************************
 * Functions.
 */

#pragma code_seg("PAGE")

static
KSPIN_MEDIUM PinMediums[] =
{
   {
      STATICGUIDOF(KSMEDIUMSETID_Standard),
      KSMEDIUM_STANDARD_DEVIO,
      0
   }
};


#define UPTOQUAD(x) (((x)+7)&~7)

/*****************************************************************************
 * PrivateHeap
 *****************************************************************************
 * Class for managing a private heap.
 */
class PrivateHeap
{
private:
    PBYTE   m_pbTop;
    PBYTE   m_pbCurrent;
    ULONG   m_ulSize;

public:
    PrivateHeap(void) : m_pbTop(NULL),
                        m_pbCurrent(NULL),
                        m_ulSize(NULL)
    {
    }

    //
    // Increase the number of bytes that will be allocated for the heap.
    //
    ULONG Reserve(ULONG ulBytes)
    {
        ASSERT(! m_pbTop);
        ASSERT(! m_pbCurrent);

        m_ulSize += UPTOQUAD(ulBytes);

        return m_ulSize;
    }

    //
    // Allocate memory for the private heap from a pool.
    //
    NTSTATUS AllocateFromPool(POOL_TYPE poolType,ULONG ulTag)
    {
        ASSERT(! m_pbTop);
        ASSERT(! m_pbCurrent);
        ASSERT(m_ulSize);

        m_pbTop = new(poolType,ulTag) BYTE[m_ulSize];

        if (! m_pbTop)
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        m_pbCurrent = m_pbTop;

        return STATUS_SUCCESS;
    }

    //
    // Allocate memory from the heap.
    //
    PVOID Alloc(ULONG ulSize)
    {
        ASSERT(ulSize);
        ASSERT(m_pbTop);
        ASSERT(m_pbCurrent);
        ASSERT(m_pbCurrent + UPTOQUAD(ulSize) <= m_pbTop + m_ulSize);

        PVOID pvResult = PVOID(m_pbCurrent);

        m_pbCurrent += UPTOQUAD(ulSize);

        return pvResult;
    }

    //
    // Determine the amount of space remaining in the heap.
    //
    ULONG BytesRemaining(void)
    {
        ASSERT(m_pbTop);
        ASSERT(m_pbCurrent);
        ASSERT(m_pbCurrent <= m_pbTop + m_ulSize);

        return ULONG((m_pbTop + m_ulSize) - m_pbCurrent);
    }
};

/*****************************************************************************
 * ::new()
 *****************************************************************************
 * New function for creating objects with private heap.
 */
inline PVOID operator new
(
    size_t    iSize,
    PrivateHeap&    privateHeap
)
{
    return privateHeap.Alloc(ULONG(iSize));
}

/*****************************************************************************
 * MeasureDataRanges()
 *****************************************************************************
 * Determine how much a set of data ranges will expand as a result
 * of cloning WAVEFORMATEX ranges into identical DSOUND ranges.
 *
 * As of WinME, we also clone non-PCM ranges.
 */
static
ULONG
MeasureDataRanges
(
    IN      PrivateHeap *           pPrivateHeap        OPTIONAL,
    IN      ULONG                   ulDataRangeCountIn,
    IN      KSDATARANGE *const *    ppKsDataRangeIn
)
{
    ULONG ulNewDataRangeCount = ulDataRangeCountIn;

    for (ULONG ul = ulDataRangeCountIn; ul--; )
    {
        ASSERT(ppKsDataRangeIn);

        if  (   (   (*ppKsDataRangeIn)->FormatSize 
                >=  sizeof(KSDATAFORMAT_WAVEFORMATEX)
                )
            &&  IsEqualGUIDAligned
                (   (*ppKsDataRangeIn)->MajorFormat,
                    KSDATAFORMAT_TYPE_AUDIO
                )
            &&  IsEqualGUIDAligned
                (   (*ppKsDataRangeIn)->Specifier,
                KSDATAFORMAT_SPECIFIER_WAVEFORMATEX
                )
            )
        {
            ulNewDataRangeCount++;
            if (pPrivateHeap)
            {
                pPrivateHeap->Reserve((*ppKsDataRangeIn)->FormatSize);
            }
        }

       ppKsDataRangeIn++;
    }

    if (pPrivateHeap && (ulNewDataRangeCount != ulDataRangeCountIn))
    {
        pPrivateHeap->Reserve(ulNewDataRangeCount * sizeof(PKSDATARANGE));
    }

    return ulNewDataRangeCount;
}

/*****************************************************************************
 * CloneDataRanges()
 *****************************************************************************
 * Expand data ranges to include DSound formats.
 */
static
const PKSDATARANGE *
CloneDataRanges
(
    IN      PrivateHeap&            privateHeap,
    OUT     PULONG                  pulDataRangeCountOut,
    IN      ULONG                   ulDataRangeCountIn,
    IN      KSDATARANGE *const *    ppKsDataRangeIn
)
{
    ASSERT(pulDataRangeCountOut);

    //
    // Determine how many data ranges there will be and how much space will be
    // required for the new ones.
    //
    ULONG ulDataRangeCountOut =
        MeasureDataRanges(NULL,ulDataRangeCountIn,ppKsDataRangeIn);

    const PKSDATARANGE *ppKsDataRangeOut;

    if (ulDataRangeCountOut == ulDataRangeCountIn)
    {
        //
        // No new data ranges.  Use the array we were given.
        //
        ppKsDataRangeOut = ppKsDataRangeIn;
    }
    else
    {
        //
        // Allocate some space for the new array.
        //
        ppKsDataRangeOut = new(privateHeap) PKSDATARANGE[ulDataRangeCountOut];

        //
        // Build the new array.
        //
        PKSDATARANGE *ppKsDataRange = (PKSDATARANGE *) ppKsDataRangeOut;
        while (ulDataRangeCountIn--)
        {
            ASSERT(ppKsDataRangeIn);

            //
            // All the data ranges get copied.
            //
            *ppKsDataRange++ = *ppKsDataRangeIn;

            //
            // Check for WaveFormatEx datarange
            // This includes non-PCM subformats....
            //
            if  (   (   (*ppKsDataRangeIn)->FormatSize 
                    >=  sizeof(KSDATAFORMAT_WAVEFORMATEX)
                    )
                &&  IsEqualGUIDAligned
                    (   (*ppKsDataRangeIn)->MajorFormat,
                        KSDATAFORMAT_TYPE_AUDIO
                    )
                &&  IsEqualGUIDAligned
                    (   (*ppKsDataRangeIn)->Specifier,
                        KSDATAFORMAT_SPECIFIER_WAVEFORMATEX
                    )
                )
            {
                //
                // WaveFormatEx datarange will require DSound clone.
                // Allocate memory for it and copy.
                //
                *ppKsDataRange = 
                    PKSDATARANGE
                    (
                        new(privateHeap) BYTE[(*ppKsDataRangeIn)->FormatSize]
                    );

                RtlCopyMemory
                ( 
                    *ppKsDataRange,
                    *ppKsDataRangeIn,
                    (*ppKsDataRangeIn)->FormatSize
                );

                //
                // Update the specifier.
                //
                (*ppKsDataRange++)->Specifier = 
                    KSDATAFORMAT_SPECIFIER_DSOUND;
            }

            //
            // Increment input position
            //
            ppKsDataRangeIn++;
        }
    }

    *pulDataRangeCountOut = ulDataRangeCountOut;

    return ppKsDataRangeOut;
}

/*****************************************************************************
 * PcCreateSubdeviceDescriptor()
 *****************************************************************************
 * Creates a subdevice descriptor.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcCreateSubdeviceDescriptor
(
    IN      PPCFILTER_DESCRIPTOR    pPcFilterDescriptor,
    IN      ULONG                   CategoriesCount,
    IN      GUID *                  Categories,
    IN      ULONG                   StreamInterfacesCount,
    IN      PKSPIN_INTERFACE        StreamInterfaces,
    IN      ULONG                   FilterPropertySetCount,
    IN      PKSPROPERTY_SET         FilterPropertySets,
    IN      ULONG                   FilterEventSetCount,
    IN      PKSEVENT_SET            FilterEventSets,
    IN      ULONG                   PinPropertySetCount,
    IN      PKSPROPERTY_SET         PinPropertySets,
    IN      ULONG                   PinEventSetCount,
    IN      PKSEVENT_SET            PinEventSets,
    OUT     PSUBDEVICE_DESCRIPTOR * OutDescriptor
)
{
    PAGED_CODE();

    ASSERT(pPcFilterDescriptor);
    ASSERT(OutDescriptor);

    NTSTATUS ntStatus = STATUS_SUCCESS;

    //
    // Calculate how much memory we will need.
    //
    PrivateHeap privateHeap;
    privateHeap.Reserve(sizeof(SUBDEVICE_DESCRIPTOR));
    privateHeap.Reserve(sizeof(KSTOPOLOGY));
    privateHeap.Reserve(sizeof(KSPIN_DESCRIPTOR) * pPcFilterDescriptor->PinCount);
    privateHeap.Reserve(sizeof(PIN_CINSTANCES)   * pPcFilterDescriptor->PinCount);
    privateHeap.Reserve(sizeof(PROPERTY_TABLE)   * pPcFilterDescriptor->PinCount);
    privateHeap.Reserve(sizeof(EVENT_TABLE)      * pPcFilterDescriptor->PinCount);

    if (pPcFilterDescriptor->NodeCount)
    {
        privateHeap.Reserve(sizeof(GUID) * pPcFilterDescriptor->NodeCount);
        privateHeap.Reserve(sizeof(GUID) * pPcFilterDescriptor->NodeCount);
    }

    const PCPIN_DESCRIPTOR *pPcPinDescriptor = pPcFilterDescriptor->Pins;
    for (ULONG ul = pPcFilterDescriptor->PinCount; ul--; )
    {
        if (pPcPinDescriptor->KsPinDescriptor.DataRanges)
        {
            MeasureDataRanges( &privateHeap,
                               pPcPinDescriptor->KsPinDescriptor.DataRangesCount,
                               pPcPinDescriptor->KsPinDescriptor.DataRanges );
            pPcPinDescriptor = PPCPIN_DESCRIPTOR(   PBYTE(pPcPinDescriptor) + pPcFilterDescriptor->PinSize );
        }
        else
        {
            ntStatus = STATUS_RANGE_NOT_FOUND;  //  DataRanges field is NULL
            break;                              //  Don't even bother, just exit
        }
    }

    if (NT_SUCCESS(ntStatus))   //  if fail above, fall through the rest
    {
        //
        // Allocate the required memory.
        //
        ntStatus = privateHeap.AllocateFromPool(PagedPool,'pFcP');
    }

    if (NT_SUCCESS(ntStatus))
    {
        PSUBDEVICE_DESCRIPTOR descr = new(privateHeap) SUBDEVICE_DESCRIPTOR;

        //
        // Set up pointers into one big chunk of memory.
        //
        descr->PinCount             = pPcFilterDescriptor->PinCount;

        descr->Topology             = new(privateHeap) KSTOPOLOGY;
        descr->PinDescriptors       = new(privateHeap) KSPIN_DESCRIPTOR[descr->PinCount];
        descr->PinInstances         = new(privateHeap) PIN_CINSTANCES[descr->PinCount];
        descr->PinPropertyTables    = new(privateHeap) PROPERTY_TABLE[descr->PinCount];
        descr->PinEventTables       = new(privateHeap) EVENT_TABLE[descr->PinCount];

        if (pPcFilterDescriptor->NodeCount)
        {
            descr->Topology->TopologyNodes = 
                new(privateHeap) GUID[pPcFilterDescriptor->NodeCount];
            descr->Topology->TopologyNodesNames = 
                new(privateHeap) GUID[pPcFilterDescriptor->NodeCount];
        }
        else
        {
            descr->Topology->TopologyNodes = NULL;
            descr->Topology->TopologyNodesNames = NULL;
        }

        //
        // Prefer the categories from the filter descriptor.
        //
        if (pPcFilterDescriptor->CategoryCount != 0)
        {
            descr->Topology->CategoriesCount    = pPcFilterDescriptor->CategoryCount;
            descr->Topology->Categories         = pPcFilterDescriptor->Categories;
        }
        else
        {
            descr->Topology->CategoriesCount    = CategoriesCount;
            descr->Topology->Categories         = Categories;
        }

        descr->Topology->TopologyNodesCount         = pPcFilterDescriptor->NodeCount;
        descr->Topology->TopologyConnectionsCount   = pPcFilterDescriptor->ConnectionCount;
        descr->Topology->TopologyConnections        = pPcFilterDescriptor->Connections;

        //
        // Initialize filter properties.
        //
        descr->FilterPropertyTable.PropertySetCount = FilterPropertySetCount;
        descr->FilterPropertyTable.PropertySets     = FilterPropertySets;
        descr->FilterPropertyTable.StaticSets       = TRUE;

        //
        // Initialize filter events.
        //
        descr->FilterEventTable.EventSetCount       = FilterEventSetCount;
        descr->FilterEventTable.EventSets           = FilterEventSets;
        descr->FilterEventTable.StaticSets          = TRUE;

        //
        // Copy node type and name and merge node properties and events.
        //
        const PCNODE_DESCRIPTOR *pPcNodeDescriptor = pPcFilterDescriptor->Nodes;
        GUID *pGuidType = (GUID *) descr->Topology->TopologyNodes;
        GUID *pGuidName = (GUID *) descr->Topology->TopologyNodesNames;
        for (ULONG node = pPcFilterDescriptor->NodeCount; node--; )
        {
            *pGuidType++ = *pPcNodeDescriptor->Type;
            if (pPcNodeDescriptor->Name)
            {
                *pGuidName++ = *pPcNodeDescriptor->Name;
            }
            else
            {
                *pGuidName++ = *pPcNodeDescriptor->Type;
            }

            if  (   (pPcNodeDescriptor->AutomationTable)
                &&  (pPcNodeDescriptor->AutomationTable->PropertyCount)
                )
            {
                PcAddToPropertyTable
                (
                    &descr->FilterPropertyTable,
                    pPcNodeDescriptor->AutomationTable->PropertyCount,
                    pPcNodeDescriptor->AutomationTable->Properties,
                    pPcNodeDescriptor->AutomationTable->PropertyItemSize,
                    TRUE
                );
            }

            if  (   (pPcNodeDescriptor->AutomationTable)
                &&  (pPcNodeDescriptor->AutomationTable->EventCount)
                )
            {
                PcAddToEventTable
                (
                    &descr->FilterEventTable,
                    pPcNodeDescriptor->AutomationTable->EventCount,
                    pPcNodeDescriptor->AutomationTable->Events,
                    pPcNodeDescriptor->AutomationTable->EventItemSize,
                    TRUE
                );
            }

            pPcNodeDescriptor = 
                PPCNODE_DESCRIPTOR
                (   PBYTE(pPcNodeDescriptor) + pPcFilterDescriptor->NodeSize
                );
        }

        //
        // Merge filter properties.
        //
        if  (   (pPcFilterDescriptor->AutomationTable)
            &&  (pPcFilterDescriptor->AutomationTable->PropertyCount)
            )
        {
            PcAddToPropertyTable
            (
                &descr->FilterPropertyTable,
                pPcFilterDescriptor->AutomationTable->PropertyCount,
                pPcFilterDescriptor->AutomationTable->Properties,
                pPcFilterDescriptor->AutomationTable->PropertyItemSize,
                FALSE
            );
        }

        //
        // Merge filter events.
        //
        if  (   (pPcFilterDescriptor->AutomationTable)
            &&  (pPcFilterDescriptor->AutomationTable->EventCount)
            )
        {
            PcAddToEventTable
            (
                &descr->FilterEventTable,
                pPcFilterDescriptor->AutomationTable->EventCount,
                pPcFilterDescriptor->AutomationTable->Events,
                pPcFilterDescriptor->AutomationTable->EventItemSize,
                FALSE
            );
        }

        //
        // Do per-pin stuff.
        //
        PPROPERTY_TABLE     pt  = descr->PinPropertyTables;
        PEVENT_TABLE        et  = descr->PinEventTables;
        PKSPIN_DESCRIPTOR   p   = descr->PinDescriptors;
        PPIN_CINSTANCES     i   = descr->PinInstances;

        pPcPinDescriptor = PPCPIN_DESCRIPTOR(pPcFilterDescriptor->Pins);
        for
        (
            ULONG pin = 0;
            pin < pPcFilterDescriptor->PinCount;
            pin++
        )
        {
            //
            // Find a pin that has the same property set.
            //
            PPROPERTY_TABLE twinPt = descr->PinPropertyTables;
            PPCPIN_DESCRIPTOR pPcPinDescriptorTwin = 
                PPCPIN_DESCRIPTOR(pPcFilterDescriptor->Pins);
            for
            (
                ULONG twinPin = 0;
                twinPin < pin;
                twinPin++, twinPt++
            )
            {
                if  (   (   pPcPinDescriptor->AutomationTable 
                        ==  pPcPinDescriptorTwin->AutomationTable
                        )
                    ||  (   pPcPinDescriptor->AutomationTable
                        &&  pPcPinDescriptorTwin->AutomationTable
                        &&  (   pPcPinDescriptor->AutomationTable->PropertyCount 
                            ==  pPcPinDescriptorTwin->AutomationTable->PropertyCount
                            )
                        &&  (   pPcPinDescriptor->AutomationTable->Properties 
                            ==  pPcPinDescriptorTwin->AutomationTable->Properties
                            )
                        &&  (   pPcPinDescriptor->AutomationTable->PropertyItemSize 
                            ==  pPcPinDescriptorTwin->AutomationTable->PropertyItemSize
                            )
                        )
                    )
                {
                    *pt = *twinPt;
                    break;
                }

                pPcPinDescriptorTwin = 
                    PPCPIN_DESCRIPTOR
                    (   PBYTE(pPcPinDescriptorTwin) + pPcFilterDescriptor->PinSize
                    );
            }

            //
            // Create a new table if we have to.
            //
            if (twinPin == pin)
            {
                pt->PropertySetCount = PinPropertySetCount;
                pt->PropertySets     = PinPropertySets;
                pt->StaticSets       = TRUE;

                if  (   (pPcPinDescriptor->AutomationTable)
                    &&  (pPcPinDescriptor->AutomationTable->PropertyCount)
                    )
                {
                    PcAddToPropertyTable
                    (
                        pt,
                        pPcPinDescriptor->AutomationTable->PropertyCount,
                        pPcPinDescriptor->AutomationTable->Properties,
                        pPcPinDescriptor->AutomationTable->PropertyItemSize,
                        FALSE
                    );
                }

                const PCNODE_DESCRIPTOR *pPcNodeDescriptor2 = pPcFilterDescriptor->Nodes;
                for (ULONG node = pPcFilterDescriptor->NodeCount; node--; )
                {
                    if  (   (pPcNodeDescriptor2->AutomationTable)
                        &&  (pPcNodeDescriptor2->AutomationTable->PropertyCount)
                        )
                    {
                        PcAddToPropertyTable
                        (
                            pt,
                            pPcNodeDescriptor2->AutomationTable->PropertyCount,
                            pPcNodeDescriptor2->AutomationTable->Properties,
                            pPcNodeDescriptor2->AutomationTable->PropertyItemSize,
                            TRUE
                        );
                    }

                    pPcNodeDescriptor2 = 
                        PPCNODE_DESCRIPTOR
                        (   PBYTE(pPcNodeDescriptor2) + pPcFilterDescriptor->NodeSize
                        );
                }
            }
            pt++;

            //
            // Find a pin that has the same event set.
            //
            PEVENT_TABLE twinEt = descr->PinEventTables;
            pPcPinDescriptorTwin = PPCPIN_DESCRIPTOR(pPcFilterDescriptor->Pins);
            for
            (
                ULONG twinEPin = 0;
                twinEPin < pin;
                twinEPin++, twinEt++
            )
            {
                if  (   (   pPcPinDescriptor->AutomationTable 
                        ==  pPcPinDescriptorTwin->AutomationTable
                        )
                    ||  (   pPcPinDescriptor->AutomationTable
                        &&  pPcPinDescriptorTwin->AutomationTable
                        &&  (   pPcPinDescriptor->AutomationTable->EventCount 
                            ==  pPcPinDescriptorTwin->AutomationTable->EventCount
                            )
                        &&  (   pPcPinDescriptor->AutomationTable->Events
                            ==  pPcPinDescriptorTwin->AutomationTable->Events
                            )
                        &&  (   pPcPinDescriptor->AutomationTable->EventItemSize 
                            ==  pPcPinDescriptorTwin->AutomationTable->EventItemSize
                            )
                        )
                    )
                {
                    *et = *twinEt;
                    break;
                }

                pPcPinDescriptorTwin = 
                    PPCPIN_DESCRIPTOR
                    (   PBYTE(pPcPinDescriptorTwin) + pPcFilterDescriptor->PinSize
                    );
            }

            //
            // Create a new table if we have to.
            //
            if  (twinEPin == pin)
            {
                et->EventSetCount = PinEventSetCount;
                et->EventSets     = PinEventSets;
                et->StaticSets    = TRUE;

                if  (   (pPcPinDescriptor->AutomationTable)
                    &&  (pPcPinDescriptor->AutomationTable->EventCount)
                    )
                {
                    PcAddToEventTable
                    (
                        et,
                        pPcPinDescriptor->AutomationTable->EventCount,
                        pPcPinDescriptor->AutomationTable->Events,
                        pPcPinDescriptor->AutomationTable->EventItemSize,
                        FALSE
                    );
                }

                const PCNODE_DESCRIPTOR *pPcNodeDescriptor2 = pPcFilterDescriptor->Nodes;
                for( ULONG node = pPcFilterDescriptor->NodeCount; node--; )
                {
                    if  (   (pPcNodeDescriptor2->AutomationTable)
                        &&  (pPcNodeDescriptor2->AutomationTable->EventCount)
                        )
                    {
                        PcAddToEventTable
                        (
                            et,
                            pPcNodeDescriptor2->AutomationTable->EventCount,
                            pPcNodeDescriptor2->AutomationTable->Events,
                            pPcNodeDescriptor2->AutomationTable->EventItemSize,
                            TRUE
                        );
                    }

                    pPcNodeDescriptor2 = PPCNODE_DESCRIPTOR( PBYTE(pPcNodeDescriptor2) + pPcFilterDescriptor->NodeSize );
                }
            }
            et++;

            //
            // Copy the KS descriptor.
            //
            *p = pPcPinDescriptor->KsPinDescriptor;

            //
            // Provide default mediums if necessary.
            //
            if (p->Mediums == NULL)
            {
                p->MediumsCount = SIZEOF_ARRAY(PinMediums);
                p->Mediums      = PinMediums;
            }

            //
            // Massage the data ranges.
            //
            p->DataRanges =
                CloneDataRanges
                (
                    privateHeap,
                    &p->DataRangesCount,
                    pPcPinDescriptor->KsPinDescriptor.DataRangesCount,
                    pPcPinDescriptor->KsPinDescriptor.DataRanges
                );
                
            //
            // Provide default interfaces if necessary.
            //
            if  (   (p->Communication & KSPIN_COMMUNICATION_BOTH)
                &&  (p->Interfaces == NULL)
                )
            {
                p->InterfacesCount  = StreamInterfacesCount;
                p->Interfaces       = StreamInterfaces;
            }
            p++;

            i->FilterPossible   = pPcPinDescriptor->MaxFilterInstanceCount;
            i->FilterNecessary  = pPcPinDescriptor->MinFilterInstanceCount;
            i->GlobalPossible   = pPcPinDescriptor->MaxGlobalInstanceCount;
            i->GlobalCurrent    = 0;
            i++;

            pPcPinDescriptor = 
                PPCPIN_DESCRIPTOR
                (   PBYTE(pPcPinDescriptor) + pPcFilterDescriptor->PinSize
                );
        }

        *OutDescriptor = descr;

        ASSERT(privateHeap.BytesRemaining() == 0);
    }

    return ntStatus;
}

/*****************************************************************************
 * PcDeleteSubdeviceDescriptor()
 *****************************************************************************
 * Deletes a subdevice descriptor.
 */
PORTCLASSAPI
void
NTAPI
PcDeleteSubdeviceDescriptor
(
    IN      PSUBDEVICE_DESCRIPTOR   pSubdeviceDescriptor
)
{
    //
    // Free allocated memory for filter property and event tables.
    //
    PcFreePropertyTable(&pSubdeviceDescriptor->FilterPropertyTable);
    PcFreeEventTable(&pSubdeviceDescriptor->FilterEventTable);

    //
    // Free allocated memory for pin property tables.
    //
    PPROPERTY_TABLE pPropertyTable = pSubdeviceDescriptor->PinPropertyTables;
    for (ULONG ul = pSubdeviceDescriptor->PinCount; ul--; pPropertyTable++)
    {
        //
        // Find and clear any references to the same property set.
        //
        for 
        (   PPROPERTY_TABLE pPropertyTableTwin = 
            (   pSubdeviceDescriptor->PinPropertyTables 
            +   (   pSubdeviceDescriptor->PinCount 
                -   1
                )
            )
        ;   pPropertyTableTwin != pPropertyTable
        ;   pPropertyTableTwin--
        )
        {
            if  
            (   pPropertyTableTwin->PropertySets 
            ==  pPropertyTable->PropertySets
            )
            {
                pPropertyTableTwin->PropertySetCount    = 0;
                pPropertyTableTwin->PropertySets        = NULL;
                pPropertyTableTwin->StaticSets          = TRUE;
                pPropertyTableTwin->StaticItems         = NULL;
            }
        }

        PcFreePropertyTable(pPropertyTable);
    }

    //
    // Free allocated memory for pin event tables.
    //
    PEVENT_TABLE pEventTable = pSubdeviceDescriptor->PinEventTables;
    for (ul = pSubdeviceDescriptor->PinCount; ul--; pEventTable++)
    {
        //
        // Find and clear any references to the same event set.
        //
        for 
        (   PEVENT_TABLE pEventTableTwin = 
            (   pSubdeviceDescriptor->PinEventTables 
            +   (   pSubdeviceDescriptor->PinCount 
                -   1
                )
            )
        ;   pEventTableTwin != pEventTable
        ;   pEventTableTwin--
        )
        {
            if  
            (   pEventTableTwin->EventSets 
            ==  pEventTable->EventSets
            )
            {
                pEventTableTwin->EventSetCount      = 0;
                pEventTableTwin->EventSets          = NULL;
                pEventTableTwin->StaticSets         = TRUE;
                pEventTableTwin->StaticItems        = NULL;
            }
        }

        PcFreeEventTable(pEventTable);
    }

    //
    // The rest is one big chunk.
    //
    delete [] PBYTE(pSubdeviceDescriptor);
}

/*****************************************************************************
 * PcValidateConnectRequest()
 *****************************************************************************
 * Validate attempt to create a pin.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcValidateConnectRequest
(   IN      PIRP                    pIrp
,   IN      PSUBDEVICE_DESCRIPTOR   pSubdeviceDescriptor
,   OUT     PKSPIN_CONNECT *        ppKsPinConnect
)
{
    PAGED_CODE();

    ASSERT(pIrp);
    ASSERT(pSubdeviceDescriptor);
    ASSERT(ppKsPinConnect);

    NTSTATUS ntStatus =
        KsValidateConnectRequest
        (   pIrp
        ,   pSubdeviceDescriptor->PinCount
        ,   pSubdeviceDescriptor->PinDescriptors
        ,   ppKsPinConnect
        );

    return ntStatus;
}

/*****************************************************************************
 * PcValidatePinCount()
 *****************************************************************************
 * Validate pin count.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcValidatePinCount
(   IN      ULONG                   ulPinId
,   IN      PSUBDEVICE_DESCRIPTOR   pSubdeviceDescriptor
,   IN      PULONG                  pulPinInstanceCounts
)
{
    PAGED_CODE();

    ASSERT(pSubdeviceDescriptor);
    ASSERT(pulPinInstanceCounts);

    NTSTATUS ntStatus = STATUS_SUCCESS;

    if 
    (   (   pSubdeviceDescriptor->PinInstances[ulPinId].GlobalCurrent
        <   pSubdeviceDescriptor->PinInstances[ulPinId].GlobalPossible
        )
    ||  (   pulPinInstanceCounts[ulPinId]
        <   pSubdeviceDescriptor->PinInstances[ulPinId].FilterPossible
        )
    )
    {
        pSubdeviceDescriptor->PinInstances[ulPinId].GlobalCurrent++;
        pulPinInstanceCounts[ulPinId]++;

        _DbgPrintF( DEBUGLVL_VERBOSE, 
        (   "Create pin %d:  global=%d  local=%d"
        ,   ulPinId
        ,   pSubdeviceDescriptor->PinInstances[ulPinId].GlobalCurrent
        ,   pulPinInstanceCounts[ulPinId]
        ));
    }
    else
    {
        // TODO:  What code?
        ntStatus = STATUS_UNSUCCESSFUL;
    }

    return ntStatus;
}

/*****************************************************************************
 * PcValidateDeviceContext()
 *****************************************************************************
 * Probes DeviceContext for writing.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcValidateDeviceContext
(   IN      PDEVICE_CONTEXT         pDeviceContext,
    IN      PIRP                    pIrp
)
{
    PAGED_CODE();

    NTSTATUS ntStatus = STATUS_SUCCESS;

    if (NULL == pDeviceContext)
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("PcValidateDeviceContext : pDeviceContext = NULL"));
        return STATUS_INVALID_PARAMETER;
    }

    // validate the pointers if we don't trust the client
    //
    /*
    // ISSUE ALPERS 2000/12/20 -     The Probe call is disabled because it always generates an exception.
    // Therefore it is disabled.

    if (KernelMode != pIrp->RequestorMode)
    {
        __try
        {
            ProbeForRead(   pDeviceContext,
                            sizeof(*pDeviceContext),
                            sizeof(BYTE));
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            ntStatus = GetExceptionCode();
            _DbgPrintF(DEBUGLVL_TERSE, ("PcValidateDeviceContext : ProbeForWrite failed %X", ntStatus));
        }
    }
    */

    if (NT_SUCCESS(ntStatus)) 
    {
        if (PORTCLS_DEVICE_EXTENSION_SIGNATURE != pDeviceContext->Signature ) 
        {
            ntStatus = STATUS_INVALID_PARAMETER;
            _DbgPrintF(DEBUGLVL_TERSE, ("PcValidateDeviceContext : Invalid Extension Signature"));
        }
    }

    return ntStatus;
} // PcValidateDeviceContext

/*****************************************************************************
 * PcTerminateConnection()
 *****************************************************************************
 * Decrement instance counts associated with a pin.
 */
PORTCLASSAPI
void
NTAPI
PcTerminateConnection
(   IN      PSUBDEVICE_DESCRIPTOR   pSubdeviceDescriptor
,   IN      PULONG                  pulPinInstanceCounts
,   IN      ULONG                   ulPinId
)
{
    PAGED_CODE();

    ASSERT(pSubdeviceDescriptor);
    ASSERT(pulPinInstanceCounts);
    ASSERT(ulPinId <= pSubdeviceDescriptor->PinCount);

    pSubdeviceDescriptor->PinInstances[ulPinId].GlobalCurrent--;
    pulPinInstanceCounts[ulPinId]--;

    _DbgPrintF( DEBUGLVL_VERBOSE, 
    (   "Delete pin %d:  global=%d  local=%d"
    ,   ulPinId
    ,   pSubdeviceDescriptor->PinInstances[ulPinId].GlobalCurrent
    ,   pulPinInstanceCounts[ulPinId]
    ));
}

/*****************************************************************************
 * PcVerifyFilterIsReady()
 *****************************************************************************
 * Verify necessary pins are connected.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcVerifyFilterIsReady
(   IN      PSUBDEVICE_DESCRIPTOR   pSubdeviceDescriptor
,   IN      PULONG                  pulPinInstanceCounts
)
{
    PAGED_CODE();

    ASSERT(pSubdeviceDescriptor);
    ASSERT(pulPinInstanceCounts);

    NTSTATUS ntStatus = STATUS_SUCCESS;
    for 
    (   ULONG ulPinId = 0
    ;   ulPinId < pSubdeviceDescriptor->PinCount
    ;   ulPinId++
    )
    {
        if 
        (   pulPinInstanceCounts[ulPinId]
        <   pSubdeviceDescriptor->PinInstances[ulPinId].FilterNecessary
        )
        {
            // TODO:  What code?
            ntStatus = STATUS_UNSUCCESSFUL;
            break;
        }
    }

    return ntStatus;
}

#define END_NONE 0
#define END_FROM 1
#define END_TO   2
#define END_BOTH 3

/*****************************************************************************
 * FindConnectionToPin()
 *****************************************************************************
 * Find a connection that connects to a given node or filter pin.
 *
 *      ulNode          - node number of KSFILTER_NODE
 *      ulConnection    - in: connection to start with
 *                        out: found connection or ULONG(-1) if not found
 *
 *      return          - 0 for no connection found
 *                        END_FROM for outgoing connection
 *                        END_TO for incoming connection
 */
ULONG
FindConnectionToPin
(
    IN      ULONG                       ulNode,
    IN      ULONG                       ulPin,
    IN      PKSTOPOLOGY                 pKsTopology,
    IN OUT  PULONG                      ulConnection,
    OUT     PKSTOPOLOGY_CONNECTION *    ppKsTopologyConnection  OPTIONAL
)
{
    ASSERT(pKsTopology);
    ASSERT(ulConnection);
    ASSERT(*ulConnection < pKsTopology->TopologyConnectionsCount);

    ULONG ulEnd;

    PKSTOPOLOGY_CONNECTION pKsTopologyConnection =
        PKSTOPOLOGY_CONNECTION
        (
            &pKsTopology->TopologyConnections[*ulConnection]
        );

    while (1)
    {
        ASSERT(*ulConnection <= pKsTopology->TopologyConnectionsCount);

        if (*ulConnection == pKsTopology->TopologyConnectionsCount)
        {
            ulEnd = END_NONE;
            *ulConnection = ULONG(-1);
            pKsTopologyConnection = NULL;
            break;
        }
        else
        if  (   (pKsTopologyConnection->FromNode == ulNode)
            &&  (pKsTopologyConnection->FromNodePin == ulPin)
            )
        {
            ulEnd = END_FROM;
            break;
        }
        else
        if  (   (pKsTopologyConnection->ToNode == ulNode)
            &&  (pKsTopologyConnection->ToNodePin == ulPin)
            )
        {
            ulEnd = END_TO;
            break;
        }

        (*ulConnection)++;
        pKsTopologyConnection++;
    }

    if (ppKsTopologyConnection)
    {
        *ppKsTopologyConnection = pKsTopologyConnection;
    }

    return ulEnd;
}

/*****************************************************************************
 * FindConnectionToNode()
 *****************************************************************************
 * Find a connection that connects to a given node or to the filter.
 *
 *      ulNode          - node number of KSFILTER_NODE
 *      ulEnd           - 0 for any direction
 *                        END_FROM for outgoing connection
 *                        END_TO for incoming connection
 *      ulConnection    - in: connection to start with
 *                        out: found connection or ULONG(-1) if not found
 *
 *      return          - 0 for no connection found
 *                        END_FROM for outgoing connection
 *                        END_TO for incoming connection
 */
ULONG
FindConnectionToNode
(
    IN      ULONG                       ulNode,
    IN      ULONG                       ulEnd,
    IN      PKSTOPOLOGY                 pKsTopology,
    IN OUT  PULONG                      ulConnection,
    OUT     PKSTOPOLOGY_CONNECTION *    ppKsTopologyConnection  OPTIONAL
)
{
    ASSERT(pKsTopology);
    ASSERT  
    (   (ulNode == KSFILTER_NODE) 
    ||  (ulNode < pKsTopology->TopologyNodesCount)
    );
    ASSERT(ulConnection);
    ASSERT(*ulConnection < pKsTopology->TopologyConnectionsCount);

    PKSTOPOLOGY_CONNECTION pKsTopologyConnection =
        PKSTOPOLOGY_CONNECTION
        (
            &pKsTopology->TopologyConnections[*ulConnection]
        );

    while (1)
    {
        ASSERT(*ulConnection <= pKsTopology->TopologyConnectionsCount);

        if (*ulConnection == pKsTopology->TopologyConnectionsCount)
        {
            ulEnd = END_NONE;
            *ulConnection = ULONG(-1);
            pKsTopologyConnection = NULL;
            break;
        }
        else
        if  (   (pKsTopologyConnection->FromNode == ulNode)
            &&  (ulEnd != END_TO)
            )
        {
            ulEnd = END_FROM;
            break;
        }
        else
        if  (   (pKsTopologyConnection->ToNode == ulNode)
            &&  (ulEnd != END_FROM)
            )
        {
            ulEnd = END_TO;
            break;
        }

        (*ulConnection)++;
        pKsTopologyConnection++;
    }

    if (ppKsTopologyConnection)
    {
        *ppKsTopologyConnection = pKsTopologyConnection;
    }

    return ulEnd;
}

/*****************************************************************************
 * NodeIsTransform()
 *****************************************************************************
 * Determines if a node is a transform.  KSFILTER_NODE is handled (FALSE).
 */
BOOLEAN
NodeIsTransform
(
    IN      ULONG       ulNode,
    IN      PKSTOPOLOGY pKsTopology
)
{
    ASSERT(pKsTopology);
    ASSERT  
    (   (ulNode == KSFILTER_NODE) 
    ||  (ulNode < pKsTopology->TopologyNodesCount)
    );

    ULONG ulEnd = END_NONE;

    if (ulNode != KSFILTER_NODE)
    {
        PKSTOPOLOGY_CONNECTION pKsTopologyConnection =
            PKSTOPOLOGY_CONNECTION(pKsTopology->TopologyConnections);

        for
        (
            ULONG ul = pKsTopology->TopologyConnectionsCount;
            ul--;
            pKsTopologyConnection++
        )
        {
            if (pKsTopologyConnection->FromNode == ulNode)
            {
                ulEnd += END_FROM;

                if  (   (ulEnd != END_FROM)
                    &&  (ulEnd != END_BOTH)
                    )
                {
                    break;
                }
            }
            if (pKsTopologyConnection->ToNode == ulNode)
            {
                ulEnd += END_TO;

                if  (   (ulEnd != END_TO)
                    &&  (ulEnd != END_BOTH)
                    )
                {
                    break;
                }
            }
        }
    }

    return ulEnd == END_BOTH;
}

/*****************************************************************************
 * NodeAtThisEnd()
 *****************************************************************************
 * Node at indicated end of the connection.
 */
inline
ULONG
NodeAtThisEnd
(
    IN      ULONG                   ulEnd,
    IN      PKSTOPOLOGY_CONNECTION  pKsTopologyConnection
)
{
    return
        (   (ulEnd == END_FROM) 
        ?   pKsTopologyConnection->FromNode
        :   pKsTopologyConnection->ToNode
        );
}

/*****************************************************************************
 * NodeAtOtherEnd()
 *****************************************************************************
 * Node at opposite end of the connection.
 */
inline
ULONG
NodeAtOtherEnd
(
    IN      ULONG                   ulEnd,
    IN      PKSTOPOLOGY_CONNECTION  pKsTopologyConnection
)
{
    return
        (   (ulEnd == END_FROM) 
        ?   pKsTopologyConnection->ToNode
        :   pKsTopologyConnection->FromNode
        );
}

/*****************************************************************************
 * PcCaptureFormat()
 *****************************************************************************
 * Capture a data format in an allocated buffer, possibly changing offensive
 * formats.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcCaptureFormat
(
    OUT     PKSDATAFORMAT *         ppKsDataFormatOut,
    IN      PKSDATAFORMAT           pKsDataFormatIn,
    IN      PSUBDEVICE_DESCRIPTOR   pSubdeviceDescriptor,
    IN      ULONG                   ulPinId
)
{
    ASSERT(ppKsDataFormatOut);
    ASSERT(pKsDataFormatIn);
    ASSERT(pSubdeviceDescriptor);
    ASSERT(ulPinId < pSubdeviceDescriptor->PinCount);

    NTSTATUS ntStatus = STATUS_SUCCESS;

    if( (pKsDataFormatIn->FormatSize >= sizeof(KSDATAFORMAT_DSOUND)) &&
        IsEqualGUIDAligned( pKsDataFormatIn->MajorFormat, KSDATAFORMAT_TYPE_AUDIO ) &&
        IsEqualGUIDAligned( pKsDataFormatIn->Specifier, KSDATAFORMAT_SPECIFIER_DSOUND ) )
    {
        //
        // This is the dread DSound format.  Check to see if we have the
        // required topology and convert to WaveFormatEx if we do.
        //
        // Note: DSound format does not have to be PCM....
        //
        PKSDATAFORMAT_DSOUND pKsDataFormatDSound = 
            PKSDATAFORMAT_DSOUND(pKsDataFormatIn);

        //
        // Fail if the client has asked for a software buffer.
        //
        if  (   pKsDataFormatDSound->BufferDesc.Flags 
            &   KSDSOUND_BUFFER_LOCSOFTWARE
            )
        {
            _DbgPrintF(DEBUGLVL_TERSE,("PcCaptureFormat  Failed because client requested software buffer."));
            return STATUS_INVALID_PARAMETER;
        }

        //
        // Find a connection involving the filter pin.
        //
        ULONG ulConnection = 0;
        PKSTOPOLOGY_CONNECTION pKsTopologyConnection;
        ULONG ulEnd =
            FindConnectionToPin
            (
                KSFILTER_NODE,
                ulPinId,
                pSubdeviceDescriptor->Topology,
                &ulConnection,
                &pKsTopologyConnection
            );

        //
        // Trace the topology until we find a non-transform or all the
        // required nodes have been found.  Position notification is
        // always supported.
        //
        ULONG ulMissing = 
            (   pKsDataFormatDSound->BufferDesc.Control
            &   ~KSDSOUND_BUFFER_CTRL_POSITIONNOTIFY
            );

        while (ulMissing && ulEnd)
        {
            //
            // Found a connection.  Follow the topology.
            //
            ULONG ulNode = NodeAtOtherEnd(ulEnd,pKsTopologyConnection);

            if (! NodeIsTransform(ulNode,pSubdeviceDescriptor->Topology))
            {
                //
                // The new node is not a simple transform (1 in, 1 out).
                //
                break;
            }

            //
            // Drop 'missing' bits as appropriate based on the node GUID.
            //
            ASSERT(ulNode < pSubdeviceDescriptor->Topology->TopologyNodesCount);
            const GUID *pGuid = &pSubdeviceDescriptor->Topology->TopologyNodes[ulNode];
            if (IsEqualGUIDAligned(*pGuid,KSNODETYPE_3D_EFFECTS))
            {
                ulMissing &=~ KSDSOUND_BUFFER_CTRL_3D;
            }
            else
            if (IsEqualGUIDAligned(*pGuid,KSNODETYPE_SRC))
            {
                ulMissing &=~ KSDSOUND_BUFFER_CTRL_FREQUENCY;
            }
            else
            if  (   IsEqualGUIDAligned(*pGuid,KSNODETYPE_SUPERMIX)
                ||  IsEqualGUIDAligned(*pGuid,KSNODETYPE_VOLUME)
                )
            {
                ulMissing &=~ KSDSOUND_BUFFER_CTRL_PAN;
                ulMissing &=~ KSDSOUND_BUFFER_CTRL_VOLUME;
            }

            //
            // Find the next connection in line.
            //
            ulConnection = 0;
            ulEnd =
                FindConnectionToNode
                (
                    ulNode,
                    ulEnd,
                    pSubdeviceDescriptor->Topology,
                    &ulConnection,
                    &pKsTopologyConnection
                );
        }

        //
        // Make sure no nodes were missing.
        //
        if (! ulMissing)
        {
            //
            // We have the capabilities required.  Build the new format.
            //
            ULONG ulSize =
                (   sizeof(KSDATAFORMAT_WAVEFORMATEX)
                +   (   pKsDataFormatIn->FormatSize 
                    -   sizeof(KSDATAFORMAT_DSOUND)
                    )
                );
            *ppKsDataFormatOut =
                PKSDATAFORMAT
                (
                    ExAllocatePoolWithTag
                    (
                        PagedPool,
                        ulSize,
                        'fDcP'
                    )
                );

            if (*ppKsDataFormatOut)
            {
                //
                // Copy KSDATAFORMAT part.
                //
                RtlCopyMemory
                (
                    *ppKsDataFormatOut,
                    pKsDataFormatIn,
                    sizeof(KSDATAFORMAT)
                );

                //
                // Copy WAVEFORMATEX part including appended stuff.
                //
                RtlCopyMemory
                (
                    *ppKsDataFormatOut + 1,
                    &pKsDataFormatDSound->BufferDesc.WaveFormatEx,
                    ulSize - sizeof(KSDATAFORMAT)
                );

                //
                // Adjust size and specifier.
                //
                (*ppKsDataFormatOut)->FormatSize = ulSize;
                (*ppKsDataFormatOut)->Specifier = 
                    KSDATAFORMAT_SPECIFIER_WAVEFORMATEX;
            }
            else
            {
                _DbgPrintF(DEBUGLVL_TERSE,("PcCaptureFormat  Failed to allocate memory for format."));
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        else
        {
            _DbgPrintF(DEBUGLVL_VERBOSE,("PcCaptureFormat  Failed due to lack of feature support (0x%08x).",ulMissing));
            //
            // Don't have the required nodes...fail.
            //
            ntStatus = STATUS_INVALID_PARAMETER;
        }
    }
    else
    {
        _DbgPrintF(DEBUGLVL_VERBOSE,("PcCaptureFormat  Format captured as-is."));

        //
        // Some other format.  Just capture it.
        //
        *ppKsDataFormatOut = PKSDATAFORMAT(ExAllocatePoolWithTag(PagedPool,
                                                                 pKsDataFormatIn->FormatSize,
                                                                 'fDcP'));

        if (*ppKsDataFormatOut)
        {
            RtlCopyMemory
            (
                *ppKsDataFormatOut,
                pKsDataFormatIn,
                pKsDataFormatIn->FormatSize
            );
        }
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE,("PcCaptureFormat  Failed to allocate memory for format."));
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    // check to verify SampleSize is set properly on waveformatex formats
    if( NT_SUCCESS(ntStatus) && 
        IsEqualGUIDAligned((*ppKsDataFormatOut)->MajorFormat,KSDATAFORMAT_TYPE_AUDIO) && 
        IsEqualGUIDAligned((*ppKsDataFormatOut)->Specifier,  KSDATAFORMAT_SPECIFIER_WAVEFORMATEX))
    {
        PKSDATAFORMAT_WAVEFORMATEX pWaveFormat = PKSDATAFORMAT_WAVEFORMATEX(*ppKsDataFormatOut);

        if( 0 == pWaveFormat->DataFormat.SampleSize )
        {
            pWaveFormat->DataFormat.SampleSize = pWaveFormat->WaveFormatEx.nBlockAlign;
        }
    }

    return ntStatus;
}

/*****************************************************************************
 * PcAcquireFormatResources()
 *****************************************************************************
 * Acquire resources specified in a format.
 */
PORTCLASSAPI
void
NTAPI
PcAcquireFormatResources
(
    IN      PKSDATAFORMAT           pKsDataFormatIn,
    IN      PSUBDEVICE_DESCRIPTOR   pSubdeviceDescriptor,
    IN      ULONG                   ulPinId,
    IN      PPROPERTY_CONTEXT       pPropertyContext
)
{
    ASSERT(pKsDataFormatIn);
    ASSERT(pSubdeviceDescriptor);
    ASSERT(ulPinId < pSubdeviceDescriptor->PinCount);
    ASSERT(pPropertyContext);

    KSP_NODE ksPNode;
    ksPNode.Property.Set    = KSPROPSETID_TopologyNode;
    ksPNode.Property.Id     = KSPROPERTY_TOPOLOGYNODE_ENABLE;
    ksPNode.Property.Flags  = KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_TOPOLOGY;
    ksPNode.NodeId          = 0;    // Fill in later
    ksPNode.Reserved        = 0;

    if  (   (pKsDataFormatIn->FormatSize >= sizeof(KSDATAFORMAT_DSOUND))
        &&  IsEqualGUIDAligned
            (   pKsDataFormatIn->MajorFormat,
                KSDATAFORMAT_TYPE_AUDIO
            )
        &&  IsEqualGUIDAligned
            (   pKsDataFormatIn->Specifier,
                KSDATAFORMAT_SPECIFIER_DSOUND
            )
        )
    {
        //
        // This is the dreaded DSound format.  Turn on all the nodes
        // that are specified in the caps bits.
        //
        PKSDATAFORMAT_DSOUND pKsDataFormatDSound = 
            PKSDATAFORMAT_DSOUND(pKsDataFormatIn);

        //
        // Find a connection involving the filter pin.
        //
        ULONG ulConnection = 0;
        PKSTOPOLOGY_CONNECTION pKsTopologyConnection;
        ULONG ulEnd =
            FindConnectionToPin
            (
                KSFILTER_NODE,
                ulPinId,
                pSubdeviceDescriptor->Topology,
                &ulConnection,
                &pKsTopologyConnection
            );

        //
        // Trace the topology until we find a non-transform or all the
        // required nodes have been found.  Position notification is
        // always supported.
        //
        ULONG ulMissing = 
            (   pKsDataFormatDSound->BufferDesc.Control
            &   (   KSDSOUND_BUFFER_CTRL_3D
                |   KSDSOUND_BUFFER_CTRL_FREQUENCY
                )
            );

        while (ulMissing && ulEnd)
        {
            //
            // Found a connection.  Follow the topology.
            //
            ULONG ulNode = NodeAtOtherEnd(ulEnd,pKsTopologyConnection);

            if (! NodeIsTransform(ulNode,pSubdeviceDescriptor->Topology))
            {
                //
                // The new node is not a simple transform (1 in, 1 out).
                //
                break;
            }

            //
            // Turn on nodes as appropriate based on the node GUID.
            //
            ASSERT(ulNode < pSubdeviceDescriptor->Topology->TopologyNodesCount);
            const GUID *pGuid = &pSubdeviceDescriptor->Topology->TopologyNodes[ulNode];
            if (IsEqualGUIDAligned(*pGuid,KSNODETYPE_3D_EFFECTS))
            {
                if (ulMissing & KSDSOUND_BUFFER_CTRL_3D)
                {
                    //
                    // Turn on the 3D node.
                    //
                    ULONG ulPropertyValue = TRUE;
                    ULONG ulPropertyValueSize = sizeof(ULONG);
                    ksPNode.NodeId = ulNode;

                    PcDispatchProperty
                    (   NULL    // pIrp
                    ,   pPropertyContext
                    ,   NULL    // pKsPropertySet
                    ,   sizeof(KSP_NODE)
                    ,   &ksPNode.Property
                    ,   &ulPropertyValueSize
                    ,   &ulPropertyValue
                    );

                    ulMissing &=~ KSDSOUND_BUFFER_CTRL_3D;
                }
            }
            else
            if (IsEqualGUIDAligned(*pGuid,KSNODETYPE_SRC))
            {
                if (ulMissing & KSDSOUND_BUFFER_CTRL_FREQUENCY)
                {
                    //
                    // Turn on the SRC node.
                    //
                    ULONG ulPropertyValue = TRUE;
                    ULONG ulPropertyValueSize = sizeof(ULONG);
                    ksPNode.NodeId = ulNode;

                    PcDispatchProperty
                    (   NULL    // pIrp
                    ,   pPropertyContext
                    ,   NULL    // pKsPropertySet
                    ,   sizeof(KSP_NODE)
                    ,   &ksPNode.Property
                    ,   &ulPropertyValueSize
                    ,   &ulPropertyValue
                    );

                    ulMissing &=~ KSDSOUND_BUFFER_CTRL_FREQUENCY;
                }
            }

            //
            // Find the next connection in line.
            //
            ulConnection = 0;
            ulEnd =
                FindConnectionToNode
                (
                    ulNode,
                    ulEnd,
                    pSubdeviceDescriptor->Topology,
                    &ulConnection,
                    &pKsTopologyConnection
                );
        }
    }
}

#pragma code_seg()

/*****************************************************************************
 * PcRegisterIoTimeout()
 *****************************************************************************
 * Registers an IoTimeout callback.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcRegisterIoTimeout
(
    IN      PDEVICE_OBJECT      pDeviceObject,
    IN      PIO_TIMER_ROUTINE   pTimerRoutine,
    IN      PVOID               pContext
)
{
    KIRQL               OldIrql;
    PTIMEOUTCALLBACK    TimeoutCallback;
    NTSTATUS            ntStatus = STATUS_SUCCESS;

    ASSERT(pDeviceObject);
    ASSERT(pTimerRoutine);
    ASSERT( PASSIVE_LEVEL == KeGetCurrentIrql() );

    //
    // Validate Parameters.
    //
    if (NULL == pDeviceObject ||
        NULL == pTimerRoutine ||
        NULL == pDeviceObject->DeviceExtension)
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("PcRegisterIoTimeout : Invalid Parameter"));
        return STATUS_INVALID_PARAMETER;
    }

    // get the device context
    PDEVICE_CONTEXT pDeviceContext = PDEVICE_CONTEXT(pDeviceObject->DeviceExtension);

    // allocate a timeout callback structure -- 'PcTc'
    TimeoutCallback = PTIMEOUTCALLBACK(ExAllocatePoolWithTag( NonPagedPool, sizeof(TIMEOUTCALLBACK),'cTcP' ));  
    if( TimeoutCallback )
    {
        // initialize the entry
        TimeoutCallback->TimerRoutine = pTimerRoutine;
        TimeoutCallback->Context = pContext;

        // grab the list spin lock
        KeAcquireSpinLock( &(pDeviceContext->TimeoutLock), &OldIrql );

        // walk the list to see if the entry is already registered
        if( !IsListEmpty( &(pDeviceContext->TimeoutList) ) )
        {
            PLIST_ENTRY         ListEntry;
            PTIMEOUTCALLBACK    pCallback;

            for( ListEntry = pDeviceContext->TimeoutList.Flink;
                 ListEntry != &(pDeviceContext->TimeoutList);
                 ListEntry = ListEntry->Flink )
            {
                pCallback = (PTIMEOUTCALLBACK) CONTAINING_RECORD( ListEntry,
                                                                  TIMEOUTCALLBACK,
                                                                  ListEntry );
                if( (pCallback->TimerRoutine == pTimerRoutine) &&
                    (pCallback->Context == pContext) )
                {
                    // entry already exists in the list, so fail this request
                    ntStatus = STATUS_UNSUCCESSFUL;
                }
            }            
        }

        if( NT_SUCCESS(ntStatus) )
        {
            // add the entry to the list
            InsertTailList( &(pDeviceContext->TimeoutList), &(TimeoutCallback->ListEntry) );
        }
        else
        {
            // free the entry
            ExFreePool( TimeoutCallback );
        }

        // release the spin lock
        KeReleaseSpinLock( &(pDeviceContext->TimeoutLock), OldIrql );
    }
    else
    {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;    
}

/*****************************************************************************
 * PcUnregisterIoTimeout()
 *****************************************************************************
 * Unregisters an IoTimeout callback.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcUnregisterIoTimeout
(
    IN      PDEVICE_OBJECT      pDeviceObject,
    IN      PIO_TIMER_ROUTINE   pTimerRoutine,
    IN      PVOID               pContext
)
{
    KIRQL       OldIrql;

    ASSERT(pDeviceObject);
    ASSERT(pTimerRoutine);
    ASSERT( PASSIVE_LEVEL == KeGetCurrentIrql() );

    //
    // Validate Parameters.
    //
    if (NULL == pDeviceObject ||
        NULL == pTimerRoutine ||
        NULL == pDeviceObject->DeviceExtension)
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("PcUnregisterIoTimeout : Invalid Parameter"));
        return STATUS_INVALID_PARAMETER;
    }

    // get the device context
    PDEVICE_CONTEXT pDeviceContext = PDEVICE_CONTEXT(pDeviceObject->DeviceExtension);

    // grab the spin lock
    KeAcquireSpinLock( &(pDeviceContext->TimeoutLock), &OldIrql );

    // walk the list
    if( !IsListEmpty( &(pDeviceContext->TimeoutList) ) )
    {
        PLIST_ENTRY         ListEntry;
        PTIMEOUTCALLBACK    pCallback;

        for( ListEntry = pDeviceContext->TimeoutList.Flink;
             ListEntry != &(pDeviceContext->TimeoutList);
             ListEntry = ListEntry->Flink )
        {
            pCallback = (PTIMEOUTCALLBACK) CONTAINING_RECORD( ListEntry,
                                                              TIMEOUTCALLBACK,
                                                              ListEntry );
            if( (pCallback->TimerRoutine == pTimerRoutine) &&
                (pCallback->Context == pContext) )
            {
                RemoveEntryList(ListEntry);
                KeReleaseSpinLock( &(pDeviceContext->TimeoutLock), OldIrql );
                ExFreePool(pCallback);
                return STATUS_SUCCESS;
            }
        }            
    }

    // release the spinlock
    KeReleaseSpinLock( &(pDeviceContext->TimeoutLock), OldIrql );

    return STATUS_NOT_FOUND;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\main\private.h ===
/*****************************************************************************
 * private.h - WDM Audio class driver
 *****************************************************************************
 * Copyright (c) 1996-2000 Microsoft Corporation.  All rights reserved.
 */

#ifndef _PORTCLS_PRIVATE_H_
#define _PORTCLS_PRIVATE_H_


#include "portclsp.h"
#include "dmusicks.h"
#include "stdunk.h"

#ifndef PC_KDEXT
#if (DBG)
#define STR_MODULENAME  "PortCls: "
#define DEBUG_VARIABLE PORTCLSDebug
#endif
#endif  // PC_KDEXT

#include <ksdebug.h>
#include <wchar.h>

#define PORTCLS_DEVICE_EXTENSION_SIGNATURE  0x000BABEE

#ifndef DEBUGLVL_LIFETIME
#define DEBUGLVL_LIFETIME DEBUGLVL_VERBOSE
#endif

// BUGBUG - the default idle times are currently set to 0 to effectively
// disable inactivity timeouts until the ntkern\configmg appy-time
// deadlock bug is resolved.
#if 1
#define DEFAULT_CONSERVATION_IDLE_TIME      0
#define DEFAULT_PERFORMANCE_IDLE_TIME       0
#else
#define DEFAULT_CONSERVATION_IDLE_TIME      30
#define DEFAULT_PERFORMANCE_IDLE_TIME       300
#endif
#define DEFAULT_IDLE_DEVICE_POWER_STATE     PowerDeviceD3

typedef enum
{
    DeviceRemoved,
    DeviceSurpriseRemoved,
    DeviceRemovePending,
    DeviceAdded
} DEVICE_REMOVE_STATE,*PDEVICE_REMOVE_STATE;

typedef enum
{
    DeviceStopped,
    DeviceStopPending,
    DevicePausedForRebalance,
    DeviceStarted,
    DeviceStartPending          //  StartDevice has not yet finished
} DEVICE_STOP_STATE,*PDEVICE_STOP_STATE;

/*****************************************************************************
 * PHYSICALCONNECTION
 *****************************************************************************
 * List entry for list of physical connections.
 */
typedef struct
{
    LIST_ENTRY      ListEntry;      // Must be first.
    PSUBDEVICE      FromSubdevice;
    PUNICODE_STRING FromString;
    ULONG           FromPin;
    PSUBDEVICE      ToSubdevice;
    PUNICODE_STRING ToString;
    ULONG           ToPin;
}
PHYSICALCONNECTION, *PPHYSICALCONNECTION;

/*****************************************************************************
 * DEVICEINTERFACE
 *****************************************************************************
 * List entry for list of physical connections.
 */
typedef struct
{
    LIST_ENTRY      ListEntry;      // Must be first.
    GUID            Interface;
    UNICODE_STRING  SymbolicLinkName;
    PSUBDEVICE      Subdevice;
}
DEVICEINTERFACE, *PDEVICEINTERFACE;

/*****************************************************************************
 * TIMEOUTCALLBACK
 *****************************************************************************
 * List entry for list of IoTimeout clients.
 */
typedef struct
{
    LIST_ENTRY          ListEntry;
    PIO_TIMER_ROUTINE   TimerRoutine;
    PVOID               Context;
} TIMEOUTCALLBACK,*PTIMEOUTCALLBACK;

/*****************************************************************************
 * DEVICE_CONTEXT
 *****************************************************************************
 * This is the context structure for the device object that represents an
 * entire adapter.  It consists primarily of the create dispatch table (in
 * device header) used by KS to create new filters.  Each item in the table
 * represents a port, i.e. a pairing of a port driver and a miniport driver.
 * The table's item structure contains a user-defined pointer, which is used
 * in this case to point to the subdevice context (SUBDEVICE_CONTEXT).  The
 * subdevice context is extended as required for the port driver and miniport
 * in question.
 */
typedef struct                                                  // 32 64  struct packing for 32-bit and 64-bit architectures
{
    PVOID                   pDeviceHeader;                      // 4  8   KS mystery device header.
    PIRPTARGETFACTORY       pIrpTargetFactory;                  // 4  8   Not used.
    PDEVICE_OBJECT          PhysicalDeviceObject;               // 4  8   Physical Device Object
    PCPFNSTARTDEVICE        StartDevice;                        // 4  8   Adapter's StartDevice fn, initialized at
                                                                //        DriverEntry & called at PnP Start_Device time.
    PVOID                   MinidriverReserved[4];              // 16 32  Reserved for multiple binding.
                                                                        
    PDEVICE_OBJECT          NextDeviceInStack;                  // 4  8   Member of the stack below us.
    PKSOBJECT_CREATE_ITEM   CreateItems;                        // 4  8   Subdevice create table entries;
    ULONG                   Signature;                          // 4  4   DeviceExtension Signature
    ULONG                   MaxObjects;                         // 4  4   Maximum number of subdevices.
    PUNICODE_STRING         SymbolicLinkNames;                  // 4  8   Link names of subdevices.
    LIST_ENTRY              DeviceInterfaceList;                // 8  16  List of device interfaces.
    LIST_ENTRY              PhysicalConnectionList;             // 8  16  List of physical connections.
    KEVENT                  kEventDevice;                       // 16 24  Device synchronization.
    KEVENT                  kEventRemove;                       // 16 24  Device removal.
    PVOID                   pWorkQueueItemStart;                // 4  8   Work queue item for pnp start.
    PIRP                    IrpStart;                           // 4  8   Start IRP.
                                                                          
    DEVICE_REMOVE_STATE     DeviceRemoveState;                  // 4  4   Device remove state.
    DEVICE_STOP_STATE       DeviceStopState;                    // 4  4   Device stop state.
                                                                          
    BOOLEAN                 PauseForRebalance;                  // 1  1   Whether to pause or turn card off during rebalance.
    BOOLEAN                 PendCreates;                        // 1  1   Whether to pend creates.
    BOOLEAN                 AllowRegisterDeviceInterface;       // 1  1   Whether to allow registering device interfaces.
    BOOLEAN                 IoTimeoutsOk;                       // 1  1   Whether or not the IoInitializeTimeout failed.
    ULONG                   ExistingObjectCount;                // 4  4   Number of existing objects.
    ULONG                   ActivePinCount;                     // 4  4   Number of active pins.
    ULONG                   PendingIrpCount;                    // 4  4   Number of pending IRPs.
                                                                          
    PADAPTERPOWERMANAGEMENT pAdapterPower;                      // 4  8   Pointer to the adapter's
                                                                //        power-management interface.
    PVOID                   SystemStateHandle;                  // 4  8   Used with PoRegisterSystemState.
    PULONG                  IdleTimer;                          // 4  8   A pointer to the idle timer.
    DEVICE_POWER_STATE      CurrentDeviceState;                 // 4  4   The current state of the device.
    SYSTEM_POWER_STATE      CurrentSystemState;                 // 4  4   The current system power state.
    DEVICE_POWER_STATE      DeviceStateMap[PowerSystemMaximum]; // 28 28  System to device power state map.
    DEVICE_POWER_STATE      IdleDeviceState;                    // 4  4   The device state to transition to when idle.
    ULONG                   ConservationIdleTime;               // 4  4   Idle timeout period for conservation mode.
    ULONG                   PerformanceIdleTime;                // 4  4   Idle timeout period for performance mode.
                                                                          
    LIST_ENTRY              PendedIrpList;                      // 8  16  Pended IRP queue.
    KSPIN_LOCK              PendedIrpLock;                      // 4  8   Spinlock for pended IRP list.
                                                                          
    USHORT                  SuspendCount;                       // 2  2   PM/ACPI power down count for debugging.
    USHORT                  StopCount;                          // 2  2   PnP stop count for debugging.
                                                                //   (4 pad)    
    LIST_ENTRY              TimeoutList;                        // 8  16  List of IoTimeout callback clients
    KSPIN_LOCK              TimeoutLock;                        // 4  8   IoTimeout list spinlock
                                                                          
    PKSPIN_LOCK             DriverDmaLock;                      // 4  8   A pointer to the DriverObject DMA spinlock
    KDPC                    DevicePowerRequestDpc;              // 32 64  DPC to handle deferred device power irps (Fast Resume)
}                                                                         
DEVICE_CONTEXT, *PDEVICE_CONTEXT;                               // 256 416
                                                                //        NOTE! For legacy reasons, can never be more than 256/512.
                                                                //        If we need to add more members, change an existing member
                                                                //        to a pointer to an additional expansion piece of memory.

/*****************************************************************************
 * POWER_IRP_CONTEXT
 *****************************************************************************
 * This is the context structure for processing power irps.
 */
typedef struct
{
    PKEVENT         PowerSyncEvent;
    NTSTATUS        Status;
    PIRP            PendingSystemPowerIrp;
    PDEVICE_CONTEXT DeviceContext;
}
POWER_IRP_CONTEXT,*PPOWER_IRP_CONTEXT;

/*****************************************************************************
 * IResourceListInit
 *****************************************************************************
 * Initialization interface for list of resources.
 */
DECLARE_INTERFACE_(IResourceListInit,IResourceList)
{
    DEFINE_ABSTRACT_UNKNOWN()   // For IUnknown

    // For IResourceList
    STDMETHOD_(ULONG,NumberOfEntries)
    (   THIS
    )   PURE;

    STDMETHOD_(ULONG,NumberOfEntriesOfType)
    (   THIS_
        IN      CM_RESOURCE_TYPE    Type
    )   PURE;

    STDMETHOD_(PCM_PARTIAL_RESOURCE_DESCRIPTOR,FindTranslatedEntry)
    (   THIS_
        IN      CM_RESOURCE_TYPE    Type,
        IN      ULONG               Index
    )   PURE;

    STDMETHOD_(PCM_PARTIAL_RESOURCE_DESCRIPTOR,FindUntranslatedEntry)
    (   THIS_
        IN      CM_RESOURCE_TYPE    Type,
        IN      ULONG               Index
    )   PURE;

    STDMETHOD_(NTSTATUS,AddEntry)
    (   THIS_
        IN      PCM_PARTIAL_RESOURCE_DESCRIPTOR Translated,
        IN      PCM_PARTIAL_RESOURCE_DESCRIPTOR Untranslated
    )   PURE;

    STDMETHOD_(NTSTATUS,AddEntryFromParent)
    (   THIS_
        IN      struct IResourceList *  Parent,
        IN      CM_RESOURCE_TYPE        Type,
        IN      ULONG                   Index
    )   PURE;

    STDMETHOD_(PCM_RESOURCE_LIST,TranslatedList)
    (   THIS
    )   PURE;

    STDMETHOD_(PCM_RESOURCE_LIST,UntranslatedList)
    (   THIS
    )   PURE;

    // For IResourceListInit
    STDMETHOD_(NTSTATUS,Init)
    (   THIS_
        IN      PCM_RESOURCE_LIST   TranslatedResources,
        IN      PCM_RESOURCE_LIST   UntranslatedResources,
        IN      POOL_TYPE           PoolType
    )   PURE;

    STDMETHOD_(NTSTATUS,InitFromParent)
    (   THIS_
        IN      PRESOURCELIST       ParentList,
        IN      ULONG               MaximumEntries,
        IN      POOL_TYPE           PoolType
    )   PURE;
};

typedef IResourceListInit *PRESOURCELISTINIT;

/*****************************************************************************
 * CResourceList
 *****************************************************************************
 * Resource list implementation.
 */
class CResourceList
:   public IResourceListInit,
    public CUnknown
{
private:
    PCM_RESOURCE_LIST   Untranslated;
    PCM_RESOURCE_LIST   Translated;
    ULONG               EntriesAllocated;
    ULONG               EntriesInUse;

public:
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CResourceList);
    ~CResourceList();

    /*************************************************************************
     * IResourceListInit methods
     */
    STDMETHODIMP_(NTSTATUS) Init
    (
        IN      PCM_RESOURCE_LIST   TranslatedResources,
        IN      PCM_RESOURCE_LIST   UntranslatedResources,
        IN      POOL_TYPE           PoolType
    );
    STDMETHODIMP_(NTSTATUS) InitFromParent
    (
        IN      PRESOURCELIST       ParentList,
        IN      ULONG               MaximumEntries,
        IN      POOL_TYPE           PoolType
    );

    /*************************************************************************
     * IResourceList methods
     */
    STDMETHODIMP_(ULONG) NumberOfEntries
    (   void
    );
    STDMETHODIMP_(ULONG) NumberOfEntriesOfType
    (
        IN      CM_RESOURCE_TYPE    Type
    );
    STDMETHODIMP_(PCM_PARTIAL_RESOURCE_DESCRIPTOR) FindTranslatedEntry
    (
        IN      CM_RESOURCE_TYPE    Type,
        IN      ULONG               Index
    );
    STDMETHODIMP_(PCM_PARTIAL_RESOURCE_DESCRIPTOR) FindUntranslatedEntry
    (
        IN      CM_RESOURCE_TYPE    Type,
        IN      ULONG               Index
    );
    STDMETHODIMP_(NTSTATUS) AddEntry
    (
        IN      PCM_PARTIAL_RESOURCE_DESCRIPTOR Translated,
        IN      PCM_PARTIAL_RESOURCE_DESCRIPTOR Untranslated
    );
    STDMETHODIMP_(NTSTATUS) AddEntryFromParent
    (
        IN      PRESOURCELIST       Parent,
        IN      CM_RESOURCE_TYPE    Type,
        IN      ULONG               Index
    );
    STDMETHODIMP_(PCM_RESOURCE_LIST) TranslatedList
    (   void
    );
    STDMETHODIMP_(PCM_RESOURCE_LIST) UntranslatedList
    (   void
    );
};

/*****************************************************************************
 * IRegistryKeyInit
 *****************************************************************************
 * Interface for registry key with Init.
 */
DECLARE_INTERFACE_(IRegistryKeyInit,IRegistryKey)
{
    DEFINE_ABSTRACT_UNKNOWN()   // For IUnknown

    // For IRegistryKey
    STDMETHOD_(NTSTATUS,QueryKey)
    (   THIS_
        IN      KEY_INFORMATION_CLASS   KeyInformationClass,
        OUT     PVOID                   KeyInformation,
        IN      ULONG                   Length,
        OUT     PULONG                  ResultLength
    )   PURE;

    STDMETHOD_(NTSTATUS,EnumerateKey)
    (   THIS_
        IN      ULONG                   Index,
        IN      KEY_INFORMATION_CLASS   KeyInformationClass,
        OUT     PVOID                   KeyInformation,
        IN      ULONG                   Length,
        OUT     PULONG                  ResultLength
    )   PURE;

    STDMETHOD_(NTSTATUS,QueryValueKey)
    (   THIS_
        IN      PUNICODE_STRING             ValueName,
        IN      KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
        OUT     PVOID                       KeyValueInformation,
        IN      ULONG                       Length,
        OUT     PULONG                      ResultLength
    )   PURE;

    STDMETHOD_(NTSTATUS,EnumerateValueKey)
    (   THIS_
        IN      ULONG                       Index,
        IN      KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
        OUT     PVOID                       KeyValueInformation,
        IN      ULONG                       Length,
        OUT     PULONG                      ResultLength
    )   PURE;

    STDMETHOD_(NTSTATUS,SetValueKey)
    (   THIS_
        IN      PUNICODE_STRING     ValueName OPTIONAL,
        IN      ULONG               Type,
        IN      PVOID               Data,
        IN      ULONG               DataSize
    )   PURE;

    STDMETHOD_(NTSTATUS,QueryRegistryValues)
    (   THIS_
        IN      PRTL_QUERY_REGISTRY_TABLE   QueryTable,
        IN      PVOID                       Context OPTIONAL
    )   PURE;

    STDMETHOD_(NTSTATUS,NewSubKey)
    (   THIS_
        OUT     IRegistryKey **     RegistrySubKey,
        IN      PUNKNOWN            OuterUnknown,
        IN      ACCESS_MASK         DesiredAccess,
        IN      PUNICODE_STRING     SubKeyName,
        IN      ULONG               CreateOptions,
        OUT     PULONG              Disposition     OPTIONAL
    )   PURE;

    STDMETHOD_(NTSTATUS,DeleteKey)
    (   THIS
    )   PURE;

    // For IRegistryKeyInit    
    STDMETHOD_(NTSTATUS,Init)
    (   THIS_
        IN      ULONG               RegistryKeyType,
        IN      ACCESS_MASK         DesiredAccess,
        IN      PDEVICE_OBJECT      DeviceObject        OPTIONAL,
        IN      PSUBDEVICE          SubDevice           OPTIONAL,
        IN      POBJECT_ATTRIBUTES  ObjectAttributes    OPTIONAL,
        IN      ULONG               CreateOptions       OPTIONAL,
        OUT     PULONG              Disposition         OPTIONAL
    )   PURE;
};

typedef IRegistryKeyInit *PREGISTRYKEYINIT;


/*****************************************************************************
 * CRegistryKey
 *****************************************************************************
 * Registry Key implementation.
 */
class CRegistryKey
:   public IRegistryKeyInit,
    public CUnknown
{
private:
    HANDLE      m_KeyHandle;    // Key Handle
    BOOLEAN     m_KeyDeleted;   // Key Deleted Flag
    BOOLEAN     m_GeneralKey;   // Only general keys may be deleted

public:
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CRegistryKey);
    ~CRegistryKey();

    /*************************************************************************
     * IRegistryKeyInit methods
     */
    STDMETHODIMP_(NTSTATUS) Init
    (
        IN      ULONG               RegistryKeyType,
        IN      ACCESS_MASK         DesiredAccess,
        IN      PDEVICE_OBJECT      DeviceObject        OPTIONAL,
        IN      PSUBDEVICE          SubDevice           OPTIONAL,
        IN      POBJECT_ATTRIBUTES  ObjectAttributes    OPTIONAL,
        IN      ULONG               CreateOptions       OPTIONAL,
        OUT     PULONG              Disposition         OPTIONAL
    );

    /*************************************************************************
     * IRegistryKey methods
     */
    STDMETHODIMP_(NTSTATUS) QueryKey
    (
        IN      KEY_INFORMATION_CLASS   KeyInformationClass,
        OUT     PVOID                   KeyInformation,
        IN      ULONG                   Length,
        OUT     PULONG                  ResultLength
    );

    STDMETHODIMP_(NTSTATUS) EnumerateKey
    (
        IN      ULONG                   Index,
        IN      KEY_INFORMATION_CLASS   KeyInformationClass,
        OUT     PVOID                   KeyInformation,
        IN      ULONG                   Length,
        OUT     PULONG                  ResultLength
    );

    STDMETHODIMP_(NTSTATUS) QueryValueKey
    (
        IN      PUNICODE_STRING             ValueName,
        IN      KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
        OUT     PVOID                       KeyValueInformation,
        IN      ULONG                       Length,
        OUT     PULONG                      ResultLength
    );

    STDMETHODIMP_(NTSTATUS) EnumerateValueKey
    (
        IN      ULONG                       Index,
        IN      KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
        OUT     PVOID                       KeyValueInformation,
        IN      ULONG                       Length,
        OUT     PULONG                      ResultLength
    );

    STDMETHODIMP_(NTSTATUS) SetValueKey
    (
        IN      PUNICODE_STRING         ValueName   OPTIONAL,
        IN      ULONG                   Type,
        IN      PVOID                   Data,
        IN      ULONG                   DataSize
    );

    STDMETHODIMP_(NTSTATUS) QueryRegistryValues
    (
        IN      PRTL_QUERY_REGISTRY_TABLE   QueryTable,
        IN      PVOID                       Context OPTIONAL
    );

    STDMETHODIMP_(NTSTATUS) NewSubKey
    (
        OUT     PREGISTRYKEY *      RegistrySubKey,
        IN      PUNKNOWN            OuterUnknown,
        IN      ACCESS_MASK         DesiredAccess,
        IN      PUNICODE_STRING     SubKeyName,
        IN      ULONG               CreateOptions,
        OUT     PULONG              Disposition     OPTIONAL
    );

    STDMETHODIMP_(NTSTATUS) DeleteKey
    (   void
    );
};

/*****************************************************************************
 * Functions
 */

/*****************************************************************************
 * AcquireDevice()
 *****************************************************************************
 * Acquire exclusive access to the device.
 */
VOID
AcquireDevice
(
    IN      PDEVICE_CONTEXT pDeviceContext
);

/*****************************************************************************
 * ReleaseDevice()
 *****************************************************************************
 * Release exclusive access to the device.
 */
VOID
ReleaseDevice
(
    IN      PDEVICE_CONTEXT pDeviceContext
);

/*****************************************************************************
 * IncrementPendingIrpCount()
 *****************************************************************************
 * Increment the pending IRP count for the device.
 */
VOID
IncrementPendingIrpCount
(
    IN      PDEVICE_CONTEXT pDeviceContext
);

/*****************************************************************************
 * DecrementPendingIrpCount()
 *****************************************************************************
 * Decrement the pending IRP count for the device.
 */
VOID
DecrementPendingIrpCount
(
    IN      PDEVICE_CONTEXT pDeviceContext
);

/*****************************************************************************
 * SubdeviceIndex()
 *****************************************************************************
 * Returns the index of a subdevice in the create items list or ULONG(-1) if
 * not found.
 */
ULONG
SubdeviceIndex
(
    IN      PDEVICE_OBJECT  DeviceObject,
    IN      PSUBDEVICE      Subdevice
);


/*****************************************************************************
 * GetDeviceACPIInfo()
 *****************************************************************************
 * Called in response to a PnP - IRP_MN_QUERY_CAPABILITIES
 * Call the bus driver to fill out the inital info,
 * Then overwrite with our own...
 *
 */
NTSTATUS
GetDeviceACPIInfo
(
    IN      PIRP            pIrp,
    IN      PDEVICE_OBJECT  pDeviceObject
);

NTSTATUS
GetIdleInfoFromRegistry
(
    IN  PDEVICE_CONTEXT     DeviceContext,
    OUT PULONG              ConservationIdleTime,
    OUT PULONG              PerformanceIdleTime,
    OUT PDEVICE_POWER_STATE IdleDeviceState
);

NTSTATUS
CheckCurrentPowerState
(
    IN  PDEVICE_OBJECT      pDeviceObject
);

NTSTATUS
UpdateActivePinCount
(
    IN      PDEVICE_CONTEXT DeviceContext,
    IN      BOOL            Increment
);

NTSTATUS
DispatchCreate
(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
);


NTSTATUS
DispatchDeviceIoControl
(
    IN      PDEVICE_OBJECT   pDeviceObject,
    IN      PIRP             pIrp
);

BOOLEAN
DispatchFastDeviceIoControl
(
    IN      PFILE_OBJECT        FileObject,
    IN      BOOLEAN             Wait,
    IN      PVOID               InputBuffer     OPTIONAL,
    IN      ULONG               InputBufferLength,
    OUT     PVOID               OutputBuffer    OPTIONAL,
    IN      ULONG               OutputBufferLength,
    IN      ULONG               IoControlCode,
    OUT     PIO_STATUS_BLOCK    IoStatus,
    IN      PDEVICE_OBJECT      DeviceObject
);

NTSTATUS
DispatchRead
(
    IN      PDEVICE_OBJECT   pDeviceObject,
    IN      PIRP             pIrp
);

BOOLEAN
DispatchFastRead
(
    IN      PFILE_OBJECT        FileObject,
    IN      PLARGE_INTEGER      FileOffset,
    IN      ULONG               Length,
    IN      BOOLEAN             Wait,
    IN      ULONG               LockKey,
    OUT     PVOID               Buffer,
    OUT     PIO_STATUS_BLOCK    IoStatus,
    IN      PDEVICE_OBJECT      DeviceObject
);

NTSTATUS
DispatchWrite
(
    IN      PDEVICE_OBJECT   pDeviceObject,
    IN      PIRP             pIrp
);

BOOLEAN
DispatchFastWrite
(
    IN      PFILE_OBJECT        FileObject,
    IN      PLARGE_INTEGER      FileOffset,
    IN      ULONG               Length,
    IN      BOOLEAN             Wait,
    IN      ULONG               LockKey,
    IN      PVOID               Buffer,
    OUT     PIO_STATUS_BLOCK    IoStatus,
    IN      PDEVICE_OBJECT      DeviceObject
);

NTSTATUS
DispatchFlush
(
    IN      PDEVICE_OBJECT   pDeviceObject,
    IN      PIRP             pIrp
);

NTSTATUS
DispatchClose
(
    IN      PDEVICE_OBJECT   pDeviceObject,
    IN      PIRP             pIrp
);

NTSTATUS
DispatchQuerySecurity
(
    IN      PDEVICE_OBJECT   pDeviceObject,
    IN      PIRP             pIrp
);

NTSTATUS
DispatchSetSecurity
(
    IN      PDEVICE_OBJECT   pDeviceObject,
    IN      PIRP             pIrp
);

/*****************************************************************************
 * DispatchPower()
 *****************************************************************************
 * The dispatch function for all MN_POWER irps.
 *
 */
NTSTATUS
DispatchPower
(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
);

/*****************************************************************************
 * CompleteIrp()
 *****************************************************************************
 * Complete an IRP unless status is STATUS_PENDING.
 */
NTSTATUS
CompleteIrp
(
    IN      PDEVICE_CONTEXT pDeviceContext,
    IN      PIRP            pIrp,
    IN      NTSTATUS        ntStatus
);

/*****************************************************************************
 * ForwardIrpSynchronous()
 *****************************************************************************
 * Forward a PnP IRP to the PDO.  The IRP is not completed at this level,
 * this function does not return until the lower driver has completed the IRP,
 * and DecrementPendingIrpCount() is not called.
 */
NTSTATUS
ForwardIrpSynchronous
(
    IN      PDEVICE_CONTEXT pDeviceContext,
    IN      PIRP            pIrp
);


/*****************************************************************************
 * ForwardIrpAsynchronous()
 *****************************************************************************
 * Forward a PnP IRP to the PDO.  The IRP is completed at this level
 * regardless of the outcome, this function returns immediately regardless of
 * whether the IRP is pending in the lower driver, and
 * DecrementPendingIrpCount() is called in all cases.
 */
NTSTATUS
ForwardIrpAsynchronous
(
    IN      PDEVICE_CONTEXT pDeviceContext,
    IN      PIRP            pIrp
);

/*****************************************************************************
 * PcRequestNewPowerState()
 *****************************************************************************
 * This routine is used to request a new power state for the device.  It is
 * normally used internally by portcls but is also exported to adapters so
 * that the adapters can also request power state changes.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcRequestNewPowerState
(
    IN      PDEVICE_OBJECT      pDeviceObject,
    IN      DEVICE_POWER_STATE  RequestedNewState
);

/*****************************************************************************
 * RequestNewPowerState()
 *****************************************************************************
 * Called by the policy manager to
 * request a change in the power state of the
 * device.
 *
 */
NTSTATUS
RequestNewPowerState
(
    IN      PDEVICE_CONTEXT     pDeviceContext,
    IN      DEVICE_POWER_STATE  RequestedNewState
);

/*****************************************************************************
 * DevicePowerRequestRoutine()
 *****************************************************************************
 * DPC used by the power routines to defer request for a device power
 * change.
 */
VOID
DevicePowerRequestRoutine(
   IN PKDPC Dpc,
   IN PVOID Context,   
   IN PVOID SystemContext1,
   IN PVOID SystemContext2
   );

/*****************************************************************************
 * PcDispatchProperty()
 *****************************************************************************
 * Dispatch a property via a PCPROPERTY_ITEM entry.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcDispatchProperty
(
    IN          PIRP                pIrp            OPTIONAL,
    IN          PPROPERTY_CONTEXT   pPropertyContext,
    IN const    KSPROPERTY_SET *    pKsPropertySet  OPTIONAL,
    IN          ULONG               ulIdentifierSize,
    IN          PKSIDENTIFIER       pKsIdentifier,
    IN OUT      PULONG              pulDataSize,
    IN OUT      PVOID               pvData          OPTIONAL
);

/*****************************************************************************
 * PcValidateDeviceContext()
 *****************************************************************************
 * Probes DeviceContext for writing.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcValidateDeviceContext
(
    IN      PDEVICE_CONTEXT         pDeviceContext,
    IN      PIRP                    pIrp
);

/*****************************************************************************
 * CompletePendedIrps
 *****************************************************************************
 * This pulls pended irps off the queue and passes them back to the appropriate
 * dispatcher via KsoDispatchIrp.
 */

typedef enum {

    EMPTY_QUEUE_AND_PROCESS = 0,
    EMPTY_QUEUE_AND_FAIL

} COMPLETE_STYLE;

void
CompletePendedIrps
(
    IN      PDEVICE_OBJECT      pDeviceObject,
    IN      PDEVICE_CONTEXT     pDeviceContext,
    IN      COMPLETE_STYLE      CompleteStyle
);

typedef enum {

    QUEUED_CALLBACK_FREE = 0,
    QUEUED_CALLBACK_RETAIN,
    QUEUED_CALLBACK_REISSUE

} QUEUED_CALLBACK_RETURN;

typedef QUEUED_CALLBACK_RETURN (*PFNQUEUED_CALLBACK)(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PVOID               Context
    );

#define MAX_THREAD_REENTRANCY   20

typedef struct {

    union {

#if COMPILED_FOR_WDM110
        PIO_WORKITEM        IoWorkItem;
#else
        WORK_QUEUE_ITEM     WorkItem;
#endif
        KDPC                Dpc;
    }; // unnamed union

    PFNQUEUED_CALLBACK  QueuedCallback;
    PDEVICE_OBJECT      DeviceObject;
    PVOID               Context;
    ULONG               Flags;
    KIRQL               Irql;
    LONG                Enqueued;
    ULONG               ReentrancyCount;

} QUEUED_CALLBACK_ITEM, *PQUEUED_CALLBACK_ITEM;

#define EQCM_SUPPORT_OR_FAIL_FLAGS      0xFFFF0000
#define EQCM_SUPPORT_OR_IGNORE_FLAGS    0x0000FFFF

#define EQCF_REUSE_HANDLE               0x00010000
#define EQCF_DIFFERENT_THREAD_REQUIRED  0x00020000

#define EQCM_SUPPORTED_FLAGS    \
    ( EQCF_REUSE_HANDLE | EQCF_DIFFERENT_THREAD_REQUIRED)

NTSTATUS
CallbackEnqueue(
    IN      PVOID                   *pCallbackHandle,
    IN      PFNQUEUED_CALLBACK      CallbackRoutine,
    IN      PDEVICE_OBJECT          DeviceObject,
    IN      PVOID                   Context,
    IN      KIRQL                   Irql,
    IN      ULONG                   Flags
    );

NTSTATUS
CallbackCancel(
    IN      PVOID   pCallbackHandle
    );

VOID
CallbackFree(
    IN      PVOID   pCallbackHandle
    );

typedef enum {

    IRPDISP_NOTREADY = 1,
    IRPDISP_QUEUE,
    IRPDISP_PROCESS

} IRPDISP;

IRPDISP
GetIrpDisposition(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  UCHAR           MinorFunction
    );

typedef enum {

    STOPSTYLE_PAUSE_FOR_REBALANCE,
    STOPSTYLE_DISABLE

} PNPSTOP_STYLE;

NTSTATUS
PnpStopDevice
(
    IN      PDEVICE_OBJECT  pDeviceObject,
    IN      PNPSTOP_STYLE   StopStyle
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\main\power.cpp ===
/*****************************************************************************
 * power.cpp - WDM Streaming port class driver
 *****************************************************************************
 * Copyright (c) 1996-2000 Microsoft Corporation.  All rights reserved.
 *
 * This file contains code related to ACPI / power management
 * for the audio adpaters/miniports
 */

#include "private.h"

#ifndef DEBUGLVL_POWER
#define DEBUGLVL_POWER DEBUGLVL_VERBOSE
#endif



NTSTATUS
ProcessPowerIrp
(
    IN      PIRP                pIrp,
    IN      PIO_STACK_LOCATION  pIrpStack,
    IN      PDEVICE_OBJECT      pDeviceObject
);

#pragma code_seg("PAGE")
/*****************************************************************************
 * GetDeviceACPIInfo()
 *****************************************************************************
 * Called in response to a PnP - IRP_MN_QUERY_CAPABILITIES
 * Call the bus driver to fill out the inital info,
 * Then overwrite with our own...
 *
 */
NTSTATUS
GetDeviceACPIInfo
(
    IN      PIRP            pIrp,
    IN      PDEVICE_OBJECT  pDeviceObject
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_POWER,("GetDeviceACPIInfo"));

    ASSERT( pDeviceObject );

    PDEVICE_CONTEXT pDeviceContext
    = PDEVICE_CONTEXT(pDeviceObject->DeviceExtension);

    ASSERT( pDeviceContext );

    // Gotta call down to the PDO (bus driver)
    // and let it fill out the default for this bus
    NTSTATUS ntStatus = ForwardIrpSynchronous( pDeviceContext, pIrp );
    if( NT_SUCCESS(ntStatus) )
    {
        PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(pIrp);
        PDEVICE_CAPABILITIES pDeviceCaps = irpSp->Parameters.DeviceCapabilities.Capabilities;

        ASSERT( pDeviceCaps );
        ASSERT( pDeviceCaps->Size >= sizeof( DEVICE_CAPABILITIES ) );

        if( pDeviceCaps && ( pDeviceCaps->Size >= sizeof( DEVICE_CAPABILITIES ) ) )
        {
            // pass the structure on down to the adapter
            if( pDeviceContext )
            {
                if( pDeviceContext->pAdapterPower )
                {
                    ntStatus = pDeviceContext->pAdapterPower->QueryDeviceCapabilities( pDeviceCaps );

                    ASSERT(ntStatus != STATUS_PENDING);
                }
            }

            // make sure that we have sensible settings for the system sleep states
            pDeviceCaps->DeviceState[PowerSystemWorking] = PowerDeviceD0;
            for(ULONG i=ULONG(PowerSystemSleeping1); i <= ULONG(PowerSystemShutdown); i++ )
            {
                // and we want some sleeping in the sleep modes.
                //
                // DEADISSUE-00/11/11-MartinP
                // We go ahead and include this code, even though it is possible that
                // there are devices that exist that can maintain state in the device
                // while sleeping.
                //
                if(pDeviceCaps->DeviceState[i] == PowerDeviceD0)
                {
                    pDeviceCaps->DeviceState[i] = PowerDeviceD3;
                }
            }

            // save in our device extension the stuff we're interested in
            for( i=ULONG(PowerSystemUnspecified); i < ULONG(PowerSystemMaximum); i++)
            {
                pDeviceContext->DeviceStateMap[ i ] = pDeviceCaps->DeviceState[ i ];
            }

            _DbgPrintF( DEBUGLVL_POWER, ( "DeviceCaps:  PowerSystemUnspecified = D%d", pDeviceCaps->DeviceState[PowerSystemUnspecified] - 1));
            _DbgPrintF( DEBUGLVL_POWER, ( "DeviceCaps:  PowerSystemWorking = D%d", pDeviceCaps->DeviceState[PowerSystemWorking] - 1));
            _DbgPrintF( DEBUGLVL_POWER, ( "DeviceCaps:  PowerSystemSleeping1 = D%d", pDeviceCaps->DeviceState[PowerSystemSleeping1] - 1));
            _DbgPrintF( DEBUGLVL_POWER, ( "DeviceCaps:  PowerSystemSleeping2 = D%d", pDeviceCaps->DeviceState[PowerSystemSleeping2] - 1));
            _DbgPrintF( DEBUGLVL_POWER, ( "DeviceCaps:  PowerSystemSleeping3 = D%d", pDeviceCaps->DeviceState[PowerSystemSleeping3] - 1));
            _DbgPrintF( DEBUGLVL_POWER, ( "DeviceCaps:  PowerSystemHibernate = D%d", pDeviceCaps->DeviceState[PowerSystemHibernate] - 1));
            _DbgPrintF( DEBUGLVL_POWER, ( "DeviceCaps:  PowerSystemShutdown = D%d", pDeviceCaps->DeviceState[PowerSystemShutdown] - 1));
            _DbgPrintF( DEBUGLVL_POWER, ( "DeviceCaps:  SystemWake = %d", pDeviceCaps->SystemWake ));
            _DbgPrintF( DEBUGLVL_POWER, ( "DeviceCaps:  DeviceWake = %d", pDeviceCaps->DeviceWake ));
        }
    }

    // complete the irp
    CompleteIrp( pDeviceContext, pIrp, ntStatus );

    // set the current power states
    pDeviceContext->CurrentDeviceState = PowerDeviceD0;
    pDeviceContext->CurrentSystemState = PowerSystemWorking;

    // attempt to get the idle info from the registry
    if( NT_SUCCESS(ntStatus) )
    {
        ULONG ConservationIdleTime;
        ULONG PerformanceIdleTime;
        DEVICE_POWER_STATE IdleDeviceState;

        NTSTATUS ntStatus2 = GetIdleInfoFromRegistry( pDeviceContext,
                                                      &ConservationIdleTime,
                                                      &PerformanceIdleTime,
                                                      &IdleDeviceState );
        if(NT_SUCCESS(ntStatus2))
        {
            pDeviceContext->ConservationIdleTime = ConservationIdleTime;
            pDeviceContext->PerformanceIdleTime = PerformanceIdleTime;
            pDeviceContext->IdleDeviceState = IdleDeviceState;
        }

        // register for idle detection
        pDeviceContext->IdleTimer = PoRegisterDeviceForIdleDetection( pDeviceContext->PhysicalDeviceObject,
                                                                      pDeviceContext->ConservationIdleTime,
                                                                      pDeviceContext->PerformanceIdleTime,
                                                                      pDeviceContext->IdleDeviceState );

        _DbgPrintF(DEBUGLVL_POWER,("Idle Detection Enabled (%d %d %d) %s", pDeviceContext->ConservationIdleTime,
                                                                             pDeviceContext->PerformanceIdleTime,
                                                                             ULONG(pDeviceContext->IdleDeviceState),
                                                                             pDeviceContext->IdleTimer ? "" : "FAILED!"));
    }

    return ntStatus;
}

#pragma code_seg()

VOID
DevicePowerRequestRoutine(
   IN PKDPC Dpc,
   IN PVOID Context,
   IN PVOID SystemContext1,
   IN PVOID SystemContext2
   )
{
    PDEVICE_CONTEXT pDeviceContext = (PDEVICE_CONTEXT) Context;
    POWER_STATE newPowerState;

    newPowerState.DeviceState = PowerDeviceD0;

    PoRequestPowerIrp(pDeviceContext->PhysicalDeviceObject,
                      IRP_MN_SET_POWER,
                      newPowerState,
                      NULL,
                      NULL,
                      NULL
                      );
}

/*****************************************************************************
 * PowerIrpCompletionRoutine()
 *****************************************************************************
 * Used when requested a new power irp.
 * Just signal an event and return.
 *
 */
VOID
PowerIrpCompletionRoutine
(
    IN      PDEVICE_OBJECT      DeviceObject,
    IN      UCHAR               MinorFunction,
    IN      POWER_STATE         PowerState,
    IN      PVOID               Context,
    IN      PIO_STATUS_BLOCK    IoStatus
)
{
    ASSERT(Context);

    _DbgPrintF( DEBUGLVL_POWER, ("PowerIrpCompletionRoutine"));

    PPOWER_IRP_CONTEXT pPowerIrpContext = PPOWER_IRP_CONTEXT(Context);

    // set the return status
    pPowerIrpContext->Status = IoStatus->Status;

    // complete any pending system power irp
    if( pPowerIrpContext->PendingSystemPowerIrp )
    {
        _DbgPrintF(DEBUGLVL_POWER,("Device Set/Query Power Irp completed, Completing Associated System Power Irp"));

        if (NT_SUCCESS(IoStatus->Status))
        {
            // Forward the system set power irp to the PDO
            ForwardIrpSynchronous( pPowerIrpContext->DeviceContext,
                                   pPowerIrpContext->PendingSystemPowerIrp );
        } else
        {
            pPowerIrpContext->PendingSystemPowerIrp->IoStatus.Status = IoStatus->Status;
        }

        // start the next power irp
        PoStartNextPowerIrp( pPowerIrpContext->PendingSystemPowerIrp );

        // complete the system set power irp
        CompleteIrp( pPowerIrpContext->DeviceContext,
                     pPowerIrpContext->PendingSystemPowerIrp,
                     pPowerIrpContext->PendingSystemPowerIrp->IoStatus.Status );

        // free the context (only when completing a pending system power irp)
        ExFreePool( pPowerIrpContext );
    } else
    {
        // set the sync event (not used in conjunction with pending system power irps)
        if( pPowerIrpContext->PowerSyncEvent )
        {
            KeSetEvent( pPowerIrpContext->PowerSyncEvent,
                        0,
                        FALSE );
        }
    }
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * DispatchPower()
 *****************************************************************************
 * Deals with all the power/ACPI messages from the OS.
 * yay.
 *
 */
NTSTATUS
DispatchPower
(
    IN      PDEVICE_OBJECT  pDeviceObject,
    IN      PIRP            pIrp
)
{
    PAGED_CODE();

    ASSERT(pDeviceObject);
    ASSERT(pIrp);

    NTSTATUS ntStatus = STATUS_SUCCESS;

    PIO_STACK_LOCATION pIrpStack =
        IoGetCurrentIrpStackLocation(pIrp);

    PDEVICE_CONTEXT pDeviceContext =
        PDEVICE_CONTEXT(pDeviceObject->DeviceExtension);

    ntStatus = PcValidateDeviceContext(pDeviceContext, pIrp);
    if (!NT_SUCCESS(ntStatus))
    {
        // Don't know what to do, but this is probably a PDO.
        // We'll try to make this right by completing the IRP
        // untouched (per PnP, WMI, and Power rules). Note
        // that if this isn't a PDO, and isn't a portcls FDO, then
        // the driver messed up by using Portcls as a filter (huh?)
        // In this case the verifier will fail us, WHQL will catch
        // them, and the driver will be fixed. We'd be very surprised
        // to see such a case.

        PoStartNextPowerIrp( pIrp );
        ntStatus = pIrp->IoStatus.Status;
        IoCompleteRequest( pIrp, IO_NO_INCREMENT );
        return ntStatus;
    }

    IncrementPendingIrpCount( pDeviceContext );

#if (DBG)
    static PCHAR aszMnNames[] =
    {
        "IRP_MN_WAIT_WAKE",
        "IRP_MN_POWER_SEQUENCE",
        "IRP_MN_SET_POWER",
        "IRP_MN_QUERY_POWER"
    };
    if (pIrpStack->MinorFunction >= SIZEOF_ARRAY(aszMnNames))
    {
        _DbgPrintF( DEBUGLVL_POWER,("DispatchPower function 0x%02x",pIrpStack->MinorFunction));
    }
    else
    {
        _DbgPrintF( DEBUGLVL_POWER,("DispatchPower function %s",aszMnNames[pIrpStack->MinorFunction]));
    }
#endif

    // Assume we won't deal with the irp.
    BOOL IrpHandled = FALSE;

    switch (pIrpStack->MinorFunction)
    {
        case IRP_MN_QUERY_POWER:
        case IRP_MN_SET_POWER:
            // Is this a device state change?
            if( DevicePowerState == pIrpStack->Parameters.Power.Type )
            {
                // yeah. Deal with it
                ntStatus = ProcessPowerIrp( pIrp,
                                            pIrpStack,
                                            pDeviceObject );
                IrpHandled = TRUE;
                // And quit.
            } else
            {
                // A system state change
                if( IRP_MN_QUERY_POWER == pIrpStack->MinorFunction )
                {
                    _DbgPrintF(DEBUGLVL_POWER,("  IRP_MN_QUERY_POWER: ->S%d",
                                               pIrpStack->Parameters.Power.State.SystemState-1));
                } else
                {
                    _DbgPrintF(DEBUGLVL_POWER,("  IRP_MN_SET_POWER: ->S%d",
                                               pIrpStack->Parameters.Power.State.SystemState-1));
                }

                POWER_STATE         newPowerState;

                // determine appropriate device state
                newPowerState.DeviceState = pDeviceContext->DeviceStateMap[ pIrpStack->Parameters.Power.State.SystemState ];

                //
                // do a sanity check on the device state
                if ((newPowerState.DeviceState < PowerDeviceD0) ||
                    (newPowerState.DeviceState > PowerDeviceD3) )
                {
                    if (pIrpStack->Parameters.Power.State.SystemState == PowerSystemWorking)
                    {
                        newPowerState.DeviceState = PowerDeviceD0;
                    } else
                    {
                        newPowerState.DeviceState = PowerDeviceD3;
                    }
                }

               _DbgPrintF(DEBUGLVL_POWER,("  ...Requesting Device Power IRP -> D%d",newPowerState.DeviceState-1));

               if ((pIrpStack->MinorFunction == IRP_MN_SET_POWER) &&
                   (newPowerState.DeviceState == PowerDeviceD0)) {
                   //
                   // doing a resume, request the D irp, but complete S-irp immediately
                   //
                   KeInsertQueueDpc(&pDeviceContext->DevicePowerRequestDpc, NULL, NULL);
                   break;

               } else {
                   // allocate a completion context (can't be on the stack because we're not going to block)
                   PPOWER_IRP_CONTEXT  PowerIrpContext =
                       PPOWER_IRP_CONTEXT(ExAllocatePoolWithTag(NonPagedPool,
                                                                sizeof(POWER_IRP_CONTEXT),
                                                                'oPcP' ) );   //  'PcPo'
                   if (PowerIrpContext)
                   {
                       _DbgPrintF(DEBUGLVL_POWER,("...Pending System Power Irp until Device Power Irp completes"));


                       // set up device power irp completion context
                       PowerIrpContext->PowerSyncEvent = NULL;
#if DBG
                       PowerIrpContext->Status = STATUS_PENDING;
#endif
                       PowerIrpContext->PendingSystemPowerIrp = pIrp;
                       PowerIrpContext->DeviceContext = pDeviceContext;

                       // pend the system set power irp
                       //
#if DBG
                       pIrp->IoStatus.Status = STATUS_PENDING;
#endif
                       IoMarkIrpPending( pIrp );

                       // set our tracking of system power state
                       if (pIrpStack->MinorFunction == IRP_MN_SET_POWER) {

                           pDeviceContext->CurrentSystemState = pIrpStack->Parameters.Power.State.SystemState;
                       }

                       // request the new device state
                       //
                       ntStatus = PoRequestPowerIrp(
                           pDeviceContext->PhysicalDeviceObject,
                           pIrpStack->MinorFunction,
                           newPowerState,
                           PowerIrpCompletionRoutine,
                           PowerIrpContext,
                           NULL
                           );

                   } else
                   {
                       // couldn't allocate completion context

                       ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                   }

                   if (NT_SUCCESS(ntStatus)) {

                       // set up return status
                       IrpHandled = TRUE;
                       ntStatus = STATUS_PENDING;

                   } else {

                       PoStartNextPowerIrp( pIrp );
                       CompleteIrp( pDeviceContext, pIrp, ntStatus );
                       return ntStatus;
                   }
               }
            }
            break;
    }

    // If we didn't cope with the irp
    if( !IrpHandled )
    {
        // Send it on it's way.
        ntStatus = ForwardIrpSynchronous( pDeviceContext, pIrp );
        // and complete it.
        PoStartNextPowerIrp( pIrp );
        CompleteIrp( pDeviceContext, pIrp, ntStatus );
    }

    return ntStatus;
}


/*****************************************************************************
 * PcRegisterAdapterPowerManagement()
 *****************************************************************************
 * Register the adapter's power management interface
 * with portcls.  This routine also does a QI for a shutdown notification
 * interface.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcRegisterAdapterPowerManagement
(
    IN      PUNKNOWN    Unknown,
    IN      PVOID       pvContext1
)
{
    PAGED_CODE();

    ASSERT(pvContext1);
    ASSERT(Unknown);

    _DbgPrintF(DEBUGLVL_POWER,("PcRegisterAdapterPowerManagement"));

    //
    // Validate Parameters.
    //
    if (NULL == pvContext1 ||
        NULL == Unknown)
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("PcRegisterAdapterPowerManagement : Invalid Parameter"));
        return STATUS_INVALID_PARAMETER;
    }

    NTSTATUS        ntStatus        = STATUS_UNSUCCESSFUL;
    PDEVICE_OBJECT  pDeviceObject   = PDEVICE_OBJECT(pvContext1);
    PDEVICE_CONTEXT pDeviceContext  = PDEVICE_CONTEXT(pDeviceObject->DeviceExtension);

    ASSERT( pDeviceContext );

    //
    // Validate DeviceContext.
    //
    if (NULL == pDeviceContext)
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("PcRegisterAdapterPowerManagement : Invalid DeviceContext"));
        return STATUS_INVALID_PARAMETER;
    }

    #if (DBG)
    if( pDeviceContext->pAdapterPower )
    {
        _DbgPrintF( DEBUGLVL_POWER, ("Adapter overwriting PowerManagement interface"));
    }
    #endif
    // Make sure this is really the right
    // interface (Note: We have to release
    // it when the device is closed/stoped )
    PVOID pResult;
    ntStatus = Unknown->QueryInterface
    (
        IID_IAdapterPowerManagement,
        &pResult
    );

    if( NT_SUCCESS(ntStatus) )
    {
        // Store the interface for later use.
        pDeviceContext->pAdapterPower = PADAPTERPOWERMANAGEMENT( pResult );
    } else
    {
        pDeviceContext->pAdapterPower = 0;
    }

    return ntStatus;
}

/*****************************************************************************
 * PowerNotifySubdevices()
 *****************************************************************************
 * Called by ProcessPowerIrp to notify the device's subdevices of a power
 * state change.
 *
 */
void
PowerNotifySubdevices
(
    IN  PDEVICE_CONTEXT     pDeviceContext,
    IN  POWER_STATE         PowerState
)
{
    PAGED_CODE();

    ASSERT(pDeviceContext);

    _DbgPrintF(DEBUGLVL_POWER,("PowerNotifySubdevices"));

    // only notify the subdevices if we're started and if there are subdevices
    if (pDeviceContext->DeviceStopState == DeviceStarted)
    {
        PKSOBJECT_CREATE_ITEM createItem = pDeviceContext->CreateItems;

        // iterate through the subdevices
        for( ULONG index=0; index < pDeviceContext->MaxObjects; index++,createItem++)
        {
            if( createItem && (createItem->Create) )
            {
                PSUBDEVICE subDevice = PSUBDEVICE( createItem->Context );

                if( subDevice )
                {
                    // notify the subdevice
                    subDevice->PowerChangeNotify( PowerState );
                }
            }
        }
    }
}

/*****************************************************************************
 * DevicePowerWorker()
 *****************************************************************************
 * Called by ProcessPowerIrp in order to notify the device of the state change.
 * This is done in a work item so that the processing for the D0 irp doesn't
 * block the rest of the system from processing D0 irps.
 */
QUEUED_CALLBACK_RETURN
DevicePowerWorker
(
    IN  PDEVICE_OBJECT      pDeviceObject,
    IN  PVOID               PowerState
)
{
    PDEVICE_CONTEXT pDeviceContext =
        PDEVICE_CONTEXT(pDeviceObject->DeviceExtension);
    BOOL ProcessPendedIrps = FALSE;
    POWER_STATE NewPowerState;

    NewPowerState.DeviceState = (DEVICE_POWER_STATE)(ULONG_PTR)PowerState;

    // acquire the device so we're sync'ed with creates
    AcquireDevice(pDeviceContext);

    // change the driver state if it has a registered POWER interface
    if( pDeviceContext->pAdapterPower )
    {
        // notify the adapter
        pDeviceContext->pAdapterPower->PowerChangeState( NewPowerState );
    }

    // keep track of new state
    pDeviceContext->CurrentDeviceState = NewPowerState.DeviceState;

    // notify everyone we're now in our lighter D-state
    PoSetPowerState( pDeviceObject,
                     DevicePowerState,
                     NewPowerState );

    PowerNotifySubdevices( pDeviceContext, NewPowerState );

    // set PendCreates appropriately
    if( pDeviceContext->DeviceStopState == DeviceStarted )
    {
        // start allowing creates
        pDeviceContext->PendCreates = FALSE;

        // we have to process the pended irps after we release the device
        ProcessPendedIrps = TRUE;
    }

    ReleaseDevice(pDeviceContext);

    // complete if necessary any pended IRPs
    if ( ProcessPendedIrps )
    {
        CompletePendedIrps( pDeviceObject,
                            pDeviceContext,
                            EMPTY_QUEUE_AND_PROCESS );
    }

    return QUEUED_CALLBACK_FREE;
}

/*****************************************************************************
 * ProcessPowerIrp()
 *****************************************************************************
 * Called by DispatchPower to call the Adapter driver and all other work
 * related to a request.  Note that this routine MUST return STATUS_SUCCESS
 * for IRP_MN_SET_POWER requests.
 *
 */
NTSTATUS
ProcessPowerIrp
(
    IN      PIRP                pIrp,
    IN      PIO_STACK_LOCATION  pIrpStack,
    IN      PDEVICE_OBJECT      pDeviceObject
)
{
    PAGED_CODE();

    ASSERT(pIrp);
    ASSERT(pIrpStack);
    ASSERT(pDeviceObject);

    _DbgPrintF(DEBUGLVL_POWER,("ProcessPowerIrp"));

    // Assume the worst
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;

    PDEVICE_CONTEXT pDeviceContext = PDEVICE_CONTEXT(pDeviceObject->DeviceExtension);

    POWER_STATE NewPowerState = pIrpStack->Parameters.Power.State;

    // Get the current count of open
    // objects for this device (pins, streams, whatever).

    // NOTE: This count is maintained by KSO.CPP

    ULONG objectCount = pDeviceContext->ExistingObjectCount;

    // get the active pin count
    // NOTE: This count is maintained by IRPSTRM.CPP

    ULONG activePinCount = pDeviceContext->ActivePinCount;

    BOOL MovingToALighterState = (pDeviceContext->CurrentDeviceState > NewPowerState.DeviceState);

    if (pDeviceContext->CurrentDeviceState != NewPowerState.DeviceState) {

        // Deal with the particular IRP_MN
        switch( pIrpStack->MinorFunction )
        {
            case IRP_MN_QUERY_POWER:
                // simply query the driver if it has registered an interface
                if( pDeviceContext->pAdapterPower )
                {
                    ntStatus = pDeviceContext->pAdapterPower->QueryPowerChangeState( NewPowerState );
                } else
                {
                    // succeed the query
                    ntStatus = STATUS_SUCCESS;
                }

                _DbgPrintF(DEBUGLVL_POWER,("  IRP_MN_QUERY_POWER: D%d->D%d %s",
                               pDeviceContext->CurrentDeviceState-1,
                               NewPowerState.DeviceState-1,
                               NT_SUCCESS(ntStatus) ? "OKAY" : "FAIL"));

                break;

            case IRP_MN_SET_POWER:
                _DbgPrintF(DEBUGLVL_POWER,("  IRP_MN_SET_POWER: D%d->D%d",
                               pDeviceContext->CurrentDeviceState-1,
                               NewPowerState.DeviceState-1));

                // acquire the device so we're sync'ed with creates
                AcquireDevice(pDeviceContext);

                // if we're moving from a low power state to a higher power state
                if( MovingToALighterState )
                {
                    ASSERT(pDeviceContext->CurrentDeviceState != PowerDeviceD0);
                    ASSERT(NewPowerState.DeviceState == PowerDeviceD0);

                    // Then we need to forward to the PDO BEFORE doing our work.
                    ForwardIrpSynchronous( pDeviceContext, pIrp );

                    ReleaseDevice(pDeviceContext);

                    // Do the rest of the work in a work item in order to complete the D0 Irp
                    // as soon as possible
                    ntStatus = CallbackEnqueue(
                                    &pDeviceContext->pWorkQueueItemStart,
                                    DevicePowerWorker,
                                    pDeviceObject,
                                    (PVOID)(ULONG_PTR)NewPowerState.DeviceState,
                                    PASSIVE_LEVEL,
                                    EQCF_DIFFERENT_THREAD_REQUIRED
                                    );

                    // If we fail to enqueue the callback, do this the slow way
                    if ( !NT_SUCCESS(ntStatus) )
                    {
                        DevicePowerWorker( pDeviceObject,
                                           (PVOID)(ULONG_PTR)NewPowerState.DeviceState );
                    }

                } else {

                    // warn everyone we're about to enter a deeper D-state
                    PoSetPowerState( pDeviceObject,
                                     DevicePowerState,
                                     NewPowerState );

                    // moving to a lower state, notify the subdevices
                    PowerNotifySubdevices( pDeviceContext, NewPowerState );

                    // keep track of suspends for debugging only
                    pDeviceContext->SuspendCount++;

                    // change the driver state if it has a registered POWER interface
                    if( pDeviceContext->pAdapterPower )
                    {
                        // notify the adapter
                        pDeviceContext->pAdapterPower->PowerChangeState( NewPowerState );
                    }

                    // keep track of new state
                    pDeviceContext->CurrentDeviceState = NewPowerState.DeviceState;

                    ReleaseDevice(pDeviceContext);
                }

                // this irp is non-failable
                ntStatus = STATUS_SUCCESS;
                break;

            default:
                ASSERT(!"Called with unknown PM IRP ");
                break;
        }
    } else {

        //
        // We're already there...
        //
        ntStatus = STATUS_SUCCESS;
        ASSERT(!MovingToALighterState);
    }

    // set the return status
    pIrp->IoStatus.Status = ntStatus;

    // if not moving to a higher state, forward to the PDO.
    if( !MovingToALighterState )
    {
        ForwardIrpSynchronous( pDeviceContext, pIrp );
    }

    // start the next power irp
    PoStartNextPowerIrp( pIrp );

    // complete this irp
    CompleteIrp( pDeviceContext, pIrp, ntStatus );

    return ntStatus;
}

/*****************************************************************************
 * UpdateActivePinCount()
 *****************************************************************************
 *
 */
NTSTATUS
UpdateActivePinCount
(
    IN  PDEVICE_CONTEXT     DeviceContext,
    IN  BOOL                Increment
)
{
    PAGED_CODE();

    ASSERT(DeviceContext);

    ULONG       ActivePinCount;
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    BOOL        DoSystemStateRegistration;

    //
    // PoRegisterSystemState and PoUnregisterSystemState are not available on WDM 1.0 (Win98 and Win98SE)
    DoSystemStateRegistration = IoIsWdmVersionAvailable( 0x01, 0x10 );

    // adjust the active pin count
    if( Increment )
    {
        ActivePinCount = InterlockedIncrement( PLONG(&DeviceContext->ActivePinCount) );

//#if COMPILED_FOR_WDM110
        if ( 1 == ActivePinCount )
        {
            // register the system state as busy
            DeviceContext->SystemStateHandle = PoRegisterSystemState( DeviceContext->SystemStateHandle,
                                                                      ES_SYSTEM_REQUIRED | ES_CONTINUOUS );
        }
//#endif // COMPILED_FOR_WDM110

    } else
    {
        ActivePinCount = InterlockedDecrement( PLONG(&DeviceContext->ActivePinCount) );

//#if COMPILED_FOR_WDM110
        if( 0 == ActivePinCount )
        {
            PoUnregisterSystemState( DeviceContext->SystemStateHandle );
            DeviceContext->SystemStateHandle = NULL;
        }
//#endif // COMPILED_FOR_WDM110
    }

    _DbgPrintF(DEBUGLVL_VERBOSE,("UpdateActivePinCount (%d)",ActivePinCount));
//    _DbgPrintF(DEBUGLVL_POWER,("UpdateActivePinCount (%d)",ActivePinCount));

    return ntStatus;
}

/*****************************************************************************
 * GetIdleInfoFromRegistry()
 *****************************************************************************
 *
 */
NTSTATUS
GetIdleInfoFromRegistry
(
    IN  PDEVICE_CONTEXT     DeviceContext,
    OUT PULONG              ConservationIdleTime,
    OUT PULONG              PerformanceIdleTime,
    OUT PDEVICE_POWER_STATE IdleDeviceState
)
{
    PAGED_CODE();

    ASSERT(DeviceContext);
    ASSERT(ConservationIdleTime);
    ASSERT(PerformanceIdleTime);
    ASSERT(IdleDeviceState);

    NTSTATUS ntStatus;
    HANDLE DriverRegistryKey;
    HANDLE PowerSettingsKey;

    // store default values in return parms
    *ConservationIdleTime = DEFAULT_CONSERVATION_IDLE_TIME;
    *PerformanceIdleTime = DEFAULT_PERFORMANCE_IDLE_TIME;
    *IdleDeviceState = DEFAULT_IDLE_DEVICE_POWER_STATE;

    // open the driver registry key
    ntStatus = IoOpenDeviceRegistryKey( DeviceContext->PhysicalDeviceObject,
                                        PLUGPLAY_REGKEY_DRIVER,
                                        KEY_READ,
                                        &DriverRegistryKey );
    if(NT_SUCCESS(ntStatus))
    {
        OBJECT_ATTRIBUTES PowerSettingsAttributes;
        UNICODE_STRING PowerSettingsKeyName;

        // init the power settings key name
        RtlInitUnicodeString( &PowerSettingsKeyName, L"PowerSettings" );

        // init the power settings key object attributes
        InitializeObjectAttributes( &PowerSettingsAttributes,
                                    &PowerSettingsKeyName,
                                    OBJ_CASE_INSENSITIVE,
                                    DriverRegistryKey,
                                    NULL );

        // open the power settings key
        ntStatus = ZwOpenKey( &PowerSettingsKey,
                              KEY_READ,
                              &PowerSettingsAttributes );
        if(NT_SUCCESS(ntStatus))
        {
            UNICODE_STRING ConservationKey,PerformanceKey,IdleStateKey;
            ULONG BytesReturned;

            // init the key names
            RtlInitUnicodeString( &ConservationKey, L"ConservationIdleTime" );
            RtlInitUnicodeString( &PerformanceKey, L"PerformanceIdleTime" );
            RtlInitUnicodeString( &IdleStateKey, L"IdlePowerState" );

            // allocate a buffer to hold the query
            PVOID KeyData = ExAllocatePoolWithTag(PagedPool,
                                                  sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(DWORD),
                                                  'dKcP' ); //  'PcKd'
            if( NULL != KeyData )
            {
                // get the conservation idle time
                ntStatus = ZwQueryValueKey( PowerSettingsKey,
                                            &ConservationKey,
                                            KeyValuePartialInformation,
                                            KeyData,
                                            sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(DWORD),
                                            &BytesReturned );
                if(NT_SUCCESS(ntStatus))
                {
                    PKEY_VALUE_PARTIAL_INFORMATION PartialInfo = PKEY_VALUE_PARTIAL_INFORMATION(KeyData);

                    if(PartialInfo->DataLength == sizeof(DWORD))
                    {
                        // set the return value
                        *ConservationIdleTime = *(PDWORD(PartialInfo->Data));
                    }
                }

                // get the performance idle time
                ntStatus = ZwQueryValueKey( PowerSettingsKey,
                                            &PerformanceKey,
                                            KeyValuePartialInformation,
                                            KeyData,
                                            sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(DWORD),
                                            &BytesReturned );
                if(NT_SUCCESS(ntStatus))
                {
                    PKEY_VALUE_PARTIAL_INFORMATION PartialInfo = PKEY_VALUE_PARTIAL_INFORMATION(KeyData);

                    if(PartialInfo->DataLength == sizeof(DWORD))
                    {
                        // set the return value
                        *PerformanceIdleTime = *(PDWORD(PartialInfo->Data));
                    }
                }

                // get the device idle state
                ntStatus = ZwQueryValueKey( PowerSettingsKey,
                                            &IdleStateKey,
                                            KeyValuePartialInformation,
                                            KeyData,
                                            sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(DWORD),
                                            &BytesReturned );
                if(NT_SUCCESS(ntStatus))
                {
                    PKEY_VALUE_PARTIAL_INFORMATION PartialInfo = PKEY_VALUE_PARTIAL_INFORMATION(KeyData);

                    if(PartialInfo->DataLength == sizeof(DWORD))
                    {
                        // determine the return value
                        switch( *(PDWORD(PartialInfo->Data)) )
                        {
                            case 3:
                                *IdleDeviceState = PowerDeviceD3;
                                break;

                            case 2:
                                *IdleDeviceState = PowerDeviceD2;
                                break;

                            case 1:
                                *IdleDeviceState = PowerDeviceD1;
                                break;

                            default:
                                *IdleDeviceState = PowerDeviceD0;
                                break;
                        }
                    }
                }

                // free the key info buffer
                ExFreePool( KeyData );
            }

            // close the power settings key
            ZwClose( PowerSettingsKey );
        }

        // close the driver registry key
        ZwClose( DriverRegistryKey );
    }

    // always succeed since we return either the registry value(s) or the defaults
    return STATUS_SUCCESS;
}

/*****************************************************************************
 * PcRequestNewPowerState()
 *****************************************************************************
 * This routine is used to request a new power state for the device.  It is
 * normally used internally by portcls but is also exported to adapters so
 * that the adapters can also request power state changes.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcRequestNewPowerState
(
    IN      PDEVICE_OBJECT      pDeviceObject,
    IN      DEVICE_POWER_STATE  RequestedNewState
)
{
    PAGED_CODE();

    ASSERT(pDeviceObject);

    _DbgPrintF(DEBUGLVL_POWER,("PcRequestNewPowerState"));

    //
    // Validate Parameters.
    //
    if (NULL == pDeviceObject)
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("PcRequestNewPowerState : Invalid Parameter"));
        return STATUS_INVALID_PARAMETER;
    }

    PDEVICE_CONTEXT pDeviceContext = PDEVICE_CONTEXT(pDeviceObject->DeviceExtension);
    ASSERT(pDeviceContext);

    NTSTATUS ntStatus = STATUS_SUCCESS;

    //
    // Validate DeviceContext.
    //
    if (NULL == pDeviceContext)
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("PcRequestNewPowerState : Invalid DeviceContext"));
        return STATUS_INVALID_PARAMETER;
    }

    // check if this is actually a state change
    if( RequestedNewState != pDeviceContext->CurrentDeviceState )
    {
        POWER_STATE         newPowerState;
        POWER_IRP_CONTEXT   PowerIrpContext;
        KEVENT              SyncEvent;

        // prepare the requested state
        newPowerState.DeviceState = RequestedNewState;

        // setup the sync event and the completion routine context
        KeInitializeEvent( &SyncEvent,
                           SynchronizationEvent,
                           FALSE );
        PowerIrpContext.PowerSyncEvent = &SyncEvent;
#if DBG
        PowerIrpContext.Status = STATUS_PENDING;
#endif // DBG
        PowerIrpContext.PendingSystemPowerIrp = NULL;
        PowerIrpContext.DeviceContext = NULL;

        // Set the new power state
        ntStatus = PoRequestPowerIrp( pDeviceContext->PhysicalDeviceObject,
                                      IRP_MN_SET_POWER,
                                      newPowerState,
                                      PowerIrpCompletionRoutine,
                                      &PowerIrpContext,
                                      NULL );

        // Did this get allocated and sent??
        //
        if( NT_SUCCESS(ntStatus) )
        {
            // Wait for the completion event
            KeWaitForSingleObject( &SyncEvent,
                                   Suspended,
                                   KernelMode,
                                   FALSE,
                                   NULL );

            ntStatus = PowerIrpContext.Status;
        }
    }

    return ntStatus;
}

/*****************************************************************************
 * CheckCurrentPowerState()
 *****************************************************************************
 * This routine resets the idle timer and checks to see if the device is
 * current in the D0 (full power) state.  If it isn't, it requests that the
 * device power up to D0.
 */
NTSTATUS
CheckCurrentPowerState
(
    IN  PDEVICE_OBJECT      pDeviceObject
)
{
    PAGED_CODE();

    ASSERT(pDeviceObject);

    PDEVICE_CONTEXT pDeviceContext = PDEVICE_CONTEXT(pDeviceObject->DeviceExtension);

    NTSTATUS ntStatus = STATUS_SUCCESS;

    // reset the idle timer
    if( pDeviceContext->IdleTimer )
    {
        PoSetDeviceBusy( pDeviceContext->IdleTimer );
    }

    // check if we're in PowerDeviceD0
    if( pDeviceContext->CurrentDeviceState != PowerDeviceD0 )
    {
        ntStatus = STATUS_DEVICE_NOT_READY;
    }

    return ntStatus;
}


#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\main\shmisc.cpp ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation.  All rights reserved.

Module Name:

    shmisc.cpp

Abstract:

    This module contains miscellaneous functions for the kernel streaming
    filter shell.

Author:

    Dale Sather  (DaleSat) 31-Jul-1998

--*/

#include "private.h"
#include "ksshellp.h"
#include <kcom.h>

#pragma code_seg("PAGE")


void
KsWorkSinkItemWorker(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine calls a worker function on a work sink interface.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("KsWorkSinkItemWorker"));

    PAGED_CODE();

    ASSERT(Context);

    PIKSWORKSINK(Context)->Work();
}


void
KspShellStandardConnect(
    IN PIKSSHELLTRANSPORT NewTransport OPTIONAL,
    OUT PIKSSHELLTRANSPORT *OldTransport OPTIONAL,
    IN KSPIN_DATAFLOW DataFlow,
    IN PIKSSHELLTRANSPORT ThisTransport,
    IN PIKSSHELLTRANSPORT* SourceTransport,
    IN PIKSSHELLTRANSPORT* SinkTransport
    )

/*++

Routine Description:

    This routine establishes a transport connection.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("KspShellStandardConnect"));

    PAGED_CODE();

    ASSERT(ThisTransport);
    ASSERT(SourceTransport);
    ASSERT(SinkTransport);

    //
    // Make sure this object sticks around until we are done.
    //
    ThisTransport->AddRef();

    PIKSSHELLTRANSPORT* transport =
        (DataFlow & KSPIN_DATAFLOW_IN) ?
        SourceTransport :
        SinkTransport;

    //
    // Release the current source/sink.
    //
    if (*transport) {
        //
        // First disconnect the old back link.  If we are connecting a back
        // link for a new connection, we need to do this too.  If we are
        // clearing a back link (disconnecting), this request came from the
        // component we're connected to, so we don't bounce back again.
        //
        switch (DataFlow) {
        case KSPIN_DATAFLOW_IN:
            (*transport)->Connect(NULL,NULL,KSPSHELL_BACKCONNECT_OUT);
            break;

        case KSPIN_DATAFLOW_OUT:
            (*transport)->Connect(NULL,NULL,KSPSHELL_BACKCONNECT_IN);
            break;
        
        case KSPSHELL_BACKCONNECT_IN:
            if (NewTransport) {
                (*transport)->Connect(NULL,NULL,KSPSHELL_BACKCONNECT_OUT);
            }
            break;

        case KSPSHELL_BACKCONNECT_OUT:
            if (NewTransport) {
                (*transport)->Connect(NULL,NULL,KSPSHELL_BACKCONNECT_IN);
            }
            break;
        }

        //
        // Now release the old neighbor or hand it off to the caller.
        //
        if (OldTransport) {
            *OldTransport = *transport;
        } else {
            (*transport)->Release();
        }
    } else if (OldTransport) {
        *OldTransport = NULL;
    }

    //
    // Copy the new source/sink.
    //
    *transport = NewTransport;

    if (NewTransport) {
        //
        // Add a reference if necessary.
        //
        NewTransport->AddRef();

        //
        // Do the back connect if necessary.
        //
        switch (DataFlow) {
        case KSPIN_DATAFLOW_IN:
            NewTransport->Connect(ThisTransport,NULL,KSPSHELL_BACKCONNECT_OUT);
            break;

        case KSPIN_DATAFLOW_OUT:
            NewTransport->Connect(ThisTransport,NULL,KSPSHELL_BACKCONNECT_IN);
            break;
        }
    }

    //
    // Now this object may die if it has no references.
    //
    ThisTransport->Release();
}

#pragma code_seg()


NTSTATUS
KspShellTransferKsIrp(
    IN PIKSSHELLTRANSPORT NewTransport,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine transfers a streaming IRP using the kernel streaming shell
    transport.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("KspShellTransferKsIrp"));

    ASSERT(NewTransport);
    ASSERT(Irp);

    NTSTATUS status = STATUS_UNSUCCESSFUL;
    while (NewTransport) {
        PIKSSHELLTRANSPORT nextTransport;
        status = NewTransport->TransferKsIrp(Irp,&nextTransport);

        ASSERT(NT_SUCCESS(status) || ! nextTransport);

        NewTransport = nextTransport;
    }

    return status;
}

#pragma code_seg("PAGE")

#if DBG

void
DbgPrintCircuit(
    IN PIKSSHELLTRANSPORT Transport
    )

/*++

Routine Description:

    This routine spews a transport circuit.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("DbgPrintCircuit"));

    PAGED_CODE();

    ASSERT(Transport);

#define MAX_NAME_SIZE 64

    PIKSSHELLTRANSPORT transport = Transport;
    while (transport) {
        CHAR name[MAX_NAME_SIZE + 1];
        PIKSSHELLTRANSPORT next;
        PIKSSHELLTRANSPORT prev;

        transport->DbgRollCall(MAX_NAME_SIZE,name,&next,&prev);
        DbgPrint("  %s",name);

        if (prev) {
            PIKSSHELLTRANSPORT next2;
            PIKSSHELLTRANSPORT prev2;
            prev->DbgRollCall(MAX_NAME_SIZE,name,&next2,&prev2);
            if (next2 != transport) {
                DbgPrint(" SOURCE'S(0x%08x) SINK(0x%08x) != THIS(%08x)",prev,next2,transport);
            }
        } else {
            DbgPrint(" NO SOURCE");
        }

        if (next) {
            PIKSSHELLTRANSPORT next2;
            PIKSSHELLTRANSPORT prev2;
            next->DbgRollCall(MAX_NAME_SIZE,name,&next2,&prev2);
            if (prev2 != transport) {
                DbgPrint(" SINK'S(0x%08x) SOURCE(0x%08x) != THIS(%08x)",next,prev2,transport);
            }
        } else {
            DbgPrint(" NO SINK");
        }

        DbgPrint("\n");

        transport = next;
        if (transport == Transport) {
            break;
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\main\waveclk.cpp ===
/*****************************************************************************
 * waveclk.cpp - wave clock implementation
 *****************************************************************************
 * Copyright (c) 1998-2000 Microsoft Corporation.  All rights reserved.
 */

#include "private.h"

/*****************************************************************************
 * IIrpTargetInit
 *****************************************************************************
 * IIrpTargetInit plus CWaveClock's Init.
 */
DECLARE_INTERFACE_(IIrpTargetInit,IIrpTarget)
{
    DEFINE_ABSTRACT_UNKNOWN()           // For IUnknown

    DEFINE_ABSTRACT_IRPTARGETFACTORY()  // For IIrpTargetFactory

    DEFINE_ABSTRACT_IRPTARGET()         // For IIrpTarget

    STDMETHOD_(NTSTATUS,Init)
    (   THIS_
        IN      PIRPSTREAMCONTROL   pIrpStreamControl,
        IN      PKSPIN_LOCK         pKSpinLock,
        IN      PLIST_ENTRY         pListEntry
    )   PURE;
};

typedef IIrpTargetInit *PIRPTARGETINIT;

/*****************************************************************************
 * CWaveClock
 *****************************************************************************
 * Wave clock implementation.
 */
class CWaveClock : 
    public IIrpTargetInit,
    public IWaveClock,
    public CUnknown
{
private:
    WAVECLOCKNODE           m_waveClockNode;
    PKSPIN_LOCK             m_pKSpinLock;
    PIRPSTREAMCONTROL       m_pIrpStreamControl;
    KSPIN_LOCK              m_ClockLock,
                            m_EventLock;
    LIST_ENTRY              m_EventList;
    KMUTEX                  m_StateMutex;
    LONGLONG                m_LastTime, 
                            m_LastPhysicalTime,
                            m_LastPhysicalPosition;
    KSSTATE                 m_DeviceState;

    LONGLONG
    m_GetCurrentTime
    (   void
    );

public:
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CWaveClock);
    ~CWaveClock();

    IMP_IIrpTarget;
    IMP_IWaveClock;
    
    STDMETHODIMP_(NTSTATUS) Init
    (   IN      PIRPSTREAMCONTROL   pIrpStreamControl,
        IN      PKSPIN_LOCK         pKSpinLock,
        IN      PLIST_ENTRY         pListEntry
    );

    //
    // helper functions (also the DPC interface)
    //      
    
    static
    LONGLONG
    FASTCALL
    GetCurrentTime(
        IN PFILE_OBJECT FileObject
        );
        
    static
    LONGLONG
    FASTCALL
    GetCurrentPhysicalTime(
        IN PFILE_OBJECT FileObject
        );
        
    static
    LONGLONG
    FASTCALL
    GetCurrentCorrelatedTime(
        IN PFILE_OBJECT FileObject,
        OUT PLONGLONG SystemTime
        );
        
    static
    LONGLONG
    FASTCALL
    GetCurrentCorrelatedPhysicalTime(
        IN PFILE_OBJECT FileObject,
        OUT PLONGLONG SystemTime
        );
        
    //
    // property handlers and event handlers
    //
    
    static
    NTSTATUS
    AddEvent(
        IN PIRP Irp,
        IN PKSEVENT_TIME_INTERVAL EventTime,
        IN PKSEVENT_ENTRY EventEntry
        );
    
    static
    NTSTATUS
    GetFunctionTable(
        IN PIRP Irp,
        IN PKSPROPERTY Property,
        OUT PKSCLOCK_FUNCTIONTABLE FunctionTable
        );
        
    static
    NTSTATUS
    GetCorrelatedTime(
        IN PIRP Irp,
        IN PKSPROPERTY Property,
        OUT PKSCORRELATED_TIME CorrelatedTime
        );
    
    static
    NTSTATUS
    GetTime(
        IN PIRP Irp,
        IN PKSPROPERTY Property,
        OUT PLONGLONG Time
        );
        
    static
    NTSTATUS
    GetCorrelatedPhysicalTime(
        IN PIRP Irp,
        IN PKSPROPERTY Property,
        OUT PKSCORRELATED_TIME CorrelatedTime
        );
        
    static
    NTSTATUS
    GetPhysicalTime(
        IN PIRP Irp,
        IN PKSPROPERTY Property,
        OUT PLONGLONG Time
        );
        
    static
    NTSTATUS
    GetResolution(
        IN PIRP Irp,
        IN PKSPROPERTY Property,
        OUT PKSRESOLUTION Resolution
        );
        
    static
    NTSTATUS
    GetState(
        IN PIRP Irp,
        IN PKSPROPERTY Property,
        OUT PKSSTATE State
        );        
};

DEFINE_KSPROPERTY_CLOCKSET( 
    ClockPropertyHandlers,
    CWaveClock::GetTime,
    CWaveClock::GetPhysicalTime,
    CWaveClock::GetCorrelatedTime,
    CWaveClock::GetCorrelatedPhysicalTime,
    CWaveClock::GetResolution,
    CWaveClock::GetState,
    CWaveClock::GetFunctionTable );

DEFINE_KSPROPERTY_SET_TABLE( ClockPropertyTable )
{
    DEFINE_KSPROPERTY_SET( 
        &KSPROPSETID_Clock,
        SIZEOF_ARRAY( ClockPropertyHandlers ),
        ClockPropertyHandlers,
        0, 
        NULL)
};

DEFINE_KSEVENT_TABLE( ClockEventHandlers ) 
{
    DEFINE_KSEVENT_ITEM(
        KSEVENT_CLOCK_INTERVAL_MARK,
        sizeof( KSEVENT_TIME_INTERVAL ),
        sizeof( ULONGLONG ) + sizeof( ULONGLONG ),
        (PFNKSADDEVENT) CWaveClock::AddEvent,
        NULL,
        NULL),
    DEFINE_KSEVENT_ITEM(
        KSEVENT_CLOCK_POSITION_MARK,
        sizeof( KSEVENT_TIME_MARK ),
        sizeof( ULONGLONG ),
        (PFNKSADDEVENT) CWaveClock::AddEvent,
        NULL,
        NULL)
};

DEFINE_KSEVENT_SET_TABLE( ClockEventTable )
{
    DEFINE_KSEVENT_SET( 
        &KSEVENTSETID_Clock, 
        SIZEOF_ARRAY( ClockEventHandlers ),
        ClockEventHandlers)
};

#pragma code_seg("PAGE")

/*****************************************************************************
 * CreateWaveClock()
 *****************************************************************************
 * Creates a CWaveClock object.
 */
NTSTATUS
CreateWaveClock
(
    OUT     PUNKNOWN *  pUnknown,
    IN      REFCLSID,
    IN      PUNKNOWN    pUnknownOuter   OPTIONAL,
    IN      POOL_TYPE   poolType
)
{
    PAGED_CODE();

    ASSERT(pUnknown);

    _DbgPrintF(DEBUGLVL_LIFETIME,("Creating WAVECLK"));

    STD_CREATE_BODY_
    (
        CWaveClock,
        pUnknown,
        pUnknownOuter,
        poolType,
        PIRPTARGET
    );
}

/*****************************************************************************
 * PcNewWaveClock()
 *****************************************************************************
 * Creates a new wave clock.
 */
NTSTATUS
PcNewWaveClock
(   OUT     PIRPTARGET *        ppIrpTarget,
    IN      PUNKNOWN            pUnknownOuter,
    IN      POOL_TYPE           poolType,
    IN      PIRPSTREAMCONTROL   pIrpStreamControl,
    IN      PKSPIN_LOCK         pKSpinLock,
    IN      PLIST_ENTRY         pListEntry
)
{
    PAGED_CODE();

    ASSERT(pIrpStreamControl);
    ASSERT(pKSpinLock);
    ASSERT(pListEntry);

    PUNKNOWN pUnknown;
    NTSTATUS ntStatus =
        CreateWaveClock
        (   &pUnknown,
            GUID_NULL,
            pUnknownOuter,
            poolType
        );

    if (NT_SUCCESS(ntStatus))
    {
        PIRPTARGETINIT pIrpTargetInit;
        ntStatus =
            pUnknown->QueryInterface
            (   IID_IIrpTarget,
                (PVOID *) &pIrpTargetInit
            );

        if (NT_SUCCESS(ntStatus))
        {
            ntStatus =
                pIrpTargetInit->Init
                (   pIrpStreamControl,
                    pKSpinLock,
                    pListEntry
                );

            if (NT_SUCCESS(ntStatus))
            {
                *ppIrpTarget = pIrpTargetInit;
            }
            else
            {
                pIrpTargetInit->Release();
            }
        }

        pUnknown->Release();
    }

    return ntStatus;
}

/*****************************************************************************
 * CWaveClock::Init()
 *****************************************************************************
 * Initializes a wave clock.
 */
NTSTATUS
CWaveClock::
Init
(   IN      PIRPSTREAMCONTROL   pIrpStreamControl,
    IN      PKSPIN_LOCK         pKSpinLock,
    IN      PLIST_ENTRY         pListEntry
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_LIFETIME,("Initializing WAVECLK (0x%08x)",this));

    ASSERT(pIrpStreamControl);
    ASSERT(pKSpinLock);
    ASSERT(pListEntry);

    //
    // Save parameters.
    //
    m_pIrpStreamControl = pIrpStreamControl;
    m_pIrpStreamControl->AddRef();

    m_pKSpinLock = pKSpinLock;

    //
    // Initialize other members.
    //
    KeInitializeMutex(&m_StateMutex,0);
    KeInitializeSpinLock(&m_EventLock);
    KeInitializeSpinLock(&m_ClockLock);
    InitializeListHead(&m_EventList);
    
    //
    // Point the wave clock node to the IWaveClock interface.
    //
    m_waveClockNode.pWaveClock = PWAVECLOCK(this);

    //
    // Add this clock to the list of clocks.  We don't need to keep the list
    // head because removal does not require it.  The spinlock will come in
    // handy, though.
    //
    ExInterlockedInsertTailList
    (   pListEntry,
        &m_waveClockNode.listEntry,
        pKSpinLock
    );

    return STATUS_SUCCESS;
}

#pragma code_seg()

/*****************************************************************************
 * MyInterlockedRemoveEntryList()
 *****************************************************************************
 * Interlocked RemoveEntryList.
 */
void
MyInterlockedRemoveEntryList
(   IN      PLIST_ENTRY     pListEntry,
    IN      PKSPIN_LOCK     pKSpinLock
)
{
    KIRQL kIrqlOld;
    KeAcquireSpinLock(pKSpinLock,&kIrqlOld);
    RemoveEntryList(pListEntry);
    KeReleaseSpinLock(pKSpinLock,kIrqlOld);
}

#pragma code_seg("PAGE")

/*****************************************************************************
 * CWaveClock::~CWaveClock()
 *****************************************************************************
 * Destructor.
 */
CWaveClock::~CWaveClock()
{
    _DbgPrintF(DEBUGLVL_LIFETIME,("Destroying WAVECLK (0x%08x)",this));

    //
    // Remove us from the list if we are in it.
    //
    if (m_waveClockNode.listEntry.Flink) 
    {
        MyInterlockedRemoveEntryList(&m_waveClockNode.listEntry,m_pKSpinLock);
    }

    //
    // Release the control interface if we have a reference.
    //
    if (m_pIrpStreamControl)
    {
        m_pIrpStreamControl->Release();
    }
}

/*****************************************************************************
 * CWaveClock::NonDelegatingQueryInterface()
 *****************************************************************************
 * Get an interface.
 */
STDMETHODIMP_(NTSTATUS)
CWaveClock::NonDelegatingQueryInterface
(
    IN      REFIID  riid,
    OUT     PVOID * ppvObject
)
{
    PAGED_CODE();

    ASSERT(ppvObject);

    _DbgPrintF(DEBUGLVL_BLAB,("CWaveClock::NonDelegatingQueryInterface"));

    if
    (   IsEqualGUIDAligned(riid,IID_IUnknown)
    ||  IsEqualGUIDAligned(riid,IID_IIrpTarget)
    ) 
    {
        *ppvObject = PVOID(PIRPTARGETINIT(this));
    } 
    else
    if (IsEqualGUIDAligned(riid,IID_IWaveClock)) 
    {
        *ppvObject = PVOID(PWAVECLOCK(this));
    } 
    else 
    {
        *ppvObject = NULL;
    }

    if (*ppvObject) 
    {
        PUNKNOWN(*ppvObject)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

STDMETHODIMP_(NTSTATUS)
CWaveClock::DeviceIoControl
(
    IN      PDEVICE_OBJECT DeviceObject,
    IN      PIRP Irp
)

/*++

Routine Description:
    Processes device I/O control for this file object on this device object
    
Arguments:
    IN PDEVICE_OBJECT DeviceObject -
        pointer to the device object

    IN PIRP Irp -
        pointer to I/O request packet

Return:
    STATUS_SUCCESS or an appropriate error code

--*/

{
    NTSTATUS            Status;
    PIO_STACK_LOCATION  irpSp;
    
    PAGED_CODE();

    ASSERT( DeviceObject );
    ASSERT( Irp );

    _DbgPrintF( DEBUGLVL_BLAB, ("CWaveClock::DeviceIoControl"));

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {

    case IOCTL_KS_PROPERTY:
        Status = 
            KsPropertyHandler( 
                Irp, 
                SIZEOF_ARRAY( ClockPropertyTable ),
                (PKSPROPERTY_SET) ClockPropertyTable );
        break;

    case IOCTL_KS_ENABLE_EVENT:
        _DbgPrintF( DEBUGLVL_VERBOSE, ("CWaveClock::EnableEvent"));

        Status = 
            KsEnableEvent( 
                Irp, 
                SIZEOF_ARRAY( ClockEventTable ), 
                (PKSEVENT_SET) ClockEventTable, 
                NULL, 
                KSEVENTS_NONE,
                NULL);
        break;

    case IOCTL_KS_DISABLE_EVENT:
        _DbgPrintF( DEBUGLVL_VERBOSE, ("CWaveClock::DisableEvent"));
    
        Status = 
            KsDisableEvent( 
                Irp, 
                &m_EventList,
                KSEVENTS_SPINLOCK,
                &m_EventLock );
        break;

    default:
    
        return KsDefaultDeviceIoCompletion( DeviceObject, Irp );

    }

    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;
}

STDMETHODIMP_(NTSTATUS)
CWaveClock::Close(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:
    Close handler for the clock file object

Arguments:
    IN PDEVICE_OBJECT DeviceObject -
        pointer to the device object

    IN PIRP Irp -
        pointer to the I/O request packet

Return:
    STATUS success or an appropriate error code

--*/

{
    PIO_STACK_LOCATION irpSp;
    
    PAGED_CODE();

    ASSERT(DeviceObject);
    ASSERT(Irp);

    _DbgPrintF( DEBUGLVL_VERBOSE, ("CWaveClock::Close"));
    
    irpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Free events associated with this pin.
    //
    
    KsFreeEventList(
        irpSp->FileObject,
        &m_EventList,
        KSEVENTS_SPINLOCK,
        &m_EventLock );

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp,IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}

DEFINE_INVALID_CREATE(CWaveClock);
DEFINE_INVALID_READ(CWaveClock);
DEFINE_INVALID_WRITE(CWaveClock);
DEFINE_INVALID_FLUSH(CWaveClock);
DEFINE_INVALID_QUERYSECURITY(CWaveClock);
DEFINE_INVALID_SETSECURITY(CWaveClock);
DEFINE_INVALID_FASTDEVICEIOCONTROL(CWaveClock);
DEFINE_INVALID_FASTREAD(CWaveClock);
DEFINE_INVALID_FASTWRITE(CWaveClock);

#pragma code_seg()

STDMETHODIMP_(NTSTATUS)
CWaveClock::
GenerateEvents
(   void
)
{
    LONGLONG                Time;
    PLIST_ENTRY             ListEntry;
    
    if (m_DeviceState == KSSTATE_RUN) {
    
        Time = m_GetCurrentTime();

        ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );
        
        KeAcquireSpinLockAtDpcLevel( &m_EventLock );

        for(ListEntry = m_EventList.Flink; 
            ListEntry != &m_EventList;) {
            
            PKSEVENT_ENTRY  EventEntry;
            PKSINTERVAL     Interval;

            EventEntry = 
                (PKSEVENT_ENTRY)
                    CONTAINING_RECORD( ListEntry, KSEVENT_ENTRY, ListEntry );
                
            //
            // Pre-inc, KsGenerateEvent() can remove this item from the list.
            //    
            ListEntry = ListEntry->Flink;
            //
            // The event-specific data was added onto the end of the entry.
            //
            Interval = (PKSINTERVAL)(EventEntry + 1);
            //
            // Time for this event to go off.
            //
            if (Interval->TimeBase <= Time) {
                _DbgPrintF(
                    DEBUGLVL_VERBOSE, ("Generating event for time: %ld at time: %ld",
                    Interval->TimeBase, Time) );
            
                if (EventEntry->EventItem->EventId != 
                        KSEVENT_CLOCK_INTERVAL_MARK) {
                    //
                    // A single-shot should only go off once, so make
                    // it a value which will never be reached again.
                    //
                    Interval->TimeBase = 0x7fffffffffffffff;
                
                } else {
                    LONGLONG    Intervals;
                    //
                    // An interval timer should only go off once per time,
                    // so update it to the next timeout.
                    //
                    Intervals = 
                        (Time - Interval->TimeBase + Interval->Interval - 1) / Interval->Interval;
                    Interval->TimeBase += Intervals * Interval->Interval;
                } 
                        
                KsGenerateEvent( EventEntry );
            }
        }
        
        KeReleaseSpinLockFromDpcLevel( &m_EventLock );
    }
    
    return STATUS_SUCCESS;
}

STDMETHODIMP_(NTSTATUS)
CWaveClock::SetState(
    KSSTATE State
    )

/*++

Routine Description:
    This method is called by the port to notify of a state change.

Arguments:
    KSSTATE State -
        New state

Return:
    STATUS_SUCCESS

--*/

{
    //
    // Synchronize with GetState,
    //
    KeWaitForMutexObject(
        &m_StateMutex,
        Executive,
        KernelMode,
        FALSE,
        NULL );

    //
    // set the new state,
    //        
    m_DeviceState = State;
    switch (State) {
    
    case KSSTATE_STOP:
        m_LastTime = m_LastPhysicalTime = m_LastPhysicalPosition = 0;
        break;
        
    case KSSTATE_RUN:
        break;
    }
    
    //
    // and then release the mutex.
    //
    KeReleaseMutex( &m_StateMutex, FALSE );
    
    return STATUS_SUCCESS;
}    

NTSTATUS
CWaveClock::AddEvent(
    IN PIRP                     Irp,
    IN PKSEVENT_TIME_INTERVAL   EventTime,
    IN PKSEVENT_ENTRY           EventEntry
    )

/*++

Routine Description:

    This is the AddEvent() handler for the clock events.

    NOTE: This routine acquires a spinlock, must be in non-paged code.
    
Arguments:

    IN PIRP Irp - 
        pointer to the I/O request packet    

    IN PKSEVENT_TIME_INTERVAL EventTime -
        specified time interval or one shot

    IN PKSEVENT_ENTRY EventEntry -
        pointer to event entry structure

Return Value:
    STATUS_SUCCESS

--*/

{
    KIRQL                   irqlOld;
    PKSINTERVAL             Interval;
    
    CWaveClock *pCWaveClock =
        (CWaveClock *) KsoGetIrpTargetFromIrp(Irp);
        
    ASSERT( pCWaveClock );
    
    _DbgPrintF( DEBUGLVL_VERBOSE, ("CWaveClock::AddEvent"));
            
    //
    // Space for the interval is located at the end of the basic 
    // event structure.
    //
    Interval = (PKSINTERVAL)(EventEntry + 1);
    //
    // Either just an event time was passed, or a time base plus an 
    // interval. In both cases the first LONGLONG is present and saved.
    //
    Interval->TimeBase = EventTime->TimeBase;
    if (EventEntry->EventItem->EventId == KSEVENT_CLOCK_INTERVAL_MARK) 
    {
        Interval->Interval = EventTime->Interval;
    }

    KeAcquireSpinLock( &pCWaveClock->m_EventLock, &irqlOld );
    InsertHeadList( &pCWaveClock->m_EventList, &EventEntry->ListEntry );
    KeReleaseSpinLock( &pCWaveClock->m_EventLock, irqlOld );
    //
    // If this event is passed, signal immediately.
    // Note, KS_CLOCK_POSITION_MARK is a single-shot event
    // 
    pCWaveClock->GenerateEvents();
    
    return STATUS_SUCCESS;
}

LONGLONG
FASTCALL
CWaveClock::
GetCurrentTime
(
    PFILE_OBJECT FileObject
)

/*++

Routine Description:
    Computes the current presentation time.
    
    NOTE: This routine acquires a spinlock, must be in non-paged code.

Arguments:
    PFILE_OBJECT FileObject -
        this clock's file object 
        
Return:
    resultant presentation time normalized to 100ns units.

--*/

{
    CWaveClock *pCWaveClock =
        (CWaveClock *) KsoGetIrpTargetFromFileObject(FileObject);

    return pCWaveClock->m_GetCurrentTime();
}
        
LONGLONG
CWaveClock::
m_GetCurrentTime
(   void
)

/*++

Routine Description:
    Computes the current presentation time.
    
    NOTE: This routine acquires a spinlock, must be in non-paged code.

Arguments:
        
Return:
    resultant presentation time normalized to 100ns units.

--*/
{
    IRPSTREAMPACKETINFO     irpStreamPacketInfoUnmapping;
    KIRQL                   irqlOld;
    LONGLONG                StreamTime;
    NTSTATUS                Status;
    PIRPSTREAMCONTROL       pIrpStreamControl;
    
    StreamTime = 0;

    //
    // Query the position from the IRP stream.
    //
    pIrpStreamControl = m_pIrpStreamControl;
    ASSERT(pIrpStreamControl);
	IRPSTREAM_POSITION irpStreamPosition;
    Status = pIrpStreamControl->GetPosition(&irpStreamPosition);
    if (NT_SUCCESS(Status))
    {
        //
        // Never exceed current stream extent.
        //
        if 
        (   irpStreamPosition.ullStreamPosition
        >   irpStreamPosition.ullCurrentExtent
        )
        {
            StreamTime = 
                irpStreamPosition.ullCurrentExtent;
        }
        else
        {
            StreamTime = 
                irpStreamPosition.ullStreamPosition;
        }

        StreamTime = 
            pIrpStreamControl->NormalizePosition(StreamTime);
    }

    KeAcquireSpinLock( &m_ClockLock, &irqlOld );

    if (NT_SUCCESS( Status )) {
        if (StreamTime < m_LastTime) {
            _DbgPrintF( 
                DEBUGLVL_VERBOSE, 
                ("new time is less than last reported time! (%I64d, %I64d)",
                StreamTime, m_LastTime) );
            StreamTime = m_LastTime;
        } else {
            m_LastTime = StreamTime;
        }
    } else {
        StreamTime = m_LastTime;
    }
    
    KeReleaseSpinLock( &m_ClockLock, irqlOld );
    
    return StreamTime;
}

LONGLONG
FASTCALL
CWaveClock::GetCurrentCorrelatedTime(
    PFILE_OBJECT FileObject,
    PLONGLONG SystemTime
    )

/*++

Routine Description:


Arguments:
    PFILE_OBJECT FileObject -

    PLONGLONG SystemTime -
        pointer 

Return:
    current presentation time in 100ns

--*/

{
    LARGE_INTEGER Time, Frequency;
    
    Time = KeQueryPerformanceCounter( &Frequency );
    
    //
    //  Convert ticks to 100ns units.
    //
    *SystemTime = KSCONVERT_PERFORMANCE_TIME(Frequency.QuadPart,Time);

    return GetCurrentTime( FileObject );
}    

LONGLONG
FASTCALL
CWaveClock::GetCurrentPhysicalTime(
    PFILE_OBJECT FileObject
    )

/*++

Routine Description:
    Computes the current physical time.

    NOTE: This routine acquires a spinlock, must be in non-paged code.
    
Arguments:
    PFILE_OBJECT FileObject -
        this clock's file object 

Return:
    current physical time in 100ns

--*/

{
    KIRQL                       irqlOld;
    LONGLONG                    PhysicalTime;
    NTSTATUS                    Status;
    ULONG                       CurrentPosition;
    
    CWaveClock *pCWaveClock =
        (CWaveClock *) KsoGetIrpTargetFromFileObject(FileObject);

    PhysicalTime = 0;
    
    //
    // Query the position from the IRP stream.
    //
    PIRPSTREAMCONTROL pIrpStreamControl = 
        pCWaveClock->m_pIrpStreamControl;
    ASSERT( pIrpStreamControl );
	IRPSTREAM_POSITION irpStreamPosition;
    Status = pIrpStreamControl->GetPosition(&irpStreamPosition);
    if (NT_SUCCESS(Status))
    {
        PhysicalTime =
            pIrpStreamControl->NormalizePosition
            (   irpStreamPosition.ullStreamPosition 
            +   irpStreamPosition.ullPhysicalOffset
            );
    }

    KeAcquireSpinLock( &pCWaveClock->m_ClockLock, &irqlOld );

    if (NT_SUCCESS( Status )) {
        //
        // Verify that this new physical time is >= to the last
        // reported physical time.  If not, set the time to the 
        // last reported time.  Flag this as an error in debug.
        //
        if (PhysicalTime < pCWaveClock->m_LastPhysicalTime) {
            _DbgPrintF( 
                DEBUGLVL_VERBOSE, 
                ("new physical time is less than last reported physical time! (%I64d, %I64d)",
                PhysicalTime, pCWaveClock->m_LastPhysicalTime) );
            PhysicalTime = pCWaveClock->m_LastPhysicalTime;
        } else {
            //
            // Set m_LastPhysicalTime to the updated time.
            //
            pCWaveClock->m_LastPhysicalTime = PhysicalTime;
        }
    } else {
        PhysicalTime = pCWaveClock->m_LastPhysicalTime;
    }
    
    KeReleaseSpinLock( &pCWaveClock->m_ClockLock, irqlOld );
    
    return PhysicalTime;
}

LONGLONG
FASTCALL
CWaveClock::GetCurrentCorrelatedPhysicalTime(
    PFILE_OBJECT FileObject,
    PLONGLONG SystemTime
    )

/*++

Routine Description:
    Retrieves the current physical time correlated with the system time.

Arguments:
    PFILE_OBJECT FileObject -
        this clock's file object

    PLONGLONG SystemTime -
        pointer to the resultant system time

Return:
    current physical time in 100ns

--*/

{

    LARGE_INTEGER Time, Frequency;
    
    Time = KeQueryPerformanceCounter( &Frequency );
    
    //
    //  Convert ticks to 100ns units.
    //
    *SystemTime = KSCONVERT_PERFORMANCE_TIME(Frequency.QuadPart,Time);
    return GetCurrentTime( FileObject );
}    



#pragma code_seg("PAGE")

NTSTATUS
CWaveClock::GetFunctionTable(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PKSCLOCK_FUNCTIONTABLE FunctionTable
    )

/*++

Routine Description:
    Retrieves the DPC interface function table for this clock.

Arguments:
    IN PIRP Irp -
        pointer to the I/O request packet

    IN PKSPROPERTY Property -
        pointer to the property structure

    OUT PKSCLOCK_FUNCTIONTABLE FunctionTable -
        pointer to the resultant function table

Return:

--*/

{
    PAGED_CODE();
    FunctionTable->GetTime = GetCurrentTime;
    FunctionTable->GetPhysicalTime = GetCurrentPhysicalTime;
    FunctionTable->GetCorrelatedTime = GetCurrentCorrelatedTime;
    FunctionTable->GetCorrelatedPhysicalTime = GetCurrentCorrelatedPhysicalTime;
    Irp->IoStatus.Information = sizeof(*FunctionTable);
    return STATUS_SUCCESS;
}

NTSTATUS
CWaveClock::GetCorrelatedTime(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PKSCORRELATED_TIME CorrelatedTime
    )

/*++

Routine Description:
    Retrieves the current presentation time correlated with the system time.

Arguments:
    IN PIRP Irp -
        pointer to the I/O request packet

    IN PKSPROPERTY Property -
        pointer to the property structure

    OUT PKSCORRELATED_TIME CorrelatedTime -
        resultant correlated presentation time

Return:
    STATUS_SUCCESS else an appropriate error code

--*/

{
    PAGED_CODE();
    
    CWaveClock *pCWaveClock =
        (CWaveClock *) KsoGetIrpTargetFromIrp(Irp);

    CorrelatedTime->Time = 
        pCWaveClock->GetCurrentCorrelatedTime( 
            IoGetCurrentIrpStackLocation( Irp )->FileObject, 
            &CorrelatedTime->SystemTime );
    Irp->IoStatus.Information = sizeof( KSCORRELATED_TIME );
    return STATUS_SUCCESS;
}    

NTSTATUS
CWaveClock::GetTime(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PLONGLONG Time
    )

/*++

Routine Description:
    Retrieves the current presentation time.

Arguments:
    IN PIRP Irp -
        pointer to the I/O request packet

    IN PKSPROPERTY Property -
        pointer to the property structure

    OUT PLONGLONG Time -
        resultant presentation time

Return:
    STATUS_SUCCESS else an appropriate error code

--*/

{
    PAGED_CODE();
    
    CWaveClock *pCWaveClock =
        (CWaveClock *) KsoGetIrpTargetFromIrp(Irp);

    *Time = pCWaveClock->GetCurrentTime( 
        IoGetCurrentIrpStackLocation( Irp )->FileObject );
    Irp->IoStatus.Information = sizeof( LONGLONG );
     
    return STATUS_SUCCESS;
}

NTSTATUS
CWaveClock::GetCorrelatedPhysicalTime(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PKSCORRELATED_TIME CorrelatedTime
    )

/*++

Routine Description:
    Retrieves the current physical time correlated with the system time.

Arguments:
    IN PIRP Irp -
        pointer to the I/O request packet

    IN PKSPROPERTY Property -
        pointer to the property structure

    OUT PKSCORRELATED_TIME CorrelatedTime -
        resultant correlated physical time

Return:
    STATUS_SUCCESS else an appropriate error code

--*/

{
    PAGED_CODE();
    
    CWaveClock *pCWaveClock =
        (CWaveClock *) KsoGetIrpTargetFromIrp(Irp);
    
    CorrelatedTime->Time =
        pCWaveClock->GetCurrentCorrelatedPhysicalTime( 
            IoGetCurrentIrpStackLocation( Irp )->FileObject,
            &CorrelatedTime->SystemTime );
    
    Irp->IoStatus.Information = sizeof( KSCORRELATED_TIME );
    return STATUS_SUCCESS;
}

NTSTATUS
CWaveClock::GetPhysicalTime(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PLONGLONG Time
    )

/*++

Routine Description:
    Returns the clock's physical time.  This is the actual clock physical time 
    which is not halted for starvation, etc.

Arguments:
    IN PIRP Irp -
        pointer to the I/O request packet

    IN PKSPROPERTY Property -
        pointer to the property structure

    OUT PLONGLONG Time -
        resultant time in 100 ns units

Return:
    STATUS_SUCCESS or an appropriate error code

--*/

{
    PAGED_CODE();
    
    CWaveClock *pCWaveClock =
        (CWaveClock *) KsoGetIrpTargetFromIrp(Irp);

    *Time = 
        pCWaveClock->GetCurrentPhysicalTime( 
            IoGetCurrentIrpStackLocation( Irp )->FileObject );
    Irp->IoStatus.Information = sizeof( LONGLONG );
    return STATUS_SUCCESS;
}

NTSTATUS
CWaveClock::GetResolution(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PKSRESOLUTION Resolution
    )
/*++

Routine Description:
    Retrieves the resolution of this clock.

Arguments:
    IN PIRP Irp -
        pointer to the I/O request packet

    IN PKSPROPERTY Property -
        pointer to the property structure
        
    OUT PKSRESOLUTIONM Resolution -
        pointer to the resultant resolution structure which stores the
        granularity and error in 100ns units.
        
Return Value:
    STATUS_SUCCESS

--*/
{
#define WAVECYC_NOTIFICATION_FREQUENCY 10

    PAGED_CODE();
    
    CWaveClock *pCWaveClock =
        (CWaveClock *) KsoGetIrpTargetFromIrp(Irp);
    
    //
    // This clock has a resolution dependant on the data format.  Assume
    // that for cyclic devices, a byte position is computed for the DMA
    // controller and convert this to 100ns units.  The error (event 
    // notification error) is +/- NotificationFrequency/2
      
    Resolution->Granularity = 
        pCWaveClock->m_pIrpStreamControl->NormalizePosition(1);
    
    Resolution->Error = 
        (_100NS_UNITS_PER_SECOND / 1000 * WAVECYC_NOTIFICATION_FREQUENCY) / 2;
        
    Irp->IoStatus.Information = sizeof(*Resolution);

    return STATUS_SUCCESS;
}

NTSTATUS
CWaveClock::GetState(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PKSSTATE State
    )

/*++

Routine Description:
    Returns the underlying pin's state.

Arguments:
    IN PIRP Irp -
        pointer to the I/O request packet

    IN PKSPROPERTY Property -
        pointer to the property structure

    OUT PKSSTATE State -
        pointer to resultant KSSTATE

Return:
    STATUS_SUCCESS

--*/

{
    PAGED_CODE();
    
    CWaveClock *pCWaveClock =
        (CWaveClock *) KsoGetIrpTargetFromIrp(Irp);

    //
    // Synchronize with SetState,
    //        
    KeWaitForMutexObject(
        &pCWaveClock->m_StateMutex,
        Executive,
        KernelMode,
        FALSE,
        NULL );
    //
    // retrieve the state
    //        
    *State = pCWaveClock->m_DeviceState;
    //
    // and then release the mutex
    //
    KeReleaseMutex( &pCWaveClock->m_StateMutex, FALSE );
    
    Irp->IoStatus.Information = sizeof(*State);
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\main\sync.cpp ===
/*****************************************************************************
 * sync.cpp - synchronization
 *****************************************************************************
 * Copyright (c) 1997-2000 Microsoft Corporation.  All rights reserved.
 */

#include "private.h"


/*****************************************************************************
 * IInterruptSyncInit
 *****************************************************************************
 * Interface for interrupt synchronizer with Init.
 */
DECLARE_INTERFACE_(IInterruptSyncInit,IInterruptSync)
{
    DEFINE_ABSTRACT_UNKNOWN()   // For IUnknown

    // For IInterruptSync
    STDMETHOD_(NTSTATUS,CallSynchronizedRoutine)
    (   THIS_
        IN      PINTERRUPTSYNCROUTINE   Routine,
        IN      PVOID                   DynamicContext
    )   PURE;
    STDMETHOD_(PKINTERRUPT,GetKInterrupt)
    (   THIS
    )   PURE;
    STDMETHOD_(NTSTATUS,Connect)
    (   THIS
    )   PURE;
    STDMETHOD_(void,Disconnect)
    (   THIS
    )   PURE;
    STDMETHOD_(NTSTATUS,RegisterServiceRoutine)
    (   THIS_
        IN      PINTERRUPTSYNCROUTINE   Routine,
        IN      PVOID                   DynamicContext,
        IN      BOOLEAN                 First
    )   PURE;

    // For IInterruptSyncInit
    STDMETHOD_(NTSTATUS,Init)
    (   THIS_
        IN      PRESOURCELIST           ResourceList,
        IN      ULONG                   ResourceIndex,
        IN      INTERRUPTSYNCMODE       Mode
    )   PURE;
};

typedef IInterruptSyncInit *PINTERRUPTSYNCINIT;

/*****************************************************************************
 * CInterruptSync
 *****************************************************************************
 * Interrupt synchronizer implementation.
 */
class CInterruptSync
:   public IInterruptSyncInit,
    public CUnknown
{
private:
    CM_PARTIAL_RESOURCE_DESCRIPTOR  m_descriptor;
    INTERRUPTSYNCMODE               m_mode;
    PKINTERRUPT                     m_pKInterrupt;
    LIST_ENTRY                      m_listEntry;
    KSPIN_LOCK                      m_kSpinLock;
    KIRQL                           m_kIrql;

public:
    DECLARE_STD_UNKNOWN();
    CInterruptSync(PUNKNOWN pUnknownOuter);
    ~CInterruptSync();

    STDMETHODIMP_(NTSTATUS) Init
    (
        IN      PRESOURCELIST           ResourceList,
        IN      ULONG                   ResourceIndex,
        IN      INTERRUPTSYNCMODE       Mode
    );

    IMP_IInterruptSync;
    
    friend
    BOOLEAN
    CInterruptSyncServiceRoutine
    (
        IN      PKINTERRUPT Interrupt,
        IN      PVOID       PVoidContext
    );
    friend
    BOOLEAN
    CInterruptSyncWrapperRoutine
    (
        IN      PVOID   PVoidContext
    );
};

/*****************************************************************************
 * ISRLISTENTRY
 *****************************************************************************
 * Entry in the list of ISRs.
 */
typedef struct
{
    LIST_ENTRY              ListEntry;
    PINTERRUPTSYNCROUTINE   Routine;
    PVOID                   DynamicContext;
} 
ISRLISTENTRY, *PISRLISTENTRY;

/*****************************************************************************
 * WRAPPERROUTINECONTEXT
 *****************************************************************************
 * Context for synchronized routine wrapper function.
 */
typedef struct
{
    PINTERRUPTSYNCROUTINE   Routine;
    PVOID                   DynamicContext;
    CInterruptSync *        InterruptSync;
    NTSTATUS                NtStatus;
} 
WRAPPERROUTINECONTEXT, *PWRAPPERROUTINECONTEXT;





/*****************************************************************************
 * Factory
 */

#pragma code_seg("PAGE")

/*****************************************************************************
 * CreateInterruptSync()
 *****************************************************************************
 * Creates an interrupt synchronization object.
 */
NTSTATUS
CreateInterruptSync
(
    OUT     PUNKNOWN *  Unknown,
    IN      REFCLSID,
    IN      PUNKNOWN    UnknownOuter    OPTIONAL,
    IN      POOL_TYPE   PoolType
)
{
    PAGED_CODE();

    ASSERT(Unknown);

    _DbgPrintF(DEBUGLVL_LIFETIME,("Creating INTERRUPTSYNC"));

    STD_CREATE_BODY_
    (
        CInterruptSync,
        Unknown,
        UnknownOuter,
        PoolType,
        PINTERRUPTSYNC
    );
}

/*****************************************************************************
 * PcNewInterruptSync()
 *****************************************************************************
 * Creates and initializes an interrupt-level synchronization object.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcNewInterruptSync
(
    OUT     PINTERRUPTSYNC *        OutInterruptSync,
    IN      PUNKNOWN                OuterUnknown            OPTIONAL,
    IN      PRESOURCELIST           ResourceList,
    IN      ULONG                   ResourceIndex,
    IN      INTERRUPTSYNCMODE       Mode
)
{
    PAGED_CODE();

    ASSERT(OutInterruptSync);
    ASSERT(ResourceList);

    //
    // Invalidate Parameters.
    //
    if (NULL == OutInterruptSync ||
        NULL == ResourceList)
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("PcInterruptSync : Invalid Parameter"));
        return STATUS_INVALID_PARAMETER;
    }

    PUNKNOWN    unknown;
    NTSTATUS    ntStatus = CreateInterruptSync( &unknown,
                                                GUID_NULL,
                                                OuterUnknown,
                                                NonPagedPool );

    if (NT_SUCCESS(ntStatus))
    {
        PINTERRUPTSYNCINIT interruptSync;
        ntStatus = unknown->QueryInterface( IID_IInterruptSync,
                                            (PVOID *) &interruptSync );

        if (NT_SUCCESS(ntStatus))
        {
            ntStatus = interruptSync->Init( ResourceList,
                                            ResourceIndex,
                                            Mode );

            if(NT_SUCCESS(ntStatus))
            {
                *OutInterruptSync = interruptSync;
            }
            else
            {
                interruptSync->Release();
            }
        }

        unknown->Release();
    }

    return ntStatus;
}





#pragma code_seg("PAGE")

/*****************************************************************************
 * CInterruptSync member functions
 */

/*****************************************************************************
 * CInterruptSync::CInterruptSync()
 *****************************************************************************
 * Constructor.
 */
CInterruptSync::
CInterruptSync
(   IN      PUNKNOWN    pUnknownOuter
)
:   CUnknown(pUnknownOuter)
{
    PAGED_CODE();

    KeInitializeSpinLock(&m_kSpinLock);
    InitializeListHead(&m_listEntry);
}

#pragma code_seg()

/*****************************************************************************
 * CInterruptSync::~CInterruptSync()
 *****************************************************************************
 * Destructor.
 */
CInterruptSync::~CInterruptSync()
{
    _DbgPrintF(DEBUGLVL_LIFETIME,("Destroying INTERRUPTSYNC (0x%08x)",this));

    //
    // Make sure we're disconnected.
    //
    Disconnect();

    //
    // Delete the list of ISRs.
    //
    if (! IsListEmpty(&m_listEntry))
    {
        KIRQL kIrqlOld;
        KeAcquireSpinLock(&m_kSpinLock,&kIrqlOld);

        //
        // Get rid of any remaining members.
        //
        while (! IsListEmpty(&m_listEntry))
        {
            PLIST_ENTRY pListEntry = RemoveHeadList(&m_listEntry);

            delete PISRLISTENTRY(pListEntry);
        }

        KeReleaseSpinLock(&m_kSpinLock,kIrqlOld);
    }
}

#pragma code_seg("PAGE")

/*****************************************************************************
 * CDmaChannel::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.
 */
STDMETHODIMP_(NTSTATUS)
CInterruptSync::
NonDelegatingQueryInterface
(
    REFIID  Interface,
    PVOID * Object
)
{
    PAGED_CODE();

    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface,IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(this));
    }
    else if (IsEqualGUIDAligned(Interface,IID_IInterruptSync))
    {
        *Object = PVOID(PINTERRUPTSYNCINIT(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

/*****************************************************************************
 * CInterruptSync::Init()
 *****************************************************************************
 * Initializes the synchronization object.
 */
STDMETHODIMP_(NTSTATUS)
CInterruptSync::
Init
(
    IN      PRESOURCELIST           ResourceList,
    IN      ULONG                   ResourceIndex,
    IN      INTERRUPTSYNCMODE       Mode
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_LIFETIME,("Initializing INTERRUPTSYNC (0x%08x)",this));

    ASSERT(ResourceList);

    m_mode = Mode;

    PCM_PARTIAL_RESOURCE_DESCRIPTOR pDescriptor = ResourceList->FindTranslatedInterrupt(ResourceIndex);

    NTSTATUS ntStatus = ( pDescriptor ? STATUS_SUCCESS : STATUS_INSUFFICIENT_RESOURCES );

    if (NT_SUCCESS(ntStatus)) 
    {
        m_descriptor    = *pDescriptor;
        m_pKInterrupt   = NULL;

        m_kIrql = KIRQL(m_descriptor.u.Interrupt.Level);
    } 

    return ntStatus;
}

#pragma code_seg()

/*****************************************************************************
 * CInterruptSyncServiceRoutine()
 *****************************************************************************
 * Wrapper for service routine.
 */
static
BOOLEAN
CInterruptSyncServiceRoutine
(
    IN      PKINTERRUPT Interrupt,
    IN      PVOID       PVoidContext
)
{
    CInterruptSync *pCInterruptSync = (CInterruptSync *)(PVoidContext);

    BOOLEAN bResult = FALSE;

    //
    // Call ISRs as indicated by mode.
    //
    while (1)
    {
        BOOLEAN bResultThisPass = FALSE;

        for
        (   PLIST_ENTRY pListEntry = pCInterruptSync->m_listEntry.Flink;
            pListEntry != &pCInterruptSync->m_listEntry;
            pListEntry = pListEntry->Flink
        )
        {
            PISRLISTENTRY pIsrListEntry = PISRLISTENTRY(pListEntry);

            ASSERT(pIsrListEntry->Routine);

            if( NT_SUCCESS( pIsrListEntry->Routine( PINTERRUPTSYNC(pCInterruptSync),
                                                    pIsrListEntry->DynamicContext ) ) )
            {
                bResult         = TRUE;
                bResultThisPass = TRUE;

                if (pCInterruptSync->m_mode == InterruptSyncModeNormal)
                {
                    break;
                }
            }
        }

        if( (pCInterruptSync->m_mode != InterruptSyncModeRepeat) ||
            (! bResultThisPass) )
        {
            break;
        }
    }

    return bResult;
}

/*****************************************************************************
 * CInterruptSync::Connect()
 *****************************************************************************
 * Initializes the synchronization object.
 */
STDMETHODIMP_(NTSTATUS)
CInterruptSync::
Connect
(   void
)
{
    _DbgPrintF(DEBUGLVL_BLAB,("CInterruptSync::Connect"));

    NTSTATUS ntStatus = STATUS_SUCCESS;

    //
    // Don't even think about connecting if we don't have any
    // ISR's in our list
    //
    KIRQL oldIrql;
    KeAcquireSpinLock( &m_kSpinLock, &oldIrql );
    if( IsListEmpty( &m_listEntry ) )
    {
        ntStatus = STATUS_UNSUCCESSFUL;
    }
    KeReleaseSpinLock( &m_kSpinLock, oldIrql );

    //
    // Connect if not already connected
    //
    if ( (NT_SUCCESS(ntStatus)) && (!m_pKInterrupt) )
    {
        ntStatus = IoConnectInterrupt( &m_pKInterrupt,
                                       CInterruptSyncServiceRoutine,
                                       PVOID(this),
                                       &m_kSpinLock,       // TODO:  Spin lock sharing?
                                       m_descriptor.u.Interrupt.Vector,
                                       m_kIrql,
                                       m_kIrql,            // TODO:  Different for >1 interrupt?
                                       ((m_descriptor.Flags & CM_RESOURCE_INTERRUPT_LATCHED) ? 
                                         Latched : LevelSensitive),
                                       (m_descriptor.ShareDisposition != CmResourceShareDeviceExclusive), 
                                       m_descriptor.u.Interrupt.Affinity,
                                       FALSE );
        if(NT_SUCCESS(ntStatus))
        {
            ASSERT(m_pKInterrupt);
        }
    } 

    return ntStatus;
}

#pragma code_seg("PAGE")

/*****************************************************************************
 * CInterruptSync::Disconnect()
 *****************************************************************************
 * Disconnect from the interrupt.
 */
STDMETHODIMP_(void)
CInterruptSync::
Disconnect
(   void
)
{
    _DbgPrintF(DEBUGLVL_BLAB,("CInterruptSync::Disconnect"));

    PAGED_CODE();

    if (m_pKInterrupt) 
    {
        IoDisconnectInterrupt(m_pKInterrupt);
        m_pKInterrupt = NULL;
    }   
}

#pragma code_seg()

/*****************************************************************************
 * CServiceGroup::RegisterServiceRoutine()
 *****************************************************************************
 * Add a service routine.
 */
STDMETHODIMP_(NTSTATUS)
CInterruptSync::
RegisterServiceRoutine
(   
    IN      PINTERRUPTSYNCROUTINE   Routine,
    IN      PVOID                   DynamicContext,
    IN      BOOLEAN                 First
)
{
    _DbgPrintF(DEBUGLVL_BLAB,("CInterruptSync::RegisterServiceRoutine"));

    ASSERT(Routine);

    NTSTATUS ntStatus = STATUS_SUCCESS;

    //
    // ensure we really have a routine
    //
    if( !Routine )
    {
        ntStatus = STATUS_INVALID_PARAMETER;
    }

    if( NT_SUCCESS(ntStatus) )
    {
        //
        // Create a new member.
        //
        PISRLISTENTRY pIsrListEntry = new(NonPagedPool,'lIcP') ISRLISTENTRY;
    
        if (pIsrListEntry)
        {
            pIsrListEntry->Routine          = Routine;
            pIsrListEntry->DynamicContext   = DynamicContext;
    
            //
            // Add the member to the list.
            //
            KIRQL kIrqlOld;
            KeAcquireSpinLock(&m_kSpinLock,&kIrqlOld);
    
            if (First)
            {
                InsertHeadList( &m_listEntry, &pIsrListEntry->ListEntry );
            }
            else
            {
                InsertTailList( &m_listEntry, &pIsrListEntry->ListEntry );
            }
    
            KeReleaseSpinLock(&m_kSpinLock,kIrqlOld);
        }
        else
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    return ntStatus;
}

/*****************************************************************************
 * CInterruptSyncWrapperRoutine()
 *****************************************************************************
 * Wrapper for synchronized routines.
 */
static
BOOLEAN
CInterruptSyncWrapperRoutine
(
    IN      PVOID   PVoidContext
)
{
    PWRAPPERROUTINECONTEXT pContext = PWRAPPERROUTINECONTEXT(PVoidContext);

    pContext->NtStatus = pContext->Routine( PINTERRUPTSYNC(pContext->InterruptSync),
                                             pContext->DynamicContext);
    return TRUE;
}

/*****************************************************************************
 * CInterruptSync::CallSynchronizedRoutine()
 *****************************************************************************
 * Call a synchronized routine.
 */
STDMETHODIMP_(NTSTATUS)
CInterruptSync::
CallSynchronizedRoutine
(
    IN      PINTERRUPTSYNCROUTINE   Routine,
    IN      PVOID                   DynamicContext
)
{
    WRAPPERROUTINECONTEXT context;

    context.Routine        = Routine;
    context.DynamicContext = DynamicContext;
    context.InterruptSync  = this;
    context.NtStatus       = STATUS_SUCCESS;

    if (m_pKInterrupt)
    {
        if (!KeSynchronizeExecution(m_pKInterrupt,CInterruptSyncWrapperRoutine,&context ) )
        {
            context.NtStatus = STATUS_UNSUCCESSFUL;
        }
    }
    else if (KeGetCurrentIrql() <= DISPATCH_LEVEL)
    {
        _DbgPrintF(DEBUGLVL_TERSE,("Interrupt not connected yet, using spinlock"));

        KIRQL kIrqlOld;
        KeAcquireSpinLock(&m_kSpinLock,&kIrqlOld);

        //  we have no interrupt yet, so synchronize the best you can
        (void)CInterruptSyncWrapperRoutine(&context);

        KeReleaseSpinLock(&m_kSpinLock,kIrqlOld);
    }
    else
    {
        context.NtStatus = STATUS_UNSUCCESSFUL;
        _DbgPrintF(DEBUGLVL_TERSE,("Interrupt not connected yet, but IRQL > DISPATCH_LEVEL"));
    }

    return context.NtStatus;
}

/*****************************************************************************
 * CInterruptSync::GetKInterrupt()
 *****************************************************************************
 * Get a WDM InterruptObject from a portcls sync object.
 */
STDMETHODIMP_(PKINTERRUPT)
CInterruptSync::
GetKInterrupt
(   void
)
{
    return m_pKInterrupt;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\main\service.cpp ===
/*****************************************************************************
 * service.cpp - service group object implementation
 *****************************************************************************
 * Copyright (c) 1997-2000 Microsoft Corporation.  All Rights Reserved.
 */

#include "private.h"





/*****************************************************************************
 * CServiceGroup
 *****************************************************************************
 * Service group implementation.
 */
class CServiceGroup
:   public IServiceGroup
,   public CUnknown
{
private:
    KDPC        m_kDpc;
    KSPIN_LOCK  m_kSpinLock;
    LIST_ENTRY  m_listEntry;
    KTIMER      m_kTimer;
    BOOLEAN     m_bDelayedService;

    static
    VOID
    NTAPI
    ServiceDpc
    (   
        IN      PKDPC   pKDpc,
        IN      PVOID   pvDeferredContext,
        IN      PVOID   pvSystemArgument1,
        IN      PVOID   pvSystemArgument2
    );

public:
    DECLARE_STD_UNKNOWN();
    CServiceGroup(PUNKNOWN pUnknownOuter);
    ~CServiceGroup();

    IMP_IServiceGroup;

friend
PKSPIN_LOCK
GetServiceGroupSpinLock (
    PSERVICEGROUP pServiceGroup
    );

};


PKSPIN_LOCK
GetServiceGroupSpinLock (
    PSERVICEGROUP pServiceGroup
    )

{

    CServiceGroup *ServiceGroup = (CServiceGroup *) pServiceGroup;

    return &ServiceGroup->m_kSpinLock;

}


/*****************************************************************************
 * SERVICEGROUPMEMBER
 *****************************************************************************
 * A structure representing a service group member.
 */
struct SERVICEGROUPMEMBER
{
    LIST_ENTRY      listEntry;
    PSERVICESINK    pServiceSink;
};

typedef SERVICEGROUPMEMBER *PSERVICEGROUPMEMBER;


/*****************************************************************************
 * Factory.
 */

#pragma code_seg("PAGE")

/*****************************************************************************
 * CreateServiceGroup()
 *****************************************************************************
 * Creates a service group object.
 */
NTSTATUS
CreateServiceGroup
(
    OUT     PUNKNOWN *  ppUnknown,
    IN      REFCLSID,
    IN      PUNKNOWN    pUnknownOuter   OPTIONAL,
    IN      POOL_TYPE   poolType
)
{
    PAGED_CODE();

    ASSERT(ppUnknown);

    _DbgPrintF(DEBUGLVL_LIFETIME,("Creating SERVICEGROUP"));

    STD_CREATE_BODY
    (
        CServiceGroup,
        ppUnknown,
        pUnknownOuter,
        poolType
    );
}

/*****************************************************************************
 * PcNewServiceGroup()
 *****************************************************************************
 * Creates and initializes a service group.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcNewServiceGroup
(
    OUT     PSERVICEGROUP * ppServiceGroup,
    IN      PUNKNOWN        pUnknownOuter   OPTIONAL
)
{
    PAGED_CODE();

    ASSERT(ppServiceGroup);

    //
    // Validate Parameters.
    //
    if (NULL == ppServiceGroup)
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("PcNewServiceGroup : Invalid Parameter"));
        return STATUS_INVALID_PARAMETER;
    }

    PUNKNOWN pUnknown;
    NTSTATUS    ntStatus =
        CreateServiceGroup
        (
            &pUnknown,
            GUID_NULL,
            pUnknownOuter,
            NonPagedPool
        );

    if (NT_SUCCESS(ntStatus))
    {
        PSERVICEGROUP pServiceGroup;
        ntStatus =
            pUnknown->QueryInterface
            (
                IID_IServiceGroup,
                (PVOID *) &pServiceGroup
            );

        if (NT_SUCCESS(ntStatus))
        {
            *ppServiceGroup = pServiceGroup;
        }
        else
        {
            pServiceGroup->Release();
        }

        pUnknown->Release();
    }

    return ntStatus;
}





/*****************************************************************************
 * Member functions.
 */

/*****************************************************************************
 * CServiceGroup::CServiceGroup()
 *****************************************************************************
 * Constructor.
 */
CServiceGroup::
CServiceGroup
(
    IN      PUNKNOWN    pUnknownOuter
)
    :   CUnknown(pUnknownOuter)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_LIFETIME,("Initializing SERVICEGROUP (0x%08x)",this));

    KeInitializeDpc(&m_kDpc,ServiceDpc,PVOID(this));
    KeInitializeSpinLock(&m_kSpinLock);
    InitializeListHead(&m_listEntry);
}

#pragma code_seg()

/*****************************************************************************
 * CServiceGroup::~CServiceGroup()
 *****************************************************************************
 * Destructor.
 */
CServiceGroup::
~CServiceGroup
(   void
)
{
    _DbgPrintF(DEBUGLVL_LIFETIME,("Destroying SERVICEGROUP (0x%08x)",this));

    //
    // Make sure that the timer is shut down if using deferred service
    //
    if( m_bDelayedService )
    {
        KeCancelTimer( &m_kTimer );
    }

    //
    // Make sure the DPC is not queued.
    //
    KeRemoveQueueDpc(&m_kDpc);

    //
    // Acquire the spin lock in order to wait for a running DPC to wind down.
    // TODO:  Is there a window here where we can have a DPC running on
    //        another processor about to take the spinlock, but we get it
    //        first?  That would mean it would wait for us to release the
    //        spinlock and then run as we destruct the service group.
    //
    KIRQL kIrqlOld;
    KeAcquireSpinLock(&m_kSpinLock,&kIrqlOld);

    //
    // Get rid of any remaining members.
    //
    while (! IsListEmpty(&m_listEntry))
    {
        PLIST_ENTRY pListEntry =
            RemoveHeadList(&m_listEntry);

        PSERVICEGROUPMEMBER pServiceGroupMember =
            PSERVICEGROUPMEMBER(pListEntry);

        pServiceGroupMember->pServiceSink->Release();
        delete pServiceGroupMember;
    }

    KeReleaseSpinLock(&m_kSpinLock,kIrqlOld);
}

#pragma code_seg("PAGE")

/*****************************************************************************
 * CServiceGroup::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.
 */
STDMETHODIMP_(NTSTATUS)
CServiceGroup::
NonDelegatingQueryInterface
(
    IN      REFIID  refIid,
    OUT     PVOID * ppvObject
)
{
    PAGED_CODE();

    ASSERT(ppvObject);

    if
    (   (IsEqualGUIDAligned(refIid,IID_IUnknown)) ||
        (IsEqualGUIDAligned(refIid,IID_IServiceSink)) ||
        (IsEqualGUIDAligned(refIid,IID_IServiceGroup)) )
    {
        *ppvObject = PVOID(PSERVICEGROUP(this));
    }
    else
    {
        *ppvObject = NULL;
    }

    if (*ppvObject)
    {
        PUNKNOWN(*ppvObject)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

#pragma code_seg()

/***************************************************************************** 
 * ServiceDpc()
 *****************************************************************************
 * Deferred procedure to be executed as a result of service request.
 */
VOID
NTAPI
CServiceGroup::
ServiceDpc
(   
    IN      PKDPC   pKDpc,
    IN      PVOID   pvDeferredContext,
    IN      PVOID   pvSystemArgument1,
    IN      PVOID   pvSystemArgument2
)
{
    _DbgPrintF(DEBUGLVL_BLAB,("CServiceGroup::ServiceDpc start"));

    ASSERT(pvDeferredContext);
    
    if( pvDeferredContext )
    {
        //
        // The deferred context is the service group object.
        //
        CServiceGroup *pServiceGroup = (CServiceGroup *) pvDeferredContext;
    
        KeAcquireSpinLockAtDpcLevel(&pServiceGroup->m_kSpinLock);
    
        //
        // Request service on all members.
        //
        for
        (   PLIST_ENTRY pListEntry = pServiceGroup->m_listEntry.Flink;
            pListEntry != &pServiceGroup->m_listEntry;
            pListEntry = pListEntry->Flink )
        {
            PSERVICEGROUPMEMBER(pListEntry)->pServiceSink->RequestService();
        }
    
        KeReleaseSpinLockFromDpcLevel(&pServiceGroup->m_kSpinLock);
    }

    _DbgPrintF(DEBUGLVL_BLAB,("CServiceGroup::ServiceDpc stop"));
}

/*****************************************************************************
 * CServiceGroup::RequestService()
 *****************************************************************************
 * Service group function to indicate that service is requested for the group.
 */
STDMETHODIMP_(void)
CServiceGroup::
RequestService
(   void
)
{
    _DbgPrintF(DEBUGLVL_BLAB,("CServiceGroup::RequestService start"));

    if (m_bDelayedService)
    {
        LARGE_INTEGER largeInteger;
        largeInteger.QuadPart = 0;
        KeSetTimer(&m_kTimer,largeInteger,&m_kDpc);
    }
    else
    if (KeGetCurrentIrql() < DISPATCH_LEVEL)
        {
        KIRQL kIrqlOld;
        KeRaiseIrql(DISPATCH_LEVEL,&kIrqlOld);
        KeInsertQueueDpc
        (   
            &m_kDpc,
            NULL,
            NULL
        );
        KeLowerIrql(kIrqlOld);
        }
    else
    {
        KeInsertQueueDpc
        (   
            &m_kDpc,
            NULL,
            NULL
        );
    }

    _DbgPrintF(DEBUGLVL_BLAB,("CServiceGroup::RequestService end"));
}

/*****************************************************************************
 * CServiceGroup::AddMember()
 *****************************************************************************
 * Service group function to add a member.
 */
STDMETHODIMP_(NTSTATUS)
CServiceGroup::
AddMember
(
    IN      PSERVICESINK    pServiceSink
)
{
    //
    // Create a new member.
    //
    PSERVICEGROUPMEMBER pServiceGroupMember = 
        new(NonPagedPool,'mScP') SERVICEGROUPMEMBER;

    NTSTATUS ntStatus = STATUS_SUCCESS;
    if (pServiceGroupMember)
    {
        //
        // Member structure holds a reference to the sink.
        //
        pServiceGroupMember->pServiceSink = pServiceSink;
        pServiceSink->AddRef();

    //
        // Add the member to the list.
    //
        KIRQL kIrqlOld;
        KeAcquireSpinLock(&m_kSpinLock,&kIrqlOld);
        
        InsertTailList
        (   
            &m_listEntry,
            &pServiceGroupMember->listEntry
        );

        KeReleaseSpinLock(&m_kSpinLock,kIrqlOld);
    }
    else
        {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
            }

/*****************************************************************************
 * CServiceGroup::RemoveMember()
 *****************************************************************************
 * Service group function to remove a member.
 */
STDMETHODIMP_(void)
CServiceGroup::
RemoveMember
(   
    IN      PSERVICESINK    pServiceSink
)
{
            //
    // Remove the member structure from the list.
            //
    KIRQL kIrqlOld;
    KeAcquireSpinLock(&m_kSpinLock,&kIrqlOld);

    for( PLIST_ENTRY pListEntry = m_listEntry.Flink;
         pListEntry != &m_listEntry;
         pListEntry = pListEntry->Flink )
            {
        PSERVICEGROUPMEMBER pServiceGroupMember =
            PSERVICEGROUPMEMBER(pListEntry);

        if (pServiceGroupMember->pServiceSink == pServiceSink)
        {
            RemoveEntryList(pListEntry);
            pServiceGroupMember->pServiceSink->Release();
            delete pServiceGroupMember;
            break;
        }
    }

    KeReleaseSpinLock(&m_kSpinLock,kIrqlOld);
}

/*****************************************************************************
 * CServiceGroup::SupportDelayedService()
 *****************************************************************************
 * Indicate service group should support delayed service.
 */
STDMETHODIMP_(void)
CServiceGroup::
SupportDelayedService
(   void
)
{
    m_bDelayedService = TRUE;
    KeInitializeTimer(&m_kTimer);
}

/*****************************************************************************
 * CServiceGroup::RequestDelayedService()
 *****************************************************************************
 * Request service after a delay.
 */
STDMETHODIMP_(void)
CServiceGroup::
RequestDelayedService
(   
    IN      ULONGLONG   ullDelay
)
{
    LARGE_INTEGER largeInteger;
    largeInteger.QuadPart = ullDelay;
    KeSetTimer(&m_kTimer,largeInteger,&m_kDpc);
}

/*****************************************************************************
 * CServiceGroup::CancelDelayedService()
 *****************************************************************************
 * Cancel delayed service.
 */
STDMETHODIMP_(void)
CServiceGroup::
CancelDelayedService
(   void
)
{
    KeCancelTimer(&m_kTimer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\main\resource.cpp ===
/*****************************************************************************
 * resource.cpp - resource list object implementation
 *****************************************************************************
 * Copyright (c) 1997-2000 Microsoft Corporation.  All rights reserved.
 */

#include "private.h"





/*****************************************************************************
 * Factory.
 */

#pragma code_seg("PAGE")

/*****************************************************************************
 * CreateResourceList()
 *****************************************************************************
 * Creates a resource list object.
 */
NTSTATUS
CreateResourceList
(
    OUT     PUNKNOWN *  Unknown,
    IN      REFCLSID,
    IN      PUNKNOWN    UnknownOuter    OPTIONAL,
    IN      POOL_TYPE   PoolType
)
{
    PAGED_CODE();

    ASSERT(Unknown);

    _DbgPrintF(DEBUGLVL_LIFETIME,("Creating RESOURCELIST"));

    STD_CREATE_BODY
    (
        CResourceList,
        Unknown,
        UnknownOuter,
        PoolType
    );
}

/*****************************************************************************
 * PcNewResourceList()
 *****************************************************************************
 * Creates and initializes a resource list.
 * Creates an empty resource list if both of the PCM_RESOURCE_LIST parameters
 * are NULL.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcNewResourceList
(
    OUT     PRESOURCELIST *     OutResourceList,
    IN      PUNKNOWN            OuterUnknown            OPTIONAL,
    IN      POOL_TYPE           PoolType,
    IN      PCM_RESOURCE_LIST   TranslatedResources,
    IN      PCM_RESOURCE_LIST   UntranslatedResources
)
{
    PAGED_CODE();

    ASSERT(OutResourceList);

    //
    // Validate Parameters.
    //
    if (NULL == OutResourceList)
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("PcNewResourceList : Invalid Parameter"));        
        return STATUS_INVALID_PARAMETER;
    }

    PUNKNOWN    unknown;
    NTSTATUS    ntStatus =
        CreateResourceList
        (
            &unknown,
            GUID_NULL,
            OuterUnknown,
            PoolType
        );

    if (NT_SUCCESS(ntStatus))
    {
        PRESOURCELISTINIT resourceList;
        ntStatus =
            unknown->QueryInterface
            (
                IID_IResourceList,
                (PVOID *) &resourceList
            );

        if (NT_SUCCESS(ntStatus))
        {
            ntStatus =
                resourceList->Init
                (
                    TranslatedResources,
                    UntranslatedResources,
                    PoolType
                );

            if (NT_SUCCESS(ntStatus))
            {
                *OutResourceList = resourceList;
            }
            else
            {
                resourceList->Release();
            }
        }

        unknown->Release();
    }

    return ntStatus;
}

/*****************************************************************************
 * PcNewResourceSublist()
 *****************************************************************************
 * Creates and initializes an empty resource list derived from another
 * resource list.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcNewResourceSublist
(
    OUT     PRESOURCELIST *     OutResourceList,
    IN      PUNKNOWN            OuterUnknown            OPTIONAL,
    IN      POOL_TYPE           PoolType,
    IN      PRESOURCELIST       ParentList,
    IN      ULONG               MaximumEntries
)
{
    PAGED_CODE();

    ASSERT(OutResourceList);
    ASSERT(ParentList);
    ASSERT(MaximumEntries);

    //
    // Validate Parameters.
    //
    if (NULL == OutResourceList ||
        NULL == ParentList ||
        0    == MaximumEntries)
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("PcNewResourceSubList : Invalid Parameter"));
        return STATUS_INVALID_PARAMETER;
    }

    PUNKNOWN    unknown;
    NTSTATUS    ntStatus =
        CreateResourceList
        (
            &unknown,
            GUID_NULL,
            OuterUnknown,
            PoolType
        );

    if (NT_SUCCESS(ntStatus))
    {
        PRESOURCELISTINIT resourceList;
        ntStatus =
            unknown->QueryInterface
            (
                IID_IResourceList,
                (PVOID *) &resourceList
            );

        if (NT_SUCCESS(ntStatus))
        {
            ntStatus =
                resourceList->InitFromParent
                (
                    ParentList,
                    MaximumEntries,
                    PoolType
                );

            if (NT_SUCCESS(ntStatus))
            {
                *OutResourceList = resourceList;
            }
            else
            {
                resourceList->Release();
            }
        }

        unknown->Release();
    }

    return ntStatus;
}





/*****************************************************************************
 * Member functions.
 */

/*****************************************************************************
 * CResourceList::~CResourceList()
 *****************************************************************************
 * Destructor.
 */
CResourceList::
~CResourceList
(   void
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_LIFETIME,("Destroying RESOURCELIST (0x%08x)",this));

    if (Translated)
    {
        ExFreePool(Translated);
    }

    if (Untranslated)
    {
        ExFreePool(Untranslated);
    }
}

/*****************************************************************************
 * CResourceList::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.
 */
STDMETHODIMP_(NTSTATUS)
CResourceList::
NonDelegatingQueryInterface
(
    REFIID  Interface,
    PVOID * Object
)
{
    PAGED_CODE();

    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface,IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(this));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IResourceList))
    {
        *Object = PVOID(PRESOURCELISTINIT(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}


/*****************************************************************************
 * CResourceList::Init()
 *****************************************************************************
 * Initializes the object.
 */
STDMETHODIMP_(NTSTATUS)
CResourceList::
Init
(
    IN      PCM_RESOURCE_LIST   TranslatedResources,
    IN      PCM_RESOURCE_LIST   UntranslatedResources,
    IN      POOL_TYPE           PoolType
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_LIFETIME,("Initializing RESOURCELIST (0x%08x)",this));
    
    // check NULL resource lists.
    if (!TranslatedResources && !UntranslatedResources)
    {
      EntriesAllocated = EntriesInUse = 0;
      Translated = Untranslated = NULL;
      return STATUS_SUCCESS;
    }
    
    // this check fails if _one_ of the resource lists is NULL, which should
    // never happen.
    ASSERT (TranslatedResources);
    ASSERT (UntranslatedResources);
    if (!TranslatedResources || !UntranslatedResources)
    {
        return STATUS_INVALID_PARAMETER;
    }

    EntriesAllocated =
        EntriesInUse =
            UntranslatedResources->List[0].PartialResourceList.Count;

    ULONG listSize =
        (   sizeof(CM_RESOURCE_LIST)
        +   (   (EntriesInUse - 1)
            *   sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR)
            )
        );

    NTSTATUS ntStatus = STATUS_SUCCESS;

    Translated = PCM_RESOURCE_LIST(ExAllocatePoolWithTag(PoolType,listSize,'lRcP'));
    if (Translated)
    {
        Untranslated =
            PCM_RESOURCE_LIST(ExAllocatePoolWithTag(PoolType,listSize,'lRcP'));
        if (Untranslated)
        {
            RtlCopyMemory(Untranslated,UntranslatedResources,listSize);
            RtlCopyMemory(Translated,TranslatedResources,listSize);
        }
        else
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            ExFreePool(Translated);
            Translated = NULL;
        }
    }
    else
    {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}

/*****************************************************************************
 * CResourceList::InitFromParent()
 *****************************************************************************
 * Initializes the object from a parent object.
 */
STDMETHODIMP_(NTSTATUS)
CResourceList::
InitFromParent
(
    IN      PRESOURCELIST       ParentList,
    IN      ULONG               MaximumEntries,
    IN      POOL_TYPE           PoolType
)
{
    PAGED_CODE();

    ASSERT(ParentList);
    ASSERT(MaximumEntries);

    ULONG listSize =
        (   sizeof(CM_RESOURCE_LIST)
        +   (   (   MaximumEntries
                -   1
                )
            *   sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR)
            )
        );

    NTSTATUS ntStatus = STATUS_SUCCESS;

    Translated = PCM_RESOURCE_LIST(ExAllocatePoolWithTag(PoolType,listSize,'lRcP'));
    if (Translated)
    {
        Untranslated = PCM_RESOURCE_LIST(ExAllocatePoolWithTag(PoolType,listSize,'lRcP'));
        if (Untranslated)
        {
            RtlZeroMemory(Translated,listSize);
            RtlZeroMemory(Untranslated,listSize);

            // Copy headers from the parent.
            RtlCopyMemory
            (
                Translated,
                ParentList->TranslatedList(),
                (   sizeof(CM_RESOURCE_LIST)
                -   sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR)
                )
            );
            RtlCopyMemory
            (
                Untranslated,
                ParentList->UntranslatedList(),
                (   sizeof(CM_RESOURCE_LIST)
                -   sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR)
                )
            );

            EntriesAllocated    = MaximumEntries;
            EntriesInUse        = 0;

            Translated->List[0].PartialResourceList.Count = EntriesInUse;
            Untranslated->List[0].PartialResourceList.Count = EntriesInUse;
        }
        else
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            ExFreePool(Translated);
            Translated = NULL;
        }
    }
    else
    {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}

/*****************************************************************************
 * CResourceList::NumberOfEntries()
 *****************************************************************************
 * Determine the number of entries in the list.
 */
STDMETHODIMP_(ULONG)
CResourceList::
NumberOfEntries
(   void
)
{
    PAGED_CODE();

    return EntriesInUse;
}

/*****************************************************************************
 * CResourceList::NumberOfEntriesOfType()
 *****************************************************************************
 * Determines the number of entries of a given type in the list.
 */
STDMETHODIMP_(ULONG)
CResourceList::
NumberOfEntriesOfType
(
    IN      CM_RESOURCE_TYPE    Type
)
{
    PAGED_CODE();

    if (!Untranslated) {
       return 0;
    }

    PCM_PARTIAL_RESOURCE_DESCRIPTOR descriptor =
        Untranslated->List[0].PartialResourceList.PartialDescriptors;

    ULONG entriesOfType = 0;

    for
    (   ULONG count = EntriesInUse;
        count--;
        descriptor++
    )
    {
        if (descriptor->Type == Type)
        {
            entriesOfType++;
        }
    }

    return entriesOfType;
}

/*****************************************************************************
 * CResourceList::FindTranslatedEntry()
 *****************************************************************************
 * Finds a translated entry.
 */
STDMETHODIMP_(PCM_PARTIAL_RESOURCE_DESCRIPTOR)
CResourceList::
FindTranslatedEntry
(
    IN      CM_RESOURCE_TYPE    Type,
    IN      ULONG               Index
)
{
    PAGED_CODE();

    if (!Translated) {
       return 0;
    }

    PCM_PARTIAL_RESOURCE_DESCRIPTOR descriptor =
        Translated->List[0].PartialResourceList.PartialDescriptors;

    ULONG count = EntriesInUse;

    if (count)
    {
        while (descriptor)
        {
            if (count-- == 0)
            {
                descriptor = NULL;
            }
            else
            {
                if (descriptor->Type == Type)
                {
                    if (Index-- == 0)
                    {
                        break;
                    }
                }

                descriptor++;
            }
        }
    }

    return descriptor;
}

/*****************************************************************************
 * CResourceList::FindUntranslatedEntry()
 *****************************************************************************
 * Finds an untranslated entry.
 */
STDMETHODIMP_(PCM_PARTIAL_RESOURCE_DESCRIPTOR)
CResourceList::
FindUntranslatedEntry
(
    IN      CM_RESOURCE_TYPE    Type,
    IN      ULONG               Index
)
{
    PAGED_CODE();

    if (!Untranslated) {
       return 0;
    }

    PCM_PARTIAL_RESOURCE_DESCRIPTOR descriptor =
        Untranslated->List[0].PartialResourceList.PartialDescriptors;

    ULONG count = EntriesInUse;

    if (count)
    {
        while (descriptor)
        {
            if (count-- == 0)
            {
                descriptor = NULL;
            }
            else
            {
                if (descriptor->Type == Type)
                {
                    if (Index-- == 0)
                    {
                        break;
                    }
                }

                descriptor++;
            }
        }
    }

    return descriptor;
}

/*****************************************************************************
 * CResourceList::AddEntry()
 *****************************************************************************
 * Adds an entry.
 */
STDMETHODIMP_(NTSTATUS)
CResourceList::
AddEntry
(
    IN      PCM_PARTIAL_RESOURCE_DESCRIPTOR TranslatedDescr,
    IN      PCM_PARTIAL_RESOURCE_DESCRIPTOR UntranslatedDescr
)
{
    PAGED_CODE();

    ASSERT(TranslatedDescr);
    ASSERT(UntranslatedDescr);

    NTSTATUS ntStatus = STATUS_SUCCESS;

    // when there is no resource list stored in this object, both EntriesInUse
    // and EntriesAllocated are 0.
    if (EntriesInUse < EntriesAllocated)
    {
        Translated->
            List[0].PartialResourceList.PartialDescriptors[EntriesInUse] =
                *TranslatedDescr;

        Untranslated->
            List[0].PartialResourceList.PartialDescriptors[EntriesInUse] =
                *UntranslatedDescr;

        EntriesInUse++;

        // update counts
        Translated->
            List[0].PartialResourceList.Count = EntriesInUse;
        Untranslated->
            List[0].PartialResourceList.Count = EntriesInUse;
    }
    else
    {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}

/*****************************************************************************
 * CResourceList::AddEntryFromParent()
 *****************************************************************************
 * Adds an entry from a parent.
 */
STDMETHODIMP_(NTSTATUS)
CResourceList::
AddEntryFromParent
(
    IN      PRESOURCELIST       Parent,
    IN      CM_RESOURCE_TYPE    Type,
    IN      ULONG               Index
)
{
    PAGED_CODE();

    ASSERT(Parent);

    PCM_PARTIAL_RESOURCE_DESCRIPTOR translated =
        Parent->FindTranslatedEntry(Type,Index);
    PCM_PARTIAL_RESOURCE_DESCRIPTOR untranslated =
        Parent->FindUntranslatedEntry(Type,Index);

    NTSTATUS ntStatus;

    if (translated && untranslated)
    {
        ntStatus = AddEntry(translated,untranslated);
    }
    else
    {
        ntStatus = STATUS_INVALID_PARAMETER;
    }

    return ntStatus;
}

/*****************************************************************************
 * CResourceList::TranslatedList()
 *****************************************************************************
 * Gets the list of translated resources.
 */
STDMETHODIMP_(PCM_RESOURCE_LIST)
CResourceList::
TranslatedList
(   void
)
{
    PAGED_CODE();

    return Translated;  // Attention: This could be NULL.
}                          

/*****************************************************************************
 * CResourceList::UntranslatedList()
 *****************************************************************************
 * Gets the list of untranslated resources.
 */
STDMETHODIMP_(PCM_RESOURCE_LIST)
CResourceList::
UntranslatedList
(   void
)
{
    PAGED_CODE();

    return Untranslated;   // Attention: This could be NULL.
}

#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\main\shreq.cpp ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation.  All rights reserved.

Module Name:

    shreq.cpp

Abstract:

    This module contains the implementation of the kernel streaming shell
    requestor object.

Author:

    Dale Sather  (DaleSat) 31-Jul-1998

--*/

#include "private.h"
#include <kcom.h>
#include "stdio.h"

#define POOLTAG_REQUESTOR 'gbcP'
#define POOLTAG_STREAMHEADER 'hscP'

//
// CKsShellQueue is the implementation of the kernel shell requestor object.
//
class CKsShellRequestor:
    public IKsShellTransport,
    public IKsWorkSink,
    public CBaseUnknown
{
private:
    PIKSSHELLTRANSPORT m_TransportSource;
    PIKSSHELLTRANSPORT m_TransportSink;
    PDEVICE_OBJECT m_NextDeviceObject;
    PFILE_OBJECT m_AllocatorFileObject;
    KSSTREAMALLOCATOR_FUNCTIONTABLE m_AllocatorFunctionTable;
    KSSTREAMALLOCATOR_STATUS m_AllocatorStatus;
    ULONG m_StackSize;
    ULONG m_ProbeFlags;
    ULONG m_StreamHeaderSize;
    ULONG m_FrameSize;
    ULONG m_FrameCount;
    ULONG m_ActiveIrpCountPlusOne;
    BOOLEAN m_Flushing;
    BOOLEAN m_EndOfStream;
    KSSTATE m_State;
    INTERLOCKEDLIST_HEAD m_IrpsToFree;
    WORK_QUEUE_ITEM m_WorkItem;
    PKSWORKER m_Worker;
    KEVENT m_StopEvent;

public:
    DEFINE_STD_UNKNOWN();

    CKsShellRequestor(PUNKNOWN OuterUnknown):
        CBaseUnknown(OuterUnknown) {
    }
    ~CKsShellRequestor();

    IMP_IKsShellTransport;
    IMP_IKsWorkSink;

    NTSTATUS
    Init(
        IN ULONG ProbeFlags,
        IN ULONG StreamHeaderSize OPTIONAL,
        IN ULONG FrameSize,
        IN ULONG FrameCount,
        IN PDEVICE_OBJECT NextDeviceObject,
        IN PFILE_OBJECT AllocatorFileObject OPTIONAL
        );

private:
    NTSTATUS
    Prime(
        void
        );
    NTSTATUS
    Unprime(
        void
        );
    PVOID
    AllocateFrame(
        void
        );
    void
    FreeFrame(
        IN PVOID Frame
        );
};

IMPLEMENT_STD_UNKNOWN(CKsShellRequestor)

#pragma code_seg("PAGE")


NTSTATUS
KspShellCreateRequestor(
    OUT PIKSSHELLTRANSPORT* RequestorTransport,
    IN ULONG ProbeFlags,
    IN ULONG StreamHeaderSize OPTIONAL,
    IN ULONG FrameSize,
    IN ULONG FrameCount,
    IN PDEVICE_OBJECT NextDeviceObject,
    IN PFILE_OBJECT AllocatorFileObject OPTIONAL
    )

/*++

Routine Description:

    This routine creates a new requestor.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("KspShellCreateRequestor"));

    PAGED_CODE();

    ASSERT(RequestorTransport);

    NTSTATUS status;

    CKsShellRequestor *requestor =
        new(NonPagedPool,POOLTAG_REQUESTOR) CKsShellRequestor(NULL);

    if (requestor) {
        requestor->AddRef();

        status =
            requestor->Init(
                ProbeFlags,
                StreamHeaderSize,
                FrameSize,
                FrameCount,
                NextDeviceObject,
                AllocatorFileObject);

        if (NT_SUCCESS(status)) {
            *RequestorTransport = PIKSSHELLTRANSPORT(requestor);
        } else {
            requestor->Release();
        }
    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return status;
}


NTSTATUS
CKsShellRequestor::
Init(
    IN ULONG ProbeFlags,
    IN ULONG StreamHeaderSize OPTIONAL,
    IN ULONG FrameSize,
    IN ULONG FrameCount,
    IN PDEVICE_OBJECT NextDeviceObject,
    IN PFILE_OBJECT AllocatorFileObject OPTIONAL
    )

/*++

Routine Description:

    This routine initializes a requestor object.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_VERBOSE,("CKsShellRequestor::Init"));

    PAGED_CODE();

    ASSERT(((StreamHeaderSize == 0) ||
            (StreamHeaderSize >= sizeof(KSSTREAM_HEADER))) &&
           ((StreamHeaderSize & FILE_QUAD_ALIGNMENT) == 0));

    if (StreamHeaderSize == 0)
    {
        StreamHeaderSize = sizeof(KSSTREAM_HEADER);
    }

    m_NextDeviceObject = NextDeviceObject;
    m_AllocatorFileObject = AllocatorFileObject;

    m_ProbeFlags = ProbeFlags;
    m_StreamHeaderSize = StreamHeaderSize;
    m_FrameSize = FrameSize;
    m_FrameCount = FrameCount;

    m_State = KSSTATE_STOP;
    m_Flushing = FALSE;
    m_EndOfStream = FALSE;

    //
    // This is a one-based count of IRPs in circulation.  We decrement it when
    // we go to stop state and block until it hits zero.
    //
    m_ActiveIrpCountPlusOne = 1;
    KeInitializeEvent(&m_StopEvent,SynchronizationEvent,FALSE);

    //
    // Initialize IRP-freeing work item stuff.
    //
    InitializeInterlockedListHead(&m_IrpsToFree);
    KsInitializeWorkSinkItem(&m_WorkItem,this);

    NTSTATUS status = KsRegisterCountedWorker(DelayedWorkQueue,&m_WorkItem,&m_Worker);
    if (!NT_SUCCESS(status))
    {
        return status;
    }

    //
    // Get the function table and status from the allocator if there is an
    // allocator.
    //
    if (m_AllocatorFileObject)
    {
        KSPROPERTY property;
        property.Set = KSPROPSETID_StreamAllocator;
        property.Id = KSPROPERTY_STREAMALLOCATOR_FUNCTIONTABLE;
        property.Flags = KSPROPERTY_TYPE_GET;

        ULONG bytesReturned;
        status =
            KsSynchronousIoControlDevice(
                m_AllocatorFileObject,
                KernelMode,
                IOCTL_KS_PROPERTY,
                PVOID(&property),
                sizeof(property),
                PVOID(&m_AllocatorFunctionTable),
                sizeof(m_AllocatorFunctionTable),
                &bytesReturned);

        if (NT_SUCCESS(status) &&
            (bytesReturned != sizeof(m_AllocatorFunctionTable)))
        {
            status = STATUS_INVALID_BUFFER_SIZE;
        }

        if (NT_SUCCESS(status))
        {
            property.Id = KSPROPERTY_STREAMALLOCATOR_STATUS;

            status =
                KsSynchronousIoControlDevice(
                    m_AllocatorFileObject,
                    KernelMode,
                    IOCTL_KS_PROPERTY,
                    PVOID(&property),
                    sizeof(property),
                    PVOID(&m_AllocatorStatus),
                    sizeof(m_AllocatorStatus),
                    &bytesReturned);

            if (NT_SUCCESS(status) &&
                (bytesReturned != sizeof(m_AllocatorStatus)))
            {
                status = STATUS_INVALID_BUFFER_SIZE;
            }

            if (NT_SUCCESS(status))
            {
                m_FrameSize = m_AllocatorStatus.Framing.FrameSize;
                m_FrameCount = m_AllocatorStatus.Framing.Frames;

                _DbgPrintF(DEBUGLVL_VERBOSE,("#### Req%p.Init:  using allocator 0x%08x, size %d, count %d",this,m_AllocatorFileObject,m_FrameSize,m_FrameCount));
            }
            else
            {
                _DbgPrintF(DEBUGLVL_TERSE,("#### Req%p.Init:  allocator failed status query: 0x%08x",this,status));
            }
            }
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE,("#### Req%p.Init:  allocator failed function table query: 0x%08x",this,status));
        }
    }
    else
    {
        _DbgPrintF(DEBUGLVL_VERBOSE,("#### Req%p.Init:  not using an allocator, size %d, count %d",this,m_FrameSize,m_FrameCount));
    }

    return status;
}


CKsShellRequestor::
~CKsShellRequestor(
    void
    )

/*++

Routine Description:

    This routine destructs a requestor object.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("CKsShellRequestor::~CKsShellRequestor"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("#### Req%p.~",this));

    PAGED_CODE();

    ASSERT(! m_TransportSink);
    ASSERT(! m_TransportSource);
    if (m_Worker) {
        KsUnregisterWorker(m_Worker);
        m_Worker = NULL;
    }
}


STDMETHODIMP_(NTSTATUS)
CKsShellRequestor::
NonDelegatedQueryInterface(
    IN REFIID InterfaceId,
    OUT PVOID* InterfacePointer
    )

/*++

Routine Description:

    This routine obtains an interface to a requestor object.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("CKsShellRequestor::NonDelegatedQueryInterface"));

    PAGED_CODE();

    ASSERT(InterfacePointer);

    NTSTATUS status = STATUS_SUCCESS;

    if (IsEqualGUIDAligned(InterfaceId,__uuidof(IKsShellTransport))) {
        *InterfacePointer = PVOID(PIKSSHELLTRANSPORT(this));
        AddRef();
    } else {
        status = CBaseUnknown::NonDelegatedQueryInterface(
            InterfaceId,InterfacePointer);
    }

    return status;
}


STDMETHODIMP_(void)
CKsShellRequestor::
Work(
    void
    )

/*++

Routine Description:

    This routine performs work in a worker thread.  In particular, it frees
    IRPs.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("CKsShellRequestor::Work"));

    PAGED_CODE();

    //
    // Send all IRPs in the queue.
    //
    do
    {
        if (! IsListEmpty(&m_IrpsToFree.ListEntry))
        {
            PIRP irp;

            PLIST_ENTRY pListHead = ExInterlockedRemoveHeadList(&m_IrpsToFree.ListEntry,&m_IrpsToFree.SpinLock);
            if (pListHead)
            {
                irp = CONTAINING_RECORD(pListHead,IRP,Tail.Overlay.ListEntry);
            }
            else
            {
                return;
            }
            _DbgPrintF(DEBUGLVL_VERBOSE,("#### Req%p.Work:  freeing IRP 0x%08x",this,irp));

            //
            // Free MDL(s).
            //
            PMDL nextMdl;
            for (PMDL mdl = irp->MdlAddress; mdl != NULL; mdl = nextMdl) {
                nextMdl = mdl->Next;

                if (mdl->MdlFlags & MDL_PAGES_LOCKED) {
                    MmUnlockPages(mdl);
                }
                IoFreeMdl(mdl);
            }

            //
            // Free header and frame.
            //
            PKSSTREAM_HEADER streamHeader = PKSSTREAM_HEADER(irp->UserBuffer);

            if (streamHeader) {
                if (streamHeader->Data) {
                    FreeFrame(streamHeader->Data);
                }
                ExFreePool(streamHeader);
            }

            IoFreeIrp(irp);

            //
            // Count the active IRPs.  If we have hit zero, this means that
            // another thread is waiting to finish a transition to stop state.
            //
            if (! InterlockedDecrement(PLONG(&m_ActiveIrpCountPlusOne))) {
                KeSetEvent(&m_StopEvent,IO_NO_INCREMENT,FALSE);
            }
        }
    } while (KsDecrementCountedWorker(m_Worker));
}

#pragma code_seg()


STDMETHODIMP_(NTSTATUS)
CKsShellRequestor::
TransferKsIrp(
    IN PIRP Irp,
    IN PIKSSHELLTRANSPORT* NextTransport
    )

/*++

Routine Description:

    This routine handles the arrival of a streaming IRP.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("CKsShellRequestor::TransferKsIrp"));

    ASSERT(Irp);
    ASSERT(NextTransport);

    ASSERT(m_TransportSink);

    if (m_State != KSSTATE_RUN) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("#### Req%p.TransferKsIrp:  got IRP %p in state %d",this,Irp,m_State));
    }

    NTSTATUS status;
    PKSSTREAM_HEADER streamHeader = PKSSTREAM_HEADER(Irp->UserBuffer);

    //
    // Check for end of stream.
    //
    if (streamHeader->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM) {
        m_EndOfStream = TRUE;
        _DbgPrintF(DEBUGLVL_VERBOSE,("#### Req%p.TransferKsIrp:  IRP %p is marked end-of-stream",this,Irp));
    }

    if (m_Flushing || m_EndOfStream || (m_State == KSSTATE_STOP)) {
        //
        // Stopping...destroy the IRP.
        //
        ExInterlockedInsertTailList(
            &m_IrpsToFree.ListEntry,
            &Irp->Tail.Overlay.ListEntry,
            &m_IrpsToFree.SpinLock);

        *NextTransport = NULL;
        KsIncrementCountedWorker(m_Worker);
        status = STATUS_PENDING;
    } else {
        //
        // Recondition and forward it.
        //
        PVOID frame = streamHeader->Data;

        RtlZeroMemory(streamHeader,m_StreamHeaderSize);
        streamHeader->Size = m_StreamHeaderSize;
        streamHeader->Data = frame;
        streamHeader->FrameExtent = m_FrameSize;

        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = 0;
        Irp->PendingReturned = 0;
        Irp->Cancel = 0;

        *NextTransport = m_TransportSink;
        status = STATUS_SUCCESS;
    }

    return status;
}

#pragma code_seg("PAGE")


STDMETHODIMP_(void)
CKsShellRequestor::
Connect(
    IN PIKSSHELLTRANSPORT NewTransport OPTIONAL,
    OUT PIKSSHELLTRANSPORT *OldTransport OPTIONAL,
    IN KSPIN_DATAFLOW DataFlow
    )

/*++

Routine Description:

    This routine establishes a transport connection.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("CKsShellRequestor::Connect"));

    PAGED_CODE();

    KsShellStandardConnect(
        NewTransport,
        OldTransport,
        DataFlow,
        PIKSSHELLTRANSPORT(this),
        &m_TransportSource,
        &m_TransportSink);
}


STDMETHODIMP_(NTSTATUS)
CKsShellRequestor::
SetDeviceState(
    IN KSSTATE ksStateTo,
    IN KSSTATE ksStateFrom,
    IN PIKSSHELLTRANSPORT* NextTransport
    )

/*++

Routine Description:

    This routine handles notification that the device state has changed.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_VERBOSE,("#### Req%p.SetDeviceState:  set from %d to %d",this,ksStateFrom,ksStateTo));

    PAGED_CODE();

    ASSERT(NextTransport);

    NTSTATUS status;

    //
    // If this is a change of state, note the new state and indicate the next
    // recipient.
    //
    if (m_State != ksStateTo) {
        //
        // The state has changed.  Just note the new state, indicate the next
        // recipient, and get out.  We will get the same state change again
        // when it has gone all the way around the circuit.
        //
        m_State = ksStateTo;

        if (ksStateTo > ksStateFrom){
            *NextTransport = m_TransportSink;
        } else {
            *NextTransport = m_TransportSource;
        }

        status = STATUS_SUCCESS;
    } else {
        //
        // The state change has gone all the way around the circuit and come
        // back.  All the other components are in the new state now.  For
        // transitions out of acquire state, there is work to be done.
        //
        *NextTransport = NULL;

        if (ksStateFrom == KSSTATE_ACQUIRE) {
            if (ksStateTo == KSSTATE_PAUSE) {
                //
                // Acquire-to-pause requires us to prime.
                //
                status = Prime();
            } else {
                //
                // Acquire-to-stop requires us to wait until all IRPs are home to
                // roost.
                //
                if (InterlockedDecrement(PLONG(&m_ActiveIrpCountPlusOne))) {
                    _DbgPrintF(DEBUGLVL_VERBOSE,("#### Req%p.SetDeviceState:  waiting for %d active IRPs to return",this,m_ActiveIrpCountPlusOne));
                    KeWaitForSingleObject(
                        &m_StopEvent,
                        Suspended,
                        KernelMode,
                        FALSE,
                        NULL
                    );
                    _DbgPrintF(DEBUGLVL_VERBOSE,("#### Req%p.SetDeviceState:  done waiting",this));
                }
                status = STATUS_SUCCESS;
            }
        } 
        else 
        {
#if 1
            //
            // Nothing to do.
            //
#else 
            // Take a configuration pass through the circuit.
            // The transport interface for each element in the circuit exposes GetTransportConfig 
            //     and SetTransportConfig.
            // The requestor's stack depth starts at 1
            // Each element that reports in GetTransportConfig returns it's stack depth
            // Queues, Intra-Pins report 1
            // Extra-Pins report the depth of the connected device object plus one
            // Splitters are handled somewhat differently (irrelevant to portcls?)
            // After each GetTransportConfig, the requestor's stack depth is adjusted to be the 
            //     highest depth seen thus far in configuration
            // At the end, SetTransportConfig is used to set the requestors stack depth
            // 
            // This mechanism is also used to decide probe flags.  
            // If you're interested in looking at the source, ksfilter\ks\shpipe.cpp 
            //     ConfigureCompleteCircuit and sh*.cpp GetTransportConfig / SetTransportConfig
            //     are the ones to look at.
            // 

#endif
            status = STATUS_SUCCESS;
        }
    }

    return status;
}


NTSTATUS
CKsShellRequestor::
Prime(
    void
    )

/*++

Routine Description:

    This routine primes the requestor.

Arguments:

    None.

Return Value:

    Status.

--*/

{
    PAGED_CODE();

    //
    // Cache the stack size.
    //
    m_StackSize = m_NextDeviceObject->StackSize;
    // HACK
    //
    // ADRIAO ISSUE 06/29/1999
    //     Arghhhh!!!!!!!!
    //
    // ISSUE MARTINP 2000/12/18  This is fixed with AVStream, so it isn't worth
    // making large changes to address this issue for Windows XP.  This code is
    // no longer present in PortCls2.  We should make sure this is fixed in for 
    // sure in Blackcomb.
    //
    _DbgPrintF(DEBUGLVL_VERBOSE,("#### Req%p.Prime:  stack size is %d",this,m_StackSize));
    m_StackSize = 6;

    //
    // Reset the end of stream indicator.
    //
    m_EndOfStream = FALSE;

    NTSTATUS status = STATUS_SUCCESS;

    //
    // Call the allocator or create some synthetic frames.  Then wrap the
    // frames in IRPs.
    //
    for (ULONG count = m_FrameCount; count--;) {
        //
        // Allocate the frame.
        //
        PVOID frame = AllocateFrame();

        if (! frame) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            _DbgPrintF(DEBUGLVL_TERSE,("#### Req%p.Prime:  failed to allocate frame",this));
            break;
        }

        //
        // Allocate and initialize the stream header.
        //
        PKSSTREAM_HEADER streamHeader = (PKSSTREAM_HEADER)
            ExAllocatePoolWithTag(
                NonPagedPool,m_StreamHeaderSize,POOLTAG_STREAMHEADER);

        if (! streamHeader) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            _DbgPrintF(DEBUGLVL_TERSE,("#### Req%p.Prime:  failed to allocate stream header",this));
            FreeFrame(frame);
            break;
        }

        RtlZeroMemory(streamHeader,m_StreamHeaderSize);
        streamHeader->Size = m_StreamHeaderSize;
        streamHeader->Data = frame;
        streamHeader->FrameExtent = m_FrameSize;

        //
        // Count the active IRPs.
        //
        InterlockedIncrement(PLONG(&m_ActiveIrpCountPlusOne));

        //
        // Allocate an IRP.
        //
        ASSERT(m_StackSize);
        PIRP irp = IoAllocateIrp(CCHAR(m_StackSize),FALSE);

        if (! irp) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            _DbgPrintF(DEBUGLVL_TERSE,("#### Req%p.Prime:  failed to allocate IRP",this));
            ExFreePool(streamHeader);
            FreeFrame(frame);
            break;
        }

        irp->UserBuffer = streamHeader;
        irp->RequestorMode = KernelMode;
        irp->Flags = IRP_NOCACHE;

        //
        // Set the stack pointer to the first location and fill it in.
        //
        IoSetNextIrpStackLocation(irp);

        PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(irp);

        irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
        irpSp->Parameters.DeviceIoControl.IoControlCode =
            IOCTL_KS_READ_STREAM;
        irpSp->Parameters.DeviceIoControl.OutputBufferLength =
            m_StreamHeaderSize;

        //
        // Let KsProbeStreamIrp() prepare the IRP as specified by the caller.
        //
        status = KsProbeStreamIrp(irp,m_ProbeFlags,sizeof(KSSTREAM_HEADER));

        if (! NT_SUCCESS(status)) {
            _DbgPrintF(DEBUGLVL_TERSE,("#### Req%p.Prime:  KsProbeStreamIrp failed:  0x%08x",this,status));
            IoFreeIrp(irp);
            ExFreePool(streamHeader);
            FreeFrame(frame);
            break;
        }

        //
        // Send the IRP to the next component.
        //
        //mgp
        _DbgPrintF(DEBUGLVL_VERBOSE,("#### Req%p.SetDeviceState:  transferring new IRP 0x%08x",this,irp));
        status = KsShellTransferKsIrp(m_TransportSink,irp);

        if (NT_SUCCESS(status) || (status == STATUS_MORE_PROCESSING_REQUIRED)) {
            status = STATUS_SUCCESS;
        } else {
            _DbgPrintF(DEBUGLVL_TERSE,("#### Req%p.Prime:  receiver failed transfer call:  0x%08x",this,status));
            IoFreeIrp(irp);
            ExFreePool(streamHeader);
            FreeFrame(frame);
            break;
        }
    }

    return status;
}


STDMETHODIMP_(void)
CKsShellRequestor::
SetResetState(
    IN KSRESET ksReset,
    IN PIKSSHELLTRANSPORT* NextTransport
    )

/*++

Routine Description:

    This routine handles notification that the reset state has changed.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_VERBOSE,("CKsShellRequestor::SetResetState] to %d",ksReset));

    PAGED_CODE();

    ASSERT(NextTransport);

    if (m_Flushing != (ksReset == KSRESET_BEGIN)) {
        *NextTransport = m_TransportSink;
        m_Flushing = (ksReset == KSRESET_BEGIN);
    } else {
        *NextTransport = NULL;
    }
}


PVOID
CKsShellRequestor::
AllocateFrame(
    void
    )

/*++

Routine Description:

    This routine allocates a frame.

Arguments:

    None.

Return Value:

    The allocated frame or NULL if no frame could be allocated.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("CKsShellRequestor::AllocateFrame"));

    PAGED_CODE();

    PVOID frame;
    if (m_AllocatorFileObject) {
        m_AllocatorFunctionTable.AllocateFrame(m_AllocatorFileObject,&frame);
    } else {
        frame = ExAllocatePoolWithTag(NonPagedPool,m_FrameSize,'kHcP');
    }

    return frame;
}


void
CKsShellRequestor::
FreeFrame(
    IN PVOID Frame
    )

/*++

Routine Description:

    This routine frees a frame.

Arguments:

    Frame -
        The frame to free.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_VERBOSE,("CKsShellRequestor::FreeFrame"));

    PAGED_CODE();

    if (m_AllocatorFileObject) {
        m_AllocatorFunctionTable.FreeFrame(m_AllocatorFileObject,Frame);
    } else {
        ExFreePool(Frame);
    }
}

#if DBG

STDMETHODIMP_(void)
CKsShellRequestor::
DbgRollCall(
    IN ULONG MaxNameSize,
    OUT PCHAR Name,
    OUT PIKSSHELLTRANSPORT* NextTransport,
    OUT PIKSSHELLTRANSPORT* PrevTransport
    )

/*++

Routine Description:

    This routine produces a component name and the transport pointers.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("CKsShellRequestor::DbgRollCall"));

    PAGED_CODE();

    ASSERT(Name);
    ASSERT(NextTransport);
    ASSERT(PrevTransport);

    ULONG references = AddRef() - 1; Release();

    _snprintf(Name,MaxNameSize,"Req%p refs=%d\n",this,references);
    *NextTransport = m_TransportSink;
    *PrevTransport = m_TransportSource;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\miniport\dmusuart\miniport.cpp ===
/*****************************************************************************
 * miniport.cpp - UART miniport implementation
 *****************************************************************************
 * Copyright (c) 1997-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *      Feb 98    MartinP   --  based on UART, began deltas for DirectMusic.
 */

#include "private.h"
#include "ksdebug.h"
#include "stdio.h"

#define STR_MODULENAME "DMusUART:Miniport: "

#pragma code_seg("PAGE")

/*****************************************************************************
 * PinDataRangesStreamLegacy
 * PinDataRangesStreamDMusic
 *****************************************************************************
 * Structures indicating range of valid format values for live pins.
 */
static
KSDATARANGE_MUSIC PinDataRangesStreamLegacy =
{
    {
        sizeof(KSDATARANGE_MUSIC),
        0,
        0,
        0,
        STATICGUIDOF(KSDATAFORMAT_TYPE_MUSIC),
        STATICGUIDOF(KSDATAFORMAT_SUBTYPE_MIDI),
        STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE)
    },
    STATICGUIDOF(KSMUSIC_TECHNOLOGY_PORT),
    0,
    0,
    0xFFFF
};
static
KSDATARANGE_MUSIC PinDataRangesStreamDMusic =
{
    {
        sizeof(KSDATARANGE_MUSIC),
        0,
        0,
        0,
        STATICGUIDOF(KSDATAFORMAT_TYPE_MUSIC),
        STATICGUIDOF(KSDATAFORMAT_SUBTYPE_DIRECTMUSIC),
        STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE)
    },
    STATICGUIDOF(KSMUSIC_TECHNOLOGY_PORT),
    0,
    0,
    0xFFFF
};

/*****************************************************************************
 * PinDataRangePointersStreamLegacy
 * PinDataRangePointersStreamDMusic
 * PinDataRangePointersStreamCombined
 *****************************************************************************
 * List of pointers to structures indicating range of valid format values
 * for live pins.
 */
static
PKSDATARANGE PinDataRangePointersStreamLegacy[] =
{
    PKSDATARANGE(&PinDataRangesStreamLegacy)
};
static
PKSDATARANGE PinDataRangePointersStreamDMusic[] =
{
    PKSDATARANGE(&PinDataRangesStreamDMusic)
};
static
PKSDATARANGE PinDataRangePointersStreamCombined[] =
{
    PKSDATARANGE(&PinDataRangesStreamLegacy)
   ,PKSDATARANGE(&PinDataRangesStreamDMusic)
};

/*****************************************************************************
 * PinDataRangesBridge
 *****************************************************************************
 * Structures indicating range of valid format values for bridge pins.
 */
static
KSDATARANGE PinDataRangesBridge[] =
{
   {
      sizeof(KSDATARANGE),
      0,
      0,
      0,
      STATICGUIDOF(KSDATAFORMAT_TYPE_MUSIC),
      STATICGUIDOF(KSDATAFORMAT_SUBTYPE_MIDI_BUS),
      STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE)
   }
};

/*****************************************************************************
 * PinDataRangePointersBridge
 *****************************************************************************
 * List of pointers to structures indicating range of valid format values
 * for bridge pins.
 */
static
PKSDATARANGE PinDataRangePointersBridge[] =
{
    &PinDataRangesBridge[0]
};

/*****************************************************************************
 * SynthProperties
 *****************************************************************************
 * List of properties in the Synth set.
 */
static
PCPROPERTY_ITEM
SynthProperties[] =
{
    // Global: S/Get synthesizer caps
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_CAPS,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Synth
    },
    // Global: S/Get port parameters
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_PORTPARAMETERS,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Synth
    },
    // Per stream: S/Get channel groups
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_CHANNELGROUPS,
        KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Synth
    },
    // Per stream: Get current latency time
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_LATENCYCLOCK,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Synth
    }
};
DEFINE_PCAUTOMATION_TABLE_PROP(AutomationSynth,  SynthProperties);
DEFINE_PCAUTOMATION_TABLE_PROP(AutomationSynth2, SynthProperties);

#define kMaxNumCaptureStreams       1
#define kMaxNumLegacyRenderStreams  1
#define kMaxNumDMusicRenderStreams  1

/*****************************************************************************
 * MiniportPins
 *****************************************************************************
 * List of pins.
 */
static
PCPIN_DESCRIPTOR MiniportPins[] =
{
    {
        kMaxNumLegacyRenderStreams,kMaxNumLegacyRenderStreams,0,    // InstanceCount
        NULL,                                                       // AutomationTable
        {                                                           // KsPinDescriptor
            0,                                              // InterfacesCount
            NULL,                                           // Interfaces
            0,                                              // MediumsCount
            NULL,                                           // Mediums
            SIZEOF_ARRAY(PinDataRangePointersStreamLegacy), // DataRangesCount
            PinDataRangePointersStreamLegacy,               // DataRanges
            KSPIN_DATAFLOW_IN,                              // DataFlow
            KSPIN_COMMUNICATION_SINK,                       // Communication
            (GUID *) &KSCATEGORY_AUDIO,                     // Category
            &KSAUDFNAME_MIDI,                               // Name
            0                                               // Reserved
        }
    },
    {
        kMaxNumDMusicRenderStreams,kMaxNumDMusicRenderStreams,0,    // InstanceCount
        NULL,                                                       // AutomationTable
        {                                                           // KsPinDescriptor
            0,                                              // InterfacesCount
            NULL,                                           // Interfaces
            0,                                              // MediumsCount
            NULL,                                           // Mediums
            SIZEOF_ARRAY(PinDataRangePointersStreamDMusic), // DataRangesCount
            PinDataRangePointersStreamDMusic,               // DataRanges
            KSPIN_DATAFLOW_IN,                              // DataFlow
            KSPIN_COMMUNICATION_SINK,                       // Communication
            (GUID *) &KSCATEGORY_AUDIO,                     // Category
            &KSAUDFNAME_DMUSIC_MPU_OUT,                     // Name
            0                                               // Reserved
        }
    },
    {
        0,0,0,                                      // InstanceCount
        NULL,                                       // AutomationTable
        {                                           // KsPinDescriptor
            0,                                          // InterfacesCount
            NULL,                                       // Interfaces
            0,                                          // MediumsCount
            NULL,                                       // Mediums
            SIZEOF_ARRAY(PinDataRangePointersBridge),   // DataRangesCount
            PinDataRangePointersBridge,                 // DataRanges
            KSPIN_DATAFLOW_OUT,                         // DataFlow
            KSPIN_COMMUNICATION_NONE,                   // Communication
            (GUID *) &KSCATEGORY_AUDIO,                 // Category
            NULL,                                       // Name
            0                                           // Reserved
        }
    },
    {
        0,0,0,                                      // InstanceCount
        NULL,                                       // AutomationTable
        {                                           // KsPinDescriptor
            0,                                          // InterfacesCount
            NULL,                                       // Interfaces
            0,                                          // MediumsCount
            NULL,                                       // Mediums
            SIZEOF_ARRAY(PinDataRangePointersBridge),   // DataRangesCount
            PinDataRangePointersBridge,                 // DataRanges
            KSPIN_DATAFLOW_IN,                          // DataFlow
            KSPIN_COMMUNICATION_NONE,                   // Communication
            (GUID *) &KSCATEGORY_AUDIO,                 // Category
            NULL,                                       // Name
            0                                           // Reserved
        }
    },
    {
        kMaxNumCaptureStreams,kMaxNumCaptureStreams,0,      // InstanceCount
        NULL,                                               // AutomationTable
        {                                                   // KsPinDescriptor
            0,                                                // InterfacesCount
            NULL,                                             // Interfaces
            0,                                                // MediumsCount
            NULL,                                             // Mediums
            SIZEOF_ARRAY(PinDataRangePointersStreamCombined), // DataRangesCount
            PinDataRangePointersStreamCombined,               // DataRanges
            KSPIN_DATAFLOW_OUT,                               // DataFlow
            KSPIN_COMMUNICATION_SINK,                         // Communication
            (GUID *) &KSCATEGORY_AUDIO,                       // Category
            &KSAUDFNAME_DMUSIC_MPU_IN,                        // Name
            0                                                 // Reserved
        }
    }
};

/*****************************************************************************
 * MiniportNodes
 *****************************************************************************
 * List of nodes.
 */
#define CONST_PCNODE_DESCRIPTOR(n)          { 0, NULL, &n, NULL }
#define CONST_PCNODE_DESCRIPTOR_AUTO(n,a)   { 0, &a, &n, NULL }
static
PCNODE_DESCRIPTOR MiniportNodes[] =
{
      CONST_PCNODE_DESCRIPTOR_AUTO(KSNODETYPE_SYNTHESIZER, AutomationSynth)
    , CONST_PCNODE_DESCRIPTOR_AUTO(KSNODETYPE_SYNTHESIZER, AutomationSynth2)
};

/*****************************************************************************
 * MiniportConnections
 *****************************************************************************
 * List of connections.
 */
enum {
      eSynthNode  = 0
    , eInputNode
};

enum {
      eFilterInputPinLeg = 0,
      eFilterInputPinDM,
      eBridgeOutputPin,
      eBridgeInputPin,
      eFilterOutputPin
};

static
PCCONNECTION_DESCRIPTOR MiniportConnections[] =
{  // From                                   To
   // Node           pin                     Node           pin
    { PCFILTER_NODE, eFilterInputPinLeg,     PCFILTER_NODE, eBridgeOutputPin }      // Legacy Stream in to synth.
  , { PCFILTER_NODE, eFilterInputPinDM,      eSynthNode,    KSNODEPIN_STANDARD_IN } // DM Stream in to synth.
  , { eSynthNode,    KSNODEPIN_STANDARD_OUT, PCFILTER_NODE, eBridgeOutputPin }      // Synth to bridge out.
  , { PCFILTER_NODE, eBridgeInputPin,        eInputNode,    KSNODEPIN_STANDARD_IN } // Bridge in to input.
  , { eInputNode,    KSNODEPIN_STANDARD_OUT, PCFILTER_NODE, eFilterOutputPin }      // Input to DM/Legacy Stream out.
};

/*****************************************************************************
 * MiniportCategories
 *****************************************************************************
 * List of categories.
 */
static
GUID MiniportCategories[] =
{
    STATICGUIDOF(KSCATEGORY_AUDIO),
    STATICGUIDOF(KSCATEGORY_RENDER),
    STATICGUIDOF(KSCATEGORY_CAPTURE)
};

/*****************************************************************************
 * MiniportFilterDescriptor
 *****************************************************************************
 * Complete miniport filter description.
 */
static
PCFILTER_DESCRIPTOR MiniportFilterDescriptor =
{
    0,                                  // Version
    NULL,                               // AutomationTable
    sizeof(PCPIN_DESCRIPTOR),           // PinSize
    SIZEOF_ARRAY(MiniportPins),         // PinCount
    MiniportPins,                       // Pins
    sizeof(PCNODE_DESCRIPTOR),          // NodeSize
    SIZEOF_ARRAY(MiniportNodes),        // NodeCount
    MiniportNodes,                      // Nodes
    SIZEOF_ARRAY(MiniportConnections),  // ConnectionCount
    MiniportConnections,                // Connections
    SIZEOF_ARRAY(MiniportCategories),   // CategoryCount
    MiniportCategories                  // Categories
};

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportDMusUART::GetDescription()
 *****************************************************************************
 * Gets the topology.
 */
STDMETHODIMP_(NTSTATUS)
CMiniportDMusUART::
GetDescription
(
    OUT     PPCFILTER_DESCRIPTOR *  OutFilterDescriptor
)
{
    PAGED_CODE();

    ASSERT(OutFilterDescriptor);

    _DbgPrintF(DEBUGLVL_BLAB,("GetDescription"));

    *OutFilterDescriptor = &MiniportFilterDescriptor;

    return STATUS_SUCCESS;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CreateMiniportDMusUART()
 *****************************************************************************
 * Creates a MPU-401 miniport driver for the adapter.  This uses a
 * macro from STDUNK.H to do all the work.
 */
NTSTATUS
CreateMiniportDMusUART
(
    OUT     PUNKNOWN *  Unknown,
    IN      REFCLSID,
    IN      PUNKNOWN    UnknownOuter    OPTIONAL,
    IN      POOL_TYPE   PoolType
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB, ("CreateMiniportDMusUART"));
    ASSERT(Unknown);

    STD_CREATE_BODY_(   CMiniportDMusUART,
                        Unknown,
                        UnknownOuter,
                        PoolType,
                        PMINIPORTDMUS);
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportDMusUART::ProcessResources()
 *****************************************************************************
 * Processes the resource list, setting up helper objects accordingly.
 */
NTSTATUS
CMiniportDMusUART::
ProcessResources
(
    IN      PRESOURCELIST   ResourceList
)
{
    PAGED_CODE();
    _DbgPrintF(DEBUGLVL_BLAB,("ProcessResources"));
    ASSERT(ResourceList);
    if (!ResourceList)
    {
        return STATUS_DEVICE_CONFIGURATION_ERROR;
    }
    //
    // Get counts for the types of resources.
    //
    ULONG   countIO     = ResourceList->NumberOfPorts();
    ULONG   countIRQ    = ResourceList->NumberOfInterrupts();
    ULONG   countDMA    = ResourceList->NumberOfDmas();
    ULONG   lengthIO    = ResourceList->FindTranslatedPort(0)->u.Port.Length;

#if (DBG)
    _DbgPrintF(DEBUGLVL_VERBOSE,("Starting MPU401 Port 0x%X",
        ResourceList->FindTranslatedPort(0)->u.Port.Start.LowPart) );
#endif

    NTSTATUS ntStatus = STATUS_SUCCESS;

    //
    // Make sure we have the expected number of resources.
    //
    if  (   (countIO != 1)
        ||  (countIRQ  > 1)
        ||  (countDMA != 0)
        ||  (lengthIO == 0)
        )
    {
        _DbgPrintF(DEBUGLVL_TERSE,("Unknown ResourceList configuraton"));
        ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
    }

    if (NT_SUCCESS(ntStatus))
    {
        //
        // Get the port address.
        //
        m_pPortBase =
            PUCHAR(ResourceList->FindTranslatedPort(0)->u.Port.Start.QuadPart);

        ntStatus = InitializeHardware(m_pInterruptSync,m_pPortBase);
    }

    return ntStatus;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportDMusUART::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.  This function works just like a COM QueryInterface
 * call and is used if the object is not being aggregated.
 */
STDMETHODIMP_(NTSTATUS)
CMiniportDMusUART::
NonDelegatingQueryInterface
(
    REFIID  Interface,
    PVOID * Object
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB, ("Miniport::NonDelegatingQueryInterface"));
    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface,IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(PMINIPORTDMUS(this)));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IMiniport))
    {
        *Object = PVOID(PMINIPORT(this));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IMiniportDMus))
    {
        *Object = PVOID(PMINIPORTDMUS(this));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IMusicTechnology))
    {
        *Object = PVOID(PMUSICTECHNOLOGY(this));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IPowerNotify))
    {
        *Object = PVOID(PPOWERNOTIFY(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        //
        // We reference the interface for the caller.
        //
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportDMusUART::~CMiniportDMusUART()
 *****************************************************************************
 * Destructor.
 */
CMiniportDMusUART::~CMiniportDMusUART(void)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB,("~CMiniportDMusUART"));

    ASSERT(0 == m_NumCaptureStreams);
    ASSERT(0 == m_NumRenderStreams);

    //  reset the HW so we don't get anymore interrupts
    if (m_UseIRQ && m_pInterruptSync)
    {
        (void) m_pInterruptSync->CallSynchronizedRoutine(InitMPU,PVOID(m_pPortBase));
    }
    else
    {
        (void) InitMPU(NULL,PVOID(m_pPortBase));
    }

    if (m_pInterruptSync)
    {
        m_pInterruptSync->Release();
        m_pInterruptSync = NULL;
    }
    if (m_pServiceGroup)
    {
        m_pServiceGroup->Release();
        m_pServiceGroup = NULL;
    }
    if (m_pPort)
    {
        m_pPort->Release();
        m_pPort = NULL;
    }
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportDMusUART::Init()
 *****************************************************************************
 * Initializes a the miniport.
 */
STDMETHODIMP_(NTSTATUS)
CMiniportDMusUART::
Init
(
    IN      PUNKNOWN        UnknownInterruptSync    OPTIONAL,
    IN      PRESOURCELIST   ResourceList,
    IN      PPORTDMUS       Port_,
    OUT     PSERVICEGROUP * ServiceGroup
)
{
    PAGED_CODE();

    ASSERT(ResourceList);
    if (!ResourceList)
    {
        return STATUS_DEVICE_CONFIGURATION_ERROR;
    }

    ASSERT(Port_);
    ASSERT(ServiceGroup);

    _DbgPrintF(DEBUGLVL_BLAB,("Init"));

    *ServiceGroup = NULL;
    m_pPortBase = 0;
    m_fMPUInitialized = FALSE;

    // This will remain unspecified if the miniport does not get any power
    // messages.
    //
    m_PowerState.DeviceState = PowerDeviceUnspecified;

    //
    // AddRef() is required because we are keeping this pointer.
    //
    m_pPort = Port_;
    m_pPort->AddRef();

    // Set dataformat.
    //
    if (IsEqualGUIDAligned(m_MusicFormatTechnology, GUID_NULL))
    {
        RtlCopyMemory(  &m_MusicFormatTechnology,
                        &KSMUSIC_TECHNOLOGY_PORT,
                        sizeof(GUID));
    }
    RtlCopyMemory(  &PinDataRangesStreamLegacy.Technology,
                    &m_MusicFormatTechnology,
                    sizeof(GUID));
    RtlCopyMemory(  &PinDataRangesStreamDMusic.Technology,
                    &m_MusicFormatTechnology,
                    sizeof(GUID));

    for (ULONG bufferCount = 0;bufferCount < kMPUInputBufferSize;bufferCount++)
    {
        m_MPUInputBuffer[bufferCount] = 0;
    }
    m_MPUInputBufferHead = 0;
    m_MPUInputBufferTail = 0;
    m_InputTimeStamp = 0;
    m_KSStateInput = KSSTATE_STOP;

    NTSTATUS ntStatus = STATUS_SUCCESS;

    m_NumRenderStreams = 0;
    m_NumCaptureStreams = 0;

    m_UseIRQ = TRUE;
    if (ResourceList->NumberOfInterrupts() == 0)
    {
        m_UseIRQ = FALSE;
    }

    ntStatus = PcNewServiceGroup(&m_pServiceGroup,NULL);
    if (NT_SUCCESS(ntStatus) && !m_pServiceGroup)   //  keep any error
    {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (NT_SUCCESS(ntStatus))
    {
        *ServiceGroup = m_pServiceGroup;
        m_pServiceGroup->AddRef();

        //
        // Register the service group with the port early so the port is
        // prepared to handle interrupts.
        //
        m_pPort->RegisterServiceGroup(m_pServiceGroup);
    }

    if (NT_SUCCESS(ntStatus) && m_UseIRQ)
    {
/*
        //
        //  Due to a bug in the InterruptSync design, we shouldn't share
        //  the interrupt sync object.  Whoever goes away first
        //  will disconnect it, and the other points off into nowhere.
        //
        //  Instead we generate our own interrupt sync object.
        //
        UnknownInterruptSync = NULL;
*/
        if (UnknownInterruptSync)
        {
            ntStatus =
                UnknownInterruptSync->QueryInterface
                (
                    IID_IInterruptSync,
                    (PVOID *) &m_pInterruptSync
                );

            if (!m_pInterruptSync && NT_SUCCESS(ntStatus))  //  keep any error
            {
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
            if (NT_SUCCESS(ntStatus))
            {                                                                           //  run this ISR first
                ntStatus = m_pInterruptSync->
                    RegisterServiceRoutine(DMusMPUInterruptServiceRoutine,PVOID(this),TRUE);
            }

        }
        else
        {   // create our own interruptsync mechanism.
            ntStatus =
                PcNewInterruptSync
                (
                    &m_pInterruptSync,
                    NULL,
                    ResourceList,
                    0,                          // Resource Index
                    InterruptSyncModeNormal     // Run ISRs once until we get SUCCESS
                );

            if (!m_pInterruptSync && NT_SUCCESS(ntStatus))    //  keep any error
            {
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            }

            if (NT_SUCCESS(ntStatus))
            {
                ntStatus = m_pInterruptSync->RegisterServiceRoutine(
                    DMusMPUInterruptServiceRoutine,
                    PVOID(this),
                    TRUE);          //  run this ISR first
            }
            if (NT_SUCCESS(ntStatus))
            {
                ntStatus = m_pInterruptSync->Connect();
            }
        }
    }

    if (NT_SUCCESS(ntStatus))
    {
        ntStatus = ProcessResources(ResourceList);
    }

    if (!NT_SUCCESS(ntStatus))
    {
        //
        // clean up our mess
        //

        // clean up the interrupt sync
        if( m_pInterruptSync )
        {
            m_pInterruptSync->Release();
            m_pInterruptSync = NULL;
        }

        // clean up the service group
        if( m_pServiceGroup )
        {
            m_pServiceGroup->Release();
            m_pServiceGroup = NULL;
        }

        // clean up the out param service group.
        if (*ServiceGroup)
        {
            (*ServiceGroup)->Release();
            (*ServiceGroup) = NULL;
        }

        // release the port
        m_pPort->Release();
        m_pPort = NULL;
    }

    return ntStatus;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportDMusUART::NewStream()
 *****************************************************************************
 * Gets the topology.
 */
STDMETHODIMP_(NTSTATUS)
CMiniportDMusUART::
NewStream
(
    OUT     PMXF                  * MXF,
    IN      PUNKNOWN                OuterUnknown    OPTIONAL,
    IN      POOL_TYPE               PoolType,
    IN      ULONG                   PinID,
    IN      DMUS_STREAM_TYPE        StreamType,
    IN      PKSDATAFORMAT           DataFormat,
    OUT     PSERVICEGROUP         * ServiceGroup,
    IN      PAllocatorMXF           AllocatorMXF,
    IN      PMASTERCLOCK            MasterClock,
    OUT     PULONGLONG              SchedulePreFetch
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB, ("NewStream"));
    NTSTATUS ntStatus = STATUS_SUCCESS;

    // In 100 ns, we want stuff as soon as it comes in
    //
    *SchedulePreFetch = 0;

    // if we don't have any streams already open, get the hardware ready.
    if ((!m_NumCaptureStreams) && (!m_NumRenderStreams))
    {
        ntStatus = ResetHardware(m_pPortBase);
        if (!NT_SUCCESS(ntStatus))
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("CMiniportDMusUART::NewStream ResetHardware failed"));
            return ntStatus;
        }
    }

    if  (   ((m_NumCaptureStreams < kMaxNumCaptureStreams)
            && (StreamType == DMUS_STREAM_MIDI_CAPTURE))
        ||  ((m_NumRenderStreams < kMaxNumLegacyRenderStreams + kMaxNumDMusicRenderStreams)
            && (StreamType == DMUS_STREAM_MIDI_RENDER))
        )
    {
        CMiniportDMusUARTStream *pStream =
            new(PoolType) CMiniportDMusUARTStream(OuterUnknown);

        if (pStream)
        {
            pStream->AddRef();

            ntStatus =
                pStream->Init(this,m_pPortBase,(StreamType == DMUS_STREAM_MIDI_CAPTURE),AllocatorMXF,MasterClock);

            if (NT_SUCCESS(ntStatus))
            {
                *MXF = PMXF(pStream);
                (*MXF)->AddRef();

                if (StreamType == DMUS_STREAM_MIDI_CAPTURE)
                {
                    m_NumCaptureStreams++;
                    *ServiceGroup = m_pServiceGroup;
                    (*ServiceGroup)->AddRef();
                }
                else
                {
                    m_NumRenderStreams++;
                    *ServiceGroup = NULL;
                }
            }

            pStream->Release();
        }
        else
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else
    {
        ntStatus = STATUS_INVALID_DEVICE_REQUEST;
        if (StreamType == DMUS_STREAM_MIDI_CAPTURE)
        {
            _DbgPrintF(DEBUGLVL_TERSE,("NewStream failed, too many capture streams"));
        }
        else if (StreamType == DMUS_STREAM_MIDI_RENDER)
        {
            _DbgPrintF(DEBUGLVL_TERSE,("NewStream failed, too many render streams"));
        }
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE,("NewStream invalid stream type"));
        }
    }

    return ntStatus;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportDMusUART::SetTechnology()
 *****************************************************************************
 * Sets pindatarange technology.
 */
STDMETHODIMP_(NTSTATUS)
CMiniportDMusUART::
SetTechnology
(
    IN      const GUID *            Technology
)
{
    PAGED_CODE();

    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;

    // Fail if miniport has already been initialized.
    //
    if (NULL == m_pPort)
    {
        RtlCopyMemory(&m_MusicFormatTechnology, Technology, sizeof(GUID));
        ntStatus = STATUS_SUCCESS;
    }

    return ntStatus;
} // SetTechnology

/*****************************************************************************
 * CMiniportDMusUART::PowerChangeNotify()
 *****************************************************************************
 * Handle power state change for the miniport.
 */
#pragma code_seg("PAGE")
STDMETHODIMP_(void)
CMiniportDMusUART::
PowerChangeNotify
(
    IN      POWER_STATE             PowerState
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE, ("CMiniportDMusUART::PoweChangeNotify D%d", PowerState.DeviceState));

    switch (PowerState.DeviceState)
    {
        case PowerDeviceD0:
            if (m_PowerState.DeviceState != PowerDeviceD0)
            {
                if (!NT_SUCCESS(InitializeHardware(m_pInterruptSync,m_pPortBase)))
                {
                    _DbgPrintF(DEBUGLVL_TERSE, ("InitializeHardware failed when resuming"));
                }
            }
            break;

        case PowerDeviceD1:
        case PowerDeviceD2:
        case PowerDeviceD3:
        default:
            break;
    }
    m_PowerState.DeviceState = PowerState.DeviceState;
} // PowerChangeNotify

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportDMusUARTStream::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.  This function works just like a COM QueryInterface
 * call and is used if the object is not being aggregated.
 */
STDMETHODIMP_(NTSTATUS)
CMiniportDMusUARTStream::
NonDelegatingQueryInterface
(
    REFIID  Interface,
    PVOID * Object
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB,("Stream::NonDelegatingQueryInterface"));
    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface,IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(this));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IMXF))
    {
        *Object = PVOID(PMXF(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        //
        // We reference the interface for the caller.
        //
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportDMusUARTStream::~CMiniportDMusUARTStream()
 *****************************************************************************
 * Destructs a stream.
 */
CMiniportDMusUARTStream::~CMiniportDMusUARTStream(void)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB,("~CMiniportDMusUARTStream"));

    KeCancelTimer(&m_TimerEvent);

    if (m_DMKEvtQueue)
    {
        if (m_AllocatorMXF)
        {
            m_AllocatorMXF->PutMessage(m_DMKEvtQueue);
        }
        else
        {
            _DbgPrintF(DEBUGLVL_ERROR,("~CMiniportDMusUARTStream, no allocator, can't flush DMKEvts"));
        }
        m_DMKEvtQueue = NULL;
    }
    if (m_AllocatorMXF)
    {
        m_AllocatorMXF->Release();
        m_AllocatorMXF = NULL;
    }

    if (m_pMiniport)
    {
        if (m_fCapture)
        {
            m_pMiniport->m_NumCaptureStreams--;
        }
        else
        {
            m_pMiniport->m_NumRenderStreams--;
        }

        m_pMiniport->Release();
    }
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportDMusUARTStream::Init()
 *****************************************************************************
 * Initializes a stream.
 */
STDMETHODIMP_(NTSTATUS)
CMiniportDMusUARTStream::
Init
(
    IN      CMiniportDMusUART * pMiniport,
    IN      PUCHAR              pPortBase,
    IN      BOOLEAN             fCapture,
    IN      PAllocatorMXF       allocatorMXF,
    IN      PMASTERCLOCK        masterClock
)
{
    PAGED_CODE();

    ASSERT(pMiniport);
    ASSERT(pPortBase);

    _DbgPrintF(DEBUGLVL_BLAB,("Init"));

    m_NumFailedMPUTries = 0;
    m_TimerQueued = FALSE;
    KeInitializeSpinLock(&m_DpcSpinLock);
    m_pMiniport = pMiniport;
    m_pMiniport->AddRef();

    pMiniport->m_MasterClock = masterClock;

    m_pPortBase = pPortBase;
    m_fCapture = fCapture;

    m_SnapshotTimeStamp = 0;
    m_DMKEvtQueue = NULL;
    m_DMKEvtOffset = 0;

    m_NumberOfRetries = 0;

    if (allocatorMXF)
    {
        allocatorMXF->AddRef();
        m_AllocatorMXF = allocatorMXF;
        m_sinkMXF = m_AllocatorMXF;
    }
    else
    {
        return STATUS_INVALID_PARAMETER;
    }

    KeInitializeDpc
    (
        &m_Dpc,
        &::DMusUARTTimerDPC,
        PVOID(this)
    );
    KeInitializeTimer(&m_TimerEvent);

    return STATUS_SUCCESS;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportDMusUARTStream::SetState()
 *****************************************************************************
 * Sets the state of the channel.
 */
STDMETHODIMP_(NTSTATUS)
CMiniportDMusUARTStream::
SetState
(
    IN      KSSTATE     NewState
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE,("SetState %d",NewState));

    if (NewState == KSSTATE_RUN)
    {
        if (m_pMiniport->m_fMPUInitialized)
        {
            LARGE_INTEGER timeDue100ns;
            timeDue100ns.QuadPart = 0;
            KeSetTimer(&m_TimerEvent,timeDue100ns,&m_Dpc);
        }
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("CMiniportDMusUARTStream::SetState KSSTATE_RUN failed due to uninitialized MPU"));
            return STATUS_INVALID_DEVICE_STATE;
        }
    }

    if (m_fCapture)
    {
        m_pMiniport->m_KSStateInput = NewState;
        if (NewState == KSSTATE_STOP)   //  STOPping
        {
            m_pMiniport->m_MPUInputBufferHead = 0;   // Previously read bytes are discarded.
            m_pMiniport->m_MPUInputBufferTail = 0;   // The entire FIFO is available.
        }
    }
    return STATUS_SUCCESS;
}

#pragma code_seg()
/*****************************************************************************
 * CMiniportDMusUART::Service()
 *****************************************************************************
 * DPC-mode service call from the port.
 */
STDMETHODIMP_(void)
CMiniportDMusUART::
Service
(   void
)
{
    _DbgPrintF(DEBUGLVL_BLAB, ("Service"));
    if (!m_NumCaptureStreams)
    {
        //  we should never get here....
        //  if we do, we must have read some trash,
        //  so just reset the input FIFO
        m_MPUInputBufferTail = m_MPUInputBufferHead = 0;
    }
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportDMusUARTStream::ConnectOutput()
 *****************************************************************************
 * Writes outgoing MIDI data.
 */
NTSTATUS
CMiniportDMusUARTStream::
ConnectOutput(PMXF sinkMXF)
{
    PAGED_CODE();

    if (m_fCapture)
    {
        if ((sinkMXF) && (m_sinkMXF == m_AllocatorMXF))
        {
            _DbgPrintF(DEBUGLVL_BLAB, ("ConnectOutput"));
            m_sinkMXF = sinkMXF;
            return STATUS_SUCCESS;
        }
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("ConnectOutput failed"));
        }
    }
    else
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("ConnectOutput called on renderer; failed"));
    }
    return STATUS_UNSUCCESSFUL;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportDMusUARTStream::DisconnectOutput()
 *****************************************************************************
 * Writes outgoing MIDI data.
 */
NTSTATUS
CMiniportDMusUARTStream::
DisconnectOutput(PMXF sinkMXF)
{
    PAGED_CODE();

    if (m_fCapture)
    {
        if ((m_sinkMXF == sinkMXF) || (!sinkMXF))
        {
            _DbgPrintF(DEBUGLVL_BLAB, ("DisconnectOutput"));
            m_sinkMXF = m_AllocatorMXF;
            return STATUS_SUCCESS;
        }
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("DisconnectOutput failed"));
        }
    }
    else
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("DisconnectOutput called on renderer; failed"));
    }
    return STATUS_UNSUCCESSFUL;
}

#pragma code_seg()
/*****************************************************************************
 * CMiniportDMusUARTStream::PutMessageLocked()
 *****************************************************************************
 * Now that the spinlock is held, add this message to the queue.
 *
 * Writes an outgoing MIDI message.
 * We don't sort a new message into the queue -- we append it.
 * This is fine, since the sequencer feeds us sequenced data.
 * Timestamps will ascend by design.
 */
NTSTATUS CMiniportDMusUARTStream::PutMessageLocked(PDMUS_KERNEL_EVENT pDMKEvt)
{
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    PDMUS_KERNEL_EVENT  aDMKEvt;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    if (!m_fCapture)
    {
        _DbgPrintF(DEBUGLVL_BLAB, ("PutMessage to render stream"));
        if (pDMKEvt)
        {
            // m_DpcSpinLock already held

            if (m_DMKEvtQueue)
            {
                aDMKEvt = m_DMKEvtQueue;            //  put pDMKEvt in event queue

                while (aDMKEvt->pNextEvt)
                {
                    aDMKEvt = aDMKEvt->pNextEvt;
                }
                aDMKEvt->pNextEvt = pDMKEvt;        //  here is end of queue
            }
            else                                    //  currently nothing in queue
            {
                m_DMKEvtQueue = pDMKEvt;
                if (m_DMKEvtOffset)
                {
                    _DbgPrintF(DEBUGLVL_ERROR, ("PutMessage  Nothing in the queue, but m_DMKEvtOffset == %d",m_DMKEvtOffset));
                    m_DMKEvtOffset = 0;
                }
            }

            // m_DpcSpinLock already held
        }
        if (!m_TimerQueued)
        {
            (void) ConsumeEvents();
        }
    }
    else    //  capture
    {
        _DbgPrintF(DEBUGLVL_BLAB, ("PutMessage to capture stream"));
        ASSERT(NULL == pDMKEvt);

        SourceEvtsToPort();
    }
    return ntStatus;
}

#pragma code_seg()
/*****************************************************************************
 * CMiniportDMusUARTStream::PutMessage()
 *****************************************************************************
 * Writes an outgoing MIDI message.
 * We don't sort a new message into the queue -- we append it.
 * This is fine, since the sequencer feeds us sequenced data.
 * Timestamps will ascend by design.
 */
NTSTATUS CMiniportDMusUARTStream::PutMessage(PDMUS_KERNEL_EVENT pDMKEvt)
{
    NTSTATUS            ntStatus = STATUS_SUCCESS;
    PDMUS_KERNEL_EVENT  aDMKEvt;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    if (!m_fCapture)
    {
        _DbgPrintF(DEBUGLVL_BLAB, ("PutMessage to render stream"));
        if (pDMKEvt)
        {
            KeAcquireSpinLockAtDpcLevel(&m_DpcSpinLock);

            if (m_DMKEvtQueue)
            {
                aDMKEvt = m_DMKEvtQueue;            //  put pDMKEvt in event queue

                while (aDMKEvt->pNextEvt)
                {
                    aDMKEvt = aDMKEvt->pNextEvt;
                }
                aDMKEvt->pNextEvt = pDMKEvt;        //  here is end of queue
            }
            else                                    //  currently nothing in queue
            {
                m_DMKEvtQueue = pDMKEvt;
                if (m_DMKEvtOffset)
                {
                    _DbgPrintF(DEBUGLVL_ERROR, ("PutMessage  Nothing in the queue, but m_DMKEvtOffset == %d",m_DMKEvtOffset));
                    m_DMKEvtOffset = 0;
                }
            }

            KeReleaseSpinLockFromDpcLevel(&m_DpcSpinLock);
        }
        if (!m_TimerQueued)
        {
            (void) ConsumeEvents();
        }
    }
    else    //  capture
    {
        _DbgPrintF(DEBUGLVL_BLAB, ("PutMessage to capture stream"));
        ASSERT(NULL == pDMKEvt);

        SourceEvtsToPort();
    }
    return ntStatus;
}

#pragma code_seg()
/*****************************************************************************
 * CMiniportDMusUARTStream::ConsumeEvents()
 *****************************************************************************
 * Attempts to empty the render message queue.
 * Called either from DPC timer or upon IRP submittal.
//  TODO: support packages right
//  process the package (actually, should do this above.
//  treat the package as a list fragment that shouldn't be sorted.
//  better yet, go through each event in the package, and when
//  an event is exhausted, delete it and decrement m_offset.
 */
NTSTATUS CMiniportDMusUARTStream::ConsumeEvents(void)
{
    PDMUS_KERNEL_EVENT aDMKEvt;

    NTSTATUS        ntStatus = STATUS_SUCCESS;
    ULONG           bytesRemaining = 0,bytesWritten = 0;
    LARGE_INTEGER   aMillisecIn100ns;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    KeAcquireSpinLockAtDpcLevel(&m_DpcSpinLock);

    m_TimerQueued = FALSE;
    while (m_DMKEvtQueue)                   //  do we have anything to play at all?
    {
        aDMKEvt = m_DMKEvtQueue;                            //  event we try to play
        if (aDMKEvt->cbEvent)
        {
            bytesRemaining = aDMKEvt->cbEvent - m_DMKEvtOffset; //  number of bytes left in this evt

            ASSERT(bytesRemaining > 0);
            if (bytesRemaining <= 0)
            {
                bytesRemaining = aDMKEvt->cbEvent;
            }

            if (aDMKEvt->cbEvent <= sizeof(PBYTE))                //  short message
            {
                _DbgPrintF(DEBUGLVL_BLAB, ("ConsumeEvents(%02x%02x%02x%02x)",aDMKEvt->uData.abData[0],aDMKEvt->uData.abData[1],aDMKEvt->uData.abData[2],aDMKEvt->uData.abData[3]));
                ntStatus = Write(aDMKEvt->uData.abData + m_DMKEvtOffset,bytesRemaining,&bytesWritten);
            }
            else if (PACKAGE_EVT(aDMKEvt))
            {
                ASSERT(m_DMKEvtOffset == 0);
                m_DMKEvtOffset = 0;
                _DbgPrintF(DEBUGLVL_BLAB, ("ConsumeEvents(Package)"));

                ntStatus = PutMessageLocked(aDMKEvt->uData.pPackageEvt);  // we already own the spinlock

                // null this because we are about to throw it in the allocator
                aDMKEvt->uData.pPackageEvt = NULL;
                aDMKEvt->cbEvent = 0;
                bytesWritten = bytesRemaining;
            }
            else                //  SysEx message
            {
                _DbgPrintF(DEBUGLVL_BLAB, ("ConsumeEvents(%02x%02x%02x%02x)",aDMKEvt->uData.pbData[0],aDMKEvt->uData.pbData[1],aDMKEvt->uData.pbData[2],aDMKEvt->uData.pbData[3]));

                ntStatus = Write(aDMKEvt->uData.pbData + m_DMKEvtOffset,bytesRemaining,&bytesWritten);
            }
        }   //  if (aDMKEvt->cbEvent)
        if (STATUS_SUCCESS != ntStatus)
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("ConsumeEvents: Write returned 0x%08x",ntStatus));
            bytesWritten = bytesRemaining;  //  just bail on this event and try next time
        }

        ASSERT(bytesWritten <= bytesRemaining);
        if (bytesWritten == bytesRemaining)
        {
            m_DMKEvtQueue = m_DMKEvtQueue->pNextEvt;
            aDMKEvt->pNextEvt = NULL;

            m_AllocatorMXF->PutMessage(aDMKEvt);    //  throw back in free pool
            m_DMKEvtOffset = 0;                     //  start fresh on next evt
            m_NumberOfRetries = 0;
        }           //  but wait ... there's more!
        else        //  our FIFO is full for now.
        {
            //  update our offset by that amount we did write
            m_DMKEvtOffset += bytesWritten;
            ASSERT(m_DMKEvtOffset < aDMKEvt->cbEvent);

            _DbgPrintF(DEBUGLVL_BLAB,("ConsumeEvents tried %d, wrote %d, at offset %d",bytesRemaining,bytesWritten,m_DMKEvtOffset));
            aMillisecIn100ns.QuadPart = -(kOneMillisec);    //  set timer, come back later
            m_TimerQueued = TRUE;
            m_NumberOfRetries++;
            ntStatus = KeSetTimer( &m_TimerEvent, aMillisecIn100ns, &m_Dpc );
            break;
        }   //  we didn't write it all
    }       //  go back, Jack, do it again (while m_DMKEvtQueue)
    KeReleaseSpinLockFromDpcLevel(&m_DpcSpinLock);
    return ntStatus;
}

#pragma code_seg()
/*****************************************************************************
 * CMiniportDMusUARTStream::HandlePortParams()
 *****************************************************************************
 * Writes an outgoing MIDI message.
 */
NTSTATUS
CMiniportDMusUARTStream::
HandlePortParams
(
    IN      PPCPROPERTY_REQUEST     pRequest
)
{
    PAGED_CODE();

    NTSTATUS ntStatus;

    if (pRequest->Verb & KSPROPERTY_TYPE_SET)
    {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    ntStatus = ValidatePropertyRequest(pRequest, sizeof(SYNTH_PORTPARAMS), TRUE);
    if (NT_SUCCESS(ntStatus))
    {
        RtlCopyMemory(pRequest->Value, pRequest->Instance, sizeof(SYNTH_PORTPARAMS));

        PSYNTH_PORTPARAMS Params = (PSYNTH_PORTPARAMS)pRequest->Value;

        if (Params->ValidParams & ~SYNTH_PORTPARAMS_CHANNELGROUPS)
        {
            Params->ValidParams &= SYNTH_PORTPARAMS_CHANNELGROUPS;
        }

        if (!(Params->ValidParams & SYNTH_PORTPARAMS_CHANNELGROUPS))
        {
            Params->ChannelGroups = 1;
        }
        else if (Params->ChannelGroups != 1)
        {
            Params->ChannelGroups = 1;
        }

        pRequest->ValueSize = sizeof(SYNTH_PORTPARAMS);
    }

    return ntStatus;
}

#pragma code_seg()
/*****************************************************************************
 * DMusTimerDPC()
 *****************************************************************************
 * The timer DPC callback. Thunks to a C++ member function.
 * This is called by the OS in response to the DirectMusic pin
 * wanting to wakeup later to process more DirectMusic stuff.
 */
VOID
NTAPI
DMusUARTTimerDPC
(
    IN  PKDPC   Dpc,
    IN  PVOID   DeferredContext,
    IN  PVOID   SystemArgument1,
    IN  PVOID   SystemArgument2
)
{
    ASSERT(DeferredContext);

    CMiniportDMusUARTStream *aStream;
    aStream = (CMiniportDMusUARTStream *) DeferredContext;
    if (aStream)
    {
        _DbgPrintF(DEBUGLVL_BLAB,("DMusUARTTimerDPC"));
        if (false == aStream->m_fCapture)
        {
            (void) aStream->ConsumeEvents();
        }
        //  ignores return value!
    }
}

/*****************************************************************************
 * DirectMusic properties
 ****************************************************************************/

#pragma code_seg("PAGE")
/*
 *  Properties concerning synthesizer functions.
 */
const WCHAR wszDescOut[] = L"DMusic MPU-401 Out ";
const WCHAR wszDescIn[] = L"DMusic MPU-401 In ";

NTSTATUS PropertyHandler_Synth
(
    IN      PPCPROPERTY_REQUEST     pRequest
)
{
    NTSTATUS    ntStatus;

    PAGED_CODE();

    if (pRequest->Verb & KSPROPERTY_TYPE_BASICSUPPORT)
    {
        ntStatus = ValidatePropertyRequest(pRequest, sizeof(ULONG), TRUE);
        if (NT_SUCCESS(ntStatus))
        {
            // if return buffer can hold a ULONG, return the access flags
            PULONG AccessFlags = PULONG(pRequest->Value);

            *AccessFlags = KSPROPERTY_TYPE_BASICSUPPORT;
            switch (pRequest->PropertyItem->Id)
            {
                case KSPROPERTY_SYNTH_CAPS:
                case KSPROPERTY_SYNTH_CHANNELGROUPS:
                    *AccessFlags |= KSPROPERTY_TYPE_GET;
            }
            switch (pRequest->PropertyItem->Id)
            {
                case KSPROPERTY_SYNTH_CHANNELGROUPS:
                    *AccessFlags |= KSPROPERTY_TYPE_SET;
            }
            ntStatus = STATUS_SUCCESS;
            pRequest->ValueSize = sizeof(ULONG);

            switch (pRequest->PropertyItem->Id)
            {
                case KSPROPERTY_SYNTH_PORTPARAMETERS:
                    if (pRequest->MinorTarget)
                    {
                        *AccessFlags |= KSPROPERTY_TYPE_GET;
                    }
                    else
                    {
                        pRequest->ValueSize = 0;
                        ntStatus = STATUS_INVALID_DEVICE_REQUEST;
                    }
            }
        }
    }
    else
    {
        ntStatus = STATUS_SUCCESS;
        switch(pRequest->PropertyItem->Id)
        {
            case KSPROPERTY_SYNTH_CAPS:
                _DbgPrintF(DEBUGLVL_VERBOSE,("PropertyHandler_Synth:KSPROPERTY_SYNTH_CAPS"));

                if (pRequest->Verb & KSPROPERTY_TYPE_SET)
                {
                    ntStatus = STATUS_INVALID_DEVICE_REQUEST;
                }

                if (NT_SUCCESS(ntStatus))
                {
                    ntStatus = ValidatePropertyRequest(pRequest, sizeof(SYNTHCAPS), TRUE);

                    if (NT_SUCCESS(ntStatus))
                    {
                        SYNTHCAPS *caps = (SYNTHCAPS*)pRequest->Value;
                        int increment;
                        RtlZeroMemory(caps, sizeof(SYNTHCAPS));
                        // XXX Different guids for different instances!
                        //
                        if (pRequest->Node == eSynthNode)
                        {
                            increment = sizeof(wszDescOut) - 2;
                            RtlCopyMemory( caps->Description,wszDescOut,increment);
                            caps->Guid           = CLSID_MiniportDriverDMusUART;
                        }
                        else
                        {
                            increment = sizeof(wszDescIn) - 2;
                            RtlCopyMemory( caps->Description,wszDescIn,increment);
                            caps->Guid           = CLSID_MiniportDriverDMusUARTCapture;
                        }

                        caps->Flags              = SYNTH_PC_EXTERNAL;
                        caps->MemorySize         = 0;
                        caps->MaxChannelGroups   = 1;
                        caps->MaxVoices          = 0xFFFFFFFF;
                        caps->MaxAudioChannels   = 0xFFFFFFFF;

                        caps->EffectFlags        = 0;

                        CMiniportDMusUART *aMiniport;
                        ASSERT(pRequest->MajorTarget);
                        aMiniport = (CMiniportDMusUART *)(PMINIPORTDMUS)(pRequest->MajorTarget);
                        WCHAR wszDesc2[16];
                        int cLen;
                        cLen = swprintf(wszDesc2,L"[%03X]\0",aMiniport->m_pPortBase);

                        cLen *= sizeof(WCHAR);
                        RtlCopyMemory((WCHAR *)((DWORD_PTR)(caps->Description) + increment),
                                       wszDesc2,
                                       cLen);


                        pRequest->ValueSize = sizeof(SYNTHCAPS);
                    }
                }

                break;

             case KSPROPERTY_SYNTH_PORTPARAMETERS:
                _DbgPrintF(DEBUGLVL_VERBOSE,("PropertyHandler_Synth:KSPROPERTY_SYNTH_PORTPARAMETERS"));

                CMiniportDMusUARTStream *aStream;

                aStream = (CMiniportDMusUARTStream*)(pRequest->MinorTarget);
                if (aStream)
                {
                    ntStatus = aStream->HandlePortParams(pRequest);
                }
                else
                {
                    ntStatus = STATUS_INVALID_DEVICE_REQUEST;
                }
                break;

            case KSPROPERTY_SYNTH_CHANNELGROUPS:
                _DbgPrintF(DEBUGLVL_VERBOSE,("PropertyHandler_Synth:KSPROPERTY_SYNTH_CHANNELGROUPS"));

                ntStatus = ValidatePropertyRequest(pRequest, sizeof(ULONG), TRUE);
                if (NT_SUCCESS(ntStatus))
                {
                    *(PULONG)(pRequest->Value) = 1;
                    pRequest->ValueSize = sizeof(ULONG);
                }
                break;

            case KSPROPERTY_SYNTH_LATENCYCLOCK:
                _DbgPrintF(DEBUGLVL_VERBOSE,("PropertyHandler_Synth:KSPROPERTY_SYNTH_LATENCYCLOCK"));

                if(pRequest->Verb & KSPROPERTY_TYPE_SET)
                {
                    ntStatus = STATUS_INVALID_DEVICE_REQUEST;
                }
                else
                {
                    ntStatus = ValidatePropertyRequest(pRequest, sizeof(ULONGLONG), TRUE);
                    if(NT_SUCCESS(ntStatus))
                    {
                        REFERENCE_TIME rtLatency;
                        CMiniportDMusUARTStream *aStream;

                        aStream = (CMiniportDMusUARTStream*)(pRequest->MinorTarget);
                        if(aStream == NULL)
                        {
                            ntStatus = STATUS_INVALID_DEVICE_REQUEST;
                        }
                        else
                        {
                            aStream->m_pMiniport->m_MasterClock->GetTime(&rtLatency);
                            *((PULONGLONG)pRequest->Value) = rtLatency;
                            pRequest->ValueSize = sizeof(ULONGLONG);
                        }
                    }
                }
                break;

            default:
                _DbgPrintF(DEBUGLVL_TERSE,("Unhandled property in PropertyHandler_Synth"));
                break;
        }
    }
    return ntStatus;
}

/*****************************************************************************
 * ValidatePropertyRequest()
 *****************************************************************************
 * Validates pRequest.
 *  Checks if the ValueSize is valid
 *  Checks if the Value is valid
 *
 *  This does not update pRequest->ValueSize if it returns NT_SUCCESS.
 *  Caller must set pRequest->ValueSize in case of NT_SUCCESS.
 */
NTSTATUS ValidatePropertyRequest
(
    IN      PPCPROPERTY_REQUEST     pRequest,
    IN      ULONG                   ulValueSize,
    IN      BOOLEAN                 fValueRequired
)
{
    NTSTATUS    ntStatus;

    if (pRequest->ValueSize >= ulValueSize)
    {
        if (fValueRequired && NULL == pRequest->Value)
        {
            ntStatus = STATUS_INVALID_PARAMETER;
        }
        else
        {
            ntStatus = STATUS_SUCCESS;
        }
    }
    else  if (0 == pRequest->ValueSize)
    {
        ntStatus = STATUS_BUFFER_OVERFLOW;
    }
    else
    {
        ntStatus = STATUS_BUFFER_TOO_SMALL;
    }

    if (STATUS_BUFFER_OVERFLOW == ntStatus)
    {
        pRequest->ValueSize = ulValueSize;
    }
    else
    {
        pRequest->ValueSize = 0;
    }

    return ntStatus;
} // ValidatePropertyRequest

#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\miniport\dmusuart\mpu.cpp ===
/*****************************************************************************
 * MPU.cpp - UART miniport implementation
 *****************************************************************************
 * Copyright (c) 1998-2000 Microsoft Corporation.  All rights reserved.
 *
 *      Sept 98    MartinP .
 */

#include "private.h"
#include "ksdebug.h"

#define STR_MODULENAME "DMusUART:MPU: "

#define UartFifoOkForWrite(status)  ((status & MPU401_DRR) == 0)
#define UartFifoOkForRead(status)   ((status & MPU401_DSR) == 0)

typedef struct
{
    CMiniportDMusUART  *Miniport;
    PUCHAR              PortBase;
    PVOID               BufferAddress;
    ULONG               Length;
    PULONG              BytesRead;
}
SYNCWRITECONTEXT, *PSYNCWRITECONTEXT;

BOOLEAN  TryMPU(IN PUCHAR PortBase);
NTSTATUS WriteMPU(IN PUCHAR PortBase,IN BOOLEAN IsCommand,IN UCHAR Value);

#pragma code_seg("PAGE")
//  make sure we're in UART mode
NTSTATUS ResetHardware(PUCHAR portBase)
{
    PAGED_CODE();

    return WriteMPU(portBase,COMMAND,MPU401_CMD_UART);
}

#pragma code_seg("PAGE")
//
// We initialize the UART with interrupts suppressed so we don't
// try to service the chip prematurely.
//
NTSTATUS CMiniportDMusUART::InitializeHardware(PINTERRUPTSYNC interruptSync,PUCHAR portBase)
{
    PAGED_CODE();

    NTSTATUS    ntStatus;
    if (m_UseIRQ)
    {
        ntStatus = interruptSync->CallSynchronizedRoutine(InitMPU,PVOID(portBase));
    }
    else
    {
        ntStatus = InitMPU(NULL,PVOID(portBase));
    }

    if (NT_SUCCESS(ntStatus))
    {
        //
        // Start the UART (this should trigger an interrupt).
        //
        ntStatus = ResetHardware(portBase);
    }
    else
    {
        _DbgPrintF(DEBUGLVL_TERSE,("*** InitMPU returned with ntStatus 0x%08x ***",ntStatus));
    }

    m_fMPUInitialized = NT_SUCCESS(ntStatus);

    return ntStatus;
}

#pragma code_seg()
/*****************************************************************************
 * InitMPU()
 *****************************************************************************
 * Synchronized routine to initialize the MPU401.
 */
NTSTATUS
InitMPU
(
    IN      PINTERRUPTSYNC  InterruptSync,
    IN      PVOID           DynamicContext
)
{
    _DbgPrintF(DEBUGLVL_BLAB, ("InitMPU"));
    if (!DynamicContext)
    {
        return STATUS_INVALID_PARAMETER_2;
    }
        
    PUCHAR      portBase = PUCHAR(DynamicContext);
    UCHAR       status;
    ULONGLONG   startTime;
    BOOLEAN     success;
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    
    //
    // Reset the card (puts it into "smart mode")
    //
    ntStatus = WriteMPU(portBase,COMMAND,MPU401_CMD_RESET);

    // wait for the acknowledgement
    // NOTE: When the Ack arrives, it will trigger an interrupt.  
    //       Normally the DPC routine would read in the ack byte and we
    //       would never see it, however since we have the hardware locked (HwEnter),
    //       we can read the port before the DPC can and thus we receive the Ack.
    startTime = PcGetTimeInterval(0);
    success = FALSE;
    while(PcGetTimeInterval(startTime) < GTI_MILLISECONDS(50))
    {
        status = READ_PORT_UCHAR(portBase + MPU401_REG_STATUS);
        
        if (UartFifoOkForRead(status))                      // Is data waiting?
        {
            READ_PORT_UCHAR(portBase + MPU401_REG_DATA);    // yep.. read ACK 
            success = TRUE;                                 // don't need to do more 
            break;
        }
        KeStallExecutionProcessor(25);  //  microseconds
    }
#if (DBG)
    if (!success)
    {
        _DbgPrintF(DEBUGLVL_VERBOSE,("First attempt to reset the MPU didn't get ACKed.\n"));
    }
#endif  //  (DBG)

    // NOTE: We cannot check the ACK byte because if the card was already in
    // UART mode it will not send an ACK but it will reset.

    // reset the card again
    (void) WriteMPU(portBase,COMMAND,MPU401_CMD_RESET);

                                    // wait for ack (again)
    startTime = PcGetTimeInterval(0); // This might take a while
    BYTE dataByte = 0;
    success = FALSE;
    while (PcGetTimeInterval(startTime) < GTI_MILLISECONDS(50))
    {
        status = READ_PORT_UCHAR(portBase + MPU401_REG_STATUS);
        if (UartFifoOkForRead(status))                              // Is data waiting?
        {
            dataByte = READ_PORT_UCHAR(portBase + MPU401_REG_DATA); // yep.. read ACK
            success = TRUE;                                         // don't need to do more
            break;
        }
        KeStallExecutionProcessor(25);
    }

    if ((0xFE != dataByte) || !success)   // Did we succeed? If no second ACK, something is hosed  
    {                       
        _DbgPrintF(DEBUGLVL_TERSE,("Second attempt to reset the MPU didn't get ACKed.\n"));
        _DbgPrintF(DEBUGLVL_TERSE,("Init Reset failure error. Ack = %X", ULONG(dataByte) ) );
        ntStatus = STATUS_IO_DEVICE_ERROR;
    }
    
    return ntStatus;
}

#pragma code_seg()
/*****************************************************************************
 * CMiniportDMusUARTStream::Write()
 *****************************************************************************
 * Writes outgoing MIDI data.
 */
STDMETHODIMP_(NTSTATUS)
CMiniportDMusUARTStream::
Write
(
    IN      PVOID       BufferAddress,
    IN      ULONG       Length,
    OUT     PULONG      BytesWritten
)
{
    _DbgPrintF(DEBUGLVL_BLAB, ("Write"));
    ASSERT(BytesWritten);
    if (!BufferAddress)
    {
        Length = 0;
    }

    NTSTATUS ntStatus = STATUS_SUCCESS;

    if (!m_fCapture)
    {
        PUCHAR  pMidiData;
        ULONG   count;

        count = 0;
        pMidiData = PUCHAR(BufferAddress);

        if (Length)
        {
            SYNCWRITECONTEXT context;
            context.Miniport        = (m_pMiniport);
            context.PortBase        = m_pPortBase;
            context.BufferAddress   = pMidiData;
            context.Length          = Length;
            context.BytesRead       = &count;

            if (m_pMiniport->m_UseIRQ)
            {
                ntStatus = m_pMiniport->m_pInterruptSync->
                                CallSynchronizedRoutine(SynchronizedDMusMPUWrite,PVOID(&context));
            }
            else    //  !m_UseIRQ
            {
                ntStatus = SynchronizedDMusMPUWrite(NULL,PVOID(&context));
            }       //  !m_UseIRQ

            if (count == 0)
            {
                m_NumFailedMPUTries++;
                if (m_NumFailedMPUTries >= 100)
                {
                    ntStatus = STATUS_IO_DEVICE_ERROR;
                    m_NumFailedMPUTries = 0;
                }
            }
            else
            {
                m_NumFailedMPUTries = 0;
            }
        }           //  if we have data at all
        *BytesWritten = count;
    }
    else    //  called write on the read stream
    {
        ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    }
    return ntStatus;
}

#pragma code_seg()
/*****************************************************************************
 * SynchronizedDMusMPUWrite()
 *****************************************************************************
 * Writes outgoing MIDI data.
 */
NTSTATUS
SynchronizedDMusMPUWrite
(
    IN      PINTERRUPTSYNC  InterruptSync,
    IN      PVOID           syncWriteContext
)
{
    PSYNCWRITECONTEXT context;
    context = (PSYNCWRITECONTEXT)syncWriteContext;
    ASSERT(context->Miniport);
    ASSERT(context->PortBase);
    ASSERT(context->BufferAddress);
    ASSERT(context->Length);
    ASSERT(context->BytesRead);

    PUCHAR  pChar = PUCHAR(context->BufferAddress);
    NTSTATUS ntStatus,readStatus;
    ntStatus = STATUS_SUCCESS;
    //
    // while we're not there yet, and
    // while we don't have to wait on an aligned byte (including 0)
    // (we never wait on a byte.  Better to come back later)
    readStatus = DMusMPUInterruptServiceRoutine(InterruptSync,PVOID(context->Miniport));
    while (  (*(context->BytesRead) < context->Length)
          && (  TryMPU(context->PortBase) 
             || (*(context->BytesRead)%3)
          )  )
    {
        ntStatus = WriteMPU(context->PortBase,DATA,*pChar);
        if (NT_SUCCESS(ntStatus))
        {
            pChar++;
            *(context->BytesRead) = *(context->BytesRead) + 1;
//            readStatus = DMusMPUInterruptServiceRoutine(InterruptSync,PVOID(context->Miniport));
        }
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE,("SynchronizedDMusMPUWrite failed (0x%08x)",ntStatus));
            break;
        }
    }
    readStatus = DMusMPUInterruptServiceRoutine(InterruptSync,PVOID(context->Miniport));
    return ntStatus;
}

#define kMPUPollTimeout 2

#pragma code_seg()
/*****************************************************************************
 * TryMPU()
 *****************************************************************************
 * See if the MPU401 is free.
 */
BOOLEAN
TryMPU
(
    IN      PUCHAR      PortBase
)
{
    BOOLEAN success;
    USHORT  numPolls;
    UCHAR   status;

    _DbgPrintF(DEBUGLVL_BLAB, ("TryMPU"));
    numPolls = 0;

    while (numPolls < kMPUPollTimeout)
    {
        status = READ_PORT_UCHAR(PortBase + MPU401_REG_STATUS);
                                       
        if (UartFifoOkForWrite(status)) // Is this a good time to write data?
        {
            break;
        }
        numPolls++;
    }
    if (numPolls >= kMPUPollTimeout)
    {
        success = FALSE;
        _DbgPrintF(DEBUGLVL_BLAB, ("TryMPU failed"));
    }
    else
    {
        success = TRUE;
    }

    return success;
}

#pragma code_seg()
/*****************************************************************************
 * WriteMPU()
 *****************************************************************************
 * Write a byte out to the MPU401.
 */
NTSTATUS
WriteMPU
(
    IN      PUCHAR      PortBase,
    IN      BOOLEAN     IsCommand,
    IN      UCHAR       Value
)
{
    _DbgPrintF(DEBUGLVL_BLAB, ("WriteMPU"));
    NTSTATUS ntStatus = STATUS_IO_DEVICE_ERROR;

    if (!PortBase)
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("O: PortBase is zero\n"));
        return ntStatus;
    }
    PUCHAR deviceAddr = PortBase + MPU401_REG_DATA;

    if (IsCommand)
    {
        deviceAddr = PortBase + MPU401_REG_COMMAND;
    }

    ULONGLONG startTime = PcGetTimeInterval(0);
    
    while (PcGetTimeInterval(startTime) < GTI_MILLISECONDS(50))
    {
        UCHAR status
        = READ_PORT_UCHAR(PortBase + MPU401_REG_STATUS);

        if (UartFifoOkForWrite(status)) // Is this a good time to write data?
        {                               // yep (Jon comment)
            WRITE_PORT_UCHAR(deviceAddr,Value);
            _DbgPrintF(DEBUGLVL_BLAB, ("WriteMPU emitted 0x%02x",Value));
            ntStatus = STATUS_SUCCESS;
            break;
        }
    }
    return ntStatus;
}

#pragma code_seg()
/*****************************************************************************
 * SnapTimeStamp()
 *****************************************************************************
 *
 * At synchronized execution to ISR, copy miniport's volatile m_InputTimeStamp 
 * to stream's m_SnapshotTimeStamp and zero m_InputTimeStamp.
 *
 */
STDMETHODIMP_(NTSTATUS) 
SnapTimeStamp(PINTERRUPTSYNC InterruptSync,PVOID pStream)
{
    CMiniportDMusUARTStream *pMPStream = (CMiniportDMusUARTStream *)pStream;

    //  cache the timestamp
    pMPStream->m_SnapshotTimeStamp = pMPStream->m_pMiniport->m_InputTimeStamp;

    //  if the window is closed, zero the timestamp
    if (pMPStream->m_pMiniport->m_MPUInputBufferHead == 
        pMPStream->m_pMiniport->m_MPUInputBufferTail)
    {
        pMPStream->m_pMiniport->m_InputTimeStamp = 0;
    }

    return STATUS_SUCCESS;
}

/*****************************************************************************
 * CMiniportDMusUARTStream::SourceEvtsToPort()
 *****************************************************************************
 *
 * Reads incoming MIDI data, feeds into DMus events.
 * No need to touch the hardware, just read from our SW FIFO.
 *
 */
STDMETHODIMP_(NTSTATUS)
CMiniportDMusUARTStream::SourceEvtsToPort()
{
    NTSTATUS    ntStatus;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    _DbgPrintF(DEBUGLVL_BLAB, ("SourceEvtsToPort"));

    if (m_fCapture)
    {
        ntStatus = STATUS_SUCCESS;
        if (m_pMiniport->m_MPUInputBufferHead != m_pMiniport->m_MPUInputBufferTail)
        {
            PDMUS_KERNEL_EVENT  aDMKEvt,eventTail,eventHead = NULL;

            while (m_pMiniport->m_MPUInputBufferHead != m_pMiniport->m_MPUInputBufferTail)
            {
                (void) m_AllocatorMXF->GetMessage(&aDMKEvt);
                if (!aDMKEvt)
                {
                    _DbgPrintF(DEBUGLVL_TERSE, ("SourceEvtsToPort can't allocate DMKEvt"));
                    return STATUS_INSUFFICIENT_RESOURCES;
                }

                //  put this event at the end of the list
                if (!eventHead)
                {
                    eventHead = aDMKEvt;
                }
                else
                {
                    eventTail = eventHead;
                    while (eventTail->pNextEvt)
                    {
                        eventTail = eventTail->pNextEvt;
                    }
                    eventTail->pNextEvt = aDMKEvt;
                }
                //  read all the bytes out of the buffer, into event(s)
                for (aDMKEvt->cbEvent = 0; aDMKEvt->cbEvent < sizeof(PBYTE); aDMKEvt->cbEvent++)
                {
                    if (m_pMiniport->m_MPUInputBufferHead == m_pMiniport->m_MPUInputBufferTail)
                    {
//                        _DbgPrintF(DEBUGLVL_TERSE, ("SourceEvtsToPort m_MPUInputBufferHead met m_MPUInputBufferTail, overrun"));
                        break;
                    }
                    aDMKEvt->uData.abData[aDMKEvt->cbEvent] = m_pMiniport->m_MPUInputBuffer[m_pMiniport->m_MPUInputBufferHead];
                    m_pMiniport->m_MPUInputBufferHead++;
                    if (m_pMiniport->m_MPUInputBufferHead >= kMPUInputBufferSize)
                    {
                        m_pMiniport->m_MPUInputBufferHead = 0;
                    }
                }
            }

            if (m_pMiniport->m_UseIRQ)
            {
                ntStatus = m_pMiniport->m_pInterruptSync->CallSynchronizedRoutine(SnapTimeStamp,PVOID(this));
            }
            else    //  !m_UseIRQ
            {
                ntStatus = SnapTimeStamp(NULL,PVOID(this));
            }       //  !m_UseIRQ
            aDMKEvt = eventHead;
            while (aDMKEvt)
            {
                aDMKEvt->ullPresTime100ns = m_SnapshotTimeStamp;
                aDMKEvt->usChannelGroup = 1;
                aDMKEvt->usFlags = DMUS_KEF_EVENT_INCOMPLETE;
                aDMKEvt = aDMKEvt->pNextEvt;
            }
            (void)m_sinkMXF->PutMessage(eventHead);
        }
    }
    else    //  render stream
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("SourceEvtsToPort called on render stream"));
        ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    }
    return ntStatus;
}

#pragma code_seg()
/*****************************************************************************
 * DMusMPUInterruptServiceRoutine()
 *****************************************************************************
 * ISR.
 */
NTSTATUS
DMusMPUInterruptServiceRoutine
(
    IN      PINTERRUPTSYNC  InterruptSync,
    IN      PVOID           DynamicContext
)
{
    _DbgPrintF(DEBUGLVL_BLAB, ("DMusMPUInterruptServiceRoutine"));
    ULONGLONG   startTime;

    ASSERT(DynamicContext);

    NTSTATUS            ntStatus;
    BOOL                newBytesAvailable;
    CMiniportDMusUART   *that;
    NTSTATUS            clockStatus;

    that = (CMiniportDMusUART *) DynamicContext;
    newBytesAvailable = FALSE;
    ntStatus = STATUS_UNSUCCESSFUL;

    UCHAR portStatus = 0xff;

    //
    // Read the MPU status byte.
    //
    if (that->m_pPortBase)
    {
        portStatus =
            READ_PORT_UCHAR(that->m_pPortBase + MPU401_REG_STATUS);

        //
        // If there is outstanding work to do and there is a port-driver for
        // the MPU miniport...
        //
        if (UartFifoOkForRead(portStatus) && that->m_pPort)
        {
            startTime = PcGetTimeInterval(0);
            while ( (PcGetTimeInterval(startTime) < GTI_MILLISECONDS(50)) 
                &&  (UartFifoOkForRead(portStatus)) )
            {
                UCHAR uDest = READ_PORT_UCHAR(that->m_pPortBase + MPU401_REG_DATA);
                if (    (that->m_KSStateInput == KSSTATE_RUN) 
                    &&  (that->m_NumCaptureStreams)
                   )
                {
                    LONG    buffHead = that->m_MPUInputBufferHead;
                    if (   (that->m_MPUInputBufferTail + 1 == buffHead)
                        || (that->m_MPUInputBufferTail + 1 - kMPUInputBufferSize == buffHead))
                    {
                        _DbgPrintF(DEBUGLVL_TERSE,("*****MPU Input Buffer Overflow*****"));
                    }
                    else
                    {
                        if (!that->m_InputTimeStamp)
                        {
                            clockStatus = that->m_MasterClock->GetTime(&that->m_InputTimeStamp);
                            if (STATUS_SUCCESS != clockStatus)
                            {
                                _DbgPrintF(DEBUGLVL_TERSE,("GetTime failed for clock 0x%08x",that->m_MasterClock));
                            }
                        }
                        newBytesAvailable = TRUE;
                        //  ...place the data in our FIFO...
                        that->m_MPUInputBuffer[that->m_MPUInputBufferTail] = uDest;
                        ASSERT(that->m_MPUInputBufferTail < kMPUInputBufferSize);
                        
                        that->m_MPUInputBufferTail++;
                        if (that->m_MPUInputBufferTail >= kMPUInputBufferSize)
                        {
                            that->m_MPUInputBufferTail = 0;
                        }
                    } 
                }
                //
                // Look for more MIDI data.
                //
                portStatus =
                    READ_PORT_UCHAR(that->m_pPortBase + MPU401_REG_STATUS);
            }   //  either there's no data or we ran too long
            if (newBytesAvailable)
            {
                //
                // ...notify the MPU port driver that we have bytes.
                //
                that->m_pPort->Notify(that->m_pServiceGroup);
            }
            ntStatus = STATUS_SUCCESS;
        }
    }

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\miniport\uart\mpu.cpp ===
/*****************************************************************************
 * MPU.cpp - UART miniport implementation
 *****************************************************************************
 * Copyright (c) 1998-2000 Microsoft Corporation.  All rights reserved.
 *
 *      Sept 98    MartinP .
 */

#include "private.h"
#include "ksdebug.h"

#define STR_MODULENAME "UART:MPU: "

//
// MPU401 ports
//
#define MPU401_REG_DATA     0x00    // Data I/O
#define MPU401_REG_COMMAND  0x01    // Command Register (w/o)
#define MPU401_REG_STATUS   0x01    // Status Register (r/o)

#define MPU401_CMD_RESET    0xFF    // Reset command
#define MPU401_CMD_UART     0x3F    // Switch to UART mode
#define MPU401_DRR          0x40    // Output ready (for command or data)
#define MPU401_DSR          0x80    // Input ready (for data)



#define UartFifoOkForWrite(status)  ((status & MPU401_DRR) == 0)
#define UartFifoOkForRead(status)   ((status & MPU401_DSR) == 0)

typedef struct
{
    CMiniportMidiUart  *Miniport;
    PUCHAR              PortBase;
    PVOID               BufferAddress;
    ULONG               Length;
    PULONG              BytesRead;
}
SYNCWRITECONTEXT, *PSYNCWRITECONTEXT;

typedef struct
{
    PVOID               BufferAddress;
    ULONG               Length;
    PULONG              BytesRead;
    PULONG              pMPUInputBufferHead;
    ULONG               MPUInputBufferTail;
    PUCHAR              MPUInputBuffer;
}
DEFERREDREADCONTEXT, *PDEFERREDREADCONTEXT;

NTSTATUS DeferredLegacyRead(IN PINTERRUPTSYNC InterruptSync,IN PVOID DynamicContext);
BOOLEAN  TryLegacyMPU(IN PUCHAR PortBase);
NTSTATUS WriteLegacyMPU(IN PUCHAR PortBase,IN BOOLEAN IsCommand,IN UCHAR Value);

#pragma code_seg("PAGE")
//  make sure we're in UART mode
NTSTATUS ResetMPUHardware(PUCHAR portBase)
{
    PAGED_CODE();

    return (WriteLegacyMPU(portBase,COMMAND,MPU401_CMD_UART));
}

#pragma code_seg("PAGE")
//
// We initialize the UART with interrupts suppressed so we don't
// try to service the chip prematurely.
//
NTSTATUS CMiniportMidiUart::InitializeHardware(PINTERRUPTSYNC interruptSync,PUCHAR portBase)
{
    PAGED_CODE();

    NTSTATUS ntStatus;
    if (m_UseIRQ)
    {
        ntStatus = interruptSync->CallSynchronizedRoutine(InitLegacyMPU,PVOID(portBase));
    }
    else
    {
        ntStatus = InitLegacyMPU(NULL,PVOID(portBase));
    }

    if (NT_SUCCESS(ntStatus))
    {
        //
        // Start the UART (this should trigger an interrupt).
        //
        ntStatus = ResetMPUHardware(portBase);
    }
    else
    {
        _DbgPrintF(DEBUGLVL_TERSE,("*** InitLegacyMPU returned with ntStatus 0x%08x ***",ntStatus));
    }

    m_fMPUInitialized = NT_SUCCESS(ntStatus);

    return ntStatus;
}

#pragma code_seg()
/*****************************************************************************
 * InitLegacyMPU()
 *****************************************************************************
 * Synchronized routine to initialize the MPU401.
 */
NTSTATUS
InitLegacyMPU
(
    IN      PINTERRUPTSYNC  InterruptSync,
    IN      PVOID           DynamicContext
)
{
    _DbgPrintF(DEBUGLVL_BLAB, ("InitLegacyMPU"));
    
    if (!DynamicContext)
    {
        return STATUS_INVALID_PARAMETER_2;
    }
    
    PUCHAR      portBase = PUCHAR(DynamicContext);
    UCHAR       status;
    ULONGLONG   startTime;
    BOOLEAN     success;
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    
    //
    // Reset the card (puts it into "smart mode")
    //
    ntStatus = WriteLegacyMPU(portBase,COMMAND,MPU401_CMD_RESET);

    // wait for the acknowledgement
    // NOTE: When the Ack arrives, it will trigger an interrupt.  
    //       Normally the DPC routine would read in the ack byte and we
    //       would never see it, however since we have the hardware locked (HwEnter),
    //       we can read the port before the DPC can and thus we receive the Ack.
    startTime = PcGetTimeInterval(0);
    success = FALSE;
    while(PcGetTimeInterval(startTime) < GTI_MILLISECONDS(50))
    {
        status = READ_PORT_UCHAR(portBase + MPU401_REG_STATUS);
        
        if (UartFifoOkForRead(status))                      // Is data waiting?
        {
            READ_PORT_UCHAR(portBase + MPU401_REG_DATA);    // yep.. read ACK 
            success = TRUE;                                 // don't need to do more 
            break;
        }
        KeStallExecutionProcessor(25);  //  microseconds
    }
#if (DBG)
    if (!success)
    {
        _DbgPrintF(DEBUGLVL_VERBOSE,("First attempt to reset the MPU didn't get ACKed.\n"));
    }
#endif  //  (DBG)

    // NOTE: We cannot check the ACK byte because if the card was already in
    // UART mode it will not send an ACK but it will reset.

    // reset the card again
    (void) WriteLegacyMPU(portBase,COMMAND,MPU401_CMD_RESET);

                                    // wait for ack (again)
    startTime = PcGetTimeInterval(0); // This might take a while
    BYTE dataByte = 0;
    success = FALSE;
    while (PcGetTimeInterval(startTime) < GTI_MILLISECONDS(50))
    {
        status = READ_PORT_UCHAR(portBase + MPU401_REG_STATUS);
        if (UartFifoOkForRead(status))                                  // Is data waiting?
        {
            dataByte = READ_PORT_UCHAR(portBase + MPU401_REG_DATA);     // yep.. read ACK
            success = TRUE;                                             // don't need to do more
            break;
        }
        KeStallExecutionProcessor(25);
    }

    if ((0xFE != dataByte) || !success)   // Did we succeed? If no second ACK, something is hosed  
    {                       
        _DbgPrintF(DEBUGLVL_TERSE,("Second attempt to reset the MPU didn't get ACKed.\n"));
        _DbgPrintF(DEBUGLVL_TERSE,("Init Reset failure error. Ack = %X", ULONG(dataByte) ) );
        ntStatus = STATUS_IO_DEVICE_ERROR;
    }
    
    return ntStatus;
}

#pragma code_seg()
/*****************************************************************************
 * CMiniportMidiStreamUart::Write()
 *****************************************************************************
 * Writes outgoing MIDI data.
 */
STDMETHODIMP_(NTSTATUS)
CMiniportMidiStreamUart::
Write
(
    IN      PVOID       BufferAddress,
    IN      ULONG       Length,
    OUT     PULONG      BytesWritten
)
{
    _DbgPrintF(DEBUGLVL_BLAB, ("Write"));
    ASSERT(BytesWritten);
    if (!BufferAddress)
    {
        Length = 0;
    }

    NTSTATUS ntStatus = STATUS_SUCCESS;

    if (!m_fCapture)
    {
        PUCHAR  pMidiData;
        ULONG   count;

        count = 0;
        pMidiData = PUCHAR(BufferAddress);

        if (Length)
        {
            SYNCWRITECONTEXT context;
            context.Miniport        = (m_pMiniport);
            context.PortBase        = m_pPortBase;
            context.BufferAddress   = pMidiData;
            context.Length          = Length;
            context.BytesRead       = &count;

            if (m_pMiniport->m_UseIRQ)
            {
                ntStatus = m_pMiniport->m_pInterruptSync->
                                CallSynchronizedRoutine(SynchronizedMPUWrite,PVOID(&context));
            }
            else    //  !m_UseIRQ
            {
                ntStatus = SynchronizedMPUWrite(NULL,PVOID(&context));
            }       //  !m_UseIRQ

            if (count == 0)
            {
                m_NumFailedMPUTries++;
                if (m_NumFailedMPUTries >= 100)
                {
                    ntStatus = STATUS_IO_DEVICE_ERROR;
                    m_NumFailedMPUTries = 0;
                }
            }
            else
            {
                m_NumFailedMPUTries = 0;
            }
        }           //  if we have data at all
        *BytesWritten = count;
    }
    else    //  called write on the read stream
    {
        ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    }
    return ntStatus;
}

#pragma code_seg()
/*****************************************************************************
 * SynchronizedMPUWrite()
 *****************************************************************************
 * Writes outgoing MIDI data.
 */
NTSTATUS
SynchronizedMPUWrite
(
    IN      PINTERRUPTSYNC  InterruptSync,
    IN      PVOID           syncWriteContext
)
{
    PSYNCWRITECONTEXT context;
    context = (PSYNCWRITECONTEXT)syncWriteContext;
    ASSERT(context->Miniport);
    ASSERT(context->PortBase);
    ASSERT(context->BufferAddress);
    ASSERT(context->Length);
    ASSERT(context->BytesRead);

    PUCHAR  pChar = PUCHAR(context->BufferAddress);
    NTSTATUS ntStatus,readStatus;
    ntStatus = STATUS_SUCCESS;
    //
    // while we're not there yet, and
    // while we don't have to wait on an aligned byte (including 0)
    // (we never wait on an aligned byte.  Better to come back later)
//    if (context->Miniport->m_NumCaptureStreams)
    {
        readStatus = MPUInterruptServiceRoutine(InterruptSync,PVOID(context->Miniport));
    }
    while (  (*(context->BytesRead) < context->Length)
          && (TryLegacyMPU(context->PortBase) 
             || (*(context->BytesRead)%4)
          )  )
    {
        ntStatus = WriteLegacyMPU(context->PortBase,DATA,*pChar);
        if (NT_SUCCESS(ntStatus))
        {
            pChar++;
            *(context->BytesRead) = *(context->BytesRead) + 1;
            readStatus = MPUInterruptServiceRoutine(InterruptSync,PVOID(context->Miniport));
        }
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE,("SynchronizedMPUWrite failed (0x%08x)",ntStatus));
            break;
        }
    }
//    if (context->Miniport->m_NumCaptureStreams)
    {
            readStatus = MPUInterruptServiceRoutine(InterruptSync,PVOID(context->Miniport));
    }
    return ntStatus;
}

#define kMPUPollTimeout 2

#pragma code_seg()
/*****************************************************************************
 * TryLegacyMPU()
 *****************************************************************************
 * See if the MPU401 is free.
 */
BOOLEAN
TryLegacyMPU
(
    IN      PUCHAR      PortBase
)
{
    BOOLEAN success;
    USHORT  numPolls;
    UCHAR   status;

    _DbgPrintF(DEBUGLVL_BLAB, ("TryLegacyMPU"));
    numPolls = 0;

    while (numPolls < kMPUPollTimeout)
    {
        status = READ_PORT_UCHAR(PortBase + MPU401_REG_STATUS);
                                       
        if (UartFifoOkForWrite(status)) // Is this a good time to write data?
        {
            break;
        }
        numPolls++;
    }
    if (numPolls >= kMPUPollTimeout)
    {
        success = FALSE;
        _DbgPrintF(DEBUGLVL_BLAB, ("TryLegacyMPU failed"));
    }
    else
    {
        success = TRUE;
    }

    return success;
}

#pragma code_seg()
/*****************************************************************************
 * WriteLegacyMPU()
 *****************************************************************************
 * Write a byte out to the MPU401.
 */
NTSTATUS
WriteLegacyMPU
(
    IN      PUCHAR      PortBase,
    IN      BOOLEAN     IsCommand,
    IN      UCHAR       Value
)
{
    _DbgPrintF(DEBUGLVL_BLAB, ("WriteLegacyMPU"));
    NTSTATUS ntStatus = STATUS_IO_DEVICE_ERROR;

    if (!PortBase)
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("O: PortBase is zero\n"));
        return ntStatus;
    }
    PUCHAR deviceAddr = PortBase + MPU401_REG_DATA;

    if (IsCommand)
    {
        deviceAddr = PortBase + MPU401_REG_COMMAND;
    }

    ULONGLONG startTime = PcGetTimeInterval(0);
    
    while (PcGetTimeInterval(startTime) < GTI_MILLISECONDS(50))
    {
        UCHAR status
        = READ_PORT_UCHAR(PortBase + MPU401_REG_STATUS);

        if (UartFifoOkForWrite(status)) // Is this a good time to write data?
        {                               // yep (Jon comment)
            WRITE_PORT_UCHAR(deviceAddr,Value);
            _DbgPrintF(DEBUGLVL_BLAB, ("WriteLegacyMPU emitted 0x%02x",Value));
            ntStatus = STATUS_SUCCESS;
            break;
        }
    }
    return ntStatus;
}

#pragma code_seg()
/*****************************************************************************
 * CMiniportMidiStreamUart::Read()
 *****************************************************************************
 * Reads incoming MIDI data.
 */
STDMETHODIMP_(NTSTATUS)
CMiniportMidiStreamUart::
Read
(
    IN      PVOID   BufferAddress,
    IN      ULONG   Length,
    OUT     PULONG  BytesRead
)
{
    ASSERT(BufferAddress);
    ASSERT(BytesRead);

    *BytesRead = 0;
    if (m_fCapture)
    {
        DEFERREDREADCONTEXT context;
        context.BufferAddress   = BufferAddress;
        context.Length          = Length;
        context.BytesRead       = BytesRead;
        context.pMPUInputBufferHead = &(m_pMiniport->m_MPUInputBufferHead);
        context.MPUInputBufferTail = m_pMiniport->m_MPUInputBufferTail;
        context.MPUInputBuffer     = m_pMiniport->m_MPUInputBuffer;

        if (*(context.pMPUInputBufferHead) != context.MPUInputBufferTail)
        {
            //
            //  More data is available.
            //  No need to touch the hardware, just read from our SW FIFO.
            //
            return (DeferredLegacyRead(m_pMiniport->m_pInterruptSync,PVOID(&context)));
        }
        else
        {
            return STATUS_SUCCESS;
        }
    }
    else
    {
        return STATUS_INVALID_DEVICE_REQUEST;
    }
}

#pragma code_seg()
/*****************************************************************************
 * DeferredLegacyRead()
 *****************************************************************************
 * Synchronized routine to read incoming MIDI data.
 * We have already read the bytes in, and now the Port wants them.
 */
NTSTATUS
DeferredLegacyRead
(
    IN      PINTERRUPTSYNC  InterruptSync,
    IN      PVOID           DynamicContext
)
{
    ASSERT(InterruptSync);
    ASSERT(DynamicContext);

    PDEFERREDREADCONTEXT context = PDEFERREDREADCONTEXT(DynamicContext);

    ASSERT(context->BufferAddress);
    ASSERT(context->BytesRead);


    NTSTATUS ntStatus = STATUS_SUCCESS;
    PUCHAR  pDest = PUCHAR(context->BufferAddress);
    PULONG  pMPUInputBufferHead = context->pMPUInputBufferHead;
    ULONG   MPUInputBufferTail = context->MPUInputBufferTail;
    ULONG   bytesRead = 0;

    ASSERT(pMPUInputBufferHead);
    ASSERT(context->MPUInputBuffer);

    while  (    (*pMPUInputBufferHead != MPUInputBufferTail)
            &&  (bytesRead < context->Length) )
    {
        *pDest = context->MPUInputBuffer[*pMPUInputBufferHead];

        pDest++;
        bytesRead++;
        *pMPUInputBufferHead = *pMPUInputBufferHead + 1;
        //
        //  Wrap FIFO position when reaching the buffer size.
        //
        if (*pMPUInputBufferHead >= kMPUInputBufferSize)
        {
            *pMPUInputBufferHead = 0;
        }
    }
    *context->BytesRead = bytesRead;

    return ntStatus;
}

#pragma code_seg()
/*****************************************************************************
 * MPUInterruptServiceRoutine()
 *****************************************************************************
 * ISR.
 */
NTSTATUS
MPUInterruptServiceRoutine
(
    IN      PINTERRUPTSYNC  InterruptSync,
    IN      PVOID           DynamicContext
)
{
    _DbgPrintF(DEBUGLVL_BLAB, ("MPUInterruptServiceRoutine"));
    ULONGLONG   startTime;

    ASSERT(DynamicContext);

    NTSTATUS            ntStatus;
    BOOL                newBytesAvailable;
    CMiniportMidiUart   *that;

    that = (CMiniportMidiUart *) DynamicContext;
    newBytesAvailable = FALSE;
    ntStatus = STATUS_UNSUCCESSFUL;

    UCHAR portStatus = 0xff;

    //
    // Read the MPU status byte.
    //
    if (that->m_pPortBase)
    {
        portStatus =
            READ_PORT_UCHAR(that->m_pPortBase + MPU401_REG_STATUS);

        //
        // If there is outstanding work to do and there is a port-driver for
        // the MPU miniport...
        //
        if (UartFifoOkForRead(portStatus) && that->m_pPort)
        {
            startTime = PcGetTimeInterval(0);
            while ( (PcGetTimeInterval(startTime) < GTI_MILLISECONDS(50)) 
                &&  (UartFifoOkForRead(portStatus)) )
            {
                UCHAR uDest = READ_PORT_UCHAR(that->m_pPortBase + MPU401_REG_DATA);
                if (    (that->m_KSStateInput == KSSTATE_RUN)
                   &&   (that->m_NumCaptureStreams)
                   )
                {
                    ULONG buffHead = that->m_MPUInputBufferHead;
                    if (   (that->m_MPUInputBufferTail + 1 == buffHead)
                        || (that->m_MPUInputBufferTail + 1 - kMPUInputBufferSize == buffHead))
                    {
                        _DbgPrintF(DEBUGLVL_TERSE,("*****MPU Input Buffer Overflow*****"));
                    }
                    else
                    {
                        newBytesAvailable = TRUE;
                        //  ...place the data in our FIFO...
                        that->m_MPUInputBuffer[that->m_MPUInputBufferTail] = uDest;
                        ASSERT(that->m_MPUInputBufferTail < kMPUInputBufferSize);
                        
                        that->m_MPUInputBufferTail++;
                        if (that->m_MPUInputBufferTail >= kMPUInputBufferSize)
                        {
                            that->m_MPUInputBufferTail = 0;
                        }
                    }
                }
                //
                // Look for more MIDI data.
                //
                portStatus =
                    READ_PORT_UCHAR(that->m_pPortBase + MPU401_REG_STATUS);
            }   //  either there's no data or we ran too long
            if (newBytesAvailable)
            {
                //
                // ...notify the MPU port driver that we have bytes.
                //
                that->m_pPort->Notify(that->m_pServiceGroup);
            }
            ntStatus = STATUS_SUCCESS;
        }
    }

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\miniport\uart\miniport.cpp ===
/*****************************************************************************
 * miniport.cpp - UART miniport implementation
 *****************************************************************************
 * Copyright (c) 1997-2000 Microsoft Corporation.  All Rights Reserved.
 *
 */

#include "private.h"
#include "ksdebug.h"

#define STR_MODULENAME "UartMini: "


#pragma code_seg("PAGE")
/*****************************************************************************
 * PinDataRangesStream
 *****************************************************************************
 * Structures indicating range of valid format values for streaming pins.
 */
static
KSDATARANGE_MUSIC PinDataRangesStream[] =
{
    {
        {
            sizeof(KSDATARANGE_MUSIC),
            0,
            0,
            0,
            STATICGUIDOF(KSDATAFORMAT_TYPE_MUSIC),
            STATICGUIDOF(KSDATAFORMAT_SUBTYPE_MIDI),
            STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE)
        },
        STATICGUIDOF(KSMUSIC_TECHNOLOGY_PORT),
        0,
        0,
        0xFFFF
    }
};

/*****************************************************************************
 * PinDataRangePointersStream
 *****************************************************************************
 * List of pointers to structures indicating range of valid format values
 * for live pins.
 */
static
PKSDATARANGE PinDataRangePointersStream[] =
{
    PKSDATARANGE(&PinDataRangesStream[0])
};

/*****************************************************************************
 * PinDataRangesBridge
 *****************************************************************************
 * Structures indicating range of valid format values for bridge pins.
 */
static
KSDATARANGE PinDataRangesBridge[] =
{
   {
      sizeof(KSDATARANGE),
      0,
      0,
      0,
      STATICGUIDOF(KSDATAFORMAT_TYPE_MUSIC),
      STATICGUIDOF(KSDATAFORMAT_SUBTYPE_MIDI_BUS),
      STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE)
   }
};

/*****************************************************************************
 * PinDataRangePointersBridge
 *****************************************************************************
 * List of pointers to structures indicating range of valid format values
 * for bridge pins.
 */
static
PKSDATARANGE PinDataRangePointersBridge[] =
{
    &PinDataRangesBridge[0]
};

#define kMaxNumCaptureStreams       1
#define kMaxNumRenderStreams        1

/*****************************************************************************
 * MiniportPins
 *****************************************************************************
 * List of pins.
 */
static
PCPIN_DESCRIPTOR MiniportPins[] =
{
    {
        kMaxNumRenderStreams,kMaxNumRenderStreams,0,  // InstanceCount
        NULL,   // AutomationTable
        {       // KsPinDescriptor
            0,                                          // InterfacesCount
            NULL,                                       // Interfaces
            0,                                          // MediumsCount
            NULL,                                       // Mediums
            SIZEOF_ARRAY(PinDataRangePointersStream),   // DataRangesCount
            PinDataRangePointersStream,                 // DataRanges
            KSPIN_DATAFLOW_IN,                          // DataFlow
            KSPIN_COMMUNICATION_SINK,                   // Communication
            (GUID *) &KSCATEGORY_AUDIO,                 // Category
            &KSAUDFNAME_MIDI,                           // Name
            0                                           // Reserved
        }
    },
    {
        0,0,0,  // InstanceCount
        NULL,   // AutomationTable
        {       // KsPinDescriptor
            0,                                          // InterfacesCount
            NULL,                                       // Interfaces
            0,                                          // MediumsCount
            NULL,                                       // Mediums
            SIZEOF_ARRAY(PinDataRangePointersBridge),   // DataRangesCount
            PinDataRangePointersBridge,                 // DataRanges
            KSPIN_DATAFLOW_OUT,                         // DataFlow
            KSPIN_COMMUNICATION_NONE,                   // Communication
            (GUID *) &KSCATEGORY_AUDIO,                 // Category
            NULL,                                       // Name
            0                                           // Reserved
        }
    },
    {
        kMaxNumCaptureStreams,kMaxNumCaptureStreams,0,  // InstanceCount
        NULL,   // AutomationTable
        {       // KsPinDescriptor
            0,                                          // InterfacesCount
            NULL,                                       // Interfaces
            0,                                          // MediumsCount
            NULL,                                       // Mediums
            SIZEOF_ARRAY(PinDataRangePointersStream),   // DataRangesCount
            PinDataRangePointersStream,                 // DataRanges
            KSPIN_DATAFLOW_OUT,                         // DataFlow
            KSPIN_COMMUNICATION_SINK,                   // Communication
            (GUID *) &KSCATEGORY_AUDIO,                 // Category
            &KSAUDFNAME_MIDI,                           // Name
            0                                           // Reserved
        }
    },
    {
        0,0,0,  // InstanceCount
        NULL,   // AutomationTable
        {       // KsPinDescriptor
            0,                                          // InterfacesCount
            NULL,                                       // Interfaces
            0,                                          // MediumsCount
            NULL,                                       // Mediums
            SIZEOF_ARRAY(PinDataRangePointersBridge),   // DataRangesCount
            PinDataRangePointersBridge,                 // DataRanges
            KSPIN_DATAFLOW_IN,                          // DataFlow
            KSPIN_COMMUNICATION_NONE,                   // Communication
            (GUID *) &KSCATEGORY_AUDIO,                 // Category
            NULL,                                       // Name
            0                                           // Reserved
        }
    }
};

/*****************************************************************************
 * MiniportConnections
 *****************************************************************************
 * List of connections.
 */
static
PCCONNECTION_DESCRIPTOR MiniportConnections[] =
{
    { PCFILTER_NODE,  0,  PCFILTER_NODE,    1 },
    { PCFILTER_NODE,  3,  PCFILTER_NODE,    2 }    
};

/*****************************************************************************
 * MiniportFilterDescriptor
 *****************************************************************************
 * Complete miniport filter description.
 */
static
PCFILTER_DESCRIPTOR MiniportFilterDescriptor =
{
    0,                                  // Version
    NULL,                               // AutomationTable
    sizeof(PCPIN_DESCRIPTOR),           // PinSize
    SIZEOF_ARRAY(MiniportPins),         // PinCount
    MiniportPins,                       // Pins
    sizeof(PCNODE_DESCRIPTOR),          // NodeSize
    0,                                  // NodeCount
    NULL,                               // Nodes
    SIZEOF_ARRAY(MiniportConnections),  // ConnectionCount
    MiniportConnections,                // Connections
    0,                                  // CategoryCount
    NULL                                // Categories
};

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportMidiUart::GetDescription()
 *****************************************************************************
 * Gets the topology.
 */
STDMETHODIMP_(NTSTATUS)
CMiniportMidiUart::
GetDescription
(
    OUT     PPCFILTER_DESCRIPTOR *  OutFilterDescriptor
)
{
    PAGED_CODE();

    ASSERT(OutFilterDescriptor);

    _DbgPrintF(DEBUGLVL_VERBOSE,("GetDescription"));

    *OutFilterDescriptor = &MiniportFilterDescriptor;

    return STATUS_SUCCESS;
}


#pragma code_seg("PAGE")
/*****************************************************************************
 * CreateMiniportMidiUart()
 *****************************************************************************
 * Creates a MPU-401 miniport driver for the adapter.  This uses a
 * macro from STDUNK.H to do all the work.
 */
NTSTATUS
CreateMiniportMidiUart
(
    OUT     PUNKNOWN *  Unknown,
    IN      REFCLSID,
    IN      PUNKNOWN    UnknownOuter    OPTIONAL,
    IN      POOL_TYPE   PoolType
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB,("CreateMiniportDMusUART"));
    ASSERT(Unknown);

    STD_CREATE_BODY_(   CMiniportMidiUart,
                        Unknown,
                        UnknownOuter,
                        PoolType, 
                        PMINIPORTMIDI);
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportMidiUart::ProcessResources()
 *****************************************************************************
 * Processes the resource list, setting up helper objects accordingly.
 */
NTSTATUS
CMiniportMidiUart::
ProcessResources
(
    IN      PRESOURCELIST   ResourceList
)
{
    PAGED_CODE();
    _DbgPrintF(DEBUGLVL_BLAB,("ProcessResources"));
    ASSERT(ResourceList);
    if (!ResourceList)
    {
        return STATUS_DEVICE_CONFIGURATION_ERROR;
    }

    //
    // Get counts for the types of resources.
    //
    ULONG   countIO     = ResourceList->NumberOfPorts();
    ULONG   countIRQ    = ResourceList->NumberOfInterrupts();
    ULONG   countDMA    = ResourceList->NumberOfDmas();
    ULONG   lengthIO    = ResourceList->FindTranslatedPort(0)->u.Port.Length;

#if (DBG)
    _DbgPrintF(DEBUGLVL_VERBOSE,("Starting MPU401 Port 0x%X",
        ResourceList->FindTranslatedPort(0)->u.Port.Start.LowPart) );
#endif

    NTSTATUS ntStatus = STATUS_SUCCESS;

    //
    // Make sure we have the expected number of resources.
    //
    if  (   (countIO != 1)
        ||  (countIRQ  > 1)
        ||  (countDMA != 0)
        ||  (lengthIO == 0)
        )
    {
        _DbgPrintF(DEBUGLVL_TERSE,("Unknown ResourceList configuraton"));
        ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
    }

    if (NT_SUCCESS(ntStatus))
    {
        //
        // Get the port address.
        //
        m_pPortBase =
            PUCHAR(ResourceList->FindTranslatedPort(0)->u.Port.Start.QuadPart);

        ntStatus = InitializeHardware(m_pInterruptSync,m_pPortBase);
    }

    return ntStatus;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportMidiUart::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.  This function works just like a COM QueryInterface
 * call and is used if the object is not being aggregated.
 */
STDMETHODIMP_(NTSTATUS)
CMiniportMidiUart::
NonDelegatingQueryInterface
(
    REFIID  Interface,
    PVOID * Object
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB,("Miniport::NonDelegatingQueryInterface"));
    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface,IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(PMINIPORTMIDI(this)));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IMiniport))
    {
        *Object = PVOID(PMINIPORT(this));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IMiniportMidi))
    {
        *Object = PVOID(PMINIPORTMIDI(this));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IMusicTechnology))
    {
        *Object = PVOID(PMUSICTECHNOLOGY(this));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IPowerNotify))
    {
        *Object = PVOID(PPOWERNOTIFY(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        //
        // We reference the interface for the caller.
        //
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportMidiUart::~CMiniportMidiUart()
 *****************************************************************************
 * Destructor.
 */
CMiniportMidiUart::~CMiniportMidiUart(void)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB,("~CMiniportMidiUart"));

    ASSERT(0 == m_NumCaptureStreams);
    ASSERT(0 == m_NumRenderStreams);
    
    //  reset the HW so we don't get any more interrupts
    if (m_UseIRQ && m_pInterruptSync)
    {
        (void) m_pInterruptSync->CallSynchronizedRoutine(InitLegacyMPU,PVOID(m_pPortBase));
    }
    else
    {
        (void) InitLegacyMPU(NULL,PVOID(m_pPortBase));
    }

    if (m_pInterruptSync)
    {
        m_pInterruptSync->Release();
        m_pInterruptSync = NULL;
    }
    if (m_pServiceGroup)
    {
        m_pServiceGroup->Release();
        m_pServiceGroup = NULL;
    }
    if (m_pPort)
    {
        m_pPort->Release();
        m_pPort = NULL;
    }
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportMidiUart::Init()
 *****************************************************************************
 * Initializes a the miniport.
 */
STDMETHODIMP_(NTSTATUS)
CMiniportMidiUart::
Init
(
    IN	    PUNKNOWN	    UnknownInterruptSync    OPTIONAL,
    IN      PRESOURCELIST   ResourceList,
    IN      PPORTMIDI       Port_,
    OUT     PSERVICEGROUP * ServiceGroup
)
{
    PAGED_CODE();

    ASSERT(ResourceList);
    if (!ResourceList)
    {
        return STATUS_DEVICE_CONFIGURATION_ERROR;
    }
    ASSERT(Port_);
    ASSERT(ServiceGroup);

    _DbgPrintF(DEBUGLVL_BLAB,("Init"));

    *ServiceGroup = NULL;
    m_pPortBase = 0;
    m_fMPUInitialized = FALSE;
 
    // This will remain unspecified if the miniport does not get any power 
    // messages.
    //
    m_PowerState.DeviceState = PowerDeviceUnspecified;
    
    //
    // AddRef() is required because we are keeping this pointer.
    //
    m_pPort = Port_;
    m_pPort->AddRef();

    // Set dataformat.
    //
    if (IsEqualGUIDAligned(m_MusicFormatTechnology, GUID_NULL))
    {
        RtlCopyMemory(  &m_MusicFormatTechnology, 
                        &KSMUSIC_TECHNOLOGY_PORT, 
                        sizeof(GUID));
    }
    RtlCopyMemory(  &PinDataRangesStream[0].Technology,
                    &m_MusicFormatTechnology,
                    sizeof(GUID));

    for (ULONG bufferCount = 0;bufferCount < kMPUInputBufferSize;bufferCount++)
    {
        m_MPUInputBuffer[bufferCount] = 0;
    }
    m_MPUInputBufferHead = 0;
    m_MPUInputBufferTail = 0;
    m_KSStateInput = KSSTATE_STOP;

    NTSTATUS ntStatus = STATUS_SUCCESS;

    m_NumRenderStreams = 0;
    m_NumCaptureStreams = 0;
    _DbgPrintF(DEBUGLVL_VERBOSE,("Init: resetting m_NumRenderStreams and m_NumCaptureStreams"));

    m_UseIRQ = TRUE;
    if (ResourceList->NumberOfInterrupts() == 0)
    {
        m_UseIRQ = FALSE;
    }

    ntStatus = PcNewServiceGroup(&m_pServiceGroup,NULL);
    if (NT_SUCCESS(ntStatus) && !m_pServiceGroup)   //  keep any error
    {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (NT_SUCCESS(ntStatus))
    {
        *ServiceGroup = m_pServiceGroup;
        m_pServiceGroup->AddRef();

		//
		// Register the service group with the port early so the port is
		// prepared to handle interrupts.
		//
		m_pPort->RegisterServiceGroup(m_pServiceGroup);
    }

    if (NT_SUCCESS(ntStatus) && m_UseIRQ)
    {
/*
        //
        //  Due to a bug in the InterruptSync design, we shouldn't share
        //  the interrupt sync object.  Whoever goes away first 
        //  will disconnect it, and the other points off into nowhere.
        //  
        //  Instead we generate our own interrupt sync object.
        //
        UnknownInterruptSync = NULL;
*/
        if (UnknownInterruptSync)
        {
            ntStatus = 
                UnknownInterruptSync->QueryInterface
                (
                    IID_IInterruptSync,
                    (PVOID *) &m_pInterruptSync
                );

            if (!m_pInterruptSync && NT_SUCCESS(ntStatus))  //  keep any error
            {
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
            if (NT_SUCCESS(ntStatus))
            {                                                                           //  run this ISR first
                ntStatus = m_pInterruptSync->
                    RegisterServiceRoutine(MPUInterruptServiceRoutine,PVOID(this),TRUE);
            }
        }
        else
        {   // create our own interruptsync mechanism.
            ntStatus = 
                PcNewInterruptSync
                (
                    &m_pInterruptSync,
                    NULL,
                    ResourceList,
                    0,                          // Resource Index
                    InterruptSyncModeNormal     // Run ISRs once until we get SUCCESS
                );

            if (!m_pInterruptSync && NT_SUCCESS(ntStatus))  //  keep any error
            {
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
            if (NT_SUCCESS(ntStatus))
            {
                ntStatus = m_pInterruptSync->RegisterServiceRoutine(
                    MPUInterruptServiceRoutine,
                    PVOID(this),
                    TRUE);                //  run this ISR first
            }
            if (NT_SUCCESS(ntStatus))
            {
                ntStatus = m_pInterruptSync->Connect();
            }
        }
    }

    if (NT_SUCCESS(ntStatus))
    {
        ntStatus = ProcessResources(ResourceList);
    }

    if (!NT_SUCCESS(ntStatus))
    {
        //
        // clean up our mess
        //

        // clean up the interrupt sync
        if( m_pInterruptSync )
        {
            m_pInterruptSync->Release();
            m_pInterruptSync = NULL;
        }

        // clean up the service group
        if( m_pServiceGroup )
        {
            m_pServiceGroup->Release();
            m_pServiceGroup = NULL;
        }

        // clean up the out param service group.
        if (*ServiceGroup)
        {
            (*ServiceGroup)->Release();
            (*ServiceGroup) = NULL;
        }

        // release the port
        m_pPort->Release();
        m_pPort = NULL;
    }

    return ntStatus;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportMidiUart::NewStream()
 *****************************************************************************
 * Gets the topology.
 */
STDMETHODIMP_(NTSTATUS) 
CMiniportMidiUart::
NewStream
(
    OUT     PMINIPORTMIDISTREAM *   Stream,
    IN      PUNKNOWN                OuterUnknown    OPTIONAL,
    IN      POOL_TYPE               PoolType,
    IN      ULONG                   PinID,
    IN      BOOLEAN                 Capture,
    IN      PKSDATAFORMAT           DataFormat,
    OUT     PSERVICEGROUP *         ServiceGroup
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB, ("NewStream"));
    NTSTATUS ntStatus = STATUS_SUCCESS;

    // if we don't have any streams already open, get the hardware ready.
    if ((!m_NumCaptureStreams) && (!m_NumRenderStreams))
    {
        _DbgPrintF(DEBUGLVL_VERBOSE,("NewStream: m_NumRenderStreams and m_NumCaptureStreams are both 0, so ResetMPUHardware"));

        ntStatus = ResetMPUHardware(m_pPortBase);
        if (!NT_SUCCESS(ntStatus))
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("CMiniportMidiUart::NewStream ResetHardware failed"));
            return ntStatus;
        }
    }
    else
    {
        _DbgPrintF(DEBUGLVL_VERBOSE,("NewStream: m_NumRenderStreams %d, m_NumCaptureStreams %d, no ResetMPUHardware",
                                     m_NumRenderStreams,m_NumCaptureStreams));
    }

    if  (   (   (m_NumCaptureStreams < kMaxNumCaptureStreams)
            &&  (Capture)  )
        ||  (   (m_NumRenderStreams < kMaxNumRenderStreams) 
            &&  (!Capture) )
        )
    {
        CMiniportMidiStreamUart *pStream =
            new(PoolType) CMiniportMidiStreamUart(OuterUnknown);

        if (pStream)
        {
            pStream->AddRef();

            ntStatus = 
                pStream->Init(this,m_pPortBase,Capture);

            if (NT_SUCCESS(ntStatus))
            {
                *Stream = PMINIPORTMIDISTREAM(pStream);
                (*Stream)->AddRef();

                if (Capture)
                {
                    m_NumCaptureStreams++;
                    *ServiceGroup = m_pServiceGroup;
                    (*ServiceGroup)->AddRef();
                }
                else
                {
                    m_NumRenderStreams++;
                    *ServiceGroup = NULL;
                }
                _DbgPrintF(DEBUGLVL_VERBOSE,("NewStream: succeeded, m_NumRenderStreams %d, m_NumCaptureStreams %d",
                                              m_NumRenderStreams,m_NumCaptureStreams));
            }

            pStream->Release();
        }
        else
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else
    {
        ntStatus = STATUS_INVALID_DEVICE_REQUEST;
        if (Capture)
        {
            _DbgPrintF(DEBUGLVL_TERSE,("NewStream failed, too many capture streams"));
        }
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE,("NewStream failed, too many render streams"));
        }
    }

    return ntStatus;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportMidiUart::SetTechnology()
 *****************************************************************************
 * Sets pindatarange technology.
 */
STDMETHODIMP_(NTSTATUS)
CMiniportMidiUart::
SetTechnology
(
    IN	    const GUID *            Technology
)
{
    PAGED_CODE();
    
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;
    
    // Fail if miniport has already been initialized. 
    //
    if (NULL == m_pPort)
    {
        RtlCopyMemory(&m_MusicFormatTechnology, Technology, sizeof(GUID));
        ntStatus = STATUS_SUCCESS;
    }

    return ntStatus;
} // SetTechnology

/*****************************************************************************
 * CMiniportMidiUart::PowerChangeNotify()
 *****************************************************************************
 * Handle power state change for the miniport.
 */
#pragma code_seg("PAGE")
STDMETHODIMP_(void)
CMiniportMidiUart::
PowerChangeNotify
(
    IN      POWER_STATE             PowerState
)
{
    PAGED_CODE();
    
    _DbgPrintF(DEBUGLVL_VERBOSE, ("CMiniportMidiUart::PoweChangeNotify D%d", PowerState.DeviceState));
    
    switch (PowerState.DeviceState)
    {
        case PowerDeviceD0:
            if (m_PowerState.DeviceState != PowerDeviceD0) 
            {
                if (!NT_SUCCESS(InitializeHardware(m_pInterruptSync,m_pPortBase)))
                {
                    _DbgPrintF(DEBUGLVL_TERSE, ("InitializeHardware failed when resuming"));
                }
            }
            break;

        case PowerDeviceD1:
        case PowerDeviceD2:
        case PowerDeviceD3:
        default:
            break;
    }
    m_PowerState.DeviceState = PowerState.DeviceState;
} // PowerChangeNotify

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportMidiStreamUart::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.  This function works just like a COM QueryInterface
 * call and is used if the object is not being aggregated.
 */
STDMETHODIMP_(NTSTATUS)
CMiniportMidiStreamUart::
NonDelegatingQueryInterface
(
    REFIID  Interface,
    PVOID * Object
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB,("Stream::NonDelegatingQueryInterface"));
    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface,IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(this));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IMiniportMidiStream))
    {
        *Object = PVOID(PMINIPORTMIDISTREAM(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        //
        // We reference the interface for the caller.
        //
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportMidiStreamUart::SetFormat()
 *****************************************************************************
 * Sets the format.
 */
STDMETHODIMP_(NTSTATUS)
CMiniportMidiStreamUart::
SetFormat
(
    IN      PKSDATAFORMAT   Format
)
{
    PAGED_CODE();

    ASSERT(Format);

    _DbgPrintF(DEBUGLVL_VERBOSE,("CMiniportMidiStreamUart::SetFormat"));

    return STATUS_SUCCESS;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportMidiStreamUart::~CMiniportMidiStreamUart()
 *****************************************************************************
 * Destructs a stream.
 */
CMiniportMidiStreamUart::~CMiniportMidiStreamUart(void)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB,("~CMiniportMidiStreamUart"));

    if (m_pMiniport)
    {
        if (m_fCapture)
        {
            m_pMiniport->m_NumCaptureStreams--;
        }
        else
        {
            m_pMiniport->m_NumRenderStreams--;
        }
        _DbgPrintF(DEBUGLVL_VERBOSE,("~CMiniportMidiStreamUart: m_NumRenderStreams %d, m_NumCaptureStreams %d",
                                      m_pMiniport->m_NumRenderStreams,m_pMiniport->m_NumCaptureStreams));

        m_pMiniport->Release();
    }
    else
    {
        _DbgPrintF(DEBUGLVL_VERBOSE,("~CMiniportMidiStreamUart, no miniport!!!: m_NumRenderStreams %d, m_NumCaptureStreams %d",
                                      m_pMiniport->m_NumRenderStreams,m_pMiniport->m_NumCaptureStreams));
    }
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportMidiStreamUart::Init()
 *****************************************************************************
 * Initializes a stream.
 */
STDMETHODIMP_(NTSTATUS) 
CMiniportMidiStreamUart::
Init
(
    IN      CMiniportMidiUart * pMiniport,
    IN      PUCHAR              pPortBase,
    IN      BOOLEAN             fCapture
)
{
    PAGED_CODE();

    ASSERT(pMiniport);
    ASSERT(pPortBase);

    _DbgPrintF(DEBUGLVL_VERBOSE,("Init"));

    m_NumFailedMPUTries = 0;
    m_pMiniport = pMiniport;
    m_pMiniport->AddRef();

    m_pPortBase = pPortBase;
    m_fCapture = fCapture;

    return STATUS_SUCCESS;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportMidiStreamUart::SetState()
 *****************************************************************************
 * Sets the state of the channel.
 */
STDMETHODIMP_(NTSTATUS)
CMiniportMidiStreamUart::
SetState
(
    IN      KSSTATE     NewState
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE,("SetState %d",NewState));

    if (NewState == KSSTATE_RUN)
    {
        if (!m_pMiniport->m_fMPUInitialized)
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("CMiniportMidiStreamUart::SetState KSSTATE_RUN failed due to uninitialized MPU"));
            return STATUS_INVALID_DEVICE_STATE;
        }
    }

    if (m_fCapture)
    {
        m_pMiniport->m_KSStateInput = NewState;
        if (NewState == KSSTATE_STOP)   // STOPping
        {
            m_pMiniport->m_MPUInputBufferHead = 0;   // Previously read bytes are discarded.
            m_pMiniport->m_MPUInputBufferTail = 0;   // The entire FIFO is available.
        }
    }
    return STATUS_SUCCESS;
}

#pragma code_seg()
/*****************************************************************************
 * CMiniportMidiUart::Service()
 *****************************************************************************
 * DPC-mode service call from the port.
 */
STDMETHODIMP_(void) 
CMiniportMidiUart::
Service
(   void
)
{
    _DbgPrintF(DEBUGLVL_BLAB, ("Service"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("Service: m_NumRenderStreams %d, m_NumCaptureStreams %d",
                                  m_NumRenderStreams,m_NumCaptureStreams));
    if (!m_NumCaptureStreams)
    {
        //  we should never get here....
        //  if we do, we must have read some trash,
        //  so just reset the input FIFO
        m_MPUInputBufferTail = m_MPUInputBufferHead = 0;
    }
}

#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\miniport\fmsynth\miniport.h ===
//
// Copyright (c) 1997-2000 Microsoft Corporation.  All rights reserved.
//
// ======================================================================
//  miniport.h
//      defines globals used by miniport.cpp
//
// ======================================================================
/* MIDI defines */
#define NUMCHANNELS                     (16)
#define NUMPATCHES                      (256)
#define DRUMCHANNEL                     (9)     /* midi channel 10 */


#define BCODE
#define fEnabled TRUE



#define AsULMUL(a, b) ((DWORD)((DWORD)(a) * (DWORD)(b)))
#define AsLSHL(a, b) ((DWORD)((DWORD)(a) << (DWORD)(b)))
#define AsULSHR(a, b) ((DWORD)((DWORD)(a) >> (DWORD)(b)))

#define AsMemCopy CopyMemory

// indexed FM registers

#define AD_LSI                          (0x000)
#define AD_LSI2                         (0x101)
#define AD_TIMER1                       (0x001)
#define AD_TIMER2                       (0x002)
#define AD_MASK                         (0x004)
#define AD_CONNECTION                   (0x104)
#define AD_NEW                          (0x105)
#define AD_NTS                          (0x008)
#define AD_MULT                         (0x020)
#define AD_MULT2                        (0x120)
#define AD_LEVEL                        (0x040)
#define AD_LEVEL2                       (0x140)
#define AD_AD                           (0x060)
#define AD_AD2                          (0x160)
#define AD_SR                           (0x080)
#define AD_SR2                          (0x180)
#define AD_FNUMBER                      (0x0a0)
#define AD_FNUMBER2                     (0x1a0)
#define AD_BLOCK                        (0x0b0)
#define AD_BLOCK2                       (0x1b0)
#define AD_DRUM                         (0x0bd)
#define AD_FEEDBACK                     (0x0c0)
#define AD_FEEDBACK2                    (0x1c0)
#define AD_WAVE                         (0x0e0)
#define AD_WAVE2                        (0x1e0)

/* transformation of linear velocity value to
        logarithmic attenuation */
BYTE gbVelocityAtten[64] = {
        40, 37, 35, 33, 31, 29, 27, 25, 24, 22, 21, 20, 19, 18, 17, 16,
        16, 15, 14, 14, 13, 13, 12, 12, 11, 11, 10, 10, 9,  9,  8,  8,
        7,  7,  6,  6,  6,  5,  5,  5,  4,  4,  4,  4,  3,  3,  3,  3,
        2,  2,  2,  2,  2,  1,  1,  1,  1,  1,  0,  0,  0,  0,  0,  0 };
/*
                                        o
                                     o
                                   o
                                 o
                               o
                             o
                           o
                         o
                        o
                      o
                     o
                    o
                   o
                  o
                 o
                o
                o
               o
              o
              o
             o
             o
            o
            o
           o
           o
          o
          o
         o
         o
        o
        o
       o
       o
      o
      o
      o
     o
     o
     o
    o
    o
    o
    o
   o
   o
   o
   o
  o
  o
  o
  o
  o
 o
 o
 o
 o
 o
o
o
o
o
o
o
*/

BYTE BCODE gbPercMap[53][2] =
{
   {  0, 35 },
   {  0, 35 },
   {  2, 52 },
   {  3, 48 },
   {  4, 58 },
   {  5, 60 },
   {  6, 47 },
   {  7, 43 },
   {  6, 49 },
   {  9, 43 },
   {  6, 51 },
   { 11, 43 },
   {  6, 54 },
   {  6, 57 },
   { 14, 72 },
   {  6, 60 },
   { 16, 76 },
   { 17, 84 },
   { 18, 36 },
   { 19, 76 },
   { 20, 84 },
   { 21, 83 },
   { 22, 84 },
   { 23, 24 },
   { 16, 77 },
   { 25, 60 },
   { 26, 65 },
   { 27, 59 },
   { 28, 51 },
   { 29, 45 },
   { 30, 71 },
   { 31, 60 },
   { 32, 58 },
   { 33, 53 },
   { 34, 64 },
   { 35, 71 },
   { 36, 61 },
   { 37, 61 },
   { 38, 48 },
   { 39, 48 },
   { 40, 69 },
   { 41, 68 },
   { 42, 63 },
   { 43, 74 },
   { 44, 60 },
   { 45, 80 },
   { 46, 64 },
   { 47, 69 },
   { 48, 73 },
   { 49, 75 },
   { 50, 68 },
   { 51, 48 },
   { 52, 53 }
} ;


/* typedefs for MIDI patches */
#define PATCH_1_4OP             (0) /* use 4-operator patch */
#define PATCH_2_2OP             (1) /* use two 2-operator patches */
#define PATCH_1_2OP             (2) /* use one 2-operator patch */

#define NUM2VOICES   18
#define NUMOPS      4

#pragma pack (1)

typedef struct _operStruct {
    BYTE    bAt20;              /* flags which are send to 0x20 on fm */
    BYTE    bAt40;              /* flags seet to 0x40 */
                                /* the note velocity & midi velocity affect total level */
    BYTE    bAt60;              /* flags sent to 0x60 */
    BYTE    bAt80;              /* flags sent to 0x80 */
    BYTE    bAtE0;              /* flags send to 0xe0 */
} operStruct;

typedef struct _noteStruct {
    operStruct op[NUMOPS];      /* operators */
    BYTE    bAtA0[2];           /* send to 0xA0, A3 */
    BYTE    bAtB0[2];           /* send to 0xB0, B3 */
                                /* use in a patch, the block should be 4 to indicate
                                    normal pitch, 3 => octave below, etc. */
    BYTE    bAtC0[2];           /* sent to 0xc0, C3 */
    BYTE    bOp;                /* see PATCH_??? */
    BYTE    bDummy;             /* place holder */
} noteStruct;


typedef struct _patchStruct {
    noteStruct note;            /* note. This is all in the structure at the moment */
} patchStruct;


#include "patch.h"

#pragma pack()

/* MIDI */

typedef struct _voiceStruct {
        BYTE    bNote;                  /* note played */
        BYTE    bChannel;               /* channel played on */
        BYTE    bPatch;                 /* what patch is the note,
                                           drums patch = drum note + 128 */
        BYTE    bOn;                    /* TRUE if note is on, FALSE if off */
        BYTE    bVelocity;              /* velocity */
        BYTE    bJunk;                  /* filler */
        DWORD   dwTime;                 /* time that was turned on/off;
                                           0 time indicates that its not in use */
        DWORD   dwOrigPitch[2];         /* original pitch, for pitch bend */
        BYTE    bBlock[2];              /* value sent to the block */
        BYTE    bSusHeld;               /* turned off, but held on by sustain */
} voiceStruct;


/* a bit of tuning information */
#define FSAMP                           (50000.0)     /* sampling frequency */
#define PITCH(x)                        ((DWORD)((x) * (double) (1L << 19) / FSAMP))
                            /* x is the desired frequency,
                                == FNUM at b=1 */
#define EQUAL                           (1.059463094359)
#ifdef EUROPE
#       define  A                                                       (442.0)
#else
#       define  A                           (440.0)
#endif
#define ASHARP                          (A * EQUAL)
#define B                               (ASHARP * EQUAL)
#define C                               (B * EQUAL / 2.0)
#define CSHARP                          (C * EQUAL)
#define D                               (CSHARP * EQUAL)
#define DSHARP                          (D * EQUAL)
#define E                               (DSHARP * EQUAL)
#define F                               (E * EQUAL)
#define FSHARP                          (F * EQUAL)
#define G                               (FSHARP * EQUAL)
#define GSHARP                          (G * EQUAL)


/* operator offset location */
static WORD BCODE gw2OpOffset[ NUM2VOICES ][ 2 ] =
   {
     { 0x000,0x003 },
     { 0x001,0x004 },
     { 0x002,0x005 },
     { 0x008,0x00b },
     { 0x009,0x00c },
     { 0x00a,0x00d },
     { 0x010,0x013 },
     { 0x011,0x014 },
     { 0x012,0x015 },

     { 0x100,0x103 },
     { 0x101,0x104 },
     { 0x102,0x105 },
     { 0x108,0x10b },
     { 0x109,0x10c },
     { 0x10a,0x10d },
     { 0x110,0x113 },
     { 0x111,0x114 },
     { 0x112,0x115 },
   } ;

/* pitch values, from middle c, to octave above it */
static DWORD BCODE gdwPitch[12] = {
        PITCH(C), PITCH(CSHARP), PITCH(D), PITCH(DSHARP),
        PITCH(E), PITCH(F), PITCH(FSHARP), PITCH(G),
        PITCH(GSHARP), PITCH(A), PITCH(ASHARP), PITCH(B)};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\miniport\fmsynth\miniport.cpp ===
// ==============================================================================
//
// miniport.cpp - miniport driver implementation for FM synth.
// Copyright (c) 1996-2000 Microsoft Corporation.  All rights reserved.
//
// ==============================================================================

#include "private.h"    // contains class definitions.

#define STR_MODULENAME "FMSynth: "


#pragma code_seg("PAGE")
// ==============================================================================
// CreateMiniportMidiFM()
// Creates a MIDI FM miniport driver.  This uses a
// macro from STDUNK.H to do all the work.
// ==============================================================================
NTSTATUS CreateMiniportMidiFM
(
OUT     PUNKNOWN *  Unknown,
IN      REFCLSID    ClassID,
IN      PUNKNOWN    UnknownOuter    OPTIONAL,
IN      POOL_TYPE   PoolType
)
{
    PAGED_CODE();

    ASSERT(Unknown);

    _DbgPrintF(DEBUGLVL_VERBOSE, ("CreateMiniportMidiFM"));

//  expand STD_CREATE_BODY_ to take constructor(boolean) for whether to include volume
    NTSTATUS ntStatus;
    CMiniportMidiFM *p =  
        new(PoolType,'MFcP') CMiniportMidiFM(
                                 UnknownOuter,
                                 (IsEqualGUIDAligned(ClassID,CLSID_MiniportDriverFmSynthWithVol))
                             );

#ifdef DEBUG
    if (IsEqualGUIDAligned(ClassID,CLSID_MiniportDriverFmSynthWithVol))
    {
        _DbgPrintF(DEBUGLVL_VERBOSE, ("Creating new FM miniport with volume node"));
    }
#endif
    if (p)
    {
        *Unknown = PUNKNOWN((PMINIPORTMIDI)(p));
        (*Unknown)->AddRef();
        ntStatus = STATUS_SUCCESS;
    }
    else
    {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    return ntStatus;
}

#pragma code_seg("PAGE")
// ==============================================================================
// CMiniportMidiFM::ProcessResources()
// Processes the resource list.
// ==============================================================================
NTSTATUS
CMiniportMidiFM::
ProcessResources
(
IN  PRESOURCELIST   ResourceList
)
{
    PAGED_CODE();

    ASSERT(ResourceList);
    if (!ResourceList)
    {
        return STATUS_DEVICE_CONFIGURATION_ERROR;
    }

    _DbgPrintF(DEBUGLVL_VERBOSE,("CMiniportMidiFM::ProcessResources"));

    //
    // Get counts for the types of resources.
    //
    ULONG       countIO     = ResourceList->NumberOfPorts();
    ULONG       countIRQ    = ResourceList->NumberOfInterrupts();
    ULONG       countDMA    = ResourceList->NumberOfDmas();

    NTSTATUS ntStatus = STATUS_SUCCESS;

    //
    // Make sure we have the expected number of resources.
    //
    if  (   (countIO != 1)
        ||  (countIRQ != 0)
        ||  (countDMA != 0)
        )
    {
        ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
    }

    if (NT_SUCCESS(ntStatus))
    {
        //
        // Get the port address.
        //
        m_PortBase = PUCHAR(ResourceList->FindTranslatedPort(0)->u.Port.Start.QuadPart);
        _DbgPrintF(DEBUGLVL_VERBOSE, ("Port Address = 0x%X", m_PortBase));
    }

    return ntStatus;
}

#pragma code_seg("PAGE")
// ==============================================================================
// CMiniportMidiFM::NonDelegatingQueryInterface()
// Obtains an interface.  This function works just like a COM QueryInterface
// call and is used if the object is not being aggregated.
// ==============================================================================
STDMETHODIMP_(NTSTATUS) CMiniportMidiFM::NonDelegatingQueryInterface
(
REFIID  Interface,
PVOID * Object
)
{
    PAGED_CODE();

    ASSERT(Object);

    _DbgPrintF(DEBUGLVL_VERBOSE,("CMiniportMidiFM::NonDelegatingQueryInterface"));

    if (IsEqualGUIDAligned(Interface,IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(PMINIPORT(this)));
    }
    else if (IsEqualGUIDAligned(Interface,IID_IMiniport))
    {
        *Object = PVOID(PMINIPORT(this));
    }
    else if (IsEqualGUIDAligned(Interface,IID_IMiniportMidi))
    {
        *Object = PVOID(PMINIPORTMIDI(this));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IPowerNotify))
    {
        *Object = PVOID(PPOWERNOTIFY(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        //
        // We reference the interface for the caller.
        //
        PUNKNOWN((PMINIPORT)*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

#pragma code_seg()
// ==============================================================================
// CMiniportMidiFM::~CMiniportMidiFM()
// Destructor.
// ==============================================================================
CMiniportMidiFM::~CMiniportMidiFM
(
void
)
{
    KIRQL   oldIrql;
    _DbgPrintF(DEBUGLVL_VERBOSE,("CMiniportMidiFM::~CMiniportMidiFM"));

    KeAcquireSpinLock(&m_SpinLock,&oldIrql);
    // Set silence on the device
    Opl3_BoardReset();

    KeReleaseSpinLock(&m_SpinLock,oldIrql);

    if (m_Port)
    {
        m_Port->Release();
    }
}

#pragma code_seg()
// ==============================================================================
// CMiniportMidiFM::Init()
// Initializes a the miniport.
// ==============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportMidiFM::
Init
(
    IN      PUNKNOWN        UnknownAdapter  OPTIONAL,
    IN      PRESOURCELIST   ResourceList,
    IN      PPORTMIDI       Port_,
    OUT     PSERVICEGROUP * ServiceGroup
)
{
    PAGED_CODE();

    ASSERT(ResourceList);
    if (!ResourceList)
    {
        return STATUS_DEVICE_CONFIGURATION_ERROR;
    }
    ASSERT(Port_);
    ASSERT(ServiceGroup);

    int i;
    
    _DbgPrintF(DEBUGLVL_VERBOSE,("CMiniportMidiFM::init"));

    //
    // AddRef() is required because we are keeping this pointer.
    //
    m_Port = Port_;
    m_Port->AddRef();

    //
    // m_fStreamExists is not explicitly set to FALSE because C++ zeros 
    // them out on a 'new'
    //

    KeInitializeSpinLock(&m_SpinLock);
    //
    // We want the IAdapterCommon interface on the adapter common object,
    // which is given to us as a IUnknown.  The QueryInterface call gives us
    // an AddRefed pointer to the interface we want.
    //
    NTSTATUS ntStatus = ProcessResources(ResourceList);

    if (NT_SUCCESS(ntStatus))
    {
        KIRQL oldIrql;
        KeAcquireSpinLock(&m_SpinLock,&oldIrql);

        for (i = 0; i < 0x200; i++)    // initialize the shadow registers, used
           m_SavedRegValues[i] = 0x00; // in case of power-down during playback

        // Initialize the hardware.
        // 1. First check to see if an opl device is present.
        // 2. Then determine if it is an opl2 or opl3. Bail if opl2.
        // 3. Call Opl3_BoardReset to silence and reset the device.
        if (SoundSynthPresent(m_PortBase, m_PortBase))
        {
            // Now check if the device is an opl2 or opl3 type.
            // The patches are already declared for opl3. So Init() is not defined.
            // For opl2 we have to go through an init and load the patches structure.
            if (SoundMidiIsOpl3())
            {
                _DbgPrintF(DEBUGLVL_VERBOSE, ("CMiniportMidiFM::Init Type = OPL3"));
                // now silence the device and reset the board.
                Opl3_BoardReset();

                *ServiceGroup = NULL;
            }
            else
            {
                _DbgPrintF(DEBUGLVL_TERSE, ("CMiniportMidiFM::Init Type = OPL2"));
                ntStatus = STATUS_NOT_IMPLEMENTED;                
            }

        }
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("CMiniportMidiFM::Init SoundSynthPresent failed"));
            ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
        }
        KeReleaseSpinLock(&m_SpinLock,oldIrql);
    }
    else
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("CMiniportMidiFM::Init ProcessResources failed"));
    }

    _DbgPrintF(DEBUGLVL_VERBOSE, ("CMiniportMidiFM::Init returning 0x%X", ntStatus));

    if (!NT_SUCCESS(ntStatus))
    {
        //
        // clean up our mess
        //

        // release the port
        m_Port->Release();
        m_Port = NULL;
    }

    return ntStatus;
}

#pragma code_seg("PAGE")
// ==============================================================================
// NewStream()
// Creates a new stream.
// ==============================================================================
STDMETHODIMP_(NTSTATUS) 
CMiniportMidiFM::
NewStream
(
    OUT     PMINIPORTMIDISTREAM *   Stream,
    IN      PUNKNOWN                OuterUnknown    OPTIONAL,
    IN      POOL_TYPE               PoolType,
    IN      ULONG                   Pin,
    IN      BOOLEAN                 Capture,
    IN      PKSDATAFORMAT           DataFormat,
    OUT     PSERVICEGROUP *         ServiceGroup
)
{
    PAGED_CODE();

    NTSTATUS ntStatus = STATUS_SUCCESS;

    if (m_fStreamExists)
    {
        _DbgPrintF(DEBUGLVL_TERSE,("CMiniportMidiFM::NewStream stream already exists"));
        ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    }
    else
    {
        _DbgPrintF(DEBUGLVL_VERBOSE,("CMiniportMidiFM::NewStream"));
        CMiniportMidiStreamFM *pStream =
            new(PoolType) CMiniportMidiStreamFM(OuterUnknown);

        if (pStream)
        {
            pStream->AddRef();

            ntStatus = pStream->Init(this,m_PortBase);

            if (NT_SUCCESS(ntStatus))
            {
                *Stream = PMINIPORTMIDISTREAM(pStream);
                (*Stream)->AddRef();

                *ServiceGroup = NULL;
                m_fStreamExists = TRUE;
            }

            pStream->Release();
        }
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE,("CMiniportMidiFM::NewStream failed, no memory"));
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    return ntStatus;
}

#pragma code_seg("PAGE")
/*----------------------------------------------------------------------------
 FUNCTION NAME- CMiniportMidiFM::PowerChangeNotify()
 ENTRY      --- IN  POWER_STATE     NewState
                        power management status
 RETURN     --- void
 *------------------------------------------------------------------------- */
STDMETHODIMP_(void) CMiniportMidiFM::PowerChangeNotify(
    IN  POWER_STATE     PowerState
) 
{
    PAGED_CODE();
    _DbgPrintF(DEBUGLVL_VERBOSE,("CMiniportMidiFM::PowerChangeNotify(%d)",PowerState));

    switch (PowerState.DeviceState)
    {
        case PowerDeviceD0:
            if (m_PowerState.DeviceState != PowerDeviceD0) // check for power state delta
            {
                MiniportMidiFMResume();
            }
            break;

        case PowerDeviceD1:
        case PowerDeviceD2:
        case PowerDeviceD3:
        default:
            //  Don't need to do anything special, we always remember where we are.
            break;
    }
    m_PowerState.DeviceState = PowerState.DeviceState;
}

#pragma code_seg()
// ==========================================================================
// ==========================================================================
void
CMiniportMidiFM::
MiniportMidiFMResume()
{
    KIRQL   oldIrql;
    BYTE    i;
    
    _DbgPrintF(DEBUGLVL_VERBOSE,("CMiniportMidiFM::MiniportMidiFMResume"));
    KeAcquireSpinLock(&m_SpinLock,&oldIrql);
    //  We never touch these--set them to the default value anyway.
    //  AD_LSI
    SoundMidiSendFM(m_PortBase, AD_LSI, m_SavedRegValues[AD_LSI]);
    //  AD_LSI2
    SoundMidiSendFM(m_PortBase, AD_LSI2, m_SavedRegValues[AD_LSI2]);
    //  AD_TIMER1
    SoundMidiSendFM(m_PortBase, AD_TIMER1, m_SavedRegValues[AD_TIMER1]);
    //  AD_TIMER2
    SoundMidiSendFM(m_PortBase, AD_TIMER2, m_SavedRegValues[AD_TIMER2]);

    //  AD_MASK
    SoundMidiSendFM(m_PortBase, AD_MASK, m_SavedRegValues[AD_MASK]);
    
    //  AD_CONNECTION
    SoundMidiSendFM(m_PortBase, AD_CONNECTION, m_SavedRegValues[AD_CONNECTION]);

    //  AD_NEW
    SoundMidiSendFM(m_PortBase, AD_NEW, m_SavedRegValues[AD_NEW]);
    
    //  AD_NTS
    SoundMidiSendFM(m_PortBase, AD_NTS, m_SavedRegValues[AD_NTS]);
  
    //  AD_DRUM
    SoundMidiSendFM(m_PortBase, AD_DRUM, m_SavedRegValues[AD_DRUM]);
  
    for (i = 0; i <= 0x15; i++) 
    {
        if ((i & 0x07) <= 0x05)
        {
            //  AD_MULT
            //  AD_MULT2
            SoundMidiSendFM(m_PortBase, AD_MULT + i, m_SavedRegValues[AD_MULT + i]);
            SoundMidiSendFM(m_PortBase, AD_MULT2 + i, m_SavedRegValues[AD_MULT2 + i]);

            //  AD_LEVEL
            //  AD_LEVEL2
            //  turn off all the oscillators
            SoundMidiSendFM(m_PortBase, AD_LEVEL + i, m_SavedRegValues[AD_LEVEL + i]);
            SoundMidiSendFM(m_PortBase, AD_LEVEL2 + i, m_SavedRegValues[AD_LEVEL2 + i]);

            //  AD_AD
            //  AD_AD2
            SoundMidiSendFM(m_PortBase, AD_AD + i, m_SavedRegValues[AD_AD + i]);
            SoundMidiSendFM(m_PortBase, AD_AD2 + i, m_SavedRegValues[AD_AD2 + i]);

            //  AD_SR
            //  AD_SR2
            SoundMidiSendFM(m_PortBase, AD_SR + i, m_SavedRegValues[AD_SR + i]);
            SoundMidiSendFM(m_PortBase, AD_SR2 + i, m_SavedRegValues[AD_SR2 + i]);

            //  AD_WAVE
            //  AD_WAVE2
            SoundMidiSendFM(m_PortBase, AD_WAVE + i, m_SavedRegValues[AD_WAVE + i]);
            SoundMidiSendFM(m_PortBase, AD_WAVE2 + i, m_SavedRegValues[AD_WAVE2 + i]);
        }
    }
    
    for (i = 0; i <= 0x08; i++) 
    {
        //  AD_FNUMBER
        //  AD_FNUMBER2
        SoundMidiSendFM(m_PortBase, AD_FNUMBER + i, m_SavedRegValues[AD_FNUMBER + i]);
        SoundMidiSendFM(m_PortBase, AD_FNUMBER2 + i, m_SavedRegValues[AD_FNUMBER2 + i]);

        //  AD_FEEDBACK
        //  AD_FEEDBACK2
        SoundMidiSendFM(m_PortBase, AD_FEEDBACK + i, m_SavedRegValues[AD_FEEDBACK + i]);
        SoundMidiSendFM(m_PortBase, AD_FEEDBACK2 + i, m_SavedRegValues[AD_FEEDBACK2 + i]);

        //  AD_BLOCK
        //  AD_BLOCK2
        SoundMidiSendFM(m_PortBase, AD_BLOCK + i, m_SavedRegValues[AD_BLOCK + i]);
        SoundMidiSendFM(m_PortBase, AD_BLOCK2 + i, m_SavedRegValues[AD_BLOCK2 + i]);
    }
    KeReleaseSpinLock(&m_SpinLock,oldIrql);

    _DbgPrintF(DEBUGLVL_VERBOSE,("Done with CMiniportMidiFM::MiniportMidiFMResume"));
}

#pragma code_seg()
void 
CMiniportMidiFM::
Opl3_BoardReset()
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    BYTE i;
    
    _DbgPrintF(DEBUGLVL_VERBOSE,("CMiniportMidiFM::Opl3_BoardReset"));
    /* ---- silence the chip -------- */

    /* tell the FM chip to use 4-operator mode, and
    fill in any other random variables */
    SoundMidiSendFM(m_PortBase, AD_NEW, 0x01);
    SoundMidiSendFM(m_PortBase, AD_MASK, 0x60);
    SoundMidiSendFM(m_PortBase, AD_CONNECTION, 0x00);
    SoundMidiSendFM(m_PortBase, AD_NTS, 0x00);

    /* turn off the drums, and use high vibrato/modulation */
    SoundMidiSendFM(m_PortBase, AD_DRUM, 0xc0);

    /* turn off all the oscillators */
    for (i = 0; i <= 0x15; i++) 
    {
        if ((i & 0x07) <= 0x05)
        {
            SoundMidiSendFM(m_PortBase, AD_LEVEL + i, 0x3f);
            SoundMidiSendFM(m_PortBase, AD_LEVEL2 + i, 0x3f);
        }
    };

    /* turn off all the voices */
    for (i = 0; i <= 0x08; i++) 
    {
        SoundMidiSendFM(m_PortBase, AD_BLOCK + i, 0x00);
        SoundMidiSendFM(m_PortBase, AD_BLOCK2 + i, 0x00);
    };
}


// ==============================================================================
// PinDataRangesStream
// Structures indicating range of valid format values for streaming pins.
// ==============================================================================
static
KSDATARANGE_MUSIC PinDataRangesStream[] =
{
    {
        {
            sizeof(KSDATARANGE_MUSIC),
            0,
            0,
            0,
            STATICGUIDOF(KSDATAFORMAT_TYPE_MUSIC),
            STATICGUIDOF(KSDATAFORMAT_SUBTYPE_MIDI),
            STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE)
        },
        STATICGUIDOF(KSMUSIC_TECHNOLOGY_FMSYNTH),
        NUM2VOICES,
        NUM2VOICES,
        0xffffffff
    }
};

// ==============================================================================
// PinDataRangePointersStream
// List of pointers to structures indicating range of valid format values
// for streaming pins.
// ==============================================================================
static
PKSDATARANGE PinDataRangePointersStream[] =
{
    PKSDATARANGE(&PinDataRangesStream[0])
};

// ==============================================================================
// PinDataRangesBridge
// Structures indicating range of valid format values for bridge pins.
// ==============================================================================
static
KSDATARANGE PinDataRangesBridge[] =
{
   {
      sizeof(KSDATARANGE),
      0,
      0,
      0,
      STATICGUIDOF(KSDATAFORMAT_TYPE_MUSIC),
      STATICGUIDOF(KSDATAFORMAT_SUBTYPE_MIDI_BUS),
      STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE)
   }
};

// ==============================================================================
// PinDataRangePointersBridge
// List of pointers to structures indicating range of valid format values
// for bridge pins.
// ==============================================================================
static
PKSDATARANGE PinDataRangePointersBridge[] =
{
    &PinDataRangesBridge[0]
};

// ==============================================================================
// MiniportPins
// List of pins.
// ==============================================================================
static
PCPIN_DESCRIPTOR MiniportPins[] =
{
    {
        1,1,1,  // InstanceCount
        NULL,   // AutomationTable
        {       // KsPinDescriptor
            0,                                          // InterfacesCount
            NULL,                                       // Interfaces
            0,                                          // MediumsCount
            NULL,                                       // Mediums
            SIZEOF_ARRAY(PinDataRangePointersStream),   // DataRangesCount
            PinDataRangePointersStream,                 // DataRanges
            KSPIN_DATAFLOW_IN,                          // DataFlow
            KSPIN_COMMUNICATION_SINK,                   // Communication
            (GUID *) &KSNODETYPE_SYNTHESIZER,           // Category
            NULL,                                       // Name
            0                                           // Reserved
        }
    },
    {
        0,0,0,  // InstanceCount
        NULL,   // AutomationTable
        {       // KsPinDescriptor
            0,                                          // InterfacesCount
            NULL,                                       // Interfaces
            0,                                          // MediumsCount
            NULL,                                       // Mediums
            SIZEOF_ARRAY(PinDataRangePointersBridge),   // DataRangesCount
            PinDataRangePointersBridge,                 // DataRanges
            KSPIN_DATAFLOW_OUT,                         // DataFlow
            KSPIN_COMMUNICATION_NONE,                   // Communication
            (GUID *) &KSCATEGORY_AUDIO,                 // Category
            NULL,                                       // Name
            0                                           // Reserved
        }
    }
};

/*****************************************************************************
 * PropertiesVolume
 *****************************************************************************
 * Properties for volume controls.
 */
static
PCPROPERTY_ITEM PropertiesVolume[] =
{
    { 
        &KSPROPSETID_Audio, 
        KSPROPERTY_AUDIO_VOLUMELEVEL,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Level
    },
    {
        &KSPROPSETID_Audio,
        KSPROPERTY_AUDIO_CPU_RESOURCES,
        KSPROPERTY_TYPE_GET,
        PropertyHandler_CpuResources
    }
};

/*****************************************************************************
 * AutomationVolume
 *****************************************************************************
 * Automation table for volume controls.
 */
DEFINE_PCAUTOMATION_TABLE_PROP(AutomationVolume,PropertiesVolume);

// ==============================================================================
// MiniportNodes
// List of nodes.
// ==============================================================================
static
PCNODE_DESCRIPTOR MiniportNodes[] =
{
    {
            // synth node, #0
        0,                      // Flags
        NULL,                   // AutomationTable
        &KSNODETYPE_SYNTHESIZER,// Type
        NULL                    // Name TODO: fill in with correct GUID
    },
    {
            // volume node, #1
        0,                      // Flags
        &AutomationVolume,      // AutomationTable
        &KSNODETYPE_VOLUME,     // Type
        NULL                    // Name TODO: fill in with correct GUID
    }
};

// ==============================================================================
// MiniportConnections
// List of connections.
// ==============================================================================

/*****************************************************************************
 *      Table of topology unit connections.
 *
 * Pin numbering is technically arbitrary, but the convention established here
 * is to number a solitary output pin 0 (looks like an 'o') and a solitary
 * input pin 1 (looks like an 'i').  Even destinations, which have no output,
 * have an input pin numbered 1 and no pin 0.
 *
 * Nodes are more likely to have multiple ins than multiple outs, so the more
 * general rule would be that inputs are numbered >=1.  If a node has multiple
 * outs, none of these conventions apply.
 *
 * Nodes have at most one control value.  Mixers are therefore simple summing
 * nodes with no per-pin levels.  Rather than assigning a unique pin to each
 * input to a mixer, all inputs are connected to pin 1.  This is acceptable
 * because there is no functional distinction between the inputs.
 *
 * There are no multiplexers in this topology, so there is no opportunity to
 * give an example of a multiplexer.  A multiplexer should have a single
 * output pin (0) and multiple input pins (1..n).  Its control value is an
 * integer in the range 1..n indicating which input is connected to the
 * output.
 *
 * In the case of connections to pins, as opposed to connections to nodes, the
 * node is identified as PCFILTER_NODE and the pin number identifies the
 * particular filter pin.
 *****************************************************************************
 */
enum {
    eFMSynthNode  = 0,
    eFMVolumeNode
};

enum {
    eFMNodeOutput = 0,
    eFMNodeInput  = 1
};

enum {
    eFilterInput = eFMNodeOutput,
    eBridgeOutput = eFMNodeInput
};

static
PCCONNECTION_DESCRIPTOR MiniportConnections[] =
{
    //  FromNode,       FromPin,        ToNode,         ToPin
    {   PCFILTER_NODE,  eFilterInput,   eFMSynthNode,   eFMNodeInput }, // Stream in to synth.
    {   eFMSynthNode,   eFMNodeOutput,  PCFILTER_NODE,  eBridgeOutput } // Synth to bridge out.
};

// different connection struct for volume version
static
PCCONNECTION_DESCRIPTOR MiniportWithVolConnections[] =
{
    //  FromNode,       FromPin,        ToNode,         ToPin
    {   PCFILTER_NODE,  eFilterInput,   eFMSynthNode,   eFMNodeInput }, // Stream in to synth.
    {   eFMSynthNode,   eFMNodeOutput,  eFMVolumeNode,  eFMNodeInput }, // Synth to volume.
    {   eFMVolumeNode,  eFMNodeOutput,  PCFILTER_NODE,  eBridgeOutput } // volume to bridge out.
};

////////////////////////////////////////////////////////////////////////////////
// MiniportCategories
//
// List of categories.
static
GUID MiniportCategories[] =
{
    STATICGUIDOF(KSCATEGORY_AUDIO),
    STATICGUIDOF(KSCATEGORY_RENDER),
    STATICGUIDOF(KSCATEGORY_SYNTHESIZER)
};

// ==============================================================================
// MiniportDescription
// Complete description of the miniport.
// ==============================================================================
static
PCFILTER_DESCRIPTOR MiniportFilterDescriptor =
{
    0,                                  // Version
    NULL,                               // AutomationTable
    sizeof(PCPIN_DESCRIPTOR),           // PinSize
    SIZEOF_ARRAY(MiniportPins),         // PinCount
    MiniportPins,                       // Pins
    sizeof(PCNODE_DESCRIPTOR),          // NodeSize
    1,                                  // NodeCount - no volume node
    MiniportNodes,                      // Nodes
    SIZEOF_ARRAY(MiniportConnections),  // ConnectionCount
    MiniportConnections,                // Connections
    SIZEOF_ARRAY(MiniportCategories),   // CategoryCount
    MiniportCategories                  // Categories
};

static
PCFILTER_DESCRIPTOR MiniportFilterWithVolDescriptor =
{
    0,                                          // Version
    NULL,                                       // AutomationTable
    sizeof(PCPIN_DESCRIPTOR),                   // PinSize
    SIZEOF_ARRAY(MiniportPins),                 // PinCount
    MiniportPins,                               // Pins
    sizeof(PCNODE_DESCRIPTOR),                  // NodeSize
    2,                                          // NodeCount - extra volume node
    MiniportNodes,                              // Nodes
    SIZEOF_ARRAY(MiniportWithVolConnections),   // ConnectionCount
    MiniportWithVolConnections,                 // Connections
    0,                                          // CategoryCount
    NULL                                        // Categories
};

#pragma code_seg("PAGE")
// ==============================================================================
// CMiniportMidiFM::GetDescription()
// Gets the topology.
// Pass back appropriate descriptor, depending on whether volume node is needed.
// ==============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportMidiFM::
GetDescription
(
    OUT     PPCFILTER_DESCRIPTOR *  OutFilterDescriptor
)
{
    PAGED_CODE();

    ASSERT(OutFilterDescriptor);

    _DbgPrintF(DEBUGLVL_VERBOSE,("CMiniportMidiFM::GetDescription"));

    if (m_volNodeNeeded)
    {
        *OutFilterDescriptor = &MiniportFilterWithVolDescriptor;
        _DbgPrintF(DEBUGLVL_VERBOSE, ("Getting descriptor of new FM miniport with volume node"));
    }
    else
    {
        *OutFilterDescriptor = &MiniportFilterDescriptor;
    }

    return STATUS_SUCCESS;
}

#pragma code_seg("PAGE")
// ==============================================================================
// CMiniportMidiStreamFM::NonDelegatingQueryInterface()
// Obtains an interface.  This function works just like a COM QueryInterface
// call and is used if the object is not being aggregated.
// ==============================================================================
STDMETHODIMP_(NTSTATUS) CMiniportMidiStreamFM::NonDelegatingQueryInterface
(
REFIID  Interface,
PVOID * Object
)
{
    PAGED_CODE();

    ASSERT(Object);

    _DbgPrintF(DEBUGLVL_VERBOSE,("CMiniportMidiStreamFM::NonDelegatingQueryInterface"));

    if (IsEqualGUIDAligned(Interface,IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(PMINIPORT(this)));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IMiniportMidiStream))
    {
        *Object = PVOID(PMINIPORTMIDISTREAM(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        //
        // We reference the interface for the caller.
        //
        PUNKNOWN(PMINIPORT(*Object))->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

#pragma code_seg("PAGE")
// ==============================================================================
// CMiniportMidiStreamFM::~CMiniportMidiStreamFM()
// Destructor.
// ==============================================================================
CMiniportMidiStreamFM::~CMiniportMidiStreamFM
(
void
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE,("CMiniportMidiStreamFM::~CMiniportMidiStreamFM"));

    Opl3_AllNotesOff();

    if (m_Miniport)
    {
        m_Miniport->m_fStreamExists = FALSE;
        m_Miniport->Release();
    }
}

#pragma code_seg("PAGE")
// ==============================================================================
// CMiniportMidiStreamFM::Init()
// Initializes a the miniport.
// ==============================================================================
NTSTATUS
CMiniportMidiStreamFM::
Init
(
    IN      CMiniportMidiFM *   Miniport,
    IN      PUCHAR              PortBase
)
{
    PAGED_CODE();

    ASSERT(Miniport);
    ASSERT(PortBase);

    int i;

    _DbgPrintF(DEBUGLVL_VERBOSE,("CMiniportMidiStreamFM::Init"));

    //
    // AddRef() is required because we are keeping this pointer.
    //
    m_Miniport = Miniport;
    m_Miniport->AddRef();

    m_PortBase = PortBase;

    // init some members
    m_dwCurTime = 1;    /* for note on/off */
    /* volume */
    m_wSynthAttenL = 0;        /* in 1.5dB steps */
    m_wSynthAttenR = 0;        /* in 1.5dB steps */

    m_MinVolValue  = 0xFFD0C000;    //  minimum -47.25(dB) * 0x10000
    m_MaxVolValue  = 0x00000000;    //  maximum  0    (dB) * 0x10000
    m_VolStepDelta = 0x0000C000;    //  steps of 0.75 (dB) * 0x10000
    m_SavedVolValue[CHAN_LEFT] = m_SavedVolValue[CHAN_RIGHT] = 0;

    /* start attenuations at -3 dB, which is 90 MIDI level */
    for (i = 0; i < NUMCHANNELS; i++) 
    {
        m_bChanAtten[i] = 4;
        m_bStereoMask[i] = 0xff;
    };

    return STATUS_SUCCESS;
}

#pragma code_seg("PAGE")
// ==============================================================================
// CMiniportMidiStreamFM::SetState()
// Sets the transport state.
// ==============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportMidiStreamFM::
SetState
(
    IN      KSSTATE     NewState
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE,("CMiniportMidiStreamFM::SetState"));

    NTSTATUS ntStatus = STATUS_SUCCESS;

    switch (NewState)
    {
    case KSSTATE_STOP:
    case KSSTATE_ACQUIRE:
    case KSSTATE_PAUSE:
        Opl3_AllNotesOff();
        break;

    case KSSTATE_RUN:
        break;
    }

    return ntStatus;
}

#pragma code_seg("PAGE")
// ==============================================================================
// CMiniportMidiStreamFM::SetFormat()
// Sets the format.
// ==============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportMidiStreamFM::
SetFormat
(
    IN      PKSDATAFORMAT   Format
)
{
    PAGED_CODE();

    ASSERT(Format);

    _DbgPrintF(DEBUGLVL_VERBOSE,("CMiniportMidiStreamFM::SetFormat"));

    return STATUS_SUCCESS;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * BasicSupportHandler()
 *****************************************************************************
 * Assists in BASICSUPPORT accesses on level properties - 
 * this is declared as a friend method in the header file.
 */
static
NTSTATUS BasicSupportHandler
(
    IN  PPCPROPERTY_REQUEST PropertyRequest
)
{
    PAGED_CODE();
    ASSERT(PropertyRequest);

    _DbgPrintF(DEBUGLVL_VERBOSE, ("BasicSupportHandler"));

    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST;

    if (PropertyRequest->ValueSize >= (sizeof(KSPROPERTY_DESCRIPTION)))
    {
        // if return buffer can hold a KSPROPERTY_DESCRIPTION, return it
        PKSPROPERTY_DESCRIPTION PropDesc = PKSPROPERTY_DESCRIPTION(PropertyRequest->Value);

        PropDesc->AccessFlags = KSPROPERTY_TYPE_BASICSUPPORT |
                                KSPROPERTY_TYPE_GET |
                                KSPROPERTY_TYPE_SET;
        PropDesc->DescriptionSize   = sizeof(KSPROPERTY_DESCRIPTION) +
                                      sizeof(KSPROPERTY_MEMBERSHEADER) +
                                      sizeof(KSPROPERTY_STEPPING_LONG);
        PropDesc->PropTypeSet.Set   = KSPROPTYPESETID_General;
        PropDesc->PropTypeSet.Id    = VT_I4;
        PropDesc->PropTypeSet.Flags = 0;
        PropDesc->MembersListCount  = 1;
        PropDesc->Reserved          = 0;

        // if return buffer can also hold a range description, return it too
        if (PropertyRequest->ValueSize >= (sizeof(KSPROPERTY_DESCRIPTION) +
                                           sizeof(KSPROPERTY_MEMBERSHEADER) +
                                           sizeof(KSPROPERTY_STEPPING_LONG)))
        {
            // fill in the members header
            PKSPROPERTY_MEMBERSHEADER Members = PKSPROPERTY_MEMBERSHEADER(PropDesc + 1);

            Members->MembersFlags   = KSPROPERTY_MEMBER_STEPPEDRANGES;
            Members->MembersSize    = sizeof(KSPROPERTY_STEPPING_LONG);
            Members->MembersCount   = 1;
            Members->Flags          = 0;

            // fill in the stepped range
            PKSPROPERTY_STEPPING_LONG Range = PKSPROPERTY_STEPPING_LONG(Members + 1);

            switch (PropertyRequest->Node)
            {
                case eFMVolumeNode:
                    CMiniportMidiStreamFM *that = (CMiniportMidiStreamFM *)PropertyRequest->MinorTarget;

                    if (that)
                    {
                        Range->Bounds.SignedMinimum = that->m_MinVolValue;
                        Range->Bounds.SignedMaximum = that->m_MaxVolValue;
                        Range->SteppingDelta        = that->m_VolStepDelta;
                        break;
                    }
                    else
                    {
                        return STATUS_INVALID_PARAMETER;
                    }
            }

            Range->Reserved = 0;

            _DbgPrintF(DEBUGLVL_VERBOSE, ("---Node: %d  Max: 0x%X  Min: 0x%X  Step: 0x%X",PropertyRequest->Node,
                                       Range->Bounds.SignedMaximum,
                                       Range->Bounds.SignedMinimum,
                                       Range->SteppingDelta));

            // set the return value size
            PropertyRequest->ValueSize = sizeof(KSPROPERTY_DESCRIPTION) +
                                         sizeof(KSPROPERTY_MEMBERSHEADER) +
                                         sizeof(KSPROPERTY_STEPPING_LONG);
        }
        else
        {
            // set the return value size
            PropertyRequest->ValueSize = sizeof(KSPROPERTY_DESCRIPTION);
        }
        ntStatus = STATUS_SUCCESS;

    }
    else if (PropertyRequest->ValueSize >= sizeof(ULONG))
    {
        // if return buffer can hold a ULONG, return the access flags
        PULONG AccessFlags = PULONG(PropertyRequest->Value);

        *AccessFlags = KSPROPERTY_TYPE_BASICSUPPORT |
                       KSPROPERTY_TYPE_GET |
                       KSPROPERTY_TYPE_SET;

        // set the return value size
        PropertyRequest->ValueSize = sizeof(ULONG);
        ntStatus = STATUS_SUCCESS;

    }
    return ntStatus;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * PropertyHandler_Level()
 *****************************************************************************
 * Accesses a KSAUDIO_LEVEL property.
 */
static
NTSTATUS PropertyHandler_Level
(
    IN  PPCPROPERTY_REQUEST PropertyRequest
)
{
    PAGED_CODE();

    ASSERT(PropertyRequest);

    _DbgPrintF(DEBUGLVL_VERBOSE,("PropertyHandler_Level"));


    NTSTATUS        ntStatus = STATUS_INVALID_PARAMETER;
    LONG            channel;

    // validate node
    if (PropertyRequest->Node == eFMVolumeNode)
    {
        if (PropertyRequest->Verb & KSPROPERTY_TYPE_GET)
        {
            // get the instance channel parameter
            if (PropertyRequest->InstanceSize >= sizeof(LONG))
            {
                channel = *(PLONG(PropertyRequest->Instance));

                // only support get requests on either mono/left(0) or right(1) channels
                if ((channel == CHAN_LEFT) || (channel == CHAN_RIGHT))
                {
                    // validate and get the output parameter
                    if (PropertyRequest->ValueSize >= sizeof(LONG))
                    {
                        PLONG Level = (PLONG)PropertyRequest->Value;

                        // check if volume property request
                        if (PropertyRequest->PropertyItem->Id == KSPROPERTY_AUDIO_VOLUMELEVEL)
                        {
                            CMiniportMidiStreamFM *that = (CMiniportMidiStreamFM *)PropertyRequest->MinorTarget;
                            if (that)
                            {
                                *Level = that->GetFMAtten(channel);
                                PropertyRequest->ValueSize = sizeof(LONG);
                                ntStatus = STATUS_SUCCESS;
                            }
                            //  if (!that) return STATUS_INVALID_PARAMETER

                        }   // (PropertyItem->Id == KSPROPERTY_AUDIO_VOLUMELEVEL)
                    }     // (ValueSize >= sizeof(LONG))
                }       // ((channel == CHAN_LEFT) || (channel == CHAN_RIGHT))
            }         // (InstanceSize >= sizeof(LONG))
        }           // (Verb & KSPROPERTY_TYPE_GET)

        else if (PropertyRequest->Verb & KSPROPERTY_TYPE_SET)
        {
            // get the instance channel parameter
            if (PropertyRequest->InstanceSize >= sizeof(LONG))
            {
                channel = *(PLONG(PropertyRequest->Instance));

                // only support get requests on either mono/left (0), right (1), or master (-1) channels
                if ((channel == CHAN_LEFT) || (channel == CHAN_RIGHT) || (channel == CHAN_MASTER))
                {
                    // validate and get the input parameter
                    if (PropertyRequest->ValueSize == sizeof(LONG))
                    {
                        PLONG level = (PLONG)PropertyRequest->Value;

                        if (PropertyRequest->PropertyItem->Id == KSPROPERTY_AUDIO_VOLUMELEVEL)
                        {
                            CMiniportMidiStreamFM *that = (CMiniportMidiStreamFM *)PropertyRequest->MinorTarget;
                            if (that)
                            {
                                that->SetFMAtten(channel,*level);
                                ntStatus = STATUS_SUCCESS;
                            }
                            //  if (!that) return STATUS_INVALID_PARAMETER

                        }   // (PropertyItem->Id == KSPROPERTY_AUDIO_VOLUMELEVEL)
                    }     // (ValueSize == sizeof(LONG))
                }       // ((channel == CHAN_LEFT) || (channel == CHAN_RIGHT) || (channel == CHAN_MASTER))
            }         // (InstanceSize >= sizeof(LONG))
        }           // (Verb & KSPROPERTY_TYPE_SET)

        else if (PropertyRequest->Verb & KSPROPERTY_TYPE_BASICSUPPORT)
        {
            if (PropertyRequest->PropertyItem->Id == KSPROPERTY_AUDIO_VOLUMELEVEL)
            {
                ntStatus = BasicSupportHandler(PropertyRequest);
            }
        }   // (Verb & KSPROPERTY_TYPE_BASICSUPPORT) 
    }     // (Node == eFMVolumeNode)

    return ntStatus;
}

#pragma code_seg()
// convert from 16.16 dB to [0,63], set m_wSynthAttenR
void 
CMiniportMidiStreamFM::
SetFMAtten
(
    IN LONG channel, 
    IN LONG level
)
{
    KIRQL   oldIrql;
    if ((channel == CHAN_LEFT) || (channel == CHAN_MASTER))
    {
        m_SavedVolValue[CHAN_LEFT] = level;

        if (level > m_MaxVolValue)
            m_wSynthAttenL = 0;
        else if (level < m_MinVolValue)
            m_wSynthAttenL = 63;
        else
            m_wSynthAttenL = WORD(-level / (LONG)m_VolStepDelta);
    }
    if ((channel == CHAN_RIGHT) || (channel == CHAN_MASTER))
    {
        m_SavedVolValue[CHAN_RIGHT] = level;
    
        if (level > m_MaxVolValue)
            m_wSynthAttenR = 0;
        else if (level < m_MinVolValue)
            m_wSynthAttenR = 63;
        else
            m_wSynthAttenR = WORD(-level / (LONG)m_VolStepDelta);
    }
#ifdef USE_KDPRINT
    KdPrint(("'StreamFM::SetFMAtten: channel: 0x%X, level: 0x%X, m_wSynthAttenL: 0x%X, m_wSynthAttenR: 0x%X \n",
                                     channel,       level,       m_wSynthAttenL,       m_wSynthAttenR));
#else   //  USE_KDPRINT
    _DbgPrintF(DEBUGLVL_VERBOSE,("StreamFM::SetFMAtten: channel: 0x%X, level: 0x%X, m_wSynthAttenL: 0x%X, m_wSynthAttenR: 0x%X \n",
                                                        channel,       level,       m_wSynthAttenL,       m_wSynthAttenR));
#endif  //  USE_KDPRINT

    KeAcquireSpinLock(&m_Miniport->m_SpinLock,&oldIrql);
    Opl3_SetVolume(0xFF); //  0xFF means all channels
    KeReleaseSpinLock(&m_Miniport->m_SpinLock,oldIrql);
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * PropertyHandler_CpuResources()
 *****************************************************************************
 * Processes a KSPROPERTY_AUDIO_CPU_RESOURCES request
 */
static
NTSTATUS PropertyHandler_CpuResources
(
    IN  PPCPROPERTY_REQUEST   PropertyRequest
)
{
    PAGED_CODE();

    ASSERT(PropertyRequest);

    _DbgPrintF(DEBUGLVL_VERBOSE,("PropertyHandler_CpuResources"));

    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST;

    // validate node
    if(PropertyRequest->Node == eFMVolumeNode)
    {
        if(PropertyRequest->Verb & KSPROPERTY_TYPE_GET)
        {
            if(PropertyRequest->ValueSize >= sizeof(LONG))
            {
                *(PLONG(PropertyRequest->Value)) = KSAUDIO_CPU_RESOURCES_NOT_HOST_CPU;
                PropertyRequest->ValueSize = sizeof(LONG);
                ntStatus = STATUS_SUCCESS;
            } 
            else
            {
                _DbgPrintF(DEBUGLVL_VERBOSE,("PropertyHandler_CpuResources failed, buffer too small"));
                ntStatus = STATUS_BUFFER_TOO_SMALL;
            }
        }
    }
    return ntStatus;
}

#pragma code_seg()
// ==============================================================================
// SoundMidiSendFM
//  Writes out to the device.
//  Called from DPC code (Write->WriteMidiData->Opl3_NoteOn->Opl3_FMNote->here)
// ==============================================================================
void 
CMiniportMidiFM::
SoundMidiSendFM
(
IN    PUCHAR PortBase,
IN    ULONG Address,
IN    UCHAR Data
)
{
    ASSERT(Address < 0x200);
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    // these delays need to be 23us at least for old opl2 chips, even
    // though new chips can handle 1 us delays.

#ifdef USE_KDPRINT
    KdPrint(("'SoundMidiSendFM(%02x %02x) \n",Address,Data));
#else   //  USE_KDPRINT
    _DbgPrintF(DEBUGLVL_VERBOSE, ("%X\t%X", Address,Data));
#endif  //  USE_KDPRINT
    WRITE_PORT_UCHAR(PortBase + (Address < 0x100 ? 0 : 2), (UCHAR)Address);
    KeStallExecutionProcessor(23);

    WRITE_PORT_UCHAR(PortBase + (Address < 0x100 ? 1 : 3), Data);
    KeStallExecutionProcessor(23);

    m_SavedRegValues[Address] = Data;
}


#pragma code_seg()
// ==============================================================================
// Service()
// DPC-mode service call from the port.
// ==============================================================================
STDMETHODIMP_(void) 
CMiniportMidiFM::
Service
(   void
)
{
}

#pragma code_seg()
// ==============================================================================
// CMiniportMidiStreamFM::Read()
// Reads incoming MIDI data.
// ==============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportMidiStreamFM::
Read
(
    IN      PVOID   BufferAddress,
    IN      ULONG   Length,
    OUT     PULONG  BytesRead
)
{
    return STATUS_NOT_IMPLEMENTED;
}

#pragma code_seg()
// ==============================================================================
// CMiniportMidiStreamFM::Write()
// Writes outgoing MIDI data.  
// 
// N.B.!!!
// THIS DATA SINK ASSUMES THAT DATA COMES IN ONE MESSAGE AT A TIME!!!
// IF LENGTH IS MORE THAN THREE BYTES, SUCH AS SYSEX OR MULTIPLE MIDI 
// MESSAGES, ALL THE DATA IS DROPPED UNCEREMONIOUSLY ON THE FLOOR!!!
// ALSO DOES NOT PLAY WELL WITH RUNNING STATUS!!!
// 
// CLEARLY, THIS MINIPORT HAS SOME "ISSUES".
//
// ==============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportMidiStreamFM::
Write
(
    IN      PVOID   BufferAddress,  // pointer to Midi Data.
    IN      ULONG   Length,
    OUT     PULONG  BytesWritten
)
{
    ASSERT(BufferAddress);
    ASSERT(BytesWritten);

    _DbgPrintF(DEBUGLVL_VERBOSE, ("CMiniportMidiStreamFM::Write"));

    BYTE    statusByte = *(PBYTE)BufferAddress & 0xF0;
    *BytesWritten = Length;
    
    if (statusByte < 0x80)
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("CMiniportMidiStreamFM::Write requires first byte to be status -- ignored"));
    }
    else if (statusByte == 0xF0)
    {
        _DbgPrintF(DEBUGLVL_VERBOSE, ("StreamFM::Write doesn't handle System messages -- ignored"));
    }
    else if (statusByte == 0xA0)
    {
        _DbgPrintF(DEBUGLVL_VERBOSE, ("StreamFM::Write doesn't handle Polyphonic key pressure/Aftertouch messages -- ignored"));
    }
    else if (statusByte == 0xD0)
    {
        _DbgPrintF(DEBUGLVL_VERBOSE, ("StreamFM::Write doesn't handle Channel pressure/Aftertouch messages -- ignored"));
    }
    else if (Length < 4)
    {
        WriteMidiData(*(DWORD *)BufferAddress);
    }
    else 
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("StreamFM::Write doesn't handle Length > 3."));
    }   
    return STATUS_SUCCESS;
}

// ==============================================================================
// ==============================================================================
// Private Methods of CMiniportMidiFM
// ==============================================================================
// ==============================================================================


#pragma code_seg()
// =================================================================
// SoundMidiIsOpl3
// Checks if the midi synthesizer is Opl3 compatible or just adlib-compatible.
// returns:  TRUE if OPL3-compatible chip. FALSE otherwise.
//
// NOTE: This has been taken as is from the nt driver code.
// =================================================================
BOOL CMiniportMidiFM::
SoundMidiIsOpl3(void)
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    BOOL bIsOpl3 = FALSE;

    /*
     * theory: an opl3-compatible synthesizer chip looks
     * exactly like two separate 3812 synthesizers (for left and right
     * channels) until switched into opl3 mode. Then, the timer-control
     * register for the right half is replaced by a channel connection register
     * (among other changes).
     *
     * We can detect 3812 synthesizers by starting a timer and looking for
     * timer overflow. So if we find 3812s at both left and right addresses,
     * we then switch to opl3 mode and look again for the right-half. If we
     * still find it, then the switch failed and we have an old synthesizer
     * if the right half disappeared, we have a new opl3 synthesizer.
     *
     * NB we use either monaural base-level synthesis, or stereo opl3
     * synthesis. If we discover two 3812s (as on early SB Pro and
     * PAS), we ignore one of them.
     */

    /*
     * nice theory - but wrong. The timer on the right half of the
     * opl3 chip reports its status in the left-half status register.
     * There is no right-half status register on the opl3 chip.
     */


    /* ensure base mode */
    SoundMidiSendFM(m_PortBase, AD_NEW, 0x00);
    KeStallExecutionProcessor(20);

    /* look for right half of chip */
    if (SoundSynthPresent(m_PortBase + 2, m_PortBase))
    {
        /* yes - is this two separate chips or a new opl3 chip ? */
        /* switch to opl3 mode */
        SoundMidiSendFM(m_PortBase, AD_NEW, 0x01);
        KeStallExecutionProcessor(20);

        if (!SoundSynthPresent(m_PortBase + 2, m_PortBase))
        {
            _DbgPrintF(DEBUGLVL_VERBOSE, ("CMiniportMidiFM: In SoundMidiIsOpl3 right half disappeared"));
            /* right-half disappeared - so opl3 */
            bIsOpl3 = TRUE;
        }
    }

    if (!bIsOpl3)
    {
        /* reset to 3812 mode */
        SoundMidiSendFM(m_PortBase, AD_NEW, 0x00);
        KeStallExecutionProcessor(20);
    }

    _DbgPrintF(DEBUGLVL_VERBOSE, ("CMiniportMidiFM: In SoundMidiIsOpl3 returning bIsOpl3 = 0x%X", bIsOpl3));
    return(bIsOpl3);
}

#pragma code_seg()
// ==============================================================================
// SoundSynthPresent
//
// Detect the presence or absence of a 3812 (opl2/adlib-compatible) synthesizer
// at the given i/o address by starting the timer and looking for an
// overflow. Can be used to detect left and right synthesizers separately.
//
// Returns: True if a synthesiser is present at that address and false if not.
//
// NOTE: This and has been taken as is from the nt driver code.
// ==============================================================================
BOOL
CMiniportMidiFM::
SoundSynthPresent
(
IN PUCHAR   base,
IN PUCHAR inbase
)
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    UCHAR t1, t2;
    // check if the chip is present
    SoundMidiSendFM(base, 4, 0x60);             // mask T1 & T2
    SoundMidiSendFM(base, 4, 0x80);             // reset IRQ

    t1 = READ_PORT_UCHAR((PUCHAR)inbase);       // read status register

    SoundMidiSendFM(base, 2, 0xff);             // set timer - 1 latch
    SoundMidiSendFM(base, 4, 0x21);             // unmask & start T1

    // this timer should go off in 80 us. It sometimes
    // takes more than 100us, but will always have expired within
    // 200 us if it is ever going to.
    KeStallExecutionProcessor(200);

    t2 = READ_PORT_UCHAR((PUCHAR)inbase);       // read status register

    SoundMidiSendFM(base, 4, 0x60);
    SoundMidiSendFM(base, 4, 0x80);

    if (!((t1 & 0xE0) == 0) || !((t2 & 0xE0) == 0xC0))
    {
        _DbgPrintF(DEBUGLVL_VERBOSE, ("SoundSynthPresent: returning false"));
        return(FALSE);
    }
    _DbgPrintF(DEBUGLVL_VERBOSE, ("SoundSynthPresent: returning true"));
    return TRUE;
}


// ==============================================================================
// this array gives the offsets of the slots within an opl2
// chip. This is needed to set the attenuation for all slots to max,
// to ensure that the chip is silenced completely - switching off the
// voices alone will not do this.
// ==============================================================================
BYTE offsetSlot[] =
{
    0, 1, 2, 3, 4, 5,
    8, 9, 10, 11, 12, 13,
    16, 17, 18, 19, 20, 21
};

#pragma code_seg()
// =========================================================================
// WriteMidiData
//      Converts a MIDI atom into the corresponding FM transaction.
// =========================================================================
void
CMiniportMidiStreamFM::
WriteMidiData(DWORD dwData)
{
    BYTE    bMsgType,bChannel, bVelocity, bNote;
    WORD    wTemp;
    KIRQL   oldIrql;

    bMsgType = (BYTE) dwData & (BYTE)0xf0;
    bChannel = (BYTE) dwData & (BYTE)0x0f;
    bNote = (BYTE) ((WORD) dwData >> 8) & (BYTE)0x7f;
    bVelocity = (BYTE) (dwData >> 16) & (BYTE)0x7f;
    
#ifdef USE_KDPRINT
    KdPrint(("'StreamFM::WriteMidiData: (%x %x %x) \n",bMsgType+bChannel,bNote,bVelocity));
#else   //  USE_KDPRINT
    _DbgPrintF(DEBUGLVL_VERBOSE,("StreamFM::WriteMidiData: (%x %x %x) \n",bMsgType+bChannel,bNote,bVelocity));
#endif  //  USE_KDPRINT
    KeAcquireSpinLock(&m_Miniport->m_SpinLock,&oldIrql);
    switch (bMsgType)
    {
        case 0x90:      /* turn key on, or key off if volume == 0 */
            if (bVelocity)
            {
                if (bChannel == DRUMCHANNEL)
                {
                    Opl3_NoteOn((BYTE)(bNote + 128),bNote,bChannel,bVelocity,(short)m_iBend[bChannel]);
                }
                else
                {
                    Opl3_NoteOn((BYTE)m_bPatch[bChannel],bNote,bChannel,bVelocity,(short) m_iBend[bChannel]);
                }
                break;
            } // if bVelocity.
            //NOTE: no break specified here. On an else case we want to continue through and turn key off

        case 0x80:
            /* turn key off */
            //  we don't care what the velocity is on note off
            if (bChannel == DRUMCHANNEL)
            {
                Opl3_NoteOff((BYTE) (bNote + 128),bNote, bChannel, 0);
            }
            else
            {
                Opl3_NoteOff ((BYTE) m_bPatch[bChannel],bNote, bChannel, m_bSustain[ bChannel ]);
            }
            break;

        case 0xb0:
            /* change control */
            switch (bNote) 
            {
                case 7:
                    /* change channel volume */
                    Opl3_ChannelVolume(bChannel,gbVelocityAtten[bVelocity >> 1]);
                    break;

                case 8:
                case 10:
                    /* change the pan level */
                    Opl3_SetPan(bChannel, bVelocity);
                    break;

                case 64:
                    /* Change the sustain level */
                    Opl3_SetSustain(bChannel, bVelocity);
                    break;

                default:
                    if (bNote >= 120)        /* Channel mode messages */
                    {
                        Opl3_ChannelNotesOff(bChannel);
                    }
                    //  else unknown controller
            };
            break;

        case 0xc0:
            if (bChannel != DRUMCHANNEL)
            {
               m_bPatch[ bChannel ] = bNote ;

            }
            break;

        case 0xe0:  // pitch bend
            wTemp = ((WORD) bVelocity << 9) | ((WORD) bNote << 2);
            m_iBend[bChannel] = (short) (WORD) (wTemp + 0x8000);
            Opl3_PitchBend(bChannel, m_iBend[bChannel]);

            break;
    };
    KeReleaseSpinLock(&m_Miniport->m_SpinLock,oldIrql);
    
    return;
}

// ========================= opl3 specific methods ============================
#pragma code_seg()
// ==========================================================================
// Opl3_AllNotesOff - turn off all notes
// ==========================================================================
void 
CMiniportMidiStreamFM::
Opl3_AllNotesOff()
{
    BYTE i;
    KIRQL   oldIrql;

    KeAcquireSpinLock(&m_Miniport->m_SpinLock,&oldIrql);
    for (i = 0; i < NUM2VOICES; i++) 
    {
        Opl3_NoteOff(m_Voice[i].bPatch, m_Voice[i].bNote, m_Voice[i].bChannel, 0);
    }
    KeReleaseSpinLock(&m_Miniport->m_SpinLock,oldIrql);
}

#pragma code_seg()
// ==========================================================================
//  void Opl3_NoteOff
//
//  Description:
//     This turns off a note, including drums with a patch
//     # of the drum note + 128, but the first drum instrument is at MIDI note _35_.
//
//  Parameters:
//     BYTE bPatch
//        MIDI patch
//
//     BYTE bNote
//        MIDI note
//
//     BYTE bChannel
//        MIDI channel
//
//  Return Value:
//     Nothing.
//
//
// ==========================================================================
void 
CMiniportMidiStreamFM::
Opl3_NoteOff
(
    BYTE            bPatch,
    BYTE            bNote,
    BYTE            bChannel,
    BYTE            bSustain
)
{
   ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

   patchStruct FAR  *lpPS ;
   WORD             wOffset, wTemp ;

   // Find the note slot
   wTemp = Opl3_FindFullSlot( bNote, bChannel ) ;

   if (wTemp != 0xffff)
   {
      if (bSustain)
      {
          // This channel is sustained, don't really turn the note off,
          // just flag it.
          //
          m_Voice[ wTemp ].bSusHeld = 1;
          
          return;
      }
      
      // get a pointer to the patch
      lpPS = glpPatch + (BYTE) m_Voice[ wTemp ].bPatch ;

      // shut off the note portion
      // we have the note slot, turn it off.
      wOffset = wTemp;
      if (wTemp >= (NUM2VOICES / 2))
         wOffset += (0x100 - (NUM2VOICES / 2));

      m_Miniport->SoundMidiSendFM(m_PortBase, AD_BLOCK + wOffset,
                  (BYTE)(m_Voice[ wTemp ].bBlock[ 0 ] & 0x1f) ) ;

      // Note this...
      m_Voice[ wTemp ].bOn = FALSE ;
      m_Voice[ wTemp ].bBlock[ 0 ] &= 0x1f ;
      m_Voice[ wTemp ].bBlock[ 1 ] &= 0x1f ;
      m_Voice[ wTemp ].dwTime = m_dwCurTime ;
   }
}

#pragma code_seg()
// ==========================================================================
//  WORD Opl3_FindFullSlot
//
//  Description:
//     This finds a slot with a specific note, and channel.
//     If it is not found then 0xFFFF is returned.
//
//  Parameters:
//     BYTE bNote
//        MIDI note number
//
//     BYTE bChannel
//        MIDI channel #
//
//  Return Value:
//     WORD
//        note slot #, or 0xFFFF if can't find it
//
//
// ==========================================================================
WORD 
CMiniportMidiStreamFM::
Opl3_FindFullSlot
(
    BYTE            bNote,
    BYTE            bChannel
)
{
   ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

   WORD  i ;

   for (i = 0; i < NUM2VOICES; i++)
   {
      if ((bChannel == m_Voice[ i ].bChannel) 
            && (bNote == m_Voice[ i ].bNote) 
            && (m_Voice[ i ].bOn))
      {
            return ( i ) ;
      }
   // couldn't find it
   }
   return ( 0xFFFF ) ;
} 


#pragma code_seg()
//------------------------------------------------------------------------
//  void Opl3_FMNote
//
//  Description:
//     Turns on an FM-synthesizer note.
//
//  Parameters:
//     WORD wNote
//        the note number from 0 to NUMVOICES
//
//     noteStruct FAR *lpSN
//        structure containing information about what
//        is to be played.
//
//  Return Value:
//     Nothing.
//------------------------------------------------------------------------
void 
CMiniportMidiStreamFM::
Opl3_FMNote
(
    WORD                wNote,
    noteStruct FAR *    lpSN
)
{
   ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

   WORD            i ;
   WORD            wOffset ;
   operStruct FAR  *lpOS ;

   // write out a note off, just to make sure...

   wOffset = wNote;
   if (wNote >= (NUM2VOICES / 2))
      wOffset += (0x100 - (NUM2VOICES / 2));

   m_Miniport->SoundMidiSendFM(m_PortBase, AD_BLOCK + wOffset, 0 ) ;

   // writing the operator information

//   for (i = 0; i < (WORD)((wNote < NUM4VOICES) ? NUMOPS : 2); i++)
   for (i = 0; i < 2; i++)
   {
      lpOS = &lpSN -> op[ i ] ;
      wOffset = gw2OpOffset[ wNote ][ i ] ;
      m_Miniport->SoundMidiSendFM( m_PortBase, 0x20 + wOffset, lpOS -> bAt20) ;
      m_Miniport->SoundMidiSendFM( m_PortBase, 0x40 + wOffset, lpOS -> bAt40) ;
      m_Miniport->SoundMidiSendFM( m_PortBase, 0x60 + wOffset, lpOS -> bAt60) ;
      m_Miniport->SoundMidiSendFM( m_PortBase, 0x80 + wOffset, lpOS -> bAt80) ;
      m_Miniport->SoundMidiSendFM( m_PortBase, 0xE0 + wOffset, lpOS -> bAtE0) ;

   }

   // write out the voice information
   wOffset = (wNote < 9) ? wNote : (wNote + 0x100 - 9) ;
   m_Miniport->SoundMidiSendFM(m_PortBase, 0xa0 + wOffset, lpSN -> bAtA0[ 0 ] ) ;
   m_Miniport->SoundMidiSendFM(m_PortBase, 0xc0 + wOffset, lpSN -> bAtC0[ 0 ] ) ;

   // Note on...
   m_Miniport->SoundMidiSendFM(m_PortBase, 0xb0 + wOffset,
               (BYTE)(lpSN -> bAtB0[ 0 ] | 0x20) ) ;

} // end of Opl3_FMNote()

#pragma code_seg()
//=======================================================================
//  WORD Opl3_NoteOn
//
//  Description:
//     This turns on a note, including drums with a patch # of the
//     drum note + 0x80.  The first GM drum instrument is mapped to note 35 instead of zero, though, so
//     we expect 0 as the first drum patch (acoustic kick) if note 35 comes in.
//
//  Parameters:
//     BYTE bPatch
//        MIDI patch
//
//     BYTE bNote
//        MIDI note
//
//     BYTE bChannel
//        MIDI channel
//
//     BYTE bVelocity
//        velocity value
//
//     short iBend
//        current pitch bend from -32768 to 32767
//
//  Return Value:
//     WORD
//        note slot #, or 0xFFFF if it is inaudible
//=======================================================================
void 
CMiniportMidiStreamFM::
Opl3_NoteOn
(
    BYTE            bPatch,
    BYTE            bNote,
    BYTE            bChannel,
    BYTE            bVelocity,
    short           iBend
)
{
   ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

   WORD             wTemp, i, j ;
   BYTE             b4Op, bTemp, bMode, bStereo ;
   patchStruct FAR  *lpPS ;
   DWORD            dwBasicPitch, dwPitch[ 2 ] ;
   noteStruct       NS ;

   // Get a pointer to the patch
   lpPS = glpPatch + bPatch ;

   // Find out the basic pitch according to our
   // note value.  This may be adjusted because of
   // pitch bends or special qualities for the note.

   dwBasicPitch = gdwPitch[ bNote % 12 ] ;
   bTemp = bNote / (BYTE) 12 ;
   if (bTemp > (BYTE) (60 / 12))
      dwBasicPitch = AsLSHL( dwBasicPitch, (BYTE)(bTemp - (BYTE)(60/12)) ) ;
   else if (bTemp < (BYTE) (60/12))
      dwBasicPitch = AsULSHR( dwBasicPitch, (BYTE)((BYTE) (60/12) - bTemp) ) ;

   // Copy the note information over and modify
   // the total level and pitch according to
   // the velocity, midi volume, and tuning.

   RtlCopyMemory( (LPSTR) &NS, (LPSTR) &lpPS -> note, sizeof( noteStruct ) ) ;
   b4Op = (BYTE)(NS.bOp != PATCH_1_2OP) ;

   for (j = 0; j < 2; j++)
   {
      // modify pitch
      dwPitch[ j ] = dwBasicPitch ;
      bTemp = (BYTE)((NS.bAtB0[ j ] >> 2) & 0x07) ;
      if (bTemp > 4)
         dwPitch[ j ] = AsLSHL( dwPitch[ j ], (BYTE)(bTemp - (BYTE)4) ) ;
      else if (bTemp < 4)
         dwPitch[ j ] = AsULSHR( dwPitch[ j ], (BYTE)((BYTE)4 - bTemp) ) ;

      wTemp = Opl3_CalcFAndB( Opl3_CalcBend( dwPitch[ j ], iBend ) ) ;
      NS.bAtA0[ j ] = (BYTE) wTemp ;
      NS.bAtB0[ j ] = (BYTE) 0x20 | (BYTE) (wTemp >> 8) ;
   }

   // Modify level for each operator, but only
   // if they are carrier waves

   bMode = (BYTE) ((NS.bAtC0[ 0 ] & 0x01) * 2 + 4) ;

   for (i = 0; i < 2; i++)
   {
      wTemp = (BYTE) 
          Opl3_CalcVolume(  (BYTE)(NS.op[ i ].bAt40 & (BYTE) 0x3f),
                            bChannel, 
                            bVelocity, 
                            (BYTE) i, 
                            bMode ) ;
      NS.op[ i ].bAt40 = (NS.op[ i ].bAt40 & (BYTE)0xc0) | (BYTE) wTemp ;
   }

   // Do stereo panning, but cutting off a left or
   // right channel if necessary...

   bStereo = Opl3_CalcStereoMask( bChannel ) ;
   NS.bAtC0[ 0 ] &= bStereo ;

   // Find an empty slot, and use it...
   wTemp = Opl3_FindEmptySlot( bPatch ) ;

   Opl3_FMNote(wTemp, &NS ) ;
   m_Voice[ wTemp ].bNote = bNote ;
   m_Voice[ wTemp ].bChannel = bChannel ;
   m_Voice[ wTemp ].bPatch = bPatch ;
   m_Voice[ wTemp ].bVelocity = bVelocity ;
   m_Voice[ wTemp ].bOn = TRUE ;
   m_Voice[ wTemp ].dwTime = m_dwCurTime++ ;
   m_Voice[ wTemp ].dwOrigPitch[0] = dwPitch[ 0 ] ;  // not including bend
   m_Voice[ wTemp ].dwOrigPitch[1] = dwPitch[ 1 ] ;  // not including bend
   m_Voice[ wTemp ].bBlock[0] = NS.bAtB0[ 0 ] ;
   m_Voice[ wTemp ].bBlock[1] = NS.bAtB0[ 1 ] ;
   m_Voice[ wTemp ].bSusHeld = 0;


} // end of Opl3_NoteOn()

#pragma code_seg()
//=======================================================================
//Opl3_CalcFAndB - Calculates the FNumber and Block given a frequency.
//
//inputs
//       DWORD   dwPitch - pitch
//returns
//        WORD - High byte contains the 0xb0 section of the
//                        block and fNum, and the low byte contains the
//                        0xa0 section of the fNumber
//=======================================================================
WORD 
CMiniportMidiStreamFM::
Opl3_CalcFAndB(DWORD dwPitch)
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    BYTE    bBlock;

    /* bBlock is like an exponential to dwPitch (or FNumber) */
    for (bBlock = 1; dwPitch >= 0x400; dwPitch >>= 1, bBlock++)
        ;

    if (bBlock > 0x07)
        bBlock = 0x07;  /* we cant do anything about this */

    /* put in high two bits of F-num into bBlock */
    return ((WORD) bBlock << 10) | (WORD) dwPitch;
}

#pragma code_seg()
//=======================================================================
//Opl3_CalcBend - This calculates the effects of pitch bend
//        on an original value.
//
//inputs
//        DWORD   dwOrig - original frequency
//        short   iBend - from -32768 to 32768, -2 half steps to +2
//returns
//        DWORD - new frequency
//=======================================================================
DWORD 
CMiniportMidiStreamFM::
Opl3_CalcBend (DWORD dwOrig, short iBend)
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    DWORD   dw;
  
    /* do different things depending upon positive or
        negative bend */
    if (iBend > 0)
    {
        dw = (DWORD)((iBend * (LONG)(256.0 * (EQUAL * EQUAL - 1.0))) >> 8);
        dwOrig += (DWORD)(AsULMUL(dw, dwOrig) >> 15);
    }
    else if (iBend < 0)
    {
        dw = (DWORD)(((-iBend) * (LONG)(256.0 * (1.0 - 1.0 / EQUAL / EQUAL))) >> 8);
        dwOrig -= (DWORD)(AsULMUL(dw, dwOrig) >> 15);
    }

    return dwOrig;
}


#pragma code_seg()
//=======================================================================
// Opl3_CalcVolume - This calculates the attenuation for an operator.
//
//inputs
//        BYTE    bOrigAtten - original attenuation in 0.75 dB units
//        BYTE    bChannel - MIDI channel
//        BYTE    bVelocity - velocity of the note
//        BYTE    bOper - operator number (from 0 to 3)
//        BYTE    bMode - voice mode (from 0 through 7 for
//                                modulator/carrier selection)
//returns
//        BYTE - new attenuation in 0.75 dB units, maxing out at 0x3f.
//=======================================================================
BYTE 
CMiniportMidiStreamFM::
Opl3_CalcVolume(BYTE bOrigAtten,BYTE bChannel,BYTE bVelocity,BYTE bOper,BYTE bMode)
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    BYTE        bVolume;
    WORD        wTemp;
    WORD        wMin;

    switch (bMode) {
        case 0:
                bVolume = (BYTE)(bOper == 3);
                break;
        case 1:
                bVolume = (BYTE)((bOper == 1) || (bOper == 3));
                break;
        case 2:
                bVolume = (BYTE)((bOper == 0) || (bOper == 3));
                break;
        case 3:
                bVolume = (BYTE)(bOper != 1);
                break;
        case 4:
                bVolume = (BYTE)((bOper == 1) || (bOper == 3));
                break;
        case 5:
                bVolume = (BYTE)(bOper >= 1);
                break;
        case 6:
                bVolume = (BYTE)(bOper <= 2);
                break;
        case 7:
                bVolume = TRUE;
                break;
        default:
                bVolume = FALSE;
                break;
        };
    if (!bVolume)
        return bOrigAtten; /* this is a modulator wave */

    wMin =(m_wSynthAttenL < m_wSynthAttenR) ? m_wSynthAttenL : m_wSynthAttenR;
    wTemp = bOrigAtten + 
            ((wMin << 1) +
            m_bChanAtten[bChannel] + 
            gbVelocityAtten[bVelocity >> 1]);
    return (wTemp > 0x3f) ? (BYTE) 0x3f : (BYTE) wTemp;
}

#pragma code_seg()
// ===========================================================================
// Opl3_ChannelNotesOff - turn off all notes on a channel
// ===========================================================================
void 
CMiniportMidiStreamFM::
Opl3_ChannelNotesOff(BYTE bChannel)
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    int i;

    for (i = 0; i < NUM2VOICES; i++) 
    {
       if ((m_Voice[ i ].bOn) && (m_Voice[ i ].bChannel == bChannel)) 
       {
          Opl3_NoteOff(m_Voice[i].bPatch, m_Voice[i].bNote,m_Voice[i].bChannel, 0) ;
       }
    }
}

#pragma code_seg()
// ===========================================================================
/* Opl3_ChannelVolume - set the volume level for an individual channel.
 *
 * inputs
 *      BYTE    bChannel - channel number to change
 *      WORD    wAtten  - attenuation in 1.5 db units
 *
 * returns
 *      none
 */
// ===========================================================================
void 
CMiniportMidiStreamFM::
Opl3_ChannelVolume(BYTE bChannel, WORD wAtten)
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    m_bChanAtten[bChannel] = (BYTE)wAtten;

    Opl3_SetVolume(bChannel);
}

#pragma code_seg()
// ===========================================================================
//  void Opl3_SetVolume
//
//  Description:
//     This should be called if a volume level has changed.
//     This will adjust the levels of all the playing voices.
//
//  Parameters:
//     BYTE bChannel
//        channel # of 0xFF for all channels
//
//  Return Value:
//     Nothing.
//
// ===========================================================================
void 
CMiniportMidiStreamFM::
Opl3_SetVolume
(
    BYTE   bChannel
)
{
   ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

   WORD            i, j, wTemp, wOffset ;
   noteStruct FAR  *lpPS ;
   BYTE            bMode, bStereo ;

   // Make sure that we are actually open...
   if (!glpPatch)
      return ;

   // Loop through all the notes looking for the right
   // channel.  Anything with the right channel gets
   // its pitch bent.
   for (i = 0; i < NUM2VOICES; i++)
   {
      if ((m_Voice[ i ].bChannel == bChannel) || (bChannel == 0xff))
      {
         // Get a pointer to the patch
         lpPS = &(glpPatch + m_Voice[ i ].bPatch) -> note ;

         // Modify level for each operator, IF they are carrier waves...
         bMode = (BYTE) ( (lpPS->bAtC0[0] & 0x01) * 2 + 4);

         for (j = 0; j < 2; j++)
         {
            wTemp = (BYTE) Opl3_CalcVolume(
               (BYTE) (lpPS -> op[j].bAt40 & (BYTE) 0x3f),
               m_Voice[i].bChannel, m_Voice[i].bVelocity, 
               (BYTE) j,            bMode ) ;

            // Write new value.
            wOffset = gw2OpOffset[ i ][ j ] ;
            m_Miniport->SoundMidiSendFM(
               m_PortBase, 0x40 + wOffset,
               (BYTE) ((lpPS -> op[j].bAt40 & (BYTE)0xc0) | (BYTE) wTemp) ) ;
         }

         // Do stereo pan, but cut left or right channel if needed.
         bStereo = Opl3_CalcStereoMask( m_Voice[ i ].bChannel ) ;
         wOffset = i;
         if (i >= (NUM2VOICES / 2))
             wOffset += (0x100 - (NUM2VOICES / 2));
         m_Miniport->SoundMidiSendFM(m_PortBase, 0xc0 + wOffset, (BYTE)(lpPS -> bAtC0[ 0 ] & bStereo) ) ;
      }
   }
} // end of Opl3_SetVolume

#pragma code_seg()
// ===========================================================================
// Opl3_SetPan - set the left-right pan position.
//
// inputs
//      BYTE    bChannel - channel number to alter
//      BYTE    bPan     - 0-47 for left, 81-127 for right, or somewhere in the middle.
//
// returns - none
//
//  As a side note, I think it's odd that (since 64 = CENTER, 127 = RIGHT and 0 = LEFT)
//  there are 63 intermediate gradations for the left side, but 62 for the right.
// ===========================================================================
void 
CMiniportMidiStreamFM::
Opl3_SetPan(BYTE bChannel, BYTE bPan)
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    /* change the pan level */
    if (bPan > (64 + 16))
            m_bStereoMask[bChannel] = 0xef;      /* let only right channel through */
    else if (bPan < (64 - 16))
            m_bStereoMask[bChannel] = 0xdf;      /* let only left channel through */
    else
            m_bStereoMask[bChannel] = 0xff;      /* let both channels */

    /* change any curently playing patches */
    Opl3_SetVolume(bChannel);
}


#pragma code_seg()
// ===========================================================================
//  void Opl3_PitchBend
//
//  Description:
//     This pitch bends a channel.
//
//  Parameters:
//     BYTE bChannel
//        channel
//
//     short iBend
//        values from -32768 to 32767, being -2 to +2 half steps
//
//  Return Value:
//     Nothing.
// ===========================================================================
void 
CMiniportMidiStreamFM::
Opl3_PitchBend
(
    BYTE        bChannel,
    short        iBend
)
{
   ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

   WORD   i, wTemp[ 2 ], wOffset, j ;
   DWORD  dwNew ;

   // Remember the current bend..
   m_iBend[ bChannel ] = iBend ;

   // Loop through all the notes looking for 
   // the correct channel.  Anything with the 
   // correct channel gets its pitch bent...
   for (i = 0; i < NUM2VOICES; i++)
      if (m_Voice[ i ].bChannel == bChannel)
      {
         j = 0 ;
         dwNew = Opl3_CalcBend( m_Voice[ i ].dwOrigPitch[ j ], iBend ) ;
         wTemp[ j ] = Opl3_CalcFAndB( dwNew ) ;
         m_Voice[ i ].bBlock[ j ] =
            (m_Voice[ i ].bBlock[ j ] & (BYTE) 0xe0) |
               (BYTE) (wTemp[ j ] >> 8) ;

         wOffset = i;
         if (i >= (NUM2VOICES / 2))
             wOffset += (0x100 - (NUM2VOICES / 2));

         m_Miniport->SoundMidiSendFM(m_PortBase, AD_BLOCK + wOffset, m_Voice[ i ].bBlock[ 0 ] ) ;
         m_Miniport->SoundMidiSendFM(m_PortBase, AD_FNUMBER + wOffset, (BYTE) wTemp[ 0 ] ) ;
      }
} // end of Opl3_PitchBend


#pragma code_seg()
// ===========================================================================
//  Opl3_CalcStereoMask - This calculates the stereo mask.
//
//  inputs
//            BYTE  bChannel - MIDI channel
//  returns
//            BYTE  mask (for register 0xc0-c8) for eliminating the
//                  left/right/both channels
// ===========================================================================
BYTE 
CMiniportMidiStreamFM::
Opl3_CalcStereoMask(BYTE bChannel)
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    WORD        wLeft, wRight;

    /* figure out the basic levels of the 2 channels */
    wLeft = (m_wSynthAttenL << 1) + m_bChanAtten[bChannel];
    wRight = (m_wSynthAttenR << 1) + m_bChanAtten[bChannel];

    /* if both are too quiet then mask to nothing */
    if ((wLeft > 0x3f) && (wRight > 0x3f))
        return 0xcf;

    /* if one channel is significantly quieter than the other than
        eliminate it */
    if ((wLeft + 8) < wRight)
        return (BYTE)(0xef & m_bStereoMask[bChannel]);   /* right is too quiet so eliminate */
    else if ((wRight + 8) < wLeft)
        return (BYTE)(0xdf & m_bStereoMask[bChannel]);   /* left too quiet so eliminate */
    else
        return (BYTE)(m_bStereoMask[bChannel]);  /* use both channels */
}

#pragma code_seg()
//------------------------------------------------------------------------
//  WORD Opl3_FindEmptySlot
//
//  Description:
//     This finds an empty note-slot for a MIDI voice.
//     If there are no empty slots then this looks for the oldest
//     off note.  If this doesn't work then it looks for the oldest
//     on-note of the same patch.  If all notes are still on then
//     this finds the oldests turned-on-note.
//
//  Parameters:
//     BYTE bPatch
//        MIDI patch that will replace it.
//
//  Return Value:
//     WORD
//        note slot #
//
//
//------------------------------------------------------------------------
WORD 
CMiniportMidiStreamFM::
Opl3_FindEmptySlot(BYTE bPatch)
{
   ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

   WORD   i, found ;
   DWORD  dwOldest ;

   // First, look for a slot with a time == 0
   for (i = 0;  i < NUM2VOICES; i++)
      if (!m_Voice[ i ].dwTime)
         return ( i ) ;

   // Now, look for a slot of the oldest off-note
   dwOldest = 0xffffffff ;
   found = 0xffff ;

   for (i = 0; i < NUM2VOICES; i++)
      if (!m_Voice[ i ].bOn && (m_Voice[ i ].dwTime < dwOldest))
      {
         dwOldest = m_Voice[ i ].dwTime ;
         found = i ;
      }
   if (found != 0xffff)
      return ( found ) ;

   // Now, look for a slot of the oldest note with
   // the same patch
   dwOldest = 0xffffffff ;
   found = 0xffff ;
   for (i = 0; i < NUM2VOICES; i++)
      if ((m_Voice[ i ].bPatch == bPatch) && (m_Voice[ i ].dwTime < dwOldest))
      {
         dwOldest = m_Voice[ i ].dwTime ;
         found = i ;
      }
   if (found != 0xffff)
      return ( found ) ;

   // Now, just look for the oldest voice
   found = 0 ;
   dwOldest = m_Voice[ found ].dwTime ;
   for (i = (found + 1); i < NUM2VOICES; i++)
      if (m_Voice[ i ].dwTime < dwOldest)
      {
         dwOldest = m_Voice[ i ].dwTime ;
         found = i ;
      }

   return ( found ) ;

} // end of Opl3_FindEmptySlot()

#pragma code_seg()
//------------------------------------------------------------------------
//  WORD Opl3_SetSustain
//
//  Description:
//     Set the sustain controller on the current channel.
//
//  Parameters:
//     BYTE bSusLevel
//        The new sustain level 
//
//
//------------------------------------------------------------------------
VOID
CMiniportMidiStreamFM::
Opl3_SetSustain(BYTE bChannel,BYTE bSusLevel)
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    WORD            i;

    if (m_bSustain[ bChannel ] && !bSusLevel)
    {
        // Sustain has just been turned off for this channel
        // Go through and turn off all notes that are being held for sustain
        //
        for (i = 0; i < NUM2VOICES; i++)
        {
            if ((bChannel == m_Voice[ i ].bChannel) &&
                m_Voice[ i ].bSusHeld)
            {
                Opl3_NoteOff(m_Voice[i].bPatch, m_Voice[i].bNote, m_Voice[i].bChannel, 0);
            }
        }
    }
    m_bSustain[ bChannel ] = bSusLevel;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\miniport\dmusuart\private.h ===
/*****************************************************************************
 * private.h - MPU-401 miniport private definitions
 *****************************************************************************
 * Copyright (c) 1997-2000 Microsoft Corporation.  All Rights Reserved.
 */

#ifndef _DMUSUART_PRIVATE_H_
#define _DMUSUART_PRIVATE_H_

#include "portcls.h"
#include "stdunk.h"
#include "dmusicks.h"

//  + for absolute / - for relative
#define kOneMillisec (10 * 1000)

//
// MPU401 ports
//
#define MPU401_REG_STATUS   0x01    // Status register
#define MPU401_DRR          0x40    // Output ready (for command or data)
                                    // if this bit is set, the output FIFO is FULL
#define MPU401_DSR          0x80    // Input ready (for data)
                                    // if this bit is set, the input FIFO is empty

#define MPU401_REG_DATA     0x00    // Data in
#define MPU401_REG_COMMAND  0x01    // Commands
#define MPU401_CMD_RESET    0xFF    // Reset command
#define MPU401_CMD_UART     0x3F    // Switch to UART mod


/*****************************************************************************
 * References forward
 */


/*****************************************************************************
 * Prototypes
 */

NTSTATUS InitMPU(IN PINTERRUPTSYNC InterruptSync,IN PVOID DynamicContext);
NTSTATUS ResetHardware(PUCHAR portBase);
NTSTATUS ValidatePropertyRequest(IN PPCPROPERTY_REQUEST pRequest, IN ULONG ulValueSize, IN BOOLEAN fValueRequired);


/*****************************************************************************
 * Constants
 */

const BOOLEAN   COMMAND   = TRUE;
const BOOLEAN   DATA      = FALSE;

const LONG      kMPUInputBufferSize = 128;


/*****************************************************************************
 * Globals
 */


/*****************************************************************************
 * Classes
 */

/*****************************************************************************
 * CMiniportDMusUART
 *****************************************************************************
 * MPU-401 miniport.  This object is associated with the device and is 
 * created when the device is started.  The class inherits IMiniportDMus
 * so it can expose this interface and CUnknown so it automatically gets
 * reference counting and aggregation support.
 */
class CMiniportDMusUART
:   public IMiniportDMus,
    public IMusicTechnology,
    public IPowerNotify,
    public CUnknown
{
private:
    KSSTATE         m_KSStateInput;         // Miniport state (RUN/PAUSE/ACQUIRE/STOP)
    PPORTDMUS       m_pPort;                // Callback interface.
    PUCHAR          m_pPortBase;            // Base port address.
    PINTERRUPTSYNC  m_pInterruptSync;       // Interrupt synchronization object.
    PSERVICEGROUP   m_pServiceGroup;        // Service group for capture.
    PMASTERCLOCK    m_MasterClock;          // for input data
    REFERENCE_TIME  m_InputTimeStamp;       // capture data timestamp
    USHORT          m_NumRenderStreams;     // Num active render streams.
    USHORT          m_NumCaptureStreams;    // Num active capture streams.
    LONG            m_MPUInputBufferHead;   // Index of the newest byte in the FIFO.
    LONG            m_MPUInputBufferTail;   // Index of the oldest empty space in the FIFO.
    GUID            m_MusicFormatTechnology;
    POWER_STATE     m_PowerState;           // Saved power state (D0 = full power, D3 = off)
    BOOLEAN         m_fMPUInitialized;      // Is the MPU HW initialized.
    BOOLEAN         m_UseIRQ;               // FALSE if no IRQ is used for MIDI.
    UCHAR           m_MPUInputBuffer[kMPUInputBufferSize];  // Internal SW FIFO.

    /*************************************************************************
     * CMiniportDMusUART methods
     *
     * These are private member functions used internally by the object.
     * See MINIPORT.CPP for specific descriptions.
     */
    NTSTATUS ProcessResources
    (
        IN      PRESOURCELIST   ResourceList
    );
    NTSTATUS InitializeHardware(PINTERRUPTSYNC interruptSync,PUCHAR portBase);

public:
    /*************************************************************************
     * The following two macros are from STDUNK.H.  DECLARE_STD_UNKNOWN()
     * defines inline IUnknown implementations that use CUnknown's aggregation
     * support.  NonDelegatingQueryInterface() is declared, but it cannot be
     * implemented generically.  Its definition appears in MINIPORT.CPP.
     * DEFINE_STD_CONSTRUCTOR() defines inline a constructor which accepts
     * only the outer unknown, which is used for aggregation.  The standard
     * create macro (in MINIPORT.CPP) uses this constructor.
     */
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CMiniportDMusUART);

    ~CMiniportDMusUART();

    /*************************************************************************
     * IMiniport methods
     */
    STDMETHODIMP_(NTSTATUS) 
    GetDescription
    (   OUT     PPCFILTER_DESCRIPTOR *  OutFilterDescriptor
    );
    STDMETHODIMP_(NTSTATUS) 
    DataRangeIntersection
    (   IN      ULONG           PinId
    ,   IN      PKSDATARANGE    DataRange
    ,   IN      PKSDATARANGE    MatchingDataRange
    ,   IN      ULONG           OutputBufferLength
    ,   OUT     PVOID           ResultantFormat
    ,   OUT     PULONG          ResultantFormatLength
    )
    {
        return STATUS_NOT_IMPLEMENTED;
    }

    /*************************************************************************
     * IMiniportDMus methods
     */
    STDMETHODIMP_(NTSTATUS) Init
    (
        IN      PUNKNOWN        UnknownAdapter,
        IN      PRESOURCELIST   ResourceList,
        IN      PPORTDMUS       Port,
        OUT     PSERVICEGROUP * ServiceGroup
    );
    STDMETHODIMP_(NTSTATUS) NewStream
    (
        OUT     PMXF                  * Stream,
        IN      PUNKNOWN                OuterUnknown    OPTIONAL,
        IN      POOL_TYPE               PoolType,
        IN      ULONG                   PinID,
        IN      DMUS_STREAM_TYPE        StreamType,
        IN      PKSDATAFORMAT           DataFormat,
        OUT     PSERVICEGROUP         * ServiceGroup,
        IN      PAllocatorMXF           AllocatorMXF,
        IN      PMASTERCLOCK            MasterClock,
        OUT     PULONGLONG              SchedulePreFetch
    );
    STDMETHODIMP_(void) Service
    (   void
    );

    /*************************************************************************
     * IMusicTechnology methods
     */
    IMP_IMusicTechnology;

    /*************************************************************************
     * IPowerNotify methods
     */
    IMP_IPowerNotify;

    /*************************************************************************
     * Friends 
     */
    friend class CMiniportDMusUARTStream;
    friend NTSTATUS 
        DMusMPUInterruptServiceRoutine(PINTERRUPTSYNC InterruptSync,PVOID DynamicContext);
    friend NTSTATUS 
        SynchronizedDMusMPUWrite(PINTERRUPTSYNC InterruptSync,PVOID syncWriteContext);
    friend VOID NTAPI 
        DMusUARTTimerDPC(PKDPC Dpc,PVOID DeferredContext,PVOID SystemArgument1,PVOID SystemArgument2);
    friend NTSTATUS PropertyHandler_Synth(IN PPCPROPERTY_REQUEST);
    friend STDMETHODIMP_(NTSTATUS) SnapTimeStamp(PINTERRUPTSYNC InterruptSync,PVOID pStream);
};

/*****************************************************************************
 * CMiniportDMusUARTStream
 *****************************************************************************
 * MPU-401 miniport stream.  This object is associated with the pin and is
 * created when the pin is instantiated.  It inherits IMXF
 * so it can expose this interface and CUnknown so it automatically gets
 * reference counting and aggregation support.
 */
class CMiniportDMusUARTStream
:   public IMXF,
    public CUnknown
{
private:
    CMiniportDMusUART * m_pMiniport;            // Parent.
    REFERENCE_TIME      m_SnapshotTimeStamp;    // Current snapshot of miniport's input timestamp.
    PUCHAR              m_pPortBase;            // Base port address.
    BOOLEAN             m_fCapture;             // Whether this is capture.
    long                m_NumFailedMPUTries;    // Deadman timeout for MPU hardware.
    PAllocatorMXF       m_AllocatorMXF;         // source/sink for DMus structs
    PMXF                m_sinkMXF;              // sink for DMus capture
    PDMUS_KERNEL_EVENT  m_DMKEvtQueue;          // queue of waiting events
    ULONG               m_NumberOfRetries;      // Number of consecutive times the h/w was busy/full
    ULONG               m_DMKEvtOffset;         // offset into the event
    KDPC                m_Dpc;                  // DPC for timer
    KTIMER              m_TimerEvent;           // timer 
    BOOL                m_TimerQueued;          // whether a timer has been set
    KSPIN_LOCK          m_DpcSpinLock;          // protects the ConsumeEvents DPC

    STDMETHODIMP_(NTSTATUS) SourceEvtsToPort();
    STDMETHODIMP_(NTSTATUS) ConsumeEvents();
    STDMETHODIMP_(NTSTATUS) PutMessageLocked(PDMUS_KERNEL_EVENT pDMKEvt);

public:
    /*************************************************************************
     * The following two macros are from STDUNK.H.  DECLARE_STD_UNKNOWN()
     * defines inline IUnknown implementations that use CUnknown's aggregation
     * support.  NonDelegatingQueryInterface() is declared, but it cannot be
     * implemented generically.  Its definition appears in MINIPORT.CPP.
     * DEFINE_STD_CONSTRUCTOR() defines inline a constructor which accepts
     * only the outer unknown, which is used for aggregation.  The standard
     * create macro (in MINIPORT.CPP) uses this constructor.
     */
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CMiniportDMusUARTStream);

    ~CMiniportDMusUARTStream();

    STDMETHODIMP_(NTSTATUS) Init
    (
        IN      CMiniportDMusUART * pMiniport,
        IN      PUCHAR              pPortBase,
        IN      BOOLEAN             fCapture,
        IN      PAllocatorMXF       allocatorMXF,
        IN      PMASTERCLOCK        masterClock
    );

    NTSTATUS HandlePortParams
    (
        IN      PPCPROPERTY_REQUEST     Request
    );

    /*************************************************************************
     * IMiniportStreamDMusUART methods
     */
    IMP_IMXF;

    STDMETHODIMP_(NTSTATUS) Write
    (
        IN      PVOID       BufferAddress,
        IN      ULONG       BytesToWrite,
        OUT     PULONG      BytesWritten
    );

    friend VOID NTAPI
    DMusUARTTimerDPC
    (
        IN      PKDPC   Dpc,
        IN      PVOID   DeferredContext,
        IN      PVOID   SystemArgument1,
        IN      PVOID   SystemArgument2
    );
    friend NTSTATUS PropertyHandler_Synth(IN PPCPROPERTY_REQUEST);
    friend STDMETHODIMP_(NTSTATUS) SnapTimeStamp(PINTERRUPTSYNC InterruptSync,PVOID pStream);
};
#endif  //  _DMusUART_PRIVATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\miniport\uart\private.h ===
/*****************************************************************************
 * private.h - MPU-401 miniport private definitions
 *****************************************************************************
 * Copyright (c) 1997-2000 Microsoft Corporation.  All Rights Reserved.
 */

#ifndef _MIDIUART_PRIVATE_H_
#define _MIDIUART_PRIVATE_H_

#include "portcls.h"
#include "stdunk.h"

/*****************************************************************************
 * References forward
 */

class timeout;


/*****************************************************************************
 * Prototypes
 */

NTSTATUS InitLegacyMPU(IN PINTERRUPTSYNC InterruptSync,IN PVOID DynamicContext);
NTSTATUS ResetMPUHardware(PUCHAR portBase);


/*****************************************************************************
 * Constants
 */

const BOOLEAN COMMAND   = TRUE;
const BOOLEAN DATA      = FALSE;

const ULONG kMPUInputBufferSize = 128;


/*****************************************************************************
 * Globals
 */



/*****************************************************************************
 * Classes
 */

/*****************************************************************************
 * CMiniportMidiUart
 *****************************************************************************
 * MPU-401 miniport.  This object is associated with the device and is
 * created when the device is started.  The class inherits IMiniportMidi
 * so it can expose this interface and CUnknown so it automatically gets
 * reference counting and aggregation support.
 */
class CMiniportMidiUart
:   public IMiniportMidi,
    public IMusicTechnology,
    public IPowerNotify,
    public CUnknown
{
private:
    KSSTATE         m_KSStateInput;         // Miniport input stream state (RUN/PAUSE/ACQUIRE/STOP)
    PPORTMIDI       m_pPort;                // Callback interface.
    PUCHAR          m_pPortBase;            // Base port address.
    PINTERRUPTSYNC  m_pInterruptSync;       // Interrupt synchronization object.
    PSERVICEGROUP   m_pServiceGroup;        // Service group for capture.
    USHORT          m_NumRenderStreams;     // Num active render streams.
    USHORT          m_NumCaptureStreams;    // Num active capture streams.
    ULONG           m_MPUInputBufferHead;   // Index of the newest byte in the FIFO.
    ULONG           m_MPUInputBufferTail;   // Index of the oldest empty space in the FIFO.
    GUID            m_MusicFormatTechnology;
    POWER_STATE     m_PowerState;           // Saved power state (D0 = full power, D3 = off)
    BOOLEAN         m_fMPUInitialized;      // Is the MPU HW initialized.
    BOOLEAN         m_UseIRQ;               //  FALSE if no IRQ is used for MIDI.
    UCHAR           m_MPUInputBuffer[kMPUInputBufferSize];  // Internal SW FIFO.

    /*************************************************************************
     * CMiniportMidiUart methods
     *
     * These are private member functions used internally by the object.  See
     * MINIPORT.CPP for specific descriptions.
     */
    NTSTATUS ProcessResources
    (
        IN      PRESOURCELIST   ResourceList
    );
    NTSTATUS InitializeHardware(PINTERRUPTSYNC interruptSync,PUCHAR portBase);

public:
    /*************************************************************************
     * The following two macros are from STDUNK.H.  DECLARE_STD_UNKNOWN()
     * defines inline IUnknown implementations that use CUnknown's aggregation
     * support.  NonDelegatingQueryInterface() is declared, but it cannot be
     * implemented generically.  Its definition appears in MINIPORT.CPP.
     * DEFINE_STD_CONSTRUCTOR() defines inline a constructor which accepts
     * only the outer unknown, which is used for aggregation.  The standard
     * create macro (in MINIPORT.CPP) uses this constructor.
     */
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CMiniportMidiUart);

    ~CMiniportMidiUart();

    /*************************************************************************
     * IMiniport methods
     */
    STDMETHODIMP_(NTSTATUS) 
    GetDescription
    (   OUT     PPCFILTER_DESCRIPTOR *  OutFilterDescriptor
    );
    STDMETHODIMP_(NTSTATUS) 
    DataRangeIntersection
    (   IN      ULONG           PinId
    ,   IN      PKSDATARANGE    DataRange
    ,   IN      PKSDATARANGE    MatchingDataRange
    ,   IN      ULONG           OutputBufferLength
    ,   OUT     PVOID           ResultantFormat
    ,   OUT     PULONG          ResultantFormatLength
    )
    {
        return STATUS_NOT_IMPLEMENTED;
    }

    /*************************************************************************
     * IMiniportMidi methods
     */
    STDMETHODIMP_(NTSTATUS) Init
    (
        IN      PUNKNOWN        UnknownAdapter,
        IN      PRESOURCELIST   ResourceList,
        IN      PPORTMIDI       Port,
        OUT     PSERVICEGROUP * ServiceGroup
    );
    STDMETHODIMP_(NTSTATUS) NewStream
    (
        OUT     PMINIPORTMIDISTREAM   * Stream,
        IN      PUNKNOWN                OuterUnknown    OPTIONAL,
        IN      POOL_TYPE               PoolType,
        IN      ULONG                   Pin,
        IN      BOOLEAN                 Capture,
        IN      PKSDATAFORMAT           DataFormat,
        OUT     PSERVICEGROUP         * ServiceGroup
    );
    STDMETHODIMP_(void) Service
    (   void
    );

    /*************************************************************************
     * IMusicTechnology methods
     */
    IMP_IMusicTechnology;

    /*************************************************************************
     * IPowerNotify methods
     */
    IMP_IPowerNotify;

    /*************************************************************************
     * Friends 
     */
    friend class CMiniportMidiStreamUart;
    friend NTSTATUS 
        MPUInterruptServiceRoutine(PINTERRUPTSYNC InterruptSync,PVOID DynamicContext);
    friend NTSTATUS 
        SynchronizedMPUWrite(PINTERRUPTSYNC InterruptSync,PVOID syncWriteContext);
};

/*****************************************************************************
 * CMiniportMidiStreamUart
 *****************************************************************************
 * MPU-401 miniport stream.  This object is associated with the pin and is
 * created when the pin is instantiated.  It inherits IMiniportMidiStream
 * so it can expose this interface and CUnknown so it automatically gets
 * reference counting and aggregation support.
 */
class CMiniportMidiStreamUart
:   public IMiniportMidiStream,
    public CUnknown
{
private:
    CMiniportMidiUart * m_pMiniport;            // Parent.
    PUCHAR              m_pPortBase;            // Base port address.
    long                m_NumFailedMPUTries;    // Deadman timeout for MPU hardware.
    BOOLEAN             m_fCapture;             // Whether this is capture.

public:
    /*************************************************************************
     * The following two macros are from STDUNK.H.  DECLARE_STD_UNKNOWN()
     * defines inline IUnknown implementations that use CUnknown's aggregation
     * support.  NonDelegatingQueryInterface() is declared, but it cannot be
     * implemented generically.  Its definition appears in MINIPORT.CPP.
     * DEFINE_STD_CONSTRUCTOR() defines inline a constructor which accepts
     * only the outer unknown, which is used for aggregation.  The standard
     * create macro (in MINIPORT.CPP) uses this constructor.
     */
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CMiniportMidiStreamUart);

    ~CMiniportMidiStreamUart();

    STDMETHODIMP_(NTSTATUS) Init
    (
        IN      CMiniportMidiUart * pMiniport,
        IN      PUCHAR              pPortBase,
        IN      BOOLEAN             fCapture
    );

    /*************************************************************************
     * IMiniportMidiStream methods
     */
    STDMETHODIMP_(NTSTATUS) SetFormat
    (
        IN      PKSDATAFORMAT   DataFormat
    );
    STDMETHODIMP_(NTSTATUS) SetState
    (
        IN      KSSTATE     State
    );
    STDMETHODIMP_(NTSTATUS) Read
    (
        IN      PVOID       BufferAddress,
        IN      ULONG       BufferLength,
        OUT     PULONG      BytesRead
    );
    STDMETHODIMP_(NTSTATUS) Write
    (
        IN      PVOID       BufferAddress,
        IN      ULONG       BytesToWrite,
        OUT     PULONG      BytesWritten
    );
};
#endif  //  _MIDIUART_PRIVATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\miniport\fmsynth\private.h ===
/*****************************************************************************
 * private.h - FM synth miniport private definitions
 *****************************************************************************
 * Copyright (c) 1997-2000 Microsoft Corporation.  All rights reserved.
 */

#ifndef _FMSYNTH_PRIVATE_H_
#define _FMSYNTH_PRIVATE_H_

#include "portcls.h"
#include "stdunk.h"
#include "ksdebug.h"

#include "miniport.h"

enum {
    CHAN_MASTER = (-1),
    CHAN_LEFT = 0,
    CHAN_RIGHT = 1
};

/*****************************************************************************
 * Classes
 */

/*****************************************************************************
 * CMiniportMidiFM
 *****************************************************************************
 * FM miniport.  This object is associated with the device and is
 * created when the device is started.  The class inherits IMiniportMidi
 * so it can expose this interface and CUnknown so it automatically gets
 * reference counting and aggregation support.
 */
class CMiniportMidiFM
:   public IMiniportMidi,
    public IPowerNotify,
    public CUnknown
{
private:
    PPORTMIDI       m_Port;                 // Callback interface.
    PUCHAR          m_PortBase;             // Base port address.
    BOOLEAN         m_BoardNotResponsive;   // Indicates dead hardware.
    BOOLEAN         m_bInit;                // true if we have already done init.
    BOOLEAN         m_fStreamExists;        // True if we have a stream.

    BYTE            m_SavedRegValues[0x200]; // Shadow copies of the FM registers.
    POWER_STATE     m_PowerState;            // Saved power state (D0 = full power, D3 = off)
    BOOLEAN         m_volNodeNeeded;         // Whether we need to furnish a volume node.
    KSPIN_LOCK      m_SpinLock;              // Protects writes to hardware.

    /*************************************************************************
     * CMiniportMidiFM methods
     *
     * These are private member functions used internally by the object.  See
     * MINIPORT.CPP for specific descriptions.
     *
     */
    NTSTATUS 
    ProcessResources
    (
        IN      PRESOURCELIST   ResourceList
    );

    void SoundMidiSendFM(PUCHAR PortBase, ULONG Address, UCHAR Data); // low-level--write registers

    BOOL SoundSynthPresent(IN PUCHAR base, IN PUCHAR inbase);   // detect if synth is present.
    BOOL SoundMidiIsOpl3(VOID);     // returns true if the device is an opl3 and false if not.
    VOID Opl3_BoardReset(VOID);
    VOID MiniportMidiFMResume(VOID);

public:
    /*************************************************************************
     * The following two macros are from STDUNK.H.  DECLARE_STD_UNKNOWN()
     * defines inline IUnknown implementations that use CUnknown's aggregation
     * support.  NonDelegatingQueryInterface() is declared, but it cannot be
     * implemented generically.  Its definition appears in MINIPORT.CPP.
     * DEFINE_STD_CONSTRUCTOR() defines inline a constructor which accepts
     * only the outer unknown, which is used for aggregation.  The standard
     * create macro (in MINIPORT.CPP) uses this constructor.
     */
    DECLARE_STD_UNKNOWN();

//  expand constructor to take bool for whether to include volume
    CMiniportMidiFM(PUNKNOWN pUnknownOuter,int createVolNode)
    :   CUnknown(pUnknownOuter)
    {
        m_volNodeNeeded = (createVolNode != 0);
    };

    ~CMiniportMidiFM();

    /*************************************************************************
     * IMiniport methods
     */
    STDMETHODIMP_(NTSTATUS) 
    GetDescription
    (   OUT     PPCFILTER_DESCRIPTOR *  OutFilterDescriptor
    );
    STDMETHODIMP_(NTSTATUS) 
    DataRangeIntersection
    (   IN      ULONG           PinId
    ,   IN      PKSDATARANGE    DataRange
    ,   IN      PKSDATARANGE    MatchingDataRange
    ,   IN      ULONG           OutputBufferLength
    ,   OUT     PVOID           ResultantFormat
    ,   OUT     PULONG          ResultantFormatLength
    )
    {
        return STATUS_NOT_IMPLEMENTED;
    }

    /*************************************************************************
     * IMiniportMidi methods
     */
    STDMETHODIMP_(NTSTATUS) Init
    (
        IN      PUNKNOWN        UnknownNotUsed  OPTIONAL,
        IN      PRESOURCELIST   ResourceList,
        IN      PPORTMIDI       Port,
        OUT     PSERVICEGROUP * ServiceGroup
    );
    STDMETHODIMP_(NTSTATUS) NewStream
    (
        OUT     PMINIPORTMIDISTREAM *   Stream,
        IN      PUNKNOWN                OuterUnknown    OPTIONAL,
        IN      POOL_TYPE               PoolType,
        IN      ULONG                   Pin,
        IN      BOOLEAN                 Capture,
        IN      PKSDATAFORMAT           DataFormat,
        OUT     PSERVICEGROUP *         ServiceGroup
    );
    STDMETHODIMP_(void) Service
    (   void
    );

    /*************************************************************************
     * IPowerNotify methods
     */
    STDMETHODIMP_(void) PowerChangeNotify(
        IN  POWER_STATE     PowerState
    );

    
/*************************************************************************
     * Friends
     */
    friend class CMiniportMidiStreamFM;

};

/*****************************************************************************
 * CMiniportMidiStreamFM
 *****************************************************************************
 * FM miniport stream.  This object is associated with a pin and is created
 * when the pin is instantiated.  The class inherits IMiniportMidiStream
 * so it can expose this interface and CUnknown so it automatically gets
 * reference counting and aggregation support.
 */
class CMiniportMidiStreamFM
:   public IMiniportMidiStream,
    public CUnknown
{
private:
    CMiniportMidiFM *   m_Miniport;     // Parent miniport.
    PUCHAR              m_PortBase;     // Base port address.

    // midi stuff
    voiceStruct m_Voice[NUM2VOICES];  /* info on what voice is where */
    DWORD m_dwCurTime;    /* for note on/off */
    /* volume */
    WORD    m_wSynthAttenL;        /* in 1.5dB steps */
    WORD    m_wSynthAttenR;        /* in 1.5dB steps */

    /* support for volume property */
    LONG    m_MinVolValue;      // Minimum value for volume controller
    LONG    m_MaxVolValue;      // Maximum value for volume controller
    ULONG   m_VolStepDelta;     // Correlation between controller and actual decibels
    LONG    m_SavedVolValue[2]; // Saved value for volume controller

    /* channel volumes */
    BYTE    m_bChanAtten[NUMCHANNELS];       /* attenuation of each channel, in .75 db steps */
    BYTE    m_bStereoMask[NUMCHANNELS];              /* mask for left/right for stereo midi files */

    short   m_iBend[NUMCHANNELS];    /* bend for each channel */
    BYTE    m_bPatch[NUMCHANNELS];   /* patch number mapped to */
    BYTE    m_bSustain[NUMCHANNELS];   /* Is sustain in effect on this channel? */

    /*************************************************************************
     * CMiniportMidiStreamFM methods
     *
     * These are private member functions used internally by the object.  See
     * MINIPORT.CPP for specific descriptions.
     */

    VOID WriteMidiData(DWORD dwData);
    // opl3 processing methods.
    VOID Opl3_ChannelVolume(BYTE bChannel, WORD wAtten);
    VOID Opl3_SetPan(BYTE bChannel, BYTE bPan);
    VOID Opl3_PitchBend(BYTE bChannel, short iBend);
    VOID Opl3_NoteOn(BYTE bPatch,BYTE bNote, BYTE bChannel, BYTE bVelocity,short iBend);
    VOID Opl3_NoteOff (BYTE bPatch,BYTE bNote, BYTE bChannel, BYTE bSustain);
    VOID Opl3_AllNotesOff(VOID);
    VOID Opl3_ChannelNotesOff(BYTE bChannel);
    WORD Opl3_FindFullSlot(BYTE bNote, BYTE bChannel);
    WORD Opl3_CalcFAndB (DWORD dwPitch);
    DWORD Opl3_CalcBend (DWORD dwOrig, short iBend);
    BYTE Opl3_CalcVolume (BYTE bOrigAtten, BYTE bChannel,BYTE bVelocity, BYTE bOper, BYTE bMode);
    BYTE Opl3_CalcStereoMask (BYTE bChannel);
    WORD Opl3_FindEmptySlot(BYTE bPatch);
    VOID Opl3_SetVolume(BYTE bChannel);
    VOID Opl3_FMNote(WORD wNote, noteStruct FAR * lpSN);
    VOID Opl3_SetSustain(BYTE bChannel, BYTE bSusLevel);

    void SetFMAtten(LONG channel, LONG level);
    LONG GetFMAtten(LONG channel)    {   return m_SavedVolValue[channel];    };

public:
    NTSTATUS
    Init
    (
        IN      CMiniportMidiFM *   Miniport,
        IN      PUCHAR              PortBase
    );

    /*************************************************************************
     * The following two macros are from STDUNK.H.  DECLARE_STD_UNKNOWN()
     * defines inline IUnknown implementations that use CUnknown's aggregation
     * support.  NonDelegatingQueryInterface() is declared, but it cannot be
     * implemented generically.  Its definition appears in MINIPORT.CPP.
     * DEFINE_STD_CONSTRUCTOR() defines inline a constructor which accepts
     * only the outer unknown, which is used for aggregation.  The standard
     * create macro (in MINIPORT.CPP) uses this constructor.
     */
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CMiniportMidiStreamFM);

    ~CMiniportMidiStreamFM();

    /*************************************************************************
     * IMiniportMidiStream methods
     */
    STDMETHODIMP_(NTSTATUS) SetFormat
    (
        IN      PKSDATAFORMAT   DataFormat
    );
    STDMETHODIMP_(NTSTATUS) SetState
    (
        IN      KSSTATE     State
    );
    STDMETHODIMP_(NTSTATUS) Read
    (
        IN      PVOID       BufferAddress,
        IN      ULONG       BufferLength,
        OUT     PULONG      BytesRead
    );
    STDMETHODIMP_(NTSTATUS) Write
    (
        IN      PVOID       BufferAddress,
        IN      ULONG       BytesToWrite,
        OUT     PULONG      BytesWritten
    );

/*************************************************************************
     * Friends
     */
    friend
    NTSTATUS BasicSupportHandler
    (
        IN  PPCPROPERTY_REQUEST PropertyRequest
    );

    friend
    NTSTATUS PropertyHandler_Level
    (
        IN  PPCPROPERTY_REQUEST PropertyRequest
    );

    friend
    NTSTATUS PropertyHandler_CpuResources
    (
        IN  PPCPROPERTY_REQUEST PropertyRequest
    );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\miniport\fmsynth\patch.h ===
//
//   Copyright (c) 1996-2000 Microsoft Corporation.  All rights reserved.
//
// ==============================================
// This file is generated programmatically from
// a RIFF file synth.pat. 

// Please do not edit this file.
// ==============================================
patchStruct glpPatch[] = 
{
    {   //  1st patch struct
        0x01,0x8f,0xf2,0xf4,0x00,0x01,0x06,0xf2,0xf7,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  2nd patch struct
        0x01,0x4b,0xf2,0xf4,0x00,0x01,0x00,0xf2,0xf7,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  3rd patch struct
        0x01,0x49,0xf2,0xf4,0x00,0x01,0x00,0xf2,0xf6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  4th patch struct
        0x81,0x12,0xf2,0xf7,0x00,0x41,0x00,0xf2,0xf7,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  5th patch struct
        0x01,0x57,0xf1,0xf7,0x00,0x01,0x00,0xf2,0xf7,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  6th patch struct
        0x01,0x93,0xf1,0xf7,0x00,0x01,0x00,0xf2,0xf7,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  7th patch struct
        0x01,0x80,0xa1,0xf2,0x00,0x16,0x0e,0xf2,0xf5,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  8th patch struct
        0x01,0x92,0xc2,0xf8,0x00,0x01,0x00,0xc2,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  9th patch struct
        0x0c,0x5c,0xf6,0xf4,0x00,0x81,0x00,0xf3,0xf5,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  10th patch struct
        0x07,0x97,0xf3,0xf2,0x00,0x11,0x80,0xf2,0xf1,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x32,0x00,0x02,0x00
    },{ //  11th patch struct
        0x17,0x21,0x54,0xf4,0x00,0x01,0x00,0xf4,0xf4,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x32,0x00,0x02,0x00
    },{ //  12th patch struct
        0x98,0x62,0xf3,0xf6,0x00,0x81,0x00,0xf2,0xf6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  13th patch struct
        0x18,0x23,0xf6,0xf6,0x00,0x01,0x00,0xe7,0xf7,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  14th patch struct
        0x15,0x91,0xf6,0xf6,0x00,0x01,0x00,0xf6,0xf6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x34,0x00,0x02,0x00
    },{ //  15th patch struct
        0x45,0x59,0xd3,0xf3,0x00,0x81,0x80,0xa3,0xf3,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3c,0x00,0x02,0x00
    },{ //  16th patch struct
        0x03,0x49,0x75,0xf5,0x01,0x81,0x80,0xb5,0xf5,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x34,0x00,0x02,0x00
    },{ //  17th patch struct
        0x71,0x92,0xf6,0x14,0x00,0x31,0x00,0xf1,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x32,0x00,0x02,0x00
    },{ //  18th patch struct
        0x72,0x14,0xc7,0x58,0x00,0x30,0x00,0xc7,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x32,0x00,0x02,0x00
    },{ //  19th patch struct
        0x70,0x44,0xaa,0x18,0x00,0xb1,0x00,0x8a,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x34,0x00,0x02,0x00
    },{ //  20th patch struct
        0x23,0x93,0x97,0x23,0x01,0xb1,0x00,0x55,0x14,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x34,0x00,0x02,0x00
    },{ //  21th patch struct
        0x61,0x13,0x97,0x04,0x01,0xb1,0x80,0x55,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  22th patch struct
        0x24,0x48,0x98,0x2a,0x01,0xb1,0x00,0x46,0x1a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3c,0x00,0x02,0x00
    },{ //  23th patch struct
        0x61,0x13,0x91,0x06,0x01,0x21,0x00,0x61,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  24th patch struct
        0x21,0x13,0x71,0x06,0x00,0xa1,0x89,0x61,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  25th patch struct
        0x02,0x9c,0xf3,0x94,0x01,0x41,0x80,0xf3,0xc8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3c,0x00,0x02,0x00
    },{ //  26th patch struct
        0x03,0x54,0xf3,0x9a,0x01,0x11,0x00,0xf1,0xe7,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3c,0x00,0x02,0x00
    },{ //  27th patch struct
        0x23,0x5f,0xf1,0x3a,0x00,0x21,0x00,0xf2,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  28th patch struct
        0x03,0x87,0xf6,0x22,0x01,0x21,0x80,0xf3,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  29th patch struct
        0x03,0x47,0xf9,0x54,0x00,0x21,0x00,0xf6,0x3a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  30th patch struct
        0x23,0x4a,0x91,0x41,0x01,0x21,0x05,0x84,0x19,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  31th patch struct
        0x23,0x4a,0x95,0x19,0x01,0x21,0x00,0x94,0x19,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  32th patch struct
        0x09,0xa1,0x20,0x4f,0x00,0x84,0x80,0xd1,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  33th patch struct
        0x21,0x1e,0x94,0x06,0x00,0xa2,0x00,0xc3,0xa6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x32,0x00,0x02,0x00
    },{ //  34th patch struct
        0x31,0x12,0xf1,0x28,0x00,0x31,0x00,0xf1,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  35th patch struct
        0x31,0x8d,0xf1,0xe8,0x00,0x31,0x00,0xf1,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  36th patch struct
        0x31,0x5b,0x51,0x28,0x00,0x32,0x00,0x71,0x48,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3c,0x00,0x02,0x00
    },{ //  37th patch struct
        0x01,0x8b,0xa1,0x9a,0x00,0x21,0x40,0xf2,0xdf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  38th patch struct
        0x21,0x8b,0xa2,0x16,0x00,0x21,0x08,0xa1,0xdf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  39th patch struct
        0x31,0x8b,0xf4,0xe8,0x00,0x31,0x00,0xf1,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  40th patch struct
        0x31,0x12,0xf1,0x28,0x00,0x31,0x00,0xf1,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  41th patch struct
        0x31,0x15,0xdd,0x13,0x01,0x21,0x00,0x56,0x26,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  42th patch struct
        0x31,0x16,0xdd,0x13,0x01,0x21,0x00,0x66,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  43th patch struct
        0x71,0x49,0xd1,0x1c,0x01,0x31,0x00,0x61,0x0c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  44th patch struct
        0x21,0x4d,0x71,0x12,0x01,0x23,0x80,0x72,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x32,0x00,0x02,0x00
    },{ //  45th patch struct
        0xf1,0x40,0xf1,0x21,0x01,0xe1,0x00,0x6f,0x16,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x32,0x00,0x02,0x00
    },{ //  46th patch struct
        0x02,0x1a,0xf5,0x75,0x01,0x01,0x80,0x85,0x35,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  47th patch struct
        0x02,0x1d,0xf5,0x75,0x01,0x01,0x80,0xf3,0xf4,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  48th patch struct
        0x10,0x41,0xf5,0x05,0x01,0x11,0x00,0xf2,0xc3,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x32,0x00,0x02,0x00
    },{ //  49th patch struct
        0x21,0x9b,0xb1,0x25,0x01,0xa2,0x01,0x72,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  50th patch struct
        0xa1,0x98,0x7f,0x03,0x01,0x21,0x00,0x3f,0x07,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  51st patch struct
        0xa1,0x93,0xc1,0x12,0x00,0x61,0x00,0x4f,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  52th patch struct
        0x21,0x18,0xc1,0x22,0x00,0x61,0x00,0x4f,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3c,0x00,0x02,0x00
    },{ //  53th patch struct
        0x31,0x5b,0xf4,0x15,0x00,0x72,0x83,0x8a,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  54th patch struct
        0xa1,0x90,0x74,0x39,0x00,0x61,0x00,0x71,0x67,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  55th patch struct
        0x71,0x57,0x54,0x05,0x00,0x72,0x00,0x7a,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3c,0x00,0x02,0x00
    },{ //  56th patch struct
        0x90,0x00,0x54,0x63,0x00,0x41,0x00,0xa5,0x45,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  57th patch struct
        0x21,0x92,0x85,0x17,0x00,0x21,0x01,0x8f,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3c,0x00,0x02,0x00
    },{ //  58th patch struct
        0x21,0x94,0x75,0x17,0x00,0x21,0x05,0x8f,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3c,0x00,0x02,0x00
    },{ //  59th patch struct
        0x21,0x94,0x76,0x15,0x00,0x61,0x00,0x82,0x37,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3c,0x00,0x02,0x00
    },{ //  60th patch struct
        0x31,0x43,0x9e,0x17,0x01,0x21,0x00,0x62,0x2c,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x32,0x00,0x02,0x00
    },{ //  61th patch struct
        0x21,0x9b,0x61,0x6a,0x00,0x21,0x00,0x7f,0x0a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x32,0x00,0x02,0x00
    },{ //  62th patch struct
        0x61,0x8a,0x75,0x1f,0x00,0x22,0x06,0x74,0x0f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  63th patch struct
        0xa1,0x86,0x72,0x55,0x01,0x21,0x83,0x71,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  64th patch struct
        0x21,0x4d,0x54,0x3c,0x00,0x21,0x00,0xa6,0x1c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  65th patch struct
        0x31,0x8f,0x93,0x02,0x01,0x61,0x00,0x72,0x0b,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  66th patch struct
        0x31,0x8e,0x93,0x03,0x01,0x61,0x00,0x72,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  th patch struct
        0x31,0x91,0x93,0x03,0x01,0x61,0x00,0x82,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  th patch struct
        0x31,0x8e,0x93,0x0f,0x01,0x61,0x00,0x72,0x0f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  th patch struct
        0x21,0x4b,0xaa,0x16,0x01,0x21,0x00,0x8f,0x0a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  70th patch struct
        0x31,0x90,0x7e,0x17,0x01,0x21,0x00,0x8b,0x0c,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  71th patch struct
        0x31,0x81,0x75,0x19,0x01,0x32,0x00,0x61,0x19,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  72th patch struct
        0x32,0x90,0x9b,0x21,0x00,0x21,0x00,0x72,0x17,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x34,0x00,0x02,0x00
    },{ //  73th patch struct
        0xe1,0x1f,0x85,0x5f,0x00,0xe1,0x00,0x65,0x1a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  74th patch struct
        0xe1,0x46,0x88,0x5f,0x00,0xe1,0x00,0x65,0x1a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  75th patch struct
        0xa1,0x9c,0x75,0x1f,0x00,0x21,0x00,0x75,0x0a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x32,0x00,0x02,0x00
    },{ //  76th patch struct
        0x31,0x8b,0x84,0x58,0x00,0x21,0x00,0x65,0x1a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  77th patch struct
        0xe1,0x4c,0x66,0x56,0x00,0xa1,0x00,0x65,0x26,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  78th patch struct
        0x62,0xcb,0x76,0x46,0x00,0xa1,0x00,0x55,0x36,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  79th patch struct
        0x62,0x99,0x57,0x07,0x00,0xa1,0x00,0x56,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3b,0x00,0x02,0x00
    },{ //  80th patch struct
        0x62,0x93,0x77,0x07,0x00,0xa1,0x00,0x76,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3b,0x00,0x02,0x00
    },{ //  th patch struct
        0x22,0x59,0xff,0x03,0x02,0x21,0x00,0xff,0x0f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  th patch struct
        0x21,0x0e,0xff,0x0f,0x01,0x21,0x00,0xff,0x0f,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  th patch struct
        0x22,0x46,0x86,0x55,0x00,0x21,0x80,0x64,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  th patch struct
        0x21,0x45,0x66,0x12,0x00,0xa1,0x00,0x96,0x0a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  85th patch struct
        0x21,0x8b,0x92,0x2a,0x01,0x22,0x00,0x91,0x2a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  th patch struct
        0xa2,0x9e,0xdf,0x05,0x00,0x61,0x40,0x6f,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x32,0x00,0x02,0x00
    },{ //  th patch struct
        0x20,0x1a,0xef,0x01,0x00,0x60,0x00,0x8f,0x06,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  th patch struct
        0x21,0x8f,0xf1,0x29,0x00,0x21,0x80,0xf4,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  th patch struct
        0x77,0xa5,0x53,0x94,0x00,0xa1,0x00,0xa0,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x32,0x00,0x02,0x00
    },{ //  90th patch struct
        0x61,0x1f,0xa8,0x11,0x00,0xb1,0x80,0x25,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  th patch struct
        0x61,0x17,0x91,0x34,0x00,0x61,0x00,0x55,0x16,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3c,0x00,0x02,0x00
    },{ //  th patch struct
        0x71,0x5d,0x54,0x01,0x00,0x72,0x00,0x6a,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  th patch struct
        0x21,0x97,0x21,0x43,0x00,0xa2,0x00,0x42,0x35,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  th patch struct
        0xa1,0x1c,0xa1,0x77,0x01,0x21,0x00,0x31,0x47,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  95th patch struct
        0x21,0x89,0x11,0x33,0x00,0x61,0x03,0x42,0x25,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  th patch struct
        0xa1,0x15,0x11,0x47,0x01,0x21,0x00,0xcf,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  th patch struct
        0x3a,0xce,0xf8,0xf6,0x00,0x51,0x00,0x86,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x32,0x00,0x02,0x00
    },{ //  th patch struct
        0x21,0x15,0x21,0x23,0x01,0x21,0x00,0x41,0x13,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  th patch struct
        0x06,0x5b,0x74,0x95,0x00,0x01,0x00,0xa5,0x72,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  100th patch struct
        0x22,0x92,0xb1,0x81,0x00,0x61,0x83,0xf2,0x26,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3c,0x00,0x02,0x00
    },{ //  th patch struct
        0x41,0x4d,0xf1,0x51,0x01,0x42,0x00,0xf2,0xf5,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  th patch struct
        0x61,0x94,0x11,0x51,0x01,0xa3,0x80,0x11,0x13,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  th patch struct
        0x61,0x8c,0x11,0x31,0x00,0xa1,0x80,0x1d,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  th patch struct
        0xa4,0x4c,0xf3,0x73,0x01,0x61,0x00,0x81,0x23,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x34,0x00,0x02,0x00
    },{ //  105th patch struct
        0x02,0x85,0xd2,0x53,0x00,0x07,0x03,0xf2,0xf6,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  th patch struct
        0x11,0x0c,0xa3,0x11,0x01,0x13,0x80,0xa2,0xe5,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  th patch struct
        0x11,0x06,0xf6,0x41,0x01,0x11,0x00,0xf2,0xe6,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x34,0x00,0x02,0x00
    },{ //  th patch struct
        0x93,0x91,0xd4,0x32,0x00,0x91,0x00,0xeb,0x11,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  th patch struct
        0x04,0x4f,0xfa,0x56,0x00,0x01,0x00,0xc2,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3c,0x00,0x02,0x00
    },{ //  110th patch struct
        0x21,0x49,0x7c,0x20,0x00,0x22,0x00,0x6f,0x0c,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  th patch struct
        0x31,0x85,0xdd,0x33,0x01,0x21,0x00,0x56,0x16,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  th patch struct
        0x20,0x04,0xda,0x05,0x02,0x21,0x81,0x8f,0x0b,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  th patch struct
        0x05,0x6a,0xf1,0xe5,0x00,0x03,0x80,0xc3,0xe5,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  th patch struct
        0x07,0x15,0xec,0x26,0x00,0x02,0x00,0xf8,0x16,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  115th patch struct
        0x05,0x9d,0x67,0x35,0x00,0x01,0x00,0xdf,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  th patch struct
        0x18,0x96,0xfa,0x28,0x00,0x12,0x00,0xf8,0xe5,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  th patch struct
        0x10,0x86,0xa8,0x07,0x00,0x00,0x03,0xfa,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  th patch struct
        0x11,0x41,0xf8,0x47,0x02,0x10,0x03,0xf3,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x34,0x00,0x02,0x00
    },{ //  th patch struct
        0x01,0x8e,0xf1,0x06,0x02,0x10,0x00,0xf3,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  120th patch struct
        0x0e,0x00,0x1f,0x00,0x00,0xc0,0x00,0x1f,0xff,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  th patch struct
        0x06,0x80,0xf8,0x24,0x00,0x03,0x88,0x56,0x84,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  th patch struct
        0x0e,0x00,0xf8,0x00,0x00,0xd0,0x05,0x34,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  th patch struct
        0x0e,0x00,0xf6,0x00,0x00,0xc0,0x00,0x1f,0x02,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  th patch struct
        0xd5,0x95,0x37,0xa3,0x00,0xda,0x40,0x56,0x37,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  125th patch struct
        0x35,0x5c,0xb2,0x61,0x02,0x14,0x08,0xf4,0x15,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  126th patch struct
        0x0e,0x00,0xf6,0x00,0x00,0xd0,0x00,0x4f,0xf5,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  127th patch struct
        0x26,0x00,0xff,0x01,0x00,0xe4,0x00,0x12,0x16,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  128th patch struct
        0x00,0x00,0xf3,0xf0,0x00,0x00,0x00,0xf6,0xc9,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  129th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  130th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  133th patch struct 
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  135th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  138th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  140th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  143th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  145th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  148th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  150th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  153th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  155th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  158th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  160th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  164th patch struct    FIRST DRUM patch. note 35
        0x10,0x44,0xf8,0x77,0x02,0x11,0x00,0xf3,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  165th patch struct
        0x10,0x44,0xf8,0x77,0x02,0x11,0x00,0xf3,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  th patch struct
        0x02,0x07,0xf9,0xff,0x00,0x11,0x00,0xf8,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  th patch struct
        0x00,0x00,0xfc,0x05,0x02,0x00,0x00,0xfa,0x17,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  th patch struct
        0x00,0x02,0xff,0x07,0x00,0x01,0x00,0xff,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  th patch struct
        0x00,0x00,0xfc,0x05,0x02,0x00,0x00,0xfa,0x17,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  170th patch struct
        0x00,0x00,0xf6,0x0c,0x00,0x00,0x00,0xf6,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x34,0x00,0x02,0x00
    },{ //  th patch struct
        0x0c,0x00,0xf6,0x08,0x00,0x12,0x00,0xfb,0x47,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  th patch struct
        0x00,0x03,0xf8,0x2a,0x00,0x00,0x00,0xf6,0x45,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x34,0x00,0x02,0x00
    },{ //  th patch struct
        0x0c,0x00,0xf6,0x08,0x00,0x12,0x05,0x7b,0x47,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  th patch struct
        0x00,0x03,0xf8,0x2a,0x00,0x00,0x00,0xf6,0x45,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x34,0x00,0x02,0x00
    },{ //  175th patch struct
        0x0c,0x00,0xf6,0x02,0x00,0x12,0x00,0xcb,0x43,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  th patch struct
        0x00,0x03,0xf8,0x2a,0x00,0x00,0x00,0xf6,0x45,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x34,0x00,0x02,0x00
    },{ //  th patch struct
        0x00,0x03,0xf8,0x2a,0x00,0x00,0x00,0xf6,0x45,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x34,0x00,0x02,0x00
    },{ //  th patch struct
        0x0e,0x00,0xf6,0x00,0x00,0xd0,0x00,0x9f,0x02,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  th patch struct
        0x00,0x03,0xf8,0x2a,0x00,0x00,0x00,0xf6,0x45,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x34,0x00,0x02,0x00
    },{ //  180th patch struct
        0x0e,0x08,0xf8,0x42,0x00,0x07,0x4a,0xf4,0xe4,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  th patch struct
        0x0e,0x00,0xf5,0x30,0x00,0xd0,0x0a,0x9f,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  th patch struct
        0x0e,0x0a,0xe4,0xe4,0x03,0x07,0x5d,0xf5,0xe5,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  th patch struct
        0x02,0x03,0xb4,0x04,0x00,0x05,0x0a,0x97,0xf7,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  th patch struct
        0x4e,0x00,0xf6,0x00,0x00,0x9e,0x00,0x9f,0x02,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  185th patch struct
        0x11,0x45,0xf8,0x37,0x02,0x10,0x08,0xf3,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  th patch struct
        0x0e,0x00,0xf6,0x00,0x00,0xd0,0x00,0x9f,0x02,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  th patch struct
        0x80,0x00,0xff,0x03,0x03,0x10,0x0d,0xff,0x14,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3c,0x00,0x02,0x00
    },{ //  th patch struct note 59
        0x0e,0x08,0xf8,0x42,0x00,0x07,0x51,0xf4,0xe4,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  th patch struct note 60
        0x06,0x0b,0xf5,0x0c,0x00,0x02,0x00,0xf5,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  190th patch struct note 61
        0x01,0x00,0xfa,0xbf,0x00,0x02,0x00,0xc8,0x97,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x37,0x00,0x02,0x00
    },{ //  th patch struct note 62
        0x01,0x51,0xfa,0x87,0x00,0x01,0x00,0xfa,0xb7,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  th patch struct note 63
        0x01,0x54,0xfa,0x8d,0x00,0x02,0x00,0xf8,0xb8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  th patch struct note 64
        0x01,0x59,0xfa,0x88,0x00,0x02,0x00,0xf8,0xb6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  th patch struct note 65
        0x01,0x00,0xf9,0x0a,0x03,0x00,0x00,0xfa,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  195th patch struct note 66
        0x00,0x80,0xf9,0x89,0x03,0x00,0x00,0xf6,0x6c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  th patch struct note 67
        0x03,0x80,0xf8,0x88,0x03,0x0c,0x08,0xf6,0xb6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3f,0x00,0x02,0x00
    },{ //  th patch struct note 68
        0x03,0x85,0xf8,0x88,0x03,0x0c,0x00,0xf6,0xb6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3f,0x00,0x02,0x00
    },{ //  th patch struct note 69
        0x0e,0x40,0x76,0x4f,0x00,0x00,0x08,0x77,0x18,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  th patch struct note 70
        0x0e,0x40,0xc8,0x49,0x00,0x03,0x00,0x9b,0x69,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  200th patch struct note 71
        0xd7,0xdc,0xad,0x05,0x03,0xc7,0x00,0x8d,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  201th patch struct note 72
        0xd7,0xdc,0xa8,0x04,0x03,0xc7,0x00,0x88,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  202th patch struct note 73
        0x80,0x00,0xf6,0x06,0x03,0x11,0x00,0x67,0x17,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  203th patch struct note 74
        0x80,0x00,0xf5,0x05,0x02,0x11,0x09,0x46,0x16,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  204th patch struct note 75
        0x06,0x3f,0x00,0xf4,0x00,0x15,0x00,0xf7,0xf5,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x31,0x00,0x02,0x00
    },{ //  205th patch struct     42nd DRUM patch note 76
        0x06,0x3f,0x00,0xf4,0x03,0x12,0x00,0xf7,0xf5,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  206th patch struct note 77 (low wood block from 60 high bongo)
        0x06,0x0b,0xf5,0x0c,0x00,0x02,0x00,0xf5,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0C,0x00,0x36,0x00,0x02,0x00
//        0x06,0x0b,0xf5,0x0c,0x00,0x02,0x00,0xf5,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  207th patch struct note 78 (mute cuica from 62 mute hi conga)
        0x01,0x51,0xfa,0x87,0x00,0x01,0x00,0xfa,0xb7,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0C,0x00,0x36,0x00,0x02,0x00
//        0x01,0x51,0xfa,0x87,0x00,0x01,0x00,0xfa,0xb7,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  208th patch struct note 79 (open cuica from 63 open hi conga)
        0x01,0x54,0xfa,0x8d,0x00,0x02,0x00,0xf8,0xb8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0C,0x00,0x36,0x00,0x02,0x00
//        0x01,0x54,0xfa,0x8d,0x00,0x02,0x00,0xf8,0xb8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  209th patch struct note 80 (mute triangle from NT - note 53 ride bell)
        0x01,0x2E,0xF5,0xF5,0x05,0x11,0x02,0xA5,0x34,0x00,0x0E,0x08,0xF1,0xF1,0x02,0x18,0x05,0xC9,0xA6,0x02,0x9A,0x67,0x14,0x10,0x30,0x7E,0x01,0x9A 
//        0x01,0x2E,0xF5,0xF5,0x05,0x11,0x02,0xA5,0x34,0x00,0x0E,0x08,0xF1,0xF1,0x02,0x18,0x05,0xC9,0xA6,0x02,0x9A,0x67,0x10,0x10,0x30,0x7E,0x01,0x9A 
    },{ //  210th patch struct note 81 (open triangle from NT - note 81)
        0x29,0x27,0xF1,0x41,0x00,0x04,0x00,0xF7,0x43,0x00,0x9A,0xFE,0x05,0x00,0x00,0x52,0x50,0x9A,0x1E,0x06,0x00,0x00,0x1C,0x10,0x32,0x5A,0x02,0x6A
//        0x29,0x27,0xF1,0x41,0x00,0x04,0x00,0xF7,0x43,0x00,0x9A,0xFE,0x05,0x00,0x00,0x52,0x50,0x9A,0x1E,0x06,0x00,0x00,0x18,0x10,0x32,0x5A,0x02,0x6A
    },{ //  211th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  212th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  213th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  214th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  215th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  216th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  221th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  226th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  231th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  236th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  240th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  245th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  246th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  247th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  248th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  249th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  250th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  251th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  252th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  253th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  254th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  255th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  256th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\ports\dmus\allocatr.h ===
/*  
    Base definition of MIDI Transform Filter object 

    Copyright (c) 1998-2000 Microsoft Corporation.  All rights reserved.

    05/08/98    Martin Puryear      Created this file
    03/10/99    Martin Puryear      Major memory management overhaul.  Ugh!

*/

#ifndef __AllocatorMXF_H__
#define __AllocatorMXF_H__

#include "MXF.h"


#define kMXFBufferSize  240
//  WDMAud currently sends down 50 capture IRPs (12 bytes each), DMusic sends down 32 (of 20).


#define kNumPtrsPerPage     (PAGE_SIZE / sizeof(PVOID))
#define kNumEvtsPerPage     (PAGE_SIZE / sizeof(DMUS_KERNEL_EVENT))

class CAllocatorMXF 
:   public CMXF,
    public IAllocatorMXF,
    public CUnknown
{
public:
    DECLARE_STD_UNKNOWN();
    IMP_IAllocatorMXF;

    CAllocatorMXF(PPOSITIONNOTIFY BytePositionNotify);
    ~CAllocatorMXF(void);
    
private:
    ULONG               m_NumFreeEvents;
    ULONG               m_NumPages;
    PVOID               m_pPages;
    PDMUS_KERNEL_EVENT  m_pEventList;
    KSPIN_LOCK          m_EventLock;            // protects the free list
    PPOSITIONNOTIFY     m_BytePositionNotify;

    void     CheckEventLowWaterMark(void);
    void     CheckEventHighWaterMark(void);
    BOOL     AddPage(PVOID *pPool, PVOID pPage);
    void     DestructorFreeBuffers(void);
    void     DestroyPages(PVOID pPages);
    NTSTATUS FreeBuffers(PDMUS_KERNEL_EVENT  pDMKEvt);
    void     MakeNewEvents(void);
};

#endif  //  __AllocatorMXF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\portclsd\portclsd.cpp ===
/*****************************************************************************
 * portclsd.cpp - Portcls WinDbg/KD Debugger Extensions
 *****************************************************************************
 * Copyright (c) 1998 Microsoft Corporation
 *
 * Ken Cooper and Martin Puryear
 */

#if LOCAL_PORTCLSD  //  if compiling the copy of this file in the portcls project

#if (_ALPHA_)
#define TARGET_ALPHA
#define HOST_ALPHA
#include "..\..\..\..\..\..\sdktools\kdexts\p_alpha\precomp.h"
#elif (_X86_)
#define TARGET_i386
#define HOST_i386
#include "..\..\..\..\..\..\sdktools\kdexts\p_i386\precomp.h"
#else
#error "Unsupported processor architecture"
#endif

#define PC_KDEXT

#ifdef _WDMDDK_
#include "..\portcls\private.h"
#include "..\portcls\irpstrm.cpp"
#include "..\ports\wavecyc\private.h"
#include "..\ports\topology\private.h"
#include "..\ports\midi\private.h"
#include "..\ports\wavepci\private.h"
#else
#define _WDMDDK_
#include "..\portcls\private.h"
#include "..\portcls\irpstrm.cpp"
#include "..\ports\wavecyc\private.h"
#include "..\ports\topology\private.h"
#include "..\ports\midi\private.h"
#include "..\ports\wavepci\private.h"
#undef _WDMDDK_
#endif // _WDMDDK_

#else   //  !LOCAL_PORTCLSD

#include "precomp.h"

#define PC_KDEXT

#ifdef _WDMDDK_
#include "..\..\ntos\dd\wdm\audio\backpln\portcls\private.h"
#include "..\..\ntos\dd\wdm\audio\backpln\portcls\irpstrm.cpp"
#include "..\..\ntos\dd\wdm\audio\backpln\ports\wavecyc\private.h"
#include "..\..\ntos\dd\wdm\audio\backpln\ports\topology\private.h"
#include "..\..\ntos\dd\wdm\audio\backpln\ports\midi\private.h"
#include "..\..\ntos\dd\wdm\audio\backpln\ports\wavepci\private.h"
#else
#define _WDMDDK_
#include "..\..\ntos\dd\wdm\audio\backpln\portcls\private.h"
#include "..\..\ntos\dd\wdm\audio\backpln\portcls\irpstrm.cpp"
#include "..\..\ntos\dd\wdm\audio\backpln\ports\wavecyc\private.h"
#include "..\..\ntos\dd\wdm\audio\backpln\ports\topology\private.h"
#include "..\..\ntos\dd\wdm\audio\backpln\ports\midi\private.h"
#include "..\..\ntos\dd\wdm\audio\backpln\ports\wavepci\private.h"
#undef _WDMDDK_
#endif // _WDMDDK_

#endif // !LOCAL_PORTCLSD

typedef enum _PCKD_PORTTYPE
{
    Topology = 0,
    WaveCyclic,
    WavePci,
    Midi,
    UnknownPort
} PCKD_PORTTYPE;

#define MAPPED_QUEUE  0
#define LOCKED_QUEUE  1
#define PRELOCK_QUEUE 2
#define MAX_QUEUES    3

typedef union _PORTCLS_FLAGS
{
    struct
    {
        ULONG   PortDump        : 1;
        ULONG   FilterDump      : 1;
        ULONG   PinDump         : 1;
        ULONG   DeviceContext   : 1;
        ULONG   PowerInfo       : 1;
        ULONG   Reserved1       : 3;
        ULONG   Verbose         : 1;
        ULONG   ReallyVerbose   : 1;
        ULONG   Reserved        : 22;
    };
    ULONG       Flags;
} PORTCLS_FLAGS;

typedef struct _PCKD_IRPSTREAM_ENTRY
{
    LIST_ENTRY      ListEntry;
    PVOID           Irp;
    ULONG           QueueType;
} PCKD_IRP_ENTRY;

typedef struct _PCKD_PIN_ENTRY
{
    LIST_ENTRY  ListEntry;
    LIST_ENTRY  IrpList;
    PVOID       PinData;
    PVOID       IrpStreamData;
    ULONG       PinInstanceId;
} PCKD_PIN_ENTRY;

typedef struct _PCKD_FILTER_ENTRY
{
    LIST_ENTRY  ListEntry;
    LIST_ENTRY  PinList;
    PVOID       FilterData;
    ULONG       FilterInstanceId;
} PCKD_FILTER_ENTRY;

typedef struct _PCKD_PORT
{
    LIST_ENTRY      FilterList;
    PCKD_PORTTYPE   PortType;
    PVOID           PortData;
} PCKD_PORT;

typedef struct _PCKD_SUBDEVICE_ENTRY
{
    LIST_ENTRY              ListEntry;
    PCKD_PORT               Port;
    KSOBJECT_CREATE_ITEM    CreateItem;
} PCKD_SUBDEVICE_ENTRY;



#define TranslateDevicePower( x ) \
    ( x == PowerDeviceD0 ? "PowerDeviceD0" :    \
      x == PowerDeviceD1 ? "PowerDeviceD1" :    \
      x == PowerDeviceD2 ? "PowerDeviceD2" :    \
      x == PowerDeviceD3 ? "PowerDeviceD3" : "Unknown" )
      
#define TranslateSystemPower( x ) \
    ( x == PowerSystemWorking ? "PowerSystemWorking" :  \
      x == PowerSystemSleeping1 ? "PowerSystemSleeping1" :  \
      x == PowerSystemSleeping2 ? "PowerSystemSleeping2" :  \
      x == PowerSystemSleeping3 ? "PowerSystemSleeping3" :  \
      x == PowerSystemHibernate ? "PowerSystemHibernate" :  \
      x == PowerSystemShutdown ? "PowerSystemShutdown" : "Unknown" )
      
#define TranslateKsState( x ) \
    ( x == KSSTATE_STOP ? "KSSTATE_STOP" :          \
      x == KSSTATE_ACQUIRE ? "KSSTATE_ACQUIRE" :    \
      x == KSSTATE_PAUSE ? "KSSTATE_PAUSE" :        \
      x == KSSTATE_RUN ? "KSSTATE_RUN" : "Unknown" )
      
#define TranslateKsDataFlow( x ) \
    ( x == KSPIN_DATAFLOW_IN ? "KSPIN_DATAFLOW_IN" :    \
      x == KSPIN_DATAFLOW_OUT ? "KSPIN_DATAFLOW_OUT" : "Unknown" )      
      
#define TranslateQueueType( x ) \
    ( x == PRELOCK_QUEUE ? "P" :    \
      x == LOCKED_QUEUE ? "L" :     \
      x == MAPPED_QUEUE ? "M" : "U" )

/**********************************************************************
 * Forward References
 **********************************************************************
 */
BOOL
PCKD_ValidateDevObj
(
    PDEVICE_CONTEXT DeviceContext
);

VOID
PCKD_AcquireDeviceData
(
    PDEVICE_CONTEXT DeviceContext,
    PLIST_ENTRY     SubdeviceList,
    ULONG           Flags
);

VOID
PCKD_DisplayDeviceData
(
    PDEVICE_CONTEXT DeviceContext,
    PLIST_ENTRY     SubdeviceList,
    ULONG           Flags
);

VOID
PCKD_FreeDeviceData
(
    PLIST_ENTRY     SubdeviceList
);

VOID
PCKD_AcquireIrpStreamData
(
    PVOID           PinEntry,
    CIrpStream     *RemoteIrpStream,
    CIrpStream     *LocalIrpStream

);

/**********************************************************************
 * DECLARE_API( portcls )
 **********************************************************************
 * Description:
 *      Dumps PortCls data given the device object (FDO) of a PortCls
 *      bound DevObj.
 *
 * Arguments:
 *      args - address flags
 *
 * Return Value:
 *      None
 */
extern "C"
DECLARE_API( portcls )
{
    ULONG           memLoc;
    ULONG           result;
    CHAR            buffer[256];
    PORTCLS_FLAGS   flags;
    DEVICE_OBJECT   Fdo;
    DEVICE_CONTEXT  DeviceContext;
    LIST_ENTRY      SubdeviceList;

    UNREFERENCED_PARAMETER( dwProcessor );
    UNREFERENCED_PARAMETER( dwCurrentPc );
    UNREFERENCED_PARAMETER( hCurrentThread );
    UNREFERENCED_PARAMETER( hCurrentProcess );

    buffer[0] = '\0';
    flags.Flags = 0;

    //
    // get the arguments
    //
    if( !*args )
    {
        memLoc = EXPRLastDump;
    } else
    {
        sscanf( args, "%lx %s", &memLoc, buffer );
    }

    if( '\0' != buffer[0] )
    {
        sscanf( buffer, "%lx", &flags.Flags );
    }

    //
    // print out info
    //
    dprintf("Dump Portcls DevObj Info %x %x \n", memLoc, flags.Flags );

    //
    // get the DevObj data
    //
    if( memLoc )
    {
        if( !ReadMemory( memLoc, &Fdo, sizeof(Fdo), &result ) )
        {
            dprintf("Could not read DevObj data\n");
            return;
        }
    } else
    {
        dprintf("\nSYNTAX:  !portcls <devobj> [flags]\n");
    }

    //
    // check for device extension
    //
    if( !Fdo.DeviceExtension )
    {
        dprintf("DevObj has no device extension\n");
        return;
    }

    //
    // get the device context
    //
    if( !ReadMemory( (ULONG)Fdo.DeviceExtension, &DeviceContext, sizeof(DeviceContext), &result ) )
    {
        dprintf("Could not read DevObj device extension\n");
        return;
    }

    //
    // validate the DevObj
    //
    if( !PCKD_ValidateDevObj( &DeviceContext ) )
    {
        dprintf("DevObj not valid or not bound to PortCls\n");
        return;
    }

    //
    // initialize the subdevice list
    //
    InitializeListHead( &SubdeviceList );

    //
    // acquire the device data
    //
    PCKD_AcquireDeviceData( &DeviceContext, &SubdeviceList, flags.Flags );

    //
    // display the requested info
    //
    PCKD_DisplayDeviceData( &DeviceContext, &SubdeviceList, flags.Flags );

    //
    // release the device data
    //
    PCKD_FreeDeviceData( &SubdeviceList );
}

/**********************************************************************
 * PCKD_ValidateDevObj
 **********************************************************************
 * Description:
 *      This routine attempts to validate whether or not a given device
 *      extension is from a PortCls bound DevObj.
 *
 * Arguments:
 *      PDEVICE_CONTEXT     DeviceContext
 *      PORTCLS_FLAGS       Flags
 *
 * Return Value:
 *      BOOL                TRUE = Valid, FALSE = Invalid
 */
BOOL
PCKD_ValidateDevObj
(
    PDEVICE_CONTEXT     DeviceContext
)
{
    UNREFERENCED_PARAMETER( DeviceContext );

    // TODO - Validate device extension
    return TRUE;
}

/**********************************************************************
 * PCKD_AcquireDeviceData
 **********************************************************************
 * Description:
 *      This routine acquires device data given a validated device
 *      context and builds a subdevice list contain all of the data.
 *
 * Arguments:
 *      PDEVICE_CONTEXT     DeviceContext
 *      PLIST_ENTRY         SubdeviceList
 *      PORTCLS_FLAGS       Flags
 *
 * Return Value:
 *      None
 */
VOID
PCKD_AcquireDeviceData
(
    PDEVICE_CONTEXT     DeviceContext,
    PLIST_ENTRY         SubdeviceList,
    ULONG               flags
)
{
    ULONG                   SubdeviceIndex;
    PCKD_SUBDEVICE_ENTRY   *SubdeviceEntry;
    PKSOBJECT_CREATE_ITEM   CreateItems;
    PKSOBJECT_CREATE_ITEM   CurrentCreateItem;
    PWSTR                   Buffer;
    ULONG                   Size;
    ULONG                   Result;
    ANSI_STRING             AnsiString;
    PLIST_ENTRY             ListEntry;
    PORTCLS_FLAGS           Flags;

    Flags.Flags = flags;

    // allocate local memory for the create items table
    Size =  DeviceContext->MaxObjects * sizeof(KSOBJECT_CREATE_ITEM);
    CreateItems = (PKSOBJECT_CREATE_ITEM)LocalAlloc( LPTR, Size );
    if( !CreateItems )
    {
        dprintf("** Unable to allocate create item table memory\n");
        return;
    }

    // copy the create items table to local memory
    if( !ReadMemory((ULONG)(DeviceContext->CreateItems), CreateItems, Size, &Result ) )
    {
        dprintf("** Unable to read create item table\n");
        LocalFree( CreateItems );
        return;
    }

    // check out each potential subdevice
    for( SubdeviceIndex = 0, CurrentCreateItem = CreateItems;
         SubdeviceIndex < DeviceContext->MaxObjects;
         SubdeviceIndex++, CurrentCreateItem++ )
    {
        if( CurrentCreateItem->Create )
        {
            // allocate a subdevice list entry
            SubdeviceEntry = (PCKD_SUBDEVICE_ENTRY *)LocalAlloc( LPTR, sizeof(PCKD_SUBDEVICE_ENTRY) );
            if( SubdeviceEntry )
            {
                // initialize the port filter list
                InitializeListHead( &(SubdeviceEntry->Port.FilterList) );

                // copy the create item data
                memcpy( &(SubdeviceEntry->CreateItem), CurrentCreateItem, sizeof(KSOBJECT_CREATE_ITEM) );

                // allocate memory for the unicode string buffer
                Buffer = (PWSTR)LocalAlloc( LPTR, CurrentCreateItem->ObjectClass.MaximumLength );
                if( !Buffer )
                {
                    dprintf("** Unable to allocate unicode string buffer\n");
                    LocalFree( SubdeviceEntry );
                    break;
                }

                // read unicode string data
                if( !ReadMemory( (ULONG)(CurrentCreateItem->ObjectClass.Buffer),
                                 Buffer,
                                 CurrentCreateItem->ObjectClass.MaximumLength,
                                 &Result ) )
                {
                    dprintf("** Unable to read unicode string buffer (0x%x)\n",CurrentCreateItem);
                    LocalFree( Buffer );
                    LocalFree( SubdeviceEntry );
                    break;
                }

                // point the create item string to the local buffer
                SubdeviceEntry->CreateItem.ObjectClass.Buffer = Buffer;

                // determine port type by checking string
                // TODO: this should be done by the GUID
                //
                
                // convert to ansi
                RtlUnicodeStringToAnsiString( &AnsiString,
                                              &(SubdeviceEntry->CreateItem.ObjectClass),
                                              TRUE );

                if( 0 == _stricmp( AnsiString.Buffer, "topology" ) )
                {
                    SubdeviceEntry->Port.PortType = Topology;
                    SubdeviceEntry->Port.PortData = NULL;

                } else if( 0 == _stricmp( AnsiString.Buffer, "wave" ) )
                {
                    SubdeviceEntry->Port.PortType = WaveCyclic;
                    SubdeviceEntry->Port.PortData = NULL;

                } else if( (0 == _stricmp( AnsiString.Buffer, "uart") ) ||
                           (0 == _stricmp( AnsiString.Buffer, "fmsynth") ) )
                {
                    SubdeviceEntry->Port.PortType = Midi;
                    SubdeviceEntry->Port.PortData = NULL;
                } else
                {
                    SubdeviceEntry->Port.PortType = UnknownPort;
                    SubdeviceEntry->Port.PortData = NULL;
                }

                // free the ansi string
                RtlFreeAnsiString( &AnsiString );

                // add the subdevice entry to the subdevice list
                InsertTailList( SubdeviceList, &(SubdeviceEntry->ListEntry) );               

            } else
            {
                dprintf("** Unable to allocate subdevice memory\n");
            }
        }
    }

    // free the create item table local storage
    LocalFree( CreateItems );

    // acquire the port, filter, and pin data
    if( (!IsListEmpty(SubdeviceList)) && (Flags.PortDump || Flags.FilterDump || Flags.PinDump) )
    {
        for( ListEntry = SubdeviceList->Flink; ListEntry != SubdeviceList; ListEntry = ListEntry->Flink )
        {
            SubdeviceEntry = (PCKD_SUBDEVICE_ENTRY *) ListEntry;

            // read basic port data
            PVOID Port = NULL;
            ULONG PortSize;

            switch( SubdeviceEntry->Port.PortType)
            {
                case Topology:
                    Port = LocalAlloc( LPTR, sizeof(CPortTopology) );
                    if( !Port )
                    {
                        dprintf("** Unable to allocate port memory\n");
                        break;
                    }

                    if( !ReadMemory( (ULONG)((CPortTopology *)((ISubdevice *)(SubdeviceEntry->CreateItem.Context))),
                        Port,
                        sizeof(CPortTopology),
                        &Result ) )
                    {
                        dprintf("** Unable to read port data\n");
                        LocalFree( Port );
                        Port = NULL;
                        break;
                    }
                    break;

                case WaveCyclic:
                    Port = LocalAlloc( LPTR, sizeof(CPortWaveCyclic) );
                    if( !Port )
                    {
                        dprintf("** Unable to allocate port memory\n");
                        break;
                    }

                    if( !ReadMemory( (ULONG)((CPortWaveCyclic *)((ISubdevice *)(SubdeviceEntry->CreateItem.Context))),
                        Port,
                        sizeof(CPortWaveCyclic),
                        &Result ) )
                    {
                        dprintf("** Unable to read port data\n");
                        LocalFree( Port );
                        Port = NULL;
                        break;
                    }
                    break;

                case WavePci:
                    Port = LocalAlloc( LPTR, sizeof(CPortWavePci) );
                    if( !Port )
                    {
                        dprintf("** Unable to allocate port memory\n");
                        break;
                    }

                    if( !ReadMemory( (ULONG)((CPortWavePci *)((ISubdevice *)(SubdeviceEntry->CreateItem.Context))),
                        Port,
                        sizeof(CPortWavePci),
                        &Result ) )
                    {
                        dprintf("** Unable to read port data\n");
                        LocalFree( Port );
                        Port = NULL;
                        break;
                    }
                    break;

                case Midi:
                    Port = LocalAlloc( LPTR, sizeof(CPortMidi) );
                    if( !Port )
                    {
                        dprintf("** Unable to allocate port memory\n");
                        break;
                    }

                    if( !ReadMemory( (ULONG)((CPortMidi *)((ISubdevice *)(SubdeviceEntry->CreateItem.Context))),
                        Port,
                        sizeof(CPortMidi),
                        &Result ) )
                    {
                        dprintf("** Unable to read port data\n");
                        LocalFree( Port );
                        Port = NULL;
                        break;
                    }
                    break;

                default:
                    break;
            }

            if (!Port)
            {
                continue;
            }
            
            // attach the port data to the subdevice entry
            SubdeviceEntry->Port.PortData = Port;

            switch( SubdeviceEntry->Port.PortType )
            {
                case Topology:
                    break;

                case WaveCyclic:
                    {
                        CPortWaveCyclic *PortWaveCyclic = (CPortWaveCyclic *)Port;


                        // get the filter and pin data
                        if( Flags.FilterDump || Flags.PinDump )
                        {
                            ULONG               Offset;
                            ULONG               PortBase;
                            PLIST_ENTRY         Flink;
                            PLIST_ENTRY         TempListEntry;
                            ULONG               PinNumber = 0;
                            CPortPinWaveCyclic *PortPinWaveCyclic;
                            CIrpStream         *IrpStream;
                            PCKD_PIN_ENTRY     *CurrentPinEntry;
                            BOOL                NeedNewFilter;

                            // get the offsets needed to walk the list
                            Offset = FIELD_OFFSET(CPortWaveCyclic,m_PinList);
                            PortBase = (ULONG)((CPortWaveCyclic *)((ISubdevice *)(SubdeviceEntry->CreateItem.Context)));

                            // get the first pin pointer
                            Flink = PortWaveCyclic->m_PinList.Flink;

                            while (Flink != PLIST_ENTRY(PortBase + Offset))
                            {
                                    // allocate a pin list entry
                                    CurrentPinEntry = (PCKD_PIN_ENTRY *)LocalAlloc( LPTR, sizeof(PCKD_PIN_ENTRY) );
                                    if( !CurrentPinEntry )
                                    {
                                        dprintf("** Unable to allocate pin list entry\n");
                                        break;
                                    }

                                    // initialize the pin entry
                                    InitializeListHead( &(CurrentPinEntry->IrpList) );
                                    CurrentPinEntry->PinData = NULL;
                                    CurrentPinEntry->IrpStreamData = NULL;
                                CurrentPinEntry->PinInstanceId = PinNumber++;

                                    // allocate local storage for the pin data
                                    PortPinWaveCyclic = (CPortPinWaveCyclic *)LocalAlloc( LPTR, sizeof(CPortPinWaveCyclic) );
                                    if( !PortPinWaveCyclic )
                                    {
                                        dprintf("** Unable to allocate pin data storage\n");
                                        LocalFree( CurrentPinEntry );
                                        break;
                                    }

                                    // read the pin data
                                if( !ReadMemory( (ULONG)CONTAINING_RECORD(Flink,
                                                                          CPortPinWaveCyclic,
                                                                          m_PinListEntry),
                                                     PortPinWaveCyclic,
                                                     sizeof(CPortPinWaveCyclic),
                                                     &Result ) )
                                    {
                                        dprintf("** Unable to read pin data\n");
                                        LocalFree( PortPinWaveCyclic );
                                        LocalFree( CurrentPinEntry );
                                        break;
                                    }

                                    // is there an irp stream
                                    if( PortPinWaveCyclic->m_IrpStream )
                                    {
                                        // allocate local storage for the irp stream data
                                        IrpStream = (CIrpStream *)LocalAlloc( LPTR, sizeof(CIrpStream) );
                                        if( IrpStream )
                                        {
                                            // read the irp stream data
                                            if( !ReadMemory( (ULONG)((CIrpStream *)(PortPinWaveCyclic->m_IrpStream)),
                                                             IrpStream,
                                                             sizeof(CIrpStream),
                                                             &Result ) )
                                            {
                                                dprintf("** Unable to read irp stream data\n");
                                                LocalFree( IrpStream );
                                            } else
                                            {
                                                PCKD_AcquireIrpStreamData( CurrentPinEntry,
                                                                           (CIrpStream *)(PortPinWaveCyclic->m_IrpStream),
                                                                           IrpStream );
                                            }
                                        } else
                                        {
                                            dprintf("** Unable to allocate irp stream storage\n");
                                        }
                                    }

                                    // we need a new filter unless we find it in the filter list
                                    NeedNewFilter = TRUE;

                                    // is the filter list empty?
                                    if( !IsListEmpty( &(SubdeviceEntry->Port.FilterList) ) )
                                    {
                                        PLIST_ENTRY     FilterListEntry;

                                        for( FilterListEntry = SubdeviceEntry->Port.FilterList.Flink;
                                             FilterListEntry != &(SubdeviceEntry->Port.FilterList);
                                             FilterListEntry = FilterListEntry->Flink )
                                        {
                                            PCKD_FILTER_ENTRY *CurrentFilterEntry = (PCKD_FILTER_ENTRY *) FilterListEntry;

                                            if( CurrentFilterEntry->FilterInstanceId == (ULONG)(PortPinWaveCyclic->m_Filter) )
                                            {
                                                // found our filter
                                                NeedNewFilter = FALSE;

                                                // add the pin data to the pin entry
                                                CurrentPinEntry->PinData = (PVOID)PortPinWaveCyclic;

                                                // add the pin entry to the filter's pin list
                                                InsertTailList( &(CurrentFilterEntry->PinList),
                                                                &(CurrentPinEntry->ListEntry) );
                                            }
                                        }
                                    }

                                    // do we need a new filter entry?
                                    if( NeedNewFilter )
                                    {
                                        PCKD_FILTER_ENTRY   *CurrentFilterEntry;

                                        // allocate a new filter entry
                                        CurrentFilterEntry = (PCKD_FILTER_ENTRY *)LocalAlloc( LPTR, sizeof(PCKD_FILTER_ENTRY) );
                                        if(!CurrentFilterEntry)
                                        {
                                            dprintf("** Unable to allocate filter entry\n");
                                            LocalFree( PortPinWaveCyclic );
                                            if( CurrentPinEntry->IrpStreamData )
                                            {
                                                LocalFree( CurrentPinEntry->IrpStreamData );
                                            }
                                            // free up any irps in the irp list
                                            while(!IsListEmpty( &(CurrentPinEntry->IrpList)))
                                            {
                                                PCKD_IRP_ENTRY *IrpEntry = (PCKD_IRP_ENTRY *)RemoveTailList(&(CurrentPinEntry->IrpList));
                                                LocalFree( IrpEntry );                                                
                                            }
                                            LocalFree( CurrentPinEntry );
                                            break;
                                        }

                                        //initialize the new filter entry
                                        InitializeListHead( &(CurrentFilterEntry->PinList) );
                                        CurrentFilterEntry->FilterData = NULL;
                                        CurrentFilterEntry->FilterInstanceId = (ULONG)(PortPinWaveCyclic->m_Filter);

                                        // add the pin data to the pin entry
                                        CurrentPinEntry->PinData = (PVOID)PortPinWaveCyclic;

                                        // add the pin entry to the filter's pin list
                                        InsertTailList( &(CurrentFilterEntry->PinList),
                                                        &(CurrentPinEntry->ListEntry) );

                                        /// add the filter entry to the port's filter list
                                        InsertTailList( &(SubdeviceEntry->Port.FilterList),
                                                        &(CurrentFilterEntry->ListEntry) );
                                    }
                                
                                // allocate list entry storage
                                TempListEntry = (PLIST_ENTRY)LocalAlloc( LPTR, sizeof(LIST_ENTRY) );
                                if( TempListEntry )
                                {
                                    // read in the next list entry
                                    if( !ReadMemory( (ULONG)Flink,
                                                     TempListEntry,
                                                     sizeof(LIST_ENTRY),
                                                     &Result ) )
                                    {
                                        dprintf("** Unable to read temp list entry\n");
                                        LocalFree(TempListEntry);
                                        break;
                                    }

                                    // update FLINK
                                    Flink = TempListEntry->Flink;

                                    // free the temp list entry
                                    LocalFree( TempListEntry );
                                } else
                                {
                                    dprintf("** Unable to allocate temp list entry\n");
                                    break;
                                }                                                
                            }
                        }
                    }
                    break;

                case WavePci:
                    {
                        CPortWavePci *PortWavePci = (CPortWavePci *)Port;


                        // get the filter and pin data
                        if( Flags.FilterDump || Flags.PinDump )
                        {
                            ULONG               Offset;
                            ULONG               PortBase;
                            PLIST_ENTRY         Flink;
                            PLIST_ENTRY         TempListEntry;
                            ULONG               PinNumber = 0;
                            CPortPinWavePci    *PortPinWavePci;
                            CIrpStream         *IrpStream;
                            PCKD_PIN_ENTRY     *CurrentPinEntry;
                            BOOL                NeedNewFilter;

                            // get the offsets needed to walk the list
                            Offset = FIELD_OFFSET(CPortWavePci,m_PinList);
                            PortBase = (ULONG)((CPortWavePci *)((ISubdevice *)(SubdeviceEntry->CreateItem.Context)));

                            // get the first pin pointer
                            Flink = PortWavePci->m_PinList.Flink;

                            while (Flink != PLIST_ENTRY(PortBase + Offset))
                                {
                                    // allocate a pin list entry
                                    CurrentPinEntry = (PCKD_PIN_ENTRY *)LocalAlloc( LPTR, sizeof(PCKD_PIN_ENTRY) );
                                    if( !CurrentPinEntry )
                                    {
                                        dprintf("** Unable to allocate pin list entry\n");
                                        break;
                                    }

                                    // initialize the pin entry
                                    InitializeListHead( &(CurrentPinEntry->IrpList) );
                                    CurrentPinEntry->PinData = NULL;
                                CurrentPinEntry->IrpStreamData = NULL;
                                CurrentPinEntry->PinInstanceId = PinNumber++;

                                    // allocate local storage for the pin data
                                    PortPinWavePci = (CPortPinWavePci *)LocalAlloc( LPTR, sizeof(CPortPinWavePci) );
                                    if( !PortPinWavePci )
                                    {
                                        dprintf("** Unable to allocate pin data storage\n");
                                        LocalFree( CurrentPinEntry );
                                        break;
                                    }

                                    // read the pin data
                                if( !ReadMemory( (ULONG)CONTAINING_RECORD(Flink,
                                                                          CPortPinWavePci,
                                                                          m_PinListEntry),
                                                     PortPinWavePci,
                                                     sizeof(CPortPinWavePci),
                                                     &Result ) )
                                    {
                                        dprintf("** Unable to read pin data\n");
                                        LocalFree( PortPinWavePci );
                                        LocalFree( CurrentPinEntry );
                                        break;
                                    }

                                    // is there an irp stream
                                    if( PortPinWavePci->m_IrpStream )
                                    {
                                        // allocate local storage for the irp stream data
                                        IrpStream = (CIrpStream *)LocalAlloc( LPTR, sizeof(CIrpStream) );
                                        if( IrpStream )
                                        {
                                            // read the irp stream data
                                            if( !ReadMemory( (ULONG)((CIrpStream *)(PortPinWavePci->m_IrpStream)),
                                                             IrpStream,
                                                             sizeof(CIrpStream),
                                                             &Result ) )
                                            {
                                                dprintf("** Unable to read irp stream data\n");
                                                LocalFree( IrpStream );
                                            } else
                                            {
                                                PCKD_AcquireIrpStreamData( CurrentPinEntry,
                                                                           (CIrpStream *)(PortPinWavePci->m_IrpStream),
                                                                           IrpStream );
                                            }
                                        } else
                                        {
                                            dprintf("** Unable to allocate irp stream storage\n");
                                        }
                                    }

                                    // we need a new filter unless we find it in the filter list
                                    NeedNewFilter = TRUE;

                                    // is the filter list empty?
                                    if( !IsListEmpty( &(SubdeviceEntry->Port.FilterList) ) )
                                    {
                                        PLIST_ENTRY     FilterListEntry;

                                        for( FilterListEntry = SubdeviceEntry->Port.FilterList.Flink;
                                             FilterListEntry != &(SubdeviceEntry->Port.FilterList);
                                             FilterListEntry = FilterListEntry->Flink )
                                        {
                                            PCKD_FILTER_ENTRY *CurrentFilterEntry = (PCKD_FILTER_ENTRY *) FilterListEntry;

                                            if( CurrentFilterEntry->FilterInstanceId == (ULONG)(PortPinWavePci->Filter) )
                                            {
                                                // found our filter
                                                NeedNewFilter = FALSE;

                                                // add the pin data to the pin entry
                                                CurrentPinEntry->PinData = (PVOID)PortPinWavePci;

                                                // add the pin entry to the filter's pin list
                                                InsertTailList( &(CurrentFilterEntry->PinList),
                                                                &(CurrentPinEntry->ListEntry) );
                                            }
                                        }
                                    }

                                    // do we need a new filter entry?
                                    if( NeedNewFilter )
                                    {
                                        PCKD_FILTER_ENTRY   *CurrentFilterEntry;

                                        // allocate a new filter entry
                                        CurrentFilterEntry = (PCKD_FILTER_ENTRY *)LocalAlloc( LPTR, sizeof(PCKD_FILTER_ENTRY) );
                                        if(!CurrentFilterEntry)
                                        {
                                            dprintf("** Unable to allocate filter entry\n");
                                            LocalFree( PortPinWavePci );
                                            if( CurrentPinEntry->IrpStreamData )
                                            {
                                                LocalFree( CurrentPinEntry->IrpStreamData );
                                            }
                                            // free up any irps in the irp list
                                            while(!IsListEmpty( &(CurrentPinEntry->IrpList)))
                                            {
                                                PCKD_IRP_ENTRY *IrpEntry = (PCKD_IRP_ENTRY *)RemoveTailList(&(CurrentPinEntry->IrpList));
                                                LocalFree( IrpEntry );                                                
                                            }
                                            LocalFree( CurrentPinEntry );
                                            break;
                                        }

                                        //initialize the new filter entry
                                        InitializeListHead( &(CurrentFilterEntry->PinList) );
                                        CurrentFilterEntry->FilterData = NULL;
                                        CurrentFilterEntry->FilterInstanceId = (ULONG)(PortPinWavePci->Filter);

                                        // add the pin data to the pin entry
                                        CurrentPinEntry->PinData = (PVOID)PortPinWavePci;

                                        // add the pin entry to the filter's pin list
                                        InsertTailList( &(CurrentFilterEntry->PinList),
                                                        &(CurrentPinEntry->ListEntry) );

                                        /// add the filter entry to the port's filter list
                                        InsertTailList( &(SubdeviceEntry->Port.FilterList),
                                                        &(CurrentFilterEntry->ListEntry) );
                                    }
                                
                                // allocate list entry storage
                                TempListEntry = (PLIST_ENTRY)LocalAlloc( LPTR, sizeof(LIST_ENTRY) );
                                if( TempListEntry )
                                {
                                    // read in the next list entry
                                    if( !ReadMemory( (ULONG)Flink,
                                                     TempListEntry,
                                                     sizeof(LIST_ENTRY),
                                                     &Result ) )
                                    {
                                        dprintf("** Unable to read temp list entry\n");
                                        LocalFree(TempListEntry);
                                        break;
                                }

                                    // update FLINK
                                    Flink = TempListEntry->Flink;

                                    // free the temp list entry
                                    LocalFree( TempListEntry );
                                } else
                                {
                                    dprintf("** Unable to allocate temp list entry\n");
                                    break;
                                }                                                
                            }
                        }
                    }                    
                    break;

                case Midi:
                    {
                        CPortMidi *PortMidi = (CPortMidi *)Port;

                        // get the filter and pin data
                        if( Flags.FilterDump || Flags.PinDump )
                        {
                            ULONG               PinIndex;
                            CPortPinMidi       *PortPinMidi;
                            CIrpStream         *IrpStream;
                            PCKD_PIN_ENTRY     *CurrentPinEntry;
                            BOOL                NeedNewFilter;

                            for( PinIndex = 0; PinIndex < PortMidi->m_PinEntriesUsed; PinIndex++ )
                            {
                                if( PortMidi->m_Pins[ PinIndex] )
                                {
                                    // allocate a pin list entry
                                    CurrentPinEntry = (PCKD_PIN_ENTRY *)LocalAlloc( LPTR, sizeof(PCKD_PIN_ENTRY) );
                                    if( !CurrentPinEntry )
                                    {
                                        dprintf("** Unable to allocate pin list entry\n");
                                        break;
                                    }

                                    // initialize the pin entry
                                    InitializeListHead( &(CurrentPinEntry->IrpList) );
                                    CurrentPinEntry->PinData = NULL;
                                    CurrentPinEntry->PinInstanceId = (ULONG)(PortMidi->m_Pins[ PinIndex ]);

                                    // allocate local storage for the pin data
                                    PortPinMidi = (CPortPinMidi *)LocalAlloc( LPTR, sizeof(CPortPinMidi) );
                                    if( !PortPinMidi )
                                    {
                                        dprintf("** Unable to allocate pin data storage\n");
                                        LocalFree( CurrentPinEntry );
                                        break;
                                    }

                                    // read the pin data
                                    if( !ReadMemory( (ULONG)(PortMidi->m_Pins[ PinIndex ]),
                                                     PortPinMidi,
                                                     sizeof(CPortPinMidi),
                                                     &Result ) )
                                    {
                                        dprintf("** Unable to read pin data\n");
                                        LocalFree( PortPinMidi );
                                        LocalFree( CurrentPinEntry );
                                        break;
                                    }

                                    // is there an irp stream
                                    if( PortPinMidi->m_IrpStream )
                                    {
                                        // allocate local storage for the irp stream data
                                        IrpStream = (CIrpStream *)LocalAlloc( LPTR, sizeof(CIrpStream) );
                                        if( IrpStream )
                                        {
                                            // read the irp stream data
                                            if( !ReadMemory( (ULONG)(PortPinMidi->m_IrpStream),
                                                             IrpStream,
                                                             sizeof(CIrpStream),
                                                             &Result ) )
                                            {
                                                dprintf("** Unable to read irp stream data\n");
                                                LocalFree( IrpStream );
                                            } else
                                            {
                                                PCKD_AcquireIrpStreamData( CurrentPinEntry,
                                                                           (CIrpStream *)(PortPinMidi->m_IrpStream),
                                                                           IrpStream );
                                            }
                                        } else
                                        {
                                            dprintf("** Unable to allocate irp stream storage\n");
                                        }
                                    }

                                    // we need a new filter unless we find it in the filter list
                                    NeedNewFilter = TRUE;

                                    // is the filter list empty?
                                    if( !IsListEmpty( &(SubdeviceEntry->Port.FilterList) ) )
                                    {
                                        PLIST_ENTRY     FilterListEntry;

                                        for( FilterListEntry = SubdeviceEntry->Port.FilterList.Flink;
                                             FilterListEntry != &(SubdeviceEntry->Port.FilterList);
                                             FilterListEntry = FilterListEntry->Flink )
                                        {
                                            PCKD_FILTER_ENTRY *CurrentFilterEntry = (PCKD_FILTER_ENTRY *) FilterListEntry;

                                            if( CurrentFilterEntry->FilterInstanceId == (ULONG)(PortPinMidi->m_Filter) )
                                            {
                                                // found our filter
                                                NeedNewFilter = FALSE;

                                                // add the pin data to the pin entry
                                                CurrentPinEntry->PinData = (PVOID)PortPinMidi;

                                                // add the pin entry to the filter's pin list
                                                InsertTailList( &(CurrentFilterEntry->PinList),
                                                                &(CurrentPinEntry->ListEntry) );
                                            }
                                        }
                                    }

                                    // do we need a new filter entry?
                                    if( NeedNewFilter )
                                    {
                                        PCKD_FILTER_ENTRY   *CurrentFilterEntry;

                                        // allocate a new filter entry
                                        CurrentFilterEntry = (PCKD_FILTER_ENTRY *)LocalAlloc( LPTR, sizeof(PCKD_FILTER_ENTRY) );
                                        if(!CurrentFilterEntry)
                                        {
                                            dprintf("** Unable to allocate filter entry\n");
                                            LocalFree( PortPinMidi );
                                            if( CurrentPinEntry->IrpStreamData )
                                            {
                                                LocalFree( CurrentPinEntry->IrpStreamData );
                                            }
                                            // free up any irps in the irp list
                                            while(!IsListEmpty( &(CurrentPinEntry->IrpList)))
                                            {
                                                PCKD_IRP_ENTRY *IrpEntry = (PCKD_IRP_ENTRY *)RemoveTailList(&(CurrentPinEntry->IrpList));
                                                LocalFree( IrpEntry );
                                            }
                                            LocalFree( CurrentPinEntry );
                                            break;
                                        }

                                        //initialize the new filter entry
                                        InitializeListHead( &(CurrentFilterEntry->PinList) );
                                        CurrentFilterEntry->FilterData = NULL;
                                        CurrentFilterEntry->FilterInstanceId = (ULONG)(PortPinMidi->m_Filter);

                                        // add the pin data to the pin entry
                                        CurrentPinEntry->PinData = (PVOID)PortPinMidi;

                                        // add the pin entry to the filter's pin list
                                        InsertTailList( &(CurrentFilterEntry->PinList),
                                                        &(CurrentPinEntry->ListEntry) );

                                        /// add the filter entry to the port's filter list
                                        InsertTailList( &(SubdeviceEntry->Port.FilterList),
                                                        &(CurrentFilterEntry->ListEntry) );
                                    }
                                }
                            }
                        }
                    }                    
                    break;

                default:
                    break;
            }
        }
    }
}

/**********************************************************************
 * PCKD_DisplayDeviceData
 **********************************************************************
 * Description:
 *      This routine displays the requested device data on the debugger
 *      given a valid device context and a subdevice list built with
 *      PCKD_AcquireDeviceData.
 * Arguments:
 *      PDEVICE_CONTEXT     DeviceContext
 *      PLIST_ENTRY         SubdeviceList
 *      PORTCLS_FLAGS       Flags
 *
 * Return Value:
 *      None
 */
VOID
PCKD_DisplayDeviceData
(
    PDEVICE_CONTEXT     DeviceContext,
    PLIST_ENTRY         SubdeviceList,
    ULONG               flags
)
{
    PLIST_ENTRY             SubdeviceListEntry;
    PCKD_SUBDEVICE_ENTRY    *SubdeviceEntry;
    ANSI_STRING             AnsiNameString;
    PORTCLS_FLAGS           Flags;

    Flags.Flags = flags;

    dprintf("\n");

    // dump misc device context information
    if( Flags.DeviceContext )
    {
        dprintf("\n  DEVICE INFO:\n");
    
        dprintf("    PDO:                   0x%x\n",DeviceContext->PhysicalDeviceObject);
        if( Flags.Verbose )
        {
            if( Flags.ReallyVerbose )
            {
                dprintf("    Max Objects:           0x%x\n",DeviceContext->MaxObjects);
            }
            dprintf("    Existing Objects:      0x%x\n",DeviceContext->ExistingObjectCount);
            dprintf("    Active Pin Count:      0x%x\n",DeviceContext->ActivePinCount);
            dprintf("    Pending IRP Count:     0x%x\n",DeviceContext->PendingIrpCount);
        }
    }

    // dump power management information
    if( Flags.PowerInfo )
    {
        dprintf("\n  POWER INFO:\n");

        dprintf("    DeviceState:           %s\n", TranslateDevicePower( DeviceContext->CurrentDeviceState ) );
        dprintf("    SystemState:           %s\n", TranslateSystemPower( DeviceContext->CurrentSystemState ) );
        dprintf("    AdapterPower:          0x%x\n", DeviceContext->pAdapterPower );
        if( Flags.Verbose && Flags.ReallyVerbose )
        {
            ULONG index;
            
            dprintf("    Idle Timer:            0x%x\n", DeviceContext->IdleTimer );
            dprintf("    Cons Idle Time:        0x%x\n", DeviceContext->ConservationIdleTime );
            dprintf("    Perf Idle Time:        0x%x\n", DeviceContext->PerformanceIdleTime );
            dprintf("    Idle Device State:     %s\n", TranslateDevicePower( DeviceContext->IdleDeviceState ) );

            dprintf("    State Mappings:\n");    
            for( index = 0; index < (ULONG)PowerSystemMaximum; index++ )
            {
                dprintf("      %20s ==> %14s\n", TranslateSystemPower( index ),
                                                 TranslateDevicePower( DeviceContext->DeviceStateMap[ index ] ) );
            }
        }
    }

    // dump port/filter/pin information
    if( Flags.PortDump || Flags.FilterDump || Flags.PinDump )
    {
        if( !IsListEmpty( SubdeviceList ) )
        {
            // go through the subdevice list
            for( SubdeviceListEntry = SubdeviceList->Flink;
                 SubdeviceListEntry != SubdeviceList;
                 SubdeviceListEntry = SubdeviceListEntry->Flink )
            {
                SubdeviceEntry = (PCKD_SUBDEVICE_ENTRY *)SubdeviceListEntry;

                switch( SubdeviceEntry->Port.PortType )
                {
                    case Topology:
                        // dump port name
                        dprintf("\n  TOPOLOGY PORT:\n");
                        break;

                    case WaveCyclic:
                        // dump port name
                        dprintf("\n  WAVECYCLIC PORT:\n");
                        break;

                    case WavePci:
                        // dump port name
                        dprintf("\n  WAVEPCI PORT:\n");
                        break;

                    case Midi:
                        // dump port name
                        dprintf("\n  MIDI PORT:\n");
                        break;

                    default:
                        // dump port name
                        dprintf("\n  UNKNOWN PORT:\n");
                        break;                        
                }

                // print out the real name
                RtlUnicodeStringToAnsiString( &AnsiNameString,
                                              &(SubdeviceEntry->CreateItem.ObjectClass),
                                              TRUE );
                dprintf("    Name:                  %s\n",AnsiNameString.Buffer);
                RtlFreeAnsiString( &AnsiNameString );

                // dump the port instance
                dprintf("    Port Instance:         0x%x\n",SubdeviceEntry->CreateItem.Context);

                if( Flags.Verbose && Flags.ReallyVerbose )
                {
                    // dump generic port data
                    dprintf("    Create:                0x%x\n",SubdeviceEntry->CreateItem.Create);
                    dprintf("    Security:              0x%x\n",SubdeviceEntry->CreateItem.SecurityDescriptor);
                    dprintf("    Flags:                 0x%x\n",SubdeviceEntry->CreateItem.Flags);
                }

                // dump port type specific port data
                switch( SubdeviceEntry->Port.PortType )
                {
                    case Topology:
                        {
                            CPortTopology *port = (CPortTopology *)(SubdeviceEntry->Port.PortData);
                            dprintf("    Miniport:              0x%x\n",port->Miniport);
                            if( Flags.Verbose && Flags.ReallyVerbose )
                            {
                                dprintf("    Subdevice Desc:        0x%x\n",port->m_pSubdeviceDescriptor);
                                dprintf("    Filter Desc:           0x%x\n",port->m_pPcFilterDescriptor);
                            }
                        }
                        break;

                    case WaveCyclic:
                        {
                            CPortWaveCyclic *port = (CPortWaveCyclic *)(SubdeviceEntry->Port.PortData);
                            dprintf("    Miniport:              0x%x\n",port->Miniport);
                            if( Flags.Verbose && Flags.ReallyVerbose )
                            {
                                dprintf("    Subdevice Desc:        0x%x\n",port->m_pSubdeviceDescriptor);
                                dprintf("    Filter Desc:           0x%x\n",port->m_pPcFilterDescriptor);
                            }
                        }
                        break;

                    case WavePci:
                        {
                            CPortWavePci *port = (CPortWavePci *)(SubdeviceEntry->Port.PortData);
                            dprintf("    Miniport:              0x%x\n",port->Miniport);
                            if( Flags.Verbose && Flags.ReallyVerbose )
                            {
                                dprintf("    Subdevice Desc:        0x%x\n",port->m_pSubdeviceDescriptor);
                                dprintf("    Filter Desc:           0x%x\n",port->m_pPcFilterDescriptor);
                            }
                        }
                        break;

                    case Midi:
                        {
                            CPortMidi *port = (CPortMidi *)(SubdeviceEntry->Port.PortData);
                            dprintf("    Miniport:              0x%x\n",port->m_Miniport);
                            if( Flags.Verbose && Flags.ReallyVerbose )
                            {
                                dprintf("    Subdevice Desc:        0x%x\n",port->m_pSubdeviceDescriptor);
                                dprintf("    Filter Desc:           0x%x\n",port->m_pPcFilterDescriptor);
                            }
                            dprintf("    Pin Count:             0x%x\n",port->m_PinEntriesUsed);
                        }
                        break;

                    default:
                        break;
                }

                if( Flags.FilterDump || Flags.PinDump )
                {
                    // dump the filters
                    if( !IsListEmpty( &(SubdeviceEntry->Port.FilterList) ) )
                    {
                        PLIST_ENTRY         FilterListEntry;
                        PCKD_FILTER_ENTRY   *FilterEntry;                        

                        // run through the filter list
                        for( FilterListEntry = SubdeviceEntry->Port.FilterList.Flink;
                             FilterListEntry != &(SubdeviceEntry->Port.FilterList);
                             FilterListEntry = FilterListEntry->Flink )
                        {
                            FilterEntry = (PCKD_FILTER_ENTRY *)FilterListEntry;

                            dprintf("      Filter Instance:     0x%x\n",FilterEntry->FilterInstanceId);

                            if( Flags.PinDump )
                            {
                                // dump the pins
                                if( !IsListEmpty( &(FilterEntry->PinList) ) )
                                {
                                    PLIST_ENTRY         PinListEntry;
                                    PCKD_PIN_ENTRY      *PinEntry;

                                    // run through the pin list
                                    for( PinListEntry = FilterEntry->PinList.Flink;
                                         PinListEntry != &(FilterEntry->PinList);
                                         PinListEntry = PinListEntry->Flink )
                                    {
                                        PinEntry = (PCKD_PIN_ENTRY *)PinListEntry;

                                        dprintf("        Pin Instance:      0x%x\n",PinEntry->PinInstanceId);

                                        // dump the pin data
                                        switch( SubdeviceEntry->Port.PortType )
                                        {
                                            case WaveCyclic:
                                                {
                                                    CPortPinWaveCyclic *pin = (CPortPinWaveCyclic *)(PinEntry->PinData);

                                                    if( pin )
                                                    {
                                                        dprintf("          Miniport Stream: 0x%x\n",pin->m_Stream);
                                                        dprintf("          Stream State:    %s\n", TranslateKsState(pin->m_DeviceState));
                                                        if( Flags.Verbose && Flags.ReallyVerbose )
                                                        {
                                                            dprintf("          Pin ID:          0x%x\n",pin->m_Id);
                                                            dprintf("          Commanded State: %s\n", TranslateKsState(pin->m_CommandedState));
                                                            dprintf("          Suspended:       %s\n", pin->m_Suspended ? "TRUE" : "FALSE");
                                                        }
                                                        dprintf("          Dataflow:        %s\n",TranslateKsDataFlow( pin->m_DataFlow ) );
                                                        dprintf("          Data Format:     0x%x\n",pin->m_DataFormat);
                                                        if( Flags.Verbose && Flags.ReallyVerbose )
                                                        {
                                                            dprintf("          Pin Desc:        0x%x\n",pin->m_Descriptor);                                                           
                                                        }
                                                        if( Flags.Verbose )
                                                        {
                                                            dprintf("          Service Group:   0x%x\n",pin->m_ServiceGroup);
                                                            dprintf("          Dma Channel:     0x%x\n",pin->m_DmaChannel);
                                                            dprintf("          Irp Stream:      0x%x\n",pin->m_IrpStream);
                                                            if( !IsListEmpty( &(PinEntry->IrpList) ) )
                                                            {
                                                                PLIST_ENTRY     IrpListEntry;
                                                                PCKD_IRP_ENTRY *IrpEntry;

                                                                // run through the irp list
                                                                for( IrpListEntry = PinEntry->IrpList.Flink;
                                                                     IrpListEntry != &(PinEntry->IrpList);
                                                                     IrpListEntry = IrpListEntry->Flink )
                                                                {
                                                                    IrpEntry = (PCKD_IRP_ENTRY *)IrpListEntry;
                                                                    dprintf("            Irp:           0x%x (%s)\n",IrpEntry->Irp,
                                                                                                                     TranslateQueueType(IrpEntry->QueueType));
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                break;

                                            case WavePci:
                                                {
                                                    CPortPinWavePci *pin = (CPortPinWavePci *)(PinEntry->PinData);

                                                    if( pin )
                                                    {
                                                        dprintf("          Miniport Stream: 0x%x\n",pin->Stream);
                                                        dprintf("          Stream State:    %s\n", TranslateKsState(pin->m_DeviceState));
                                                        if( Flags.Verbose && Flags.ReallyVerbose )
                                                        {
                                                            dprintf("          Pin ID:          0x%x\n",pin->Id);
                                                            dprintf("          Commanded State: %s\n", TranslateKsState(pin->CommandedState));
                                                            dprintf("          Suspended:       %s\n", pin->m_Suspended ? "TRUE" : "FALSE");
                                                        }
                                                        //dprintf("          Dataflow:        %s\n",TranslateKsDataFlow( pin->DataFlow ) );
                                                        dprintf("          Data Format:     0x%x\n",pin->DataFormat);
                                                        if( Flags.Verbose && Flags.ReallyVerbose )
                                                        {
                                                            dprintf("          Pin Desc:        0x%x\n",pin->Descriptor);                                                           
                                                        }
                                                        if( Flags.Verbose )
                                                        {
                                                            dprintf("          Service Group:   0x%x\n",pin->ServiceGroup);
                                                            dprintf("          Dma Channel:     0x%x\n",pin->DmaChannel);
                                                            dprintf("          Irp Stream:      0x%x\n",pin->m_IrpStream);
                                                        }
                                                    }
                                                }
                                                break;

                                            case Midi:
                                                {
                                                    CPortPinMidi *pin = (CPortPinMidi *)(PinEntry->PinData);

                                                    if( pin )
                                                    {
                                                        dprintf("          Miniport Stream: 0x%x\n",pin->m_Stream);
                                                        dprintf("          Stream State:    %s\n", TranslateKsState(pin->m_DeviceState));
                                                        if( Flags.Verbose && Flags.ReallyVerbose )
                                                        {
                                                            dprintf("          Pin ID:          0x%x\n",pin->m_Id);
                                                            dprintf("          Commanded State: %s\n", TranslateKsState(pin->m_CommandedState));
                                                            dprintf("          Suspended:       %s\n", pin->m_Suspended ? "TRUE" : "FALSE");
                                                        }
                                                        dprintf("          Dataflow:        %s\n",TranslateKsDataFlow( pin->m_DataFlow ) );
                                                        dprintf("          Data Format:     0x%x\n",pin->m_DataFormat);
                                                        if( Flags.Verbose && Flags.ReallyVerbose )
                                                        {
                                                            dprintf("          Pin Desc:        0x%x\n",pin->m_Descriptor);                                                           
                                                        }
                                                        if( Flags.Verbose )
                                                        {
                                                            dprintf("          Service Group:   0x%x\n",pin->m_ServiceGroup);
                                                            dprintf("          Irp Stream:      0x%x\n",pin->m_IrpStream);
                                                        }
                                                    }
                                                }
                                                break;

                                            default:
                                                break;
                                        }

                                    }

                                } else
                                {
                                    dprintf("        No Pin Instances:\n");      
                                }
                            }
                        }   
                    }
                }
            }
        }
    }

    return;
}

/**********************************************************************
 * PCKD_FreeDeviceData
 **********************************************************************
 * Description:
 *      This routine cleans up and frees the subdevice list.
 * Arguments:
 *      PLIST_ENTRY         SubdeviceList
 *
 * Return Value:
 *      None
 */
VOID
PCKD_FreeDeviceData
(
    PLIST_ENTRY         SubdeviceList
)
{
    PLIST_ENTRY             SubdeviceListEntry;
    PLIST_ENTRY             FilterListEntry;
    PLIST_ENTRY             PinListEntry;
    PCKD_SUBDEVICE_ENTRY    *SubdeviceEntry;
    PCKD_FILTER_ENTRY       *FilterEntry;
    PCKD_PIN_ENTRY          *PinEntry;

    if( !IsListEmpty( SubdeviceList ) )
    {
        SubdeviceListEntry = RemoveHeadList( SubdeviceList );

        while( SubdeviceListEntry )
        {
            SubdeviceEntry = (PCKD_SUBDEVICE_ENTRY *) SubdeviceListEntry;

            // see if we have filters in the filter list
            if( !IsListEmpty( &(SubdeviceEntry->Port.FilterList) ) )
            {
                FilterListEntry = RemoveHeadList( &(SubdeviceEntry->Port.FilterList) );

                while( FilterListEntry )
                {
                    FilterEntry = (PCKD_FILTER_ENTRY *)FilterListEntry;

                    // see if we have pins in the pin list
                    if( !IsListEmpty( &(FilterEntry->PinList) ) )
                    {
                        PinListEntry = RemoveHeadList( &(FilterEntry->PinList) );

                        while( PinListEntry )
                        {
                            PinEntry = (PCKD_PIN_ENTRY *)PinListEntry;

                            // free the pin data
                            if( PinEntry->PinData )
                            {
                                LocalFree( PinEntry->PinData );
                            }

                            // free the irp stream data
                            if( PinEntry->IrpStreamData )
                            {
                                LocalFree( PinEntry->IrpStreamData );
                            }

                            // free up any irps in the irp list
                            while( !IsListEmpty( &(PinEntry->IrpList) ) )
                            {
                                PCKD_IRP_ENTRY *IrpEntry = (PCKD_IRP_ENTRY *)RemoveTailList(&(PinEntry->IrpList));
                                LocalFree( IrpEntry );
                            }

                            // free the pin entry
                            LocalFree( PinEntry );

                            // get the next pin
                            if( !IsListEmpty( &(FilterEntry->PinList) ) )
                            {
                                PinListEntry = RemoveTailList( &(FilterEntry->PinList) );
                            } else
                            {
                                PinListEntry = NULL;
                            }
                        }
                    }

                    // free the filter data
                    if( FilterEntry->FilterData )
                    {
                        LocalFree( FilterEntry->FilterData );
                    }

                    // free the filter entry
                    LocalFree( FilterEntry );

                    // get the next filter
                    if( !IsListEmpty( &(SubdeviceEntry->Port.FilterList) ) )
                    {
                        FilterListEntry = RemoveTailList( &(SubdeviceEntry->Port.FilterList) );
                    } else
                    {
                        FilterListEntry = NULL;
                    }
                }
            }

            // free the port data
            if( SubdeviceEntry->Port.PortData )
            {
                LocalFree( SubdeviceEntry->Port.PortData );
            }

            // free the unicode string buffer
            LocalFree( SubdeviceEntry->CreateItem.ObjectClass.Buffer );

            // free the subdevice entry
            LocalFree( SubdeviceEntry );

            // on to the next subdevice
            if( !IsListEmpty( SubdeviceList ) )
            {
                SubdeviceListEntry = RemoveTailList( SubdeviceList );
            } else
            {
                SubdeviceListEntry = NULL;
            }
        }
    }

    return;
}

/**********************************************************************
 * PCKD_AcquireIrpStreamData
 **********************************************************************
 * Description:
 *      This routine acquires irp stream irp queue data.
 * Arguments:
 *      PCKD_PIN_ENTRY  *CurrentPinEntry
 *      CIrpStream      *RemoteIrpStream,
 *      CIrpStream      *LocalIrpStream
 *
 * Return Value:
 *      None
 */
VOID
PCKD_AcquireIrpStreamData
(
    PVOID           PinEntry,
    CIrpStream     *RemoteIrpStream,
    CIrpStream     *LocalIrpStream
)
{
    ULONG           QueueType;
    PLIST_ENTRY     Flink;
    PLIST_ENTRY     TempListEntry;
    PIRP            pIrp;
    PCKD_IRP_ENTRY *IrpEntry;
    ULONG           Offset;
    ULONG           Result;
    PCKD_PIN_ENTRY *CurrentPinEntry;

    CurrentPinEntry = (PCKD_PIN_ENTRY *)PinEntry;

    // processs the queues
    for( QueueType = MAPPED_QUEUE; QueueType < MAX_QUEUES; QueueType++ )
    {
        switch( QueueType )
        {
            case PRELOCK_QUEUE:
                Offset = FIELD_OFFSET(CIrpStream,PreLockQueue);
                Flink = LocalIrpStream->PreLockQueue.Flink;
                break;
            case LOCKED_QUEUE:
                Offset = FIELD_OFFSET(CIrpStream,LockedQueue);
                Flink = LocalIrpStream->LockedQueue.Flink;
                break;
            case MAPPED_QUEUE:
                Offset = FIELD_OFFSET(CIrpStream,MappedQueue);
                Flink = LocalIrpStream->MappedQueue.Flink;
                break;
            default:
                Flink = 0;
                break;
        }

        // walk the list (note we can't use IsListEmpty)
        while( (Flink) && (Flink != (PLIST_ENTRY)((PBYTE)RemoteIrpStream + Offset)))
        {
            // get the irp pointer
            pIrp = CONTAINING_RECORD( Flink, IRP, Tail.Overlay.ListEntry );
    
            // allocate an irp entry
            IrpEntry = (PCKD_IRP_ENTRY *)LocalAlloc( LPTR, sizeof(PCKD_IRP_ENTRY) );
            if( IrpEntry )
            {
                // initialize the irp entry
                IrpEntry->QueueType = QueueType;
                IrpEntry->Irp = pIrp;
    
                // add the irp entry to the pin entry
                InsertTailList( &(CurrentPinEntry->IrpList),
                                &(IrpEntry->ListEntry) );
    
            } else
            {
                dprintf("** Unable to allocate irp entry\n");
            }
    
            // allocate list entry storage
            TempListEntry = (PLIST_ENTRY)LocalAlloc( LPTR, sizeof(LIST_ENTRY) );
            if( TempListEntry )
            {
                // read in the next list entry
                if( !ReadMemory( (ULONG)Flink,
                                 TempListEntry,
                                 sizeof(LIST_ENTRY),
                                 &Result ) )
                {
                    dprintf("** Unable to read temp list entry\n");
                    LocalFree(TempListEntry);
                    break;
                }
    
                // update FLINK
                Flink = TempListEntry->Flink;
    
                // free the temp list entry
                LocalFree( TempListEntry );
            } else
            {
                dprintf("** Unable to allocate temp list entry\n");
                break;
            }                                                
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\ports\dmus\allocatr.cpp ===
/*  
    Base implementation of MIDI Transform Filter object for DMUS_KERNEL_EVENT struct allocation.

    Copyright (c) 1998-2000 Microsoft Corporation.  All rights reserved.

    05/08/98    Martin Puryear      Created this file
    03/10/99    Martin Puryear      Major memory management overhaul.  Ugh!

*/

#define STR_MODULENAME "DMus:AllocatorMXF: "

#include "private.h"
#include "Allocatr.h"


/*****************************************************************************
 * CAllocatorMXF::CAllocatorMXF()
 *****************************************************************************
 * Constructor.
 */
#pragma code_seg("PAGE")
CAllocatorMXF::CAllocatorMXF(PPOSITIONNOTIFY BytePositionNotify)
:   CUnknown(NULL),
    CMXF(NULL)
{
    PAGED_CODE();
	ASSERT(BytePositionNotify);

    m_NumPages = 0;
    m_NumFreeEvents = 0;
    m_pPages = NULL;
    m_pEventList = NULL;

    KeInitializeSpinLock(&m_EventLock);

    m_BytePositionNotify = BytePositionNotify;
    if (BytePositionNotify)
    {
        BytePositionNotify->AddRef();
    }
}

/*****************************************************************************
 * CAllocatorMXF::~CAllocatorMXF()
 *****************************************************************************
 * Destructor.  Put away the messages in the pool.
 */
#pragma code_seg("PAGE")
CAllocatorMXF::~CAllocatorMXF(void)
{
    PAGED_CODE();
   
    _DbgPrintF(DEBUGLVL_BLAB,("~CAllocatorMXF, m_BytePositionNotify == ox%p",m_BytePositionNotify));
    if (m_BytePositionNotify)
    {
        m_BytePositionNotify->Release();
    }

    DestructorFreeBuffers();
    DestroyPages(m_pPages);

    ASSERT(m_NumPages == 0);
}

/*****************************************************************************
 * CAllocatorMXF::~CAllocatorMXF()
 *****************************************************************************
 * Destructor.  Put away the messages in the pool.
 */
#pragma code_seg()
void CAllocatorMXF::DestructorFreeBuffers(void)
{
    KIRQL               OldIrql;
    KeAcquireSpinLock(&m_EventLock,&OldIrql);
    (void) FreeBuffers(m_pEventList);
    KeReleaseSpinLock(&m_EventLock,OldIrql);
}

/*****************************************************************************
 * CAllocatorMXF::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.
 */
#pragma code_seg("PAGE")
STDMETHODIMP_(NTSTATUS) CAllocatorMXF::NonDelegatingQueryInterface
(
    REFIID  Interface,
    PVOID * Object
)
{
    PAGED_CODE();

    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface,IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(PMXF(this)));
    }
    else if (IsEqualGUIDAligned(Interface,IID_IMXF))
    {
        *Object = PVOID(PMXF(this));
    }
    else if (IsEqualGUIDAligned(Interface,IID_IAllocatorMXF))
    {
        *Object = PVOID(PAllocatorMXF(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER_1;
}

/*****************************************************************************
 * CAllocatorMXF::SetState()
 *****************************************************************************
 * Not implemented.
 */
#pragma code_seg("PAGE")
NTSTATUS CAllocatorMXF::SetState(KSSTATE State)    
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE,("SetState %d",State));
    return STATUS_NOT_IMPLEMENTED;    
}

/*****************************************************************************
 * CAllocatorMXF::ConnectOutput()
 *****************************************************************************
 * Not implemented.
 */
#pragma code_seg("PAGE")
NTSTATUS CAllocatorMXF::ConnectOutput(PMXF sinkMXF)
{   
    PAGED_CODE();

    return STATUS_NOT_IMPLEMENTED;
};

/*****************************************************************************
 * CAllocatorMXF::DisconnectOutput()
 *****************************************************************************
 * Not implemented.
 */
#pragma code_seg("PAGE")
NTSTATUS CAllocatorMXF::DisconnectOutput(PMXF sinkMXF) 
{   
    PAGED_CODE();

    return STATUS_NOT_IMPLEMENTED;    
};

/*****************************************************************************
 * CAllocatorMXF::GetBuffer()
 *****************************************************************************
 * Create a buffer for long events.
 */
#pragma code_seg()
NTSTATUS CAllocatorMXF::GetBuffer(PBYTE *pByte)
{
    USHORT  bufferSize = GetBufferSize();
    
    _DbgPrintF(DEBUGLVL_BLAB,("GetBuffer(0x%p)",pByte));
    
    *pByte = (PBYTE) ExAllocatePoolWithTag(NonPagedPool,bufferSize,'bFXM');    //  'MXFb'

    if (!(*pByte))
    {
        _DbgPrintF(DEBUGLVL_TERSE,("GetBuffer: ExAllocatePoolWithTag failed"));
    }
    else
    {
        _DbgPrintF(DEBUGLVL_BLAB,("GetBuffer: *pByte returns 0x%p",*pByte));
    }
    return STATUS_SUCCESS;
}

/*****************************************************************************
 * CAllocatorMXF::PutBuffer()
 *****************************************************************************
 * Destroy a buffer.
 */
#pragma code_seg()
NTSTATUS CAllocatorMXF::PutBuffer(PBYTE pByte)
{
    _DbgPrintF(DEBUGLVL_BLAB,("PutBuffer(%p)",pByte));
    NTSTATUS    ntStatus;

    if (pByte)
    {
        ExFreePool(pByte);
        ntStatus = STATUS_SUCCESS;
    }
    else
    {
        ntStatus = STATUS_UNSUCCESSFUL;
    }
    return ntStatus;
}

/*****************************************************************************
 * CAllocatorMXF::GetMessage()
 *****************************************************************************
 * Get an event from the pool.
 */
#pragma code_seg()
NTSTATUS CAllocatorMXF::GetMessage(PDMUS_KERNEL_EVENT *ppDMKEvt)
{
    NTSTATUS ntStatus;

    ntStatus = STATUS_SUCCESS;
    KIRQL   OldIrql;
    KeAcquireSpinLock(&m_EventLock,&OldIrql);
    //_DbgPrintF(DEBUGLVL_TERSE,("GetMessage: m_NumFreeEvents was originally %d",m_NumFreeEvents));
    CheckEventLowWaterMark();

    //_DbgPrintF(DEBUGLVL_TERSE,("GetMessage: low water check, then m_NumFreeEvents was %d",m_NumFreeEvents));
    if (m_NumFreeEvents)
    {
        //  take a message off the free list
        *ppDMKEvt = m_pEventList;
        m_pEventList = m_pEventList->pNextEvt;
        (*ppDMKEvt)->pNextEvt = NULL;
        m_NumFreeEvents--;
        KeReleaseSpinLock(&m_EventLock,OldIrql);

        // ensure that all the fields are blank (don't mess with cbStruct)
        if (  ((*ppDMKEvt)->bReserved) || ((*ppDMKEvt)->cbEvent)          || ((*ppDMKEvt)->usChannelGroup) 
           || ((*ppDMKEvt)->usFlags)   || ((*ppDMKEvt)->ullPresTime100ns) || ((*ppDMKEvt)->uData.pbData)
           || ((*ppDMKEvt)->ullBytePosition != kBytePositionNone))
        {
            _DbgPrintF(DEBUGLVL_TERSE,("GetMessage: new message isn't zeroed out:"));
            DumpDMKEvt((*ppDMKEvt),DEBUGLVL_TERSE);
            _DbgPrintF(DEBUGLVL_ERROR,(""));
        }
    }
    else
    {
        KeReleaseSpinLock(&m_EventLock,OldIrql);
        _DbgPrintF(DEBUGLVL_TERSE,("GetMessage: couldn't allocate new message"));
        *ppDMKEvt = NULL;
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

//    _DbgPrintF(DEBUGLVL_TERSE,("GetMessage: *ppDMKEvt returning %p",*ppDMKEvt));
    if (m_NumFreeEvents)
    {
        ASSERT(m_pEventList);
    }
    else
    {
        ASSERT(!m_pEventList);
    } 

    return ntStatus;
}

/*****************************************************************************
 * CAllocatorMXF::PutMessage()
 *****************************************************************************
 * Put a list of messages back in the pool.
 *
 *      Wait as long as you can until grabbing the spinlock.
 */
#pragma code_seg()
NTSTATUS CAllocatorMXF::PutMessage(PDMUS_KERNEL_EVENT pDMKEvt)
{
    PDMUS_KERNEL_EVENT  pEvtList;
    NTSTATUS            ntStatus,masterStatus;

    masterStatus = STATUS_SUCCESS;
    
    if (!pDMKEvt)
    {
        return masterStatus;
    }

    while (pDMKEvt->pNextEvt)   //  put them away one at a time
    {
        pEvtList = pDMKEvt->pNextEvt;
        pDMKEvt->pNextEvt = NULL;
        ntStatus = PutMessage(pDMKEvt);
        if (NT_SUCCESS(masterStatus))
        {
            masterStatus = ntStatus;
        }
        pDMKEvt = pEvtList;
    }

    if (!(PACKAGE_EVT(pDMKEvt)))
    {
        if (pDMKEvt->ullBytePosition)
        {
            if (pDMKEvt->ullBytePosition != kBytePositionNone)
            {
                m_BytePositionNotify->PositionNotify(pDMKEvt->ullBytePosition);

                if (pDMKEvt->ullBytePosition >= 0xFFFFFFFFFFFFF000)
                {
                    _DbgPrintF(DEBUGLVL_TERSE,("running byte position will roll over soon!"));
                }
            }
        }
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE,("BytePosition has been zeroed out, unable to advance byte position!"));
        }

        pDMKEvt->bReserved = 0;
        pDMKEvt->cbStruct = sizeof(DMUS_KERNEL_EVENT);
        pDMKEvt->usChannelGroup = 0;
        pDMKEvt->usFlags = 0;
        pDMKEvt->ullPresTime100ns = 0;
        pDMKEvt->ullBytePosition = kBytePositionNone;
        if (pDMKEvt->cbEvent > sizeof(PBYTE))
        {
            PutBuffer(pDMKEvt->uData.pbData);
        }
        pDMKEvt->cbEvent = 0;
        pDMKEvt->uData.pbData = NULL;

        KIRQL   OldIrql;
        KeAcquireSpinLock(&m_EventLock,&OldIrql);
        pDMKEvt->pNextEvt = m_pEventList;
        m_pEventList = pDMKEvt;

        m_NumFreeEvents++;
        CheckEventHighWaterMark();
        KeReleaseSpinLock(&m_EventLock,OldIrql);
        return masterStatus;
    }

    //  package event
    ASSERT(kBytePositionNone == pDMKEvt->ullBytePosition);
    pDMKEvt->ullBytePosition = kBytePositionNone;

    pEvtList = pDMKEvt->uData.pPackageEvt;
    pDMKEvt->uData.pPackageEvt = NULL;
    CLEAR_PACKAGE_EVT(pDMKEvt);   //  no longer a package
    ntStatus = PutMessage(pDMKEvt);
    if (NT_SUCCESS(masterStatus))
    {
        masterStatus = ntStatus;
    }
    ntStatus = PutMessage(pEvtList);
    if (NT_SUCCESS(masterStatus))
    {
        masterStatus = ntStatus;
    }

    if (m_NumFreeEvents)
    {
        ASSERT(m_pEventList);
    }
    else
    {
        ASSERT(!m_pEventList);
    } 

    return masterStatus;
}

/*****************************************************************************
 * CAllocatorMXF::CheckEventHighWaterMark()
 *****************************************************************************
 * See if the pool is too large.
 * Assumes the protective spinlock is held.
 */
#pragma code_seg()
void CAllocatorMXF::CheckEventHighWaterMark(void)
{
//    _DbgPrintF(DEBUGLVL_ERROR,("CheckEventHighWaterMark"));
    //  SOMEDAY:    prune the working set here
}

/*****************************************************************************
 * CAllocatorMXF::CheckBufferHighWaterMark()
 *****************************************************************************
 * See if the pool is too large.
 * Assumes the protective spinlock is held.
 *
#pragma code_seg()
void CAllocatorMXF::CheckBufferHighWaterMark(void)
{
//    _DbgPrintF(DEBUGLVL_ERROR,("CheckBufferHighWaterMark"));
    //  SOMEDAY:    prune the working set here
}

/*****************************************************************************
 * CAllocatorMXF::CheckEventLowWaterMark()
 *****************************************************************************
 * See if the pool is depleted.
 * Assumes the protective spinlock is held.
 */
#pragma code_seg()
void CAllocatorMXF::CheckEventLowWaterMark(void)
{
//    _DbgPrintF(DEBUGLVL_TERSE,("CheckEventLowWaterMark, m_NumFreeEvents was %d",m_NumFreeEvents));
//    _DbgPrintF(DEBUGLVL_TERSE,("CheckEventLowWaterMark, m_pEventList was %p",m_pEventList));
    
    if (m_NumFreeEvents)
    {
        ASSERT(m_pEventList);
        return;
    }
    else
    {
        ASSERT(!m_pEventList);

        //  allocate a page worth of messages        
        MakeNewEvents();
    } 
//    _DbgPrintF(DEBUGLVL_TERSE,("CheckEventLowWaterMark, m_NumFreeEvents is now %d",m_NumFreeEvents));
//    _DbgPrintF(DEBUGLVL_TERSE,("CheckEventLowWaterMark, m_pEventList is now %p",m_pEventList));
}

/*****************************************************************************
 * CAllocatorMXF::MakeNewEvents()
 *****************************************************************************
 * Create messages for the pool.
 */
#pragma code_seg()
void CAllocatorMXF::MakeNewEvents(void)
{
    ASSERT(!m_pEventList);

    PDMUS_KERNEL_EVENT pDMKEvt;

    pDMKEvt = (PDMUS_KERNEL_EVENT) ExAllocatePoolWithTag(
                              NonPagedPool,
                              sizeof(DMUS_KERNEL_EVENT) * kNumEvtsPerPage,
                              ' FXM');    //  'MXF '
    if (pDMKEvt)
    {
        if (AddPage(&m_pPages,(PVOID)pDMKEvt))
        {
            USHORT msgCountdown = kNumEvtsPerPage;
            PDMUS_KERNEL_EVENT pRunningDMKEvt = pDMKEvt;
        
            while (msgCountdown)
            {
                m_NumFreeEvents ++;
                pRunningDMKEvt->bReserved = 0;
                pRunningDMKEvt->cbStruct = sizeof(DMUS_KERNEL_EVENT);
                pRunningDMKEvt->cbEvent = 0;
                pRunningDMKEvt->usChannelGroup = 0;
                pRunningDMKEvt->usFlags = 0;
                pRunningDMKEvt->ullPresTime100ns = 0;
                pRunningDMKEvt->ullBytePosition = kBytePositionNone;
                pRunningDMKEvt->uData.pbData = NULL;

                msgCountdown--;
                if (msgCountdown)   //  there will be another after this one
                {
                    pRunningDMKEvt->pNextEvt = pRunningDMKEvt + 1;
                    pRunningDMKEvt = pRunningDMKEvt->pNextEvt;
                }
                else
                {
                    pRunningDMKEvt->pNextEvt = NULL;
                }
            }
            ASSERT ( m_NumFreeEvents == kNumEvtsPerPage ); 
            m_pEventList = pDMKEvt;
        }
        else
        {
            ExFreePool(pDMKEvt);
        }
    }
    else
    {
        _DbgPrintF(DEBUGLVL_TERSE,("MakeNewEvents: ExAllocatePoolWithTag failed"));
    }

#if DBG
    // sanity check with m_pEventList and m_NumFreeEvents
    DWORD   dwCount = 0;
    pDMKEvt = m_pEventList;
    while (pDMKEvt)
    {
        dwCount++;
        pDMKEvt = pDMKEvt->pNextEvt;
    }
    ASSERT(dwCount == m_NumFreeEvents);

    if (m_NumFreeEvents)
    {
        ASSERT(m_pEventList);
    }
    else
    {
        ASSERT(!m_pEventList);
    }
#endif  //  DBG
}

/*****************************************************************************
 * CAllocatorMXF::GetBufferSize()
 *****************************************************************************
 * Get the size of the standard buffer allocated.
 */
#pragma code_seg()
USHORT CAllocatorMXF::GetBufferSize()
{
    return kMXFBufferSize;  //  even multiple of 12 and 20 (legacy and DMusic IRP buffer sizes)
}

//  TODO:   bit that signifies whether event is in allocator currently or not.
//          This will catch double-Puts (such as packages)

/*****************************************************************************
 * CAllocatorMXF::AddPage()
 *****************************************************************************
 * Destroy a message from the pool.
 */
#pragma code_seg()
BOOL CAllocatorMXF::AddPage(PVOID *pPool, PVOID pPage)
{
    _DbgPrintF(DEBUGLVL_BLAB,("AddPage( %p %p )",pPool,pPage));

    if (!*pPool)
    {
        *pPool = ExAllocatePoolWithTag(NonPagedPool,
                                         kNumPtrsPerPage * sizeof(PVOID),
                                         'pFXM');    //  'MXFp'
        _DbgPrintF(DEBUGLVL_BLAB,("AddPage: ExAllocate *pPool is 0x%p",*pPool));
        if (*pPool)
        {
            RtlZeroMemory(*pPool,kNumPtrsPerPage * sizeof(PVOID));
            m_NumPages++;       //  this is for the root page itself
        }
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE,("AddPage: ExAllocatePoolWithTag failed"));
        }

        _DbgPrintF(DEBUGLVL_BLAB,("AddPage: m_NumPages is %d",m_NumPages));
    }
    if (*pPool)
    {
        PVOID   *pPagePtr;
        pPagePtr = (PVOID *)(*pPool);
        USHORT count = 1;
        while (count < kNumPtrsPerPage)
        {
            if (*pPagePtr)
            {
                pPagePtr++;
            }
            else
            {
                *pPagePtr = pPage;
                m_NumPages++;       //  this is for the leaf page 
                break;
            }
            count++;
        }
        if (count == kNumPtrsPerPage)
        {
            _DbgPrintF(DEBUGLVL_ERROR,("AddPage: about to recurse"));
            if (!AddPage(pPagePtr,pPage))
            {
                _DbgPrintF(DEBUGLVL_ERROR,("AddPage: recursion failed."));
                return FALSE;
            }
        }
    }
    else
    {
        _DbgPrintF(DEBUGLVL_ERROR,("AddPage: creating trunk failed."));
        return FALSE;
    }
    _DbgPrintF(DEBUGLVL_BLAB,("AddPage: final m_NumPages is %d",m_NumPages));
    return TRUE;
}

/*****************************************************************************
 * CAllocatorMXF::DestroyPages()
 *****************************************************************************
 * Tears down the accumulated pool.
 */
#pragma code_seg("PAGE")
void CAllocatorMXF::DestroyPages(PVOID pPages)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB,("DestroyPages(0x%p)",pPages));
    PVOID *ppPage;
    
    if (pPages)
    {
        ppPage = (PVOID *)pPages;
        for (USHORT count = kNumPtrsPerPage;count > 1;count--)
        {
            if (*ppPage)
            {
                ExFreePool(PVOID(*ppPage));
                *ppPage = NULL;
                m_NumPages--;
            }
            ppPage++;
        }
        if (*ppPage)
        {
            _DbgPrintF(DEBUGLVL_ERROR,("DestroyPages:About to recurse"));
            DestroyPages(PVOID(*ppPage));
        }

        ExFreePool(pPages);
        m_NumPages--;
    }
}

#pragma code_seg()
NTSTATUS CAllocatorMXF::FreeBuffers(PDMUS_KERNEL_EVENT  pDMKEvt)
{
    NTSTATUS            ntStatus;

    ntStatus = STATUS_SUCCESS;
    _DbgPrintF(DEBUGLVL_BLAB,("FreeBuffers(%p)",pDMKEvt));

    while (pDMKEvt)
    {
        if (!PACKAGE_EVT(pDMKEvt))
        {
            if (pDMKEvt->cbEvent > sizeof(PBYTE))
            {
                PutBuffer(pDMKEvt->uData.pbData);
                pDMKEvt->uData.pbData = NULL;
                pDMKEvt->cbEvent = 0;
            }
        }
        else
        {
            FreeBuffers(pDMKEvt->uData.pPackageEvt);
        }
        pDMKEvt = pDMKEvt->pNextEvt;
    }
    return ntStatus;
}

#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\ports\dmus\basicmxf.cpp ===
/*  
    Base implementation of MIDI Transform Filter object

    Copyright (c) 1998-2000 Microsoft Corporation.  All rights reserved.

    05/06/98    Martin Puryear      Created this file

*/

#include "private.h"
#include "BasicMXF.h"

#pragma code_seg("PAGE")
CBasicMXF::CBasicMXF(CAllocatorMXF *allocatorMXF, PMASTERCLOCK clock)
:   CUnknown(NULL),
    CMXF(allocatorMXF)
{
    PAGED_CODE();

    m_SinkMXF = allocatorMXF;
    m_Clock = clock;
}

/*  Artfully remove this filter from the chain  */
#pragma code_seg("PAGE")
CBasicMXF::~CBasicMXF(void)
{
    PAGED_CODE();

    (void) DisconnectOutput(m_SinkMXF);
}

/*****************************************************************************
 * CBasicMXF::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.
 */
#pragma code_seg("PAGE")
STDMETHODIMP_(NTSTATUS)
CBasicMXF::
NonDelegatingQueryInterface
(
    REFIID  Interface,
    PVOID * Object
)
{
    PAGED_CODE();

    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface,IID_IUnknown))
    {
        *Object = PVOID(PMXF(this));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IMXF))
    {
        *Object = PVOID(PMXF(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER_1;
}

#pragma code_seg("PAGE")
NTSTATUS 
CBasicMXF::SetState(KSSTATE State)    
{   
    PAGED_CODE();
    
    _DbgPrintF(DEBUGLVL_VERBOSE,("SetState %d",State));
    return STATUS_NOT_IMPLEMENTED;    
}

#pragma code_seg("PAGE")
NTSTATUS CBasicMXF::ConnectOutput(PMXF sinkMXF)
{
    PAGED_CODE();

    if ((sinkMXF) && (m_SinkMXF == m_AllocatorMXF)) 
    {
        _DbgPrintF(DEBUGLVL_BLAB, ("ConnectOutput"));
        m_SinkMXF = sinkMXF;
        return STATUS_SUCCESS;
    }
    _DbgPrintF(DEBUGLVL_TERSE, ("ConnectOutput failed"));
    return STATUS_UNSUCCESSFUL;
}

#pragma code_seg("PAGE")
NTSTATUS CBasicMXF::DisconnectOutput(PMXF sinkMXF)
{
    PAGED_CODE();
    
    if ((m_SinkMXF == sinkMXF) || (!sinkMXF))
    {
        _DbgPrintF(DEBUGLVL_BLAB, ("DisconnectOutput"));
        m_SinkMXF = m_AllocatorMXF;
        return STATUS_SUCCESS;
    }
    _DbgPrintF(DEBUGLVL_TERSE, ("DisconnectOutput failed"));
    return STATUS_UNSUCCESSFUL;
}

#pragma code_seg()
//  Process and forward this message to the next filter in the chain.
NTSTATUS CBasicMXF::PutMessage(PDMUS_KERNEL_EVENT pDMKEvt)
{
    if (m_SinkMXF)
    {
        (void) UnrollAndProcess(pDMKEvt);
        m_SinkMXF->PutMessage(pDMKEvt);
    }
    else
    {
        m_AllocatorMXF->PutMessage(pDMKEvt);
    }
    return STATUS_SUCCESS;
}

#pragma code_seg()
NTSTATUS CBasicMXF::UnrollAndProcess(PDMUS_KERNEL_EVENT pDMKEvt)
{
    if (COMPLETE_EVT(pDMKEvt))
    {
        if (pDMKEvt->cbEvent <= sizeof(PBYTE))  //  short message
        {
            (void) DoProcessing(pDMKEvt);
        }
        else if (PACKAGE_EVT(pDMKEvt))          //  deal with packages
        {
            (void) UnrollAndProcess(pDMKEvt->uData.pPackageEvt);
        }
    }
    if (pDMKEvt->pNextEvt)                      //  deal with successors
    {
        (void) UnrollAndProcess(pDMKEvt->pNextEvt);
    }
    return STATUS_SUCCESS;
}

#pragma code_seg()
NTSTATUS CBasicMXF::DoProcessing(PDMUS_KERNEL_EVENT pDMKEvt)
{
    if (  (pDMKEvt->uData.abData[0] & 0xE0 == 0x80)     //  if NoteOn/NoteOff
       || (pDMKEvt->uData.abData[0] & 0xF0 == 0xA0))    //  if After-Pressure
    {
        (pDMKEvt->uData.abData[1])++;                   //  increment the noteNum
    }
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\ports\dmus\basicmxf.h ===
/*  
    Base definition of MIDI Transform Filter object 

    Copyright (c) 1998-2000 Microsoft Corporation.  All rights reserved.

    05/06/98    Martin Puryear      Created this file

*/

#ifndef __BasicMXF_H__
#define __BasicMXF_H__

#include "MXF.h"
#include "Allocatr.h"


class CBasicMXF 
:   public CMXF,
    public IMXF,
    public CUnknown
{
public:
    CBasicMXF(CAllocatorMXF *allocatorMXF, PMASTERCLOCK clock);
    ~CBasicMXF(void);

    DECLARE_STD_UNKNOWN();
    IMP_IMXF;
protected:
    NTSTATUS UnrollAndProcess(PDMUS_KERNEL_EVENT pDMKEvt);
    NTSTATUS DoProcessing(PDMUS_KERNEL_EVENT pDMKEvt);

protected:
    PMXF            m_SinkMXF;
    PMASTERCLOCK    m_Clock;
};

#endif  //  __BasicMXF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\ports\audport\audport.cpp ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation.  All rights reserved.

Module Name:

    audport.cpp

Abstract:

    Kernel Port

--*/

#define PUT_GUIDS_HERE
#include "portclsp.h"
#include <unknown.h>
#include <kcom.h>
#if (DBG)
#define STR_MODULENAME "audport: "
#endif
#include <ksdebug.h>

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA

//
// Here we have a table of all the things we want to instantiate.  This is
// the way portcls did it, so we just copied the code.  No such table is
// required.  There just needs to be a way to create the right object
// based on the clsid.
//
extern PORT_DRIVER PortDriverWaveCyclic;
extern PORT_DRIVER PortDriverWavePci;
extern PORT_DRIVER PortDriverTopology;
extern PORT_DRIVER PortDriverMidi;
extern PORT_DRIVER PortDriverDMus;
extern PORT_DRIVER MiniportDriverUart;
extern PORT_DRIVER MiniportDriverFmSynth;
extern PORT_DRIVER MiniportDriverFmSynthWithVol;
extern PORT_DRIVER MiniportDriverDMusUART;

PPORT_DRIVER PortDriverTable[] =
{
    &PortDriverWaveCyclic,
    &PortDriverWavePci,
    &PortDriverTopology,
    &PortDriverMidi,
    &PortDriverDMus,
    &MiniportDriverUart,
    &MiniportDriverFmSynth,
    &MiniportDriverFmSynthWithVol,
    &MiniportDriverDMusUART
};

/*****************************************************************************
 * GetClassInfo()
 *****************************************************************************
 * Get information regarding a class.
 */
NTSTATUS
GetClassInfo
(
	IN	REFCLSID            ClassId,
    OUT PFNCREATEINSTANCE * Create
)
{
    PAGED_CODE();

    ASSERT(Create);

    PPORT_DRIVER *  portDriver = PortDriverTable;

    for
    (
        ULONG count = SIZEOF_ARRAY(PortDriverTable);
        count--;
        portDriver++
    )
    {
        if (IsEqualGUIDAligned(ClassId,*(*portDriver)->ClassId))
        {
            *Create = (*portDriver)->Create;
            return STATUS_SUCCESS;
        }
    }

    return STATUS_INVALID_DEVICE_REQUEST;
}


extern "C"
NTSTATUS
CreateObjectHandler(
    IN REFCLSID ClassId,
    IN IUnknown* UnkOuter OPTIONAL,
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    )
/*++

Routine Description:

    This entry point is used to create an object of the class supported by this
    module. The entry point is registered in DriverEntry so that the built-in
    default processing can be used to acquire this entry point when the module
    is loaded by KCOM.

Arguments:

    ClassId -
        The class of object to create. This must be PMPORT_Transform.

    UnkOuter -
        Optionally contains the outer IUnknown interface to use.

    InterfaceId -
        Contains the interface to return on the object created. The test
        object only supports IUnknown.

    Interface -
        The place in which to return the interface on the object created.

Return Values:

    Returns STATUS_SUCCESS if the object is created and the requested
    interface is returned, else an error.

--*/
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_TERSE, ("CreateObjectHandler"));

    ASSERT(Interface);

    PUNKNOWN            unknown;
    PFNCREATEINSTANCE   create;

    //
    // Look it up in the table.
    //
    NTSTATUS ntStatus =
        GetClassInfo
        (
            ClassId,
            &create
        );

    //
    // If we found one, create it.
    //
    if (NT_SUCCESS(ntStatus))
    {
        ntStatus =
            create
            (
                &unknown,
                ClassId,
                UnkOuter,
                NonPagedPool
            );

        //
        // Get the requested interface.
        //
        if (NT_SUCCESS(ntStatus))
        {
            ntStatus = unknown->QueryInterface(IID_IPort,(PVOID *) Interface);

            unknown->Release();
        }
    }

    return ntStatus;
}

#ifdef ALLOC_PRAGMA
#pragma code_seg("INIT")
#endif // ALLOC_PRAGMA


extern "C"
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPathName
    )
/*++

Routine Description:

    Sets up the driver object by calling the default KCOM initialization.

Arguments:

    DriverObject -
        Driver object for this instance.

    RegistryPathName -
        Contains the registry path which was used to load this instance.

Return Values:

    Returns STATUS_SUCCESS if the driver was initialized.

--*/
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_TERSE, ("DriverEntry"));
    //
    // Initialize the driver entry points to use the default Irp processing
    // code. Pass in the create handler for objects supported by this module.
    //
    return KoDriverInitialize(DriverObject, RegistryPathName, CreateObjectHandler);
}

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\ports\dmus\captsink.cpp ===
/*  
    MIDI Transform Filter object for parsing the capture stream
    This includes expanding running status, flagging bad MIDI data,
    and handling multiple channel groups concurrently.

    Copyright (c) 1998-2000 Microsoft Corporation.  All rights reserved.

    12/10/98    Martin Puryear      Created this file

*/

#define STR_MODULENAME "DMus:CaptureSinkMXF: "
#include "private.h"
#include "parse.h"
#include "CaptSink.h"

#define TestOutOfMem1 0
#define TestOutOfMem2 0
#define TestOutOfMem3 0

#pragma code_seg("PAGE")
/*****************************************************************************
 * CCaptureSinkMXF::CCaptureSinkMXF()
 *****************************************************************************
 * Constructor.  An allocator and a clock must be provided.
 */
CCaptureSinkMXF::CCaptureSinkMXF(CAllocatorMXF *AllocatorMXF,
                                 PMASTERCLOCK Clock)
:   CUnknown(NULL),
    CMXF(AllocatorMXF)
{
    PAGED_CODE();
    
    ASSERT(AllocatorMXF);
    ASSERT(Clock);
    
    _DbgPrintF(DEBUGLVL_BLAB, ("Constructor"));
    m_SinkMXF = AllocatorMXF;
    m_Clock = Clock;
    m_ParseList = NULL;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CCaptureSinkMXF::~CCaptureSinkMXF()
 *****************************************************************************
 * Destructor.  Artfully remove this filter from the chain before freeing.
 */
CCaptureSinkMXF::~CCaptureSinkMXF(void)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB, ("Destructor"));
    (void) DisconnectOutput(m_SinkMXF);
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CCaptureSinkMXF::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.
 */
STDMETHODIMP_(NTSTATUS)
CCaptureSinkMXF::
NonDelegatingQueryInterface
(
    REFIID  Interface,
    PVOID * Object
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB, ("NonDelegatingQueryInterface"));
    ASSERT(Object);
    if (!Object)
    {
        return STATUS_INVALID_PARAMETER_2;
    }

    if (IsEqualGUIDAligned(Interface,IID_IUnknown))
    {
        *Object = PVOID(PMXF(this));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IMXF))
    {
        *Object = PVOID(PMXF(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER_1;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CCaptureSinkMXF::SetState()
 *****************************************************************************
 * Set the state of the filter.
 * This is currently not implemented.
 */
NTSTATUS 
CCaptureSinkMXF::SetState(KSSTATE State)    
{   
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB, ("SetState %d",State));
    m_State = State;
//    if (KSSTATE_STOP == State)
//    {
//        (void) Flush();
//    }
    return STATUS_SUCCESS;    
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CCaptureSinkMXF::ConnectOutput()
 *****************************************************************************
 * Create a forwarding address for this filter, 
 * instead of shunting it to the allocator.
 */
NTSTATUS CCaptureSinkMXF::ConnectOutput(PMXF sinkMXF)
{
    PAGED_CODE();

    if ((sinkMXF) && (m_SinkMXF == m_AllocatorMXF)) 
    {
        _DbgPrintF(DEBUGLVL_BLAB, ("ConnectOutput"));
        m_SinkMXF = sinkMXF;
        return STATUS_SUCCESS;
    }
    _DbgPrintF(DEBUGLVL_TERSE, ("ConnectOutput failed"));
    return STATUS_UNSUCCESSFUL;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CCaptureSinkMXF::DisconnectOutput()
 *****************************************************************************
 * Remove the forwarding address for this filter.
 * This filter should now forward all messages to the allocator.
 */
NTSTATUS CCaptureSinkMXF::DisconnectOutput(PMXF sinkMXF)
{
    PAGED_CODE();

    if ((m_SinkMXF == sinkMXF) || (!sinkMXF))
    {
        _DbgPrintF(DEBUGLVL_BLAB, ("DisconnectOutput"));
        m_SinkMXF = m_AllocatorMXF;
        return STATUS_SUCCESS;
    }
    _DbgPrintF(DEBUGLVL_TERSE, ("DisconnectOutput failed"));
    return STATUS_UNSUCCESSFUL;
}

#pragma code_seg()
/*****************************************************************************
 * CCaptureSinkMXF::PutMessage()
 *****************************************************************************
 * Receive a message.
 * We should unwrap any packages here.
 * We should unroll any chains here.
 * We should send single messages to SinkOneEvent()
 */
NTSTATUS CCaptureSinkMXF::PutMessage(PDMUS_KERNEL_EVENT pDMKEvt)
{
    PDMUS_KERNEL_EVENT pNextEvt;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //  do we have a forwarding address?  If not, trash the message (chain) now.
    if ((m_SinkMXF == m_AllocatorMXF) || (KSSTATE_STOP == m_State))
    {
        _DbgPrintF(DEBUGLVL_VERBOSE, ("PutMessage->allocator"));
        m_AllocatorMXF->PutMessage(pDMKEvt);
        return STATUS_SUCCESS;
    }

    //  This gets us started, and handles being called with NULL
    while (pDMKEvt)
    {
        pNextEvt = pDMKEvt->pNextEvt;
        pDMKEvt->pNextEvt = NULL;
        if (PACKAGE_EVT(pDMKEvt))
        {
            _DbgPrintF(DEBUGLVL_VERBOSE, ("PutMessage(package), unwrapping package"));
            PutMessage(pDMKEvt->uData.pPackageEvt);
            m_AllocatorMXF->PutMessage(pDMKEvt);
        }
        else 
        {
            SinkOneEvent(pDMKEvt);
        }
        pDMKEvt = pNextEvt;
    }
    return STATUS_SUCCESS;
}

#pragma code_seg()
/*****************************************************************************
 * CCaptureSinkMXF::SinkOneEvent()
 *****************************************************************************
 * If the event is a raw byte fragment, submit it for parsing.
 * If the event is complete (pre-parsed, potentially non-compliant), 
 * forward any previous data on that channel group as an incomplete message 
 * (unstructured) and forward the complete message verbatim.
 */
NTSTATUS CCaptureSinkMXF::SinkOneEvent(PDMUS_KERNEL_EVENT pDMKEvt)
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    //  is this a raw byte stream fragment, or a complete msg?
    //
    if (INCOMPLETE_EVT(pDMKEvt))
    {
        //  this is a message fragment
        _DbgPrintF(DEBUGLVL_BLAB, ("SinkOneEvent(incomplete)"));
        (void) ParseFragment(pDMKEvt);
    }
    else
    {   //  complete message, we are going to send this msg as is
        PDMUS_KERNEL_EVENT pPrevData;
    
        pPrevData = RemoveListEvent(pDMKEvt->usChannelGroup);
        //  A complete msg flushes that channel group's queue and clears running status.
        //  This is cool because the device is either: 
        //  - Not MIDI compliant (ForceFeedback), so deriving running status is weird, or
        //  - Parsing anyway, so we decree they must expand running status
        _DbgPrintF(DEBUGLVL_VERBOSE, ("SinkOneEvent(complete): pDMKEvt:"));
        DumpDMKEvt(pDMKEvt,DEBUGLVL_VERBOSE);
        _DbgPrintF(DEBUGLVL_VERBOSE, ("SinkOneEvent(complete): pPrevData:"));
        DumpDMKEvt(pPrevData,DEBUGLVL_VERBOSE);

        if (pPrevData)
        {
            if (RUNNING_STATUS(pPrevData))
            {   //  throw away this message, no real content
                _DbgPrintF(DEBUGLVL_VERBOSE, ("SinkOneEvent: throwing away pPrevData"));
                m_AllocatorMXF->PutMessage(pPrevData);
            }
            else
            {
                _DbgPrintF(DEBUGLVL_VERBOSE, ("SinkOneEvent: pPrevData is a fragment, set INCOMPLETE and forwarded"));
                SET_INCOMPLETE_EVT(pPrevData);  //  mark this as a fragment
                SET_DATA2_STATE(pPrevData);     //  mark this as a data discontinuity
                pPrevData->pNextEvt = pDMKEvt;
                pDMKEvt = pPrevData;
            }
        }
        SET_STATUS_STATE(pDMKEvt);
        m_SinkMXF->PutMessage(pDMKEvt);
    }

    return STATUS_SUCCESS;
}

#pragma code_seg()
/*****************************************************************************
 *  CCaptureSinkMXF::ParseFragment()
 *****************************************************************************
 * This is where a raw byte stream is coallesced into cooked 
 * messages.  We use a different queue for each channel group.  
 * For SysEx messages, flush the message when a page is full.
 *
 * check out unpacker and packer for cases I've forgotten
 * must update docs for implications of "complete" messages (clear running status, not MIDI parsed) 
 * as well as embedded RT messages (perf hit), 
 * long messages coming from the miniport must be supported (USB/1394)
 
 *  Parse additional input on a given channel group.
 *  Forward messages onward if they are complete.
 *  Take running status into account.
 */
NTSTATUS CCaptureSinkMXF::ParseFragment(PDMUS_KERNEL_EVENT pDMKEvt)
{
    DMUS_KERNEL_EVENT   dmKEvt, *pPrevData;
    USHORT              cbData;
    PBYTE               pFragSource;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    _DbgPrintF(DEBUGLVL_VERBOSE, ("ParseFragment: this msg:"));
    DumpDMKEvt(pDMKEvt,DEBUGLVL_VERBOSE);
    ASSERT(pDMKEvt);
    ASSERT(pDMKEvt->cbEvent);
    
    //  copy message locally, to reuse that PDMKEvt
    //  zero the PDMKEvt before we use it; retain cbStruct, usChannelGroup
    ASSERT(pDMKEvt->cbStruct == sizeof(DMUS_KERNEL_EVENT));

    RtlCopyMemory(&dmKEvt,pDMKEvt,sizeof(DMUS_KERNEL_EVENT));
    pDMKEvt->cbEvent          = pDMKEvt->usFlags = 0;
    pDMKEvt->ullPresTime100ns = 0;
    pDMKEvt->uData.pbData     = 0;

    //  tack pDMKEvt on to previous data (as available scribble space)
    pPrevData = RemoveListEvent(pDMKEvt->usChannelGroup);
    if (pPrevData)
    {
        pPrevData->pNextEvt = pDMKEvt;
    }
    else
    {
        pPrevData = pDMKEvt;
    }

    _DbgPrintF(DEBUGLVL_BLAB, ("ParseFragment: scribble space will be:"));
    DumpDMKEvt(pPrevData,DEBUGLVL_BLAB);
    if (pPrevData->pNextEvt)
    {
        DumpDMKEvt(pPrevData->pNextEvt,DEBUGLVL_BLAB);
    }

    if (dmKEvt.cbEvent > sizeof(PBYTE)) 
    {
        pFragSource = dmKEvt.uData.pbData;
    } 
    else 
    {
        pFragSource = dmKEvt.uData.abData;
    }
    //  one byte at a time, parse into pPrevData
    for (cbData = 0;cbData < dmKEvt.cbEvent;cbData++)
    {
        //  no scribble space, nor running status event
        if (!pPrevData)
        {
            _DbgPrintF(DEBUGLVL_BLAB, ("ParseFragment: we exhausted our scribble space, allocating more"));
            
            //  allocate a new pPrevData, set chanGroup
            (void) m_AllocatorMXF->GetMessage(&pPrevData);
        }
        //  out of memory; clean up and bail
        if (!pPrevData)
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("ParseFragment: can't allocate additional scribble space"));
            if (dmKEvt.cbEvent > sizeof(PBYTE))
            {
                m_AllocatorMXF->PutBuffer(dmKEvt.uData.pbData);
                dmKEvt.cbEvent = 0;
                dmKEvt.uData.pbData = NULL;
            }
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        //  if adding the first byte to a new event, set it up
        if (pPrevData->cbEvent == 0)
        {
            pPrevData->ullPresTime100ns = dmKEvt.ullPresTime100ns;
            pPrevData->usChannelGroup = dmKEvt.usChannelGroup;
        }
        //  add this byte.  pPrevData will potentially become a different message
        ParseOneByte(pFragSource[cbData],&pPrevData,dmKEvt.ullPresTime100ns);
    }
    //  done parsing this fragment
    //  free the buffer of a long fragment
    if (dmKEvt.cbEvent > sizeof(PBYTE))
    {
        m_AllocatorMXF->PutBuffer(dmKEvt.uData.pbData);
    }
    if (pPrevData)
    {
        //  we only need one fragment event
        if (pPrevData->pNextEvt)
        {
            _DbgPrintF(DEBUGLVL_BLAB, ("ParseFragment: Tossing this into the allocator:"));
            DumpDMKEvt(pPrevData->pNextEvt,DEBUGLVL_BLAB);

            (void) m_AllocatorMXF->PutMessage(pPrevData->pNextEvt);
            pPrevData->pNextEvt = NULL;
        }
        //  only save one if it has content (this includes running status)
        if (pPrevData->cbEvent)
        {
            _DbgPrintF(DEBUGLVL_BLAB, ("ParseFragment: Inserting this into the list:"));
            (void)InsertListEvent(pPrevData);
        }
    }

    return STATUS_SUCCESS;
}


#pragma code_seg()
/*****************************************************************************
 * CCaptureSinkMXF::ParseOneByte()
 *****************************************************************************
 * Parse a byte into a fragment.  Forward it if necessary.
 */
NTSTATUS CCaptureSinkMXF::ParseOneByte(BYTE aByte,PDMUS_KERNEL_EVENT *ppDMKEvt,REFERENCE_TIME refTime)
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    if (STATUS_STATE((*ppDMKEvt)))
    {
        ASSERT((*ppDMKEvt)->cbEvent <= 1);
    }
    _DbgPrintF(DEBUGLVL_BLAB, ("ParseOneByte: %X into:",aByte));
    DumpDMKEvt((*ppDMKEvt),DEBUGLVL_BLAB);

    //  arranged in some semblance of decreasing frequency
    if (IS_DATA_BYTE(aByte))
    {
        _DbgPrintF(DEBUGLVL_BLAB, ("ParseOneByte: IS_DATA_BYTE"));
        return ParseDataByte(aByte,ppDMKEvt,refTime);
    }
    if (IS_CHANNEL_MSG(aByte))
    {
        _DbgPrintF(DEBUGLVL_BLAB, ("ParseOneByte: IS_CHANNEL_MSG"));
        return ParseChanMsgByte(aByte,ppDMKEvt,refTime);
    }
    if (IS_REALTIME_MSG(aByte))
    {
        _DbgPrintF(DEBUGLVL_BLAB, ("ParseOneByte: IS_REALTIME_MSG"));
        return ParseRTByte(aByte,ppDMKEvt,refTime);
    }
    if (IS_SYSEX(aByte))
    {
        _DbgPrintF(DEBUGLVL_BLAB, ("ParseOneByte: IS_SYSEX"));
        return ParseSysExByte(aByte,ppDMKEvt,refTime);
    }
    if (IS_SYSEX_END(aByte))
    {
        _DbgPrintF(DEBUGLVL_BLAB, ("ParseOneByte: IS_SYSEX_END"));
        return ParseEOXByte(aByte,ppDMKEvt,refTime);
    }
    if (IS_SYSTEM_COMMON(aByte))
    {
        _DbgPrintF(DEBUGLVL_BLAB, ("ParseOneByte: IS_SYSTEM_COMMON"));
        return ParseSysCommonByte(aByte,ppDMKEvt,refTime);
    }
    return STATUS_SUCCESS;  //  ha! not really
}

#pragma code_seg()
/*****************************************************************************
 * CCaptureSinkMXF::AddByteToEvent()
 *****************************************************************************
 * Simply append the byte to this event.
 */
NTSTATUS CCaptureSinkMXF::AddByteToEvent(BYTE aByte,PDMUS_KERNEL_EVENT pDMKEvt)
{    
    PBYTE              pBuffer;
    PDMUS_KERNEL_EVENT pOtherDMKEvt;
    
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    if (pDMKEvt->cbEvent < sizeof(PBYTE))
    {
        pDMKEvt->uData.abData[pDMKEvt->cbEvent] = aByte;
    }
    else if (pDMKEvt->cbEvent == sizeof(PBYTE))
    {    //  if we are a full short message, allocate a page and copy data into it
        (void) m_AllocatorMXF->GetBuffer(&pBuffer);
        if (pBuffer)
        {
            RtlCopyMemory(pBuffer,pDMKEvt->uData.abData,pDMKEvt->cbEvent);
            pDMKEvt->uData.pbData = pBuffer;
            pDMKEvt->uData.pbData[sizeof(PBYTE)] = aByte;
        }
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("AddByteToEvent: alloc->GetBuffer failed"));
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else if (pDMKEvt->cbEvent < m_AllocatorMXF->GetBufferSize())
    {
        pDMKEvt->uData.pbData[pDMKEvt->cbEvent] = aByte;
    }
    else    //  buffer full!  allocate new message, copy pDMKEvt to new message
    {   
        (void) m_AllocatorMXF->GetMessage(&pOtherDMKEvt);
        if (pOtherDMKEvt)
        {
            pOtherDMKEvt->cbEvent = pDMKEvt->cbEvent;
            pOtherDMKEvt->usChannelGroup = pDMKEvt->usChannelGroup;
            pOtherDMKEvt->usFlags = pDMKEvt->usFlags;
            pOtherDMKEvt->ullPresTime100ns = pDMKEvt->ullPresTime100ns;
            pOtherDMKEvt->uData.pbData = pDMKEvt->uData.pbData;
        }
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("AddByteToEvent: alloc->GetMessage failed"));
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        SET_INCOMPLETE_EVT(pOtherDMKEvt);
        SET_STATUS_STATE(pOtherDMKEvt);   
        m_SinkMXF->PutMessage(pOtherDMKEvt);
        pDMKEvt->cbEvent = 0;
        pDMKEvt->uData.abData[0] = aByte;
    }
    pDMKEvt->cbEvent++;

    return STATUS_SUCCESS;
}

#pragma code_seg()
/*****************************************************************************
 * CCaptureSinkMXF::ParseDataByte()
 *****************************************************************************
 * Parse a data byte into a fragment.  
 * Forward a completed message if necessary.
 * Create running status if necessary.
 */
NTSTATUS CCaptureSinkMXF::ParseDataByte(BYTE aByte,PDMUS_KERNEL_EVENT *ppDMKEvt,REFERENCE_TIME refTime)
{
    PDMUS_KERNEL_EVENT  pDMKEvt,pOtherDMKEvt;
    NTSTATUS            ntStatus;

    pDMKEvt = *ppDMKEvt;
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    _DbgPrintF(DEBUGLVL_BLAB, ("ParseDataByte: %X into:",aByte));
    DumpDMKEvt(pDMKEvt,DEBUGLVL_BLAB);
    if (RUNNING_STATUS(pDMKEvt))
    {
        _DbgPrintF(DEBUGLVL_BLAB, ("ParseDataByte: RunStat"));
        pDMKEvt->cbEvent = 0;
        ntStatus = ParseChanMsgByte(pDMKEvt->uData.abData[0],ppDMKEvt,refTime); //  parse the status correctly
        if (NT_SUCCESS(ntStatus))
        {
            return ParseDataByte(aByte,ppDMKEvt,refTime);                //  then parse the data
        }
        else
        {
            return ntStatus;
        }
    }
    else if (DATA2_STATE(pDMKEvt))
    {
        if (pDMKEvt->cbEvent > 2)
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("ParseDataByte: DATA2_STATE: Bad parse cbEvt > 2:"));
            DumpDMKEvt(pDMKEvt,DEBUGLVL_TERSE);
        }
        if (pDMKEvt->cbEvent == 0)
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("ParseDataByte: DATA2_STATE: Bad parse cbEvt 0:"));
            DumpDMKEvt(pDMKEvt,DEBUGLVL_TERSE);
        }
        if (pDMKEvt->uData.abData[0] < 0x80)
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("ParseDataByte: DATA2_STATE: Bad parse <80:"));
            DumpDMKEvt(pDMKEvt,DEBUGLVL_TERSE);
        }
        if (((pDMKEvt->uData.abData[0] & 0xc0) == 0x80) && (pDMKEvt->cbEvent != 2))
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("ParseDataByte: DATA2_STATE: Bad parse 8x 9x ax bx:"));
            DumpDMKEvt(pDMKEvt,DEBUGLVL_TERSE);
        }
        if ((pDMKEvt->uData.abData[0] > 0xbf) && (pDMKEvt->uData.abData[0] < 0xe0) && (pDMKEvt->cbEvent != 1))
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("ParseDataByte: DATA2_STATE: Bad parse cx dx:"));
            DumpDMKEvt(pDMKEvt,DEBUGLVL_TERSE);
        }
        if (((pDMKEvt->uData.abData[0] & 0xf0) == 0xe0) && (pDMKEvt->cbEvent != 2))
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("ParseDataByte: DATA2_STATE: Bad parse ex:"));
            DumpDMKEvt(pDMKEvt,DEBUGLVL_TERSE);
        }
        if (pDMKEvt->uData.abData[0] == 0xf0)
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("ParseDataByte: DATA2_STATE: Bad parse f0:"));
            DumpDMKEvt(pDMKEvt,DEBUGLVL_TERSE);
        }
        if ((pDMKEvt->uData.abData[0] == 0xf1) && (pDMKEvt->cbEvent != 1))
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("ParseDataByte: DATA2_STATE: Bad parse f1:"));
            DumpDMKEvt(pDMKEvt,DEBUGLVL_TERSE);
        }
        if ((pDMKEvt->uData.abData[0] == 0xf2) && (pDMKEvt->cbEvent != 2))
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("ParseDataByte: DATA2_STATE: Bad parse f2:"));
            DumpDMKEvt(pDMKEvt,DEBUGLVL_TERSE);
        }
        if ((pDMKEvt->uData.abData[0] == 0xf3) && (pDMKEvt->cbEvent != 1))
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("ParseDataByte: DATA2_STATE: Bad parse f3:"));
            DumpDMKEvt(pDMKEvt,DEBUGLVL_TERSE);
        }
        if (pDMKEvt->uData.abData[0] > 0xf3)
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("ParseDataByte: DATA2_STATE: Bad parse fx > f3:"));
            DumpDMKEvt(pDMKEvt,DEBUGLVL_TERSE);
        }

        pOtherDMKEvt = pDMKEvt->pNextEvt;
        *ppDMKEvt = pOtherDMKEvt;
        pDMKEvt->pNextEvt = NULL;
        AddByteToEvent(aByte,pDMKEvt);

        if (IS_CHANNEL_MSG(pDMKEvt->uData.abData[0]))   //  running status?
        {                                               //  set runStat in newEvt, cbEvent = 1
            _DbgPrintF(DEBUGLVL_BLAB, ("ParseDataByte: DATA2 with RunStat"));
            if (!pOtherDMKEvt)
            {
                _DbgPrintF(DEBUGLVL_BLAB, ("ParseDataByte: DATA2 with RunStat, allocating msg for RunStat"));
                (void) m_AllocatorMXF->GetMessage(&pOtherDMKEvt);
            }
            *ppDMKEvt = pOtherDMKEvt;
            if (pOtherDMKEvt)
            {
                _DbgPrintF(DEBUGLVL_BLAB, ("ParseDataByte: DATA2 with RunStat, setting up RunStat"));
                pOtherDMKEvt->cbEvent          = 1;
                pOtherDMKEvt->usChannelGroup   = pDMKEvt->usChannelGroup;
                pOtherDMKEvt->uData.abData[0]  = pDMKEvt->uData.abData[0];
            }
            else
            {
                _DbgPrintF(DEBUGLVL_TERSE, ("ParseDataByte: DATA2 with RunStat, out of mem, can't setup RunStat"));
            }
        }
        else
        {
            _DbgPrintF(DEBUGLVL_BLAB, ("ParseDataByte: DATA2 without RunStat"));
        }
        SET_STATUS_STATE(pDMKEvt);
        SET_COMPLETE_EVT(pDMKEvt);
        (void) m_SinkMXF->PutMessage(pDMKEvt);
        return STATUS_SUCCESS;
    }
    else if (DATA1_STATE(pDMKEvt))
    {
        if (pDMKEvt->cbEvent > 1)
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("ParseDataByte: DATA1_STATE: Bad parse cbEvt > 1:"));
            DumpDMKEvt(pDMKEvt,DEBUGLVL_TERSE);
        }
        else if (pDMKEvt->cbEvent == 0)
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("ParseDataByte: DATA1_STATE: Bad parse cbEvt 0:"));
            DumpDMKEvt(pDMKEvt,DEBUGLVL_TERSE);
        }
        else if (pDMKEvt->uData.abData[0] < 0x80)
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("ParseDataByte: DATA1_STATE: Bad parse <80:"));
            DumpDMKEvt(pDMKEvt,DEBUGLVL_TERSE);
        }
        else if ((pDMKEvt->uData.abData[0] > 0xbf) && (pDMKEvt->uData.abData[0] < 0xe0))
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("ParseDataByte: DATA1_STATE: Bad parse cx dx:"));
            DumpDMKEvt(pDMKEvt,DEBUGLVL_TERSE);
        }
        else if ((pDMKEvt->uData.abData[0] > 0xef) && (pDMKEvt->uData.abData[0] < 0xf2))
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("ParseDataByte: DATA1_STATE: Bad parse f0-f1:"));
            DumpDMKEvt(pDMKEvt,DEBUGLVL_TERSE);
        }
        else if (pDMKEvt->uData.abData[0] > 0xf2)
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("ParseDataByte: DATA1_STATE: Bad parse >f2:"));
            DumpDMKEvt(pDMKEvt,DEBUGLVL_TERSE);
        }

        _DbgPrintF(DEBUGLVL_BLAB, ("ParseDataByte: DATA1"));
        AddByteToEvent(aByte,pDMKEvt);
        SET_DATA2_STATE(pDMKEvt);
    }
    else if (SYSEX_STATE(pDMKEvt))
    {
        _DbgPrintF(DEBUGLVL_BLAB, ("ParseDataByte: SYSEX"));
        AddByteToEvent(aByte,pDMKEvt);
    }
    else if (STATUS_STATE(pDMKEvt))  //  data without status, flush it 
    {
        _DbgPrintF(DEBUGLVL_BLAB, ("ParseDataByte: STATUS"));
        pDMKEvt->ullPresTime100ns = refTime;
        AddByteToEvent(aByte,pDMKEvt);
        SET_DATA2_STATE(pDMKEvt);   //  mark data dis-continuity
        SET_INCOMPLETE_EVT(pDMKEvt);
        *ppDMKEvt = pDMKEvt->pNextEvt;
        pDMKEvt->pNextEvt = NULL;
        (void) m_SinkMXF->PutMessage(pDMKEvt);
    }
    return STATUS_SUCCESS;
}

#pragma code_seg()
/*****************************************************************************
 * CCaptureSinkMXF::ParseChanMsgByte()
 *****************************************************************************
 * Parse a Channel Message Status byte into a fragment.  
 * Forward the fragment as an incomplete message if necessary.
 */
NTSTATUS CCaptureSinkMXF::ParseChanMsgByte(BYTE aByte,PDMUS_KERNEL_EVENT *ppDMKEvt,REFERENCE_TIME refTime)
{
    PDMUS_KERNEL_EVENT  pDMKEvt;

    pDMKEvt = *ppDMKEvt;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    ASSERT(aByte > 0x7f);
    ASSERT(aByte < 0xf0);
    _DbgPrintF(DEBUGLVL_BLAB, ("ParseChanMsgByte: %X into:",aByte));
    DumpDMKEvt(pDMKEvt,DEBUGLVL_BLAB);

    if (STATUS_STATE(pDMKEvt))
    {
        _DbgPrintF(DEBUGLVL_BLAB, ("ParseChanMsgByte: STATUS"));
        if (RUNNING_STATUS(pDMKEvt))
        {
            _DbgPrintF(DEBUGLVL_BLAB, ("ParseChanMsgByte: STATUS, RunStat"));
        }
        pDMKEvt->cbEvent = 1;
        pDMKEvt->ullPresTime100ns = refTime;
        pDMKEvt->uData.abData[0] = aByte;
        if (aByte < 0xc0)
        {
            _DbgPrintF(DEBUGLVL_BLAB, ("ParseChanMsgByte: STATUS, 80-bf"));
            SET_DATA1_STATE(pDMKEvt);
        }
        else if (aByte < 0xe0)
        {
            _DbgPrintF(DEBUGLVL_BLAB, ("ParseChanMsgByte: STATUS, c0-df"));
            SET_DATA2_STATE(pDMKEvt);
        }
        else
        {
            _DbgPrintF(DEBUGLVL_BLAB, ("ParseChanMsgByte: STATUS, e0-ef"));
            SET_DATA1_STATE(pDMKEvt);
        }
        _DbgPrintF(DEBUGLVL_BLAB, ("ParseChanMsgByte: After adding the byte:"));
        DumpDMKEvt(pDMKEvt,DEBUGLVL_BLAB);
        return STATUS_SUCCESS;
    }
    _DbgPrintF(DEBUGLVL_BLAB, ("ParseChanMsgByte: flush"));
    SET_STATUS_STATE(pDMKEvt);
    SET_INCOMPLETE_EVT(pDMKEvt);
    *ppDMKEvt = pDMKEvt->pNextEvt;
    pDMKEvt->pNextEvt = NULL;
    if (!(*ppDMKEvt))
    {
        _DbgPrintF(DEBUGLVL_BLAB, ("ParseChanMsgByte: flush, allocating msg for ChanMsg"));
        (void)m_AllocatorMXF->GetMessage(ppDMKEvt);
    }
#if TestOutOfMem1
    (void)m_AllocatorMXF->PutMessage(*ppDMKEvt);
    *ppDMKEvt = NULL; 
#endif
    SET_DATA2_STATE(pDMKEvt);       //  mark this as a data discontinuity
    if (*ppDMKEvt)
    {
        (*ppDMKEvt)->usChannelGroup = pDMKEvt->usChannelGroup;
        m_SinkMXF->PutMessage(pDMKEvt);
        _DbgPrintF(DEBUGLVL_BLAB, ("ParseChanMsgByte: flush, storing chan msg byte in new msg"));
        return (ParseChanMsgByte(aByte,ppDMKEvt,refTime));
    }
    m_SinkMXF->PutMessage(pDMKEvt);
    _DbgPrintF(DEBUGLVL_TERSE, ("ParseChanMsgByte: flush, couldn't allocate msg for chan msg byte"));
    return STATUS_INSUFFICIENT_RESOURCES;  //  out of memory.
}

#pragma code_seg()
/*****************************************************************************
 * CCaptureSinkMXF::ParseSysExByte()
 *****************************************************************************
 * Parse a SysEx Start byte into a fragment.  
 * Forward the fragment as an incomplete message if necessary.
 */
NTSTATUS CCaptureSinkMXF::ParseSysExByte(BYTE aByte,PDMUS_KERNEL_EVENT *ppDMKEvt,REFERENCE_TIME refTime)
{
    NTSTATUS            ntStatus;
    PDMUS_KERNEL_EVENT  pDMKEvt,pOtherDMKEvt;

    ntStatus = STATUS_SUCCESS;
    pDMKEvt = *ppDMKEvt;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    _DbgPrintF(DEBUGLVL_BLAB, ("ParseSysExByte: %X into:",aByte));
    DumpDMKEvt(pDMKEvt,DEBUGLVL_BLAB);

    if (STATUS_STATE(pDMKEvt))  //  nuke running status
    {
        _DbgPrintF(DEBUGLVL_BLAB, ("ParseSysExByte: STATUS"));
        pDMKEvt->cbEvent = 1;
        pDMKEvt->ullPresTime100ns = refTime;
        pDMKEvt->uData.abData[0] = aByte;
        SET_SYSEX_STATE(pDMKEvt);
    }
    else    //  must flush what we have as a fragment
    {
        _DbgPrintF(DEBUGLVL_BLAB, ("ParseSysExByte: flush"));
        pOtherDMKEvt = pDMKEvt->pNextEvt;
        pDMKEvt->pNextEvt = NULL;
        if (!pOtherDMKEvt)
        {
            _DbgPrintF(DEBUGLVL_BLAB, ("ParseSysExByte: flush, allocating msg for SysEx"));
            (void) m_AllocatorMXF->GetMessage(&pOtherDMKEvt);
        }
#if TestOutOfMem2
        (void)m_AllocatorMXF->PutMessage(pOtherDMKEvt);
        pOtherDMKEvt = NULL; 
#endif
        *ppDMKEvt = pOtherDMKEvt;
        if (pOtherDMKEvt)
        {
            _DbgPrintF(DEBUGLVL_BLAB, ("ParseSysExByte, flush, forwarding fragment, saving F0"));
            pOtherDMKEvt->usChannelGroup   = pDMKEvt->usChannelGroup; 
            pOtherDMKEvt->ullPresTime100ns = refTime; 
            SET_INCOMPLETE_EVT(pOtherDMKEvt);
            AddByteToEvent(aByte,pOtherDMKEvt);
            SET_SYSEX_STATE(pOtherDMKEvt);
        }
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("ParseSysExByte, flush, can't save F0"));
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
        SET_INCOMPLETE_EVT(pDMKEvt);
        SET_DATA2_STATE(pDMKEvt);       //  mark this as a data discontinuity
        (void) m_SinkMXF->PutMessage(pDMKEvt);
    }
    return ntStatus;
}

#pragma code_seg()
/*****************************************************************************
 * CCaptureSinkMXF::ParseSysCommonByte()
 *****************************************************************************
 * Parse a System Common byte into a fragment.  
 * Forward the fragment as an incomplete message if necessary.
 */
NTSTATUS CCaptureSinkMXF::ParseSysCommonByte(BYTE aByte,PDMUS_KERNEL_EVENT *ppDMKEvt,REFERENCE_TIME refTime)
{
    PDMUS_KERNEL_EVENT  pDMKEvt;

    pDMKEvt = *ppDMKEvt;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    ASSERT(aByte > 0xef);
    ASSERT(aByte < 0xf8);
    ASSERT(aByte != 0xf0);
    ASSERT(aByte != 0xf7);
    _DbgPrintF(DEBUGLVL_BLAB, ("ParseSysCommonByte: %X into:",aByte));
    DumpDMKEvt(pDMKEvt,DEBUGLVL_BLAB);

    if (STATUS_STATE(pDMKEvt))
    {
        _DbgPrintF(DEBUGLVL_BLAB, ("ParseSysCommonByte: STATUS"));
        if (RUNNING_STATUS(pDMKEvt))
        {
            _DbgPrintF(DEBUGLVL_BLAB, ("ParseSysCommonByte: STATUS, RunStat"));
        }
        pDMKEvt->cbEvent = 1;
        pDMKEvt->ullPresTime100ns = refTime;
        pDMKEvt->uData.abData[0] = aByte;
        if (aByte == 0xf1)
        {
            _DbgPrintF(DEBUGLVL_BLAB, ("ParseSysCommonByte: STATUS, f1"));
            SET_DATA2_STATE(pDMKEvt);
        }
        else if (aByte == 0xf2)
        {
            _DbgPrintF(DEBUGLVL_BLAB, ("ParseSysCommonByte: STATUS, f2"));
            SET_DATA1_STATE(pDMKEvt);
        }
        else if (aByte == 0xf3)
        {
            _DbgPrintF(DEBUGLVL_BLAB, ("ParseSysCommonByte: STATUS, f3"));
            SET_DATA2_STATE(pDMKEvt);
        }
        else 
        {
            if (aByte == 0xf6)
            {
                _DbgPrintF(DEBUGLVL_BLAB, ("ParseSysCommonByte: STATUS, f6"));
                SET_COMPLETE_EVT(pDMKEvt);
                SET_STATUS_STATE(pDMKEvt);
            }
            else // f4, f5
            {
                _DbgPrintF(DEBUGLVL_BLAB, ("ParseSysCommonByte: STATUS, f4-f5"));
                SET_INCOMPLETE_EVT(pDMKEvt);
                SET_DATA2_STATE(pDMKEvt);       //  mark this as a data discontinuity
            }
            *ppDMKEvt = pDMKEvt->pNextEvt;
            pDMKEvt->pNextEvt = NULL;
            m_SinkMXF->PutMessage(pDMKEvt);
            return STATUS_SUCCESS;
        }
        _DbgPrintF(DEBUGLVL_BLAB, ("ParseSysCommonByte: Added the byte:"));
        DumpDMKEvt(pDMKEvt,DEBUGLVL_BLAB);
        return STATUS_SUCCESS;
    }
    SET_STATUS_STATE(pDMKEvt);
    SET_INCOMPLETE_EVT(pDMKEvt);
    *ppDMKEvt = pDMKEvt->pNextEvt;
    pDMKEvt->pNextEvt = NULL;
    if (!(*ppDMKEvt))
    {
        _DbgPrintF(DEBUGLVL_BLAB, ("ParseSysCommonByte: flush, allocating msg for sys com byte")); //  XXX
        (void)m_AllocatorMXF->GetMessage(ppDMKEvt);
    }
#if TestOutOfMem3
    (void)m_AllocatorMXF->PutMessage(*ppDMKEvt);
    *ppDMKEvt = NULL;
#endif
    SET_DATA2_STATE(pDMKEvt);       //  mark data mis-parse
    if (*ppDMKEvt)
    {
        _DbgPrintF(DEBUGLVL_BLAB, ("ParseSysCommonByte: flush, putting sys com byte in new message"));
        (*ppDMKEvt)->usChannelGroup = pDMKEvt->usChannelGroup;
        m_SinkMXF->PutMessage(pDMKEvt);

        SET_STATUS_STATE((*ppDMKEvt));
        return (ParseSysCommonByte(aByte,ppDMKEvt,refTime));
    }
    _DbgPrintF(DEBUGLVL_TERSE, ("ParseSysCommonByte: flush, couldn't allocate msg for sys com byte"));
    m_SinkMXF->PutMessage(pDMKEvt);
    return STATUS_INSUFFICIENT_RESOURCES;  //  out of memory.
}

#pragma code_seg()
/*****************************************************************************
 * CCaptureSinkMXF::ParseEOXByte()
 *****************************************************************************
 * Parse an EOX byte into a fragment.  Forward a completed message if necessary.
 */
NTSTATUS CCaptureSinkMXF::ParseEOXByte(BYTE aByte,PDMUS_KERNEL_EVENT *ppDMKEvt,REFERENCE_TIME refTime)
{
    PDMUS_KERNEL_EVENT  pDMKEvt;

    pDMKEvt = *ppDMKEvt;

    _DbgPrintF(DEBUGLVL_BLAB, ("ParseEOXByte: %X into:",aByte));
    DumpDMKEvt(pDMKEvt,DEBUGLVL_BLAB);

    if (SYSEX_STATE(pDMKEvt))
    {
        _DbgPrintF(DEBUGLVL_BLAB, ("ParseEOXByte: SYSEX"));
        AddByteToEvent(aByte,pDMKEvt);
        SET_STATUS_STATE(pDMKEvt);
        SET_COMPLETE_EVT(pDMKEvt);
    }
    else
    {   //  flush this fragment as incomplete (including the EOX)
        _DbgPrintF(DEBUGLVL_BLAB, ("ParseEOXByte: flush"));
        AddByteToEvent(aByte,pDMKEvt);
        SET_DATA2_STATE(pDMKEvt);       //  mark data mis-parse
        SET_INCOMPLETE_EVT(pDMKEvt);
    }

    //  don't set up running status, return no fragment
    *ppDMKEvt = pDMKEvt->pNextEvt;
    pDMKEvt->pNextEvt = NULL;
    (void) m_SinkMXF->PutMessage(pDMKEvt);

    return STATUS_SUCCESS;
}

#pragma code_seg()
/*****************************************************************************
 * CCaptureSinkMXF::ParseRTByte()
 *****************************************************************************
 * Parse a RT byte.  Forward it as a completed message.
 */
NTSTATUS CCaptureSinkMXF::ParseRTByte(BYTE aByte,PDMUS_KERNEL_EVENT *ppDMKEvt,REFERENCE_TIME refTime)
{
    PDMUS_KERNEL_EVENT  pDMKEvt,pOtherDMKEvt;

    pDMKEvt = *ppDMKEvt;

    _DbgPrintF(DEBUGLVL_BLAB, ("ParseRTByte: %X into:",aByte));
    DumpDMKEvt(pDMKEvt,DEBUGLVL_BLAB);

    //  get a new event, copy in the byte, chanGroup, refTime, cb
    pOtherDMKEvt = pDMKEvt->pNextEvt;
    pDMKEvt->pNextEvt = NULL;
    if (!pOtherDMKEvt)
    {
        _DbgPrintF(DEBUGLVL_BLAB, ("ParseRTByte: allocating msg for RT byte"));
        (void) m_AllocatorMXF->GetMessage(&pOtherDMKEvt);
    }
    if (pOtherDMKEvt)
    {
        _DbgPrintF(DEBUGLVL_BLAB, ("ParseRTByte: putting RT byte into msg"));
        pOtherDMKEvt->cbEvent          = 1;
        pOtherDMKEvt->usChannelGroup   = pDMKEvt->usChannelGroup;
        pOtherDMKEvt->usFlags          = 0;
        pOtherDMKEvt->ullPresTime100ns = refTime;
        pOtherDMKEvt->pNextEvt         = NULL;
        pOtherDMKEvt->uData.abData[0]  = aByte;

        SET_COMPLETE_EVT(pOtherDMKEvt);
        (void) m_SinkMXF->PutMessage(pOtherDMKEvt);
        //  don't bother the fragment already in place
        return STATUS_SUCCESS;
    }
    else
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("ParseRTByte: can't get msg for RT byte"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }
}

#pragma code_seg()
/*****************************************************************************
 * CCaptureSinkMXF::InsertListEvent()
 *****************************************************************************
 * For the given channel group, insert this fragment.
 * This should fail if there is already a fragment for this channel group.
 */
VOID CCaptureSinkMXF::InsertListEvent(PDMUS_KERNEL_EVENT pDMKEvt)
{
    PDMUS_KERNEL_EVENT pEvt,pPrevEvt;
    
    _DbgPrintF(DEBUGLVL_BLAB, ("InsertListEvent, inserting this event:"));
    DumpDMKEvt(pDMKEvt,DEBUGLVL_BLAB);

    //
    //  run through the list and find events on both sides of this channel group
    //
    pPrevEvt = NULL;
    pEvt = m_ParseList;

    if (!pEvt)
    {
        _DbgPrintF(DEBUGLVL_BLAB, ("InsertListEvent: NULL m_ParseList"));
    }

    while (pEvt)
    {
        _DbgPrintF(DEBUGLVL_BLAB, ("InsertListEvent: pEvt is non-NULL"));
        DumpDMKEvt(pEvt,DEBUGLVL_BLAB);
        //  not there yet -- skip the lower groups
        if (pEvt->usChannelGroup < pDMKEvt->usChannelGroup)
        {
            _DbgPrintF(DEBUGLVL_BLAB, ("InsertListEvent: list group %d is less than inserting %d, advancing to next group",
                                         pEvt->usChannelGroup,pDMKEvt->usChannelGroup));
            pPrevEvt = pEvt;
            pEvt = pEvt->pNextEvt;
        }
        else
        {
            _DbgPrintF(DEBUGLVL_BLAB, ("InsertListEvent: list group %d is not less than inserting %d, stopping here",
                                         pEvt->usChannelGroup,pDMKEvt->usChannelGroup));
            if (pEvt->usChannelGroup == pDMKEvt->usChannelGroup)
            {
                // Found a duplicate.  Error condition.
                _DbgPrintF(DEBUGLVL_TERSE,("InsertListEvent: **** Error - group %d already exists in list",
                                            pEvt->usChannelGroup));
            }

            //  we passed it, so Prev and Evt bracket the channel group
            break;
        }
    }

    if (pPrevEvt)
    {
        pPrevEvt->pNextEvt = pDMKEvt;
        _DbgPrintF(DEBUGLVL_BLAB, ("InsertListEvent, inserting after event:"));
        DumpDMKEvt(pPrevEvt,DEBUGLVL_BLAB);
    }
    else
    {
        m_ParseList = pDMKEvt;
        _DbgPrintF(DEBUGLVL_BLAB, ("InsertListEvent, inserting at head of list"));
    }
    _DbgPrintF(DEBUGLVL_BLAB, ("InsertListEvent, inserting before event:"));
    DumpDMKEvt(pEvt,DEBUGLVL_BLAB);
    pDMKEvt->pNextEvt = pEvt;
}

#pragma code_seg()
/*****************************************************************************
 * CCaptureSinkMXF::RemoveListEvent()
 *****************************************************************************
 * For the given channel group, remove and return the previous fragment.
 */
PDMUS_KERNEL_EVENT CCaptureSinkMXF::RemoveListEvent(USHORT usChannelGroup)
{
    PDMUS_KERNEL_EVENT pEvt,pPrevEvt;
    
    _DbgPrintF(DEBUGLVL_BLAB, ("RemoveListEvent(%d)",usChannelGroup));
    
    //
    //  run through the sorted list and remove/return the event that has this channel group
    //
    pPrevEvt = NULL;
    pEvt = m_ParseList;

    // if no parse list at all, return NULL
    if (!pEvt)
    {
        _DbgPrintF(DEBUGLVL_BLAB, ("RemoveListEvent: NULL m_ParseList"));
    }

    while (pEvt)
    {
        _DbgPrintF(DEBUGLVL_BLAB, ("RemoveListEvent: pEvt is non-NULL:"));
        DumpDMKEvt(pEvt,DEBUGLVL_BLAB);
        //  do we have a match?
        if (pEvt->usChannelGroup == usChannelGroup)
        {
            _DbgPrintF(DEBUGLVL_BLAB, ("RemoveListEvent: list group %d is matches",pEvt->usChannelGroup));
            if (pPrevEvt)
            {
                _DbgPrintF(DEBUGLVL_BLAB, ("RemoveListEvent: pPrevEvt is non-NULL:"));
                DumpDMKEvt(pPrevEvt,DEBUGLVL_BLAB);
                pPrevEvt->pNextEvt = pEvt->pNextEvt;
            }
            else
            {
                _DbgPrintF(DEBUGLVL_BLAB, ("RemoveListEvent: pPrevEvt is NULL, setting m_ParseList to:"));
                DumpDMKEvt(pPrevEvt,DEBUGLVL_BLAB);
                m_ParseList = pEvt->pNextEvt;
            }
            //  clear pNextEvt in the event before returning it
            pEvt->pNextEvt = NULL;
            break;
        }

        //  skip all lower channel groups
        else if (pEvt->usChannelGroup < usChannelGroup)
        {
            _DbgPrintF(DEBUGLVL_BLAB, ("RemoveListEvent: list group %d is less than inserting %d, advancing to next",
                                         pEvt->usChannelGroup,usChannelGroup));
            pPrevEvt = pEvt;
            pEvt = pEvt->pNextEvt;
            continue;
        }
        else    //  we passed the channel group without finding a match
        {
            _DbgPrintF(DEBUGLVL_BLAB, ("RemoveListEvent: list group %d is greater than inserting %d, advancing to next group",
                                         pEvt->usChannelGroup,usChannelGroup));
            pEvt = NULL;
        }
    }
    _DbgPrintF(DEBUGLVL_BLAB, ("RemoveListEvent: returning the following event:"));
    DumpDMKEvt(pEvt,DEBUGLVL_BLAB);
    return pEvt;
}

#pragma code_seg()
/*****************************************************************************
 * CCaptureSinkMXF::Flush()
 *****************************************************************************
 * Empty out the parse list, marking each message fragment as incomplete.
 * Take care not to send a running status placeholder.  Reset state.
 */
NTSTATUS CCaptureSinkMXF::Flush(void)
{
//    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    PDMUS_KERNEL_EVENT pEvt;

    while (m_ParseList)
    {
        pEvt = m_ParseList;
        m_ParseList = pEvt->pNextEvt;
        pEvt->pNextEvt = NULL;

        if (RUNNING_STATUS(pEvt))
        {   //  throw away this message, no real content
            _DbgPrintF(DEBUGLVL_VERBOSE, ("Flush: throwing away running status:"));
            DumpDMKEvt(pEvt,DEBUGLVL_VERBOSE);
            m_AllocatorMXF->PutMessage(pEvt);
        }
        else
        {
            _DbgPrintF(DEBUGLVL_VERBOSE, ("Flush: fragment set INCOMPLETE and forwarded"));
            SET_INCOMPLETE_EVT(pEvt);   //  mark this as a fragment
            SET_DATA2_STATE(pEvt);      //  mark this as a data discontinuity
            DumpDMKEvt(pEvt,DEBUGLVL_VERBOSE);
            m_SinkMXF->PutMessage(pEvt);
        }
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\ports\dmus\captsink.h ===
/*  
    MIDI Transform Filter object for parsing the capture stream

    Copyright (c) 1998-2000 Microsoft Corporation.  All rights reserved.

    12/10/98    Martin Puryear      Created this file

*/

#ifndef __CaptureSinkMXF_H__
#define __CaptureSinkMXF_H__

#include "MXF.h"
#include "Allocatr.h"




BYTE FindLastStatusByte(PDMUS_KERNEL_EVENT pDMKEvt);

class CCaptureSinkMXF 
:   public CMXF,
    public IMXF,
    public CUnknown
{
public:
    //  must provide a default sink
    CCaptureSinkMXF(CAllocatorMXF *allocatorMXF,PMASTERCLOCK clock);
    ~CCaptureSinkMXF(void);

    DECLARE_STD_UNKNOWN();
    IMP_IMXF;

    NTSTATUS SinkOneEvent(PDMUS_KERNEL_EVENT pDMKEvt);
    NTSTATUS Flush(void);
    NTSTATUS ParseFragment(PDMUS_KERNEL_EVENT pDMKEvt);
    NTSTATUS ParseOneByte(BYTE aByte,PDMUS_KERNEL_EVENT *ppDMKEvt,REFERENCE_TIME refTime);
    NTSTATUS AddByteToEvent(BYTE aByte,PDMUS_KERNEL_EVENT pDMKEvt);

    NTSTATUS ParseDataByte(BYTE aByte,PDMUS_KERNEL_EVENT *ppDMKEvt,REFERENCE_TIME refTime);
    NTSTATUS ParseChanMsgByte(BYTE aByte,PDMUS_KERNEL_EVENT *ppDMKEvt,REFERENCE_TIME refTime);
    NTSTATUS ParseSysExByte(BYTE aByte,PDMUS_KERNEL_EVENT *ppDMKEvt,REFERENCE_TIME refTime);
    NTSTATUS ParseSysCommonByte(BYTE aByte,PDMUS_KERNEL_EVENT *ppDMKEvt,REFERENCE_TIME refTime);
    NTSTATUS ParseEOXByte(BYTE aByte,PDMUS_KERNEL_EVENT *ppDMKEvt,REFERENCE_TIME refTime);
    NTSTATUS ParseRTByte(BYTE aByte,PDMUS_KERNEL_EVENT *ppDMKEvt,REFERENCE_TIME refTime);
    
    VOID               InsertListEvent(PDMUS_KERNEL_EVENT pDMKEvt);
    PDMUS_KERNEL_EVENT RemoveListEvent(USHORT usChannelGroup);
    NTSTATUS           FlushParseList(void);


protected:
    PMXF                m_SinkMXF;
    PMASTERCLOCK        m_Clock;
    KSSTATE             m_State;
    PDMUS_KERNEL_EVENT  m_ParseList;
};

#endif  //  __CaptureSinkMXF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\ports\dmus\feedout.h ===
/*  
    MIDI Transform Filter object to translate DMusic<-->legacy
    
    Copyright (c) 1999-2000 Microsoft Corporation.  All rights reserved.

    This enables IPortDMus to send to IMiniportMidi.

    2/15/99    Martin Puryear      Created this file

*/

#ifndef __FeederOutMXF_H__
#define __FeederOutMXF_H__

#include "MXF.h"
#include "Allocatr.h"


VOID NTAPI DMusFeederOutDPC(PKDPC Dpc,PVOID DeferredContext,PVOID SystemArgument1,PVOID SystemArgument2);

class CFeederOutMXF 
:   public CMXF,
    public IMXF,
    public CUnknown
{
public:
    CFeederOutMXF(CAllocatorMXF *allocatorMXF,PMASTERCLOCK clock);
    ~CFeederOutMXF(void);

    DECLARE_STD_UNKNOWN();
    IMP_IMXF;

    NTSTATUS    SetMiniportStream(PMINIPORTMIDISTREAM MiniportStream);
    NTSTATUS    ConsumeEvents(void);

private:
    NTSTATUS    SyncPutMessage(PDMUS_KERNEL_EVENT pDMKEvt);

private:
    KDPC                m_Dpc;
    KTIMER              m_TimerEvent;
    PMINIPORTMIDISTREAM m_MiniportStream;
    PMXF                m_SinkMXF;
    PMASTERCLOCK        m_Clock;
    KSSTATE             m_State;
    PDMUS_KERNEL_EVENT  m_DMKEvtQueue;
    BOOL                m_TimerQueued;
    ULONG               m_DMKEvtOffset;
    KSPIN_LOCK          m_EvtQSpinLock;    
};

#endif  //  __FeederOutMXF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\ports\dmus\feedin.h ===
/*  
    MIDI Transform Filter object to translate legacy<-->DMusic
    
    This enables IMiniportMidi to capture IPortDMus.

    Copyright (c) 1999-2000 Microsoft Corporation.  All rights reserved.

    2/15/99    Martin Puryear      Created this file

*/

#ifndef __FeederInMXF_H__
#define __FeederInMXF_H__

#include "MXF.h"
#include "Allocatr.h"


class CFeederInMXF 
:   public CMXF,
    public IMXF,
    public CUnknown
{
public:
    CFeederInMXF(CAllocatorMXF *allocatorMXF,PMASTERCLOCK clock);
    ~CFeederInMXF(void);

    DECLARE_STD_UNKNOWN();
    IMP_IMXF;

    NTSTATUS    SetMiniportStream(PMINIPORTMIDISTREAM MiniportStream);

protected:
    PAllocatorMXF       m_AllocatorMXF;         
    PMXF                m_SinkMXF;
    PMASTERCLOCK        m_Clock;
    KSSTATE             m_State;

    PMINIPORTMIDISTREAM m_MiniportStream;
};

#endif  //  __FeederInMXF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\ports\dmus\feedin.cpp ===
/*  
    MIDI Transform Filter object for translating an IMiniportMidi
    input stream to a DirectMusic port.

    Copyright (c) 1999-2000 Microsoft Corporation.  All rights reserved.

    02/15/99    Martin Puryear      Created this file

*/

#define STR_MODULENAME "DMus:FeederInMXF: "
#include "private.h"
#include "FeedIn.h"

#pragma code_seg("PAGE")
/*****************************************************************************
 * CFeederInMXF::CFeederInMXF()
 *****************************************************************************
 * Constructor.  An allocator and a clock must be provided.
 */
CFeederInMXF::CFeederInMXF(CAllocatorMXF *AllocatorMXF,
                                 PMASTERCLOCK Clock)
:   CUnknown(NULL),
    CMXF(AllocatorMXF),
    m_MiniportStream(NULL)
{
    PAGED_CODE();
    
    ASSERT(AllocatorMXF);
    ASSERT(Clock);
    
    _DbgPrintF(DEBUGLVL_BLAB, ("Constructor"));
    m_SinkMXF = AllocatorMXF;
    m_AllocatorMXF = AllocatorMXF;
    m_Clock = Clock;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CFeederInMXF::~CFeederInMXF()
 *****************************************************************************
 * Destructor.  Artfully remove this filter from the chain before freeing.
 */
CFeederInMXF::~CFeederInMXF(void)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB, ("Destructor"));
    (void) DisconnectOutput(m_SinkMXF);
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CFeederInMXF::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.
 */
STDMETHODIMP_(NTSTATUS)
CFeederInMXF::
NonDelegatingQueryInterface
(
    REFIID  Interface,
    PVOID * Object
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB, ("NonDelegatingQueryInterface"));
    ASSERT(Object);
    if (!Object)
    {
        return STATUS_INVALID_PARAMETER_2;
    }

    if (IsEqualGUIDAligned(Interface,IID_IUnknown))
    {
        *Object = PVOID(PMXF(this));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IMXF))
    {
        *Object = PVOID(PMXF(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER_1;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CFeederInMXF::SetState()
 *****************************************************************************
 * Set the state of the filter.
 */
NTSTATUS 
CFeederInMXF::SetState(KSSTATE State)    
{   
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB, ("SetState %d",State));
    
    NTSTATUS ntStatus = STATUS_INVALID_PARAMETER;

    if (m_MiniportStream)
    {
        ntStatus = m_MiniportStream->SetState(State);
        if (NT_SUCCESS(ntStatus))
        {
            m_State = State;
        }
    }

    return ntStatus;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CFeederInMXF::SetMiniportStream()
 *****************************************************************************
 * Set the destination MiniportStream of the filter.
 */
NTSTATUS CFeederInMXF::SetMiniportStream(PMINIPORTMIDISTREAM MiniportStream)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB, ("SetMiniportStream %p",MiniportStream));
    
    if (MiniportStream)
    {
        m_MiniportStream = MiniportStream;
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CFeederInMXF::ConnectOutput()
 *****************************************************************************
 * Create a forwarding address for this filter, 
 * instead of shunting it to the allocator.
 */
NTSTATUS CFeederInMXF::ConnectOutput(PMXF sinkMXF)
{
    PAGED_CODE();

    if ((sinkMXF) && (m_SinkMXF == m_AllocatorMXF)) 
    {
        _DbgPrintF(DEBUGLVL_BLAB, ("ConnectOutput"));
        m_SinkMXF = sinkMXF;
        return STATUS_SUCCESS;
    }
    _DbgPrintF(DEBUGLVL_TERSE, ("ConnectOutput failed"));
    return STATUS_UNSUCCESSFUL;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CFeederInMXF::DisconnectOutput()
 *****************************************************************************
 * Remove the forwarding address for this filter.
 * This filter should now forward all messages to the allocator.
 */
NTSTATUS CFeederInMXF::DisconnectOutput(PMXF sinkMXF)
{
    PAGED_CODE();

    if ((m_SinkMXF == sinkMXF) || (!sinkMXF))
    {
        _DbgPrintF(DEBUGLVL_BLAB, ("DisconnectOutput"));
        m_SinkMXF = m_AllocatorMXF;
        return STATUS_SUCCESS;
    }
    _DbgPrintF(DEBUGLVL_TERSE, ("DisconnectOutput failed"));
    return STATUS_UNSUCCESSFUL;
}

#pragma code_seg()
/*****************************************************************************
 * CFeederInMXF::PutMessage()
 *****************************************************************************
 * Receive a message.
 * Legacy miniport should never call this.
 * Spinlock is owned by ServeCapture.
 */
NTSTATUS CFeederInMXF::PutMessage(PDMUS_KERNEL_EVENT pDMKEvt)
{
    BYTE                aMidiData[sizeof(PBYTE)];
    ULONG               bytesRead;
    PDMUS_KERNEL_EVENT  aDMKEvt = NULL,eventTail,eventHead = NULL;
    BOOL                fExitLoop = FALSE;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    ASSERT(m_MiniportStream);

    while (!fExitLoop)           //  get any new raw data
    {
        if (NT_SUCCESS(m_MiniportStream->Read(aMidiData,sizeof(PBYTE),&bytesRead)))
        {
            if (!bytesRead)
            {
                break;
            }
        }

        if (m_State == KSSTATE_RUN)   //  if not RUN, don't fill IRP
        {
            (void) m_AllocatorMXF->GetMessage(&aDMKEvt);
            if (!aDMKEvt)
            {
                m_AllocatorMXF->PutMessage(eventHead);  // Free events.
                _DbgPrintF(DEBUGLVL_TERSE, ("FeederInMXF cannot allocate memory"));
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            //  put this event at the end of the list
            //
            if (!eventHead)
            {
                eventHead = aDMKEvt;
            }
            else
            {
                eventTail = eventHead;
                while (eventTail->pNextEvt)
                {
                    eventTail = eventTail->pNextEvt;
                }
                eventTail->pNextEvt = aDMKEvt;
            }

            // Fill in the remaining fields of DMUS_KERNEL_EVENT
            //
            RtlCopyMemory(aDMKEvt->uData.abData, aMidiData, sizeof(PBYTE));
            aDMKEvt->cbEvent = (USHORT) bytesRead;
            aDMKEvt->ullPresTime100ns = DMusicDefaultGetTime(); 
            aDMKEvt->usChannelGroup = 1;
            aDMKEvt->usFlags = DMUS_KEF_EVENT_INCOMPLETE;
        }
        // If the miniport returns an error from Read and we are not
        // KSSTATE_RUN, this routine will loop forever in DISPATCH_LEVEL.
        //
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("Received a UART interrupt while the stream is not running"));
            break;
        }
    }   

    (void)m_SinkMXF->PutMessage(eventHead);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\ports\dmus\filter.cpp ===
/*****************************************************************************
 * filter.cpp - DirectMusic port filter implementation
 *****************************************************************************
 * Copyright (c) 1997-2000 Microsoft Corporation.  All rights reserved.
 *
 *      6/3/98  MartinP
 */

#include "private.h"

#define STR_MODULENAME "DMus:Filter: "

static
NTSTATUS
PropertyHandler_MasterClock
(
    IN      PIRP        Irp,
    IN      PKSPROPERTY Property,
    IN OUT  PVOID       Data
);

/*****************************************************************************
 * Constants
 */

#pragma code_seg("PAGE")
/*****************************************************************************
 * PropertyTable_Pin
 *****************************************************************************
 * List of pin properties supported by the property handler.
 */
DEFINE_KSPROPERTY_TABLE(PropertyTable_Pin) 
{
    DEFINE_KSPROPERTY_ITEM_PIN_CINSTANCES(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_CTYPES(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_DATAFLOW(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_DATARANGES(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_DATAINTERSECTION(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_INTERFACES(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_MEDIUMS(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_COMMUNICATION(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_GLOBALCINSTANCES(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_NECESSARYINSTANCES(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_PHYSICALCONNECTION(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_CATEGORY(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_NAME(PropertyHandler_Pin)
};

/*****************************************************************************
 * PropertyTable_Topology
 *****************************************************************************
 * List of topology properties supported by the property handler.
 */
DEFINE_KSPROPERTY_TOPOLOGYSET
(
    PropertyTable_Topology,
    PropertyHandler_Topology
);

/*****************************************************************************
 * PropertyTable_MasterClock
 *****************************************************************************
 * List of clock properties supported by the property handler.
 */
DEFINE_KSPROPERTY_TABLE(PropertyTable_MasterClock)
{
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_SYNTH_MASTERCLOCK, 
        PropertyHandler_MasterClock,
        sizeof(KSPROPERTY),
        sizeof(ULONGLONG),
        NULL,
        NULL, 0, NULL, NULL, 0)
};

/*****************************************************************************
 * PropertyTable_FilterDMus
 *****************************************************************************
 * Table of properties supported by the filter property handler.
 */
KSPROPERTY_SET PropertyTable_FilterDMus[] =
{
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_Pin,
        SIZEOF_ARRAY(PropertyTable_Pin),
        PropertyTable_Pin,
        0,
        NULL
    ),
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_Topology,
        SIZEOF_ARRAY(PropertyTable_Topology),
        PropertyTable_Topology,
        0,
        NULL
    ),
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_SynthClock,
        SIZEOF_ARRAY(PropertyTable_MasterClock),
        PropertyTable_MasterClock,
        0,
        NULL
    )
};


/*****************************************************************************
 * Factory 
 */

#pragma code_seg("PAGE")
/*****************************************************************************
 * CreatePortFilterDMus()
 *****************************************************************************
 * Creates a DMusic port driver filter.
 */
NTSTATUS
CreatePortFilterDMus
(
    OUT     PUNKNOWN *  Unknown,
    IN      REFCLSID,
    IN      PUNKNOWN    UnknownOuter    OPTIONAL,
    IN      POOL_TYPE   PoolType
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB,("CreatePortFilterDMus"));
    ASSERT(Unknown);

    STD_CREATE_BODY(CPortFilterDMus,Unknown,UnknownOuter,PoolType);
}



/*****************************************************************************
 * Member functions.
 */

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortFilterDMus::~CPortFilterDMus()
 *****************************************************************************
 * Destructor.
 */
CPortFilterDMus::~CPortFilterDMus()
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB,("~CPortFilterDMus"));

    if (m_Port)
    {
        m_Port->Release();
        m_Port = NULL;
    }

    if (m_propertyContext.pulPinInstanceCounts)
    {
        delete [] m_propertyContext.pulPinInstanceCounts;
    }
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortFilterDMus::Init()
 *****************************************************************************
 * Initializes the object.
 */
STDMETHODIMP_(NTSTATUS)
CPortFilterDMus::
Init
(
    IN  CPortDMus *Port_
)
{
    PAGED_CODE();

    ASSERT(Port_);

    _DbgPrintF( DEBUGLVL_BLAB, ("Init"));

    m_Port = Port_;
    m_Port->AddRef();

    //
    // Set up context for properties.
    //
    m_propertyContext.pSubdevice           = PSUBDEVICE(m_Port);
    m_propertyContext.pSubdeviceDescriptor = m_Port->m_pSubdeviceDescriptor;
    m_propertyContext.pPcFilterDescriptor  = m_Port->m_pPcFilterDescriptor;
    m_propertyContext.pUnknownMajorTarget  = m_Port->m_Miniport;
    m_propertyContext.pUnknownMinorTarget  = NULL;
    m_propertyContext.ulNodeId             = ULONG(-1);
    m_propertyContext.pulPinInstanceCounts = 
        new(NonPagedPool,'cIcP') ULONG[m_Port->m_pSubdeviceDescriptor->PinCount];

    NTSTATUS ntStatus = STATUS_SUCCESS;

    if (! m_propertyContext.pulPinInstanceCounts)
    {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    return ntStatus;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortFilterDMus::NewIrpTarget()
 *****************************************************************************
 * Creates and initializes a pin object.
 */
STDMETHODIMP_(NTSTATUS)
CPortFilterDMus::
NewIrpTarget
(
    OUT     PIRPTARGET *        IrpTarget,
    OUT     BOOLEAN *           ReferenceParent,
    IN      PUNKNOWN            OuterUnknown,
    IN      POOL_TYPE           PoolType,
    IN      PDEVICE_OBJECT      DeviceObject,
    IN      PIRP                Irp,
    OUT     PKSOBJECT_CREATE    ObjectCreate
)
{
    PAGED_CODE();

    ASSERT(IrpTarget);
    ASSERT(DeviceObject);
    ASSERT(Irp);
    ASSERT(ObjectCreate);

    ASSERT(m_Port);
    ASSERT(m_Port->m_pSubdeviceDescriptor);
    ASSERT(m_Port->m_pSubdeviceDescriptor->PinDescriptors);

    _DbgPrintF(DEBUGLVL_BLAB,("NewIrpTarget"));

//    KdBreakPoint();

    PKSPIN_CONNECT pinConnect;
    NTSTATUS ntStatus =
        PcValidateConnectRequest
        (
            Irp,
            m_Port->m_pSubdeviceDescriptor,
            &pinConnect
        );

    if (NT_SUCCESS(ntStatus))
    {
        ULONG PinId = pinConnect->PinId;

        m_Port->PinCount
        ( 
            PinId,
            &(m_propertyContext.pSubdeviceDescriptor->
                PinInstances[PinId].FilterNecessary),
            &(m_propertyContext.pulPinInstanceCounts[PinId]),
            &(m_propertyContext.pSubdeviceDescriptor->
                PinInstances[PinId].FilterPossible),
            &(m_propertyContext.pSubdeviceDescriptor->
                PinInstances[PinId].GlobalCurrent),
            &(m_propertyContext.pSubdeviceDescriptor->
                PinInstances[PinId].GlobalPossible) 
        );

        ntStatus = 
            PcValidatePinCount
            (
                PinId,
                m_Port->m_pSubdeviceDescriptor,
                m_propertyContext.pulPinInstanceCounts
            );

        if (NT_SUCCESS(ntStatus))
        {
            ObjectCreate->CreateItemsCount  = 0;
            ObjectCreate->CreateItemsList   = NULL;

            PUNKNOWN pinUnknown;
            ntStatus =
                CreatePortPinDMus
                (
                    &pinUnknown,
                    GUID_NULL,
                    OuterUnknown,
                    PoolType
                );

            if (NT_SUCCESS(ntStatus))
            {
                PPORTPINDMUS pinDMus;

                ntStatus =
                    pinUnknown->QueryInterface
                    (
                        IID_IIrpTarget,
                        (PVOID *) &pinDMus
                    );

                if (NT_SUCCESS(ntStatus))
                {
                    //
                    // The QI for IIrpTarget actually gets IPortPinDMus.
                    //
                    ntStatus = 
                        pinDMus->Init
                        (
                            m_Port,
                            this,
                            pinConnect,
                            &m_Port->m_pSubdeviceDescriptor->
                                PinDescriptors[pinConnect->PinId]
                        );

                    if (NT_SUCCESS(ntStatus))
                    {
                        *ReferenceParent = TRUE;
                        *IrpTarget = pinDMus;
                    }
                    else
                    {
                        pinDMus->Release();
                    }
                }

                pinUnknown->Release();
            }

            if (! NT_SUCCESS(ntStatus))
            {
                PcTerminateConnection
                (   m_Port->m_pSubdeviceDescriptor
                ,   m_propertyContext.pulPinInstanceCounts
                ,   pinConnect->PinId
                );
            }
        }
    }

    return ntStatus;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortFilterDMus::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.
 */
STDMETHODIMP_(NTSTATUS)
CPortFilterDMus::
NonDelegatingQueryInterface
(
    REFIID  Interface,
    PVOID * Object
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB,("NonDelegatingQueryInterface"));
    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface,IID_IUnknown))
    {
        *Object = PVOID(PPORTFILTERDMUS(this));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IIrpTarget))
    {
        // Cheat!  Get specific interface so we can reuse the IID.
        *Object = PVOID(PPORTFILTERDMUS(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortFilterDMus::DeviceIOControl()
 *****************************************************************************
 * Handles an IOCTL IRP.
 */
STDMETHODIMP_(NTSTATUS)
CPortFilterDMus::
DeviceIoControl
(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
)
{
    PAGED_CODE();

    ASSERT(DeviceObject);
    ASSERT(Irp);

    _DbgPrintF( DEBUGLVL_BLAB, ("DeviceIoControl"));

    NTSTATUS            ntStatus;
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);

    switch (irpSp->Parameters.DeviceIoControl.IoControlCode)
    {
    case IOCTL_KS_PROPERTY:
        ntStatus =
            PcHandlePropertyWithTable
            (
                Irp,
                m_Port->m_pSubdeviceDescriptor->FilterPropertyTable.PropertySetCount,
                m_Port->m_pSubdeviceDescriptor->FilterPropertyTable.PropertySets,
                &m_propertyContext
            );
        break;

    case IOCTL_KS_ENABLE_EVENT:
        {
            EVENT_CONTEXT EventContext;

            EventContext.pPropertyContext = &m_propertyContext;
            EventContext.pEventList = NULL;
            EventContext.ulPinId = ULONG(-1);
            EventContext.ulEventSetCount = m_Port->m_pSubdeviceDescriptor->FilterEventTable.EventSetCount;
            EventContext.pEventSets = m_Port->m_pSubdeviceDescriptor->FilterEventTable.EventSets;
            
            ntStatus =
                PcHandleEnableEventWithTable
                (
                    Irp,
                    &EventContext
                );
        }
        break;

    case IOCTL_KS_DISABLE_EVENT:
        {
            EVENT_CONTEXT EventContext;

            EventContext.pPropertyContext = &m_propertyContext;
            EventContext.pEventList = &(m_Port->m_EventList);
            EventContext.ulPinId = ULONG(-1);            
            EventContext.ulEventSetCount = m_Port->m_pSubdeviceDescriptor->FilterEventTable.EventSetCount;
            EventContext.pEventSets = m_Port->m_pSubdeviceDescriptor->FilterEventTable.EventSets;

            ntStatus =
                PcHandleDisableEventWithTable
                (
                    Irp,
                    &EventContext
            );
        }
        break;

    default:
        return KsDefaultDeviceIoCompletion(DeviceObject, Irp);
    }

    Irp->IoStatus.Status = ntStatus;
    IoCompleteRequest(Irp,IO_NO_INCREMENT);
    return ntStatus;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortFilterDMus::Close()
 *****************************************************************************
 * Handles a flush IRP.
 */
STDMETHODIMP_(NTSTATUS)
CPortFilterDMus::
Close
(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
)
{
    PAGED_CODE();

    _DbgPrintF( DEBUGLVL_BLAB, ("Close"));
    ASSERT(DeviceObject);
    ASSERT(Irp);

    //
    // free any events in the port event list associated with this
    // filter instance
    //
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
    KsFreeEventList( IrpStack->FileObject,
                     &( m_Port->m_EventList.List ),
                     KSEVENTS_SPINLOCK,
                     &( m_Port->m_EventList.ListLock) );

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp,IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}

DEFINE_INVALID_READ(CPortFilterDMus);
DEFINE_INVALID_WRITE(CPortFilterDMus);
DEFINE_INVALID_FLUSH(CPortFilterDMus);
DEFINE_INVALID_QUERYSECURITY(CPortFilterDMus);
DEFINE_INVALID_SETSECURITY(CPortFilterDMus);
DEFINE_INVALID_FASTDEVICEIOCONTROL(CPortFilterDMus);
DEFINE_INVALID_FASTREAD(CPortFilterDMus);
DEFINE_INVALID_FASTWRITE(CPortFilterDMus);

#pragma code_seg("PAGE")
/*****************************************************************************
 * PropertyHandler_Pin()
 *****************************************************************************
 * Property handler for pin description properties.
 */
static
NTSTATUS
PropertyHandler_Pin
(
    IN      PIRP        Irp,
    IN      PKSP_PIN    Pin,
    IN OUT  PVOID       Data
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB,("PropertyHandler_Pin"));
    ASSERT(Irp);
    ASSERT(Pin);

    return
        PcPinPropertyHandler
        (   Irp
        ,   Pin
        ,   Data
        );
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * PropertyHandler_Topology()
 *****************************************************************************
 * Property handler for topology.
 */
static
NTSTATUS
PropertyHandler_Topology
(
    IN      PIRP        Irp,
    IN      PKSPROPERTY Property,
    IN OUT  PVOID       Data
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB,("PropertyHandler_Topology"));
    ASSERT(Irp);
    ASSERT(Property);

    PPROPERTY_CONTEXT pPropertyContext =
        PPROPERTY_CONTEXT(Irp->Tail.Overlay.DriverContext[3]);
    ASSERT(pPropertyContext);

    PSUBDEVICE_DESCRIPTOR pSubdeviceDescriptor =
        pPropertyContext->pSubdeviceDescriptor;
    ASSERT(pSubdeviceDescriptor);

    return
        KsTopologyPropertyHandler
        (
            Irp,
            Property,
            Data,
            pSubdeviceDescriptor->Topology
        );
}

#pragma code_seg()
/*****************************************************************************
 * PropertyHandler_Clock()
 *****************************************************************************
 * Property handler for clock.
 */
static
NTSTATUS
PropertyHandler_MasterClock
(
    IN      PIRP        Irp,
    IN      PKSPROPERTY Property,
    IN OUT  PVOID       Data
)
{
    if (Property->Id != KSPROPERTY_SYNTH_MASTERCLOCK)
    {
        return STATUS_NOT_FOUND;
    }

    *(PULONGLONG)Data = DMusicDefaultGetTime();

    Irp->IoStatus.Information = sizeof(ULONGLONG);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\ports\dmus\feedout.cpp ===
/*  
    MIDI Transform Filter object for translating a DMusic output
    stream to a IMiniportMidiStream miniport.

    Copyright (c) 1998-2000 Microsoft Corporation.  All rights reserved.

    12/10/98    Martin Puryear      Created this file

*/

#define STR_MODULENAME "DMus:FeederOutMXF: "
#include "private.h"
#include "FeedOut.h"

#pragma code_seg("PAGE")
/*****************************************************************************
 * CFeederOutMXF::CFeederOutMXF()
 *****************************************************************************
 * Constructor.  An allocator and a clock must be provided.
 */
CFeederOutMXF::CFeederOutMXF(CAllocatorMXF *AllocatorMXF,
                             PMASTERCLOCK   Clock)
:   CUnknown(NULL),
    CMXF(AllocatorMXF)
{
    PAGED_CODE();
    ASSERT(AllocatorMXF);
    ASSERT(Clock);
    
    m_DMKEvtQueue = NULL;
    KeInitializeSpinLock(&m_EvtQSpinLock);

    _DbgPrintF(DEBUGLVL_BLAB, ("CFeederOutMXF::CFeederOutMXF"));
    m_SinkMXF = AllocatorMXF;
    m_Clock = Clock;
    m_State = KSSTATE_STOP;
    
    m_TimerQueued = FALSE;
    m_DMKEvtOffset = 0;
    m_MiniportStream = NULL;

    KeInitializeDpc(&m_Dpc,&::DMusFeederOutDPC,PVOID(this));
    KeInitializeTimer(&m_TimerEvent);
}

#pragma code_seg()
/*****************************************************************************
 * CFeederOutMXF::~CFeederOutMXF()
 *****************************************************************************
 * Destructor.  Artfully remove this filter from the chain before freeing.
 */
CFeederOutMXF::~CFeederOutMXF(void)
{
    _DbgPrintF(DEBUGLVL_BLAB, ("CFeederOutMXF::~CFeederOutMXF"));

    // Prevent new DPCs.
    //
    KeCancelTimer(&m_TimerEvent);
    KeRemoveQueueDpc(&m_Dpc);

    // Release any remaining messages.
    //
    KIRQL oldIrql;
    KeAcquireSpinLock(&m_EvtQSpinLock, &oldIrql);
    if (m_DMKEvtQueue != NULL)
    {
        m_AllocatorMXF->PutMessage(m_DMKEvtQueue);
        m_DMKEvtQueue = NULL;
    }
    KeReleaseSpinLock(&m_EvtQSpinLock, oldIrql);

    DisconnectOutput(m_SinkMXF);
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CFeederOutMXF::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.
 */
STDMETHODIMP_(NTSTATUS)
CFeederOutMXF::
NonDelegatingQueryInterface
(
    REFIID  Interface,
    PVOID * Object
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB, ("NonDelegatingQueryInterface"));
    ASSERT(Object);
    if (!Object)
    {
        return STATUS_INVALID_PARAMETER_2;
    }

    if (IsEqualGUIDAligned(Interface,IID_IUnknown))
    {
        *Object = PVOID(PMXF(this));
    }
    else if (IsEqualGUIDAligned(Interface,IID_IMXF))
    {
        *Object = PVOID(PMXF(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER_1;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CFeederOutMXF::SetState()
 *****************************************************************************
 * Set the state of the filter.
 */
NTSTATUS 
CFeederOutMXF::SetState(KSSTATE State)    
{   
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB, ("SetState %d",State));

    NTSTATUS ntStatus = STATUS_INVALID_PARAMETER;

    if (m_MiniportStream)
    {
        ntStatus = m_MiniportStream->SetState(State);
        if (NT_SUCCESS(ntStatus))
        {
            m_State = State;
        }
    }

    return ntStatus;    
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CFeederOutMXF::SetMiniportStream()
 *****************************************************************************
 * Set the destination MiniportStream of the filter.
 */
NTSTATUS CFeederOutMXF::SetMiniportStream(PMINIPORTMIDISTREAM MiniportStream)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB, ("SetMiniportStream %p",MiniportStream));
    
    if (MiniportStream)
    {
        m_MiniportStream = MiniportStream;
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CFeederOutMXF::ConnectOutput()
 *****************************************************************************
 * Create a forwarding address for this filter, 
 * instead of shunting it to the allocator.
 */
NTSTATUS CFeederOutMXF::ConnectOutput(PMXF sinkMXF)
{
    PAGED_CODE();

    if ((sinkMXF) && (m_SinkMXF == m_AllocatorMXF)) 
    {
        _DbgPrintF(DEBUGLVL_BLAB, ("ConnectOutput"));
        m_SinkMXF = sinkMXF;
        return STATUS_SUCCESS;
    }
    _DbgPrintF(DEBUGLVL_TERSE, ("ConnectOutput failed"));
    return STATUS_UNSUCCESSFUL;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CFeederOutMXF::DisconnectOutput()
 *****************************************************************************
 * Remove the forwarding address for this filter.
 * This filter should now forward all messages to the allocator.
 */
NTSTATUS CFeederOutMXF::DisconnectOutput(PMXF sinkMXF)
{
    PAGED_CODE();

    if ((m_SinkMXF == sinkMXF) || (!sinkMXF))
    {
        _DbgPrintF(DEBUGLVL_BLAB, ("DisconnectOutput"));
        m_SinkMXF = m_AllocatorMXF;
        return STATUS_SUCCESS;
    }
    _DbgPrintF(DEBUGLVL_TERSE, ("DisconnectOutput failed"));
    return STATUS_UNSUCCESSFUL;
}

#pragma code_seg()
/*****************************************************************************
 * CFeederOutMXF::PutMessage()
 *****************************************************************************
 * Writes an outgoing MIDI message.
 */
NTSTATUS CFeederOutMXF::PutMessage(PDMUS_KERNEL_EVENT pDMKEvt)
{
    NTSTATUS            ntStatus = STATUS_SUCCESS;
    PDMUS_KERNEL_EVENT  aDMKEvt;
    
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    KeAcquireSpinLockAtDpcLevel(&m_EvtQSpinLock);
    if (NT_SUCCESS(SyncPutMessage(pDMKEvt)))
    {
        if (!m_TimerQueued)
        {
            KeReleaseSpinLockFromDpcLevel(&m_EvtQSpinLock);
            (void) ConsumeEvents();
        }
        else
        {
            KeReleaseSpinLockFromDpcLevel(&m_EvtQSpinLock);            
        }
    }
    else
    {
        KeReleaseSpinLockFromDpcLevel(&m_EvtQSpinLock);            
    }

    return ntStatus;
}

#pragma code_seg()
/*****************************************************************************
 * CFeederOutMXF::SyncPutMessage()
 *****************************************************************************
 * Puts a new message to event queue without acquiring spinlocks.
 * Caller must acquire m_EvtQSpinLock.
 */
NTSTATUS CFeederOutMXF::SyncPutMessage(PDMUS_KERNEL_EVENT pDMKEvt)
{
    NTSTATUS            ntStatus = STATUS_SUCCESS;
    PDMUS_KERNEL_EVENT  aDMKEvt;
    
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    _DbgPrintF(DEBUGLVL_BLAB, ("SyncPutMessage(0x%p)",pDMKEvt));
    
    if (pDMKEvt)
    {
        if (m_DMKEvtQueue)  
        {
            aDMKEvt = m_DMKEvtQueue;
            while (aDMKEvt->pNextEvt)
            {           
                aDMKEvt = aDMKEvt->pNextEvt;
            }
            //  put pDMKEvt at end of event queue 
            aDMKEvt->pNextEvt = pDMKEvt;
        }
        else
        {
            // currently nothing in queue
            m_DMKEvtQueue = pDMKEvt;
            if (m_DMKEvtOffset)
            {
                _DbgPrintF(DEBUGLVL_TERSE,("PutMessage  Nothing in the queue, but m_DMKEvtOffset == %d",m_DMKEvtOffset));
            }
            m_DMKEvtOffset = 0;
        }
    }
    else
    {
        ntStatus = STATUS_INVALID_PARAMETER;
    }

    return ntStatus;
}

#pragma code_seg()
/*****************************************************************************
 * CFeederOutMXF::ConsumeEvents()
 *****************************************************************************
 * Attempts to empty the render message queue.  
 * Called either from DPC timer or upon IRP submittal.
 */
NTSTATUS CFeederOutMXF::ConsumeEvents(void)
{
    PDMUS_KERNEL_EVENT aDMKEvt;

    NTSTATUS    ntStatus = STATUS_SUCCESS;
    ULONG       bytesWritten = 0;
    ULONG       byteOffset,bytesRemaining;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    m_TimerQueued = FALSE;

    KeAcquireSpinLockAtDpcLevel(&m_EvtQSpinLock);
   
    //  do we have anything to play at all?
    while (m_DMKEvtQueue)
    {
        //  here is the event we will try to play
        aDMKEvt = m_DMKEvtQueue;

        byteOffset = m_DMKEvtOffset;

        //  here is the number of bytes left in this event
        bytesRemaining = aDMKEvt->cbEvent - byteOffset;

        ASSERT(bytesRemaining > 0);
        if (aDMKEvt->cbEvent <= sizeof(PBYTE))            //  short message
        {
            _DbgPrintF(DEBUGLVL_VERBOSE, ("ConsumeEvents(%02x%02x%02x%02x)",aDMKEvt->uData.abData[0],aDMKEvt->uData.abData[1],aDMKEvt->uData.abData[2],aDMKEvt->uData.abData[3]));
            ntStatus = m_MiniportStream->Write(aDMKEvt->uData.abData + byteOffset,bytesRemaining,&bytesWritten);
        }   
        else if (PACKAGE_EVT(aDMKEvt))
        {
            ASSERT(byteOffset == 0);
            _DbgPrintF(DEBUGLVL_BLAB, ("ConsumeEvents(Package)"));

            SyncPutMessage(aDMKEvt->uData.pPackageEvt);

            // null pPackageEvt and set bytesWritten: we're throwing aDMKEvt away
            aDMKEvt->uData.pPackageEvt = NULL;
            bytesWritten = bytesRemaining;
        }
        else    //  SysEx message
        {
            _DbgPrintF(DEBUGLVL_VERBOSE, ("ConsumeEvents(%02x%02x%02x%02x) [SysEx]",aDMKEvt->uData.pbData[0],aDMKEvt->uData.pbData[1],aDMKEvt->uData.pbData[2],aDMKEvt->uData.pbData[3]));
            ntStatus = m_MiniportStream->Write(aDMKEvt->uData.pbData + byteOffset,bytesRemaining,&bytesWritten);
        }

        // If one of the miniport writes failed, we should update
        // bytesWritten. Otherwise playback will not progress.
        if (STATUS_SUCCESS != ntStatus)
        {
            bytesWritten = bytesRemaining;
            ntStatus = STATUS_SUCCESS;
        }
        
        //  if we completed an event, throw it away.
        if (bytesWritten == bytesRemaining)
        {
            //  start fresh on the next event
            m_DMKEvtOffset = 0;

            m_DMKEvtQueue = m_DMKEvtQueue->pNextEvt;

            aDMKEvt->pNextEvt = NULL;

            //  throw back in the free pool
            m_AllocatorMXF->PutMessage(aDMKEvt);
        }
        else
        {
            //  HW is full, update offset for anything we wrote
            m_DMKEvtOffset += bytesWritten;
            ASSERT(m_DMKEvtOffset < aDMKEvt->cbEvent);

            _DbgPrintF(DEBUGLVL_BLAB,("ConsumeEvents tried %d, wrote %d, offset is now %d",bytesRemaining,bytesWritten,m_DMKEvtOffset));

            //  set a timer and come back later
            LARGE_INTEGER   aMillisecIn100ns;
            aMillisecIn100ns.QuadPart = -kOneMillisec;     
            ntStatus = KeSetTimer( &m_TimerEvent, aMillisecIn100ns, &m_Dpc );
            m_TimerQueued = TRUE;
            break;
        }   //  we didn't write it all
    }       //  while (m_DMKEvtQueue):  go back, Jack, do it again
    KeReleaseSpinLockFromDpcLevel(&m_EvtQSpinLock);
    return ntStatus;
}

#pragma code_seg()
/*****************************************************************************
 * DMusFeederOutDPC()
 *****************************************************************************
 * The timer DPC callback. Thunks to a C++ member function.
 * This is called by the OS in response to the DirectMusic pin
 * wanting to wakeup later to process more DirectMusic stuff.
 */
VOID NTAPI DMusFeederOutDPC
(
    IN  PKDPC   Dpc,
    IN  PVOID   DeferredContext,
    IN  PVOID   SystemArgument1,
    IN  PVOID   SystemArgument2
)
{
    ASSERT(DeferredContext);
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    ((CFeederOutMXF *) DeferredContext)->ConsumeEvents();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\ports\dmus\private.h ===
/*****************************************************************************
 * private.h - DMusic port private definitions
 *****************************************************************************
 * Copyright (c) 1998-2000 Microsoft Corporation.  All rights reserved.
 *
 *      6/3/98  MartinP
 */

#ifndef _DMUS_PRIVATE_H_
#define _DMUS_PRIVATE_H_

#include "portclsp.h"
#include "stdunk.h"
#include "dmusicks.h"

#include "stdio.h"
#include "stdarg.h"

#include "ksdebug.h"

#ifndef DEBUGLVL_LIFETIME
#define DEBUGLVL_LIFETIME DEBUGLVL_VERBOSE
#endif

#define kAdjustingTimerRes          1

#define kOneMillisec (10 * 1000)

#if kAdjustingTimerRes
const ULONG kDMusTimerResolution100ns = 1 * kOneMillisec;   //  # 100nsec resolution for timer callbacks
#else   //  !kAdjustingTimerRes
const ULONG kDMusTimerResolution100ns = 5 * kOneMillisec;   //  # 100nsec resolution for timer callbacks
#endif  //  !kAdjustingTimerRes


//
// THE SIZES HERE MUST AGREE WITH THE DEFINITION IN FILTER.CPP AND PIN.CPP.
//
extern KSPROPERTY_SET PropertyTable_FilterDMus[3];
extern KSPROPERTY_SET PropertyTable_PinDMus[2];
extern KSEVENT_SET    EventTable_PinDMus[1];

/*****************************************************************************
 * Interfaces
 */

class CPortDMus;
class CPortFilterDMus;
class CPortPinDMus;
class CAllocatorMXF;
class CCaptureSinkMXF;
class CPackerMXF;
class CSequencerMXF;
class CUnpackerMXF;
class CFeederInMXF;
class CFeederOutMXF;

/*****************************************************************************
 * IPortFilterDMus
 *****************************************************************************
 * Interface for DirectMusic filters.
 */
DECLARE_INTERFACE_(IPortFilterDMus,IIrpTarget)
{
    DEFINE_ABSTRACT_UNKNOWN()           // For IUnknown

    DEFINE_ABSTRACT_IRPTARGETFACTORY()  // For IIrpTargetFactory

    DEFINE_ABSTRACT_IRPTARGET()         // For IIrpTarget

    STDMETHOD_(NTSTATUS,Init)
    (   THIS_
        IN      CPortDMus *Port
    )   PURE;
};

typedef IPortFilterDMus *PPORTFILTERDMUS;

/*****************************************************************************
 * IPortPinDMus
 *****************************************************************************
 * Interface for DirectMusic pins.
 */
DECLARE_INTERFACE_(IPortPinDMus,IIrpTarget)
{
    DEFINE_ABSTRACT_UNKNOWN()           // For IUnknown

    DEFINE_ABSTRACT_IRPTARGETFACTORY()  // For IIrpTargetFactory

    DEFINE_ABSTRACT_IRPTARGET()         // For IIrpTarget

    STDMETHOD_(NTSTATUS,Init)
    (   THIS_
        IN      CPortDMus *         Port,
        IN      CPortFilterDMus *   Filter,
        IN      PKSPIN_CONNECT      PinConnect,
        IN      PKSPIN_DESCRIPTOR   PinDescriptor
    )   PURE;
};

typedef IPortPinDMus *PPORTPINDMUS;

/*****************************************************************************
 * IPositionNotify
 *****************************************************************************
 * Byte position notify for MXF graph
 */
DECLARE_INTERFACE_(IPositionNotify,IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    STDMETHOD_(void,PositionNotify)
    (   THIS_
        IN      ULONGLONG   bytePosition
    )   PURE;
};

typedef IPositionNotify *PPOSITIONNOTIFY;

#define IMP_IPositionNotify                 \
    STDMETHODIMP_(void) PositionNotify      \
    (   THIS_                               \
        IN      ULONGLONG   bytePosition    \
    );                                      \

/*****************************************************************************
 * Classes
 */

/*****************************************************************************
 * CPortDMus
 *****************************************************************************
 * DMus port driver.
 */
class CPortDMus
:   public IPortDMus,
    public IPortEvents,
    public IServiceSink,
    public ISubdevice,
    public IMasterClock,
#ifdef DRM_PORTCLS
    public IDrmPort2,
#endif  // DRM_PORTCLS
    public IPortClsVersion,
    public CUnknown
{
private:
    PDEVICE_OBJECT          m_DeviceObject;
    PMINIPORTDMUS           m_Miniport;
    PSERVICEGROUP           m_MiniportServiceGroup;
    PSUBDEVICE_DESCRIPTOR   m_pSubdeviceDescriptor;
    PPCFILTER_DESCRIPTOR    m_pPcFilterDescriptor;
    KDPC                    m_EventDpc;
    KDPC                    m_Dpc;
    KMUTEX                  m_ControlMutex;
    INTERLOCKED_LIST        m_EventList;
    EVENT_DPC_CONTEXT       m_EventContext;
    PMINIPORTMIDI           m_MiniportMidi;
    PPINCOUNT               m_MPPinCountI;

    // TODO:  Fix this.
#define MAX_PINS 32
    ULONG                   m_PinEntriesUsed;
    CPortPinDMus *          m_Pins[MAX_PINS];


public:
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CPortDMus);
    ~CPortDMus();

    IMP_ISubdevice;
    IMP_IPortDMus;
    IMP_IServiceSink;
    IMP_IPortEvents;
    IMP_IMasterClock;
#ifdef DRM_PORTCLS
    IMP_IDrmPort2;
#endif  // DRM_PORTCLS
    IMP_IPortClsVersion;

    /*************************************************************************
     * friends
     */
    friend class CPortFilterDMus;
    friend class CPortPinDMus;

    friend
    NTSTATUS
    PinPropertyDataFormat
    (
        IN      PIRP            Irp,
        IN      PKSPROPERTY     Property,
        IN OUT  PKSDATAFORMAT   DataFormat
    );
    friend
    NTSTATUS
    PinPropertyDeviceState
    (
        IN      PIRP        Irp,
        IN      PKSPROPERTY Property,
        IN OUT  PKSSTATE    DeviceState
    );
    friend
    NTSTATUS
    PropertyHandler_Pin
    (
        IN      PIRP        Irp,
        IN      PKSP_PIN    Pin,
        IN OUT  PVOID       Data
    );
    friend
    NTSTATUS
    PropertyHandler_Topology
    (
        IN      PIRP        Irp,
        IN      PKSPROPERTY Property,
        IN OUT  PVOID       Data
    );
    friend
    NTSTATUS
    PropertyHandler_Clock
    (
        IN      PIRP        Irp,
        IN      PKSPROPERTY Property,
        IN OUT  PVOID       Data
    );
    friend
    void
    PcGenerateEventDeferredRoutine
    (
        IN PKDPC Dpc,
        IN PVOID DeferredContext,
        IN PVOID SystemArgument1,
        IN PVOID SystemArgument2
    );
};

/*****************************************************************************
 * CPortFilterDMus
 *****************************************************************************
 * Filter implementation for DirectMusic port.
 */
class CPortFilterDMus
:   public IPortFilterDMus,
    public CUnknown
{
private:
    CPortDMus *         m_Port;
    PROPERTY_CONTEXT    m_propertyContext;

public:
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CPortFilterDMus);
    ~CPortFilterDMus();

    IMP_IIrpTarget;

    STDMETHODIMP_(NTSTATUS) Init
    (
        IN      CPortDMus *Port
    );

    /*************************************************************************
     * friends
     */
    friend class CPortPinDMus;

    friend
    NTSTATUS
    PropertyHandler_Pin
    (
        IN      PIRP        Irp,
        IN      PKSP_PIN    Pin,
        IN OUT  PVOID       Data
    );
    friend
    NTSTATUS
    PropertyHandler_Topology
    (
        IN      PIRP        Irp,
        IN      PKSPROPERTY Property,
        IN OUT  PVOID       Data
    );
    friend
    NTSTATUS
    PropertyHandler_Clock
    (
        IN      PIRP        Irp,
        IN      PKSPROPERTY Property,
        IN OUT  PVOID       Data
    );
};

typedef struct {
    KSMUSICFORMAT musicFormat;
    ULONG         midiData;
} MIDI_SHORT_MESSAGE, *PMIDI_SHORT_MESSAGE;

const ULONG kMaxSysExChunk = 12;   //  break up sysex messages into
                                   //  KSMUSICFORMATs of this many bytes

/*****************************************************************************
 * CPortPinDMus
 *****************************************************************************
 * Pin implementation for DirectMusic port.
 */
class CPortPinDMus
:   public IPortPinDMus,
    public IIrpStreamNotify,
    public IServiceSink,
    public IKsShellTransport,
    public IKsWorkSink,
    public CUnknown,
    public IPositionNotify
{
private:
    PDEVICE_OBJECT      m_ConnectionDeviceObject;
    PFILE_OBJECT        m_ConnectionFileObject;
    KSRESET             m_ResetState;
    KSSTATE             m_DeviceState;
    KSSTATE             m_TransportState;
    KSSTATE             m_CommandedState;
    KSSTATE             m_MXFGraphState;

    CPortDMus *         m_Port;
    CPortFilterDMus *   m_Filter;

    PMXF                m_MiniportMXF;
    PMINIPORTMIDISTREAM m_MiniportMidiStream;
    ULONG               m_Id;
    PKSPIN_DESCRIPTOR   m_Descriptor;
    ULONG               m_Index;
    DMUS_STREAM_TYPE    m_StreamType;

    PIRPSTREAMVIRTUAL   m_IrpStream;
    CAllocatorMXF      *m_AllocatorMXF;
    CCaptureSinkMXF    *m_CaptureSinkMXF;
    CPackerMXF         *m_PackerMXF;
    CSequencerMXF      *m_SequencerMXF;
    CUnpackerMXF       *m_UnpackerMXF;
    CFeederOutMXF      *m_FeederOutMXF;
    CFeederInMXF       *m_FeederInMXF;

    ULONGLONG           m_SubmittedPresTime100ns;

    ULONGLONG           m_SubmittedBytePosition; // # bytes we shoved into MXF graph
    ULONGLONG           m_CompletedBytePosition; // # bytes we completed in IrpStream

    PKSDATAFORMAT       m_DataFormat;
    KSPIN_DATAFLOW      m_DataFlow;     //  Because descriptor is paged.

    ULONG               m_BlockAlign;
    ULONG               m_FrameSize;
    PSYNTHSINKDMUS      m_SynthSink;
    LONGLONG            m_SamplePosition;
    PBYTE               m_WaveBuffer;
    PFILE_OBJECT        m_WaveClockFileObject;

    BOOLEAN             m_DirectMusicPin;
    BOOLEAN             m_Suspended;
    BOOLEAN             m_Flushing;
    BOOLEAN             m_LastDPCWasIncomplete;

    KDPC                m_Dpc;          //  x20 size
    KSPIN_LOCK          m_DpcSpinLock;  //  x04 size
    KTIMER              m_TimerEvent;   //  x24 size

    PROPERTY_CONTEXT    m_propertyContext;

    PSERVICEGROUP       m_ServiceGroup;

    PIKSSHELLTRANSPORT      m_TransportSink;
    PIKSSHELLTRANSPORT      m_TransportSource;
    PIKSSHELLTRANSPORT      m_RequestorTransport;
    PIKSSHELLTRANSPORT      m_QueueTransport;
    INTERLOCKEDLIST_HEAD    m_IrpsToSend;
    INTERLOCKEDLIST_HEAD    m_IrpsOutstanding;
    PKSWORKER               m_Worker;
    WORK_QUEUE_ITEM         m_WorkItem;

    ULONG           m_ByteCount;

    KSPIN_LOCK      m_EventLock;
    LIST_ENTRY      m_EventList;

    STDMETHODIMP_(NTSTATUS) SetMXFGraphState(KSSTATE NewState);
    NTSTATUS CreateMXFs(void);
    NTSTATUS ConnectMXFGraph(void);
    NTSTATUS DeleteMXFGraph(void);

    STDMETHODIMP_(void) PowerNotify(POWER_STATE PowerState);

    void    ServeRender(void);
    void    ServeCapture(void);
    void    SynthSinkWorker(void);
    void    ServiceRenderIRP(void);
    void    FlushCaptureSink(void);

    BOOL    IrpStreamHasValidTimeBase(PIRPSTREAMPACKETINFO pIrpStreamPacketInfo);

    ULONG   GetNextDeltaTime();

    NTSTATUS    SyncToMaster(BOOL fStart);
    LONGLONG    SampleToByte(LONGLONG llSamples);
    LONGLONG    ByteToSample(LONGLONG llBytes);
    LONGLONG    SampleAlign(LONGLONG llBytes);

public:
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CPortPinDMus);
    ~CPortPinDMus();

    IMP_IIrpTarget;
    IMP_IIrpStreamNotify;
    IMP_IServiceSink;
    IMP_IKsShellTransport;
    IMP_IKsWorkSink;
    IMP_IPositionNotify;

    /*************************************************************************
     * IPortPinDMus methods
     */

    STDMETHODIMP_(NTSTATUS) Init
    (
        IN      CPortDMus *         Port,
        IN      CPortFilterDMus *   Filter,
        IN      PKSPIN_CONNECT      PinConnect,
        IN      PKSPIN_DESCRIPTOR   PinDescriptor
    );

    /*************************************************************************
     * friends
     */
    friend CPortDMus;

    friend VOID NTAPI
    DMusTimerDPC
    (
        IN      PKDPC   Dpc,
        IN      PVOID   DeferredContext,
        IN      PVOID   SystemArgument1,
        IN      PVOID   SystemArgument2
    );
    friend
    NTSTATUS
    PinPropertyDeviceState
    (
        IN      PIRP        Irp,
        IN      PKSPROPERTY Property,
        IN OUT  PKSSTATE    DeviceState
    );
    friend
    NTSTATUS
    PinPropertyDataFormat
    (
        IN      PIRP            Irp,
        IN      PKSPROPERTY     Property,
        IN OUT  PKSDATAFORMAT   DataFormat
    );

    static
    NTSTATUS
    PinPropertyStreamMasterClock(
        IN PIRP Irp,
        IN PKSPROPERTY Property,
        IN OUT PHANDLE ClockHandle
    );

    NTSTATUS
    DistributeDeviceState(
        IN KSSTATE NewState,
        IN KSSTATE OldState
        );
    void
    DistributeResetState(
        IN KSRESET NewState
        );
    static
    NTSTATUS
    IoCompletionRoutine(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp,
        IN PVOID Context
        );
    NTSTATUS
    BuildTransportCircuit(
        void
        );
    void
    CancelIrpsOutstanding(
        void
        );
};




/*****************************************************************************
 * Functions.
 */

/*****************************************************************************
 * CreatePortFilterDMus()
 *****************************************************************************
 * Creates a DirectMusic port driver filter.
 */
NTSTATUS
CreatePortFilterDMus
(
    OUT     PUNKNOWN *  Unknown,
    IN      REFCLSID,
    IN      PUNKNOWN    UnknownOuter    OPTIONAL,
    IN      POOL_TYPE   PoolType
);

/*****************************************************************************
 * CreatePortPinDMus()
 *****************************************************************************
 * Creates a DirectMusic port driver pin.
 */
NTSTATUS
CreatePortPinDMus
(
    OUT     PUNKNOWN *  Unknown,
    IN      REFCLSID,
    IN      PUNKNOWN    UnknownOuter    OPTIONAL,
    IN      POOL_TYPE   PoolType
);

/*****************************************************************************
 * DMusicDefaultGetTime()
 *****************************************************************************
 * Gets the default reference time for the DMusic port driver.  This is
 * the only clock for the initial release of DMusic kernel components.
 */
REFERENCE_TIME DMusicDefaultGetTime(void);

#endif  //  _DMUS_PRIVATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\ports\dmus\pin.cpp ===
/*****************************************************************************
 * pin.cpp - DirectMusic port pin implementation
 *****************************************************************************
 * Copyright (c) 1997-2000 Microsoft Corporation.  All rights reserved.
 *
 *      6/3/98  MartinP
 */

#include "private.h"
#include "Allocatr.h"
#include "CaptSink.h"
#include "FeedIn.h"
#include "FeedOut.h"
#include "Packer.h"
#include "Sequencr.h"
#include "Unpacker.h"


#define STR_MODULENAME "DMus:Pin: "

#define FRAME_COUNT        10
#define FRAMES_PER_SEC     105  //  even integer divisor of 11025, 22050 and 44100


//
// IRPLIST_ENTRY is used for the list of outstanding IRPs.  This structure is
// overlayed on the Parameters section of the current IRP stack location.  The
// reserved PVOID at the top preserves the OutputBufferLength, which is the
// only parameter that needs to be preserved.
//
typedef struct IRPLIST_ENTRY_
{
    PVOID       Reserved;
    PIRP        Irp;
    LIST_ENTRY  ListEntry;
} IRPLIST_ENTRY, *PIRPLIST_ENTRY;

#define IRPLIST_ENTRY_IRP_STORAGE(Irp) \
    PIRPLIST_ENTRY(&IoGetCurrentIrpStackLocation(Irp)->Parameters)


#pragma code_seg("PAGE")                                    
/*****************************************************************************
 * Constants.
 */


DEFINE_KSPROPERTY_TABLE(PinPropertyTableConnection)
{
    DEFINE_KSPROPERTY_ITEM_CONNECTION_STATE
    (
        PinPropertyDeviceState,
        PinPropertyDeviceState
    ),
    DEFINE_KSPROPERTY_ITEM_CONNECTION_DATAFORMAT
    (
        PinPropertyDataFormat,
        PinPropertyDataFormat
    )
};

DEFINE_KSPROPERTY_TABLE(PinPropertyTableStream)
{
    DEFINE_KSPROPERTY_ITEM_STREAM_MASTERCLOCK
    ( 
        CPortPinDMus::PinPropertyStreamMasterClock,
        CPortPinDMus::PinPropertyStreamMasterClock
    )
};

KSPROPERTY_SET PropertyTable_PinDMus[] =
{
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_Connection,
        SIZEOF_ARRAY(PinPropertyTableConnection),
        PinPropertyTableConnection,
        0,
        NULL
    ),
    DEFINE_KSPROPERTY_SET
    (
         &KSPROPSETID_Stream,
         SIZEOF_ARRAY(PinPropertyTableStream),
         PinPropertyTableStream,
         0,
         NULL
    )
};

DEFINE_KSEVENT_TABLE(ConnectionEventTable) {
    DEFINE_KSEVENT_ITEM
    (
        KSEVENT_CONNECTION_ENDOFSTREAM,
        sizeof(KSEVENTDATA),
        0,
        NULL,
        NULL, 
        NULL
    )
};

KSEVENT_SET EventTable_PinDMus[] =
{
    DEFINE_KSEVENT_SET
    (
        &KSEVENTSETID_Connection,
        SIZEOF_ARRAY(ConnectionEventTable),
        ConnectionEventTable
    )
};

/*****************************************************************************
 * Factory functions.
 */

#pragma code_seg("PAGE")
/*****************************************************************************
 * CreatePortPinDMus()
 *****************************************************************************
 * Creates a DirectMusic port driver pin.
 */
NTSTATUS
CreatePortPinDMus
(
    OUT     PUNKNOWN *  Unknown,
    IN      REFCLSID,
    IN      PUNKNOWN    UnknownOuter    OPTIONAL,
    IN      POOL_TYPE   PoolType
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_LIFETIME,("Creating DMUS Pin"));
    ASSERT(Unknown);

    STD_CREATE_BODY_
    (
        CPortPinDMus,
        Unknown,
        UnknownOuter,
        PoolType,
        PPORTPINDMUS
    );
}


/*****************************************************************************
 * Functions.
 */

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortPinDMus::~CPortPinDMus()
 *****************************************************************************
 * Destructor.
 */
CPortPinDMus::~CPortPinDMus()
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_LIFETIME,("Destroying DMUS Pin (0x%08x)",this));

    ASSERT(!m_WaveClockFileObject);
    ASSERT(!m_WaveBuffer);
    ASSERT(!m_SynthSink);
    ASSERT(!m_MiniportMXF);
    ASSERT(!m_IrpStream);
    ASSERT(!m_ServiceGroup);

    if (m_Worker)
    {
        KsUnregisterWorker(m_Worker);
        m_Worker = NULL;
    }
    else
    {
        _DbgPrintF(DEBUGLVL_TERSE,("KsWorker NULL, never unregistered!"));
    }

    if (m_DataFormat)
    {
        ::ExFreePool(m_DataFormat);
        m_DataFormat = NULL;
    }
    if (m_Port)
    {
        m_Port->Release();
        m_Port = NULL;
    }

    if (m_Filter)
    {
        m_Filter->Release();
        m_Filter = NULL;
    }

#ifdef kAdjustingTimerRes
    ULONG   returnVal = ExSetTimerResolution(kDMusTimerResolution100ns,FALSE);   // 100 nanoseconds
    _DbgPrintF( DEBUGLVL_VERBOSE, ("*** Cleared timer resolution request (is now %d.%04d ms) ***",returnVal/10000,returnVal%10000));
#endif  //  kAdjustingTimerRes
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortPinDMus::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.
 */
STDMETHODIMP_(NTSTATUS)
CPortPinDMus::
NonDelegatingQueryInterface
(
    REFIID  Interface,
    PVOID * Object
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB,("CPortPinDMus::NonDelegatingQueryInterface"));
    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface,IID_IUnknown))
    {
        *Object = PVOID(PPORTPINDMUS(this));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IIrpTarget))
    {
        // Cheat!  Get specific interface so we can reuse the IID.
        *Object = PVOID(PPORTPINDMUS(this));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IIrpStreamNotify))
    {
        *Object = PVOID(PIRPSTREAMNOTIFY(this));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IKsShellTransport))
    {
        *Object = PVOID(PIKSSHELLTRANSPORT(this));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IKsWorkSink))
    {
        *Object = PVOID(PIKSWORKSINK(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER_2;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortPinDMus::Init()
 *****************************************************************************
 * Initializes the object.
 */
STDMETHODIMP_(NTSTATUS)
CPortPinDMus::
Init
(
    IN      CPortDMus *             Port_,
    IN      CPortFilterDMus *       Filter_,
    IN      PKSPIN_CONNECT          PinConnect,
    IN      PKSPIN_DESCRIPTOR       PinDescriptor
)
{
    PAGED_CODE();

    ASSERT(Port_);
    ASSERT(Port_->m_pSubdeviceDescriptor);
    ASSERT(Filter_);
    ASSERT(PinConnect);
    ASSERT(PinDescriptor);

    _DbgPrintF(DEBUGLVL_LIFETIME,("Initializing DMUS Pin (0x%08x)",this));

    //
    // Hold references to ancestors objects.
    //
    m_Port = Port_;
    m_Port->AddRef();

    m_Filter = Filter_;
    m_Filter->AddRef();

    //
    // Squirrel away some things.
    //
    m_Id                    = PinConnect->PinId;
    m_Descriptor            = PinDescriptor;
    m_DeviceState           = KSSTATE_STOP;
    m_TransportState        = KSSTATE_STOP;
    m_MXFGraphState         = KSSTATE_STOP;
    m_Flushing              = FALSE;
    m_Suspended             = FALSE;
    m_DataFlow              = PinDescriptor->DataFlow;
    m_LastDPCWasIncomplete  = FALSE;
    m_SubmittedBytePosition = 0;
    m_CompletedBytePosition = 0;
    m_MiniportMidiStream    = NULL;
    m_FeederInMXF           = NULL;
    m_FeederOutMXF          = NULL;

    InitializeListHead( &m_EventList );
    KeInitializeSpinLock( &m_EventLock );
    
    KsInitializeWorkSinkItem(&m_WorkItem,this);
    NTSTATUS ntStatus = KsRegisterCountedWorker(DelayedWorkQueue,&m_WorkItem,&m_Worker);
    if (!NT_SUCCESS(ntStatus))
    {
        _DbgPrintF(DEBUGLVL_TERSE,("KsRegisterCountedWorker failed in Init"));
    }

    InitializeInterlockedListHead(&m_IrpsToSend);
    InitializeInterlockedListHead(&m_IrpsOutstanding);

    m_FrameSize = 0;
    m_WaveBuffer = NULL;
    m_SynthSink = NULL;
    m_WaveClockFileObject = NULL;
    m_DataFormat = NULL;
    m_DirectMusicPin = FALSE;
    m_SubmittedPresTime100ns = 0;

    //
    // Keep a copy of the format.
    //
    if (NT_SUCCESS(ntStatus))
    {
        ntStatus = PcCaptureFormat( &m_DataFormat,
                PKSDATAFORMAT(PinConnect + 1),
                m_Port->m_pSubdeviceDescriptor,
                                    m_Id );
        if (!NT_SUCCESS(ntStatus))
        {
            _DbgPrintF(DEBUGLVL_TERSE,("PcCaptureFormat failed in Init"));
        }
    }

    ASSERT(m_DataFormat || !NT_SUCCESS(ntStatus));

    if (NT_SUCCESS(ntStatus))
    {
        if (IsEqualGUIDAligned(m_DataFormat->MajorFormat, KSDATAFORMAT_TYPE_MUSIC))
        {
            m_StreamType = m_DataFlow == KSPIN_DATAFLOW_OUT ? DMUS_STREAM_MIDI_CAPTURE : DMUS_STREAM_MIDI_RENDER;
            m_DirectMusicPin = (BOOLEAN) IsEqualGUIDAligned(m_DataFormat->SubFormat, KSDATAFORMAT_SUBTYPE_DIRECTMUSIC);
        }
        else if (IsEqualGUIDAligned(m_DataFormat->MajorFormat, KSDATAFORMAT_TYPE_AUDIO))
        {
            m_StreamType = m_DataFlow == KSPIN_DATAFLOW_OUT ? DMUS_STREAM_WAVE_SINK : DMUS_STREAM_MIDI_INVALID;

            if (m_StreamType == DMUS_STREAM_WAVE_SINK)
            {
                if (IsEqualGUIDAligned
                    (   m_DataFormat->SubFormat,
                        KSDATAFORMAT_SUBTYPE_PCM
                    )
                    &&  IsEqualGUIDAligned
                    (   m_DataFormat->Specifier,
                        KSDATAFORMAT_SPECIFIER_WAVEFORMATEX
                    ))
                {
                    m_BlockAlign = PKSDATAFORMAT_WAVEFORMATEX(m_DataFormat)->WaveFormatEx.nBlockAlign;
                    m_FrameSize = (PKSDATAFORMAT_WAVEFORMATEX(m_DataFormat)->WaveFormatEx.nSamplesPerSec * 
                                   m_BlockAlign) / FRAMES_PER_SEC;

                    _DbgPrintF(DEBUGLVL_VERBOSE,("wave sink SamplesPerSec:%lu",
                                                 PKSDATAFORMAT_WAVEFORMATEX(m_DataFormat)->WaveFormatEx.nSamplesPerSec));

                    m_WaveBuffer = new(NonPagedPool,'mDcP') BYTE[m_FrameSize];
                    if (NULL == m_WaveBuffer)
                    {
                        _DbgPrintF(DEBUGLVL_TERSE,("Could not allocate memory for m_WaveBuffer"));
                        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }
                else
                {
                    _DbgPrintF(DEBUGLVL_TERSE,("MINIPORT BUG:  Wave sink format not recognized."));
                    ntStatus = STATUS_UNSUCCESSFUL;
                }
            }
        }
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE,("MINIPORT BUG:  Format not supported."));
            ntStatus = STATUS_UNSUCCESSFUL;
            m_StreamType = DMUS_STREAM_MIDI_INVALID;
        }
    }

    // REVIEW: frame size for music source?
    //
    // Reference the next pin if this is a source.  This must be undone if
    // this function fails.
    //
    if (NT_SUCCESS(ntStatus) && PinConnect->PinToHandle)
    {
        ntStatus = ObReferenceObjectByHandle( PinConnect->PinToHandle,
                                 GENERIC_READ | GENERIC_WRITE,
                                 NULL,
                                 KernelMode,
                                 (PVOID *) &m_ConnectionFileObject,
                                 NULL);
        if (NT_SUCCESS(ntStatus))
        {
            m_ConnectionDeviceObject = IoGetRelatedDeviceObject(m_ConnectionFileObject);
        } 
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE,("ObReferenceObjectByHandle failed in Init"));
        }

        if (m_ConnectionDeviceObject && m_StreamType == DMUS_STREAM_WAVE_SINK)
        {
            KSCLOCK_CREATE ClockCreate;
            HANDLE ClockHandle;

            RtlZeroMemory(&ClockCreate, sizeof(ClockCreate));

            ntStatus = KsCreateClock(PinConnect->PinToHandle,
                                     &ClockCreate,
                                     &ClockHandle);
            if (NT_SUCCESS(ntStatus))
            {
                ntStatus = ObReferenceObjectByHandle(ClockHandle,
                                                     FILE_READ_DATA | SYNCHRONIZE,
                                                     NULL,
                                                     ExGetPreviousMode(), 
                                                     (PVOID *)&m_WaveClockFileObject,
                                                     NULL );
                if (!NT_SUCCESS(ntStatus))
                {
                    _DbgPrintF(DEBUGLVL_TERSE,("ObReferenceObjectByHandle for wave clock failed:%x",ntStatus));
                    _DbgPrintF(DEBUGLVL_TERSE,("*** Using stream demand for PLL ***"));
                    ntStatus = STATUS_SUCCESS;
                }
                ZwClose(ClockHandle);
            }
            else
            {
                _DbgPrintF(DEBUGLVL_TERSE,("KsCreateClock on wave sink failed:%x",ntStatus));
                _DbgPrintF(DEBUGLVL_TERSE,("*** Using stream demand for PLL ***"));
                ntStatus = STATUS_SUCCESS;
            }
        }
    }

    //
    // Create an IrpStream to handling incoming streaming IRPs.
    //
    if (NT_SUCCESS(ntStatus))
    {
        ntStatus = PcNewIrpStreamVirtual( &m_IrpStream,
                NULL,
                m_DataFlow == KSPIN_DATAFLOW_IN,
                PinConnect,
                m_Port->m_DeviceObject );

        if (!NT_SUCCESS(ntStatus))
        {
            _DbgPrintF(DEBUGLVL_TERSE,("PcNewIrpStreamVirtual failed in Init"));
        }

        ASSERT(m_IrpStream || !NT_SUCCESS(ntStatus));
    }

    if (NT_SUCCESS(ntStatus))
    {
        ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
        
        if (m_StreamType != DMUS_STREAM_WAVE_SINK)
        {
            ntStatus = CreateMXFs();
            if (!NT_SUCCESS(ntStatus))
            {
                _DbgPrintF(DEBUGLVL_TERSE,("CreateMXFs failed in Init"));
            }
        }
    }

    if( NT_SUCCESS(ntStatus) )
    {
        ntStatus = BuildTransportCircuit();
    
        if (! NT_SUCCESS(ntStatus))
        {
            _DbgPrintF(DEBUGLVL_TERSE,("BuildTransportCircuit() returned status 0x%08x",ntStatus));
        }
    }

    //
    // Register a notification sink with the IrpStream for IRP arrivals.
    //
    if (NT_SUCCESS(ntStatus))
    {
        m_IrpStream->RegisterNotifySink(PIRPSTREAMNOTIFY(this));
    }

    //
    // Create the miniport stream object.
    //
    ULONGLONG SchedulePreFetch = 0;
    if (NT_SUCCESS(ntStatus))
    {
        if (m_Port->m_MiniportMidi)
        {
            // If we are connected to MiniportMidi, set m_MiniportMXF accordingly.
            // Note that FeederIn and FeederOut will simulate IMiniportDMus 
            // for port and IPortMidi for MiniportMidi.
            // 
            ntStatus = m_Port->m_MiniportMidi->NewStream( &m_MiniportMidiStream,
                                                          NULL,
                                                          NonPagedPool,
                                                          m_Id,
                                                          m_StreamType,
                                                          m_DataFormat,
                                                          &(m_ServiceGroup) );
            if (NT_SUCCESS(ntStatus))
            {
                if (m_StreamType == DMUS_STREAM_MIDI_RENDER)
                {
                    ntStatus = m_FeederOutMXF->QueryInterface(IID_IMXF, (PVOID *) &m_MiniportMXF);
                    if (NT_SUCCESS(ntStatus))
                    {
                        m_FeederOutMXF->SetMiniportStream(m_MiniportMidiStream);
                    }
                }
                else if (m_StreamType == DMUS_STREAM_MIDI_CAPTURE)
                {
                    ntStatus = m_FeederInMXF->QueryInterface(IID_IMXF, (PVOID *) &m_MiniportMXF);
                    if (NT_SUCCESS(ntStatus))
                    {
                        m_FeederInMXF->SetMiniportStream(m_MiniportMidiStream);
                    }
                }
            }
        }
        else
        {
            ntStatus = m_Port->m_Miniport->NewStream( &m_MiniportMXF,
                                                      NULL,
                                                      NonPagedPool,
                                                      m_Id,
                                                      m_StreamType,
                                                      m_DataFormat,
                                                      &(m_ServiceGroup),
                                                      (PAllocatorMXF)m_AllocatorMXF,
                                                      (PMASTERCLOCK)this->m_Port,
                                                      &SchedulePreFetch );
        }

        if (!NT_SUCCESS(ntStatus))
        {
            // unregister the notification sink
            m_IrpStream->RegisterNotifySink(NULL);

            // don't trust the miniport return values
            m_ServiceGroup = NULL;
            m_MiniportMXF = NULL;
            m_MiniportMidiStream = NULL;

            _DbgPrintF(DEBUGLVL_TERSE,("NewStream failed in Init"));
        }
    }

    if (NT_SUCCESS(ntStatus) && m_StreamType != DMUS_STREAM_WAVE_SINK)
    {
        // Set the stream latency and create the graph
        //
        if (m_DataFlow == KSPIN_DATAFLOW_IN)
        {
            m_SequencerMXF->SetSchedulePreFetch(SchedulePreFetch);
        }

        ntStatus = ConnectMXFGraph();
        if (!NT_SUCCESS(ntStatus))
        {
            _DbgPrintF(DEBUGLVL_TERSE,("ConnectMXFGraph failed in Init"));
        }
    }
    //
    // Verify that the miniport has supplied us with the objects we require.
    //
    if (NT_SUCCESS(ntStatus) && ! m_MiniportMXF)
    {
        if (!m_MiniportMXF)
        {
            _DbgPrintF(DEBUGLVL_TERSE,("MINIPORT BUG:  Successful stream instantiation yielded NULL stream."));
            ntStatus = STATUS_UNSUCCESSFUL;
        }

        if (  m_StreamType == DMUS_STREAM_MIDI_CAPTURE 
           && !(m_ServiceGroup))
        {
            _DbgPrintF(DEBUGLVL_TERSE,("MINIPORT BUG:  Capture stream did not supply service group."));
            ntStatus = STATUS_UNSUCCESSFUL;
        }
    }

    if (  NT_SUCCESS(ntStatus) 
       && m_StreamType == DMUS_STREAM_MIDI_CAPTURE
       && !(m_ServiceGroup))
    {
        _DbgPrintF(DEBUGLVL_TERSE,("MINIPORT BUG:  Capture stream did not supply service group."));
        ntStatus = STATUS_UNSUCCESSFUL;
    }

    if (  NT_SUCCESS(ntStatus) 
       && m_StreamType == DMUS_STREAM_WAVE_SINK)
    {
        m_SamplePosition = 0;

        ntStatus = m_MiniportMXF->QueryInterface(IID_ISynthSinkDMus,(PVOID *) &m_SynthSink);

        if (!NT_SUCCESS(ntStatus))
        {
            _DbgPrintF(DEBUGLVL_TERSE,("MINIPORT BUG:  Stream does not support ISynthSinkDMus interface."));
        }
    }

    if (NT_SUCCESS(ntStatus) && (m_StreamType != DMUS_STREAM_MIDI_CAPTURE))
    {
        KeInitializeDpc
        (
            &m_Dpc,
            &::DMusTimerDPC,
            PVOID(this)
        );

        KeInitializeTimer(&m_TimerEvent);
    }

    if (NT_SUCCESS(ntStatus))
    {
        if (m_ServiceGroup)
        {
            m_ServiceGroup->AddMember(PSERVICESINK(this));
        }

        for (m_Index = 0; m_Index < MAX_PINS; m_Index++)
        {
            if (! m_Port->m_Pins[m_Index])
            {
                m_Port->m_Pins[m_Index] = this;
                if (m_Port->m_PinEntriesUsed <= m_Index)
                {
                    m_Port->m_PinEntriesUsed = m_Index + 1;
                }
                break;
            }
        }
        
        KeInitializeSpinLock(&m_DpcSpinLock);

       _DbgPrintF( DEBUGLVL_BLAB, ("Stream created"));

        //
        // Set up context for properties.
        //
        m_propertyContext.pSubdevice           = PSUBDEVICE(m_Port);
        m_propertyContext.pSubdeviceDescriptor = m_Port->m_pSubdeviceDescriptor;
        m_propertyContext.pPcFilterDescriptor  = m_Port->m_pPcFilterDescriptor;
        m_propertyContext.pUnknownMajorTarget  = m_Port->m_Miniport;
        m_propertyContext.ulNodeId             = ULONG(-1);        
        
        //
        // MinorTarget should always point to Stream. 
        // For DMUSIC miniports m_MiniportMXF is Stream.
        // For legacy miniports m_MiniportMXF is FeederMXF.
        //
        if (m_Port->m_MiniportMidi)
        {
            m_propertyContext.pUnknownMinorTarget  = m_MiniportMidiStream;
        }
        else
        {
            m_propertyContext.pUnknownMinorTarget  = m_MiniportMXF;
        }

#ifdef kAdjustingTimerRes
        ULONG returnVal = ExSetTimerResolution(kDMusTimerResolution100ns,TRUE);   // 100 nanoseconds
        _DbgPrintF( DEBUGLVL_TERSE, ("*** Set timer resolution request (is now %d.%04d ms) ***",returnVal/10000,returnVal%10000));
#endif  //  kAdjustingTimerRes

    }
    else
    {
        // dereference next pin if this is a source pin
        if( m_ConnectionFileObject )
        {
            ObDereferenceObject( m_ConnectionFileObject );
            m_ConnectionFileObject = NULL;
        }
        
        // dereference the clock if there is one
        if (m_WaveClockFileObject) 
        {
            ObDereferenceObject(m_WaveClockFileObject);
            m_WaveClockFileObject = NULL;
        }

        // dereference the synth sink
        ULONG ulRefCount;       
        if (m_SynthSink)
        {
            ulRefCount = m_SynthSink->Release();
            ASSERT(ulRefCount == 0);
            m_SynthSink = NULL;
        }

        // dereference the wave buffer if there is one
        if (m_WaveBuffer)
        {
            delete m_WaveBuffer;
            m_WaveBuffer = NULL;
        }
        
        (void) DeleteMXFGraph (); //WinSE 20812

        // dereference the miniportMXF
        if (m_MiniportMXF)
        {
            ulRefCount = m_MiniportMXF->Release();
            _DbgPrintF(DEBUGLVL_BLAB,("RefCount from stream->Release in Init == %d",ulRefCount));
            m_MiniportMXF = NULL;
        }

        if (m_MiniportMidiStream)
        {
            m_MiniportMidiStream->Release();
            m_MiniportMidiStream = NULL;
        }

        PIKSSHELLTRANSPORT distribution;
        if( m_RequestorTransport )
        {
            distribution = m_RequestorTransport;
        } 
        else
        {
            distribution = m_QueueTransport;
        }

        if( distribution )
        {
            distribution->AddRef();
            while( distribution )
            {
                PIKSSHELLTRANSPORT nextTransport;
                distribution->Connect(NULL,&nextTransport,KSPIN_DATAFLOW_OUT);
                distribution->Release();
                distribution = nextTransport;
            }
        }

        // dereference the queue if there is one
        if( m_QueueTransport )
        {
            m_QueueTransport->Release();
            m_QueueTransport = NULL;
        }

        // dereference the requestor if there is one
        if( m_RequestorTransport )
        {
            m_RequestorTransport->Release();
            m_RequestorTransport = NULL;
        }

        if (m_IrpStream)
        {
            m_IrpStream->Release();
            m_IrpStream = NULL;
        }

        _DbgPrintF( DEBUGLVL_TERSE, ("Could not create new Stream. Error:%X", ntStatus));
    }

    return ntStatus;
}

#pragma code_seg("PAGE")
NTSTATUS 
CPortPinDMus::CreateMXFs()
{
    PAGED_CODE();

    NTSTATUS ntStatus = STATUS_SUCCESS;
    PMASTERCLOCK Clock = (PMASTERCLOCK)this->m_Port;
    PPOSITIONNOTIFY PositionNotify = (PPOSITIONNOTIFY) this;
    
    (void) DeleteMXFGraph();

    m_AllocatorMXF = new(NonPagedPool,'mDcP') CAllocatorMXF(PositionNotify);
    if (!m_AllocatorMXF)
    {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        m_AllocatorMXF->AddRef();
        if (m_StreamType == DMUS_STREAM_MIDI_RENDER) 
        {   
            m_SequencerMXF = new(NonPagedPool,'mDcP') CSequencerMXF(m_AllocatorMXF,Clock);
            if (!m_SequencerMXF)
            {
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
            else
            {
                if (IsEqualGUIDAligned(m_DataFormat->SubFormat, KSDATAFORMAT_SUBTYPE_DIRECTMUSIC))
                {
                    m_UnpackerMXF = new(NonPagedPool,'mDcP') CDMusUnpackerMXF(m_AllocatorMXF,Clock);
                    if (!m_UnpackerMXF)
                    {   
                        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }
                else if (IsEqualGUIDAligned(m_DataFormat->SubFormat, KSDATAFORMAT_SUBTYPE_MIDI))
                {
                    m_UnpackerMXF = new(NonPagedPool,'mDcP') CKsUnpackerMXF(m_AllocatorMXF,Clock);
                    if (!m_UnpackerMXF)
                    {   
                        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }
                else
                {
                    _DbgPrintF( DEBUGLVL_TERSE, ("Got unknown subformat in CreateMXF's") );
                    ntStatus = STATUS_UNSUCCESSFUL;
                }

                // If MiniportMidi is connected, create FeederOut.
                //
                if (NT_SUCCESS(ntStatus) && m_Port->m_MiniportMidi)
                {
                    m_FeederOutMXF = new(NonPagedPool, 'mDcP') CFeederOutMXF(m_AllocatorMXF, Clock);
                    if (!m_FeederOutMXF)
                    {
                        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                    }
                    else
                    {
                        m_FeederOutMXF->AddRef();
                    }
                }
            }
        }
        else if (m_StreamType == DMUS_STREAM_MIDI_CAPTURE)
        {   //  capture
            // If MiniportMidi is connected, create FeederIn.
            //
            if (m_Port->m_MiniportMidi)
            {
                m_FeederInMXF = new(NonPagedPool, 'mDcP') CFeederInMXF(m_AllocatorMXF, Clock);
                if (!m_FeederInMXF)
                {
                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                }
                else
                {
                    m_FeederInMXF->AddRef();
                }
            }

            if (NT_SUCCESS(ntStatus))
            {
                m_CaptureSinkMXF = new(NonPagedPool,'mDcP') CCaptureSinkMXF(m_AllocatorMXF,Clock);
                if (!m_CaptureSinkMXF)
                {
                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                }
                else
                {
                    if (IsEqualGUIDAligned(m_DataFormat->SubFormat, KSDATAFORMAT_SUBTYPE_DIRECTMUSIC))
                    {
                        m_PackerMXF = new(NonPagedPool,'mDcP') CDMusPackerMXF(m_AllocatorMXF,m_IrpStream,Clock);
                        if (!m_PackerMXF)
                        {
                            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                        }
                    }
                    else if (IsEqualGUIDAligned(m_DataFormat->SubFormat, KSDATAFORMAT_SUBTYPE_MIDI))
                    {
                        m_PackerMXF = new(NonPagedPool,'mDcP') CKsPackerMXF(m_AllocatorMXF,m_IrpStream,Clock);
                        if (!m_PackerMXF)
                        {   
                            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                        }
                    }
                    else
                    {
                        _DbgPrintF( DEBUGLVL_TERSE, ("Got unknown subformat in CreateMXF's") );
                        ntStatus = STATUS_UNSUCCESSFUL;
                    }
                }
            }
        }
        else
        {
            // This should never happen.
            ASSERT(0);
            ntStatus = STATUS_UNSUCCESSFUL;
        }
    }

    if (!NT_SUCCESS(ntStatus))
    {
        (void) DeleteMXFGraph();
    }
    return ntStatus;
}

#pragma code_seg("PAGE")
NTSTATUS 
CPortPinDMus::ConnectMXFGraph()
{
    PAGED_CODE();

    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;
    
    if (m_AllocatorMXF && m_MiniportMXF)
    {
        if (m_StreamType == DMUS_STREAM_MIDI_RENDER) 
        {   //  render
            if (m_UnpackerMXF && m_SequencerMXF)
            {
                if (NT_SUCCESS(m_SequencerMXF->ConnectOutput(m_MiniportMXF)))
                {
                    if (NT_SUCCESS(m_UnpackerMXF->ConnectOutput(m_SequencerMXF)))
                    {
                        ntStatus = STATUS_SUCCESS;
                    }
                }
            }
        }
        else if (m_StreamType == DMUS_STREAM_MIDI_CAPTURE)
        {   //  capture
            if (m_CaptureSinkMXF && m_PackerMXF)
            {
                if (NT_SUCCESS(m_CaptureSinkMXF->ConnectOutput(m_PackerMXF)))
                {
                    if (NT_SUCCESS(m_MiniportMXF->ConnectOutput(m_CaptureSinkMXF)))
                    {
                        ntStatus = STATUS_SUCCESS;
                    }
                }
            }
        }
    }
    if (!(NT_SUCCESS(ntStatus)))
    {
        (void) DeleteMXFGraph();
    }
    return ntStatus;
}

#pragma code_seg("PAGE")
NTSTATUS
CPortPinDMus::DeleteMXFGraph()
{
    PAGED_CODE();
    
    if (m_MXFGraphState != KSSTATE_STOP)
    {
        (void) SetMXFGraphState(KSSTATE_STOP);
    }
    if (m_StreamType == DMUS_STREAM_MIDI_RENDER)
    {
        if (m_UnpackerMXF)
        {
            (void) m_UnpackerMXF->DisconnectOutput(m_SequencerMXF);
            delete m_UnpackerMXF;
            m_UnpackerMXF = NULL;
        }
        if (m_SequencerMXF)
        {
            (void) m_SequencerMXF->DisconnectOutput(m_MiniportMXF);
            delete m_SequencerMXF;
            m_SequencerMXF = NULL;
        }
        if (m_FeederOutMXF)
        {
            (void) m_FeederOutMXF->Release();
            m_FeederOutMXF = NULL;
        }
    }
    if (m_StreamType == DMUS_STREAM_MIDI_CAPTURE)
    {
        if (m_MiniportMXF)
        {
            (void) m_MiniportMXF->DisconnectOutput(m_CaptureSinkMXF);
        }
        if (m_CaptureSinkMXF)
        {
            (void) m_CaptureSinkMXF->DisconnectOutput(m_PackerMXF);
            delete m_CaptureSinkMXF;
            m_CaptureSinkMXF = NULL;
        }
        if (m_PackerMXF)
        {
            delete m_PackerMXF;
            m_PackerMXF = NULL;
        }
        
        // FeederInMXF (if exists) is disconnected in MiniportMXF
        // disconnect call. Remember that MiniportMXF is a pointer to 
        // FeederInMXF.
        //
        if (m_FeederInMXF)
        {
            m_FeederInMXF->Release();
            m_FeederInMXF = NULL;
        }
    }
    if (m_AllocatorMXF)
    {
        m_AllocatorMXF->Release();
        m_AllocatorMXF = NULL;
    }
    
    return STATUS_SUCCESS;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortPinDMus::SetMXFGraphState()
 *****************************************************************************
 * Set the MXF graph to a new state.
 *
 * We need to keep track of whether we are going up
 * in state or down, because that determines whether
 * to make the transitions from the bottom up or 
 * vice versa.
 */
STDMETHODIMP_(NTSTATUS) CPortPinDMus::SetMXFGraphState(KSSTATE NewState)
{
    ASSERT(DMUS_STREAM_WAVE_SINK != m_StreamType);
    ASSERT(NewState != m_MXFGraphState);

    BOOL    stateIncreasing;
    stateIncreasing = (  (NewState == KSSTATE_RUN)
                      || ((NewState == KSSTATE_PAUSE) && (m_MXFGraphState != KSSTATE_RUN))
                      || ((NewState == KSSTATE_ACQUIRE) && (m_MXFGraphState == KSSTATE_STOP))
                      || (m_MXFGraphState == KSSTATE_STOP));

    if (m_StreamType == DMUS_STREAM_MIDI_RENDER) 
    {   //  render
        ASSERT(m_UnpackerMXF && m_SequencerMXF);
        if (stateIncreasing)
        {
            if (m_UnpackerMXF)
            {
                (void) m_UnpackerMXF->SetState(NewState);
            }
            if (m_SequencerMXF)
            {
                (void) m_SequencerMXF->SetState(NewState);
            }
            if (m_MiniportMXF)
            {
                (void) m_MiniportMXF->SetState(NewState);
            }
        }
        else
        {
            if (m_MiniportMXF)
            {
                (void) m_MiniportMXF->SetState(NewState);
            }
            if (m_SequencerMXF)
            {
                (void) m_SequencerMXF->SetState(NewState);
            }
            if (m_UnpackerMXF)
            {
                (void) m_UnpackerMXF->SetState(NewState);
            }
        }
    }
    else if (m_StreamType == DMUS_STREAM_MIDI_CAPTURE)
    {   //  capture
        ASSERT(m_CaptureSinkMXF && m_PackerMXF);
        if (stateIncreasing)
        {
            if (m_PackerMXF)
            {
                (void) m_PackerMXF->SetState(NewState);
            }
            if (m_CaptureSinkMXF)
            {
                (void) m_CaptureSinkMXF->SetState(NewState);
            }
            if (m_MiniportMXF)
            {
                (void) m_MiniportMXF->SetState(NewState);
            }
        }
        else
        {
            if (m_MiniportMXF)
            {
                (void) m_MiniportMXF->SetState(NewState);
            }
            if (m_CaptureSinkMXF)
            {
                (void) m_CaptureSinkMXF->SetState(NewState);
            }
            if (m_PackerMXF)
            {
                (void) m_PackerMXF->SetState(NewState);
            }
        }
    }

    m_MXFGraphState = NewState;
    return STATUS_SUCCESS;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortPinDMus::DeviceIoControl()
 *****************************************************************************
 * Handles an IOCTL IRP.
 */
STDMETHODIMP_(NTSTATUS)
CPortPinDMus::
DeviceIoControl
(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
)
{
    PAGED_CODE();
    
    ASSERT(DeviceObject);
    ASSERT(Irp);

    NTSTATUS            ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    ASSERT(irpSp);

    _DbgPrintF( DEBUGLVL_BLAB, ("DeviceIoControl"));

    switch (irpSp->Parameters.DeviceIoControl.IoControlCode)
    {
    case IOCTL_KS_PROPERTY:
        _DbgPrintF( DEBUGLVL_BLAB, ("IOCTL_KS_PROPERTY"));

        ntStatus =
            PcHandlePropertyWithTable
            (
                Irp,
                m_Port->m_pSubdeviceDescriptor->PinPropertyTables[m_Id].PropertySetCount,
                m_Port->m_pSubdeviceDescriptor->PinPropertyTables[m_Id].PropertySets,
                &m_propertyContext
            );
        break;

    case IOCTL_KS_ENABLE_EVENT:
        {
            _DbgPrintF( DEBUGLVL_BLAB, ("IOCTL_KS_ENABLE_EVENT"));

            EVENT_CONTEXT EventContext;

            EventContext.pPropertyContext = &m_propertyContext;
            EventContext.pEventList = NULL;
            EventContext.ulPinId = m_Id;
            EventContext.ulEventSetCount = m_Port->m_pSubdeviceDescriptor->PinEventTables[m_Id].EventSetCount;
            EventContext.pEventSets = m_Port->m_pSubdeviceDescriptor->PinEventTables[m_Id].EventSets;

            ntStatus =
                PcHandleEnableEventWithTable
                (
                    Irp,
                    &EventContext
                );
        }              
        break;

    case IOCTL_KS_DISABLE_EVENT:
        {
            _DbgPrintF( DEBUGLVL_BLAB, ("IOCTL_KS_DISABLE_EVENT"));

            EVENT_CONTEXT EventContext;

            EventContext.pPropertyContext = &m_propertyContext;
            EventContext.pEventList = &(m_Port->m_EventList);
            EventContext.ulPinId = m_Id;
            EventContext.ulEventSetCount = m_Port->m_pSubdeviceDescriptor->PinEventTables[m_Id].EventSetCount;
            EventContext.pEventSets = m_Port->m_pSubdeviceDescriptor->PinEventTables[m_Id].EventSets;
            
            ntStatus =
                PcHandleDisableEventWithTable
                (
                    Irp,
                    &EventContext
                );
        }              
        break;

    case IOCTL_KS_WRITE_STREAM:
    case IOCTL_KS_READ_STREAM:
            _DbgPrintF( DEBUGLVL_BLAB, ("IOCTL_KS_PACKETSTREAM"));

            if
                 (   m_TransportSink
                     && (! m_ConnectionFileObject)
                     &&  (m_Descriptor->Communication == KSPIN_COMMUNICATION_SINK)
                     &&  (   (   (m_DataFlow == KSPIN_DATAFLOW_IN)
                                 &&  (   irpSp->Parameters.DeviceIoControl.IoControlCode
                                         ==  IOCTL_KS_WRITE_STREAM
                                     )
                             )
                             ||  (   (m_DataFlow == KSPIN_DATAFLOW_OUT)
                                     &&  (   irpSp->Parameters.DeviceIoControl.IoControlCode
                                             ==  IOCTL_KS_READ_STREAM
                                         )
                                 )
                         )
                 )
            {
                if (m_DeviceState == KSSTATE_STOP)
                {
                    //
                    // Stopped...reject.
                    //
                    ntStatus = STATUS_INVALID_DEVICE_STATE;
                } 
                else if (m_Flushing)
                {
                    //
                    // Flushing...reject.
                    //
                    ntStatus = STATUS_DEVICE_NOT_READY;
                } 
                else
                {
                    // We going to submit the IRP to our pipe, so make sure that
                    // we start out with a clear status field.
                    Irp->IoStatus.Status = STATUS_SUCCESS;
                    //
                    // Send around the circuit.  We don't use KsShellTransferKsIrp
                    // because we want to stop if we come back around to this pin.
                    //
                    PIKSSHELLTRANSPORT transport = m_TransportSink;
                    while (transport)
                    {
                        if (transport == PIKSSHELLTRANSPORT(this))
                        {
                            //
                            // We have come back around to the pin.  Just complete
                            // the IRP.
                            //
                            if (ntStatus == STATUS_PENDING)
                            {
                                ntStatus = STATUS_SUCCESS;
                            }
                            break;
                        }

                        PIKSSHELLTRANSPORT nextTransport;
                        ntStatus = transport->TransferKsIrp(Irp,&nextTransport);

                        ASSERT(NT_SUCCESS(ntStatus) || ! nextTransport);

                        transport = nextTransport;
                    }
                }
            }
        break;
        
    case IOCTL_KS_RESET_STATE:
        {
            KSRESET ResetType = KSRESET_BEGIN;  //  initial value

            ntStatus = KsAcquireResetValue( Irp, &ResetType );
            DistributeResetState(ResetType);
        }
        break;
        
    default:
        return KsDefaultDeviceIoCompletion(DeviceObject, Irp);
    }

    if (ntStatus != STATUS_PENDING)
    {
        Irp->IoStatus.Status = ntStatus;
        IoCompleteRequest(Irp,IO_NO_INCREMENT);
    }

    return ntStatus;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortPinDMus::Close()
 *****************************************************************************
 * Handles a flush IRP.
 */
STDMETHODIMP_(NTSTATUS)
CPortPinDMus::
Close
(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
)
{
    PAGED_CODE();

    ASSERT(DeviceObject);
    ASSERT(Irp);

    _DbgPrintF( DEBUGLVL_BLAB, ("Close"));

    // !!! WARNING !!!
    // The order that these objects are
    // being released is VERY important!
    // All data used by the service routine
    // must exists until AFTER the stream
    // has been released.
    
    // remove this pin from the list of pins
    // that need servicing...
    if ( m_Port )
    {
        m_Port->m_Pins[m_Index] = NULL;
        while(  (m_Port->m_PinEntriesUsed != 0)
            &&  !m_Port->m_Pins[m_Port->m_PinEntriesUsed - 1])
        {
            m_Port->m_PinEntriesUsed--;
        }
        // Servicing be gone!
        if( m_ServiceGroup )
        {
            m_ServiceGroup->RemoveMember(PSERVICESINK(this));
            m_ServiceGroup->Release();
            m_ServiceGroup = NULL;
        }
    }

    //
    // Dereference next pin if this is a source pin.
    //
    if (m_ConnectionFileObject)
    {
        ObDereferenceObject(m_ConnectionFileObject);
        m_ConnectionFileObject = NULL;
    }

    if (m_WaveClockFileObject) 
    {
        ObDereferenceObject(m_WaveClockFileObject);
        m_WaveClockFileObject = NULL;
    }
    if (m_SynthSink)
    {
        m_SynthSink->Release();
        m_SynthSink = NULL;
    }
    if (m_WaveBuffer)
    {
        delete m_WaveBuffer;
        m_WaveBuffer = NULL;
    }

    // ISSUE-2001/03/20-alpers BLACKCOMB
    // MiniportMXF is FeederMXF for Midi miniports.
    // We are releasing this up-front to deal with RefCount issues.
    // This is not an elegant solution. For Blackcomb we should
    // make this better.
    if (m_MiniportMXF && m_MiniportMidiStream)
    {
        m_MiniportMXF->Release();
        m_MiniportMXF = NULL;
    }

    if (m_StreamType != DMUS_STREAM_WAVE_SINK)
    {
        (void) DeleteMXFGraph();
    }

    // Tell the miniport to close the stream.
    if (m_MiniportMXF)
    {
        ULONG ulRefCount = m_MiniportMXF->Release();
        _DbgPrintF(DEBUGLVL_BLAB,("RefCount from stream->Release in Close == %d",ulRefCount));
        m_MiniportMXF = NULL;
    }

    // Tell the midi miniport to close the stream.
    if (m_MiniportMidiStream)
    {
        m_MiniportMidiStream->Release();
        m_MiniportMidiStream = NULL;
    }
    
    PIKSSHELLTRANSPORT distribution;
    if (m_RequestorTransport)
    {
        //
        // This section owns the requestor, so it does own the pipe, and the
        // requestor is the starting point for any distribution.
        //
        distribution = m_RequestorTransport;
    } 
    else
    {
        //
        // This section is at the top of an open circuit, so it does own the
        // pipe and the queue is the starting point for any distribution.
        //
        distribution = m_QueueTransport;
    }

    //
    // If this section owns the pipe, it must disconnect the entire circuit.
    //
    if (distribution)
    {

        //
        // We are going to use Connect() to set the transport sink for each
        // component in turn to NULL.  Because Connect() takes care of the
        // back links, transport source pointers for each component will
        // also get set to NULL.  Connect() gives us a referenced pointer
        // to the previous transport sink for the component in question, so
        // we will need to do a release for each pointer obtained in this
        // way.  For consistency's sake, we will release the pointer we
        // start with (distribution) as well, so we need to AddRef it first.
        //
        distribution->AddRef();
        while (distribution)
        {
            PIKSSHELLTRANSPORT nextTransport;
            distribution->Connect(NULL,&nextTransport,KSPIN_DATAFLOW_OUT);
            distribution->Release();
            distribution = nextTransport;
        }
    }

    //
    // Dereference the queue if there is one.
    //
    if (m_QueueTransport)
    {
        m_QueueTransport->Release();
        m_QueueTransport = NULL;
    }

    //
    // Dereference the requestor if there is one.
    //
    if (m_RequestorTransport)
    {
        m_RequestorTransport->Release();
        m_RequestorTransport = NULL;
    }
    
    // Kill all the outstanding irps...
    ASSERT(m_IrpStream);
    if (m_IrpStream)
    {
        ASSERT(m_SubmittedBytePosition >= m_CompletedBytePosition);
        if ( (m_StreamType == DMUS_STREAM_MIDI_RENDER)
          && (m_SubmittedBytePosition != m_CompletedBytePosition))
        {
            ULONG   returnVal;
            m_IrpStream->Complete(ULONG(m_SubmittedBytePosition - m_CompletedBytePosition),
                                  &returnVal);
            m_CompletedBytePosition += returnVal;
            ASSERT(m_SubmittedBytePosition == m_CompletedBytePosition);
        }
        // Destroy the irpstream...
        m_IrpStream->Release();
        m_IrpStream = NULL;
    }

    //
    // Decrement instances counts.
    //
    ASSERT(m_Port);
    ASSERT(m_Filter);
    PcTerminateConnection( m_Port->m_pSubdeviceDescriptor,
                           m_Filter->m_propertyContext.pulPinInstanceCounts,
                           m_Id );

    //
    // free any events in the port event list associated with this pin
    //
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
    KsFreeEventList( irpSp->FileObject,
                     &( m_Port->m_EventList.List ),
                     KSEVENTS_SPINLOCK,
                     &( m_Port->m_EventList.ListLock) );

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp,IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}

DEFINE_INVALID_CREATE(CPortPinDMus);
DEFINE_INVALID_WRITE(CPortPinDMus);
DEFINE_INVALID_READ(CPortPinDMus);
DEFINE_INVALID_FLUSH(CPortPinDMus);
DEFINE_INVALID_QUERYSECURITY(CPortPinDMus);
DEFINE_INVALID_SETSECURITY(CPortPinDMus);
DEFINE_INVALID_FASTDEVICEIOCONTROL(CPortPinDMus);
DEFINE_INVALID_FASTREAD(CPortPinDMus);
DEFINE_INVALID_FASTWRITE(CPortPinDMus);

#pragma code_seg()
/*****************************************************************************
 * CPortPinDMus::IrpSubmitted()
 *****************************************************************************
 * IrpSubmitted - Called by IrpStream when a new irp
 * is submited into the irpStream. (probably from DeviceIoControl).
 * If there is not a timer pending, do work on the new Irp.
 * If there is a timer pending, do nothing.
 */
STDMETHODIMP_(void)
CPortPinDMus::
IrpSubmitted
(
    IN      PIRP        /* pIrp */,
    IN      BOOLEAN     /* WasExhausted */
)
{
    _DbgPrintF(DEBUGLVL_BLAB,("IrpSubmitted"));
    if (m_DeviceState == KSSTATE_RUN)
    {
        if (m_ServiceGroup) //  assume capture
        {
            //  Using a service group...just notify the port.
            //
            m_Port->Notify(m_ServiceGroup);
        }
        else if (m_StreamType != DMUS_STREAM_WAVE_SINK)
        {
            //
            // Using a timer...set it off.
            //
            ASSERT(m_StreamType != DMUS_STREAM_MIDI_CAPTURE);
            LARGE_INTEGER timeDue100ns;
            timeDue100ns.QuadPart = 0;
            KeSetTimer(&m_TimerEvent,timeDue100ns,&m_Dpc);
        }
    }
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortPinDMus::SyncToMaster
 *****************************************************************************
 * 
 */
NTSTATUS
CPortPinDMus::SyncToMaster
(
    IN  BOOL    fStart
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB,("SyncToMaster"));
    ASSERT(PKSDATAFORMAT_WAVEFORMATEX(m_DataFormat)->WaveFormatEx.nSamplesPerSec);

    NTSTATUS ntStatus = STATUS_SUCCESS;

    if (m_WaveClockFileObject)
    {
        KSPROPERTY Property;
        LONGLONG llWaveTime;
        ULONG BytesReturned;

        Property.Set   = KSPROPSETID_Clock;
        Property.Id    = KSPROPERTY_CLOCK_TIME;
        Property.Flags = KSPROPERTY_TYPE_GET;

        ntStatus = KsSynchronousIoControlDevice(m_WaveClockFileObject,
                                                KernelMode,
                                                IOCTL_KS_PROPERTY,
                                                &Property,
                                                sizeof(Property),
                                                &llWaveTime,
                                                sizeof(llWaveTime),
                                                &BytesReturned);
        if (NT_SUCCESS(ntStatus))
        {
            m_SynthSink->SyncToMaster(llWaveTime, fStart);
        }
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE,("KsSynchronousIoControlDevice on wave clock failed:%x",ntStatus));
            ObDereferenceObject(m_WaveClockFileObject);
            m_WaveClockFileObject = NULL;
#if 1
            _DbgPrintF(DEBUGLVL_TERSE,("*** Using stream demand for PLL ***"));
            ntStatus = STATUS_SUCCESS;
            m_SynthSink->SyncToMaster(((m_SamplePosition * 10000) /
                                       PKSDATAFORMAT_WAVEFORMATEX(m_DataFormat)->WaveFormatEx.nSamplesPerSec) * 1000,
                                       TRUE);
#endif
        }
    }
    else
    {
        m_SynthSink->SyncToMaster(((m_SamplePosition * 10000) /
                                   PKSDATAFORMAT_WAVEFORMATEX(m_DataFormat)->WaveFormatEx.nSamplesPerSec) * 1000,
                                   fStart);
    }

    return ntStatus;
}

#pragma code_seg("PAGE")
/*
 * SynthSink helpers
 */
inline
LONGLONG
CPortPinDMus::
SampleToByte
(
    LONGLONG llSamples
)
{
    return llSamples * m_BlockAlign;
}

inline
LONGLONG
CPortPinDMus::
ByteToSample
(
    LONGLONG llBytes
)
{
    return m_BlockAlign ? (llBytes / m_BlockAlign) : 0;
}

inline
LONGLONG
CPortPinDMus::
SampleAlign
(
    LONGLONG llBytes
)
{
    return llBytes - (llBytes % m_BlockAlign);
}

/*****************************************************************************
 * CPortPinDMus::SynthSinkWorker
 *****************************************************************************
 * 
 */
void
CPortPinDMus::SynthSinkWorker(void)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB,("SynthSinkWorker"));
    ASSERT(m_WaveBuffer);
    ASSERT(m_SynthSink);
    ASSERT(m_IrpStream);

    // REVIEW: acquire spin lock?

    SyncToMaster(FALSE);

    RtlZeroMemory(PVOID(m_WaveBuffer), m_FrameSize);
    m_SynthSink->Render(m_WaveBuffer, DWORD(ByteToSample(m_FrameSize)), m_SamplePosition);

    ULONG ulActualSize = 0;

    m_IrpStream->Copy
    (
        FALSE,          // WriteOperation
        m_FrameSize,    // RequestedSize
        &ulActualSize,
        m_WaveBuffer
    );

    if (ulActualSize)
    {
        m_IrpStream->Complete(ulActualSize, &ulActualSize);

        m_SamplePosition += ByteToSample(ulActualSize);

        ASSERT(ulActualSize == SampleAlign(ulActualSize));
    }
}

#pragma code_seg()
/*****************************************************************************
 * CPortPinDMus::ServiceRenderIRP()
 *****************************************************************************
 * An IRP has arrived.  Take it and feed it to the unpacker.
 * We assume that this routine is protected by the DPC spinlock.
 * We assume m_IrpStream is valid.  
 *
 * (Both assumptions validated by ServeRender(), the caller)
 */
void
CPortPinDMus::ServiceRenderIRP(void)
{
    IRPSTREAMPACKETINFO irpStreamPacketInfo;   
    KSTIME  *pKSTime;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    while (TRUE)
    {
        //  get the timebase from this IRP's stream_header
        (void) m_IrpStream->GetPacketInfo(&irpStreamPacketInfo,NULL);
        
        //  if invalid time, use previous one
        if (IrpStreamHasValidTimeBase(&irpStreamPacketInfo))
        {
            if (irpStreamPacketInfo.CurrentOffset == 0)    //  if first packet in IRP
            {
                pKSTime = &(irpStreamPacketInfo.Header.PresentationTime);
                //  #units * freq (i.e. * #100ns/units) to get #100ns
                m_SubmittedPresTime100ns = (pKSTime->Time * pKSTime->Numerator) / pKSTime->Denominator;
            }
        }
        
        ULONG   bytesToConsume = 0;
        PBYTE   pIrpData = 0;
        //  grab data out of the IrpStream
        m_IrpStream->GetLockedRegion(&bytesToConsume,(PVOID *)&pIrpData);

        //  if no data in IrpStream, leave
        if (!bytesToConsume)
        {
            break;
        }
        ASSERT(pIrpData);
        //  feed this IRP to the unpacker
        if (m_UnpackerMXF)
        {
             m_UnpackerMXF->SinkIRP(
                 pIrpData, 
                 bytesToConsume,
                 m_SubmittedPresTime100ns,
                 m_SubmittedBytePosition);
            //
            //  release and complete the locked region
            m_IrpStream->ReleaseLockedRegion(bytesToConsume);
            m_SubmittedBytePosition += bytesToConsume;

            (void) m_UnpackerMXF->ProcessQueues();
        }
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE,("ServiceRenderIRP:No UnpackerMXF"));
            //
            //  release and complete the locked region
            m_IrpStream->ReleaseLockedRegion(bytesToConsume);
            m_SubmittedBytePosition += bytesToConsume;
        }
    }   //  until GetLockedRegion comes up dry
}

#pragma code_seg()
/*****************************************************************************
 * CPortPinDMus::PositionNotify()
 *****************************************************************************
 * Called to notify of position changes.
 * Usually called by the allocator to facilitate timely IRP completion.
 */
STDMETHODIMP_(void)
CPortPinDMus::PositionNotify(ULONGLONG bytePosition)
{
    ULONG   bytesToComplete;
    ASSERT(bytePosition);
    ASSERT(bytePosition != kBytePositionNone);

    _DbgPrintF(DEBUGLVL_VERBOSE,("PositionNotify(0x%I64X)",bytePosition));
    _DbgPrintF(DEBUGLVL_VERBOSE,("PositionNotify: Submitted: 0x%I64X, Completed: 0x%I64X",
                                             m_SubmittedBytePosition, m_CompletedBytePosition));

    if (bytePosition > m_CompletedBytePosition)
    {
        ASSERT((bytePosition - m_CompletedBytePosition) < 0x0FFFFFFFF);
        bytesToComplete = (ULONG)(bytePosition - m_CompletedBytePosition);

        _DbgPrintF(DEBUGLVL_VERBOSE,("PositionNotify, bytesToComplete: 0x%x",bytesToComplete));

        m_CompletedBytePosition += bytesToComplete; //  even if IrpStream doesn't complete it all, we advance the pos
        m_IrpStream->Complete(bytesToComplete,&bytesToComplete);
//        ASSERT(ULONG(bytePosition - m_CompletedBytePosition) == bytesToComplete); //  might be starvation

        _DbgPrintF(DEBUGLVL_VERBOSE,("PositionNotify, bytesToComplete returned as: 0x%x",bytesToComplete));
        _DbgPrintF(DEBUGLVL_VERBOSE,("Notified - Completed: 0x%x",
                                    ULONG(bytePosition - m_CompletedBytePosition)));
        _DbgPrintF(DEBUGLVL_VERBOSE,("PositionNotify, completed 0x%x, new Completed: 0x%I64X",bytesToComplete,m_CompletedBytePosition));
    }
    else
    {
        _DbgPrintF(DEBUGLVL_VERBOSE,("PositionNotify, m_CompletedBytePosition > bytePosition; doing nothing"));
    }
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortPinDMus::PowerNotify()
 *****************************************************************************
 * Called by the port to notify of power state changes.
 */
STDMETHODIMP_(void)
CPortPinDMus::
PowerNotify
(   
    IN  POWER_STATE     PowerState
)
{
    PAGED_CODE();

    // grap the control mutex
    KeWaitForSingleObject( &m_Port->m_ControlMutex,
                           Executive,
                           KernelMode,
                           FALSE,
                           NULL );

    // do the right thing based on power state
    switch (PowerState.DeviceState)
    {
        case PowerDeviceD0:
            //
            // keep track of whether or not we're suspended
            m_Suspended = FALSE;

            // if we're not in the right state, change the miniport stream state.
            if( m_DeviceState != m_CommandedState )
            {
                //
                // Transitions go through the intermediate states.
                //
                if (m_DeviceState == KSSTATE_STOP)               //  going to stop
                {
                    switch (m_CommandedState)
                    {
                        case KSSTATE_RUN:                           //  going from run
                            m_MiniportMXF->SetState(KSSTATE_PAUSE); //  fall thru - additional transitions
                        case KSSTATE_PAUSE:                         //  going from run/pause
                            m_MiniportMXF->SetState(KSSTATE_ACQUIRE); //  fall thru - additional transitions
                        case KSSTATE_ACQUIRE:                       //  already only one state away
                            break;
                    }
                }
                else if (m_DeviceState == KSSTATE_ACQUIRE)          //  going to acquire
                {
                    if (m_CommandedState == KSSTATE_RUN)            //  going from run
                    {
                        m_MiniportMXF->SetState(KSSTATE_PAUSE);     //  now only one state away
                    }
                }
                else if (m_DeviceState == KSSTATE_PAUSE)            //  going to pause
                {
                    if (m_CommandedState == KSSTATE_STOP)           //  going from stop
                    {
                        m_MiniportMXF->SetState(KSSTATE_ACQUIRE);   //  now only one state away
                    }
                }
                else if (m_DeviceState == KSSTATE_RUN)              //  going to run
                {
                    switch (m_CommandedState)
                    {
                        case KSSTATE_STOP:                          //  going from stop
                            m_MiniportMXF->SetState(KSSTATE_ACQUIRE); //  fall thru - additional transitions
                        case KSSTATE_ACQUIRE:                       //  going from acquire
                            m_MiniportMXF->SetState(KSSTATE_PAUSE); //  fall thru - additional transitions
                        case KSSTATE_PAUSE:                         //  already only one state away
                            break;         
                    }
                }

                // we should now be one state away from our target
                m_MiniportMXF->SetState(m_DeviceState);
                m_CommandedState = m_DeviceState;
             }
            break;

        case PowerDeviceD1:
        case PowerDeviceD2:
        case PowerDeviceD3:
            //
            // keep track of whether or not we're suspended
            m_Suspended = TRUE;

            // if we're higher than KSSTATE_ACQUIRE, place miniportMXF
            // in that state so clocks are stopped (but not reset).
            switch (m_DeviceState)
            {
                case KSSTATE_RUN:
                    m_MiniportMXF->SetState(KSSTATE_PAUSE);    //  fall thru - additional transitions
                case KSSTATE_PAUSE:
                    m_MiniportMXF->SetState(KSSTATE_ACQUIRE);  //  fall thru - additional transitions
                m_CommandedState = KSSTATE_ACQUIRE;
            }
            break;

        default:
            _DbgPrintF(DEBUGLVL_TERSE,("Unknown Power State"));
            break;
    }

    // release the control mutex
    KeReleaseMutex(&m_Port->m_ControlMutex, FALSE);
}

#pragma code_seg()
/*****************************************************************************
 * CPortPinDMus::IrpStreamHasValidTimeBase()
 *****************************************************************************
 * Check whether this is a valid IRP.
 */
BOOL
CPortPinDMus::
IrpStreamHasValidTimeBase
(   PIRPSTREAMPACKETINFO pIrpStreamPacketInfo
)
{
    if (!pIrpStreamPacketInfo->Header.PresentationTime.Denominator)
        return FALSE;
    if (!pIrpStreamPacketInfo->Header.PresentationTime.Numerator)
        return FALSE;

    return TRUE;
}

#pragma code_seg("PAGE")

STDMETHODIMP_(NTSTATUS)
CPortPinDMus::
SetDeviceState(
              IN KSSTATE NewState,
              IN KSSTATE OldState,
              OUT PIKSSHELLTRANSPORT* NextTransport
              )

/*++

Routine Description:

    This routine handles notification that the device state has changed.

Arguments:

Return Value:

--*/

{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB,("#### Pin%p.SetDeviceState:  from %d to %d",this,OldState,NewState));

    ASSERT(NextTransport);

    NTSTATUS ntStatus = STATUS_SUCCESS;

    if (m_StreamType != DMUS_STREAM_MIDI_CAPTURE)
    {
        KeCancelTimer(&m_TimerEvent);
    }

    if (m_TransportState != NewState)
    {
        m_TransportState = NewState;

        // grab the control mutex
        KeWaitForSingleObject( &m_Port->m_ControlMutex,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );

        if (NewState > OldState)
        {
            *NextTransport = m_TransportSink;
        }
        else
        {
            *NextTransport = m_TransportSource;
        }

        if (DMUS_STREAM_WAVE_SINK != m_StreamType)
        {
            // set the MXF graph state if we're not suspended.
            if (FALSE == m_Suspended)
            {
                SetMXFGraphState(NewState);
            }
        }
        m_CommandedState = NewState;
        

        if (NT_SUCCESS(ntStatus))
        {
            switch(NewState)
            {
                case KSSTATE_STOP:
                    _DbgPrintF(DEBUGLVL_BLAB,("KSSTATE_STOP"));    

                    ASSERT(m_SubmittedBytePosition >= m_CompletedBytePosition);
                    if ( (m_StreamType == DMUS_STREAM_MIDI_RENDER)
                      && (m_SubmittedBytePosition != m_CompletedBytePosition))
                    {
                        ULONG   returnVal;
                        m_IrpStream->Complete(ULONG(m_SubmittedBytePosition - m_CompletedBytePosition),
                                              &returnVal);
                        m_CompletedBytePosition = m_SubmittedBytePosition;
                    }
                    _DbgPrintF(DEBUGLVL_BLAB,("#### Pin%p.SetDeviceState:  cancelling outstanding IRPs",this));
                    CancelIrpsOutstanding();

                    break;

                case KSSTATE_ACQUIRE:
                    _DbgPrintF(DEBUGLVL_BLAB,("KSSTATE_ACQUIRE"));
                    if ((m_DataFlow == KSPIN_DATAFLOW_OUT)
                        && (OldState == KSSTATE_PAUSE)
                        && (m_CaptureSinkMXF))
                    {
                        FlushCaptureSink();
                    }
                    break;

                case KSSTATE_PAUSE:
                    _DbgPrintF(DEBUGLVL_BLAB,("KSSTATE_PAUSE"));
                    break;

                case KSSTATE_RUN:
                    _DbgPrintF(DEBUGLVL_BLAB,("KSSTATE_RUN"));
        
                    if ((m_DataFlow == KSPIN_DATAFLOW_OUT) && m_PackerMXF)
                    {                                       // if RUN->PAUSE->RUN
                        NTSTATUS ntStatusDbg = m_PackerMXF->MarkStreamHeaderContinuity();       //  Going back into RUN, mark continuous.

                        if (STATUS_SUCCESS != ntStatusDbg)
                        {
                            _DbgPrintF(DEBUGLVL_TERSE,("SetDeviceState: MarkStreamHeaderContinuity failed 0x%08x",ntStatusDbg));
                        }
                    }
        
                    if (m_ServiceGroup && m_Port)           //  Using service group...notify the port.
                    {
                        m_Port->Notify(m_ServiceGroup);
                    }
                    else                                    //  Using a timer...set it off.
                    {
                        ASSERT(m_StreamType != DMUS_STREAM_MIDI_CAPTURE);
                        m_DeviceState = NewState;            //  Set the state before DPC fires

                        if (m_StreamType == DMUS_STREAM_WAVE_SINK)
                        {
                            m_SamplePosition = 0;

                            ntStatus = SyncToMaster(TRUE);

                            if (NT_SUCCESS(ntStatus))
                            {
                                for (int iFrame = 0; iFrame < FRAME_COUNT; iFrame++)
                                {
                                    SynthSinkWorker();
                                }
                            }
                        }
                        else
                        {
                            LARGE_INTEGER timeDue100ns;
                            timeDue100ns.QuadPart = 0;

                            KeSetTimer(&m_TimerEvent,timeDue100ns,&m_Dpc);
                        }
                    }
                    break;
            }

            if (NT_SUCCESS(ntStatus))
            {
                m_DeviceState = NewState;
            }
        }
        // release the control mutex
        KeReleaseMutex(&m_Port->m_ControlMutex, FALSE);
    }

    return ntStatus;
}

#pragma code_seg()
/*****************************************************************************
 * FlushCaptureSink()
 *****************************************************************************
 * Flush the capture sink.  Should be called from Dispatch level.
 */
void CPortPinDMus::FlushCaptureSink(void)
{
    ASSERT(m_CaptureSinkMXF);
    KIRQL oldIrql;
    KeAcquireSpinLock(&m_DpcSpinLock,&oldIrql);
    (void) m_CaptureSinkMXF->Flush();   //  Flush, exit SysEx state.
    KeReleaseSpinLock(&m_DpcSpinLock,oldIrql);
}

#pragma code_seg()
/*****************************************************************************
 * GetPosition()
 *****************************************************************************
 * Gets the current position.
 */
STDMETHODIMP_(NTSTATUS)
CPortPinDMus::
GetPosition
(   IN OUT  PIRPSTREAM_POSITION pIrpStreamPosition
)
{
    return STATUS_SUCCESS;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * PinPropertyDeviceState()
 *****************************************************************************
 * Handles device state property access for the pin.
 */
static
NTSTATUS
PinPropertyDeviceState
(
    IN      PIRP        Irp,
    IN      PKSPROPERTY Property,
    IN OUT  PKSSTATE    DeviceState
)
{
    PAGED_CODE();
    
    ASSERT(Irp);
    ASSERT(Property);
    ASSERT(DeviceState);

    CPortPinDMus *that =
        (CPortPinDMus *) KsoGetIrpTargetFromIrp(Irp);
    if (!that)
    {
        return STATUS_UNSUCCESSFUL;
    }
    CPortDMus *port = that->m_Port;

    NTSTATUS ntStatus;

    if (Property->Flags & KSPROPERTY_TYPE_GET)  // Handle get property.
    {
        _DbgPrintF(DEBUGLVL_BLAB,("PinPropertyDeviceState get %d",that->m_DeviceState));
        *DeviceState = that->m_DeviceState;
        Irp->IoStatus.Information = sizeof(KSSTATE);
        return STATUS_SUCCESS;
    }

    if (*DeviceState != that->m_DeviceState)      // If change in set property.
    {
        _DbgPrintF(DEBUGLVL_BLAB,("PinPropertyDeviceState set from %d to %d",that->m_DeviceState,*DeviceState));
        
        // Serialize.
        KeWaitForSingleObject
        (
            &port->m_ControlMutex,
            Executive,
            KernelMode,
            FALSE,              // Not alertable.
            NULL
        );

        that->m_CommandedState = *DeviceState;

        if (*DeviceState < that->m_DeviceState)
        {
            KSSTATE oldState = that->m_DeviceState;
            that->m_DeviceState = *DeviceState;
            ntStatus = that->DistributeDeviceState(*DeviceState,oldState);
            if (! NT_SUCCESS(ntStatus))
            {
                that->m_DeviceState = oldState;
            }
        }
        else
        {
            ntStatus = that->DistributeDeviceState(*DeviceState,that->m_DeviceState);
            if (NT_SUCCESS(ntStatus))
            {
                that->m_DeviceState = *DeviceState;
            }
        }

        KeReleaseMutex(&port->m_ControlMutex,FALSE);

        return ntStatus;
    }
    //  No change in set property.
    return STATUS_SUCCESS;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * PinPropertyDataFormat()
 *****************************************************************************
 * Handles data format property access for the pin.
 */
static
NTSTATUS
PinPropertyDataFormat
(
    IN      PIRP            Irp,
    IN      PKSPROPERTY     Property,
    IN OUT  PKSDATAFORMAT   DataFormat
)
{
    PAGED_CODE();

    ASSERT(Irp);
    ASSERT(Property);
    ASSERT(DataFormat);

    _DbgPrintF( DEBUGLVL_BLAB, ("PinPropertyDataFormat"));

    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    ASSERT(irpSp);
    CPortPinDMus *that =
        (CPortPinDMus *) KsoGetIrpTargetFromIrp(Irp);
    CPortDMus *port = that->m_Port;

    NTSTATUS ntStatus = STATUS_SUCCESS;

    if (Property->Flags & KSPROPERTY_TYPE_GET)
    {
        if (that->m_DataFormat)
        {
            if  (   !irpSp->Parameters.DeviceIoControl.OutputBufferLength
                )
            {
                Irp->IoStatus.Information = that->m_DataFormat->FormatSize;
                ntStatus = STATUS_BUFFER_OVERFLOW;
            }
            else
            if  (   irpSp->Parameters.DeviceIoControl.OutputBufferLength
                >=  that->m_DataFormat->FormatSize
                )
            {
                RtlCopyMemory(DataFormat,that->m_DataFormat,
                              that->m_DataFormat->FormatSize);
                Irp->IoStatus.Information = that->m_DataFormat->FormatSize;
            }
            else
            {
                ntStatus = STATUS_BUFFER_TOO_SMALL;
            }
        }
        else
        {
            ntStatus = STATUS_UNSUCCESSFUL;
        }
    }
    else
    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(*DataFormat))
    {
        ntStatus = STATUS_BUFFER_TOO_SMALL;
    }
    else
    {
        PKSDATAFORMAT FilteredDataFormat = NULL;

        ntStatus = PcCaptureFormat(&FilteredDataFormat,
                                    DataFormat,
                                    port->m_pSubdeviceDescriptor,
                                    that->m_Id);

        if (NT_SUCCESS(ntStatus))
        {
//            ntStatus = that->m_MiniportMXF->SetFormat(DataFormat);

            ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
            if (NT_SUCCESS(ntStatus))
            {
                if (that->m_DataFormat)
                {
                    ::ExFreePool(that->m_DataFormat);
                }

                that->m_DataFormat = FilteredDataFormat;
            }
            else
            {
                ::ExFreePool(FilteredDataFormat);
            }
        }
    }

    return ntStatus;
}

#pragma code_seg()
/*****************************************************************************
 * DMusTimerDPC()
 *****************************************************************************
 * The timer DPC callback. Thunks to a C++ member function.
 * This is called by the OS in response to the DirectMusic pin
 * wanting to wakeup later to process more DirectMusic stuff.
 */
VOID 
NTAPI
DMusTimerDPC
(
    IN  PKDPC   Dpc,
    IN  PVOID   DeferredContext,
    IN  PVOID   SystemArgument1,
    IN  PVOID   SystemArgument2
)
{
    ASSERT(DeferredContext);

    _DbgPrintF(DEBUGLVL_BLAB,("DMusTimerDPC"));
    (void) ((CPortPinDMus*) DeferredContext)->RequestService();    //  ignores return value!
}

#pragma code_seg()
/*****************************************************************************
 * CPortPinDMus::RequestService()
 *****************************************************************************
 * Service the pin in a DPC.
 */
STDMETHODIMP_(void)
CPortPinDMus::
RequestService
(   void
)
{
    _DbgPrintF(DEBUGLVL_BLAB,("CPortPinDMus:RequestService"));

    if (m_StreamType == DMUS_STREAM_MIDI_RENDER)
        ServeRender();
    else if (m_StreamType == DMUS_STREAM_MIDI_CAPTURE)
        ServeCapture();
}

#pragma code_seg()
/*****************************************************************************
 * CPortPinDMus::ServeRender()
 *****************************************************************************
 * Service the render pin in a DPC.
 *
 * Called to do the sequencing and output of midi data.
 * This function checks the time-stamp of the outgoing data.
 * If it's more than (kDMusTimerResolution100ns) in the future it queues
 * a timer (the timer just calls this function back).
 * If the data is less than (kDMusTimerResolution100ns) in the future, it 
 * sends it to the miniport, and works on the next chunk of data until:
 * 1) no more data, or 
 * 2) it hits data more than (kDMusTimerResolution100ns) in the future.
 * TODO: Make kDMusTimerResolution100ns adjustable via the control panel?
 */
void
CPortPinDMus::
ServeRender
(   void
)
{
    _DbgPrintF(DEBUGLVL_BLAB,("CPortPinDMus:ServeRender"));

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    if (!m_IrpStream)   //  don't even waste our time -- no data source
    {
        return;
    }
    KeAcquireSpinLockAtDpcLevel(&m_DpcSpinLock);

    ServiceRenderIRP();

    KeReleaseSpinLockFromDpcLevel(&m_DpcSpinLock);
}


/*
                    MIDI Capture

    This work is done by the PackerMXF object.

*/

#pragma code_seg()
 /*****************************************************************************
 * CPortPinDMus::ServeCapture()
 *****************************************************************************
 * Service the capture pin in a DPC, because an IRP has been submitted.
 */
void
CPortPinDMus::
ServeCapture
(   void
)
{
    _DbgPrintF(DEBUGLVL_BLAB,("CPortPinDMus:ServeCapture"));

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    if (!m_IrpStream)   //  don't even waste our time -- no data source
    {
        return;
    }

    KeAcquireSpinLockAtDpcLevel(&m_DpcSpinLock);

    //
    //  This triggers the stream to call PutMessage
    //
    if (m_MiniportMXF)
    {
        (void) m_MiniportMXF->PutMessage(NULL);
    }

    if (m_PackerMXF)
    {
        (void) m_PackerMXF->ProcessQueues();    //  if any leftovers, clean them out now.
    }
    
    KeReleaseSpinLockFromDpcLevel(&m_DpcSpinLock);
}

#pragma code_seg("PAGE")
 /*****************************************************************************
 * CPortPinDMus::PinPropertyStreamMasterClock()
 *****************************************************************************
 * Set the given file object as the clock for this pin
 */
NTSTATUS
CPortPinDMus::
PinPropertyStreamMasterClock(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN OUT PHANDLE ClockHandle
    )
{
    PAGED_CODE();
    return STATUS_SUCCESS;
}

#pragma code_seg()
STDMETHODIMP_(NTSTATUS) CPortPinDMus::TransferKsIrp(IN PIRP Irp,OUT PIKSSHELLTRANSPORT* NextTransport)
/*++

Routine Description:

    This routine handles the arrival of a streaming IRP via the shell 
    transport.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("TransferKsIrp"));

    ASSERT(NextTransport);

    NTSTATUS status;

    if (m_ConnectionFileObject)
    {
        //
        // Source pin.
        //
        if (m_Flushing || (m_TransportState == KSSTATE_STOP))
        {
            //
            // Shunt IRPs to the next component if we are reset or stopped.
            //
            *NextTransport = m_TransportSink;
        }
        else
        {
            //
            // Send the IRP to the next device.
            //
            KsAddIrpToCancelableQueue(
                                     &m_IrpsToSend.ListEntry,
                                     &m_IrpsToSend.SpinLock,
                                     Irp,
                                     KsListEntryTail,
                                     NULL);

            KsIncrementCountedWorker(m_Worker);
            *NextTransport = NULL;
        }

        status = STATUS_PENDING;
    }
    else
    {
        //
        // Sink pin:  complete the IRP.
        //
        PKSSTREAM_HEADER StreamHeader = PKSSTREAM_HEADER( Irp->AssociatedIrp.SystemBuffer );

        PIO_STACK_LOCATION irpSp =  IoGetCurrentIrpStackLocation( Irp );

        if (irpSp->Parameters.DeviceIoControl.IoControlCode ==
            IOCTL_KS_WRITE_STREAM)
        {
            ASSERT( StreamHeader );

            //
            // Signal end-of-stream event for the renderer.
            //
#if 0
            if (StreamHeader->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM)
            {

                GenerateEndOfStreamEvents();
            }
#endif
        }

        IoCompleteRequest(Irp,IO_NO_INCREMENT);
        *NextTransport = NULL;

        status = STATUS_PENDING;
    }

    return status;
}

#pragma code_seg("PAGE")


NTSTATUS 
CPortPinDMus::
DistributeDeviceState(
                     IN KSSTATE NewState,
                     IN KSSTATE OldState
                     )

/*++

Routine Description:

    This routine sets the state of the pipe, informing all components in the
    pipe of the new state.  A transition to stop state destroys the pipe.

Arguments:

    NewState -
        The new state.

Return Value:

    Status.

--*/

{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB,("DistributeDeviceState(%p)",this));

    KSSTATE state = OldState;
    KSSTATE targetState = NewState;

    NTSTATUS status = STATUS_SUCCESS;

    //
    // Determine if this pipe section controls the entire pipe.
    //
    PIKSSHELLTRANSPORT distribution;
    if (m_RequestorTransport)
    {
        //
        // This section owns the requestor, so it does own the pipe, and the
        // requestor is the starting point for any distribution.
        //
        distribution = m_RequestorTransport;
    }
    else
    {
        //
        // This section is at the top of an open circuit, so it does own the
        // pipe and the queue is the starting point for any distribution.
        //
        distribution = m_QueueTransport;
    }

    //
    // Proceed sequentially through states.
    //
    while (state != targetState)
    {
        KSSTATE oldState = state;

        if (ULONG(state) < ULONG(targetState))
        {
            state = KSSTATE(ULONG(state) + 1);
        }
        else
        {
            state = KSSTATE(ULONG(state) - 1);
        }

        NTSTATUS statusThisPass = STATUS_SUCCESS;

        //
        // Distribute state changes if this section is in charge.
        //
        if (distribution)
        {
            //
            // Tell everyone about the state change.
            //
            _DbgPrintF(DEBUGLVL_VERBOSE,("(%p)->DistributeDeviceState from %d to %d",this,oldState,state));
            PIKSSHELLTRANSPORT transport = distribution;
            PIKSSHELLTRANSPORT previousTransport = NULL;
            while (transport)
            {
                PIKSSHELLTRANSPORT nextTransport;
                statusThisPass =
                transport->SetDeviceState(state,oldState,&nextTransport);

                ASSERT(NT_SUCCESS(statusThisPass) || ! nextTransport);

                if (NT_SUCCESS(statusThisPass))
                {
                    previousTransport = transport;
                    transport = nextTransport;
                }
                else
                {
                    //
                    // Back out on failure.
                    //
                    _DbgPrintF(DEBUGLVL_TERSE,("#### Pin%p.DistributeDeviceState:  failed transition from %d to %d",this,oldState,state));
                    while (previousTransport)
                    {
                        transport = previousTransport;
                        statusThisPass =
                        transport->SetDeviceState(
                                                 oldState,
                                                 state,
                                                 &previousTransport);

                        ASSERT(
                              NT_SUCCESS(statusThisPass) || 
                              ! previousTransport);
                    }
                    break;
                }
            }
        }

        if (NT_SUCCESS(status) && ! NT_SUCCESS(statusThisPass))
        {
            //
            // First failure:  go back to original state.
            //
            state = oldState;
            targetState = OldState;
            status = statusThisPass;
        }
    }

    return status;
}


void 
CPortPinDMus::
DistributeResetState(
                    IN KSRESET NewState
                    )

/*++

Routine Description:

    This routine informs transport components that the reset state has 
    changed.

Arguments:

    NewState -
        The new reset state.

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("DistributeResetState"));

    PAGED_CODE();

    //
    // If this section of the pipe owns the requestor, or there is a 
    // non-shell pin up the pipe (so there's no bypass), this pipe is
    // in charge of telling all the components about state changes.
    //
    // (Always)

    //
    // Set the state change around the circuit.
    //
    PIKSSHELLTRANSPORT transport =
    m_RequestorTransport ? 
    m_RequestorTransport : 
    m_QueueTransport;

    while (transport)
    {
        transport->SetResetState(NewState,&transport);
    }

    m_ResetState = NewState;
}


STDMETHODIMP_(void)
CPortPinDMus::
Connect(
       IN PIKSSHELLTRANSPORT NewTransport OPTIONAL,
       OUT PIKSSHELLTRANSPORT *OldTransport OPTIONAL,
       IN KSPIN_DATAFLOW DataFlow
       )

/*++

Routine Description:

    This routine establishes a shell transport connection.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("Connect"));

    PAGED_CODE();

    KsShellStandardConnect(
                          NewTransport,
                          OldTransport,
                          DataFlow,
                          PIKSSHELLTRANSPORT(this),
                          &m_TransportSource,
                          &m_TransportSink);
}


STDMETHODIMP_(void)
CPortPinDMus::
SetResetState(
             IN KSRESET ksReset,
             OUT PIKSSHELLTRANSPORT* NextTransport
             )

/*++

Routine Description:

    This routine handles notification that the reset state has changed.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("SetResetState"));

    PAGED_CODE();

    ASSERT(NextTransport);

    if (m_Flushing != (ksReset == KSRESET_BEGIN))
    {
        *NextTransport = m_TransportSink;
        m_Flushing = (ksReset == KSRESET_BEGIN);
        if (m_Flushing)
        {
            CancelIrpsOutstanding();
        }
    }
    else
    {
        *NextTransport = NULL;
    }
}

#if DBG
STDMETHODIMP_(void)
CPortPinDMus::
DbgRollCall(
    IN ULONG MaxNameSize,
    OUT PCHAR Name,
    OUT PIKSSHELLTRANSPORT* NextTransport,
    OUT PIKSSHELLTRANSPORT* PrevTransport
    )

/*++

Routine Description:

    This routine produces a component name and the transport pointers.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("DbgRollCall"));

    PAGED_CODE();

    ASSERT(Name);
    ASSERT(NextTransport);
    ASSERT(PrevTransport);

    ULONG references = AddRef() - 1; Release();

    _snprintf(Name,MaxNameSize,"Pin%p %d (%s) refs=%d",this,m_Id,m_ConnectionFileObject ? "src" : "snk",references);
    *NextTransport = m_TransportSink;
    *PrevTransport = m_TransportSource;
}

static
void
DbgPrintCircuit(
    IN PIKSSHELLTRANSPORT Transport
    )

/*++

Routine Description:

    This routine spews a transport circuit.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("DbgPrintCircuit"));

    PAGED_CODE();

    ASSERT(Transport);

#define MAX_NAME_SIZE 64

    PIKSSHELLTRANSPORT transport = Transport;
    while (transport) 
    {
        CHAR name[MAX_NAME_SIZE + 1];
        PIKSSHELLTRANSPORT next;
        PIKSSHELLTRANSPORT prev;

        transport->DbgRollCall(MAX_NAME_SIZE,name,&next,&prev);
        _DbgPrintF(DEBUGLVL_BLAB,("  %s",name));

        if (prev)
        {
            PIKSSHELLTRANSPORT next2;
            PIKSSHELLTRANSPORT prev2;
            prev->DbgRollCall(MAX_NAME_SIZE,name,&next2,&prev2);
            if (next2 != transport)
            {
                _DbgPrintF(DEBUGLVL_BLAB,(" SOURCE'S(0x%08x) SINK(0x%08x) != THIS(%08x)",prev,next2,transport));
            }
        }
        else
        {
            _DbgPrintF(DEBUGLVL_BLAB,(" NO SOURCE"));
        }

        if (next)
        {
            PIKSSHELLTRANSPORT next2;
            PIKSSHELLTRANSPORT prev2;
            next->DbgRollCall(MAX_NAME_SIZE,name,&next2,&prev2);
            if (prev2 != transport)
            {
                _DbgPrintF(DEBUGLVL_BLAB,(" SINK'S(0x%08x) SOURCE(0x%08x) != THIS(%08x)",next,prev2,transport));
            }
        }
        else
        {
            _DbgPrintF(DEBUGLVL_BLAB,(" NO SINK"));
        }

        _DbgPrintF(DEBUGLVL_BLAB,("\n"));

        transport = next;
        if (transport == Transport)
        {
            break;
        }
    }
}
#endif

STDMETHODIMP_(void)
CPortPinDMus::
Work(
    void
    )

/*++

Routine Description:

    This routine performs work in a worker thread.  In particular, it sends
    IRPs to the connected pin using IoCallDriver().

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("Work"));

    PAGED_CODE();

    //
    // Send all IRPs in the queue.
    //
    do
    {
        PIRP irp =
        KsRemoveIrpFromCancelableQueue(
                                      &m_IrpsToSend.ListEntry,
                                      &m_IrpsToSend.SpinLock,
                                      KsListEntryHead,
                                      KsAcquireAndRemoveOnlySingleItem);

        //
        // Irp's may have been cancelled, but the loop must still run through
        // the reference counting.
        //
        if (irp)
        {
            if (m_Flushing || (m_TransportState == KSSTATE_STOP))
            {
                //
                // Shunt IRPs to the next component if we are reset or stopped.
                //
                KsShellTransferKsIrp(m_TransportSink,irp);
            }
            else
            {
                //
                // Set up the next stack location for the callee.  
                //
                IoCopyCurrentIrpStackLocationToNext(irp);

                PIO_STACK_LOCATION irpSp = IoGetNextIrpStackLocation(irp);

                irpSp->Parameters.DeviceIoControl.IoControlCode =
                    (m_DataFlow == KSPIN_DATAFLOW_OUT) ?
                    IOCTL_KS_WRITE_STREAM : IOCTL_KS_READ_STREAM;
                irpSp->DeviceObject = m_ConnectionDeviceObject;
                irpSp->FileObject = m_ConnectionFileObject;

                //
                // Add the IRP to the list of outstanding IRPs.
                //
                PIRPLIST_ENTRY irpListEntry = IRPLIST_ENTRY_IRP_STORAGE(irp);
                irpListEntry->Irp = irp;
                ExInterlockedInsertTailList(
                                           &m_IrpsOutstanding.ListEntry,
                                           &irpListEntry->ListEntry,
                                           &m_IrpsOutstanding.SpinLock);

                IoSetCompletionRoutine(
                                      irp,
                                      CPortPinDMus::IoCompletionRoutine,
                                      PVOID(this),
                                      TRUE,
                                      TRUE,
                                      TRUE);

                IoCallDriver(m_ConnectionDeviceObject,irp);
            }
        }
    } while (KsDecrementCountedWorker(m_Worker));
}

#pragma code_seg()


NTSTATUS
CPortPinDMus::
IoCompletionRoutine(
                   IN PDEVICE_OBJECT DeviceObject,
                   IN PIRP Irp,
                   IN PVOID Context
                   )

/*++

Routine Description:

    This routine handles the completion of an IRP.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("IoCompletionRoutine 0x%08x",Irp));

    //    ASSERT(DeviceObject);
    ASSERT(Irp);
    ASSERT(Context);

    CPortPinDMus *pin = (CPortPinDMus *) Context;

    //
    // Remove the IRP from the list of IRPs.  Most of the time, it will be at
    // the head of the list, so this is cheaper than it looks.
    //
    KIRQL oldIrql;
    KeAcquireSpinLock(&pin->m_IrpsOutstanding.SpinLock,&oldIrql);
    for (PLIST_ENTRY listEntry = pin->m_IrpsOutstanding.ListEntry.Flink;
        listEntry != &pin->m_IrpsOutstanding.ListEntry;
        listEntry = listEntry->Flink)
    {
        PIRPLIST_ENTRY irpListEntry =
        CONTAINING_RECORD(listEntry,IRPLIST_ENTRY,ListEntry);

        if (irpListEntry->Irp == Irp)
        {
            RemoveEntryList(listEntry);
            break;
        }
    }
    ASSERT(listEntry != &pin->m_IrpsOutstanding.ListEntry);
    KeReleaseSpinLock(&pin->m_IrpsOutstanding.SpinLock,oldIrql);

    if (pin->m_StreamType == DMUS_STREAM_WAVE_SINK)
    {
        if (NT_SUCCESS(Irp->IoStatus.Status))
        {
            pin->SynthSinkWorker();
        }
        else if (Irp->IoStatus.Status == STATUS_CANCELLED)
        {
            _DbgPrintF(DEBUGLVL_VERBOSE,("wave sink IRP cancelled"));
        }
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE,("wave sink IRP status:%x",Irp->IoStatus.Status));
        }
    }

    NTSTATUS status;
    if (pin->m_TransportSink)
    {
        //
        // The transport circuit is up, so we can forward the IRP.
        //
        status = KsShellTransferKsIrp(pin->m_TransportSink,Irp);
    }
    else
    {
        //
        // The transport circuit is down.  This means the IRP came from another
        // filter, and we can just complete this IRP.
        //
        _DbgPrintF(DEBUGLVL_TERSE,("#### Pin%p.IoCompletionRoutine:  got IRP %p with no transport",pin,Irp));
        IoCompleteRequest(Irp,IO_NO_INCREMENT);
        status = STATUS_SUCCESS;
    }

    //
    // Transport objects typically return STATUS_PENDING meaning that the
    // IRP won't go back the way it came.
    //
    if (status == STATUS_PENDING)
    {
        status = STATUS_MORE_PROCESSING_REQUIRED;
    }

    return status;
}

#pragma code_seg("PAGE")

NTSTATUS
CPortPinDMus::
BuildTransportCircuit(
                     void
                     )

/*++

Routine Description:

    This routine initializes a pipe object.  This includes locating all the
    pins associated with the pipe, setting the Pipe and NextPinInPipe pointers
    in the appropriate pin structures, setting all the fields in the pipe
    structure and building the transport circuit for the pipe.  The pipe and
    the associated components are left in acquire state.
    
    The filter's control mutex must be acquired before this function is called.

Arguments:

    Pin -
        Contains a pointer to the pin requesting the creation of the pipe.

Return Value:

    Status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("BuildTransportCircuit"));

    PAGED_CODE();

    BOOLEAN masterIsSource = m_ConnectionFileObject != NULL;

    NTSTATUS status = STATUS_SUCCESS;

    //
    // Create a queue.
    //
    status =
    m_IrpStream->QueryInterface(
                               __uuidof(IKsShellTransport),(PVOID *) &m_QueueTransport);

    PIKSSHELLTRANSPORT hot;
    PIKSSHELLTRANSPORT cold;
    if (NT_SUCCESS(status))
    {
        //
        // Connect the queue to the master pin.  The queue is then the dangling
        // end of the 'hot' side of the circuit.
        //
        hot = m_QueueTransport;
        ASSERT(hot);

        hot->Connect(PIKSSHELLTRANSPORT(this),NULL,m_DataFlow);

        //
        // The 'cold' side of the circuit is either the upstream connection on
        // a sink pin or a requestor connected to same on a source pin.
        //
        if (masterIsSource)
        {
            //
            // Source pin...needs a requestor.
            //
            status =
            KspShellCreateRequestor(
                                   &m_RequestorTransport,
                                   (KSPROBE_STREAMREAD |
                                    KSPROBE_ALLOCATEMDL |
                                    KSPROBE_PROBEANDLOCK |
                                    KSPROBE_SYSTEMADDRESS),
                                   0,   // TODO:  header size
                                   m_FrameSize,
                                   FRAME_COUNT,
                                   m_ConnectionDeviceObject,
                                   NULL );

            if (NT_SUCCESS(status))
            {
                PIKSSHELLTRANSPORT(this)->
                Connect(m_RequestorTransport,NULL,m_DataFlow);
                cold = m_RequestorTransport;
            }
        }
        else
        {
            //
            // Sink pin...no requestor required.
            //
            cold = PIKSSHELLTRANSPORT(this);
        }

    }

    //
    // Now we have a hot end and a cold end to hook up to other pins in the
    // pipe, if any.  There are three cases:  1, 2 and many pins.
    // TODO:  Handle headless pipes.
    //
    if (NT_SUCCESS(status))
    {
        //
        // No other pins.  This is the end of the pipe.  We connect the hot
        // and the cold ends together.  The hot end is not really carrying
        // data because the queue is not modifying the data, it is producing
        // or consuming it.
        //
        cold->Connect(hot,NULL,m_DataFlow);
    }

    //
    // Clean up after a failure.
    //
    if (! NT_SUCCESS(status))
    {
        //
        // Dereference the queue if there is one.
        //
        if (m_QueueTransport)
        {
            m_QueueTransport->Release();
            m_QueueTransport = NULL;
        }

        //
        // Dereference the requestor if there is one.
        //
        if (m_RequestorTransport)
        {
            m_RequestorTransport->Release();
            m_RequestorTransport = NULL;
        }
    }

#if DBG
    if (NT_SUCCESS(status))
    {
        VOID DbgPrintCircuit(IN PIKSSHELLTRANSPORT Transport);
        _DbgPrintF(DEBUGLVL_BLAB,("TRANSPORT CIRCUIT:\n"));
        DbgPrintCircuit(PIKSSHELLTRANSPORT(this));
    }
#endif

    return status;
}

#pragma code_seg()
void
CPortPinDMus::
CancelIrpsOutstanding(
                     void
                     )
/*++

Routine Description:

    Cancels all IRP's on the outstanding IRPs list.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _DbgPrintF(DEBUGLVL_BLAB,("CancelIrpsOutstanding"));

    //
    // This algorithm searches for uncancelled IRPs starting at the head of
    // the list.  Every time such an IRP is found, it is cancelled, and the
    // search starts over at the head.  This will be very efficient, generally,
    // because IRPs will be removed by the completion routine when they are
    // cancelled.
    //
    for (;;)
    {
        //
        // Take the spinlock and search for an uncancelled IRP.  Because the
        // completion routine acquires the same spinlock, we know IRPs on this
        // list will not be completely cancelled as long as we have the 
        // spinlock.
        //
        PIRP irp = NULL;
        KIRQL oldIrql;
        KeAcquireSpinLock(&m_IrpsOutstanding.SpinLock,&oldIrql);
        for (PLIST_ENTRY listEntry = m_IrpsOutstanding.ListEntry.Flink;
            listEntry != &m_IrpsOutstanding.ListEntry;
            listEntry = listEntry->Flink)
        {
            PIRPLIST_ENTRY irpListEntry =
            CONTAINING_RECORD(listEntry,IRPLIST_ENTRY,ListEntry);

            if (! irpListEntry->Irp->Cancel)
            {
                irp = irpListEntry->Irp;
                break;
            }
        }

        //
        // If there are no uncancelled IRPs, we are done.
        //
        if (! irp)
        {
            KeReleaseSpinLock(&m_IrpsOutstanding.SpinLock,oldIrql);
            break;
        }

        //
        // Mark the IRP cancelled whether we can call the cancel routine now
        // or not.
        // 
        irp->Cancel = TRUE;

        //
        // If the cancel routine has already been removed, then this IRP
        // can only be marked as canceled, and not actually canceled, as
        // another execution thread has acquired it. The assumption is that
        // the processing will be completed, and the IRP removed from the list
        // some time in the near future.
        //
        // If the element has not been acquired, then acquire it and cancel it.
        // Otherwise, it's time to find another victim.
        //
        PDRIVER_CANCEL driverCancel = IoSetCancelRoutine(irp,NULL);

        //
        // Since the Irp has been acquired by removing the cancel routine, or
        // there is no cancel routine and we will not be cancelling, it is safe 
        // to release the list lock.
        //
        KeReleaseSpinLock(&m_IrpsOutstanding.SpinLock,oldIrql);

        if (driverCancel)
        {
            _DbgPrintF(DEBUGLVL_VERBOSE,("#### Pin%p.CancelIrpsOutstanding:  cancelling IRP %p",this,irp));
            //
            // This needs to be acquired since cancel routines expect it, and
            // in order to synchronize with NTOS trying to cancel Irp's.
            //
            IoAcquireCancelSpinLock(&irp->CancelIrql);
            driverCancel(IoGetCurrentIrpStackLocation(irp)->DeviceObject,irp);
        }
        else
        {
            _DbgPrintF(DEBUGLVL_VERBOSE,("#### Pin%p.CancelIrpsOutstanding:  uncancellable IRP %p",this,irp));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\ports\dmus\mxf.h ===
/*  
    Base definition of MIDI Transform Filter object 

    Copyright (c) 1998-2000 Microsoft Corporation.  All rights reserved.

    05/06/98    Created this file

*/

#ifndef __MXF_H__
#define __MXF_H__

#include "private.h"

#define DMUS_KEF_EVENT_IN_USE       0x0004  //  This event is not presently in the allocator.
#define DMUS_KEF_EVENT_STATUS_STATE 0x0000  //  This event contains a running status byte only.
#define DMUS_KEF_EVENT_DATA1_STATE  0x4000  //  This event is a fragment that requires 1 more data byte.
#define DMUS_KEF_EVENT_DATA2_STATE  0x8000  //  This event is a fragment that requires 2 more data bytes.
#define DMUS_KEF_EVENT_SYSEX_STATE  0xC000  //  This event is a fragment that requires an EOX.

#define EVT_IN_USE(evt)         ((evt)->usFlags & DMUS_KEF_EVENT_IN_USE)
#define EVT_NOT_IN_USE(evt)     ((evt)->usFlags & DMUS_KEF_EVENT_IN_USE == 0)
#define EVT_PARSE_STATE(evt)   ((evt)->usFlags & DMUS_KEF_EVENT_SYSEX_STATE)
#define STATUS_STATE(evt)      (EVT_PARSE_STATE(evt) == DMUS_KEF_EVENT_STATUS_STATE)
#define DATA1_STATE(evt)       (EVT_PARSE_STATE(evt) == DMUS_KEF_EVENT_DATA1_STATE)
#define DATA2_STATE(evt)       (EVT_PARSE_STATE(evt) == DMUS_KEF_EVENT_DATA2_STATE)
#define SYSEX_STATE(evt)       (EVT_PARSE_STATE(evt) == DMUS_KEF_EVENT_SYSEX_STATE)
#define RUNNING_STATUS(evt)    (((evt)->cbEvent == 1) && (STATUS_STATE(evt)))

#define SET_EVT_IN_USE(evt)     ((evt)->usFlags |= DMUS_KEF_EVENT_IN_USE)
#define SET_EVT_NOT_IN_USE(evt) ((evt)->usFlags &= (~DMUS_KEF_EVENT_IN_USE))
#define SET_STATUS_STATE(evt) ((evt)->usFlags &= ~DMUS_KEF_EVENT_SYSEX_STATE)
#define SET_DATA1_STATE(evt)  ((evt)->usFlags = (((evt)->usFlags & ~DMUS_KEF_EVENT_SYSEX_STATE) | DMUS_KEF_EVENT_DATA1_STATE))
#define SET_DATA2_STATE(evt)  ((evt)->usFlags = (((evt)->usFlags & ~DMUS_KEF_EVENT_SYSEX_STATE) | DMUS_KEF_EVENT_DATA2_STATE))
#define SET_SYSEX_STATE(evt)  ((evt)->usFlags |= DMUS_KEF_EVENT_SYSEX_STATE)
#define CLEAR_STATE(evt)      (SET_STATUS_STATE(evt))


#if DBG
#define DumpDMKEvt(evt,lvl) \
    _DbgPrintF(lvl,("    PDMUS_KERNEL_EVENT:      0x%p",evt)); \
    if (evt) \
    { \
        if (evt->bReserved) \
        { \
            _DbgPrintF(lvl,("        bReserved:           0x%0.2X",evt->bReserved)); \
        } \
        else \
        { \
            _DbgPrintF(lvl,("        bReserved:           --")); \
        } \
        _DbgPrintF(lvl,("        cbStruct:            %d",evt->cbStruct)); \
        _DbgPrintF(lvl,("        cbEvent:             %d",evt->cbEvent)); \
        _DbgPrintF(lvl,("        usChannelGroup:      %d",evt->usChannelGroup)); \
        _DbgPrintF(lvl,("        usFlags:             0x%04X",evt->usFlags)); \
        _DbgPrintF(lvl,("        ullPresTime100ns:    0x%04X %04X  %04X %04X",WORD(evt->ullPresTime100ns >> 48),WORD(evt->ullPresTime100ns >> 32),WORD(evt->ullPresTime100ns >> 16),WORD(evt->ullPresTime100ns)));  \
        _DbgPrintF(lvl,("        ullBytePosition:     0x%04X %04X  %04X %04X",WORD(evt->ullBytePosition >> 48),WORD(evt->ullBytePosition >> 32),WORD(evt->ullBytePosition >> 16),WORD(evt->ullBytePosition)));  \
        if (evt->pNextEvt) \
        { \
            _DbgPrintF(lvl,("        pNextEvt:            0x%p",evt->pNextEvt)); \
        } \
        else \
        { \
            _DbgPrintF(lvl,("        pNextEvt:            --")); \
        } \
        if (PACKAGE_EVT(evt)) \
        { \
            _DbgPrintF(lvl,("        uData.pPackageEvt:   0x%p",evt->uData.pPackageEvt)); \
        } \
        else if (SHORT_EVT(evt)) \
        { \
            if (evt->cbEvent) \
            { \
                ULONGLONG data = 0; \
                for (int count = 0;count < evt->cbEvent;count++) \
                { \
                    data <<= 8; \
                    data += evt->uData.abData[count]; \
                } \
                _DbgPrintF(lvl,("        uData.abData:        0x%.*I64X",evt->cbEvent * 2,data)); \
            } \
            else \
            { \
                _DbgPrintF(lvl,("        uData.abData:        --")); \
            } \
        } \
        else \
        { \
            ULONGLONG   data; \
            ULONG       count; \
            PBYTE       dataPtr = evt->uData.pbData; \
            _DbgPrintF(lvl,("        uData.pbData:        0x%p",dataPtr)); \
            for (data = 0,count = 0;(count < sizeof(PBYTE)) && (count < evt->cbEvent);count++,dataPtr++) \
            { \
                data <<= 8; \
                data += *dataPtr; \
            } \
            _DbgPrintF(lvl,("            (uData.pbData):  0x%.*I64X",count * 2,data)); \
            while (count < evt->cbEvent) \
            { \
                int localCount; \
                for (localCount = 0, data = 0; \
                     (localCount < sizeof(PBYTE)) && (count < evt->cbEvent); \
                     localCount++,count++,dataPtr++) \
                { \
                    data <<= 8; \
                    data += *dataPtr; \
                } \
                _DbgPrintF(lvl,("                             0x%.*I64X",localCount * 2,data)); \
            } \
        } \
    }
#else
#define DumpDMKEvt(evt,level)
#endif
/*
typedef struct _DMUS_KERNEL_EVENT
{                                           //  this    offset
    BYTE            bReserved;              //  1       0
    BYTE            cbStruct;               //  1       1
    USHORT          cbEvent;                //  2       2
    USHORT          usChannelGroup;         //  2       4
    USHORT          usFlags;                //  2       6
    REFERENCE_TIME  ullPresTime100ns;       //  8       8
    ULONGLONG       ullBytePosition;        //  8      16
    _DMUS_KERNEL_EVENT *pNextEvt;           //  4 (8)  24
    union
    {
        BYTE        abData[sizeof(PBYTE)];  //  4 (8)  28 (32)
        PBYTE       pbData;
        _DMUS_KERNEL_EVENT *pPackageEvt;
    } uData;
} DMUS_KERNEL_EVENT, *PDMUS_KERNEL_EVENT;   //         32 (40)

#define DMUS_KEF_PACKAGE_EVENT      0x0001  // This event is a package. The uData.pPackageEvt
                                            // field contains a pointer to a chain of events.

#define DMUS_KEF_EVENT_COMPLETE     0x0000
#define DMUS_KEF_EVENT_INCOMPLETE   0x0002  // This event is an incomplete package or sysex.
                                            // Do not use this data.

#define SHORT_EVT(evt)       ((evt)->cbEvent <= sizeof(PBYTE))
#define PACKAGE_EVT(evt)     ((evt)->usFlags & DMUS_KEF_PACKAGE_EVENT)
#define INCOMPLETE_EVT(evt)  ((evt)->usFlags & DMUS_KEF_EVENT_INCOMPLETE)
#define COMPLETE_EVT(evt)    ((evt)->usFlags & DMUS_KEF_EVENT_INCOMPLETE == 0)

#define SET_PACKAGE_EVT(evt)    ((evt)->usFlags |= DMUS_KEF_PACKAGE_EVENT)
#define CLEAR_PACKAGE_EVT(evt)  ((evt)->usFlags &= (~DMUS_KEF_PACKAGE_EVENT))
#define SET_INCOMPLETE_EVT(evt) ((evt)->usFlags |= DMUS_KEF_EVENT_INCOMPLETE)
#define SET_COMPLETE_EVT(evt)   ((evt)->usFlags &= (~DMUS_KEF_EVENT_INCOMPLETE))
*/


class CAllocatorMXF;

class CMXF
{
public:
    CMXF(CAllocatorMXF *AllocatorMXF) { m_AllocatorMXF = AllocatorMXF;};
    virtual ~CMXF(void) {};

    IMP_IMXF;

protected:
    CAllocatorMXF *m_AllocatorMXF;
};

#endif  //  __MXF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\ports\dmus\packer.h ===
/*  Base definition of MIDI event packer

    Copyright (c) 1998-2000 Microsoft Corporation.  All rights reserved.

    05/22/98    Created this file
    09/10/98    Reworked for kernel use

*/

#ifndef __PackerMXF_H__
#define __PackerMXF_H__

#include "MXF.h"
#include "Allocatr.h"


class CIrp
{
    public:
        PBYTE       m_pbBuffer;
        DWORD       m_cbBuffer;
        DWORD       m_cbLeft;
        ULONGLONG   m_ullPresTime100ns;
        CIrp        *m_pNext;

        virtual void Notify(void) = 0;
        virtual void Complete(NTSTATUS hr) = 0;
};

class CPackerMXF : public CMXF,
    public IMXF,
    public CUnknown
{
    public:
        CPackerMXF(CAllocatorMXF *allocatorMXF,
                   PIRPSTREAMVIRTUAL m_IrpStream,
                   PMASTERCLOCK Clock);

        virtual ~CPackerMXF();

        // CMXF interface
        //
        DECLARE_STD_UNKNOWN();
        IMP_IMXF;

        // Upper edge interface
        //
        NTSTATUS ProcessQueues();
        NTSTATUS MarkStreamHeaderContinuity(void);
    protected:
        ULONGLONG m_ullBaseTime;
        ULONG     m_HeaderSize;       //  size of chunk w/out data
        ULONG     m_MinEventSize;     //  size of smallest event
        KSSTATE   m_State;            //  current KS graph state
        ULONGLONG m_PauseTime;
        ULONGLONG m_StartTime;
        
        // Subclass interface
        //
        virtual void TruncateDestCount(PULONG pcbDest) = 0;
        virtual PBYTE FillHeader(PBYTE pbHeader, 
                                 ULONGLONG ullPresentationTime, 
                                 USHORT usChannelGroup, 
                                 ULONG cbEvent,
                                 PULONG pcbTotalEvent) = 0;
        virtual void AdjustTimeForState(REFERENCE_TIME *Time);
        
    private:
        PDMUS_KERNEL_EVENT  m_DMKEvtHead;
        PDMUS_KERNEL_EVENT  m_DMKEvtTail;
        ULONG               m_DMKEvtOffset;
        ULONGLONG           m_ullLastTime;
        PIRPSTREAMVIRTUAL   m_IrpStream;
        PMASTERCLOCK        m_Clock;

        NTSTATUS CheckIRPHeadTime(void);
        PBYTE    GetDestBuffer(PULONG pcbDest);
        ULONG    NumBytesLeftInBuffer(void);
        void     CompleteStreamHeaderInProcess(void);
        NTSTATUS MarkStreamHeaderDiscontinuity(void);
};

class CDMusPackerMXF : public CPackerMXF
{
    public:
        CDMusPackerMXF(CAllocatorMXF *allocatorMXF,
                   PIRPSTREAMVIRTUAL m_IrpStream,
                   PMASTERCLOCK Clock);
        ~CDMusPackerMXF();

    protected:        
        PBYTE FillHeader(PBYTE pbHeader, 
                         ULONGLONG ullPresentationTime, 
                         USHORT usChannelGroup, 
                         ULONG cbEvent,
                         PULONG pcbTotalEvent);
        void TruncateDestCount(PULONG pcbDest);
};

class CKsPackerMXF : public CPackerMXF
{
    public:
        CKsPackerMXF(CAllocatorMXF *allocatorMXF,
                   PIRPSTREAMVIRTUAL m_IrpStream,
                   PMASTERCLOCK Clock);
        ~CKsPackerMXF();
        

    protected:
        PBYTE FillHeader(PBYTE pbHeader, 
                         ULONGLONG ullPresentationTime, 
                         USHORT usChannelGroup, 
                         ULONG cbEvent,
                         PULONG pcbTotalEvent);
        void TruncateDestCount(PULONG pcbDest);
        
        void AdjustTimeForState(REFERENCE_TIME *Time);
};

#endif // __PackerMXF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\ports\dmus\parse.h ===
/*  MIDI parser helpers 

    Copyright (c) 1999-2000 Microsoft Corporation.  All rights reserved.

    01/20/99    Martin Puryear      Created this file

*/

// MIDI parsing helpers
//
#define SYSEX_END           0xF7

#define IS_DATA_BYTE(x)     (((x) & 0x80) == 0)
#define IS_STATUS_BYTE(x)   ((x) & 0x80)
#define IS_CHANNEL_MSG(x)   (IS_STATUS_BYTE(x) && (((x) & 0xF0) != 0xF0))
#define IS_REALTIME_MSG(x)  (((x) & 0xF8) == 0xF8)
#define IS_SYSTEM_COMMON(x) (((x) & 0xF8) == 0xF0)
#define IS_SYSEX(x)         ((x) == 0xF0)
#define IS_SYSEX_END(x)     ((x) == SYSEX_END)


static ULONG cbChannelMsgData[] =
{
    2,  /* 0x8x Note off */
    2,  /* 0x9x Note on */
    2,  /* 0xAx Polyphonic key pressure/aftertouch */
    2,  /* 0xBx Control change */
    1,  /* 0xCx Program change */
    1,  /* 0xDx Channel pressure/aftertouch */
    2,  /* 0xEx Pitch change */
    0,  /* 0xFx System message - use cbSystemMsgData */
};

static ULONG cbSystemMsgData[] =
{
    0,  /* 0xF0 SysEx (variable until F7 seen) */

        /* System common messages */
    1,  /* 0xF1 MTC quarter frame */
    2,  /* 0xF2 Song position pointer */
    1,  /* 0xF3 Song select */
    0,  /* 0xF4 Undefined */
    0,  /* 0xF5 Undefined */
    0,  /* 0xF6 Tune request */
    0,  /* 0xF7 End of sysex flag */

        /* System realtime messages */
    0,  /* 0xF8 Timing clock */
    0,  /* 0xF9 Undefined */
    0,  /* 0xFA Start */
    0,  /* 0xFB Continue */
    0,  /* 0xFC Stop */
    0,  /* 0xFD Undefined */
    0,  /* 0xFE Active sensing */
    0,  /* 0xFF System reset */
};

#define STATUS_MSG_DATA_BYTES(x)    \
    (IS_CHANNEL_MSG(x) ? cbChannelMsgData[((x) >> 4) & 0x07] : cbSystemMsgData[(x) & 0x0F])
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\ports\dmus\packer.cpp ===
/*  
    Base implementation of MIDI event packer

    Copyright (c) 1998-2000 Microsoft Corporation.  All rights reserved.

    05/22/98    Created this file
    09/10/98    Reworked for kernel use

*/

#include "private.h"
#include "Packer.h"

#include "Ks.h"
#include "KsMedia.h"

#define STR_MODULENAME "DMus:PackerMXF: "

// Alignment macros
//
#define DWORD_ALIGN(x) (((x) + 3) & ~3)     // Pad to next DWORD
#define DWORD_TRUNC(x) ((x) & ~3)           // Trunc to DWORD's that will fit
#define QWORD_ALIGN(x) (((x) + 7) & ~7)
#define QWORD_TRUNC(x) ((x) & ~7)


#pragma code_seg("PAGE")
///////////////////////////////////////////////////////////////////////
//
// CPackerMXF
//
// Code which is common to all packers
//

/*****************************************************************************
 * CPackerMXF::CPackerMXF()
 *****************************************************************************
 * TODO: Might want one m_DMKEvtNodePool per PortClass, not per graph instance.
 */
CPackerMXF::CPackerMXF(CAllocatorMXF     *allocatorMXF,
                       PIRPSTREAMVIRTUAL  IrpStream,
                       PMASTERCLOCK       Clock) 
:   CUnknown(NULL),
    CMXF(allocatorMXF)

{
    PAGED_CODE();

    m_DMKEvtHead    = NULL;
    m_DMKEvtTail    = NULL;
    m_ullBaseTime   = 0;
    m_StartTime     = 0;
    m_PauseTime     = 0;
    m_IrpStream     = IrpStream;
    m_Clock         = Clock;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPackerMXF::~CPackerMXF
/*****************************************************************************
 *
 */
CPackerMXF::~CPackerMXF()
{
    PAGED_CODE();
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPackerMXF::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.
 */
STDMETHODIMP_(NTSTATUS) 
CPackerMXF::NonDelegatingQueryInterface
(
    REFIID  Interface,
    PVOID * Object
)
{
    PAGED_CODE();

    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface,IID_IUnknown))
    {
        *Object = PVOID(PMXF(this));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IMXF))
    {
        *Object = PVOID(PMXF(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER_1;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPackerMXF::SetState()
 *****************************************************************************
 *
 */
NTSTATUS CPackerMXF::SetState(KSSTATE State)    
{   
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE,("SetState from %d to %d",m_State,State));

    if (State == m_State) 
    {
        return STATUS_SUCCESS;
    }

    NTSTATUS ntStatus;
    REFERENCE_TIME Now;

    ntStatus = m_Clock->GetTime(&Now);    
    if (NT_SUCCESS(ntStatus))
    {
        if (m_State == KSSTATE_RUN)
        {
            // Leaving run, set the pause time
            //
            m_PauseTime = Now - m_StartTime;
            _DbgPrintF(DEBUGLVL_VERBOSE,("Leaving run; pause time 0x%08X %08X",
                (ULONG)(m_PauseTime >> 32),
                (ULONG)(m_PauseTime & 0xFFFFFFFF)));
        }
        else if (State == KSSTATE_RUN)
        {
            // Entering run, set the start time
            //
            m_StartTime = Now - m_PauseTime;
            _DbgPrintF(DEBUGLVL_VERBOSE,("Entering run; start time 0x%08X %08X",
                (ULONG)(m_StartTime >> 32),
                (ULONG)(m_StartTime & 0xFFFFFFFF)));
        }
        else if (State == KSSTATE_ACQUIRE && m_State == KSSTATE_STOP)
        {
            (void) ProcessQueues(); //  flush any residual data

            // Acquire from stop, reset everything to zero.
            //
            m_PauseTime = 0;
            m_StartTime = 0;
            _DbgPrintF(DEBUGLVL_VERBOSE,("Acquire from stop; zero time"));
        }
    
        m_State = State;
    }
    return ntStatus;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPackerMXF::ConnectOutput()
 *****************************************************************************
 * Fail; this filter is an MXF sink only
 */
NTSTATUS CPackerMXF::ConnectOutput(PMXF sinkMXF)
{
    PAGED_CODE();

    return STATUS_NOT_IMPLEMENTED;
}

// CPackerMXF::DisconnectOutput
//
// Fail; this filter is an MXF sink only
//
#pragma code_seg("PAGE")
/*****************************************************************************
 * CPackerMXF::DisconnectOutput()
 *****************************************************************************
 * Fail; this filter is an MXF sink only
 */
NTSTATUS CPackerMXF::DisconnectOutput(PMXF sinkMXF)
{
    PAGED_CODE();

    return STATUS_NOT_IMPLEMENTED;
}

#pragma code_seg()
/*****************************************************************************
 * CPackerMXF::PutMessage()
 *****************************************************************************
 * Call the appropriate translate function with a buffer to pack
 */
NTSTATUS CPackerMXF::PutMessage(PDMUS_KERNEL_EVENT pDMKEvtHead)
{
    PDMUS_KERNEL_EVENT pDMKEvtTail;

    if (pDMKEvtHead)
    {
        pDMKEvtTail = pDMKEvtHead;
        while (pDMKEvtTail->pNextEvt)
        {
            pDMKEvtTail = pDMKEvtTail->pNextEvt;
        }

        if (m_DMKEvtHead)
        {
            // Event queue not empty
            //
            ASSERT(m_DMKEvtTail);

            m_DMKEvtTail->pNextEvt = pDMKEvtHead;
            m_DMKEvtTail = pDMKEvtTail;

            // Already waiting on an IRP to fill or queue would be empty, so 
            // don't bother trying to process
        }
        else
        {
            // Event queue empty
            //
            m_DMKEvtHead   = pDMKEvtHead;
            m_DMKEvtTail   = pDMKEvtTail;
            m_DMKEvtOffset = 0;            
        }
    }
    if (m_DMKEvtHead)
    {
        (void) ProcessQueues();
    }

    return STATUS_SUCCESS;
}

#pragma code_seg()
/*****************************************************************************
 * CPackerMXF::ProcessQueues()
 *****************************************************************************
 *
 */
NTSTATUS CPackerMXF::ProcessQueues()
{
    ULONG cbSource, cbDest, cbTotalWritten;
    PBYTE pbSource, pbDest;
    PDMUS_KERNEL_EVENT pDMKEvt;

    NTSTATUS    ntStatus = STATUS_UNSUCCESSFUL;

    while (m_DMKEvtHead)
    {
        ASSERT(m_DMKEvtOffset < m_DMKEvtHead->cbEvent);
        pbDest = GetDestBuffer(&cbDest);
        _DbgPrintF(DEBUGLVL_VERBOSE,("ProcessQ: m_DMKEvtOffset %d, pbDest 0x%x, cbDest %d, DMKEvt 0x%x",
                                                m_DMKEvtOffset,    pbDest,      cbDest,    m_DMKEvtHead));
        DumpDMKEvt(m_DMKEvtHead,DEBUGLVL_VERBOSE);
        while (cbDest < m_MinEventSize)
        {
            if (!cbDest || !pbDest)
            {
                _DbgPrintF(DEBUGLVL_VERBOSE,("ProcessQ: bombing out, no dest buffer"));
                return ntStatus;
            }
            m_IrpStream->ReleaseLockedRegion(cbDest);
            m_IrpStream->Complete(cbDest,&cbDest);
            CompleteStreamHeaderInProcess();
            pbDest = GetDestBuffer(&cbDest);
        }        
        
        //  we now have IRP with room for a short event, or part of a long one.
        cbSource = m_DMKEvtHead->cbEvent + m_HeaderSize - m_DMKEvtOffset; //  how much remaining data?
        if (cbDest > cbSource)
        {
            cbDest = cbSource; //  we only need enough for this message
        }

        // If this is the first time referencing this event, adjust its time
        //
        if (m_DMKEvtOffset == 0)
        {
            _DbgPrintF(DEBUGLVL_BLAB,("Change event time stamp: 0x%08X %08X",
                (ULONG)(m_DMKEvtHead->ullPresTime100ns >> 32),
                (ULONG)(m_DMKEvtHead->ullPresTime100ns & 0xFFFFFFFF)));
            AdjustTimeForState(&m_DMKEvtHead->ullPresTime100ns);
            _DbgPrintF(DEBUGLVL_BLAB,("                     to: 0x%08X %08X",
                (ULONG)(m_DMKEvtHead->ullPresTime100ns >> 32),
                (ULONG)(m_DMKEvtHead->ullPresTime100ns & 0xFFFFFFFF)));
        }    

        pbDest = FillHeader(pbDest, 
                            m_DMKEvtHead->ullPresTime100ns, 
                            m_DMKEvtHead->usChannelGroup, 
                            cbDest - m_HeaderSize,
                            &cbTotalWritten);    //  num data bytes
        //  pbDest now points to where data should go
        
        if (m_DMKEvtHead->cbEvent <= sizeof(PBYTE))
        {
            pbSource = m_DMKEvtHead->uData.abData;
        } 
        else 
        {
            pbSource = m_DMKEvtHead->uData.pbData;
        }

        cbDest -= m_HeaderSize;

        _DbgPrintF(DEBUGLVL_VERBOSE, ("ProcessQueues ---- %d bytes at offset %d",cbDest,m_DMKEvtOffset));
        
        RtlCopyMemory(pbDest, pbSource + m_DMKEvtOffset, cbDest);
        m_DMKEvtOffset += cbDest;
        ASSERT(m_DMKEvtOffset <= m_DMKEvtHead->cbEvent);

        // close the IRPStream window (including the pad amount)
        if (STATUS_STATE(m_DMKEvtHead) || (m_DMKEvtOffset != m_DMKEvtHead->cbEvent))
        {
            m_IrpStream->ReleaseLockedRegion(cbTotalWritten);
            m_IrpStream->Complete(cbTotalWritten,&cbTotalWritten);
            CompleteStreamHeaderInProcess();
        }
        else
        {
            m_IrpStream->ReleaseLockedRegion(cbTotalWritten - 1);
            m_IrpStream->Complete(cbTotalWritten - 1,&cbTotalWritten);

            NTSTATUS ntStatusDbg = MarkStreamHeaderDiscontinuity();
            if (ntStatusDbg != STATUS_SUCCESS)
            {
                _DbgPrintF(DEBUGLVL_TERSE,("ProcessQueues: MarkStreamHeaderDiscontinuity failed 0x%08x",ntStatusDbg));
            }

            pbDest = GetDestBuffer(&cbDest);
            m_IrpStream->ReleaseLockedRegion(1);
            m_IrpStream->Complete(1,&cbTotalWritten);

            CompleteStreamHeaderInProcess();
        }

        if (NumBytesLeftInBuffer() < m_MinEventSize)    //  if not enough room for
        {                                               //  another, eject it now
            CompleteStreamHeaderInProcess();
        }

        if (m_DMKEvtOffset == m_DMKEvtHead->cbEvent)
        {
            m_DMKEvtOffset = 0;
            pDMKEvt = m_DMKEvtHead;
            m_DMKEvtHead = pDMKEvt->pNextEvt;
            pDMKEvt->pNextEvt = NULL;

            m_AllocatorMXF->PutMessage(pDMKEvt);
        }
        else if (m_DMKEvtOffset > m_DMKEvtHead->cbEvent)
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("ProcessQueues ---- offset %d is greater than cbEvent %d",m_DMKEvtOffset,m_DMKEvtHead->cbEvent));
        }

        ntStatus = STATUS_SUCCESS;  //  we did something worthwhile
    }
    return ntStatus;
}

#pragma code_seg()
/*****************************************************************************
 * CPackerMXF::AdjustTimeForState()
 *****************************************************************************
 * Adjust the time for the graph state. Default implementation does nothing.
 */
void CPackerMXF::AdjustTimeForState(REFERENCE_TIME *Time)
{
}

#pragma code_seg()
/*****************************************************************************
 * CPackerMXF::GetDestBuffer()
 *****************************************************************************
 * Get a buffer.
 */
PBYTE CPackerMXF::GetDestBuffer(PULONG pcbDest)
{
    PVOID pbDest;
    NTSTATUS ntStatus;

    ntStatus = CheckIRPHeadTime();  //  set m_ullBaseTime if head of IRP
    m_IrpStream->GetLockedRegion(pcbDest,&pbDest);

    if (NT_SUCCESS(ntStatus))       //  if our IRP makes sense
    {
        _DbgPrintF(DEBUGLVL_BLAB,("GetDestBuffer: cbDest %d, pbDest 0x%x",
                                                  *pcbDest,  pbDest));
        TruncateDestCount(pcbDest);
    }
    else                            //  we don't have a valid IRP
    {   
        ASSERT((*pcbDest == 0) && (pbDest == 0));

//        m_IrpStream->ReleaseLockedRegion(*pcbDest);
//        m_IrpStream->Complete(*pcbDest,pcbDest);
        *pcbDest = 0;
        pbDest = 0;
    }
    return (PBYTE)pbDest;
}

#pragma code_seg()
/*****************************************************************************
 * CPackerMXF::CheckIRPHeadTime()
 *****************************************************************************
 * Set variables to known state, done
 * initially and upon any state error.
 */
NTSTATUS CPackerMXF::CheckIRPHeadTime(void)
{
    IRPSTREAMPACKETINFO irpStreamPacketInfo;
    KSTIME              time;
    NTSTATUS            ntStatus;

    ntStatus = m_IrpStream->GetPacketInfo(&irpStreamPacketInfo,NULL);
    if (NT_ERROR(ntStatus))
    {
        _DbgPrintF(DEBUGLVL_TERSE,("CheckIRPHeadTime received error from GetPacketInfo"));
        return STATUS_UNSUCCESSFUL;
    }
    time = irpStreamPacketInfo.Header.PresentationTime;
    
    if (!time.Denominator)
    {
        _DbgPrintF(DEBUGLVL_VERBOSE,("CheckIRPHeadTime: IRP denominator is zero"));
        return STATUS_UNSUCCESSFUL;
    }
    if (!time.Numerator)
    {
        _DbgPrintF(DEBUGLVL_VERBOSE,("CheckIRPHeadTime IRP numerator is zero"));
        return STATUS_UNSUCCESSFUL;
    }

    //  this is a valid IRP
    if (!irpStreamPacketInfo.CurrentOffset)
    {
        m_ullBaseTime = time.Time * time.Numerator / time.Denominator;
    }

    return STATUS_SUCCESS;
}

#pragma code_seg()
/*****************************************************************************
 * CPackerMXF::NumBytesLeftInBuffer()
 *****************************************************************************
 * Return the number of bytes .
 */
ULONG
CPackerMXF::
NumBytesLeftInBuffer
(   void
)
{
    ULONG   bytesLeftInIrp;
    PVOID   pDummy;

    m_IrpStream->GetLockedRegion(&bytesLeftInIrp,&pDummy);
    m_IrpStream->ReleaseLockedRegion(0);
    return bytesLeftInIrp;
}

#pragma code_seg()
/*****************************************************************************
 * CPackerMXF::CompleteStreamHeaderInProcess()
 *****************************************************************************
 * Complete this packet before putting incongruous data in 
 * the next packet and marking that packet as bad.
 */
void CPackerMXF::CompleteStreamHeaderInProcess(void)
{
    IRPSTREAMPACKETINFO irpStreamPacketInfo;
    NTSTATUS            ntStatus;
    KSTIME              time;

    ntStatus = m_IrpStream->GetPacketInfo(&irpStreamPacketInfo,NULL);
    if (NT_ERROR(ntStatus))
        return;
    time = irpStreamPacketInfo.Header.PresentationTime;
    
    if (!time.Denominator)
        return;
    if (!time.Numerator)
        return;
    //  is this a valid IRP

    if (irpStreamPacketInfo.CurrentOffset)
    {
        m_IrpStream->TerminatePacket();
    }
}

#pragma code_seg()
/*****************************************************************************
 * CPackerMXF::MarkStreamHeaderDiscontinuity()
 *****************************************************************************
 * Alert client of a break in the MIDI input stream.
 */
NTSTATUS CPackerMXF::MarkStreamHeaderDiscontinuity(void)
{
    return m_IrpStream->
        ChangeOptionsFlags(KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY, 0xFFFFFFFF,   
                           0,                                          0xFFFFFFFF);
}

#pragma code_seg()
/*****************************************************************************
 * CPackerMXF::MarkStreamHeaderContinuity()
 *****************************************************************************
 * Alert client of a break in the MIDI input stream.
 */
NTSTATUS CPackerMXF::MarkStreamHeaderContinuity(void)
{
    return m_IrpStream->
        ChangeOptionsFlags(0, ~KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY,   
                           0, 0xFFFFFFFF);
}

#pragma code_seg("PAGE")
///////////////////////////////////////////////////////////////////////
//
// CDMusPackerMXF
//
// Code to pack into DirectMusic buffer format
//

/*****************************************************************************
 * CDMusPackerMXF::CDMusPackerMXF()
 *****************************************************************************
 *
 */
CDMusPackerMXF::CDMusPackerMXF(CAllocatorMXF *allocatorMXF,
                               PIRPSTREAMVIRTUAL  IrpStream,
                               PMASTERCLOCK Clock)  
    : CPackerMXF(allocatorMXF,IrpStream,Clock)
{
    m_HeaderSize = sizeof(DMUS_EVENTHEADER);
    m_MinEventSize = DMUS_EVENT_SIZE(1);
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CDMusPackerMXF::~CDMusPackerMXF()
 *****************************************************************************
 *
 */
CDMusPackerMXF::~CDMusPackerMXF()
{
}

#pragma code_seg()
/*****************************************************************************
 * CDMusPackerMXF::FillHeader()
 *****************************************************************************
 *
 */
PBYTE CDMusPackerMXF::FillHeader(PBYTE pbHeader, 
                                 ULONGLONG ullPresentationTime, 
                                 USHORT usChannelGroup, 
                                 ULONG cbEvent,
                                 PULONG pcbTotalEvent)
{
    DMUS_EVENTHEADER *pEvent = (DMUS_EVENTHEADER *)pbHeader;

    pEvent->cbEvent           = cbEvent;
    pEvent->dwChannelGroup    = usChannelGroup;

    ASSERT(ullPresentationTime >= m_ullBaseTime);
    pEvent->rtDelta           = ullPresentationTime - m_ullBaseTime;
    pEvent->dwFlags           = 0;  //  TODO - not ignore this

    *pcbTotalEvent = QWORD_ALIGN(sizeof(DMUS_EVENTHEADER) + cbEvent);

    return (PBYTE)(pEvent+1);
}

#pragma code_seg()
/*****************************************************************************
 * CDMusPackerMXF::TruncateDestCount()
 *****************************************************************************
 * Set variables to known state, done
 * initially and upon any state error.
 */
void CDMusPackerMXF::TruncateDestCount(PULONG pcbDest)
{
    *pcbDest = QWORD_TRUNC(*pcbDest);
}

#pragma code_seg("PAGE")
///////////////////////////////////////////////////////////////////////
//
// CKsPackerMXF
//
// Code to pack into KSMUSICFORMAT
//

/*****************************************************************************
 * CKsPackerMXF::CKsPackerMXF()
 *****************************************************************************
 *
 */
CKsPackerMXF::CKsPackerMXF(CAllocatorMXF *allocatorMXF,
                           PIRPSTREAMVIRTUAL  IrpStream,
                           PMASTERCLOCK Clock)  
    : CPackerMXF(allocatorMXF,IrpStream,Clock)
{
    m_HeaderSize = sizeof(KSMUSICFORMAT);
    m_MinEventSize = m_HeaderSize + 1;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CKsPackerMXF::~CKsPackerMXF()
 *****************************************************************************
 *
 */
CKsPackerMXF::~CKsPackerMXF()
{
}

#pragma code_seg()
/*****************************************************************************
 * CKsPackerMXF::FillHeader()
 *****************************************************************************
 * 
 */
PBYTE CKsPackerMXF::FillHeader(PBYTE     pbHeader, 
                               ULONGLONG ullPresentationTime, 
                               USHORT    usChannelGroup, 
                               ULONG     cbEvent,
                               PULONG    pcbTotalEvent)
{
    KSMUSICFORMAT *pEvent = (KSMUSICFORMAT*)pbHeader;

    ASSERT(usChannelGroup <= 1);
    ASSERT(ullPresentationTime >= m_ullBaseTime);

    pEvent->TimeDeltaMs = (DWORD)((ullPresentationTime - m_ullBaseTime) / 10000);
    m_ullBaseTime       += (ULONGLONG(pEvent->TimeDeltaMs) * 10000);
    pEvent->ByteCount   = cbEvent;

    *pcbTotalEvent = DWORD_ALIGN(sizeof(KSMUSICFORMAT) + cbEvent);

    return (PBYTE)(pEvent + 1);
}

#pragma code_seg()
/*****************************************************************************
 * CKsPackerMXF::TruncateDestCount()
 *****************************************************************************
 * Set variables to known state, done
 * initially and upon any state error.
 */
void CKsPackerMXF::TruncateDestCount(PULONG pcbDest)
{
//    *pcbDest = DWORD_TRUNC(*pcbDest);
}

/*****************************************************************************
 * CKsPackerMXF::AdjustTimeForState()
 *****************************************************************************
 * Adjust the time for the graph state. 
 */
void CKsPackerMXF::AdjustTimeForState(REFERENCE_TIME *Time)
{
    if (m_State == KSSTATE_RUN)
    {
        *Time -= m_StartTime;
    }
    else
    {
        *Time = m_PauseTime;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\ports\dmus\port.cpp ===
/*****************************************************************************
 * port.cpp - DirectMusic port driver
 *****************************************************************************
 * Copyright (c) 1997-2000 Microsoft Corporation.  All rights reserved.
 *
 *      6/3/98  MartinP
 */

#include "private.h"

#define STR_MODULENAME "DMus:Port: "

/*****************************************************************************
 * Factory
 */

#pragma code_seg("PAGE")
/*****************************************************************************
 * CreatePortDMus()
 *****************************************************************************
 * Creates a DirectMusic port driver.
 */
NTSTATUS
CreatePortDMus
(
    OUT     PUNKNOWN *  Unknown,
    IN      REFCLSID,
    IN      PUNKNOWN    UnknownOuter    OPTIONAL,
    IN      POOL_TYPE   PoolType
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_LIFETIME, ("Creating DMUS Port"));
    ASSERT(Unknown);

    STD_CREATE_BODY_( CPortDMus,
                      Unknown,
                      UnknownOuter,
                      PoolType,
                      PPORTDMUS);
}

/*****************************************************************************
 * PortDriverDMus
 *****************************************************************************
 * Port driver descriptor.  Referenced extern in porttbl.c.
 */
PORT_DRIVER
PortDriverDMus =
{
    &CLSID_PortDMus,
    CreatePortDMus
};

/*****************************************************************************
 * CreatePortMidi()
 *****************************************************************************
 * Creates a midi port driver.
 */
NTSTATUS
CreatePortMidi
(
    OUT     PUNKNOWN *  Unknown,
    IN      REFCLSID,
    IN      PUNKNOWN    UnknownOuter    OPTIONAL,
    IN      POOL_TYPE   PoolType
)
{
    PAGED_CODE();

    ASSERT(Unknown);

    _DbgPrintF(DEBUGLVL_LIFETIME,("Creating MIDI Port"));

    //
    // Support for Midi Miniports. The PPORTMIDI and PPORTDMUS interfaces
    // are exactly the same. Therefore it is OK to create CPortDMus for
    // PPORTMIDI request.
    //
    NTSTATUS ntStatus;
    CPortDMus *p = new(PoolType,'rCcP') CPortDMus(UnknownOuter);
    if (p)
    {
        *Unknown = PUNKNOWN(PPORTMIDI(p));
        (*Unknown)->AddRef();
        ntStatus = STATUS_SUCCESS;
    }
    else
    {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    return ntStatus;
}

/*****************************************************************************
 * PortDriverMidi
 *****************************************************************************
 * Port driver descriptor.  Referenced extern in porttbl.c.
 */
PORT_DRIVER
PortDriverMidi =
{
    &CLSID_PortMidi,
    CreatePortMidi
};

/*****************************************************************************

#pragma code_seg()


/*****************************************************************************
 * Member functions
 */

#pragma code_seg()
REFERENCE_TIME DMusicDefaultGetTime(void)
{
    LARGE_INTEGER   liFrequency, liTime,keQPCTime;

    //  total VTD ticks since system booted
    liTime = KeQueryPerformanceCounter(&liFrequency);

#ifndef UNDER_NT

    //
    //  TODO Since timeGetTime assumes 1193 VTD ticks per millisecond, 
    //  instead of 1193.182 (or 1193.18 -- really spec'ed as 1193.18175), 
    //  we have to do the same (on Win 9x codebase only).
    //
    //  This means we drop the bottom three digits of the frequency.  
    //  We need to fix this when the fix to timeGetTime is checked in.
    //  instead we do this:
    //
    liFrequency.QuadPart /= 1000;           //  drop the precision on the floor
    liFrequency.QuadPart *= 1000;           //  drop the precision on the floor

#endif  //  !UNDER_NT

    //
    //  Convert ticks to 100ns units.
    //
    keQPCTime.QuadPart = KSCONVERT_PERFORMANCE_TIME(liFrequency.QuadPart,liTime);

    return keQPCTime.QuadPart;
}


 /*****************************************************************************
 * CPortPinDMus::GetTime()
 *****************************************************************************
 * Implementation of get time based on IReferenceClock
 */
#pragma code_seg()
NTSTATUS CPortDMus::GetTime(REFERENCE_TIME *pTime)
{
    *pTime = DMusicDefaultGetTime();
    
    return STATUS_SUCCESS;
}

/*****************************************************************************
. * CPortDMus::Notify()
 *****************************************************************************
 * Lower-edge function to notify port driver of notification interrupt.
 */
STDMETHODIMP_(void)
CPortDMus::Notify(IN PSERVICEGROUP ServiceGroup OPTIONAL)
{
    _DbgPrintF(DEBUGLVL_BLAB, ("Notify"));
    if (ServiceGroup)
    {
        ServiceGroup->RequestService();
    }
    else
    {
        if (m_MiniportServiceGroup)
        {
            m_MiniportServiceGroup->RequestService();
        }

        for (ULONG pIndex = 0; pIndex < m_PinEntriesUsed; pIndex++)
        {
            if (m_Pins[pIndex] && m_Pins[pIndex]->m_ServiceGroup)
            {
                m_Pins[pIndex]->m_ServiceGroup->RequestService();
            }
        }
    }
}

/*****************************************************************************
 * CPortDMus::RequestService()
 *****************************************************************************
 * 
 */
STDMETHODIMP_(void)
CPortDMus::RequestService(void)
{
    if (m_Miniport)
    {
        m_Miniport->Service();
    }
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortDMus::~CPortDMus()
 *****************************************************************************
 * Destructor.
 */
CPortDMus::~CPortDMus()
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_LIFETIME,("Destroying DMUS Port (0x%08x)", this));

    if (m_pSubdeviceDescriptor)
    {
        PcDeleteSubdeviceDescriptor(m_pSubdeviceDescriptor);
    }
    ULONG ulRefCount;
    if (m_MPPinCountI)
    {
        ulRefCount = m_MPPinCountI->Release();
        m_MPPinCountI = NULL;
    }
    if (m_Miniport)
    {
        ulRefCount = m_Miniport->Release();
        ASSERT(0 == ulRefCount);
        m_Miniport = NULL;
    }
    if (m_MiniportServiceGroup)
    {
        m_MiniportServiceGroup->RemoveMember(PSERVICESINK(this));
        ulRefCount = m_MiniportServiceGroup->Release();
        ASSERT(0 == ulRefCount);
        m_MiniportServiceGroup = NULL;
    }
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortDMus::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.
 */
STDMETHODIMP_(NTSTATUS)
CPortDMus::NonDelegatingQueryInterface(REFIID Interface,PVOID * Object)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB, ("NonDelegatingQueryInterface"));

    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface,IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(PPORT(this)));
    }
    else if (IsEqualGUIDAligned(Interface,IID_IPort))
    {
        *Object = PVOID(PPORT(this));
    }
    else if (IsEqualGUIDAligned(Interface,IID_IPortDMus))
    {
        *Object = PVOID(PPORTDMUS(this));
    }
    else if (IsEqualGUIDAligned(Interface,IID_IIrpTargetFactory))
    {
        *Object = PVOID(PIRPTARGETFACTORY(this));
    }
    else if (IsEqualGUIDAligned(Interface,IID_ISubdevice))
    {
        *Object = PVOID(PSUBDEVICE(this));
    }
    else if (IsEqualGUIDAligned(Interface,IID_IServiceSink))
    {
        *Object = PVOID(PSERVICESINK(this));
    }
    else if (IsEqualGUIDAligned(Interface,IID_IPortEvents))
    {
        *Object = PVOID(PPORTEVENTS(this));
    }
#ifdef DRM_PORTCLS
    else if (IsEqualGUIDAligned(Interface,IID_IDrmPort))
    {
        *Object = PVOID(PDRMPORT(this));
    }
    else if (IsEqualGUIDAligned(Interface,IID_IDrmPort2))
    {
        *Object = PVOID(PDRMPORT2(this));
    }
#endif  // DRM_PORTCLS
    else if (IsEqualGUIDAligned(Interface,IID_IPortClsVersion))
    {
        *Object = PVOID(PPORTCLSVERSION(this));
    }
    else if (IsEqualGUIDAligned(Interface,IID_IPortMidi))
    {
        // PPORTDMUS and PPORTMIDI interfaces are the same.
        // Return PPORTDMUS for IID_IPortMidi.
        *Object = PVOID(PPORTDMUS(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

static
GUID TopologyCategories[] =
{
    STATICGUIDOF(KSCATEGORY_AUDIO),
    STATICGUIDOF(KSCATEGORY_RENDER),
    STATICGUIDOF(KSCATEGORY_CAPTURE)
};

static
KSPIN_INTERFACE PinInterfacesStream[] =
{
   {
      STATICGUIDOF(KSINTERFACESETID_Standard),
      KSINTERFACE_STANDARD_STREAMING,
      0
   }
};

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortDMus::Init()
 *****************************************************************************
 * Initializes the port.
 */
STDMETHODIMP_(NTSTATUS)
CPortDMus::Init
(
    IN      PDEVICE_OBJECT  DeviceObjectIn,
    IN      PIRP            Irp,
    IN      PUNKNOWN        UnknownMiniport,
    IN      PUNKNOWN        UnknownAdapter  OPTIONAL,
    IN      PRESOURCELIST   ResourceList
)
{
    PAGED_CODE();

    ASSERT(DeviceObjectIn);
    ASSERT(Irp);
    ASSERT(UnknownMiniport);
    ASSERT(ResourceList); 

    _DbgPrintF(DEBUGLVL_LIFETIME, ("Initializing DMUS Port (0x%08x)", this));

    m_DeviceObject = DeviceObjectIn;
    m_MiniportMidi = NULL;

    KeInitializeMutex(&m_ControlMutex,1);

    KeInitializeSpinLock(&(m_EventList.ListLock));
    InitializeListHead(&(m_EventList.List));
    m_EventContext.ContextInUse = FALSE;
    KeInitializeDpc( &m_EventDpc,
                     PKDEFERRED_ROUTINE(PcGenerateEventDeferredRoutine),
                     PVOID(&m_EventContext));

    PSERVICEGROUP pServiceGroup = NULL;

    NTSTATUS ntStatus =
        UnknownMiniport->QueryInterface( IID_IMiniportDMus,
                                         (PVOID *) &m_Miniport);
    if (!NT_SUCCESS(ntStatus))
    {
        // If the miniport does not support IID_IMiniportDMus,
        // the miniport is IID_IMiniportMidi. 
        //
        ntStatus = 
            UnknownMiniport->QueryInterface
            ( 
                IID_IMiniportMidi,
                (PVOID *) &m_MiniportMidi
            );
        if (NT_SUCCESS(ntStatus))
        {
            m_Miniport = (PMINIPORTDMUS) m_MiniportMidi;
        }
    }

    if (NT_SUCCESS(ntStatus))
    {
        ntStatus = m_Miniport->Init( UnknownAdapter,
                                     ResourceList,
                                     PPORTDMUS(this),
                                     &pServiceGroup);
    }
    
    if (NT_SUCCESS(ntStatus))
    {
        ntStatus = m_Miniport->GetDescription(&m_pPcFilterDescriptor);
    }
    
    if (NT_SUCCESS(ntStatus))
    {
        ntStatus = PcCreateSubdeviceDescriptor
                    (
                        m_pPcFilterDescriptor,
                        SIZEOF_ARRAY(TopologyCategories),
                        TopologyCategories,
                        SIZEOF_ARRAY(PinInterfacesStream),
                        PinInterfacesStream,
                        SIZEOF_ARRAY(PropertyTable_FilterDMus),
                        PropertyTable_FilterDMus,
                        0,      // FilterEventSetCount
                        NULL,   // FilterEventSets
                        SIZEOF_ARRAY(PropertyTable_PinDMus),
                        PropertyTable_PinDMus,
                        SIZEOF_ARRAY(EventTable_PinDMus),
                        EventTable_PinDMus,
                        &m_pSubdeviceDescriptor
                    );
    }
    if (NT_SUCCESS(ntStatus) && pServiceGroup)
    {
        //
        // The miniport supplied a service group.
        //
        if (m_MiniportServiceGroup)
        {
        //
        // We got it already from RegisterServiceGroup().
        // Do a release because we don't need the new ref.
        //
            ASSERT(m_MiniportServiceGroup == pServiceGroup);
            pServiceGroup->Release();
            pServiceGroup = NULL;
        }
        else
        {
            //
            // RegisterServiceGroup() was not called.  We need
            // to add a member.  There is already a reference
            // added by the miniport's Init().
            //
            m_MiniportServiceGroup = pServiceGroup;
            m_MiniportServiceGroup->AddMember(PSERVICESINK(this));
        }
    }

    if (NT_SUCCESS(ntStatus))
    {
        NTSTATUS ntStatus = m_Miniport->QueryInterface( IID_IPinCount,(PVOID *)&m_MPPinCountI);
    }

#if 0 //DEBUG
    if (NT_SUCCESS(ntStatus))
    {
        PKSPIN_DESCRIPTOR pKsPinDescriptor = m_pSubdeviceDescriptor->PinDescriptors;
        for (ULONG ulPinId = 0; ulPinId < m_pSubdeviceDescriptor->PinCount; ulPinId++, pKsPinDescriptor++)
        {
            if (  (pKsPinDescriptor->Communication == KSPIN_COMMUNICATION_SINK)
               && (pKsPinDescriptor->DataFlow == KSPIN_DATAFLOW_OUT))
            {
                _DbgPrintF(DEBUGLVL_TERSE,("CPortDMus::Init converting pin %d to KSPIN_COMMUNICATION_BOTH",ulPinId));
                pKsPinDescriptor->Communication = KSPIN_COMMUNICATION_BOTH;
            }
        }
    }
#endif //DEBUG

    if(!NT_SUCCESS(ntStatus))
    {
        if (pServiceGroup)
        {
            pServiceGroup->Release();
        }
        
        if (m_MiniportServiceGroup)
        {
            m_MiniportServiceGroup->RemoveMember(PSERVICESINK(this));
            m_MiniportServiceGroup->Release();
            m_MiniportServiceGroup = NULL;            
        }

        if (m_MPPinCountI)
        {
            m_MPPinCountI->Release();
            m_MPPinCountI = NULL;
        }

        if (m_Miniport)
        {
            m_Miniport->Release();
            m_Miniport = NULL;
        }
    }

    _DbgPrintF(DEBUGLVL_BLAB, ("DMusic Port Init done w/status %x",ntStatus));

    return ntStatus;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortDMus::RegisterServiceGroup()
 *****************************************************************************
 * Early registration of the service group to handle interrupts during Init().
 */
STDMETHODIMP_(void)
CPortDMus::RegisterServiceGroup(IN PSERVICEGROUP pServiceGroup)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB, ("RegisterServiceGroup"));
    ASSERT(pServiceGroup);
    ASSERT(!m_MiniportServiceGroup);

    m_MiniportServiceGroup = pServiceGroup;
    m_MiniportServiceGroup->AddRef();
    m_MiniportServiceGroup->AddMember(PSERVICESINK(this));
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortDMus::GetDeviceProperty()
 *****************************************************************************
 * Gets device properties from the registry for PnP devices.
 */
STDMETHODIMP_(NTSTATUS)
CPortDMus::GetDeviceProperty
(
    IN      DEVICE_REGISTRY_PROPERTY    DeviceProperty,
    IN      ULONG                       BufferLength,
    OUT     PVOID                       PropertyBuffer,
    OUT     PULONG                      ResultLength
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB, ("GetDeviceProperty"));
    return ::PcGetDeviceProperty( PVOID(m_DeviceObject),
                                  DeviceProperty,
                                  BufferLength,
                                  PropertyBuffer,
                                  ResultLength );
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortDMus::NewRegistryKey()
 *****************************************************************************
 * Opens/creates a registry key object.
 */
STDMETHODIMP_(NTSTATUS)
CPortDMus::NewRegistryKey
(
    OUT     PREGISTRYKEY *      OutRegistryKey,
    IN      PUNKNOWN            OuterUnknown        OPTIONAL,
    IN      ULONG               RegistryKeyType,
    IN      ACCESS_MASK         DesiredAccess,
    IN      POBJECT_ATTRIBUTES  ObjectAttributes    OPTIONAL,
    IN      ULONG               CreateOptions       OPTIONAL,
    OUT     PULONG              Disposition         OPTIONAL
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB, ("NewRegistryKey"));
    return ::PcNewRegistryKey( OutRegistryKey,
                               OuterUnknown,
                               RegistryKeyType,
                               DesiredAccess,
                               PVOID(m_DeviceObject),
                               PVOID(PSUBDEVICE(this)),
                               ObjectAttributes,
                               CreateOptions,
                               Disposition);
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortDMus::ReleaseChildren()
 *****************************************************************************
 * Release child objects.
 */
STDMETHODIMP_(void) CPortDMus::ReleaseChildren(void)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_LIFETIME, ("ReleaseChildren of DMUS Port (0x%08x)", this));

    if (m_MPPinCountI)
    {
        m_MPPinCountI->Release();
        m_MPPinCountI = NULL;
    }

    if (m_Miniport)
    {
        m_Miniport->Release();
        m_Miniport = NULL;
    }

    if (m_MiniportServiceGroup)
    {
        m_MiniportServiceGroup->RemoveMember(PSERVICESINK(this));
        m_MiniportServiceGroup->Release();
        m_MiniportServiceGroup = NULL;
    }
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortDMus::GetDescriptor()
 *****************************************************************************
 * Return the descriptor for this port
 */
STDMETHODIMP_(NTSTATUS) 
CPortDMus::GetDescriptor
(
    OUT     const SUBDEVICE_DESCRIPTOR **   ppSubdeviceDescriptor
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB, ("GetDescriptor"));
    ASSERT(ppSubdeviceDescriptor);

    *ppSubdeviceDescriptor = m_pSubdeviceDescriptor;

    return STATUS_SUCCESS;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortDMus::DataRangeIntersection()
 *****************************************************************************
 * Generate a format which is the intersection of two data ranges.
 */
STDMETHODIMP_(NTSTATUS)
CPortDMus::DataRangeIntersection
(   
    IN      ULONG           PinId,
    IN      PKSDATARANGE    DataRange,
    IN      PKSDATARANGE    MatchingDataRange,
    IN      ULONG           OutputBufferLength,
    OUT     PVOID           ResultantFormat     OPTIONAL,
    OUT     PULONG          ResultantFormatLength
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB, ("DataRangeIntersection"));
    ASSERT(DataRange);
    ASSERT(MatchingDataRange);
    ASSERT(ResultantFormatLength);

    return m_Miniport->DataRangeIntersection( PinId,
                                              DataRange,
                                              MatchingDataRange,
                                              OutputBufferLength,
                                              ResultantFormat,
                                              ResultantFormatLength);
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortDMus::PowerChangeNotify()
 *****************************************************************************
 * Called by portcls to notify the port/miniport of a device power
 * state change.
 */
STDMETHODIMP_(void)
CPortDMus::PowerChangeNotify(POWER_STATE PowerState)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB, ("PowerChangeNotify"));
    PPOWERNOTIFY pPowerNotify;

    if (m_Miniport)
    {
        // QI for the miniport notification interface
        NTSTATUS ntStatus = m_Miniport->QueryInterface( IID_IPowerNotify,
                                                        (PVOID *)&pPowerNotify);
        // check if we're powering up
        if (PowerState.DeviceState == PowerDeviceD0)
        {
            // notify the miniport
            if (NT_SUCCESS(ntStatus))
            {
                pPowerNotify->PowerChangeNotify(PowerState);
    
                pPowerNotify->Release();
            }
    
            // notify each port pin
            for (ULONG index=0; index < MAX_PINS; index++)
            {
                if (m_Pins[index])
                {
                    m_Pins[index]->PowerNotify(PowerState);
                }
            }
        } 
        else  // we're powering down
        {
            // notify each port pin
            for (ULONG index=0; index < MAX_PINS; index++)
            {
                if (m_Pins[index])
                {
                    m_Pins[index]->PowerNotify(PowerState);
                }
            }
            
            // notify the miniport
            if (NT_SUCCESS(ntStatus))
            {
                pPowerNotify->PowerChangeNotify(PowerState);
    
                pPowerNotify->Release();
            }
        }
    }
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortDMus::PinCount()
 *****************************************************************************
 * Called by portcls to give the port\miniport a chance 
 * to override the default pin counts for this pin ID.
 */
STDMETHODIMP_(void)
CPortDMus::PinCount
(
    IN      ULONG   PinId,
    IN  OUT PULONG  FilterNecessary,
    IN  OUT PULONG  FilterCurrent,
    IN  OUT PULONG  FilterPossible,
    IN  OUT PULONG  GlobalCurrent,
    IN  OUT PULONG  GlobalPossible
)
{
    PAGED_CODE();

    _DbgPrintF( DEBUGLVL_BLAB, 
                ("PinCount PID:0x%08x FN(0x%08x):%d FC(0x%08x):%d FP(0x%08x):%d GC(0x%08x):%d GP(0x%08x):%d",
                  PinId,                           FilterNecessary,*FilterNecessary,
                  FilterCurrent,  *FilterCurrent,  FilterPossible, *FilterPossible, 
                  GlobalCurrent,  *GlobalCurrent,  GlobalPossible, *GlobalPossible ) );

    if (m_MPPinCountI)
    {
        m_MPPinCountI->PinCount(PinId,FilterNecessary,FilterCurrent,FilterPossible,GlobalCurrent,GlobalPossible);

        _DbgPrintF( DEBUGLVL_BLAB, 
                    ("Post-PinCount PID:0x%08x FN(0x%08x):%d FC(0x%08x):%d FP(0x%08x):%d GC(0x%08x):%d GP(0x%08x):%d",
                      PinId,                           FilterNecessary,*FilterNecessary,
                      FilterCurrent,  *FilterCurrent,  FilterPossible, *FilterPossible, 
                      GlobalCurrent,  *GlobalCurrent,  GlobalPossible, *GlobalPossible ) );
    }
}

/*****************************************************************************
 * PinTypeName
 *****************************************************************************
 * The name of the pin object type.
 */
static const WCHAR PinTypeName[] = KSSTRING_Pin;

/*****************************************************************************
 * CreateTable
 *****************************************************************************
 * Create dispatch table.
 */
static KSOBJECT_CREATE_ITEM CreateTable[] =
{
    DEFINE_KSCREATE_ITEM(KsoDispatchCreateWithGenericFactory,PinTypeName,0)
};

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortDMus::NewIrpTarget()
 *****************************************************************************
 * Creates and initializes a filter object.
 */
STDMETHODIMP_(NTSTATUS)
CPortDMus::NewIrpTarget
(
    OUT     PIRPTARGET *        IrpTarget,
    OUT     BOOLEAN *           ReferenceParent,
    IN      PUNKNOWN            OuterUnknown,
    IN      POOL_TYPE           PoolType,
    IN      PDEVICE_OBJECT      DeviceObject,
    IN      PIRP                Irp,
    OUT     PKSOBJECT_CREATE    ObjectCreate
)
{
    PAGED_CODE();

    ASSERT(IrpTarget);
    ASSERT(DeviceObject);
    ASSERT(Irp);
    ASSERT(ObjectCreate);

    _DbgPrintF(DEBUGLVL_BLAB, ("NewIrpTarget"));

    ObjectCreate->CreateItemsCount  = SIZEOF_ARRAY(CreateTable);
    ObjectCreate->CreateItemsList   = CreateTable;

    PUNKNOWN filterUnknown;
    NTSTATUS ntStatus = CreatePortFilterDMus( &filterUnknown,
                                              GUID_NULL,
                                              OuterUnknown,
                                              PoolType);

    if (NT_SUCCESS(ntStatus))
    {
        PPORTFILTERDMUS filterDMus;

        ntStatus = filterUnknown->QueryInterface( IID_IIrpTarget,
                                                  (PVOID *) &filterDMus);
        if (NT_SUCCESS(ntStatus))
        {
            // The QI for IIrpTarget actually gets IPortFilterDMus.
            ntStatus = filterDMus->Init(this);
            if (NT_SUCCESS(ntStatus))
            {
                *ReferenceParent = TRUE;
                *IrpTarget = filterDMus;
            }
            else
            {
                filterDMus->Release();
            }
        }
        filterUnknown->Release();
    }
    return ntStatus;
}

#pragma code_seg()
/*****************************************************************************
 * CPortDMus::AddEventToEventList()
 *****************************************************************************
 * Adds an event to the port's event list.
 */
STDMETHODIMP_(void)
CPortDMus::AddEventToEventList(IN PKSEVENT_ENTRY EventEntry)
{
    ASSERT(EventEntry);

    _DbgPrintF(DEBUGLVL_BLAB,("AddEventToEventList"));

    KIRQL   oldIrql;

    if (EventEntry)
    {
        // grab the event list spin lock
        KeAcquireSpinLock(&(m_EventList.ListLock), &oldIrql);

        // add the event to the list tail
        InsertTailList(&(m_EventList.List),
                        (PLIST_ENTRY)((PVOID)EventEntry));

        // release the event list spin lock
        KeReleaseSpinLock(&(m_EventList.ListLock), oldIrql);
    }
}

/*****************************************************************************
 * CPortDMus::GenerateEventList()
 *****************************************************************************
 * Wraps KsGenerateEventList for miniports.
 */
STDMETHODIMP_(void)
CPortDMus::GenerateEventList
(
    IN  GUID*   Set     OPTIONAL,
    IN  ULONG   EventId,
    IN  BOOL    PinEvent,
    IN  ULONG   PinId,
    IN  BOOL    NodeEvent,
    IN  ULONG   NodeId
)
{
    if (KeGetCurrentIrql() > DISPATCH_LEVEL)
    {
        if (!m_EventContext.ContextInUse)
        {
            m_EventContext.ContextInUse = TRUE;
            m_EventContext.Set = Set;
            m_EventContext.EventId = EventId;
            m_EventContext.PinEvent = PinEvent;
            m_EventContext.PinId = PinId;
            m_EventContext.NodeEvent = NodeEvent;
            m_EventContext.NodeId = NodeId;
    
            KeInsertQueueDpc( &m_EventDpc,
                              PVOID(&m_EventList),
                              NULL);
        }
    }
    else
    {
        PcGenerateEventList( &m_EventList,
                             Set,
                             EventId,
                             PinEvent,
                             PinId,
                             NodeEvent,
                             NodeId);
    }
}

#ifdef DRM_PORTCLS

#pragma code_seg("PAGE")

STDMETHODIMP_(NTSTATUS)
CPortDMus::
AddContentHandlers(ULONG ContentId,PVOID * paHandlers,ULONG NumHandlers)
{
    PAGED_CODE();
    return DrmAddContentHandlers(ContentId,paHandlers,NumHandlers);
}

STDMETHODIMP_(NTSTATUS)
CPortDMus::
CreateContentMixed(PULONG paContentId,ULONG cContentId,PULONG pMixedContentId)
{
    PAGED_CODE();
    return DrmCreateContentMixed(paContentId,cContentId,pMixedContentId);
}

STDMETHODIMP_(NTSTATUS)
CPortDMus::
DestroyContent(ULONG ContentId)
{
    PAGED_CODE();
    return DrmDestroyContent(ContentId);
}

STDMETHODIMP_(NTSTATUS)
CPortDMus::
ForwardContentToDeviceObject(ULONG ContentId,PVOID Reserved,PCDRMFORWARD DrmForward)
{
    PAGED_CODE();
    return DrmForwardContentToDeviceObject(ContentId,Reserved,DrmForward);
}

STDMETHODIMP_(NTSTATUS)
CPortDMus::
ForwardContentToFileObject(ULONG ContentId,PFILE_OBJECT FileObject)
{
    PAGED_CODE();
    return DrmForwardContentToFileObject(ContentId,FileObject);
}

STDMETHODIMP_(NTSTATUS)
CPortDMus::
ForwardContentToInterface(ULONG ContentId,PUNKNOWN pUnknown,ULONG NumMethods)
{
    PAGED_CODE();
    return DrmForwardContentToInterface(ContentId,pUnknown,NumMethods);
}

STDMETHODIMP_(NTSTATUS)
CPortDMus::
GetContentRights(ULONG ContentId,PDRMRIGHTS DrmRights)
{
    PAGED_CODE();
    return DrmGetContentRights(ContentId,DrmRights);
}

#endif  // DRM_PORTCLS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\ports\dmus\sequencr.cpp ===
/*  Base implementation of MIDI Transform Filter object

    Copyright (c) 1998-2000 Microsoft Corporation.  All rights reserved.

    05/06/98    Martin Puryear      Created this file

*/

#include "private.h"
#include "Sequencr.h"

#define STR_MODULENAME "DMus:SequencerMXF: "

#pragma code_seg("PAGE")
/*****************************************************************************
 * CSequencerMXF::CSequencerMXF()
 *****************************************************************************
 * Create a sequencer MXF object.
 */
CSequencerMXF::CSequencerMXF(CAllocatorMXF *AllocatorMXF,
                             PMASTERCLOCK   Clock)
:   CUnknown(NULL),
    CMXF(AllocatorMXF)
{
    PAGED_CODE();
    ASSERT(AllocatorMXF);
    ASSERT(Clock);
    
    m_DMKEvtQueue = NULL;
    KeInitializeSpinLock(&m_EvtQSpinLock);

    _DbgPrintF(DEBUGLVL_BLAB, ("Constructor"));
    m_SinkMXF = AllocatorMXF;
    m_Clock = Clock;
    m_SchedulePreFetch = 0;

    KeInitializeDpc(&m_Dpc,&::DMusSeqTimerDPC,PVOID(this));
    KeInitializeTimer(&m_TimerEvent);
}

#pragma code_seg()
/*****************************************************************************
 * CSequencerMXF::~CSequencerMXF()
 *****************************************************************************
 * Artfully remove this filter from the chain.
 */
CSequencerMXF::~CSequencerMXF(void)
{
    (void) KeCancelTimer(&m_TimerEvent);
    (void) KeRemoveQueueDpc(&m_Dpc);

    (void) DisconnectOutput(m_SinkMXF);

    KIRQL oldIrql;
    KeAcquireSpinLock(&m_EvtQSpinLock, &oldIrql);
    if (m_DMKEvtQueue != NULL)
    {
        m_AllocatorMXF->PutMessage(m_DMKEvtQueue);
        m_DMKEvtQueue = NULL;
    }
    KeReleaseSpinLock(&m_EvtQSpinLock, oldIrql);
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CSequencerMXF::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.
 */
STDMETHODIMP_(NTSTATUS)
CSequencerMXF::
NonDelegatingQueryInterface
(
    REFIID  Interface,
    PVOID * Object
)
{
    PAGED_CODE();

    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface,IID_IUnknown))
    {
        *Object = PVOID(PMXF(this));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IMXF))
    {
        *Object = PVOID(PMXF(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER_1;
}

#pragma code_seg("PAGE")
//  Must furnish an allocator.
//  Perhaps must furnish a clock as well?
NTSTATUS 
CSequencerMXF::SetState(KSSTATE State)    
{   
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE,("SetState %d",State));
    return STATUS_NOT_IMPLEMENTED;
}

#pragma code_seg("PAGE")
//  Furnish a sink.  The allocator is default (events are destroyed).
NTSTATUS CSequencerMXF::ConnectOutput(PMXF sinkMXF)
{
    PAGED_CODE();

    if ((sinkMXF) && (m_SinkMXF == m_AllocatorMXF))
    {
        _DbgPrintF(DEBUGLVL_BLAB, ("ConnectOutput"));
        m_SinkMXF = sinkMXF;
        return STATUS_SUCCESS;
    }
    _DbgPrintF(DEBUGLVL_TERSE, ("ConnectOutput failed"));
    return STATUS_UNSUCCESSFUL;
}

#pragma code_seg("PAGE")
//  Pull the plug.  The sequencer should now put into the allocator.
NTSTATUS CSequencerMXF::DisconnectOutput(PMXF sinkMXF)
{
    PAGED_CODE();

    if ((m_SinkMXF == sinkMXF) || (!sinkMXF))
    {
        _DbgPrintF(DEBUGLVL_BLAB, ("DisconnectOutput"));
        m_SinkMXF = m_AllocatorMXF;
        return STATUS_SUCCESS;
    }
    _DbgPrintF(DEBUGLVL_TERSE, ("DisconnectOutput failed"));
    return STATUS_UNSUCCESSFUL;
}

#pragma code_seg()
//  Receive event from above.  Insert in queue and check timer.
NTSTATUS CSequencerMXF::PutMessage(PDMUS_KERNEL_EVENT pDMKEvt)
{
    (void) InsertEvtIntoQueue(pDMKEvt);
    (void) ProcessQueues();
    
    return STATUS_SUCCESS;
}           

#pragma code_seg()
/*****************************************************************************
 * CSequencerMXF::InsertEvtIntoQueue()
 *****************************************************************************
 * Maintain the sorted list, using only the forward 
 * links already in the DMUS)KERNEL_EVENT struct.
 *
 * BUGBUG I haven't yet dealt with multi-part SysEx.
 */
NTSTATUS CSequencerMXF::InsertEvtIntoQueue(PDMUS_KERNEL_EVENT pDMKEvt)
{
    PDMUS_KERNEL_EVENT pEvt;

    //  break up event chains
    while (pDMKEvt->pNextEvt) 
    {
        pEvt = pDMKEvt->pNextEvt;
        pDMKEvt->pNextEvt = NULL;            //  disconnect the first
        (void) InsertEvtIntoQueue(pDMKEvt); //  queue it
        pDMKEvt = pEvt;        
    }
    KIRQL oldIrql;
    KeAcquireSpinLock(&m_EvtQSpinLock, &oldIrql);
    if (!m_DMKEvtQueue)
    {
        m_DMKEvtQueue = pDMKEvt;
        KeReleaseSpinLock(&m_EvtQSpinLock, oldIrql);
        return STATUS_SUCCESS;
    }
    if (m_DMKEvtQueue->ullPresTime100ns > pDMKEvt->ullPresTime100ns)
    {
        pDMKEvt->pNextEvt = m_DMKEvtQueue;
        m_DMKEvtQueue = pDMKEvt;
        KeReleaseSpinLock(&m_EvtQSpinLock, oldIrql);
        return STATUS_SUCCESS;
    }

    //  go through each message in the queue looking at timestamps
    pEvt = m_DMKEvtQueue;
    while (pEvt->pNextEvt)
    {
        if (pEvt->pNextEvt->ullPresTime100ns <= pDMKEvt->ullPresTime100ns)
        {
            pEvt = pEvt->pNextEvt;
        }
        else
        {
            pDMKEvt->pNextEvt = pEvt->pNextEvt;
            pEvt->pNextEvt = pDMKEvt;
            KeReleaseSpinLock(&m_EvtQSpinLock, oldIrql);
            return STATUS_SUCCESS;
        }
    }
    pEvt->pNextEvt = pDMKEvt;
    KeReleaseSpinLock(&m_EvtQSpinLock, oldIrql);
    return STATUS_SUCCESS;
}

#pragma code_seg()
/*****************************************************************************
 * CSequencerMXF::ProcessQueues()
 *****************************************************************************
 * Get the current time and emit those messages whose time have come.
 * Make only one PutMessage with a sorted chain.
 */
NTSTATUS CSequencerMXF::ProcessQueues(void)
{
    REFERENCE_TIME      ullCurrentPresTime100ns;
    PDMUS_KERNEL_EVENT  pEvt, pNewQueueHeadEvt;
    NTSTATUS            Status;

    KIRQL oldIrql;
    KeAcquireSpinLock(&m_EvtQSpinLock, &oldIrql);
    if (m_DMKEvtQueue) //  if no messages, leave
    {
        if (m_SchedulePreFetch == DONT_HOLD_FOR_SEQUENCING)
        {
            pEvt = m_DMKEvtQueue;
            m_DMKEvtQueue = NULL;
            KeReleaseSpinLock(&m_EvtQSpinLock, oldIrql);
            m_SinkMXF->PutMessage(pEvt);
            return STATUS_SUCCESS;
        }
        Status = m_Clock->GetTime(&ullCurrentPresTime100ns);
        ullCurrentPresTime100ns += m_SchedulePreFetch;

        if (Status != STATUS_SUCCESS)
        {
            KeReleaseSpinLock(&m_EvtQSpinLock, oldIrql);
            return Status;
        }

        //  if we will send down at least one event, 
        if (m_DMKEvtQueue->ullPresTime100ns <= ullCurrentPresTime100ns)
        {
            //  figure out how many events are good to go
            //  pEvt will be the last event to be included
            pEvt = m_DMKEvtQueue;
            while ( (pEvt->pNextEvt) 
                 && (pEvt->pNextEvt->ullPresTime100ns <= ullCurrentPresTime100ns))
            {
                pEvt = pEvt->pNextEvt;
            }
            //  set new m_DMKEvtQueue to pEvt->pNextEvt
            //  then break the chain after pEvt
            pNewQueueHeadEvt = pEvt->pNextEvt;
            pEvt->pNextEvt = NULL;

            pEvt = m_DMKEvtQueue;
            //  if queue is now empty, m_DMKEvtQueue == NULL
            m_DMKEvtQueue = pNewQueueHeadEvt;

            //  don't call externally while holding the spinlock
            KeReleaseSpinLock(&m_EvtQSpinLock, oldIrql);

            //  send string of messages
            m_SinkMXF->PutMessage(pEvt);
        
            //  we need the spinlock again before we look at the queue
            KeAcquireSpinLock(&m_EvtQSpinLock, &oldIrql);
        }   //  if we sent at least one event
        
        if (m_DMKEvtQueue)
        {       // We need to do this work later... set up a timer.
                // Timers are one-shot, so if we're in one now it's cool.
            LARGE_INTEGER   timeDue100ns;
                //  determine the delta until the next message
                //  + for absolute / - for relative (timeDue will be negative)
            timeDue100ns.QuadPart = ullCurrentPresTime100ns - m_DMKEvtQueue->ullPresTime100ns;
            
            //  if closer than one millisecond away, 
            //  TODO, compare this to resolution returned in ExSetTimerResolution
            if (timeDue100ns.QuadPart > (-kOneMillisec))
            {
                timeDue100ns.QuadPart = -kOneMillisec;
            }
            //  set a Timer for then
            (void) KeSetTimer(&m_TimerEvent, timeDue100ns, &m_Dpc);
                //  the timer routine thunks down to grab 
                //  our spinlock, then call this routine
        }
    }   //  if queue is not empty
    KeReleaseSpinLock(&m_EvtQSpinLock, oldIrql);
    return STATUS_SUCCESS;
}

#pragma code_seg()
/*****************************************************************************
 * CSequencerMXF::SetSchedulePreFetch()
 *****************************************************************************
 * Set the schedule latency: the amount of time ahead that events should be
 * sequenced.  Example: HW device requests events to be sent 30 ms early.
 * Note: units are 100nanoseconds.
 */
void CSequencerMXF::SetSchedulePreFetch(ULONGLONG SchedulePreFetch)
{
    m_SchedulePreFetch = SchedulePreFetch;
}

#pragma code_seg()
/*****************************************************************************
 * DMusSeqTimerDPC()
 *****************************************************************************
 * The timer DPC callback. Thunks to a C++ member function.
 * This is called by the OS in response to the midi pin
 * wanting to wakeup later to process more midi stuff.
 */
VOID
DMusSeqTimerDPC
(
    IN  PKDPC   Dpc,
    IN  PVOID   DeferredContext,
    IN  PVOID   SystemArgument1,
    IN  PVOID   SystemArgument2
)
{
    ASSERT(DeferredContext);
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //  ignores return value!
    (void) ((CSequencerMXF*) DeferredContext)->ProcessQueues();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\ports\dmus\sequencr.h ===
/*  Base definition of MIDI Transform Filter object 

    Copyright (c) 1998-2000 Microsoft Corporation.  All rights reserved.

    05/06/98    Martin Puryear      Created this file

*/

#ifndef __SequencerMXF_H__
#define __SequencerMXF_H__

#include "MXF.h"
#include "Allocatr.h"


void DMusSeqTimerDPC(
              PKDPC Dpc,
              PVOID DeferredContext,
              PVOID SystemArgument1,
              PVOID SystemArgument2);

class CSequencerMXF : public CMXF,
    public IMXF,
    public CUnknown
{
public:
    CSequencerMXF(CAllocatorMXF *allocatorMXF,
                  PMASTERCLOCK clock);          //  must provide a default sink/source
    ~CSequencerMXF(void);

    DECLARE_STD_UNKNOWN();
    IMP_IMXF;

    NTSTATUS    ProcessQueues(void);
    void        SetSchedulePreFetch(ULONGLONG SchedulePreFetch);

protected:
    NTSTATUS    InsertEvtIntoQueue(PDMUS_KERNEL_EVENT pDMKEvt);

    PMXF                m_SinkMXF;
    PDMUS_KERNEL_EVENT  m_DMKEvtQueue;

private:
    KDPC            m_Dpc;
    KTIMER          m_TimerEvent;
    PMASTERCLOCK    m_Clock;
    ULONGLONG       m_SchedulePreFetch;
    KSPIN_LOCK      m_EvtQSpinLock;    
};

#endif  //  __SequencerMXF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\ports\dmus\unpacker.cpp ===
/*  Base implementation of MIDI event unpacker
    
    Copyright (c) 1998-2000 Microsoft Corporation.  All rights reserved.
    
    05/19/98    Created this file
    09/10/98    Reworked for kernel use
*/

#include <assert.h>

#include "private.h"
#include "parse.h"
#include "Unpacker.h"

#include "Ks.h"
#include "KsMedia.h"

#define STR_MODULENAME "DMus:UnpackerMXF: "

// Alignment macros
//
#define DWORD_ALIGN(x) (((x) + 3) & ~3)
#define QWORD_ALIGN(x) (((x) + 7) & ~7)

#pragma code_seg("PAGE")
///////////////////////////////////////////////////////////////////////
//
// CUnpackerMXF
//
// Code which is common to all unpackers
//

// CUnpackerMXF::CUnpackerMXF
//
// Get the system page size, which unpackers use as the maximum buffer size.
//
CUnpackerMXF::CUnpackerMXF(CAllocatorMXF    *allocatorMXF,
                           PMASTERCLOCK     Clock)
:   CUnknown(NULL),
    CMXF(allocatorMXF)
{
    m_SinkMXF = allocatorMXF;
    m_Clock   = Clock;

    m_EvtQueue = NULL;
    m_bRunningStatus = 0;
    m_parseState = stateNone;
    m_State = KSSTATE_STOP;
    m_StartTime = 0;
    m_PauseTime = 0;
}

#pragma code_seg("PAGE")
// CUnpackerMXF::~CUnpackerMXF
//
CUnpackerMXF::~CUnpackerMXF()
{
    if (m_EvtQueue)
    {
        ProcessQueues();
    }

    DisconnectOutput(m_SinkMXF);
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CUnpackerMXF::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.
 */
STDMETHODIMP_(NTSTATUS)
CUnpackerMXF::
NonDelegatingQueryInterface
(
    REFIID  Interface,
    PVOID * Object
)
{
    PAGED_CODE();

    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface,IID_IUnknown))
    {
        *Object = PVOID(PMXF(this));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IMXF))
    {
        *Object = PVOID(PMXF(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER_1;
}

#pragma code_seg("PAGE")
NTSTATUS
CUnpackerMXF::SetState(KSSTATE State)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE,("SetState %d from %d",State,m_State));

    if (State == m_State) 
    {
        return STATUS_SUCCESS;
    }

    NTSTATUS ntStatus;
    REFERENCE_TIME Now;

    ntStatus = m_Clock->GetTime(&Now);    
    if (NT_SUCCESS(ntStatus))
    {
        if (m_State == KSSTATE_RUN)
        {
            // Leaving run, set the pause time
            //
            m_PauseTime = Now - m_StartTime;
            _DbgPrintF(DEBUGLVL_VERBOSE,("Leaving run; pause time 0x%08X %08X",
                (ULONG)(m_PauseTime >> 32),
                (ULONG)(m_PauseTime & 0xFFFFFFFF)));
        }
        else if (State != KSSTATE_STOP && m_State == KSSTATE_STOP)
        {
            // Moving from stop, reset everything to zero.
            //
            m_PauseTime = 0;
            m_StartTime = 0;
            _DbgPrintF(DEBUGLVL_VERBOSE,("Acquire from stop; zero time"));
        }
        if (State == KSSTATE_RUN)
        {
            // Entering run, set the start time
            //
            m_StartTime = Now - m_PauseTime;
            _DbgPrintF(DEBUGLVL_VERBOSE,("Entering run; start time 0x%08X %08X",
                (ULONG)(m_StartTime >> 32),
                (ULONG)(m_StartTime & 0xFFFFFFFF)));
        }
    
        m_State = State;
    }
    return ntStatus;
}

#pragma code_seg("PAGE")
// CUnpackerMXF::ConnectOutput
//
// It is an error to connect to nothing (use DisconnectOutput) or to connect
// an unpacker to more than one sink (split the stream instead).
//
NTSTATUS CUnpackerMXF::ConnectOutput(PMXF sinkMXF)
{
    PAGED_CODE();

    if ((sinkMXF) && (m_SinkMXF == m_AllocatorMXF))
    {
        _DbgPrintF(DEBUGLVL_BLAB, ("ConnectOutput"));
        m_SinkMXF = sinkMXF;
        return STATUS_SUCCESS;
    }
    _DbgPrintF(DEBUGLVL_TERSE, ("ConnectOutput failed"));
    return STATUS_UNSUCCESSFUL;
}

#pragma code_seg("PAGE")
// CUnpackerMXF::DisconnectOutput
//
// Validate that the unpacker is connected and the disconnection applies
// to the correct filter.
//
NTSTATUS CUnpackerMXF::DisconnectOutput(PMXF sinkMXF)
{
    PAGED_CODE();

    if ((m_SinkMXF == sinkMXF) || (!sinkMXF))
    {
        _DbgPrintF(DEBUGLVL_BLAB, ("DisconnectOutput"));
        m_SinkMXF = m_AllocatorMXF;
        return STATUS_SUCCESS;
    }
    _DbgPrintF(DEBUGLVL_TERSE, ("DisconnectOutput failed"));
    return STATUS_UNSUCCESSFUL;
}

#pragma code_seg()
// CUnpackerMXF::PutMessage
//
// An unpacker's upper edge is type dependent, but it is not by definition an MXF interface.
// Therefore this method should never be called.
//
NTSTATUS CUnpackerMXF::PutMessage(PDMUS_KERNEL_EVENT)
{
    return STATUS_NOT_IMPLEMENTED;
}

#pragma code_seg()
// CUnpackerMXF::QueueShortEvent
//
// Create and put an MXF event with a short message (anything other than system exclusive data).
// By definition this data must fit in 4 bytes or less.
//
NTSTATUS CUnpackerMXF::QueueShortEvent( PBYTE     pbData,
                                        USHORT    cbData,
                                        USHORT    wChannelGroup,
                                        ULONGLONG ullPresTime,
                                        ULONGLONG ullBytePosition)
{
    _DbgPrintF(DEBUGLVL_VERBOSE, ("QueueShortEvent bytePos: 0x%I64X",ullBytePosition));
    NTSTATUS ntStatus;

    PDMUS_KERNEL_EVENT  pDMKEvt;

    _DbgPrintF(DEBUGLVL_BLAB, ("QueueShortEvent"));

    ntStatus = m_AllocatorMXF->GetMessage(&pDMKEvt);
    if (NT_SUCCESS(ntStatus) && pDMKEvt)
    {
        pDMKEvt->cbEvent          = cbData;
        pDMKEvt->usFlags          = 0;
        pDMKEvt->usChannelGroup   = wChannelGroup;
        pDMKEvt->ullPresTime100ns = ullPresTime;
        pDMKEvt->ullBytePosition  = ullBytePosition;
        pDMKEvt->pNextEvt         = NULL;

        // Short event by definition is < sizeof(PBYTE)
        //
        ASSERT(cbData <= sizeof(PBYTE));
        RtlCopyMemory(pDMKEvt->uData.abData, pbData, cbData);
        DumpDMKEvt(pDMKEvt,DEBUGLVL_VERBOSE);

        if (m_EvtQueue)
        {
            PDMUS_KERNEL_EVENT pDMKEvtQueue = m_EvtQueue;
            while (pDMKEvtQueue->pNextEvt)
            {
                pDMKEvtQueue = pDMKEvtQueue->pNextEvt;
            }
            pDMKEvtQueue->pNextEvt = pDMKEvt;
        }
        else
        {
            m_EvtQueue = pDMKEvt;
        }
    }
    else
    {
        if (!pDMKEvt)
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            _DbgPrintF(DEBUGLVL_TERSE, ("QueueShortEvent failed to allocate event"));
        }
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("QueueShortEvent failed:%x", ntStatus));
        }
    }

    return ntStatus;
}

#pragma code_seg()
// CUnpackerMXF::QueueSysEx
//
// Create and put an MXF event which contains system exclusive data. This data must already
// be truncated into page-sized buffers.
//
NTSTATUS CUnpackerMXF::QueueSysEx(PBYTE     pbData,
                                  USHORT    cbData,
                                  USHORT    wChannelGroup,
                                  ULONGLONG ullPresTime,
                                  BOOL      fIsContinued,
                                  ULONGLONG ullBytePosition)
{
    ASSERT(cbData <= m_AllocatorMXF->GetBufferSize());

    _DbgPrintF(DEBUGLVL_VERBOSE, ("QueueSysEx bytePos: 0x%I64X",ullBytePosition));

    PDMUS_KERNEL_EVENT pDMKEvt;
    NTSTATUS ntStatus;
    ntStatus = m_AllocatorMXF->GetMessage(&pDMKEvt);
    if (!pDMKEvt)
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("QueueSysEx: alloc->GetMessage failed"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Build the event.
    //
    pDMKEvt->cbEvent          = cbData;
    pDMKEvt->usFlags          = (USHORT)(fIsContinued ? DMUS_KEF_EVENT_INCOMPLETE : 0);
    pDMKEvt->usChannelGroup   = wChannelGroup;
    pDMKEvt->ullPresTime100ns = ullPresTime;
    pDMKEvt->ullBytePosition  = ullBytePosition;
    pDMKEvt->pNextEvt         = NULL;

    if (cbData <= sizeof(PBYTE))
    {
        RtlCopyMemory(&pDMKEvt->uData.abData[0], pbData, cbData);
    }
    else
    {
        // Event data won't fit in uData, so allocate some memory to
        // hold it.
        //
        (void) m_AllocatorMXF->GetBuffer(&(pDMKEvt->uData.pbData));

        if (pDMKEvt->uData.pbData ==  NULL)
        {
            m_AllocatorMXF->PutMessage(pDMKEvt);

            _DbgPrintF(DEBUGLVL_TERSE, ("QueueSysEx: alloc->GetBuffer failed at 0x%X %08X",ULONG(ullBytePosition >> 32),ULONG(ullBytePosition & 0x0FFFFFFFF)));
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlCopyMemory(pDMKEvt->uData.pbData, pbData, cbData);
    }

    DumpDMKEvt(pDMKEvt,DEBUGLVL_VERBOSE);
    if (m_EvtQueue)
    {
        PDMUS_KERNEL_EVENT pDMKEvtQueue = m_EvtQueue;
        while (pDMKEvtQueue->pNextEvt)
        {
            pDMKEvtQueue = pDMKEvtQueue->pNextEvt;
        }
        pDMKEvtQueue->pNextEvt = pDMKEvt;
    }
    else
    {
        m_EvtQueue = pDMKEvt;
    }

    return STATUS_SUCCESS;
}

#pragma code_seg()
/*****************************************************************************
 * CUnpackerMXF::AdjustTimeForState()
 *****************************************************************************
 * Adjust the time for the graph state. Default implementation does nothing.
 */
void CUnpackerMXF::AdjustTimeForState(REFERENCE_TIME *Time)
{
}

#pragma code_seg()
// CUnpackerMXF::UnpackEventBytes
//
// This is basically a MIDI parser with state. It assumes nothing about alignment of
// events to the buffers that are passed in - a message may cross calls.
//
// QueueEvent's return code is not checked; we don't want to lose state if we
// can't queue a message.
//
// We must set the ullBytePosition in the event that we send along.
// This is equal to the number of bytes in the event PLUS the IN param ullBytePosition
//
NTSTATUS CUnpackerMXF::UnpackEventBytes(ULONGLONG ullCurrentTime,
                                        USHORT    usChannelGroup,
                                        PBYTE     pbDataStart,
                                        ULONG     cbData,
                                        ULONGLONG ullBytePosition)
{
    PBYTE   pbData = pbDataStart;
    PBYTE   pbSysExStart;
    BYTE    bData;
    USHORT  buffSize;
    
    buffSize = m_AllocatorMXF->GetBufferSize();

    _DbgPrintF(DEBUGLVL_BLAB, ("UnpackEventBytes"));
    _DbgPrintF(DEBUGLVL_VERBOSE, ("UnpackEventBytes bytePos: 0x%I64X",ullBytePosition));
    
    if (m_parseState == stateInSysEx)
    {
        pbSysExStart = pbData;
    }

    while (cbData)
    {
        ullBytePosition++;
        bData = *pbData++;
        cbData--;

        _DbgPrintF(DEBUGLVL_BLAB, ("UnpackEventBytes byte:0x%.2x", bData));

        // Realtime messages have priority over anything else. They can appear anywhere and
        // don't change the state of the stream.
        //
        if (IS_REALTIME_MSG(bData))
        {
            QueueShortEvent(&bData,         sizeof(bData),
                            usChannelGroup, ullCurrentTime,
                            ullBytePosition);

            // Did this interrupt a SysEx? Spit out the contiguous buffer so far
            // and reset the start pointer. State is still in SysEx.
            //
            // Other messages are copied as they are parsed so no need to change their
            // parsing state.
            //
            if (m_parseState == stateInSysEx)
            {
                USHORT cbSysEx = (USHORT)((pbData - 1) - pbSysExStart);

                if (cbSysEx)
                {
                    QueueSysEx(pbSysExStart,    cbSysEx,
                               usChannelGroup,  m_ullEventTime,
                               TRUE,            ullBytePosition);
                }

                pbSysExStart = pbData;
            }

            continue;
        }

        // If we're parsing a SysEx, just pass over data bytes - they will be dealt with
        // when we reach a terminating condition (end of buffer or a status byte).
        //
        if (m_parseState == stateInSysEx)
        {
            if (!IS_STATUS_BYTE(bData))
            {
                // Don't allow a single buffer to grow to more than the buffer size
                //
                USHORT cbSysEx = (USHORT)(pbData - pbSysExStart);
                if (cbSysEx >= buffSize)
                {
                    QueueSysEx(pbSysExStart,    cbSysEx, 
                               usChannelGroup,  m_ullEventTime, 
                               TRUE,            ullBytePosition);
                    pbSysExStart = pbData;
                }

                continue;
            }

            // Trickery: We have the end of the SysEx. We always want to plant an F7 in the end of
            // the sysex so anyone watching the buffers above us will know when it ends, even if
            // it was truncated. TODO: Indication of truncation?
            //
            pbData[-1] = SYSEX_END;

            // Unlike the above case, we are guaranteed at least one byte to pack here
            //
            QueueSysEx( pbSysExStart,   (USHORT)(pbData - pbSysExStart), 
                        usChannelGroup, m_ullEventTime,
                        FALSE,          ullBytePosition);

            // Restore original data. If this was a real end of sysex, then eat the byte and
            // continue.
            //
            pbData[-1] = bData;

            m_parseState = stateNone;
            if (IS_SYSEX_END(bData))
            {
                continue;
            }
        }

        // If we're starting a SysEx, tag it.
        //
        if (IS_SYSEX(bData))
        {
            // Note that we've already advanced over the start byte.
            //
            m_ullEventTime = ullCurrentTime;
            pbSysExStart = pbData - 1;
            m_parseState = stateInSysEx;

            continue;
        }

        if (IS_STATUS_BYTE(bData))
        {
            // We have a status byte. Even if we're already in the middle of a short
            // message, we have to start a new one
            //
            m_abShortMsg[0]     = bData;
            m_pbShortMsg        = &m_abShortMsg[1];
            m_cbShortMsgLeft    = STATUS_MSG_DATA_BYTES(bData);
            m_ullEventTime      = ullCurrentTime;
            m_parseState             = stateInShortMsg;

            // Update running status
            // System common -> clear running status
            // Channel message -> change running status
            //
            m_bRunningStatus = 0;
            if (IS_CHANNEL_MSG(bData))
            {
                m_bRunningStatus = bData;
            }
        }
        else
        {
            // Not a status byte. If we're not in a short message,
            // start one with running status.
            //
            if (m_parseState != stateInShortMsg)
            {
#ifdef DEBUG
                if (m_parseState == stateInShortMsg)
                {
                    //Trace("Short message interrupted by another short msg");
                }
#endif
                if (m_bRunningStatus == 0)
                {
                    //Trace("Attempt to use running status with no pending status byte");
                    continue;
                }

                m_abShortMsg[0]     = m_bRunningStatus;
                m_pbShortMsg        = &m_abShortMsg[1];
                m_cbShortMsgLeft    = STATUS_MSG_DATA_BYTES(m_bRunningStatus);
                m_ullEventTime      = ullCurrentTime;
                m_parseState             = stateInShortMsg;
            }

            // Now we are guaranteed to be in a short message, and can safely add this
            // byte. Note that since running status is only allowed on channel messages,
            // we are also guaranteed at least one byte of expected data, so no need
            // to check for that.
            //
            *m_pbShortMsg++ = bData;
            m_cbShortMsgLeft--;
        }

        // See if we've finished a short message, and if so, queue it.
        //
        if (m_parseState == stateInShortMsg && m_cbShortMsgLeft == 0)
        {
            QueueShortEvent(    m_abShortMsg,   (USHORT)(m_pbShortMsg - m_abShortMsg), 
                                usChannelGroup, m_ullEventTime,
                                ullBytePosition);
            m_parseState = stateNone;
        }
    }

    // If we got part of a SysEx but ran out of buffer, queue that part
    // without leaving the SysEx
    //
    if (m_parseState == stateInSysEx)
    {
        QueueSysEx( pbSysExStart,   (USHORT)(pbData - pbSysExStart), 
                    usChannelGroup, m_ullEventTime, 
                    TRUE,           ullBytePosition);
    }

    return STATUS_SUCCESS;
}

#pragma code_seg()
NTSTATUS CUnpackerMXF::ProcessQueues(void)
{
    NTSTATUS ntStatus;
    
    if (m_EvtQueue)
    {
        ntStatus = m_SinkMXF->PutMessage(m_EvtQueue);
        m_EvtQueue = NULL;
    }
    else
    {
        ntStatus = STATUS_SUCCESS;
    }
    return ntStatus;
}

//  Find the last queued item, and set its position.
#pragma code_seg()
NTSTATUS CUnpackerMXF::UpdateQueueTrailingPosition(ULONGLONG ullBytePosition)
{
    if (m_EvtQueue)
    {
        PDMUS_KERNEL_EVENT pDMKEvtQueue = m_EvtQueue;
        while (pDMKEvtQueue->pNextEvt)
        {
            pDMKEvtQueue = pDMKEvtQueue->pNextEvt;
        }
        pDMKEvtQueue->ullBytePosition = ullBytePosition;
        return STATUS_SUCCESS;
    }
    return STATUS_UNSUCCESSFUL;
}

///////////////////////////////////////////////////////////////////////
//
// CDMusUnpackerMXF
//
// Unpacker which understands DirectMusic buffer format.
//
#pragma code_seg("PAGE")
// CDMusUnpackerMXF::CDMusUnpackerMXF
//
CDMusUnpackerMXF::CDMusUnpackerMXF(CAllocatorMXF *allocatorMXF,PMASTERCLOCK  Clock) 
                : CUnpackerMXF(allocatorMXF,Clock)
{
}

#pragma code_seg("PAGE")
// CDMusUnpackerMXF::~CDMusUnpackerMXF
//
CDMusUnpackerMXF::~CDMusUnpackerMXF()
{
}

#pragma code_seg()
// CDMusUnpackerMXF::SinkIRP
//
// This does all the work. Use the MIDI parser to split up DirectMusic events.
// Using the parser is a bit of overkill, but it handles saving state across
// buffers for SysEx, which we have to support.
//
NTSTATUS CDMusUnpackerMXF::SinkIRP(PBYTE pbData,
                                   ULONG cbData,
                                   ULONGLONG ullBaseTime,
                                   ULONGLONG ullBytePosition)
{
#if (DEBUG_LEVEL >= DEBUGLVL_VERBOSE)
    KdPrint(("'DMus: SinkIRP %lu @ %p, bytePos 0x%x\n",cbData,pbData,ullBytePosition & 0x0ffffffff));
#endif  //  (DEBUG_LEVEL >= DEBUGLVL_VERBOSE)
    _DbgPrintF(DEBUGLVL_VERBOSE, ("DMus:SinkIRP %lu bytes, bytePos 0x%I64X",cbData,ullBytePosition));

    USHORT  buffSize = m_AllocatorMXF->GetBufferSize();
    while (cbData)
    {
        DMUS_EVENTHEADER *pEvent = (DMUS_EVENTHEADER *)pbData;
        DWORD cbFullEvent = DMUS_EVENT_SIZE(pEvent->cbEvent);

        _DbgPrintF(DEBUGLVL_VERBOSE, ("DMus:SinkIRP cbEvent:%lu, rounds to %lu, ",
                                                pEvent->cbEvent, cbFullEvent));
        _DbgPrintF(DEBUGLVL_VERBOSE, ("DMus:SinkIRP new bytePos: 0x%I64X",ullBytePosition));
        if (cbData >= cbFullEvent)
        {
            ullBytePosition += (cbFullEvent - pEvent->cbEvent); //  all but the data
            pbData += cbFullEvent;
            cbData -= cbFullEvent;

            // Event is intact, let's build an MXF event for it
            //
            PBYTE pbThisEvent = (PBYTE)(pEvent + 1);
            ULONG  cbThisEvent = pEvent->cbEvent;

            // If this event is marked unstructured, just pull it wholesale out of the
            // MIDI stream and pack it
            //
            if (!(pEvent->dwFlags & DMUS_EVENT_STRUCTURED))
            {
                while (cbThisEvent)
                {
                    ULONG cbThisPage = min(cbThisEvent, buffSize);
                    cbThisEvent -= cbThisPage;

                    ullBytePosition += cbThisPage;  //  QSysX won't add cbEvent, it just copies ull into evt
                    // TODO: Failure case? (out of memory)
                    //
                    (void) QueueSysEx( pbThisEvent, 
                                       (USHORT)cbThisPage, 
                                       (WORD) pEvent->dwChannelGroup,
                                       ullBaseTime + pEvent->rtDelta,
                                       cbData ? TRUE : FALSE,
                                       ullBytePosition);
                    pbThisEvent += cbThisPage;
                }
            }            
            else
            {
                UnpackEventBytes(   ullBaseTime + pEvent->rtDelta,
                                    (WORD)pEvent->dwChannelGroup,
                                    pbThisEvent,
                                    cbThisEvent,
                                    ullBytePosition);
                ullBytePosition += cbThisEvent;
            }
            continue;   //  loop again
        }
        ullBytePosition += cbData;
        _DbgPrintF(DEBUGLVL_TERSE,("ERROR:Not enough data for a DMUS_EVENTHEADER + data"));
        UpdateQueueTrailingPosition(ullBytePosition);
        return STATUS_INVALID_PARAMETER_2;
    }

    return STATUS_SUCCESS;
}


///////////////////////////////////////////////////////////////////////
//
// CKsUnpackerMXF
//
// Unpacker which understands KSMUSICFORMAT.
//

#pragma code_seg("PAGE")
// CKsUnpackerMXF::CKsUnpackerMXF
//
CKsUnpackerMXF::CKsUnpackerMXF(CAllocatorMXF *allocatorMXF,PMASTERCLOCK Clock)
              : CUnpackerMXF(allocatorMXF,Clock)
{
}

#pragma code_seg("PAGE")
// CKsUnpackerMXF::~CKsUnpackerMXF
//
CKsUnpackerMXF::~CKsUnpackerMXF()
{
}

#pragma code_seg()
// CKsUnpackerMXF::SinkIRP
//
// Parse the MIDI stream, assuming nothing about what might cross a packet or IRP boundary.
//
// An IRP buffer contains one or more KSMUSICFORMAT headers, each with data. Pull them apart
// and call UnpackEventBytes to turn them into messages.
//
NTSTATUS CKsUnpackerMXF::SinkIRP(PBYTE pbData,
                                 ULONG cbData,
                                 ULONGLONG ullBaseTime,
                                 ULONGLONG ullBytePosition)
{
#if (DEBUG_LEVEL >= DEBUGLVL_VERBOSE)
    KdPrint(("'Ks: SinkIRP %lu @ %p, bytePos 0x%x\n",cbData,pbData,ullBytePosition & 0x0ffffffff));
#endif  //  (DEBUG_LEVEL >= DEBUGLVL_VERBOSE)
    _DbgPrintF(DEBUGLVL_BLAB, ("Ks:SinkIRP %lu bytes, bytePos: 0x%I64X",cbData,ullBytePosition));
    // This data can consist of multiple KSMUSICFORMAT headers, each w/ associated bytestream data
    //
    ULONGLONG ullCurrentTime = ullBaseTime;
    while (cbData)
    {
        if (cbData < sizeof(KSMUSICFORMAT))
        {
            _DbgPrintF(DEBUGLVL_TERSE,("ERROR:Not enough data for a KSMUSICFORMAT + data"));
            UpdateQueueTrailingPosition(ullBytePosition + cbData);
            return STATUS_INVALID_PARAMETER_2;
        }

        PKSMUSICFORMAT pksmf = (PKSMUSICFORMAT)pbData;
        pbData += sizeof(KSMUSICFORMAT);
        cbData -= sizeof(KSMUSICFORMAT);

        ULONG cbPacket = pksmf->ByteCount;
        if (cbPacket > cbData)
        {
            _DbgPrintF(DEBUGLVL_TERSE,("ERROR:Packet length longer than IRP buffer - truncated"));
            cbPacket = cbData;
        }

        ULONG   cbPad = DWORD_ALIGN(cbPacket) - cbPacket;
        // TODO: What is the base of this clock
        // TODO: How do we relate this to the master clock? Is legacy time always KeQueryPerformanceCounter
        //
        ullCurrentTime += (pksmf->TimeDeltaMs * 10000);
        ullBytePosition += (sizeof(KSMUSICFORMAT) + cbPad);  //  fudging a little, but it works out
        _DbgPrintF(DEBUGLVL_VERBOSE, ("Ks:SinkIRP new bytePos: 0x%I64X",ullBytePosition));

        ULONG cbThisPacket = cbPacket;
        USHORT  buffSize = m_AllocatorMXF->GetBufferSize();

        while (cbThisPacket)
        {
            USHORT cbThisEvt;
            if (buffSize >= cbThisPacket)
            {
                cbThisEvt = (USHORT) cbThisPacket;
            }
            else
            {
                cbThisEvt = buffSize;
            }

            ullBytePosition += cbThisEvt;
            QueueSysEx(pbData, cbThisEvt, 1, ullCurrentTime, TRUE, ullBytePosition);

            pbData += cbThisEvt;
            cbThisPacket -= cbThisEvt;
        }

        cbPacket += cbPad;
        ASSERT(cbData >= cbPacket);
        pbData += cbPad;
        cbData -= cbPacket;
    }

    return STATUS_SUCCESS;
}

/*****************************************************************************
 * CKsUnpackerMXF::AdjustTimeForState()
 *****************************************************************************
 * Adjust the time for the graph state. 
 */
#pragma code_seg()
void CKsUnpackerMXF::AdjustTimeForState(REFERENCE_TIME *Time)
{
    if (m_State == KSSTATE_RUN)
    {
        *Time += m_StartTime;
    }
    else
    {
        *Time += m_PauseTime;   //  this is all wrong, but what can we do?
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\ports\midi\filter.cpp ===
/*****************************************************************************
 * filter.cpp - midi port filter implementation
 *****************************************************************************
 * Copyright (c) 1997-2000 Microsoft Corporation.  All rights reserved.
 */

#include "private.h"



/*****************************************************************************
 * Constants
 */

#pragma code_seg("PAGE")
/*****************************************************************************
 * PropertyTable_Pin
 *****************************************************************************
 * List of pin properties supported by the property handler.
 */
DEFINE_KSPROPERTY_TABLE(PropertyTable_Pin) 
{
    DEFINE_KSPROPERTY_ITEM_PIN_CINSTANCES(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_CTYPES(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_DATAFLOW(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_DATARANGES(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_DATAINTERSECTION(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_INTERFACES(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_MEDIUMS(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_COMMUNICATION(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_GLOBALCINSTANCES(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_NECESSARYINSTANCES(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_PHYSICALCONNECTION(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_CATEGORY(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_NAME(PropertyHandler_Pin)
};

/*****************************************************************************
 * PropertyTable_Topology
 *****************************************************************************
 * List of topology properties supported by the property handler.
 */
DEFINE_KSPROPERTY_TOPOLOGYSET
(
    PropertyTable_Topology,
    PropertyHandler_Topology
);

/*****************************************************************************
 * PropertyTable_FilterMidi
 *****************************************************************************
 * Table of properties supported by the filter property handler.
 */
KSPROPERTY_SET PropertyTable_FilterMidi[] =
{
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_Pin,
        SIZEOF_ARRAY(PropertyTable_Pin),
        PropertyTable_Pin,
        0,
        NULL
    ),
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_Topology,
        SIZEOF_ARRAY(PropertyTable_Topology),
        PropertyTable_Topology,
        0,
        NULL
    )
};


/*****************************************************************************
 * Factory 
 */

#pragma code_seg("PAGE")
/*****************************************************************************
 * CreatePortFilterMidi()
 *****************************************************************************
 * Creates a MIDI port driver filter.
 */
NTSTATUS
CreatePortFilterMidi
(
    OUT     PUNKNOWN *  Unknown,
    IN      REFCLSID,
    IN      PUNKNOWN    UnknownOuter    OPTIONAL,
    IN      POOL_TYPE   PoolType
)
{
    PAGED_CODE();

    ASSERT(Unknown);

    _DbgPrintF(DEBUGLVL_LIFETIME,("Creating MIDI Filter"));

    STD_CREATE_BODY(CPortFilterMidi,Unknown,UnknownOuter,PoolType);
}


/*****************************************************************************
 * Member functions.
 */

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortFilterMidi::~CPortFilterMidi()
 *****************************************************************************
 * Destructor.
 */
CPortFilterMidi::~CPortFilterMidi()
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_LIFETIME,("Destroying MIDI Filter (0x%08x)",this));

    if (m_Port)
    {
        m_Port->Release();
        m_Port = NULL;
    }

    if (m_propertyContext.pulPinInstanceCounts)
    {
        delete [] m_propertyContext.pulPinInstanceCounts;
    }
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortFilterMidi::Init()
 *****************************************************************************
 * Initializes the object.
 */
STDMETHODIMP_(NTSTATUS)
CPortFilterMidi::
Init
(
    IN  CPortMidi *Port_
)
{
    PAGED_CODE();

    ASSERT(Port_);

    _DbgPrintF(DEBUGLVL_LIFETIME,("Initializing MIDI Filter (0x%08x)",this));

    m_Port = Port_;
    m_Port->AddRef();

    //
    // Set up context for properties.
    //
    m_propertyContext.pSubdevice           = PSUBDEVICE(m_Port);
    m_propertyContext.pSubdeviceDescriptor = m_Port->m_pSubdeviceDescriptor;
    m_propertyContext.pPcFilterDescriptor  = m_Port->m_pPcFilterDescriptor;
    m_propertyContext.pUnknownMajorTarget  = m_Port->m_Miniport;
    m_propertyContext.pUnknownMinorTarget  = NULL;
    m_propertyContext.ulNodeId             = ULONG(-1);
    m_propertyContext.pulPinInstanceCounts = 
        new(NonPagedPool,'cIcP') ULONG[m_Port->m_pSubdeviceDescriptor->PinCount];

    NTSTATUS ntStatus = STATUS_SUCCESS;

    if (! m_propertyContext.pulPinInstanceCounts)
    {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    return ntStatus;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortFilterMidi::NewIrpTarget()
 *****************************************************************************
 * Creates and initializes a pin object.
 */
STDMETHODIMP_(NTSTATUS)
CPortFilterMidi::
NewIrpTarget
(
    OUT     PIRPTARGET *        IrpTarget,
    OUT     BOOLEAN *           ReferenceParent,
    IN      PUNKNOWN            OuterUnknown,
    IN      POOL_TYPE           PoolType,
    IN      PDEVICE_OBJECT      DeviceObject,
    IN      PIRP                Irp,
    OUT     PKSOBJECT_CREATE    ObjectCreate
)
{
    PAGED_CODE();

    ASSERT(IrpTarget);
    ASSERT(DeviceObject);
    ASSERT(Irp);
    ASSERT(ObjectCreate);

    ASSERT(m_Port);
    ASSERT(m_Port->m_pSubdeviceDescriptor);
    ASSERT(m_Port->m_pSubdeviceDescriptor->PinDescriptors);

    _DbgPrintF( DEBUGLVL_BLAB, ("CPortFilterMidi::NewPin"));

    PKSPIN_CONNECT pinConnect;
    NTSTATUS ntStatus =
        PcValidateConnectRequest
        (
            Irp,
            m_Port->m_pSubdeviceDescriptor,
            &pinConnect
        );
    
    if (NT_SUCCESS(ntStatus))
    {
        ULONG PinId = pinConnect->PinId;

        m_Port->PinCount
        ( 
            PinId,
            &(m_propertyContext.pSubdeviceDescriptor->
                PinInstances[PinId].FilterNecessary),
            &(m_propertyContext.pulPinInstanceCounts[PinId]),
            &(m_propertyContext.pSubdeviceDescriptor->
                PinInstances[PinId].FilterPossible),
            &(m_propertyContext.pSubdeviceDescriptor->
                PinInstances[PinId].GlobalCurrent),
            &(m_propertyContext.pSubdeviceDescriptor->
                PinInstances[PinId].GlobalPossible) 
        );

        ntStatus = 
            PcValidatePinCount
            (
                PinId,
                m_Port->m_pSubdeviceDescriptor,
                m_propertyContext.pulPinInstanceCounts
            );

        if (NT_SUCCESS(ntStatus))
        {
            ObjectCreate->CreateItemsCount  = 0;
            ObjectCreate->CreateItemsList   = NULL;

            PUNKNOWN pinUnknown;
            ntStatus =
                CreatePortPinMidi
                (
                    &pinUnknown,
                    GUID_NULL,
                    OuterUnknown,
                    PoolType
                );

            if (NT_SUCCESS(ntStatus))
            {
                PPORTPINMIDI pinMidi;

                ntStatus =
                    pinUnknown->QueryInterface
                    (
                        IID_IIrpTarget,
                        (PVOID *) &pinMidi
                    );

                if (NT_SUCCESS(ntStatus))
                {
                    //
                    // The QI for IIrpTarget actually gets IPortPinMidi.
                    //
                    ntStatus = 
                        pinMidi->Init
                        (
                            m_Port,
                            this,
                            pinConnect,
                            &m_Port->m_pSubdeviceDescriptor->
                                PinDescriptors[pinConnect->PinId]
                        );

                    if (NT_SUCCESS(ntStatus))
                    {
                        *ReferenceParent = TRUE;
                        *IrpTarget = pinMidi;
                    }
                    else
                    {
                        pinMidi->Release();
                    }
                }

                pinUnknown->Release();
            }

            if (! NT_SUCCESS(ntStatus))
            {
                PcTerminateConnection
                (   m_Port->m_pSubdeviceDescriptor
                ,   m_propertyContext.pulPinInstanceCounts
                ,   pinConnect->PinId
                );
            }
        }
    }

    return ntStatus;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortFilterMidi::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.
 */
STDMETHODIMP_(NTSTATUS)
CPortFilterMidi::
NonDelegatingQueryInterface
(
    REFIID  Interface,
    PVOID * Object
)
{
    PAGED_CODE();

    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface,IID_IUnknown))
    {
        *Object = PVOID(PPORTFILTERMIDI(this));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IIrpTarget))
    {
        // Cheat!  Get specific interface so we can reuse the IID.
        *Object = PVOID(PPORTFILTERMIDI(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortFilterMidi::DeviceIOControl()
 *****************************************************************************
 * Handles an IOCTL IRP.
 */
STDMETHODIMP_(NTSTATUS)
CPortFilterMidi::
DeviceIoControl
(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
)
{
    PAGED_CODE();

    ASSERT(DeviceObject);
    ASSERT(Irp);

    _DbgPrintF( DEBUGLVL_BLAB, ("CPortFilterMidi::DeviceIoControl"));

    NTSTATUS            ntStatus;
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);

    switch (irpSp->Parameters.DeviceIoControl.IoControlCode)
    {
    case IOCTL_KS_PROPERTY:
        ntStatus =
            PcHandlePropertyWithTable
            (
                Irp,
                m_Port->m_pSubdeviceDescriptor->FilterPropertyTable.PropertySetCount,
                m_Port->m_pSubdeviceDescriptor->FilterPropertyTable.PropertySets,
                &m_propertyContext
            );
        break;

    case IOCTL_KS_ENABLE_EVENT:
        {
            EVENT_CONTEXT EventContext;

            EventContext.pPropertyContext = &m_propertyContext;
            EventContext.pEventList = NULL;
            EventContext.ulPinId = ULONG(-1);
            EventContext.ulEventSetCount = m_Port->m_pSubdeviceDescriptor->FilterEventTable.EventSetCount;
            EventContext.pEventSets = m_Port->m_pSubdeviceDescriptor->FilterEventTable.EventSets;
            
            ntStatus =
                PcHandleEnableEventWithTable
                (
                    Irp,
                    &EventContext
                );
        }
        break;

    case IOCTL_KS_DISABLE_EVENT:
        {
            EVENT_CONTEXT EventContext;

            EventContext.pPropertyContext = &m_propertyContext;
            EventContext.pEventList = &(m_Port->m_EventList);
            EventContext.ulPinId = ULONG(-1);
            EventContext.ulEventSetCount = m_Port->m_pSubdeviceDescriptor->FilterEventTable.EventSetCount;
            EventContext.pEventSets = m_Port->m_pSubdeviceDescriptor->FilterEventTable.EventSets;

            ntStatus =
                PcHandleDisableEventWithTable
                (
                    Irp,
                    &EventContext
                );
        }
        break;

    default:
        return KsDefaultDeviceIoCompletion(DeviceObject, Irp);
    }

    Irp->IoStatus.Status = ntStatus;
    IoCompleteRequest(Irp,IO_NO_INCREMENT);
    return ntStatus;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortFilterMidi::Close()
 *****************************************************************************
 * Handles a flush IRP.
 */
STDMETHODIMP_(NTSTATUS)
CPortFilterMidi::
Close
(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
)
{
    PAGED_CODE();

    ASSERT(DeviceObject);
    ASSERT(Irp);

    //
    // free any events in the port event list associated with this
    // filter instance
    //
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
    KsFreeEventList( IrpStack->FileObject,
                     &( m_Port->m_EventList.List ),
                     KSEVENTS_SPINLOCK,
                     &( m_Port->m_EventList.ListLock) );

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp,IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}

DEFINE_INVALID_READ(CPortFilterMidi);
DEFINE_INVALID_WRITE(CPortFilterMidi);
DEFINE_INVALID_FLUSH(CPortFilterMidi);
DEFINE_INVALID_QUERYSECURITY(CPortFilterMidi);
DEFINE_INVALID_SETSECURITY(CPortFilterMidi);
DEFINE_INVALID_FASTDEVICEIOCONTROL(CPortFilterMidi);
DEFINE_INVALID_FASTREAD(CPortFilterMidi);
DEFINE_INVALID_FASTWRITE(CPortFilterMidi);

#pragma code_seg("PAGE")
/*****************************************************************************
 * PropertyHandler_Pin()
 *****************************************************************************
 * Property handler for pin description properties.
 */
static
NTSTATUS
PropertyHandler_Pin
(
    IN      PIRP        Irp,
    IN      PKSP_PIN    Pin,
    IN OUT  PVOID       Data
)
{
    PAGED_CODE();

    ASSERT(Irp);
    ASSERT(Pin);

    return
        PcPinPropertyHandler
        (   Irp
        ,   Pin
        ,   Data
        );
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * PropertyHandler_Topology()
 *****************************************************************************
 * Property handler for topology.
 */
static
NTSTATUS
PropertyHandler_Topology
(
    IN      PIRP        Irp,
    IN      PKSPROPERTY Property,
    IN OUT  PVOID       Data
)
{
    PAGED_CODE();

    ASSERT(Irp);
    ASSERT(Property);

    PPROPERTY_CONTEXT pPropertyContext =
        PPROPERTY_CONTEXT(Irp->Tail.Overlay.DriverContext[3]);
    ASSERT(pPropertyContext);

    PSUBDEVICE_DESCRIPTOR pSubdeviceDescriptor =
        pPropertyContext->pSubdeviceDescriptor;
    ASSERT(pSubdeviceDescriptor);

    return
        KsTopologyPropertyHandler
        (
            Irp,
            Property,
            Data,
            pSubdeviceDescriptor->Topology
        );
}

#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\ports\dmus\splitter.h ===
/*  Base definition of MIDI Transform Filter object

    Copyright (c) 1998-2000 Microsoft Corporation.  All rights reserved.
    
    05/10/98    Martin Puryear      Created this file

*/

#ifndef __SplitterMXF_H__
#define __SplitterMXF_H__

#include "MXF.h"
#include "Allocatr.h"


#define kNumSinkMXFs    32

class CSplitterMXF : public CMXF,
    public IMXF,
    public CUnknown
{
public:
    CSplitterMXF(CAllocatorMXF *allocatorMXF, PMASTERCLOCK clock);
    ~CSplitterMXF(void);

    DECLARE_STD_UNKNOWN();
    IMP_IMXF;
private:
    PDMUS_KERNEL_EVENT  MakeDMKEvtCopy(PDMUS_KERNEL_EVENT pDMKEvt);


    PMXF            m_SinkMXF[kNumSinkMXFs];
    DWORD           m_SinkMXFBitMap;
    PMASTERCLOCK    m_Clock;
};

#endif  //  __SplitterMXF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\ports\dmus\unpacker.h ===
/*  Base definition of MIDI event unpacker

    Copyright (c) 1998-2000 Microsoft Corporation.  All rights reserved.

    05/19/98    Created this file
    09/10/98    Reworked for kernel use

*/

#ifndef __UnpackerMXF_H__
#define __UnpackerMXF_H__

#include "MXF.h"
#include "Allocatr.h"


class CUnpackerMXF : public CMXF,
    public IMXF,
    public CUnknown
{
public:
    CUnpackerMXF(CAllocatorMXF *allocatorMXF,PMASTERCLOCK Clock);
    virtual ~CUnpackerMXF();

    DECLARE_STD_UNKNOWN();
    IMP_IMXF;

    // NOTE: All of these things will eventually be pulled out of the IRP
    //
    virtual NTSTATUS SinkIRP(   PBYTE bufferData, 
                                ULONG bufferSize, 
                                ULONGLONG ullBaseTime,
                                ULONGLONG bytePosition) = 0;

    // Common code for allocating and queueing an event
    //
    NTSTATUS QueueShortEvent(   PBYTE pbData, 
                                USHORT cbData, 
                                USHORT wChannelGroup,
                                ULONGLONG ullPresTime, 
                                ULONGLONG ullBytePosition);

    NTSTATUS QueueSysEx(        PBYTE pbData, 
                                USHORT cbData, 
                                USHORT wChannelGroup, 
                                ULONGLONG ullPresTime, 
                                BOOL fIsContinued,
                                ULONGLONG ullBytePosition);

    NTSTATUS UnpackEventBytes(  ULONGLONG ullCurrenTime, 
                                USHORT usChannelGroup, 
                                PBYTE pbData, 
                                ULONG cbData,
                                ULONGLONG ullBytePosition);

    NTSTATUS ProcessQueues(void);
    NTSTATUS UpdateQueueTrailingPosition(ULONGLONG ullBytePosition);

protected:
    virtual void AdjustTimeForState(REFERENCE_TIME *Time);

    KSSTATE     m_State;
    ULONGLONG   m_PauseTime;
    ULONGLONG   m_StartTime;

private:
    PMXF                m_SinkMXF;
    PDMUS_KERNEL_EVENT  m_EvtQueue;

    ULONGLONG           m_ullEventTime;
    BYTE                m_bRunningStatus;

    enum
    {
        stateNone,
        stateInShortMsg,
        stateInSysEx
    }                   m_parseState;
    ULONG               m_cbShortMsgLeft;
    BYTE                m_abShortMsg[4];
    PBYTE               m_pbShortMsg;
    PMASTERCLOCK        m_Clock;
};

class CDMusUnpackerMXF : public CUnpackerMXF
{
public:
    CDMusUnpackerMXF(CAllocatorMXF *allocatorMXF,PMASTERCLOCK Clock);
    ~CDMusUnpackerMXF();

    // NOTE: All of these things will eventually be pulled out of the IRP
    //
    NTSTATUS SinkIRP(PBYTE bufferData, 
                     ULONG bufferSize, 
                     ULONGLONG ullBaseTime,
                     ULONGLONG bytePosition);
};

class CKsUnpackerMXF : public CUnpackerMXF
{
public:
    CKsUnpackerMXF(CAllocatorMXF *allocatorMXF,PMASTERCLOCK Clock);
    ~CKsUnpackerMXF();

    // NOTE: All of these things will eventually be pulled out of the IRP
    //
    NTSTATUS SinkIRP(PBYTE bufferData, 
                     ULONG bufferSize, 
                     ULONGLONG ullBaseTime,
                     ULONGLONG bytePosition);
protected:
    void AdjustTimeForState(REFERENCE_TIME *Time);
};
#endif // __UnpackerMXF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\ports\dmus\splitter.cpp ===
/*  Base implementation of MIDI Transform Filter object 

    Copyright (c) 1998-2000 Microsoft Corporation.  All rights reserved.

    05/10/98    Created this file

*/

#include "private.h"
#include "Splitter.h"

CSplitterMXF::CSplitterMXF(CAllocatorMXF *allocatorMXF, PMASTERCLOCK clock)
:   CUnknown(NULL),
    CMXF(allocatorMXF)
{
    short count;

    m_SinkMXFBitMap = 0;
    for (count = 0;count < kNumSinkMXFs;count++)
    {
        m_SinkMXF[count] = NULL;
    }
    m_Clock = clock;
}

/*  Artfully remove this filter from the chain  */
CSplitterMXF::~CSplitterMXF(void)
{
}

/*****************************************************************************
 * CSplitterMXF::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.
 */
STDMETHODIMP_(NTSTATUS)
CSplitterMXF::
NonDelegatingQueryInterface
(
    REFIID  Interface,
    PVOID * Object
)
{
    PAGED_CODE();

    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface,IID_IUnknown))
    {
        *Object = PVOID(PMXF(this));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IMXF))
    {
        *Object = PVOID(PMXF(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER_1;
}

NTSTATUS 
CSplitterMXF::SetState(KSSTATE State)    
{   
    _DbgPrintF(DEBUGLVL_VERBOSE,("SetState %d",State));
    return STATUS_NOT_IMPLEMENTED;    
}

NTSTATUS CSplitterMXF::ConnectOutput(PMXF sinkMXF)
{
    DWORD   bitmap;
    short   count;

    if (m_SinkMXFBitMap == 0xFFFFFFFF)
        return STATUS_UNSUCCESSFUL;
    
    bitmap = m_SinkMXFBitMap;
    count = 0;
    
    for (count = 0;count < kNumSinkMXFs;count++)
    {
        if ((bitmap & 1) == 0)
        {
            break;
        }
        bitmap >>= 1;
    }    
    m_SinkMXF[count] = sinkMXF;
    m_SinkMXFBitMap |= (1 << count);
    
    return STATUS_SUCCESS;
}

NTSTATUS CSplitterMXF::DisconnectOutput(PMXF sinkMXF)
{
    DWORD bitmap;
    
    if (m_SinkMXFBitMap == 0)
    {
        return STATUS_UNSUCCESSFUL;
    }
    
    bitmap = m_SinkMXFBitMap;
    for (short count = 0;count < kNumSinkMXFs;count++)
    {
        if ((bitmap & 1) && (m_SinkMXF[count] == sinkMXF))
        {
            m_SinkMXF[count] = NULL;
            m_SinkMXFBitMap &= ~(1 << count);
        }
        bitmap >>= 1;
    }
    return STATUS_SUCCESS;
}

NTSTATUS CSplitterMXF::PutMessage(PDMUS_KERNEL_EVENT pDMKEvt)
{
    DWORD               bitmap;
    PDMUS_KERNEL_EVENT  pDMKEvt2;

    if (m_SinkMXFBitMap)
    {
        bitmap = m_SinkMXFBitMap;
        for (short count = 0;count < kNumSinkMXFs;count++)
        {
            if (bitmap & 1)
            {
                pDMKEvt2 = MakeDMKEvtCopy(pDMKEvt);
                if (pDMKEvt2 != NULL)
                {
                    m_SinkMXF[count]->PutMessage(pDMKEvt2);
                }
            }
            bitmap >>= 1;
        }
    }
    m_AllocatorMXF->PutMessage(pDMKEvt);

    return STATUS_SUCCESS;
}

PDMUS_KERNEL_EVENT CSplitterMXF::MakeDMKEvtCopy(PDMUS_KERNEL_EVENT pDMKEvt)
{
    PDMUS_KERNEL_EVENT  pDMKEvt2;

    if (m_AllocatorMXF != NULL)
    {
        m_AllocatorMXF->GetMessage(&pDMKEvt2);
        if (pDMKEvt2 != NULL)
        {
            ASSERT(pDMKEvt->cbStruct == pDMKEvt2->cbStruct);
            ASSERT(pDMKEvt->cbStruct == sizeof(DMUS_KERNEL_EVENT));

            (void) memcpy(pDMKEvt2,pDMKEvt, sizeof(DMUS_KERNEL_EVENT));
            if (pDMKEvt->cbEvent > sizeof(PBYTE))
            {
                (void) m_AllocatorMXF->GetBuffer(&(pDMKEvt2->uData.pbData));
                if (pDMKEvt2->uData.pbData)
                {
                    (void) memcpy(  pDMKEvt2->uData.pbData,
                                    pDMKEvt->uData.pbData,
                                    pDMKEvt->cbEvent);
                }
                else
                {
                    _DbgPrintF(DEBUGLVL_TERSE, ("MakeDMKEvtCopy: alloc->GetBuffer failed"));
                    m_AllocatorMXF->PutMessage(pDMKEvt2);
                    pDMKEvt2 = NULL;
                }
            }
            if (pDMKEvt->pNextEvt != NULL)
            {
                pDMKEvt2->pNextEvt = MakeDMKEvtCopy(pDMKEvt->pNextEvt);
            }
        }
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("MakeDMKEvtCopy: alloc->GetMessage failed"));
        }
    }
    else
    {
        pDMKEvt2 = NULL;
    }
    return pDMKEvt2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\ports\midi\pin.cpp ===
/*****************************************************************************
 * pin.cpp - midi port pin implementation
 *****************************************************************************
 * Copyright (c) 1997-2000 Microsoft Corporation.  All rights reserved.
 */

#include "private.h"



//
// this needs to be modified to reflect the desired frame size
// that will be allocated for source pins
// NOTE that this should go away with the new portcls.
//
#define HACK_FRAME_COUNT        3
#define HACK_SAMPLE_RATE        44100
#define HACK_BYTES_PER_SAMPLE   2
#define HACK_CHANNELS           2
#define HACK_MS_PER_FRAME       10
#define HACK_FRAME_SIZE         (   (   HACK_SAMPLE_RATE\
                                    *   HACK_BYTES_PER_SAMPLE\
                                    *   HACK_CHANNELS\
                                    *   HACK_MS_PER_FRAME\
                                    )\
                                /   1000\
                                )


//
// IRPLIST_ENTRY is used for the list of outstanding IRPs.  This structure is
// overlayed on the Parameters section of the current IRP stack location.  The
// reserved PVOID at the top preserves the OutputBufferLength, which is the
// only parameter that needs to be preserved.
//
typedef struct IRPLIST_ENTRY_
{
    PVOID       Reserved;
    PIRP        Irp;
    LIST_ENTRY  ListEntry;
} IRPLIST_ENTRY, *PIRPLIST_ENTRY;

#define IRPLIST_ENTRY_IRP_STORAGE(Irp) \
    PIRPLIST_ENTRY(&IoGetCurrentIrpStackLocation(Irp)->Parameters)

/*****************************************************************************
 * Constants.
 */

#pragma code_seg("PAGE")
DEFINE_KSPROPERTY_TABLE(PinPropertyTableConnection)
{
    DEFINE_KSPROPERTY_ITEM_CONNECTION_STATE
    (
    PinPropertyDeviceState,
    PinPropertyDeviceState
    ),
    DEFINE_KSPROPERTY_ITEM_CONNECTION_DATAFORMAT
    (
    PinPropertyDataFormat,
    PinPropertyDataFormat
    )
};

KSPROPERTY_SET PropertyTable_PinMidi[] =
{
    DEFINE_KSPROPERTY_SET
    (
    &KSPROPSETID_Connection,
    SIZEOF_ARRAY(PinPropertyTableConnection),
    PinPropertyTableConnection,
    0,NULL
    )
};

DEFINE_KSEVENT_TABLE(ConnectionEventTable) {
    DEFINE_KSEVENT_ITEM(
                       KSEVENT_CONNECTION_ENDOFSTREAM,
                       sizeof(KSEVENTDATA),
                       0,
                       NULL,
                       NULL, 
                       NULL
                       )
};

KSEVENT_SET EventTable_PinMidi[] =
{
    DEFINE_KSEVENT_SET(
                      &KSEVENTSETID_Connection,
                      SIZEOF_ARRAY(ConnectionEventTable),
                      ConnectionEventTable
                      )

};

/*****************************************************************************
 * Factory functions.
 */

#pragma code_seg("PAGE")
/*****************************************************************************
 * CreatePortPinMidi()
 *****************************************************************************
 * Creates a MIDI port driver pin.
 */
NTSTATUS
CreatePortPinMidi
(
    OUT     PUNKNOWN *  Unknown,
    IN      REFCLSID,
    IN      PUNKNOWN    UnknownOuter    OPTIONAL,
    IN      POOL_TYPE   PoolType
)
{
    PAGED_CODE();

    ASSERT(Unknown);

    _DbgPrintF(DEBUGLVL_LIFETIME,("Creating MIDI Pin"));

    STD_CREATE_BODY_
    (
        CPortPinMidi,
        Unknown,
        UnknownOuter,
        PoolType,
        PPORTPINMIDI
    );
}


/*****************************************************************************
 * Functions.
 */

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortPinMidi::~CPortPinMidi()
 *****************************************************************************
 * Destructor.
 */
CPortPinMidi::~CPortPinMidi()
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_LIFETIME,("Destroying MIDI Pin (0x%08x)",this));

    _DbgPrintF(DEBUGLVL_BLAB,("CPortPinMidi::~CPortPinMidi"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("#### Pin%p.~",this));

    ASSERT(!m_Stream);
    ASSERT(!m_IrpStream);
    ASSERT(!m_ServiceGroup);

    if (m_Worker)
    {
        KsUnregisterWorker(m_Worker);
        m_Worker = NULL;
    }
    else
    {
        _DbgPrintF(DEBUGLVL_TERSE,("KsWorker NULL, never unregistered!"));
    }

    if (m_DataFormat)
    {
        ::ExFreePool(m_DataFormat);
        m_DataFormat = NULL;
    }
    if (m_Port)
    {
        m_Port->Release();
        m_Port = NULL;
    }

    if (m_Filter)
    {
        m_Filter->Release();
        m_Filter = NULL;
    }

    if ((m_DataFlow == KSPIN_DATAFLOW_OUT) && (m_SysExBufferPtr))
    {
        FreeSysExBuffer();
        if (*m_SysExBufferPtr)
        {
            ::ExFreePool(*m_SysExBufferPtr);
            *m_SysExBufferPtr = 0;
        }
        ::ExFreePool(m_SysExBufferPtr);
        m_SysExBufferPtr = 0;
    }

#ifdef kAdjustingTimerRes
    ULONG   returnVal = ExSetTimerResolution(kMidiTimerResolution100ns,FALSE);   // 100 nanoseconds
    _DbgPrintF( DEBUGLVL_VERBOSE, ("*** Cleared timer resolution request (is now %d.%04d ms) ***",returnVal/10000,returnVal%10000));
#endif  //  kAdjustingTimerRes
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortPinMidi::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.
 */
STDMETHODIMP_(NTSTATUS)
CPortPinMidi::
NonDelegatingQueryInterface
(
REFIID  Interface,
PVOID * Object
)
{
    PAGED_CODE();

    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface,IID_IUnknown))
    {
        *Object = PVOID(PPORTPINMIDI(this));
    } else
        if (IsEqualGUIDAligned(Interface,IID_IIrpTarget))
    {
        // Cheat!  Get specific interface so we can reuse the IID.
        *Object = PVOID(PPORTPINMIDI(this));
    } else
        if (IsEqualGUIDAligned(Interface,IID_IIrpStreamNotify))
    {
        *Object = PVOID(PIRPSTREAMNOTIFY(this));
    } else
        if (IsEqualGUIDAligned(Interface,IID_IServiceSink))
    {
        *Object = PVOID(PSERVICESINK(this));
    } else
        if (IsEqualGUIDAligned(Interface,IID_IKsShellTransport))
    {
        *Object = PVOID(PIKSSHELLTRANSPORT(this));
    } else
        if (IsEqualGUIDAligned(Interface,IID_IKsWorkSink))
    {
        *Object = PVOID(PIKSWORKSINK(this));
    } else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER_2;
}


#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortPinMidi::Init()
 *****************************************************************************
 * Initializes the object.
 */
STDMETHODIMP_(NTSTATUS)
CPortPinMidi::
Init
(
IN      CPortMidi *             Port_,
IN      CPortFilterMidi *       Filter_,
IN      PKSPIN_CONNECT          PinConnect,
IN      PKSPIN_DESCRIPTOR       PinDescriptor
)
{
    PAGED_CODE();

    ASSERT(Port_);
    ASSERT(Port_->m_pSubdeviceDescriptor);
    ASSERT(Filter_);
    ASSERT(PinConnect);
    ASSERT(PinDescriptor);

    _DbgPrintF(DEBUGLVL_LIFETIME,("Initializing MIDI Pin (0x%08x)",this));

    //
    // Hold references to ancestors objects.
    //
    m_Port = Port_;
    m_Port->AddRef();

    m_Filter = Filter_;
    m_Filter->AddRef();

    //
    // Squirrel away some things.
    //
    m_Id          = PinConnect->PinId;
    m_Descriptor  = PinDescriptor;

    m_DeviceState   =   KSSTATE_STOP;
    m_TransportState =  KSSTATE_STOP;

    m_Flushing    = FALSE;
    m_DataFlow    = PinDescriptor->DataFlow;
    m_LastDPCWasIncomplete = FALSE;
    m_Suspended   = FALSE;
    m_NumberOfRetries = 0;

    InitializeListHead( &m_EventList );
    KeInitializeSpinLock( &m_EventLock );

    KsInitializeWorkSinkItem(&m_WorkItem,this);
    NTSTATUS ntStatus = KsRegisterCountedWorker(DelayedWorkQueue,&m_WorkItem,&m_Worker);

    InitializeInterlockedListHead(&m_IrpsToSend);
    InitializeInterlockedListHead(&m_IrpsOutstanding);

    //
    // Keep a copy of the format.
    //
    if ( NT_SUCCESS(ntStatus) )
    {
        ntStatus = PcCaptureFormat( &m_DataFormat,
                                    PKSDATAFORMAT(PinConnect + 1),
                                    m_Port->m_pSubdeviceDescriptor,
                                    m_Id );
    }

    ASSERT(m_DataFormat || !NT_SUCCESS(ntStatus));

#ifdef kAdjustingTimerRes
     ULONG   returnVal = ExSetTimerResolution(kMidiTimerResolution100ns,TRUE);   // 100 nanoseconds
    _DbgPrintF( DEBUGLVL_TERSE, ("*** Set timer resolution request (is now %d.%04d ms) ***",returnVal/10000,returnVal%10000));
#endif  //  kAdjustingTimerRes

    if (NT_SUCCESS(ntStatus))
    {
        InitializeStateVariables();
        m_StartTime = 0;
        m_PauseTime = 0;
        m_MidiMsgPresTime = 0;
        m_TimerDue100ns.QuadPart = 0;
        m_SysExByteCount = 0;
        m_UpdatePresTime = TRUE;

        ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
        if (m_DataFlow == KSPIN_DATAFLOW_OUT) //  MIDI capture
        {
            //
            //  PcSX - branch page
            //  PcSx - leaf pages
            //
            m_SysExBufferPtr =
            (PBYTE *)::ExAllocatePoolWithTag(NonPagedPool,PAGE_SIZE,'XScP');

            if (m_SysExBufferPtr)
            {
                PBYTE *pPagePtr;

                pPagePtr = m_SysExBufferPtr;

                *pPagePtr = (PBYTE)::ExAllocatePoolWithTag(NonPagedPool,PAGE_SIZE,'xScP');
                if (*pPagePtr == NULL)
                {
                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                }

                for (short ptrCount = 1;ptrCount < (PAGE_SIZE/sizeof(PBYTE));ptrCount++)
                {
                    pPagePtr++;
                    *pPagePtr = 0;
                }
            } else
            {
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }

    //
    // Reference the next pin if this is a source.  This must be undone if
    // this function fails.
    //
    if (NT_SUCCESS(ntStatus) && PinConnect->PinToHandle)
    {
        ntStatus = ObReferenceObjectByHandle( PinConnect->PinToHandle,
                                              GENERIC_READ | GENERIC_WRITE,
                                              NULL,
                                              KernelMode,
                                              (PVOID *) &m_ConnectionFileObject,
                                              NULL );

        if (NT_SUCCESS(ntStatus))
        {
            m_ConnectionDeviceObject = IoGetRelatedDeviceObject(m_ConnectionFileObject);
        }
    }

    //
    // Create an IrpStream to handling incoming streaming IRPs.
    //
    if (NT_SUCCESS(ntStatus))
    {
        ntStatus = PcNewIrpStreamVirtual( &m_IrpStream,
                                          NULL,
                                          m_DataFlow == KSPIN_DATAFLOW_IN,
                                          PinConnect,
                                          m_Port->m_DeviceObject );

        ASSERT(m_IrpStream || !NT_SUCCESS(ntStatus));
    }

    if (NT_SUCCESS(ntStatus))
    {
        ntStatus = BuildTransportCircuit();

#if (DBG)
        if (! NT_SUCCESS(ntStatus))
        {
            _DbgPrintF(DEBUGLVL_VERBOSE,("CPortPinMidi::Init]  BuildTransportCircuit() returned status 0x%08x",ntStatus));
        }
#endif
    }

    if (NT_SUCCESS(ntStatus))
    {
        //
        // Register a notification sink with the IrpStream for IRP arrivals.
        //
        m_IrpStream->RegisterNotifySink(PIRPSTREAMNOTIFY(this));

        //
        // Create the miniport stream object.
        //
        ASSERT(!m_Stream);

        ntStatus = m_Port->m_Miniport->NewStream( &m_Stream,
                                                  NULL,
                                                  NonPagedPool,
                                                  m_Id,
                                                  m_DataFlow == KSPIN_DATAFLOW_OUT,
                                                  m_DataFormat,
                                                  &(m_ServiceGroup) );

        if(!NT_SUCCESS(ntStatus))
        {
            // unregister the notification sink
            m_IrpStream->RegisterNotifySink(NULL);

            // don't trust the return values from the miniport
            m_ServiceGroup = NULL;
            m_Stream = NULL;
        }
    }

    //
    // Verify that the miniport has supplied us with the objects we require.
    //
    if (NT_SUCCESS(ntStatus) && ! m_Stream)
    {
        if (! m_Stream)
        {
            _DbgPrintF(DEBUGLVL_TERSE,("MINIPORT BUG:  Successful stream instantiation yielded NULL stream."));
            ntStatus = STATUS_UNSUCCESSFUL;
        }

        if (   (m_DataFlow == KSPIN_DATAFLOW_OUT) 
               &&  ! (m_ServiceGroup)
           )
        {
            _DbgPrintF(DEBUGLVL_TERSE,("MINIPORT BUG:  Capture stream did not supply service group."));
            ntStatus = STATUS_UNSUCCESSFUL;
        }
    }

    if (   NT_SUCCESS(ntStatus) 
           &&  (m_DataFlow == KSPIN_DATAFLOW_OUT) 
           &&  ! (m_ServiceGroup)
       )
    {
        _DbgPrintF(DEBUGLVL_TERSE,("MINIPORT BUG:  Capture stream did not supply service group."));
        ntStatus = STATUS_UNSUCCESSFUL;
    }

    if (NT_SUCCESS(ntStatus) && (m_DataFlow == KSPIN_DATAFLOW_IN))
    {
        KeInitializeDpc( &m_Dpc,
                         &::TimerDPC,
                         PVOID(this) );

        KeInitializeTimer(&m_TimerEvent);
    }

    if (NT_SUCCESS(ntStatus))
    {
        if (m_ServiceGroup)
        {
            m_ServiceGroup->AddMember(PSERVICESINK(this));
        }

        for (m_Index = 0; m_Index < MAX_PINS; m_Index++)
        {
            if (! m_Port->m_Pins[m_Index])
            {
                m_Port->m_Pins[m_Index] = this;
                if (m_Port->m_PinEntriesUsed <= m_Index)
                {
                    m_Port->m_PinEntriesUsed = m_Index + 1;
                }
                break;
            }
        }

        KeInitializeSpinLock(&m_DpcSpinLock);

        _DbgPrintF( DEBUGLVL_BLAB, ("Stream created"));


        //
        // Set up context for properties.
        //
        m_propertyContext.pSubdevice           = PSUBDEVICE(m_Port);
        m_propertyContext.pSubdeviceDescriptor = m_Port->m_pSubdeviceDescriptor;
        m_propertyContext.pPcFilterDescriptor  = m_Port->m_pPcFilterDescriptor;
        m_propertyContext.pUnknownMajorTarget  = m_Port->m_Miniport;
        m_propertyContext.pUnknownMinorTarget  = m_Stream;
        m_propertyContext.ulNodeId             = ULONG(-1);
    } else
    {
        // dereference next pin if this is a source pin
        if( m_ConnectionFileObject )
        {
            ObDereferenceObject( m_ConnectionFileObject );
            m_ConnectionFileObject = NULL;
        }

        // close the miniport stream
        ULONG ulRefCount;
        if (m_Stream)
        {
            ulRefCount = m_Stream->Release();
            ASSERT(ulRefCount == 0);
            m_Stream = NULL;
        }

        PIKSSHELLTRANSPORT distribution;
        if( m_RequestorTransport )
        {
            distribution = m_RequestorTransport;
        } else
        {
            distribution = m_QueueTransport;
        }

        if( distribution )
        {
            distribution->AddRef();
            while( distribution )
            {
                PIKSSHELLTRANSPORT nextTransport;
                distribution->Connect(NULL,&nextTransport,KSPIN_DATAFLOW_OUT);
                distribution->Release();
                distribution = nextTransport;
            }
        }

        // dereference the queue is there is one
        if( m_QueueTransport )
        {
            m_QueueTransport->Release();
            m_QueueTransport = NULL;
        }

        // dereference the requestor if there is one
        if( m_RequestorTransport )
        {
            m_RequestorTransport->Release();
            m_RequestorTransport = NULL;
        }

        if (m_IrpStream)
        {
            m_IrpStream->Release();
            m_IrpStream = NULL;
        }

        _DbgPrintF( DEBUGLVL_TERSE, ("Could not create new Stream. Error:%X", ntStatus));
    }

    return ntStatus;
}


#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortPinMidi::DeviceIoControl()
 *****************************************************************************
 * Handles an IOCTL IRP.
 */
STDMETHODIMP_(NTSTATUS)
CPortPinMidi::
DeviceIoControl
(
IN  PDEVICE_OBJECT  DeviceObject,
IN  PIRP            Irp
)
{
    PAGED_CODE();

    ASSERT(DeviceObject);
    ASSERT(Irp);

    NTSTATUS            ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    ASSERT(irpSp);

    _DbgPrintF( DEBUGLVL_BLAB, ("CPortPinMidi::DeviceIoControl"));

    switch (irpSp->Parameters.DeviceIoControl.IoControlCode)
    {
        case IOCTL_KS_PROPERTY:
            _DbgPrintF( DEBUGLVL_BLAB, ("IOCTL_KS_PROPERTY"));

            ntStatus =
            PcHandlePropertyWithTable
            (
            Irp,
            m_Port->m_pSubdeviceDescriptor->PinPropertyTables[m_Id].PropertySetCount,
            m_Port->m_pSubdeviceDescriptor->PinPropertyTables[m_Id].PropertySets,
            &m_propertyContext
            );
            break;

        case IOCTL_KS_ENABLE_EVENT:
            {
                _DbgPrintF( DEBUGLVL_BLAB, ("IOCTL_KS_ENABLE_EVENT"));

                EVENT_CONTEXT EventContext;

                EventContext.pPropertyContext = &m_propertyContext;
                EventContext.pEventList = NULL;
                EventContext.ulPinId = m_Id;
                EventContext.ulEventSetCount = m_Port->m_pSubdeviceDescriptor->PinEventTables[m_Id].EventSetCount;
                EventContext.pEventSets = m_Port->m_pSubdeviceDescriptor->PinEventTables[m_Id].EventSets;

                ntStatus =
                PcHandleEnableEventWithTable
                (
                Irp,
                &EventContext
                );
            }              
            break;

        case IOCTL_KS_DISABLE_EVENT:
            {
                _DbgPrintF( DEBUGLVL_BLAB, ("IOCTL_KS_DISABLE_EVENT"));

                EVENT_CONTEXT EventContext;

                EventContext.pPropertyContext = &m_propertyContext;
                EventContext.pEventList = &(m_Port->m_EventList);
                EventContext.ulPinId = m_Id;
                EventContext.ulEventSetCount = m_Port->m_pSubdeviceDescriptor->PinEventTables[m_Id].EventSetCount;
                EventContext.pEventSets = m_Port->m_pSubdeviceDescriptor->PinEventTables[m_Id].EventSets;

                ntStatus =
                PcHandleDisableEventWithTable
                (
                Irp,
                &EventContext
                );
            }              
            break;

        case IOCTL_KS_WRITE_STREAM:
        case IOCTL_KS_READ_STREAM:
            _DbgPrintF( DEBUGLVL_BLAB, ("IOCTL_KS_PACKETSTREAM"));

            if
                 (   m_TransportSink
                     && (! m_ConnectionFileObject)
                     &&  (m_Descriptor->Communication == KSPIN_COMMUNICATION_SINK)
                     &&  (   (   (m_DataFlow == KSPIN_DATAFLOW_IN)
                                 &&  (   irpSp->Parameters.DeviceIoControl.IoControlCode
                                         ==  IOCTL_KS_WRITE_STREAM
                                     )
                             )
                             ||  (   (m_DataFlow == KSPIN_DATAFLOW_OUT)
                                     &&  (   irpSp->Parameters.DeviceIoControl.IoControlCode
                                             ==  IOCTL_KS_READ_STREAM
                                         )
                                 )
                         )
                 )
            {
                if (m_DeviceState == KSSTATE_STOP)
                {
                    //
                    // Stopped...reject.
                    //
                    ntStatus = STATUS_INVALID_DEVICE_STATE;
                } else if (m_Flushing)
                {
                    //
                    // Flushing...reject.
                    //
                    ntStatus = STATUS_DEVICE_NOT_READY;
                } else
                {
                    // We going to submit the IRP to our pipe, so make sure that
                    // we start out with a clear status field.
                    Irp->IoStatus.Status = STATUS_SUCCESS;
                    //
                    // Send around the circuit.  We don't use KsShellTransferKsIrp
                    // because we want to stop if we come back around to this pin.
                    //
                    PIKSSHELLTRANSPORT transport = m_TransportSink;
                    while (transport)
                    {
                        if (transport == PIKSSHELLTRANSPORT(this))
                        {
                            //
                            // We have come back around to the pin.  Just complete
                            // the IRP.
                            //
                            if (ntStatus == STATUS_PENDING)
                            {
                                ntStatus = STATUS_SUCCESS;
                            }
                            break;
                        }

                        PIKSSHELLTRANSPORT nextTransport;
                        ntStatus = transport->TransferKsIrp(Irp,&nextTransport);

                        ASSERT(NT_SUCCESS(ntStatus) || ! nextTransport);

                        transport = nextTransport;
                    }
                }
            }
            break;

        case IOCTL_KS_RESET_STATE:
            {
            KSRESET ResetType = KSRESET_BEGIN;  //  initial value

                ntStatus = KsAcquireResetValue( Irp, &ResetType );
                DistributeResetState(ResetType);
            }
            break;

        default:
            return KsDefaultDeviceIoCompletion(DeviceObject, Irp);
    }

    if (ntStatus != STATUS_PENDING)
    {
        Irp->IoStatus.Status = ntStatus;
        IoCompleteRequest(Irp,IO_NO_INCREMENT);
    }

    return ntStatus;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortPinMidi::Close()
 *****************************************************************************
 * Handles a flush IRP.
 */
STDMETHODIMP_(NTSTATUS)
CPortPinMidi::
Close
(
IN  PDEVICE_OBJECT  DeviceObject,
IN  PIRP            Irp
)
{
    PAGED_CODE();

    ASSERT(DeviceObject);
    ASSERT(Irp);

    _DbgPrintF( DEBUGLVL_VERBOSE, ("CPortPinMidi::Close"));

    // !!! WARNING !!!
    // The order that these objects are
    // being released is VERY important!
    // All data used by the service routine
    // must exists until AFTER the stream
    // has been released.

    // remove this pin from the list of pins
    // that need servicing...
    if ( m_Port )
    {
        m_Port->m_Pins[m_Index] = NULL;
        while (  (m_Port->m_PinEntriesUsed != 0)
                 &&  !m_Port->m_Pins[m_Port->m_PinEntriesUsed - 1])
        {
            m_Port->m_PinEntriesUsed--;
        }
        // Servicing be gone!
        if ( m_ServiceGroup )
        {
            m_ServiceGroup->RemoveMember(PSERVICESINK(this));
            m_ServiceGroup->Release();
            m_ServiceGroup = NULL;
        }
    }

    //
    // Dereference next pin if this is a source pin.
    //
    if (m_ConnectionFileObject)
    {
        ObDereferenceObject(m_ConnectionFileObject);
        m_ConnectionFileObject = NULL;
    }

    // Tell the miniport to close the stream.
    if (m_Stream)
    {
        m_Stream->Release();
        m_Stream = NULL;
    }

    PIKSSHELLTRANSPORT distribution;
    if (m_RequestorTransport)
    {
        //
        // This section owns the requestor, so it does own the pipe, and the
        // requestor is the starting point for any distribution.
        //
        distribution = m_RequestorTransport;
    } else
    {
        //
        // This section is at the top of an open circuit, so it does own the
        // pipe and the queue is the starting point for any distribution.
        //
        distribution = m_QueueTransport;
    }

    //
    // If this section owns the pipe, it must disconnect the entire circuit.
    //
    if (distribution)
    {

        //
        // We are going to use Connect() to set the transport sink for each
        // component in turn to NULL.  Because Connect() takes care of the
        // back links, transport source pointers for each component will
        // also get set to NULL.  Connect() gives us a referenced pointer
        // to the previous transport sink for the component in question, so
        // we will need to do a release for each pointer obtained in this
        // way.  For consistency's sake, we will release the pointer we
        // start with (distribution) as well, so we need to AddRef it first.
        //
        distribution->AddRef();
        while (distribution)
        {
            PIKSSHELLTRANSPORT nextTransport;
            distribution->Connect(NULL,&nextTransport,KSPIN_DATAFLOW_OUT);
            distribution->Release();
            distribution = nextTransport;
        }
    }

    //
    // Dereference the queue if there is one.
    //
    if (m_QueueTransport)
    {
        m_QueueTransport->Release();
        m_QueueTransport = NULL;
    }

    //
    // Dereference the requestor if there is one.
    //
    if (m_RequestorTransport)
    {
        m_RequestorTransport->Release();
        m_RequestorTransport = NULL;
    }

    // Kill all the outstanding irps...
    ASSERT(m_IrpStream);
    if (m_IrpStream)
    {
        // Destroy the irpstream...
        m_IrpStream->Release();
        m_IrpStream = NULL;
    }
    //
    // Decrement instances counts.
    //
    ASSERT(m_Port);
    ASSERT(m_Filter);
    PcTerminateConnection
    (
    m_Port->m_pSubdeviceDescriptor,
    m_Filter->m_propertyContext.pulPinInstanceCounts,
    m_Id
    );

    //
    // free any events in the port event list associated with this pin
    //
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
    KsFreeEventList( irpSp->FileObject,
                     &( m_Port->m_EventList.List ),
                     KSEVENTS_SPINLOCK,
                     &( m_Port->m_EventList.ListLock) );

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp,IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}

DEFINE_INVALID_CREATE(CPortPinMidi);
DEFINE_INVALID_WRITE(CPortPinMidi);
DEFINE_INVALID_READ(CPortPinMidi);
DEFINE_INVALID_FLUSH(CPortPinMidi);
DEFINE_INVALID_QUERYSECURITY(CPortPinMidi);
DEFINE_INVALID_SETSECURITY(CPortPinMidi);
DEFINE_INVALID_FASTDEVICEIOCONTROL(CPortPinMidi);
DEFINE_INVALID_FASTREAD(CPortPinMidi);
DEFINE_INVALID_FASTWRITE(CPortPinMidi);

#pragma code_seg()
/*****************************************************************************
 * CPortPinMidi::IrpSubmitted()
 *****************************************************************************
 * IrpSubmitted - Called by IrpStream when a new irp
 * is submited into the irpStream. (probably from DeviceIoControl).
 * If there is not a timer pending, do work on the new Irp.
 * If there is a timer pending, do nothing.
 */
STDMETHODIMP_(void)
CPortPinMidi::
IrpSubmitted
(
IN      PIRP        pIrp,
IN      BOOLEAN     WasExhausted
)
{
    if (m_DeviceState == KSSTATE_RUN)
    {
        if (m_ServiceGroup)
        {
            //
            // Using a service group...just notify the port.
            //
            m_Port->Notify(m_ServiceGroup);
        } else
        {
            //
            // Using a timer...set it off.
            //
            ASSERT(m_DataFlow == KSPIN_DATAFLOW_IN);
            m_TimerDue100ns.QuadPart = 0;
            KeSetTimer(&m_TimerEvent,m_TimerDue100ns,&m_Dpc);
        }
    }
}

#if 0
STDMETHODIMP_(void)
CPortPinMidi::IrpCompleting(
                           IN PIRP Irp
                           )

/*++

Routine Description:
    This method handles the dispatch from CIrpStream when a streaming IRP 
    is about to be completed.

Arguments:
    IN PIRP Irp -
        I/O request packet

Return:

--*/

{
    PKSSTREAM_HEADER    StreamHeader;
    PIO_STACK_LOCATION  irpSp;
    CPortPinMidi        *PinMidi;

    StreamHeader = PKSSTREAM_HEADER( Irp->AssociatedIrp.SystemBuffer );

    irpSp =  IoGetCurrentIrpStackLocation( Irp );

    if (irpSp->Parameters.DeviceIoControl.IoControlCode ==
        IOCTL_KS_WRITE_STREAM)
    {
        ASSERT( StreamHeader );

        //
        // Signal end-of-stream event for the renderer.
        //
        if (StreamHeader->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM)
        {

            PinMidi =
            (CPortPinMidi *) KsoGetIrpTargetFromIrp( Irp );

            KsGenerateEventList( NULL, 
                                 KSEVENT_CONNECTION_ENDOFSTREAM, 
                                 &PinMidi->m_EventList,
                                 KSEVENTS_SPINLOCK,
                                 &PinMidi->m_EventLock );
            //MGP is this used?  
            //            _asm int 3          
            //never gets hit.

        }
    }
}
#endif

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortPinMidi::PowerNotify()
 *****************************************************************************
 * Called by the port to notify of power state changes.
 */
STDMETHODIMP_(void)
CPortPinMidi::
PowerNotify
(
IN  POWER_STATE     PowerState
)
{
    PAGED_CODE();

    // grap the control mutex
    KeWaitForSingleObject( &m_Port->m_ControlMutex,
                           Executive,
                           KernelMode,
                           FALSE,
                           NULL );

    // do the right thing based on power state
    switch (PowerState.DeviceState)
    {
        case PowerDeviceD0:
            //
            // keep track of whether or not we're suspended
            m_Suspended = FALSE;

            // if we're not in the right state, change the miniport stream state.
            if( m_DeviceState != m_CommandedState )
            {
                //
                // Transitions go through the intermediate states.
                //
                if (m_DeviceState == KSSTATE_STOP)               //  going to stop
                {
                    switch (m_CommandedState)
                    {
                        case KSSTATE_RUN:                        //  going from run
                            m_Stream->SetState(KSSTATE_PAUSE);   //  fall thru - additional transitions
                        case KSSTATE_PAUSE:                      //  going from run/pause
                            m_Stream->SetState(KSSTATE_ACQUIRE); //  fall thru - additional transitions
                        case KSSTATE_ACQUIRE:                    //  already only one state away
                            break;
                    }
                }
                else if (m_DeviceState == KSSTATE_ACQUIRE)       //  going to acquire
                {
                    if (m_CommandedState == KSSTATE_RUN)         //  going from run
                    {
                        m_Stream->SetState(KSSTATE_PAUSE);       //  now only one state away
                    }
                }
                else if (m_DeviceState == KSSTATE_PAUSE)         //  going to pause
                {
                    if (m_CommandedState == KSSTATE_STOP)        //  going from stop
                    {
                        m_Stream->SetState(KSSTATE_ACQUIRE);     //  now only one state away
                    }
                }
                else if (m_DeviceState == KSSTATE_RUN)           //  going to run
                {
                    switch (m_CommandedState)
                    {
                        case KSSTATE_STOP:                       //  going from stop
                            m_Stream->SetState(KSSTATE_ACQUIRE); //  fall thru - additional transitions
                        case KSSTATE_ACQUIRE:                    //  going from acquire
                            m_Stream->SetState(KSSTATE_PAUSE);   //  fall thru - additional transitions
                        case KSSTATE_PAUSE:                      //  already only one state away
                            break;         
                    }
                }

                // we should now be one state away from our target
                m_Stream->SetState(m_DeviceState);
                m_CommandedState = m_DeviceState;
             }
            break;

        case PowerDeviceD1:
        case PowerDeviceD2:
        case PowerDeviceD3:
            //
            // keep track of whether or not we're suspended
            m_Suspended = TRUE;

            // if we're higher than KSSTATE_ACQUIRE, place miniportMXF
            // in that state so clocks are stopped (but not reset).
            switch (m_DeviceState)
            {
                case KSSTATE_RUN:
                    m_Stream->SetState(KSSTATE_PAUSE);    //  fall thru - additional transitions
                case KSSTATE_PAUSE:
                    m_Stream->SetState(KSSTATE_ACQUIRE);  //  fall thru - additional transitions
                m_CommandedState = KSSTATE_ACQUIRE;
            }
            break;

        default:
            _DbgPrintF(DEBUGLVL_TERSE,("Unknown Power State"));
            break;
    }

    // release the control mutex
    KeReleaseMutex( &m_Port->m_ControlMutex, FALSE );
}

#pragma code_seg()
//  Needs to be non-paged to synchronize with DPCs that come and go.

STDMETHODIMP_(NTSTATUS)
CPortPinMidi::
SetDeviceState(
              IN KSSTATE NewState,
              IN KSSTATE OldState,
              OUT PIKSSHELLTRANSPORT* NextTransport
              )

/*++

Routine Description:

    This routine handles notification that the device state has changed.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("CPortPinMidi::SetDeviceState(0x%08x)",this));
    _DbgPrintF(DEBUGLVL_VERBOSE,("#### Pin%p.SetDeviceState:  from %d to %d",this,OldState,NewState));

    ASSERT(NextTransport);

    NTSTATUS ntStatus = STATUS_SUCCESS;

    if (m_DataFlow == KSPIN_DATAFLOW_IN)
    {
        KeCancelTimer(&m_TimerEvent);
    }

    if (m_TransportState != NewState)
    {
        m_TransportState = NewState;

        if (NewState > OldState)
        {
            *NextTransport = m_TransportSink;
        } else
        {
            *NextTransport = m_TransportSource;
        }

        // set the miniport stream state if we're not suspended.
        if (FALSE == m_Suspended)
        {
            ntStatus = m_Stream->SetState(NewState);
            if (NT_SUCCESS(ntStatus))
            {
                m_CommandedState = NewState;
            }
        }

        if (NT_SUCCESS(ntStatus))
        {
            KIRQL oldIrql;
            KeAcquireSpinLock(&m_DpcSpinLock,&oldIrql);

            LONGLONG currentTime100ns;
            currentTime100ns = GetCurrentTime();

            if (OldState == KSSTATE_RUN)
            {
                m_PauseTime = currentTime100ns - m_StartTime;
                _DbgPrintF(DEBUGLVL_VERBOSE,("SetState away from KSSTATE_RUN, currentTime %x %08x start %x %08x pause %x %08x",
                    LONG(currentTime100ns >> 32), LONG(currentTime100ns & 0x0ffffffff), 
                    LONG(m_StartTime >> 32),      LONG(m_StartTime & 0x0ffffffff),
                    LONG(m_PauseTime >> 32),      LONG(m_PauseTime & 0x0ffffffff)
                    ));
                
                if ((m_DataFlow == KSPIN_DATAFLOW_OUT) && (GetMidiState() != eStatusState))
                {
                    //  Mark stream discontinuous now.
                    //  If we wait longer, the IRPs are already gone.
                    (void) MarkStreamHeaderDiscontinuity();
                }
            }
            switch (NewState)
            {
                case KSSTATE_STOP:
                    _DbgPrintF(DEBUGLVL_VERBOSE,("KSSTATE_STOP"));    
                    _DbgPrintF(DEBUGLVL_VERBOSE,("#### Pin%p.SetDeviceState:  cancelling outstanding IRPs",this));

                    m_UpdatePresTime = TRUE;
                    CancelIrpsOutstanding();
                    
                    break;

                case KSSTATE_ACQUIRE:
                    _DbgPrintF(DEBUGLVL_VERBOSE,("KSSTATE_ACQUIRE"));

                    if (OldState == KSSTATE_STOP)
                    {
                        m_StartTime = m_PauseTime = 0;
                        _DbgPrintF(DEBUGLVL_VERBOSE,("SetState STOP->ACQUIRE, start %x %08x pause %x %08x",
                            (LONG(m_StartTime >> 32)), LONG(m_StartTime & 0x0ffffffff),
                            (LONG(m_PauseTime >> 32)), LONG(m_PauseTime & 0x0ffffffff)
                            ));
                    }

                    if (    (GetMidiState() == eSysExState)
                            &&  (m_DataFlow == KSPIN_DATAFLOW_OUT))
                    {
                        SubmitCompleteSysEx(eCookEndOfStream);  //  Flush what we have.
                        SetMidiState(eStatusState);             //  Take us out of SysEx state.
                    }

                    break;
                
                case KSSTATE_PAUSE:
                    _DbgPrintF(DEBUGLVL_VERBOSE,("KSSTATE_PAUSE"));
                    break;
                
                case KSSTATE_RUN:
                    _DbgPrintF(DEBUGLVL_VERBOSE,("KSSTATE_RUN"));

                    m_StartTime = currentTime100ns - m_PauseTime;
                    _DbgPrintF(DEBUGLVL_VERBOSE,("SetState to RUN, currentTime %x %08x start %x %08x pause %x %08x",
                        LONG(currentTime100ns >> 32), LONG(currentTime100ns & 0x0ffffffff),
                        LONG(m_StartTime >> 32),      LONG(m_StartTime & 0x0ffffffff),
                        LONG(m_PauseTime >> 32),      LONG(m_PauseTime & 0x0ffffffff)
                        ));
                    
                    if ((m_DataFlow == KSPIN_DATAFLOW_OUT) && (GetMidiState() != eStatusState))
                    {                                       // if RUN->PAUSE->RUN
                        (void) MarkStreamHeaderContinuity();       //  Going back into RUN, mark continuous.
                    }

                    if (m_ServiceGroup && m_Port)           //  Using service group...notify the port.
                    {
                        m_Port->Notify(m_ServiceGroup);
                    } else                                    //  Using a timer...set it off.
                    {
                        ASSERT(m_DataFlow == KSPIN_DATAFLOW_IN);
                        m_DeviceState = NewState;           //  Set the state before DPC fires
                        m_TimerDue100ns.QuadPart = 0;
                        KeSetTimer(&m_TimerEvent,m_TimerDue100ns,&m_Dpc);
                    }
                    break;
            }

            if (NT_SUCCESS(ntStatus))
            {
                m_DeviceState = NewState;
            }
            KeReleaseSpinLock(&m_DpcSpinLock,oldIrql);
        }
    } else
    {
        *NextTransport = NULL;
    }

    return ntStatus;
}

#pragma code_seg()
/*****************************************************************************
 * GetPosition()
 *****************************************************************************
 * Gets the current position.
 */
STDMETHODIMP_(NTSTATUS)
CPortPinMidi::
GetPosition
(   IN OUT  PIRPSTREAM_POSITION pIrpStreamPosition
)
{
    return STATUS_SUCCESS;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * PinPropertyDeviceState()
 *****************************************************************************
 * Handles device state property access for the pin.
 */
static
NTSTATUS
PinPropertyDeviceState
(
IN      PIRP        Irp,
IN      PKSPROPERTY Property,
IN OUT  PKSSTATE    DeviceState
)
{
    PAGED_CODE();

    ASSERT(Irp);
    ASSERT(Property);
    ASSERT(DeviceState);

    CPortPinMidi *that =
    (CPortPinMidi *) KsoGetIrpTargetFromIrp(Irp);
    if (!that)
    {
        return STATUS_UNSUCCESSFUL;
    }
    CPortMidi *port = that->m_Port;

    NTSTATUS ntStatus;

    if (Property->Flags & KSPROPERTY_TYPE_GET)  // Handle get property.
    {
        _DbgPrintF(DEBUGLVL_VERBOSE,("PinPropertyDeviceState] get %d",that->m_DeviceState));
        *DeviceState = that->m_DeviceState;
        Irp->IoStatus.Information = sizeof(KSSTATE);
        return STATUS_SUCCESS;
    }

    if (*DeviceState != that->m_DeviceState)      // If change in set property.
    {
        _DbgPrintF(DEBUGLVL_VERBOSE,("PinPropertyDeviceState] set from %d to %d",that->m_DeviceState,*DeviceState));

        // Serialize.
        KeWaitForSingleObject
        (
        &port->m_ControlMutex,
        Executive,
        KernelMode,
        FALSE,              // Not alertable.
        NULL
        );

        that->m_CommandedState = *DeviceState;

        if (*DeviceState < that->m_DeviceState)
        {
            KSSTATE oldState = that->m_DeviceState;
            that->m_DeviceState = *DeviceState;
            ntStatus = that->DistributeDeviceState(*DeviceState,oldState);
            if (! NT_SUCCESS(ntStatus))
            {
                that->m_DeviceState = oldState;
            }
        } else
        {
            ntStatus = that->DistributeDeviceState(*DeviceState,that->m_DeviceState);
            if (NT_SUCCESS(ntStatus))
            {
                that->m_DeviceState = *DeviceState;
            }
        }

        KeReleaseMutex(&port->m_ControlMutex,FALSE);

        return ntStatus;
    }
    //  No change in set property.
    return STATUS_SUCCESS;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * PinPropertyDataFormat()
 *****************************************************************************
 * Handles data format property access for the pin.
 */
static
NTSTATUS
PinPropertyDataFormat
(
IN      PIRP            Irp,
IN      PKSPROPERTY     Property,
IN OUT  PKSDATAFORMAT   DataFormat
)
{
    PAGED_CODE();

    ASSERT(Irp);
    ASSERT(Property);
    ASSERT(DataFormat);

    _DbgPrintF( DEBUGLVL_VERBOSE, ("PinPropertyDataFormat"));

    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    ASSERT(irpSp);
    CPortPinMidi *that =
    (CPortPinMidi *) KsoGetIrpTargetFromIrp(Irp);
    CPortMidi *port = that->m_Port;

    NTSTATUS ntStatus = STATUS_SUCCESS;

    if (Property->Flags & KSPROPERTY_TYPE_GET)
    {
        if (that->m_DataFormat)
        {
            if (   !irpSp->Parameters.DeviceIoControl.OutputBufferLength
               )
            {
                Irp->IoStatus.Information = that->m_DataFormat->FormatSize;
                ntStatus = STATUS_BUFFER_OVERFLOW;
            } else
                if (   irpSp->Parameters.DeviceIoControl.OutputBufferLength
                       >=  sizeof(that->m_DataFormat->FormatSize)
                   )
            {
                RtlCopyMemory(DataFormat,that->m_DataFormat,
                              that->m_DataFormat->FormatSize);
                Irp->IoStatus.Information = that->m_DataFormat->FormatSize;
            } else
            {
                ntStatus = STATUS_BUFFER_TOO_SMALL;
            }
        } else
        {
            ntStatus = STATUS_UNSUCCESSFUL;
        }
    } else
        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(*DataFormat))
    {
        ntStatus = STATUS_BUFFER_TOO_SMALL;
    } else
    {
        PKSDATAFORMAT FilteredDataFormat = NULL;

        ntStatus = PcCaptureFormat( &FilteredDataFormat,
                                    DataFormat,
                                    port->m_pSubdeviceDescriptor,
                                    that->m_Id );

        if (NT_SUCCESS(ntStatus))
        {
            ntStatus = that->m_Stream->SetFormat(FilteredDataFormat);

            ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
            if (NT_SUCCESS(ntStatus))
            {
                if (that->m_DataFormat)
                {
                    ::ExFreePool(that->m_DataFormat);
                }

                that->m_DataFormat = FilteredDataFormat;
            } else
            {
                ::ExFreePool(FilteredDataFormat);
            }
        }
    }

    return ntStatus;
}

#pragma code_seg()
/*****************************************************************************
 * CPortPinMidi::GetCurrentTime()
 *****************************************************************************
 * A simple helper function to return the current
 * system time in 100 nanosecond units. It uses KeQueryPerformanceCounter
 */
LONGLONG
CPortPinMidi::
GetCurrentTime
(   void
)
{
    LARGE_INTEGER   liFrequency,liTime;

    //  total ticks since system booted
    liTime = KeQueryPerformanceCounter(&liFrequency);

#ifndef UNDER_NT

    //
    //  TODO Since timeGetTime assumes 1193 VTD ticks per millisecond, 
    //  instead of 1193.182 (or 1193.18 -- really spec'ed as 1193.18175), 
    //  we should do the same (on Win 9x codebase only).
    //
    //  This means we drop the bottom three digits of the frequency.  
    //  We need to fix this when the fix to timeGetTime is checked in.
    //  instead we do this:
    //
    liFrequency.QuadPart /= 1000;           //  drop the precision on the floor
    liFrequency.QuadPart *= 1000;           //  drop the precision on the floor

#endif  //  !UNDER_NT

    //  Convert ticks to 100ns units.
    //
    return (KSCONVERT_PERFORMANCE_TIME(liFrequency.QuadPart,liTime));
}

#pragma code_seg()
/*****************************************************************************
 * TimerDPC()
 *****************************************************************************
 * The timer DPC callback. Thunks to a C++ member function.
 * This is called by the OS in response to the midi pin
 * wanting to wakeup later to process more midi stuff.
 */
VOID 
NTAPI
TimerDPC
(
IN  PKDPC   Dpc,
IN  PVOID   DeferredContext,
IN  PVOID   SystemArgument1,
IN  PVOID   SystemArgument2
)
{
    ASSERT(DeferredContext);

    (void) ((CPortPinMidi*) DeferredContext)->RequestService();    //  ignores return value!
}

#pragma code_seg()
/*****************************************************************************
 * CPortPinMidi::RequestService()
 *****************************************************************************
 * Service the pin in a DPC.
 */
STDMETHODIMP_(void)
CPortPinMidi::
RequestService
(   void
)
{
    if (m_DataFlow == KSPIN_DATAFLOW_IN)
    {
        ServeRender();
    } else
    {
        ServeCapture();
    }
}

#pragma code_seg()
/*****************************************************************************
 * CPortPinMidi::GetCurrentPresTime()
 *****************************************************************************
 * Get the presentation time right now.
 *
 * Use the DeviceState to interpret the two clock times.  m_PauseTime is the
 * presentation time at the moment the device was PAUSEd (or STOPped).  
 * m_StartTime is the apparent clock time at the moment the device was started 
 * from 0 - "apparent" because it takes into account any pausing and
 * re-running of the device.
 * (presentation time does not advance during PAUSE or STOP state, and is
 * reset during STOP state.
 *
 * DPC spin lock is already owned, by the Serve function, so we are synchronized
 * with SetDeviceState calls that might change m_StartTime or m_PauseTime.
 */
LONGLONG
CPortPinMidi::
GetCurrentPresTime
(   void
)
{
    LONGLONG   currentTime;

    if (m_DeviceState == KSSTATE_RUN)
    {
        currentTime = GetCurrentTime();
        _DbgPrintF(DEBUGLVL_BLAB,("GetCurrentTime %x %08x start %x %08x pause %x %08x",
            LONG(currentTime >> 32), LONG(currentTime & 0x0ffffffff),
            LONG(m_StartTime >> 32), LONG(m_StartTime & 0x0ffffffff),
            LONG(m_PauseTime >> 32), LONG(m_PauseTime & 0x0ffffffff)
            ));
        
        if (currentTime >= m_StartTime)
        {
            currentTime -= m_StartTime;
        }
        else
        {
            //  if "now" is earlier than start time, 
            //  reset our conception of start time.
            //  Start time is only referenced in this function and in SetState.
            m_StartTime = currentTime - 1;
            currentTime = 1;
        }
    } 
    else    //  PAUSE, ACQUIRE or STOP
    {
        currentTime = m_PauseTime;
    }

    ASSERT(currentTime > 0);
    return currentTime;
}

#pragma code_seg()
/*****************************************************************************
 * CPortPinMidi::GetNewPresTime()
 *****************************************************************************
 * Determine the new presentation time.
 *
 * Given the IRPs header and a delta, determine the presentation time of the 
 * last event, then add the delta100ns to it to get the new presentation time.
 * If we are the first event in the IRP, use the IRP time instead of the 
 * previous event.
 *
 */
LONGLONG
CPortPinMidi::
GetNewPresTime
(   IRPSTREAMPACKETINFO *pPacketInfo,
    LONGLONG            delta100ns
)
{
    LONGLONG   newPresTime;
    KSTIME     *pKSTime;

    //TODO first packet?
    if (pPacketInfo->CurrentOffset == 0)    //  if first event in IRP
    {
        pKSTime = &(pPacketInfo->Header.PresentationTime);
        if ((pKSTime->Denominator) && (pKSTime->Numerator))
        {
            //  #units * freq (i.e. * #100ns/units) to get #100ns
            newPresTime = (pKSTime->Time * pKSTime->Numerator) / pKSTime->Denominator;

            //  If IRP presentation time is negative, at least make it zero.
            if (newPresTime < 0)
            {
                newPresTime = 0;
            }
        } 
        else
        {
            //  Not a valid IRP.  How did we get data?!?  Just play it now.
            return m_MidiMsgPresTime;
        }
    } 
    else
    {
        //  not first packet in the IRP
        newPresTime = m_MidiMsgPresTime;
    }
    newPresTime += delta100ns;
    
    return newPresTime;
}

#pragma code_seg()
/*****************************************************************************
 * CPortPinMidi::ServeRender()
 *****************************************************************************
 * Service the render pin in a DPC.
 *
 * Called to do the sequencing and output of midi data.
 * This function checks the time-stamp of the outgoing data.
 * If it's more than (kMidiTimerResolution100ns) in the future it queues
 * a timer (the timer just calls this function back).
 * If the data is less than (kMidiTimerResolution100ns) in the future, it 
 * sends it to the miniport, and works on the next chunk of data until:
 * 1) no more data, or 
 * 2) it hits data more than (kMidiTimerResolution100ns) in the future.
 * TODO: Make kMidiTimerResolution100ns adjustable via the control panel?
 */
void
CPortPinMidi::
ServeRender
(   void
)
{
    BOOLEAN         doneYet = FALSE,needNextTimer = FALSE;
    ULONG           bytesWritten;
    NTSTATUS        ntStatus;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    if (!m_IrpStream)   //  don't even waste our time -- no data source
    {
        return;
    }
    KeAcquireSpinLockAtDpcLevel(&m_DpcSpinLock);
    //  see kProfilingTimerResolution item 1

    // until we've played all the data, or we've set up a timer to finish later...
    while (!doneYet && (m_DeviceState == KSSTATE_RUN))
    {
        // See note 1 below for output FIFO
        ULONG               count;
        PKSMUSICFORMAT      pMidiFormat,pNewMidiFormat;
        IRPSTREAMPACKETINFO irpStreamPacketInfo;

        ntStatus = m_IrpStream->GetPacketInfo(&irpStreamPacketInfo,NULL);

        m_IrpStream->GetLockedRegion(&count,(PVOID *)&pMidiFormat);

        if (!(NT_SUCCESS(ntStatus)))
            count = 0;
        if (count >= sizeof (KSMUSICFORMAT))      //  do we have more data to play?
        {
            LONGLONG   delta100ns,newPresentationTime;

            m_LastSequencerPresTime = GetCurrentPresTime();
            if (m_UpdatePresTime)
            {
                newPresentationTime = GetNewPresTime(&irpStreamPacketInfo,LONGLONG(pMidiFormat->TimeDeltaMs) * 10000);
                m_MidiMsgPresTime = newPresentationTime;   //  save it for next time
            } 
            else
            {
                newPresentationTime = m_MidiMsgPresTime;   //  the last one is still the one
            }
            m_UpdatePresTime = FALSE;   //  stick with this pres time until the data is consumed

            if (newPresentationTime <= m_LastSequencerPresTime)
            {
                delta100ns = 0;
            }
            else
            {
                delta100ns = newPresentationTime - m_LastSequencerPresTime;
            }
            if (delta100ns < kMidiTimerResolution100ns)        // if less than kMidiTimerResolution100ns in the future
            {
                ULONG   bytesCompleted,dwordCount;
                PUCHAR  pRawData;

                if (pMidiFormat->ByteCount > count)
                {
                    pMidiFormat->ByteCount = count;
                }
                bytesWritten = 0;
                if (pMidiFormat->ByteCount)
                {
                    pRawData = (PUCHAR)(pMidiFormat+1);

                    // Write data to device (call miniport)
                    // This is a bit of a problem.  The Stream must complete an aligned amount of data
                    // if it doesn't complete it all.  See below for why.
                    ntStatus = m_Stream->Write(pRawData,pMidiFormat->ByteCount,&bytesWritten);
                    //  see kProfilingTimerResolution item 2

                    if (NT_ERROR(ntStatus))
                    {
                        bytesWritten = pMidiFormat->ByteCount;
                        _DbgPrintF(DEBUGLVL_TERSE,("The MIDI device dropped data on the floor!!\n\n"));
                    }
                    //  see note 2 below for output FIFOing
                    if (bytesWritten < pMidiFormat->ByteCount)
                    {                    // let us know that we didn't get it all
                        needNextTimer = TRUE;
                        delta100ns = kMidiTimerResolution100ns;    //  set DPC kMidiTimerResolution100ns from now to do more.
                    }
                }

                if ((bytesWritten > 0) || (pMidiFormat->ByteCount == 0))
                {
                    //  Calculate # DWORDS written, round if misaligned. 
                    //  N.B.:caller MUST pad packet out, so if a partial dword at the end,
                    //  throw another dword on the barby...
                    bytesWritten += (sizeof(ULONG) - 1);
                    dwordCount = bytesWritten / sizeof(ULONG);
                    bytesWritten = dwordCount * sizeof(ULONG);

                    if (bytesWritten < pMidiFormat->ByteCount)
                    {
                        // this is why DWORD aligned above.
                        // rewrite the header information so that it gets picked up next time
                        // find the correct spot for next time.
                        pNewMidiFormat = (PKSMUSICFORMAT)(pRawData + bytesWritten - sizeof(KSMUSICFORMAT));
                        ASSERT(LONGLONG(pNewMidiFormat) % sizeof(ULONG) == 0);

                        pNewMidiFormat->ByteCount = pMidiFormat->ByteCount - bytesWritten;
                        pNewMidiFormat->TimeDeltaMs = 0;
                        needNextTimer = TRUE;
                    } else
                    {
                        bytesWritten += sizeof(KSMUSICFORMAT);  //  we didn't have to relocate the header.
                        m_UpdatePresTime = TRUE;                //  data was completely consumed
                    }

                    // Unlock the data we used
                    m_IrpStream->ReleaseLockedRegion(bytesWritten);

                    if (bytesWritten)
                    {   // set the complete position for the data we used
                        m_IrpStream->Complete(bytesWritten,&bytesCompleted);
                        ASSERT(bytesCompleted == bytesWritten);
                    }
                }   //  if bytesWritten (unaligned)
                else
                {
                    //  didn't write any bytes, don't advance the IrpStream
                    m_IrpStream->ReleaseLockedRegion(0);
                }
            }       //  if (delta100ns < kMidiTimerResolution100ns)
            else
            {
                //  Don't play this yet -- don't advance the IrpStream
                needNextTimer = TRUE;
                m_IrpStream->ReleaseLockedRegion(0);
            }

            if (needNextTimer)
            {       // We need to do this work later... setup a timer.
                    // If we're in a TIMER DPC now it's ok because timer is a one-shot
                doneYet = TRUE;

                ASSERT(delta100ns > 0);
                m_TimerDue100ns.QuadPart = -LONGLONG(delta100ns);     //  + for absolute / - for relative
                ntStatus = KeSetTimer( &m_TimerEvent, m_TimerDue100ns, &m_Dpc );
                m_NumberOfRetries++;
            }
            else
            {
                m_NumberOfRetries = 0;  //  miniport accepted data.
            }
        }   //  if data left to play
        else
        {
            m_UpdatePresTime = TRUE;
            m_IrpStream->ReleaseLockedRegion(count);
            if (count)
            {
                m_IrpStream->Complete(count,&count);
            }
            doneYet = TRUE;
        }   //  if no more data
    }   //  while !doneYet  && _RUN
    //  see kProfilingTimerResolution item 3
    KeReleaseSpinLockFromDpcLevel(&m_DpcSpinLock);
}


/*
                    MIDI Capture

    The underlying assumptions are as follows:

 1) Timestamping is done using KeQueryPerformanceCounter().  
 2) There is no KS_EVENT that signals when a new message has
    arrived.  The WDMAUD client will be using IRPs with buffers
    of 12-20 bytes, exactly the size of a short MIDI message.
    The completion of the IRP serves as the signal to the client 
    that the new message has been received.

    The proposed order of improvements is as follows:

 A) Change to new data format (DirectMusic)
 B) Add events so that buffers can be of arbitrary length
    without inducing unacceptable latency.
 C) Change the timestamping to use the default KS clock pin.
 D) Add new data format for raw MIDI data.

*/

#define IS_REALTIME_BYTE(x) ((x & 0xF8) == 0xF8)
#define IS_SYSTEM_BYTE(x)   ((x & 0xF0) == 0xF0)
#define IS_STATUS_BYTE(x)   ((x & 0x80) != 0)
#define IS_DATA_BYTE(x)     ((x & 0x80) == 0)

#pragma code_seg()
/*****************************************************************************
 * CPortPinMidi::InitializeStateVariables()
 *****************************************************************************
 * Set variables to known state, done
 * initially and upon any state error.
 */
void
CPortPinMidi::
InitializeStateVariables
(   VOID
)
{
    m_MidiMsg = 0;
    SetMidiState(eStatusState);
    m_ByteCount = 0;
    m_RunningStatus = 0;
}

#pragma code_seg()
/*****************************************************************************
 * CPortPinMidi::GetNextDeltaTime()
 *****************************************************************************
 * Set variables to known state, done
 * initially and upon any state error.
 */
ULONG
CPortPinMidi::
GetNextDeltaTime
(   VOID
)
{
    NTSTATUS            ntStatus;
    LONGLONG            currentPresTime,lastPresTime;
    IRPSTREAMPACKETINFO packetInfo;

    currentPresTime = GetCurrentPresTime();    //  Get current pres time.

    ntStatus = m_IrpStream->GetPacketInfo(&packetInfo,NULL);
    if (!(NT_SUCCESS(ntStatus)))
    {
        _DbgPrintF(DEBUGLVL_TERSE,("CPortPinMidi::GetNextDeltaTime, GetPacketInfo returned 0x%08x\n",ntStatus));
    }

    lastPresTime = GetNewPresTime(&packetInfo,0);
    m_MidiMsgPresTime = currentPresTime;  //  save it for next time

    return ULONG((currentPresTime - lastPresTime)/10000);   // 100ns->Ms for delta MSec.
}

#pragma code_seg()
/*****************************************************************************
 * CPortPinMidi::StartSysEx()
 *****************************************************************************
 * Change mState to next state.
 * Set or reset mRunningStatus
 */
void
CPortPinMidi::
StartSysEx
(   BYTE    aByte
)
{

    if (!m_SysExBufferPtr)
    {
        ASSERT(m_SysExBufferPtr);
        return;
    }

    ASSERT(aByte == 0xF0);

    FreeSysExBuffer();
    AddByteToSysEx(aByte);
}

#pragma code_seg()
/*****************************************************************************
 * CPortPinMidi::AddByteToSysEx()
 *****************************************************************************
 * Change mState to next state.
 * Set or reset mRunningStatus
    //  check the byte count.  create a new page if !(byteCount%PAGE_SIZE)
    //  allocate must give an entire nonpaged chunk of PAGE_SIZE.
    //  check for going off the end of the table, off the end of the page.
 */
void
CPortPinMidi::
AddByteToSysEx
(   BYTE    aByte
)
{
    ULONG pageNum,offsetIntoPage;
    PBYTE   pDataPtr;
    PBYTE  *pPagePtr;

    if (!m_SysExBufferPtr)
    {
        ASSERT(m_SysExBufferPtr);
        return;
    }

    ASSERT((aByte == 0xF0) 
           || (aByte == 0xF7) 
           || (IS_DATA_BYTE(aByte)));

    ASSERT(m_SysExByteCount < kMaxSysExMessageSize);

    pPagePtr = m_SysExBufferPtr;
    pageNum = m_SysExByteCount / PAGE_SIZE;
    offsetIntoPage = m_SysExByteCount - (pageNum * PAGE_SIZE);
    pPagePtr += pageNum;            //  determine next table entry; set to pPagePtr
    pDataPtr = *pPagePtr;
    if (!pDataPtr)
    {
        ASSERT(!offsetIntoPage);//  should be head of the page

        //  allocate a new page, poke it into the page table
        pDataPtr = (PBYTE) ::ExAllocatePoolWithTag(NonPagedPool,PAGE_SIZE,'xScP');
        //
        //  PcSX - branch page
        //  PcSx - leaf pages
        //

        if (!pDataPtr)
        {
            ASSERT(pDataPtr);
            return;
        }
        *pPagePtr = pDataPtr;
    }
    pDataPtr += offsetIntoPage;    //  index into the page to determine pDataPtr
    *pDataPtr = aByte;             //  poke in the new value
    m_SysExByteCount++;
}

#pragma code_seg()
/*****************************************************************************
 * CPortPinMidi::SubmitCompleteSysEx()
 *****************************************************************************
 * Change mState to next state.
 * Set or reset mRunningStatus
 */
void
CPortPinMidi::
SubmitCompleteSysEx
(   EMidiCookStatus cookStatus
)
{
    if (!m_SysExBufferPtr)
    {
        ASSERT(m_SysExBufferPtr);
        return;
    }
    if (m_SysExByteCount)
    {
        SubmitCompleteMessage(m_SysExBufferPtr,m_SysExByteCount,cookStatus);
    }
    FreeSysExBuffer();
}

#pragma code_seg()
/*****************************************************************************
 * CPortPinMidi::FreeSysExBuffer()
 *****************************************************************************
 * Go through the page table and free any alloc'ed pages.  Set the entries to 0.
 * Try/Except so we don't crash anything?  For now, no - don't want to mask bugs.
 */
void
CPortPinMidi::
FreeSysExBuffer
(   VOID
)
{
    PBYTE   *pPage;
    ULONG   ptrCount;

    ASSERT(m_SysExBufferPtr);
    if (!m_SysExBufferPtr)
        return;

    pPage = m_SysExBufferPtr;
    for (ptrCount = 1;ptrCount < (PAGE_SIZE/sizeof(PVOID));ptrCount++)
    {
        pPage++;
        if (*pPage)
        {
            ::ExFreePool(*pPage);
            *pPage = 0;
        }
    }
    m_SysExByteCount = 0;
}

#pragma code_seg()
/*****************************************************************************
 * CPortPinMidi::NumBytesLeftInBuffer()
 *****************************************************************************
 * Return the number of bytes .
 */
ULONG
CPortPinMidi::
NumBytesLeftInBuffer
(   void
)
{
    ULONG   bytesLeftInIrp;
    PVOID   pDummy;

    m_IrpStream->GetLockedRegion(&bytesLeftInIrp,&pDummy);
    m_IrpStream->ReleaseLockedRegion(0);
    return bytesLeftInIrp;
}

#pragma code_seg()
/*****************************************************************************
 * CPortPinMidi::StatusSetState()
 *****************************************************************************
 * Change mState to next state.
 * Set or reset mRunningStatus
 */
void
CPortPinMidi::
StatusSetState
(   BYTE    aByte
)
{
    ASSERT(!(IS_REALTIME_BYTE(aByte)));

    if (IS_STATUS_BYTE(aByte))
    {
        if (IS_SYSTEM_BYTE(aByte))
        {
            m_RunningStatus = 0;
            switch (aByte)
            {
                case 0xF0:      //  SYSEX
                    SetMidiState(eSysExState);
                    StartSysEx(aByte);
                    break;  //  Start of SysEx byte
                case 0xF1:      //  MTC 1/4 Frame   (+ 1)
                case 0xF2:      //  Song Pos        (+ 2)
                case 0xF3:      //  Song Sel        (+ 1)
                    m_MidiMsg = aByte & 0x0FF; //  (same as default)
                    SetMidiState(eData1State); //  look for more data
                    m_RunningStatus = aByte;
                    break;  //  Valid multi-byte system messages
                case 0xF4:      //  Undef system common
                case 0xF5:      //  Undef system common
                case 0xF7:      //  EOX
                    break;  //  Invalid system messages
                case 0xF6:      //  Tune Req
                    m_MidiMsg = aByte & 0x0FF;
                    m_ByteCount = 1;
                    break;  //  Valid single-byte system messages
            }
        } else    //  status bytes 80-EF that need more data
        {
            m_MidiMsg = aByte & 0x000FF;
            SetMidiState(eData1State);  //  look for more data
            m_RunningStatus = aByte;
        }
    } else        //  non-status bytes 00-7F.  
    {
        if (m_RunningStatus)
        {
            SubmitRawByte(m_RunningStatus);
            SubmitRawByte(aByte);
        }
#ifdef DEBUG
        else    //  if no running status, drop the random data on the floor.
        {
            _DbgPrintF(DEBUGLVL_VERBOSE,("CPortPinMidi::StatusSetState received data byte with no running status."));
        }
#endif  //  DEBUG
    }
}

#pragma code_seg()
/*****************************************************************************
 * CPortPinMidi::SysExSetState()
 *****************************************************************************
 * Change mState to next state.
 */
void
CPortPinMidi::
SysExSetState
(   BYTE    aByte
)
{
    ASSERT(!(IS_REALTIME_BYTE(aByte)));

    if (IS_DATA_BYTE(aByte))    //  more data for SysEx
    {
        AddByteToSysEx(aByte);
        if (    (m_SysExByteCount + sizeof(KSMUSICFORMAT))
                >=  NumBytesLeftInBuffer())
        {
            SubmitCompleteSysEx(eCookSuccess);
        }
    } else    //  ending message anyway, don't need to check for end of chunk.
    {
        if (aByte == 0xF7)      //  end of SysEx
        {
            AddByteToSysEx(aByte);
            SubmitCompleteSysEx(eCookSuccess);
            SetMidiState(eStatusState);
        } else                    //  implied end of SysEx (interrupted)
        {
            _DbgPrintF(DEBUGLVL_TERSE,("*** SysExSetState eCookDataError! ***\n"));
            SubmitCompleteSysEx(eCookDataError);
            SetMidiState(eStatusState);
            SubmitRawByte(aByte);
        }
    }
}

#pragma code_seg()
/*****************************************************************************
 * CPortPinMidi::Data1SetState()
 *****************************************************************************
 * Change mState to next state.
 * Set or reset mRunningStatus
 */
void
CPortPinMidi::
Data1SetState
(   BYTE    aByte
)
{
    ASSERT(!(IS_REALTIME_BYTE(aByte)));

    if (IS_DATA_BYTE(aByte))
    {
        if (  ((m_RunningStatus & 0xC0) == 0x80)   // 80-BF,
              || ((m_RunningStatus & 0xF0) == 0xE0)   // E0-EF,
              || ( m_RunningStatus == 0xF2)           // F2 are all
           )                                            // valid 3-byte msgs
        {
            m_MidiMsg |= aByte << 8;
            SetMidiState(eData2State);             // look for more data
        } else
            if (  (m_RunningStatus < 0xF0)             // C0-DF: two-byte messages
                  || ((m_RunningStatus & 0xFD) == 0xF1))  // F1,F3: two-byte messages        
        {
            m_MidiMsg |= aByte << 8;
            SetMidiState(eStatusState);
            m_ByteCount = 2;                       // complete message
            if ((m_RunningStatus & 0xF0) == 0xF0)  // F1,F3: SYS msg, no run stat
                m_RunningStatus = 0;
        } else                                            // F0,F4-F7
        {
            ASSERT(!"eData1State reached for invalid status");
            InitializeStateVariables();
        }
    } else
        StatusSetState(aByte);       
}

#pragma code_seg()
/*****************************************************************************
 * CPortPinMidi::Data2SetState()
 *****************************************************************************
 * Change mState to next state.
 * Set or reset mRunningStatus
 */
void
CPortPinMidi::
Data2SetState
(   BYTE    aByte
)
{
    ASSERT(!(IS_REALTIME_BYTE(aByte)));

    if (IS_DATA_BYTE(aByte))
    {
        if (  ((m_RunningStatus & 0xC0) == 0x80)   //  80-BF,
              || ((m_RunningStatus & 0xF0) == 0xE0)   //  E0-EF,
              || ( m_RunningStatus == 0xF2)           //  F2 are all
           )                                            //  valid 3-byte msgs
        {
            m_MidiMsg |= (aByte << 16);
            m_ByteCount = 3;       //  complete message
            SetMidiState(eStatusState);

            if ((m_RunningStatus & 0xF0) == 0xF0) // F2: SYS, no run stat
                m_RunningStatus = 0;
        } else
        {
            ASSERT(!"eData2State reached for invalid status.");
            InitializeStateVariables();
        }
    } else
        StatusSetState(aByte);
}

#pragma code_seg()
/*****************************************************************************
 * CPortPinMidi::SubmitRawByte()
 *****************************************************************************
 * Add a raw data byte to the cooker, and 
 * construct a complete message if possible.
 * Should only call SetNewMsgState on valid additional bytes.
 */
void
CPortPinMidi::
SubmitRawByte
(   BYTE    aByte
)
{
    _DbgPrintF(DEBUGLVL_BLAB,("new MIDI data %02x\n",aByte));

    if (IS_REALTIME_BYTE(aByte))
        SubmitRealTimeByte(aByte);
    else
    {
        switch (m_EMidiState)
        {
            case eStatusState:
                StatusSetState(aByte);
                break;
            case eSysExState:
                SysExSetState(aByte);
                break;
            case eData1State:
                Data1SetState(aByte);
                break;
            case eData2State:
                Data2SetState(aByte);
                break;
        }
    }
}

#pragma code_seg()
/*****************************************************************************
 * CPortPinMidi::GetShortMessage()
 *****************************************************************************
 * Retrieve a complete message from 
 * the cooker, if there is one.
 */
BOOL
CPortPinMidi::
GetShortMessage
(   PBYTE  pMidiData,
    ULONG *pByteCount
)
{
    if (m_ByteCount)
    {
        *pByteCount = m_ByteCount;
        *((ULONG *)pMidiData) = m_MidiMsg;
        m_MidiMsg = 0;
        m_ByteCount = 0;
        return TRUE;
    }
    return FALSE;
}

#pragma code_seg()
/*****************************************************************************
 * CPortPinMidi::SubmitRealTimeByte()
 *****************************************************************************
 * Shortcut this byte to the IRP.  
 * Don't disturb the state variables.
 */
void
CPortPinMidi::
SubmitRealTimeByte
(   BYTE rtByte
)
{
    ULONG midiData;
    PBYTE pMidiData;

    ASSERT(IS_REALTIME_BYTE(rtByte));
    switch (rtByte)
    {
        //  Valid single-byte system real-time messages
        case 0xF8:  //  Timing Clk
        case 0xFA:  //  Start
        case 0xFB:  //  Cont
        case 0xFC:  //  Stop
        case 0xFE:  //  Active Sense
        case 0xFF:  //  Sys Reset
            SubmitCompleteSysEx(eCookSuccess);
            midiData = rtByte & 0x0FF;
            pMidiData = (PBYTE) (&midiData);
            SubmitCompleteMessage(&pMidiData,1,eCookSuccess);
            break;

            //  Invalid system real-time messages
        case 0xF9:  //  Undef system real-time
        case 0xFD:  //  Undef system real-time
            break;
    }
}

#pragma code_seg()
/*****************************************************************************
 * CPortPinMidi::IrpStreamHasValidTimeBase()
 *****************************************************************************
 * Check whether this is a valid IRP.
 */
BOOL
CPortPinMidi::
IrpStreamHasValidTimeBase
(   PIRPSTREAMPACKETINFO pIrpStreamPacketInfo
)
{
    if (!pIrpStreamPacketInfo->Header.PresentationTime.Denominator)
        return FALSE;
    if (!pIrpStreamPacketInfo->Header.PresentationTime.Numerator)
        return FALSE;

    return TRUE;
}

#pragma code_seg()
/*****************************************************************************
 * CPortPinMidi::MarkStreamHeaderDiscontinuity()
 *****************************************************************************
 * Alert client of a break in the MIDI input stream.
 */
NTSTATUS CPortPinMidi::MarkStreamHeaderDiscontinuity(void)
{
    return m_IrpStream->ChangeOptionsFlags(
                            KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY,0xFFFFFFFF,   
                            0,                                         0xFFFFFFFF);
}

#pragma code_seg()
/*****************************************************************************
 * CPortPinMidi::MarkStreamHeaderContinuity()
 *****************************************************************************
 * Alert client of a break in the MIDI input stream.
 */
NTSTATUS CPortPinMidi::MarkStreamHeaderContinuity(void)
{
    return m_IrpStream->ChangeOptionsFlags(
                            0,~KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY,   
                            0,0xFFFFFFFF);
}

#pragma code_seg()
/*****************************************************************************
 * CPortPinMidi::CompleteStreamHeaderInProcess()
 *****************************************************************************
 * Complete this packet before putting incongruous data in 
 * the next packet and marking that packet as bad.
 */
void
CPortPinMidi::
CompleteStreamHeaderInProcess(void)
{
    IRPSTREAMPACKETINFO irpStreamPacketInfo;
    NTSTATUS            ntStatus;

    ntStatus = m_IrpStream->GetPacketInfo(&irpStreamPacketInfo,NULL);
    if (NT_ERROR(ntStatus))
        return;
    if (!IrpStreamHasValidTimeBase(&irpStreamPacketInfo))   //  is this a valid IRP
        return;

    if (irpStreamPacketInfo.CurrentOffset)
        m_IrpStream->TerminatePacket();
}

#pragma code_seg()
/*****************************************************************************
 * CPortPinMidi::SubmitCompleteMessage()
 *****************************************************************************
 * Add a complete message to the IRP buffer.
 */
void
CPortPinMidi::
SubmitCompleteMessage
(   PBYTE          *ppMidiData,
    ULONG           midiByteCount,
    EMidiCookStatus cookStatus
)
{
    ULONG   bytesLeftInIrp,bytesLeftInPage;
    ULONG   dataBytesToWrite,dataBytesWritten;
    ULONG   pageBytesToWrite;
    ULONG   timeDeltaMs;
    PBYTE   pDestDataBuf,*pPageTable,pPage;

    PMIDI_SHORT_MESSAGE pDestBuffer;

    if (!midiByteCount)     return;
    if (!ppMidiData)        return;
    if (!(*ppMidiData))     return;

    pPageTable = ppMidiData;
    pPage = *pPageTable;
    bytesLeftInPage = PAGE_SIZE;

    if (cookStatus != eCookSuccess)
        CompleteStreamHeaderInProcess();
    while (midiByteCount)
    {
        timeDeltaMs = GetNextDeltaTime();
        m_IrpStream->GetLockedRegion(&bytesLeftInIrp,(PVOID *)&pDestBuffer);

        if (bytesLeftInIrp <= 0)
        {
            _DbgPrintF(DEBUGLVL_TERSE,("***** MIDI Capture STARVATION in CPortPinMidi::SubmitCompleteMessage *****"));
            break;      //  no available IRP.  Drop msg on the floor; we're outta here.
        }
        if (bytesLeftInIrp < sizeof(MIDI_SHORT_MESSAGE))
        {
            m_IrpStream->ReleaseLockedRegion(0);
            m_IrpStream->TerminatePacket();
            _DbgPrintF(DEBUGLVL_TERSE,("SubmitCompleteMessage region too small (%db)."));
            continue;                           //  try again with next IRP
        }

        if ((midiByteCount + sizeof(KSMUSICFORMAT)) > bytesLeftInIrp)
            dataBytesToWrite = bytesLeftInIrp - sizeof(KSMUSICFORMAT); // can't fit msg, just fill region
        else
        {
            dataBytesToWrite = midiByteCount;       //  all the data bytes will fit in this region.
            if (cookStatus != eCookSuccess)
            {
                m_IrpStream->ReleaseLockedRegion(0);
                (void) MarkStreamHeaderDiscontinuity();    //  use status to mark the packet if needed.
                m_IrpStream->GetLockedRegion(&bytesLeftInIrp,(PVOID *)&pDestBuffer);
            }
        }

        dataBytesWritten = 0;
        pDestDataBuf = (PBYTE)&(pDestBuffer->midiData);
        while (dataBytesWritten < dataBytesToWrite) //  write this region worth of data
        {
            if (!pPage)                             //  null ptr, can't find midi data
                break;
            if ((dataBytesToWrite - dataBytesWritten)
                < bytesLeftInPage)
                pageBytesToWrite = (dataBytesToWrite - dataBytesWritten); // data all fits on the rest of current page
            else
                pageBytesToWrite = bytesLeftInPage; //  just write a page's worth, then do more

            RtlCopyMemory(  pDestDataBuf,
                            pPage,
                            pageBytesToWrite);

            bytesLeftInPage -= pageBytesToWrite;
            pDestDataBuf += pageBytesToWrite;
            dataBytesWritten += pageBytesToWrite;
            if (bytesLeftInPage)
                pPage += pageBytesToWrite;          //  didn't finish page.  Update page ptr.
            else
            {
                pPageTable++;                       //  finished page.  Go to next page
                pPage = *pPageTable;                //  get next page ptr
                bytesLeftInPage = PAGE_SIZE;        //  entire page lies ahead of us.
            }
        }
        pDestBuffer->musicFormat.TimeDeltaMs = timeDeltaMs;
        pDestBuffer->musicFormat.ByteCount = dataBytesWritten;
        //  done with message, can signal event now.
        midiByteCount -= dataBytesWritten;

        dataBytesWritten = ((dataBytesWritten + 3) & 0xFFFFFFFC);     //    round up
        dataBytesWritten += sizeof (KSMUSICFORMAT);
        m_IrpStream->ReleaseLockedRegion(dataBytesWritten);
        m_IrpStream->Complete(dataBytesWritten,&dataBytesToWrite);
        bytesLeftInIrp -= dataBytesWritten;

        if (!midiByteCount)
        {
            if ((bytesLeftInIrp < sizeof(MIDI_SHORT_MESSAGE)) && (pDestBuffer))
            {
                _DbgPrintF(DEBUGLVL_VERBOSE,("SubmitCompleteMessage finishing IRP now, only %db left.",bytesLeftInIrp));
                m_IrpStream->TerminatePacket();
            }
            break;                  //  done with this message, exit.
        }
    }   //  while there are data bytes
}

#pragma code_seg()
/*****************************************************************************
 * CPortPinMidi::ServeCapture()
 *****************************************************************************
 * Service the capture pin in a DPC.
 */
void
CPortPinMidi::
ServeCapture
(   void
)
{
    BYTE    aByte;
    ULONG   bytesRead,midiData;
    PBYTE   pMidiData;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    if (!m_IrpStream)   //  this routine doesn't use it, 
    {                   //  but all the support routines do.
        return;
    }
    if (!m_Stream)  //  Absolutely required 
    {
        return;
    }
    pMidiData = (PBYTE)&midiData;

    KeAcquireSpinLockAtDpcLevel(&m_DpcSpinLock);
    //  see kProfilingTimerResolution item 4

    while (1)           //  get any new raw data
    {
        bytesRead = 0;
        if (NT_SUCCESS(m_Stream->Read(&aByte,1,&bytesRead)))
        {
            if (!bytesRead)
                break;
            if (m_DeviceState == KSSTATE_RUN)   //  if not RUN, don't fill IRP
            {
                SubmitRawByte(aByte);

                if (GetShortMessage(pMidiData,&bytesRead))
                {
                    SubmitCompleteMessage(&pMidiData,bytesRead,eCookSuccess);
                    //  see kProfilingTimerResolution item 5
                }
            }
        }
    }

    //  see kProfilingTimerResolution item 6
    KeReleaseSpinLockFromDpcLevel(&m_DpcSpinLock);
}

/*
    Use this debugging code if you need to profile the frequency of timer interrupts
    and/or the amount of time spent in dispatch or device IRQL.

    kProfilingTimerResolution items 1 through 6:

  1)
#if kProfilingTimerResolution
    LARGE_INTEGER time, frequency;
    time = KeQueryPerformanceCounter( &frequency );
    time.QuadPart *= 1000000;
    time.QuadPart /= frequency.QuadPart;
    KdPrint(("'%5d.%02d ms\n",time.LowPart/1000,time.LowPart/10 - ((time.LowPart/1000)*100)));
    KdPrint(("'ServeRender@%5dus\n",time.LowPart));
#endif  //  kProfilingTimerResolution

  2)
#if kProfilingTimerResolution
    LARGE_INTEGER time3, freq3;
    time3 = KeQueryPerformanceCounter(&freq3);
    time3.QuadPart *= 1000000;
    time3.QuadPart /= freq3.QuadPart;
    KdPrint(("'ServeRender(0x%x), delta100ns:%d(100ns)@%d(100ns)\n",*PULONG(pRawData),delta100ns,time.LowPart&0x0FFFF));
#endif  //  kProfilingTimerResolution

  3)
#if kProfilingTimerResolution
    if (m_DeviceState == KSSTATE_RUN)
    {
        LARGE_INTEGER time2,freq2;
        time2 = KeQueryPerformanceCounter( &freq2 );
        time2.QuadPart *= 1000000;
        time2.QuadPart /= frequency.QuadPart;
        time2.QuadPart -= time.QuadPart;
        KdPrint(("'Render DPC for %5dus @ %dus\n",time2.LowPart,time.LowPart&0x0FFFF));
    }
#endif  //  kProfilingTimerResolution


  4)
#if kProfilingTimerResolution
    LARGE_INTEGER time, frequency;
    time = KeQueryPerformanceCounter( &frequency );
    time.QuadPart *= 1000000;
    time.QuadPart /= frequency.QuadPart;
#endif  //  kProfilingTimerResolution


  5)
#if kProfilingTimerResolution
    LARGE_INTEGER time3, freq3;
    time3 = KeQueryPerformanceCounter(&freq3);
    time3.QuadPart *= 1000000;
    time3.QuadPart /= freq3.QuadPart;
    KdPrint(("'ServeCapture(0x%x)@%5dus\n",*PULONG(pMidiData),time3.LowPart&0x0FFFF));
#endif  //  kProfilingTimerResolution

  6)
#if kProfilingTimerResolution
    if (m_DeviceState == KSSTATE_RUN)
    {
        LARGE_INTEGER time2,freq2;
        time2 = KeQueryPerformanceCounter( &freq2 );
        time2.QuadPart *= 1000000;
        time2.QuadPart /= frequency.QuadPart;
        time2.QuadPart -= time.QuadPart;
        KdPrint(("'Capture DPC for %5dus @ %dus\n",time2.LowPart,time.LowPart&0x0FFFF));
    }
#endif  //  kProfilingTimerResolution

*/

#pragma code_seg()

STDMETHODIMP_(NTSTATUS)
CPortPinMidi::
TransferKsIrp(
             IN PIRP Irp,
             OUT PIKSSHELLTRANSPORT* NextTransport
             )

/*++

Routine Description:

    This routine handles the arrival of a streaming IRP via the shell 
    transport.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("CPortPinMidi::TransferKsIrp"));

    ASSERT(NextTransport);

    NTSTATUS status;

    if (m_ConnectionFileObject)
    {
        //
        // Source pin.
        //
        if (m_Flushing || (m_TransportState == KSSTATE_STOP))
        {
            //
            // Shunt IRPs to the next component if we are reset or stopped.
            //
            *NextTransport = m_TransportSink;
        } else
        {
            //
            // Send the IRP to the next device.
            //
            KsAddIrpToCancelableQueue(
                                     &m_IrpsToSend.ListEntry,
                                     &m_IrpsToSend.SpinLock,
                                     Irp,
                                     KsListEntryTail,
                                     NULL);

            KsIncrementCountedWorker(m_Worker);
            *NextTransport = NULL;
        }

        status = STATUS_PENDING;
    } else
    {
        //
        // Sink pin:  complete the IRP.
        //
        PKSSTREAM_HEADER StreamHeader = PKSSTREAM_HEADER( Irp->AssociatedIrp.SystemBuffer );

        PIO_STACK_LOCATION irpSp =  IoGetCurrentIrpStackLocation( Irp );

        if (irpSp->Parameters.DeviceIoControl.IoControlCode ==
            IOCTL_KS_WRITE_STREAM)
        {
            ASSERT( StreamHeader );

            //
            // Signal end-of-stream event for the renderer.
            //
#if 0
            if (StreamHeader->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM)
            {

                GenerateEndOfStreamEvents();
            }
#endif
        }

        IoCompleteRequest(Irp,IO_NO_INCREMENT);
        *NextTransport = NULL;

        status = STATUS_PENDING;
    }

    return status;
}

#pragma code_seg("PAGE")

NTSTATUS 
CPortPinMidi::
DistributeDeviceState(
                     IN KSSTATE NewState,
                     IN KSSTATE OldState
                     )

/*++

Routine Description:

    This routine sets the state of the pipe, informing all components in the
    pipe of the new state.  A transition to stop state destroys the pipe.

Arguments:

    NewState -
        The new state.

Return Value:

    Status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("CPortPinMidi::DistributeDeviceState(%p)",this));

    KSSTATE state = OldState;
    KSSTATE targetState = NewState;

    NTSTATUS status = STATUS_SUCCESS;

    //
    // Determine if this pipe section controls the entire pipe.
    //
    PIKSSHELLTRANSPORT distribution;
    if (m_RequestorTransport)
    {
        //
        // This section owns the requestor, so it does own the pipe, and the
        // requestor is the starting point for any distribution.
        //
        distribution = m_RequestorTransport;
    } else
    {
        //
        // This section is at the top of an open circuit, so it does own the
        // pipe and the queue is the starting point for any distribution.
        //
        distribution = m_QueueTransport;
    }

    //
    // Proceed sequentially through states.
    //
    while (state != targetState)
    {
        KSSTATE oldState = state;

        if (ULONG(state) < ULONG(targetState))
        {
            state = KSSTATE(ULONG(state) + 1);
        } else
        {
            state = KSSTATE(ULONG(state) - 1);
        }

        NTSTATUS statusThisPass = STATUS_SUCCESS;

        //
        // Distribute state changes if this section is in charge.
        //
        if (distribution)
        {
            //
            // Tell everyone about the state change.
            //
            _DbgPrintF(DEBUGLVL_VERBOSE,("CPortPinMidi::DistributeDeviceState(%p)] distributing transition from %d to %d",this,oldState,state));
            PIKSSHELLTRANSPORT transport = distribution;
            PIKSSHELLTRANSPORT previousTransport = NULL;
            while (transport)
            {
                PIKSSHELLTRANSPORT nextTransport;
                statusThisPass =
                transport->SetDeviceState(state,oldState,&nextTransport);

                ASSERT(NT_SUCCESS(statusThisPass) || ! nextTransport);

                if (NT_SUCCESS(statusThisPass))
                {
                    previousTransport = transport;
                    transport = nextTransport;
                } else
                {
                    //
                    // Back out on failure.
                    //
                    _DbgPrintF(DEBUGLVL_TERSE,("#### Pin%p.DistributeDeviceState:  failed transition from %d to %d",this,oldState,state));
                    while (previousTransport)
                    {
                        transport = previousTransport;
                        statusThisPass =
                        transport->SetDeviceState(
                                                 oldState,
                                                 state,
                                                 &previousTransport);

                        ASSERT(
                              NT_SUCCESS(statusThisPass) || 
                              ! previousTransport);
                    }
                    break;
                }
            }
        }

        if (NT_SUCCESS(status) && ! NT_SUCCESS(statusThisPass))
        {
            //
            // First failure:  go back to original state.
            //
            state = oldState;
            targetState = OldState;
            status = statusThisPass;
        }
    }

    return status;
}

void 
CPortPinMidi::
DistributeResetState(
                    IN KSRESET NewState
                    )

/*++

Routine Description:

    This routine informs transport components that the reset state has 
    changed.

Arguments:

    NewState -
        The new reset state.

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("CPortPinMidi::DistributeResetState"));

    PAGED_CODE();

    //
    // If this section of the pipe owns the requestor, or there is a 
    // non-shell pin up the pipe (so there's no bypass), this pipe is
    // in charge of telling all the components about state changes.
    //
    // (Always)

    //
    // Set the state change around the circuit.
    //
    PIKSSHELLTRANSPORT transport =
    m_RequestorTransport ? 
    m_RequestorTransport : 
    m_QueueTransport;

    while (transport)
    {
        transport->SetResetState(NewState,&transport);
    }

    m_ResetState = NewState;
}

STDMETHODIMP_(void)
CPortPinMidi::
Connect(
       IN PIKSSHELLTRANSPORT NewTransport OPTIONAL,
       OUT PIKSSHELLTRANSPORT *OldTransport OPTIONAL,
       IN KSPIN_DATAFLOW DataFlow
       )

/*++

Routine Description:

    This routine establishes a shell transport connection.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("CPortPinMidi::Connect"));

    PAGED_CODE();

    KsShellStandardConnect(
                          NewTransport,
                          OldTransport,
                          DataFlow,
                          PIKSSHELLTRANSPORT(this),
                          &m_TransportSource,
                          &m_TransportSink);
}

STDMETHODIMP_(void)
CPortPinMidi::
SetResetState(
             IN KSRESET ksReset,
             OUT PIKSSHELLTRANSPORT* NextTransport
             )

/*++

Routine Description:

    This routine handles notification that the reset state has changed.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("CPortPinMidi::SetResetState"));

    PAGED_CODE();

    ASSERT(NextTransport);

    if (m_Flushing != (ksReset == KSRESET_BEGIN))
    {
        *NextTransport = m_TransportSink;
        m_Flushing = (ksReset == KSRESET_BEGIN);
        if (m_Flushing)
        {
            CancelIrpsOutstanding();
        }
    } else
    {
        *NextTransport = NULL;
    }
}

#if DBG
STDMETHODIMP_(void)
CPortPinMidi::
DbgRollCall(
    IN ULONG MaxNameSize,
    OUT PCHAR Name,
    OUT PIKSSHELLTRANSPORT* NextTransport,
    OUT PIKSSHELLTRANSPORT* PrevTransport
    )

/*++

Routine Description:

    This routine produces a component name and the transport pointers.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("CPortPinMidi::DbgRollCall"));

    PAGED_CODE();

    ASSERT(Name);
    ASSERT(NextTransport);
    ASSERT(PrevTransport);

    ULONG references = AddRef() - 1; Release();

    _snprintf(Name,MaxNameSize,"Pin%p %d (%s) refs=%d",this,m_Id,m_ConnectionFileObject ? "src" : "snk",references);
    *NextTransport = m_TransportSink;
    *PrevTransport = m_TransportSource;
}

static
void
DbgPrintCircuit(
    IN PIKSSHELLTRANSPORT Transport
    )

/*++

Routine Description:

    This routine spews a transport circuit.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("DbgPrintCircuit"));

    PAGED_CODE();

    ASSERT(Transport);

#define MAX_NAME_SIZE 64

    PIKSSHELLTRANSPORT transport = Transport;
    while (transport) {
        CHAR name[MAX_NAME_SIZE + 1];
        PIKSSHELLTRANSPORT next;
        PIKSSHELLTRANSPORT prev;

        transport->DbgRollCall(MAX_NAME_SIZE,name,&next,&prev);
        _DbgPrintF(DEBUGLVL_VERBOSE,("  %s",name));

        if (prev) {
            PIKSSHELLTRANSPORT next2;
            PIKSSHELLTRANSPORT prev2;
            prev->DbgRollCall(MAX_NAME_SIZE,name,&next2,&prev2);
            if (next2 != transport) {
                _DbgPrintF(DEBUGLVL_VERBOSE,(" [SOURCE'S(0x%08x) SINK(0x%08x) != THIS(%08x)",prev,next2,transport));
            }
        } else {
            _DbgPrintF(DEBUGLVL_VERBOSE,(" [NO SOURCE"));
        }

        if (next) {
            PIKSSHELLTRANSPORT next2;
            PIKSSHELLTRANSPORT prev2;
            next->DbgRollCall(MAX_NAME_SIZE,name,&next2,&prev2);
            if (prev2 != transport) {
                _DbgPrintF(DEBUGLVL_VERBOSE,(" [SINK'S(0x%08x) SOURCE(0x%08x) != THIS(%08x)",next,prev2,transport));
            }
        } else {
            _DbgPrintF(DEBUGLVL_VERBOSE,(" [NO SINK"));
        }

        _DbgPrintF(DEBUGLVL_VERBOSE,("\n"));

        transport = next;
        if (transport == Transport) {
            break;
        }
    }
}
#endif

STDMETHODIMP_(void)
CPortPinMidi::
Work(
    void
    )

/*++

Routine Description:

    This routine performs work in a worker thread.  In particular, it sends
    IRPs to the connected pin using IoCallDriver().

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("CPortPinMidi::Work"));

    PAGED_CODE();

    //
    // Send all IRPs in the queue.
    //
    do
    {
        PIRP irp =
        KsRemoveIrpFromCancelableQueue(
                                      &m_IrpsToSend.ListEntry,
                                      &m_IrpsToSend.SpinLock,
                                      KsListEntryHead,
                                      KsAcquireAndRemoveOnlySingleItem);

        //
        // Irp's may have been cancelled, but the loop must still run through
        // the reference counting.
        //
        if (irp)
        {
            if (m_Flushing || (m_TransportState == KSSTATE_STOP))
            {
                //
                // Shunt IRPs to the next component if we are reset or stopped.
                //
                KsShellTransferKsIrp(m_TransportSink,irp);
            } else
            {
                //
                // Set up the next stack location for the callee.  
                //
                IoCopyCurrentIrpStackLocationToNext(irp);

                PIO_STACK_LOCATION irpSp = IoGetNextIrpStackLocation(irp);

                irpSp->Parameters.DeviceIoControl.IoControlCode =
                (m_DataFlow == KSPIN_DATAFLOW_OUT) ?
                IOCTL_KS_WRITE_STREAM : IOCTL_KS_READ_STREAM;
                irpSp->DeviceObject = m_ConnectionDeviceObject;
                irpSp->FileObject = m_ConnectionFileObject;

                //
                // Add the IRP to the list of outstanding IRPs.
                //
                PIRPLIST_ENTRY irpListEntry = IRPLIST_ENTRY_IRP_STORAGE(irp);
                irpListEntry->Irp = irp;
                ExInterlockedInsertTailList(
                                           &m_IrpsOutstanding.ListEntry,
                                           &irpListEntry->ListEntry,
                                           &m_IrpsOutstanding.SpinLock);

                IoSetCompletionRoutine(
                                      irp,
                                      CPortPinMidi::IoCompletionRoutine,
                                      PVOID(this),
                                      TRUE,
                                      TRUE,
                                      TRUE);

                IoCallDriver(m_ConnectionDeviceObject,irp);
            }
        }
    } while (KsDecrementCountedWorker(m_Worker));
}

#pragma code_seg()


NTSTATUS
CPortPinMidi::
IoCompletionRoutine(
                   IN PDEVICE_OBJECT DeviceObject,
                   IN PIRP Irp,
                   IN PVOID Context
                   )

/*++

Routine Description:

    This routine handles the completion of an IRP.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("CPortPinMidi::IoCompletionRoutine] 0x%08x",Irp));

    //    ASSERT(DeviceObject);
    ASSERT(Irp);
    ASSERT(Context);

    CPortPinMidi *pin = (CPortPinMidi *) Context;

    //
    // Remove the IRP from the list of IRPs.  Most of the time, it will be at
    // the head of the list, so this is cheaper than it looks.
    //
    KIRQL oldIrql;
    KeAcquireSpinLock(&pin->m_IrpsOutstanding.SpinLock,&oldIrql);
    for (PLIST_ENTRY listEntry = pin->m_IrpsOutstanding.ListEntry.Flink;
        listEntry != &pin->m_IrpsOutstanding.ListEntry;
        listEntry = listEntry->Flink)
    {
        PIRPLIST_ENTRY irpListEntry =
        CONTAINING_RECORD(listEntry,IRPLIST_ENTRY,ListEntry);

        if (irpListEntry->Irp == Irp)
        {
            RemoveEntryList(listEntry);
            break;
        }
    }
    ASSERT(listEntry != &pin->m_IrpsOutstanding.ListEntry);
    KeReleaseSpinLock(&pin->m_IrpsOutstanding.SpinLock,oldIrql);

    NTSTATUS status;
    if (pin->m_TransportSink)
    {
        //
        // The transport circuit is up, so we can forward the IRP.
        //
        status = KsShellTransferKsIrp(pin->m_TransportSink,Irp);
    } else
    {
        //
        // The transport circuit is down.  This means the IRP came from another
        // filter, and we can just complete this IRP.
        //
        _DbgPrintF(DEBUGLVL_TERSE,("#### Pin%p.IoCompletionRoutine:  got IRP %p with no transport",pin,Irp));
        IoCompleteRequest(Irp,IO_NO_INCREMENT);
        status = STATUS_SUCCESS;
    }

    //
    // Transport objects typically return STATUS_PENDING meaning that the
    // IRP won't go back the way it came.
    //
    if (status == STATUS_PENDING)
    {
        status = STATUS_MORE_PROCESSING_REQUIRED;
    }

    return status;
}

#pragma code_seg("PAGE")


NTSTATUS
CPortPinMidi::
BuildTransportCircuit(
                     void
                     )

/*++

Routine Description:

    This routine initializes a pipe object.  This includes locating all the
    pins associated with the pipe, setting the Pipe and NextPinInPipe pointers
    in the appropriate pin structures, setting all the fields in the pipe
    structure and building the transport circuit for the pipe.  The pipe and
    the associated components are left in acquire state.
    
    The filter's control mutex must be acquired before this function is called.

Arguments:

    Pin -
        Contains a pointer to the pin requesting the creation of the pipe.

Return Value:

    Status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("CPortPinMidi::BuildTransportCircuit"));

    PAGED_CODE();

    BOOLEAN masterIsSource = m_ConnectionFileObject != NULL;

    NTSTATUS status = STATUS_SUCCESS;

    //
    // Create a queue.
    //
    status =
    m_IrpStream->QueryInterface(
                               __uuidof(IKsShellTransport),(PVOID *) &m_QueueTransport);

    PIKSSHELLTRANSPORT hot;
    PIKSSHELLTRANSPORT cold;
    if (NT_SUCCESS(status))
    {
        //
        // Connect the queue to the master pin.  The queue is then the dangling
        // end of the 'hot' side of the circuit.
        //
        hot = m_QueueTransport;
        ASSERT(hot);

        hot->Connect(PIKSSHELLTRANSPORT(this),NULL,m_DataFlow);

        //
        // The 'cold' side of the circuit is either the upstream connection on
        // a sink pin or a requestor connected to same on a source pin.
        //
        if (masterIsSource)
        {
            //
            // Source pin...needs a requestor.
            //
            status =
            KspShellCreateRequestor(
                                   &m_RequestorTransport,
                                   (KSPROBE_STREAMREAD |
                                    KSPROBE_ALLOCATEMDL |
                                    KSPROBE_PROBEANDLOCK |
                                    KSPROBE_SYSTEMADDRESS),
                                   0,   // TODO:  header size
                                   HACK_FRAME_SIZE,
                                   HACK_FRAME_COUNT,
                                   m_ConnectionDeviceObject,
                                   NULL );

            if (NT_SUCCESS(status))
            {
                PIKSSHELLTRANSPORT(this)->
                Connect(m_RequestorTransport,NULL,m_DataFlow);
                cold = m_RequestorTransport;
            }
        } else
        {
            //
            // Sink pin...no requestor required.
            //
            cold = PIKSSHELLTRANSPORT(this);
        }

    }

    //
    // Now we have a hot end and a cold end to hook up to other pins in the
    // pipe, if any.  There are three cases:  1, 2 and many pins.
    // TODO:  Handle headless pipes.
    //
    if (NT_SUCCESS(status))
    {
        //
        // No other pins.  This is the end of the pipe.  We connect the hot
        // and the cold ends together.  The hot end is not really carrying
        // data because the queue is not modifying the data, it is producing
        // or consuming it.
        //
        cold->Connect(hot,NULL,m_DataFlow);
    }

    //
    // Clean up after a failure.
    //
    if (! NT_SUCCESS(status))
    {
        //
        // Dereference the queue if there is one.
        //
        if (m_QueueTransport)
        {
            m_QueueTransport->Release();
            m_QueueTransport = NULL;
        }

        //
        // Dereference the requestor if there is one.
        //
        if (m_RequestorTransport)
        {
            m_RequestorTransport->Release();
            m_RequestorTransport = NULL;
        }
    }

#if DBG
    if (NT_SUCCESS(status)) {
        VOID
        DbgPrintCircuit(
            IN PIKSSHELLTRANSPORT Transport
            );
        _DbgPrintF(DEBUGLVL_VERBOSE,("TRANSPORT CIRCUIT:\n"));
        DbgPrintCircuit(PIKSSHELLTRANSPORT(this));
    }
#endif

    return status;
}

#pragma code_seg()
void
CPortPinMidi::
CancelIrpsOutstanding(
                     void
                     )
/*++

Routine Description:

    Cancels all IRP's on the outstanding IRPs list.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _DbgPrintF(DEBUGLVL_BLAB,("CPortPinMidi::CancelIrpsOutstanding"));

    //
    // This algorithm searches for uncancelled IRPs starting at the head of
    // the list.  Every time such an IRP is found, it is cancelled, and the
    // search starts over at the head.  This will be very efficient, generally,
    // because IRPs will be removed by the completion routine when they are
    // cancelled.
    //
    for (;;)
    {
        //
        // Take the spinlock and search for an uncancelled IRP.  Because the
        // completion routine acquires the same spinlock, we know IRPs on this
        // list will not be completely cancelled as long as we have the 
        // spinlock.
        //
        PIRP irp = NULL;
        KIRQL oldIrql;
        KeAcquireSpinLock(&m_IrpsOutstanding.SpinLock,&oldIrql);
        for (PLIST_ENTRY listEntry = m_IrpsOutstanding.ListEntry.Flink;
            listEntry != &m_IrpsOutstanding.ListEntry;
            listEntry = listEntry->Flink)
        {
            PIRPLIST_ENTRY irpListEntry =
            CONTAINING_RECORD(listEntry,IRPLIST_ENTRY,ListEntry);

            if (! irpListEntry->Irp->Cancel)
            {
                irp = irpListEntry->Irp;
                break;
            }
        }

        //
        // If there are no uncancelled IRPs, we are done.
        //
        if (! irp)
        {
            KeReleaseSpinLock(&m_IrpsOutstanding.SpinLock,oldIrql);
            break;
        }

        //
        // Mark the IRP cancelled whether we can call the cancel routine now
        // or not.
        // 
        irp->Cancel = TRUE;

        //
        // If the cancel routine has already been removed, then this IRP
        // can only be marked as canceled, and not actually canceled, as
        // another execution thread has acquired it. The assumption is that
        // the processing will be completed, and the IRP removed from the list
        // some time in the near future.
        //
        // If the element has not been acquired, then acquire it and cancel it.
        // Otherwise, it's time to find another victim.
        //
        PDRIVER_CANCEL driverCancel = IoSetCancelRoutine(irp,NULL);

        //
        // Since the Irp has been acquired by removing the cancel routine, or
        // there is no cancel routine and we will not be cancelling, it is safe 
        // to release the list lock.
        //
        KeReleaseSpinLock(&m_IrpsOutstanding.SpinLock,oldIrql);

        if (driverCancel)
        {
            _DbgPrintF(DEBUGLVL_VERBOSE,("#### Pin%p.CancelIrpsOutstanding:  cancelling IRP %p",this,irp));
            //
            // This needs to be acquired since cancel routines expect it, and
            // in order to synchronize with NTOS trying to cancel Irp's.
            //
            IoAcquireCancelSpinLock(&irp->CancelIrql);
            driverCancel(IoGetCurrentIrpStackLocation(irp)->DeviceObject,irp);
        } else
        {
            _DbgPrintF(DEBUGLVL_VERBOSE,("#### Pin%p.CancelIrpsOutstanding:  uncancelable IRP %p",this,irp));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\ports\midi\private.h ===
/*****************************************************************************
 * private.h - midi port private definitions
 *****************************************************************************
 * Copyright (c) 1997-2000 Microsoft Corporation.  All rights reserved.
 */

#ifndef _MIDI_PRIVATE_H_
#define _MIDI_PRIVATE_H_

#include "portclsp.h"
#include "stdunk.h"

#include "stdio.h"
#include "stdarg.h"

#include "ksdebug.h"

#ifndef PC_KDEXT
#define STR_MODULENAME  "MidiPort: "
#endif  // PC_KDEXT

#ifndef DEBUGLVL_LIFETIME
#define DEBUGLVL_LIFETIME DEBUGLVL_VERBOSE
#endif


#define kProfilingTimerResolution   0

#define kAdjustingTimerRes          1

#if kAdjustingTimerRes
const ULONG kMidiTimerResolution100ns = 1 * 10000;   //  # 100ns resolution for timer callbacks
#else   //  !kAdjustingTimerRes
const ULONG kMidiTimerResolution100ns = 5 * 10000;   //  # 100ns resolution for timer callbacks
#endif  //  !kAdjustingTimerRes


//
// THE SIZES HERE MUST AGREE WITH THE DEFINITION IN FILTER.CPP AND PIN.CPP.
//
extern KSPROPERTY_SET PropertyTable_FilterMidi[2];
extern KSPROPERTY_SET PropertyTable_PinMidi[1];
extern KSEVENT_SET    EventTable_PinMidi[1];



/*****************************************************************************
 * Interfaces
 */

class CPortMidi;
class CPortFilterMidi;
class CPortPinMidi;

/*****************************************************************************
 * IPortFilterMidi
 *****************************************************************************
 * Interface for MIDI filters.
 */
DECLARE_INTERFACE_(IPortFilterMidi,IIrpTarget)
{
    DEFINE_ABSTRACT_UNKNOWN()           // For IUnknown

    DEFINE_ABSTRACT_IRPTARGETFACTORY()  // For IIrpTargetFactory

    DEFINE_ABSTRACT_IRPTARGET()         // For IIrpTarget

    STDMETHOD_(NTSTATUS,Init)
    (   THIS_
        IN      CPortMidi *Port
    )   PURE;
};

typedef IPortFilterMidi *PPORTFILTERMIDI;

/*****************************************************************************
 * IPortPinMidi
 *****************************************************************************
 * Interface for MIDI pins.
 */
DECLARE_INTERFACE_(IPortPinMidi,IIrpTarget)
{
    DEFINE_ABSTRACT_UNKNOWN()           // For IUnknown

    DEFINE_ABSTRACT_IRPTARGETFACTORY()  // For IIrpTargetFactory

    DEFINE_ABSTRACT_IRPTARGET()         // For IIrpTarget

    STDMETHOD_(NTSTATUS,Init)
    (   THIS_
        IN      CPortMidi *         Port,
        IN      CPortFilterMidi *   Filter,
        IN      PKSPIN_CONNECT      PinConnect,
        IN      PKSPIN_DESCRIPTOR   PinDescriptor
    )   PURE;
};

typedef IPortPinMidi *PPORTPINMIDI;





/*****************************************************************************
 * Classes
 */

/*****************************************************************************
 * CPortMidi
 *****************************************************************************
 * Midi port driver.
 */
class CPortMidi
:   public IPortMidi,
    public IPortEvents,
    public IServiceSink,
    public ISubdevice,
#ifdef DRM_PORTCLS
    public IDrmPort2,
#endif  // DRM_PORTCLS
    public IPortClsVersion,
    public CUnknown
{
private:
    PDEVICE_OBJECT          m_DeviceObject;
    PMINIPORTMIDI           m_Miniport;
    PSERVICEGROUP           m_MiniportServiceGroup;
    PPINCOUNT               m_MPPinCountI;

    PSUBDEVICE_DESCRIPTOR   m_pSubdeviceDescriptor;
    PPCFILTER_DESCRIPTOR    m_pPcFilterDescriptor;
    KDPC                    m_EventDpc;
    KMUTEX                  m_ControlMutex;
    INTERLOCKED_LIST        m_EventList;
    EVENT_DPC_CONTEXT       m_EventContext;

    // TODO:  Fix this.
#define MAX_PINS 32
    ULONG                   m_PinEntriesUsed;
    CPortPinMidi *          m_Pins[MAX_PINS];



public:
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CPortMidi);
    ~CPortMidi();

    IMP_ISubdevice;
    IMP_IPortMidi;
    IMP_IServiceSink;
    IMP_IPortEvents;
#ifdef DRM_PORTCLS
    IMP_IDrmPort2;
#endif  // DRM_PORTCLS
    IMP_IPortClsVersion;

    /*************************************************************************
     * friends
     */
    friend class CPortFilterMidi;
    friend class CPortPinMidi;

    friend
    NTSTATUS
    PinPropertyDataFormat
    (
        IN      PIRP            Irp,
        IN      PKSPROPERTY     Property,
        IN OUT  PKSDATAFORMAT   DataFormat
    );
    friend
    NTSTATUS
    PinPropertyDeviceState
    (
        IN      PIRP        Irp,
        IN      PKSPROPERTY Property,
        IN OUT  PKSSTATE    DeviceState
    );
    friend
    NTSTATUS
    PropertyHandler_Pin
    (
        IN      PIRP        Irp,
        IN      PKSP_PIN    Pin,
        IN OUT  PVOID       Data
    );
    friend
    NTSTATUS
    PropertyHandler_Topology
    (
        IN      PIRP        Irp,
        IN      PKSPROPERTY Property,
        IN OUT  PVOID       Data
    );
    friend
    void
    PcGenerateEventDeferredRoutine
    (
        IN PKDPC Dpc,
        IN PVOID DeferredContext,
        IN PVOID SystemArgument1,
        IN PVOID SystemArgument2        
    );
#ifdef PC_KDEXT
    //  Debugger extension routines
    friend
    VOID
    PCKD_AcquireDeviceData
    (
        PDEVICE_CONTEXT     DeviceContext,
        PLIST_ENTRY         SubdeviceList,
        ULONG               Flags
    );
    friend
    VOID
    PCKD_DisplayDeviceData
    (
        PDEVICE_CONTEXT     DeviceContext,
        PLIST_ENTRY         SubdeviceList,
        ULONG               Flags
    );
#endif
};

/*****************************************************************************
 * CPortFilterMidi
 *****************************************************************************
 * Filter implementation for midi port.
 */
class CPortFilterMidi
:   public IPortFilterMidi,
    public CUnknown
{
private:
    CPortMidi *         m_Port;
    PROPERTY_CONTEXT    m_propertyContext;

public:
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CPortFilterMidi);
    ~CPortFilterMidi();

    IMP_IIrpTarget;

    STDMETHODIMP_(NTSTATUS) Init
    (
        IN      CPortMidi *Port
    );

    /*************************************************************************
     * friends
     */
    friend class CPortPinMidi;

    friend
    NTSTATUS
    PropertyHandler_Pin
    (
        IN      PIRP        Irp,
        IN      PKSP_PIN    Pin,
        IN OUT  PVOID       Data
    );
    friend
    NTSTATUS
    PropertyHandler_Topology
    (
        IN      PIRP        Irp,
        IN      PKSPROPERTY Property,
        IN OUT  PVOID       Data
    );
};


typedef struct {
    KSMUSICFORMAT musicFormat;
    ULONG         midiData;
} MIDI_SHORT_MESSAGE, *PMIDI_SHORT_MESSAGE;

typedef enum
{
    eStatusState,
    eSysExState,
    eData1State,
    eData2State
} EMidiState;

typedef enum
{
    eCookSuccess,
    eCookDataError,
    eCookEndOfStream
} EMidiCookStatus;

#define kMaxSysExMessageSize (PAGE_SIZE / sizeof(PVOID) * PAGE_SIZE)
const ULONG kMaxSysExChunk = 12;   //  break up sysex messages into 
                                    //  KSMUSICFORMATs of this many bytes
/*****************************************************************************
 * CPortPinMidi
 *****************************************************************************
 * Pin implementation for midi port.
 */
class CPortPinMidi
:   public IPortPinMidi,
    public IIrpStreamNotify,
    public IServiceSink,
    public IKsShellTransport,
    public IKsWorkSink,
    public CUnknown
{
private:
    PDEVICE_OBJECT          m_ConnectionDeviceObject;
    PFILE_OBJECT            m_ConnectionFileObject;
    KSRESET                 m_ResetState;
    KSSTATE                 m_DeviceState;
    KSSTATE                 m_TransportState;
    KSSTATE                 m_CommandedState;

    CPortMidi *             m_Port;
    CPortFilterMidi *       m_Filter;

    PMINIPORTMIDISTREAM     m_Stream;
    ULONG                   m_Id;
    ULONG                   m_NumberOfRetries;
    PKSPIN_DESCRIPTOR       m_Descriptor;
    PKSDATAFORMAT           m_DataFormat;
    KSPIN_DATAFLOW          m_DataFlow;   // Because descriptor is paged.
    ULONG                   m_Index;

    PIRPSTREAMVIRTUAL       m_IrpStream;
    PSERVICEGROUP           m_ServiceGroup;

    LONGLONG                m_StartTime;
    LONGLONG                m_PauseTime;
    LONGLONG                m_MidiMsgPresTime;      //  the time of the next message
    LONGLONG                m_LastSequencerPresTime; // last time serve render ran.
    LARGE_INTEGER           m_TimerDue100ns;        //  we set sequencer timer to this (negative is relative)

    ULONG                   m_MidiMsg;
    BYTE                    m_RunningStatus;
    EMidiState              m_EMidiState;

    ULONG                   m_ByteCount;

    PBYTE                 * m_SysExBufferPtr;
    ULONG                   m_SysExByteCount;
    
    BOOLEAN                 m_UpdatePresTime;
    BOOLEAN                 m_Flushing;
    BOOLEAN                 m_LastDPCWasIncomplete;

    BOOL                    m_Suspended;
    
    KDPC                    m_Dpc;          //  x20 size
    KTIMER                  m_TimerEvent;   //  x24 size
    KSPIN_LOCK              m_DpcSpinLock;  //  x04 size

    KSPIN_LOCK              m_EventLock;
    LIST_ENTRY              m_EventList;
    PIKSSHELLTRANSPORT      m_TransportSink;
    PIKSSHELLTRANSPORT      m_TransportSource;
    PIKSSHELLTRANSPORT      m_RequestorTransport;
    PIKSSHELLTRANSPORT      m_QueueTransport;
    INTERLOCKEDLIST_HEAD    m_IrpsToSend;
    INTERLOCKEDLIST_HEAD    m_IrpsOutstanding;
    PKSWORKER               m_Worker;
    WORK_QUEUE_ITEM         m_WorkItem;

    PROPERTY_CONTEXT        m_propertyContext;
    
public:
    EMidiState  GetMidiState()  {   return this->m_EMidiState;    };

private:
    STDMETHODIMP_(void)
    PowerNotify(
        POWER_STATE PowerState
        );

    NTSTATUS
    WriteMidiDataToMiniport
    (
        PIRP pIrp
    );

    NTSTATUS
    DealWithOutputIrp
    (
        PIRP pIrp
    );

    LONGLONG
    GetCurrentTime();

    void ServeRender
    (   void
    );
    void ServeCapture
    (   void
    );

    BOOL IrpStreamHasValidTimeBase
    (   PIRPSTREAMPACKETINFO pIrpStreamPacketInfo
    );

    NTSTATUS MarkStreamHeaderDiscontinuity(void);
    NTSTATUS MarkStreamHeaderContinuity(void);
    void    CompleteStreamHeaderInProcess(void);

    void  InitializeStateVariables();
    void  PrintStateVariables();
    void  StatusSetState(BYTE aByte);
    void  SysExSetState(BYTE aByte);
    void  Data1SetState(BYTE aByte);
    void  Data2SetState(BYTE aByte);
    
    ULONG NumBytesLeftInBuffer(void);
    void  StartSysEx(BYTE aByte);
    void  AddByteToSysEx(BYTE aByte);
    void  SubmitCompleteSysEx(EMidiCookStatus cookStatus);
    void  FreeSysExBuffer();

    ULONG GetNextDeltaTime();
    void  SubmitRawByte(BYTE aByte);
    void  SubmitRealTimeByte(BYTE rtByte);

    BOOL  GetShortMessage(PBYTE pMidiData,ULONG *byteCount);
    void  SubmitCompleteMessage(PBYTE *ppMidiData,ULONG byteCount,EMidiCookStatus cookStatus);

    LONGLONG       GetCurrentPresTime(void);
    LONGLONG       GetNewPresTime(IRPSTREAMPACKETINFO *pPacketInfo,LONGLONG delta100ns);

    void SetMidiState(EMidiState state)  {  m_EMidiState = state;  };

public:
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CPortPinMidi);
    ~CPortPinMidi();

    IMP_IIrpTarget;
    IMP_IIrpStreamNotify;
    IMP_IServiceSink;
    IMP_IKsShellTransport;
    IMP_IKsWorkSink;

    /*************************************************************************
     * IPortPinMidi methods
     */
    STDMETHODIMP_(NTSTATUS) Init
    (
        IN      CPortMidi *         Port,
        IN      CPortFilterMidi *   Filter,
        IN      PKSPIN_CONNECT      PinConnect,
        IN      PKSPIN_DESCRIPTOR   PinDescriptor
    );

    /*************************************************************************
     * friends
     */
    friend CPortMidi;

    friend VOID NTAPI
    TimerDPC
    (
        IN      PKDPC   Dpc,
        IN      PVOID   DeferredContext,
        IN      PVOID   SystemArgument1,
        IN      PVOID   SystemArgument2
    );
    friend
    NTSTATUS
    PinPropertyDeviceState
    (
        IN      PIRP        Irp,
        IN      PKSPROPERTY Property,
        IN OUT  PKSSTATE    DeviceState
    );
    friend
    NTSTATUS
    PinPropertyDataFormat
    (
        IN      PIRP            Irp,
        IN      PKSPROPERTY     Property,
        IN OUT  PKSDATAFORMAT   DataFormat
    );
#ifdef PC_KDEXT
    //  Debugger extension routines
    friend
    VOID
    PCKD_AcquireDeviceData
    (
        PDEVICE_CONTEXT     DeviceContext,
        PLIST_ENTRY         SubdeviceList,
        ULONG               Flags
    );
    friend
    VOID
    PCKD_DisplayDeviceData
    (
        PDEVICE_CONTEXT     DeviceContext,
        PLIST_ENTRY         SubdeviceList,
        ULONG               Flags
    );
#endif
    
    NTSTATUS 
    DistributeDeviceState(
        IN KSSTATE NewState,
        IN KSSTATE OldState
        );
    void 
    DistributeResetState(
        IN KSRESET NewState
        );
    static
    NTSTATUS
    IoCompletionRoutine(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp,
        IN PVOID Context
        );
    NTSTATUS
    BuildTransportCircuit(
        void
        );
    void
    CancelIrpsOutstanding(
        void
        );
};




/*****************************************************************************
 * Functions.
 */

/*****************************************************************************
 * CreatePortFilterMidi()
 *****************************************************************************
 * Creates a MIDI port driver filter.
 */
NTSTATUS
CreatePortFilterMidi
(
    OUT     PUNKNOWN *  Unknown,
    IN      REFCLSID,
    IN      PUNKNOWN    UnknownOuter    OPTIONAL,
    IN      POOL_TYPE   PoolType
);

/*****************************************************************************
 * CreatePortPinMidi()
 *****************************************************************************
 * Creates a MIDI port driver pin.
 */
NTSTATUS
CreatePortPinMidi
(
    OUT     PUNKNOWN *  Unknown,
    IN      REFCLSID,
    IN      PUNKNOWN    UnknownOuter    OPTIONAL,
    IN      POOL_TYPE   PoolType
);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\ports\topology\pin.cpp ===
/*****************************************************************************
 * pin.cpp - toplogy port pin implementation
 *****************************************************************************
 * Copyright (c) 1997-2000 Microsoft Corporation.  All rights reserved.
 */

#include "private.h"





/*****************************************************************************
 * Factory functions.
 */

#pragma code_seg("PAGE")

/*****************************************************************************
 * CreatePortPinTopology()
 *****************************************************************************
 * Creates a topology port driver pin.
 */
NTSTATUS
CreatePortPinTopology
(
    OUT     PUNKNOWN *  Unknown,
    IN      REFCLSID,
    IN      PUNKNOWN    UnknownOuter    OPTIONAL,  
    IN      POOL_TYPE   PoolType
)
{
    PAGED_CODE();

    ASSERT(Unknown);

    _DbgPrintF(DEBUGLVL_LIFETIME,("Creating TOPOLOGY Pin"));

    STD_CREATE_BODY(CPortPinTopology,Unknown,UnknownOuter,PoolType);
}





/*****************************************************************************
 * Member functions.
 */

/*****************************************************************************
 * CPortPinTopology::~CPortPinTopology()
 *****************************************************************************
 * Destructor.
 */
CPortPinTopology::~CPortPinTopology()
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_LIFETIME,("Destroying TOPOLOGY Pin (0x%08x)",this));

    if (Port)
    {
        Port->Release();
    }
    if (Filter)
    {
        Filter->Release();
    }
}

/*****************************************************************************
 * CPortPinTopology::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.
 */
STDMETHODIMP_(NTSTATUS) 
CPortPinTopology::
NonDelegatingQueryInterface
(
    REFIID  Interface,
    PVOID * Object
)
{
    PAGED_CODE();

    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface,IID_IUnknown))
	{
        *Object = PVOID(PPORTPINTOPOLOGY(this));
	}
	else
    if (IsEqualGUIDAligned(Interface,IID_IIrpTarget))
	{
        // Cheat!  Get specific interface so we can reuse the IID.
        *Object = PVOID(PPORTPINTOPOLOGY(this));
    }
	else
	{
	    *Object = NULL;
	}
    
    if (*Object)
    {
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

/*****************************************************************************
 * CPortPinTopology::Init()
 *****************************************************************************
 * Initializes the object.
 */
STDMETHODIMP_(NTSTATUS) 
CPortPinTopology::
Init
(   
    IN  CPortTopology *			Port_,
	IN	CPortFilterTopology *	Filter_,
	IN	PKSPIN_CONNECT			PinConnect
)
{
    PAGED_CODE();

    ASSERT(Port_);
    ASSERT(Filter_);
    ASSERT(PinConnect);

    _DbgPrintF(DEBUGLVL_LIFETIME,("Initializing TOPOLOGY Pin (0x%08x)",this));

    Port = Port_;
    Port->AddRef();

    Filter = Filter_;
    Filter->AddRef();

	Id = PinConnect->PinId;

    //
    // Set up context for properties.
    //
    m_propertyContext.pSubdevice           = PSUBDEVICE(Port);
    m_propertyContext.pSubdeviceDescriptor = Port->m_pSubdeviceDescriptor;
    m_propertyContext.pPcFilterDescriptor  = Port->m_pPcFilterDescriptor;
    m_propertyContext.pUnknownMajorTarget  = Port->Miniport;
    m_propertyContext.pUnknownMinorTarget  = NULL;
    m_propertyContext.ulNodeId             = ULONG(-1);

    return STATUS_SUCCESS;
}

/*****************************************************************************
 * CPortPinTopology::DeviceIOControl()
 *****************************************************************************
 * Handles an IOCTL IRP.
 */
STDMETHODIMP_(NTSTATUS) 
CPortPinTopology::
DeviceIoControl
(   
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
)
{
    PAGED_CODE();

    ASSERT(DeviceObject);
    ASSERT(Irp);

    return KsDefaultDeviceIoCompletion(DeviceObject, Irp);
}

/*****************************************************************************
 * CPortPinTopology::Close()
 *****************************************************************************
 * Handles a flush IRP.
 */
STDMETHODIMP_(NTSTATUS) 
CPortPinTopology::
Close
(   
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
)
{
    PAGED_CODE();

    ASSERT(DeviceObject);
    ASSERT(Irp);

	//
	// Decrement instance counts.
	//
	ASSERT(Port);
	ASSERT(Filter);
    PcTerminateConnection
    (   Port->m_pSubdeviceDescriptor
    ,   Filter->m_propertyContext.pulPinInstanceCounts
    ,   Id
    );

    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp,IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}

DEFINE_INVALID_CREATE(CPortPinTopology);
DEFINE_INVALID_READ(CPortPinTopology);
DEFINE_INVALID_WRITE(CPortPinTopology);
DEFINE_INVALID_FLUSH(CPortPinTopology);
DEFINE_INVALID_QUERYSECURITY(CPortPinTopology);
DEFINE_INVALID_SETSECURITY(CPortPinTopology);
DEFINE_INVALID_FASTDEVICEIOCONTROL(CPortPinTopology);
DEFINE_INVALID_FASTREAD(CPortPinTopology);
DEFINE_INVALID_FASTWRITE(CPortPinTopology);

#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\ports\topology\port.cpp ===
/*****************************************************************************
 * port.cpp - topology port driver
 *****************************************************************************
 * Copyright (c) 1997-2000 Microsoft Corporation.  All rights reserved.
 */

#include "private.h"




/*****************************************************************************
 * Constants
 */
#pragma code_seg("PAGE")

static KSPIN_INTERFACE PinInterfaces[] =
{
   {
      STATICGUIDOF(KSINTERFACESETID_Standard),
      KSINTERFACE_STANDARD_STREAMING
   }
};

static KSPIN_MEDIUM PinMedia[] =
{
   {
      STATICGUIDOF(KSMEDIUMSETID_Standard),
      KSMEDIUM_STANDARD_DEVIO
   }
};


/*****************************************************************************
 * Factory
 */

/*****************************************************************************
 * CreatePortTopology()
 *****************************************************************************
 * Creates a topology port driver.
 */
NTSTATUS
CreatePortTopology
(
    OUT     PUNKNOWN *  Unknown,
    IN      REFCLSID,
    IN      PUNKNOWN    UnknownOuter    OPTIONAL,
    IN      POOL_TYPE   PoolType
)
{
    PAGED_CODE();

    ASSERT(Unknown);

    _DbgPrintF(DEBUGLVL_LIFETIME,("Creating TOPOLOGY Port"));

    STD_CREATE_BODY_
    (
        CPortTopology,
        Unknown,
        UnknownOuter,
        PoolType,
        PPORTTOPOLOGY
    );
}

/*****************************************************************************
 * PortDriverTopology
 *****************************************************************************
 * Port driver descriptor.  Referenced extern in porttbl.c.
 */
PORT_DRIVER
PortDriverTopology =
{
    &CLSID_PortTopology,
    CreatePortTopology
};





/*****************************************************************************
 * Member functions
 */

#pragma code_seg("PAGE")

/*****************************************************************************
 * CPortTopology::~CPortTopology()
 *****************************************************************************
 * Destructor.
 */
CPortTopology::~CPortTopology()
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_LIFETIME,("Destroying TOPOLOGY Port (0x%08x)",this));

    if (m_MPPinCountI)
    {
        m_MPPinCountI->Release();
        m_MPPinCountI = NULL;
    }

    if (Miniport)
    {
        Miniport->Release();
    }
    if (m_pSubdeviceDescriptor)
    {
        PcDeleteSubdeviceDescriptor(m_pSubdeviceDescriptor);
    }

    // TODO:  Kill notification queue?
}

/*****************************************************************************
 * CPortTopology::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.
 */
STDMETHODIMP_(NTSTATUS)
CPortTopology::
NonDelegatingQueryInterface
(
    REFIID  Interface,
    PVOID * Object
)
{
    PAGED_CODE();

    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface,IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(PPORT(this)));
    }
    else if (IsEqualGUIDAligned(Interface,IID_IPort))
    {
        *Object = PVOID(PPORT(this));
    }
    else if (IsEqualGUIDAligned(Interface,IID_IPortTopology))
    {
        *Object = PVOID(PPORTTOPOLOGY(this));
    }
    else if (IsEqualGUIDAligned(Interface,IID_IIrpTargetFactory))
    {
        *Object = PVOID(PIRPTARGETFACTORY(this));
    }
    else if (IsEqualGUIDAligned(Interface,IID_ISubdevice))
    {
        *Object = PVOID(PSUBDEVICE(this));
    }
    else if (IsEqualGUIDAligned(Interface,IID_IPortEvents))
    {
        *Object = PVOID(PPORTEVENTS(this));
    }
#ifdef DRM_PORTCLS
    else if (IsEqualGUIDAligned(Interface,IID_IDrmPort))
    {
        *Object = PVOID(PDRMPORT(this));
    }
    else if (IsEqualGUIDAligned(Interface,IID_IDrmPort2))
    {
        *Object = PVOID(PDRMPORT2(this));
    }
#endif  // DRM_PORTCLS
    else if (IsEqualGUIDAligned(Interface,IID_IPortClsVersion))
    {
        *Object = PVOID(PPORTCLSVERSION(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

static
GUID TopologyCategories[] =
{
    STATICGUIDOF(KSCATEGORY_AUDIO),
    STATICGUIDOF(KSCATEGORY_TOPOLOGY)
};

/*****************************************************************************
 * CPortTopology::Init()
 *****************************************************************************
 * Initializes the port.
 */
STDMETHODIMP_(NTSTATUS)
CPortTopology::
Init
(
    IN      PDEVICE_OBJECT  DeviceObjectIn,
    IN      PIRP            Irp,
    IN      PUNKNOWN        UnknownMiniport,
    IN      PUNKNOWN        UnknownAdapter  OPTIONAL,
    IN      PRESOURCELIST   ResourceList
)
{
    PAGED_CODE();

    ASSERT(DeviceObjectIn);
    ASSERT(Irp);
    ASSERT(UnknownMiniport);

    _DbgPrintF(DEBUGLVL_LIFETIME,("Initializing TOPOLOGY Port (0x%08x)",this));

    NTSTATUS ntStatus =
        UnknownMiniport->QueryInterface
        (
            IID_IMiniportTopology,
            (PVOID *) &Miniport
        );

    if (NT_SUCCESS(ntStatus))
    {
        DeviceObject = DeviceObjectIn;

        KeInitializeSpinLock( &(m_EventList.ListLock) );
        InitializeListHead( &(m_EventList.List) );
        m_EventContext.ContextInUse = FALSE;
        KeInitializeDpc( &m_EventDpc,
                         PKDEFERRED_ROUTINE(PcGenerateEventDeferredRoutine),
                         PVOID(&m_EventContext) );
        
        ntStatus =
            Miniport->Init
            (
                UnknownAdapter,
                ResourceList,
                PPORTTOPOLOGY(this)
            );

        if (NT_SUCCESS(ntStatus))
        {
            ntStatus = Miniport->GetDescription(&m_pPcFilterDescriptor);

            if (NT_SUCCESS(ntStatus))
            {
                ntStatus =
                    PcCreateSubdeviceDescriptor
                    (
                        m_pPcFilterDescriptor,
                        SIZEOF_ARRAY(TopologyCategories),
                        TopologyCategories,
                        0,
                        NULL,
                        SIZEOF_ARRAY(PropertyTable_FilterTopology),
                        PropertyTable_FilterTopology,
                        0,      // FilterEventSetCount
                        NULL,   // FilterEventSets
                        0,
                        NULL,
                        0,      // PinEventSetCount
                        NULL,   // PinEventSets
                        &m_pSubdeviceDescriptor
                    );
                if (NT_SUCCESS(ntStatus))
                {
                    NTSTATUS ntStatus = Miniport->QueryInterface( IID_IPinCount,(PVOID *)&m_MPPinCountI);
                }
            }
        }
    }

    if(!NT_SUCCESS(ntStatus))
    {
        if (m_MPPinCountI)
        {
            m_MPPinCountI->Release();
            m_MPPinCountI = NULL;
        }

        if( Miniport )
        {
            Miniport->Release();
            Miniport = NULL;
        }
    }

    return ntStatus;
}

/*****************************************************************************
 * CPortTopology::GetDeviceProperty()
 *****************************************************************************
 * Gets device properties from the registry for PnP devices.
 */
STDMETHODIMP_(NTSTATUS)
CPortTopology::
GetDeviceProperty
(
    IN      DEVICE_REGISTRY_PROPERTY    DeviceProperty,
    IN      ULONG                       BufferLength,
    OUT     PVOID                       PropertyBuffer,
    OUT     PULONG                      ResultLength
)
{
    return ::PcGetDeviceProperty(   PVOID(DeviceObject),
                                    DeviceProperty,
                                    BufferLength,
                                    PropertyBuffer,
                                    ResultLength );
}

/*****************************************************************************
 * CPortTopology::NewRegistryKey()
 *****************************************************************************
 * Opens/creates a registry key object.
 */
STDMETHODIMP_(NTSTATUS)
CPortTopology::
NewRegistryKey
(
    OUT     PREGISTRYKEY *      OutRegistryKey,
    IN      PUNKNOWN            OuterUnknown        OPTIONAL,
    IN      ULONG               RegistryKeyType,
    IN      ACCESS_MASK         DesiredAccess,
    IN      POBJECT_ATTRIBUTES  ObjectAttributes    OPTIONAL,
    IN      ULONG               CreateOptions       OPTIONAL,
    OUT     PULONG              Disposition         OPTIONAL
)
{
    return ::PcNewRegistryKey(  OutRegistryKey,
                                OuterUnknown,
                                RegistryKeyType,
                                DesiredAccess,
                                PVOID(DeviceObject),
                                PVOID(PSUBDEVICE(this)),
                                ObjectAttributes,
                                CreateOptions,
                                Disposition );
}

/*****************************************************************************
 * CPortTopology::ReleaseChildren()
 *****************************************************************************
 * Release child objects.
 */
STDMETHODIMP_(void)
CPortTopology::
ReleaseChildren
(   void
)
{
    if (m_MPPinCountI)
    {
        m_MPPinCountI->Release();
        m_MPPinCountI = NULL;
    }

    if (Miniport)
    {
        Miniport->Release();
        Miniport = NULL;
    }
}

/*****************************************************************************
 * CPortTopology::GetDescriptor()
 *****************************************************************************
 * Return the descriptor for this port
 */
STDMETHODIMP_(NTSTATUS)
CPortTopology::
GetDescriptor
(   OUT     const SUBDEVICE_DESCRIPTOR **   ppSubdeviceDescriptor
)
{
    PAGED_CODE();

    ASSERT(ppSubdeviceDescriptor);

    *ppSubdeviceDescriptor = m_pSubdeviceDescriptor;

    return STATUS_SUCCESS;
}

/*****************************************************************************
 * CPortTopology::DataRangeIntersection()
 *****************************************************************************
 * Generate a format which is the intersection of two data ranges.
 */
STDMETHODIMP_(NTSTATUS)
CPortTopology::
DataRangeIntersection
(   
    IN      ULONG           PinId,
    IN      PKSDATARANGE    DataRange,
    IN      PKSDATARANGE    MatchingDataRange,
    IN      ULONG           OutputBufferLength,
    OUT     PVOID           ResultantFormat     OPTIONAL,
    OUT     PULONG          ResultantFormatLength
)
{
    PAGED_CODE();

    ASSERT(DataRange);
    ASSERT(MatchingDataRange);
    ASSERT(ResultantFormatLength);

    return 
        Miniport->DataRangeIntersection
        (   PinId,
            DataRange,
            MatchingDataRange,
            OutputBufferLength,
            ResultantFormat,
            ResultantFormatLength
        );
}

/*****************************************************************************
 * CPortTopology::PowerChangeNotify()
 *****************************************************************************
 * Called by portcls to notify the port/miniport of a device power
 * state change.
 */
STDMETHODIMP_(void)
CPortTopology::
PowerChangeNotify
(   
    IN  POWER_STATE     PowerState
)
{
    PAGED_CODE();

    PPOWERNOTIFY pPowerNotify;

    if( Miniport )
    {
        // QI for the miniport notification interface
        NTSTATUS ntStatus = Miniport->QueryInterface( IID_IPowerNotify,
                                                      (PVOID *)&pPowerNotify );
        if(NT_SUCCESS(ntStatus))
        {
            // notify the miniport
            pPowerNotify->PowerChangeNotify( PowerState );

            // release the interface
            pPowerNotify->Release();
        }
    }
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortTopology::PinCount()
 *****************************************************************************
 * Called by portcls to give the port\miniport a chance 
 * to override the default pin counts for this pin ID.
 */
STDMETHODIMP_(void)
CPortTopology::PinCount
(
    IN      ULONG   PinId,
    IN  OUT PULONG  FilterNecessary,
    IN  OUT PULONG  FilterCurrent,
    IN  OUT PULONG  FilterPossible,
    IN  OUT PULONG  GlobalCurrent,
    IN  OUT PULONG  GlobalPossible
)
{
    PAGED_CODE();

    _DbgPrintF( DEBUGLVL_BLAB, 
                ("PinCount PID:0x%08x FN(0x%08x):%d FC(0x%08x):%d FP(0x%08x):%d GC(0x%08x):%d GP(0x%08x):%d",
                  PinId,                           FilterNecessary,*FilterNecessary,
                  FilterCurrent,  *FilterCurrent,  FilterPossible, *FilterPossible, 
                  GlobalCurrent,  *GlobalCurrent,  GlobalPossible, *GlobalPossible ) );

    if (m_MPPinCountI)
    {
        m_MPPinCountI->PinCount(PinId,FilterNecessary,FilterCurrent,FilterPossible,GlobalCurrent,GlobalPossible);

        _DbgPrintF( DEBUGLVL_BLAB, 
                    ("Post-PinCount PID:0x%08x FN(0x%08x):%d FC(0x%08x):%d FP(0x%08x):%d GC(0x%08x):%d GP(0x%08x):%d",
                      PinId,                           FilterNecessary,*FilterNecessary,
                      FilterCurrent,  *FilterCurrent,  FilterPossible, *FilterPossible, 
                      GlobalCurrent,  *GlobalCurrent,  GlobalPossible, *GlobalPossible ) );
    }
}

/*****************************************************************************
 * PinTypeName
 *****************************************************************************
 * The name of the pin object type.
 */
static const WCHAR PinTypeName[] = KSSTRING_Pin;

/*****************************************************************************
 * CreateTable
 *****************************************************************************
 * Create dispatch table.
 */
static KSOBJECT_CREATE_ITEM CreateTable[] =
{
    DEFINE_KSCREATE_ITEM(KsoDispatchCreateWithGenericFactory,PinTypeName,0)
};

/*****************************************************************************
 * CPortTopology::NewIrpTarget()
 *****************************************************************************
 * Creates and initializes a filter object.
 */
STDMETHODIMP_(NTSTATUS)
CPortTopology::
NewIrpTarget
(
    OUT     PIRPTARGET *        IrpTarget,
    OUT     BOOLEAN *           ReferenceParent,
    IN      PUNKNOWN            OuterUnknown,
    IN      POOL_TYPE           PoolType,
    IN      PDEVICE_OBJECT      DeviceObject,
    IN      PIRP                Irp,
    OUT     PKSOBJECT_CREATE    ObjectCreate
)
{
    PAGED_CODE();

    ASSERT(IrpTarget);
    ASSERT(DeviceObject);
    ASSERT(Irp);
    ASSERT(ObjectCreate);

    _DbgPrintF( DEBUGLVL_BLAB, ("CPortTopology::NewIrpTarget"));

    ObjectCreate->CreateItemsCount  = SIZEOF_ARRAY(CreateTable);
    ObjectCreate->CreateItemsList   = CreateTable;

    PUNKNOWN filterUnknown;
    NTSTATUS ntStatus =
        CreatePortFilterTopology
        (
            &filterUnknown,
            GUID_NULL,
            OuterUnknown,
            PoolType
        );

    if (NT_SUCCESS(ntStatus))
    {
        PPORTFILTERTOPOLOGY filterTopology;

        ntStatus =
            filterUnknown->QueryInterface
            (
                IID_IIrpTarget,
                (PVOID *) &filterTopology
            );

        if (NT_SUCCESS(ntStatus))
        {
            // The QI for IIrpTarget actually gets IPortFilterTopology.
            ntStatus = filterTopology->Init(this);
            if (NT_SUCCESS(ntStatus))
            {
                *IrpTarget = filterTopology;
                *ReferenceParent = TRUE;
            }
            else
            {
                filterTopology->Release();
            }
        }

        filterUnknown->Release();
    }

    return ntStatus;
}

#pragma code_seg()

/*****************************************************************************
 * CPortTopology::AddEventToEventList()
 *****************************************************************************
 * Adds an event to the port's event list.
 */
STDMETHODIMP_(void)
CPortTopology::
AddEventToEventList
(
    IN  PKSEVENT_ENTRY  EventEntry
)
{
    ASSERT(EventEntry);

    _DbgPrintF(DEBUGLVL_VERBOSE,("CPortTopology::AddEventToEventList"));

    KIRQL   oldIrql;

    if( EventEntry )
    {
        // grab the event list spin lock
        KeAcquireSpinLock( &(m_EventList.ListLock), &oldIrql );

        // add the event to the list tail
        InsertTailList( &(m_EventList.List),
                        (PLIST_ENTRY)((PVOID)EventEntry) );

        // release the event list spin lock
        KeReleaseSpinLock( &(m_EventList.ListLock), oldIrql );
    }
}

/*****************************************************************************
 * CPortTopology::GenerateEventList()
 *****************************************************************************
 * Wraps KsGenerateEventList for miniports.
 */
STDMETHODIMP_(void)
CPortTopology::
GenerateEventList
(
    IN  GUID*   Set     OPTIONAL,
    IN  ULONG   EventId,
    IN  BOOL    PinEvent,
    IN  ULONG   PinId,
    IN  BOOL    NodeEvent,
    IN  ULONG   NodeId
)
{
    if( KeGetCurrentIrql() > DISPATCH_LEVEL )
    {
        if( !m_EventContext.ContextInUse )
        {
            m_EventContext.ContextInUse = TRUE;
            m_EventContext.Set = Set;
            m_EventContext.EventId = EventId;
            m_EventContext.PinEvent = PinEvent;
            m_EventContext.PinId = PinId;
            m_EventContext.NodeEvent = NodeEvent;
            m_EventContext.NodeId = NodeId;
    
            KeInsertQueueDpc( &m_EventDpc,
                              PVOID(&m_EventList),
                              NULL );
        }
    } else
    {
        PcGenerateEventList( &m_EventList,
                             Set,
                             EventId,
                             PinEvent,
                             PinId,
                             NodeEvent,
                             NodeId );
    }
}

#ifdef DRM_PORTCLS

#pragma code_seg("PAGE")

STDMETHODIMP_(NTSTATUS)
CPortTopology::
AddContentHandlers(ULONG ContentId,PVOID * paHandlers,ULONG NumHandlers)
{
    PAGED_CODE();
    return DrmAddContentHandlers(ContentId,paHandlers,NumHandlers);
}

STDMETHODIMP_(NTSTATUS)
CPortTopology::
CreateContentMixed(PULONG paContentId,ULONG cContentId,PULONG pMixedContentId)
{
    PAGED_CODE();
    return DrmCreateContentMixed(paContentId,cContentId,pMixedContentId);
}

STDMETHODIMP_(NTSTATUS)
CPortTopology::
DestroyContent(ULONG ContentId)
{
    PAGED_CODE();
    return DrmDestroyContent(ContentId);
}

STDMETHODIMP_(NTSTATUS)
CPortTopology::
ForwardContentToDeviceObject(ULONG ContentId,PVOID Reserved,PCDRMFORWARD DrmForward)
{
    PAGED_CODE();
    return DrmForwardContentToDeviceObject(ContentId,Reserved,DrmForward);
}

STDMETHODIMP_(NTSTATUS)
CPortTopology::
ForwardContentToFileObject(ULONG ContentId,PFILE_OBJECT FileObject)
{
    PAGED_CODE();
    return DrmForwardContentToFileObject(ContentId,FileObject);
}

STDMETHODIMP_(NTSTATUS)
CPortTopology::
ForwardContentToInterface(ULONG ContentId,PUNKNOWN pUnknown,ULONG NumMethods)
{
    PAGED_CODE();
    return DrmForwardContentToInterface(ContentId,pUnknown,NumMethods);
}

STDMETHODIMP_(NTSTATUS)
CPortTopology::
GetContentRights(ULONG ContentId,PDRMRIGHTS DrmRights)
{
    PAGED_CODE();
    return DrmGetContentRights(ContentId,DrmRights);
}

#endif  // DRM_PORTCLS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\ports\topology\filter.cpp ===
/*****************************************************************************
 * filter.cpp - topology port filter implementation
 *****************************************************************************
 * Copyright (c) 1997-2000 Microsoft Corporation.  All rights reserved.
 */

#include "private.h"





/*****************************************************************************
 * Constants
 */

#pragma code_seg("PAGE")

/*****************************************************************************
 * PropertyTable_Pin
 *****************************************************************************
 * List of pin properties supported by the property handler.
 */
DEFINE_KSPROPERTY_TABLE(PropertyTable_Pin) 
{
    DEFINE_KSPROPERTY_ITEM_PIN_CINSTANCES(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_CTYPES(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_DATAFLOW(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_DATARANGES(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_DATAINTERSECTION(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_INTERFACES(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_MEDIUMS(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_COMMUNICATION(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_GLOBALCINSTANCES(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_NECESSARYINSTANCES(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_PHYSICALCONNECTION(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_CATEGORY(PropertyHandler_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_NAME(PropertyHandler_Pin)
};

/*****************************************************************************
 * PropertyTable_Topology
 *****************************************************************************
 * List of topology properties supported by the property handler.
 */
DEFINE_KSPROPERTY_TOPOLOGYSET
(
    PropertyTable_Topology,
    PropertyHandler_Topology
);

/*****************************************************************************
 * PropertyTable_FilterTopology
 *****************************************************************************
 * Table of properties supported by the property handler.
 */
KSPROPERTY_SET PropertyTable_FilterTopology[] =
{
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_Pin,
        SIZEOF_ARRAY(PropertyTable_Pin),
        PropertyTable_Pin,
        0,
        NULL
    ),
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_Topology,
        SIZEOF_ARRAY(PropertyTable_Topology),
        PropertyTable_Topology,
        0,
        NULL
    )
};





/*****************************************************************************
 * Factory functions.
 */

/*****************************************************************************
 * CreatePortFilterTopology()
 *****************************************************************************
 * Creates a topology port driver filter.
 */
NTSTATUS
CreatePortFilterTopology
(
    OUT     PUNKNOWN *  Unknown,
    IN      REFCLSID,
    IN      PUNKNOWN    UnknownOuter    OPTIONAL,  
    IN      POOL_TYPE   PoolType
)
{
    PAGED_CODE();

    ASSERT(Unknown);

    _DbgPrintF(DEBUGLVL_LIFETIME,("Creating TOPOLOGY Filter"));

    STD_CREATE_BODY(CPortFilterTopology,Unknown,UnknownOuter,PoolType);
}





/*****************************************************************************
 * Member functions.
 */

/*****************************************************************************
 * CPortFilterTopology::~CPortFilterTopology()
 *****************************************************************************
 * Destructor.
 */
CPortFilterTopology::~CPortFilterTopology()
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_LIFETIME,("Destroying TOPOLOGY Filter (0x%08x)",this));

    if (Port)
    {
        Port->Release();
    }

    if (m_propertyContext.pulPinInstanceCounts)
    {
        delete [] m_propertyContext.pulPinInstanceCounts;
    }
}

/*****************************************************************************
 * CPortFilterTopology::Init()
 *****************************************************************************
 * Initializes the object.
 */
STDMETHODIMP_(NTSTATUS) 
CPortFilterTopology::
Init
(   
    IN  CPortTopology *Port_
)
{
    PAGED_CODE();

    ASSERT(Port_);

    _DbgPrintF(DEBUGLVL_LIFETIME,("Initializing TOPOLOGY Filter (0x%08x)",this));

    Port = Port_;
    Port->AddRef();

    //
    // Set up context for properties.
    //
    m_propertyContext.pSubdevice           = PSUBDEVICE(Port);
    m_propertyContext.pSubdeviceDescriptor = Port->m_pSubdeviceDescriptor;
    m_propertyContext.pPcFilterDescriptor  = Port->m_pPcFilterDescriptor;
    m_propertyContext.pUnknownMajorTarget  = Port->Miniport;
    m_propertyContext.pUnknownMinorTarget  = NULL;
    m_propertyContext.ulNodeId             = ULONG(-1);
    m_propertyContext.pulPinInstanceCounts = 
        new(NonPagedPool,'cIcP') ULONG[Port->m_pSubdeviceDescriptor->PinCount];

    NTSTATUS ntStatus = STATUS_SUCCESS;

    if (! m_propertyContext.pulPinInstanceCounts)
    {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}

/*****************************************************************************
 * CPortFilterTopology::NewIrpTarget()
 *****************************************************************************
 * Creates and initializes a pin object.
 */
STDMETHODIMP_(NTSTATUS)
CPortFilterTopology::
NewIrpTarget
(
    OUT     PIRPTARGET *        IrpTarget,
    OUT     BOOLEAN *           ReferenceParent,
    IN      PUNKNOWN            OuterUnknown,
    IN      POOL_TYPE           PoolType,
    IN      PDEVICE_OBJECT      DeviceObject,
    IN      PIRP                Irp,
    OUT     PKSOBJECT_CREATE    ObjectCreate
)
{
    PAGED_CODE();

    ASSERT(IrpTarget);
    ASSERT(DeviceObject);
    ASSERT(Irp);
    ASSERT(ObjectCreate);

    _DbgPrintF( DEBUGLVL_BLAB, ("CPortFilterTopology::NewPin"));

    PKSPIN_CONNECT pinConnect;
    NTSTATUS ntStatus =
        PcValidateConnectRequest
        (
            Irp,
            Port->m_pSubdeviceDescriptor,
            &pinConnect
        );

    if (NT_SUCCESS(ntStatus))
    {
        ULONG PinId = pinConnect->PinId;

        Port->PinCount
        ( 
            PinId,
            &(m_propertyContext.pSubdeviceDescriptor->
                PinInstances[PinId].FilterNecessary),
            &(m_propertyContext.pulPinInstanceCounts[PinId]),
            &(m_propertyContext.pSubdeviceDescriptor->
                PinInstances[PinId].FilterPossible),
            &(m_propertyContext.pSubdeviceDescriptor->
                PinInstances[PinId].GlobalCurrent),
            &(m_propertyContext.pSubdeviceDescriptor->
                PinInstances[PinId].GlobalPossible) 
        );

        ntStatus = 
            PcValidatePinCount
            (
                PinId,
                Port->m_pSubdeviceDescriptor,
                m_propertyContext.pulPinInstanceCounts
            );

        if (NT_SUCCESS(ntStatus))
        {
            ObjectCreate->CreateItemsCount  = 0;
            ObjectCreate->CreateItemsList   = NULL;

            PUNKNOWN pinUnknown;
            ntStatus =
                CreatePortPinTopology
                (
                    &pinUnknown,
                    GUID_NULL,
                    OuterUnknown,
                    PoolType
                );

            if (NT_SUCCESS(ntStatus))
            {
                PPORTPINTOPOLOGY pinTopology;

                ntStatus = 
                    pinUnknown->QueryInterface
                    (
                        IID_IIrpTarget,
                        (PVOID *) &pinTopology
                    );

                if (NT_SUCCESS(ntStatus))
                {
                    // The QI for IIrpTarget actually gets IPortPinMidi.
                    ntStatus = pinTopology->Init(Port,this,pinConnect);
                    if (NT_SUCCESS(ntStatus))
                    {
                        *IrpTarget = pinTopology;
                        *ReferenceParent = TRUE;
                    }
                    else
                    {
                        pinTopology->Release();
                    }
                }

                pinUnknown->Release();
            }

            if (! NT_SUCCESS(ntStatus))
            {
                PcTerminateConnection
                (   Port->m_pSubdeviceDescriptor
                ,   m_propertyContext.pulPinInstanceCounts
                ,   pinConnect->PinId
                );
            }
        }
    }

    return ntStatus;
}

/*****************************************************************************
 * CPortFilterTopology::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.
 */
STDMETHODIMP_(NTSTATUS) 
CPortFilterTopology::
NonDelegatingQueryInterface
(
    REFIID  Interface,
    PVOID * Object
)
{
    PAGED_CODE();

    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface,IID_IUnknown))
	{
        *Object = PVOID(PPORTFILTERTOPOLOGY(this));
	}
	else
    if (IsEqualGUIDAligned(Interface,IID_IIrpTarget))
	{
        // Cheat!  Get specific interface so we can reuse the IID.
        *Object = PVOID(PPORTFILTERTOPOLOGY(this));
    }
	else
	{
	    *Object = NULL;
	}
    
    if (*Object)
    {
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

/*****************************************************************************
 * CPortFilterTopology::DeviceIOControl()
 *****************************************************************************
 * Handles an IOCTL IRP.
 */
STDMETHODIMP_(NTSTATUS) 
CPortFilterTopology::
DeviceIoControl
(   
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
)
{
    PAGED_CODE();

    ASSERT(DeviceObject);
    ASSERT(Irp);

    NTSTATUS            ntStatus;
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);

    switch (irpSp->Parameters.DeviceIoControl.IoControlCode) 
    {
    case IOCTL_KS_PROPERTY:
        ntStatus =
            PcHandlePropertyWithTable
            (
                Irp,
                Port->m_pSubdeviceDescriptor->FilterPropertyTable.PropertySetCount,
                Port->m_pSubdeviceDescriptor->FilterPropertyTable.PropertySets,
				&m_propertyContext
            );
        break;

    case IOCTL_KS_ENABLE_EVENT:
        {
            EVENT_CONTEXT EventContext;

            EventContext.pPropertyContext = &m_propertyContext;
            EventContext.pEventList = NULL;
            EventContext.ulPinId = ULONG(-1);
            EventContext.ulEventSetCount = Port->m_pSubdeviceDescriptor->FilterEventTable.EventSetCount;
            EventContext.pEventSets = Port->m_pSubdeviceDescriptor->FilterEventTable.EventSets;
            
            ntStatus =
                PcHandleEnableEventWithTable
                (
                    Irp,
                    &EventContext
                );
        }
        break;

    case IOCTL_KS_DISABLE_EVENT:
        {
            EVENT_CONTEXT EventContext;

            EventContext.pPropertyContext = &m_propertyContext;
            EventContext.pEventList = &(Port->m_EventList);
            EventContext.ulPinId = ULONG(-1);
            EventContext.ulEventSetCount = Port->m_pSubdeviceDescriptor->FilterEventTable.EventSetCount;
            EventContext.pEventSets = Port->m_pSubdeviceDescriptor->FilterEventTable.EventSets;

            ntStatus =
                PcHandleDisableEventWithTable
                (
                    Irp,
                    &EventContext
                );
        }
        break;
    
    default:
        return KsDefaultDeviceIoCompletion(DeviceObject, Irp);
    }

    Irp->IoStatus.Status = ntStatus;
    IoCompleteRequest(Irp,IO_NO_INCREMENT);
    return ntStatus;
}

/*****************************************************************************
 * CPortFilterTopology::Close()
 *****************************************************************************
 * Handles a flush IRP.
 */
STDMETHODIMP_(NTSTATUS) 
CPortFilterTopology::
Close
(   
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
)
{
    PAGED_CODE();

    ASSERT(DeviceObject);
    ASSERT(Irp);

    //
    // free any events in the port event list associated with this
    // filter instance
    //
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
    KsFreeEventList( IrpStack->FileObject,
                     &( Port->m_EventList.List ),
                     KSEVENTS_SPINLOCK,
                     &( Port->m_EventList.ListLock) );

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp,IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}

DEFINE_INVALID_READ(CPortFilterTopology);
DEFINE_INVALID_WRITE(CPortFilterTopology);
DEFINE_INVALID_FLUSH(CPortFilterTopology);
DEFINE_INVALID_QUERYSECURITY(CPortFilterTopology);
DEFINE_INVALID_SETSECURITY(CPortFilterTopology);
DEFINE_INVALID_FASTDEVICEIOCONTROL(CPortFilterTopology);
DEFINE_INVALID_FASTREAD(CPortFilterTopology);
DEFINE_INVALID_FASTWRITE(CPortFilterTopology);

/*****************************************************************************
 * PropertyHandler_Pin()
 *****************************************************************************
 * Property handler for pin description properties.
 */
static
NTSTATUS
PropertyHandler_Pin
(
    IN      PIRP        Irp,
    IN      PKSP_PIN    Pin,
    IN OUT  PVOID       Data
)
{
    PAGED_CODE();

    ASSERT(Irp);
    ASSERT(Pin);

    return
        PcPinPropertyHandler
        (   Irp
        ,   Pin
        ,   Data
        );
}

/*****************************************************************************
 * PropertyHandler_Topology()
 *****************************************************************************
 * Property handler for topology.
 */
static
NTSTATUS
PropertyHandler_Topology
(
    IN      PIRP        Irp,
    IN      PKSPROPERTY Property,
    IN OUT  PVOID       Data
)
{
    PAGED_CODE();

    ASSERT(Irp);
    ASSERT(Property);

    PPROPERTY_CONTEXT pPropertyContext =
        PPROPERTY_CONTEXT(Irp->Tail.Overlay.DriverContext[3]);
    ASSERT(pPropertyContext);

    PSUBDEVICE_DESCRIPTOR pSubdeviceDescriptor =
        pPropertyContext->pSubdeviceDescriptor;
    ASSERT(pSubdeviceDescriptor);

    return
        KsTopologyPropertyHandler
        (
            Irp,
            Property,
            Data,
            pSubdeviceDescriptor->Topology
        );
}

#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\ports\midi\port.cpp ===
/*****************************************************************************
 * port.cpp - midi port driver
 *****************************************************************************
 * Copyright (c) 1997-2000 Microsoft Corporation.  All rights reserved.
 */

#include "private.h"





/*****************************************************************************
 * Factory
 */

#pragma code_seg("PAGE")
/*****************************************************************************
 * CreatePortMidi()
 *****************************************************************************
 * Creates a midi port driver.
 */
NTSTATUS
CreatePortMidi
(
    OUT     PUNKNOWN *  Unknown,
    IN      REFCLSID,
    IN      PUNKNOWN    UnknownOuter    OPTIONAL,
    IN      POOL_TYPE   PoolType
)
{
    PAGED_CODE();

    ASSERT(Unknown);

    _DbgPrintF(DEBUGLVL_LIFETIME,("Creating MIDI Port"));

    STD_CREATE_BODY_
    (
        CPortMidi,
        Unknown,
        UnknownOuter,
        PoolType,
        PPORTMIDI
    );
}

/*****************************************************************************
 * PortDriverMidi
 *****************************************************************************
 * Port driver descriptor.  Referenced extern in porttbl.c.
 */
PORT_DRIVER
PortDriverMidi =
{
    &CLSID_PortMidi,
    CreatePortMidi
};

#pragma code_seg()


/*****************************************************************************
 * Member functions
 */

/*****************************************************************************
 * CPortMidi::Notify()
 *****************************************************************************
 * Lower-edge function to notify port driver of notification interrupt.
 */
STDMETHODIMP_(void)
CPortMidi::
Notify
(
    IN      PSERVICEGROUP   ServiceGroup    OPTIONAL
)
{
    if (ServiceGroup)
    {
        ServiceGroup->RequestService();
    }
    else
    {
        if (m_MiniportServiceGroup)
        {
            m_MiniportServiceGroup->RequestService();
        }

        for (ULONG pIndex = 0; pIndex < m_PinEntriesUsed; pIndex++)
        {
            if (m_Pins[pIndex] && m_Pins[pIndex]->m_ServiceGroup)
            {
                m_Pins[pIndex]->m_ServiceGroup->RequestService();
            }
            }
        }
    }

/*****************************************************************************
 * CPortMidi::RequestService()
 *****************************************************************************
 * 
 */
STDMETHODIMP_(void)
CPortMidi::
RequestService
(   void
)
    {
    if (m_Miniport)
    {
        m_Miniport->Service();
    }
}



#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortMidi::~CPortMidi()
 *****************************************************************************
 * Destructor.
 */
CPortMidi::~CPortMidi()
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_LIFETIME,("Destroying MIDI Port (0x%08x)",this));

    if (m_pSubdeviceDescriptor)
    {
        PcDeleteSubdeviceDescriptor(m_pSubdeviceDescriptor);
    }
    ULONG ulRefCount;
    if (m_MPPinCountI)
    {
        ulRefCount = m_MPPinCountI->Release();
        m_MPPinCountI = NULL;
    }
    if (m_MiniportServiceGroup)
    {
        m_MiniportServiceGroup->RemoveMember(PSERVICESINK(this));
        ulRefCount = m_MiniportServiceGroup->Release();
        ASSERT(0 == ulRefCount);
        m_MiniportServiceGroup = NULL;
    }
    if (m_Miniport)
    {
        ulRefCount = m_Miniport->Release();
        ASSERT(0 == ulRefCount);
        m_Miniport = NULL;
    }
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortMidi::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.
 */
STDMETHODIMP_(NTSTATUS)
CPortMidi::
NonDelegatingQueryInterface
(
    REFIID  Interface,
    PVOID * Object
)
{
    PAGED_CODE();

    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface,IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(PPORT(this)));
    }
    else if (IsEqualGUIDAligned(Interface,IID_IPort))
    {
        *Object = PVOID(PPORT(this));
    }
    else if (IsEqualGUIDAligned(Interface,IID_IPortMidi))
    {
        *Object = PVOID(PPORTMIDI(this));
    }
    else if (IsEqualGUIDAligned(Interface,IID_IIrpTargetFactory))
    {
        *Object = PVOID(PIRPTARGETFACTORY(this));
    }
    else if (IsEqualGUIDAligned(Interface,IID_ISubdevice))
    {
        *Object = PVOID(PSUBDEVICE(this));
    }
    else if (IsEqualGUIDAligned(Interface,IID_IServiceSink))
    {
        *Object = PVOID(PSERVICESINK(this));
    }
    else if (IsEqualGUIDAligned(Interface,IID_IPortEvents))
    {
        *Object = PVOID(PPORTEVENTS(this));
    }
#ifdef DRM_PORTCLS
    else if (IsEqualGUIDAligned(Interface,IID_IDrmPort))
    {
        *Object = PVOID(PDRMPORT(this));
    }
    else if (IsEqualGUIDAligned(Interface,IID_IDrmPort2))
    {
        *Object = PVOID(PDRMPORT2(this));
    }
#endif  // DRM_PORTCLS
    else if (IsEqualGUIDAligned(Interface,IID_IPortClsVersion))
    {
        *Object = PVOID(PPORTCLSVERSION(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

static
GUID TopologyCategories[] =
{
    STATICGUIDOF(KSCATEGORY_AUDIO),
    STATICGUIDOF(KSCATEGORY_RENDER),
    STATICGUIDOF(KSCATEGORY_CAPTURE)
};

static
KSPIN_INTERFACE PinInterfacesStream[] =
{
   {
      STATICGUIDOF(KSINTERFACESETID_Standard),
      KSINTERFACE_STANDARD_STREAMING,
      0
   }
};

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortMidi::Init()
 *****************************************************************************
 * Initializes the port.
 */
STDMETHODIMP_(NTSTATUS)
CPortMidi::
Init
(
    IN      PDEVICE_OBJECT  DeviceObjectIn,
    IN      PIRP            Irp,
    IN      PUNKNOWN        UnknownMiniport,
    IN      PUNKNOWN        UnknownAdapter  OPTIONAL,
    IN      PRESOURCELIST   ResourceList
)
{
    PAGED_CODE();

    ASSERT(DeviceObjectIn);
    ASSERT(Irp);
    ASSERT(UnknownMiniport);
    ASSERT(ResourceList);

    _DbgPrintF(DEBUGLVL_LIFETIME,("Initializing MIDI Port (0x%08x)",this));

    m_DeviceObject = DeviceObjectIn;

    KeInitializeMutex(&m_ControlMutex,1);

    KeInitializeSpinLock( &(m_EventList.ListLock) );
    InitializeListHead( &(m_EventList.List) );
    m_EventContext.ContextInUse = FALSE;
    KeInitializeDpc( &m_EventDpc,
                     PKDEFERRED_ROUTINE(PcGenerateEventDeferredRoutine),
                     PVOID(&m_EventContext) );

    PSERVICEGROUP pServiceGroup = NULL;

    NTSTATUS ntStatus =
        UnknownMiniport->QueryInterface
        (
            IID_IMiniportMidi,
            (PVOID *) &m_Miniport
        );

    if (NT_SUCCESS(ntStatus))
    {
        ntStatus =
            m_Miniport->Init
            (
                UnknownAdapter,
                ResourceList,
                PPORTMIDI(this),
                &pServiceGroup
            );

        if (NT_SUCCESS(ntStatus))
        {
            ntStatus = m_Miniport->GetDescription(&m_pPcFilterDescriptor);

            if (NT_SUCCESS(ntStatus))
            {
                ntStatus =
                    PcCreateSubdeviceDescriptor
                    (
                        m_pPcFilterDescriptor,
                        SIZEOF_ARRAY(TopologyCategories),
                        TopologyCategories,
                        SIZEOF_ARRAY(PinInterfacesStream),
                        PinInterfacesStream,
                        SIZEOF_ARRAY(PropertyTable_FilterMidi),
                        PropertyTable_FilterMidi,
                        0,      // FilterEventSetCount
                        NULL,   // FilterEventSets
                        SIZEOF_ARRAY(PropertyTable_PinMidi),
                        PropertyTable_PinMidi,
                        SIZEOF_ARRAY(EventTable_PinMidi),
                        EventTable_PinMidi,
                        &m_pSubdeviceDescriptor
                    );

                if (NT_SUCCESS(ntStatus) && pServiceGroup)
                {
                    //
                    // The miniport supplied a service group.
                    //
                    if (m_MiniportServiceGroup)
                    {
                        //
                        // We got it already from RegisterServiceGroup().
                        // Do a release because we don't need the new ref.
                        //
                        ASSERT(m_MiniportServiceGroup == pServiceGroup);
                        pServiceGroup->Release();
                        pServiceGroup = NULL;
                    }
                    else
                    {
                        //
                        // RegisterServiceGroup() was not called.  We need
                        // to add a member.  There is already a reference
                        // added by the miniport's Init().
                        //
                        m_MiniportServiceGroup = pServiceGroup;
                        m_MiniportServiceGroup->AddMember(PSERVICESINK(this));
                    }
                }
                if (NT_SUCCESS(ntStatus))
                {
                    NTSTATUS ntStatus = m_Miniport->QueryInterface( IID_IPinCount,(PVOID *)&m_MPPinCountI);
                }

#if 0 //DEBUG
                if (NT_SUCCESS(ntStatus))
                {
                    PKSPIN_DESCRIPTOR pKsPinDescriptor = m_pSubdeviceDescriptor->PinDescriptors;
                    for (ULONG ulPinId = 0; ulPinId < m_pSubdeviceDescriptor->PinCount; ulPinId++, pKsPinDescriptor++)
                    {
                        if 
                        (   (pKsPinDescriptor->Communication == KSPIN_COMMUNICATION_SINK)
                        &&  (pKsPinDescriptor->DataFlow == KSPIN_DATAFLOW_OUT)
                        )
                        {
                            _DbgPrintF(DEBUGLVL_TERSE,("CPortMidi::Init] converting pin %d to KSPIN_COMMUNICATION_BOTH",ulPinId));
                            pKsPinDescriptor->Communication = KSPIN_COMMUNICATION_BOTH;
                        }
                    }
                }
#endif //DEBUG
            }
        }
    }

    if (!NT_SUCCESS(ntStatus))
    {
        if (pServiceGroup)
        {
            pServiceGroup->Release();
        }

        if (m_MiniportServiceGroup)
        {
            m_MiniportServiceGroup->RemoveMember(PSERVICESINK(this));
            m_MiniportServiceGroup->Release();
            m_MiniportServiceGroup = NULL;            
        }

        if (m_MPPinCountI)
        {
            m_MPPinCountI->Release();
            m_MPPinCountI = NULL;
        }

        if (m_Miniport)
        {
            m_Miniport->Release();
            m_Miniport = NULL;
        }
    }

    _DbgPrintF( DEBUGLVL_VERBOSE, ("Midi Port Init done w/status %x",ntStatus));

    return ntStatus;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortMidi::RegisterServiceGroup()
 *****************************************************************************
 * Early registration of the service group to handle interrupts during Init().
 */
STDMETHODIMP_(void)
CPortMidi::
RegisterServiceGroup
(
    IN      PSERVICEGROUP   pServiceGroup
)
{
    PAGED_CODE();

    ASSERT(pServiceGroup);
    ASSERT(!m_MiniportServiceGroup);

    m_MiniportServiceGroup = pServiceGroup;
    m_MiniportServiceGroup->AddRef();
    m_MiniportServiceGroup->AddMember(PSERVICESINK(this));
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortMidi::GetDeviceProperty()
 *****************************************************************************
 * Gets device properties from the registry for PnP devices.
 */
STDMETHODIMP_(NTSTATUS)
CPortMidi::
GetDeviceProperty
(
    IN      DEVICE_REGISTRY_PROPERTY    DeviceProperty,
    IN      ULONG                       BufferLength,
    OUT     PVOID                       PropertyBuffer,
    OUT     PULONG                      ResultLength
)
{
    PAGED_CODE();

    return ::PcGetDeviceProperty(   PVOID(m_DeviceObject),
                                    DeviceProperty,
                                    BufferLength,
                                    PropertyBuffer,
                                    ResultLength );
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortMidi::NewRegistryKey()
 *****************************************************************************
 * Opens/creates a registry key object.
 */
STDMETHODIMP_(NTSTATUS)
CPortMidi::
NewRegistryKey
(
    OUT     PREGISTRYKEY *      OutRegistryKey,
    IN      PUNKNOWN            OuterUnknown        OPTIONAL,
    IN      ULONG               RegistryKeyType,
    IN      ACCESS_MASK         DesiredAccess,
    IN      POBJECT_ATTRIBUTES  ObjectAttributes    OPTIONAL,
    IN      ULONG               CreateOptions       OPTIONAL,
    OUT     PULONG              Disposition         OPTIONAL
)
{
    PAGED_CODE();

    return ::PcNewRegistryKey(  OutRegistryKey,
                                OuterUnknown,
                                RegistryKeyType,
                                DesiredAccess,
                                PVOID(m_DeviceObject),
                                PVOID(PSUBDEVICE(this)),
                                ObjectAttributes,
                                CreateOptions,
                                Disposition );
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortMidi::ReleaseChildren()
 *****************************************************************************
 * Release child objects.
 */
STDMETHODIMP_(void)
CPortMidi::
ReleaseChildren
(   void
)
{
    PAGED_CODE();

    _DbgPrintF (DEBUGLVL_LIFETIME, ("ReleaseChildren of 0x%08x", this));

    if (m_MPPinCountI)
    {
        m_MPPinCountI->Release();
        m_MPPinCountI = NULL;
    }

    if (m_Miniport)
    {
        m_Miniport->Release();
        m_Miniport = NULL;
    }

    if (m_MiniportServiceGroup)
    {
        m_MiniportServiceGroup->RemoveMember(PSERVICESINK(this));
        m_MiniportServiceGroup->Release();
        m_MiniportServiceGroup = NULL;
    }
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortMidi::GetDescriptor()
 *****************************************************************************
 * Return the descriptor for this port
 */
STDMETHODIMP_(NTSTATUS)
CPortMidi::
GetDescriptor
(   OUT     const SUBDEVICE_DESCRIPTOR **   ppSubdeviceDescriptor
)
{
    PAGED_CODE();

    ASSERT(ppSubdeviceDescriptor);

    *ppSubdeviceDescriptor = m_pSubdeviceDescriptor;

    return STATUS_SUCCESS;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortMidi::DataRangeIntersection()
 *****************************************************************************
 * Generate a format which is the intersection of two data ranges.
 */
STDMETHODIMP_(NTSTATUS)
CPortMidi::
DataRangeIntersection
(   
    IN      ULONG           PinId,
    IN      PKSDATARANGE    DataRange,
    IN      PKSDATARANGE    MatchingDataRange,
    IN      ULONG           OutputBufferLength,
    OUT     PVOID           ResultantFormat     OPTIONAL,
    OUT     PULONG          ResultantFormatLength
)
{
    PAGED_CODE();

    ASSERT(DataRange);
    ASSERT(MatchingDataRange);
    ASSERT(ResultantFormatLength);

    return 
        m_Miniport->DataRangeIntersection
        (   PinId,
            DataRange,
            MatchingDataRange,
            OutputBufferLength,
            ResultantFormat,
            ResultantFormatLength
        );
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortMidi::PowerChangeNotify()
 *****************************************************************************
 * Called by portcls to notify the port/miniport of a device power
 * state change.
 */
STDMETHODIMP_(void)
CPortMidi::
PowerChangeNotify
(   
    IN  POWER_STATE     PowerState
)
{
    PAGED_CODE();

    PPOWERNOTIFY pPowerNotify;

    if (m_Miniport)
    {
        // QI for the miniport notification interface
        NTSTATUS ntStatus = m_Miniport->QueryInterface( IID_IPowerNotify,
                                                        (PVOID *)&pPowerNotify );

        // check if we're powering up
        if (PowerState.DeviceState == PowerDeviceD0)
        {
            // notify the miniport
            if (NT_SUCCESS(ntStatus))
            {
                pPowerNotify->PowerChangeNotify( PowerState );
    
                pPowerNotify->Release();
            }
    
            // notify each port pin
            for (ULONG index=0; index < MAX_PINS; index++)
            {
                if (m_Pins[index])
                {
                    m_Pins[index]->PowerNotify( PowerState );
                }
            }
        } 
        else  // we're powering down
        {
            // notify each port pin
            for (ULONG index=0; index < MAX_PINS; index++)
            {
                if (m_Pins[index])
                {
                    m_Pins[index]->PowerNotify( PowerState );
                }
            }
            
            // notify the miniport
            if (NT_SUCCESS(ntStatus))
            {
                pPowerNotify->PowerChangeNotify( PowerState );
    
                pPowerNotify->Release();
            }
        }
    }
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortMidi::PinCount()
 *****************************************************************************
 * Called by portcls to give the port\miniport a chance 
 * to override the default pin counts for this pin ID.
 */
STDMETHODIMP_(void)
CPortMidi::PinCount
(
    IN      ULONG   PinId,
    IN  OUT PULONG  FilterNecessary,
    IN  OUT PULONG  FilterCurrent,
    IN  OUT PULONG  FilterPossible,
    IN  OUT PULONG  GlobalCurrent,
    IN  OUT PULONG  GlobalPossible
)
{
    PAGED_CODE();

    _DbgPrintF( DEBUGLVL_BLAB, 
                ("PinCount PID:0x%08x FN(0x%08x):%d FC(0x%08x):%d FP(0x%08x):%d GC(0x%08x):%d GP(0x%08x):%d",
                  PinId,                           FilterNecessary,*FilterNecessary,
                  FilterCurrent,  *FilterCurrent,  FilterPossible, *FilterPossible, 
                  GlobalCurrent,  *GlobalCurrent,  GlobalPossible, *GlobalPossible ) );

    if (m_MPPinCountI)
    {
        m_MPPinCountI->PinCount(PinId,FilterNecessary,FilterCurrent,FilterPossible,GlobalCurrent,GlobalPossible);

        _DbgPrintF( DEBUGLVL_BLAB, 
                    ("Post-PinCount PID:0x%08x FN(0x%08x):%d FC(0x%08x):%d FP(0x%08x):%d GC(0x%08x):%d GP(0x%08x):%d",
                      PinId,                           FilterNecessary,*FilterNecessary,
                      FilterCurrent,  *FilterCurrent,  FilterPossible, *FilterPossible, 
                      GlobalCurrent,  *GlobalCurrent,  GlobalPossible, *GlobalPossible ) );
    }
}

/*****************************************************************************
 * PinTypeName
 *****************************************************************************
 * The name of the pin object type.
 */
static const WCHAR PinTypeName[] = KSSTRING_Pin;

/*****************************************************************************
 * CreateTable
 *****************************************************************************
 * Create dispatch table.
 */
static KSOBJECT_CREATE_ITEM CreateTable[] =
{
    DEFINE_KSCREATE_ITEM(KsoDispatchCreateWithGenericFactory,PinTypeName,0)
};

#pragma code_seg("PAGE")
/*****************************************************************************
 * CPortMidi::NewIrpTarget()
 *****************************************************************************
 * Creates and initializes a filter object.
 */
STDMETHODIMP_(NTSTATUS)
CPortMidi::
NewIrpTarget
(
    OUT     PIRPTARGET *        IrpTarget,
    OUT     BOOLEAN *           ReferenceParent,
    IN      PUNKNOWN            OuterUnknown,
    IN      POOL_TYPE           PoolType,
    IN      PDEVICE_OBJECT      DeviceObject,
    IN      PIRP                Irp,
    OUT     PKSOBJECT_CREATE    ObjectCreate
)
{
    PAGED_CODE();

    ASSERT(IrpTarget);
    ASSERT(DeviceObject);
    ASSERT(Irp);
    ASSERT(ObjectCreate);

    _DbgPrintF( DEBUGLVL_BLAB, ("CPortMidi::NewIrpTarget"));

    ObjectCreate->CreateItemsCount  = SIZEOF_ARRAY(CreateTable);
    ObjectCreate->CreateItemsList   = CreateTable;

    PUNKNOWN filterUnknown;
    NTSTATUS ntStatus =
        CreatePortFilterMidi
        (
            &filterUnknown,
            GUID_NULL,
            OuterUnknown,
            PoolType
        );

    if (NT_SUCCESS(ntStatus))
    {
        PPORTFILTERMIDI filterMidi;

        ntStatus =
            filterUnknown->QueryInterface
            (
                IID_IIrpTarget,
                (PVOID *) &filterMidi
            );

        if (NT_SUCCESS(ntStatus))
        {
            // The QI for IIrpTarget actually gets IPortFilterMidi.
            ntStatus = filterMidi->Init(this);
            if (NT_SUCCESS(ntStatus))
            {
                *ReferenceParent = TRUE;
                *IrpTarget = filterMidi;
            }
            else
            {
                filterMidi->Release();
            }
        }

        filterUnknown->Release();
    }

    return ntStatus;
}

#pragma code_seg()

/*****************************************************************************
 * CPortMidi::AddEventToEventList()
 *****************************************************************************
 * Adds an event to the port's event list.
 */
STDMETHODIMP_(void)
CPortMidi::
AddEventToEventList
(
    IN  PKSEVENT_ENTRY  EventEntry
)
{
    ASSERT(EventEntry);

    _DbgPrintF(DEBUGLVL_VERBOSE,("CPortMidi::AddEventToEventList"));

    KIRQL   oldIrql;

    if (EventEntry)
    {
        // grab the event list spin lock
        KeAcquireSpinLock( &(m_EventList.ListLock), &oldIrql );

        // add the event to the list tail
        InsertTailList( &(m_EventList.List),
                        (PLIST_ENTRY)((PVOID)EventEntry) );

        // release the event list spin lock
        KeReleaseSpinLock( &(m_EventList.ListLock), oldIrql );
    }
}

/*****************************************************************************
 * CPortMidi::GenerateEventList()
 *****************************************************************************
 * Wraps KsGenerateEventList for miniports.
 */
STDMETHODIMP_(void)
CPortMidi::
GenerateEventList
(
    IN  GUID*   Set     OPTIONAL,
    IN  ULONG   EventId,
    IN  BOOL    PinEvent,
    IN  ULONG   PinId,
    IN  BOOL    NodeEvent,
    IN  ULONG   NodeId
)
{
    if (KeGetCurrentIrql() > DISPATCH_LEVEL)
    {
        if (!m_EventContext.ContextInUse)
        {
            m_EventContext.ContextInUse = TRUE;
            m_EventContext.Set = Set;
            m_EventContext.EventId = EventId;
            m_EventContext.PinEvent = PinEvent;
            m_EventContext.PinId = PinId;
            m_EventContext.NodeEvent = NodeEvent;
            m_EventContext.NodeId = NodeId;
    
            KeInsertQueueDpc( &m_EventDpc,
                              PVOID(&m_EventList),
                              NULL );
        }
    } 
    else
    {
        PcGenerateEventList( &m_EventList,
                             Set,
                             EventId,
                             PinEvent,
                             PinId,
                             NodeEvent,
                             NodeId );
    }
}

#ifdef DRM_PORTCLS

#pragma code_seg("PAGE")

STDMETHODIMP_(NTSTATUS)
CPortMidi::
AddContentHandlers(ULONG ContentId,PVOID * paHandlers,ULONG NumHandlers)
{
    PAGED_CODE();
    return DrmAddContentHandlers(ContentId,paHandlers,NumHandlers);
}

STDMETHODIMP_(NTSTATUS)
CPortMidi::
CreateContentMixed(PULONG paContentId,ULONG cContentId,PULONG pMixedContentId)
{
    PAGED_CODE();
    return DrmCreateContentMixed(paContentId,cContentId,pMixedContentId);
}

STDMETHODIMP_(NTSTATUS)
CPortMidi::
DestroyContent(ULONG ContentId)
{
    PAGED_CODE();
    return DrmDestroyContent(ContentId);
}

STDMETHODIMP_(NTSTATUS)
CPortMidi::
ForwardContentToDeviceObject(ULONG ContentId,PVOID Reserved,PCDRMFORWARD DrmForward)
{
    PAGED_CODE();
    return DrmForwardContentToDeviceObject(ContentId,Reserved,DrmForward);
}

STDMETHODIMP_(NTSTATUS)
CPortMidi::
ForwardContentToFileObject(ULONG ContentId,PFILE_OBJECT FileObject)
{
    PAGED_CODE();
    return DrmForwardContentToFileObject(ContentId,FileObject);
}

STDMETHODIMP_(NTSTATUS)
CPortMidi::
ForwardContentToInterface(ULONG ContentId,PUNKNOWN pUnknown,ULONG NumMethods)
{
    PAGED_CODE();
    return DrmForwardContentToInterface(ContentId,pUnknown,NumMethods);
}

STDMETHODIMP_(NTSTATUS)
CPortMidi::
GetContentRights(ULONG ContentId,PDRMRIGHTS DrmRights)
{
    PAGED_CODE();
    return DrmGetContentRights(ContentId,DrmRights);
}

#endif  // DRM_PORTCLS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\ports\wavecyc\drmhelp.c ===
#include "portclsp.h"

#ifdef DRM_PORTCLS

#include <drmk.h>

#pragma code_seg("PAGE")

NTSTATUS DrmForwardContentToStream(ULONG ContentId, PMINIPORTWAVECYCLICSTREAM pStream)
{
    PAGED_CODE();
    return DrmForwardContentToInterface(ContentId,
                                        (PUNKNOWN)pStream,
                                        sizeof(*pStream->lpVtbl)/sizeof(pStream->lpVtbl->QueryInterface));
}

#endif  // DRM_PORTCLS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\ports\topology\private.h ===
/*****************************************************************************
 * private.h - topology port private definitions
 *****************************************************************************
 * Copyright (c) 1997-2000 Microsoft Corporation.  All rights reserved.
 */

#ifndef _TOPOLOGY_PRIVATE_H_
#define _TOPOLOGY_PRIVATE_H_

#include "portclsp.h"
#include "stdunk.h"
#include "ksdebug.h"




#ifndef PC_KDEXT
#if (DBG)
#define STR_MODULENAME  "Topology: "
#endif
#endif // PC_KDEXT

#ifndef DEBUGLVL_LIFETIME
#define DEBUGLVL_LIFETIME DEBUGLVL_VERBOSE
#endif

//
// THE SIZE HERE MUST AGREE WITH THE DEFINITION IN FILTER.CPP.
//
extern KSPROPERTY_SET PropertyTable_FilterTopology[2];






/*****************************************************************************
 * Interfaces
 */

class CPortTopology;
class CPortFilterTopology;
class CPortPinTopology;

/*****************************************************************************
 * IPortFilterTopology
 *****************************************************************************
 * Interface for topology filters.
 */
DECLARE_INTERFACE_(IPortFilterTopology,IIrpTarget)
{
    DEFINE_ABSTRACT_UNKNOWN()           // For IUnknown

    DEFINE_ABSTRACT_IRPTARGETFACTORY()  // For IIrpTargetFactory

    DEFINE_ABSTRACT_IRPTARGET()         // For IIrpTarget

    STDMETHOD_(NTSTATUS,Init)
    (   THIS_
        IN      CPortTopology *Port
    )   PURE;
};

typedef IPortFilterTopology *PPORTFILTERTOPOLOGY;

/*****************************************************************************
 * IPortPinTopology
 *****************************************************************************
 * Interface for topology pins.
 */
DECLARE_INTERFACE_(IPortPinTopology,IIrpTarget)
{
    DEFINE_ABSTRACT_UNKNOWN()           // For IUnknown

    DEFINE_ABSTRACT_IRPTARGETFACTORY()  // For IIrpTargetFactory

    DEFINE_ABSTRACT_IRPTARGET()         // For IIrpTarget

    STDMETHOD_(NTSTATUS,Init)
    (   THIS_
        IN      CPortTopology *      Port,
        IN      CPortFilterTopology *Filter,
        IN      PKSPIN_CONNECT       PinConnect
    )   PURE;
};

typedef IPortPinTopology *PPORTPINTOPOLOGY;





/*****************************************************************************
 * Classes
 */

/*****************************************************************************
 * Connection
 *****************************************************************************
 * Private connection descriptor.
 */
struct Connection
{
    PCCONNECTION_DESCRIPTOR Miniport;   // As supplied by the miniport.
};

/*****************************************************************************
 * CPortTopology
 *****************************************************************************
 * Topology port driver.
 */
class CPortTopology
:   public IPortTopology,
    public IPortEvents,
    public ISubdevice,
#ifdef DRM_PORTCLS
    public IDrmPort2,
#endif  // DRM_PORTCLS
    public IPortClsVersion,
    public CUnknown
{
private:
    PDEVICE_OBJECT          DeviceObject;

    PMINIPORTTOPOLOGY       Miniport;
    PPINCOUNT               m_MPPinCountI;

    PSUBDEVICE_DESCRIPTOR   m_pSubdeviceDescriptor;
    PPCFILTER_DESCRIPTOR    m_pPcFilterDescriptor;
    INTERLOCKED_LIST        m_EventList;
    KDPC                    m_EventDpc;
    EVENT_DPC_CONTEXT       m_EventContext;

public:
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CPortTopology);
    ~CPortTopology();

    IMP_ISubdevice;
    IMP_IPort;
    IMP_IPortEvents;
#ifdef DRM_PORTCLS
    IMP_IDrmPort2;
#endif  // DRM_PORTCLS
    IMP_IPortClsVersion;

    /*************************************************************************
     * friends
     */
    friend class CPortFilterTopology;
    friend class CPortPinTopology;

    friend
    NTSTATUS
    PropertyHandler_Pin
    (
        IN      PIRP        Irp,
        IN      PKSP_PIN    Pin,
        IN OUT  PVOID       Data
    );
    friend
    NTSTATUS
    PropertyHandler_Topology
    (
        IN      PIRP        Irp,
        IN      PKSPROPERTY Property,
        IN OUT  PVOID       Data
    );
    friend
    void
    PcGenerateEventDeferredRoutine
    (
        IN PKDPC Dpc,
        IN PVOID DeferredContext,
        IN PVOID SystemArgument1,
        IN PVOID SystemArgument2        
    );
#ifdef PC_KDEXT
    //  Debugger extension routines
    friend
    VOID
    PCKD_AcquireDeviceData
    (
        PDEVICE_CONTEXT     DeviceContext,
        PLIST_ENTRY         SubdeviceList,
        ULONG               Flags
    );
    friend
    VOID
    PCKD_DisplayDeviceData
    (
        PDEVICE_CONTEXT     DeviceContext,
        PLIST_ENTRY         SubdeviceList,
        ULONG               Flags
    );
#endif
};

/*****************************************************************************
 * CPortFilterTopology
 *****************************************************************************
 * Filter implementation for topology port.
 */
class CPortFilterTopology
:   public IPortFilterTopology,
    public CUnknown
{
private:
    CPortTopology *     Port;
    PROPERTY_CONTEXT    m_propertyContext;

public:
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CPortFilterTopology);
    ~CPortFilterTopology();

    IMP_IIrpTarget;

    STDMETHODIMP_(NTSTATUS) Init
    (
        IN      CPortTopology *Port
    );

    /*************************************************************************
     * friends
     */
    friend class CPortPinTopology;

    friend
    NTSTATUS
    PropertyHandler_Pin
    (
        IN      PIRP        Irp,
        IN      PKSP_PIN    Pin,
        IN OUT  PVOID       Data
    );
    friend
    NTSTATUS
    PropertyHandler_Topology
    (
        IN      PIRP        Irp,
        IN      PKSPROPERTY Property,
        IN OUT  PVOID       Data
    );
};

/*****************************************************************************
 * CPortPinTopology
 *****************************************************************************
 * Pin implementation for topology port.
 */
class CPortPinTopology
:   public IPortPinTopology,
    public CUnknown
{
private:
    CPortTopology *             Port;
    CPortFilterTopology *       Filter;
	ULONG						Id;
    PROPERTY_CONTEXT            m_propertyContext;

public:
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CPortPinTopology);
    ~CPortPinTopology();

    IMP_IIrpTarget;

    STDMETHODIMP_(NTSTATUS) Init
    (
        IN      CPortTopology *         Port,
        IN      CPortFilterTopology *   Filter,
        IN      PKSPIN_CONNECT          PinConnect
    );
};





/*****************************************************************************
 * Functions.
 */

/*****************************************************************************
 * CreatePortFilterTopology()
 *****************************************************************************
 * Creates a topology port driver filter.
 */
NTSTATUS
CreatePortFilterTopology
(
    OUT     PUNKNOWN *  Unknown,
    IN      REFCLSID,
    IN      PUNKNOWN    UnknownOuter    OPTIONAL,
    IN      POOL_TYPE   PoolType
);

/*****************************************************************************
 * CreatePortPinTopology()
 *****************************************************************************
 * Creates a topology port driver pin.
 */
NTSTATUS
CreatePortPinTopology
(
    OUT     PUNKNOWN *  Unknown,
    IN      REFCLSID,
    IN      PUNKNOWN    UnknownOuter    OPTIONAL,
    IN      POOL_TYPE   PoolType
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\ports\wavecyc\clock.cpp ===
/*++

    Copyright (c) 1997-2000 Microsoft Corporation.  All rights reserved.

Module Name:

    Clock.cpp

Abstract:
    
    This module implements the clock handler

Author:

    bryanw 07-Oct-1997

--*/

#include "private.h"

DEFINE_KSPROPERTY_CLOCKSET( 
    ClockPropertyHandlers,
    CPortClockWaveCyclic::GetTime,
    CPortClockWaveCyclic::GetPhysicalTime,
    CPortClockWaveCyclic::GetCorrelatedTime,
    CPortClockWaveCyclic::GetCorrelatedPhysicalTime,
    CPortClockWaveCyclic::GetResolution,
    CPortClockWaveCyclic::GetState,
    CPortClockWaveCyclic::GetFunctionTable );

DEFINE_KSPROPERTY_SET_TABLE( ClockPropertyTable )
{
    DEFINE_KSPROPERTY_SET( 
        &KSPROPSETID_Clock,
        SIZEOF_ARRAY( ClockPropertyHandlers ),
        ClockPropertyHandlers,
        0, 
        NULL)
};

DEFINE_KSEVENT_TABLE( ClockEventHandlers ) {
    DEFINE_KSEVENT_ITEM(
        KSEVENT_CLOCK_INTERVAL_MARK,
        sizeof( KSEVENT_TIME_INTERVAL ),
        sizeof( ULONGLONG ) + sizeof( ULONGLONG ),
        (PFNKSADDEVENT) CPortClockWaveCyclic::AddEvent,
        NULL,
        NULL),
    DEFINE_KSEVENT_ITEM(
        KSEVENT_CLOCK_POSITION_MARK,
        sizeof( KSEVENT_TIME_MARK ),
        sizeof( ULONGLONG ),
        (PFNKSADDEVENT) CPortClockWaveCyclic::AddEvent,
        NULL,
        NULL)
};

DEFINE_KSEVENT_SET_TABLE( ClockEventTable )
{
    DEFINE_KSEVENT_SET( 
        &KSEVENTSETID_Clock, 
        SIZEOF_ARRAY( ClockEventHandlers ),
        ClockEventHandlers)
};

//
//
//

#pragma code_seg("PAGE")

NTSTATUS
CreatePortClockWaveCyclic(
    OUT PUNKNOWN *Unknown,
    IN PPORTPINWAVECYCLIC IPortPin,
    IN REFCLSID Interface,
    IN PUNKNOWN UnknownOuter OPTIONAL,
    IN POOL_TYPE PoolType
    )

/*++

Routine Description:
    Creates a cyclic-wave clock object for the port.

Arguments:
    IN PFILE_OBJECT FileObject -
        associated file object
        
    OUT PUNKNOWN *Unknown -
        resultant pointer to our unknown
        
    IN PPORTPINWAVECYCLIC - 
        wave cyclic pin interface

    IN REFCLSID Interface -
        interface requested

    IN PUNKNOWN UnknownOuter OPTIONAL -
        pointer to the controlling unknown

    IN POOL_TYPE PoolType -
        pool type for allocation

Return:

--*/

{
    CPortClockWaveCyclic    *WaveCyclicClock;
    NTSTATUS                Status;
    
    PAGED_CODE();

    ASSERT(Unknown);
    
    _DbgPrintF(DEBUGLVL_LIFETIME,("Creating WAVECYCLIC Clock"));
    
    //
    // Create the object
    //    
    WaveCyclicClock =
        new(PoolType) 
            CPortClockWaveCyclic( UnknownOuter, IPortPin, &Status );
    if (NULL == WaveCyclicClock) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    
    if (NT_SUCCESS( Status )) {
        WaveCyclicClock->AddRef();
        *Unknown = WaveCyclicClock;
    } else {
        delete WaveCyclicClock;
        *Unknown = NULL;
    }

    return Status;
}

CPortClockWaveCyclic::CPortClockWaveCyclic(
    IN PUNKNOWN UnkOuter,
    IN PPORTPINWAVECYCLIC IPortPin,    
    OUT NTSTATUS *Status
    ) :
    CUnknown( UnkOuter )

/*++

Routine Description:
    CPortClockWaveCyclic constructor.
    
    Initializes the object.
    
Arguments:
    IN PUNKNOWN UnkOuter -
        controlling unknown

    OUT NTSTATUS *Status -
        return status

Return:
    Nothing

--*/

{
    _DbgPrintF(
        DEBUGLVL_VERBOSE,
        ("CPortClockWaveCyclic::CPortClockWaveCyclic") );
        
    ASSERT( IPortPin );
    
    KeInitializeMutex( &m_StateMutex, 0 );
    KeInitializeSpinLock( &m_EventLock );
    KeInitializeSpinLock( &m_ClockLock );
    InitializeListHead( &m_EventList );
    
    RtlZeroMemory( &m_ClockNode, sizeof( m_ClockNode ) );
    m_ClockNode.IWaveCyclicClock = this;
    
    m_IPortPin = IPortPin;
    m_IPortPin->AddRef();

    *Status = STATUS_SUCCESS;       
}

#pragma code_seg()

CPortClockWaveCyclic::~CPortClockWaveCyclic()
{
    _DbgPrintF(DEBUGLVL_LIFETIME,("Destroying WAVECYCLIC Clock (0x%08x)",this));

    if (m_ClockNode.ListEntry.Flink) {
        KIRQL irqlOld;
        
        //
        // If the parent object linked us in, unlink from the list
        // using the provided spinlock.
        //
        
        KeAcquireSpinLock( m_ClockNode.ListLock, &irqlOld );
        RemoveEntryList( &m_ClockNode.ListEntry );
        KeReleaseSpinLock( m_ClockNode.ListLock, irqlOld );
    }        
    m_IPortPin->Release();
}

#pragma code_seg("PAGE")

STDMETHODIMP_(NTSTATUS)
CPortClockWaveCyclic::NonDelegatingQueryInterface(
    REFIID Interface,
    PVOID * Object
    )
{
    PAGED_CODE();

    ASSERT(Object);

    _DbgPrintF( 
        DEBUGLVL_VERBOSE,
        ("CPortClockWaveCyclic::NonDelegatingQueryInterface") );
    if (IsEqualGUIDAligned( Interface, IID_IUnknown )) {
        *Object = PVOID(PIRPTARGET( this ));
    } else if (IsEqualGUIDAligned( Interface, IID_IIrpTarget )) {
        *Object = PVOID(PIRPTARGET( this ));
    } else if (IsEqualGUIDAligned( Interface, IID_IWaveCyclicClock )) {
        *Object = PVOID(PWAVECYCLICCLOCK( this ));
    } else {
        *Object = NULL;
    }

    if (*Object) {
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

STDMETHODIMP_(NTSTATUS)
CPortClockWaveCyclic::DeviceIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:
    Processes device I/O control for this file object on this device object
    
Arguments:
    IN PDEVICE_OBJECT DeviceObject -
        pointer to the device object

    IN PIRP Irp -
        pointer to I/O request packet

Return:
    STATUS_SUCCESS or an appropriate error code

--*/

{
    NTSTATUS            Status;
    PIO_STACK_LOCATION  irpSp;
    
    PAGED_CODE();

    ASSERT( DeviceObject );
    ASSERT( Irp );

    _DbgPrintF( DEBUGLVL_BLAB, ("CPortClockWaveCyclic::DeviceIoControl"));

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {

    case IOCTL_KS_PROPERTY:
        Status = 
            KsPropertyHandler( 
                Irp, 
                SIZEOF_ARRAY( ClockPropertyTable ),
                (PKSPROPERTY_SET) ClockPropertyTable );
        break;

    case IOCTL_KS_ENABLE_EVENT:
        _DbgPrintF( DEBUGLVL_VERBOSE, ("CPortClockWaveCyclic::EnableEvent"));

        Status = 
            KsEnableEvent( 
                Irp, 
                SIZEOF_ARRAY( ClockEventTable ), 
                (PKSEVENT_SET) ClockEventTable, 
                NULL, 
                KSEVENTS_NONE,
                NULL);
        break;

    case IOCTL_KS_DISABLE_EVENT:
        _DbgPrintF( DEBUGLVL_VERBOSE, ("CPortClockWaveCyclic::DisableEvent"));
    
        Status = 
            KsDisableEvent( 
                Irp, 
                &m_EventList,
                KSEVENTS_SPINLOCK,
                &m_EventLock );
        break;

    default:
    
        return KsDefaultDeviceIoCompletion( DeviceObject, Irp );

    }

    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;
}

STDMETHODIMP_(NTSTATUS)
CPortClockWaveCyclic::Close(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:
    Close handler for the clock file object

Arguments:
    IN PDEVICE_OBJECT DeviceObject -
        pointer to the device object

    IN PIRP Irp -
        pointer to the I/O request packet

Return:
    STATUS success or an appropriate error code

--*/

{
    PIO_STACK_LOCATION irpSp;
    
    PAGED_CODE();

    ASSERT(DeviceObject);
    ASSERT(Irp);

    _DbgPrintF( DEBUGLVL_VERBOSE, ("CPortClockWaveCyclic::Close"));
    
    irpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Free events associated with this pin.
    //
    
    KsFreeEventList(
        irpSp->FileObject,
        &m_EventList,
        KSEVENTS_SPINLOCK,
        &m_EventLock );

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp,IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}

DEFINE_INVALID_CREATE(CPortClockWaveCyclic);
DEFINE_INVALID_READ(CPortClockWaveCyclic);
DEFINE_INVALID_WRITE(CPortClockWaveCyclic);
DEFINE_INVALID_FLUSH(CPortClockWaveCyclic);
DEFINE_INVALID_QUERYSECURITY(CPortClockWaveCyclic);
DEFINE_INVALID_SETSECURITY(CPortClockWaveCyclic);
DEFINE_INVALID_FASTDEVICEIOCONTROL(CPortClockWaveCyclic);
DEFINE_INVALID_FASTREAD(CPortClockWaveCyclic);
DEFINE_INVALID_FASTWRITE(CPortClockWaveCyclic);

#pragma code_seg()

STDMETHODIMP_(NTSTATUS)
CPortClockWaveCyclic::GenerateEvents(
    PFILE_OBJECT FileObject
    )
{
    LONGLONG                Time;
    PLIST_ENTRY             ListEntry;
    
    if (m_DeviceState == KSSTATE_RUN) {
    
        Time = GetCurrentTime( FileObject );

        ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );
        
        KeAcquireSpinLockAtDpcLevel( &m_EventLock );

        for(ListEntry = m_EventList.Flink; 
            ListEntry != &m_EventList;) {
            
            PKSEVENT_ENTRY  EventEntry;
            PKSINTERVAL     Interval;

            EventEntry = 
                (PKSEVENT_ENTRY)
                    CONTAINING_RECORD( ListEntry, KSEVENT_ENTRY, ListEntry );
                
            //
            // Pre-inc, KsGenerateEvent() can remove this item from the list.
            //    
            ListEntry = ListEntry->Flink;
            //
            // The event-specific data was added onto the end of the entry.
            //
            Interval = (PKSINTERVAL)(EventEntry + 1);
            //
            // Time for this event to go off.
            //
            if (Interval->TimeBase <= Time) {
                _DbgPrintF(
                    DEBUGLVL_VERBOSE, ("Generating event for time: %ld at time: %ld",
                    Interval->TimeBase, Time) );
            
                if (EventEntry->EventItem->EventId != 
                        KSEVENT_CLOCK_INTERVAL_MARK) {
                    //
                    // A single-shot should only go off once, so make
                    // it a value which will never be reached again.
                    //
                    Interval->TimeBase = 0x7fffffffffffffff;
                
                } else {
                    LONGLONG    Intervals;
                    //
                    // An interval timer should only go off once per time,
                    // so update it to the next timeout.
                    //
                    Intervals = 
                        (Time - Interval->TimeBase + Interval->Interval - 1) / Interval->Interval;
                    Interval->TimeBase += Intervals * Interval->Interval;
                } 
                        
                KsGenerateEvent( EventEntry );
            }
        }
        
        KeReleaseSpinLockFromDpcLevel( &m_EventLock );
    }
    
    return STATUS_SUCCESS;
}

STDMETHODIMP_(NTSTATUS)
CPortClockWaveCyclic::SetState(
    KSSTATE State
    )

/*++

Routine Description:
    This method is called by the port to notify of a state change.

Arguments:
    KSSTATE State -
        New state

Return:
    STATUS_SUCCESS

--*/

{
    //
    // Synchronize with GetState,
    //
    KeWaitForMutexObject(
        &m_StateMutex,
        Executive,
        KernelMode,
        FALSE,
        NULL );

    //
    // set the new state,
    //        
    m_DeviceState = State;
    switch (State) {
    
    case KSSTATE_STOP:
        m_LastTime = m_LastPhysicalTime = m_LastPhysicalPosition = 0;
        break;
        
    case KSSTATE_RUN:
        m_DeviceBufferSize = m_IPortPin->GetDeviceBufferSize();
        break;
    }
    
    //
    // and then release the mutex.
    //
    KeReleaseMutex( &m_StateMutex, FALSE );
    
    return STATUS_SUCCESS;
}    

NTSTATUS
CPortClockWaveCyclic::AddEvent(
    IN PIRP                     Irp,
    IN PKSEVENT_TIME_INTERVAL   EventTime,
    IN PKSEVENT_ENTRY           EventEntry
    )

/*++

Routine Description:

    This is the AddEvent() handler for the clock events.

    NOTE: This routine acquires a spinlock, must be in non-paged code.
    
Arguments:

    IN PIRP Irp - 
        pointer to the I/O request packet    

    IN PKSEVENT_TIME_INTERVAL EventTime -
        specified time interval or one shot

    IN PKSEVENT_ENTRY EventEntry -
        pointer to event entry structure

Return Value:
    STATUS_SUCCESS

--*/

{
    KIRQL                   irqlOld;
    PKSINTERVAL             Interval;
    CPortClockWaveCyclic    *WaveCyclicClock;
    
    WaveCyclicClock =
        (CPortClockWaveCyclic *) KsoGetIrpTargetFromIrp(Irp);
        
    ASSERT( WaveCyclicClock );
    
    _DbgPrintF( DEBUGLVL_VERBOSE, ("CPortClockWaveCyclic::AddEvent"));
            
    //
    // Space for the interval is located at the end of the basic 
    // event structure.
    //
    Interval = (PKSINTERVAL)(EventEntry + 1);
    //
    // Either just an event time was passed, or a time base plus an 
    // interval. In both cases the first LONGLONG is present and saved.
    //
    Interval->TimeBase = EventTime->TimeBase;
    if (EventEntry->EventItem->EventId == KSEVENT_CLOCK_INTERVAL_MARK) {
        Interval->Interval = EventTime->Interval;
    }

    KeAcquireSpinLock( &WaveCyclicClock->m_EventLock, &irqlOld );
    InsertHeadList( &WaveCyclicClock->m_EventList, &EventEntry->ListEntry );
    KeReleaseSpinLock( &WaveCyclicClock->m_EventLock, irqlOld );
    //
    // If this event is passed, signal immediately.
    // Note, KS_CLOCK_POSITION_MARK is a one-shot event.
    //
    WaveCyclicClock->GenerateEvents(IoGetCurrentIrpStackLocation( Irp )->FileObject);
    
    return STATUS_SUCCESS;
}

LONGLONG
FASTCALL
CPortClockWaveCyclic::GetCurrentTime(
    PFILE_OBJECT FileObject
    )

/*++

Routine Description:
    Computes the current presentation time.
    
    NOTE: This routine acquires a spinlock, must be in non-paged code.

Arguments:
    PFILE_OBJECT FileObject -
        this clock's file object 
        
Return:
    resultant presentation time normalized to 100ns units.

--*/

{
    KIRQL                   irqlOld;
    LONGLONG                StreamTime;
    NTSTATUS                Status;
    PIRPSTREAM              IrpStream;
    CPortClockWaveCyclic    *WaveCyclicClock;
    PMINIPORTWAVECYCLICSTREAM Miniport;
    
    WaveCyclicClock =
        (CPortClockWaveCyclic *) KsoGetIrpTargetFromFileObject(FileObject);
        
    StreamTime = 0;

    //
    // Query the position from the IRP stream.
    //
    IrpStream = WaveCyclicClock->m_IPortPin->GetIrpStream();
    Miniport = WaveCyclicClock->m_IPortPin->GetMiniport();

    if( !IrpStream || !Miniport )
    {
        Status = STATUS_UNSUCCESSFUL;
    } else
    {
        IRPSTREAM_POSITION irpStreamPosition;
        Status = IrpStream->GetPosition(&irpStreamPosition);
        if (NT_SUCCESS(Status))
        {
            //
            // Never exceed current stream extent.
            //
            if 
            (   irpStreamPosition.ullStreamPosition
            >   irpStreamPosition.ullCurrentExtent
            )
            {
                StreamTime = 
                    irpStreamPosition.ullCurrentExtent;
            }
            else
            {
                StreamTime = 
                    irpStreamPosition.ullStreamPosition;
            }

            Status = Miniport->NormalizePhysicalPosition( &StreamTime );

        }
        Miniport->Release();
        IrpStream->Release();
    }

    KeAcquireSpinLock( &WaveCyclicClock->m_ClockLock, &irqlOld );

    if (NT_SUCCESS( Status )) {
        if (StreamTime < WaveCyclicClock->m_LastTime) {
            _DbgPrintF( 
                DEBUGLVL_VERBOSE, 
                ("new time is less than last reported time! (%I64d, %I64d)",
                StreamTime, WaveCyclicClock->m_LastTime) );
            StreamTime = WaveCyclicClock->m_LastTime;
        } else {
            WaveCyclicClock->m_LastTime = StreamTime;
        }
    } else {
        StreamTime = WaveCyclicClock->m_LastTime;
    }
    
    KeReleaseSpinLock( &WaveCyclicClock->m_ClockLock, irqlOld );
    
    return StreamTime;
}

LONGLONG
FASTCALL
CPortClockWaveCyclic::GetCurrentCorrelatedTime(
    PFILE_OBJECT FileObject,
    PLONGLONG SystemTime
    )

/*++

Routine Description:


Arguments:
    PFILE_OBJECT FileObject -

    PLONGLONG SystemTime -
        pointer 

Return:
    current presentation time in 100ns

--*/

{
    LARGE_INTEGER Time, Frequency;
    
    Time = KeQueryPerformanceCounter( &Frequency );
    
    //
    //  Convert ticks to 100ns units.
    //
    *SystemTime = KSCONVERT_PERFORMANCE_TIME(Frequency.QuadPart,Time);
    return GetCurrentTime( FileObject );
}    

LONGLONG
FASTCALL
CPortClockWaveCyclic::GetCurrentPhysicalTime(
    PFILE_OBJECT FileObject
    )

/*++

Routine Description:
    Computes the current physical time.

    NOTE: This routine acquires a spinlock, must be in non-paged code.
    
Arguments:
    PFILE_OBJECT FileObject -
        this clock's file object 

Return:
    current physical time in 100ns

--*/

{
    KIRQL                       irqlOld;
    LONGLONG                    PhysicalTime;
    NTSTATUS                    Status;
    CPortClockWaveCyclic        *WaveCyclicClock;
    PIRPSTREAM                  IrpStream;
    PMINIPORTWAVECYCLICSTREAM   Miniport;
    
    WaveCyclicClock =
        (CPortClockWaveCyclic *) KsoGetIrpTargetFromFileObject(FileObject);

    PhysicalTime = 0;
    
    //
    // Query the position from the IRP stream.
    //
    IrpStream = WaveCyclicClock->m_IPortPin->GetIrpStream();
    Miniport = WaveCyclicClock->m_IPortPin->GetMiniport();

    if( !IrpStream || !Miniport )
    {
        Status = STATUS_UNSUCCESSFUL;
    } else
    {
        IRPSTREAM_POSITION irpStreamPosition;
        Status = IrpStream->GetPosition(&irpStreamPosition);
        if (NT_SUCCESS(Status))
        {
            PhysicalTime = 
                (   irpStreamPosition.ullStreamPosition 
                +   irpStreamPosition.ullPhysicalOffset
                );

            Status = 
                Miniport->NormalizePhysicalPosition( &PhysicalTime );

        }

        Miniport->Release();
        IrpStream->Release();
    }
	
    KeAcquireSpinLock( &WaveCyclicClock->m_ClockLock, &irqlOld );

    if (NT_SUCCESS( Status ))
    {
        //
        // Verify that this new physical time is >= to the last
        // reported physical time.  If not, set the time to the 
        // last reported time.  Flag this as an error in debug.
        //
        if (PhysicalTime < WaveCyclicClock->m_LastPhysicalTime) {
            _DbgPrintF( 
                DEBUGLVL_VERBOSE, 
                ("new physical time is less than last reported physical time! (%I64d, %I64d)",
                PhysicalTime, WaveCyclicClock->m_LastPhysicalTime) );
            PhysicalTime = WaveCyclicClock->m_LastPhysicalTime;
        } else {
            //
            // Set m_LastPhysicalTime to the updated time.
            //
            WaveCyclicClock->m_LastPhysicalTime = PhysicalTime;
        }
    } else
    {
        PhysicalTime = WaveCyclicClock->m_LastPhysicalTime;
    }
    
    KeReleaseSpinLock( &WaveCyclicClock->m_ClockLock, irqlOld );
    
    return PhysicalTime;
}

LONGLONG
FASTCALL
CPortClockWaveCyclic::GetCurrentCorrelatedPhysicalTime(
    PFILE_OBJECT FileObject,
    PLONGLONG SystemTime
    )

/*++

Routine Description:
    Retrieves the current physical time correlated with the system time.

Arguments:
    PFILE_OBJECT FileObject -
        this clock's file object

    PLONGLONG SystemTime -
        pointer to the resultant system time

Return:
    current physical time in 100ns

--*/

{

    LARGE_INTEGER Time, Frequency;
    
    Time = KeQueryPerformanceCounter( &Frequency );
    
    //
    // Convert ticks to 100ns units.
    //
    *SystemTime = KSCONVERT_PERFORMANCE_TIME( Frequency.QuadPart, Time );
    
    return GetCurrentTime( FileObject );
}    



#pragma code_seg("PAGE")

NTSTATUS
CPortClockWaveCyclic::GetFunctionTable(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PKSCLOCK_FUNCTIONTABLE FunctionTable
    )

/*++

Routine Description:
    Retrieves the DPC interface function table for this clock.

Arguments:
    IN PIRP Irp -
        pointer to the I/O request packet

    IN PKSPROPERTY Property -
        pointer to the property structure

    OUT PKSCLOCK_FUNCTIONTABLE FunctionTable -
        pointer to the resultant function table

Return:

--*/

{
    PAGED_CODE();
    FunctionTable->GetTime = GetCurrentTime;
    FunctionTable->GetPhysicalTime = GetCurrentPhysicalTime;
    FunctionTable->GetCorrelatedTime = GetCurrentCorrelatedTime;
    FunctionTable->GetCorrelatedPhysicalTime = GetCurrentCorrelatedPhysicalTime;
    Irp->IoStatus.Information = sizeof(*FunctionTable);
    return STATUS_SUCCESS;
}

NTSTATUS
CPortClockWaveCyclic::GetCorrelatedTime(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PKSCORRELATED_TIME CorrelatedTime
    )

/*++

Routine Description:
    Retrieves the current presentation time correlated with the system time.

Arguments:
    IN PIRP Irp -
        pointer to the I/O request packet

    IN PKSPROPERTY Property -
        pointer to the property structure

    OUT PKSCORRELATED_TIME CorrelatedTime -
        resultant correlated presentation time

Return:
    STATUS_SUCCESS else an appropriate error code

--*/

{
    CPortClockWaveCyclic    *WaveCyclicClock;
    
    PAGED_CODE();
    
    WaveCyclicClock =
        (CPortClockWaveCyclic *) KsoGetIrpTargetFromIrp(Irp);

    CorrelatedTime->Time = 
        WaveCyclicClock->GetCurrentCorrelatedTime( 
            IoGetCurrentIrpStackLocation( Irp )->FileObject, 
            &CorrelatedTime->SystemTime );
    Irp->IoStatus.Information = sizeof( KSCORRELATED_TIME );
    return STATUS_SUCCESS;
}    

NTSTATUS
CPortClockWaveCyclic::GetTime(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PLONGLONG Time
    )

/*++

Routine Description:
    Retrieves the current presentation time.

Arguments:
    IN PIRP Irp -
        pointer to the I/O request packet

    IN PKSPROPERTY Property -
        pointer to the property structure

    OUT PLONGLONG Time -
        resultant presentation time

Return:
    STATUS_SUCCESS else an appropriate error code

--*/

{
    CPortClockWaveCyclic    *WaveCyclicClock;
    
    PAGED_CODE();
    
    WaveCyclicClock =
        (CPortClockWaveCyclic *) KsoGetIrpTargetFromIrp(Irp);

    *Time = WaveCyclicClock->GetCurrentTime( 
        IoGetCurrentIrpStackLocation( Irp )->FileObject );
    Irp->IoStatus.Information = sizeof( LONGLONG );
     
    return STATUS_SUCCESS;
}

NTSTATUS
CPortClockWaveCyclic::GetCorrelatedPhysicalTime(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PKSCORRELATED_TIME CorrelatedTime
    )

/*++

Routine Description:
    Retrieves the current physical time correlated with the system time.

Arguments:
    IN PIRP Irp -
        pointer to the I/O request packet

    IN PKSPROPERTY Property -
        pointer to the property structure

    OUT PKSCORRELATED_TIME CorrelatedTime -
        resultant correlated physical time

Return:
    STATUS_SUCCESS else an appropriate error code

--*/

{
    CPortClockWaveCyclic    *WaveCyclicClock;
    
    PAGED_CODE();
    
    WaveCyclicClock =
        (CPortClockWaveCyclic *) KsoGetIrpTargetFromIrp(Irp);
    
    CorrelatedTime->Time =
        WaveCyclicClock->GetCurrentCorrelatedPhysicalTime( 
            IoGetCurrentIrpStackLocation( Irp )->FileObject,
            &CorrelatedTime->SystemTime );
    
    Irp->IoStatus.Information = sizeof( KSCORRELATED_TIME );
    return STATUS_SUCCESS;
}

NTSTATUS
CPortClockWaveCyclic::GetPhysicalTime(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PLONGLONG Time
    )

/*++

Routine Description:
    Returns the clock's physical time.  This is the actual clock physical time 
    which is not halted for starvation, etc.

Arguments:
    IN PIRP Irp -
        pointer to the I/O request packet

    IN PKSPROPERTY Property -
        pointer to the property structure

    OUT PLONGLONG Time -
        resultant time in 100 ns units

Return:
    STATUS_SUCCESS or an appropriate error code

--*/

{
    CPortClockWaveCyclic    *WaveCyclicClock;
    
    PAGED_CODE();
    
    WaveCyclicClock =
        (CPortClockWaveCyclic *) KsoGetIrpTargetFromIrp(Irp);

    *Time = 
        WaveCyclicClock->GetCurrentPhysicalTime( 
            IoGetCurrentIrpStackLocation( Irp )->FileObject );
    Irp->IoStatus.Information = sizeof( LONGLONG );
    return STATUS_SUCCESS;
}

NTSTATUS
CPortClockWaveCyclic::GetResolution(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PKSRESOLUTION Resolution
    )
/*++

Routine Description:
    Retrieves the resolution of this clock.

Arguments:
    IN PIRP Irp -
        pointer to the I/O request packet

    IN PKSPROPERTY Property -
        pointer to the property structure
        
    OUT PKSRESOLUTIONM Resolution -
        pointer to the resultant resolution structure which stores the
        granularity and error in 100ns units.
        
Return Value:
    STATUS_SUCCESS

--*/
{
    LONGLONG                    OneByte = 1;
    PMINIPORTWAVECYCLICSTREAM   Miniport;
    CPortClockWaveCyclic        *WaveCyclicClock;
    
    PAGED_CODE();
    
    WaveCyclicClock =
        (CPortClockWaveCyclic *) KsoGetIrpTargetFromIrp(Irp);
    
    Miniport = WaveCyclicClock->m_IPortPin->GetMiniport();
    ASSERT( Miniport );
        
    //
    // This clock has a resolution dependant on the data format.  Assume
    // that for cyclic devices, a byte position is computed for the DMA
    // controller and convert this to 100ns units.  The error (event 
    // notification error) is +/- NotificationFrequency/2
    //
    // NTRAID#Windows Bugs-65581-2001/01/02-fberreth Clock granularity/error misreport.
    // portcls cannot know what the error reported by GetPosition is for the miniport.
    //
      
    Resolution->Granularity = 
        Miniport->NormalizePhysicalPosition( &OneByte );
    Miniport->Release();
    
    Resolution->Error = 
        (_100NS_UNITS_PER_SECOND / 1000 * WAVECYC_NOTIFICATION_FREQUENCY) / 2;
        
    Irp->IoStatus.Information = sizeof(*Resolution);
    return STATUS_SUCCESS;
}

NTSTATUS
CPortClockWaveCyclic::GetState(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PKSSTATE State
    )

/*++

Routine Description:
    Returns the underlying pin's state.

Arguments:
    IN PIRP Irp -
        pointer to the I/O request packet

    IN PKSPROPERTY Property -
        pointer to the property structure

    OUT PKSSTATE State -
        pointer to resultant KSSTATE

Return:
    STATUS_SUCCESS

--*/

{
    CPortClockWaveCyclic    *WaveCyclicClock;
    
    PAGED_CODE();
    
    WaveCyclicClock =
        (CPortClockWaveCyclic *) KsoGetIrpTargetFromIrp(Irp);

    //
    // Synchronize with SetState,
    //        
    KeWaitForMutexObject(
        &WaveCyclicClock->m_StateMutex,
        Executive,
        KernelMode,
        FALSE,
        NULL );
    //
    // retrieve the state
    //        
    *State = WaveCyclicClock->m_DeviceState;
    //
    // and then release the mutex
    //
    KeReleaseMutex( &WaveCyclicClock->m_StateMutex, FALSE );
    
    Irp->IoStatus.Information = sizeof(*State);
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\backpln\portcls\ports\wavecyc\pin.cpp ===
/*****************************************************************************
 * pin.cpp - cyclic wave port pin implementation
 *****************************************************************************
 * Copyright (c) 1996-2000 Microsoft Corporation.  All rights reserved.
 */

#include "private.h"
#include "perf.h"

// Turn this off in order to enable glitch-detection
#define WRITE_SILENCE           1


#define HACK_FRAME_COUNT        3
#define HACK_SAMPLE_RATE        44100
#define HACK_BYTES_PER_SAMPLE   2
#define HACK_CHANNELS           2
#define HACK_MS_PER_FRAME       10
#define HACK_FRAME_SIZE         (   (   HACK_SAMPLE_RATE\
                                    *   HACK_BYTES_PER_SAMPLE\
                                    *   HACK_CHANNELS\
                                    *   HACK_MS_PER_FRAME\
                                    )\
                                /   1000\
                                )

//
// IRPLIST_ENTRY is used for the list of outstanding IRPs.  This structure is
// overlayed on the Parameters section of the current IRP stack location.  The
// reserved PVOID at the top preserves the OutputBufferLength, which is the
// only parameter that needs to be preserved.
//
typedef struct IRPLIST_ENTRY_
{
    PVOID       Reserved;
    PIRP        Irp;
    LIST_ENTRY  ListEntry;
} IRPLIST_ENTRY, *PIRPLIST_ENTRY;

#define IRPLIST_ENTRY_IRP_STORAGE(Irp) \
    PIRPLIST_ENTRY(&IoGetCurrentIrpStackLocation(Irp)->Parameters)

/*****************************************************************************
 * Constants.
 */

DEFINE_KSPROPERTY_TABLE(PinPropertyTableConnection)
{
    DEFINE_KSPROPERTY_ITEM_CONNECTION_STATE(
        PinPropertyDeviceState,
        PinPropertyDeviceState ),

    DEFINE_KSPROPERTY_ITEM_CONNECTION_DATAFORMAT(
        PinPropertyDataFormat,
        PinPropertyDataFormat ),

    DEFINE_KSPROPERTY_ITEM_CONNECTION_ALLOCATORFRAMING(
        CPortPinWaveCyclic::PinPropertyAllocatorFraming )
};

DEFINE_KSPROPERTY_TABLE(PinPropertyTableStream)
{
    DEFINE_KSPROPERTY_ITEM_STREAM_ALLOCATOR(
        CPortPinWaveCyclic::PinPropertyStreamAllocator,
        CPortPinWaveCyclic::PinPropertyStreamAllocator ),

    DEFINE_KSPROPERTY_ITEM_STREAM_MASTERCLOCK(
        CPortPinWaveCyclic::PinPropertyStreamMasterClock,
        CPortPinWaveCyclic::PinPropertyStreamMasterClock )
};


DEFINE_KSPROPERTY_TABLE(PinPropertyTableAudio)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_AUDIO_POSITION,
        PinPropertyPosition,
        sizeof(KSPROPERTY),
        sizeof(KSAUDIO_POSITION),
        PinPropertyPosition,
        NULL,0,NULL,NULL,0
    )
};

DEFINE_KSPROPERTY_TABLE(PinPropertyTableDrmAudioStream)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_DRMAUDIOSTREAM_CONTENTID,            // idProperty
        NULL,                                           // pfnGetHandler
        sizeof(KSPROPERTY),                             // cbMinGetPropertyInput
        sizeof(ULONG),                                  // cbMinGetDataInput
        PinPropertySetContentId,                        // pfnSetHandler
        0,                                              // Values
        0,                                              // RelationsCount
        NULL,                                           // Relations
        NULL,                                           // SupportHandler
        0                                               // SerializedSize
    )
};

KSPROPERTY_SET PropertyTable_PinWaveCyclic[] =
{
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_Stream,
        SIZEOF_ARRAY(PinPropertyTableStream),
        PinPropertyTableStream,
        0,NULL
    ),
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_Connection,
        SIZEOF_ARRAY(PinPropertyTableConnection),
        PinPropertyTableConnection,
        0,NULL
    ),
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_Audio,
        SIZEOF_ARRAY(PinPropertyTableAudio),
        PinPropertyTableAudio,
        0,NULL
    ),
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_DrmAudioStream,
        SIZEOF_ARRAY(PinPropertyTableDrmAudioStream),
        PinPropertyTableDrmAudioStream,
        0,NULL
    )
};

DEFINE_KSEVENT_TABLE(PinEventTable)
{
    DEFINE_KSEVENT_ITEM(
        KSEVENT_LOOPEDSTREAMING_POSITION,
        sizeof(LOOPEDSTREAMING_POSITION_EVENT_DATA),
        sizeof(POSITION_EVENT_ENTRY) - sizeof(KSEVENT_ENTRY),
        PFNKSADDEVENT(PinAddEvent_Position),
        NULL,
        NULL
        )
};

DEFINE_KSEVENT_TABLE(ConnectionEventTable) {
    DEFINE_KSEVENT_ITEM(
        KSEVENT_CONNECTION_ENDOFSTREAM,
        sizeof(KSEVENTDATA),
        sizeof(ENDOFSTREAM_EVENT_ENTRY) - sizeof( KSEVENT_ENTRY ),
        PFNKSADDEVENT(CPortPinWaveCyclic::AddEndOfStreamEvent),
        NULL,
        NULL
        )
};

KSEVENT_SET EventTable_PinWaveCyclic[] =
{
    DEFINE_KSEVENT_SET(
        &KSEVENTSETID_LoopedStreaming,
        SIZEOF_ARRAY(PinEventTable),
        PinEventTable
        ),
    DEFINE_KSEVENT_SET(
        &KSEVENTSETID_Connection,
        SIZEOF_ARRAY(ConnectionEventTable),
        ConnectionEventTable
        )
};



/*****************************************************************************
 * Factory
 */

extern ULONG TraceEnable;
extern TRACEHANDLE LoggerHandle;

#pragma code_seg("PAGE")

/*****************************************************************************
 * CreatePortPinWaveCyclic()
 *****************************************************************************
 * Creates a cyclic wave port driver pin.
 */
NTSTATUS
CreatePortPinWaveCyclic
(
    OUT     PUNKNOWN *  Unknown,
    IN      REFCLSID    Interface,
    IN      PUNKNOWN    UnknownOuter    OPTIONAL,
    IN      POOL_TYPE   PoolType
)
{
    PAGED_CODE();

    ASSERT(Unknown);

    _DbgPrintF(DEBUGLVL_LIFETIME,("Creating WAVECYCLIC Pin"));

    STD_CREATE_BODY_
    (
        CPortPinWaveCyclic,
        Unknown,
        UnknownOuter,
        PoolType,
        PPORTPINWAVECYCLIC
    );
}





/*****************************************************************************
 * Member functions.
 */

/*****************************************************************************
 * CPortPinWaveCyclic::~CPortPinWaveCyclic()
 *****************************************************************************
 * Destructor.
 */
CPortPinWaveCyclic::~CPortPinWaveCyclic()
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_LIFETIME,("Destroying WAVECYCLIC Pin (0x%08x)",this));

    _DbgPrintF(DEBUGLVL_BLAB,("CPortPinWaveCyclic::~CPortPinWaveCyclic"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("#### Pin%p.~",this));

    ASSERT(!m_Stream);
    ASSERT(!m_IrpStream);

    if( m_ServiceGroup )
    {
        // Note: m_ServiceGroup->RemoveMember is called in ::Close
        m_ServiceGroup->Release();
        m_ServiceGroup = NULL;
    }

    if (m_Worker)
    {
        KsUnregisterWorker(m_Worker);
        m_Worker = NULL;
    }
    else
    {
        _DbgPrintF(DEBUGLVL_TERSE,("KsWorker NULL, never unregistered!"));
    }

    if (m_DataFormat)
    {
        ExFreePool(m_DataFormat);
    }
    if (m_DmaChannel)
    {
        m_DmaChannel->Release();
    }
    if (m_Port)
    {
        m_Port->Release();
    }
    if (m_Filter)
    {
        m_Filter->Release();
    }

#ifdef DEBUG_WAVECYC_DPC
    if( DebugRecord )
    {
        ExFreePool( DebugRecord );
    }
#endif
}

/*****************************************************************************
 * CPortPinWaveCyclic::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.
 */
STDMETHODIMP_(NTSTATUS)
CPortPinWaveCyclic::
NonDelegatingQueryInterface
(
    REFIID  Interface,
    PVOID * Object
)
{
    PAGED_CODE();

    ASSERT(Object);

    _DbgPrintF( DEBUGLVL_VERBOSE, ("CPortPinWaveCyclic::NonDelegatingQueryInterface") );

    if (IsEqualGUIDAligned( Interface, IID_IUnknown ))
    {
        *Object = PVOID(PPORTPINWAVECYCLIC( this ));

    } else if (IsEqualGUIDAligned( Interface, IID_IIrpTargetFactory ))
    {
        *Object = PVOID(PIRPTARGETFACTORY( this ));

    } else if (IsEqualGUIDAligned( Interface,IID_IIrpTarget ))
    {
        // Cheat!  Get specific interface so we can reuse the GUID.
        *Object = PVOID(PPORTPINWAVECYCLIC( this ));

    } else if (IsEqualGUIDAligned( Interface,IID_IServiceSink ))
    {
        // Cheat!  Get specific interface so we can reuse the GUID.
        *Object = PVOID(PSERVICESINK( this ));

    } else if (IsEqualGUIDAligned( Interface,IID_IKsShellTransport ))
    {
        *Object = PVOID(PIKSSHELLTRANSPORT( this ));

    } else if (IsEqualGUIDAligned( Interface,IID_IKsWorkSink ))
    {
        *Object = PVOID(PIKSWORKSINK( this ));

    } else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

/*****************************************************************************
 * CPortPinWaveCyclic::Init()
 *****************************************************************************
 * Initializes the object.
 */
HRESULT
CPortPinWaveCyclic::
Init
(
    IN  CPortWaveCyclic *       Port_,
    IN  CPortFilterWaveCyclic * Filter_,
    IN  PKSPIN_CONNECT          PinConnect,
    IN  PKSPIN_DESCRIPTOR       PinDescriptor
)
{
    PAGED_CODE();

    ASSERT(Port_);
    ASSERT(Filter_);
    ASSERT(PinConnect);
    ASSERT(PinDescriptor);

    _DbgPrintF(DEBUGLVL_LIFETIME,("Initializing WAVECYCLIC Pin (0x%08x)",this));

    _DbgPrintF(DEBUGLVL_BLAB,("CPortPinWaveCyclic::Init"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("#### Pin%p.Init",this));

    m_Port = Port_;
    m_Port->AddRef();

    m_Filter = Filter_;
    m_Filter->AddRef();

    m_Id                    = PinConnect->PinId;
    m_Descriptor            = PinDescriptor;
    m_DeviceState           = KSSTATE_STOP;
    m_DataFlow              = PinDescriptor->DataFlow;

    m_WorkItemIsPending     = FALSE;
    m_SetPropertyIsPending  = FALSE;
    m_pPendingDataFormat    = NULL;
    m_pPendingSetFormatIrp  = NULL;
    m_Suspended             = FALSE;
    m_bSetPosition          = TRUE;     // set TRUE so that we do the right thing on the first DPC
    m_bJustReceivedIrp      = FALSE;    // set TRUE when an IRP arrives, cleared in RequestService

    m_GlitchType            = PERFGLITCH_PORTCLSOK;
    m_DMAGlitchType         = PERFGLITCH_PORTCLSOK;
    m_LastStateChangeTimeSample     = 0;
    if (LoggerHandle && TraceEnable) {
        m_LastStateChangeTimeSample=KeQueryPerformanceCounter(NULL).QuadPart;
    }

    KeInitializeSpinLock(&m_ksSpinLockDpc);

    InitializeListHead( &m_ClockList );
    KeInitializeSpinLock( &m_ClockListLock );

    ExInitializeWorkItem( &m_SetFormatWorkItem,
                          PropertyWorkerItem,
                          this    );

    KsInitializeWorkSinkItem(&m_WorkItem,this);
    NTSTATUS ntStatus = KsRegisterCountedWorker(DelayedWorkQueue,&m_WorkItem,&m_Worker);

    InitializeInterlockedListHead(&m_IrpsToSend);
    InitializeInterlockedListHead(&m_IrpsOutstanding);

    ExInitializeWorkItem( &m_RecoveryWorkItem,
                          RecoveryWorkerItem,
                          this );
    m_SecondsSinceLastDpc = 0;
    m_SecondsSinceSetFormatRequest = 0;
#ifdef  TRACK_LAST_COMPLETE
    m_SecondsSinceLastComplete = 0;
#endif  //  TRACK_LAST_COMPLETE
    m_SecondsSinceDmaMove = 0;
    m_RecoveryCount = 0;
    m_TimeoutsRegistered = FALSE;

#ifdef DEBUG_WAVECYC_DPC
    DebugRecordCount = 0;
    DebugEnable = FALSE;
    DebugRecord = PCYCLIC_DEBUG_RECORD(ExAllocatePoolWithTag(NonPagedPool,(MAX_DEBUG_RECORDS*sizeof(CYCLIC_DEBUG_RECORD)),'BDcP'));
    if( DebugRecord )
    {
        RtlZeroMemory( PVOID(DebugRecord), MAX_DEBUG_RECORDS * sizeof(CYCLIC_DEBUG_RECORD) );
    }
#endif

    if (NT_SUCCESS(ntStatus))
    {
        ntStatus = PcCaptureFormat( &m_DataFormat,
                                    PKSDATAFORMAT(PinConnect + 1),
                                    m_Port->m_pSubdeviceDescriptor,
                                    m_Id );
#if (DBG)
        if (! NT_SUCCESS(ntStatus))
        {
           _DbgPrintF(DEBUGLVL_VERBOSE,("CPortPinWaveCyclic::Init  PcCaptureFormat() returned status 0x%08x",ntStatus));
        }
#endif
    }

    //
    // Reference the next pin if this is a source.  This must be undone if
    // this function fails.
    //
    if (NT_SUCCESS(ntStatus) && PinConnect->PinToHandle)
    {
        ntStatus = ObReferenceObjectByHandle( PinConnect->PinToHandle,
                                              GENERIC_READ | GENERIC_WRITE,
                                              NULL,
                                              KernelMode,
                                              (PVOID *) &m_ConnectionFileObject,
                                              NULL );

        if (NT_SUCCESS(ntStatus))
        {
            m_ConnectionDeviceObject = IoGetRelatedDeviceObject(m_ConnectionFileObject);
        }
    }

    if (NT_SUCCESS(ntStatus))
    {
        ntStatus = PcNewIrpStreamVirtual( &m_IrpStream,
                                          NULL,
                                          m_DataFlow == KSPIN_DATAFLOW_IN,
                                          PinConnect,
                                          m_Port->DeviceObject );

#if (DBG)
        if (! NT_SUCCESS(ntStatus))
        {
           _DbgPrintF(DEBUGLVL_VERBOSE,("CPortPinWaveCyclic::Init  PcNewIrpStreamVirtual() returned status 0x%08x",ntStatus));
        }
#endif
    }

    if (NT_SUCCESS(ntStatus))
    {
        ntStatus = BuildTransportCircuit();

#if (DBG)
        if (! NT_SUCCESS(ntStatus))
        {
           _DbgPrintF(DEBUGLVL_VERBOSE,("CPortPinWaveCyclic::Init  BuildTransportCircuit() returned status 0x%08x",ntStatus));
        }
#endif
    }

    if (NT_SUCCESS(ntStatus))
    {
        m_IrpStream->RegisterNotifySink(PIRPSTREAMNOTIFY(this));

        ntStatus = m_Port->Miniport->NewStream( &m_Stream,
                                                NULL,
                                                NonPagedPool,
                                                m_Id,
                                                m_DataFlow == KSPIN_DATAFLOW_OUT,
                                                m_DataFormat,
                                                &m_DmaChannel,
                                                &m_ServiceGroup );

        if(!NT_SUCCESS(ntStatus))
        {
            // remove the notify sink reference
            m_IrpStream->RegisterNotifySink(NULL);

            // don't trust any of the return values from the miniport
            m_DmaChannel = NULL;
            m_ServiceGroup = NULL;
            m_Stream = NULL;

           _DbgPrintF(DEBUGLVL_VERBOSE,("CPortPinWaveCyclic::Init  Miniport->NewStream() returned status 0x%08x",ntStatus));
        }
    }

    if (NT_SUCCESS(ntStatus))
    {
        ASSERT(m_Stream);
        ASSERT(m_DmaChannel);
        ASSERT(m_ServiceGroup);

        m_Stream->SetNotificationFreq( WAVECYC_NOTIFICATION_FREQUENCY,
                                       &m_FrameSize );

        m_ulMinBytesReadyToTransfer = m_FrameSize;
        m_ServiceGroup->AddMember(PSERVICESINK(this));

        // add the pin to the port pin list
        KeWaitForSingleObject( &(m_Port->m_PinListMutex),
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );

        InsertTailList( &(m_Port->m_PinList),
                        &m_PinListEntry );

        KeReleaseMutex( &(m_Port->m_PinListMutex), FALSE );

       _DbgPrintF(DEBUGLVL_BLAB,("CPortPinWaveCyclic::Init  m_Stream created"));

        //
        // Set up context for properties.
        //
        m_propertyContext.pSubdevice           = PSUBDEVICE(m_Port);
        m_propertyContext.pSubdeviceDescriptor = m_Port->m_pSubdeviceDescriptor;
        m_propertyContext.pPcFilterDescriptor  = m_Port->m_pPcFilterDescriptor;
        m_propertyContext.pUnknownMajorTarget  = m_Port->Miniport;
        m_propertyContext.pUnknownMinorTarget  = m_Stream;
        m_propertyContext.ulNodeId             = ULONG(-1);

        //
        // Turn on all nodes whose use is specified in the format.  The DSound
        // format contains some capabilities bits.  The port driver uses
        // PcCaptureFormat to convert the DSound format to a WAVEFORMATEX
        // format, making sure the specified caps are satisfied by nodes in
        // the topology.  If the DSound format is used, this call enables all
        // the nodes whose corresponding caps bits are turned on in the format.
        //
        PcAcquireFormatResources( PKSDATAFORMAT(PinConnect + 1),
                                  m_Port->m_pSubdeviceDescriptor,
                                  m_Id,
                                  &m_propertyContext );

        if( m_DataFormat->SampleSize == 0 )
        {
            m_ulSampleSize = 4;
        } else
        {
            m_ulSampleSize = m_DataFormat->SampleSize;
        }
        _DbgPrintF(DEBUGLVL_VERBOSE,("CPortPinWaveCyclic::Init Pin %d",m_Id));
    }
    else
    {
        _DbgPrintF( DEBUGLVL_VERBOSE, ("Could not create new m_Stream. Error:%X", ntStatus));
    }

    // Did something go wrong?
    if ( !NT_SUCCESS(ntStatus) )
    {
        // release the clock if it was assigned
        if( m_ClockFileObject )
        {
            ObDereferenceObject( m_ClockFileObject );
            m_ClockFileObject = NULL;
        }

        // release the allocator if it was assigned
        if( m_AllocatorFileObject )
        {
            ObDereferenceObject( m_AllocatorFileObject );
            m_AllocatorFileObject = NULL;
        }

        // dereference the next pin if this is a source pin
        if( m_ConnectionFileObject )
        {
            ObDereferenceObject( m_ConnectionFileObject );
            m_ConnectionFileObject = NULL;
        }

        // clean up the transports
        PIKSSHELLTRANSPORT distribution;
        if( m_RequestorTransport )
        {
            distribution = m_RequestorTransport;
        } else
        {
            distribution = m_QueueTransport;
        }

        if( distribution )
        {
            distribution->AddRef();

            while(distribution)
            {
                PIKSSHELLTRANSPORT nextTransport;
                distribution->Connect(NULL,&nextTransport,KSPIN_DATAFLOW_OUT);
                distribution->Release();
                distribution = nextTransport;
            }
        }

        // dereference the queue if there is one
        if( m_QueueTransport )
        {
            m_QueueTransport->Release();
            m_QueueTransport = NULL;
        }

        // dereference the requestor if there is one
        if( m_RequestorTransport )
        {
            m_RequestorTransport->Release();
            m_RequestorTransport = NULL;
        }

        // release the IrpStream
        if(m_IrpStream)
        {
            m_IrpStream->Release();
            m_IrpStream = NULL;
        }
    } else
    {
        // Register for timeout callbacks
        SetupIoTimeouts( TRUE );

        m_bInitCompleted = TRUE;
    }

    return ntStatus;
}

#pragma code_seg()

STDMETHODIMP_(NTSTATUS)
CPortPinWaveCyclic::NewIrpTarget(
    OUT PIRPTARGET * IrpTarget,
    OUT BOOLEAN * ReferenceParent,
    IN PUNKNOWN UnkOuter,
    IN POOL_TYPE PoolType,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    OUT PKSOBJECT_CREATE ObjectCreate
    )

/*++

Routine Description:
    Handles the NewIrpTarget method for IIrpTargetFactory interface.

Arguments:
    OUT PIRPTARGET * IrpTarget -

    OUT BOOLEAN * ReferenceParent -

    IN PUNKNOWN UnkOuter -

    IN POOL_TYPE PoolType -

    IN PDEVICE_OBJECT DeviceObject -

    IN PIRP Irp -

    OUT PKSOBJECT_CREATE ObjectCreate -

Return:

--*/

{
    NTSTATUS                Status;
    PKSCLOCK_CREATE         ClockCreate;
    PWAVECYCLICCLOCK        WaveCyclicClock;
    PUNKNOWN                Unknown;

    ASSERT( IrpTarget );
    ASSERT( DeviceObject );
    ASSERT( Irp );
    ASSERT( ObjectCreate );
    ASSERT( m_Port );

    _DbgPrintF( DEBUGLVL_BLAB, ("CPortPinWaveCyclic::NewIrpTarget"));

    Status =
        KsValidateClockCreateRequest(
            Irp,
            &ClockCreate );

    if (NT_SUCCESS( Status )) {

        //
        // Clocks use spinlocks, this better be NonPaged
        //

        ASSERT( PoolType == NonPagedPool );

        Status =
            CreatePortClockWaveCyclic(
                &Unknown,
                this,
                GUID_NULL,
                UnkOuter,
                PoolType );

        if (NT_SUCCESS( Status )) {

            Status =
                Unknown->QueryInterface(
                    IID_IIrpTarget,
                    (PVOID *) &WaveCyclicClock );

            if (NT_SUCCESS( Status )) {
                PWAVECYCLICCLOCK_NODE   Node;
                KIRQL                   irqlOld;

                //
                // Hook this child into the list of clocks.  Note that
                // when this child is released, it will remove ITSELF
                // from this list by acquiring the given SpinLock.
                //

                Node = WaveCyclicClock->GetNodeStructure();
                Node->ListLock = &m_ClockListLock;
                Node->FileObject =
                    IoGetCurrentIrpStackLocation( Irp )->FileObject;
                KeAcquireSpinLock( &m_ClockListLock, &irqlOld );
                InsertTailList(
                    &m_ClockList,
                    &Node->ListEntry );
                KeReleaseSpinLock( &m_ClockListLock, irqlOld );

                *ReferenceParent = FALSE;
                *IrpTarget = WaveCyclicClock;
            }

            Unknown->Release();
        }
    }

    return Status;
}

#pragma code_seg("PAGE")

/*****************************************************************************
 * CPortPinWaveCyclic::DeviceIoControl()
 *****************************************************************************
 * Handles an IOCTL IRP.
 */
STDMETHODIMP_(NTSTATUS)
CPortPinWaveCyclic::
DeviceIoControl
(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
)
{
    PAGED_CODE();

    ASSERT(DeviceObject);
    ASSERT(Irp);

    NTSTATUS            ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    ASSERT(irpSp);

    _DbgPrintF( DEBUGLVL_BLAB, ("CPortPinWaveCyclic::DeviceIoControl"));

    switch (irpSp->Parameters.DeviceIoControl.IoControlCode)
    {
    case IOCTL_KS_PROPERTY:
        _DbgPrintF( DEBUGLVL_BLAB, ("IOCTL_KS_PROPERTY"));

        ntStatus =
            PcHandlePropertyWithTable
            (
                Irp,
                m_Port->m_pSubdeviceDescriptor->PinPropertyTables[m_Id].PropertySetCount,
                m_Port->m_pSubdeviceDescriptor->PinPropertyTables[m_Id].PropertySets,
                &m_propertyContext
            );
        break;

    case IOCTL_KS_ENABLE_EVENT:
        {
            _DbgPrintF( DEBUGLVL_BLAB, ("IOCTL_KS_ENABLE_EVENT"));

            EVENT_CONTEXT EventContext;

            EventContext.pPropertyContext = &m_propertyContext;
            EventContext.pEventList = NULL;
            EventContext.ulPinId = m_Id;
            EventContext.ulEventSetCount = m_Port->m_pSubdeviceDescriptor->PinEventTables[m_Id].EventSetCount;
            EventContext.pEventSets = m_Port->m_pSubdeviceDescriptor->PinEventTables[m_Id].EventSets;

            ntStatus =
                PcHandleEnableEventWithTable
                (
                    Irp,
                    &EventContext
                );
        }
        break;

    case IOCTL_KS_DISABLE_EVENT:
        {
            _DbgPrintF( DEBUGLVL_BLAB, ("IOCTL_KS_DISABLE_EVENT"));

            EVENT_CONTEXT EventContext;

            EventContext.pPropertyContext = &m_propertyContext;
            EventContext.pEventList = &(m_Port->m_EventList);
            EventContext.ulPinId = m_Id;
            EventContext.ulEventSetCount = m_Port->m_pSubdeviceDescriptor->PinEventTables[m_Id].EventSetCount;
            EventContext.pEventSets = m_Port->m_pSubdeviceDescriptor->PinEventTables[m_Id].EventSets;

            ntStatus =
                PcHandleDisableEventWithTable
                (
                    Irp,
                    &EventContext
                );
        }
        break;

    case IOCTL_KS_WRITE_STREAM:
    case IOCTL_KS_READ_STREAM:
        _DbgPrintF( DEBUGLVL_BLAB, ("IOCTL_KS_PACKETSTREAM"));

        if
        (   m_TransportSink
        && (! m_ConnectionFileObject)
        &&  (m_Descriptor->Communication == KSPIN_COMMUNICATION_SINK)
        &&  (   (   (m_DataFlow == KSPIN_DATAFLOW_IN)
                &&  (   irpSp->Parameters.DeviceIoControl.IoControlCode
                    ==  IOCTL_KS_WRITE_STREAM
                    )
                )
            ||  (   (m_DataFlow == KSPIN_DATAFLOW_OUT)
                &&  (   irpSp->Parameters.DeviceIoControl.IoControlCode
                    ==  IOCTL_KS_READ_STREAM
                    )
                )
            )
        )
        {
            if (m_DeviceState == KSSTATE_STOP) {
                //
                // Stopped...reject.
                //
                ntStatus = STATUS_INVALID_DEVICE_STATE;
            } else if (m_Flushing) {
                //
                // Flushing...reject.
                //
                ntStatus = STATUS_DEVICE_NOT_READY;
            } else {

                // We going to submit the IRP to our pipe, so make sure that
                // we start out with a clear status field.
                Irp->IoStatus.Status = STATUS_SUCCESS;

                //
                // Send around the circuit.  We don't use KsShellTransferKsIrp
                // because we want to stop if we come back around to this pin.
                //
                PIKSSHELLTRANSPORT transport = m_TransportSink;
                while (transport) {
                    if (transport == PIKSSHELLTRANSPORT(this)) {
                        //
                        // We have come back around to the pin.  Just complete
                        // the IRP.
                        //
                        if (ntStatus == STATUS_PENDING) {
                            ntStatus = STATUS_SUCCESS;
                        }
                        break;
                    }

                    PIKSSHELLTRANSPORT nextTransport;
                    ntStatus = transport->TransferKsIrp(Irp,&nextTransport);

                    ASSERT(NT_SUCCESS(ntStatus) || ! nextTransport);

                    transport = nextTransport;
                }
            }
        }
        break;

    case IOCTL_KS_RESET_STATE:
        {
            KSRESET ResetType = KSRESET_BEGIN;  //  initial value

            ntStatus = KsAcquireResetValue( Irp, &ResetType );
            DistributeResetState(ResetType);
        }
        break;

    default:
        return KsDefaultDeviceIoCompletion(DeviceObject, Irp);
    }

    if (ntStatus != STATUS_PENDING)
    {
        Irp->IoStatus.Status = ntStatus;
        IoCompleteRequest(Irp,IO_NO_INCREMENT);
    }

    return ntStatus;
}

/*****************************************************************************
 * CPortPinWaveCyclic::Close()
 *****************************************************************************
 * Handles a flush IRP.
 */
STDMETHODIMP_(NTSTATUS)
CPortPinWaveCyclic::
Close
(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
)
{
    PAGED_CODE();

    ASSERT(DeviceObject);
    ASSERT(Irp);

    _DbgPrintF(DEBUGLVL_VERBOSE,("CPortPinWaveCyclic::Close Pin %d",m_Id));
#if (DBG)
    if (m_ullServiceCount)
    {
        _DbgPrintF(DEBUGLVL_VERBOSE,("  SERVICE:     occurrences=%I64d  bytes=%I64d, bytes/occurence=%I64d",m_ullServiceCount,m_ullByteCount,m_ullByteCount/m_ullServiceCount));
        _DbgPrintF(DEBUGLVL_VERBOSE,("               max copied=%d  max completed=%d",m_ulMaxBytesCopied,m_ulMaxBytesCompleted));
        if (m_ullServiceCount > 1)
        {
            _DbgPrintF(DEBUGLVL_VERBOSE,("               max interval=%d  avg interval=%d",m_ulMaxServiceInterval,ULONG(m_ullServiceIntervalSum / (m_ullServiceCount - 1))));
        }
    }
    if (m_ullStarvationCount)
    {
        _DbgPrintF(DEBUGLVL_VERBOSE,("  STARVATION:  occurrences=%I64d  bytes=%I64d, bytes/occurence=%I64d",m_ullStarvationCount,m_ullStarvationBytes,m_ullStarvationBytes/m_ullStarvationCount));
    }
#endif

    // !!! WARNING !!!
    // The order that these objects are
    // being released is VERY important!
    // All data used by the service routine
    // must exists until AFTER the stream
    // has been released.

    // we don't need I/O timeout services any more
    SetupIoTimeouts( FALSE );

    // remove this pin from the list of pins
    // that need servicing...
    if (m_Port)
    {
        KeWaitForSingleObject( &(m_Port->m_PinListMutex),
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );

        RemoveEntryList( &m_PinListEntry );

        KeReleaseMutex( &(m_Port->m_PinListMutex), FALSE );
    }

    // We don't need servicing any more
    if (m_ServiceGroup)
    {
        m_ServiceGroup->RemoveMember(PSERVICESINK(this));
    }

    // release the clock if it was assigned

    if (m_ClockFileObject) {
        ObDereferenceObject( m_ClockFileObject );
        m_ClockFileObject = NULL;
    }

    // release the allocator if it was assigned

    if (m_AllocatorFileObject) {
        ObDereferenceObject( m_AllocatorFileObject );
        m_AllocatorFileObject = NULL;
    }

    //
    // Dereference next pin if this is a source pin.
    //
    if (m_ConnectionFileObject)
    {
        ObDereferenceObject(m_ConnectionFileObject);
        m_ConnectionFileObject = NULL;
    }

    // Tell the miniport to close the stream.
    if (m_Stream)
    {
        m_Stream->Release();
        m_Stream = NULL;
    }

    PIKSSHELLTRANSPORT distribution;
    if (m_RequestorTransport) {
        //
        // This section owns the requestor, so it does own the pipe, and the
        // requestor is the starting point for any distribution.
        //
        distribution = m_RequestorTransport;
    } else {
        //
        // This section is at the top of an open circuit, so it does own the
        // pipe and the queue is the starting point for any distribution.
        //
        distribution = m_QueueTransport;
    }

    //
    // If this section owns the pipe, it must disconnect the entire circuit.
    //
    if (distribution) {

        //
        // We are going to use Connect() to set the transport sink for each
        // component in turn to NULL.  Because Connect() takes care of the
        // back links, transport source pointers for each component will
        // also get set to NULL.  Connect() gives us a referenced pointer
        // to the previous transport sink for the component in question, so
        // we will need to do a release for each pointer obtained in this
        // way.  For consistency's sake, we will release the pointer we
        // start with (distribution) as well, so we need to AddRef it first.
        //
        distribution->AddRef();
        while (distribution) {
            PIKSSHELLTRANSPORT nextTransport;
            distribution->Connect(NULL,&nextTransport,KSPIN_DATAFLOW_OUT);
            distribution->Release();
            distribution = nextTransport;
        }
    }

    //
    // Dereference the queue if there is one.
    //
    if (m_QueueTransport) {
        m_QueueTransport->Release();
        m_QueueTransport = NULL;
    }

    //
    // Dereference the requestor if there is one.
    //
    if (m_RequestorTransport) {
        m_RequestorTransport->Release();
        m_RequestorTransport = NULL;
    }

    // Destroy the irpstream...
    m_IrpStream->Release();
    m_IrpStream = NULL;

    //
    // Decrement instance counts.
    //
    ASSERT(m_Port);
    ASSERT(m_Filter);
    PcTerminateConnection
    (
        m_Port->m_pSubdeviceDescriptor,
        m_Filter->m_propertyContext.pulPinInstanceCounts,
        m_Id
    );

    //
    // free any events in the port event list associated with this pin
    //
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
    KsFreeEventList( irpSp->FileObject,
                     &( m_Port->m_EventList.List ),
                     KSEVENTS_SPINLOCK,
                     &( m_Port->m_EventList.ListLock) );

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp,IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}

//DEFINE_INVALID_CREATE(CPortPinWaveCyclic);
DEFINE_INVALID_READ(CPortPinWaveCyclic);
DEFINE_INVALID_WRITE(CPortPinWaveCyclic);
DEFINE_INVALID_FLUSH(CPortPinWaveCyclic);
DEFINE_INVALID_QUERYSECURITY(CPortPinWaveCyclic);
DEFINE_INVALID_SETSECURITY(CPortPinWaveCyclic);
DEFINE_INVALID_FASTDEVICEIOCONTROL(CPortPinWaveCyclic);
DEFINE_INVALID_FASTREAD(CPortPinWaveCyclic);
DEFINE_INVALID_FASTWRITE(CPortPinWaveCyclic);

#pragma code_seg()

/*****************************************************************************
 * CPortPinWaveCyclic::IrpSubmitted()
 *****************************************************************************
 * Handles notification that an irp was submitted.
 */
STDMETHODIMP_(void)
CPortPinWaveCyclic::
IrpSubmitted
(
    IN      PIRP        Irp,
    IN      BOOLEAN     WasExhausted
)
{
    KIRQL OldIrql;
    PKSPIN_LOCK pServiceGroupSpinLock;

    _DbgPrintF(DEBUGLVL_VERBOSE,("IrpSubmitted 0x%08x",Irp));

    ASSERT( m_ServiceGroup );

    pServiceGroupSpinLock = GetServiceGroupSpinLock ( m_ServiceGroup );

    ASSERT( pServiceGroupSpinLock );

    KeAcquireSpinLock ( pServiceGroupSpinLock, &OldIrql );

    m_bJustReceivedIrp=TRUE;

    RequestService();

    KeReleaseSpinLock ( pServiceGroupSpinLock, OldIrql );

}


STDMETHODIMP_(NTSTATUS)
CPortPinWaveCyclic::ReflectDeviceStateChange(
    KSSTATE State
    )

/*++

Routine Description:
    Reflects the device state change to any component that requires
    interactive state change information.  Note that the objects

Arguments:
    KSSTATE State -
        new device state

Return:
    STATUS_SUCCESS

--*/

{
    KIRQL                   irqlOld;
    PWAVECYCLICCLOCK_NODE   ClockNode;
    PLIST_ENTRY             ListEntry;

    KeAcquireSpinLock( &m_ClockListLock, &irqlOld );

    for (ListEntry = m_ClockList.Flink;
        ListEntry != &m_ClockList;
        ListEntry = ListEntry->Flink) {

        ClockNode =
            (PWAVECYCLICCLOCK_NODE)
                CONTAINING_RECORD( ListEntry,
                                   WAVECYCLICCLOCK_NODE,
                                   ListEntry);
        ClockNode->IWaveCyclicClock->SetState( State );
    }

    KeReleaseSpinLock( &m_ClockListLock, irqlOld );

    if (State == KSSTATE_STOP) {
        m_GlitchType = PERFGLITCH_PORTCLSOK;
        m_DMAGlitchType = PERFGLITCH_PORTCLSOK;
    }

    return STATUS_SUCCESS;
}

#pragma code_seg("PAGE")

#if 0

STDMETHODIMP_(void)
CPortPinWaveCyclic::IrpCompleting(
    IN PIRP Irp
    )

/*++

Routine Description:
    This method handles the dispatch from CIrpStream when a streaming IRP
    is about to be completed.

Arguments:
    IN PIRP Irp -
        I/O request packet

Return:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("IrpCompleting 0x%08x",Irp));

    PKSSTREAM_HEADER    StreamHeader;
    PIO_STACK_LOCATION  irpSp;
    CPortPinWaveCyclic  *PinWaveCyclic;

    StreamHeader = PKSSTREAM_HEADER( Irp->AssociatedIrp.SystemBuffer );

    irpSp =  IoGetCurrentIrpStackLocation( Irp );

    if (irpSp->Parameters.DeviceIoControl.IoControlCode ==
            IOCTL_KS_WRITE_STREAM) {
        ASSERT( StreamHeader );

        //
        // Signal end-of-stream event for the renderer.
        //
        if (StreamHeader->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM) {

            PinWaveCyclic =
                (CPortPinWaveCyclic *) KsoGetIrpTargetFromIrp( Irp );

            PinWaveCyclic->GenerateEndOfStreamEvents();
        }
    }
}

#endif

#ifdef DEBUG_WAVECYC_DPC

void
CPortPinWaveCyclic::
DumpDebugRecords(
    void
)
{
    if( DebugRecord )
    {
        _DbgPrintF(DEBUGLVL_TERSE,("---- WaveCyclic DPC Debug Records ----"));

        for( ULONG Record = 0; Record < MAX_DEBUG_RECORDS; Record++ )
        {
            _DbgPrintF(DEBUGLVL_TERSE,("Record#%d",Record));
            _DbgPrintF(DEBUGLVL_TERSE,("  PinState:        %s",
                                       KSSTATE_TO_STRING(DebugRecord[Record].DbgPinState)));
            _DbgPrintF(DEBUGLVL_TERSE,("  BufferSize:      0x%08x",
                                       DebugRecord[Record].DbgBufferSize));
            _DbgPrintF(DEBUGLVL_TERSE,("  DmaPosition:     0x%08x",
                                       DebugRecord[Record].DbgDmaPosition));
            if( DebugRecord[Record].DbgCopy1Bytes )
            {
                _DbgPrintF(DEBUGLVL_TERSE,("  Copy1Bytes:      0x%08x",
                                           DebugRecord[Record].DbgCopy1Bytes));
                _DbgPrintF(DEBUGLVL_TERSE,("  Copy1From:       0x%08x",
                                           DebugRecord[Record].DbgCopy1From));
                _DbgPrintF(DEBUGLVL_TERSE,("  Copy1To:         0x%08x",
                                           DebugRecord[Record].DbgCopy1To));
            }
            if( DebugRecord[Record].DbgCopy2Bytes )
            {
                _DbgPrintF(DEBUGLVL_TERSE,("  Copy2Bytes:      0x%08x",
                                           DebugRecord[Record].DbgCopy2Bytes));
                _DbgPrintF(DEBUGLVL_TERSE,("  Copy2From:       0x%08x",
                                           DebugRecord[Record].DbgCopy2From));
                _DbgPrintF(DEBUGLVL_TERSE,("  Copy2To:         0x%08x",
                                           DebugRecord[Record].DbgCopy2To));
            }
            if( DebugRecord[Record].DbgCompletedBytes )
            {
                _DbgPrintF(DEBUGLVL_TERSE,("  CompletedBytes:  0x%08x",
                                           DebugRecord[Record].DbgCompletedBytes));
                _DbgPrintF(DEBUGLVL_TERSE,("  CompletedFrom:   0x%08x",
                                           DebugRecord[Record].DbgCompletedFrom));
                _DbgPrintF(DEBUGLVL_TERSE,("  CompletedTo:     0x%08x",
                                           DebugRecord[Record].DbgCompletedTo));
            }
            _DbgPrintF(DEBUGLVL_TERSE,("  FrameSize:       0x%08x",
                                       DebugRecord[Record].DbgFrameSize));
            _DbgPrintF(DEBUGLVL_TERSE,("  WindowSize:      0x%08x",
                                       DebugRecord[Record].DbgWindowSize));
            if( DebugRecord[Record].DbgSetPosition )
            {
                _DbgPrintF(DEBUGLVL_TERSE,("  SetPosition:     True"));
            }
            if( DebugRecord[Record].DbgStarvation )
            {
                _DbgPrintF(DEBUGLVL_TERSE,("  StarvationBytes: 0x%08x",
                                           DebugRecord[Record].DbgStarvationBytes));
            }
            _DbgPrintF(DEBUGLVL_TERSE,("  DmaBytes:        0x%04x",
                                       DebugRecord[Record].DbgDmaSamples[0]));
            _DbgPrintF(DEBUGLVL_TERSE,("  DmaBytes:        0x%04x",
                                       DebugRecord[Record].DbgDmaSamples[1]));
            _DbgPrintF(DEBUGLVL_TERSE,("  DmaBytes:        0x%04x",
                                       DebugRecord[Record].DbgDmaSamples[2]));
            _DbgPrintF(DEBUGLVL_TERSE,("  DmaBytes:        0x%04x",
                                       DebugRecord[Record].DbgDmaSamples[3]));
        }
    }
}

#endif

#pragma code_seg()

STDMETHODIMP_(NTSTATUS)
CPortPinWaveCyclic::
SetDeviceState(
    IN KSSTATE NewState,
    IN KSSTATE OldState,
    OUT PIKSSHELLTRANSPORT* NextTransport
)

/*++

Routine Description:

    This routine handles notification that the device state has changed.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("CPortPinWaveCyclic::SetDeviceState(0x%08x)",this));
    _DbgPrintF(DEBUGLVL_VERBOSE,("#### Pin%p.SetDeviceState:  from %d to %d",this,OldState,NewState));

    ASSERT(PASSIVE_LEVEL == KeGetCurrentIrql());

    ASSERT(NextTransport);

    NTSTATUS ntStatus = STATUS_SUCCESS;

    if (m_State != NewState) {
        m_State = NewState;

        if (NewState > OldState) {
            *NextTransport = m_TransportSink;
        } else {
            *NextTransport = m_TransportSource;
        }

    // set the miniport stream state if we're not suspended.
    if( FALSE == m_Suspended )
    {
            ntStatus = m_Stream->SetState(NewState);
        if( NT_SUCCESS(ntStatus) )
        {
                m_CommandedState = NewState;
        }
    }

    if (NT_SUCCESS(ntStatus))
    {
            switch (NewState)
        {
        case KSSTATE_STOP:
            if( OldState != KSSTATE_STOP )
            {
                _DbgPrintF(DEBUGLVL_VERBOSE,("#### Pin%p.SetDeviceState:  cancelling outstanding IRPs",this));
                CancelIrpsOutstanding();
                m_ulDmaCopy             = 0;
                m_ulDmaComplete         = 0;
                m_ulDmaWindowSize       = 0;
                m_ullPlayPosition       = 0;
                m_ullPosition           = 0;
            }
            break;

        case KSSTATE_PAUSE:
            KIRQL oldIrql;
            if (OldState != KSSTATE_RUN)
            {
                m_Stream->Silence(m_DmaChannel->SystemAddress(),m_DmaChannel->BufferSize());
            }
#ifdef DEBUG_WAVECYC_DPC
            else
            {
                KeRaiseIrql(DISPATCH_LEVEL,&oldIrql);
                GeneratePositionEvents();
                KeLowerIrql(oldIrql);

                DumpDebugRecords();
            }

            if( DebugRecord )
            {
                DebugRecordCount = 0;
                DebugEnable = TRUE;
            }
#else
            else
            {
                KeRaiseIrql(DISPATCH_LEVEL,&oldIrql);
                GeneratePositionEvents();
                KeLowerIrql(oldIrql);
            }
#endif
            break;

        case KSSTATE_RUN:
            break;
        }

        if (NT_SUCCESS(ntStatus))
        {
                ReflectDeviceStateChange(NewState);
            }
        }
    } else {
        *NextTransport = NULL;
    }

    return ntStatus;
}

#pragma code_seg("PAGE")

/*****************************************************************************
 * PinPropertyDeviceState()
 *****************************************************************************
 * Handles device state property access for the pin.
 */
NTSTATUS
PinPropertyDeviceState
(
    IN      PIRP        Irp,
    IN      PKSPROPERTY Property,
    IN OUT  PKSSTATE    DeviceState
)
{
    PAGED_CODE();

    ASSERT(Irp);
    ASSERT(Property);
    ASSERT(DeviceState);

    CPortPinWaveCyclic *that =
        (CPortPinWaveCyclic *) KsoGetIrpTargetFromIrp(Irp);
    CPortWaveCyclic *port = that->m_Port;

    NTSTATUS ntStatus;

    if (Property->Flags & KSPROPERTY_TYPE_GET)
    {
        _DbgPrintF(DEBUGLVL_VERBOSE,("PinPropertyDeviceState get %d",that->m_DeviceState));
        // Handle property get.
        *DeviceState = that->m_DeviceState;
        Irp->IoStatus.Information = sizeof(KSSTATE);
        ntStatus = STATUS_SUCCESS;
        if( (that->m_DataFlow == KSPIN_DATAFLOW_OUT) &&
            (*DeviceState == KSSTATE_PAUSE) )
        {
            ntStatus = STATUS_NO_DATA_DETECTED;
        }
    }
    else
    {
        _DbgPrintF(DEBUGLVL_VERBOSE,("PinPropertyDeviceState set from %d to %d",that->m_DeviceState,*DeviceState));

        // Serialize.
        KeWaitForSingleObject
        (
            &port->ControlMutex,
            Executive,
            KernelMode,
            FALSE,          // Not alertable.
            NULL
        );

        if (that->m_SetPropertyIsPending)
        {    //  Complete the m_pPendingSetFormatIrp,
            that->FailPendedSetFormat();
        }

        if (*DeviceState < that->m_DeviceState) {
            KSSTATE oldState = that->m_DeviceState;
            that->m_DeviceState = *DeviceState;
            ntStatus = that->DistributeDeviceState(*DeviceState,oldState);
            if (! NT_SUCCESS(ntStatus)) {
                that->m_DeviceState = oldState;
            }
        } else {
            ntStatus = that->DistributeDeviceState(*DeviceState,that->m_DeviceState);
            if (NT_SUCCESS(ntStatus)) {
                that->m_DeviceState = *DeviceState;
            }
        }

        KeReleaseMutex(&port->ControlMutex,FALSE);
    }

    return ntStatus;
}

#pragma code_seg()
/*****************************************************************************
 * FailPendedSetFormat()
 *****************************************************************************
 * Disposes of a pended SetFormat property IRP.
 */
void
CPortPinWaveCyclic::
FailPendedSetFormat(void)
{
    if( m_pPendingSetFormatIrp )
    {
        m_pPendingSetFormatIrp->IoStatus.Information = 0;
        m_pPendingSetFormatIrp->IoStatus.Status = STATUS_DEVICE_BUSY;
        IoCompleteRequest(m_pPendingSetFormatIrp,IO_NO_INCREMENT);
    }

    m_pPendingSetFormatIrp = 0;
    m_SetPropertyIsPending = FALSE; //  The work item might run in the future
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * PinPropertyDataFormat()
 *****************************************************************************
 * Handles data format property access for the pin.
 */
NTSTATUS
PinPropertyDataFormat
(
    IN      PIRP            Irp,
    IN      PKSPROPERTY     Property,
    IN OUT  PKSDATAFORMAT   ioDataFormat
)
{
    PAGED_CODE();

    ASSERT(Irp);
    ASSERT(Property);
    ASSERT(ioDataFormat);

    _DbgPrintF( DEBUGLVL_VERBOSE, ("PinPropertyDataFormat"));

    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    ASSERT(irpSp);
    CPortPinWaveCyclic *that =
        (CPortPinWaveCyclic *) KsoGetIrpTargetFromIrp(Irp);
    CPortWaveCyclic *port = that->m_Port;

    NTSTATUS ntStatus = STATUS_SUCCESS;

    if (Property->Flags & KSPROPERTY_TYPE_GET)
    {
        if (that->m_DataFormat)
        {
            if  (   !irpSp->Parameters.DeviceIoControl.OutputBufferLength
                )
            {
                Irp->IoStatus.Information = that->m_DataFormat->FormatSize;
                ntStatus = STATUS_BUFFER_OVERFLOW;
            }
            else    //  nonzero OutputBufferLength
            {
                if  (   irpSp->Parameters.DeviceIoControl.OutputBufferLength
                    >=  sizeof(that->m_DataFormat->FormatSize)
                    )
                {
                    RtlCopyMemory
                    (
                        ioDataFormat,
                        that->m_DataFormat,
                        that->m_DataFormat->FormatSize
                    );
                    Irp->IoStatus.Information = that->m_DataFormat->FormatSize;
                }
                else    //  OutputBufferLength not large enough
                {
                    ntStatus = STATUS_BUFFER_TOO_SMALL;
                }
            }
        }
        else    //  no ioDataFormat
        {
            ntStatus = STATUS_UNSUCCESSFUL;
        }
    }
    else    //  Set property
    {
        PKSDATAFORMAT FilteredDataFormat = NULL;

        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength >= sizeof(*ioDataFormat))
        {
            ntStatus =
                PcCaptureFormat
                (
                    &FilteredDataFormat,
                    ioDataFormat,
                    port->m_pSubdeviceDescriptor,
                    that->m_Id
                );
        }
        else
        {
            ntStatus = STATUS_BUFFER_TOO_SMALL;
        }

        if (NT_SUCCESS(ntStatus))
        {
            KeWaitForSingleObject
            (
                &port->ControlMutex,
                Executive,
                KernelMode,
                FALSE,          // Not alertable.
                NULL
            );

            if (that->m_DeviceState != KSSTATE_RUN)
            {
                //  do the usual
                if(NT_SUCCESS(ntStatus))
                {
                    ntStatus = that->SynchronizedSetFormat(FilteredDataFormat);
                }
            }
            else    //  KSSTATE_RUN, do special stuff
            {
                //  If we had previously pended a SetFormat,
                //  fail previous one!
                //
                //  DPC reads m_SetPropertyIsPending, too, so Interlocked
                if (InterlockedExchange((LPLONG)&that->m_SetPropertyIsPending, TRUE))
                {
                    that->FailPendedSetFormat();
                }

                // kick off a timeout timer
                InterlockedExchange( PLONG(&(that->m_SecondsSinceSetFormatRequest)), 0 );

                //  Pend this IRP
                Irp->IoStatus.Information = 0;
                IoMarkIrpPending(Irp);
                ntStatus = STATUS_PENDING;
                that->m_pPendingDataFormat = FilteredDataFormat;
                that->m_pPendingSetFormatIrp = Irp;
            }
            // Unserialize
            KeReleaseMutex(&port->ControlMutex,FALSE);
        }
    }
    return ntStatus;
}


//  Assumes already synchronized with control mutex
NTSTATUS
CPortPinWaveCyclic::SynchronizedSetFormat
(
    IN PKSDATAFORMAT   inDataFormat
)
{
    NTSTATUS        ntStatus;

    PAGED_CODE();

    //
    // Removed a check for a reasonable sample rate (100Hz-100,000Hz).  This was originally added to
    // avoid a bug in an ESS Solo driver that was shipped by ESS after Win98 Gold and before OSR1
    //

    // set the format on the miniport stream
    ntStatus = m_Stream->SetFormat(inDataFormat);
    if( NT_SUCCESS(ntStatus) )
    {
        m_Stream->SetNotificationFreq( WAVECYC_NOTIFICATION_FREQUENCY,
                                       &m_FrameSize );

        m_ulMinBytesReadyToTransfer = m_FrameSize;

        if (m_DataFormat)
        {
            ExFreePool(m_DataFormat);
        }

        m_DataFormat = inDataFormat;

        if( 0 == inDataFormat->SampleSize )
        {
            // if no sample size, assume 16-bit stereo.
            m_ulSampleSize = 4;
        } else
        {
            m_ulSampleSize = inDataFormat->SampleSize;
        }

        // Is DMA out of alignment now?
        this->RealignBufferPosToFrame();
    }
    else    //  ! SUCCESS
    {
        ExFreePool(inDataFormat);
    }

    return ntStatus;
}

NTSTATUS
CPortPinWaveCyclic::PinPropertyAllocatorFraming(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PKSALLOCATOR_FRAMING AllocatorFraming
    )

/*++

Routine Description:
    Returns the allocator framing structure for the device.

Arguments:
    IN PIRP Irp -
        I/O request packet

    IN PKSPROPERTY Property -
        property containing allocator framing request

    OUT PKSALLOCATOR_FRAMING AllocatorFraming -
        resultant structure filled in by the port driver

Return:
    STATUS_SUCCESS

--*/

{
    CPortPinWaveCyclic  *WaveCyclicPin;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("PinPropertyAllocatorFraming") );

    WaveCyclicPin =
        (CPortPinWaveCyclic *) KsoGetIrpTargetFromIrp( Irp );

    //
    // Report the minimum requirements.
    //

    AllocatorFraming->RequirementsFlags =
        KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY |
        KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY;
    AllocatorFraming->Frames = 8;
    AllocatorFraming->FrameSize = WaveCyclicPin->m_FrameSize;
    AllocatorFraming->FileAlignment = KeGetRecommendedSharedDataAlignment()-1;
    AllocatorFraming->PoolType = NonPagedPool;

    Irp->IoStatus.Information = sizeof(*AllocatorFraming);

    return STATUS_SUCCESS;
}

#pragma code_seg()

/*****************************************************************************
 * GetPosition()
 *****************************************************************************
 * Gets the current position.
 *
 * This code assumes that m_IrpStream->m_irpStreamPositionLock is
 * held by the caller to protect m_OldDmaPosition and m_ulDmaComplete
 * as well as m_IrpStream->m_IrpStreamPosition.
 *
 */
STDMETHODIMP_(NTSTATUS)
CPortPinWaveCyclic::
GetPosition
(   IN OUT  PIRPSTREAM_POSITION pIrpStreamPosition
)
{
    KIRQL kIrqlOld;
    KeAcquireSpinLock(&m_ksSpinLockDpc,&kIrqlOld);

    ULONG ulDmaPosition;

    //
    // We continue even if m_Stream->GetPosition() failed,
    // because this just means the IrpStrm's Notify members
    // didn't succeed in modifying the initial IrpStrm value.
    // We will bubble the error back up to the caller, of course,
    // but with as accurate position information as we can get.
    //
    NTSTATUS ntStatus = m_Stream->GetPosition(&ulDmaPosition);

    //
    // Cache the buffer size.
    //
    ULONG ulDmaBufferSize = m_DmaChannel->BufferSize();

    if (ulDmaBufferSize)
    {
        //
        // Treat end-of-buffer as 0.
        //
        if (ulDmaPosition >= ulDmaBufferSize)
        {
            ulDmaPosition = 0;
        }

        //
        // Make sure we are aligned on a frame boundary.
        //
        ULONG ulFrameAlignment = ulDmaPosition % m_ulSampleSize;
        if (ulFrameAlignment)
        {
            if (m_DataFlow == KSPIN_DATAFLOW_IN)
            {
                //
                // Render:  round up.
                //
                ulDmaPosition =
                    (   (   (   ulDmaPosition
                            +   m_ulSampleSize
                            )
                        -   ulFrameAlignment
                        )
                    %   ulDmaBufferSize
                    );
            }
            else
            {
                //
                // Capture:  round down.
                //
                ulDmaPosition -= ulFrameAlignment;
            }
        }

        ASSERT(ulDmaPosition % m_ulSampleSize == 0);

        pIrpStreamPosition->ullStreamPosition +=
            (   (   (   ulDmaBufferSize
                    +   ulDmaPosition
                    )
                -   m_ulDmaComplete
                )
            %   ulDmaBufferSize
            );
    }
    else
    {
        ntStatus = STATUS_UNSUCCESSFUL;
    }

    //
    // Provide physical offset.
    //
    pIrpStreamPosition->ullPhysicalOffset = m_ullStarvationBytes;

    KeReleaseSpinLock(&m_ksSpinLockDpc,kIrqlOld);

    return ntStatus;
}

/*****************************************************************************
 * GetKsAudioPosition()
 *****************************************************************************
 * Gets the current position offsets.
 */
STDMETHODIMP_(NTSTATUS)
CPortPinWaveCyclic::
GetKsAudioPosition
(   OUT     PKSAUDIO_POSITION   pKsAudioPosition
)
{
    ASSERT(pKsAudioPosition);

    //
    // Ask the IrpStream for position information.
    //
    IRPSTREAM_POSITION irpStreamPosition;
    NTSTATUS ntStatus = m_IrpStream->GetPosition(&irpStreamPosition);

    if (NT_SUCCESS(ntStatus))
    {
        if (irpStreamPosition.bLoopedInterface)
        {
            ASSERT(irpStreamPosition.ullStreamPosition >= irpStreamPosition.ullUnmappingPosition);

            //
            // Using looped interface.
            //
            // The play offset is based on the unmapping offset into the
            // packet.  Only ullStreamPosition reflects the port driver's
            // adjustment of the unmapping position, so the difference
            // between this value and the unmapping position must be
            // applied to the offset.
            //
            // WriteOffset is based on the mapping offset into the packet.
            //
            // For looped packets, a modulo is applied to both values.
            // Both offsets can reach the packet size, and the play offset
            // will often exceed it due to the adjustment.  For one-shots,
            // offsets are returned to zero when they reach or exceed the
            // buffer size.  Go figure.
            //
            ULONG ulPlayOffset =
                (   irpStreamPosition.ulUnmappingOffset
                +   ULONG
                    (   irpStreamPosition.ullStreamPosition
                    -   irpStreamPosition.ullUnmappingPosition
                    )
                );

            if (irpStreamPosition.ulUnmappingPacketSize == 0)
            {
                pKsAudioPosition->PlayOffset = 0;
            }
            else
            if (irpStreamPosition.bUnmappingPacketLooped)
            {
                pKsAudioPosition->PlayOffset =
                    (   ulPlayOffset
                    %   irpStreamPosition.ulUnmappingPacketSize
                    );
            }
            else
            {
                if (ulPlayOffset < irpStreamPosition.ulUnmappingPacketSize)
                {
                    pKsAudioPosition->PlayOffset = ulPlayOffset;
                }
                else
                {
                    pKsAudioPosition->PlayOffset = 0;
                }
            }

            //
            // WriteOffset.
            //
            if (irpStreamPosition.ulMappingPacketSize == 0)
            {
                pKsAudioPosition->WriteOffset = 0;
            }
            else
            if (irpStreamPosition.bMappingPacketLooped)
            {
                pKsAudioPosition->WriteOffset =
                    (   irpStreamPosition.ulMappingOffset
                    %   irpStreamPosition.ulMappingPacketSize
                    );
            }
            else
            {
                if  (   irpStreamPosition.ulMappingOffset
                    <   irpStreamPosition.ulMappingPacketSize
                    )
                {
                    pKsAudioPosition->WriteOffset =
                        irpStreamPosition.ulMappingOffset;
                }
                else
                {
                    pKsAudioPosition->WriteOffset = 0;
                }
            }
        }
        else
        {
            //
            // Using standard interface.
            //
            // PlayOffset is based on the 'stream position', which is the
            // unmapping position with an adjustment from the port for
            // better accuracy.  The WriteOffset is the mapping position.
            // In starvation cases, the stream position can exceed the
            // current extent, so we limit the play offset accordingly.
            // Starvation cases can also produce anomolies in which there
            // is retrograde motion, so we fix that too.
            //
            pKsAudioPosition->PlayOffset =
                irpStreamPosition.ullStreamPosition;
            pKsAudioPosition->WriteOffset =
                irpStreamPosition.ullMappingPosition;

            //
            // Make sure we don't go beyond the current extent.
            //
            if
            (   pKsAudioPosition->PlayOffset
            >   irpStreamPosition.ullCurrentExtent
            )
            {
                pKsAudioPosition->PlayOffset =
                    irpStreamPosition.ullCurrentExtent;
            }

            //
            // Never back up.
            //
            if (pKsAudioPosition->PlayOffset < m_ullPlayPosition)
            {
                pKsAudioPosition->PlayOffset = m_ullPlayPosition;
            }
            else
            {
                m_ullPlayPosition = pKsAudioPosition->PlayOffset;
            }
        }
    }

    return ntStatus;
}

/*****************************************************************************
 * PinPropertyPosition()
 *****************************************************************************
 * Handles position property access for the pin.
 */
static
NTSTATUS
PinPropertyPosition
(
    IN      PIRP                pIrp,
    IN      PKSPROPERTY         pKsProperty,
    IN OUT  PKSAUDIO_POSITION   pKsAudioPosition
)
{
    PAGED_CODE();

    NTSTATUS ntStatus;

    ASSERT(pIrp);
    ASSERT(pKsProperty);
    ASSERT(pKsAudioPosition);

    _DbgPrintF(DEBUGLVL_VERBOSE,("PinPropertyPosition"));
    CPortPinWaveCyclic *that =
    (CPortPinWaveCyclic *) KsoGetIrpTargetFromIrp(pIrp);
    ASSERT(that);

    if (pKsProperty->Flags & KSPROPERTY_TYPE_GET)
    {
        ntStatus = that->GetKsAudioPosition(pKsAudioPosition);

        if (NT_SUCCESS(ntStatus))
        {
            pIrp->IoStatus.Information = sizeof(KSAUDIO_POSITION);
        }
    }
    else
    {
        ASSERT(that->m_IrpStream);
        ASSERT(that->m_ulSampleSize);

        ULONGLONG ullOffset = pKsAudioPosition->PlayOffset -
                             (pKsAudioPosition->PlayOffset % that->m_ulSampleSize);

        // We previously raised to DISPATCH_LEVEL around SetPacketOffsets.
        // However, SetPacketOffsets grabs a spinlock first off, so this
        // can't be the whole story.  I believe the reason this code exists
        // is to attempt to synchronize any additional SetPos calls that
        // arrive.  However, this is not necessary since we are already
        // synchronized down at the bottom, at the "HW access".
        //
        ntStatus =
            that->m_IrpStream->SetPacketOffsets
            (
                ULONG(ullOffset),
                ULONG(ullOffset)
            );

        if (NT_SUCCESS(ntStatus))
        {
            that->m_ullPlayPosition = ullOffset;
            that->m_ullPosition     = ullOffset;
            that->m_bSetPosition    = TRUE;
        }
    }
    return ntStatus;
}

#pragma code_seg("PAGE")

/*****************************************************************************
 * PinPropertySetContentId
 *****************************************************************************
 *
 */
static
NTSTATUS
PinPropertySetContentId
(
    IN PIRP        pIrp,
    IN PKSPROPERTY pKsProperty,
    IN PVOID       pvData
)
{
    PAGED_CODE();

    ULONG ContentId;
    NTSTATUS ntStatus;

    ASSERT(pIrp);
    ASSERT(pKsProperty);
    ASSERT(pvData);

    _DbgPrintF(DEBUGLVL_VERBOSE,("WaveCyc: PinPropertySetContentId"));
    if (KernelMode == pIrp->RequestorMode)
    {
        CPortPinWaveCyclic *that = (CPortPinWaveCyclic *) KsoGetIrpTargetFromIrp(pIrp);
        ASSERT(that);

        ContentId = *(PULONG)pvData;
        ntStatus = DrmForwardContentToStream(ContentId, that->m_Stream);
    }
    else
    {
        ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    }
    return ntStatus;
}

/*****************************************************************************
 * PinAddEvent_Position()
 *****************************************************************************
 * Enables the position pin event.
 */
static
NTSTATUS
PinAddEvent_Position
(
    IN      PIRP                                    pIrp,
    IN      PLOOPEDSTREAMING_POSITION_EVENT_DATA    pPositionEventData,
    IN      PPOSITION_EVENT_ENTRY                   pPositionEventEntry
)
{
    PAGED_CODE();

    ASSERT(pIrp);
    ASSERT(pPositionEventData);
    ASSERT(pPositionEventEntry);

    _DbgPrintF(DEBUGLVL_VERBOSE,("PinEventEnablePosition"));
    CPortPinWaveCyclic *that =
        (CPortPinWaveCyclic *) KsoGetIrpTargetFromIrp(pIrp);
    ASSERT(that);

    //
    // Copy the position information.
    //
    pPositionEventEntry->EventType = PositionEvent;
    pPositionEventEntry->ullPosition = pPositionEventData->Position;

    //
    // Add the entry to the list.
    //
    that->m_Port->AddEventToEventList( &(pPositionEventEntry->EventEntry) );

    return STATUS_SUCCESS;
}

NTSTATUS
CPortPinWaveCyclic::AddEndOfStreamEvent(
    IN PIRP Irp,
    IN PKSEVENTDATA EventData,
    IN PENDOFSTREAM_EVENT_ENTRY EndOfStreamEventEntry
    )

/*++

Routine Description:
    Handler for "add event" of end of stream events.

Arguments:
    IN PIRP Irp -
        I/O request packet

    IN PKSEVENTDATA EventData -
        pointer to event data

    IN PENDOFSTREAM_EVENT_ENTRY EndOfStreamEventEntry -
        event entry

Return:

--*/

{
    CPortPinWaveCyclic  *PinWaveCyclic;

    PAGED_CODE();

    ASSERT(Irp);
    ASSERT(EventData);
    ASSERT(EndOfStreamEventEntry);

    _DbgPrintF(DEBUGLVL_VERBOSE,("AddEndOfStreamEvent"));

    PinWaveCyclic =
        (CPortPinWaveCyclic *) KsoGetIrpTargetFromIrp( Irp );
    ASSERT( PinWaveCyclic );

    EndOfStreamEventEntry->EventType = EndOfStreamEvent;

    //
    // Add the entry to the list.
    //
    PinWaveCyclic->m_Port->AddEventToEventList( &(EndOfStreamEventEntry->EventEntry) );

    return STATUS_SUCCESS;
}

#pragma code_seg()

void
CPortPinWaveCyclic::GenerateClockEvents(
    void
    )

/*++

Routine Description:
    Walks the list of children clock objects and requests
    a clock event update.

Arguments:
    None.

Return:
    Nothing.

--*/

{
    PWAVECYCLICCLOCK_NODE   ClockNode;
    PLIST_ENTRY             ListEntry;

    if (!IsListEmpty(&m_ClockList)) {

        KeAcquireSpinLockAtDpcLevel( &m_ClockListLock );

        for (ListEntry = m_ClockList.Flink;
            ListEntry != &m_ClockList;
            ListEntry = ListEntry->Flink) {

            ClockNode =
                (PWAVECYCLICCLOCK_NODE)
                    CONTAINING_RECORD( ListEntry,
                                       WAVECYCLICCLOCK_NODE,
                                       ListEntry);
            ClockNode->IWaveCyclicClock->GenerateEvents( ClockNode->FileObject );
        }

        KeReleaseSpinLockFromDpcLevel( &m_ClockListLock );

    }

}

void
CPortPinWaveCyclic::GenerateEndOfStreamEvents(
    void
    )
{
    KIRQL                       irqlOld;
    PENDOFSTREAM_EVENT_ENTRY    EndOfStreamEventEntry;
    PLIST_ENTRY                 ListEntry;

    if (!IsListEmpty( &(m_Port->m_EventList.List) )) {

        KeAcquireSpinLock( &(m_Port->m_EventList.ListLock), &irqlOld );

        for (ListEntry = m_Port->m_EventList.List.Flink;
             ListEntry != &(m_Port->m_EventList.List);) {
            EndOfStreamEventEntry =
                CONTAINING_RECORD(
                    ListEntry,
                    ENDOFSTREAM_EVENT_ENTRY,
                    EventEntry.ListEntry );

            ListEntry = ListEntry->Flink;

            //
            // Generate the end of stream event if the event type
            // is correct.
            //

            if (EndOfStreamEventEntry->EventType == EndOfStreamEvent) {
                KsGenerateEvent( &EndOfStreamEventEntry->EventEntry );
            }
        }

        KeReleaseSpinLock( &(m_Port->m_EventList.ListLock), irqlOld );
    }
}


/*****************************************************************************
 * GeneratePositionEvents()
 *****************************************************************************
 * Generates position events.
 */
void
CPortPinWaveCyclic::
GeneratePositionEvents
(   void
)
{
    if (! IsListEmpty(&(m_Port->m_EventList.List)))
    {
        KSAUDIO_POSITION ksAudioPosition;

        if (NT_SUCCESS(GetKsAudioPosition(&ksAudioPosition)))
        {
            ULONGLONG ullPosition = ksAudioPosition.PlayOffset;

            KeAcquireSpinLockAtDpcLevel(&(m_Port->m_EventList.ListLock));

            for
            (
                PLIST_ENTRY pListEntry = m_Port->m_EventList.List.Flink;
                pListEntry != &(m_Port->m_EventList.List);
            )
            {
                PPOSITION_EVENT_ENTRY pPositionEventEntry =
                    CONTAINING_RECORD
                    (
                        pListEntry,
                        POSITION_EVENT_ENTRY,
                        EventEntry.ListEntry
                    );

                pListEntry = pListEntry->Flink;

                //
                // Generate an event if its in the interval.
                //
                if
                (   (pPositionEventEntry->EventType == PositionEvent)
                &&  (   (m_ullPosition <= ullPosition)
                    ?   (   (pPositionEventEntry->ullPosition >= m_ullPosition)
                        &&  (pPositionEventEntry->ullPosition < ullPosition)
                        )
                    :   (   (pPositionEventEntry->ullPosition >= m_ullPosition)
                        ||  (pPositionEventEntry->ullPosition < ullPosition)
                        )
                    )
                )
                {
                    KsGenerateEvent(&pPositionEventEntry->EventEntry);
                }
            }

            KeReleaseSpinLockFromDpcLevel(&(m_Port->m_EventList.ListLock));

            m_ullPosition = ullPosition;
        }
    }
}


STDMETHODIMP_( LONGLONG )
CPortPinWaveCyclic::GetCycleCount( VOID )

/*++

Routine Description:
    Synchronizes with DPC to return the current 64-bit count of cycles.

Arguments:
    None.

Return:
    Cycle count.

--*/

{
    LONGLONG Cycles;
    KIRQL   irqlOld;

    KeAcquireSpinLock( &m_ksSpinLockDpc, &irqlOld );
    Cycles = m_ulDmaCycles;
    KeReleaseSpinLock( &m_ksSpinLockDpc, irqlOld );

    return Cycles;
}

STDMETHODIMP_( ULONG )
CPortPinWaveCyclic::GetCompletedPosition( VOID )

/*++

Routine Description:
    Synchronizes with DPC to return the completed DMA position.

Arguments:
    None.

Return:
    Last completed DMA position.

--*/

{
    ULONG   Position;
    KIRQL   irqlOld;

    KeAcquireSpinLock( &m_ksSpinLockDpc, &irqlOld );
    Position = m_ulDmaComplete;
    KeReleaseSpinLock( &m_ksSpinLockDpc, irqlOld );

    return Position;
}


/*****************************************************************************
 * CPortPinWaveCyclic::Copy()
 *****************************************************************************
 * Copy to or from locked-down memory.
 */
void
CPortPinWaveCyclic::
Copy
(
    IN      BOOLEAN     WriteOperation,
    IN      ULONG       RequestedSize,
    OUT     PULONG      ActualSize,
    IN OUT  PVOID       Buffer
)
{
    ASSERT(ActualSize);
    ASSERT(Buffer);

    PBYTE buffer    = PBYTE(Buffer);
    ULONG remaining = RequestedSize;

    ULONG loopMax = 10000;
    while (remaining)
    {
        ASSERT(loopMax--);
        ULONG   byteCount;
        PVOID   systemAddress;

        m_IrpStream->GetLockedRegion
        (
            &byteCount,
            &systemAddress
        );

        if (! byteCount)
        {
            break;
        }

        if (byteCount > remaining)
        {
            byteCount = remaining;
        }

        if (WriteOperation)
        {
            m_DmaChannel->CopyTo(PVOID(buffer),systemAddress,byteCount);
        }
        else
        {
            m_DmaChannel->CopyFrom(systemAddress,PVOID(buffer),byteCount);
        }

        m_IrpStream->ReleaseLockedRegion(byteCount);

        buffer      += byteCount;
        remaining   -= byteCount;
    }

    *ActualSize = RequestedSize - remaining;
}

#pragma code_seg("PAGE")

/*****************************************************************************
 * CPortPinWaveCyclic::PowerNotify()
 *****************************************************************************
 * Called by the port to notify of power state changes.
 */
STDMETHODIMP_(void)
CPortPinWaveCyclic::
PowerNotify
(
    IN  POWER_STATE     PowerState
)
{
    PAGED_CODE();

    // grap the control mutex
    KeWaitForSingleObject( &m_Port->ControlMutex,
                           Executive,
                           KernelMode,
                           FALSE,
                           NULL );

    // do the right thing based on power state
    switch (PowerState.DeviceState)
    {
        case PowerDeviceD0:
            //
            // keep track of whether or not we're suspended
            m_Suspended = FALSE;

            // if we're not in the right state, change the miniport stream state.
            if( m_DeviceState != m_CommandedState )
            {
                //
                // Transitions go through the intermediate states.
                //
                if (m_DeviceState == KSSTATE_STOP)               //  going to stop
                {
                    switch (m_CommandedState)
                    {
                        case KSSTATE_RUN:                        //  going from run
                            m_Stream->SetState(KSSTATE_PAUSE);   //  fall thru - additional transitions
                        case KSSTATE_PAUSE:                      //  going from run/pause
                            m_Stream->SetState(KSSTATE_ACQUIRE); //  fall thru - additional transitions
                        case KSSTATE_ACQUIRE:                    //  already only one state away
                            break;
                    }
                }
                else if (m_DeviceState == KSSTATE_ACQUIRE)       //  going to acquire
                {
                    if (m_CommandedState == KSSTATE_RUN)         //  going from run
                    {
                        m_Stream->SetState(KSSTATE_PAUSE);       //  now only one state away
                    }
                }
                else if (m_DeviceState == KSSTATE_PAUSE)         //  going to pause
                {
                    if (m_CommandedState == KSSTATE_STOP)        //  going from stop
                    {
                        m_Stream->SetState(KSSTATE_ACQUIRE);     //  now only one state away
                    }
                }
                else if (m_DeviceState == KSSTATE_RUN)           //  going to run
                {
                    switch (m_CommandedState)
                    {
                        case KSSTATE_STOP:                       //  going from stop
                            m_Stream->SetState(KSSTATE_ACQUIRE); //  fall thru - additional transitions
                        case KSSTATE_ACQUIRE:                    //  going from acquire
                            m_Stream->SetState(KSSTATE_PAUSE);   //  fall thru - additional transitions
                        case KSSTATE_PAUSE:                      //  already only one state away
                            break;
                    }
                }

                // we should now be one state away from our target
                m_Stream->SetState(m_DeviceState);
                m_CommandedState = m_DeviceState;

                // register I/O timeouts
                SetupIoTimeouts( TRUE );
             }
            break;

        case PowerDeviceD1:
        case PowerDeviceD2:
        case PowerDeviceD3:

            // unregister I/O timeouts
            SetupIoTimeouts( FALSE );
            //
            // keep track of whether or not we're suspended
            m_Suspended = TRUE;

            // if we're not in KSSTATE_STOP, place the stream
            // in the stop state so that DMA is stopped.
            switch (m_DeviceState)
            {
                case KSSTATE_RUN:
                    m_Stream->SetState(KSSTATE_PAUSE);    //  fall thru - additional transitions
                case KSSTATE_PAUSE:
                    m_Stream->SetState(KSSTATE_ACQUIRE);  //  fall thru - additional transitions
                case KSSTATE_ACQUIRE:
                    m_Stream->SetState(KSSTATE_STOP);
            }
            m_CommandedState = KSSTATE_STOP;
            break;

        default:
            _DbgPrintF(DEBUGLVL_TERSE,("Unknown Power State"));
            break;
    }

    // release the control mutex
    KeReleaseMutex(&m_Port->ControlMutex, FALSE);
}

#pragma code_seg()

/*****************************************************************************
 * CPortPinWaveCyclic::RequestService()
 *****************************************************************************
 * Writes up to the current position.
 */
STDMETHODIMP_(void)
CPortPinWaveCyclic::
RequestService
(   void
)
{
    ULONG LogGlitch = PERFGLITCH_PORTCLSOK;
    ULONG LogDMAGlitch = PERFGLITCH_PORTCLSOK;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    // zero the "SecondsSinceLastDpc" timeout count
    InterlockedExchange( PLONG(&m_SecondsSinceLastDpc), 0 );

    //
    // Return right away if we haven't finished Init() or if we are in
    // the STOP state or if we are not in the RUN state and we didn't
    // just get sent an IRP.

    if ((!m_bInitCompleted) ||
        (KSSTATE_STOP == m_DeviceState) ||
        ((KSSTATE_RUN != m_DeviceState) && (!m_bJustReceivedIrp))
        )
    {
        return;
    }

    m_bJustReceivedIrp = FALSE;

    //
    // We