as fired since we set it up.
    DWORD res = WaitForSingleObject( m_hRegEvent, 
                                     0 );   // timeout for wait
    if (res == WAIT_TIMEOUT)
    {
        // Wait timed out => the reg key sub-tree has not changed
        // Our cache is up to date.
        bUptodate = TRUE;
    }
    else if (res == WAIT_OBJECT_0)
    {
        // Some CLSID must have changed => cache not up to date.
        bUptodate = FALSE;

        // We have to re-Register for the notification!
        ResetEvent(m_hRegEvent);
        res = RegNotifyChangeKeyValue(  m_hRegKey, 
                                        TRUE,   // watch sub-tree
                                        REG_NOTIFY_CHANGE_NAME 
                                      | REG_NOTIFY_CHANGE_LAST_SET,
                                        m_hRegEvent, 
                                        TRUE ); // asynchronous call                                        
        if (res != ERROR_SUCCESS)
        {
            // Cache is useless if we cannot watch CLSID sub-tree.
            gbOKToUseCache = FALSE;
        }
    }
    else
    {
        OleDbgAssert(!"Unexpected return from WaitForSingleObject");
        bUptodate = FALSE;
    }
    return bUptodate;
}


//+-------------------------------------------------------------------------
//
//  Method:     CStringCache::AddString, Public
//
//  Synopsis:   Called to notify the cache of a fresh OleUIInsertObject call
//
//  Parameters: [lpStrAdd]  -   String to add to the cache.
//
//  History:    02-May-99   MPrabhu       Created
//
//+-------------------------------------------------------------------------    
BOOL CStringCache::AddString(LPTSTR lpStrAdd)
{
    if (m_ulStringCount+2 == m_ulMaxStringCount)
    {
        // The offset array stores the offset of all the existing strings and
        // the next one to be added!
        // Hence at start of AddString, we must have enough space for the new
        // string being added *and* the next one (hence the +2 above)
        if (!ExpandOffsetTable())
        {
            // Something is really wrong.
            // Mark the cache as useless hereafter.
            gbOKToUseCache = FALSE;
            return FALSE;
        }
    }

    ULONG cbStrAdd = sizeof(TCHAR)*(lstrlen(lpStrAdd) + 1);
    ULONG offset = m_pOffsetTable[m_ulStringCount];

    if ( offset + cbStrAdd > m_ulMaxBytes )
    {
        // not enough space in the string block
        if (!ExpandStringTable())
        {
            // Something is really wrong.
            // Mark the cache as useless hereafter.
            gbOKToUseCache = FALSE;
            return FALSE;
        }
    }

    if (! lstrcpy( (TCHAR *)(m_pStrings+offset), lpStrAdd))
    {
        // Mark the cache as useless hereafter.
        gbOKToUseCache = FALSE;
        return FALSE;
    }

    // We have successfully added one more string to the cache.
    m_ulStringCount++;
    
    // Next string goes at this byte offset in m_pStrings.
    m_pOffsetTable[m_ulStringCount] =  offset + cbStrAdd;
    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Method:     CStringCache::NextString, Public
//
//  Synopsis:   Used to obtain a pointer to the next string during
//              during cache enumeration.
//
//  History:    02-May-99   MPrabhu       Created
//
//+-------------------------------------------------------------------------    
LPCTSTR CStringCache::NextString()
{
    if (m_ulNextStringNum > m_ulStringCount)
    {
        return NULL;
    }
    return (LPCTSTR) (m_pStrings+m_pOffsetTable[m_ulNextStringNum++-1]);
}

//+-------------------------------------------------------------------------
//
//  Method:     CStringCache::ResetEnumerator, Public
//
//  Synopsis:   Used to reset the enumerator.
//
//  History:    02-May-99   MPrabhu       Created
//
//+-------------------------------------------------------------------------    
void CStringCache::ResetEnumerator()
{
    m_ulNextStringNum = 1;
}

//+-------------------------------------------------------------------------
//
//  Method:     CStringCache::FlushCache, Public
//
//  Synopsis:   Invalidates the cache by clearing the counters.
//
//  History:    02-May-99   MPrabhu       Created
//
//+-------------------------------------------------------------------------    
BOOL CStringCache::FlushCache()
{
    m_ulNextStringNum = 1;
    m_ulStringCount = 0;
    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Method:     CStringCache::OKToUse, Public
//
//  Synopsis:   Used to check if cache is in good shape.
//
//  History:    02-May-99   MPrabhu       Created
//
//+-------------------------------------------------------------------------    
BOOL CStringCache::OKToUse()
{
    return gbOKToUseCache;
}

#endif // USE_STRING_CACHE==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole2ui32\uiclass.h ===
#define SZCLASSICONBOX1  "OLE2UIiconbox"
#define SZCLASSICONBOX2  "MFCUIA32iconbox"
#define SZCLASSICONBOX3  "MFCUIW32iconbox"
#define SZCLASSRESULTIMAGE1 "OLE2UIresimage"
#define SZCLASSRESULTIMAGE2 "MFCUIA32resimage"
#define SZCLASSRESULTIMAGE3 "MFCUIW32resimage"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole2ui32\targtdev.cpp ===
/*************************************************************************
**
**    OLE 2 Standard Utilities
**
**    olestd.c
**
**    This file contains utilities that are useful for dealing with
**    target devices.
**
**    (c) Copyright Microsoft Corp. 1992 All Rights Reserved
**
*************************************************************************/

#include "precomp.h"

STDAPI_(BOOL) OleStdCompareTargetDevice(
        DVTARGETDEVICE* ptdLeft, DVTARGETDEVICE* ptdRight)
{
        if (ptdLeft == ptdRight)
                // same address of td; must be same (handles NULL case)
                return TRUE;
        else if ((ptdRight == NULL) || (ptdLeft == NULL))
                return FALSE;
        else if (ptdLeft->tdSize != ptdRight->tdSize)
                // different sizes, not equal
                return FALSE;
        else if (memcmp(ptdLeft, ptdRight, ptdLeft->tdSize) != 0)
                // not same target device, not equal
                return FALSE;

        return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole2ui32\template.cpp ===
/*
 * TEMPLATE.CPP
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 *
 *
 * CUSTOMIZATION INSTRUCTIONS:
 *
 *  1.  Replace <FILE> with the uppercased filename for this file.
 *      Lowercase the <FILE>.h entry
 *
 *  2.  Replace <NAME> with the mixed case dialog name in one word,
 *      such as InsertObject
 *
 *  3.  Replace <FULLNAME> with the mixed case dialog name in multiple
 *      words, such as Insert Object
 *
 *  4.  Replace <ABBREV> with the suffix for pointer variables, such
 *      as the IO in InsertObject's pIO or the CI in ChangeIcon's pCI.
 *      Check the alignment of the first variable declaration in the
 *      Dialog Proc after this.  I will probably be misaligned with the
 *      rest of the variables.
 *
 *  5.  Replace <STRUCT> with the uppercase structure name for this
 *      dialog sans OLEUI, such as INSERTOBJECT.  Changes OLEUI<STRUCT>
 *      in most cases, but we also use this for IDD_<STRUCT> as the
 *      standard template resource ID.
 *
 *  6.  Find <UFILL> fields and fill them out with whatever is appropriate.
 *
 *  7.  Delete this header up to the start of the next comment.
 */


/*
 * <FILE>.CPP
 *
 * Implements the OleUI<NAME> function which invokes the complete
 * <FULLNAME> dialog.
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */

#include "precomp.h"
#include "common.h"

#include "template.h"

/*
 * OleUI<NAME>
 *
 * Purpose:
 *  Invokes the standard OLE <FULLNAME> dialog box allowing the user
 *  to <UFILL>
 *
 * Parameters:
 *  lp<ABBREV>            LPOLEUI<NAME> pointing to the in-out structure
 *                  for this dialog.
 *
 * Return Value:
 *  UINT            One of the following codes, indicating success or error:
 *                      OLEUI_SUCCESS           Success
 *                      OLEUI_ERR_STRUCTSIZE    The dwStructSize value is wrong
 */

STDAPI_(UINT) OleUI<NAME>(LPOLEUI<STRUCT> lp<ABBREV>)
{
        UINT        uRet;
        HGLOBAL     hMemDlg=NULL;

        uRet = UStandardValidation((LPOLEUISTANDARD)lp<ABBREV>,
                sizeof(OLEUI<STRUCT>), &hMemDlg);

        if (OLEUI_SUCCESS!=uRet)
                return uRet;

        /*
         * PERFORM ANY STRUCTURE-SPECIFIC VALIDATION HERE!
         * ON FAILURE:
         *  {
         *  return OLEUI_<ABBREV>ERR_<ERROR>
         *  }
         */

        //Now that we've validated everything, we can invoke the dialog.
        uRet = UStandardInvocation(<NAME>DialogProc, (LPOLEUISTANDARD)lp<ABBREV>
                                                         , hMemDlg, MAKEINTRESOURCE(IDD_<STRUCT>));

        /*
         * IF YOU ARE CREATING ANYTHING BASED ON THE RESULTS, DO IT HERE.
         */
        <UFILL>

        return uRet;
}

/*
 * <NAME>DialogProc
 *
 * Purpose:
 *  Implements the OLE <FULLNAME> dialog as invoked through the
 *  OleUI<NAME> function.
 *
 * Parameters:
 *  Standard
 *
 * Return Value:
 *  Standard
 */

BOOL CALLBACK <NAME>DialogProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
        P<STRUCT>               p<ABBREV>;
        BOOL                    fHook=FALSE;

        //Declare Win16/Win32 compatible WM_COMMAND parameters.
        COMMANDPARAMS(wID, wCode, hWndMsg);

        //This will fail under WM_INITDIALOG, where we allocate it.
        p<ABBREV>=(<STRUCT>)PvStandardEntry(hDlg, iMsg, wParam, lParam, &uHook);

        //If the hook processed the message, we're done.
        if (0!=uHook)
                return (BOOL)uHook;

        //Process the temination message
        if (iMsg==uMsgEndDialog)
        {
                EndDialog(hDlg, wParam);
                return TRUE;
        }

        switch (iMsg)
        {
        case WM_DESTROY:
            if (p<ABBREV>)
            {
                //Free any specific allocations before calling StandardCleanup
                StandardCleanup((PVOID)p<ABBREV>, hDlg);
            }
            break;
        case WM_INITDIALOG:
                F<NAME>Init(hDlg, wParam, lParam);
                return TRUE;

        case WM_COMMAND:
                switch (wID)
                {
                case IDOK:
                        /*
                         * PERFORM WHATEVER FUNCTIONS ARE DEFAULT HERE.
                         */
                        SendMessage(hDlg, uMsgEndDialog, OLEUI_OK, 0L);
                        break;

                case IDCANCEL:
                        /*
                         * PERFORM ANY UNDOs HERE, BUT NOT CLEANUP THAT WILL
                         * ALWAYS HAPPEN WHICH SHOULD BE IN uMsgEndDialog.
                         */
                        SendMessage(hDlg, uMsgEndDialog, OLEUI_CANCEL, 0L);
                        break;

                case ID_OLEUIHELP:
                        PostMessage(p<ABBREV>->lpO<ABBREV>->hWndOwner, uMsgHelp
                                                , (WPARAM)hDlg, MAKELPARAM(IDD_<STRUCT>, 0));
                        break;
                }
        break;
        }
        return FALSE;
}


/*
 * F<NAME>Init
 *
 * Purpose:
 *  WM_INITIDIALOG handler for the <FULLNAME> dialog box.
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  wParam          WPARAM of the message
 *  lParam          LPARAM of the message
 *
 * Return Value:
 *  BOOL            Value to return for WM_INITDIALOG.
 */

BOOL F<NAME>Init(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
        P<STRUCT>               p<ABBREV>;
        LPOLEUI<STRUCT>         lpO<ABBREV>;
        HFONT                   hFont;

        //1.  Copy the structure at lParam into our instance memory.
        p<ABBREV>=(PSTRUCT)PvStandardInit(hDlg, sizeof(<STRUCT>), TRUE, &hFont);

        //PvStandardInit send a termination to us already.
        if (NULL==p<ABBREV>)
                return FALSE;

        lpO<ABBREV>=(LPOLEUI<STRUCT>)lParam);

        p<ABBREV>->lpO<ABBREV>=lpO<ABBREV>;

        //Copy other information from lpO<ABBREV> that we might modify.
        <UFILL>

        //2.  If we got a font, send it to the necessary controls.
        if (NULL!=hFont)
        {
                //Do this for as many controls as you need it for.
                SendDlgItemMessage(hDlg, ID_<UFILL>, WM_SETFONT, (WPARAM)hFont, 0L);
        }

        //3.  Show or hide the help button
        if (!(p<ABBREV>->lpO<ABBREV>->dwFlags & <ABBREV>F_SHOWHELP))
                StandardShowDlgItem(hDlg, ID_OLEUIHELP, SW_HIDE);

        /*
         * PERFORM OTHER INITIALIZATION HERE.  ON ANY LoadString
         * FAILURE POST OLEUI_MSG_ENDDIALOG WITH OLEUI_ERR_LOADSTRING.
         */

        //n.  Call the hook with lCustData in lParam
        UStandardHook((PVOID)p<ABBREV>, hDlg, WM_INITDIALOG, wParam, lpO<ABBREV>->lCustData);
        return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole2ui32\utility.cpp ===
/*
 * UTILITY.CPP
 *
 * Utility routines for functions inside OLEDLG.DLL
 *
 *  General:
 *  ----------------------
 *  HourGlassOn             Displays the hourglass
 *  HourGlassOff            Hides the hourglass
 *
 *  Misc Tools:
 *  ----------------------
 *  Browse                  Displays the "File..." or "Browse..." dialog.
 *  ReplaceCharWithNull     Used to form filter strings for Browse.
 *  ErrorWithFile           Creates an error message with embedded filename
 *  OpenFileError           Give error message for OpenFile error return
 *  ChopText                Chop a file path to fit within a specified width
 *  DoesFileExist           Checks if file is valid
 *
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */

#include "precomp.h"
#include "common.h"
#include <stdlib.h>
#include <commdlg.h>
#include <memory.h>
#include <cderr.h>
#include "utility.h"

OLEDBGDATA

/*
 * HourGlassOn
 *
 * Purpose:
 *  Shows the hourglass cursor returning the last cursor in use.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HCURSOR         Cursor in use prior to showing the hourglass.
 */

HCURSOR WINAPI HourGlassOn(void)
{
        HCURSOR     hCur;

        hCur=SetCursor(LoadCursor(NULL, IDC_WAIT));
        ShowCursor(TRUE);

        return hCur;
}


/*
 * HourGlassOff
 *
 * Purpose:
 *  Turns off the hourglass restoring it to a previous cursor.
 *
 * Parameters:
 *  hCur            HCURSOR as returned from HourGlassOn
 *
 * Return Value:
 *  None
 */

void WINAPI HourGlassOff(HCURSOR hCur)
{
        ShowCursor(FALSE);
        SetCursor(hCur);
        return;
}


/*
 * Browse
 *
 * Purpose:
 *  Displays the standard GetOpenFileName dialog with the title of
 *  "Browse."  The types listed in this dialog are controlled through
 *  iFilterString.  If it's zero, then the types are filled with "*.*"
 *  Otherwise that string is loaded from resources and used.
 *
 * Parameters:
 *  hWndOwner       HWND owning the dialog
 *  lpszFile        LPSTR specifying the initial file and the buffer in
 *                  which to return the selected file.  If there is no
 *                  initial file the first character of this string should
 *                  be NULL.
 *  lpszInitialDir  LPSTR specifying the initial directory.  If none is to
 *                  set (ie, the cwd should be used), then this parameter
 *                  should be NULL.
 *  cchFile         UINT length of pszFile
 *  iFilterString   UINT index into the stringtable for the filter string.
 *  dwOfnFlags      DWORD flags to OR with OFN_HIDEREADONLY
 *  nBrowseID
 *  lpfnHook        Callback Hook Proceedure.  Set if OFN_ENABLE_HOOK is
 *                  in dwOfnFlags else it should be NULL.
 *
 * Return Value:
 *  BOOL            TRUE if the user selected a file and pressed OK.
 *                  FALSE otherwise, such as on pressing Cancel.
 */

BOOL WINAPI Browse(HWND hWndOwner, LPTSTR lpszFile, LPTSTR lpszInitialDir, UINT cchFile,
        UINT iFilterString, DWORD dwOfnFlags, UINT nBrowseID, LPOFNHOOKPROC lpfnHook)
{
        UINT    cch;
        TCHAR   szFilters[256];
        TCHAR   szDlgTitle[128];  // that should be big enough

        if (NULL == lpszFile || 0 == cchFile)
                return FALSE;

        /*
         * Exact contents of the filter combobox is TBD.  One idea
         * is to take all the extensions in the RegDB and place them in here
         * with the descriptive class name associate with them.  This has the
         * extra step of finding all extensions of the same class handler and
         * building one extension string for all of them.  Can get messy quick.
         * UI demo has only *.* which we do for now.
         */

        if (0 != iFilterString)
        {
                cch = LoadString(_g_hOleStdResInst, iFilterString, szFilters,
                        sizeof(szFilters)/sizeof(TCHAR));
        }
        else
        {
                szFilters[0] = 0;
                cch = 1;
        }

        if (0 == cch)
                return FALSE;

        ReplaceCharWithNull(szFilters, szFilters[cch-1]);

        // Prior string must also be initialized, if there is one.
        OPENFILENAME ofn;
        memset(&ofn, 0, sizeof(ofn));
        ofn.lStructSize = sizeof(ofn);
        ofn.hwndOwner   = hWndOwner;
        ofn.lpstrFile   = lpszFile;
        ofn.nMaxFile    = cchFile;
        ofn.lpstrFilter = szFilters;
        ofn.nFilterIndex = 1;
        ofn.lpfnHook = lpfnHook;
        if (LoadString(_g_hOleStdResInst, IDS_BROWSE, szDlgTitle, sizeof(szDlgTitle)/sizeof(TCHAR)))
                ofn.lpstrTitle  = szDlgTitle;
        ofn.hInstance = _g_hOleStdResInst;
        if (NULL != lpszInitialDir)
                ofn.lpstrInitialDir = lpszInitialDir;
        ofn.Flags = OFN_HIDEREADONLY | dwOfnFlags;
        if (bWin4)
            ofn.Flags |= OFN_EXPLORER;

        // Lastly, parent to tweak OFN parameters
        if (hWndOwner != NULL)
                SendMessage(hWndOwner, uMsgBrowseOFN, nBrowseID, (LPARAM)&ofn);

        // On success, copy the chosen filename to the static display
        BOOL bResult = StandardGetOpenFileName((LPOPENFILENAME)&ofn);
        return bResult;
}

/*
 * ReplaceCharWithNull
 *
 * Purpose:
 *  Walks a null-terminated string and replaces a given character
 *  with a zero.  Used to turn a single string for file open/save
 *  filters into the appropriate filter string as required by the
 *  common dialog API.
 *
 * Parameters:
 *  psz             LPTSTR to the string to process.
 *  ch              int character to replace.
 *
 * Return Value:
 *  int             Number of characters replaced.  -1 if psz is NULL.
 */

int WINAPI ReplaceCharWithNull(LPTSTR psz, int ch)
{
        int cChanged = 0;

        if (psz == NULL)
                return -1;

        while ('\0' != *psz)
        {
                if (ch == *psz)
                {
                        *psz++ = '\0';
                        cChanged++;
                        continue;
                }
                psz = CharNext(psz);
        }
        return cChanged;
}

/*
 * ErrorWithFile
 *
 * Purpose:
 *  Displays a message box built from a stringtable string containing
 *  one %s as a placeholder for a filename and from a string of the
 *  filename to place there.
 *
 * Parameters:
 *  hWnd            HWND owning the message box.  The caption of this
 *                  window is the caption of the message box.
 *  hInst           HINSTANCE from which to draw the idsErr string.
 *  idsErr          UINT identifier of a stringtable string containing
 *                  the error message with a %s.
 *  lpszFile        LPSTR to the filename to include in the message.
 *  uFlags          UINT flags to pass to MessageBox, like MB_OK.
 *
 * Return Value:
 *  int             Return value from MessageBox.
 */

int WINAPI ErrorWithFile(HWND hWnd, HINSTANCE hInst, UINT idsErr,
        LPTSTR pszFile, UINT uFlags)
{
        int             iRet=0;
        HANDLE          hMem;
        const UINT      cb = (2*MAX_PATH);
        LPTSTR          psz1, psz2, psz3;

        if (NULL == hInst || NULL == pszFile)
                return iRet;

        // Allocate three 2*MAX_PATH byte work buffers
        hMem=GlobalAlloc(GHND, (DWORD)(3*cb)*sizeof(TCHAR));

        if (NULL==hMem)
                return iRet;

        psz1 = (LPTSTR)GlobalLock(hMem);
        psz2 = psz1+cb;
        psz3 = psz2+cb;

        if (0 != LoadString(hInst, idsErr, psz1, cb))
        {
                wsprintf(psz2, psz1, pszFile);

                // Steal the caption of the dialog
                GetWindowText(hWnd, psz3, cb);
                iRet=MessageBox(hWnd, psz2, psz3, uFlags);
        }

        GlobalUnlock(hMem);
        GlobalFree(hMem);
        return iRet;
}

// returns width of line of text. this is a support routine for ChopText
static LONG GetTextWSize(HDC hDC, LPTSTR lpsz)
{
        SIZE size;

        if (GetTextExtentPoint(hDC, lpsz, lstrlen(lpsz), (LPSIZE)&size))
                return size.cx;
        else
                return 0;
}

LPTSTR FindChar(LPTSTR lpsz, TCHAR ch)
{
        while (*lpsz != 0)
        {
                if (*lpsz == ch)
                        return lpsz;
                lpsz = CharNext(lpsz);
        }
        return NULL;
}

LPTSTR FindReverseChar(LPTSTR lpsz, TCHAR ch)
{
        LPTSTR lpszLast = NULL;
        while (*lpsz != 0)
        {
                if (*lpsz == ch)
                        lpszLast = lpsz;
                lpsz = CharNext(lpsz);
        }
        return lpszLast;
}

static void WINAPI Abbreviate(HDC hdc, int nWidth, LPTSTR lpch, int nMaxChars)
{
        /* string is too long to fit; chop it */
        /* set up new prefix & determine remaining space in control */
        LPTSTR lpszFileName = NULL;
        LPTSTR lpszCur = CharNext(CharNext(lpch));
        lpszCur = FindChar(lpszCur, TEXT('\\'));

        // algorithm will insert \... so allocate extra 4
        LPTSTR lpszNew = (LPTSTR)OleStdMalloc((lstrlen(lpch)+5) * sizeof(TCHAR));
        if (lpszNew == NULL)
                return;

        if (lpszCur != NULL)  // at least one backslash
        {
                *lpszNew = (TCHAR)0;
                *lpszCur = (TCHAR)0;
                lstrcpy(lpszNew, lpch);
                *lpszCur = TEXT('\\');
                // lpszNew now contains c: or \\servername
                lstrcat(lpszNew, TEXT("\\..."));
                // lpszNew now contains c:\... or \\servername\...
                LPTSTR lpszEnd = lpszNew;
                while (*lpszEnd != (TCHAR)0)
                        lpszEnd = CharNext(lpszEnd);
                // lpszEnd is now at the end of c:\... or \\servername\...

                // move down directories until it fits or no more directories
                while (lpszCur != NULL)
                {
                        *lpszEnd = (TCHAR)0;
                        lstrcat(lpszEnd, lpszCur);
                        if (GetTextWSize(hdc, lpszNew) <= nWidth &&
                                lstrlen(lpszNew) < nMaxChars)
                        {
                                lstrcpyn(lpch, lpszNew, nMaxChars);
                                OleStdFree(lpszNew);
                                return;
                        }
                        lpszCur = CharNext(lpszCur);    // advance past backslash
                        lpszCur = FindChar(lpszCur, TEXT('\\'));
                }

                // try just ...filename and then shortening filename
                lpszFileName = FindReverseChar(lpch, TEXT('\\'));
        }
        else
                lpszFileName = lpch;

        while (*lpszFileName != (TCHAR)0)
        {
                lstrcpy(lpszNew, TEXT("..."));
                lstrcat(lpszNew, lpszFileName);
                if (GetTextWSize(hdc, lpszNew) <= nWidth && lstrlen(lpszNew) < nMaxChars)
                {
                        lstrcpyn(lpch, lpszNew, nMaxChars);
                        OleStdFree(lpszNew);
                        return;
                }
                lpszFileName = CharNext(lpszFileName);
        }

        OleStdFree(lpszNew);

        // not even a single character fit
        *lpch = (TCHAR)0;
}

/*
 * ChopText
 *
 * Purpose:
 *  Parse a string (pathname) and convert it to be within a specified
 *  length by chopping the least significant part
 *
 * Parameters:
 *  hWnd            window handle in which the string resides
 *  nWidth          max width of string in pixels
 *                  use width of hWnd if zero
 *  lpch            pointer to beginning of the string
 *  nMaxChars       maximum allowable number of characters (0 ignore)
 *
 * Return Value:
 *  pointer to the modified string
 */
LPTSTR WINAPI ChopText(HWND hWnd, int nWidth, LPTSTR lpch, int nMaxChars)
{
        HDC     hdc;
        HFONT   hfont;
        HFONT   hfontOld = NULL;
        RECT    rc;

        if (!hWnd || !lpch)
            return NULL;

        if (nMaxChars == 0)
            nMaxChars = 32768; // big number

        /* Get length of static field. */
        if (!nWidth)
        {
            GetClientRect(hWnd, (LPRECT)&rc);
            nWidth = rc.right - rc.left;
        }
        
        /* Set up DC appropriately for the static control */
        hdc = CreateIC(TEXT("DISPLAY"), NULL, NULL, NULL);
		
		/* CreateIC can return NULL in low memory situations */
		if (hdc != NULL)
		{
			hfont = (HFONT)SendMessage(hWnd, WM_GETFONT, 0, 0L);
        
			if (NULL != hfont)   // WM_GETFONT returns NULL if window uses system font
				hfontOld = (HFONT)SelectObject(hdc, hfont);
        
			/* check horizontal extent of string */
			if (GetTextWSize(hdc, lpch) > nWidth || lstrlen(lpch) >= nMaxChars)
				Abbreviate(hdc, nWidth, lpch, nMaxChars);
        
			if (NULL != hfont)
				SelectObject(hdc, hfontOld);
			DeleteDC(hdc);
        }

        return lpch;
}

/*
 * OpenFileError
 *
 * Purpose:
 *  display message for error returned from OpenFile
 *
 * Parameters:
 *  hDlg            HWND of the dialog.
 *  nErrCode        UINT error code returned in OFSTRUCT passed to OpenFile
 *  lpszFile        LPSTR file name passed to OpenFile
 *
 * Return Value:
 *  None
 */
void WINAPI OpenFileError(HWND hDlg, UINT nErrCode, LPTSTR lpszFile)
{
        switch (nErrCode)
        {
        case 0x0005:    // Access denied
                ErrorWithFile(hDlg, _g_hOleStdResInst, IDS_CIFILEACCESS, lpszFile,
                        MB_OK | MB_ICONEXCLAMATION);
                break;

        case 0x0020:    // Sharing violation
                ErrorWithFile(hDlg, _g_hOleStdResInst, IDS_CIFILESHARE, lpszFile,
                        MB_OK | MB_ICONEXCLAMATION);
                break;

        case 0x0002:    // File not found
        case 0x0003:    // Path not found
                ErrorWithFile(hDlg, _g_hOleStdResInst, IDS_CIINVALIDFILE, lpszFile,
                        MB_OK | MB_ICONEXCLAMATION);
                break;

        default:
                ErrorWithFile(hDlg, _g_hOleStdResInst, IDS_CIFILEOPENFAIL, lpszFile,
                        MB_OK | MB_ICONEXCLAMATION);
                break;
        }
}

/*
 * DoesFileExist
 *
 * Purpose:
 *  Determines if a file path exists
 *
 * Parameters:
 *  lpszFile        LPTSTR - file name
 *  cchMax          UINT - size of the lpszFile string buffer in characters.
 *
 * Return Value:
 *  BOOL            TRUE if file exists, else FALSE.
 *
 * NOTE: lpszFile may be changed as a result of this call to match the first
 *       matching file name found by this routine.
 *
 */
BOOL WINAPI DoesFileExist(LPTSTR lpszFile, UINT cchMax)
{
        static const TCHAR *arrIllegalNames[] =
        {
                TEXT("LPT1"), TEXT("LPT2"), TEXT("LPT3"),
                TEXT("COM1"), TEXT("COM2"), TEXT("COM3"), TEXT("COM4"),
                TEXT("CON"),  TEXT("AUX"),  TEXT("PRN")
        };

        // check is the name is an illegal name (eg. the name of a device)
        for (int i = 0; i < (sizeof(arrIllegalNames)/sizeof(arrIllegalNames[0])); i++)
        {
                if (lstrcmpi(lpszFile, arrIllegalNames[i])==0)
                        return FALSE;
        }

        // First try to find the file with an exact match

        // check the file's attributes
        DWORD dwAttrs = GetFileAttributes(lpszFile);
        if (dwAttrs == 0xFFFFFFFF)  // file wasn't found
        {
            // look in path for file
            TCHAR szTempFileName[MAX_PATH];
            LPTSTR lpszFilePart;
            BOOL fFound = SearchPath(NULL, lpszFile, NULL, MAX_PATH, szTempFileName, &lpszFilePart) != 0;
            if (!fFound)
            {
                // File wasn't found in the search path
                // Try to append a .* and use FindFirstFile to try for a match in the current directory
                UINT cchFile = lstrlen(lpszFile);
                if (cchFile + 4 < MAX_PATH)
                {
                    WIN32_FIND_DATA sFindFileData;
                    lstrcpy(szTempFileName,lpszFile);
                    lstrcpy(&szTempFileName[cchFile], TEXT("*.*"));
                    HANDLE hFindFile = FindFirstFile(szTempFileName, &sFindFileData);
                    if (INVALID_HANDLE_VALUE != hFindFile)
                    {
                        // found something
                        while (0 != (sFindFileData.dwFileAttributes & (FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_TEMPORARY)))
                        {
                            // found a directory or a temporary file try again
                            if (!FindNextFile(hFindFile, &sFindFileData))
                            {
                                // Could only match a directory or temporary file.
                                FindClose(hFindFile);
                                return(FALSE);
                            }
                        }
                        // Copy the name of the found file into the end of the path in the
                        // temporary buffer (if any).
                        // First scan back for the last file separator.
                        UINT cchPath = lstrlen(szTempFileName);
                        while (cchPath)
                        {
                            if (_T('\\') == szTempFileName[cchPath - 1]
                                || _T('/') == szTempFileName[cchPath - 1])
                            {
                                break;
                            }
                            cchPath--;
                        }
                        lstrcpyn(&szTempFileName[cchPath], sFindFileData.cFileName, MAX_PATH - cchPath);
                        fFound = TRUE;
                        FindClose(hFindFile);
                    }
                }
            }
            if (fFound)
            {
                // copy the temporary buffer into szFile
                lstrcpyn(lpszFile, szTempFileName, cchMax -1);
            }
            return(fFound);
        }
        else if (dwAttrs & (FILE_ATTRIBUTE_DIRECTORY|
                FILE_ATTRIBUTE_TEMPORARY))
        {
                return FALSE;
        }
        return TRUE;
}

/*
 * FormatStrings
 *
 * Purpose:
 *  Simple message formatting API compatible w/ different languages
 *
 * Note:
 *  Shamelessly stolen/modified from MFC source code
 *
 */

void WINAPI FormatStrings(LPTSTR lpszDest, LPCTSTR lpszFormat,
        LPCTSTR* rglpsz, int nString)
{
        LPCTSTR pchSrc = lpszFormat;
        while (*pchSrc != '\0')
        {
                if (pchSrc[0] == '%' && (pchSrc[1] >= '1' && pchSrc[1] <= '9'))
                {
                        int i = pchSrc[1] - '1';
                        pchSrc += 2;
                        if (i >= nString)
                                *lpszDest++ = '?';
                        else if (rglpsz[i] != NULL)
                        {
                                lstrcpy(lpszDest, rglpsz[i]);
                                lpszDest += lstrlen(lpszDest);
                        }
                }
                else
                {
#ifndef _UNICODE
                        if (IsDBCSLeadByte(*pchSrc))
                                *lpszDest++ = *pchSrc++; // copy first of 2 bytes
#endif
                        *lpszDest++ = *pchSrc++;
                }
        }
        *lpszDest = '\0';
}

void WINAPI FormatString1(LPTSTR lpszDest, LPCTSTR lpszFormat, LPCTSTR lpsz1)
{
        FormatStrings(lpszDest, lpszFormat, &lpsz1, 1);
}

void WINAPI FormatString2(LPTSTR lpszDest, LPCTSTR lpszFormat, LPCTSTR lpsz1,
        LPCTSTR lpsz2)
{
        LPCTSTR rglpsz[2];
        rglpsz[0] = lpsz1;
        rglpsz[1] = lpsz2;
        FormatStrings(lpszDest, lpszFormat, rglpsz, 2);
}

// Replacement for stdlib atol,
// which didn't work and doesn't take far pointers.
// Must be tolerant of leading spaces.
//
//
LONG WINAPI Atol(LPTSTR lpsz)
{
        signed int sign = +1;
        UINT base = 10;
        LONG l = 0;

        if (NULL==lpsz)
        {
                OleDbgAssert (0);
                return 0;
        }
        while (*lpsz == ' ' || *lpsz == '\t' || *lpsz == '\n')
                lpsz++;

        if (*lpsz=='-')
        {
                lpsz++;
                sign = -1;
        }
        if (lpsz[0] == TEXT('0') && lpsz[1] == TEXT('x'))
        {
                base = 16;
                lpsz+=2;
        }

        if (base == 10)
        {
                while (*lpsz >= '0' && *lpsz <= '9')
                {
                        l = l * base + *lpsz - '0';
                        lpsz++;
                }
        }
        else
        {
                OleDbgAssert(base == 16);
                while (*lpsz >= '0' && *lpsz <= '9' ||
                        *lpsz >= 'A' && *lpsz <= 'F' ||
                        *lpsz >= 'a' && *lpsz <= 'f')
                {
                        l = l * base;
                        if (*lpsz >= '0' && *lpsz <= '9')
                                l += *lpsz - '0';
                        else if (*lpsz >= 'a' && *lpsz <= 'f')
                                l += *lpsz - 'a' + 10;
                        else
                                l += *lpsz - 'A' + 10;
                        lpsz++;
                }
        }
        return l * sign;
}

BOOL WINAPI IsValidClassID(REFCLSID clsid)
{
        return clsid != CLSID_NULL;
}

/* PopupMessage
 * ------------
 *
 *  Purpose:
 *      Popup messagebox and get some response from the user. It is the same
 *      as MessageBox() except that the title and message string are loaded
 *      from the resource file.
 *
 *  Parameters:
 *      hwndParent      parent window of message box
 *      idTitle         id of title string
 *      idMessage       id of message string
 *      fuStyle         style of message box
 */
int WINAPI PopupMessage(HWND hwndParent, UINT idTitle, UINT idMessage, UINT fuStyle)
{
        TCHAR szTitle[256];
        TCHAR szMsg[256];

        LoadString(_g_hOleStdResInst, idTitle, szTitle, sizeof(szTitle)/sizeof(TCHAR));
        LoadString(_g_hOleStdResInst, idMessage, szMsg, sizeof(szMsg)/sizeof(TCHAR));
        return MessageBox(hwndParent, szMsg, szTitle, fuStyle);
}

/* DiffPrefix
 * ----------
 *
 *  Purpose:
 *      Compare (case-insensitive) two strings and return the prefixes of the
 *      the strings formed by removing the common suffix string from them.
 *      Integrity of tokens (directory name, filename and object names) are
 *      preserved. Note that the prefixes are converted to upper case
 *      characters.
 *
 *  Parameters:
 *      lpsz1           string 1
 *      lpsz2           string 2
 *      lplpszPrefix1   prefix of string 1
 *      lplpszPrefix2   prefix of string 2
 *
 *  Returns:
 *
 */
void WINAPI DiffPrefix(LPCTSTR lpsz1, LPCTSTR lpsz2, TCHAR FAR* FAR* lplpszPrefix1, TCHAR FAR* FAR* lplpszPrefix2)
{
        LPTSTR  lpstr1;
        LPTSTR  lpstr2;
        TCHAR   szTemp1[MAX_PATH];
        TCHAR   szTemp2[MAX_PATH];

        OleDbgAssert(lpsz1);
        OleDbgAssert(lpsz2);
        OleDbgAssert(*lpsz1);
        OleDbgAssert(*lpsz2);
        OleDbgAssert(lplpszPrefix1);
        OleDbgAssert(lplpszPrefix2);

        // need to copy into temporary for case insensitive compare
        lstrcpy(szTemp1, lpsz1);
        lstrcpy(szTemp2, lpsz2);
        CharLower(szTemp1);
        CharLower(szTemp2);

        // do comparison
        lpstr1 = szTemp1 + lstrlen(szTemp1);
        lpstr2 = szTemp2 + lstrlen(szTemp2);

        while ((lpstr1 > szTemp1) && (lpstr2 > szTemp2))
        {
                lpstr1 = CharPrev(szTemp1, lpstr1);
                lpstr2 = CharPrev(szTemp2, lpstr2);
                if (*lpstr1 != *lpstr2)
                {
                        lpstr1 = CharNext(lpstr1);
                        lpstr2 = CharNext(lpstr2);
                        break;
                }
        }

        // scan forward to first delimiter
        while (*lpstr1 && *lpstr1 != '\\' && *lpstr1 != '!')
                lpstr1 = CharNext(lpstr1);
        while (*lpstr2 && *lpstr2 != '\\' && *lpstr2 != '!')
                lpstr2 = CharNext(lpstr2);

        *lpstr1 = '\0';
        *lpstr2 = '\0';

        // initialize in case of failure
        *lplpszPrefix1 = NULL;
        *lplpszPrefix2 = NULL;

        // allocate memory for the result
        *lplpszPrefix1 = (LPTSTR)OleStdMalloc((lstrlen(lpsz1)+1) * sizeof(TCHAR));
        if (!*lplpszPrefix1)
                return;

        *lplpszPrefix2 = (LPTSTR)OleStdMalloc((lstrlen(lpsz2)+1) * sizeof(TCHAR));
        if (!*lplpszPrefix2)
        {
                OleStdFree(*lplpszPrefix1);
                *lplpszPrefix1 = NULL;
                return;
        }

        // copy result
        lstrcpyn(*lplpszPrefix1, lpsz1, lstrlen(szTemp1)+1);
        lstrcpyn(*lplpszPrefix2, lpsz2, lstrlen(szTemp2)+1);
}

UINT WINAPI GetFileName(LPCTSTR lpszPathName, LPTSTR lpszTitle, UINT nMax)
{
        // always capture the complete file name including extension (if present)
        LPTSTR lpszTemp = (LPTSTR)lpszPathName;
        for (LPCTSTR lpsz = lpszPathName; *lpsz != '\0'; lpsz = CharNext(lpsz))
        {
                // remember last directory/drive separator
                if (*lpsz == '\\' || *lpsz == '/' || *lpsz == ':')
                        lpszTemp = CharNext(lpsz);
        }

        // lpszTitle can be NULL which just returns the number of bytes
        if (lpszTitle == NULL)
                return lstrlen(lpszTemp)+1;

        // otherwise copy it into the buffer provided
        lstrcpyn(lpszTitle, lpszTemp, nMax);
        return 0;
}

BOOL WINAPI IsValidMetaPict(HGLOBAL hMetaPict)
{
    BOOL fReturn = FALSE;
    LPMETAFILEPICT pMF = (LPMETAFILEPICT) GlobalLock(hMetaPict);
    if (pMF != NULL)
    {
        if (!IsBadReadPtr( pMF, sizeof(METAFILEPICT)))
        {
            if (GetMetaFileBitsEx(pMF->hMF, 0, 0))
            {
                fReturn = TRUE;
            }
        }
        GlobalUnlock(hMetaPict);
    }
    return(fReturn);
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole2ui32\template.h ===
/*
 * TEMPLATE.H
 *
 * CUSTOMIZATION INSTRUCTIONS:
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 *
 *
 *  1.  Replace <FILE> with the uppercased filename for this file.
 *      Lowercase the <FILE>.h entry
 *
 *  2.  Replace <NAME> with the mixed case dialog name in one word,
 *      such as InsertObject
 *
 *  3.  Replace <FULLNAME> with the mixed case dialog name in multiple
 *      words, such as Insert Object
 *
 *  4.  Replace <ABBREV> with the suffix for pointer variables, such
 *      as the IO in InsertObject's pIO or the CI in ChangeIcon's pCI.
 *      Check the alignment of the first variable declaration in the
 *      Dialog Proc after this.  I will probably be misaligned with the
 *      rest of the variables.
 *
 *  5.  Replace <STRUCT> with the uppercase structure name for this
 *      dialog sans OLEUI, such as INSERTOBJECT.  Changes OLEUI<STRUCT>
 *      in most cases, but we also use this for IDD_<STRUCT> as the
 *      standard template resource ID.
 *
 *  6.  Find <UFILL> fields and fill them out with whatever is appropriate.
 *
 *  7.  Delete this header up to the start of the next comment.
 *
 */


/*
 * <FILE>.H
 *
 * Internal definitions, structures, and function prototypes for the
 * OLE 2.0 UI <FULLNAME> dialog.
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */


#ifndef <UFILL>
#define <UFILL>

// UFILL>  Move from here to INTERNAL to to OLE2UI.H


typedef struct tagOLEUI<STRUCT>
{
	// These IN fields are standard across all OLEUI dialog functions.
	DWORD           cbStruct;       //Structure Size
	DWORD           dwFlags;        //IN-OUT:  Flags
	HWND            hWndOwner;      //Owning window
	LPCTSTR         lpszCaption;    //Dialog caption bar contents
	LPFNOLEUIHOOK   lpfnHook;       //Hook callback
	LPARAM          lCustData;      //Custom data to pass to hook
	HINSTANCE       hInstance;      //Instance for customized template name
	LPCTSTR         lpszTemplate;   //Customized template name
	HRSRC           hResource;      //Customized template handle

	// Specifics for OLEUI<STRUCT>.  All are IN-OUT unless otherwise spec.
} OLEUI<STRUCT>, *POLEUI<STRUCT>, FAR *LPOLEUI<STRUCT>;


// API Prototype
UINT FAR PASCAL OleUI<NAME>(LPOLEUI<STRUCT>);


// <FULLNAME> flags
#define <ABBREV>F_SHOWHELP                0x00000001L
<UFILL>


// <FULLNAME> specific error codes
// DEFINE AS OLEUI_<ABBREV>ERR_<ERROR>     (OLEUI_ERR_STANDARDMAX+n)
<UFILL>


// <FULLNAME> Dialog identifiers
// FILL IN DIALOG IDs HERE
<UFILL>





// INTERNAL INFORMATION STARTS HERE

// Internally used structure
typedef struct tag<STRUCT>
{
	//Keep this item first as the Standard* functions depend on it here.
	LPOLEUI<STRUCT>     lpO<ABBREV>;       //Original structure passed.
	UINT			nIDD;	// IDD of dialog (used for help info)

	/*
	 * What we store extra in this structure besides the original caller's
	 * pointer are those fields that we need to modify during the life of
	 * the dialog but that we don't want to change in the original structure
	 * until the user presses OK.
	 */

	<UFILL>
} <STRUCT>, *P<STRUCT>;


// Internal function prototypes
// <FILE>.CPP

BOOL FAR PASCAL <NAME>DialogProc(HWND, UINT, WPARAM, LPARAM);
BOOL            F<NAME>Init(HWND hDlg, WPARAM, LPARAM);
<UFILL>


#endif //<UFILL>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole2ui32\winres.h ===
// Microsoft Foundation Classes C++ library.
// Copyright (C) 1992 Microsoft Corporation,
// All rights reserved.

// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// winres.h - Windows resource definitions
//  extracted from WINDOWS.H
//          Version 3.10
//          Copyright (c) 1985-1992, Microsoft Corp. All rights reserved.
//

#define VS_VERSION_INFO     1

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS // Ignore following symbols
#endif

#define OBM_CLOSE       32754
#define OBM_UPARROW     32753
#define OBM_DNARROW     32752
#define OBM_RGARROW     32751
#define OBM_LFARROW     32750
#define OBM_REDUCE      32749
#define OBM_ZOOM        32748
#define OBM_RESTORE     32747
#define OBM_REDUCED     32746
#define OBM_ZOOMD       32745
#define OBM_RESTORED    32744
#define OBM_UPARROWD    32743
#define OBM_DNARROWD    32742
#define OBM_RGARROWD    32741
#define OBM_LFARROWD    32740
#define OBM_MNARROW     32739
#define OBM_COMBO       32738
#define OBM_UPARROWI    32737
#define OBM_DNARROWI    32736
#define OBM_RGARROWI    32735
#define OBM_LFARROWI    32734
#define OBM_OLD_CLOSE   32767
#define OBM_SIZE        32766
#define OBM_OLD_UPARROW 32765
#define OBM_OLD_DNARROW 32764
#define OBM_OLD_RGARROW 32763
#define OBM_OLD_LFARROW 32762
#define OBM_BTSIZE      32761
#define OBM_CHECK       32760
#define OBM_CHECKBOXES  32759
#define OBM_BTNCORNERS  32758
#define OBM_OLD_REDUCE  32757
#define OBM_OLD_ZOOM    32756
#define OBM_OLD_RESTORE 32755
#define OCR_NORMAL      32512
#define OCR_IBEAM       32513
#define OCR_WAIT        32514
#define OCR_CROSS       32515
#define OCR_UP          32516
#define OCR_SIZE        32640
#define OCR_ICON        32641
#define OCR_SIZENWSE    32642
#define OCR_SIZENESW    32643
#define OCR_SIZEWE      32644
#define OCR_SIZENS      32645
#define OCR_SIZEALL     32646
#define OCR_ICOCUR      32647
#define OIC_SAMPLE      32512
#define OIC_HAND        32513
#define OIC_QUES        32514
#define OIC_BANG        32515
#define OIC_NOTE        32516

#define WS_OVERLAPPED   0x00000000L
#define WS_POPUP        0x80000000L
#define WS_CHILD        0x40000000L
#define WS_CLIPSIBLINGS 0x04000000L
#define WS_CLIPCHILDREN 0x02000000L
#define WS_VISIBLE      0x10000000L
#define WS_DISABLED     0x08000000L
#define WS_MINIMIZE     0x20000000L
#define WS_MAXIMIZE     0x01000000L
#define WS_CAPTION      0x00C00000L
#define WS_BORDER       0x00800000L
#define WS_DLGFRAME     0x00400000L
#define WS_VSCROLL      0x00200000L
#define WS_HSCROLL      0x00100000L
#define WS_SYSMENU      0x00080000L
#define WS_THICKFRAME   0x00040000L
#define WS_MINIMIZEBOX  0x00020000L
#define WS_MAXIMIZEBOX  0x00010000L
#define WS_GROUP        0x00020000L
#define WS_TABSTOP      0x00010000L

// other aliases
#define WS_OVERLAPPEDWINDOW (WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX)
#define WS_POPUPWINDOW  (WS_POPUP | WS_BORDER | WS_SYSMENU)
#define WS_CHILDWINDOW  (WS_CHILD)
#define WS_TILED        WS_OVERLAPPED
#define WS_ICONIC       WS_MINIMIZE
#define WS_SIZEBOX      WS_THICKFRAME
#define WS_TILEDWINDOW  WS_OVERLAPPEDWINDOW

#define VK_LBUTTON      0x01
#define VK_RBUTTON      0x02
#define VK_CANCEL       0x03
#define VK_MBUTTON      0x04
#define VK_BACK         0x08
#define VK_TAB          0x09
#define VK_CLEAR        0x0C
#define VK_RETURN       0x0D
#define VK_SHIFT        0x10
#define VK_CONTROL      0x11
#define VK_MENU         0x12
#define VK_PAUSE        0x13
#define VK_CAPITAL      0x14
#define VK_ESCAPE       0x1B
#define VK_SPACE        0x20
#define VK_PRIOR        0x21
#define VK_NEXT         0x22
#define VK_END          0x23
#define VK_HOME         0x24
#define VK_LEFT         0x25
#define VK_UP           0x26
#define VK_RIGHT        0x27
#define VK_DOWN         0x28
#define VK_SELECT       0x29
#define VK_PRINT        0x2A
#define VK_EXECUTE      0x2B
#define VK_SNAPSHOT     0x2C
#define VK_INSERT       0x2D
#define VK_DELETE       0x2E
#define VK_HELP         0x2F
#define VK_NUMPAD0      0x60
#define VK_NUMPAD1      0x61
#define VK_NUMPAD2      0x62
#define VK_NUMPAD3      0x63
#define VK_NUMPAD4      0x64
#define VK_NUMPAD5      0x65
#define VK_NUMPAD6      0x66
#define VK_NUMPAD7      0x67
#define VK_NUMPAD8      0x68
#define VK_NUMPAD9      0x69
#define VK_MULTIPLY     0x6A
#define VK_ADD          0x6B
#define VK_SEPARATOR    0x6C
#define VK_SUBTRACT     0x6D
#define VK_DECIMAL      0x6E
#define VK_DIVIDE       0x6F
#define VK_F1           0x70
#define VK_F2           0x71
#define VK_F3           0x72
#define VK_F4           0x73
#define VK_F5           0x74
#define VK_F6           0x75
#define VK_F7           0x76
#define VK_F8           0x77
#define VK_F9           0x78
#define VK_F10          0x79
#define VK_F11          0x7A
#define VK_F12          0x7B
#define VK_F13          0x7C
#define VK_F14          0x7D
#define VK_F15          0x7E
#define VK_F16          0x7F
#define VK_F17          0x80
#define VK_F18          0x81
#define VK_F19          0x82
#define VK_F20          0x83
#define VK_F21          0x84
#define VK_F22          0x85
#define VK_F23          0x86
#define VK_F24          0x87
#define VK_NUMLOCK      0x90
#define VK_SCROLL       0x91

#define SC_SIZE         0xF000
#define SC_MOVE         0xF010
#define SC_MINIMIZE     0xF020
#define SC_MAXIMIZE     0xF030
#define SC_NEXTWINDOW   0xF040
#define SC_PREVWINDOW   0xF050
#define SC_CLOSE        0xF060
#define SC_VSCROLL      0xF070
#define SC_HSCROLL      0xF080
#define SC_MOUSEMENU    0xF090
#define SC_KEYMENU      0xF100
#define SC_ARRANGE      0xF110
#define SC_RESTORE      0xF120
#define SC_TASKLIST     0xF130
#define SC_SCREENSAVE   0xF140
#define SC_HOTKEY       0xF150

#define DS_ABSALIGN     0x01L
#define DS_SYSMODAL     0x02L
#define DS_LOCALEDIT    0x20L
#define DS_SETFONT      0x40L
#define DS_MODALFRAME   0x80L
#define DS_NOIDLEMSG    0x100L

#ifdef _MAC
#define DS_WINDOWSUI    0x8000L
#endif

#define SS_LEFT         0x00000000L
#define SS_CENTER       0x00000001L
#define SS_RIGHT        0x00000002L
#define SS_ICON         0x00000003L
#define SS_BLACKRECT    0x00000004L
#define SS_GRAYRECT     0x00000005L
#define SS_WHITERECT    0x00000006L
#define SS_BLACKFRAME   0x00000007L
#define SS_GRAYFRAME    0x00000008L
#define SS_WHITEFRAME   0x00000009L
#define SS_SIMPLE       0x0000000BL
#define SS_LEFTNOWORDWRAP 0x0000000CL
#define SS_NOPREFIX     0x00000080L

#define BS_PUSHBUTTON   0x00000000L
#define BS_DEFPUSHBUTTON 0x00000001L
#define BS_CHECKBOX     0x00000002L
#define BS_AUTOCHECKBOX 0x00000003L
#define BS_RADIOBUTTON  0x00000004L
#define BS_3STATE       0x00000005L
#define BS_AUTO3STATE   0x00000006L
#define BS_GROUPBOX     0x00000007L
#define BS_USERBUTTON   0x00000008L
#define BS_AUTORADIOBUTTON  0x00000009L
#define BS_OWNERDRAW        0x0000000BL
#define BS_LEFTTEXT     0x00000020L

#define ES_LEFT         0x00000000L
#define ES_CENTER       0x00000001L
#define ES_RIGHT        0x00000002L
#define ES_MULTILINE    0x00000004L
#define ES_UPPERCASE    0x00000008L
#define ES_LOWERCASE    0x00000010L
#define ES_PASSWORD     0x00000020L
#define ES_AUTOVSCROLL  0x00000040L
#define ES_AUTOHSCROLL  0x00000080L
#define ES_NOHIDESEL    0x00000100L
#define ES_OEMCONVERT   0x00000400L
#define ES_READONLY     0x00000800L
#define ES_WANTRETURN   0x00001000L

#define SBS_HORZ        0x0000L
#define SBS_VERT        0x0001L
#define SBS_TOPALIGN    0x0002L
#define SBS_LEFTALIGN   0x0002L
#define SBS_BOTTOMALIGN 0x0004L
#define SBS_RIGHTALIGN  0x0004L
#define SBS_SIZEBOXTOPLEFTALIGN 0x0002L
#define SBS_SIZEBOXBOTTOMRIGHTALIGN 0x0004L
#define SBS_SIZEBOX     0x0008L

#define LBS_NOTIFY      0x0001L
#define LBS_SORT        0x0002L
#define LBS_NOREDRAW    0x0004L
#define LBS_MULTIPLESEL 0x0008L
#define LBS_OWNERDRAWFIXED 0x0010L
#define LBS_OWNERDRAWVARIABLE 0x0020L
#define LBS_HASSTRINGS  0x0040L
#define LBS_USETABSTOPS 0x0080L
#define LBS_NOINTEGRALHEIGHT 0x0100L
#define LBS_MULTICOLUMN 0x0200L
#define LBS_WANTKEYBOARDINPUT 0x0400L
#define LBS_EXTENDEDSEL 0x0800L
#define LBS_DISABLENOSCROLL 0x1000L
#define LBS_STANDARD    (LBS_NOTIFY | LBS_SORT | WS_VSCROLL | WS_BORDER)

#define CBS_SIMPLE      0x0001L
#define CBS_DROPDOWN    0x0002L
#define CBS_DROPDOWNLIST 0x0003L
#define CBS_OWNERDRAWFIXED 0x0010L
#define CBS_OWNERDRAWVARIABLE 0x0020L
#define CBS_AUTOHSCROLL 0x0040L
#define CBS_OEMCONVERT  0x0080L
#define CBS_SORT        0x0100L
#define CBS_HASSTRINGS  0x0200L
#define CBS_NOINTEGRALHEIGHT 0x0400L
#define CBS_DISABLENOSCROLL 0x0800L

// operation messages sent to DLGINIT
#define WM_USER         0x0400
#define LB_ADDSTRING    (WM_USER+1)
#define CB_ADDSTRING    (WM_USER+3)

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif

#define IDOK            1
#define IDCANCEL        2
#define IDABORT         3
#define IDRETRY         4
#define IDIGNORE        5
#define IDYES           6
#define IDNO            7
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole2ui32\utility.h ===
/*
 * UTILITY.H
 *
 * Miscellaneous prototypes and definitions for OLE UI dialogs.
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */


#ifndef _UTILITY_H_
#define _UTILITY_H_

#define CF_CLIPBOARDMIN   0xc000
#define CF_CLIPBOARDMAX   0xffff

// Function prototypes
// UTILITY.CPP
HCURSOR  WINAPI HourGlassOn(void);
void     WINAPI HourGlassOff(HCURSOR);

BOOL     WINAPI Browse(HWND, LPTSTR, LPTSTR, UINT, UINT, DWORD, UINT, LPOFNHOOKPROC);
int      WINAPI ReplaceCharWithNull(LPTSTR, int);
int      WINAPI ErrorWithFile(HWND, HINSTANCE, UINT, LPTSTR, UINT);
BOOL     WINAPI DoesFileExist(LPTSTR lpszFile, UINT cchMax);
LONG     WINAPI Atol(LPTSTR lpsz);
BOOL     WINAPI IsValidClassID(REFCLSID);
UINT     WINAPI GetFileName(LPCTSTR, LPTSTR, UINT);
BOOL     WINAPI IsValidMetaPict(HGLOBAL hMetaPict);

LPTSTR FindChar(LPTSTR lpsz, TCHAR ch);
LPTSTR FindReverseChar(LPTSTR lpsz, TCHAR ch);

LPTSTR FAR PASCAL PointerToNthField(LPTSTR, int, TCHAR);
BOOL FAR PASCAL GetAssociatedExecutable(LPTSTR, LPTSTR);
LPTSTR   WINAPI ChopText(HWND hwndStatic, int nWidth, LPTSTR lpch,
        int nMaxChars);
void     WINAPI OpenFileError(HWND hDlg, UINT nErrCode, LPTSTR lpszFile);
int WINAPI PopupMessage(HWND hwndParent, UINT idTitle, UINT idMessage, UINT fuStyle);
void WINAPI DiffPrefix(LPCTSTR lpsz1, LPCTSTR lpsz2, TCHAR FAR* FAR* lplpszPrefix1, TCHAR FAR* FAR* lplpszPrefix2);

// string formatting APIs
void WINAPI FormatStrings(LPTSTR, LPCTSTR, LPCTSTR*, int);
void WINAPI FormatString1(LPTSTR, LPCTSTR, LPCTSTR);
void WINAPI FormatString2(LPTSTR, LPCTSTR, LPCTSTR, LPCTSTR);

// global instance to load strings/resources from
extern HINSTANCE _g_hOleStdInst;
extern HINSTANCE _g_hOleStdResInst;

// standard OLE 2.0 clipboard formats
extern UINT _g_cfObjectDescriptor;
extern UINT _g_cfLinkSrcDescriptor;
extern UINT _g_cfEmbedSource;
extern UINT _g_cfEmbeddedObject;
extern UINT _g_cfLinkSource;
extern UINT _g_cfOwnerLink;
extern UINT _g_cfFileName;

// Metafile utility functions
STDAPI_(void)    OleUIMetafilePictIconFree(HGLOBAL);
STDAPI_(BOOL)    OleUIMetafilePictIconDraw(HDC, LPCRECT, HGLOBAL, BOOL);
STDAPI_(UINT)    OleUIMetafilePictExtractLabel(HGLOBAL, LPTSTR, UINT, LPDWORD);
STDAPI_(HICON)   OleUIMetafilePictExtractIcon(HGLOBAL);
STDAPI_(BOOL)    OleUIMetafilePictExtractIconSource(HGLOBAL, LPTSTR, UINT FAR *);

#endif //_UTILITY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole2ui32\wrapstub.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       wrapstub.cpp
//
//  Contents:   ANSI to Unicode wrappers and Unicode stubs
//
//  Classes:    WrappedIOleUILinkContainer
//              WrappedIOleUIObjInfo
//              WrappedIOleUILinkInfo
//
//  Functions:
#ifdef UNICODE
//            OleUIAddVerbMenuA
//            OleUIInsertObjectA
//            OleUIPasteSpecialA
//            OleUIEditLinksA
//            OleUIChangeIconA
//            OleUIConvertA
//            OleUIBusyA
//            OleUIUpdateLinksA
//            OleUIObjectPropertiesA
//            OleUIChangeSourceA
//            OleUIPromptUserA
#else
//            OleUIAddVerbMenuW
//            OleUIInsertObjectW
//            OleUIPasteSpecialW
//            OleUIEditLinksW
//            OleUIChangeIconW
//            OleUIConvertW
//            OleUIBusyW
//            OleUIUpdateLinksW
//            OleUIObjectPropertiesW
//            OleUIChangeSourceW
//            OleUIPromptUserW
#endif
//
//  History:    11-02-94   stevebl   Created
//
//----------------------------------------------------------------------------

#include "precomp.h"
#include "common.h"

#ifdef UNICODE
// ANSI to Unicode Wrappers

//+---------------------------------------------------------------------------
//
//  Function:   OleUIAddVerbMenuA
//
//  Synopsis:   converts call to ANSI version into call to Unicode version
//
//  Arguments:  [lpOleObj]      -
//              [lpszShortType] - [in] on heap
//              [hMenu]         -
//              [uPos]          -
//              [uIDVerbMin]    -
//              [uIDVerbMax]    -
//              [bAddConvert]   -
//              [idConvert]     -
//              [lphMenu]       -
//
//  History:    11-04-94   stevebl   Created
//
//----------------------------------------------------------------------------

STDAPI_(BOOL) OleUIAddVerbMenuA(LPOLEOBJECT lpOleObj, LPCSTR lpszShortType,
        HMENU hMenu, UINT uPos, UINT uIDVerbMin, UINT uIDVerbMax,
        BOOL bAddConvert, UINT idConvert, HMENU FAR *lphMenu)
{
    LPWSTR lpwszShortType = NULL;
    if (lpszShortType && !IsBadReadPtr(lpszShortType, 1))
    {
        UINT uSize = ATOWLEN(lpszShortType);
        lpwszShortType = (LPWSTR)OleStdMalloc(sizeof(WCHAR) * uSize);
        if (lpwszShortType)
        {
            ATOW(lpwszShortType, lpszShortType, uSize);
        }
    }

    // NOTE - if OleStdMalloc fails, this routine must still go ahead and
    // succeed as best as it can since there is no way to report failure.

    BOOL fReturn = OleUIAddVerbMenuW(lpOleObj, lpwszShortType, hMenu, uPos,
        uIDVerbMin, uIDVerbMax, bAddConvert, idConvert, lphMenu);

    if (lpwszShortType)
        OleStdFree((LPVOID)lpwszShortType);

    return(fReturn);
}

//+---------------------------------------------------------------------------
//
//  Function:   OleUIInsertObjectA
//
//  Synopsis:   converts call to ANSI version into call to Unicode version
//
//  Arguments:  [psA] - ANSI structure
//
//  History:    11-04-94   stevebl   Created
//
//  Structure members converted or passed back out (everything is passed in):
//              lpszCaption     [in] on stack
//              lpszTemplate    [in] on stack
//              lpszFile        [in, out] on stack
//              dwFlags         [out]
//              clsid           [out]
//              lpIStorage      [out]
//              ppvObj          [out]
//              sc              [out]
//              hMetaPict       [out]
//
//----------------------------------------------------------------------------

STDAPI_(UINT) OleUIInsertObjectA(LPOLEUIINSERTOBJECTA psA)
{
    UINT uRet = UStandardValidation((LPOLEUISTANDARD)psA, sizeof(*psA), NULL);

    // If the caller is using a private template, UStandardValidation will
    // always return OLEUI_ERR_FINDTEMPLATEFAILURE here.  This is because we
    // haven't converted the template name to UNICODE yet, so the
    // FindResource call in UStandardValidation won't find the caller's
    // template.  This is OK for two reasons: (1) it's the last thing that
    // UStandardValidation checks so by this time it's basically done its
    // job, and (2) UStandardValidation will be called again when we forward
    // this call on to the Unicode version.
    if (OLEUI_SUCCESS != uRet && OLEUI_ERR_FINDTEMPLATEFAILURE != uRet)
            return uRet;

    if (NULL != psA->lpszFile &&
        (psA->cchFile <= 0 || psA->cchFile > MAX_PATH))
    {
        return(OLEUI_IOERR_CCHFILEINVALID);
    }

    // NULL is NOT valid for lpszFile
    if (psA->lpszFile == NULL)
    {
        return(OLEUI_IOERR_LPSZFILEINVALID);
    }

    if (IsBadWritePtr(psA->lpszFile, psA->cchFile*sizeof(char)))
        return(OLEUI_IOERR_LPSZFILEINVALID);

    OLEUIINSERTOBJECTW sW;
    WCHAR szCaption[MAX_PATH], szTemplate[MAX_PATH], szFile[MAX_PATH];

    memcpy(&sW, psA, sizeof(OLEUIINSERTOBJECTW));
    if (psA->lpszCaption)
    {
        ATOW(szCaption, psA->lpszCaption, MAX_PATH);
        sW.lpszCaption = szCaption;
    }
    if (0 != HIWORD(PtrToUlong(psA->lpszTemplate)))
    {
        ATOW(szTemplate, psA->lpszTemplate, MAX_PATH);
        sW.lpszTemplate = szTemplate;
    }
    if (psA->lpszFile)
    {
        ATOW(szFile, psA->lpszFile, MAX_PATH);
        sW.lpszFile = szFile;
    }

    uRet = OleUIInsertObjectW(&sW);

    if (psA->lpszFile)
    {
        WTOA(psA->lpszFile, sW.lpszFile, psA->cchFile);
    }
    memcpy(&psA->clsid, &sW.clsid, sizeof(CLSID));
    psA->dwFlags = sW.dwFlags;
    psA->lpIStorage = sW.lpIStorage;
    psA->ppvObj = sW.ppvObj;
    psA->sc = sW.sc;
    psA->hMetaPict = sW.hMetaPict;
    return(uRet);
}

//+---------------------------------------------------------------------------
//
//  Function:   OleUIPasteSpecialA
//
//  Synopsis:   convers call to ANSI version into call to Unicode version
//
//  Arguments:  [psA] - ANSI structure
//
//  History:    11-04-94   stevebl   Created
//
//  Structure members converted or passed back out (everything is passed in):
//              lpszCaption     [in] on stack
//              lpszTemplate    [in] on stack
//              arrPasteEntries [in] on heap
//              arrPasteEntries[n].lpstrFormatName [in] on heap
//              dwFlags         [out]
//              nSelectedIndex  [out]
//              fLink           [out]
//              hMetaPict       [out]
//              sizel           [out]
//
//----------------------------------------------------------------------------


STDAPI_(UINT) OleUIPasteSpecialA(LPOLEUIPASTESPECIALA psA)
{
    UINT uRet = UStandardValidation((LPOLEUISTANDARD)psA, sizeof(*psA), NULL);

    // If the caller is using a private template, UStandardValidation will
    // always return OLEUI_ERR_FINDTEMPLATEFAILURE here.  This is because we
    // haven't converted the template name to UNICODE yet, so the
    // FindResource call in UStandardValidation won't find the caller's
    // template.  This is OK for two reasons: (1) it's the last thing that
    // UStandardValidation checks so by this time it's basically done its
    // job, and (2) UStandardValidation will be called again when we forward
    // this call on to the Unicode version.
    if (OLEUI_SUCCESS != uRet && OLEUI_ERR_FINDTEMPLATEFAILURE != uRet)
            return uRet;

    // Validate PasteSpecial specific fields
    if (NULL == psA->arrPasteEntries || IsBadReadPtr(psA->arrPasteEntries, psA->cPasteEntries * sizeof(OLEUIPASTEENTRYA)))
        return(OLEUI_IOERR_ARRPASTEENTRIESINVALID);

    OLEUIPASTESPECIALW sW;
    WCHAR szCaption[MAX_PATH], szTemplate[MAX_PATH];
    uRet = OLEUI_ERR_LOCALMEMALLOC;
    UINT uIndex;

    memcpy(&sW, psA, sizeof(OLEUIPASTESPECIALW));

    if (psA->lpszCaption)
    {
        ATOW(szCaption, psA->lpszCaption, MAX_PATH);
        sW.lpszCaption = szCaption;
    }
    if (0 != HIWORD(PtrToUlong(psA->lpszTemplate)))
    {
        ATOW(szTemplate, psA->lpszTemplate, MAX_PATH);
        sW.lpszTemplate = szTemplate;
    }
    if (psA->cPasteEntries)
    {
        sW.arrPasteEntries = new OLEUIPASTEENTRYW[psA->cPasteEntries];
        if (NULL == sW.arrPasteEntries)
        {
            return(uRet);
        }
        for (uIndex = psA->cPasteEntries; uIndex--;)
        {
            sW.arrPasteEntries[uIndex].lpstrFormatName = NULL;
            sW.arrPasteEntries[uIndex].lpstrResultText = NULL;
        }
        for (uIndex = psA->cPasteEntries; uIndex--;)
        {
            sW.arrPasteEntries[uIndex].fmtetc = psA->arrPasteEntries[uIndex].fmtetc;
            sW.arrPasteEntries[uIndex].dwFlags = psA->arrPasteEntries[uIndex].dwFlags;
            sW.arrPasteEntries[uIndex].dwScratchSpace = psA->arrPasteEntries[uIndex].dwScratchSpace;
            if (psA->arrPasteEntries[uIndex].lpstrFormatName)
            {
                UINT uLength = ATOWLEN(psA->arrPasteEntries[uIndex].lpstrFormatName);
                sW.arrPasteEntries[uIndex].lpstrFormatName = new WCHAR[uLength];
                if (NULL == sW.arrPasteEntries[uIndex].lpstrFormatName)
                {
                    goto oom_error;
                }
                ATOW((WCHAR *)sW.arrPasteEntries[uIndex].lpstrFormatName,
                    psA->arrPasteEntries[uIndex].lpstrFormatName,
                    uLength);
            }
            if (psA->arrPasteEntries[uIndex].lpstrResultText)
            {
                UINT uLength = ATOWLEN(psA->arrPasteEntries[uIndex].lpstrResultText);
                sW.arrPasteEntries[uIndex].lpstrResultText = new WCHAR[uLength];
                if (NULL == sW.arrPasteEntries[uIndex].lpstrResultText)
                {
                    goto oom_error;
                }
                ATOW((WCHAR *)sW.arrPasteEntries[uIndex].lpstrResultText,
                    psA->arrPasteEntries[uIndex].lpstrResultText,
                    uLength);
            }
        }
    }

    uRet = OleUIPasteSpecialW(&sW);
    psA->lpSrcDataObj = sW.lpSrcDataObj;
    psA->dwFlags = sW.dwFlags;
    psA->nSelectedIndex = sW.nSelectedIndex;
    psA->fLink = sW.fLink;
    psA->hMetaPict = sW.hMetaPict;
    psA->sizel = sW.sizel;

oom_error:
    for (uIndex = psA->cPasteEntries; uIndex--;)
    {
        if (sW.arrPasteEntries[uIndex].lpstrFormatName)
        {
            delete[] (WCHAR*)sW.arrPasteEntries[uIndex].lpstrFormatName;
        }
        if (sW.arrPasteEntries[uIndex].lpstrResultText)
        {
            delete[] (WCHAR *)sW.arrPasteEntries[uIndex].lpstrResultText;
        }
    }
    delete[] sW.arrPasteEntries;
    return(uRet);
}

//+---------------------------------------------------------------------------
//
//  Class:      WrappedIOleUILinkContainer
//
//  Purpose:    Wraps IOleUILinkContainerA with IOleUILinkContainerW methods
//              so it can be passed on to Unicode methods within OLE2UI32.
//
//  Interface:  QueryInterface              --
//              AddRef                      --
//              Release                     --
//              GetNextLink                 --
//              SetLinkUpdateOptions        --
//              GetLinkUpdateOptions        --
//              SetLinkSource               -- requires string conversion
//              GetLinkSource               -- requires string conversion
//              OpenLinkSource              --
//              UpdateLink                  --
//              CancelLink                  --
//              WrappedIOleUILinkContainer  -- constructor
//              ~WrappedIOleUILinkContainer -- destructor
//
//  History:    11-04-94   stevebl   Created
//
//  Notes:      This is a private interface wrapper.  QueryInterface is not
//              supported and the wrapped interface may not be used outside
//              of the OLE2UI32 code.
//
//----------------------------------------------------------------------------

class WrappedIOleUILinkContainer: public IOleUILinkContainerW
{
public:
    // *** IUnknown methods *** //
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef) (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IOleUILinkContainer *** //
    STDMETHOD_(DWORD,GetNextLink) (THIS_ DWORD dwLink);
    STDMETHOD(SetLinkUpdateOptions) (THIS_ DWORD dwLink,
            DWORD dwUpdateOpt);
    STDMETHOD(GetLinkUpdateOptions) (THIS_ DWORD dwLink,
            DWORD FAR* lpdwUpdateOpt);
    STDMETHOD(SetLinkSource) (THIS_ DWORD dwLink, LPWSTR lpszDisplayName,
            ULONG lenFileName, ULONG FAR* pchEaten, BOOL fValidateSource);
    STDMETHOD(GetLinkSource) (THIS_ DWORD dwLink,
            LPWSTR FAR* lplpszDisplayName, ULONG FAR* lplenFileName,
            LPWSTR FAR* lplpszFullLinkType, LPWSTR FAR* lplpszShortLinkType,
            BOOL FAR* lpfSourceAvailable, BOOL FAR* lpfIsSelected);
    STDMETHOD(OpenLinkSource) (THIS_ DWORD dwLink);
    STDMETHOD(UpdateLink) (THIS_ DWORD dwLink,
            BOOL fErrorMessage, BOOL fErrorAction);
    STDMETHOD(CancelLink) (THIS_ DWORD dwLink);

    // *** Constructor and Destructor *** //
    WrappedIOleUILinkContainer(IOleUILinkContainerA *pilc);
    ~WrappedIOleUILinkContainer();
private:
    IOleUILinkContainerA * m_pilc;
    ULONG m_uRefCount;
};

// *** IUnknown methods *** //
HRESULT STDMETHODCALLTYPE WrappedIOleUILinkContainer::QueryInterface(THIS_ REFIID riid, LPVOID FAR* ppvObj)
{
    return(E_NOTIMPL);
}

ULONG STDMETHODCALLTYPE WrappedIOleUILinkContainer::AddRef()
{
    return(m_uRefCount++);
}

ULONG STDMETHODCALLTYPE WrappedIOleUILinkContainer::Release()
{
    ULONG uRet = --m_uRefCount;
    if (0 == uRet)
    {
        delete(this);
    }
    return(uRet);
}

// *** IOleUILinkContainer *** //
DWORD STDMETHODCALLTYPE WrappedIOleUILinkContainer::GetNextLink(DWORD dwLink)
{
    return(m_pilc->GetNextLink(dwLink));
}

HRESULT STDMETHODCALLTYPE WrappedIOleUILinkContainer::SetLinkUpdateOptions (DWORD dwLink,
        DWORD dwUpdateOpt)
{
    return(m_pilc->SetLinkUpdateOptions(dwLink, dwUpdateOpt));
}

HRESULT STDMETHODCALLTYPE WrappedIOleUILinkContainer::GetLinkUpdateOptions (DWORD dwLink,
        DWORD FAR* lpdwUpdateOpt)
{
    return(m_pilc->GetLinkUpdateOptions(dwLink, lpdwUpdateOpt));
}

//+---------------------------------------------------------------------------
//
//  Member:     WrappedIOleUILinkContainer::SetLinkSource
//
//  Synopsis:   forwards Unicode method call on to the ANSI version
//
//  Arguments:  [dwLink]          -
//              [lpszDisplayName] - [in] converted on stack
//              [lenFileName]     -
//              [pchEaten]        -
//              [fValidateSource] -
//
//  History:    11-04-94   stevebl   Created
//
//----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE WrappedIOleUILinkContainer::SetLinkSource (DWORD dwLink, LPWSTR lpszDisplayName,
        ULONG lenFileName, ULONG FAR* pchEaten, BOOL fValidateSource)
{
    char szDisplayName[MAX_PATH];
    char * lpszDisplayNameA;
    if (lpszDisplayName)
    {
        WTOA(szDisplayName, lpszDisplayName, MAX_PATH);
        lpszDisplayNameA = szDisplayName;
    }
    else
        lpszDisplayNameA = NULL;

    return(m_pilc->SetLinkSource(dwLink, lpszDisplayNameA, lenFileName, pchEaten, fValidateSource));
}

//+---------------------------------------------------------------------------
//
//  Member:     WrappedIOleUILinkContainer::GetLinkSource
//
//  Synopsis:   forwards Unicode method call on to the ANSI version
//
//  Arguments:  [dwLink]              -
//              [lplpszDisplayName]   - [out] converted on heap
//              [lplenFileName]       -
//              [lplpszFullLinkType]  - [out] converted on heap
//              [lplpszShortLinkType] - [out] converted on heap
//              [lpfSourceAvailable]  -
//              [lpfIsSelected]       -
//
//  History:    11-04-94   stevebl   Created
//
//----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE WrappedIOleUILinkContainer::GetLinkSource (DWORD dwLink,
        LPWSTR FAR* lplpszDisplayName, ULONG FAR* lplenFileName,
        LPWSTR FAR* lplpszFullLinkType, LPWSTR FAR* lplpszShortLinkType,
        BOOL FAR* lpfSourceAvailable, BOOL FAR* lpfIsSelected)
{
    LPSTR lpszDisplayName = NULL;
    LPSTR lpszFullLinkType = NULL;
    LPSTR lpszShortLinkType = NULL;
    LPSTR * lplpszDisplayNameA = NULL;
    LPSTR * lplpszFullLinkTypeA = NULL;
    LPSTR * lplpszShortLinkTypeA = NULL;
    if (lplpszDisplayName)
    {
        lplpszDisplayNameA = &lpszDisplayName;
    }
    if (lplpszFullLinkType)
    {
        lplpszFullLinkTypeA = &lpszFullLinkType;
    }
    if (lplpszShortLinkType)
    {
        lplpszShortLinkTypeA = &lpszShortLinkType;
    }
    HRESULT hrReturn = m_pilc->GetLinkSource(dwLink,
        lplpszDisplayNameA,
        lplenFileName,
        lplpszFullLinkTypeA,
        lplpszShortLinkTypeA,
        lpfSourceAvailable,
        lpfIsSelected);
    if (lplpszDisplayName)
    {
        *lplpszDisplayName = NULL;
        if (lpszDisplayName)
        {
            UINT uLen = ATOWLEN(lpszDisplayName);
            *lplpszDisplayName = (LPWSTR)OleStdMalloc(uLen * sizeof(WCHAR));
            if (*lplpszDisplayName)
            {
                ATOW(*lplpszDisplayName, lpszDisplayName, uLen);
            }
            else
                hrReturn = E_OUTOFMEMORY;
            OleStdFree((LPVOID)lpszDisplayName);
        }
    }
    if (lplpszFullLinkType)
    {
        *lplpszFullLinkType = NULL;
        if (lpszFullLinkType)
        {
            UINT uLen = ATOWLEN(lpszFullLinkType);
            *lplpszFullLinkType = (LPWSTR)OleStdMalloc(uLen * sizeof(WCHAR));
            if (*lplpszFullLinkType)
            {
                ATOW(*lplpszFullLinkType, lpszFullLinkType, uLen);
            }
            else
                hrReturn = E_OUTOFMEMORY;
            OleStdFree((LPVOID)lpszFullLinkType);
        }
    }
    if (lplpszShortLinkType)
    {
        *lplpszShortLinkType = NULL;
        if (lpszShortLinkType)
        {
            UINT uLen = ATOWLEN(lpszShortLinkType);
            *lplpszShortLinkType = (LPWSTR)OleStdMalloc(uLen * sizeof(WCHAR));
            if (*lplpszShortLinkType)
            {
                ATOW(*lplpszShortLinkType, lpszShortLinkType, uLen);
            }
            else
                hrReturn = E_OUTOFMEMORY;
            OleStdFree((LPVOID)lpszShortLinkType);
        }
    }
    return(hrReturn);
}

HRESULT STDMETHODCALLTYPE WrappedIOleUILinkContainer::OpenLinkSource (DWORD dwLink)
{
    return(m_pilc->OpenLinkSource(dwLink));
}

HRESULT STDMETHODCALLTYPE WrappedIOleUILinkContainer::UpdateLink (DWORD dwLink,
        BOOL fErrorMessage, BOOL fErrorAction)
{
    return(m_pilc->UpdateLink(dwLink, fErrorMessage, fErrorAction));
}

HRESULT STDMETHODCALLTYPE WrappedIOleUILinkContainer::CancelLink (DWORD dwLink)
{
    return(m_pilc->CancelLink(dwLink));
}

WrappedIOleUILinkContainer::WrappedIOleUILinkContainer(IOleUILinkContainerA *pilc)
{
    m_pilc = pilc;
    m_pilc->AddRef();
    m_uRefCount=1;
}

WrappedIOleUILinkContainer::~WrappedIOleUILinkContainer()
{
    m_pilc->Release();
}

//+---------------------------------------------------------------------------
//
//  Function:   OleUIEditLinksA
//
//  Synopsis:   converts call to ANSI version into call to Unicode version
//
//  Arguments:  [psA] - ANSI structure
//
//  History:    11-04-94   stevebl   Created
//
//  Notes:      Uses the WrappedIOleUILinkContainer interface wrapper.
//
//  Structure members converted or passed back out (everything is passed in):
//              lpszCaption     [in] on stack
//              lpszTemplate    [in] on stack
//              dwFlags         [out]
//              lpOleUILinkContainer [in] wrapped interface
//
//----------------------------------------------------------------------------

STDAPI_(UINT) OleUIEditLinksA(LPOLEUIEDITLINKSA psA)
{
    UINT uRet = UStandardValidation((LPOLEUISTANDARD)psA, sizeof(*psA), NULL);

    // If the caller is using a private template, UStandardValidation will
    // always return OLEUI_ERR_FINDTEMPLATEFAILURE here.  This is because we
    // haven't converted the template name to UNICODE yet, so the
    // FindResource call in UStandardValidation won't find the caller's
    // template.  This is OK for two reasons: (1) it's the last thing that
    // UStandardValidation checks so by this time it's basically done its
    // job, and (2) UStandardValidation will be called again when we forward
    // this call on to the Unicode version.
    if (OLEUI_SUCCESS != uRet && OLEUI_ERR_FINDTEMPLATEFAILURE != uRet)
            return uRet;

    uRet = OLEUI_SUCCESS;

    // Validate interface.
    if (NULL == psA->lpOleUILinkContainer)
    {
        uRet = OLEUI_ELERR_LINKCNTRNULL;
    }
    else if(IsBadReadPtr(psA->lpOleUILinkContainer, sizeof(IOleUILinkContainerA)))
    {
        uRet = OLEUI_ELERR_LINKCNTRINVALID;
    }

    if (OLEUI_SUCCESS != uRet)
    {
        return(uRet);
    }


    OLEUIEDITLINKSW sW;
    WCHAR szCaption[MAX_PATH], szTemplate[MAX_PATH];
    uRet = OLEUI_ERR_LOCALMEMALLOC;

    memcpy(&sW, psA, sizeof(OLEUIEDITLINKSW));
    if (psA->lpszCaption)
    {
        ATOW(szCaption, psA->lpszCaption, MAX_PATH);
        sW.lpszCaption = szCaption;
    }
    if (0 != HIWORD(PtrToUlong(psA->lpszTemplate)))
    {
        ATOW(szTemplate, psA->lpszTemplate, MAX_PATH);
        sW.lpszTemplate = szTemplate;
    }

    sW.lpOleUILinkContainer = new WrappedIOleUILinkContainer(psA->lpOleUILinkContainer);
    if (NULL == sW.lpOleUILinkContainer)
    {
        return(uRet);
    }

    uRet = OleUIEditLinksW(&sW);

    psA->dwFlags = sW.dwFlags;
    sW.lpOleUILinkContainer->Release();
    return(uRet);
}

//+---------------------------------------------------------------------------
//
//  Function:   OleUIChangeIconA
//
//  Synopsis:   converts call to ANSI version into call to Unicode version
//
//  Arguments:  [psA] - ANSI structure
//
//  History:    11-04-94   stevebl   Created
//
//  Structure members converted or passed back out (everything is passed in):
//              lpszCaption     [in] on stack
//              lpszTemplate    [in] on stack
//              szIconExe       [in] array embedded in structure
//              dwFlags         [out]
//              hMetaPict       [out]
//
//----------------------------------------------------------------------------

STDAPI_(UINT) OleUIChangeIconA(LPOLEUICHANGEICONA psA)
{
    UINT uRet = UStandardValidation((LPOLEUISTANDARD)psA, sizeof(*psA), NULL);

    // If the caller is using a private template, UStandardValidation will
    // always return OLEUI_ERR_FINDTEMPLATEFAILURE here.  This is because we
    // haven't converted the template name to UNICODE yet, so the
    // FindResource call in UStandardValidation won't find the caller's
    // template.  This is OK for two reasons: (1) it's the last thing that
    // UStandardValidation checks so by this time it's basically done its
    // job, and (2) UStandardValidation will be called again when we forward
    // this call on to the Unicode version.
    if (OLEUI_SUCCESS != uRet && OLEUI_ERR_FINDTEMPLATEFAILURE != uRet)
            return uRet;

    OLEUICHANGEICONW sW;
    WCHAR szCaption[MAX_PATH], szTemplate[MAX_PATH];

    memcpy(&sW, psA, sizeof(OLEUICHANGEICONA));

    sW.cbStruct = sizeof(OLEUICHANGEICONW);

    if (psA->lpszCaption)
    {
        ATOW(szCaption, psA->lpszCaption, MAX_PATH);
        sW.lpszCaption = szCaption;
    }
    if (0 != HIWORD(PtrToUlong(psA->lpszTemplate)))
    {
        ATOW(szTemplate, psA->lpszTemplate, MAX_PATH);
        sW.lpszTemplate = szTemplate;
    }
    ATOW(sW.szIconExe, psA->szIconExe, MAX_PATH);
    sW.cchIconExe = psA->cchIconExe;


    uRet = OleUIChangeIconW(&sW);

    psA->dwFlags = sW.dwFlags;
    psA->hMetaPict = sW.hMetaPict;
    return(uRet);
}

//+---------------------------------------------------------------------------
//
//  Function:   OleUIConvertA
//
//  Synopsis:   converts a call to ANSI version into call to Unicode version
//
//  Arguments:  [psA] - ANSI structure
//
//  History:    11-04-94   stevebl   Created
//
//  Structure members converted or passed back out (everything is passed in):
//              lpszCaption     [in] on stack
//              lpszTemplate    [in] on stack
//              lpszUserType    [in] on heap
//                              [out] always freed and returned as NULL
//              lpszDefLabel    [in] on heap
//              lpszDefLabel    [out] always freed and returned as NULL
//              dwFlags         [out]
//              clsidNew        [out]
//              dvAspect        [out]
//              hMetaPict       [out]
//
//----------------------------------------------------------------------------

STDAPI_(UINT) OleUIConvertA(LPOLEUICONVERTA psA)
{
    UINT uRet = UStandardValidation((LPOLEUISTANDARD)psA, sizeof(*psA), NULL);

    // If the caller is using a private template, UStandardValidation will
    // always return OLEUI_ERR_FINDTEMPLATEFAILURE here.  This is because we
    // haven't converted the template name to UNICODE yet, so the
    // FindResource call in UStandardValidation won't find the caller's
    // template.  This is OK for two reasons: (1) it's the last thing that
    // UStandardValidation checks so by this time it's basically done its
    // job, and (2) UStandardValidation will be called again when we forward
    // this call on to the Unicode version.
    if (OLEUI_SUCCESS != uRet && OLEUI_ERR_FINDTEMPLATEFAILURE != uRet)
            return uRet;

    if ((NULL != psA->lpszUserType)
        && (IsBadReadPtr(psA->lpszUserType, 1)))
        return(OLEUI_CTERR_STRINGINVALID);

    if ( (NULL != psA->lpszDefLabel)
        && (IsBadReadPtr(psA->lpszDefLabel, 1)) )
        return(OLEUI_CTERR_STRINGINVALID);

    OLEUICONVERTW sW;
    WCHAR szCaption[MAX_PATH], szTemplate[MAX_PATH];
    uRet = OLEUI_ERR_LOCALMEMALLOC;

    memcpy(&sW, psA, sizeof(OLEUICONVERTW));
    if (psA->lpszCaption)
    {
        ATOW(szCaption, psA->lpszCaption, MAX_PATH);
        sW.lpszCaption = szCaption;
    }
    if (0 != HIWORD(PtrToUlong(psA->lpszTemplate)))
    {
        ATOW(szTemplate, psA->lpszTemplate, MAX_PATH);
        sW.lpszTemplate = szTemplate;
    }
    sW.lpszUserType = sW.lpszDefLabel = NULL;
    if (psA->lpszUserType)
    {
        UINT uLen = ATOWLEN(psA->lpszUserType);
        sW.lpszUserType = (LPWSTR)OleStdMalloc(uLen * sizeof(WCHAR));
        if (!sW.lpszUserType)
        {
            goto oom_error;
        }
        ATOW(sW.lpszUserType, psA->lpszUserType, uLen);
    }
    if (psA->lpszDefLabel)
    {
        UINT uLen = ATOWLEN(psA->lpszDefLabel);
        sW.lpszDefLabel = (LPWSTR)OleStdMalloc(uLen * sizeof(WCHAR));
        if (!sW.lpszDefLabel)
        {
            goto oom_error;
        }
        ATOW(sW.lpszDefLabel, psA->lpszDefLabel, uLen);
    }

    uRet = OleUIConvertW(&sW);

    psA->dwFlags = sW.dwFlags;
    memcpy(&psA->clsidNew, &sW.clsidNew, sizeof(CLSID));
    psA->dvAspect = sW.dvAspect;
    psA->hMetaPict = sW.hMetaPict;
    psA->fObjectsIconChanged = sW.fObjectsIconChanged;
oom_error:
    if (sW.lpszUserType)
    {
        OleStdFree((LPVOID)sW.lpszUserType);
    }
    if (sW.lpszDefLabel)
    {
        OleStdFree((LPVOID)sW.lpszDefLabel);
    }
    if (psA->lpszUserType)
    {
        OleStdFree((LPVOID)psA->lpszUserType);
        psA->lpszUserType = NULL;
    }
    if (psA->lpszDefLabel)
    {
        OleStdFree((LPVOID)psA->lpszDefLabel);
        psA->lpszDefLabel = NULL;
    }
    return(uRet);
}

//+---------------------------------------------------------------------------
//
//  Function:   OleUIBusyA
//
//  Synopsis:   converts call to ANSI version into call to Unicode version
//
//  Arguments:  [psA] - ANSI structure
//
//  History:    11-04-94   stevebl   Created
//
//  Structure members converted or passed back out (everything is passed in):
//              lpszCaption     [in] on stack
//              lpszTemplate    [in] on stack
//              dwFlags         [out]
//
//----------------------------------------------------------------------------

STDAPI_(UINT) OleUIBusyA(LPOLEUIBUSYA psA)
{
    UINT uRet = UStandardValidation((LPOLEUISTANDARD)psA, sizeof(*psA), NULL);

    // If the caller is using a private template, UStandardValidation will
    // always return OLEUI_ERR_FINDTEMPLATEFAILURE here.  This is because we
    // haven't converted the template name to UNICODE yet, so the
    // FindResource call in UStandardValidation won't find the caller's
    // template.  This is OK for two reasons: (1) it's the last thing that
    // UStandardValidation checks so by this time it's basically done its
    // job, and (2) UStandardValidation will be called again when we forward
    // this call on to the Unicode version.
    if (OLEUI_SUCCESS != uRet && OLEUI_ERR_FINDTEMPLATEFAILURE != uRet)
            return uRet;

    OLEUIBUSYW sW;
    WCHAR szCaption[MAX_PATH], szTemplate[MAX_PATH];

    memcpy(&sW, psA, sizeof(OLEUIBUSYW));
    if (psA->lpszCaption)
    {
        ATOW(szCaption, psA->lpszCaption, MAX_PATH);
        sW.lpszCaption = szCaption;
    }
    if (0 != HIWORD(PtrToUlong(psA->lpszTemplate)))
    {
        ATOW(szTemplate, psA->lpszTemplate, MAX_PATH);
        sW.lpszTemplate = szTemplate;
    }
    uRet = OleUIBusyW(&sW);

    psA->dwFlags = sW.dwFlags;
    return(uRet);
}

//+---------------------------------------------------------------------------
//
//  Function:   OleUIUpdateLinksA
//
//  Synopsis:   converts call to ANSI version into call to Unicode version
//
//  Arguments:  [lpOleUILinkCntr] - [in] wrapped with Unicode version
//              [hwndParent]      -
//              [lpszTitle]       - [in] on stack
//              [cLinks]          -
//
//  History:    11-04-94   stevebl   Created
//
//----------------------------------------------------------------------------

STDAPI_(BOOL) OleUIUpdateLinksA(LPOLEUILINKCONTAINERA lpOleUILinkCntr,
        HWND hwndParent, LPSTR lpszTitle, int cLinks)
{
    WrappedIOleUILinkContainer * lpWrappedOleUILinkCntr = NULL;

    if (NULL != lpszTitle && IsBadReadPtr(lpszTitle, 1))
        return(FALSE);

    if (NULL == lpOleUILinkCntr || IsBadReadPtr(lpOleUILinkCntr, sizeof(IOleUILinkContainerA)))
        return(FALSE);

    lpWrappedOleUILinkCntr = new WrappedIOleUILinkContainer(lpOleUILinkCntr);
    if (NULL == lpWrappedOleUILinkCntr)
        return(FALSE); // ran out of memory

    WCHAR wszTitle[MAX_PATH];
    WCHAR *lpwszTitle;
    if (lpszTitle)
    {
        ATOW(wszTitle, lpszTitle, MAX_PATH);
        lpwszTitle = wszTitle;
    }
    else
        lpwszTitle = NULL;
    BOOL fReturn = OleUIUpdateLinksW(lpWrappedOleUILinkCntr, hwndParent, lpwszTitle, cLinks);

    lpWrappedOleUILinkCntr->Release();

    return(fReturn);
}

//+---------------------------------------------------------------------------
//
//  Class:      WrappedIOleUIObjInfo
//
//  Purpose:    Wraps IOleUIObjInfoA with IOleUIObjInfoW methods
//              so it can be passed on to Unicode methods within OLE2UI32.
//
//  Interface:  QueryInterface        --
//              AddRef                --
//              Release               --
//              GetObjectInfo         -- requires string conversion
//              GetConvertInfo        --
//              ConvertObject         --
//              GetViewInfo           --
//              SetViewInfo           --
//              WrappedIOleUIObjInfo  -- constructor
//              ~WrappedIOleUIObjInfo -- destructor
//
//  History:    11-08-94   stevebl   Created
//
//  Notes:      This is a private interface wrapper.  QueryInterface is not
//              supported and the wrapped interface may not be used outside
//              of the OLE2UI32 code.
//
//----------------------------------------------------------------------------

class WrappedIOleUIObjInfo: public IOleUIObjInfoW
{
public:
    // *** IUnknown methods *** //
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef) (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** extra for General Properties *** //
    STDMETHOD(GetObjectInfo) (THIS_ DWORD dwObject,
            DWORD FAR* lpdwObjSize, LPWSTR FAR* lplpszLabel,
            LPWSTR FAR* lplpszType, LPWSTR FAR* lplpszShortType,
            LPWSTR FAR* lplpszLocation);
    STDMETHOD(GetConvertInfo) (THIS_ DWORD dwObject,
            CLSID FAR* lpClassID, WORD FAR* lpwFormat,
            CLSID FAR* lpConvertDefaultClassID,
            LPCLSID FAR* lplpClsidExclude, UINT FAR* lpcClsidExclude);
    STDMETHOD(ConvertObject) (THIS_ DWORD dwObject, REFCLSID clsidNew);

    // *** extra for View Properties *** //
    STDMETHOD(GetViewInfo) (THIS_ DWORD dwObject,
            HGLOBAL FAR* phMetaPict, DWORD* pdvAspect, int* pnCurrentScale);
    STDMETHOD(SetViewInfo) (THIS_ DWORD dwObject,
            HGLOBAL hMetaPict, DWORD dvAspect,
            int nCurrentScale, BOOL bRelativeToOrig);
    // *** Constructor and Destructor *** //
    WrappedIOleUIObjInfo(IOleUIObjInfoA * pioi);
    ~WrappedIOleUIObjInfo();
private:
    IOleUIObjInfoA * m_pioi;
    ULONG m_uRefCount;
};

// *** IUnknown methods *** //
HRESULT STDMETHODCALLTYPE WrappedIOleUIObjInfo::QueryInterface(THIS_ REFIID riid, LPVOID FAR* ppvObj)
{
    return(E_NOTIMPL);
}

ULONG STDMETHODCALLTYPE WrappedIOleUIObjInfo::AddRef()
{
    return(m_uRefCount++);
}

ULONG STDMETHODCALLTYPE WrappedIOleUIObjInfo::Release()
{
    ULONG uRet = --m_uRefCount;
    if (0 == uRet)
    {
        delete(this);
    }
    return(uRet);
}

//+---------------------------------------------------------------------------
//
//  Member:     WrappedIOleUIObjInfo::GetObjectInfo
//
//  Synopsis:   forwards Unicode method call on to the ANSI version
//
//  Arguments:  [dwObject]        -
//              [lpdwObjSize]     -
//              [lplpszLabel]     - [out] converted on heap
//              [lplpszType]      - [out] converted on heap
//              [lplpszShortType] - [out] converted on heap
//              [lplpszLocation]  - [out] converted on heap
//
//  History:    11-09-94   stevebl   Created
//
//----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE WrappedIOleUIObjInfo::GetObjectInfo(DWORD dwObject,
        DWORD FAR* lpdwObjSize, LPWSTR FAR* lplpszLabel,
        LPWSTR FAR* lplpszType, LPWSTR FAR* lplpszShortType,
        LPWSTR FAR* lplpszLocation)
{
    LPSTR lpszLabel = NULL;
    LPSTR lpszType = NULL;
    LPSTR lpszShortType = NULL;
    LPSTR lpszLocation = NULL;
    LPSTR * lplpszLabelA = NULL;
    LPSTR * lplpszTypeA = NULL;
    LPSTR * lplpszShortTypeA = NULL;
    LPSTR * lplpszLocationA = NULL;
    if (lplpszLabel)
    {
        lplpszLabelA = &lpszLabel;
    }
    if (lplpszType)
    {
        lplpszTypeA = &lpszType;
    }
    if (lplpszShortType)
    {
        lplpszShortTypeA = &lpszShortType;
    }
    if (lplpszLocation)
    {
        lplpszLocationA = &lpszLocation;
    }
    HRESULT hrReturn = m_pioi->GetObjectInfo(dwObject,
        lpdwObjSize,
        lplpszLabelA,
        lplpszTypeA,
        lplpszShortTypeA,
        lplpszLocationA);
    if (lplpszLabel)
    {
        *lplpszLabel = NULL;
        if (lpszLabel)
        {
            UINT uLen = ATOWLEN(lpszLabel);
            *lplpszLabel = (LPWSTR)OleStdMalloc(uLen * sizeof(WCHAR));
            if (*lplpszLabel)
            {
                ATOW(*lplpszLabel, lpszLabel, uLen);
            }
            else
                hrReturn = E_OUTOFMEMORY;
            OleStdFree((LPVOID)lpszLabel);
        }
    }
    if (lplpszType)
    {
        *lplpszType = NULL;
        if (lpszType)
        {
            UINT uLen = ATOWLEN(lpszType);
            *lplpszType = (LPWSTR)OleStdMalloc(uLen * sizeof(WCHAR));
            if (*lplpszType)
            {
                ATOW(*lplpszType, lpszType, uLen);
            }
            else
                hrReturn = E_OUTOFMEMORY;
            OleStdFree((LPVOID)lpszType);
        }
    }
    if (lplpszShortType)
    {
        *lplpszShortType = NULL;
        if (lpszShortType)
        {
            UINT uLen = ATOWLEN(lpszShortType);
            *lplpszShortType = (LPWSTR)OleStdMalloc(uLen * sizeof(WCHAR));
            if (*lplpszShortType)
            {
                ATOW(*lplpszShortType, lpszShortType, uLen);
            }
            else
                hrReturn = E_OUTOFMEMORY;
            OleStdFree((LPVOID)lpszShortType);
        }
    }
    if (lplpszLocation)
    {
        *lplpszLocation = NULL;
        if (lpszLocation)
        {
            UINT uLen = ATOWLEN(lpszLocation);
            *lplpszLocation = (LPWSTR)OleStdMalloc(uLen * sizeof(WCHAR));
            if (*lplpszLocation)
            {
                ATOW(*lplpszLocation, lpszLocation, uLen);
            }
            else
                hrReturn = E_OUTOFMEMORY;
            OleStdFree((LPVOID)lpszLocation);
        }
    }
    return(hrReturn);
}

HRESULT STDMETHODCALLTYPE WrappedIOleUIObjInfo::GetConvertInfo(DWORD dwObject,
        CLSID FAR* lpClassID, WORD FAR* lpwFormat,
        CLSID FAR* lpConvertDefaultClassID,
        LPCLSID FAR* lplpClsidExclude, UINT FAR* lpcClsidExclude)
{
    return(m_pioi->GetConvertInfo(dwObject,
        lpClassID,
        lpwFormat,
        lpConvertDefaultClassID,
        lplpClsidExclude,
        lpcClsidExclude));
}

HRESULT STDMETHODCALLTYPE WrappedIOleUIObjInfo::ConvertObject(DWORD dwObject, REFCLSID clsidNew)
{
    return(m_pioi->ConvertObject(dwObject, clsidNew));
}

HRESULT STDMETHODCALLTYPE WrappedIOleUIObjInfo::GetViewInfo(DWORD dwObject,
        HGLOBAL FAR* phMetaPict, DWORD* pdvAspect, int* pnCurrentScale)
{
    return(m_pioi->GetViewInfo(dwObject, phMetaPict, pdvAspect, pnCurrentScale));
}

HRESULT STDMETHODCALLTYPE WrappedIOleUIObjInfo::SetViewInfo(DWORD dwObject,
        HGLOBAL hMetaPict, DWORD dvAspect,
        int nCurrentScale, BOOL bRelativeToOrig)
{
    return(m_pioi->SetViewInfo(dwObject, hMetaPict, dvAspect, nCurrentScale, bRelativeToOrig));
}

WrappedIOleUIObjInfo::WrappedIOleUIObjInfo(IOleUIObjInfoA *pioi)
{
    m_pioi = pioi;
    m_pioi->AddRef();
    m_uRefCount=1;
}

WrappedIOleUIObjInfo::~WrappedIOleUIObjInfo()
{
    m_pioi->Release();
}


//+---------------------------------------------------------------------------
//
//  Class:      WrappedIOleUILinkInfo
//
//  Purpose:    Wraps IOleUILinkInfoA with IOleUILinkInfoW methods
//              so it can be passed on to Unicode methods within OLE2UI32.
//
//  Interface:  QueryInterface         --
//              AddRef                 --
//              Release                --
//              GetNextLink            --
//              SetLinkUpdateOptions   --
//              GetLinkUpdateOptions   --
//              SetLinkSource          -- requires string conversion
//              GetLinkSource          -- requires string conversion
//              OpenLinkSource         --
//              UpdateLink             --
//              CancelLink             --
//              GetLastUpdate          --
//              WrappedIOleUILinkInfo  -- constructor
//              ~WrappedIOleUILinkInfo -- destructor
//
//  History:    11-08-94   stevebl   Created
//
//  Notes:      This is a private interface wrapper.  QueryInterface is not
//              supported and the wrapped interface may not be used outside
//              of the OLE2UI32 code.
//
//----------------------------------------------------------------------------

class WrappedIOleUILinkInfo: public IOleUILinkInfoW
{
public:
    // *** IUnknown methods *** //
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef) (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IOleUILinkContainer *** //
    STDMETHOD_(DWORD,GetNextLink) (THIS_ DWORD dwLink);
    STDMETHOD(SetLinkUpdateOptions) (THIS_ DWORD dwLink,
            DWORD dwUpdateOpt);
    STDMETHOD(GetLinkUpdateOptions) (THIS_ DWORD dwLink,
            DWORD FAR* lpdwUpdateOpt);
    STDMETHOD(SetLinkSource) (THIS_ DWORD dwLink, LPWSTR lpszDisplayName,
            ULONG lenFileName, ULONG FAR* pchEaten, BOOL fValidateSource);
    STDMETHOD(GetLinkSource) (THIS_ DWORD dwLink,
            LPWSTR FAR* lplpszDisplayName, ULONG FAR* lplenFileName,
            LPWSTR FAR* lplpszFullLinkType, LPWSTR FAR* lplpszShortLinkType,
            BOOL FAR* lpfSourceAvailable, BOOL FAR* lpfIsSelected);
    STDMETHOD(OpenLinkSource) (THIS_ DWORD dwLink);
    STDMETHOD(UpdateLink) (THIS_ DWORD dwLink,
            BOOL fErrorMessage, BOOL fErrorAction);
    STDMETHOD(CancelLink) (THIS_ DWORD dwLink);

    // *** extra for Link Properties ***//
    STDMETHOD(GetLastUpdate) (THIS_ DWORD dwLink,
            FILETIME FAR* lpLastUpdate);

    // *** Constructor and Destructor *** //
    WrappedIOleUILinkInfo(IOleUILinkInfoA *pili);
    ~WrappedIOleUILinkInfo();
private:
    IOleUILinkInfoA * m_pili;
    ULONG m_uRefCount;
};

// *** IUnknown methods *** //
HRESULT STDMETHODCALLTYPE WrappedIOleUILinkInfo::QueryInterface(THIS_ REFIID riid, LPVOID FAR* ppvObj)
{
    return(E_NOTIMPL);
}

ULONG STDMETHODCALLTYPE WrappedIOleUILinkInfo::AddRef()
{
    return(m_uRefCount++);
}

ULONG STDMETHODCALLTYPE WrappedIOleUILinkInfo::Release()
{
    ULONG uRet = --m_uRefCount;
    if (0 == uRet)
    {
        delete(this);
    }
    return(uRet);
}

// *** IOleUILinkInfo *** //
DWORD STDMETHODCALLTYPE WrappedIOleUILinkInfo::GetNextLink(DWORD dwLink)
{
    return(m_pili->GetNextLink(dwLink));
}

HRESULT STDMETHODCALLTYPE WrappedIOleUILinkInfo::SetLinkUpdateOptions (DWORD dwLink,
        DWORD dwUpdateOpt)
{
    return(m_pili->SetLinkUpdateOptions(dwLink, dwUpdateOpt));
}

HRESULT STDMETHODCALLTYPE WrappedIOleUILinkInfo::GetLinkUpdateOptions (DWORD dwLink,
        DWORD FAR* lpdwUpdateOpt)
{
    return(m_pili->GetLinkUpdateOptions(dwLink, lpdwUpdateOpt));
}

//+---------------------------------------------------------------------------
//
//  Member:     WrappedIOleUILinkInfo::SetLinkSource
//
//  Synopsis:   forwards Unicode method call on to the ANSI version
//
//  Arguments:  [dwLink]          -
//              [lpszDisplayName] - [in] converted on stack
//              [lenFileName]     -
//              [pchEaten]        -
//              [fValidateSource] -
//
//  History:    11-04-94   stevebl   Created
//
//----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE WrappedIOleUILinkInfo::SetLinkSource (DWORD dwLink, LPWSTR lpszDisplayName,
        ULONG lenFileName, ULONG FAR* pchEaten, BOOL fValidateSource)
{
    char szDisplayName[MAX_PATH];
    char * lpszDisplayNameA;
    if (lpszDisplayName)
    {
        WTOA(szDisplayName, lpszDisplayName, MAX_PATH);
        lpszDisplayNameA = szDisplayName;
    }
    else
        lpszDisplayNameA = NULL;

    return(m_pili->SetLinkSource(dwLink, lpszDisplayNameA, lenFileName, pchEaten, fValidateSource));
}

//+---------------------------------------------------------------------------
//
//  Member:     WrappedIOleUILinkInfo::GetLinkSource
//
//  Synopsis:   forwards Unicode method call on to the ANSI version
//
//  Arguments:  [dwLink]              -
//              [lplpszDisplayName]   - [out] converted on heap
//              [lplenFileName]       -
//              [lplpszFullLinkType]  - [out] converted on heap
//              [lplpszShortLinkType] - [out] converted on heap
//              [lpfSourceAvailable]  -
//              [lpfIsSelected]       -
//
//  History:    11-04-94   stevebl   Created
//
//----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE WrappedIOleUILinkInfo::GetLinkSource (DWORD dwLink,
        LPWSTR FAR* lplpszDisplayName, ULONG FAR* lplenFileName,
        LPWSTR FAR* lplpszFullLinkType, LPWSTR FAR* lplpszShortLinkType,
        BOOL FAR* lpfSourceAvailable, BOOL FAR* lpfIsSelected)
{
    LPSTR lpszDisplayName = NULL;
    LPSTR lpszFullLinkType = NULL;
    LPSTR lpszShortLinkType = NULL;
    LPSTR * lplpszDisplayNameA = NULL;
    LPSTR * lplpszFullLinkTypeA = NULL;
    LPSTR * lplpszShortLinkTypeA = NULL;
    if (lplpszDisplayName)
    {
        lplpszDisplayNameA = &lpszDisplayName;
    }
    if (lplpszFullLinkType)
    {
        lplpszFullLinkTypeA = &lpszFullLinkType;
    }
    if (lplpszShortLinkType)
    {
        lplpszShortLinkTypeA = &lpszShortLinkType;
    }
    HRESULT hrReturn = m_pili->GetLinkSource(dwLink,
        lplpszDisplayNameA,
        lplenFileName,
        lplpszFullLinkTypeA,
        lplpszShortLinkTypeA,
        lpfSourceAvailable,
        lpfIsSelected);
    if (lplpszDisplayName)
    {
        *lplpszDisplayName = NULL;
        if (lpszDisplayName)
        {
            UINT uLen = ATOWLEN(lpszDisplayName);
            *lplpszDisplayName = (LPWSTR)OleStdMalloc(uLen * sizeof(WCHAR));
            if (*lplpszDisplayName)
            {
                ATOW(*lplpszDisplayName, lpszDisplayName, uLen);
            }
            else
                hrReturn = E_OUTOFMEMORY;
            OleStdFree((LPVOID)lpszDisplayName);
        }
    }
    if (lplpszFullLinkType)
    {
        *lplpszFullLinkType = NULL;
        if (lpszFullLinkType)
        {
            UINT uLen = ATOWLEN(lpszFullLinkType);
            *lplpszFullLinkType = (LPWSTR)OleStdMalloc(uLen * sizeof(WCHAR));
            if (*lplpszFullLinkType)
            {
                ATOW(*lplpszFullLinkType, lpszFullLinkType, uLen);
            }
            else
                hrReturn = E_OUTOFMEMORY;
            OleStdFree((LPVOID)lpszFullLinkType);
        }
    }
    if (lplpszShortLinkType)
    {
        *lplpszShortLinkType = NULL;
        if (lpszShortLinkType)
        {
            UINT uLen = ATOWLEN(lpszShortLinkType);
            *lplpszShortLinkType = (LPWSTR)OleStdMalloc(uLen * sizeof(WCHAR));
            if (*lplpszShortLinkType)
            {
                ATOW(*lplpszShortLinkType, lpszShortLinkType, uLen);
            }
            else
                hrReturn = E_OUTOFMEMORY;
            OleStdFree((LPVOID)lpszShortLinkType);
        }
    }
    return(hrReturn);
}

HRESULT STDMETHODCALLTYPE WrappedIOleUILinkInfo::OpenLinkSource (DWORD dwLink)
{
    return(m_pili->OpenLinkSource(dwLink));
}

HRESULT STDMETHODCALLTYPE WrappedIOleUILinkInfo::UpdateLink (DWORD dwLink,
        BOOL fErrorMessage, BOOL fErrorAction)
{
    return(m_pili->UpdateLink(dwLink, fErrorMessage, fErrorAction));
}

HRESULT STDMETHODCALLTYPE WrappedIOleUILinkInfo::CancelLink (DWORD dwLink)
{
    return(m_pili->CancelLink(dwLink));
}

HRESULT STDMETHODCALLTYPE WrappedIOleUILinkInfo::GetLastUpdate (DWORD dwLink,
            FILETIME FAR* lpLastUpdate)
{
    return(m_pili->GetLastUpdate(dwLink, lpLastUpdate));
}

WrappedIOleUILinkInfo::WrappedIOleUILinkInfo(IOleUILinkInfoA *pili)
{
    m_pili = pili;
    m_pili->AddRef();
    m_uRefCount=1;
}

WrappedIOleUILinkInfo::~WrappedIOleUILinkInfo()
{
    m_pili->Release();
}


//+---------------------------------------------------------------------------
//
//  Function:   OleUIObjectPropertiesA
//
//  Synopsis:   converts call to ANSI version into call to Unicode version
//
//  Arguments:  [psA] - ANSI structure
//
//  History:    11-04-94   stevebl   Created
//
//  Structure members converted or passed back out (everything is passed in):
//              lpPS            [in]
//              lpObjInfo       [in] wrapped with Unicode interface
//              lpLinkInfo      [in] wrapped with Unicode interface
//              lpGP            [in] (no data conversion, only type conversion)
//              lpVP            [in] (no data conversion, only type conversion)
//              lpLP            [in] (no data conversion, only type conversion)
//
//              dwFlags         [out]
//
//----------------------------------------------------------------------------

STDAPI_(UINT) OleUIObjectPropertiesA(LPOLEUIOBJECTPROPSA psA)
{
    if (NULL == psA)
    {
        return(OLEUI_ERR_STRUCTURENULL);
    }

    if (IsBadWritePtr(psA, sizeof(OLEUIOBJECTPROPSA)))
        return OLEUI_ERR_STRUCTUREINVALID;

    LPOLEUIOBJECTPROPSW psW;
    UINT uRet = OLEUI_ERR_LOCALMEMALLOC;

    if (NULL == psA->lpObjInfo)
    {
        return(OLEUI_OPERR_OBJINFOINVALID);
    }

    if (IsBadReadPtr(psA->lpObjInfo, sizeof(IOleUIObjInfoA)))
    {
        return(OLEUI_OPERR_OBJINFOINVALID);
    }

    if (psA->dwFlags & OPF_OBJECTISLINK)
    {
        if (NULL == psA->lpLinkInfo)
        {
            return(OLEUI_OPERR_LINKINFOINVALID);
        }

        if (IsBadReadPtr(psA->lpLinkInfo, sizeof(IOleUILinkInfoA)))
        {
            return(OLEUI_OPERR_LINKINFOINVALID);
        }
    }

    BOOL fWrappedIOleUILinkInfo = FALSE;
    psW = (LPOLEUIOBJECTPROPSW) OleStdMalloc(sizeof(OLEUIOBJECTPROPSW));
    if (NULL != psW)
    {
        memcpy(psW, psA, sizeof(OLEUIOBJECTPROPSW));
        psW->lpObjInfo = new WrappedIOleUIObjInfo(psA->lpObjInfo);
        if (NULL == psW->lpObjInfo)
        {
            OleStdFree(psW);
            return(uRet);
        }
        if (psW->dwFlags & OPF_OBJECTISLINK)
        {
            psW->lpLinkInfo = new WrappedIOleUILinkInfo(psA->lpLinkInfo);
            if (NULL == psW->lpLinkInfo)
            {
                psW->lpObjInfo->Release();
                OleStdFree(psW);
                return(uRet);
            }
            fWrappedIOleUILinkInfo = TRUE;
        }
        uRet = InternalObjectProperties(psW, FALSE);
        psA->dwFlags = psW->dwFlags;
        psW->lpObjInfo->Release();
        if (fWrappedIOleUILinkInfo)
        {
            psW->lpLinkInfo->Release();
        }
        OleStdFree(psW);
    }
    return(uRet);
}

//+---------------------------------------------------------------------------
//
//  Function:   OleUIChangeSourceA
//
//  Synopsis:   converts call to ANSI version into call to Unicode version
//
//  Arguments:  [psA] - ANSI structure
//
//  History:    11-04-94   stevebl   Created
//
//  Structure members converted or passed back out (everything is passed in):
//              lpszCaption     [in] on stack
//              lpszTemplate    [in] on stack
//              lpszDisplayName [in, out] on heap
//              lpszFrom        [out] on heap
//              lpszTo          [out] on heap
//              lpOleUILinkContainer  [in] wrapped interface
//              dwFlags         [out]
//              nFileLength     [out]
//
//----------------------------------------------------------------------------

STDAPI_(UINT) OleUIChangeSourceA(LPOLEUICHANGESOURCEA psA)
{
    UINT uRet = UStandardValidation((LPOLEUISTANDARD)psA, sizeof(*psA), NULL);

    // If the caller is using a private template, UStandardValidation will
    // always return OLEUI_ERR_FINDTEMPLATEFAILURE here.  This is because we
    // haven't converted the template name to UNICODE yet, so the
    // FindResource call in UStandardValidation won't find the caller's
    // template.  This is OK for two reasons: (1) it's the last thing that
    // UStandardValidation checks so by this time it's basically done its
    // job, and (2) UStandardValidation will be called again when we forward
    // this call on to the Unicode version.
    if (OLEUI_SUCCESS != uRet && OLEUI_ERR_FINDTEMPLATEFAILURE != uRet)
            return uRet;

    // lpszFrom and lpszTo must be NULL (they are out only)
    if (psA->lpszFrom != NULL)
    {
        return(OLEUI_CSERR_FROMNOTNULL);
    }
    if (psA->lpszTo != NULL)
    {
        return(OLEUI_CSERR_TONOTNULL);
    }

    // lpszDisplayName must be valid or NULL
    if (psA->lpszDisplayName != NULL &&
        IsBadReadPtr(psA->lpszDisplayName, 1))
    {
        return(OLEUI_CSERR_SOURCEINVALID);
    }

    OLEUICHANGESOURCEW sW;
    WCHAR szCaption[MAX_PATH], szTemplate[MAX_PATH];
    uRet = OLEUI_ERR_LOCALMEMALLOC;

    memcpy(&sW, psA, sizeof(OLEUICHANGESOURCEW));
    if (psA->lpszCaption != NULL)
    {
        ATOW(szCaption, psA->lpszCaption, MAX_PATH);
        sW.lpszCaption = szCaption;
    }
    if (0 != HIWORD(PtrToUlong(psA->lpszTemplate)))
    {
        ATOW(szTemplate, psA->lpszTemplate, MAX_PATH);
        sW.lpszTemplate = szTemplate;
    }
    if (psA->lpszDisplayName)
    {
        UINT uLen = ATOWLEN(psA->lpszDisplayName);
        sW.lpszDisplayName = (LPWSTR)OleStdMalloc(uLen * sizeof(WCHAR));
        if (!sW.lpszDisplayName)
        {
            return(uRet);
        }
        ATOW(sW.lpszDisplayName, psA->lpszDisplayName, uLen);
    }
    if (NULL != psA->lpOleUILinkContainer)
    {
        if (IsBadReadPtr(psA->lpOleUILinkContainer, sizeof(IOleUILinkContainerA)))
        {
            return(OLEUI_CSERR_LINKCNTRINVALID);
        }
        sW.lpOleUILinkContainer = new WrappedIOleUILinkContainer(psA->lpOleUILinkContainer);
        if (NULL == sW.lpOleUILinkContainer)
        {
            return(uRet);
        }
    }

    uRet = OleUIChangeSourceW(&sW);
    if (psA->lpszDisplayName)
    {
        OleStdFree((LPVOID)psA->lpszDisplayName);
        psA->lpszDisplayName = NULL;
    }
    if (sW.lpszDisplayName)
    {
        UINT uLen = WTOALEN(sW.lpszDisplayName);
        psA->lpszDisplayName = (LPSTR)OleStdMalloc(uLen * sizeof(char));
        if (!psA->lpszDisplayName)
        {
            uRet = OLEUI_ERR_LOCALMEMALLOC;
        }
        else
        {
            WTOA(psA->lpszDisplayName, sW.lpszDisplayName, uLen);
        }
        OleStdFree((LPVOID)sW.lpszDisplayName);
    }
    if (sW.lpszFrom)
    {
        UINT uLen = WTOALEN(sW.lpszFrom);
        psA->lpszFrom = (LPSTR)OleStdMalloc(uLen * sizeof(char));
        if (!psA->lpszFrom)
        {
            uRet = OLEUI_ERR_LOCALMEMALLOC;
        }
        else
        {
            WTOA(psA->lpszFrom, sW.lpszFrom, uLen);
        }
        OleStdFree((LPVOID)sW.lpszFrom);
    }
    if (sW.lpszTo)
    {
        UINT uLen = WTOALEN(sW.lpszTo);
        psA->lpszTo = (LPSTR)OleStdMalloc(uLen * sizeof(char));
        if (!psA->lpszTo)
        {
            uRet = OLEUI_ERR_LOCALMEMALLOC;
        }
        else
        {
            WTOA(psA->lpszTo, sW.lpszTo, uLen);
        }
        OleStdFree((LPVOID)sW.lpszTo);
    }
    psA->dwFlags = sW.dwFlags;
    psA->nFileLength = sW.nFileLength;
    if (NULL != sW.lpOleUILinkContainer)
    {
        sW.lpOleUILinkContainer->Release();
    }
    return(uRet);
}

int OleUIPromptUserInternal(int nTemplate, HWND hwndParent, LPTSTR szTitle, va_list arglist);

//+---------------------------------------------------------------------------
//
//  Function:   OleUIPromptUserA
//
//  Synopsis:   converts call to ANSI version into call to Unicode version
//
//  Arguments:  [nTemplate]  - template ID
//              [hwndParent] - parent's HWND
//              [lpszTitle]  - title of the window
//              [...]        - variable argument list
//
//  History:    11-30-94   stevebl   Created
//
//  Notes:      The first parameter passed in by this function is always the
//              title for the dialog.  It must be converted to Unicode before
//              forwarding the call.  The other parameters do not need to
//              be converted because the template ID will indicate the dialog
//              that contains the correct wsprintf formatting string for
//              converting the other ANSI parameters to Unicode when the
//              function calls wsprintf to build it's text.
//
//----------------------------------------------------------------------------

int FAR CDECL OleUIPromptUserA(int nTemplate, HWND hwndParent, ...)
{
    WCHAR wszTemp[MAX_PATH];
    WCHAR * wszTitle = NULL;
    va_list arglist;
    va_start(arglist, hwndParent);
    LPSTR szTitle = va_arg(arglist, LPSTR);
    if (szTitle != NULL)
    {
        ATOW(wszTemp, szTitle, MAX_PATH);
        wszTitle = wszTemp;
    }
    int nRet = OleUIPromptUserInternal(nTemplate, hwndParent, wszTitle, arglist);
    va_end(arglist);

    return(nRet);
}

#else // UNICODE not defined
// Stubbed out Wide entry points

STDAPI_(BOOL) OleUIAddVerbMenuW(LPOLEOBJECT lpOleObj, LPCWSTR lpszShortType,
        HMENU hMenu, UINT uPos, UINT uIDVerbMin, UINT uIDVerbMax,
        BOOL bAddConvert, UINT idConvert, HMENU FAR *lphMenu)
{
    return(FALSE);
}

//+---------------------------------------------------------------------------
//
//  Function:   ReturnError
//
//  Synopsis:   Used to stub out the following entry points:
//                  OleUIInsertObjectW
//                  OleUIPasteSpecialW
//                  OleUIEditLinksW
//                  OleUIChangeIconW
//                  OleUIConvertW
//                  OleUIBusyW
//                  OleUIObjectPropertiesW
//                  OleUIChangeSourceW
//
//  Returns:    OLEUI_ERR_DIALOGFAILURE
//
//  History:    12-29-94   stevebl   Created
//
//  Notes:      The entry points listed above are all mapped to this function
//              in the Chicago version of OLEDLG.DEF.
//
//----------------------------------------------------------------------------

STDAPI_(UINT) ReturnError(void * p)
{
    return(OLEUI_ERR_DIALOGFAILURE);
}

STDAPI_(BOOL) OleUIUpdateLinksW(LPOLEUILINKCONTAINERW lpOleUILinkCntr,
        HWND hwndParent, LPWSTR lpszTitle, int cLinks)
{
    return(FALSE);
}

int FAR CDECL OleUIPromptUserW(int nTemplate, HWND hwndParent, LPWSTR lpszTitle, ...)
{
    return(2); // same as if user had cancelled the dialog
}
#endif // UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole2ui32\mfcui\mfcui.cpp ===
// ===========================================================================
// File: M F C U I . C P P
// 
// Copyright 1995 Microsoft Corporation.  All Rights Reserved.
// Microsoft Confidential
// ===========================================================================
#ifndef UNICODE

// %%Includes: ---------------------------------------------------------------
#include <windows.h>
#include <ole2.h>
#include <oledlg.h>

// %%Prototypes: -------------------------------------------------------------
STDAPI Ole2AnsiWFromA(REFIID riid, LPUNKNOWN punkWrappeeA, LPUNKNOWN *ppunkWrapperW);
STDAPI Ole2AnsiAFromW(REFIID riid, LPUNKNOWN punkWrappeeW, LPUNKNOWN *ppunkWrapperA);


// ---------------------------------------------------------------------------
// %%Function: OleUIAddVerbMenu                           %%Reviewed: 00/00/95
// 
// Description:
//  Wraps OleUIAddVerbMenu to OLEDLG.DLL for MFC clients, which expect to be
// able to pass Ansi IOleObject's.
// ---------------------------------------------------------------------------
#undef OleUIAddVerbMenu     // overrides the Ansi/Unicode macros in OLEDLG.H
 STDAPI_(BOOL)
OleUIAddVerbMenu(LPOLEOBJECT lpOleObjA, LPCSTR lpszShortType,
        HMENU hMenu, UINT uPos, UINT uIDVerbMin, UINT uIDVerbMax,
        BOOL bAddConvert, UINT idConvert, HMENU FAR *lphMenu)
{
    LPOLEOBJECT lpOleObjW = NULL;
    BOOL        fResult = FALSE;

    // allow NULL IOleObject (OleUIAddVerbMenuA handles this by making an empty menu), but
    // otherwise wrap the Ansi IOleObject to Unicode.
    if (lpOleObjA == NULL ||
        SUCCEEDED(Ole2AnsiWFromA(IID_IOleObject, (LPUNKNOWN)lpOleObjA, (LPUNKNOWN *)&lpOleObjW)))
        {
        fResult = OleUIAddVerbMenuA(lpOleObjW, lpszShortType, hMenu, uPos, uIDVerbMin,
            uIDVerbMax, bAddConvert, idConvert, lphMenu);

        // release the Unicode IOleObject if it was created
        if (lpOleObjW != NULL)
            lpOleObjW->Release();
        }

    return fResult;
}  // OleUIAddVerbMenu

// ---------------------------------------------------------------------------
// %%Function: OleUIInsertObject                          %%Reviewed: 00/00/95
// 
// Description:
//  Wraps OleUIInsertObject to OLEDLG.DLL for MFC clients, which expect to be
// able to pass Ansi IOleClientSite and IStorage in and receive Ansi interfaces
// out in ppvObj.
// ---------------------------------------------------------------------------
#undef OleUIInsertObject    // overrides the Ansi/Unicode macros in OLEDLG.H
 STDAPI_(UINT)
OleUIInsertObject(LPOLEUIINSERTOBJECTA lpio)
{
    LPOLECLIENTSITE lpIOleClientSiteA = NULL;
    LPSTORAGE       lpIStorageA = NULL;
    LPVOID FAR      *ppvObjA;
    LPUNKNOWN       punkObjW = NULL;
    BOOL            fCreatingObject;
    UINT            wResult;
    HRESULT         hr = S_OK;

    // validate the structure superficially: let the actual function do most of the validation
    if (!lpio)
        return OLEUI_ERR_STRUCTURENULL;
    if (IsBadReadPtr(lpio, sizeof(LPOLEUIINSERTOBJECTA)) ||
        IsBadWritePtr(lpio, sizeof(LPOLEUIINSERTOBJECTA)))
        return OLEUI_ERR_STRUCTUREINVALID;
    if (lpio->cbStruct < sizeof(LPOLEUIINSERTOBJECTA))
        return OLEUI_ERR_CBSTRUCTINCORRECT;

    if (fCreatingObject = (lpio->dwFlags & (IOF_CREATENEWOBJECT | IOF_CREATEFILEOBJECT | IOF_CREATELINKOBJECT)))
        {
        // verify these parameters, otherwise cleanup becomes complicated
        if (IsBadWritePtr(lpio->ppvObj, sizeof(LPUNKNOWN)))
            return OLEUI_IOERR_PPVOBJINVALID;
        if (lpio->lpIOleClientSite != NULL && IsBadReadPtr(lpio->lpIOleClientSite, sizeof(IOleClientSite)))
            return OLEUI_IOERR_LPIOLECLIENTSITEINVALID;
        if (lpio->lpIStorage != NULL && IsBadReadPtr(lpio->lpIStorage, sizeof(IStorage)))
            return OLEUI_IOERR_LPISTORAGEINVALID;

        // save away the Ansi IOleClientSite, stuff in our Unicode one.
        // if it's NULL, OleUIInsertObjectA() will handle the error appropriately and we'll clean up correctly, below.
        if (lpIOleClientSiteA = lpio->lpIOleClientSite)
            {
            hr = Ole2AnsiWFromA(IID_IOleClientSite, (LPUNKNOWN)lpIOleClientSiteA, (LPUNKNOWN *)&lpio->lpIOleClientSite);
            if (FAILED(hr))
                {
                lpio->lpIOleClientSite = lpIOleClientSiteA;
                lpio->sc = hr;
                return OLEUI_IOERR_SCODEHASERROR;
                }
            }

        // save away the Ansi IStorage, stuff in our Unicode one.
        // if it's NULL, OleUIInsertObjectA() will handle the error appropriately and we'll clean up correctly, below.
        if (lpIStorageA = lpio->lpIStorage)
            {
            hr = Ole2AnsiWFromA(IID_IStorage, (LPUNKNOWN)lpIStorageA, (LPUNKNOWN *)&lpio->lpIStorage);
            if (FAILED(hr))
                {
                // make sure to free the Unicode IOleClientSite which we converted above.
                if (lpio->lpIOleClientSite)
                    {
                    lpio->lpIOleClientSite->Release();
                    lpio->lpIOleClientSite = lpIOleClientSiteA;
                    }
                lpio->lpIStorage = lpIStorageA;
                lpio->sc = hr;
                return OLEUI_IOERR_SCODEHASERROR;
                }
            }

        // save the current Ansi ppvObj, stuff in our Unicode one
        ppvObjA = lpio->ppvObj;
        lpio->ppvObj = (LPVOID FAR *)&punkObjW;
        }

    wResult = OleUIInsertObjectA(lpio);

    // regardless of success or failure of the above call, we have to clean up the wrapping we did
    if (fCreatingObject)
        {
        // return the Ansi versions of the IOleClientSite and IStorage to
        // the structure, and release the Unicode ones
        if (lpio->lpIOleClientSite)
            {
            lpio->lpIOleClientSite->Release();
            lpio->lpIOleClientSite = lpIOleClientSiteA;
            }
        if (lpio->lpIStorage)
            {
            lpio->lpIStorage->Release();
            lpio->lpIStorage = lpIStorageA;
            }

        // return the Ansi object pointer to the structure
        lpio->ppvObj = ppvObjA;

        // convert
        if (punkObjW != NULL)
            {
            HRESULT hr;
            // if we were creating an object and we succeeded, punkObjW must be valid and contain an interface
            // of type iid. if not, there is a problem in OleUIInsertObjectA(), not in this code. we could assert
            // here if this code wanted to, but wouldn't be able to properly circumvent the error anyway.
            if (FAILED(hr = Ole2AnsiAFromW(lpio->iid, (LPUNKNOWN)punkObjW, (LPUNKNOWN *)ppvObjA)))
                {
                lpio->sc = hr;
                }
            punkObjW->Release();
            if (lpio->sc != S_OK)
                return OLEUI_IOERR_SCODEHASERROR;
            }
        }
    
    return wResult;
}  // OleUIInsertObject

// ---------------------------------------------------------------------------
// %%Function: OleUIPasteSpecial                          %%Reviewed: 00/00/95
// 
// Description:
//  Wraps OleUIPasteSpecial to OLEDLG.DLL for MFC clients, which expect to be
// able to pass in and get back Ansi IDataObject's.
// ---------------------------------------------------------------------------
#undef OleUIPasteSpecial    // overrides the Ansi/Unicode macros in OLEDLG.H
 STDAPI_(UINT)
OleUIPasteSpecial(LPOLEUIPASTESPECIALA lpps)
{
    LPDATAOBJECT    lpSrcDataObjA;
    UINT            wResult;

    // validate the structure superficially: let the actual function do most of the validation
    if (!lpps)
        return OLEUI_ERR_STRUCTURENULL;
    if (IsBadReadPtr(lpps, sizeof(LPOLEUIPASTESPECIALA)) ||
        IsBadWritePtr(lpps, sizeof(LPOLEUIPASTESPECIALA)))
        return OLEUI_ERR_STRUCTUREINVALID;
    if (lpps->cbStruct < sizeof(LPOLEUIPASTESPECIALA))
        return OLEUI_ERR_CBSTRUCTINCORRECT;
    if (NULL != lpps->lpSrcDataObj && IsBadReadPtr(lpps->lpSrcDataObj, sizeof(IDataObject)))
        return OLEUI_IOERR_SRCDATAOBJECTINVALID;

    if (!(lpSrcDataObjA = lpps->lpSrcDataObj) ||
        SUCCEEDED(Ole2AnsiWFromA(IID_IDataObject, (LPUNKNOWN)lpSrcDataObjA, (LPUNKNOWN *)&lpps->lpSrcDataObj)))
        {
        wResult = OleUIPasteSpecialA(lpps);

        // if we had an Ansi IDataObject on entry, put it back and release the Unicode wrapper.
        if (lpSrcDataObjA != NULL)
            {
            lpps->lpSrcDataObj->Release();
            lpps->lpSrcDataObj = lpSrcDataObjA;
            }
        // otherwise check to see if OleUIPasteSpecialA() placed a Unicode IDataObject into our structure.
        // if it did, wrap it to make sure an Ansi one gets sent back out.
        else if (lpps->lpSrcDataObj != NULL)
            {
            if (FAILED(Ole2AnsiAFromW(IID_IDataObject, (LPUNKNOWN)lpps->lpSrcDataObj, (LPUNKNOWN *)&lpSrcDataObjA)))
                {
                lpps->lpSrcDataObj->Release();
                lpps->lpSrcDataObj = NULL;
                return OLEUI_PSERR_GETCLIPBOARDFAILED; // well, that's pretty much what happened, after all
                }
            lpps->lpSrcDataObj->Release();
            lpps->lpSrcDataObj = lpSrcDataObjA;
            }
        }

    return wResult;
}  // OleUIPasteSpecial

#endif // !UNICODE
// EOF =======================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole2ui32\mfcui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by mfcui.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole2ui32\test\about.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       about.h
//
//  Contents:   definition for an about dialog box class
//
//  Classes:    CAbout
//
//  Functions:
//
//  History:    6-08-94   stevebl   Created
//
//----------------------------------------------------------------------------

#ifndef __ABOUT_H__
#define __ABOUT_H__

#include <cdialog.h>

#ifdef __cplusplus

//+---------------------------------------------------------------------------
//
//  Class:      CAbout
//
//  Purpose:    implements the about dialog box
//
//  Interface:  DialogProc -- dialog procedure
//
//  History:    6-08-94   stevebl   Created
//
//----------------------------------------------------------------------------

class CAbout: public CHlprDialog
{
public:
    BOOL DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
};

#endif //__cplusplus

#endif //__ABOUT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole2ui32\test\cdialog.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       dialog.cxx
//
//  Contents:
//
//  Classes:    CHlprDialog
//
//  Functions:  DialogProc
//
//  History:    4-12-94   stevebl   Created
//
//----------------------------------------------------------------------------

#include <windows.h>
#include "cdialog.h"

//+---------------------------------------------------------------------------
//
//  Member:     CHlprDialog::ShowDialog
//
//  Synopsis:   Creates the dialog so that it's DialogProc member function can
//              be invoked.
//
//  Arguments:  [hinst]        - handle of the application instance
//              [lpszTemplate] - identifies the dialog box template
//              [hwndOwner]    - handle of the owner window
//
//  Returns:    return value from the dialog box
//
//  History:    4-12-94   stevebl   Created
//
//  Notes:      The dialog box object exists until deleted by the caller.
//              It can be shown any number of times.
//
//              This function is analgous to Windows' DialogBox function.  The
//              main difference being that you don't specify a DialogProc;
//              you override the pure virtal function CHlprDialog::DialogProc.
//
//----------------------------------------------------------------------------

int CHlprDialog::ShowDialog(HINSTANCE hinst, LPCTSTR lpszTemplate, HWND hwndOwner)
{
    _hInstance = hinst;
    return(DialogBoxParam(hinst, lpszTemplate, hwndOwner, (DLGPROC)::DialogProc, (long)this));
}

//+---------------------------------------------------------------------------
//
//  Function:   DialogProc
//
//  Synopsis:   Common DialogProc used by all CHlprDialog class objects.
//
//  Arguments:  [hwndDlg] - handle of dialog box
//              [uMsg]    - message
//              [wParam]  - first message parameter
//              [lParam]  - second message parameter
//
//  Returns:    response from the CHlprDialog::DialogProc method
//
//  History:    4-12-94   stevebl   Created
//
//  Notes:      This procedure is the DialogProc registered for all dialogs
//              created with the CHlprDialog class.  It uses the parameter
//              passed with the WM_INITDIALOG message to identify the dialog
//              classes' "this" pointer which it then stores in the window
//              structure's GWL_USERDATA field.  All subsequent messages
//              can then be forwarded on to the correct dialog class's
//              DialogProc method by using the pointer stored in the
//              GWL_USERDATA field.
//
//----------------------------------------------------------------------------

BOOL CALLBACK DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CHlprDialog * pdlg;
    switch (uMsg)
    {
    case WM_INITDIALOG:
        // This message is how we identify the dialog object.

        // get a pointer to the window class object
        pdlg = (CHlprDialog *) lParam;
        // set its USERDATA word to point to the class object
        SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdlg);
        break;
    default:
        // get a pointer to the window class object
        pdlg = (CHlprDialog *) GetWindowLong(hwndDlg, GWL_USERDATA);
        break;
    }
    // and call its message proc method
    if (pdlg != (CHlprDialog *) 0)
    {
        return(pdlg->DialogProc(hwndDlg, uMsg, wParam, lParam));
    }
    else
    {
        return(FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole2ui32\test\about.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       about.cxx
//
//  Contents:   implementation for a simple about dialog box
//
//  Classes:    CAbout
//
//  Functions:
//
//  History:    6-08-94   stevebl   Created
//
//----------------------------------------------------------------------------

#include <windows.h>
#include "about.h"


//+---------------------------------------------------------------------------
//
//  Member:     CAbout::DialogProc
//
//  Synopsis:   dialog proc for the About dialog box
//
//  Arguments:  [uMsg]   - message
//              [wParam] - first message parameter
//              [lParam] - second message parameter
//
//  History:    4-12-94   stevebl   Created for MFract
//              6-08-94   stevebl   Stolen from MFract
//
//----------------------------------------------------------------------------

BOOL CAbout::DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        return(TRUE);
    case WM_COMMAND:
        if (LOWORD(wParam) == IDOK
            || LOWORD(wParam) == IDCANCEL)
        {
            EndDialog(hwndDlg, TRUE);
            return(TRUE);
        }
    }
    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole2ui32\test\cwindow.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       cwindow.h
//
//  Contents:   definition of a virtual window class
//
//  Classes:    CHlprWindow
//
//  Functions:  WindowProc
//
//  History:    4-12-94   stevebl   Created
//
//----------------------------------------------------------------------------


#ifndef __CWINDOW_H__
#define __CWINDOW_H__

#include <windows.h>

#ifdef __cplusplus
extern "C" {
#endif

LRESULT CALLBACK WindowProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam);

#ifdef __cplusplus
}

//+---------------------------------------------------------------------------
//
//  Class:      CHlprWindow
//
//  Purpose:    virtual base class for wrapping a window
//
//  Interface:  Create     -- analagous to Windows' CreateWindow function
//              WindowProc -- pure virtual WindowProc for the window
//              ~CHlprWindow   -- destructor
//              CHlprWindow    -- constructor
//
//  History:    4-12-94   stevebl   Created
//
//  Notes:      This class allows a window to be cleanly wrapped in a
//              c++ class.  Specifically, it provides a way for a c++ class
//              to use one of its methods as a WindowProc, giving it a "this"
//              pointer and allowing it to have direct access to all of its
//              private members.
//
//----------------------------------------------------------------------------

class CHlprWindow
{
public:
    HWND Create(
        LPCTSTR lpszClassName,
        LPCTSTR lpszWindowName,
        DWORD dwStyle,
        int x,
        int y,
        int nWidth,
        int nHeight,
        HWND hwndParent,
        HMENU hmenu,
        HINSTANCE hinst);
    virtual LRESULT WindowProc(UINT uMsg, WPARAM wParam, LPARAM lParam) = 0;
    virtual ~CHlprWindow(){};
    HWND GetHwnd(void)
    {
        return(_hwnd);
    }
    CHlprWindow()
    {
        _hwnd = NULL;
        _hInstance = NULL;
    };
protected:
friend LRESULT CALLBACK ::WindowProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam);
    HWND _hwnd;
    HINSTANCE _hInstance;
};

#endif

#endif //__CWINDOW_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole2ui32\test\cdialog.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       cdialog.h
//
//  Contents:   definition for common dialog functionality
//
//  Classes:    CHlprDialog (pure virtual class)
//
//  Functions:  DialogProc
//
//  History:    4-12-94   stevebl   Created
//
//----------------------------------------------------------------------------

#ifndef __CDIALOG_H__
#define __CDIALOG_H__

#ifdef __cplusplus
extern "C" {
#endif

BOOL CALLBACK DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

#ifdef __cplusplus
}

//+---------------------------------------------------------------------------
//
//  Class:      CHlprDialog
//
//  Purpose:    virtual base class for wrapping Windows' dialog functionality
//
//  Interface:  ShowDialog -- analagous to the Windows DialogBox function
//              DialogProc -- pure virtual DialogProc for the dialog box
//              ~CHlprDialog   -- destructor
//
//  History:    4-12-94   stevebl   Created
//
//  Notes:      This class allows a dialog box to be cleanly wrapped in
//              a c++ class.  Specifically, it provides a way for a c++ class
//              to use one of its methods as a DialogProc, giving it a "this"
//              pointer and allowing it to have direct access to all of its
//              private members.
//
//----------------------------------------------------------------------------

class CHlprDialog
{
public:
    virtual int ShowDialog(HINSTANCE hinst, LPCTSTR lpszTemplate, HWND hwndOwner);
    virtual BOOL DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam) = 0;
    virtual ~CHlprDialog(){};
protected:
    HINSTANCE _hInstance;
};

#endif //__cplusplus

#endif //__CDIALOG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole2ui32\test\cwindow.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       cwindow.cxx
//
//  Contents:   implementation for a window class
//
//  Classes:    CHlprWindow
//
//  Functions:  WindowProc
//
//  History:    4-12-94   stevebl   Created
//
//----------------------------------------------------------------------------

#include "cwindow.h"

//+---------------------------------------------------------------------------
//
//  Member:     CHlprWindow::Create
//
//  Synopsis:   Special version of CreateWindow.
//
//  Arguments:  [lpszClassName]  - address of registered class name
//              [lpszWindowName] - address of window name
//              [dwStyle]        - window style
//              [x]              - horizontal position of window
//              [y]              - vertical position of window
//              [nWidth]         - window width
//              [nHeight]        - window height
//              [hwndParent]     - handle of parent or owner window
//              [hmenu]          - handle of menu, or child window identifier
//              [hinst]          - handle of application instance
//
//  Returns:    HWND of the created window
//
//  Modifies:   _hwnd, _hInstance
//
//  History:    4-12-94   stevebl   Created
//
//  Notes:      The window class must have been previously registered (as
//              is normal Windows procedure) and the callback function
//              must have been registered as ::WindowProc.  ::WindowProc will
//              then forward all messages on to the CHlprWindow::WindowProc
//              method, allowing the window to directly access class members
//              (i.e. giving the WindowProc access to the "this" pointer).
//
//----------------------------------------------------------------------------

HWND CHlprWindow::Create(
    LPCTSTR lpszClassName,
    LPCTSTR lpszWindowName,
    DWORD dwStyle,
    int x,
    int y,
    int nWidth,
    int nHeight,
    HWND hwndParent,
    HMENU hmenu,
    HINSTANCE hinst)
{
    _hInstance = hinst;
    return(_hwnd =
        CreateWindow(
            lpszClassName,
            lpszWindowName,
            dwStyle,
            x,
            y,
            nWidth,
            nHeight,
            hwndParent,
            hmenu,
            hinst,
            this));
}

//+---------------------------------------------------------------------------
//
//  Function:   WindowProc
//
//  Synopsis:   Standard WindowProc that forwards Windows messages on to the
//              CHlprWindow::WindowProc method.
//
//  Arguments:  [hwnd]   - window handle
//              [uMsg]   - message
//              [wParam] - first message parameter
//              [lParam] - second message parameter
//
//  History:    4-12-94   stevebl   Created
//
//  Notes:      This Window procedure expects that it will receive a "this"
//              pointer as the lpCreateParams member passed as part of the
//              WM_CREATE message.  It saves the "this" pointer in the
//              GWL_USERDATA field of the window structure.
//
//----------------------------------------------------------------------------

LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CHlprWindow * pw;
    switch (uMsg)
    {
    case WM_CREATE:
        // Since this is the first time that we can get ahold of
        // a pointer to the window class object, all messages that might
        // have been sent before this are never seen by the Windows object
        // and only get passed on to te DefWindowProc

        // get a pointer to the window class object
        pw = (CHlprWindow *) ((CREATESTRUCT *)lParam)->lpCreateParams;
        // set its USERDATA DWORD to point to the class object
        SetWindowLong(hwnd, GWL_USERDATA, (long) pw);
        // Set it's protected _hwnd member variable to ensure that
        // member functions have access to the correct window handle.
        pw->_hwnd = hwnd;
        break;
    case WM_DESTROY:
        // This is our signal to destroy the window class object.

        pw = (CHlprWindow *) GetWindowLong(hwnd, GWL_USERDATA);
        SetWindowLong(hwnd, GWL_USERDATA, 0);
        delete pw;
        pw = (CHlprWindow *) 0;
        break;
    default:
        // get a pointer to the window class object
        pw = (CHlprWindow *) GetWindowLong(hwnd, GWL_USERDATA);
        break;
    }
    // and call its message proc method
    if (pw != (CHlprWindow *) 0)
    {
        return(pw->WindowProc(uMsg, wParam, lParam));
    }
    else
    {
        return(DefWindowProc(hwnd, uMsg, wParam, lParam));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole2ui32\test\linkcntr.cxx ===
#include <windows.h>
#include <assert.h>
#include <oledlg.h>
#include "linkcntr.h"

HRESULT STDMETHODCALLTYPE CMyOleUILinkContainer::QueryInterface(REFIID riid, LPVOID FAR * ppvObj)
{
    return(E_NOTIMPL);
};

ULONG STDMETHODCALLTYPE CMyOleUILinkContainer::AddRef()
{
    return(0);
};

ULONG STDMETHODCALLTYPE CMyOleUILinkContainer::Release()
{
    return(0);
}

DWORD STDMETHODCALLTYPE CMyOleUILinkContainer::GetNextLink(DWORD dwLink)
{
    return(0);
}

HRESULT STDMETHODCALLTYPE CMyOleUILinkContainer::SetLinkUpdateOptions(DWORD dwLink, DWORD dwUpdateOpt)
{
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CMyOleUILinkContainer::GetLinkUpdateOptions(DWORD dwLink,
            DWORD FAR* lpdwUpdateOpt)
{
    *lpdwUpdateOpt = OLEUPDATE_ONCALL;
    return(S_OK);
};

HRESULT STDMETHODCALLTYPE CMyOleUILinkContainer::SetLinkSource(DWORD dwLink, LPTSTR lpszDisplayName,
            ULONG lenFileName, ULONG FAR* pchEaten, BOOL fValidateSource)
{
    return(E_NOTIMPL);
};

HRESULT STDMETHODCALLTYPE CMyOleUILinkContainer::GetLinkSource(DWORD dwLink,
            LPTSTR FAR* lplpszDisplayName, ULONG FAR* lplenFileName,
            LPTSTR FAR* lplpszFullLinkType, LPTSTR FAR* lplpszShortLinkType,
            BOOL FAR* lpfSourceAvailable, BOOL FAR* lpfIsSelected)
{
    return(E_NOTIMPL);
};

HRESULT STDMETHODCALLTYPE CMyOleUILinkContainer::OpenLinkSource(DWORD dwLink)
{
    return(E_NOTIMPL);
};

HRESULT STDMETHODCALLTYPE CMyOleUILinkContainer::UpdateLink(DWORD dwLink,
            BOOL fErrorMessage, BOOL fErrorAction)
{
    return(E_NOTIMPL);
};

HRESULT STDMETHODCALLTYPE CMyOleUILinkContainer::CancelLink(DWORD dwLink)
{
    return(E_NOTIMPL);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole2ui32\test\message.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       message.h
//
//  Contents:   Helper functions for popup message boxes.
//
//  Classes:
//
//  Functions:  MessageBoxFromStringIds
//
//  History:    6-24-94   stevebl   Created
//
//----------------------------------------------------------------------------

#ifndef __MESSAGE_H__
#define __MESSAGE_H__

#define MAX_STRING_LENGTH           256

int MessageBoxFromStringIds(
    const HWND hwndOwner,
    const HINSTANCE hinst,
    const UINT idText,
    const UINT idTitle,
    const UINT fuStyle);

int MessageBoxFromStringIdsAndArgs(
    const HWND hwndOwner,
    const HINSTANCE hinst,
    const UINT idText,
    const UINT idTitle,
    const UINT fuStyle,
    ...);

#endif //__MESSAGE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole2ui32\test\linkcntr.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       linkcntr.h
//
//  Contents:   bogus implementation of IOleUILinkContainer
//
//  Classes: CMyOleUILinkContainer
//
//  Functions:
//
//  History:    11-28-94   stevebl   Created
//
//----------------------------------------------------------------------------

#ifndef _LINKCNTR_H_
#define _LINKCNTR_H_

class CMyOleUILinkContainer: public IOleUILinkContainer
{
public:
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR * ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    STDMETHOD_(DWORD, GetNextLink)(THIS_ DWORD dwLink);
    STDMETHOD(SetLinkUpdateOptions)(THIS_ DWORD dwLink, DWORD dwUpdateOpt);
    STDMETHOD(GetLinkUpdateOptions) (THIS_ DWORD dwLink,
            DWORD FAR* lpdwUpdateOpt);
    STDMETHOD(SetLinkSource) (THIS_ DWORD dwLink, LPTSTR lpszDisplayName,
            ULONG lenFileName, ULONG FAR* pchEaten, BOOL fValidateSource);
    STDMETHOD(GetLinkSource) (THIS_ DWORD dwLink,
            LPTSTR FAR* lplpszDisplayName, ULONG FAR* lplenFileName,
            LPTSTR FAR* lplpszFullLinkType, LPTSTR FAR* lplpszShortLinkType,
            BOOL FAR* lpfSourceAvailable, BOOL FAR* lpfIsSelected);
    STDMETHOD(OpenLinkSource) (THIS_ DWORD dwLink);
    STDMETHOD(UpdateLink) (THIS_ DWORD dwLink,
            BOOL fErrorMessage, BOOL fErrorAction);
    STDMETHOD(CancelLink) (THIS_ DWORD dwLink);
};

#endif // _LINKCNTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole2ui32\test\mwclass.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       mwclass.cxx
//
//  Contents:   implementation for the main window class
//
//  Classes:    CMainWindow
//
//  Functions:  Exists
//
//  History:    9-30-94   stevebl   Created
//
//----------------------------------------------------------------------------

#include "test.h"
#include "mwclass.h"
#include "about.h"
#include <assert.h>
#include <oledlg.h>
#include "linkcntr.h"

CMyOleUILinkContainer MyOleUILinkContainer;


//+---------------------------------------------------------------------------
//
//  Member:     CMainWindow::CMainWindow
//
//  Synopsis:   constructor
//
//  History:    9-30-94   stevebl   Created
//
//----------------------------------------------------------------------------

CMainWindow::CMainWindow()
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CMainWindow::~CMainWindow
//
//  Synopsis:   destructor
//
//  History:    9-30-94   stevebl   Created
//
//  Notes:      Destruction of the main window indicates that the app should
//              quit.
//
//----------------------------------------------------------------------------

CMainWindow::~CMainWindow()
{
    PostQuitMessage(0);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMainWindow::InitInstance
//
//  Synopsis:   Instantiates an instance of the Galactic War window.
//
//  Arguments:  [hInstance] - instance of the app
//              [nCmdShow]  - command to pass to ShowWindow
//
//  Returns:    TRUE on success
//              FALSE on failure
//
//  History:    9-30-94   stevebl   Created
//
//  Notes:      This method must be called only once, immediately after
//              class construction.
//
//----------------------------------------------------------------------------

BOOL CMainWindow::InitInstance(HINSTANCE hInstance, int nCmdShow)
{
    // Note, the Create method sets the _hwnd member for me so I don't
    // need to set it myself.
    if (!Create(
        TEXT(MAIN_WINDOW_CLASS_NAME),
        TEXT(VER_INTERNALNAME_STR),
        WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX
            | WS_MAXIMIZEBOX | WS_THICKFRAME,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        NULL,
        NULL,
        hInstance))
    {
        return(FALSE);
    }

    ShowWindow(_hwnd, nCmdShow);
    UpdateWindow(_hwnd);

    return(TRUE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMainWindow::WindowProc
//
//  Synopsis:   main window procedure
//
//  Arguments:  [uMsg]   - Windows message
//              [wParam] - first message parameter
//              [lParam] - second message parameter
//
//  History:    9-30-94   stevebl   Created
//
//  Notes:      See CHlprWindow for a description of how this method gets
//              called by the global WinProc.
//
//----------------------------------------------------------------------------

LRESULT CMainWindow::WindowProc(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_CREATE:
        return(TRUE);
    case WM_COMMAND:
        return DoMenu(wParam, lParam);
    case WM_QUIT:
    case WM_CLOSE:
    default:
        return(DefWindowProc(_hwnd, uMsg, wParam, lParam));
    }
    return(FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMainWindow::DoMenu
//
//  Synopsis:   implements the main menu commands
//
//  Arguments:  [wParam] - first window parameter
//              [lParam] - second window parameter
//
//  History:    9-30-94   stevebl   Created
//
//----------------------------------------------------------------------------

LRESULT CMainWindow::DoMenu(WPARAM wParam, LPARAM lParam)
{
    switch (LOWORD(wParam))
    {
    case IDM_INSERTOBJECT:
        TestInsertObject();
        break;
    case IDM_PASTESPECIAL:
        TestPasteSpecial();
        break;
    case IDM_EDITLINKS:
        TestEditLinks();
        break;
    case IDM_CHANGEICON:
        TestChangeIcon();
        break;
    case IDM_CONVERT:
        TestConvert();
        break;
    case IDM_CANCONVERT:
        TestCanConvert();
        break;
    case IDM_BUSY:
        TestBusy();
        break;
    case IDM_CHANGESOURCE:
        TestChangeSource();
        break;
    case IDM_OBJECTPROPS:
        TestObjectProps();
        break;
    case IDD_LINKSOURCEUNAVAILABLE:
    case IDD_CANNOTUPDATELINK:
    case IDD_SERVERNOTREG:
    case IDD_LINKTYPECHANGED:
    case IDD_SERVERNOTFOUND:
    case IDD_OUTOFMEMORY:
        TestPromptUser((int)LOWORD(wParam));
        break;
    case IDM_UPDATELINKS:
        TestUpdateLinks();
        break;
    case IDM_EXIT:
        SendMessage(_hwnd, WM_CLOSE, 0, 0);
        break;
    case IDM_ABOUT:
        {
            CAbout dlgAbout;
            dlgAbout.ShowDialog(_hInstance, MAKEINTRESOURCE(IDM_ABOUT), _hwnd);
        }
        break;
    default:
        return(DefWindowProc(_hwnd, WM_COMMAND, wParam, lParam));
    }
    return(FALSE);
}

void CMainWindow::TestInsertObject()
{
    TCHAR szFile[MAX_PATH];
    OLEUIINSERTOBJECT io;
    memset(&io, 0, sizeof(OLEUIINSERTOBJECT));
    io.cbStruct = sizeof(io);
    io.dwFlags = IOF_SELECTCREATECONTROL | IOF_SHOWINSERTCONTROL;
//    io.dwFlags = IOF_SHOWINSERTCONTROL;
    io.hWndOwner = _hwnd;
    io.lpszFile = szFile;
    io.cchFile = MAX_PATH;
    io.lpszCaption = TEXT("Testing OleUIInsertObject dialog");
    memset(szFile, 0, sizeof(szFile));

    UINT uReturn = OleUIInsertObject(&io);

    MessageBoxFromStringIdsAndArgs(
        _hwnd,
        _hInstance,
        IDS_INSERTOBJECT,
        IDS_RETURN,
        MB_OK,
        uReturn,
        io.dwFlags,
        io.lpszFile,
        io.sc);
}

void CMainWindow::TestPasteSpecial()
{
    LPDATAOBJECT lpClipboardDataObj = NULL;
    HRESULT hr = OleGetClipboard(&lpClipboardDataObj);
    if (SUCCEEDED(NOERROR))
    {
        OLEUIPASTEENTRY rgPe[1];
        rgPe[0].fmtetc.cfFormat = CF_TEXT;
        rgPe[0].fmtetc.ptd = NULL;
        rgPe[0].fmtetc.dwAspect = DVASPECT_CONTENT;
        rgPe[0].fmtetc.tymed = TYMED_HGLOBAL;
        rgPe[0].fmtetc.lindex = -1;
        rgPe[0].lpstrFormatName = TEXT("Text");
        rgPe[0].lpstrResultText = TEXT("Text");
        rgPe[0].dwFlags = OLEUIPASTE_PASTEONLY;

        OLEUIPASTESPECIAL ps;
        memset(&ps, 0, sizeof(ps));
        ps.cbStruct = sizeof(ps);
        ps.dwFlags = IOF_SHOWHELP | PSF_SELECTPASTE;
        ps.hWndOwner = _hwnd;
        ps.lpszCaption = TEXT("Paste Special");
        ps.lpSrcDataObj = lpClipboardDataObj;
        ps.arrPasteEntries = rgPe;
        ps.cPasteEntries = 1;
        ps.lpszCaption = TEXT("Testing OleUIPasteSpecial dialog");

        UINT uReturn = OleUIPasteSpecial(&ps);

        MessageBoxFromStringIdsAndArgs(
            _hwnd,
            _hInstance,
            IDS_PASTESPECIAL,
            IDS_RETURN,
            MB_OK,
            uReturn,
            ps.dwFlags,
            ps.nSelectedIndex,
            ps.fLink,
            ps.sizel);
        if (lpClipboardDataObj)
        {
            lpClipboardDataObj->Release();
        }
    }
    else
    {
        MessageBoxFromStringIdsAndArgs(
            _hwnd,
            _hInstance,
            IDS_NOCLIPBOARD,
            IDS_ERROR,
            MB_OK,
            hr);
        // report failure getting clipboard object
    }
}

void CMainWindow::TestEditLinks()
{
    OLEUIEDITLINKS el;
    memset(&el, 0, sizeof(el));
    el.cbStruct = sizeof(el);
    el.dwFlags = ELF_SHOWHELP;
    el.hWndOwner = _hwnd;
    el.lpOleUILinkContainer = &MyOleUILinkContainer;
    el.lpszCaption = TEXT("Testing OleUIEditLinks dialog");

    UINT uReturn = OleUIEditLinks(&el);

    MessageBoxFromStringIdsAndArgs(
        _hwnd,
        _hInstance,
        IDS_EDITLINKS,
        IDS_RETURN,
        MB_OK,
        uReturn,
        el.dwFlags);
}

void CMainWindow::TestChangeIcon()
{
    OLEUICHANGEICON ci;
    memset(&ci, 0, sizeof(ci));
    ci.cbStruct = sizeof(ci);
    ci.dwFlags = CIF_SHOWHELP | CIF_SELECTCURRENT;
    ci.hWndOwner = _hwnd;
    ci.lpszCaption = TEXT("Testing OleUIChangeIcon dialog");

    UINT uReturn = OleUIChangeIcon(&ci);

    MessageBoxFromStringIdsAndArgs(
        _hwnd,
        _hInstance,
        IDS_CHANGEICON,
        IDS_RETURN,
        MB_OK,
        uReturn,
        ci.dwFlags);
}

void CMainWindow::TestConvert()
{
    OLEUICONVERT cv;
    memset(&cv, 0, sizeof(cv));
    cv.cbStruct = sizeof(cv);
    cv.dwFlags = CF_SHOWHELPBUTTON;
    cv.hWndOwner = _hwnd;
    cv.lpszCaption = TEXT("Testing OleUIConvert dialog");

    UINT uReturn = OleUIConvert(&cv);

    MessageBoxFromStringIdsAndArgs(
        _hwnd,
        _hInstance,
        IDS_CONVERT,
        IDS_RETURN,
        MB_OK,
        uReturn,
        cv.dwFlags);
}

void CMainWindow::TestCanConvert()
{
    CLSID cid = { /* 00030003-0000-0000-c000-000000000046 ("Word Document") */
        0x00030003,
        0x0000,
        0x0000,
        {0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46}
    };
    BOOL fReturn = OleUICanConvertOrActivateAs(cid, FALSE, CF_TEXT);

    MessageBoxFromStringIdsAndArgs(
        _hwnd,
        _hInstance,
        IDS_CANCONVERT,
        IDS_RETURN,
        MB_OK,
        fReturn);
}

void CMainWindow::TestBusy()
{
    OLEUIBUSY bz;
    memset(&bz, 0, sizeof(bz));
    bz.cbStruct = sizeof(bz);
    bz.hWndOwner = _hwnd;
    bz.lpszCaption = TEXT("Testing OleUIBusy dialog");

    UINT uReturn = OleUIBusy(&bz);

    MessageBoxFromStringIdsAndArgs(
        _hwnd,
        _hInstance,
        IDS_BUSY,
        IDS_RETURN,
        MB_OK,
        uReturn,
        bz.dwFlags);
}

void CMainWindow::TestChangeSource()
{
    OLEUICHANGESOURCE cs;
    memset(&cs, 0, sizeof(cs));
    cs.cbStruct = sizeof(cs);
    cs.hWndOwner = _hwnd;
    cs.lpszCaption = TEXT("Testing OleUIChangeSource dialog");

    UINT uReturn = OleUIChangeSource(&cs);

    MessageBoxFromStringIdsAndArgs(
        _hwnd,
        _hInstance,
        IDS_CHANGESOURCE,
        IDS_RETURN,
        MB_OK,
        uReturn,
        cs.dwFlags);
}

void CMainWindow::TestObjectProps()
{
    OLEUIOBJECTPROPS op;
    memset(&op, 0, sizeof(op));
    op.cbStruct = sizeof(op);

    UINT uReturn = OleUIObjectProperties(&op);

    MessageBoxFromStringIdsAndArgs(
        _hwnd,
        _hInstance,
        IDS_OBJECTPROPS,
        IDS_RETURN,
        MB_OK,
        uReturn,
        op.dwFlags);
}

void CMainWindow::TestPromptUser(int nTemplate)
{
    UINT uReturn = OleUIPromptUser(
        nTemplate,
        _hwnd,
        // string arguments:
        TEXT("Testing OleUIPromptUser"),
        TEXT("BAR"),
        TEXT("FOO"));
    MessageBoxFromStringIdsAndArgs(
        _hwnd,
        _hInstance,
        IDS_PROMPTUSER,
        IDS_RETURN,
        MB_OK,
        uReturn);
}

void CMainWindow::TestUpdateLinks()
{
    UINT cLinks = 0;
    BOOL fReturn = OleUIUpdateLinks(
        &MyOleUILinkContainer,
        _hwnd,
        TEXT("Testing OleUIUpdateLinks dialog"),
        cLinks);

    MessageBoxFromStringIdsAndArgs(
        _hwnd,
        _hInstance,
        IDS_UPDATELINKS,
        IDS_RETURN,
        MB_OK,
        fReturn);
}

//+---------------------------------------------------------------------------
//
//  Function:   Exists
//
//  Synopsis:   simple function to test for the existance of a file
//
//  History:    6-16-93   stevebl   Created
//
//----------------------------------------------------------------------------

int Exists(TCHAR *sz)
{
    HANDLE h;
    h = CreateFile(sz,
        GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        0,
        0);
    if (h != INVALID_HANDLE_VALUE)
    {
        CloseHandle(h);
        return(1);
    }
    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole2ui32\test\winmain.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       winmain.cxx
//
//  Contents:   main entry point
//
//  Classes:
//
//  Functions:  WinMain
//
//  History:    9-30-94   stevebl   Created
//
//----------------------------------------------------------------------------

#include "test.h"
#include "mwclass.h"
#include <ole2ver.h>

//+---------------------------------------------------------------------------
//
//  Function:   InitApplication
//
//  Synopsis:   initializes the application and registers its window class
//              (called once for all instances)
//
//  Arguments:  [hInstance] - handle to the first instance
//
//  Returns:    TRUE on success
//
//  History:    4-11-94   stevebl   Created for MFract
//              9-30-94   stevebl   Stolen from MFract
//
//----------------------------------------------------------------------------

BOOL InitApplication(HINSTANCE hInstance)
{
    WNDCLASS wc;

    wc.style = 0;
    wc.lpfnWndProc = &WindowProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInstance;
    wc.hCursor = (HCURSOR) LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);
    wc.hIcon = LoadIcon(hInstance, TEXT("AppIcon"));
    wc.lpszMenuName = TEXT(MAIN_WINDOW_CLASS_MENU_STR);
    wc.lpszClassName = TEXT(MAIN_WINDOW_CLASS_NAME);
    return(RegisterClass(&wc));
}

//+---------------------------------------------------------------------------
//
//  Function:   WinMain
//
//  Synopsis:   main window proceedure
//
//  Arguments:  [hInstance]     - instance handle
//              [hPrevInstance] - handle of the previous instance (if any)
//              [lpCmdLine]     - pointer to the command line
//              [nCmdShow]      - show state
//
//  History:    4-11-94   stevebl   Created for MFract
//              9-30-94   stevebl   Stolen from MFract
//
//  Notes:      initializes application and starts message loop
//
//----------------------------------------------------------------------------

extern "C" int PASCAL WinMain(HINSTANCE hInstance,
            HINSTANCE hPrevInstance,
            LPSTR lpCmdLine,
            int nCmdShow)
{
    DWORD dwBuildVersion = OleBuildVersion();
    if (HIWORD(dwBuildVersion) != rmm || LOWORD(dwBuildVersion) < rup)
    {
        // alert the caller that the OLE version is incompatible
        // with this build.
        MessageBoxFromStringIds(
                    NULL,
                    hInstance,
                    IDS_BADOLEVERSION,
                    IDS_ERROR,
                    MB_OK);
        return(FALSE);
    }
    if (FAILED(OleInitialize(NULL)))
    {
        // alert the caller that OLE couldn't be initialized
        MessageBoxFromStringIds(
                    NULL,
                    hInstance,
                    IDS_OLEINITFAILED,
                    IDS_ERROR,
                    MB_OK);
        return(FALSE);
    }
    if (!hPrevInstance)
    {
        if (!InitApplication(hInstance))
        {
            return(FALSE);
        }
    }
    CMainWindow * pw = new CMainWindow;
    if (pw == NULL)
    {
        return(FALSE);
    }
    if (!pw->InitInstance(hInstance, nCmdShow))
    {
        // Note, if InitInstance has failed then it would have
        // already deleted pw for me so I don't delete it here.
        // This is because when WM_CREATE returns -1 (failure)
        // Windows sends the WM_DESTROY message to the window
        // and the the CHlprWindow class destroys itself whenever
        // it receives this message.
        return(FALSE);
    }

    MSG msg;
    HACCEL haccel = LoadAccelerators(hInstance, TEXT("AppAccel"));
    if (haccel == NULL)
    {
        return(FALSE);
    }

    while (GetMessage(&msg, NULL, 0, 0))
    {
        if (!TranslateAccelerator(
            pw->GetHwnd(),
            haccel,
            &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    OleUninitialize();
    return(msg.wParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole2ui32\test\message.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       message.cxx
//
//  Contents:   Helper functions for popup message boxes.
//
//  Classes:
//
//  Functions:  MessageBoxFromSringIds
//
//  History:    6-24-94   stevebl   Created
//
//----------------------------------------------------------------------------

#include <windows.h>
#include "message.h"

//+---------------------------------------------------------------------------
//
//  Function:   MessageBoxFromStringIds
//
//  Synopsis:   Displays a simple message box taking its text from a string
//              table instead of from user allocated strings.
//
//  Arguments:  [hwndOwner]      - window handle for the message box's owner
//              [hinst]          - instance associated with the string table
//              [idText]         - string id for the box's text string
//              [idTitle]        - string id for the box's title string
//              [fuStyle]        - style of message box
//                                 (see Windows function MessageBox for styles)
//
//  Returns:    result from MessageBox
//
//  History:    6-24-94   stevebl   Created
//
//  Notes:      Each string is limited to MAX_STRING_LENGTH characters.
//
//----------------------------------------------------------------------------

int MessageBoxFromStringIds(
    const HWND hwndOwner,
    const HINSTANCE hinst,
    const UINT idText,
    const UINT idTitle,
    const UINT fuStyle)
{
    int iReturn = 0;
    TCHAR szTitle[MAX_STRING_LENGTH];
    TCHAR szText[MAX_STRING_LENGTH];
    if (LoadString(hinst, idTitle, szTitle, MAX_STRING_LENGTH))
    {
        if (LoadString(hinst, idText, szText, MAX_STRING_LENGTH))
        {
            iReturn = MessageBox(
                hwndOwner,
                szText,
                szTitle,
                fuStyle);
        }
    }
    return(iReturn);
}

//+---------------------------------------------------------------------------
//
//  Function:   MessageBoxFromStringIdsAndArgs
//
//  Synopsis:   Creates a message box from a pair of string IDs similar
//              to MessageBoxFromStringIds.  The principle difference
//              is that idFormat is an ID for a string which is a printf
//              format string suitable for passing to wsprintf.
//              The variable argument list is combined with the format
//              string to create the text of the message box.
//
//  Arguments:  [hwndOwner] - window handle for the message box's owner
//              [hinst]     - instance associated with the string table
//              [idFormat]  - string id for the format of the box's text
//              [idTitle]   - string id for the box's title string
//              [fuStyle]   - style of the dialog box
//              [...]       - argument list for text format string
//
//  Returns:    result from MessageBox
//
//  History:    6-24-94   stevebl   Created
//
//  Notes:      Neither the composed text string nor the title must be
//              longer than MAX_STRING_LENGTH characters.
//
//----------------------------------------------------------------------------

int MessageBoxFromStringIdsAndArgs(
    const HWND hwndOwner,
    const HINSTANCE hinst,
    const UINT idFormat,
    const UINT idTitle,
    const UINT fuStyle, ...)
{
    int iReturn = 0;
    va_list arglist;
    va_start(arglist, fuStyle);
    TCHAR szTitle[MAX_STRING_LENGTH];
    TCHAR szText[MAX_STRING_LENGTH];
    TCHAR szFormat[MAX_STRING_LENGTH];
    if (LoadString(hinst, idTitle, szTitle, MAX_STRING_LENGTH))
    {
        if (LoadString(hinst, idFormat, szFormat, MAX_STRING_LENGTH))
        {
            wvsprintf(szText, szFormat, arglist);
            iReturn = MessageBox(
                hwndOwner,
                szText,
                szTitle,
                fuStyle);
        }
    }
    return(iReturn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\chicago0.inc ===
!IF 0

Copyright (c) 1989-1996  Microsoft Corporation

Module Name:

    chicago.inc

Abstract:

    This file is included from all of the chicago sources files. It
    is handy for doing things like turning off precompiled headers
    to get around compiler bugs, and other such global activities.

!ENDIF

!include ole.inc

C_DEFINES=    \
              $(C_DEFINES)          \
              -DFLAT                \
              -DWIN32=200           \
              -D_CHICAGO_=200       \
              -DINC_OLE2            \
              -DNOEXCEPTIONS        \
              -DCAIROLE_DOWNLEVEL   \
              -DSTRICT              \
              -DNEWPROPS            \
              -D_TRACKLINK_=1       \
              -DMSWMSG              \
              -DDCOM                \
              -DASYNC               \
              -DDCOM_SECURITY       \
!if 0
              -DSHRMEM_OBJEX        \
              -D_CHICAGO_SCM_       \
!endif
              -D_WIN32_DCOM         \
              $(TRACELOG)

MSC_WARNING_LEVEL=/W3 /WX

USE_NOLIBS=1

CHICAGO_PRODUCT=1

GPCH_BUILD=chicago

DEST_TREE=chicago
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\chicago.inc ===
!IF 0

Copyright (c) 1989-1996  Microsoft Corporation

Module Name:

    chicago.inc

Abstract:

    This file is included from all of the chicago sources files. It
    is handy for doing things like turning off precompiled headers
    to get around compiler bugs, and other such global activities.

!ENDIF

# we need to define it here (in addition to chicago0.inc) as build
# does not read chicago0.inc and so it ends up rebuilding evrything
# as it cannot locate the pch
GPCH_BUILD=chicago
!include chicago0.inc

!IFDEF LEGOIZE_OLE32
NTBBT=1
_NT_BBT_ON_THIS_MACHINE=1
!ENDIF

C_DEFINES=    \
              $(C_DEFINES)          \
              -DLITTLEENDIAN=1

MIDL_NO_ROBUST  = 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole2ui32\test\mwclass.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       mwclass.h
//
//  Contents:   definition of the main window class
//
//  Classes:    CMainWindow
//
//  Functions:  Exists
//
//  History:    9-30-94   stevebl   Created
//
//----------------------------------------------------------------------------

#ifndef __MWCLASS_H__
#define __MWCLASS_H__

#include <cwindow.h>
#include <commdlg.h>

#ifdef __cplusplus

int Exists(TCHAR *sz);

//+---------------------------------------------------------------------------
//
//  Class:      CMainWindow
//
//  Purpose:    Code for the main Galactic War window and the main menu.
//
//  Interface:  CMainWindow          -- constructor
//              InitInstance         -- instantiates the main window
//
//  History:    9-30-94   stevebl   Created
//
//  Notes:      only the public interface is listed here
//
//----------------------------------------------------------------------------

class CMainWindow: public CHlprWindow
{
public:
    CMainWindow();
    BOOL InitInstance(HINSTANCE, int);
protected:
    ~CMainWindow();
    LRESULT WindowProc(UINT uMsg, WPARAM wParam, LPARAM lParam);
private:
    LRESULT DoMenu(WPARAM wParam, LPARAM lParam);
    void TestInsertObject();
    void TestPasteSpecial();
    void TestEditLinks();
    void TestChangeIcon();
    void TestConvert();
    void TestCanConvert();
    void TestBusy();
    void TestChangeSource();
    void TestObjectProps();
    void TestPromptUser(int nTemplate);
    void TestUpdateLinks();
};

#endif // __cplusplus

#endif // __MWCLASS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole2ui32\test\test.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       test.h
//
//  Contents:   globaly defined constance, IDs and structures for Galactic War
//
//
//  History:    9-30-94   stevebl   Created
//
//----------------------------------------------------------------------------

#ifndef __TEST_H__
#define __TEST_H__

#include <windows.h>
#include "message.h"

// string constants
#define VER_FILEDESCRIPTION_STR     "OLE2UI32 Test Ap"
#define VER_INTERNALNAME_STR        "TOLE2UI"
#define VER_ORIGINALFILENAME_STR    "TOLE2UI.EXE"
#define MAIN_WINDOW_CLASS_NAME      "TOLE2UIWindow"
#define MAIN_WINDOW_CLASS_MENU      TOLE2UIMenu
#define MAIN_WINDOW_CLASS_MENU_STR  "TOLE2UIMenu"

// menu command identifiers
#define IDM_EXIT            101
#define IDM_INSERTOBJECT    102
#define IDM_PASTESPECIAL    103
#define IDM_EDITLINKS       104
#define IDM_CHANGEICON      105
#define IDM_CONVERT         106
#define IDM_CANCONVERT      107
#define IDM_BUSY            108
#define IDM_CHANGESOURCE    110
#define IDM_OBJECTPROPS     111
#define IDM_PROMPTUSER      112
#define IDM_UPDATELINKS     113

#define IDM_HELP            202
#define IDM_ABOUT           202

// string identifiers
#define IDS_ERROR           1000
#define IDS_OUTOFMEMORY     1001
#define IDS_OLEINITFAILED   1002
#define IDS_BADOLEVERSION   1003
#define IDS_RETURN          1004
#define IDS_INSERTOBJECT    1005
#define IDS_PASTESPECIAL    1006
#define IDS_NOCLIPBOARD     1007
#define IDS_EDITLINKS       1008
#define IDS_CHANGEICON      1009
#define IDS_CONVERT         1010
#define IDS_CANCONVERT      1011
#define IDS_BUSY            1012
#define IDS_CHANGESOURCE    1013
#define IDS_OBJECTPROPS     1014
#define IDS_PROMPTUSER      1015
#define IDS_UPDATELINKS     1016

#endif // __TEST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ole.inc ===
!IF 0

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ole.inc

Abstract:

    This file is included from all of the sources files for all platforms
    built in the ole tree.  It is handy for defining common options and
    paths used in building for different platformsn.

!ENDIF

# This *should* be the only place the root of the project is defined or
# used in building the ole source tree.  If you want to build this
# project with a different root either edit this file or set OLEDIR in your
# environment.
# But, OLEDIR is also used in olethunk\ole16\makefile.inc

!ifndef OLEDIR
OLEDIR=$(PROJECT_ROOT)\ole32
!endif

#   We define _OLE32_ so that when building ole32.dll we don't have
#   DECLSPEC_IMPORT defined (see objbase.h)

!if "$(MINORCOMP)"=="com" || "$(MINORCOMP)"=="stg"||"$(MINORCOMP)"=="ole232"|| \
    "$(MINORCOMP)"=="common" || "$(MINORCOMP)"=="proxy" ||\
     "$(MINORCOMP)"=="comcat" || "$(MINORCOMP)"=="txfole"
C_DEFINES=    \
              $(C_DEFINES)          \
              -D_OLE32_
!endif

MSC_WARNING_LEVEL=/W3 /WX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\daytona.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    daytona.inc

Abstract:

    This file is included from all of the daytona sources files. It
    is handy for doing things like turning off precompiled headers
    to get around compiler bugs, and other such global activities.

!ENDIF

!include ole.inc

C_DEFINES=    \
              $(C_DEFINES)\
              -DNOEXCEPTIONS\
              -DINC_OLE2\
              -DFLAT\
              -DWIN32=100\
              -DDIRECTORY_SERVICE\
              -D_NT1X_=100\
              -D_WIN32_WINNT=0x0501\
              -DUNICODE\
              -D_UNICODE\
              -DCAIROLE_DOWNLEVEL\
              -DDCOM\
              -DASYNC\
              -DMSWMSG\
              -DDCOM_SECURITY\
              -DDFSACTIVATION\
              -DNEWPROPS\
              -D_TRACKLINK_=1\
              -DLITTLEENDIAN=1\
              -DLOCK_PERF=0\
              -D_SRVRHR=0\
              -DSSL\
              -DLIGHTNA\
              $(TRACELOG)

# For the x86, we have the few C runtime routines we use self-contained.

!IF $(386)
USE_NOLIBS=1
!ELSE
USE_MSVCRT=1
!ENDIF

GPCH_BUILD=daytona

DEST_TREE=daytona
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\catalog\classic\tester\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\actprops\serial.cxx ===
//+-------------------------------------------------------------------
//
//  File:       serial.cxx
//
//  Contents:   serialization support
//
//  Classes:    Serializer
//
//  Functions:  Helper class for serialization which holds
//              serialization state like MES handles, position
//              in buffer, stream etc. Provides a virtual
//              buffer for operation but is created from and
//              commited back to an IStream object.
//
//  History:    24-Jan-98   vinaykr      Created
//              17-Aug-98   vinaykr      Made every method inline
//                                       and non-COM class in serial.hxx
//                                       This file no longer used
//              
//
//--------------------------------------------------------------------

#include <ole2int.h>

#include    "serial.hxx"
#include    "buffer.h"


Serializer::~Serializer()
{
    // Free MES handle
    if (_handle!=0)
        MesHandleFree(_handle);

    // If we have a stream free it
    if (_pStream)
    {
        _pIBuff->Release();
        _pStream->Release();
    }

    // If original stream is different free it
    if ((_pOriginalStream) && (_pOriginalStream != _pStream))
        _pOriginalStream->Release();
}

Serializer::Serializer()
{
    _bufSize=0;
    _operationSize=0;
    _buffer = 0;
    _nWritten = 0;
    _position = 0;
    _start = 0;
    _pStream = NULL;
    _pOriginalStream = NULL;
    _pIBuff = NULL;
    _handle = 0;
    _clRefs = 1;
}


HRESULT Serializer::QueryInterface(REFIID iidInterface,
    void **ppvObj)
{
    HRESULT hresult = S_OK;

    // We only support IUnknown and ISerializer
    if (IsEqualIID(iidInterface, IID_IUnknown) ||
    IsEqualIID(iidInterface, IID_ISerializer))
    {
        *ppvObj = (void*)this;
        AddRef();
    }
    else
    {
    *ppvObj = NULL;
    hresult = E_NOINTERFACE;
    }

    return hresult;
}

STDMETHODIMP_(ULONG) Serializer::AddRef(void)
{
    Win4Assert((_clRefs != 0) && "Serializer::AddRef");
    InterlockedIncrement(&_clRefs);
    return _clRefs;
}

STDMETHODIMP_(ULONG) Serializer::Release(void)
{
    Win4Assert((_clRefs != 0) && "Serializer::Release");

    if (InterlockedDecrement(&_clRefs) == 0)
    {
        delete this;
        return 0;
    }

    return _clRefs;
}


/***************************************************************************/
/** Initializes state based on stream for serialization                   **/
/** Assumes that we know the limits of our operation before hand if we    **/
/** writing out to the stream.                                            **/
/***************************************************************************/
STDMETHODIMP Serializer::InitStream(IStream *pStream,DWORD dwSize,
                                    DWORD direction, DWORD dwDestCtx,
                                    DWORD dwMarshalCtx)
{
    HRESULT hr;
    DWORD nRead;
    _direction = direction;
    _destCtx = dwDestCtx;
    _marshalCtx = dwMarshalCtx;
    _pOriginalStream = pStream;
    _pOriginalStream->AddRef();

    // Either read or write initial protocol header
    if (direction == DIRECTION_IN)
    {
         DWORD  x[2];
         if ((hr = _pOriginalStream->Read(x, 8, &nRead)) != S_OK)
             return hr;
         _operationSize = x[0];
    }
    else
    {
         DWORD x[2];
         x[0] = dwSize;
         if ((hr = _pOriginalStream->Write(x, 8, &_nWritten)) != S_OK)
             return hr;
         _operationSize = dwSize;
    }

    // See if given stream supports IBuffer otherwise create one that does
    IBuffer *pibuff;
    if (_pOriginalStream->QueryInterface(IID_IBuffer, (void**)&pibuff)!=S_OK)
    {
        // allocate more in case alignment needed
        _bufSize = _operationSize + 8;
        _pStream = new ActivationStream(_bufSize);
        if (_pStream==NULL)
            return E_OUTOFMEMORY;

        hr = _pStream->QueryInterface(IID_IBuffer, (void**)&_pIBuff);
        ASSERT(hr==S_OK);
        pibuff = _pIBuff;
    }

    do // Loop until we get right buffer
    {
        // Invariant is that pibuff must exist by the time we get here
        ASSERT(pibuff != 0);

        // Set up our buffer appropriately
        if (direction == DIRECTION_IN)
        {
            if (pibuff->GetBuffer(&_bufSize, &_buffer)!=S_OK)
                return E_FAIL;
            if (_bufSize < _operationSize)
                return E_FAIL;
        }
        else
        if (direction == DIRECTION_OUT)
        {
            if (pibuff->GetOrCreateBuffer(_operationSize+GetSize(),
                                            &_bufSize, &_buffer)!=S_OK)
                return E_FAIL;
        }

        if(((INT_PTR)_buffer)&0x7)
        {
            // If buffer is not 8 byte aligned, do it
            if (pibuff != _pIBuff)
            {
                // Only get here if we are still using original
                ASSERT(_pIBuff == 0);
                // So release it and create a new aligned one
                pibuff->Release();
                _bufSize = _operationSize + 8;
                _pStream = new ActivationStream(_bufSize);
                if (_pStream==NULL)
                    return E_OUTOFMEMORY;

                hr = _pStream->QueryInterface(IID_IBuffer, (void**)&_pIBuff);
                ASSERT(hr==S_OK);
                pibuff = _pIBuff;  //Continue loop
            }
            else
            {
                // Got a buffer which we can align
                ASSERT(_pIBuff != 0);
                pibuff = 0;  //Signal end of loop
                // Align buffer
                _start = 8-(PtrToUlong(_buffer)&7);
            }
        }
        else
        {
            // We have an original good one
            _pIBuff = pibuff;
            pibuff  = 0;
        }
    }
    while (pibuff);

    ASSERT(_pIBuff!=0);
    // Set position for next operations and set up
    // internal state correctly
    hr = _pIBuff->SetPosition(_bufSize, _start);
    ASSERT(hr == S_OK);
    _bufSize -= _start;
    _buffer += _start;
    _position = 0;

    if (direction==DIRECTION_IN)
    {
        if ((_pStream) && (_pOriginalStream != _pStream))
        {
            //If what we have is not the original one then we
            //need to copy data into aligned address from original
            DWORD nOver=0;
            do {
                if ((hr=_pOriginalStream->Read(_buffer+nOver,
                                            _operationSize-nOver, &nRead))!= S_OK)
                   return hr;
                nOver += nRead;
             }
              while (nOver<_operationSize);
            _pOriginalStream->Release();
            _pOriginalStream = 0; // Don't need original any longer
        }
        else
            _pStream = _pOriginalStream; // Set operating to original

        ASSERT(_pStream!=0);
        // Create decoding handle for MES operations
        MesDecodeBufferHandleCreate((char*)_buffer, _bufSize, &_handle);
        if (_handle == NULL)
            return E_OUTOFMEMORY;
    }
    else
    {
        _nWritten = 0;
        // Check if we are still using the orignal stream
        if (_pStream == 0)
            _pStream = _pOriginalStream;
        // Create encoding handle for MES operations
        MesEncodeFixedBufferHandleCreate((char*)_buffer,
                                        _bufSize, &_nWritten, &_handle);
        if (_handle == NULL)
            return E_OUTOFMEMORY;
    }

    return S_OK;
}

/***************************************************************************/
/** Sets stream and state for further serialization operations            **/
/** Assumes that a stream supporting IBuffer is provided.                 **/
/***************************************************************************/
STDMETHODIMP Serializer::SetStream(IStream *pStream,DWORD dwOpSize,
                                   DWORD direction,DWORD dwDestCtx,
                                   DWORD dwMarshalCtx)
{
    // Set up internal state
    _destCtx = dwDestCtx;
    _marshalCtx = dwMarshalCtx;
    _direction = direction;
    _pOriginalStream = 0;
    _pStream = pStream;
    _operationSize = dwOpSize;
    _pStream->AddRef();

    // Assume IBuffer exists otherwise fail
    if (_pStream->QueryInterface(IID_IBuffer, (void**)&_pIBuff)!=S_OK)
        return E_FAIL;
    if (_pIBuff->GetBuffer(&_bufSize, &_buffer)!=S_OK)
        return E_FAIL;
    if (_bufSize < _operationSize)
        return E_FAIL;

    // Set up MES handles
    if (direction==DIRECTION_IN)
        MesDecodeBufferHandleCreate((char*)_buffer, _bufSize, &_handle);
    else
        MesEncodeFixedBufferHandleCreate((char*)_buffer,
                                        _bufSize, &_nWritten, &_handle);

        if (_handle == NULL)
            return E_OUTOFMEMORY;

    return S_OK;
}

// Gets MES handle
STDMETHODIMP Serializer::GetSerializationHandle(void *pHandle)
{
    *((handle_t*) pHandle) = _handle;
    Win4Assert(_handle);
    return S_OK;
}

// Gets MES handle for sizing operations
STDMETHODIMP Serializer::GetSizingHandle(void *pHandle)
{
    char dummy[30], *dummybuff;
    unsigned long encodedSize;
    handle_t   handle;
    dummybuff = (char*)(((INT_PTR)(&dummy[7])) & ~7);
    MesEncodeFixedBufferHandleCreate(dummybuff, 100,  &encodedSize, (handle_t*)pHandle);
    if (pHandle == NULL)
        return E_OUTOFMEMORY;
    return S_OK;
}

//Signals end of operations on this object and commits
//operations to stream
STDMETHODIMP Serializer::Commit()
{
    // If we are not using original and we are writing,
    // then we need to copy
    if ((_pOriginalStream) && (_pOriginalStream != _pStream))
    {
        ASSERT(_direction==DIRECTION_OUT);
        HRESULT hr;
        do
        {
            _nWritten = 0;
            hr = _pOriginalStream->Write(_buffer,
                                         _operationSize, &_nWritten);
            if (hr != S_OK)
                break;
            _operationSize -= _nWritten;
            _buffer += _nWritten;
        }
        while (_operationSize);

        return hr;
    }
    else
        return _pIBuff->SetPosition(_bufSize, _operationSize);
}

STDMETHODIMP Serializer::SetPosition(DWORD dwPos)
{
    // Sets position in buffer and creates appropriate MES handle
    HRESULT hr = _pIBuff->SetPosition(_bufSize, dwPos);
    if (hr!=S_OK)
        return hr;
    MesHandleFree(_handle);
    if (_direction == DIRECTION_IN)
        MesDecodeBufferHandleCreate((char*)(_buffer+dwPos), _bufSize, &_handle);
    else
    {
        _nWritten = 0;
        MesEncodeFixedBufferHandleCreate((char*)(_buffer+dwPos), _bufSize, &_nWritten, &_handle);
    }
    if (_handle == NULL)
        return E_OUTOFMEMORY;

    _position = dwPos;
    return S_OK;
}

// Gets current position in buffer
STDMETHODIMP Serializer::GetPosition(DWORD *pdwPos)
{
    *pdwPos = _position;
    return S_OK;
}

// Increment current position by specified amount in buffer
STDMETHODIMP Serializer::IncrementPosition(DWORD dwInc)
{
    return SetPosition(_position+dwInc);
}

// Get buffers underlying stream object
STDMETHODIMP Serializer::GetStream(IStream **ppStream)
{
    _pStream->AddRef();
    *ppStream = _pStream;
    return S_OK;
}

// Get a copy of this object
STDMETHODIMP Serializer::GetCopy(ISerializer **ppSer)
{

   HRESULT hr;
   IStream *pNewStream;
   if (_pStream)
   {
        ASSERT(_direction==DIRECTION_IN); //No need for any other case right now
        hr = _pIBuff->SetPosition(_bufSize, 0);
        ASSERT(hr==S_OK);
        Serializer *ser = new Serializer();
        if (ser==NULL)
            return E_OUTOFMEMORY;

        if (_pOriginalStream) // Still using original so clone
        {
            ASSERT(_start==0);
            ASSERT(_pStream==_pOriginalStream);
            hr = _pIBuff->SetCopyAlignment(8);
            ASSERT(hr==S_OK);
            hr = _pStream->Clone(&pNewStream);
            if (hr != S_OK)
	    {
	       delete ser;
	       return hr;
	    }
        }
        else
        {
            pNewStream = _pStream;
        }
        hr = ser->SetStream(pNewStream, _operationSize,
                            _direction, _destCtx, _marshalCtx);
	if (FAILED(hr)) 
	{
	   if (pNewStream != _pStream)
	       pNewStream->Release();
	   delete ser;
	   return hr;
	}
        hr = ser->SetPosition(_position);
	if (FAILED(hr)) 
	{
	   if (pNewStream != _pStream)
	       pNewStream->Release();
	   delete ser;
	   return hr;
	}
        hr = _pIBuff->SetPosition(_bufSize, _position);
        ASSERT(hr==S_OK);
        *ppSer = ser;
        if (pNewStream != _pStream)
            pNewStream->Release();
        return S_OK;
   }

   return E_FAIL;
}

// Write provided buffer into our buffer at current position
// and advance position
STDMETHODIMP Serializer::Write(BYTE *buff, DWORD nBytes)
{
   ASSERT(nBytes<=(_bufSize-_position));
   memcpy(_buffer+_position,buff, (size_t) nBytes);
   IncrementPosition(nBytes);
   return S_OK;
}

// Copy into provided Serializer our data at given position and length
STDMETHODIMP Serializer::CopyTo(ISerializer *pSer, DWORD dwPos, DWORD nBytes)
{
   ASSERT(nBytes<=(_bufSize-dwPos));
   return pSer->Write(_buffer+dwPos, nBytes);
}

// return buffer starting at current position
STDMETHODIMP Serializer::GetBufferAtCurrent(BYTE **ppBuff)
{
    *ppBuff = _buffer+_position;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\actprops\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=   actprops
TARGETPATH=   obj
TARGETTYPE=   LIBRARY

INCLUDES=     ..\..\ih;..;..\..\com\inc;..\..\com\dcomrem
INCLUDES=     $(INCLUDES);..\..\idl\internal\$(DEST_TREE)\$(O)
INCLUDES=     $(INCLUDES);..\..\idl\public\$(DEST_TREE)\$(O)
INCLUDES=     $(INCLUDES);..\..\idl\private\$(DEST_TREE)\$(O)
INCLUDES=     $(INCLUDES);$(BASE_INC_PATH)

C_DEFINES=    \
              $(C_DEFINES)

SOURCES=      \
              ..\actprops.cxx   \
              ..\propifs.cxx \
              ..\actstrm.cxx

UMTYPE=       windows
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\actprops\actstrm.cxx ===
//+-------------------------------------------------------------------
//
//  File:       actstrm.cxx
//
//  Contents:   code for providing a stream with an IBuffer interface
//              as well as providing marshalled interface data for 
//              RPC.
//
//  Classes:    ActivationStream
//
//  History:    30-Jan-93   Ricksa      Created CXmitRpcStream
//              04-Feb-98   Vinaykr     ActivationStream
//
//  Description: All requirements of CXmitRpcStream, plus the additional
//               requirement of being able to support a buffer interface
//               for activation custom marshalling.
//--------------------------------------------------------------------

#include <ole2int.h>

#include    <actstrm.hxx>


HRESULT GetActivationStream(REFIID riid, void** ppv, DWORD size)
{
    ActivationStream *st = new ActivationStream(size);
    if (st==NULL)
        return E_OUTOFMEMORY;
    return st->QueryInterface(riid, ppv);
    return S_OK;
}



STDMETHODIMP ActivationStream::QueryInterface(
    REFIID iidInterface,
    void FAR* FAR* ppvObj)
{
    HRESULT hresult = S_OK;

    // We only support IUnknown and IStream
    if (IsEqualIID(iidInterface, IID_IUnknown) ||
        IsEqualIID(iidInterface, IID_IStream))
    {
        *ppvObj = (IStream*)this;
        AddRef();
    }
    else
    if (IsEqualIID(iidInterface, IID_IBuffer))
    {
        *ppvObj = (IBuffer*)this;
        AddRef();
    }
    else
    {
        *ppvObj = NULL;
        hresult = E_NOINTERFACE;
    }

    return hresult;
}

STDMETHODIMP_(ULONG) ActivationStream::AddRef(void)
{
    Win4Assert((_clRefs != 0) && "ActivationStream::AddRef");
    InterlockedIncrement(&_clRefs);
    return _clRefs;
}

STDMETHODIMP_(ULONG) ActivationStream::Release(void)
{
    Win4Assert((_clRefs != 0) && "ActivationStream::Release");

    if (InterlockedDecrement(&_clRefs) == 0)
    {
        delete this;
        return 0;
    }

    return _clRefs;
}

STDMETHODIMP ActivationStream::Read(
    VOID HUGEP* pv,
    ULONG cb,
    ULONG FAR* pcbRead)
{
    HRESULT hresult = S_OK;

    if (pcbRead)
    {
        *pcbRead = 0L;
    }

    if (cb + _lOffset > _cbData)
    {
        cb = _cbData - _lOffset;
        //CairoleDebugOut((DEB_ERROR, "ActivationStream read past end of stream %x\n", cb+_lOffset));
        hresult = STG_E_READFAULT;
    }

    memcpy(pv,_pifData->abData + _lOffset, (size_t) cb);
    _lOffset += cb;

    if (pcbRead != NULL)
    {
        *pcbRead = cb;
    }

    return hresult;
}

STDMETHODIMP ActivationStream::Write(
    VOID  const HUGEP* pv,
    ULONG cbToWrite,
    ULONG FAR* pcbWritten)
{
    HRESULT hresult = S_OK;

    if (pcbWritten)
    {
        *pcbWritten = 0L;
    }

    if (cbToWrite + _lOffset > _cbData)
    {
        // the current stream is too small, try to grow it.

        if (!_fFree)
        {
            // The stream doesn't own the buffer so it can't reallocate it
            //CairoleDebugOut((DEB_ERROR, "ActivationStream write past end of stream %x\n",
                //cbToWrite + _lOffset));
            return STG_E_WRITEFAULT;
        }

        // Reallocate the size of the buffer
        // REVIEW: The constant added to the size allocated is a number
        // designed simply to try and decrease the number of follow on
        // allocations. In other words it needs to be tuned (or dropped!).

        BYTE *pbNewBuf = (BYTE *) ActMemAlloc(sizeof(DWORD) +
                                                     cbToWrite +
                                                     _lOffset + 64);

        if (pbNewBuf == NULL)
        {
            //CairoleDebugOut((DEB_ERROR, "ActivationStream cant grow stream\n"));
            return E_OUTOFMEMORY;
        }

        if (_pifData)
        {
            // we had a buffer from before, copy that in, and free the old one.
            memcpy(pbNewBuf, _pifData, sizeof(DWORD) + _cbData);
            ActMemFree(_pifData);
        }

        _cbData = cbToWrite + _lOffset + 64;
        _pifData = (InterfaceData *)pbNewBuf;
    }


    // copy in the new data
    memcpy(_pifData->abData + _lOffset, pv, (size_t) cbToWrite);
    _lOffset += cbToWrite;

    if (pcbWritten != NULL)
    {
        *pcbWritten = cbToWrite;
    }

    // We assume maxium size of buffer is the size to send on the network.
    if (_cSize < _lOffset)
    {
        _cSize = _lOffset;
    }

    return hresult;
}

STDMETHODIMP ActivationStream::Seek(
    LARGE_INTEGER dlibMoveIN,
    DWORD dwOrigin,
    ULARGE_INTEGER FAR* plibNewPosition)
{
    HRESULT hresult = S_OK;

/*
can't use this code until the stuff in ole2pr32.dll is fixed.

    // check against -2^31-1 <= x <= 2^31-1
    if (dlibMoveIN.HighPart == 0 && dlibMoveIN.LowPart < 0x80000000)
        // positive 31 bit value
        ;
    else if (dlibMoveIN.HighPart == -1L && dlibMoveIN.LowPart >= 0x80000000)
        // negative 31 bit value
        ;
    else
        return STG_E_SEEKERROR;
*/

    LONG dlibMove = dlibMoveIN.LowPart;
    ULONG cbNewPos = dlibMove;

    switch(dwOrigin)
    {
    case STREAM_SEEK_SET:

        if (dlibMove >= 0)
        {
            _lOffset = dlibMove;
        }
        else
        {
            hresult = STG_E_SEEKERROR;
        }
        break;

    case STREAM_SEEK_CUR:

        if (!(dlibMove < 0 && (-dlibMove > _lOffset)))
        {
            _lOffset += (ULONG) dlibMove;
        }
        else
        {
            hresult = STG_E_SEEKERROR;
        }
        break;

    case STREAM_SEEK_END:

        if (!(dlibMove < 0 && ((ULONG) -dlibMove) > _cbData))
        {
            _lOffset = _cbData + dlibMove;
        }
        else
        {
            hresult = STG_E_SEEKERROR;
        }
        break;

    default:

        hresult = STG_E_SEEKERROR;
    }

    if (plibNewPosition != NULL)
    {
        ULISet32(*plibNewPosition, _lOffset);
    }

    return hresult;
}

STDMETHODIMP ActivationStream::SetSize(ULARGE_INTEGER cb)
{
    return E_NOTIMPL;
}

STDMETHODIMP ActivationStream::CopyTo(
    IStream FAR* pstm,
    ULARGE_INTEGER cb,
    ULARGE_INTEGER FAR* pcbRead,
    ULARGE_INTEGER FAR* pcbWritten)
{
    return E_NOTIMPL;
}

STDMETHODIMP ActivationStream::Commit(DWORD grfCommitFlags)
{
    return NOERROR;
}

STDMETHODIMP ActivationStream::Revert(void)
{
    return NOERROR;
}

STDMETHODIMP ActivationStream::LockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType)
{
    return STG_E_INVALIDFUNCTION;
}

STDMETHODIMP ActivationStream::UnlockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType)
{
    return STG_E_INVALIDFUNCTION;
}

STDMETHODIMP ActivationStream::Stat(
    STATSTG FAR* pstatstg,
    DWORD statflag)
{
    memset(pstatstg, 0, sizeof(STATSTG));
    return E_NOTIMPL;
}

STDMETHODIMP ActivationStream::SetCopyAlignment(DWORD alignment)
{
    _copyAlignment = alignment;
    return S_OK;
}

inline ActivationStream *ActivationStream::Clone()
{
    DWORD len;
    BYTE *newBuff;
    DWORD alignmentOffset=0;

    // Assume 8 byte alignment for new buffer
    ActivationStream *strm = new ActivationStream(_cbData+_copyAlignment-1);

    if (strm == NULL)
        return strm;

    // make sure we were able to allocate an internal buffer
    if (_cbData != 0)
    {
        strm->GetLength(&len);
        if (len == 0)
        {
            delete strm;
            return NULL;
        }
    }
    
    strm->GetBuffer(&len, &newBuff);
   
    ASSERT(len==(_cbData+_copyAlignment-1));
    ASSERT( sizeof(_lOffset) == sizeof(LONG) );
    if ((UINT_PTR)(newBuff+_lOffset) & (_copyAlignment-1))
    {
        alignmentOffset = _copyAlignment - 
                               ( PtrToUlong(newBuff+_lOffset) & (_copyAlignment-1) );
    }
    GetCopy(newBuff+alignmentOffset);
    strm->SetPosition(len, _lOffset+alignmentOffset);
    return strm;
}

STDMETHODIMP ActivationStream::Clone(IStream FAR * FAR *ppstm)
{
    *ppstm = Clone();
    if (*ppstm==NULL)
        return E_OUTOFMEMORY;
    return S_OK;
}

STDMETHODIMP ActivationStream::GetOrCreateBuffer(DWORD dwReq, DWORD *pdwLength, BYTE **ppBuff)
{
    if (((_cbData - _lOffset) < dwReq) || (!_pifData))
    {
        BYTE* pbNewBuf = (BYTE*)ActMemAlloc(sizeof(DWORD)+dwReq+_cbData-_lOffset);
        if (pbNewBuf==NULL)
            return E_OUTOFMEMORY;

        if (_pifData)
        {
            // we had a buffer from before, copy that in, and free the old one.
            memcpy(pbNewBuf, _pifData, sizeof(DWORD) + _cbData);
            ActMemFree(_pifData);
        } 
        // update _cbData
        _cbData = dwReq + _cbData - _lOffset;

        _pifData = (InterfaceData*)pbNewBuf;
    }
    *ppBuff = _pifData->abData + _lOffset;
    *pdwLength = _cbData - _lOffset;
    return S_OK;
}

STDMETHODIMP ActivationStream::GetBuffer(DWORD *pdwLength, BYTE **ppBuff)
{
    *pdwLength = _cbData-_lOffset;
    *ppBuff = _pifData->abData + _lOffset;
    return S_OK;
}

STDMETHODIMP ActivationStream::GetLength(DWORD *pdwLength)
{
    *pdwLength = _cbData;
    return S_OK;
}

STDMETHODIMP ActivationStream::GetCopy(BYTE *pBuff)
{
    memcpy(pBuff, _pifData->abData, _cbData);
    return S_OK;
}

STDMETHODIMP ActivationStream::SetPosition(DWORD dwLenFromEnd, DWORD dwPosFromStart)
{
    if (dwPosFromStart > dwLenFromEnd)
        return E_FAIL;
    _lOffset = _cbData - dwLenFromEnd + dwPosFromStart;
    if (_cSize < _lOffset)
        _cSize = _lOffset;
    return S_OK;
}

STDMETHODIMP ActivationStream::SetBuffer(DWORD dwLength, BYTE *pBuff)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\catalog\classic\cat_dll.cpp ===
/* cat_dll.cpp */

#include <windows.h>
#include <comdef.h>


const GUID CLSID_COMCatalog = { 0x00000346, 0, 0, 0xC0,0,0,0,0,0,0,0x46 };

HRESULT __stdcall GetCatalogObject
(
    /* [in] */ REFIID riid,
    /* [out, iis_is(riid)] */ void ** ppv
)
{
    return CoCreateInstance (CLSID_COMCatalog, NULL, CLSCTX_INPROC, riid, ppv);
}


#define CLSID_CATALOG "{1A26EFEF-9F04-11D1-8F36-00C04FD8FF5E}"

const CLSID g_clsid_catalog =
    {0x1A26EFEF,0x9F04,0x11D1,{0x8F,0x36,0x00,0xC0,0x4F,0xD8,0xFF,0x5E}};

class CClassFactory : public IClassFactory
{
public:
    CClassFactory(void);
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    STDMETHODIMP CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID FAR* ppvObject);
    STDMETHODIMP LockServer(BOOL fLock);

private:
    long m_cRef;
};

CClassFactory::CClassFactory(void) : m_cRef(0) { }

STDMETHODIMP CClassFactory::QueryInterface(
        REFIID riid,
        LPVOID FAR* ppvObj)
{
    *ppvObj = NULL;

    if ((riid == IID_IClassFactory) || (riid == IID_IUnknown))
    {
        *ppvObj = (LPVOID) (IClassFactory *) this;
    }

    if (*ppvObj != NULL)
    {
        ((LPUNKNOWN)*ppvObj)->AddRef();

        return S_OK;
    }

    return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CClassFactory::AddRef(void)
{
    long cRef;

    cRef = InterlockedIncrement(&m_cRef);

    return(cRef);
}

STDMETHODIMP_(ULONG) CClassFactory::Release(void)
{
    long cRef;

    cRef = InterlockedDecrement(&m_cRef);
    if (cRef == 0)
    {
        delete this;
    }

    return(cRef);
}


STDMETHODIMP CClassFactory::CreateInstance(
        LPUNKNOWN pUnkOuter,
        REFIID riid,
        LPVOID FAR* ppvObj)
{
    HRESULT hr;

    *ppvObj = NULL;

    if (pUnkOuter)
    {
        return(CLASS_E_NOAGGREGATION);
    }

    hr = CoCreateInstance (CLSID_COMCatalog, NULL, CLSCTX_INPROC, riid, ppvObj);

    return(hr);
}


STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    return(S_OK);
}


static HINSTANCE g_hInst = NULL;

STDAPI_(BOOL) APIENTRY DllMain
(
    HINSTANCE hInst,
    DWORD dwReason,
    LPVOID lpReserved
)
{
    g_hInst = hInst;
    return(TRUE);
}


STDAPI DllCanUnloadNow(void)
{
    return( S_FALSE );
}


STDAPI DllGetClassObject
(
    REFCLSID rclsid,
    REFIID riid,
    LPVOID FAR* ppvObj
)
{
    if (rclsid != g_clsid_catalog)
    {
        return(E_FAIL);
    }

    if (ppvObj == NULL)
    {
        return E_INVALIDARG;
    }
    *ppvObj = NULL;

    CClassFactory *pcf = new CClassFactory;
    if (pcf == NULL)
    {
        return(E_OUTOFMEMORY);
    }

    pcf->AddRef();
    HRESULT hRes = pcf->QueryInterface(riid, ppvObj);
    pcf->Release();

    return(hRes);
}


typedef struct
{
    char *KeyName;
    char *ValueName;
    char *Value;
} REGISTRATION_ENTRY;

REGISTRATION_ENTRY registration[] =
{
    { "CLSID\\" CLSID_CATALOG, NULL, "COM+ Catalog Queries" },
    { "CLSID\\" CLSID_CATALOG "\\InprocServer32", NULL, /* dynamic */ },
    { "CLSID\\" CLSID_CATALOG "\\InprocServer32", "ThreadingModel", "Both" }
};

#define NUM_REGISTRATION_VALUES (sizeof(registration) / sizeof(registration[0]))
#define REGISTRATION_SERVER (1)


STDAPI DllRegisterServer(void)
{
    HRESULT hr;
    char szModuleName[MAX_PATH];

    GetModuleFileNameA(g_hInst, szModuleName, MAX_PATH);
    registration[REGISTRATION_SERVER].Value = szModuleName;

    for (int i = 0; i < NUM_REGISTRATION_VALUES; i++)
    {
        HKEY hKey;
        hr = RegCreateKeyA(HKEY_CLASSES_ROOT, registration[i].KeyName, &hKey);
        if (hr == ERROR_SUCCESS)
        {
            hr = RegSetValueExA(hKey,
                    registration[i].ValueName,
                    0,
                    REG_SZ,
                    (BYTE *) registration[i].Value,
                    strlen(registration[i].Value) + 1);

            RegCloseKey(hKey);
        }

        if (hr != ERROR_SUCCESS)
        {
            DllUnregisterServer();

            return(SELFREG_E_CLASS);
        }
    }

    return(S_OK);
}


STDAPI DllUnregisterServer(void)
{
    for (int i = NUM_REGISTRATION_VALUES - 1; i >= 0; i--)
    {
        RegDeleteKeyA(HKEY_CLASSES_ROOT, registration[i].KeyName);
    }

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\catalog\classic\tester\tester.cpp ===
/* tester.cpp */

#define DISPLAY
//#define QUICK
//#define SCM_TEST

#define COMREG32DLL "ComReg32.dll"

#include <windows.h>
#include <comdef.h>
#include <stdio.h>

#include "catalog_i.c"  // from classreg.idl
#include "catalog.h"    // from classreg.idl


#define NUM_PASSES  (1)
#define NUM_REPS    (1)

#define MAX_IDS     (3000)

#define REAL_PER_BOGUS  (20)    /* xxx real ids per bogus ids real ids */


//  abcdefgh-ijkl-mnop-qrst-uvwxyzABCDEF
//  0000000000111111111122222222223333333
//  0123456789012345678901234567890123456

//  00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15
//  gh ef cd ab kl ij op mn qr st uv wx yz AB CD EF

#define SEPARATOR1 (8)
#define SEPARATOR2 (13)
#define SEPARATOR3 (18)
#define SEPARATOR4 (23)

int guidByteToStringPosition[] =
{
    6, 4, 2, 0, 11, 9, 16, 14, 19, 21, 24, 26, 28, 30, 32, 34, -1
};

//  {abcdefgh-ijkl-mnop-qrst-uvwxyzABCDEF}
//  000000000011111111112222222222333333333
//  012345678901234567890123456789012345678

#define CURLY_OPEN  (0)
#define CURLY_CLOSE (37)


bool StringToGUID(const char *pszString, _GUID *pGuid)
{
    int *pPosition = guidByteToStringPosition;
    BYTE *pGuidByte = (BYTE *) pGuid;
    char c;
    const char *pchIn;
    BYTE b;

    while (*pPosition >= 0)
    {
        pchIn = pszString + *pPosition++;

        c = *pchIn++;

        if ((c >= '0') && (c <= '9'))
        {
            b = c - '0';
        }
        else if ((c >= 'A') && (c <= 'Z'))
        {
            b = c - 'A' + 10;
        }
        else if ((c >= 'a') && (c <= 'z'))
        {
            b = c - 'a' + 10;
        }
        else
        {
            return(FALSE);
        }

        b <<= 4;

        c = *pchIn++;

        if ((c >= '0') && (c <= '9'))
        {
            b |= (c - '0');
        }
        else if ((c >= 'A') && (c <= 'Z'))
        {
            b |= (c - 'A' + 10);
        }
        else if ((c >= 'a') && (c <= 'z'))
        {
            b |= (c - 'a' + 10);
        }
        else
        {
            return(FALSE);
        }

        *pGuidByte++ = b;
    }

    if ((pszString[SEPARATOR1] != '-') ||
        (pszString[SEPARATOR2] != '-') ||
        (pszString[SEPARATOR3] != '-') ||
        (pszString[SEPARATOR4] != '-'))
    {
        return(FALSE);
    }

    return(TRUE);
}


bool CurlyStringToGUID(const char *pszString, _GUID *pGuid)
{
    if ((pszString[CURLY_OPEN] == '{') &&
        (pszString[CURLY_CLOSE] == '}'))
    {
        return(StringToGUID(pszString + 1, pGuid));
    }
    else
    {
        return(FALSE);
    }
}


int __cdecl compare_guid(const void *elem1, const void *elem2)
{
    const _GUID *guid1 = (const _GUID *) elem1;
    const _GUID *guid2 = (const _GUID *) elem2;

    if (guid1->Data1 < guid2->Data1)
    {
        return(-1);
    }
    else if (guid1->Data1 > guid2->Data1)
    {
        return(+1);
    }
    else if (guid1->Data2 < guid2->Data2)
    {
        return(-1);
    }
    else if (guid1->Data2 > guid2->Data2)
    {
        return(+1);
    }
    else if (guid1->Data3 < guid2->Data3)
    {
        return(-1);
    }
    else if (guid1->Data3 > guid2->Data3)
    {
        return(+1);
    }
    else
    {
        return(memcmp(guid1->Data4, guid2->Data4, sizeof(guid1->Data4)));
    }
}


HRESULT DoLookup(IComClassInfo *pClassInfo)
{
    HRESULT hr;
    CLSID *pClsid;
    WCHAR *pwsz;
    WCHAR *pwsz2;
    IClassClassicInfo *pClassicInfo;
    ThreadingModel dwThreadingModel;
    ITypeInfo *pTypeInfo;
    IComProcessInfo *pProcessInfo;
    IProcessServerInfo *pServerInfo;
    CLSCTX clsctx;
    LocalServerType eLocalServerType;
    int iStage;
    ULONG ulCount;
    char *psz;
    ProcessType eProcessType;
    RunAsType eRunAsType;
    SECURITY_DESCRIPTOR *psd;
    DWORD dw;
    BOOL fBool;


    /* IComClassInfo::GetConfiguredClsid */

    hr = pClassInfo->GetConfiguredClsid(&pClsid);
#ifdef DISPLAY
    if (hr != S_OK)
    {
        printf("GetConfiguredClsid returned 0x%X\n", hr);
    }
    else
    {
        printf("GetConfiguredClsid returned %08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X\n",
                pClsid->Data1,
                pClsid->Data2,
                pClsid->Data3,
                pClsid->Data4[0],
                pClsid->Data4[1],
                pClsid->Data4[2],
                pClsid->Data4[3],
                pClsid->Data4[4],
                pClsid->Data4[5],
                pClsid->Data4[6],
                pClsid->Data4[7]);
    }
#endif

    /* IComClassInfo::GetProgId */

    hr = pClassInfo->GetProgId(&pwsz);
#ifdef DISPLAY
    if (hr == S_OK)
    {
        printf("GetProgId returned '%ls'\n", pwsz);
    }
    else if (hr == E_FAIL)
    {
        printf("GetProgId returned <none>\n");
    }
    else
    {
        printf("GetProgId returned 0x%X\n", hr);
    }
#endif

    /* IComClassInfo::GetClassName */

    hr = pClassInfo->GetClassName(&pwsz);
#ifdef DISPLAY
    if (hr == S_OK)
    {
        printf("GetClassName returned '%ls'\n", pwsz);
    }
    else if (hr == E_FAIL)
    {
        printf("GetClassName returned <none>\n");
    }
    else
    {
        printf("GetClassName returned 0x%X\n", hr);
    }
#endif

    /* IComClassInfo::GetApplication does not apply in Classic */

    /* IComClassInfo::GetClassContext */

    hr = pClassInfo->GetClassContext((CLSCTX) 0xFFFFFFFF, &clsctx);
#ifdef DISPLAY
    if (hr == S_OK)
    {
        printf("GetClassContext returned clsctx=0x%X ( ", clsctx);

        if (clsctx & CLSCTX_INPROC_SERVER)
        {
            printf("CLSCTX_INPROC_SERVER ");
        }

        if (clsctx & CLSCTX_INPROC_HANDLER)
        {
            printf("CLSCTX_INPROC_HANDLER ");
        }

        if (clsctx & CLSCTX_LOCAL_SERVER)
        {
            printf("CLSCTX_LOCAL_SERVER ");
        }

        if (clsctx & CLSCTX_INPROC_SERVER16)
        {
            printf("CLSCTX_INPROC_SERVER16 ");
        }

        if (clsctx & CLSCTX_REMOTE_SERVER)
        {
            printf("CLSCTX_REMOTE_SERVER ");
        }

        if (clsctx & CLSCTX_INPROC_HANDLER16)
        {
            printf("CLSCTX_INPROC_HANDLER16 ");
        }

        if (clsctx & CLSCTX_INPROC_SERVERX86)
        {
            printf("CLSCTX_INPROC_SERVERX86 ");
        }

        if (clsctx & CLSCTX_INPROC_HANDLERX86)
        {
            printf("CLSCTX_INPROC_HANDLERX86 ");
        }

        printf(")\n");
    }
    else
    {
        printf("GetClassContext returned 0x%X\n", hr);
    }
#endif

    /* IComClassInfo::GetCustomActivatorCount */

    for (iStage = 0; iStage <= 4; iStage++)
    {
        hr = pClassInfo->GetCustomActivatorCount((ACTIVATION_STAGE) iStage, &ulCount);
#ifdef DISPLAY
        if (hr == S_OK)
        {
            printf("GetCustomActivatorCount(%u) returned ulCount=%u\n", iStage, ulCount);
        }
        else
        {
            printf("GetCustomActivatorCount(%u) returned 0x%X\n", iStage, hr);
        }
#endif
    }

    /* IComClassInfo::GetCustomActivatorClsids does not apply in Classic */

    /* IComClassInfo::GetCustomActivators does not apply in Classic */

    /* IComClassInfo::GetTypeInfo does not apply in Classic */

    hr = pClassInfo->GetTypeInfo(IID_ITypeInfo, (void **) &pTypeInfo);
#ifdef DISPLAY
    if (hr == S_OK)
    {
        printf("GetTypeInfo succeeded\n");

        pTypeInfo->Release();
    }
    else
    {
        printf("GetTypeInfo returned 0x%X\n", hr);
    }
#endif

#if 0   //not implemented yet
    /* IClassClassicInfo::IsComPlusConfiguredClass */

    hr = pClassInfo->IsComPlusConfiguredClass(&fBool);
#ifdef DISPLAY
    if (hr == S_OK)
    {
        printf("IsComPlusConfiguredClass returned %s\n", fBool ? "TRUE" : "FALSE");
    }
    else
    {
        printf("IsComPlusConfiguredClass returned 0x%X\n", hr);
    }
#endif
#endif  

    /* IComClassInfo::QI for IClassClassicInfo */

    hr = pClassInfo->QueryInterface(IID_IClassClassicInfo, (void **) &pClassicInfo);
    if (hr == S_OK)
    {
#ifdef DISPLAY
        printf("QI for IClassClassicInfo succeeded\n");
#endif

        /* IClassClassicInfo::GetThreadingModel */

        hr = pClassicInfo->GetThreadingModel( &dwThreadingModel);
#ifdef DISPLAY
        if (hr == S_OK)
        {
            printf("GetThreadingModel returned S_OK, model=", dwThreadingModel);
            switch (dwThreadingModel)
            {
            case SingleThreaded:
                printf("SingleThreaded\n");
                break;

            case ApartmentThreaded:
                printf("ApartmentThreaded\n");
                break;

            case FreeThreaded:
                printf("FreeThreaded\n");
                break;

            case BothThreaded:
                printf("BothThreaded\n");
                break;

            case NeutralThreaded:
                printf("NeutralThreaded\n");
                break;

            default:
                printf("<unknown 0x%X>\n", dwThreadingModel);
            }
        }
        else
        {
            printf("GetThreadingModel returned 0x%X\n", hr);
        }
#endif

        /* IClassClassicInfo::GetModulePath */

        if (clsctx & CLSCTX_INPROC_SERVER)
        {
            hr = pClassicInfo->GetModulePath(CLSCTX_INPROC_SERVER, &pwsz);
#ifdef DISPLAY
            if (hr == S_OK)
            {
                printf("GetModulePath(CLSCTX_INPROC_SERVER) returned '%ls'\n", pwsz);
            }
            else
            {
                printf("GetModulePath(CLSCTX_INPROC_SERVER) returned 0x%X\n", hr);
            }
#endif
        }

        if (clsctx & CLSCTX_INPROC_HANDLER)
        {
            hr = pClassicInfo->GetModulePath(CLSCTX_INPROC_HANDLER, &pwsz);
#ifdef DISPLAY
            if (hr == S_OK)
            {
                printf("GetModulePath(CLSCTX_INPROC_HANDLER) returned '%ls'\n", pwsz);
            }
            else
            {
                printf("GetModulePath(CLSCTX_INPROC_HANDLER) returned 0x%X\n", hr);
            }
#endif
        }

        if (clsctx & CLSCTX_LOCAL_SERVER)
        {
            hr = pClassicInfo->GetModulePath(CLSCTX_LOCAL_SERVER, &pwsz);
#ifdef DISPLAY
            if (hr == S_OK)
            {
                printf("GetModulePath(CLSCTX_LOCAL_SERVER) returned '%ls'\n", pwsz);
            }
            else
            {
                printf("GetModulePath(CLSCTX_LOCAL_SERVER) returned 0x%X\n", hr);
            }
#endif
            /* IClassClassicInfo::GetLocalServerType */

            hr = pClassicInfo->GetLocalServerType(&eLocalServerType);
#ifdef DISPLAY
            if (hr == S_OK)
            {
                switch(eLocalServerType)
                {
                case LocalServerType16:
                    printf("GetLocalServerType returned LocalServerType16\n");
                    break;

                case LocalServerType32:
                    printf("GetLocalServerType returned LocalServerType32\n");
                    break;

                default:
                    printf("GetLocalServerType returned unknown type %d\n", eLocalServerType);
                }
            }
            else
            {
                printf("GetLocalServerType retured hr = 0x%X\n", hr);
            }
#endif
        }

        if (clsctx & CLSCTX_INPROC_SERVER16)
        {
            hr = pClassicInfo->GetModulePath(CLSCTX_INPROC_SERVER16, &pwsz);
#ifdef DISPLAY
            if (hr == S_OK)
            {
                printf("GetModulePath(CLSCTX_INPROC_SERVER16) returned '%ls'\n", pwsz);
            }
            else
            {
                printf("GetModulePath(CLSCTX_INPROC_SERVER16) returned 0x%X\n", hr);
            }
#endif
        }

        if (clsctx & CLSCTX_REMOTE_SERVER)
        {
            hr = pClassicInfo->GetModulePath(CLSCTX_REMOTE_SERVER, &pwsz);
#ifdef DISPLAY
            if (hr == S_OK)
            {
                printf("GetModulePath(CLSCTX_REMOTE_SERVER) returned '%ls'\n", pwsz);
            }
            else
            {
                printf("GetModulePath(CLSCTX_REMOTE_SERVER) returned 0x%X\n", hr);
            }
#endif
        }

        if (clsctx & CLSCTX_INPROC_HANDLER16)
        {
            hr = pClassicInfo->GetModulePath(CLSCTX_INPROC_HANDLER16, &pwsz);
#ifdef DISPLAY
            if (hr == S_OK)
            {
                printf("GetModulePath(CLSCTX_INPROC_HANDLER16) returned '%ls'\n", pwsz);
            }
            else
            {
                printf("GetModulePath(CLSCTX_INPROC_HANDLER16) returned 0x%X\n", hr);
            }
#endif
        }

        if (clsctx & CLSCTX_INPROC_SERVERX86)
        {
            hr = pClassicInfo->GetModulePath(CLSCTX_INPROC_SERVERX86, &pwsz);
#ifdef DISPLAY
            if (hr == S_OK)
            {
                printf("GetModulePath(CLSCTX_INPROC_SERVERX86) returned '%ls'\n", pwsz);
            }
            else
            {
                printf("GetModulePath(CLSCTX_INPROC_SERVERX86) returned 0x%X\n", hr);
            }
#endif
        }

        if (clsctx & CLSCTX_INPROC_HANDLERX86)
        {
            hr = pClassicInfo->GetModulePath(CLSCTX_INPROC_HANDLERX86, &pwsz);
#ifdef DISPLAY
            if (hr == S_OK)
            {
                printf("GetModulePath(CLSCTX_INPROC_HANDLERX86) returned '%ls'\n", pwsz);
            }
            else
            {
                printf("GetModulePath(CLSCTX_INPROC_HANDLERX86) returned 0x%X\n", hr);
            }
#endif
        }


        /* IClassClassicInfo::GetImplementedClsid */

        hr = pClassicInfo->GetImplementedClsid(&pClsid);
#ifdef DISPLAY
        if (hr != S_OK)
        {
            printf("GetImplementedClsid returned 0x%X\n", hr);
        }
        else
        {
            printf("GetImplementedClsid returned %08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X\n",
                    pClsid->Data1,
                    pClsid->Data2,
                    pClsid->Data3,
                    pClsid->Data4[0],
                    pClsid->Data4[1],
                    pClsid->Data4[2],
                    pClsid->Data4[3],
                    pClsid->Data4[4],
                    pClsid->Data4[5],
                    pClsid->Data4[6],
                    pClsid->Data4[7]);
        }
#endif

        /* IClassClassicInfo::GetProcess */

        hr = pClassicInfo->GetProcess(IID_IComProcessInfo, (void **) &pProcessInfo);
        if (hr == S_OK)
        {
#ifdef DISPLAY
            printf("GetProcess succeeded\n");
#endif

            /* IComProcessInfo::GetProcessId */

            hr = pProcessInfo->GetProcessId(&pClsid);
#ifdef DISPLAY
            if (hr != S_OK)
            {
                printf("GetProcessId returned 0x%X\n", hr);
            }
            else
            {
                printf("GetProcessId returned %08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X\n",
                        pClsid->Data1,
                        pClsid->Data2,
                        pClsid->Data3,
                        pClsid->Data4[0],
                        pClsid->Data4[1],
                        pClsid->Data4[2],
                        pClsid->Data4[3],
                        pClsid->Data4[4],
                        pClsid->Data4[5],
                        pClsid->Data4[6],
                        pClsid->Data4[7]);
            }
#endif

            /* IComProcessInfo::GetProcessName */

            hr = pProcessInfo->GetProcessName(&pwsz);
#ifdef DISPLAY
            if (hr == S_OK)
            {
                printf("GetProcessName returned '%ls'\n", pwsz);
            }
            else
            {
                printf("GetProcessName returned 0x%X\n", hr);
            }
#endif

            /* IComProcessInfo::GetProcessType */

            hr = pProcessInfo->GetProcessType(&eProcessType);
#ifdef DISPLAY
            if (hr == S_OK)
            {
                switch (eProcessType)
                {
                case ProcessTypeNormal:
                    psz = "ProcessTypeNormal";
                    break;

                case ProcessTypeService:
                    psz = "ProcessTypeService";
                    break;

                case ProcessTypeComPlus:
                    psz = "ProcessTypeComPlus";
                    break;

                case ProcessTypeLegacySurrogate:
                    psz = "ProcessTypeLegacySurrogate";
                    break;

                default:
                    psz = "<unknown process type>";
                }

                printf("GetProcessType returned %u (%s)\n", eProcessType, psz);
            }
            else
            {
                printf("GetProcessType returned 0x%X\n", hr);
            }
#endif

            /* IComProcessInfo::GetSurrogatePath */

            hr = pProcessInfo->GetSurrogatePath(&pwsz);
#ifdef DISPLAY
            if (hr == S_OK)
            {
                printf("GetSurrogatePath returned '%ls'\n", pwsz);
            }
            else
            {
                printf("GetSurrogatePath returned 0x%X\n", hr);
            }
#endif

            /* IComProcessInfo::GetServiceName */

            hr = pProcessInfo->GetServiceName(&pwsz);
#ifdef DISPLAY
            if (hr == S_OK)
            {
                printf("GetServiceName returned '%ls'\n", pwsz);
            }
            else
            {
                printf("GetServiceName returned 0x%X\n", hr);
            }
#endif

            /* IComProcessInfo::GetServiceParameters */

            hr = pProcessInfo->GetServiceParameters(&pwsz);
#ifdef DISPLAY
            if (hr == S_OK)
            {
                printf("GetServiceParameters returned '%ls'\n", pwsz);
            }
            else
            {
                printf("GetServiceParameters returned 0x%X\n", hr);
            }
#endif

            /* IComProcessInfo::GetActivateAtStorage */

            hr = pProcessInfo->GetActivateAtStorage(&fBool);
#ifdef DISPLAY
            if (hr == S_OK)
            {
                printf("GetActivateAtStorage returned %s\n", fBool ? "TRUE":"FALSE");
            }
            else
            {
                printf("GetActivateAtStorage returned 0x%X\n", hr);
            }
#endif

            /* IComProcessInfo::GetRunAsType */

            hr = pProcessInfo->GetRunAsType(&eRunAsType);
#ifdef DISPLAY
            if (hr == S_OK)
            {
                switch (eRunAsType)
                {
                case RunAsSpecifiedUser:
                    psz = "RunAsSpecifiedUser";
                    break;

                case RunAsInteractiveUser:
                    psz = "RunAsInteractiveUser";
                    break;

                case RunAsLaunchingUser:
                    psz = "RunAsLaunchingUser";
                    break;

                default:
                    psz = "<unknown RunAsType>";
                }

                printf("GetRunAsType returned %u (%s)\n", eRunAsType, psz);
            }
            else
            {
                printf("GetRunAsType returned 0x%X\n", hr);
            }
#endif

            /* IComProcessInfo::GetRunAsUser */

            hr = pProcessInfo->GetRunAsUser(&pwsz);
#ifdef DISPLAY
            if (hr == S_OK)
            {
                printf("GetRunAsUser returned '%ls'\n", pwsz);
            }
            else
            {
                printf("GetRunAsUser returned 0x%X\n", hr);
            }
#endif

            /* IComProcessInfo::GetLaunchPermission */

            hr = pProcessInfo->GetLaunchPermission((void **) &psd);
#ifdef DISPLAY
            if (hr == S_OK)
            {
                if (psd == NULL)
                {
                    printf("GetLaunchPermission returned S_OK, NULL\n");
                }
                else
                {
                    if (IsValidSecurityDescriptor(psd) == TRUE)
                    {
                        printf("GetLaunchPermission returned S_OK and a valid descriptor\n");
                    }
                    else
                    {
                        printf("GetLaunchPermission returned S_OK but an INVALID descriptor\n");
                    }
                }
            }
            else
            {
                printf("GetLaunchPermission returned 0x%X\n", hr);
            }
#endif

            /* IComProcessInfo::GetAccessPermission */

            hr = pProcessInfo->GetAccessPermission((void **) &psd);
#ifdef DISPLAY
            if (hr == S_OK)
            {
                if (psd == NULL)
                {
                    printf("GetAccessPermission returned S_OK, NULL\n");
                }
                else
                {
                    if (IsValidSecurityDescriptor(psd) == TRUE)
                    {
                        printf("GetAccessPermission returned S_OK and a valid descriptor\n");
                    }
                    else
                    {
                        printf("GetAccessPermission returned S_OK but an INVALID descriptor\n");
                    }
                }
            }
            else
            {
                printf("GetAccessPermission returned 0x%X\n", hr);
            }
#endif

            /* IComProcessInfo::GetAuthenticationLevel */

            hr = pProcessInfo->GetAuthenticationLevel(&dw);
#ifdef DISPLAY
            if (hr == S_OK)
            {
                printf("GetAuthenticationLevel returned S_OK, level = %d\n", dw);
            }
            else
            {
                printf("GetAuthenticationLevel returned 0x%X\n", hr);
            }
#endif

            /* IComProcessInfo::GetImpersonationLevel */

            hr = pProcessInfo->GetImpersonationLevel(&dw);
#ifdef DISPLAY
            if (hr == S_OK)
            {
                printf("GetImpersonationLevel returned S_OK, level = %d\n", dw);
            }
            else
            {
                printf("GetImpersonationLevel returned 0x%X\n", hr);
            }
#endif

            /* IComProcessInfo::GetRemoteServerName */

            hr = pProcessInfo->GetRemoteServerName(&pwsz);
#ifdef DISPLAY
            if (hr == S_OK)
            {
                printf("GetRemoteServerName returned '%ls'\n", pwsz);
            }
            else
            {
                printf("GetRemoteServerName returned 0x%X\n", hr);
            }
#endif

            /* IComProcessInfo::QI for IProcessServerInfo */

            hr = pProcessInfo->QueryInterface(IID_IProcessServerInfo, (void **) &pServerInfo);
            if (hr == S_OK)
            {
#ifdef DISPLAY
                printf("QI for IProcessServerInfo succeeded\n");
#endif

                pServerInfo->Release();
            }
            else
            {
#ifdef DISPLAY
                printf("QI for IProcessServerInfo returned 0x%X\n", hr);
#endif
            }

            pProcessInfo->Release();
        }
        else
        {
#ifdef DISPLAY
            printf("GetProcess returned 0x%X\n", hr);
#endif
        }

        /* IClassClassicInfo::GetRemoteServerName */

        hr = pClassicInfo->GetRemoteServerName(&pwsz);
#ifdef DISPLAY
        if (hr == S_OK)
        {
            printf("GetRemoteServerName returned '%ls'\n", pwsz);
        }
        else
        {
            printf("GetRemoteServerName returned 0x%X\n", hr);
        }
#endif

        pClassicInfo->Release();
    }
    else
    {
#ifdef DISPLAY
        printf("QI for IClassClassicInfo returned 0x%X\n", hr);
#endif
    }

    /* IComClassInfo::QI for IClassActivityInfo does not apply in Classic */

    /* IComClassInfo::QI for IClassTransactionInfo does not apply in Classic */

    /* IComClassInfo::QI for IClassJitActivationInfo does not apply in Classic */

    /* IComClassInfo::QI for IClassSecurityInfo does not apply in Classic */

    /* IComClassInfo::QI for IClassRetInfo does not apply in Classic */

    /* IComClassInfo::QI for IClassLoadBalancingInfo does not apply in Classic */

    /* IComClassInfo::QI for IClassObjectPoolingInfo does not apply in Classic */

    return(S_OK);
}


#ifdef SCM_TEST
HRESULT CreateLookup(IComCatalogSCM *pCatalogSCM, CLSID Clsid)
#else
HRESULT CreateLookup(IComCatalog *pCatalog, CLSID Clsid)
#endif
{
    HRESULT hr;
    IComClassInfo *pClassInfo;

#ifdef DISPLAY
    printf("CLSID: %08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X\n",
            Clsid.Data1,
            Clsid.Data2,
            Clsid.Data3,
            Clsid.Data4[0],
            Clsid.Data4[1],
            Clsid.Data4[2],
            Clsid.Data4[3],
            Clsid.Data4[4],
            Clsid.Data4[5],
            Clsid.Data4[6],
            Clsid.Data4[7]);
#endif

    /* IComCatalog::GetClassInfo */

#ifdef SCM_TEST
    hr = pCatalogSCM->GetClassInfo(NULL, Clsid, IID_IComClassInfo, (LPVOID *) &pClassInfo);
#else
    hr = pCatalog->GetClassInfo(Clsid, IID_IComClassInfo, (LPVOID *) &pClassInfo);
#endif
    if ((hr == S_OK) || (hr == S_FALSE))
    {
#ifndef QUICK
        hr = DoLookup(pClassInfo);
        if (hr != S_OK)
        {
#ifdef DISPLAY
            printf("DoLookup returned 0x%X\n", hr);
#endif
        }
#endif //QUICK

        pClassInfo->Release();
    }
    else if (hr == REGDB_E_CLASSNOTREG)
    {
#ifdef DISPLAY
        printf("GetClassInfo returned REGDB_E_CLASSNOTREG\n");
#endif
    }
    else
    {
#ifdef DISPLAY
        printf("IComCatalog->GetClassInfo returned 0x%X\n", hr);
#endif
    }

    /* IComCatalog::GetApplicationInfo returns E_FAIL in Classic */

    /* IComCatalog::GetProcessInfo is tested via IComClassInfo::GetProcess */

    /* IComCatalog::GetServerGroupInfo returns E_FAIL in Classic */

    /* IComCatalog::GetRetQueueInfo returns E_FAIL in Classic */

    /* IComCatalog::GetApplicationInfoForExe returns E_FAIL in Classic */

    /* IComCatalog::GetTypeLibrary returns E_NOTIMPL in Classic  */

    return(hr);
}


HRESULT DoCatalog(void)
{
    HINSTANCE hCatalog;
    FN_GetCatalogObject *pfnGetCatalogObject;
    HRESULT hr;
#ifdef SCM_TEST
    IComCatalogSCM *pCatalogSCM;
#else
    IComCatalog *pCatalog;
#endif
    int id;
    int pass;
    int rep;
    DWORD dwTickCount;
    DWORD dwLastTickCount;
    CLSID ids[MAX_IDS];
    int cIds;
    int cBogus;
    HKEY hKey;
    DWORD iKey;
    char sz[50];

    cIds = 0;
    iKey = 0;
    cBogus = 0;

    hr = RegOpenKey(HKEY_CLASSES_ROOT, "CLSID", &hKey);
    if (hr == ERROR_SUCCESS)
    {
        do
        {
            hr = RegEnumKey(hKey, iKey++, sz, sizeof(sz));
            if (hr == ERROR_SUCCESS)
            {
                if (CurlyStringToGUID(sz, &ids[cIds]) == TRUE)
                {
                    cIds++;
                }

                if (++cBogus > REAL_PER_BOGUS)
                {
                    cBogus = 0;

                    ids[cIds] = ids[cIds - 1];

                    ids[cIds].Data1 ^= 0x4D494B45;

                    cIds++;
                }
            }
        } while ((hr == ERROR_SUCCESS) && (cIds < MAX_IDS));

        RegCloseKey(hKey);
    }

    fprintf(stderr,"Loaded %d CLSIDs, doing %d passes X %d reps\n", cIds, NUM_PASSES, NUM_REPS);

    if (cIds == 0)
    {
        return(E_FAIL);
    }

    qsort(ids, cIds, sizeof(CLSID), compare_guid);

    dwTickCount = GetTickCount();

    hCatalog = LoadLibrary( COMREG32DLL );
    if (hCatalog == NULL)
    {
        printf("LoadLibrary(\"" COMREG32DLL "\") failed\n");

        return(E_FAIL);
    }

    pfnGetCatalogObject = (FN_GetCatalogObject *)
            GetProcAddress(hCatalog, "GetCatalogObject");
    if (pfnGetCatalogObject == NULL)
    {
        FreeLibrary(hCatalog);

        printf("GetProcAddress(\"GetCatalogObject\") failed\n");

        return(E_FAIL);
    }

#ifdef SCM_TEST
    hr = pfnGetCatalogObject(IID_IComCatalogSCM, (void **) &pCatalogSCM);
#else
    hr = pfnGetCatalogObject(IID_IComCatalog, (void **) &pCatalog);
#endif
    if (hr != NOERROR)
    {
        printf("GetCatalogObject returned 0x%X\n", hr);
    }
    else
    {
        for (pass = 1; pass <= NUM_PASSES; pass++)
        {
            dwLastTickCount = dwTickCount;
            dwTickCount = GetTickCount();

#if (NUM_PASSES > 1)
            fprintf(stderr, "%10ld Pass %d of %d\n", dwTickCount - dwLastTickCount, pass, NUM_PASSES);
#endif

            for (rep = 1; rep <= NUM_REPS; rep++)
            {
                for (id = 0; id < cIds; id++)
                {
#ifdef SCM_TEST
                    hr = CreateLookup(pCatalogSCM, ids[id]);
#else
                    hr = CreateLookup(pCatalog, ids[id]);
#endif

#ifdef DISPLAY7
                    if (hr != S_OK)
                    {
                        printf("CreateLookup returned 0x%X\n", hr);
                    }
#endif
#ifdef DISPLAY
                    printf("\n");
#endif
                }
            }
        }

        /* IComCatalog::FlushCache */

#ifdef SCM_TEST
        hr = pCatalogSCM->FlushCache();
#else
        hr = pCatalog->FlushCache();
#endif

#ifdef DISPLAY
        if (hr == S_OK)
        {
            printf("IComCatalog->FlushCache returned S_OK\n");
        }
        else
        {
            printf("IComCatalog->FlushCache returned 0x%X\n", hr);
        }
#endif

#ifdef SCM_TEST
        pCatalogSCM->Release();
#else
        pCatalog->Release();
#endif

        hr = S_OK;
    }

    FreeLibrary(hCatalog);

    return(hr);
}


int _cdecl main(int argc, char *argv[])
{
    HRESULT hr;
    int rc = 0;
    char sz[200];

    setvbuf(stdout, NULL, _IONBF, 0);

    hr = CoInitialize(NULL);
    if (hr != S_OK)
    {
        printf("CoInitialize returned 0x%X\n", hr);
        rc = 1;
    }
    else
    {
        hr = DoCatalog();
        if (hr != S_OK)
        {
            printf("DoCatalog returned 0x%X\n", hr);
            rc = 1;
        }

        CoUninitialize();
    }

    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\actprops\actprops.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       actprops.cxx
//
//  Contents:   Activation Functions used by object servers.
//
//  Functions:  Implements classes in Actprops.hxx
//
//  History:    24-Jan-98 Vinaykr   Created
//              24-Jul-98 CBiks     Fixed RAID# 199660.
//              14-Sep-98 CBiks     Fixed RAID# 214719.
//              29-Sep-98 vinaykr   Fixed RAID# 169084,
//                                  inproc unmarshaller for perf
//              14-Sep-98 CBiks     Fixed RAID# 151056.
//              22-Oct-98 TarunA    Fixed RAID# 234750
//
//--------------------------------------------------------------------------

#include <ole2int.h>

#include <actprops.hxx>
#include <stdidx.h>

//---------------------------------------------------------------------------
// GUIDs need to be declared here since they have to
// live in both the SCM and OLE32.
//---------------------------------------------------------------------------
// catalog query helper defined in ..\com\objact.cxx
HRESULT GetClassInfoFromClsid(REFCLSID rclsid, IComClassInfo **ppClassInfo);

CLSID CLSID_Grammatik = {0xc9da6c40,0x83b1,0x11ce,
                         {0x81, 0xac, 0x00, 0x60, 0x8c, 0xb9, 0xf8, 0x3b}};
CLSID CLSID_WonderWare = {0x28dd9320, 0x6f69, 0x11ce,
                          {0x8b, 0x69, 0x00, 0x60, 0x8c, 0xc9, 0x7d, 0x5b}};
CLSID CLSID_WPNatLangTools = {0xe6246810, 0x030f, 0x11cf,
                              {0x88, 0x75, 0x00, 0x60, 0x8c, 0xf5, 0xab, 0x6f}};
CLSID CLSID_Grammatik8 = {0xc0e10005, 0x0201, 0x0180,
                          {0xc0, 0xe1, 0xc0, 0xe1, 0xc0, 0xe1, 0xc0, 0xe1}};

InprocActpropsUnmarshaller InprocActpropsUnmarshaller::_InprocActUnmarshaller;

CLSID *arBrokenRefCount[] =
{
    &CLSID_Grammatik,
    &CLSID_WonderWare,
    &CLSID_WPNatLangTools,
    &CLSID_Grammatik8
};

//
// Marshalling functions.  They are here because we cannot link to ole32.dll
// if we are in the SCM.
//
PFN_CORELEASEMARSHALDATA pfnCoReleaseMarshalData = NULL;
PFN_COUNMARSHALINTERFACE pfnCoUnmarshalInterface = NULL;
PFN_COGETMARSHALSIZEMAX  pfnCoGetMarshalSizeMax  = NULL;
PFN_COMARSHALINTERFACE   pfnCoMarshalInterface   = NULL;


// Resolve the function pointers for marshalling.  Call this before you
// use any of the above functions, or you WILL crash, ole32 or not.
void InitMarshalling(void)
{
    static int init = 0;

    // Only attempt to initialize once.
    if (init)
        return;

    // Do not load ole32.dll, but if it is loaded then we are linked into it,
    // and this will work.
    HMODULE hOle32 = GetModuleHandle(L"ole32.dll");
    if (hOle32)
    {
        // Get the functions we need.  
        pfnCoGetMarshalSizeMax = (PFN_COGETMARSHALSIZEMAX)GetProcAddress(hOle32, "CoGetMarshalSizeMax");
        Win4Assert(pfnCoGetMarshalSizeMax && "Could not get CoGetMarshalSizeMax!");

        pfnCoMarshalInterface = (PFN_COMARSHALINTERFACE)GetProcAddress(hOle32, "CoMarshalInterface");
        Win4Assert(pfnCoMarshalInterface && "Could not get CoMarshalInterface!");

        pfnCoUnmarshalInterface = (PFN_COUNMARSHALINTERFACE)GetProcAddress(hOle32, "CoUnmarshalInterface");
        Win4Assert(pfnCoUnmarshalInterface && "Could not get CoUnmarshalInterface!");

        pfnCoReleaseMarshalData = (PFN_CORELEASEMARSHALDATA)GetProcAddress(hOle32, "CoReleaseMarshalData");
        Win4Assert(pfnCoReleaseMarshalData && "Could not get CoReleaseMarshalData!");
    }
    else
    {
        // ole32.dll is not loaded.  The functions stay null.  If anybody
        // tries to call them, you will crash.  You should not be calling
        // such functions from the SCM.
        //
        // REVIEW: We might want to assert here.  Revisit when Jon Schwartz
        //         makes ole32.dll delay load.
    }

    init = 1;
}

//+----------------------------------------------------------------------------
//
//  Function:      IsBrokenRefCount
//
//  Synopsis:      Check to see if this clsid is known to have broken reference
//                 counting.
//
//  History:       21-Apr-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
BOOL IsBrokenRefCount(CLSID *pClsId)
{

    ULONG i;
    ULONG len = sizeof(arBrokenRefCount)/sizeof(CLSID*);
    for (i = 0; i < len; i++)
    {
        if (IsEqualIID(*pClsId, *(arBrokenRefCount[i])))
        {
            return TRUE;
        }
    }
    return FALSE;

}

//---------------------------------------------------------------------------
//  Internal Class Factories for Activation Properties
//---------------------------------------------------------------------------
HRESULT CActivationPropertiesInCF_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void** ppv)
{
    ActivationPropertiesIn * actin =
        new ActivationPropertiesIn();

    if (actin==NULL)
        return E_OUTOFMEMORY;

    HRESULT hr = actin->QueryInterface(riid, ppv);
    actin->Release();
    return hr;
}

HRESULT CActivationPropertiesOutCF_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void** ppv)
{
    ActivationPropertiesOut * actout =
        new ActivationPropertiesOut(FALSE /* fBrokenRefCount */ );

    if (actout==NULL)
        return E_OUTOFMEMORY;

    HRESULT hr = actout->QueryInterface(riid, ppv);
    actout->Release();
    return hr;
}

HRESULT CInprocActpropsUnmarshallerCF_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void** ppv)
{
    InprocActpropsUnmarshaller *pInst;

    pInst = InprocActpropsUnmarshaller::GetInstance();

    Win4Assert(pInst);

    return pInst->QueryInterface(riid, ppv);
}

//---------------------------------------------------------------------------
// ActivationProperties is a helper class for marshalling
// different property objects. It implements ISerializableParent
// and manages a set of serializable interfaces.
// Assumptions are:
//                  a. QI'ing an interface can bring an
//                     instance into existence.
//                  b. It is possible for some interfaces
//                     to never be instantiatable on
//                     an unserialized Actprops object.
//                     This is achieved through GetClass()
//                  c. It is possible for some interfaces
//                     to never be instantiated again
//                     after they are unserialized(at
//                     least once). Achieved by returning
//                     a size of 0 in GetMarshalSizeMax
//                     Used to turn off  propagation at a
//                     particular stage.
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//             Methods for ActivationProperties
//---------------------------------------------------------------------------
ActivationProperties::ActivationProperties()
{
    memset(&_serHeader, 0, sizeof(CustomHeader));
    memset(&_unSerHeader, 0, sizeof(CustomHeader));
    _ifsIndex = 0;
    _unSerialized = FALSE;
    _unSerializedInproc = FALSE;
    _pUnSer = 0;
    _serHeader.destCtx = MSHCTX_CROSSCTX;
    _marshalFlags = MSHLFLAGS_NORMAL;
    _toDelete = TRUE;
    _fDestruct = FALSE;
    _marshalState = NOT_MARSHALLED;
    _fInprocSerializationRequired = FALSE;
}

ActivationProperties::~ActivationProperties()
{
#if 0 // Allocate them as member vars now
    //-------------------------------------------------------------------
    //  Release all references to property objects held
    //-------------------------------------------------------------------
    for (DWORD i=0; i<_ifsIndex; i++)
    {
        if (serializableIfsCollection[i])
            serializableIfsCollection[i]->Release();
    }
#endif

    //-------------------------------------------------------------------
    //  Release reference to unserialized stream
    //-------------------------------------------------------------------
    if (_pUnSer)
        _pUnSer->Release();

    //-------------------------------------------------------------------
    //  Release unserialized data
    //-------------------------------------------------------------------
    if (_unSerialized)
    {
        ActMemFree(_unSerHeader.pclsid);
        ActMemFree(_unSerHeader.pSizes);
    }

    if (_serHeader.cOpaqueData)
    {
        for (DWORD i=0; i<_serHeader.cOpaqueData;i++)
            ActMemFree(_serHeader.opaqueData[i].data);

        ActMemFree(_serHeader.opaqueData);
    }
}


//---------------------------------------------------------------------------
//  Methods for IUnknown
//---------------------------------------------------------------------------

    //-----------------------------------------------------------------------
    //  Assumption is that the Top-level ActivationProperties object
    //  supports interfaces of the objects contained within it.
    //  QI'ing an interface of a property object can bring it into
    //  existence. GetClass is used for this.
    //  When this is unmarshalled, the contained objects are not
    //  unserialized. They are unserialized when QI's for using
    //  UnSerializeCallback().
    //-----------------------------------------------------------------------
STDMETHODIMP ActivationProperties::QueryInterface( REFIID riid, LPVOID* ppv)
{
    HRESULT hr;

    //-------------------------------------------------------------------
    //  Check for Top level interfaces
    //-------------------------------------------------------------------
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = (IActivationProperties*)this;
    else
        if (IsEqualIID(riid, IID_IActivationProperties))
            *ppv = (IActivationProperties*)this;
        else
            if (IsEqualIID(riid, IID_ISerializableParent))
                *ppv = (ISerializableParent*)this;
            else
                if (IsEqualIID(riid, IID_IMarshal))
                    *ppv = (IMarshal*)this;
                else
                    if (IsEqualIID(riid, IID_IMarshal2))
                        *ppv = (IMarshal2*)this;
                    else
                        if (IsEqualIID(riid, IID_IGetCatalogObject))
                            *ppv = (IGetCatalogObject*)this;
                        else
                            if (IsEqualIID(riid, CLSID_ActivationProperties))
                            {
                                // Don't addref for this one
                                *ppv = (ActivationProperties*)this;
                                return S_OK;
                            }
                            else
                                *ppv = NULL;

    if (*ppv != NULL)
    {
        AddRef();
        return S_OK;
    }

    //-------------------------------------------------------------------
    //  Check Contained objects
    //-------------------------------------------------------------------
    for (DWORD i=0; i<_ifsIndex; i++)
        if (serializableIfsCollection[i])
            if (serializableIfsCollection[i]->SerializableQueryInterface(riid, ppv) == S_OK)
                return S_OK;

    //-------------------------------------------------------------------
    //  Check for unserialized objects                                 */
    //-------------------------------------------------------------------
    SerializableProperty *pSer;
    if (_unSerialized)
    {
        if ((hr = UnSerializeCallBack(riid, &pSer)) == S_OK)
        {
            if (pSer->SerializableQueryInterface(riid, ppv) == S_OK)
                return S_OK;
        }
        else
            if (hr != E_FAIL)
            {
                *ppv = NULL;
                return hr;
            }
    }

    //-------------------------------------------------------------------
    // Check if interface supported here                               */
    //-------------------------------------------------------------------
    if (GetClass(riid, &pSer, TRUE) == S_OK)
    {
        AddSerializableIfs(pSer);
        HRESULT hr = pSer->SerializableQueryInterface(riid, ppv);
        Win4Assert(hr==S_OK);
        return S_OK;
    }

    *ppv = NULL;
    return E_NOINTERFACE;
}

ULONG ActivationProperties::AddRef(void)
{
    return InterlockedIncrement(&_refCount);
}

ULONG ActivationProperties::Release(void)
{
    ULONG count;
    if ((count = InterlockedDecrement(&_refCount)) == 0)
    {
        //-------------------------------------------------------------------
        //  Relinquish parent-child relationship and send child off into
        //  the big bad world.
        //-------------------------------------------------------------------
        for (DWORD i=0; i<_ifsIndex; i++)
            if (serializableIfsCollection[i])
            {
                serializableIfsCollection[i]->SetParent(NULL);
            }

        return 0;
    }

    return count;
}

//---------------------------------------------------------------------------
//  Custom marshalling Methods(IMarshal)                                   */
//  Ignore Table marshalling
//---------------------------------------------------------------------------

STDMETHODIMP ActivationProperties::MarshalInterface(
    IStream *pStm,
    REFIID riid,
    void *pv,
    DWORD dwDestContext,
    void *pvDestContext,
    DWORD mshlflags)
{
    HRESULT hr;
    BOOL fReleaseThis;

    //-------------------------------------------------------------------
    //  Check to see that requested interface is supported
    //-------------------------------------------------------------------
    void *ppv;
    if (!SUCCEEDED(hr=QueryInterface(riid, &ppv)))
    {
        return hr;
    }
    else
        fReleaseThis = TRUE;

    RpcTryExcept
        {
            //-------------------------------------------------------------------
            //  Internal marshalling distance flag already set up by
            //  GetMarshalSizeMax
            //-------------------------------------------------------------------

            void *pv;
            if (MARSHALCTX_WITHIN_PROCESS(dwDestContext))
            {
                pv = (void*)((ActivationProperties*) this);


                fReleaseThis = FALSE;
            }
            else
                pv = NULL;

            //-------------------------------------------------------------------
            //  Create Serializer for serialization
            //-------------------------------------------------------------------
            Serializer ser(_serHeader.destCtx, dwDestContext, _marshalFlags);
            hr = ser.InitStream(pStm, _serHeader.totalSize,
                                Serializer::DIRECTION_WRITE, pv);

            if (FAILED(hr))
            {
                if(fReleaseThis)
                    Release();
                return hr;
            }

            if ((!pv) || _fInprocSerializationRequired)
                hr = Serialize(ser);
            else
                hr = S_OK;

            _marshalState = MARSHALLED;
        }

    RpcExcept(TRUE)
        {
            hr = HRESULT_FROM_WIN32(RpcExceptionCode());
        }

    RpcEndExcept

        if (fReleaseThis)
            Release();

    return hr;
}

inline HRESULT ActivationProperties::Serialize(Serializer &ser)
{
    HRESULT hr;

    //-------------------------------------------------------------------
    //  First encode Generic header
    //-------------------------------------------------------------------
    handle_t handle;
    hr = ser.GetSerializationHandle((void*) &handle);
    if (FAILED(hr))
        return hr;
    CustomHeader_Encode(handle, &_serHeader);
    hr = ser.IncrementPosition(_headerSize);
    if (FAILED(hr))
        return hr;
    DWORD unSerializedPosition=_unSerHeader.headerSize;
    DWORD totalinc = 0;

    //-------------------------------------------------------------------
    //  Now serialize all contained objects
    //-------------------------------------------------------------------
    for (DWORD i=0; i<_ifsIndex;i++)
    {
        if (!_sizeArray[i])
            continue;
        if ((_unSerialized) && (!serializableIfsCollection[i]))
        {
            hr = _pUnSer->CopyTo(&ser, unSerializedPosition, _sizeArray[i]);
            if (FAILED(hr))
                return hr;
        }
        else
        {
            hr = serializableIfsCollection[i]->Serialize(&ser);
            if (hr != S_OK)
                return hr;
            hr = ser.IncrementPosition(_sizeArray[i]);
            if (FAILED(hr))
                return hr;
        }
        if (_unSerialized && (i<_unSerHeader.cIfs))
            unSerializedPosition += _unSerHeader.pSizes[i];
    }


    //-------------------------------------------------------------------
    //  Commit to stream
    //-------------------------------------------------------------------
    return ser.Commit();
}


inline HRESULT ActivationProperties::SetupForUnserializing(Serializer *pSer)
{
    //---------------------------------------------------------------
    //  Read Custom header
    //  Make a copy to hold still unserialized objects for future
    //  Set up state for next serialization
    //---------------------------------------------------------------
    handle_t handle;
    pSer->GetSerializationHandle((void*) &handle);
    _unSerHeader.pclsid = 0;
    _unSerHeader.pSizes = 0;
    _unSerHeader.opaqueData = 0;
    CustomHeader_Decode(handle, &_unSerHeader);
    pSer->IncrementPosition(_unSerHeader.headerSize);
    HRESULT hr = pSer->GetCopy(&_pUnSer);
    if (FAILED(hr))
        return hr;
    pSer->Commit();
    _unSerialized = TRUE;
    _ifsIndex = _unSerHeader.cIfs;
    _serHeader.destCtx = _unSerHeader.destCtx;
    _serHeader.cOpaqueData = _unSerHeader.cOpaqueData;
    _serHeader.opaqueData = _unSerHeader.opaqueData;
    return S_OK;
}

STDMETHODIMP InprocActpropsUnmarshaller::UnmarshalInterface(IStream *pStm,
                                                            REFIID riid,
                                                            void **ppv)
{
    ActivationProperties *pAct = NULL;

    RpcTryExcept
        {
            HRESULT hr;
            DWORD dwSize;
            void *pv = NULL;
            //---------------------------------------------------------------
            //  Init Serializer for reading from stream
            //---------------------------------------------------------------
            Serializer ser;
            hr = ser.InitStream(pStm, dwSize,
                                Serializer::DIRECTION_READ, pv);


            if (!SUCCEEDED(hr))
                return hr;

            pAct = (ActivationProperties*) pv;

            Win4Assert(pAct);

            if (!pAct)
                return(E_UNEXPECTED);


            //---------------------------------------------------------------
            // If we received a pointer, check if any further unserialization
            // required. If so set up stream inside object pointed to
            //---------------------------------------------------------------
            Win4Assert(pAct->_marshalState !=
                       ActivationProperties::UNMARSHALLED);

            if (dwSize != 0)
                hr = pAct->SetupForUnserializing(&ser);

            if (SUCCEEDED(hr))
            {
                if (ppv != NULL)
                    hr = pAct->QueryInterface(riid, ppv);
                else
                    hr = E_UNEXPECTED;
            }


            pAct->_marshalState = ActivationProperties::UNMARSHALLED;

            pAct->Release();


            return hr;
        }

    RpcExcept(TRUE)
        {
            //---------------------------------------------------------------
            // If we get here and have a pAct then we must release it
            //---------------------------------------------------------------
            if (pAct)
            {
                pAct->Release();
            }

            return HRESULT_FROM_WIN32(RpcExceptionCode());
        }

    RpcEndExcept

        // Should never get here !
        Win4Assert(0 && "Should never reach here");
    return E_UNEXPECTED;

}

STDMETHODIMP ActivationProperties::UnmarshalInterface(IStream *pStm,
                                                      REFIID riid,
                                                      void **ppv)
{
    RpcTryExcept
        {

            Win4Assert(_marshalState != UNMARSHALLED);

            HRESULT hr;
            DWORD dwSize;

            void *pv = NULL;

            //---------------------------------------------------------------
            //  Init Serializer for reading from stream
            //---------------------------------------------------------------
            Serializer ser;
            hr = ser.InitStream(pStm, dwSize,
                                Serializer::DIRECTION_READ, pv);


            if (!SUCCEEDED(hr))
                return hr;

            hr = SetupForUnserializing(&ser);

            if (FAILED(hr))
                return hr;

            for (DWORD i=0; i<_ifsIndex;i++)
                serializableIfsCollection[i] = 0;

            _marshalState = UNMARSHALLED;
        }

    RpcExcept(TRUE)
        {
            return HRESULT_FROM_WIN32(RpcExceptionCode());
        }

    RpcEndExcept


        //-------------------------------------------------------------------
        //  Query for requested interface to return
        //-------------------------------------------------------------------
        if (ppv != NULL)
            return QueryInterface(riid, ppv);
        else
            return S_OK;
}

STDMETHODIMP ActivationProperties::GetMarshalSizeMax(
    REFIID riid,
    void *pv,
    DWORD dwDestContext,
    void *pvDestContext,
    DWORD mshlflags,
    DWORD *pSize)
{
    HRESULT hr;

    //-------------------------------------------------------------------
    //  If already know size, return it
    //-------------------------------------------------------------------
    if (_marshalState == SIZED)
    {
        *pSize = _size;
        return S_OK;
    }
    else
    {
        //---------------------------------------------------------------
        //  First set internal marshalling distance flag
        //---------------------------------------------------------------
        SetDestCtx(dwDestContext);

        if (MARSHALCTX_WITHIN_PROCESS(dwDestContext) &&
            (!_fInprocSerializationRequired))
        {
            _size = 0;
            hr = S_OK;
        }
        else
        {
            RpcTryExcept
                {
                    //---------------------------------------------------------------
                    //  Create Serializer for serialization
                    //---------------------------------------------------------------
                    Serializer ser(_serHeader.destCtx, dwDestContext, _marshalFlags);

                    hr = GetSize(ser, pSize);
                    _size = *pSize;
                    if (!_size)
                        _fInprocSerializationRequired = FALSE;
                }

            RpcExcept(TRUE)
                {
                    hr = HRESULT_FROM_WIN32(RpcExceptionCode());
                }

            RpcEndExcept
                }
    }

    if (SUCCEEDED(hr))
    {
        // Add fixed serializer header size to serialization size
        _size += Serializer::GetSize();
        *pSize = _size;
        _marshalState = SIZED;
    }

    return hr;
}

inline HRESULT ActivationProperties::GetSize(Serializer &ser, DWORD *pSize)
{

    HRESULT hr;
    DWORD size = 0;

    //-------------------------------------------------------------------
    //  Get sizes of contained objects
    //-------------------------------------------------------------------
    for (DWORD i=0; i<_ifsIndex;i++)
    {
        //---------------------------------------------------------------
        //  If object was never unserialized then simply use old size
        //---------------------------------------------------------------
        if ((_unSerialized) && (!serializableIfsCollection[i]))
        {
            _clsidArray[i] = _unSerHeader.pclsid[i];
            _sizeArray[i] = _unSerHeader.pSizes[i];
        }
        else
        {
            hr = serializableIfsCollection[i]->GetCLSID(&_clsidArray[i]);
            Win4Assert(hr==S_OK);
            hr = serializableIfsCollection[i]->GetSize(&ser, &_sizeArray[i]);
            if (FAILED(hr))
                return hr;

            _sizeArray[i] = (_sizeArray[i]+7) & ~7;
        }
        size += _sizeArray[i];
    }

    //-------------------------------------------------------------------
    //  Set up header for serialization and get its size if we need
    //  to marshal any information(i.e size>0)
    //-------------------------------------------------------------------
    if (size)
    {
        _serHeader.cIfs = _ifsIndex;
        _serHeader.pSizes = _sizeArray;
        _serHeader.pclsid = _clsidArray;

        handle_t   handle;
        hr = ser.GetSizingHandle((void*) &handle);

        if (FAILED(hr))
            return hr;

        _headerSize = CustomHeader_AlignSize(handle, &_serHeader);
        MesHandleFree(handle);
        _serHeader.headerSize = _headerSize;
        size += _headerSize;
    }

    // return serialization size
    _serHeader.totalSize = size;
    *pSize = size;

    return S_OK;
}

STDMETHODIMP ActivationProperties::GetUnmarshalClass(
    REFIID riid,
    void *pv,
    DWORD dwDestContext,
    void *pvDestContext,
    DWORD mshlflags,
    CLSID *pCid)
{
    if (MARSHALCTX_WITHIN_PROCESS(dwDestContext))
        *pCid = CLSID_InprocActpropsUnmarshaller;
    else
        *pCid = _actCLSID;

    return S_OK;
}

STDMETHODIMP ActivationProperties::ReleaseMarshalData(IStream *pStm)
{
    return E_NOTIMPL;
}

STDMETHODIMP ActivationProperties::DisconnectObject(DWORD dwReserved)
{
    return E_NOTIMPL;
}


//---------------------------------------------------------------------------
//      Methods from ISerializableParent
//---------------------------------------------------------------------------


    //-----------------------------------------------------------------------
    //  Returns serializer pointing to unserialized data for referenced
    //  CLSID
    //-----------------------------------------------------------------------
STDMETHODIMP ActivationProperties::GetUnserialized(REFCLSID clsid,
                                                   void **ppISer,
                                                   DWORD *pSize, DWORD *pPos)
{
    if (!_unSerialized)
        return E_FAIL;

    DWORD pos = _unSerHeader.headerSize;
    HRESULT hr;
    for (DWORD i=0; i<_ifsIndex; i++)
    {
        if (IsEqualIID(clsid,_unSerHeader.pclsid[i]))
        {
            hr = _pUnSer->SetPosition(pos);
	    if (FAILED (hr)) 
	    {
	       return hr;
	    }
            *pSize = _unSerHeader.pSizes[i];
            *ppISer = _pUnSer;
            *pPos = pos;
            return S_OK;
        }
        pos +=_unSerHeader.pSizes[i];
    }

    return E_FAIL;
}

//-----------------------------------------------------------------------
//  Used to do late unserialization via a QueryInterface
//  returns -
//            E_NOINTERFACE: implies that this interface can
//                           never be supported here(even if GetClass
//                           returns a valid instance).
//                           Implication is that once a class is
//                           signalled in the activation stream to
//                           not be marshalled by setting its size
//                           to zero, it can never be QI'd again.
//            E_FAIL:        implies that this interface was not
//                           part of the serialized packet(but could
//                           be supported if GetClass succeeds).
//-----------------------------------------------------------------------
inline HRESULT ActivationProperties::UnSerializeCallBack(REFCLSID clsid,
                                                         SerializableProperty **ppSer)
{
    HRESULT hr;
    SerializableProperty *pClass = NULL;
    BOOL pClassUsed = FALSE;
    Win4Assert(_unSerialized!=0);

    //-------------------------------------------------------------------
    //  Position past header
    //-------------------------------------------------------------------
    DWORD pos = _unSerHeader.headerSize;
    CLSID realclsid;
    //-------------------------------------------------------------------
    //  Check to see if class supported at all
    //-------------------------------------------------------------------
    BOOL bZeroSizeOk;
    if ((hr = GetClass(clsid, &pClass, FALSE, &bZeroSizeOk))==S_OK)
        pClass->GetCLSID(&realclsid);
    else
        return hr;

    hr = E_FAIL;
    for (DWORD i=0; i<_unSerHeader.cIfs; i++)
    {
        //---------------------------------------------------------------
        //  Check if contained objects match requested class ID
        //  If so then it may or may not be unserialized.
        //---------------------------------------------------------------
        if (IsEqualIID(realclsid,_unSerHeader.pclsid[i]))
        {

            RpcTryExcept
                {
                    //-------------------------------------------------------
                    //  If size is zero for a matched object then it is an
                    //  interface that is no longer supported unless we
                    //  are told otherwise
                    //-------------------------------------------------------
                    if ((!_unSerHeader.pSizes[i]) && (!bZeroSizeOk))
                    {
                        hr = E_NOINTERFACE;
                        break;
                    }

                    //-------------------------------------------------------
                    //  Set position for serializer for unserializing
                    //-------------------------------------------------------
                    hr = S_OK;
                    hr = _pUnSer->SetPosition(pos);
		    if (FAILED(hr)) 
		    {
		       break;
		    }
                    //-------------------------------------------------------
                    //  If unserializing add it to our collection and make it
                    //  a child and return found object.
                    //-------------------------------------------------------
                    if (serializableIfsCollection[i] == NULL)
                    {
                        SetSerializableIfs(i, pClass);
                        pClassUsed = TRUE;
                        if (FAILED(hr = pClass->UnSerialize(_pUnSer)))
                        {
                            serializableIfsCollection[i] = NULL;
                            pClass->SetParent(NULL);
                            pClassUsed = FALSE;
                        }
                    }
                    else
                    {
                        hr = serializableIfsCollection[i]->UnSerialize(_pUnSer);
                    }

                    if (ppSer)
                        *ppSer = serializableIfsCollection[i];
                }

            RpcExcept(TRUE)
                {
                    hr = HRESULT_FROM_WIN32(RpcExceptionCode());
                }

            RpcEndExcept

                //
                // E_FAIL is not considered catastrophic by caller
                // But this is a catastrophic condition since we could
                // not unserialize.
                //
                if (hr == E_FAIL)
                    hr = E_UNEXPECTED;

            break;
        }

        //---------------------------------------------------------------
        //  Increment position for next one
        //---------------------------------------------------------------
        pos +=_unSerHeader.pSizes[i];
    }

    if (pClass != NULL && !pClassUsed)
    {
        ReturnClass (clsid, pClass);
    }

    return hr;
}


//-----------------------------------------------------------------------
//  Do things required to make a child
//-----------------------------------------------------------------------
inline void ActivationProperties::SetSerializableIfs(DWORD index,
                                                     SerializableProperty *pSer)
{
    serializableIfsCollection[index]= pSer;
    pSer->SetParent((ISerializableParent*) this);
    pSer->Added();
}

//-----------------------------------------------------------------------
//  Add a serializiable object to the collection
//-----------------------------------------------------------------------
inline void ActivationProperties::AddSerializableIfs(SerializableProperty *pSer)
{
    if (pSer->IsAdded())
        return;

    Win4Assert(_ifsIndex < MAX_ACTARRAY_SIZE);


    SetSerializableIfs(_ifsIndex, pSer);
    _ifsIndex++;
}

//---------------------------------------------------------------------------
//            Methods for ActivationPropertiesIn
//---------------------------------------------------------------------------
ActivationPropertiesIn::ActivationPropertiesIn()
{
    _customIndex = 0;
    _cCustomAct = 0;
    _actCLSID=CLSID_ActivationPropertiesIn;
    _refCount = 1;
    _pinst = NULL;
    _pPersist = NULL;
    _pContextInfo = NULL;
    _pServerLocationInfo = NULL;
    _pSecurityInfo = NULL;
    _pSpecialProperties = NULL;
    _pClassInfo = NULL;
    _customActList = NULL;
    _delegated = FALSE;
    _actOut.SetNotDelete();
    _pDip = NULL;
    _clientToken = NULL;
    _fComplusOnly = FALSE;
    _fUseSystemIdentity = FALSE;
    _dwInitialContext = 0;
}

ActivationPropertiesIn::~ActivationPropertiesIn()
{
    if (_pClassInfo)
    {
        _pClassInfo->Unlock();
        _pClassInfo->Release();
    }
}

//-----------------------------------------------------------------------
//  Methods from IUnknown
//-----------------------------------------------------------------------
STDMETHODIMP ActivationPropertiesIn::QueryInterface( REFIID riid, LPVOID* ppv)
{
    // USE CLSID_ActivationPropertiesIn to get at the real object
    // Note that this is a hidden contract to be used by COM only and
    // the object is not AddRef'd as an optimization
    if (IsEqualIID(riid, CLSID_ActivationPropertiesIn))
    {
        *ppv = (ActivationPropertiesIn*)this;
        return S_OK;
    }
    else
        if (IsEqualIID(riid, IID_IUnknown) ||
            IsEqualIID(riid, IID_IActivationPropertiesIn))
            *ppv = (IActivationPropertiesIn*)this;
        else
            if (IsEqualIID(riid, IID_IPrivActivationPropertiesIn))
                *ppv = (IPrivActivationPropertiesIn*)this;
            else
                if (IsEqualIID(riid, IID_IInitActivationPropertiesIn))
                    *ppv = (IInitActivationPropertiesIn*)this;
                else
                    if (IsEqualIID(riid, IID_IActivationStageInfo))
                        *ppv = (IActivationStageInfo*)this;
                    else
                        *ppv = NULL;

    if (*ppv != NULL)
    {
        AddRef();
        return S_OK;
    }

    return ActivationProperties::QueryInterface(riid, ppv);
}

ULONG ActivationPropertiesIn::AddRef(void)
{
    return ActivationProperties::AddRef();
}

ULONG ActivationPropertiesIn::Release(void)
{
    ULONG ret=ActivationProperties::Release();

    if (ret==0)
    {
        if (_toDelete)
            delete this;
        else
            if (_fDestruct)
                this->ActivationPropertiesIn::~ActivationPropertiesIn();
    }

    return ret;
}


//---------------------------------------------------------------------------
//      Methods from IInitActivationPropertiesIn
//---------------------------------------------------------------------------

STDMETHODIMP ActivationPropertiesIn::SetClsctx (DWORD dwClsCtx)
{
    if (dwClsCtx && _pClassInfo)
    {
        DWORD dwAcceptableClsCtx;

        //Note:  hack for VB since it cannot specify CLSCTX_REMOTE_SERVER
        if (dwClsCtx & CLSCTX_LOCAL_SERVER)
            dwClsCtx |= CLSCTX_REMOTE_SERVER;

        //  Before we filter the specified class context by the class
        //  info, we remember the original class context.
        
        if (_dwInitialContext == 0)
            _dwInitialContext = dwClsCtx;

        //  Here we figure out the desired ClsCtx
        //  by anding the one in the catalog with the
        //  one requested by the user.
        //  If the GetClassContext()
        //  returns an error, we just go ahead and
        //  use the one the user passed.

        HRESULT hr = _pClassInfo->GetClassContext( (CLSCTX) dwClsCtx,
                                                   (CLSCTX*) &dwAcceptableClsCtx);

        // REVIEW: Continue if Get fails? 
        if (SUCCEEDED(hr))
        {
            dwClsCtx &= (dwAcceptableClsCtx |
                         (CLSCTX_PS_DLL | CLSCTX_LOCAL_SERVER));

#ifdef WX86OLE
            //  The code above filters the acceptable context bits found
            //  with those supplied by the caller.  The x86 context bits
            //  might have been found and should be allowed.  For example
            //  INPROC_SERVER might have been set and an x86 server found,
            //  which is valid.

            if ( dwAcceptableClsCtx & CLSCTX_INPROC_SERVERX86 )
            {
                dwClsCtx |= CLSCTX_INPROC_SERVERX86;
            }

            if ( dwAcceptableClsCtx & CLSCTX_INPROC_HANDLERX86 )
            {
                dwClsCtx |= CLSCTX_INPROC_HANDLERX86;
            }
#endif
        }
    }

    return GetInstantiationInfo()->SetClsctx(dwClsCtx);
}

STDMETHODIMP ActivationPropertiesIn::SetActivationFlags (IN DWORD actvflags)
{
    return GetInstantiationInfo()->SetActivationFlags(actvflags);

    // The following code was the original implementation by CBiks.
    // This code is no longer executes because we delegate above.
    //
    /*
      HRESULT hr;
      hr = GetPropertyInfo(IID_IInstantiationInfo, (void**) &_pinst);
      if (SUCCEEDED(hr))
      {
      Win4Assert(_pinst != NULL);
      hr = _pinst->SetActivationFlags(actvflags);
      }
      return hr;
    */
}

STDMETHODIMP ActivationPropertiesIn::SetClassInfo (IUnknown* pUnkClassInfo)
{

    if (_pClassInfo)
    {
        _pClassInfo->Unlock();
        _pClassInfo->Release();
        _pClassInfo = NULL;
    }
        
	// useful and tests minimal usefulness of the object given
    HRESULT hr = pUnkClassInfo->QueryInterface(IID_IComClassInfo,(LPVOID*)&_pClassInfo);

    CLSID *pclsid;

    if (FAILED(hr))
        return hr;

    _pClassInfo->Lock();

    hr = _pClassInfo->GetConfiguredClsid(&pclsid);

    GetInstantiationInfo()->SetClsid(*pclsid);

    if (SUCCEEDED(hr) && _dwInitialContext)
    {
        // Somebody has specifically set the class 
        // context on this actprops, but has now changed 
        // the IComClassInfo.  We need to change our
        // filtered CLSCTX to match the new ClassInfo.
        hr = SetClsctx(_dwInitialContext);
    }

    return hr;
}

STDMETHODIMP ActivationPropertiesIn::SetContextInfo (
    IContext* pClientContext,
    IContext* pPrototypeContext)
{
    HRESULT hr;

    ContextInfo *pactctx= GetContextInfo();
    Win4Assert(pactctx != NULL);

    hr = pactctx->SetClientContext(pClientContext);
    if (hr != S_OK)
        return hr;

    hr = pactctx->SetPrototypeContext(pPrototypeContext);
    return hr;
}

STDMETHODIMP ActivationPropertiesIn::SetConstructFromStorage (IStorage* pStorage)
{
    HRESULT hr;
    GetPersistInfo();
    Win4Assert(_pPersist != NULL);
    // This is an optimization for inproc marshalling. We know
    // that the storage pointer is the only one that requires
    // inproc serialization in the ActivationPropertiesIn object.
    _fInprocSerializationRequired = TRUE;
    return _pPersist->SetStorage(pStorage);
}

STDMETHODIMP ActivationPropertiesIn::SetConstructFromFile (WCHAR* wszFileName, DWORD dwMode)
{
    HRESULT hr;
    GetPersistInfo();
    Win4Assert(_pPersist != NULL);
    return _pPersist->SetFile(wszFileName, dwMode);
}

//---------------------------------------------------------------------------
//  Methods for IActivationPropertiesIn
//---------------------------------------------------------------------------

STDMETHODIMP ActivationPropertiesIn::GetClsctx(OUT DWORD *pdwClsctx)
{
    return GetInstantiationInfo()->GetClsctx(pdwClsctx);
}


STDMETHODIMP ActivationPropertiesIn::AddRequestedIIDs(IN DWORD cIfs,
                                                      IN IID *pIID)
{
    return GetInstantiationInfo()->AddRequestedIIDs(cIfs, pIID);
}


STDMETHODIMP ActivationPropertiesIn::GetRequestedIIDs(OUT DWORD  *pcIfs,
                                                      OUT IID  **ppIID)
{
    return GetInstantiationInfo()->GetRequestedIIDs(pcIfs, ppIID);
}


STDMETHODIMP ActivationPropertiesIn::GetActivationID(OUT GUID  *pActivationID)
{
    *pActivationID = GUID_NULL;  // currently unused and not supported
    return E_NOTIMPL;
}

STDMETHODIMP ActivationPropertiesIn::GetActivationFlags(OUT DWORD *pactvflags)
{
    return GetInstantiationInfo()->GetActivationFlags(pactvflags);

    // The following code was the original implementation by CBiks.
    // This code is no longer executes because we delegate above.
    //
    /*
      HRESULT hr;
      hr = GetPropertyInfo(IID_IInstantiationInfo, (void**) &_pinst);
      if (SUCCEEDED(hr))
      {
      Win4Assert(_pinst != NULL);
      return _pinst->GetActivationFlags(pactvflags);
      }
      return hr;
    */
}

//-----------------------------------------------------------------------
//  The Following 3 routines should be called at the tail end of the
//  activation path to get activation properties for return
//  Only the first one is meant to be pubicly used
//-----------------------------------------------------------------------
STDMETHODIMP ActivationPropertiesIn::GetReturnActivationProperties(
    IN  IUnknown *pobj,
    OUT IActivationPropertiesOut **ppActOut)
{
    HRESULT hr;

    *ppActOut = NULL;

    //-------------------------------------------------------------------
    //  If no punk then don't return an out object
    //-------------------------------------------------------------------
    if (!pobj)
    {
        return E_FAIL;
    }

    if (_unSerialized)
        hr = GetPropertyInfo(IID_IInstantiationInfo, (void**) &_pinst);

    Win4Assert(_pinst != NULL);

    CLSID clsid;
    hr = _pinst->GetClsid(&clsid);
    Win4Assert(hr == S_OK);
    //-------------------------------------------------------------------
    //  Create Return Object
    //-------------------------------------------------------------------
    ActivationPropertiesOut *pout;
    if (!_unSerialized && !_toDelete && !IsBrokenRefCount(&clsid))
    {
        _actOut.Initialize();
        pout = &_actOut;
    }
    else
    {
        pout = new ActivationPropertiesOut(IsBrokenRefCount(&clsid));
        if (pout==NULL)
            return E_OUTOFMEMORY;
    }


    //-------------------------------------------------------------------
    //  Set the marshal and dest context flags for marshalling returns
    //-------------------------------------------------------------------
    pout->SetMarshalFlags(_marshalFlags);
    pout->SetDestCtx(_serHeader.destCtx);

    //-------------------------------------------------------------------
    //  Check to see if we are handling a persistent instance
    //  NOTE: cannot call GetPeristInfo because we need to QI to
    //        so that this will only cause this interface to exist
    //        if it was ever added to the properties object
    //-------------------------------------------------------------------
    if (_unSerialized)
        hr = GetPropertyInfo(IID_IInstanceInfo, (void**) &_pPersist);

    if (_pPersist)
    {
        hr = LoadPersistentObject(pobj, _pPersist);
        if (FAILED(hr))
        {
            pout->Release();
            return hr;
        }
    }

    //-------------------------------------------------------------------
    //  Set COMVERSION of client for marshalling
    //-------------------------------------------------------------------
    Win4Assert(_pinst != NULL);

    COMVERSION *pVersion;
    GetInstantiationInfo()->GetClientCOMVersion(&pVersion);
    pout->SetClientCOMVersion(*pVersion);

    //-------------------------------------------------------------------
    //      Get IIDs requested and set them for return
    //-------------------------------------------------------------------
    DWORD cifs;
    IID *pIID;
    hr = _pinst->GetRequestedIIDs(&cifs, &pIID);
    Win4Assert(hr==S_OK);

    hr = pout->SetObjectInterfaces(cifs, pIID, pobj);

    *ppActOut = pout;

    CleanupLocalState();
    return hr;
}

STDMETHODIMP ActivationPropertiesIn::PrivGetReturnActivationProperties(
    OUT IPrivActivationPropertiesOut **ppActOut)
{
    //-------------------------------------------------------------------
    //  Create Return Object
    //-------------------------------------------------------------------
    ActivationPropertiesOut *pout = new ActivationPropertiesOut(FALSE /* fBrokenRefCount */  );
    if (pout==NULL)
        return E_OUTOFMEMORY;

        //-------------------------------------------------------------------
        //  Set the marshal and dest context flags for marshalling returns
        //-------------------------------------------------------------------
    pout->SetMarshalFlags(_marshalFlags);
    pout->SetDestCtx(_serHeader.destCtx);

    *ppActOut = (IPrivActivationPropertiesOut*) pout;
    CleanupLocalState();
    return S_OK;
}

STDMETHODIMP ActivationPropertiesIn::GetReturnActivationProperties(
    ActivationPropertiesOut **ppActOut)
{
    //-------------------------------------------------------------------
    //  Create Return Object
    //-------------------------------------------------------------------
    *ppActOut = new ActivationPropertiesOut(FALSE /* fBrokenRefCount */ );
    if (*ppActOut==NULL)
        return E_OUTOFMEMORY;


        //-------------------------------------------------------------------
        //  Set the marshal and dest context flags for marshalling returns
        //-------------------------------------------------------------------
    (*ppActOut)->SetMarshalFlags(_marshalFlags);
    (*ppActOut)->SetDestCtx(_serHeader.destCtx);

    CleanupLocalState();
    return S_OK;
}


//-----------------------------------------------------------------------
//  Following two routines are used delegate through a chain of custom
//  activators. When the chain is exhausted, the COM activator for the
//  current stage is invoked.
//-----------------------------------------------------------------------
STDMETHODIMP ActivationPropertiesIn::DelegateGetClassObject(
    OUT IActivationPropertiesOut  **pActPropsOut)
{
    Win4Assert(_customIndex <= _cCustomAct && (LONG) _customIndex >= 0);
    _delegated=TRUE;

    if ((_cCustomAct == 0) || (_customIndex == _cCustomAct))
    {
        ISystemActivator *pComAct = GetComActivatorForStage(_stage);
        return pComAct->GetClassObject(this, pActPropsOut);
    }

    _customIndex++;
    // Sajia - Support for partitions.
    // a) See if the activator supports IReplaceClassInfo
    // b) If yes, this is the partition activator.Delegate to it.
    //    If the partition activator switches the classinfo, 
    //    it returns ERROR_RETRY. It will not delegate in this case. 
    //    Otherwise, it simply delegates  down the chain.
    // c) If it returns ERROR_RETRY, call IReplaceClassInfo->GetClassInfo().
    //    Switch our class info and return ERROR_RETRY so our caller 
    //    knows to restart the activation chain.      
    //     
       
    IReplaceClassInfo *pReplaceClassInfo = NULL;
    HRESULT hr = _customActList[_customIndex-1]->QueryInterface(IID_IReplaceClassInfo, (void**)&pReplaceClassInfo);
    if (SUCCEEDED(hr)) 
    {
        Win4Assert(pReplaceClassInfo && "QI Error");
        // Assert that the partition activator is supported only
        // in the SCM and Server Process stage and must be the 
        // first activator in the stage.
        Win4Assert((_customIndex == 1) && (_stage == SERVER_MACHINE_STAGE || _stage == SERVER_PROCESS_STAGE || _stage == CLIENT_CONTEXT_STAGE));
        hr = _customActList[_customIndex-1]->GetClassObject(this, pActPropsOut);
        if (ERROR_RETRY == hr) 
        {
            CLSID clsid;
            IUnknown     *pClassInfo;
            hr = GetClsid(&clsid);
            Win4Assert(SUCCEEDED(hr));
            if (SUCCEEDED(hr)) 
            {
                hr = pReplaceClassInfo->GetClassInfo(clsid, IID_IUnknown, (void**)&pClassInfo);
                Win4Assert(SUCCEEDED(hr));
                if (SUCCEEDED(hr)) 
                {
                    hr = SetClassInfo(pClassInfo);
                    Win4Assert(SUCCEEDED(hr));
                    pClassInfo->Release();
                    if (SUCCEEDED(hr)) 
                    {
                        hr = ERROR_RETRY;
                    }
                }
            }
        }
        pReplaceClassInfo->Release();
        return hr;
    }
    else
        return _customActList[_customIndex-1]->GetClassObject(this, pActPropsOut);
}

STDMETHODIMP ActivationPropertiesIn::DelegateCreateInstance(
    IN IUnknown  *pUnkOuter,
    OUT IActivationPropertiesOut  **ppActPropsOut)
{
    Win4Assert(_customIndex <= _cCustomAct && (LONG) _customIndex >= 0);
    _delegated=TRUE;

    if ((_cCustomAct == 0) || (_customIndex == _cCustomAct))
    {
        ISystemActivator *pComAct = GetComActivatorForStage(_stage);
        return pComAct->CreateInstance(pUnkOuter, this, ppActPropsOut);
    }

    _customIndex++;
    // Sajia - Support for partitions.
    // a) See if the activator supports IReplaceClassInfo
    // b) If yes, this is the partition activator.Delegate to it.
    //    If the partition activator switches the classinfo, 
    //    it returns ERROR_RETRY. It will not delegate in this case. 
    //    Otherwise, it simply delegates  down the chain.
    // c) If it returns ERROR_RETRY, call IReplaceClassInfo->GetClassInfo().
    //    Switch our class info and return ERROR_RETRY so our caller 
    //    knows to restart the activation chain.      
    //     
       
    IReplaceClassInfo *pReplaceClassInfo = NULL;
    HRESULT hr = _customActList[_customIndex-1]->QueryInterface(IID_IReplaceClassInfo, (void**)&pReplaceClassInfo);
    if (SUCCEEDED(hr)) 
    {
        Win4Assert(pReplaceClassInfo && "QI Error");
        // Assert that the partition activator is supported only
        // in the SCM and Server Process stage and must be the 
        // first activator in the stage.
        Win4Assert((_customIndex == 1) && (_stage == SERVER_MACHINE_STAGE || _stage == SERVER_PROCESS_STAGE || _stage == CLIENT_CONTEXT_STAGE));
        hr = _customActList[_customIndex-1]->CreateInstance(pUnkOuter, this, ppActPropsOut);
        if (ERROR_RETRY == hr) 
        {
            CLSID clsid;
            IUnknown     *pClassInfo;
            hr = GetClsid(&clsid);
            Win4Assert(SUCCEEDED(hr));
            if (SUCCEEDED(hr)) 
            {
                hr = pReplaceClassInfo->GetClassInfo(clsid, IID_IUnknown, (void**)&pClassInfo);
                Win4Assert(SUCCEEDED(hr));
                if (SUCCEEDED(hr)) 
                {
                    hr = SetClassInfo(pClassInfo);
                    Win4Assert(SUCCEEDED(hr));
                    pClassInfo->Release();
                    if (SUCCEEDED(hr)) 
                    {
                        hr = ERROR_RETRY;
                    }
                }
            }
        }
        pReplaceClassInfo->Release();
        return hr;
    }
    else
        return _customActList[_customIndex-1]->CreateInstance(pUnkOuter, this, ppActPropsOut);
}

//-----------------------------------------------------------------------
// Note that this function could return a NULL Class Factory if an
// intercepting custom activator returns an object.
//-----------------------------------------------------------------------
STDMETHODIMP ActivationPropertiesIn::DelegateCIAndGetCF(
    IN IUnknown  *pUnkOuter,
    OUT IActivationPropertiesOut  **ppActPropsOut,
    OUT IClassFactory **ppCF)
{
    if (_stage != SERVER_CONTEXT_STAGE)
        return E_UNEXPECTED;

    HRESULT hr = DelegateCreateInstance(pUnkOuter, ppActPropsOut);

    if (FAILED(hr))
        return hr;

    ActivationPropertiesOut *pActOut;
    hr = (*ppActPropsOut)->QueryInterface(CLSID_ActivationPropertiesOut,
                                          (void**) &pActOut);
    Win4Assert(SUCCEEDED(hr));

    *ppCF = pActOut->GetCF();

    return S_OK;
}


//-----------------------------------------------------------------------
//  Instantiate classes supported by this interfaces given an IID
//-----------------------------------------------------------------------
HRESULT ActivationPropertiesIn::GetClass(REFIID iid,
                                         SerializableProperty **ppSer,
                                         BOOL forQI,
                                         BOOL *pbZeroSizeOk)
{
    if (pbZeroSizeOk)
        *pbZeroSizeOk = FALSE;

    if ((iid == IID_IActivationSecurityInfo) || (iid == IID_ILegacyInfo))
        *ppSer = &_securityInfo;
    else
        if (iid == IID_IServerLocationInfo)
            *ppSer = &_serverLocationInfo;
        else
            if (iid == IID_IInstantiationInfo)
                *ppSer = &_instantiationInfo;
            else
                if (iid == IID_IActivationContextInfo || iid == IID_IPrivActivationContextInfo)
                    *ppSer = &_contextInfo;
                else
                    if ((!(_delegated && forQI)) && (iid == IID_IInstanceInfo))
                        *ppSer = &_instanceInfo;
                    else
                        if (iid == IID_IScmRequestInfo)
                            *ppSer = &_scmRequestInfo;
                        else
                            if (iid == IID_ISpecialSystemProperties)
                            {
                                *ppSer = &_specialProperties;
                            }
                            else
                                if (iid == IID_IOpaqueDataInfo)
                                {
                                    *ppSer = new OpaqueDataInfo();
                                    if (pbZeroSizeOk)
                                        *pbZeroSizeOk = TRUE;
                                }
                                else
                                    return E_NOINTERFACE;

    return S_OK;
}

HRESULT ActivationProperties::ReturnClass(REFIID iid, SerializableProperty *pSer)
{
    if (iid == IID_IOpaqueDataInfo)
    {
        delete (OpaqueDataInfo*) pSer;
        return S_OK;
    }

    return S_FALSE;
}

//---------------------------------------------------------------------------
//  Methods from IActivationStageInfo
//---------------------------------------------------------------------------
STDMETHODIMP ActivationPropertiesIn::SetStageAndIndex(ACTIVATION_STAGE stage,
                                                      int index)
{
    _stage = stage;
    _customIndex = index;
    _cCustomAct = 0;
    _customActList = NULL;

    HRESULT hr = E_UNEXPECTED;

    // JSimmons -- 6/30/99 added this assert:
    Win4Assert(_pClassInfo && "SetStageAndIndex called and _pClassInfo is not set");

    if (_pClassInfo)
    {
        hr = _pClassInfo->GetCustomActivatorCount(stage,&_cCustomAct);
        if (SUCCEEDED (hr) && _cCustomAct)
        {
            hr = _pClassInfo->GetCustomActivators(stage,&_customActList);
            if (FAILED (hr))
            {
                _cCustomAct = 0;
                _customActList = NULL;
            }
        }
    }

    return hr;
}

STDMETHODIMP ActivationPropertiesIn::UnmarshalInterface(IStream *pStm,REFIID riid,void **ppv)
{
    HRESULT hr = ActivationProperties::UnmarshalInterface(pStm, riid,ppv);

    if (hr != S_OK)
        return hr;

    CLSID clsid;
    GetInstantiationInfo()->GetClsid(&clsid);
    hr = GetClassInfoFromClsid(clsid, &_pClassInfo);

    if ((hr == S_OK) && _pClassInfo)
    {
        _pClassInfo->Lock();
    }

    _delegated=TRUE; //assume unmarshalling imples that delegation happened

    return hr;

}


//---------------------------------------------------------------------------
//            Methods for ActivationPropertiesOut
//---------------------------------------------------------------------------
ActivationPropertiesOut::ActivationPropertiesOut(BOOL fBrokenRefCount)
    : _outSer(fBrokenRefCount)
{
    _pOutSer=0;
    _refCount = 1;
    _actCLSID=CLSID_ActivationPropertiesOut;
    _fBrokenRefCount = fBrokenRefCount;
    _fInprocSerializationRequired = TRUE;
}

ActivationPropertiesOut::~ActivationPropertiesOut()
{
}

//---------------------------------------------------------------------------
//  Methods for IUnknown
//---------------------------------------------------------------------------

STDMETHODIMP ActivationPropertiesOut::QueryInterface( REFIID riid, LPVOID* ppv)
{
    // USE CLSID_ActivationPropertiesOut to get at the real object
    // Note that this is a hidden contract to be used by COM only and
    // the object is not AddRef'd as an optimization
    if (IsEqualIID(riid, CLSID_ActivationPropertiesOut))
    {
        *ppv = (ActivationPropertiesOut*)this;
        return S_OK;
    }
    else
        if (IsEqualIID(riid, IID_IUnknown))
            *ppv = (IActivationPropertiesOut*)this;
        else
            if (IsEqualIID(riid, IID_IPrivActivationPropertiesOut))
                *ppv = (IPrivActivationPropertiesOut*)this;
            else
                if (IsEqualIID(riid, IID_IActivationPropertiesOut))
                    *ppv = (IActivationPropertiesOut*)this;
                else
                    *ppv = NULL;

    if (*ppv != NULL)
    {
        AddRef();
        return S_OK;
    }

    return ActivationProperties::QueryInterface(riid, ppv);
}

ULONG ActivationPropertiesOut::AddRef(void)
{
    return ActivationProperties::AddRef();
}

ULONG ActivationPropertiesOut::Release(void)
{
    ULONG ret=ActivationProperties::Release();

    if (ret==0)
    {
        if (_toDelete)
            delete this;
        else
            if (_fDestruct)
                this->ActivationPropertiesOut::~ActivationPropertiesOut();
    }

    return ret;
}

STDMETHODIMP ActivationPropertiesOut::GetActivationID(OUT GUID  *pActivationID)
{
    *pActivationID = GUID_NULL; // currently unused and not supported
    return E_NOTIMPL;
}


//-----------------------------------------------------------------------
//  Set Marshalled interface data that are results of activation
//-----------------------------------------------------------------------
STDMETHODIMP ActivationPropertiesOut::SetMarshalledResults(
    IN DWORD cIfs,
    IN IID *pIID,
    IN HRESULT *pHr,
    IN MInterfacePointer **ppIntfData)
{
    if (!_pOutSer)
    {
        _pOutSer = &_outSer;
        AddSerializableIfs((SerializableProperty*) _pOutSer);
    }

    _pOutSer->_info.cIfs = cIfs;

    //
    // Allocate new storage and copy parameters
    //
    _pOutSer->_info.piid = (IID*) ActMemAlloc(sizeof(IID)*cIfs);
    if (_pOutSer->_info.piid == NULL)
    {
       _pOutSer->_info.cIfs=0;
       return E_OUTOFMEMORY;
    }
    _pOutSer->_info.ppIntfData = (MInterfacePointer**)
        ActMemAlloc(sizeof(MInterfacePointer*)*cIfs);
    if (_pOutSer->_info.ppIntfData == NULL)
    {
       _pOutSer->_info.cIfs=0;
       ActMemFree(_pOutSer->_info.piid);
       _pOutSer->_info.piid = NULL;
       return E_OUTOFMEMORY;
    }
    _pOutSer->_info.phresults = (HRESULT*) ActMemAlloc(sizeof(HRESULT)*cIfs);
    if (_pOutSer->_info.phresults == NULL)
    {
       _pOutSer->_info.cIfs=0;
       ActMemFree(_pOutSer->_info.piid);
       _pOutSer->_info.piid = NULL;
       ActMemFree(_pOutSer->_info.ppIntfData);
       _pOutSer->_info.ppIntfData = NULL;
       return E_OUTOFMEMORY;
    }
    for (DWORD i=0; i< cIfs; i++)
    {
        _pOutSer->_info.piid[i] = pIID[i];
        if (ppIntfData[i])
        {
            //
            // Use stream cloning to copy marshalled stuff
            //
            ActivationStream strm((InterfaceData*) ppIntfData[i]);
            ActivationStream *newStrm;
            newStrm = strm.Clone();
            if (newStrm == NULL)
	    {
	       _pOutSer->_info.cIfs=0;
	       ActMemFree(_pOutSer->_info.piid);
	       _pOutSer->_info.piid = NULL;
	       ActMemFree(_pOutSer->_info.ppIntfData);
	       _pOutSer->_info.ppIntfData = NULL;
	       ActMemFree(_pOutSer->_info.phresults);
	       _pOutSer->_info.phresults = NULL;
	       return E_OUTOFMEMORY;
	    }
            newStrm->AssignSerializedInterface(
                (InterfaceData**)&_pOutSer->_info.ppIntfData[i]);
            newStrm->Release();
        }
        else
            _pOutSer->_info.ppIntfData[i] = NULL;

        _pOutSer->_info.phresults[i] = pHr[i];
    }

    return S_OK;
}

//-----------------------------------------------------------------------
//  Get results of activation in marshalled form
//-----------------------------------------------------------------------
STDMETHODIMP ActivationPropertiesOut::GetMarshalledResults(OUT DWORD *pcIfs,
                                                           OUT IID **ppIID,
                                                           OUT HRESULT **ppHr,
                                                           OUT MInterfacePointer ***pppIntfData)
{
    HRESULT hr;

    //-------------------------------------------------------------------
    //  If not unserialized we have to unserialize appropriately
    //-------------------------------------------------------------------
    if ((!_pOutSer) && (_unSerialized))
    {
        if (!SUCCEEDED(hr = UnSerializeCallBack(CLSID_ActivationPropertiesOut,
                                                (SerializableProperty**)&_pOutSer)))
            return hr;

    }

    Win4Assert(_pOutSer != NULL);

    //-------------------------------------------------------------------
    //  If user passed holders, copy into them otherwise allocate
    //-------------------------------------------------------------------

    //-------------------------------------------------------------------
    //  First do IIDs
    //-------------------------------------------------------------------
    *pcIfs = _pOutSer->_info.cIfs;
    DWORD i;
    if (*ppIID == NULL)
        *ppIID = _pOutSer->_info.piid;
    else
    {
        IID *pIID = *ppIID;
        for (i=0;i<_pOutSer->_info.cIfs;i++)
            pIID[i] = _pOutSer->_info.piid[i];
    }

    //-------------------------------------------------------------------
    //  Do Marshalled results
    //-------------------------------------------------------------------
    if (*pppIntfData == NULL)
        *pppIntfData = _pOutSer->_info.ppIntfData;
    else
    {
        MInterfacePointer **ppIntfData = *pppIntfData;
        for (i=0;i<_pOutSer->_info.cIfs;i++)
        {
            ActivationStream strm((InterfaceData*)_pOutSer->_info.ppIntfData[i]);
            ActivationStream *newStrm;
            newStrm = strm.Clone();
            if (newStrm==NULL)
                return E_OUTOFMEMORY;
            newStrm->AssignSerializedInterface((InterfaceData**)&ppIntfData[i]);
            newStrm->Release();
        }
    }

    //-------------------------------------------------------------------
    //  Set error codes and return appropriate one as result
    //  Call suceeds if at least one interface exists
    //-------------------------------------------------------------------
    HRESULT rethr = E_NOINTERFACE;
    if (*ppHr == NULL)
    {
        *ppHr = _pOutSer->_info.phresults;
        for (i=0;i<_pOutSer->_info.cIfs;i++)
            if (_pOutSer->_info.phresults[i] == S_OK)
            {
                rethr = S_OK;
                break;
            }

    }
    else
    {
        HRESULT *phr = *ppHr;
        for (i=0;i<_pOutSer->_info.cIfs;i++)
        {
            phr[i] = _pOutSer->_info.phresults[i];
            if (phr[i] == S_OK)
                rethr = S_OK;
        }
    }

    return rethr;
}

//-----------------------------------------------------------------------
//  Set results of activation
//-----------------------------------------------------------------------
STDMETHODIMP ActivationPropertiesOut::SetObjectInterfaces(
    IN DWORD  cIfs,
    IN IID *pIID,
    IN IUnknown *pUnk)
{
    if (!cIfs)
        return E_FAIL;

    if (!_pOutSer)
    {
        _pOutSer = &_outSer;
        _pOutSer->_pClientCOMVersion = &_clientCOMVersion;
        AddSerializableIfs((SerializableProperty*) _pOutSer);
    }

    _pOutSer->_info.cIfs = cIfs;
    if (cIfs > MAX_ACTARRAY_SIZE)
    {
        _pOutSer->_info.piid = (IID*) ActMemAlloc(sizeof(IID)*cIfs);
        if (_pOutSer->_info.piid == NULL)
            return E_OUTOFMEMORY;
    }
    else
        _pOutSer->_info.piid = _pOutSer->_pIIDs;
    for (DWORD i=0; i< cIfs; i++)
        _pOutSer->_info.piid[i] = pIID[i];
    _pOutSer->_pUnk = pUnk;


    if (!_fBrokenRefCount)
    {
        pUnk->AddRef();
    }
    _pOutSer->_info.phresults = NULL;

    return S_OK;
}

//-----------------------------------------------------------------------
//  Get results of activation
//-----------------------------------------------------------------------
STDMETHODIMP ActivationPropertiesOut::GetObjectInterface(
    IN REFIID riid,
    IN DWORD actvflags,
    OUT void **ppv)
{
    //-------------------------------------------------------------------
    //  If not unserialized we have to unserialize appropriately
    //-------------------------------------------------------------------
    if (!_pOutSer)
    {
        if (_unSerialized)
        {
            HRESULT rethr;
            rethr = UnSerializeCallBack(CLSID_ActivationPropertiesOut,
                                        (SerializableProperty**)&_pOutSer);
            if (FAILED(rethr))
                return rethr;
        }
        else
            return E_UNEXPECTED; // We must have a _pOutSer
    }

    Win4Assert(_pOutSer);


    IUnknown *punk = NULL;
    *ppv = NULL;
    BOOL fCountedPunk = FALSE;    // Indicates whether we hold a reference
    // to punk and must release it.

    if (!_pOutSer->_ppvObj)
    {
        Win4Assert(_pOutSer->_pUnk!=NULL);
        punk = _pOutSer->_pUnk;
    }
    else
        for (DWORD i=0; i<_pOutSer->_info.cIfs; i++)
        {
            if (IsEqualIID(riid, _pOutSer->_info.piid[i]))
            {
                _pOutSer->UnmarshalAtIndex(i);

                if (_pOutSer->_info.phresults[i] == S_OK)
                {
                    _fInprocSerializationRequired = TRUE;
                    punk = (IUnknown*) _pOutSer->_ppvObj[i];
                    *ppv = punk;
                    punk->AddRef();
                    return S_OK;
                }
            }
        }

    if (!punk)
    {
        if (!IsEqualIID(IID_IUnknown, riid))
        {
            // If we get a punk back here, it will be counted, so we
            // must release it.

            HRESULT hr = GetObjectInterface(IID_IUnknown,
                                            NULL,
                                            (void**) &punk);
            if (FAILED(hr))
                punk = NULL;
            else
                fCountedPunk = TRUE;
        }
        else
            for (DWORD i=0; i<_pOutSer->_info.cIfs; i++)
            {
                _pOutSer->UnmarshalAtIndex(i);

                if (_pOutSer->_info.phresults[i] == S_OK)
                {
                    _fInprocSerializationRequired = TRUE;
                    punk = (IUnknown*) _pOutSer->_ppvObj[i];
                }
            }
    }

    if (punk)
    {
        //  If we're being called by x86 code and the IP is x86 then set the
        //  OleStubInvoked flag to allow MapIFacePtr() to thunk unknown IP
        //  return values as -1 because we're just returning this to x86
        //  code anyway.
#ifdef WX86OLE
        if ( (actvflags & ACTVFLAGS_WX86_CALLER) && gcwx86.IsN2XProxy(punk) )
        {
            gcwx86.SetStubInvokeFlag((UCHAR)-1);
        }
#endif
        HRESULT hr = punk->QueryInterface(riid, ppv);

            // If we hold a reference on the punk, release it.

        if (fCountedPunk)
            punk->Release();

        return hr;
    }
    else
        return E_NOINTERFACE;
}

//-----------------------------------------------------------------------
//  Get results of activation
//-----------------------------------------------------------------------
STDMETHODIMP ActivationPropertiesOut::GetObjectInterfaces(
    IN DWORD  cIfs,
    IN DWORD actvflags,
    IN MULTI_QI  *pMultiQi)
{
    HRESULT rethr;

    //-------------------------------------------------------------------
    //  If not unserialized we have to unserialize appropriately
    //-------------------------------------------------------------------
    if (!_pOutSer)
    {
        if (_unSerialized)
        {
            rethr = UnSerializeCallBack(CLSID_ActivationPropertiesOut,
                                        (SerializableProperty**)&_pOutSer);
            if (FAILED(rethr))
                return rethr;
        }
        else
            return E_UNEXPECTED; // We must have a _pOutSer
    }

    Win4Assert(_pOutSer);

    rethr = E_NOINTERFACE;
    //-------------------------------------------------------------------
    //  Either Interfaces already unmarshalled or marshalling never
    //  took place.
    //  Set error codes and return appropriate one as result
    //-------------------------------------------------------------------
    for (DWORD i=0; i<cIfs; i++)
    {
        //---------------------------------------------------------------
        //  If no umarshalled result then we have to have a pUnk
        //---------------------------------------------------------------
        if (!_pOutSer->_ppvObj)
        {
            Win4Assert(_pOutSer->_pUnk!=NULL);

            if (_fBrokenRefCount && (i == 0))
            {

                pMultiQi[i].pItf = _pOutSer->_pUnk;
                pMultiQi[i].hr = S_OK;
            }
            else
            {
#ifdef WX86OLE
                //  If we're being called by x86 code and the IP is x86 thenset the
                //  OleStubInvoked flag to allow MapIFacePtr() to thunk unknown IP
                //  return values as -1 because we're just returning this tox86
                //  code anyway.
                if ( (actvflags & ACTVFLAGS_WX86_CALLER) && gcwx86.IsN2XProxy(_pOutSer->_pUnk) )
                {
                    gcwx86.SetStubInvokeFlag((UCHAR)-1);
                }
#endif
                pMultiQi[i].hr =
                    _pOutSer->_pUnk->QueryInterface(*pMultiQi[i].pIID,
                                                    (void**) &pMultiQi[i].pItf);
            }
        }
        else
            //---------------------------------------------------------------
            //  If IIDs don't match then we're inefficient(order n-square)
            //  anyway so call to get a single interface.
            //---------------------------------------------------------------
            if ((_pOutSer->_info.piid[i] != *pMultiQi[i].pIID)||
                (_pOutSer->_info.ppIntfData[i] == NULL))
            {
                pMultiQi[i].hr = GetObjectInterface(*pMultiQi[i].pIID,
                                                    actvflags,
                                                    (void**)&pMultiQi[i].pItf);

            }
            else
                //---------------------------------------------------------------
                //  Common case where we are returning originally requested
                //  IIDs after unmarshalling.
                //---------------------------------------------------------------
            {
                Win4Assert(!_fBrokenRefCount);
                Win4Assert(_outSer._info.ppIntfData != NULL);
                _pOutSer->UnmarshalAtIndex(i);
                _fInprocSerializationRequired = TRUE;
                pMultiQi[i].pItf = (IUnknown*) _pOutSer->_ppvObj[i];
                pMultiQi[i].hr = _pOutSer->_info.phresults[i];
                if (pMultiQi[i].hr == S_OK)
                    ((IUnknown*)_pOutSer->_ppvObj[i])->AddRef();
            }

        //---------------------------------------------------------------
        //  Call suceeds if at least one interface exists
        //---------------------------------------------------------------
        if (rethr != S_OK)
            rethr = pMultiQi[i].hr;
    }

    return rethr;
}

//-----------------------------------------------------------------------
//  Removes requested IIDs: to be used by custom activators
//  REVIEW: Longer term, having a refcount on the IIDs may make code
//          more readable and could be more efficient all round.
//          However, since this method can add on to existing scheme
//          without change we will punt refcounting IIDs for now.
//          However, also issue of Marshalling n-times at source vs
//          marshalling once at source and n-1 times in b/w should be
//          considered as a tradeoff.
//          Also if something is unmarshallable in an intermediate
//          stage but activation does'nt fail, all is not lost.
//-----------------------------------------------------------------------
STDMETHODIMP ActivationPropertiesOut::RemoveRequestedIIDs(
    IN DWORD cIfs,
    IN IID  *pIID)
{
    //-------------------------------------------------------------------
    //  If not unserialized we have to unserialize appropriately
    //-------------------------------------------------------------------
    if (!_pOutSer)
    {
        if (!_unSerialized)
            return E_INVALIDARG;

        if (UnSerializeCallBack(CLSID_ActivationPropertiesOut,
                                (SerializableProperty**)&_pOutSer)!= S_OK)
            return E_FAIL;

        Win4Assert(_pOutSer != NULL);
    }

    //
    //Assume that we never remove originally requested ones
    //
    if ((cIfs > _pOutSer->_info.cIfs) || (cIfs == 0))
        return E_INVALIDARG;

    LONG i,j;
    DWORD dec = 0;

        //
        //First try to do it efficiently assuming
        //that we always added to end
        //
    for (i=_pOutSer->_info.cIfs-1; i>=0 && cIfs; i--)
    {
        if (_pOutSer->_info.piid[i]==pIID[cIfs-1])
        {
            //
            //If we still have interface data then make sure
            //that we give to duplicate entry if it exists and does'nt
            //have one. Otherwise free it
            //
            if (_pOutSer->_info.ppIntfData)
            {
                if (_pOutSer->_info.ppIntfData[i])
                {
                    for (j=0;j<i;j++)
                    {
                        if ((_pOutSer->_info.piid[i]==_pOutSer->_info.piid[j]) &&
                            (_pOutSer->_info.ppIntfData[j] == NULL))
                        {
                            _pOutSer->_info.ppIntfData[j] =
                                _pOutSer->_info.ppIntfData[i];
                            _pOutSer->_info.ppIntfData[i] = NULL;
                            _pOutSer->_info.phresults[j] =
                                _pOutSer->_info.phresults[i];
                            Win4Assert(_pOutSer->_info.phresults[j]==S_OK);
                            if (_pOutSer->_ppvObj && _pOutSer->_ppvObj[j])
                            {
                                ((IUnknown*)_pOutSer->_ppvObj[j])->Release();
                                _pOutSer->_ppvObj[j] = NULL;
                            }

                        }
                    }

                    // If we did'nt give it away release it
                    if (_pOutSer->_info.ppIntfData[i])
                    {
                        ReleaseIFD(_pOutSer->_info.ppIntfData[i]);
                        ActMemFree(_pOutSer->_info.ppIntfData[i]);
                        _pOutSer->_info.ppIntfData[i] = NULL;
                    }
                }
                else
                    // Release Unmarshalled object
                    if (_pOutSer->_ppvObj && _pOutSer->_ppvObj[i])
                    {
                        ((IUnknown*)_pOutSer->_ppvObj[i])->Release();
                        _pOutSer->_ppvObj[i] = NULL;
                    }
            }
            _pOutSer->_info.cIfs--;
            cIfs--;
            dec++;
        }
        else
            break;
    }

    //
    //Do inefficiently if we still have leftover IIDs
    //
    if (cIfs)
    {
        IID *newIIDs=NULL;
        MInterfacePointer **newIFD=NULL;
        void **newppv = NULL;
        HRESULT *newhr=NULL;

        BOOL *pFound = (BOOL*) ActMemAlloc(sizeof(BOOL) * cIfs);
        if (pFound == NULL)
            return E_OUTOFMEMORY;

        DWORD newLen = _pOutSer->_info.cIfs-cIfs;

        //
        // Allocate storage for new stuff
        //
        if (newLen)
        {
            newIIDs =  (IID*) ActMemAlloc(sizeof(IID)*newLen);
            if (_marshalState == UNMARSHALLED)
            {
                newIFD = (MInterfacePointer**)
                    ActMemAlloc(sizeof(MInterfacePointer*)*
                                newLen);
                newppv = (void**) ActMemAlloc(sizeof(IUnknown*)*newLen);

                newhr = (HRESULT*) ActMemAlloc(sizeof(HRESULT)*newLen);

                if ((newIIDs==NULL) || (newppv==NULL) ||
                    (newIFD==NULL) || (newhr == NULL))
                {
                    ActMemFree(newppv);
                    ActMemFree(newIIDs);
                    ActMemFree(newIFD);
                    ActMemFree(newhr);
		    ActMemFree(pFound);
                    return E_OUTOFMEMORY;
                }
            }
        }



        for (i=0;i<(LONG)cIfs;i++)
            pFound[i] = FALSE;

        DWORD newIndex=0;
        //
        // Loop trying to establish new arrays
        //
        for (i=0;i<(LONG)_pOutSer->_info.cIfs;i++)
        {
            BOOL found=FALSE;
            for (j=0;j<(LONG)cIfs;j++)
                if (!pFound[j])
                {
                    if (_pOutSer->_info.piid[i] == pIID[j])
                    {
                        found = TRUE;
                        pFound[j] = TRUE;
                        if ((_marshalState == UNMARSHALLED) &&
                            (SUCCEEDED(_pOutSer->_info.phresults[i])))
                        {
                            if (_pOutSer->_info.ppIntfData[i])
                            {
                                ReleaseIFD(_pOutSer->_info.ppIntfData[i]);
                                ActMemFree(_pOutSer->_info.ppIntfData[i]);
                                _pOutSer->_info.ppIntfData[i] = NULL;
                            }
                            else
                                if (_pOutSer->_ppvObj && _pOutSer->_ppvObj[i])
                                {
                                    ((IUnknown*)_pOutSer->_ppvObj[i])->Release();
                                    _pOutSer->_ppvObj[i] = NULL;
                                }
                        }
                        break;
                    }
                }

            // If this was'nt part of passed in array we need to
            // keep it
            if ((!found) && newLen)
            {
                newIIDs[newIndex] = _pOutSer->_info.piid[i];

                if (_marshalState == UNMARSHALLED)
                {
                    newIFD[newIndex] = _pOutSer->_info.ppIntfData[i];
                    newppv[newIndex] = _pOutSer->_ppvObj[i];
                    newhr[newIndex] =  _pOutSer->_info.phresults[i];
                }

                newIndex++;
            }
        }

#if 0 //Assume good behaviour since implementing
        //This failure case would require more changes
        //than necessary for a failure that should'nt happen
        for (i=0;i<cIfs;i++)
            if (!pFound[i])
            {
                ActMemFree(pFound);
                ActMemFree(newIIDs);
                ActMemFree(newIFD);
                ActMemFree(newppv);
                ActMemFree(newhr);
                _pOutSer->_info.cIfs += dec; // this will not work
                // unless we preserve
                // _ppvObj[k] till here
                return E_INVALIDARG;
            }
#endif

        Win4Assert(newIndex == newLen);

        ActMemFree(pFound);

        //
        //Free old ones and set new ones
        //
        _pOutSer->_info.cIfs = newLen;
        if (_pOutSer->_info.piid != _pOutSer->_pIIDs)
            ActMemFree(_pOutSer->_info.piid);
        _pOutSer->_info.piid = newIIDs;
        if (_marshalState == UNMARSHALLED)
        {
            ActMemFree(_pOutSer->_info.ppIntfData);
            _pOutSer->_info.ppIntfData = newIFD;
            ActMemFree(_pOutSer->_ppvObj);
            _pOutSer->_ppvObj = newppv;
            ActMemFree(_pOutSer->_info.phresults);
            _pOutSer->_info.phresults = newhr;
        }
    }

    return S_OK;
}


//-----------------------------------------------------------------------
//  Get classes supported by this interfaces given an IID
//-----------------------------------------------------------------------
HRESULT ActivationPropertiesOut::GetClass(REFIID iid,
                                          SerializableProperty **ppSer,
                                          BOOL forQI,
                                          BOOL *pbZeroSizeOk)
{

    if (pbZeroSizeOk)
        *pbZeroSizeOk = FALSE;

    if (iid == CLSID_ActivationPropertiesOut)
        *ppSer = &_outSer;
    else
        if (iid == IID_IScmReplyInfo)
            *ppSer = &_scmReplyInfo;
        else
            if (iid == IID_IOpaqueDataInfo)
            {
                *ppSer = new OpaqueDataInfo();
                if (pbZeroSizeOk)
                    *pbZeroSizeOk = TRUE;
            }
            else
                return E_NOINTERFACE;

    return S_OK;
}



//---------------------------------------------------------------------------
//   Methods for ActivationPropertiesOut::OutSerializer
//---------------------------------------------------------------------------

ActivationPropertiesOut::OutSerializer::OutSerializer(BOOL fBrokenRefCount)
{
    memset(&_info, 0, sizeof(PropsOutInfo));
    _ppvObj = NULL;
    _unSerialized=FALSE;
    _pUnk = NULL;
    _parent = NULL;
    _fBrokenRefCount = fBrokenRefCount;
    _fToReleaseIFD = FALSE;
}

ActivationPropertiesOut::OutSerializer::~OutSerializer()
{
    //-------------------------------------------------------------------
    //  Free marshalled data
    //-------------------------------------------------------------------
    if (_info.ppIntfData)
    {
        for (DWORD i=0;i<_info.cIfs;i++)
        {
            if ((_info.ppIntfData[i]) && (_fToReleaseIFD))
                ReleaseIFD(_info.ppIntfData[i]);
            ActMemFree(_info.ppIntfData[i]);
            if (_ppvObj && _ppvObj[i])
                ((IUnknown*)_ppvObj[i])->Release();
        }
        ActMemFree(_info.ppIntfData);
        ActMemFree(_ppvObj);
    }

    ActMemFree(_info.phresults);

    if (_info.piid != _pIIDs)
        ActMemFree(_info.piid);

    if (_pUnk && !_fBrokenRefCount)
    {
        _pUnk->Release();
    }
}

inline void ActivationPropertiesOut::OutSerializer::UnmarshalAtIndex(DWORD index)
{
    InitMarshalling();

    Win4Assert(_info.ppIntfData != NULL);
    if (_info.ppIntfData[index] && (_info.phresults[index] == S_OK))
    {
        ActivationStream strm((InterfaceData*)_info.ppIntfData[index]);
        if (IsInterfaceImplementedByProxy(_info.piid[index]))
        {
            IUnknown* pUnk = NULL;

            HRESULT hr;

            if (pfnCoUnmarshalInterface)
            {
                hr = pfnCoUnmarshalInterface(&strm, IID_IUnknown, (void**) &pUnk);
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
            }

            if (SUCCEEDED(hr))
            {
                _info.phresults[index] = pUnk->QueryInterface (_info.piid[index], &_ppvObj[index]);
                pUnk->Release();
            }
            else
            {
                _info.phresults[index] = hr;
                _ppvObj[index] = (void*) pUnk;
            }
        }
        else
        {
            if (pfnCoUnmarshalInterface)
            {
                _info.phresults[index] = pfnCoUnmarshalInterface(&strm, _info.piid[index], &_ppvObj[index]);
            }
            else
            {
                _info.phresults[index] = HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
            }
        }

        if (_info.phresults[index] != S_OK)
            _ppvObj[index] = NULL;

        ActMemFree(_info.ppIntfData[index]);
        _info.ppIntfData[index] = NULL;
    }
}


//---------------------------------------------------------------------------
//   Methods from IUnknown
//---------------------------------------------------------------------------
STDMETHODIMP ActivationPropertiesOut::OutSerializer::QueryInterface( REFIID riid, LPVOID* ppvObj)
{
    if (_parent)
        return _parent->QueryInterface(riid, ppvObj);
    else
        return SerializableQueryInterface(riid, ppvObj);
}

STDMETHODIMP ActivationPropertiesOut::OutSerializer::SerializableQueryInterface( REFIID riid, LPVOID* ppvObj)
{
    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG ActivationPropertiesOut::OutSerializer::AddRef(void)
{
    if (_parent)
        return _parent->AddRef();

    return 1;
}

ULONG ActivationPropertiesOut::OutSerializer::Release(void)
{
    if (_parent)
        return _parent->Release();

    return 0;
}


//---------------------------------------------------------------------------
//   Methods from ISerializable
//---------------------------------------------------------------------------

STDMETHODIMP ActivationPropertiesOut::OutSerializer::Serialize(void *pv)
{
    HRESULT hr;
    Serializer *pSer = (Serializer*) pv;

    //-------------------------------------------------------------------
    //  Encode this object
    //-------------------------------------------------------------------
    handle_t handle;
    hr = pSer->GetSerializationHandle((void*) &handle);
    PropsOutInfo_Encode(handle, &_info);

    return S_OK;
}

STDMETHODIMP ActivationPropertiesOut::OutSerializer::UnSerialize(void *pv)
{
    Serializer *pSer = (Serializer*) pv;
    //-------------------------------------------------------------------
    //  If not unserialized then read header
    //-------------------------------------------------------------------
    if (!_unSerialized)
    {
        handle_t handle;
        pSer->GetSerializationHandle((void*) &handle);
        if (_info.piid)
            ActMemFree(_info.piid);
        _info.piid = 0;
        if (_info.phresults)
            ActMemFree(_info.phresults);
        _info.phresults = 0;
        PropsOutInfo_Decode(handle, &_info);
        if (_info.ppIntfData)
        {
            Win4Assert(_info.cIfs != 0);
            _ppvObj = (void**) ActMemAlloc(sizeof(IUnknown*)*_info.cIfs);
            if (_ppvObj == NULL)
                return E_OUTOFMEMORY;
            for (DWORD i=0; i<_info.cIfs; i++)
                _ppvObj[i] = NULL;
        }
        else
            _ppvObj = NULL;
    }

    return S_OK;
}

STDMETHODIMP ActivationPropertiesOut::OutSerializer::GetSize(IN void *pv, OUT DWORD *pdwSize)
{
    Serializer *pSer = (Serializer*) pv;
    //-------------------------------------------------------------------
    //  Need to marshal interfaces to calculate size
    //-------------------------------------------------------------------
    DWORD dwMaxDestCtx;
    BOOL firstMarshal;
    DWORD i;
    HRESULT hr;

    InitMarshalling();

    pSer->GetMaxDestCtx(&dwMaxDestCtx);

    if (!_info.cIfs)
        goto EncodeOut;


    if (_info.ppIntfData == NULL)
    {
        _info.ppIntfData = (MInterfacePointer**)
            ActMemAlloc(sizeof(MInterfacePointer*)
                        * _info.cIfs);

        if (_info.ppIntfData == NULL)
            return E_OUTOFMEMORY;
        for (DWORD i=0; i< _info.cIfs; i++)
            _info.ppIntfData[i] = NULL;

        Win4Assert(_info.phresults == NULL);

        _info.phresults = (HRESULT *)
            ActMemAlloc(sizeof(HRESULT)*_info.cIfs);
        if (_info.phresults == NULL)
	{
	   ActMemFree(_info.ppIntfData);
	   _info.ppIntfData=NULL;
	   return E_OUTOFMEMORY;
	}
        firstMarshal = TRUE;
    }
    else
        firstMarshal = FALSE;


    for (i=0; i< _info.cIfs; i++)
    {
        if ((!firstMarshal) &&
            ((_info.ppIntfData[i]) ||
             (FAILED(_info.phresults[i]))))
            continue;

        // Stream to put marshaled interface in
        ActivationStream xrpc;

        DWORD dwMarshalFlags;
        pSer->GetMarshalFlags(&dwMarshalFlags);

        IUnknown *punk;

        if (firstMarshal)
            punk = _pUnk;
        else
            punk = (IUnknown*) _ppvObj[i];

        Win4Assert(punk != NULL);

        void *pvDestCtx = NULL;
        if (dwMaxDestCtx == MSHCTX_DIFFERENTMACHINE)
        {
            pvDestCtx = GetDestCtxPtr(_pClientCOMVersion);
            if (pvDestCtx == NULL)
            {
	       ActMemFree(_info.ppIntfData);
	       _info.ppIntfData=NULL;
	       ActMemFree(_info.phresults);
	       _info.phresults = NULL;
	       return E_OUTOFMEMORY;
            }
        }

        if (pfnCoMarshalInterface)
        {
            if (IsInterfaceImplementedByProxy(_info.piid[i]))
            {
                hr = pfnCoMarshalInterface(&xrpc,
                                           IID_IUnknown,
                                           punk,
                                           dwMaxDestCtx,
                                           pvDestCtx,
                                           dwMarshalFlags);
            }
            else
            {
                hr = pfnCoMarshalInterface(&xrpc,
                                           _info.piid[i],
                                           punk,
                                           dwMaxDestCtx,
                                           pvDestCtx,
                                           dwMarshalFlags);
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
        }

        if (pvDestCtx != NULL)
        {
            delete pvDestCtx;
            pvDestCtx = NULL;
        }

        _info.phresults[i] = hr;
        if (SUCCEEDED(hr))
        {
            xrpc.AssignSerializedInterface(
                (InterfaceData**)&_info.ppIntfData[i]);
        }
        else
        {
            _info.ppIntfData[i] = NULL;

            // If MSHLFLAGS_NOTIFYACTIVATION is set then
            // it is an error path in the LocalServer case
            // (CobjServer) and it is possible for the server
            // to linger around forever unless the LockServer
            // api is toggled on the class factory
            if (dwMarshalFlags & MSHLFLAGS_NOTIFYACTIVATION)
            {
                Win4Assert(_info.cIfs == 1);

                IClassFactory *pcf;

                BOOL fToRelease;

                if (_info.piid[0] != IID_IClassFactory)
                {
                    HRESULT hr2;
                    hr2 = punk->QueryInterface(IID_IClassFactory,
                                               (void**) &pcf);
                    if (FAILED(hr2))
                        pcf = NULL;

                    fToRelease = TRUE;
                }
                else
                {
                    pcf = (IClassFactory*)punk;
                    fToRelease = FALSE;
                }

                if (pcf)
                {
                    pcf->LockServer(TRUE);
                    pcf->LockServer(FALSE);

                    if (fToRelease)
                        pcf->Release();
                }
            }
        }
    }


 EncodeOut:
    DWORD dwCurrDestCtx;
    pSer->GetCurrDestCtx(&dwCurrDestCtx);

    // If marshalling within process, set up as though unmarshalled
    if (MARSHALCTX_WITHIN_PROCESS(dwCurrDestCtx))
    {
        if (_info.ppIntfData)
        {
            Win4Assert(_info.cIfs != 0);
            if (!_ppvObj)
                _ppvObj = (void**) ActMemAlloc(sizeof(IUnknown*)*_info.cIfs);

            if (_ppvObj == NULL)
	    {
	       ActMemFree(_info.ppIntfData);
	       _info.ppIntfData=NULL;
	       ActMemFree(_info.phresults);
	       _info.phresults = NULL;
	       return E_OUTOFMEMORY;
	    }

            for (DWORD i=0; i<_info.cIfs; i++)
                _ppvObj[i] = NULL;

            // Release punk since destructor won't get called
            if (_pUnk)
            {
                if (!_fBrokenRefCount)
                    _pUnk->Release();
                _pUnk = NULL;
            }
        }
        else
            _ppvObj = NULL;

        _size = 0;
    }
    else
    {
        _fToReleaseIFD = FALSE;

        //-------------------------------------------------------------------
        //  Get Header size
        //-------------------------------------------------------------------
        handle_t   handle;
        hr = pSer->GetSizingHandle((void*) &handle);

        if (FAILED(hr))
            return hr;

        _size = PropsOutInfo_AlignSize(handle, &_info);
        MesHandleFree(handle);
    }

    *pdwSize = _size;

    return S_OK;
}

STDMETHODIMP ActivationPropertiesOut::OutSerializer::GetCLSID(OUT CLSID *pclsid)
{
    *pclsid = CLSID_ActivationPropertiesOut;
    return S_OK;
}


//---------------------------------------------------------------------------
//
//  Function:   ActPropsMarshalHelper
//
//  Synopsis:   Makes an "on the wire" representation of an ActProps
//
//  Arguments:  [pact] - interface to marshal
//              [riid] - iid to marshal
//              [ppIRD] - where to put pointer to marshaled data
//
//  Returns:    S_OK - object successfully marshaled.
//
//  Algorithm:  Marshal the object and then get the pointer to
//              the marshaled data so we can give it to RPC
//
//---------------------------------------------------------------------------
HRESULT ActPropsMarshalHelper(
    IActivationProperties *pact,
    REFIID    riid,
    DWORD     destCtx,
    DWORD     mshlflags,
    MInterfacePointer **ppIRD)
{
    TRACECALL(TRACE_ACTIVATION, "ActPropsMarshalHelper");
    HRESULT hr;

    // This should'nt really get used by functions
    // called. If that changes we should really QI
    IUnknown *punk = (IUnknown *)pact;


    // Do Marshalling ourselves since this is also
    // used in the SCM. Code collapsed and copied from
    // dcomrem for Custom marshalling
    ULONG dwSize, objrefSize;

    hr = pact->GetMarshalSizeMax(riid,
                                 (void*) punk,
                                 destCtx,
                                 NULL,
                                 mshlflags,
                                 &dwSize);

    if (FAILED(hr))
        return hr;

    objrefSize = dwSize + sizeof(OBJREF);

    // Stream to put marshaled interface in
    ActivationStream xrpc(objrefSize);

    // get the clsid for unmarshaling
    CLSID UnmarshalCLSID;
    hr = pact->GetUnmarshalClass(riid, punk, destCtx, NULL,
                                 mshlflags, &UnmarshalCLSID);


    if (FAILED(hr))
        return hr;

    OBJREF objref;

    objref.signature = OBJREF_SIGNATURE;
    objref.flags     = OBJREF_CUSTOM;
    objref.iid       = riid;
    objref.u_objref.u_custom.clsid     = UnmarshalCLSID;
    objref.u_objref.u_custom.size      = dwSize;

    // currently we dont write any extensions into the custom
    // objref. The provision is there so we can do it in the
    // future, for example,  if the unmarshaler does not have the
    // unmarshal class code available we could to provide a callback
    // mechanism by putting the OXID, and saResAddr in there.

    objref.u_objref.u_custom.cbExtension = 0;

    // write the objref header info into the stream
    ULONG cbToWrite = PtrToUlong( (LPVOID)( (BYTE *)(&objref.u_objref.u_custom.pData)
                                            - (BYTE *)&objref ) );
    hr = xrpc.Write(&objref, cbToWrite, NULL);

    if (FAILED(hr))
        return hr;

    hr = pact->MarshalInterface(&xrpc, riid, punk,
                                destCtx, NULL,
                                mshlflags);

    if (SUCCEEDED(hr))
        xrpc.AssignSerializedInterface((InterfaceData**)ppIRD);

    return hr;
}

//---------------------------------------------------------------------------
//
//  Function:   ActPropsUnMarshalHelper
//
//  Synopsis:   Unmarshals an Activation Properties given an IFD
//
//  Arguments:  [pact] - Object to unmarshal into
//              [riid] - iid to unmarshal
//              [pIFP] - pointer to marshaled data
//
//  Returns:    S_OK - object successfully unmarshaled.
//
//---------------------------------------------------------------------------
HRESULT ActPropsUnMarshalHelper(
    IActivationProperties *pAct,
    MInterfacePointer *pIFP,
    REFIID riid,
    void **ppv
)
{
    HRESULT hr = E_INVALIDARG;

    if (pIFP && ppv)
    {
        ActivationStream Stm((InterfaceData *) pIFP);

        *ppv = NULL;

        hr = pAct->UnmarshalInterface(&Stm, riid, ppv);
    }

    return hr;
}

//---------------------------------------------------------------------------
//
//  Function:   GetIFDFromInterface
//
//  Synopsis:   Makes an "on the wire" representation of an interface
//
//  Arguments:  [punk] - interface to marshal
//              [riid] - iid to marshal
//              [ppIRD] - where to put pointer to marshaled data
//
//  Returns:    S_OK - object successfully marshaled.
//
//  Algorithm:  Marshal the object and then get the pointer to
//              the marshaled data
//
//---------------------------------------------------------------------------
HRESULT GetIFDFromInterface(
    IUnknown *pUnk,
    REFIID    riid,
    DWORD     destCtx,
    DWORD     mshlflags,
    MInterfacePointer **ppIRD)
{
    DWORD sz;

    InitMarshalling();

    HRESULT rethr;

    if (pfnCoGetMarshalSizeMax)
    {
        rethr = pfnCoGetMarshalSizeMax(&sz, riid , pUnk,
                                           destCtx,
                                           NULL, mshlflags);
    }
    else
    {
        rethr = HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
    }

    if (rethr == S_OK)
    {
        ActivationStream stream(sz);
        if (pfnCoMarshalInterface)
        {
            rethr = pfnCoMarshalInterface(&stream, riid , pUnk,
                                          destCtx, NULL, mshlflags);
        }
        else
        {
            rethr = HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
        }

        if (rethr == S_OK)
            stream.AssignSerializedInterface((InterfaceData**)ppIRD);
        else
            *ppIRD = NULL;
    }
    return rethr;
}

//---------------------------------------------------------------------------
//
//  Function:   ReleaseIFD
//
//  Synopsis:   Releases Marshalled Data
//
//  Arguments:   [pIRD] - Marshalled Data
//
//  Returns:    S_OK - object successfully marshaled.
//
//  Algorithm:  Marshal the object and then get the pointer to
//              the marshaled data
//
//---------------------------------------------------------------------------
HRESULT ReleaseIFD(
    MInterfacePointer *pIRD)
{
    InitMarshalling();

    if (pIRD == NULL)
        return S_OK;

    if (pfnCoReleaseMarshalData == NULL)
        return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);

    ActivationStream Strm((InterfaceData *) pIRD);

    return pfnCoReleaseMarshalData(&Strm);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\actprops\propifs.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       propifs.cxx
//
//  Contents:   Activation Functions used by object servers.
//
//  Functions:  Implements classes in propifs.hxx
//
//  History:    24-Jan-98 Vinaykr    Created
//
///--------------------------------------------------------------------------

#include <ole2int.h>

#include <context.hxx>
#include <actprops.hxx>
#include <serial.hxx>
#include <hash.hxx>

//---------------------------------------------------------------------------   
// This file contains implementations of serializable      
// interfaces                                              
//---------------------------------------------------------------------------   

//---------------------------------------------------------------------------   
//             Methods for InstantiationInfo               
//---------------------------------------------------------------------------   

    //-----------------------------------------------------------------------   
    // Methods from IUnknown                               
    //-----------------------------------------------------------------------   
    STDMETHODIMP InstantiationInfo::QueryInterface( REFIID riid, LPVOID* ppvObj)
    {
        if (_parent)
          return _parent->QueryInterface(riid, ppvObj);
        else
          return SerializableQueryInterface(riid, ppvObj);
    }

    STDMETHODIMP InstantiationInfo::SerializableQueryInterface( REFIID riid, LPVOID* ppvObj)
    {
       //Use IID_InstantiationInfo to return the real object right now
       if (IsEqualIID(riid, IID_IInstantiationInfo))  
       {
          *ppvObj = (InstantiationInfo*) this;
          AddRef();
          return S_OK;
       }
       else
       if  (IsEqualIID(riid, IID_IUnknown))
       {
           *ppvObj = (IInstantiationInfo*) this;
           AddRef();
           return S_OK;
       }
       else
       if (IsEqualIID(riid, IID_ISerializable))
       {
           *ppvObj = (ISerializable*) this;
           AddRef();
           return S_OK;
       }
       *ppvObj = NULL;
       return E_NOINTERFACE;
    }

    ULONG InstantiationInfo::AddRef(void)
    {
        if (_parent)
            return _parent->AddRef();

        return 1;
    }

    ULONG InstantiationInfo::Release(void)
    {
        if (_parent)
           return _parent->Release();

       return 0;
    }

    //-----------------------------------------------------------------------   
    // Methods from ISerializable                          
    //-----------------------------------------------------------------------   

    STDMETHODIMP InstantiationInfo::Serialize(void *pv)
    {
        HRESULT hr;
        Serializer *pSer = (Serializer*) pv;

        handle_t handle;
        hr = pSer->GetSerializationHandle((void*) &handle);
        Win4Assert(hr==S_OK);
    
        InstantiationInfoData_Encode(handle, &_instantiationInfoData);
        return S_OK;
    }

    STDMETHODIMP InstantiationInfo::UnSerialize(void *pv)
    {
        Serializer *pSer = (Serializer*) pv;
        if (!_unSerialized)
        {
            handle_t handle;
            HRESULT hr = pSer->GetSerializationHandle((void*) &handle);
            Win4Assert(hr==S_OK);
            _instantiationInfoData.pIID = 0;
            InstantiationInfoData_Decode(handle, &_instantiationInfoData);

            _unSerialized = TRUE;
       }

       return S_OK;
    }

    STDMETHODIMP InstantiationInfo::GetSize(IN void *pv, OUT DWORD *pdwSize)
    {
        Serializer *pSer = (Serializer*) pv;
        if (!IsInproc(pSer))
        {
            handle_t   handle;
            HRESULT hr = pSer->GetSizingHandle((void*) &handle);
            if (FAILED(hr))
                return hr;
            *pdwSize = InstantiationInfoData_AlignSize(handle, 
                                                       &_instantiationInfoData);
            MesHandleFree(handle);
            _instantiationInfoData.thisSize = *pdwSize;
        }
        else
            *pdwSize = 0;

        return S_OK;
    }

    STDMETHODIMP InstantiationInfo::GetCLSID(OUT CLSID *pclsid)
    {
        *pclsid = IID_IInstantiationInfo;
        return S_OK;
    }

//---------------------------------------------------------------------------   
//             Methods for ServerLocationInfo              
//---------------------------------------------------------------------------   

    //-----------------------------------------------------------------------   
    // Methods from IUnknown                               
    //-----------------------------------------------------------------------   
    STDMETHODIMP ServerLocationInfo::QueryInterface( REFIID riid, LPVOID* ppvObj)
    {
        if (_parent)
          return _parent->QueryInterface(riid, ppvObj);
        else
          return SerializableQueryInterface(riid, ppvObj);
    }

    STDMETHODIMP ServerLocationInfo::SerializableQueryInterface( REFIID riid, LPVOID* ppvObj)
    {
       if (IsEqualIID(riid, IID_IServerLocationInfo) || 
           IsEqualIID(riid, IID_IUnknown))
       {
           *ppvObj = (IServerLocationInfo*) this;
           AddRef();
           return S_OK;
       }
       else
       if (IsEqualIID(riid, IID_ISerializable))
       {
           *ppvObj = (ISerializable*) this;
           AddRef();
           return S_OK;
       }

       *ppvObj = NULL;
       return E_NOINTERFACE;
    }

    ULONG ServerLocationInfo::AddRef(void)
    {
        if (_parent)
            return _parent->AddRef();

        return 1;
    }

    ULONG ServerLocationInfo::Release(void)
    {
        if (_parent)
           return _parent->Release();

       return 0;
    }
    
    //-----------------------------------------------------------------------   
    // Constructor/destructor
    //-----------------------------------------------------------------------   
    ServerLocationInfo::ServerLocationInfo()
    {
        ZeroMemory(&_locationInfoData, sizeof(LocationInfoData));
        _pObjectContext = NULL;
        _pISSP = NULL;
    }

    ServerLocationInfo::~ServerLocationInfo()
    {
        if (_locationInfoData.machineName)
            ActMemFree(_locationInfoData.machineName);
        if (_pObjectContext)
            _pObjectContext->InternalRelease();

        // do not release _pISSP
    }

    //-----------------------------------------------------------------------   
    // Methods
    //-----------------------------------------------------------------------   
    STDMETHODIMP ServerLocationInfo::SetRemoteServerName(IN WCHAR  *pwszMachineName)
    {
        HRESULT hr;

        if (_locationInfoData.machineName)
        {
            ActMemFree(_locationInfoData.machineName);
            _locationInfoData.machineName = NULL;
        }

        Win4Assert(_locationInfoData.machineName == NULL);

        if (pwszMachineName)
        {
            //
            // Some apps may unnecessarily put slashes before their
            // server names.  We'll allow this and strip them off.
            //
            if (pwszMachineName[0]  == L'\\' &&
                pwszMachineName[1] == L'\\' )
                pwszMachineName += 2;

            if ( 0 == *pwszMachineName)
                return CO_E_BAD_SERVER_NAME;

            BOOL fIsSelf;

            _locationInfoData.machineName =
                makeWStringCopy(pwszMachineName);
            if (_locationInfoData.machineName == NULL)
                return E_OUTOFMEMORY;
        }

        return S_OK;
    }
  
    STDMETHODIMP ServerLocationInfo::SetProcess(IN DWORD processId, OUT DWORD dwPRT)
    {
        HRESULT hr;
        ISpecialSystemProperties* pISSP = NULL;

        // This is necessary since we didn't want to break the wire-format
        // after RC2.   If it wasn't for that, we could have put the storage for
        // dwPRT right into _locationInfoData. 

        // Note:   calling this method before this object is aggregated into the
        // actpropsin object means that this QI will fail (see 
        // ServerLocationInfo::QueryInterface up above, _pParent will still be NULL)
        hr = this->QueryInterface(IID_ISpecialSystemProperties, (void**)&pISSP);
        if (SUCCEEDED(hr))
        {
            hr = pISSP->SetProcessRequestType(dwPRT);
            if (SUCCEEDED(hr))
            {
                _locationInfoData.processId = processId;
            }
            pISSP->Release();
        }

        return hr;       
	}

    STDMETHODIMP ServerLocationInfo::GetProcess(OUT DWORD *pProcessId, OUT DWORD* pdwPRT)
    {
        HRESULT hr;
        ISpecialSystemProperties* pISSP = NULL;

        // This is necessary since we didn't want to break the wire-format
        // after RC2.   If it wasn't for that, we could have put the storage for
        // dwPRT right into _locationInfoData. 

        // Note:   calling this method before this object is aggregated into the
        // actpropsin object means that this QI will fail (see 
        // ServerLocationInfo::QueryInterface up above, _pParent will still be NULL)
        hr = this->QueryInterface(IID_ISpecialSystemProperties, (void**)&pISSP);
        if (SUCCEEDED(hr))
        {
            hr = pISSP->GetProcessRequestType(pdwPRT);
            if (SUCCEEDED(hr))
            {
                *pProcessId = _locationInfoData.processId;
            }
            pISSP->Release();
        }

        return hr;       
    }

    
    //-----------------------------------------------------------------------   
    // Methods from ISerializable                          
    //-----------------------------------------------------------------------   
    STDMETHODIMP ServerLocationInfo::Serialize(void *pv)
    {
        Serializer *pSer = (Serializer*) pv;
        handle_t handle;
        HRESULT hr = pSer->GetSerializationHandle((void*) &handle);
        Win4Assert(hr==S_OK);

        LocationInfoData_Encode(handle, &_locationInfoData);
        return S_OK;
    }

    STDMETHODIMP ServerLocationInfo::UnSerialize(void *pv)
    {
        Serializer *pSer = (Serializer*) pv;
        if (!_unSerialized)
        {
            _locationInfoData.machineName=0;
            handle_t handle;
            pSer->GetSerializationHandle((void*) &handle);
            LocationInfoData_Decode(handle, &_locationInfoData);

            _unSerialized = TRUE;
        }
        return S_OK;
    }

    STDMETHODIMP ServerLocationInfo::GetSize(IN void *pv, OUT DWORD *pdwSize)
    {
        Serializer *pSer = (Serializer*) pv;
        if (!IsInproc(pSer))
        {
            handle_t   handle;
            HRESULT hr = pSer->GetSizingHandle((void*) &handle);
            if (FAILED(hr))
                return hr;
            *pdwSize = LocationInfoData_AlignSize(handle, &_locationInfoData);
            MesHandleFree(handle);
        }
        else
            *pdwSize = 0;

        return S_OK;
    }

    STDMETHODIMP ServerLocationInfo::GetCLSID(OUT CLSID *pclsid)
    {
        *pclsid = IID_IServerLocationInfo;
        return S_OK;
    }

//---------------------------------------------------------------------------   
//             Methods for SecurityInfo                    
//---------------------------------------------------------------------------   

    //-----------------------------------------------------------------------   
    // Methods from IUnknown                               
    //-----------------------------------------------------------------------   
    STDMETHODIMP SecurityInfo::QueryInterface( REFIID riid, LPVOID* ppvObj)
    {
        if (_parent)
          return _parent->QueryInterface(riid, ppvObj);
        else
          return SerializableQueryInterface(riid, ppvObj);
    }

    STDMETHODIMP SecurityInfo::SerializableQueryInterface( REFIID riid, LPVOID* ppvObj)
    {
       if (IsEqualIID(riid, IID_IActivationSecurityInfo) ||
           IsEqualIID(riid, IID_IUnknown))
       {
           *ppvObj = (IActivationSecurityInfo*) this;
           AddRef();
           return S_OK;
       }
       else
       if (IsEqualIID(riid, IID_ISerializable))
       {
           *ppvObj = (ISerializable*) this;
           AddRef();
           return S_OK;
       }
       else
       if (IsEqualIID(riid, IID_ILegacyInfo))
       {
           *ppvObj = (ILegacyInfo*) this;
           AddRef();
           return S_OK;
       }

       *ppvObj = NULL;
       return E_NOINTERFACE;
    }

    ULONG SecurityInfo::AddRef(void)
    {
        if (_parent)
            return _parent->AddRef();

        return 1;
    }

    ULONG SecurityInfo::Release(void)
    {
        if (_parent)
           return _parent->Release();
       return 0;
    }

    //-----------------------------------------------------------------------   
    // Methods from ISerializable                          
    //-----------------------------------------------------------------------   
    STDMETHODIMP SecurityInfo::Serialize(IN void *pv)
    {
        Serializer *pSer = (Serializer*) pv;
       handle_t handle;
       HRESULT hr = pSer->GetSerializationHandle((void*) &handle);
       Win4Assert(hr==S_OK);
       SecurityInfoData_Encode(handle, &_securityInfoData);
       return S_OK;
    }

    STDMETHODIMP SecurityInfo::UnSerialize(IN void *pv)
    {
        Serializer *pSer = (Serializer*) pv;
        if (!_unSerialized)
        {
            handle_t handle;
            HRESULT hr = pSer->GetSerializationHandle((void*) &handle);
            Win4Assert(hr==S_OK);
            _securityInfoData.pServerInfo = 0;
            _securityInfoData.pAuthIdentityInfo = 0;
            SecurityInfoData_Decode(handle, &_securityInfoData);
     
            _unSerialized = TRUE;
        }
        return S_OK;
    }

    STDMETHODIMP SecurityInfo::GetSize(IN void *pv, OUT DWORD *pdwSize)
    {
        Serializer *pSer = (Serializer*) pv;
        if (!IsInproc(pSer))
        {
            handle_t   handle;
            HRESULT hr = pSer->GetSizingHandle((void*) &handle);
            if (FAILED(hr))
                return hr;
            *pdwSize = SecurityInfoData_AlignSize(handle, &_securityInfoData);
            MesHandleFree(handle);
        }
        else
            *pdwSize = 0;

        return S_OK;
    }

    STDMETHODIMP SecurityInfo::GetCLSID(OUT CLSID *pclsid)
    {
        *pclsid = IID_IActivationSecurityInfo;
        return S_OK;
    }

//---------------------------------------------------------------------------   
//             Methods for ScmRequestInfo                  
//---------------------------------------------------------------------------   
    
    //-----------------------------------------------------------------------   
    // Methods from IUnknown                               
    //-----------------------------------------------------------------------   
    STDMETHODIMP ScmRequestInfo::QueryInterface( REFIID riid, LPVOID* ppvObj)
    {
        if (_parent)
          return _parent->QueryInterface(riid, ppvObj);
        else
          return SerializableQueryInterface(riid, ppvObj);
    }

    STDMETHODIMP ScmRequestInfo::SerializableQueryInterface( REFIID riid, LPVOID*
ppvObj)
    {
       if (IsEqualIID(riid, IID_IScmRequestInfo) ||
           IsEqualIID(riid, IID_IUnknown))
       {
           *ppvObj = (IScmRequestInfo*) this;
           AddRef();
           return S_OK;
       }
       else
       if (IsEqualIID(riid, IID_ISerializable))
       {
           *ppvObj = (ISerializable*) this;
           AddRef();
           return S_OK;
       }

       *ppvObj = NULL;
       return E_NOINTERFACE;
    }

    ULONG ScmRequestInfo::AddRef(void)
    {
        if (_parent)
            return _parent->AddRef();

        return 1;
    }

    ULONG ScmRequestInfo::Release(void)
    {
        if (_parent)
           return _parent->Release();

#if 0 //Always allocate on stack
       ULONG count;
       if ((count=InterlockedDecrement(&_cRefs)) == 0)
       {
            delete this;
           return 0;
       }

       return count;
#else
       return 0;
#endif
    }

    //-----------------------------------------------------------------------   
    // Methods from ISerializable                          
    //-----------------------------------------------------------------------   
    STDMETHODIMP ScmRequestInfo::Serialize(IN void *pv)
    {
        Serializer *pSer = (Serializer*) pv;
       handle_t handle;
       HRESULT hr = pSer->GetSerializationHandle((void*) &handle);
       Win4Assert(hr==S_OK);
       ScmRequestInfoData_Encode(handle, &_scmRequestInfoData);
       return S_OK;
    }

    STDMETHODIMP ScmRequestInfo::UnSerialize(IN void *pv)
    {
        Serializer *pSer = (Serializer*) pv;
        if (!_unSerialized)
        {
            handle_t handle;
           HRESULT hr = pSer->GetSerializationHandle((void*) &handle);
           Win4Assert(hr==S_OK);
           _scmRequestInfoData.pScmInfo = 0;
           _scmRequestInfoData.remoteRequest = 0;
           ScmRequestInfoData_Decode(handle, &_scmRequestInfoData);
           _unSerialized = TRUE;
        }
        return S_OK;
    }

    STDMETHODIMP ScmRequestInfo::GetSize(IN void *pv, OUT DWORD *pdwSize)
    {
        Serializer *pSer = (Serializer*) pv;
        if (!IsInproc(pSer))
        {
            handle_t   handle;
            HRESULT hr = pSer->GetSizingHandle((void*) &handle);
            if (FAILED(hr))
                return hr;
            *pdwSize = ScmRequestInfoData_AlignSize(handle, &_scmRequestInfoData);
            MesHandleFree(handle);
        }
        else
            *pdwSize = 0;

        return S_OK;
    }

    STDMETHODIMP ScmRequestInfo::GetCLSID(OUT CLSID *pclsid)
    {
        *pclsid = IID_IScmRequestInfo;
        return S_OK;
    }

//---------------------------------------------------------------------------   
//             Methods for ScmReplyInfo                    
//---------------------------------------------------------------------------   
    
    //-----------------------------------------------------------------------   
    // Methods from IUnknown                               
    //-----------------------------------------------------------------------   
    STDMETHODIMP ScmReplyInfo::QueryInterface( REFIID riid, LPVOID* ppvObj)
    {
        if (_parent)
          return _parent->QueryInterface(riid, ppvObj);
        else
          return SerializableQueryInterface(riid, ppvObj);
    }

    STDMETHODIMP ScmReplyInfo::SerializableQueryInterface( REFIID riid, LPVOID*
ppvObj)
    {
       if (IsEqualIID(riid, IID_IScmReplyInfo) ||
           IsEqualIID(riid, IID_IUnknown))
       {
           *ppvObj = (IScmReplyInfo*) this;
           AddRef();
           return S_OK;
       }
       else
       if (IsEqualIID(riid, IID_ISerializable))
       {
           *ppvObj = (ISerializable*) this;
           AddRef();
           return S_OK;
       }

       *ppvObj = NULL;
       return E_NOINTERFACE;
    }

    ULONG ScmReplyInfo::AddRef(void)
    {
        if (_parent)
            return _parent->AddRef();

        return 1;
    }

    ULONG ScmReplyInfo::Release(void)
    {
        if (_parent)
           return _parent->Release();

#if 0 //Always allocate on stack
       ULONG count;
       if ((count=InterlockedDecrement(&_cRefs)) == 0)
       {
            delete this;
           return 0;
       }

       return count;
#else
       return 0;
#endif
    }

       
    //-----------------------------------------------------------------------   
    // Methods from ISerializable                          
    //-----------------------------------------------------------------------   
    STDMETHODIMP ScmReplyInfo::Serialize(IN void *pv)
    {
        Serializer *pSer = (Serializer*) pv;
       handle_t handle;
       HRESULT hr = pSer->GetSerializationHandle((void*) &handle);
       Win4Assert(hr==S_OK);
       ScmReplyInfoData_Encode(handle, &_scmReplyInfoData);
       return S_OK;
    }

    STDMETHODIMP ScmReplyInfo::UnSerialize(IN void *pv)
    {
        Serializer *pSer = (Serializer*) pv;
        if (!_unSerialized)
        {
            handle_t handle;
           HRESULT hr = pSer->GetSerializationHandle((void*) &handle);
           Win4Assert(hr==S_OK);
           _scmReplyInfoData.remoteReply = 0;
           _scmReplyInfoData.pResolverInfo = 0;
           ScmReplyInfoData_Decode(handle, &_scmReplyInfoData);
           _unSerialized = TRUE;
        }
        return S_OK;
    }

    STDMETHODIMP ScmReplyInfo::GetSize(IN void *pv, OUT DWORD *pdwSize)
    {
        Serializer *pSer = (Serializer*) pv;
        handle_t   handle;
        HRESULT hr = pSer->GetSizingHandle((void*) &handle);
        if (FAILED(hr))
            return hr;
        *pdwSize = ScmReplyInfoData_AlignSize(handle, &_scmReplyInfoData);
        MesHandleFree(handle);

        return S_OK;
    }

    STDMETHODIMP ScmReplyInfo::GetCLSID(OUT CLSID *pclsid)
    {
        *pclsid = IID_IScmReplyInfo;
        return S_OK;
    }


//---------------------------------------------------------------------------   
//             Methods for ContextInfo                     
//---------------------------------------------------------------------------   
    
    //-----------------------------------------------------------------------   
    // Methods from IUnknown                               
    //-----------------------------------------------------------------------   
    STDMETHODIMP ContextInfo::QueryInterface( REFIID riid, LPVOID* ppvObj)
    {
        if (_parent)
          return _parent->QueryInterface(riid, ppvObj);
        else
          return SerializableQueryInterface(riid, ppvObj);
    }

    STDMETHODIMP ContextInfo::SerializableQueryInterface(REFIID riid, 
                                                         LPVOID* ppvObj)
    {
       if (IsEqualIID(riid, IID_IPrivActivationContextInfo))
       {
           *ppvObj = (IPrivActivationContextInfo*) this;
           AddRef();
           return S_OK;
       }
       else if (IsEqualIID(riid, IID_IActivationContextInfo)
           || IsEqualIID(riid, IID_IUnknown))
       {
           *ppvObj = (IActivationContextInfo*) this;
           AddRef();
           return S_OK;
       }
       else if (IsEqualIID(riid, IID_IOverrideTargetContext))
       {
           *ppvObj = (IOverrideTargetContext*) this;
           AddRef();
           return S_OK;
       }
       else if (IsEqualIID(riid, IID_ISerializable))
       {
           *ppvObj = (ISerializable*) this;
           AddRef();
           return S_OK;
       }

       *ppvObj = NULL;
       return E_NOINTERFACE;
    }

    ULONG ContextInfo::AddRef(void)
    {
        if (_parent)
            return _parent->AddRef();

        return 1;
    }

    ULONG ContextInfo::Release(void)
    {
        if (_parent)
           return _parent->Release();

       return 0;
    }

    HRESULT ContextInfo::GetClientContext(OUT IContext **ppCtx)
    {
        CObjectContext *pCtx;
        HRESULT hr = GetInternalClientContext(&pCtx);
        if (SUCCEEDED(hr) && pCtx)
        {
            pCtx->AddRef();
            pCtx->InternalRelease();
            *ppCtx = (IContext*)pCtx;
        }
        
        return hr;
    }
    
    HRESULT ContextInfo::GetInternalClientContext(OUT CObjectContext **ppCtx)
    {
        HRESULT hr = S_OK;

        InitMarshalling();

        if ((_unSerialized) && 
            (_pClientCtx==NULL)   && 
            (_contextInfoData.pIFDClientCtx != NULL))
        {
            if (pfnCoUnmarshalInterface)
            {
                ActivationStream stream((InterfaceData*)_contextInfoData.pIFDClientCtx);
                hr = pfnCoUnmarshalInterface(&stream, 
                                             IID_IStdObjectContext,
                                             (void**)&_pClientCtx);
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
            }

            if (SUCCEEDED(hr))
            {
                // Unmarshaling the context gives a user reference.  We want
                // an internal ref, so we take one and release the user ref.
                _pClientCtx->InternalAddRef();
                _pClientCtx->Release();
            }

            ActMemFree(_contextInfoData.pIFDClientCtx);
            _contextInfoData.pIFDClientCtx = NULL;
        }

        if (_pClientCtx)
            _pClientCtx->InternalAddRef();
        else
           SetClientContextNotOK();

        *ppCtx = _pClientCtx;

        return hr;
    }

    STDMETHODIMP ContextInfo::GetPrototypeContext(OUT IContext **ppCtx)
    {
        CObjectContext *pCtx;
        HRESULT hr = GetInternalPrototypeContext(&pCtx);
        if (SUCCEEDED(hr))
        {
            pCtx->AddRef();
            pCtx->InternalRelease();
            *ppCtx = (IContext*)pCtx;
        }
        return hr;
    }

    HRESULT ContextInfo::GetInternalPrototypeContext(OUT CObjectContext **ppCtx)
    {
        extern HRESULT CObjectContextCF_CreateInstance(IUnknown *pUnkOuter, 
                                                       REFIID riid, 
                                                       void** ppv);

        InitMarshalling();
                                                   
        HRESULT hr = S_OK;

        if ((_unSerialized) && 
            (_pPrototypeCtx==NULL)   && 
            (_contextInfoData.pIFDPrototypeCtx != NULL))
        {
            if (pfnCoUnmarshalInterface)
            {
                ActivationStream stream((InterfaceData*)_contextInfoData.pIFDPrototypeCtx);
                hr = pfnCoUnmarshalInterface(&stream, 
                                             IID_IStdObjectContext, 
                                             (void**)&_pPrototypeCtx);
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
            }

            if (SUCCEEDED(hr))
            {
                // Unmarshaling the context gives a user reference.  We want
                // an internal ref, so we take one and release the user ref.
                _pPrototypeCtx->InternalAddRef();
                _pPrototypeCtx->Release();
            }

            ActMemFree(_contextInfoData.pIFDPrototypeCtx);
            _contextInfoData.pIFDPrototypeCtx = NULL;
        }
        else 
        if (!_pPrototypeCtx)
        {
            hr = CObjectContextCF_CreateInstance(NULL,
                                                 IID_IStdObjectContext,
                                                 (void**) &_pPrototypeCtx);
            if (SUCCEEDED(hr))
            {
                // Creating the context gives a user reference.  We want
                // an internal ref, so we take one and release the user ref.
                _pPrototypeCtx->InternalAddRef();
                _pPrototypeCtx->Release();
            }
        }

        if (SUCCEEDED(hr))        
            _pPrototypeCtx->InternalAddRef();

        *ppCtx = _pPrototypeCtx;

        return hr;
    }
    
    //-----------------------------------------------------------------------   
    // Methods from ISerializable                          
    //-----------------------------------------------------------------------   
    STDMETHODIMP ContextInfo::Serialize(IN void *pv)
    {
        Serializer *pSer = (Serializer*) pv;
        //-------------------------------------------------------------------   
        //       Encode header                             
        //-------------------------------------------------------------------   
        handle_t handle;
        HRESULT hr = pSer->GetSerializationHandle((void*) &handle);
        Win4Assert(hr==S_OK);
        ActivationContextInfoData_Encode(handle, &_contextInfoData);
        _unSerialized = FALSE;
        return S_OK;
    }

    STDMETHODIMP ContextInfo::UnSerialize(IN void *pv)
    {
        Serializer *pSer = (Serializer*) pv;
        if (!_unSerialized)
        {
            handle_t handle;
            HRESULT hr = pSer->GetSerializationHandle((void*) &handle);
            Win4Assert(hr==S_OK);
            _pClientCtx = 0;
            _pPrototypeCtx = 0;
            ActivationContextInfoData_Decode(handle, &_contextInfoData);
            _unSerialized = TRUE;
        }

        return S_OK;
    }

    STDMETHODIMP ContextInfo::GetSize(IN void *pv, OUT DWORD *pdwSize)
    {
        Serializer *pSer = (Serializer*) pv;
        HRESULT rethr=S_OK;

       //--------------------------------------------------------------------   
       // If Is an inproc path, no need to marshal context
       //--------------------------------------------------------------------   
        if (IsInproc(pSer))
        {
            *pdwSize = 0;
            return S_OK;
        }

        _toReleaseIFD = FALSE;

        if (_pClientCtx)
        {
            rethr = GetIFDFromInterface((IUnknown*)(IObjContext*) _pClientCtx,
                                         IID_IContext,
                                         MSHCTX_DIFFERENTMACHINE,
                                         MSHLFLAGS_NORMAL,
                                         &_contextInfoData.pIFDClientCtx);
            if (FAILED(rethr))
            {
               _contextInfoData.pIFDClientCtx = NULL;
                return rethr;
            }
        }
   
        if (_pPrototypeCtx)
        {
            rethr = GetIFDFromInterface((IUnknown*)(IObjContext*) _pPrototypeCtx,
                                         IID_IContext,
                                         MSHCTX_DIFFERENTMACHINE,
                                         MSHLFLAGS_NORMAL,
                                         &_contextInfoData.pIFDPrototypeCtx);
   
            if (FAILED(rethr))
            {
               _contextInfoData.pIFDPrototypeCtx = NULL;
                return rethr;
            }
        }

        handle_t   handle;
        rethr = pSer->GetSizingHandle((void*) &handle);

        if (SUCCEEDED(rethr))
        {
            *pdwSize = ActivationContextInfoData_AlignSize(handle, 
                                                        &_contextInfoData);
            MesHandleFree(handle);
        }
        
        return rethr;
    }

    STDMETHODIMP ContextInfo::GetCLSID(OUT CLSID *pclsid)
    {
        *pclsid = IID_IActivationContextInfo;
        return S_OK;
    }


//---------------------------------------------------------------------------   
//             Methods for InstanceInfo                     
//---------------------------------------------------------------------------   
    
    //-----------------------------------------------------------------------   
    // Methods from IUnknown                               
    //-----------------------------------------------------------------------   
    STDMETHODIMP InstanceInfo::QueryInterface( REFIID riid, LPVOID* ppvObj)
    {
        if (_parent)
          return _parent->QueryInterface(riid, ppvObj);
        else
          return SerializableQueryInterface(riid, ppvObj);
    }

    STDMETHODIMP InstanceInfo::SerializableQueryInterface( REFIID riid, LPVOID*
ppvObj)
    {
       if (IsEqualIID(riid, IID_IInstanceInfo) ||
           IsEqualIID(riid, IID_IUnknown))
       {
           *ppvObj = (IInstanceInfo*) this;
           AddRef();
           return S_OK;
       }
       else
       if (IsEqualIID(riid, IID_ISerializable))
       {
           *ppvObj = (ISerializable*) this;
           AddRef();
           return S_OK;
       }

       *ppvObj = NULL;
       return E_NOINTERFACE;
    }

    ULONG InstanceInfo::AddRef(void)
    {
        if (_parent)
            return _parent->AddRef();

        return 1;
    }

    ULONG InstanceInfo::Release(void)
    {
        if (_parent)
           return _parent->Release();

#if 0 //Always allocate on stack
       ULONG count;
       if ((count=InterlockedDecrement(&_cRefs)) == 0)
       {
            delete this;
           return 0;
       }

       return count;
#else
       return 0;
#endif
    }

    
    //-----------------------------------------------------------------------   
    // Methods from IInstanceInfo                          
    //-----------------------------------------------------------------------   
    STDMETHODIMP InstanceInfo::SetStorage(IN IStorage *pstg)
    {
        _pstg = pstg;

        if (_pstg)
            _pstg->AddRef();

        return S_OK;
    }

    STDMETHODIMP InstanceInfo::GetStorage(OUT IStorage **ppstg)
    {
        HRESULT hr = S_OK;

        InitMarshalling();

        if ((_pstg==NULL)   && 
            (_instanceInfoData.ifdStg != NULL))
        {
            if (pfnCoUnmarshalInterface)
            {
                ActivationStream stream((InterfaceData*)_instanceInfoData.ifdStg);
                hr = pfnCoUnmarshalInterface(&stream, IID_IStorage, (void**)&_pstg);
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
            }
        }

        if (_pstg)
            _pstg->AddRef();

        *ppstg = _pstg;
        return hr;
    }

       
    //-----------------------------------------------------------------------   
    // Methods from ISerializable                          
    //-----------------------------------------------------------------------   
    STDMETHODIMP InstanceInfo::Serialize(IN void *pv)
    {
        Serializer *pSer = (Serializer*) pv;
        handle_t handle;
        HRESULT hr = pSer->GetSerializationHandle((void*) &handle);
        Win4Assert(hr==S_OK);
        InstanceInfoData_Encode(handle, &_instanceInfoData);
        _unSerialized = FALSE;
        return hr;
    }

    STDMETHODIMP InstanceInfo::UnSerialize(IN void *pv)
    {
        Serializer *pSer = (Serializer*) pv;
        HRESULT hr = S_OK;

        if (!_unSerialized)
        {
            handle_t handle;
            hr = pSer->GetSerializationHandle((void*) &handle);
            Win4Assert(hr==S_OK);
            InstanceInfoData_Decode(handle, &_instanceInfoData);
            _unSerialized = TRUE;
        }

        return hr;
    }

    //-----------------------------------------------------------------------   
    // NOTE: This function should only get called if a storage pointer is
    //       present during inproc/crossctx marshalling
    //-----------------------------------------------------------------------   
    STDMETHODIMP InstanceInfo::GetSize(IN void *pv, OUT DWORD *pdwSize)
    {
        Serializer *pSer = (Serializer*) pv;
        HRESULT rethr=S_OK;

        DWORD dwCurrDestCtx;
        pSer->GetCurrDestCtx(&dwCurrDestCtx);
        
        //-------------------------------------------------------------------   
        //Need to marshal interface first to compute size   
        //-------------------------------------------------------------------   
        if (_pstg)
        {
           //----------------------------------------------------------------   
           // Need to free previously marshalled data       
           //----------------------------------------------------------------   
            if (_instanceInfoData.ifdStg) 
               ActMemFree(_instanceInfoData.ifdStg);

            if (dwCurrDestCtx == MSHCTX_LOCAL)
                dwCurrDestCtx = MSHCTX_DIFFERENTMACHINE;

            rethr = GetIFDFromInterface((IUnknown*) _pstg,
                                               IID_IStorage,
                                         dwCurrDestCtx,
                                         MSHLFLAGS_NORMAL,
                                         &_instanceInfoData.ifdStg);
            if (FAILED(rethr))
            {
                _instanceInfoData.ifdStg = NULL; 
                return rethr;
            }

            _pstg->Release();
            _pstg = NULL;
        
        }

        if (IsInproc(pSer))
        {
            *pdwSize = 0;
        }
        else
        {
        //-------------------------------------------------------------------   
        // Encode header                                    
        //-------------------------------------------------------------------   
            handle_t   handle;
            rethr = pSer->GetSizingHandle((void*) &handle);
            if (SUCCEEDED(rethr))
            {
                *pdwSize = InstanceInfoData_AlignSize(handle, 
                                                &_instanceInfoData);
                MesHandleFree(handle);
            }
        }

        return rethr;
    }

    STDMETHODIMP InstanceInfo::GetCLSID(OUT CLSID *pclsid)
    {
        *pclsid = IID_IInstanceInfo;
        return S_OK;
    }

    //-----------------------------------------------------------------------
    // Methods from IOpaqueDataInfo
    //-----------------------------------------------------------------------
    STDMETHODIMP OpaqueDataInfo::AddOpaqueData (OpaqueData *pData)
    {
        HRESULT hr;

        if (_cOpaqueData == _dwCollSize)
        {
            OpaqueData *pNew = (OpaqueData*)
                    ActMemAlloc(sizeof(OpaqueData) *(_dwCollSize+20)); 

            if (pNew == NULL)
            {
                return E_OUTOFMEMORY;
            }

            _dwCollSize += 20;

            CopyOpaqueData(pNew, _pOpaqueData, 
                           _cOpaqueData, FALSE);

            ActMemFree(_pOpaqueData);

            _pOpaqueData = pNew;
        }


        hr = CopyOpaqueData(&_pOpaqueData[_cOpaqueData], pData, 
                            1, TRUE);

        if (FAILED(hr))
            return hr;

        _cOpaqueData++;

        return S_OK;
    }

    STDMETHODIMP OpaqueDataInfo::GetOpaqueData (REFGUID guid,
                                   OpaqueData **pData)
    {
        for (DWORD i=0; i < _cOpaqueData ; i++)
        {
            if (_pOpaqueData[i].guid == guid)
            {
                *pData = &_pOpaqueData[i];
                return S_OK;
            }
        }

        return E_FAIL;
    }

    STDMETHODIMP  OpaqueDataInfo::DeleteOpaqueData (REFGUID guid)
    {
        BOOL found = FALSE;

        for (DWORD i=0; i < _cOpaqueData ; i++)
        {
            if (_pOpaqueData[i].guid == guid)
            {
                found = TRUE;
                break;
            }
        }

        if (!found)
            return E_FAIL;

        ActMemFree(_pOpaqueData[i].data);

        for (i=i+1; i < _cOpaqueData ; i++)
        {
            CopyOpaqueData(&_pOpaqueData[i-1],
                           &_pOpaqueData[i],
                           1, FALSE);
        }


        _cOpaqueData--;

        return S_OK;
    }

    STDMETHODIMP  OpaqueDataInfo::GetOpaqueDataCount (ULONG *pulCount)
    {
        *pulCount = _cOpaqueData;

        return S_OK;
    }

    STDMETHODIMP  OpaqueDataInfo::GetAllOpaqueData (OpaqueData **prgData)
    {
        *prgData = _pOpaqueData;

        return S_OK;
    }

    //-----------------------------------------------------------------------
    // Methods from ISerializable
    //-----------------------------------------------------------------------
    STDMETHODIMP OpaqueDataInfo::Serialize(IN void *pv)
    {
        _unSerialized = FALSE;
        return S_OK;
    }

    STDMETHODIMP OpaqueDataInfo::UnSerialize(IN void *pv)
    {
        if (!_parent)
            return E_INVALIDARG;

        HRESULT hr = S_OK;
        if (!_unSerialized)
        {
            hr = ((ActivationProperties*)_pAct)->GetOpaqueDataInfo(&_cOpaqueData, &_pOpaqueData);
            _unSerialized = TRUE;
        }

        return hr;
    }

    STDMETHODIMP OpaqueDataInfo::GetSize(IN void *pv, OUT DWORD *pdwSize)
    {
        if (!_parent)
            return E_INVALIDARG;

        *pdwSize = 0;

        Serializer *pSer = (Serializer*) pv;

        if ((!IsInproc(pSer)) && _cOpaqueData) 
        {
            ((ActivationProperties*)_pAct)->SetOpaqueDataInfo(_cOpaqueData,
                                                                _pOpaqueData);

            _cOpaqueData = 0;
            _pOpaqueData = NULL;
        }

        return S_OK;
    }

    STDMETHODIMP OpaqueDataInfo::GetCLSID(OUT CLSID *pclsid)
    {
        *pclsid = IID_IOpaqueDataInfo;
        return S_OK;
    }

    STDMETHODIMP OpaqueDataInfo::SetParent(ISerializableParent *pParent)
    {
        _parent = pParent;

        if (pParent)
            return pParent->QueryInterface(CLSID_ActivationProperties, 
                                           &_pAct);

        return S_OK;
    }

    //-----------------------------------------------------------------------
    // Methods from IUnknown
    //-----------------------------------------------------------------------
    STDMETHODIMP OpaqueDataInfo::QueryInterface( REFIID riid, LPVOID* ppvObj)
    {
        if (_parent)
          return _parent->QueryInterface(riid, ppvObj);
        else
          return SerializableQueryInterface(riid, ppvObj);
    }

    STDMETHODIMP OpaqueDataInfo::SerializableQueryInterface( REFIID riid, LPVOID* ppvObj)
    {
       //Use IID_OpaqueDataInfo to return the real object right now
       if (IsEqualIID(riid, IID_IOpaqueDataInfo))
       {
          *ppvObj = (OpaqueDataInfo*) this;
          AddRef();
          return S_OK;
       }
       else
       if  (IsEqualIID(riid, IID_IUnknown))
       {
           *ppvObj = (IOpaqueDataInfo*) this;
           AddRef();
           return S_OK;
       }
       else
       if (IsEqualIID(riid, IID_ISerializable))
       {
           *ppvObj = (ISerializable*) this;
           AddRef();
           return S_OK;
       }
       *ppvObj = NULL;

       return E_NOINTERFACE;
    }

    ULONG OpaqueDataInfo::AddRef(void)
    {
        if (_parent)
            return _parent->AddRef();

        return 1;
    }

    ULONG OpaqueDataInfo::Release(void)
    {
        if (_parent)
           return _parent->Release();

       return 0;
    }


    //-----------------------------------------------------------------------
    // Methods from IUnknown
    //-----------------------------------------------------------------------
    STDMETHODIMP SpecialProperties::QueryInterface( REFIID riid, LPVOID* ppvObj)
    {
        if (_parent)
          return _parent->QueryInterface(riid, ppvObj);
        else
          return SerializableQueryInterface(riid, ppvObj);
    }

    STDMETHODIMP SpecialProperties::SerializableQueryInterface( REFIID riid, LPVOID
* ppvObj)
    {
       //Use IID_ISpecialSystemProperties to return the real object right now
       if (IsEqualIID(riid, IID_ISpecialSystemProperties))
       {
          *ppvObj = (SpecialProperties*) this;
          AddRef();
          return S_OK;
       }
       else
       if  (IsEqualIID(riid, IID_IUnknown))
       {
           *ppvObj = (ISpecialSystemProperties*) this;
           AddRef();
           return S_OK;
       }
       else
       if (IsEqualIID(riid, IID_ISerializable))
       {
           *ppvObj = (ISerializable*) this;
           AddRef();
           return S_OK;
       }
       *ppvObj = NULL;

       return E_NOINTERFACE;
    }

    ULONG SpecialProperties::AddRef(void)
    {
        if (_parent)
            return _parent->AddRef();

        return 1;
    }

    ULONG SpecialProperties::Release(void)
    {
        if (_parent)
           return _parent->Release();

       return 0;
    }

    //-----------------------------------------------------------------------
    // Methods from ISerializable
    //-----------------------------------------------------------------------
    STDMETHODIMP SpecialProperties::Serialize(IN void *pv)
    {
        Serializer *pSer = (Serializer*) pv;
       handle_t handle;
       HRESULT hr = pSer->GetSerializationHandle((void*) &handle);
       Win4Assert(hr==S_OK);
       SpecialPropertiesData_Encode(handle, &_data);
       return S_OK;
    }

    STDMETHODIMP SpecialProperties::UnSerialize(IN void *pv)
    {
        Serializer *pSer = (Serializer*) pv;
        if (!_unSerialized)
        {
            handle_t handle;
           HRESULT hr = pSer->GetSerializationHandle((void*) &handle);
           Win4Assert(hr==S_OK);
           SpecialPropertiesData_Decode(handle, &_data);
           _unSerialized = TRUE;
        }
        return S_OK;
    }

    STDMETHODIMP SpecialProperties::GetSize(IN void *pv, OUT DWORD *pdwSize)
    {
        Serializer *pSer = (Serializer*) pv;

        if (!IsInproc(pSer))
        {
            handle_t   handle;
            HRESULT hr = pSer->GetSizingHandle((void*) &handle);
            if (FAILED(hr))
                return hr;
            *pdwSize = SpecialPropertiesData_AlignSize(handle, &_data);
            MesHandleFree(handle);
        }
        else
            *pdwSize = 0;

        return S_OK;
    }

    STDMETHODIMP SpecialProperties::GetCLSID(OUT CLSID *pclsid)
    {
        *pclsid = IID_ISpecialSystemProperties;
        return S_OK;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\precomp2.inc ===
#//+---------------------------------------------------------------
#//
#//  File:	precom2.inc
#//
#//  Contents:	directives for global precompiled include file when the
#//		sources file is two directories below com (or wherever
#//		this file is located).  We could easily have precomp3 and
#//		precomp4 for other areas.  The ole2int.* files should not
#//		otherwise be mentioned in the sources files.
#//
#//  History:	18-May-94   CraigWi	Created
#//
#//----------------------------------------------------------------

!ifdef OLE32ROOT
PCH_ROOT=$(OLE32ROOT)\com
!else
PCH_ROOT=..\..
!endif

# The precompiled header needs something out of these inc paths...
INCLUDES=$(INCLUDES);..\..\..\idl\private\$(DEST_TREE)\$(O)
INCLUDES=$(INCLUDES);..\..\..\idl\public\$(DEST_TREE)\$(O)
INCLUDES=$(INCLUDES);$(BASE_INC_PATH)

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\..\inc\ole2int.h
PRECOMPILED_TARGET=..\..\inc\$(GPCH_BUILD)\$(_OBJ_DIR)\*\com2int.pch
PRECOMPILED_OPTION=/Yuole2int.h /Fp..\..\inc\$(GPCH_BUILD)\$(_OBJ_DIR)\*\com2int.pch
PRECOMPILED_OBJ=$(PCH_ROOT)\inc\$(GPCH_BUILD)\$(_OBJ_DIR)\*\com2int.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\accctrl\caccctrl.h ===
/*---------------------------------------------------------------------------

 File: CAccCntrl.h

 Copyright (c) 1996-1996, Microsoft Corp. All rights reserved.

 Description: This file contains the class definitions of COAccessControl,
              CImpAccessControl, and CFAccessControl.
              Note that the class and structure declarations contained in
              are not meant to be used and seen directly by developers who
              only uses the IAccessControl interface.

 Classes:  COAccessControl - This is the principle class that implements
                             the DCOM IAccessControl component object.
                             Except the nondelegating IUnknown interface, the
                             COAccessControl class supports the IPersist,
                             IPersistStream and IAccessControl interfaces by
                             exposing its inner CImpAccessCOntrol pointer.
                             Through this arrangement, the COAccessControl
                             class is able to support aggregation by
                             controlling the object to which the IUnknown
                             calls of the inner CImpAccess control are
                             delegated at object contruction.

           CImpAccessControl - This is the class that nested inside
                               COAccessControl. CImpAccessControl
                               implements the IPersist, IPersistStream,
                               IAccessControl  interfaces and the IUnknown
                               interface which always delegates the call to
                               the IUnknown methods of the controlling object.
                               When COAccessControl is not part of an
                               aggregate CImpAccessControl IUnknown calls
                               should be delegated to its outer
                               COAccessControl, otherwise the IUnknown calls
                               should be delegated to the object controlling
                               the outer COAccessControl object.

           CFAccessControl - Class factory for manufacturing COAccessControl
                             objects.

 Notes: The definition of IAccessControl interface can be found in
        oleext.h in ...sdk\inc and the data types that are defined to use with
        IAccessControl can be found in sdk\inc\accctrl.h.

--------------------------------------------------------------------------*/

#ifndef _CACCCNTRL_H_
#define _CACCCNTRL_H_

//////////////////////////////////////////////////////////////////////////////
// Internal data types
//////////////////////////////////////////////////////////////////////////////

/*////////////////////////////////////////////////////////////////////////////
 PCB- Pickle Control Block.
      Originally intended to be a structure for maintaining the information
      about the pickling buffer, the PCB has become something that transcends
      its intended purposes. Besides data related to the pickling buffer, the
      structure also contains a copy of the access control object's ACL in a
      format that can readily be serialized into a buffer by one of the type
      encoding function generated by the midl compiler, see acpickl.idl for
      details. The bDirtyHandle and the bPickled fields in the PCB structure
      are control flags which allows better coordination between different
      methods in CImpAccessControl. The purpose of the bDirtyHandle flag is
      to minimize the number of times the encoding handle has to be reset
      and the purpose of the bPickled flag is to minimize the number of times
      the ACL has to be serialized into a buffer.

////////////////////////////////////////////////////////////////////////////*/
typedef struct tagPCB
{
    char       *pPicklingBuff;      // This pointer is always aligned on the 8-byte
                                    // boundary
    char       *pTruePicklingBuff;  // This is the true pickling buffer pointer
    ULONG      ulPicklingBuffSize;  // Size of the pickling buffer after the 8-byte alignment
    ULONG      ulBytesUsed;         // This field indicates the number of bytes requires
                                    // to serialize the interanl ACL
    STREAM_ACL StreamACL;           // The stream format ACL
    handle_t   PickleHandle;        // Handle for encoding and decoding
    BOOL       bDirtyHandle;        // This flag indicates whether the handle needs to be reset
    BOOL       bPickled;            // This flag indicates whether the current stream ACL has been encoded
                                    // into the pickling buffer.
    ULONG      ulMaxNumOfStreamACEs;// The maximum number of stream ACEs that the StreamACL structure has been allocated for
    ULONG      ulNumOfStreamACEs;   // The number of stream ACEs that the StreamACL structure is holding

} PCB;

#if 0 // #ifdef _CHICAGO_

///////////////////////////////////////////////////////////////////////////////
// ACL_IMAGE - This structure is used on Chicago only
//  This structure can only be considered a partial representation of the
//  ACL using the native structure available on the Chicago plaform. Owing
//  to fact that the LAN Manager APIs available on the Chicago platform
//  can distinguish between GRANT_ACCESS mode ACEs and DENY_MODE ACEs, two
//  LAN Manager ACLs are used to create the illusion of having two different
//  types of ACEs can appear simultaneously in the ACL.
///////////////////////////////////////////////////////////////////////////////

typedef struct tagACL_IMAGE
{
    access_info_1 *pACL;         // Pointer to a LAN Manager ACL.
                                 // Format: |access_info_1|array of access_list|
    SHORT         sMaxNumOfACEs; // The maximum number of ACEs that the
                                 // structure can hold
    BOOL          bDirtyACL;     // This flag indicatess whether the ACL has
                                 // changed since the last time it was mapped to
                                 // the system registry use the NetAccess* functions
} ACL_IMAGE;

///////////////////////////////////////////////////////////////////////////////
// ACL_DESC - ACL Descriptor
//  The ACL descriptor is a structure that describes how access control
//  native to specific platform can be used to emulate the ACL as perceived
//  through the IAccessControl interface.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// The following structure is the ACL descriptor on the Chicago platform.
// This structure is divided into two symmetric portions, one portion holds
// the DENY_ACCESS mode ACEs while the other holds GRANT_ACCESS mode ACEs.
///////////////////////////////////////////////////////////////////////////////
typedef struct tagACLDescriptor
{
    ACL_IMAGE DenyACL;
    ACL_IMAGE GrantACL;
} ACL_DESCRIPTOR;

#else

///////////////////////////////////////////////////////////////////////////////
// The following is supposed to be the ACL descriptor on the Windows NT
// platform. Since the Windows NT version of DCOM IAccessControl implementation
// is still under developement, the content of the following structure may
// change in the future.
//////////////////////////////////////////////////////////////////////////////
typedef struct tagACL_DESCRIPTOR
{
    void                *pACLBuffer;     // Pointer to the NT ACL buffer
    ULONG               ulACLBufferSize; // Size of the ACL buffer
    ULONG               ulSIDSize;       // Exacted size of all the SIDs in the NT ACL
    BOOL                bDirtyACL;       // This flag indicates whether the internal
                                         // ACL has been chcanged since the last time
                                         // it was mapped to an NT ACL.
    SECURITY_DESCRIPTOR SecDesc;         // We need the security descriptor to call
                                         // AccessCheck

} ACL_DESCRIPTOR;



#endif

//////////////////////////////////////////////////////////////////////////////
// CFAccessControl - COAccessControl class factory.
//////////////////////////////////////////////////////////////////////////////

class CFAccessControl : public IClassFactory
{
private:

    // Private variables.
    LONG               m_cRefs; // Object reference count

public:

    // IUnknown methods

    STDMETHODIMP_(HRESULT) QueryInterface
    (
    REFIID iid,
    void   **ppv
    );

    STDMETHODIMP_(ULONG) AddRef(void);

    // If the object's reference count reaches zero, the RElease method will
    // decrement the global object count named g_cObjects in acsrv.cxx.
    STDMETHODIMP_(ULONG) Release(void);


    // IClassFactory methods
    // Upon successful creation of a new COAccessControl object,
    // the following function will increment the global object
    // count named g_cObjects by one.
    STDMETHODIMP_(HRESULT) CreateInstance
    (
    IUnknown *pUnkOuter,
    REFIID   riid,
    void     **ppv
    );

    // The following method relies on a global lock count named g_cServer
    // which is maintained inside acsrv.cxx.
    STDMETHODIMP_(HRESULT) LockServer
    (
    BOOL fLock
    );

    // Constructor
    CFAccessControl(void);

    // Destructor
    ~CFAccessControl(void);

}; // CFAccessControl

//////////////////////////////////////////////////////////////////////////////
// COAccessControl - The DCOM IAccessControl implementation component. The
//                   COAccessControl componnet is implemented as a nested
//                   class to support aggregation.
//////////////////////////////////////////////////////////////////////////////
class COAccessControl : public IUnknown
{
public:

    // Main object IUnknown Methods - These IUnknown methods are non-delegating
    STDMETHODIMP_(HRESULT) QueryInterface
    (
    REFIID riid,
    void   **ppv
    );

    STDMETHODIMP_(ULONG) AddRef(void);

    // The following method relies on a global lock count named g_cServer
    // which is maintained inside acsrv.cxx.
    STDMETHODIMP_(ULONG) Release(void);

    // Constructor
    COAccessControl(void);
    STDMETHODIMP_(HRESULT) Init(IUnknown *pOuter);

    // Destructor
    ~COAccessControl(void);

    //////////////////////////////////////////////////////////////////////
    // CImpAccessControl - This class is nested inside COAccessControl.
    //                     The CImpAccessControl class implements
    //                     the IPersistStream interface, IPersist interface
    //                     , and the IAccessControl interface
    //////////////////////////////////////////////////////////////////////
    class CImpAccessControl : public IPersistStream, public IAccessControl
    {
    public:

        // IUnknown methods, all calls are delegated to the controlling object.
        STDMETHODIMP_(HRESULT) QueryInterface
        (
        REFIID riid,
        void   **ppv
        );

        STDMETHODIMP_(ULONG) AddRef(void);

        STDMETHODIMP_(ULONG) Release(void);

        // IPersist method

        STDMETHODIMP_(HRESULT) GetClassID
        (
        CLSID *pClassID
        );

        // IPersistStream Methods
        STDMETHODIMP_(HRESULT) IsDirty
        (
        void
        );
		
        // Object initialization method. This method must be called
        // before any non-IUnknown methods.
        STDMETHODIMP_(HRESULT)Load
        (
        IStream *pStm
        );

        STDMETHODIMP_(HRESULT)Save
        (
        IStream *pStm,
        BOOL    fClearDirty
        );

        STDMETHODIMP_(HRESULT) GetSizeMax
        (
        ULARGE_INTEGER *pcdSize
        );

        // IAccessControl Methods
        STDMETHODIMP_(HRESULT) GrantAccessRights
        (
        PACTRL_ACCESSW pAccessList
        );

        // This function is not implemented.
        STDMETHODIMP_(HRESULT) SetAccessRights
        (
        PACTRL_ACCESSW pAccessList
        );

        // This function is not implemented.
        STDMETHODIMP_(HRESULT) SetOwner
        (
        PTRUSTEEW pOwner,
        PTRUSTEEW pGroup
        );

        STDMETHODIMP_(HRESULT) RevokeAccessRights
        (
        LPWSTR         lpProperty,
        ULONG          cCount,
        TRUSTEEW       pTrustee[]
        );

        STDMETHODIMP_(HRESULT) GetAllAccessRights
        (
        LPWSTR               lpProperty,
        PACTRL_ACCESSW      *ppAccessList,
        PTRUSTEEW           *ppOwner,
        PTRUSTEEW           *ppGroup
        );

        STDMETHODIMP_(HRESULT) IsAccessAllowed
        (
        PTRUSTEEW            pTrustee,
        LPWSTR               lpProperty,
        ACCESS_RIGHTS        AccessRights,
        BOOL                *pfAccessAllowed
        );

        // Constructor
        CImpAccessControl
        (
        IUnknown *pBackPtr,
        IUnknown *pUnkOuter,
        HRESULT *phrCtorResult
        );

        // Destructor
        ~CImpAccessControl(void);


    private:

        STDMETHODIMP_(void) CleanupAccessList
        (
        BOOL           fReleaseAll,
        STREAM_ACE    *pStreamACEReqs,
        void          *pACEReqs,
        ULONG          cGrant,
        ULONG          cDeny
        );

        STDMETHODIMP_(HRESULT) AddAccessList
        (
        STREAM_ACE    *pStreamACEReqs,
        void          *pACEReqs,
        ULONG          ulEstPickledSize,
        ULONG          cGrant,
        ULONG          cDeny
        );

        STDMETHODIMP_(HRESULT) GetEffAccRights
        (
        TRUSTEE_W *pTrustee,
        DWORD     *pdwRights
        );

        // Static data members
        BOOL                 m_bInitialized; // Object initialization flag.
        BOOL                 m_bDirty;       // This flag is set to TRUE if the
                                             // object has been changed since the
                                             // last save.
        BOOL                 m_bLockValid;   // TRUE if m_ACLLock was initialized
        IUnknown             *m_pUnkOuter;   // Pointer to the controlling object's
                                             // IUnkown implementation.
        CRITICAL_SECTION     m_ACLLock;      // Critical section object for
                                             // protecting the ACL from concurrent
                                             // access.
#ifdef _CHICAGO_
        CEffectivePermsCache m_Cache;        // This cache stores the results of
                                             // previous access checking.
#else
        CEffPermsCacheLUID   m_Cache;        // Access check results cache indexed
                                             // by LUID.
#endif
        ACL_DESCRIPTOR       m_ACLDesc;      // Platform dependent  representation
                                             // of the ACL
        PCB                  m_pcb;          // Pickle control block

    }; // COAccessControl::CImpAccessControl

    // Private variables

    LONG              m_cRefs;       // Object's reference count
    CImpAccessControl *m_ImpObj;     // Pointer to the inner CImpAccessControl object

}; // COAccessControl


#endif // #ifndef _CACCCNTRL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\accctrl\acsrv.cxx ===
//+---------------------------------------------------------------------------
//
// File: acsrv.cxx
//
// Description: This file contains code to initialize the access control
//              globals
//
// Functions: InitializeAccessControl
//
//+---------------------------------------------------------------------------

#include "ole2int.h"
#include <windows.h>
#include <iaccess.h>
#include <stdio.h>

#if 0 // #ifdef _CHICAGO_
#include "svrapi.h"   // NetAccessDel
#endif
#include "acpickl.h"  //
#include "cache.h"    //
#include "caccctrl.h" // Declaration of COAccessControl class factory

// Global variables
BOOL    g_bInitialized = FALSE; // Module initialization flag
IMalloc *g_pIMalloc;            // Cache a pointer to the task allocator for

CRITICAL_SECTION g_ServerLock;
#if 0 // #ifdef _CHICAGO_
DWORD   g_dwProcessID;          // Current process ID.
UINT    g_uiCodePage;           // Code page to use for converting
                                // more efficient memory allocation.
#endif
ULONG   g_ulHeaderSize;         // Since the encoded size of the header
                                // is frequently used by the CImpAccessControl
                                // methods, I just make it a one time
                                // initialized global value.

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: InitializeAccessControl
//
// Summary: This function performs per-process initialization
//          The major bulk of module initialization
//          code has been moved to ComGetClassObject to avoid circular module
//          initialization dependency. Right now, the function will only
//          initialize a critical section
//
// Args:
//
// Modifies: CRITICAL_SECTIOn g_ServerLock - This CRITICAL_SECTION object is
//                                           used to prevent simultaneous
//                                           initialization of the module in
//                                           ComGetClassObj. g_cServerLock is
//                                           destroyed when the
//                                           UninitializeAccessControl is
//                                           called.
//
// Return: BOOL - This function should always S_OK.
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M
HRESULT InitializeAccessControl()
{
    NTSTATUS status;

    status = RtlInitializeCriticalSection(&g_ServerLock);

    return NT_SUCCESS(status) ? S_OK : E_UNEXPECTED;
}

/****************************************************************************

    Function:   UninitializeAccessControl

    Summary:    Cleans up this module.

****************************************************************************/
void UninitializeAccessControl()
{
    // If the module is unloaded after it is initialized,
    // then make sure that the task memory allocator pointer
    // is freed.
    if(g_bInitialized)
    {
        g_pIMalloc->Release();
        g_bInitialized = FALSE;
    }
    // The g_ServerLock CRITICAL_SECTION object should always
    // be destroyed.
    DeleteCriticalSection(&g_ServerLock);
}


//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: InitGlobals
//
// Summary: This function initializes globals for this module.  All threads
//          that call this function
//          will be blocked by the g_ServerLock CRITICAL_SECTION object until
//          the first thread that arrives has completed the module initialization
//          sequence.
//
// Modifies: g_ProcessID - The current processID of the Dll module. This
//                         process ID is used by CImpAccessControl object to
//                         compose filename.
//
//           g_HeaderSize - Size of the STREAM_HEAEDER structure when it is
//                          encoded into
//           Chicago only:
//           g_uiCodePage - The console code page that is currently in use.
//                          This code page is used for translating Unicode
//                          string to ANSI string on Chicago.
//
// Return: HRESULT
//                 - E_FAIL: The function failed to create
//                           a message encoding handle.
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M
HRESULT InitGlobals()
{
    EnterCriticalSection(&g_ServerLock);
    if(g_bInitialized == FALSE)
    {

#if 0 // #ifdef _CHICAGO_

        ULONG            ulStrLen;               // Length of the Windows path
        CHAR             *pcszStrPtr;            // This pointer is used to point
                                                 // to the end of the Windows path,
                                                 // so that the filename can be
                                                 // easily attached after the Windows
                                                 // path.
        CHAR             pcszPathName[MAX_PATH]; // This character array is for storing
                                                 // the full path name of the files
                                                 // to search for and the files to be
                                                 // deleted.
        WIN32_FIND_DATAA FindFileData;           // This structure contains information
                                                 // a file that is found by the FindFirstFile
                                                 // and the FindNextFile functions. Only the
                                                 // file name in the structure is used in the
                                                 // following segment of code.
        HANDLE           SearchHandle;           // This handle is used for searching files
                                                 // with names that matches a certain pattern.
        CHAR            *pcszCompose;

        // Clean up any temporary files left over
        // from a previous instance of COAccessControl
        // that was not shut down properly due to a system crash
        g_dwProcessID = GetCurrentProcessId();

        // Compose the pathname for searching
        // Notice that the format of the filename is <Windows path>\<ProcessID>_<UUID>.tmp
        ulStrLen = GetWindowsDirectoryA(pcszPathName, MAX_PATH);
        pcszStrPtr = pcszPathName + ulStrLen;

        // We are interested in files with process IDs prefix that matches
        // the current process ID. Since the current segment of code will only be
        // executed the first time a process is started up, the files with
        // a prefix that matches the current processID found now must be
        // be left over from a crashed COM IAccessCOntrol object.
        pcszCompose = pcszStrPtr;
        *(pcszCompose++) = '\\';
        _ultoa( g_dwProcessID, pcszCompose, 16 );
        pcszCompose += strlen( pcszCompose );
        strcat( pcszCompose, "*.tmp" );

        SearchHandle = FindFirstFileA(pcszPathName, &FindFileData);
        if (SearchHandle != INVALID_HANDLE_VALUE)
        {
            // While we can still find files with a matching file name,
            // we
            do
            {
                strcpy( &pcszStrPtr[1], FindFileData.cFileName );
                DeleteFileA(pcszPathName);
                NetAccessDel(NULL, pcszPathName);
            }   while (FindNextFileA(SearchHandle, &FindFileData));

            // Release the file search handle
            FindClose(SearchHandle);
        } // if

        // Get the console code page for trustee name conversion
        g_uiCodePage = GetConsoleCP();


#endif
        // Cache a pointer to the task memory allocator
        // This pointer is used by the global functions LocalMemAlloc,
        // LocalMemFree, midl_user_allocate, and midl_user_free.
        if (FAILED(CoGetMalloc(MEMCTX_TASK, &g_pIMalloc)))
        {
            // CoGetMalloc will never fail.
            Win4Assert(!"CoGetMalloc failed!  Fix this right now!");
        }


        // The following segment of code is for computing the encoded size of
        // StTREAM_HEADER structure.
        RPC_STATUS status;
        CHAR          DummyBuffer[64];
        ULONG         ulEncodedSize;
        STREAM_HEADER DummyHeader;
        handle_t      PickleHandle;
        CHAR          *pEncodingBuffer;

        pEncodingBuffer = (CHAR *)(((UINT_PTR)DummyBuffer + 8) & ~7);
        if(status = (MesEncodeFixedBufferHandleCreate( pEncodingBuffer
                                                     , 56
                                                     , &ulEncodedSize
                                                     , &PickleHandle)) != RPC_S_OK )
        {
            ComDebOut((DEB_COMPOBJ, "MesEncodeFixedBufferHandelCreate failed with return code %x.\n", status));
            LeaveCriticalSection(&g_ServerLock);
            return E_FAIL;
        }

        STREAM_HEADER_Encode(PickleHandle, &DummyHeader);
        g_ulHeaderSize = ulEncodedSize;
        MesHandleFree(PickleHandle);

        // Set server initialization flag
        g_bInitialized = TRUE;

    }
    LeaveCriticalSection(&g_ServerLock);
    return S_OK;
} // InitGlobals
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\accctrl\cache.cxx ===
//+---------------------------------------------------------------------------
//
// File: cache.cxx
//
// Copyright (c) 1996-1996, Microsoft Corp. All rights reserved.
//
// Description: This file contains the implementation of the
//              CEffectivePermsCache class. The cache is implemented as a hash
//              without any fancy mechanism to handle collisions. If a
//              collision occur, the old entry is simply overwritten.
//
// Classes:  CEffectivePermsCache
//
//+---------------------------------------------------------------------------

#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ole2.h>
#include "Cache.h"
#define BIG_PRIME 48271
#define SMALL_PRIME 2683

#include "acext.h"

const DWORD LUID_LEN = 8;

#ifdef _CHICAGO_
// constructor

CEffectivePermsCache::CEffectivePermsCache(void)
{
    // Set the whole cache to null
    memset(m_cache, 0 , CACHE_SIZE * sizeof(CACHE_ENTRY));
    // Create an instance of the critical section object.
    m_bLockValid = NT_SUCCESS(RtlInitializeCriticalSection(&m_CacheLock));

}

// destructor
CEffectivePermsCache::~CEffectivePermsCache(void)
{
    // Flush the cache to free memory allocated for strings
    FlushCache();
    // Destroy critical section object
    if (m_bLockValid)
        DeleteCriticalSection(&m_CacheLock);
}


//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: CEffectivePermsCache::Hash, private
//
// Summary: This function returns a hash value for a Unicode string
//
// Args: LPWSTR pwszString [in]- Pointer to a null terminated Unicode string.
//
// Modifies: Nothing
//
// Return: DWORD - The hash value of the string.
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M

DWORD CEffectivePermsCache::Hash
(
LPWSTR pwszString
)
{
    DWORD  dwHashValue = 0;
    LPWSTR pwszWCHAR = pwszString;
    WCHAR  wc;
    ULONG  ulStrLen = lstrlenW(pwszString);

    for (USHORT i = 0; i < ulStrLen; i++, pwszWCHAR++)
    {
        wc = *pwszWCHAR;
        // Make the hash function case insensitive
        wc = toupper(wc);

        dwHashValue = ((dwHashValue + wc) * SMALL_PRIME) % BIG_PRIME;
    } // for

    return (dwHashValue % CACHE_SIZE);

} // Hash

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: CEffectivePermsCache::LookUpEntry
//
// Summary: This function search for the effective permission of a trustee
//          given the trustee name in Unicode.
//
// Args: LPWSTR pName [in] - The name of the trustee in unicode.
//
// Modifies: Nothing.
//
// Return: TRUE - If the the trustee's effective permission is found in
//                the cache.
//         FALSE - Otherwise.
//
// Actions: 1) Computes the hash value of the input string, k.
//          2) Compares the name in the kth entry of the cache with the
//             trustee's name.
//          3) If the trustee's name matches, sets *pdwEffectivePermissions to the
//             effective permissions in the cache entry and returns TRUE.
//          4) Returns FALSE otherwise.
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M

BOOL CEffectivePermsCache::LookUpEntry
(
LPWSTR pName,
DWORD  *pdwEffectivePermissions
)
{
    CACHE_ENTRY *pCacheEntry = m_cache + Hash(pName);

    if (!m_bLockValid)
        return FALSE;

    EnterCriticalSection(&m_CacheLock);
    if (FoolstrcmpiW(pName, pCacheEntry->pName) == 0)
    {
        *pdwEffectivePermissions = pCacheEntry->dwEffectivePermissions;
        LeaveCriticalSection(&m_CacheLock);
        return TRUE;
    } // if
    else
    {
        LeaveCriticalSection(&m_CacheLock);
        return FALSE;

    } // else
} // LookUpEntry

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: CEffectivePermsCache::DeleteEntry
//
// Summary: This function search for the effective permission of a
//
// Args: LPWSTR pName [in] - The name of the trustee in unicode.
//
// Modifies: Nothing.
//
// Return: TRUE - If the the trustee's effective permission is found in
//                the cache.
//         FALSE - Otherwise.
//
// Actions: 1) Computes the hash value of the input string, k.
//          2) Compares the name in the kth entry of the cache with the
//             trustee's name.
//          3) If the trustee's name matches, frees memory allocated for
//             *pCacheEntry->pName, sets *pCacheEntry->pName to
//             NULL and returns TRUE.
//          4) Returns FALSE otherwise.
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M

BOOL CEffectivePermsCache::DeleteEntry
(
LPWSTR pName
)
{
    CACHE_ENTRY *pCacheEntry = m_cache + Hash(pName);
    LPWSTR      pCacheName;

    if (!m_bLockValid)
        return FALSE;

    EnterCriticalSection(&m_CacheLock);
    pCacheName = pCacheEntry->pName;
    if (FoolstrcmpiW(pName, pCacheName) == 0)
    {
        LocalMemFree(pCacheName);
        pCacheEntry->pName = NULL;
        LeaveCriticalSection(&m_CacheLock);
        return TRUE;
    } // if
    else
    {
        LeaveCriticalSection(&m_CacheLock);
        return FALSE;

    } // else
} // DeleteEntry

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: CEffectivePermsCache::WriteEntry
//
// Summary: This function writes a new entry to the cache. In case of a hash
//          collision the old entry is overwritten.
//
// Args: LPWSTR pName [in] - Name of the trustee in the form of a NULL
//                           terminated unicode string.
//       DWORD  dwEffectivePermissions [in] - The set of effective
//                                            permissions that belong to the
//                                            trustee.
//
// Modifies: m_cache - The object's private hash table.
//
// Return: TRUE - If the operation is successful.
//         FALSE - If there is not enough memory to allocate the new string.
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M

BOOL CEffectivePermsCache::WriteEntry
(
LPWSTR pName,
DWORD  dwEffectivePermissions
)
{
    CACHE_ENTRY *pCacheEntry = m_cache + Hash(pName);
    ULONG       ulcStringLength;

    if (!m_bLockValid)
        return FALSE;

    // See if the name is already in the cache
    // and avoid reallocating a new string if possible.
    EnterCriticalSection(&m_CacheLock);
    if (FoolstrcmpiW(pName, pCacheEntry->pName) != 0)
    {
        if (pCacheEntry->pName != NULL)
        {
            // Free the old list if there was an old entry
            // in the slot
            LocalMemFree(pCacheEntry->pName);
        } // if
        ulcStringLength = lstrlenW(pName) + 1;
        pCacheEntry->pName = (LPWSTR)LocalMemAlloc(ulcStringLength * sizeof(WCHAR));
        if (pCacheEntry->pName == NULL)
        {
            // Out of memory error
            LeaveCriticalSection(&m_CacheLock);
            return FALSE;
        } // if

        memcpy(pCacheEntry->pName, pName, sizeof(WCHAR) * ulcStringLength);
    } // if

    pCacheEntry->dwEffectivePermissions = dwEffectivePermissions;
    LeaveCriticalSection(&m_CacheLock);
    return TRUE;
} // WriteEntry

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: CEffectivePermsCache::FlushCache
//
// Summary: This function empties the cache
//
// Args: void
//
// Modifies: m_cache - The object's private hash table
//
// Return: void
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M

void CEffectivePermsCache::FlushCache
(
void
)
{
    LPWSTR pString;
    USHORT i = 0;
    CACHE_ENTRY *pCache;

    if (!m_bLockValid)
        return FALSE;

    EnterCriticalSection(&m_CacheLock);
    for ( i = 0, pCache = m_cache
        ; i < CACHE_SIZE
        ; i++, pCache++)
    {
        if ((pString = pCache->pName) != NULL)
        {
            LocalMemFree(pString);
            pCache->pName = NULL;
        } // if

    } // for
    LeaveCriticalSection(&m_CacheLock);
    return;
} // FlushCache

#else
inline BOOL IsEqualLUID( LUID x, LUID y )
{
  return x.LowPart == y.LowPart && x.HighPart == y.HighPart;
}

CEffPermsCacheLUID::CEffPermsCacheLUID(void)
{
    // Set the whole cache to null
    memset(m_cache, 0 , CACHE_SIZE * sizeof(CACHE_ENTRY));
    // Create an instance of the critical section object.
    m_bLockValid = NT_SUCCESS(RtlInitializeCriticalSection(&m_CacheLock));
}

// destructor
CEffPermsCacheLUID::~CEffPermsCacheLUID(void)
{
    // Flush the cache to free memory allocated for strings
    FlushCache();
    // Destroy critical section object
    if (m_bLockValid)
        DeleteCriticalSection(&m_CacheLock);
}


//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: CEffPermsCacheLUID::Hash, private
//
// Summary: This function returns a hash value for a security identifier.
//
// Args: PLUID pLUID [in] - Pointer to a security identifier.
//
// Modifies: Nothing
//
// Return: DWORD - The hash value of the LUID.
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M

DWORD CEffPermsCacheLUID::Hash
(
LUID lClient
)
{
    DWORD  dwHashValue = 0;
    CHAR   *pLUIDBuff = (CHAR *)&lClient;

    for (USHORT i = 0; i < LUID_LEN; i++, pLUIDBuff++)
    {
        dwHashValue = ((dwHashValue + *pLUIDBuff) * SMALL_PRIME) % BIG_PRIME;
    } // for

    return (dwHashValue % CACHE_SIZE);

} // Hash

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: CEffPermsCacheLUID::LookUpEntry
//
// Summary: This function search for the effective permission of a trustee
//          given the trustee's security identifier.
//
// Args: PLUID pLUID [in] - Security identifier of the trustee.
//
// Modifies: Nothing.
//
// Return: TRUE - If the the trustee's effective permission is found in
//                the cache.
//         FALSE - Otherwise.
//
// Actions: 1) Computes the hash value of the input LUID, k.
//          2) Compares the LUID in the kth entry of the cache with the
//             trustee's LUID.
//          3) If the trustee's LUID matches, sets *pdwEffectivePermissions to the
//             effective permissions in the cache entry and return TRUE.
//          4) Returns FALSE otherwise.
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M

BOOL CEffPermsCacheLUID::LookUpEntry
(
LUID    lClient,
DWORD  *pdwEffectivePermissions
)
{
    CACHE_ENTRY *pCacheEntry = m_cache + Hash(lClient);
    BOOL         fFound      = FALSE;
	
    if (!m_bLockValid)
        return FALSE;

    EnterCriticalSection(&m_CacheLock);
    if (IsEqualLUID(pCacheEntry->lClient, lClient))
    {
        *pdwEffectivePermissions = pCacheEntry->dwEffectivePermissions;
        fFound = TRUE;
    } // if

    LeaveCriticalSection(&m_CacheLock);
    return fFound;
} // LookUpEntry

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: CEffPermsCacheLUID::DeleteEntry
//
// Summary: This function search for the effective permission of a
//
// Args: PLUID pLUID [in] - Security identifier of the trustee.
//
// Modifies: Nothing.
//
// Return: TRUE - If the the trustee's effective permission is found in
//                the cache.
//         FALSE - Otherwise.
//
// Actions: 1) Computes the hash value of the input LUID, k.
//          2) Compares the LUID in the kth entry of the cache with the
//             trustee's LUID.
//          3) If the trustee's LUID matches, frees memory allocated for
//             *pCacheEntry->pLUID, sets *pCacheEntry->pLUID to
//             NULL and returns TRUE.
//          4) Returns FALSE otherwise.
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M

BOOL CEffPermsCacheLUID::DeleteEntry
(
LUID lClient
)
{
    CACHE_ENTRY *pCacheEntry = m_cache + Hash(lClient);
    BOOL fFound = FALSE;

    if (!m_bLockValid)
        return FALSE;

    EnterCriticalSection(&m_CacheLock);
    if (IsEqualLUID(pCacheEntry->lClient, lClient ))
    {
        fFound = TRUE;
        pCacheEntry->lClient.HighPart = 0;
        pCacheEntry->lClient.LowPart  = 0;
    } // if

    LeaveCriticalSection(&m_CacheLock);
    return fFound;
} // DeleteEntry

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: CEffPermsCacheLUID::WriteEntry
//
// Summary: This function writes a new entry to the cache. In case of a hash
//          collision the old entry is overwritten.
//
// Args: PLUID pLUID [in] - Security identifier of the trustee.
//       DWORD  dwEffectivePermissions [in] - The set of effective
//                                            permissions that belong to the
//                                            trustee.
//
// Modifies: m_cache - The object's private hash table.
//
// Return: TRUE - If the operation is successful.
//         FALSE - If there is not enough memory to allocate the new string.
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M

BOOL CEffPermsCacheLUID::WriteEntry
(
LUID   lClient,
DWORD  dwEffectivePermissions
)
{
    CACHE_ENTRY *pCacheEntry = m_cache + Hash(lClient);

    if (!m_bLockValid)
        return FALSE;

    EnterCriticalSection(&m_CacheLock);
    pCacheEntry->lClient                = lClient;
    pCacheEntry->dwEffectivePermissions = dwEffectivePermissions;
    LeaveCriticalSection(&m_CacheLock);
    return TRUE;
} // WriteEntry

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: CEffPermsCacheLUID::FlushCache
//
// Summary: This function empties the cache
//
// Args: void
//
// Modifies: m_cache - The object's private hash table
//
// Return: void
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M

void CEffPermsCacheLUID::FlushCache
(
void
)
{
    USHORT i = 0;
    CACHE_ENTRY *pCache;

    if (!m_bLockValid)
        return;

    EnterCriticalSection(&m_CacheLock);
    for ( i = 0, pCache = m_cache
        ; i < CACHE_SIZE
        ; i++, pCache++)
    {
        pCache->lClient.LowPart = 0;
        pCache->lClient.HighPart = 0;
    } // for
    LeaveCriticalSection(&m_CacheLock);
    return;
} // FlushCache

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\accctrl\acext.h ===
//+-------------------------------------------------------------------
//
//  File:       acext.h
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996.
//
//  Contents:   Definitions shared by access control implementation
//
//--------------------------------------------------------------------

// Variables imported from the acsrv module
extern IMalloc *g_pIMalloc;  // Cached pointer to memory allocator
extern ULONG g_ulHeaderSize;
extern UINT  g_uiCodePage;   // Code page used for Chicago string converion

#ifdef _CHICAGO_
extern DWORD g_dwProcessID;  // Current process ID of the DLL
#endif

// Define the set of access mask supported
// Memory management functions local to the server
extern void * LocalMemAlloc(SIZE_T);
extern void   LocalMemFree(void *);
#ifdef _CHICAGO_
extern SHORT  FoolstrcmpiW(LPWSTR, LPWSTR);
#endif

// A table can be used to store mask in a more elegant manner
// COM_RIGHTS_EXECUTE is defined in objbase.h

#ifndef COM_RIGHTS_EXECUTE
#define COM_RIGHTS_EXECUTE      0x00000001
#endif
#define COM_RIGHTS_ALL          (COM_RIGHTS_EXECUTE)

//#ifdef _CHICAGO_
#define CHICAGO_RIGHTS_EXECUTE  ACCESS_EXEC
#define CHICAGO_RIGHTS_ALL      (CHICAGO_RIGHTS_EXECUTE)
//#else
#define NT_RIGHTS_EXECUTE       (COM_RIGHTS_EXECUTE)
#define NT_RIGHTS_ALL           (NT_RIGHTS_EXECUTE)
//#endif

// Define the stream version code
#define STREAM_VERSION 0x00000001

// A GUID string containing the braces and dashes
// but no null character at the end has exactly
// 38 characters.
#define GUID_SIZE 38
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\accctrl\makeidl.inc ===
!ifndef MIDL
MIDL = midl.exe
!endif

MIDL_FLAGS= \
        -Zp8 \
        -Oicf \
        -I$(INCLUDES:;= -I) -I.. \
        -char unsigned \
        -error allocation \
        -error bounds_check \
        -error stub_data \
        -cpp_cmd $(TARGET_CPP) \
        -DMIDL_PASS $(C_DEFINES)

$(O)\acpickl.h: ..\acpickl.idl ..\acpickl.acf
        $(MIDL) $(MIDL_FLAGS) \
		-server none -header $@ -cstub $(@:.h=_c.c) ..\acpickl.idl

allidl: $(O)\acpickl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\accctrl\cache.h ===
//+---------------------------------------------------------------------------
//
// File: Cache.h
//
// Description: This file contains the definition of the CEffectivePermsCache
//              class which is used by the COleDs_AcccessControl class to
//              speed up the access checking process. Access to the cache is
//              made thread safe through the use of a critical section object.
// Classes:  CEffectivePermsCache
//
// See the Cache.cpp source file for detail description of each of the
// methods.
//+---------------------------------------------------------------------------

#ifndef _CACHE_H_
#define _CACHE_H_
#define CACHE_SIZE 23


#ifdef _CHICAGO_
class CEffectivePermsCache
{
public:

    BOOL LookUpEntry
    (
    LPWSTR pName,
    DWORD *pdwEffectivePermissions
    );

    BOOL WriteEntry
    (
    LPWSTR pName,
    DWORD dwEffectivePermissions
    );

    BOOL DeleteEntry
    (
    LPWSTR pName
    );

    void FlushCache(void);

    void DumpCache(void);

    // constructor
    CEffectivePermsCache(void);

    // destructor
    ~CEffectivePermsCache(void);


private:

    typedef struct tagCACHE_ENTRY
    {
        LPWSTR  pName;
        DWORD   dwEffectivePermissions;
    } CACHE_ENTRY;

    CACHE_ENTRY m_cache[CACHE_SIZE];
    DWORD Hash(LPWSTR pStr);
    CRITICAL_SECTION m_CacheLock;
    BOOL m_bLockValid;

};
#else
class CEffPermsCacheLUID
{
public:

    BOOL LookUpEntry
    (
    LUID   lClient,
    DWORD *pdwEffectivePermissions
    );

    BOOL WriteEntry
    (
    LUID  lClient,
    DWORD dwEffectivePermissions
    );

    BOOL DeleteEntry
    (
    LUID lClient
    );

    void FlushCache(void);

    void DumpCache(void);

    // constructor
    CEffPermsCacheLUID(void);

    // destructor
    ~CEffPermsCacheLUID(void);


private:

    typedef struct tagCACHE_ENTRY
    {
        LUID    lClient;
        DWORD   dwEffectivePermissions;
    } CACHE_ENTRY;

    CACHE_ENTRY m_cache[CACHE_SIZE];
    DWORD Hash(LUID lClient);
    CRITICAL_SECTION m_CacheLock;
    BOOL m_bLockValid;

};
#endif
#endif // #ifndef _CACHE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\accctrl\caccctrl.cxx ===
//+---------------------------------------------------------------------------
//
// File: caccctrl.cxx
//
// Copyright (c) 1996-1996, Microsoft Corp. All rights reserved.
//
// Description: This file contains the method definitions of the DCOM
//              IAccessControl implementation classes
//
// Classes:  COAccessControl - This is the implementation component of DCOM
//                             IAccessControl. For aggregation support, the
//                             COAccessControl component is implemented as a
//                             nested class containing the CImpAccessControl
//                             class. The COAccessControl object itself
//                             contains a non-delegating implementation of
//                             IUknown that exposed the IUnknown, IPersist,
//                             IPersistStream, and the IAccessControl
//                             interfaces.
//           CImpAccessControl - This is the class nested within the
//                               COAccessControl component class. It
//                               contains the implementation of IAccessControl
//                               and IPersistStream and an implementation
//                               of IUnknown that always delegates the call
//                               to the controlling unknown.
//           CFAccessControl - The class factory for manufacturing COAccessControl
//                             objects.
//
// CODEWORK:
//      Use PrivMemAllow everywhere.
//      Always check m_bInitialized before argument validation.
//
//+---------------------------------------------------------------------------
#include "ole2int.h"
#include <windows.h>
#include <objbase.h>
#include <stdio.h>

#if 0 // #ifdef _CHICAGO_
#include <svrapi.h>   // 16-bit LAN Manager NetAccess API
#endif

#include "iaccess.h"   // IAccessControl interface definition
#include "Cache.h"    // Effective permissions cache
#include "acpickl.h"  // Pickling support
#include "caccctrl.h" // COAccessControl, CImpAccessControl and CFAccessControl
                      // class declarations.

// External variables
#include "acext.h"

GENERIC_MAPPING gDummyMapping   = {0,0,0,0};
PRIVILEGE_SET   gDummyPrivilege = {1,0};
SID             gEveryone       = {1,1,SECURITY_WORLD_SID_AUTHORITY,
                                   SECURITY_WORLD_RID};
#if 0
// Not needed for NT5 - see GetSIDFromName
SID             gSystem         = {1,1,SECURITY_NT_AUTHORITY,
                                   SECURITY_LOCAL_SYSTEM_RID};
#endif

// Internal function prototypes, please see the function headers for details
HRESULT InitGlobals                   ();
void    AddACEToStreamACL             (STREAM_ACE *, PCB *);
void    CleanAllMemoryResources       (ACL_DESCRIPTOR *, PCB *);
void    CleanUpStreamACL              (STREAM_ACL *pStreamACL);
HRESULT EnlargeStreamACL              (PCB *, ULONG);
void    FreePicklingBuff              (PCB *);
BOOL    IsValidAccessMask             (DWORD);
void    *LocalMemAlloc                (SIZE_T);
void    LocalMemFree                  (void *);
HRESULT MapStreamACLToAccessList      (PCB *, PACTRL_ACCESSW *);
HRESULT ResizePicklingBuff            (PCB *, ULONG);
HRESULT ValidateTrusteeString         (LPWSTR);
HRESULT ValidateTrustee               (PTRUSTEE_W);
HRESULT ValidateAccessCheckClient     (PTRUSTEE_W);
HRESULT ValidateAndTransformAccReqList(PACTRL_ACCESSW ,STREAM_ACE **, void **, ULONG *, ULONG *, ULONG *);

#if 0 // #ifdef _CHICAGO_
void    AddACEToACLImage              (access_list_2 *, ULONG, ACL_DESCRIPTOR *);
HRESULT AllocACLImage                 (ACL_IMAGE *, SHORT);
void    CleanFileResource             (ACL_IMAGE *);
void    CleanUpACLImage               (ACL_IMAGE *);
HRESULT ComputeEffectiveAccess        (LPWSTR,DWORD *, ACL_DESCRIPTOR *);
void    DeleteACEFromACLImage         (CHAR *, ACL_IMAGE *);
BOOL    DeleteACEFromStreamACL        (PTRUSTEE_W, ULONG, PCB *);
HRESULT EnsureACLImage                (ACL_IMAGE *, ULONG);
HRESULT GenerateFile                  (LPTSTR *);
HRESULT MapStreamACLToChicagoACL      (STREAM_ACE *, ACL_IMAGE *, SHORT);
HRESULT ReadACLFromStream             (IStream *, PCB *);
SHORT   StandardMaskToLANManagerMask  (DWORD *, USHORT *);
HRESULT ValidateAndFixStreamACL       (STREAM_ACL *);
HRESULT WStringToMBString             (LPWSTR, CHAR **);
#else
HRESULT ComputeEffectiveAccess        (ACL_DESCRIPTOR *, STREAM_ACL *, HANDLE, DWORD *);
BOOL    DeleteACEFromStreamACL        (PTRUSTEE_W, ULONG, ACL_DESCRIPTOR *, PCB *);
HRESULT GetSIDFromName                (PSID *, LPWSTR, TRUSTEE_TYPE *);
HRESULT GetNameFromSID                (LPWSTR *, PSID, TRUSTEE_TYPE *);
HRESULT InitSecDescInACLDesc          (ACL_DESCRIPTOR *);
void    NTMaskToStandardMask          (ACCESS_MASK *, DWORD *);
HRESULT PutStreamACLIntoSecDesc       (STREAM_ACL *, ACL_DESCRIPTOR *);
HRESULT ReadACLFromStream             (IStream *, PCB *, ACL_DESCRIPTOR *);
void    StandardMaskToNTMask          (DWORD *, ACCESS_MASK *);
HRESULT ValidateAndFixStreamACL       (STREAM_ACL *, ULONG *, ULONG *);
#endif

//////////////////////////////////////////////////////////////////////////////
// CFAccessControl methods (Class Factory)
//////////////////////////////////////////////////////////////////////////////

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Function: CAccessControlCF_CreateInstance(), public
//
// Summary: This function creates an instance of the CAccesControl object
//          and returns a requested interface pointer to the object. If the
//          caller of this method intends to aggregate with the COAccessControl
//          component, it will pass it's IUnknown pointer to this method which
//          will in turn be passed into the COAccessControl contructor.
//          Owing to the fact that the COAccessControl object supports
//          aggregation, and COM rules dictate that a client must only ask for
//          the IUnknown interface at creation of an aggregatable object,
//          the caller must pass in IID_IUnknown as the riid parameter,
//          otherwise this call will fail and return E_INVALIDARG.
//
// Args: IUnknown *pUnkOuter [in] - IUnknown pointer to the controlling object which
//                                  can be NULL if the COAccessControl object is not
//                                  created as part of an aggregate.
//       REFIID riid [in] - Reference to the identifier of the interface that
//                          the client has requested.
//       void **ppv [out] - Reference to the interface pointer to be returned to
//                          the caller.
//
// Return: HRESULT -S_OK: Succeeded.
//                  E_INVALIDARG: ppv is NULL, or the client ask for an interface
//                                other than IUnknown
//                  E_OUTOFMEMORY: Not enough memory to create new object.
//                  E_NOINTERFACE: The interface requested by the client
//                                 was not supported by the COM IAccessControl
//                                 object.
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M
HRESULT CAccessControlCF_CreateInstance(IUnknown *pUnkOuter,
                                        REFIID riid, void **ppv)
{
    HRESULT hr = InitGlobals();
    if (FAILED(hr))
    {
        return hr;
    }

    hr = E_OUTOFMEMORY;
    COAccessControl *pAccessControl = new COAccessControl;
    if (pAccessControl)
    {
        hr = pAccessControl->Init(pUnkOuter);
        if (SUCCEEDED(hr))
        {
            hr = pAccessControl->QueryInterface(riid, ppv);
        }

        if (FAILED(hr))
        {
            delete pAccessControl;
        }
    }

    return hr;
} // CFAccessControl::CreateInstance

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: CFAccessControl::LockServer() , public
//
// Summary: This function either increases of decreases the server lock count.
//
// Args: BOOL fLock [in] - This flag tells the function whether to increment or
//                         decrement the server lock count.
//                         TRUE - Increment the server lock count.
//                         FALSE - Decrement the server lock count.
//                         The server can be unloaded if the server lock count
//                         and the object count are both zero.
//
// Return: S_OK: This function cannot fail.
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M

STDMETHODIMP_(HRESULT)
CFAccessControl::LockServer
(
BOOL fLock
)
{
    return S_OK;
} // CFAccessControl::LockServer

//////////////////////////////////////////////////////////////////////////////
// COAccessControl methods
//////////////////////////////////////////////////////////////////////////////

// Constructor, destructor

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: COAccessControl::COAccessControl(), public
//
// Summary: Object constructor. This function sets the object's reference count
//          to zero.
//
// Args:  void
//
// Modifies: m_cRefs
//
// Return: void
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M
COAccessControl::COAccessControl
(
void
)
{
    // Set object reference count to zero
    m_cRefs = 0;
    m_ImpObj = NULL;
    return;

} // COAccessControl::COAccessControl

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: COAccessControl::Init(), public
//
// Summary: COAccessControl initialization method. Notice that this function
//          initialize the COAccessControl object in a sense different from
//          that of COAccessControl::Load. COAccessControl::Load initializes
//          COAccessControl
//
// Args:  IUnknown pUnkOuter - Pointer to the controlling object. This pointer
//                             can be NULL if the COAccessControl object
//                             is not part of an aggregate.
//
// Modifies: m_ImpObj
//
// Return: void
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M
STDMETHODIMP_(HRESULT)
COAccessControl::Init
(
IUnknown *pUnkOuter
)
{

    // Initialize inner object
    HRESULT hr;
    m_ImpObj = new CImpAccessControl(this, pUnkOuter, &hr);
    if(m_ImpObj == NULL)
    {
        return E_OUTOFMEMORY;
    }
    else
    {
        if (FAILED(hr)) 
        {
            delete m_ImpObj;
            m_ImpObj = NULL;
            return hr;
        }
        return m_ImpObj->Load( NULL );
    }

} // COAccessControl::Init

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: COAccessControl::~COAccessControl(), public
//
// Summary: Object destructor. This function does nothing at the moment.
//
// Args:  void
//
// Return: void
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M
COAccessControl::~COAccessControl
(
void
)
{
    // Destroy inner object
    delete m_ImpObj;
    return;
} // COAccessControl::~COAccessControl

// IUnknown methods

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: COAccessControl::QueryInterface() , public
//
// Summary: This function queries the COAccessControl object for an
//          interface pointer for the caller.
//
// Args: [in] REFIID riid - Reference to the identifier of the interface
//                          that the client wants.
//       [out] void **ppv - Interface pointer returned.
//
// Modifies: m_cRefs.
//
// Return: HRESULT - S_OK: Succeeded.
//                 - E_NOINTERFACE: The requested interface is not supported.
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M

STDMETHODIMP_(HRESULT)
COAccessControl::QueryInterface
(
REFIID riid,
void   **ppv
)
{

    HRESULT hr = E_NOINTERFACE;

    // Since the CImpAccessControl class inherits from multiple
    // virtual classes, it is important that the interface pointer
    // returned is type cast properly.
    if (IsEqualGUID(riid, IID_IUnknown))
    {
        *ppv = (IUnknown *)this;
    }
    else if (IsEqualGUID(riid, IID_IPersist))
    {
        *ppv = (IPersist *)m_ImpObj;
    }
    else if (IsEqualGUID(riid, IID_IPersistStream))
    {
        *ppv = (IPersistStream *)m_ImpObj;
    }
    else if (IsEqualGUID(riid, IID_IAccessControl))
    {
        *ppv = (IAccessControl *)m_ImpObj;
    }
    else
    {
        *ppv = NULL;
    }

    if(*ppv != NULL)
    {

        // Obey COM reference counting rules, call
        // AddRef on the interface pointer returned.
        ((IUnknown *)(*ppv))->AddRef();
        hr = S_OK;
    }
    return hr;

} // COAccessControl::QueryInterface

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: COAccessControl::AddRef(), public
//
// Summary: Increments the COAccessControl object reference count.
//
// Args: void
//
// Modifies: m_cRefs.
//
// Return: ULONG
//          New reference count of the object.
//
// Remark: The modification of m_cRefs is made thread-safe by using the
//         InterlockedIncrement function.
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M
STDMETHODIMP_(ULONG)
COAccessControl::AddRef
(
void
)
{
    ULONG cRefs = m_cRefs + 1;
    InterlockedIncrement(&m_cRefs);
    return cRefs;
} // COAccessControl::AddRef

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: COAccessControl::Release(), public
//
// Summary: Decrements the COAccessControl object reference count and deletes
//          the object when the reference drops to zero. After the object itself
//          is destroyed, this function will also decrement the server's object
//          count. Modification of object's reference count and the server's
//          object count must be made thread-safe by using the
//          InterlockedIncrement and the InterlockedDecrement functions.
//
// Args: void
//
// Modifies: m_cRefs.
//
// Return: ULONG
//          New reference count of the object. This number may not be accurate
//          in a multithreaded environment.
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M
STDMETHODIMP_(ULONG)
COAccessControl::Release
(
void
)
{
    ULONG cRefs = m_cRefs - 1;
    if(InterlockedDecrement(&m_cRefs) == 0)
    {
        // self-destruct
        delete this;
        return 0;
    }
    else
    {
        return cRefs;
    }

} // COAccessControl::Release

//////////////////////////////////////////////////////////////////////////////
// CImpAccessControl
//////////////////////////////////////////////////////////////////////////////

// Constructor, destructor

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: COAccessControl::CImpAccessControl::CImpAccessControl, public
//
// Summary: Object contructor. This function is responsible for initializing
//          the initialization flag and the dirty flag to false, setting
//          the object's two major structures, the ACL descriptor and the
//          pickling control block, to NULL, and initializing the object's
//          outer unknown pointer to point to the appropriate object depending
//          on whether the COAccessControl object is part of an aggregate.
//
// Args: IUnknown *pBackPtr [in] - IUnknown pointer to the outer object ie.
//                                 the COAccessControl control that contains
//                                 the current CImpAccessControl object.
//       IUnknown *pUnkOuter [in] - IUnknown pointer to the controlling unknown
//                                  which is NULL if the COAccessControl object
//                                  is not part of an aggregation.
//       HRESULT *phrCtorResult [out] - Hresult pointer which contains the result
//                                      of the constructor.  Do not use object if
//                                      hr is failed.
//
// Modifies: m_bDirty, m_bInitialized, m_pUnkOuter, m_ACLDesc, m_pcb
//
// Return: void
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M

COAccessControl::CImpAccessControl::CImpAccessControl
(
IUnknown *pBackPtr,
IUnknown *pUnkOuter,
HRESULT *phrCtorResult
)
{
    m_pUnkOuter = (pUnkOuter == NULL) ? pBackPtr : pUnkOuter;
    m_bInitialized = FALSE;
    m_bDirty = FALSE;
    // Initialize the structures within the object...
    memset(&m_ACLDesc, 0, sizeof(ACL_DESCRIPTOR));
    memset(&m_pcb, 0, sizeof(PCB));

    m_bLockValid = NT_SUCCESS(RtlInitializeCriticalSection(&m_ACLLock));

    *phrCtorResult = m_bLockValid ? S_OK : E_OUTOFMEMORY;

    return;
} // COAccessControl::CImpAccessControl::CImpAccessControl


//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: COAccessControl::CImpAccessControl::~CImpAccessControl(), public
//
// Summary: Object destructor. This function releases all the memory allocated
//          for an initialized CImpAccessControl object and destroys the
//          critical section object for guarding the internal from concurrent
//          access.
//
// Args: void
//
// Modifies: m_ACLDesc, m_pcb.
//
// Return: void
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M
COAccessControl::CImpAccessControl::~CImpAccessControl
(
void
)
{
    if(m_bInitialized)
    {
#if 0 // #ifdef _CHICAGO_
        CleanFileResource(&(m_ACLDesc.DenyACL));
        CleanFileResource(&(m_ACLDesc.GrantACL));
#endif
        CleanAllMemoryResources(&m_ACLDesc, &m_pcb);
    } // if

    if (m_bLockValid)
    {
        DeleteCriticalSection(&m_ACLLock);
    }
}  //COAccessControl::CImpAccessControl:~CImpAccessControl

// IUnknown methods

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: COAccessControl::CImpAccessControl::QueryInterface(), public
//
// Summary: This function simply delegates the QueryInterface call to the
//          outer unknown's QueryInterface method.
//
// Args:  REFIID riif [in] - Reference to the interface identifier that signifies
//                           the interface that the client wanted.
//
//
// Return: HRESULT - See outer unknown implementation for details.
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M
STDMETHODIMP_(HRESULT)
COAccessControl::CImpAccessControl::QueryInterface
(
REFIID riid,
void   **ppv
)
{
    return m_pUnkOuter->QueryInterface(riid, ppv);
} // COAccessControl:CImpAccessControl::QueryInterface

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: COAccessControl::CImpAccessControl::AddRef(), public
//
// Summary: This function simply delegates the AddRef call to the outer unknown's
//          AddRef method.
//
// Args:  void
//
// Modifies: Outer unknown reference count.
//
// Return: HRESULT - See outer unknown implementation for details
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M
STDMETHODIMP_(ULONG)
COAccessControl::CImpAccessControl::AddRef
(
void
)
{
    // AddRef of the outer object must be thread-safe
    return m_pUnkOuter->AddRef();
} // COAccessControl::CImpAccessControl::AddRef

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: COAccessControl::CImpAccessControl::Release(), public
//
// Summary: This function simply delegates the Release call to the outer unknown's
//          Release method.
//
// Args:  void
//
// Modifies: Outer unknown reference count
//
// Return: ULONG - See outer unknown implementation for details.
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M
STDMETHODIMP_(ULONG)
COAccessControl::CImpAccessControl::Release
(
void
)
{
    // Release of the outer object must be thread safe
    return m_pUnkOuter->Release();
} // COAccessControl::CImpAccessControl::Release

// IPersist method

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: COAccessControl::CImpAccessControl::GetClassID(), public
//
// Summary: This function returns the class id of the COAccessControl component.
//          pClassID must be pointing to a valid memory block big enough to
//          hold the returned class ID.
//
// Args: CLSID *pCLSID [out] - Pointer to the returned CLSID.
//
// Modifies: Nothing
//
// Return: HRESULT - E_INVALIDARG: pClassID == NULL.
//                   S_OK: Succeeded.
//                   CO_E_ACNOTINITIALIZED: This method was called before
//                                        the DCOM IAccessControl object
//                                        was initialized by the Load method.
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M
STDMETHODIMP_(HRESULT)
COAccessControl::CImpAccessControl::GetClassID
(
CLSID *pClassID
)
{
    if (pClassID == NULL)
    {
        return E_INVALIDARG;
    } // if
    *pClassID = CLSID_DCOMAccessControl;
    return S_OK;
} // COAccessControl::CImpAccessControl::GetClassID

// IPersistStream methods

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: COAccessControl::CImpAccessControl::IsDirty(), public
//
// Summary: This function returns TRUE if the object has been modified since
//          the last time it was saved and FALSE otherwise.
//
// Args: void.
//
// Return: HRESULT - S_OK: The object has changed since the last save.
//                   S_FALSE: The object has not changed since the last save.
//                   CO_E_ACNOTINITIALIZED: This method was called before
//                                        the DCOM IAccessControl object
//                                        was initialized by the Load method.
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M
STDMETHODIMP_(HRESULT)
COAccessControl::CImpAccessControl::IsDirty
(
void
)
{
    if(!m_bInitialized)
        return CO_E_ACNOTINITIALIZED;

    return (m_bDirty? S_OK:S_FALSE);
} // COAccessControl::CimpAccessControl::IsDirty


//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: COAccessControl::CImpAccessControl::Load(), public
//
// Summary: This function is the initialization method of CImpAccessControl
//          and it must be called before any non-IUnknown methods.
//
// Args: IStream *pStm [in] - Interface pointer to a stream object from which
//                            access control data is loaded into the object.
//                            The seek pointer of the stream should be at the
//                            beginning of the stream header.
//                            If pStm is NULL, this function will initialize
//                            an empty DCOM IAccessControl object.
//
// Modifies: m_ACLDesc, m_pcb
//
// Return: HRESULT - S_OK: Succeeded.
//                   E_INVALIDARG: This method will return E_INVALIDARG if
//                                 either
//                                 a) the ACL in the stream provided by the
//                                    user contains an invalid access mask, or
//                                 b) one of STREAM_ACE structure in the ACL
//                                    provided by the user contains a null
//                                    pTrusteeName pointer.
//                   E_OUTOFMEMORY: The system ran out of memory for some
//                                  crucial operation.
//                   CO_E_FAILEDTOGETWINDIR: (Windows 95 only)Unable to obtain
//                                           the Windows directory.
//                   CO_E_PATHTOOLONG: (Windows 95 only)The path generated by
//                                     the GenerateFile function was longer
//                                     than the system's limit.
//                   CO_E_FAILEDTOGENUUID: (Windows 95 only)Unable to generate
//                                         a uuid using the UuidCreate funciton.
//                   CO_E_FAILEDTOCREATEFILE: (Windows 95 only)Unable to create
//                                            a dummy file.
//                   CO_E_FAILEDTOCLOSEHANDLE: Unable to close a serialization
//                                             handle.
//                   CO_E_SETSERLHNDLFAILED: Unable to (re)set a serialization
//                                           handle.
//                   CO_E_EXCEEDSYSACLLIMIT: The number of ACEs in the ACL
//                                           provided by the user exceeded the
//                                           limit imposed by the system that
//                                           is loading the ACL. On Windows 95,
//                                           the system can handle 32767
//                                           ACTRL_ACCESS_DENIED ACEs and 32767
//                                           ACTRL_ACCESS_ALLOWED ACEs. On Windows NT,
//                                           the system can only handle 32767
//                                           ACTRL_ACCESS_DENIED and ACTRL_ACCESS_ALLOWED ACEs
//                                           combined.
//                   CO_E_ACESINWRONGORDER: Not all ACTRL_ACCESS_DENIED ACEs in the ACL
//                                          provided by the user were arranged
//                                          in front of the ACTRL_ACCESS_ALLOWED ACEs.
//                   CO_E_WRONGTRUSTEENAMESYNTAX: The ACL provided by the user
//                                                contained a trustee name
//                                                string that didn't conform
//                                                to the <Domain>\<Account>
//                                                syntax.
//                   CO_E_INVALIDSID: (Windows NT only)The ACL provided by the
//                                    user contained an invalid security
//                                    identifier.
//                   CO_E_LOOKUPACCNAMEFAILED: (Window NT only) The system call,
//                                             LookupAccountName, failed. The
//                                             user can call GetLastError to
//                                             obtain extended error information.
//                   CO_E_NOMATCHINGSIDFOUND: (Windows NT only) At least one of
//                                            the trustee name in the ACL provided
//                                            by the user had no corresponding
//                                            security identifier.
//                   CO_E_CONVERSIONFAILED: (Windows 95 only) WideCharToMultiByte
//                                          failed.
//
//                   CO_E_FAILEDTOOPENPROCESSTOKEN: (Windows NT only)The system
//                                                  call, OpenProcessToken,
//                                                  failed. The user can get
//                                                  extended information by
//                                                  calling GetLastError.
//                   CO_E_FAILEDTOGETTOKENINFO: (Windows Nt only)The system call,
//                                              GetTokenInformation, failed.
//                                              The user can call GetLastError to
//                                              get extended error information.
//                   CO_E_DECODEFAILED: Unable to decode the ACL in the
//                                      IStream object.
//                   CO_E_INCOMPATIBLESTREAMVERSION: The version code in the
//                                                   stream header was not
//                                                   supported by this version
//                                                   of IAccessControl.
//                   Error codes from IStream::Read - See the Win32 SDK
//                   documentation for detail descriptions of the following
//                   error codes.
//                   STG_E_ACCESSDENIED:
//                   STG_E_INVALIDPOINTER:
//                   STG_E_REVERTED:
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M
STDMETHODIMP_(HRESULT)
COAccessControl::CImpAccessControl::Load
(
IStream *pStm
)
{

    HRESULT        hr;                     // Function return code
    ACL_DESCRIPTOR ACLDescBackup;          // Backup of the original ACL descriptor in the object
    PCB            PCBBackup;              // Backup of the original PCB in the object.
#if 0 // #ifdef _CHICAGO_
    SHORT          sNumOfDenyEntries = 0;  // Number of deny entries in the stream
    SHORT          sNumOfGrantEntries = 0; // Number of grant entries in the stream
    CHAR           *pszDenyFilename;       // Name of the deny ACL dummy file
    CHAR           *pszGrantFilename;      // Name of the grant ACL dummy file
#endif
	
    // There are too much things happening in this
    // function so I'll simply lock the whole thing
    EnterCriticalSection(&m_ACLLock);

    // Take a snapshot of the old ACL so that if anything goes wrong, I can restore to the
    // old configuration
    memcpy(&PCBBackup, &m_pcb, sizeof(PCB));
    memcpy(&ACLDescBackup,&m_ACLDesc,sizeof(ACL_DESCRIPTOR));

    // Set the original ACL descritpor and the PCB to NULL just to be save
    memset(&m_ACLDesc, 0, sizeof(ACL_DESCRIPTOR));
    memset(&m_pcb, 0, sizeof(PCB));

#if 0 // #ifdef _CHICAGO_
    // Generate new dummy files if this is the first time the object
    // is initialized, reuse the old ones otherwise
    if (m_bInitialized)
    {
        pszDenyFilename  = ACLDescBackup.DenyACL.pACL->acc1_resource_name;
        pszGrantFilename = ACLDescBackup.GrantACL.pACL->acc1_resource_name;
    } // if
    else
    {
        if (FAILED(hr = GenerateFile(&pszDenyFilename)))
        {
            goto Error;
        } // if

        if (FAILED(hr = GenerateFile(&pszGrantFilename)))
        {
            goto Error;
        } // if
    } // if
#endif

    if (pStm != NULL)
    {

        // Read the ACL in the stream into the pickle control block
#if 0 // #ifdef _CHICAGO_
        if(FAILED(hr = ReadACLFromStream(pStm, &m_pcb)))
#else
        if(FAILED(hr = ReadACLFromStream(pStm, &m_pcb, &m_ACLDesc)))
#endif
        {
#ifndef _CHICAGO_
            if(hr != CO_E_NOMATCHINGSIDFOUND && hr != CO_E_LOOKUPACCNAMEFAILED)
            {
#endif
                goto Error;
#ifndef _CHICAGO_
            } // if
#endif
        }

    }
    else
    {

        if (FAILED(hr = EnlargeStreamACL(&m_pcb, 10)))
        {
            goto Error;
        }
        m_pcb.ulBytesUsed = sizeof(STREAM_ACL)
                          + sizeof(STREAM_ACE)
                          + 256;
        m_pcb.bPickled = FALSE;
        if (FAILED(hr = ResizePicklingBuff(&m_pcb, m_pcb.ulBytesUsed + 800)))
        {
            goto Error;
        }


    } // if (pStm != NULL)
    m_pcb.ulNumOfStreamACEs = m_pcb.StreamACL.ulNumOfDenyEntries
                            + m_pcb.StreamACL.ulNumOfGrantEntries;

#if 0 // #ifdef _CHICAGO_
    // Allocate memory for the two ACL images
    // NT ACL that contains more than 32767 may be too large to fit
    // into the LAN Manager ACL
    sNumOfDenyEntries = (SHORT)(m_pcb.StreamACL.ulNumOfDenyEntries);
    hr = AllocACLImage(&(m_ACLDesc.DenyACL), sNumOfDenyEntries + EXTRA_ACES);
    if (FAILED(hr))
    {
        goto Error;
    } // if
    m_ACLDesc.DenyACL.pACL->acc1_count         = sNumOfDenyEntries;
    m_ACLDesc.DenyACL.pACL->acc1_resource_name = pszDenyFilename;

    // NT ACL that contains more than 32767 may be too large to fit
    // into the LAN Manager ACL
    sNumOfGrantEntries = (SHORT)(m_pcb.StreamACL.ulNumOfGrantEntries);
    hr = AllocACLImage(&(m_ACLDesc.GrantACL), sNumOfGrantEntries + EXTRA_ACES);
    if (FAILED(hr))
    {
        goto Error;
    } // if
    m_ACLDesc.GrantACL.pACL->acc1_count         = sNumOfGrantEntries;
    m_ACLDesc.GrantACL.pACL->acc1_resource_name = pszGrantFilename;


    // Map Stream ACL to Chicago ACL
    if(FAILED(hr = MapStreamACLToChicagoACL( m_pcb.StreamACL.pACL
                                           , &(m_ACLDesc.DenyACL)
                                           , sNumOfDenyEntries)))
    {
        goto Error;
    } // if

    if(FAILED(hr = MapStreamACLToChicagoACL( m_pcb.StreamACL.pACL
                                           + sNumOfDenyEntries
                                           , &(m_ACLDesc.GrantACL)
                                           , sNumOfGrantEntries)))
    {
        goto Error;
    } // if

    m_ACLDesc.DenyACL.bDirtyACL = TRUE;
    m_ACLDesc.GrantACL.bDirtyACL = TRUE;

#else

    if(FAILED(hr = InitSecDescInACLDesc(&m_ACLDesc)))
    {
        goto Error;
    } // if

#endif
    // Create a new pickling handle for the new ACL
    if (MesEncodeFixedBufferHandleCreate( m_pcb.pPicklingBuff
                                        , m_pcb.ulPicklingBuffSize
                                        , &(m_pcb.ulBytesUsed)
                                        , &(m_pcb.PickleHandle)) != RPC_S_OK)
    {
        hr = CO_E_SETSERLHNDLFAILED;
        goto Error;
    } // if

    m_pcb.bDirtyHandle = FALSE;

    if(m_bInitialized)
    {
        CleanAllMemoryResources(&ACLDescBackup, &PCBBackup);
        m_Cache.FlushCache();
    }
    else
    {
        m_bInitialized = TRUE;
    } // if
    // Set dirty flag to false
    m_bDirty = FALSE;

    LeaveCriticalSection(&m_ACLLock);
    return S_OK;

// Error handling code
Error:
#if 0 // #ifdef _CHICAGO_

    // Cleanup the ACL images
    if (m_ACLDesc.GrantACL.pACL != NULL)
    {
        CleanUpACLImage(&(m_ACLDesc.GrantACL));
    }

    if (m_ACLDesc.DenyACL.pACL != NULL)
    {
        CleanUpACLImage(&(m_ACLDesc.DenyACL));
    }

    // Destroy all the generated files if the
    // object has been initialized before
    if (!m_bInitialized)
    {
        if (pszGrantFilename != NULL)
        {
            DeleteFileA(pszGrantFilename);
            LocalMemFree(pszGrantFilename);
        } // if

        if (pszDenyFilename != NULL)
        {
            DeleteFileA(pszDenyFilename);
            LocalMemFree(pszDenyFilename);
        } // if
    } // if
#endif

    // Cleanup the stream ACL
    if(m_pcb.StreamACL.pACL != NULL)
    {
        CleanUpStreamACL(&(m_pcb.StreamACL));
    }// if

    // Release the decoding handle
    if (m_pcb.PickleHandle != NULL)
    {
        MesHandleFree(m_pcb.PickleHandle);
    } // if

    // Release the pickling buffer
    if (m_pcb.pPicklingBuff != NULL)
    {
        FreePicklingBuff(&m_pcb);
    } // if

    // Restore the old ACL
    memcpy(&m_pcb, &PCBBackup, sizeof(PCB));
    memcpy(&m_ACLDesc, &ACLDescBackup, sizeof(ACL_DESCRIPTOR));
    LeaveCriticalSection(&m_ACLLock);
    return hr;

} // COAccessControl::CImpAccessControl::Load

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: COAccessControl::CImpAccessControl::Save(), public
//
// Summary: This function saves the object's ACL to a user provided stream.
//
// Args: IStream *pStm [in,out] - Pointer to a user provided stream object.
//       BOOL fClearDirty [in] - Flag indicating whether the object should clear
//                               its dirty flag after the save.
//
// Modifies: m_bDirty
//
// Return: HRESULT - S_OK: Succeeded.
//                   CO_E_ACNOTINITIALIZED: This method was called before
//                                        the DCOM IAccessControl object
//                                        was initialized by the Load method.
//                   E_INVALIDARG: pStm was NULL.
//                   CO_E_SETSERLHNDLFAILED - Failed to (re)set serializtion
//                                            handle.
//                   Error codes that can be returned by the write operation.
//                   See Win32 SDK help for details
//                   STG_E_MEDIUMFULL
//                   STG_E_ACCESSDENIED
//                   STG_E_CANTSAVE
//                   STG_E_INVALIDPOINTER
//                   STG_E_REVERTED
//                   STG_E_WRITEFAULT
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M
STDMETHODIMP_(HRESULT)
COAccessControl::CImpAccessControl::Save
(
IStream *pStm,
BOOL    fClearDirty
)
{
    HRESULT        hr = S_OK;
    handle_t       HeaderHandle;
    CHAR           HeaderBuffer[64];
    CHAR           *pHeaderBuffPtr;
    STREAM_HEADER  StreamHeader;
    LARGE_INTEGER  liOffset;
    ULONG          ulEncodedSize;

    if(!m_bInitialized)
        return CO_E_ACNOTINITIALIZED;

    if (pStm == NULL)
    {
        return E_INVALIDARG;
    } // if

    // Other threads shouldn't mess with the object
    // when the object is saving its state

    EnterCriticalSection(&m_ACLLock);

    if (m_pcb.bDirtyHandle)
    {

        if (MesBufferHandleReset( m_pcb.PickleHandle
                                , MES_FIXED_BUFFER_HANDLE
                                , MES_ENCODE
                                , &(m_pcb.pPicklingBuff)
                                , m_pcb.ulPicklingBuffSize
                                , &(m_pcb.ulBytesUsed)) != RPC_S_OK)

        {
            hr = CO_E_SETSERLHNDLFAILED;
            goto Error;
        } // if

        m_pcb.bDirtyHandle = FALSE;

    } // if

    if (!(m_pcb.bPickled))
    {
        // Encode the STREAM_ACL structure into the pickling buffer
        STREAM_ACL_Encode(m_pcb.PickleHandle, &(m_pcb.StreamACL));
        m_pcb.bPickled = TRUE;
        m_pcb.bDirtyHandle = TRUE;
    } // if

    pHeaderBuffPtr = (CHAR *)(((ULONG_PTR)HeaderBuffer + 8) & ~7);

    // Create encoding handle
    if (MesEncodeFixedBufferHandleCreate( pHeaderBuffPtr
                                        , 56
                                        , &ulEncodedSize
                                        , &HeaderHandle ) != RPC_S_OK)
    {
        hr = CO_E_SETSERLHNDLFAILED;
        goto Error;
    } // if


    StreamHeader.ulStreamVersion = STREAM_VERSION;
    StreamHeader.ulPickledSize = m_pcb.ulBytesUsed;

    STREAM_HEADER_Encode(HeaderHandle, &StreamHeader);

    MesHandleFree(HeaderHandle);

    if(FAILED(hr = pStm->Write(pHeaderBuffPtr, ulEncodedSize, NULL)))
    {
        goto Error;
    } // if

    // Write encoded buffer to stream
    hr = pStm->Write(m_pcb.pPicklingBuff, m_pcb.ulBytesUsed, NULL);
    if (FAILED(hr))
    {
        goto Error;
    } // if

    // Reset the object's dirty flag if the user say so
    if (fClearDirty)
    {
        m_bDirty = FALSE;
    } // if

Error:
    LeaveCriticalSection(&m_ACLLock);
    return hr;

} // COAccessControl::CImpAccessControl::Save

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: COAccessControl::CImpAccessControl::GetSizeMax(), public
//
// Summary: This function returns the number of bytes required to store the
//          object's ACL to a stream. Notice that only the lower 32-bit of the
//          the ULARGE_INTEGER *pcbSize is used.
//
// Args: ULARGE_INTEGER *pcbSize [in] - Number of bytes required to store the
//                                      object's ACL.
//
// Return: HRESULT - S_OK: Succeeded.
//                   CO_E_ACNOTINITIALIZED: This method was called before
//                                        the DCOM IAccessControl object
//                                        was initialized by the Load method.
//                   CO_E_SETSERLHNDLFAILED: Failed to reset the serialization
//                                           handle.
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M
STDMETHODIMP_(HRESULT)
COAccessControl::CImpAccessControl::GetSizeMax
(
ULARGE_INTEGER *pcbSize
)
{
    HRESULT       hr = S_OK;
    STREAM_HEADER StreamHeader;

    if(!m_bInitialized)
        return CO_E_ACNOTINITIALIZED;
    if (pcbSize == NULL)
        return E_INVALIDARG;

    EnterCriticalSection(&m_ACLLock);
    if (m_pcb.bDirtyHandle)
    {

        if (MesBufferHandleReset( m_pcb.PickleHandle
                                , MES_FIXED_BUFFER_HANDLE
                                , MES_ENCODE
                                , &(m_pcb.pPicklingBuff)
                                , m_pcb.ulPicklingBuffSize
                                , &(m_pcb.ulBytesUsed)) != RPC_S_OK)

        {
            hr = CO_E_SETSERLHNDLFAILED;
            goto Error;
        } // if

        m_pcb.bDirtyHandle = FALSE;

    } // if

    if (!(m_pcb.bPickled))
    {
        STREAM_ACL_Encode(m_pcb.PickleHandle, &(m_pcb.StreamACL));
        m_pcb.bPickled = TRUE;
        m_pcb.bDirtyHandle = TRUE;

    } // if

    pcbSize->HighPart = 0;
    pcbSize->LowPart  = m_pcb.ulBytesUsed + g_ulHeaderSize;

Error:
    LeaveCriticalSection(&m_ACLLock);
    return hr;
} // COAccessControl::CImpAccessControl::GetSizeMax

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: COAccessControl::CImpAccessControl::GrantAccessRights()
//
// Args:
//       PACTRL_ACCESSW [in] - The array of ACTRL_ACCCESS_ENTRY structures to
//                             be processed.
// Modifies: m_ACLDesc, m_bDirty
//
// Return: HRESULT - S_OK: Succeeded.
//                   CO_E_ACNOTINITIALIZED: This method was called before
//                                        the DCOM IAccessControl object
//                                        was initialized by the Load method.
//                   E_INVALIDARG: This method will return E_INVALIDARG if
//                                 one of the following is true:
//                      1) One of the access mask specfied by the user is
//                         invalid.
//                      2) The pMultipleTrustee field in one of the user
//                         specified TRUSTEE_W structure is not NULL.
//                      3) The MultipleTrusteeOPeration field in one of the
//                         user specified TRUSTEE_W structure is not
//                         NO_MULTIPLE_TRUSTEE.
//                      4) The TrusteeType field in one of the user specified
//                         TRUSTEE_W structure has the value TRUSTEE_IS_UNKNOWN.
//                      5) (On Windows 95 only) The TrusteeForm field in one
//                         of the user specified TRUSTEE_W structure has
//                         the value TRUSTEE_IS_SID.
//                   E_OUTOFMEMORY: The system ran out of memory for some
//                                  crucial operations.
//                   CO_E_WRONGTRUSTEENAMESYNTAX: One of the trustee name
//                      specified by the client didn't conform to the
//                      <Domain>\<Account> syntax.
//                   CO_E_INVALIDSID: One of the security identifiers
//                      specified by the client was invalid.
//                   CO_E_NOMATCHINGNAMEFOUND: No matching account name
//                          could be found for one of the security identifiers
//                          specified by the client.
//                   CO_E_LOOKUPACCSIDFAILED: The system function,
//                          LookupAccountSID, failed during the reprocessing
//                          of the ACL. The client can call GetLastError to
//                          obtain extended error inforamtion.
//                   CO_E_NOMATCHINGSIDFOUND: No matching security identifier
//                                            could be found for one of the
//                                            trustee name specified by the
//                                            client.
//                   CO_E_LOOKUPACCNAMEFAILED: The system function,
//                          LookupAccountName, failed during the reprocessing
//                          of the ACL. The client can call GetLastError
//                          to obtain extended error information.
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M
STDMETHODIMP_(HRESULT)
COAccessControl::CImpAccessControl::GrantAccessRights
(
PACTRL_ACCESSW pAccessList
)
{

    STREAM_ACE        *pStreamACEReqs;     // Pointer to an array
                                           // of stream ACEs
                                           // converted from the
                                           // access request list
    ULONG             ulEstPickledSize;
    HRESULT           hr = S_OK;
    void             *pACEReqs;
    ULONG             cGrant;
    ULONG             cDeny;

    if(!m_bInitialized)
        return CO_E_ACNOTINITIALIZED;

    if (FAILED(hr = ValidateAndTransformAccReqList( pAccessList
                                                  , &pStreamACEReqs
                                                  , &pACEReqs
                                                  , &ulEstPickledSize
                                                  , &cGrant
                                                  , &cDeny )))
    {
        return hr;
    } // if

    EnterCriticalSection(&m_ACLLock);

    hr = AddAccessList( pStreamACEReqs, pACEReqs, ulEstPickledSize, cGrant,
                        cDeny );

    LeaveCriticalSection(&m_ACLLock);

    CleanupAccessList( FAILED(hr), pStreamACEReqs, pACEReqs, cGrant, cDeny );
    return hr;

} // COAccessControl::CImpAccessControl::GrantAccessRights

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
//
// Method: COAccessControl::CImpAccessControl::CleanupAccessList()
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M
STDMETHODIMP_(void)
COAccessControl::CImpAccessControl::CleanupAccessList
(
BOOL           fReleaseAll,
STREAM_ACE    *pStreamACEReqs,
void          *pvACEReqs,
ULONG          cGrant,
ULONG          cDeny
)
{
    ULONG              cCount;
    ULONG              i;
#if 0 // #ifdef _CHICAGO_
    access_list_2     *pACEReqs = (access_list_2 *) pvACEReqs;
    access_list_2     *pACE;               // Pointer for stepping through
                                           // the LAN Manager ACL in the ACLimage
#endif
    STREAM_ACE        *pStreamACEReqsPtr;  // Pointer for stepping
                                           // through the array of
                                           // access requests
                                           // transformed into
                                           // STREAM_ACE structures

    if (fReleaseAll)
    {
        cCount = cGrant + cDeny;
        pStreamACEReqsPtr = pStreamACEReqs;
#if 0 // #ifdef _CHICAGO_
        pACE = pACEReqs;
#endif
        for (i = 0; i < cCount; i++, pStreamACEReqsPtr++)
        {
            midl_user_free(pStreamACEReqsPtr->pTrusteeName);
#if 0 // #ifdef _CHICAGO_
            LocalMemFree(pACE->acl2_ugname);
            pACE++;
#else
            midl_user_free(pStreamACEReqsPtr->pSID);
#endif

        } // for
    }
    LocalMemFree(pStreamACEReqs);
#if 0 // #ifdef _CHICAGO_
    LocalMemFree(pACEReqs);
#endif
}

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
//
// Method: COAccessControl::CImpAccessControl::AddAccessList()
//
// Notes: This function assumes that the access list has been validated.  It
//        Can only fail if it runs out of memory.  In all failure conditions
//        the object's state is unchanged.  The caller must take the lock.
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M
STDMETHODIMP_(HRESULT)
COAccessControl::CImpAccessControl::AddAccessList
(
STREAM_ACE    *pStreamACEReqs,
void          *pvACEReqs,
ULONG          ulEstPickledSize,
ULONG          cGrant,
ULONG          cDeny
)
{

    ULONG             i;                   // Loop counters
    STREAM_ACE        *pStreamACEReqsPtr;  // Pointer for stepping
                                           // through the array of
                                           // access requests
                                           // transformed into
                                           // STREAM_ACE structures
    HRESULT           hr = S_OK;
    ULONG             cCount;
#if 0 // #ifdef _CHICAGO_
    access_list_2     *pACEReqs = (access_list_2 *) pvACEReqs;
    access_list_2     *pACE;               // Pointer for stepping through
                                           // the LAN Manager ACL in the ACLimage
#endif

    // Extend the stream ACL, the ACL image and the pickling
    // buffer to accomodate the new entries
    cCount = cGrant + cDeny;
    if(FAILED(hr = EnlargeStreamACL( &m_pcb
                                   , m_pcb.ulNumOfStreamACEs
                                   + cCount)))
    {
        return hr;
    } // if

    if(FAILED(hr = ResizePicklingBuff( &m_pcb, m_pcb.ulBytesUsed
                                     + ulEstPickledSize
                                     + 800)))
    {
        return hr;
    } // if
    m_pcb.ulBytesUsed += ulEstPickledSize;

#if 0 // #ifdef _CHICAGO_
    if (FAILED(hr = EnsureACLImage(&m_ACLDesc.GrantACL, cGrant)))
    {
        return hr;
    } // if
    if (FAILED(hr = EnsureACLImage(&m_ACLDesc.DenyACL, cDeny)))
    {
        return hr;
    } // if
    pACE = pACEReqs;

#endif

    for ( pStreamACEReqsPtr = pStreamACEReqs,i = 0
        ; i < cCount
        ; i++
#if 0 // #ifdef _CHICAGO_
        , pACE++
#endif
        , pStreamACEReqsPtr++)
    {


#if 0 // #ifdef _CHICAGO_
        AddACEToACLImage(pACE, pStreamACEReqsPtr->grfAccessMode, &m_ACLDesc);
#else
        m_ACLDesc.ulSIDSize += GetLengthSid(pStreamACEReqsPtr->pSID);
#endif
        AddACEToStreamACL(pStreamACEReqsPtr, &m_pcb);

    } // for

    // fixing up the cache
    m_Cache.FlushCache();

    // Re-compute the encoded size of the stream ACL
    m_pcb.bPickled = FALSE;
    m_bDirty = TRUE;
#if 0 // #ifdef _CHICAGO_
    if (cGrant != 0)
        m_ACLDesc.GrantACL.bDirtyACL = TRUE;
    if (cDeny != 0)
        m_ACLDesc.DenyACL.bDirtyACL = TRUE;
#else
    m_ACLDesc.bDirtyACL = TRUE;
#endif
    return S_OK;

} // COAccessControl::CImpAccessControl::GrantAccessRights

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: COAccessControl::CImpAccessControl::SetOwner(), public
//
// Summary: This method is not implemented at this moment
//
// Args:
//
// Modifies:
//
// Return: HRESULT - This method will always return E_NOTIMPL.
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M
STDMETHODIMP_(HRESULT)
COAccessControl::CImpAccessControl::SetOwner
(
PTRUSTEEW pOwner,
PTRUSTEEW pGroup
)
{
    return E_NOTIMPL;
} // COAccessControl::CimpAccessControl::SetOwner

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: COAccessControl::CImpAccessControl::SetAccessRights(), public
//
// Summary: This function replace the internal ACL with an array of
//          ACTRL_ACCESS_ENTRY structures provided by the caller of this method.
//          Note that this function does not literally replace the internal
//          ACL, instead it will map the array of ACTTRL_ACCESS_ENTRY structures
//          into the internal representation of an ACL.
//          This function will also merge entries with the same access mode
//          and trustee name together into one internal ACE.
//
// Args:
//       PACTRL_ACCESSW [in] - The array of ACTRL_ACCCESS_ENTRY structures to
//                             be processed.
//
// Modifies: m_ACLDesc, m_bDirty, m_pcb
//
// Return: HRESULT - S_OK: Succeeded.
//                   E_INVALIDARG: This method will return E_INVALIDARG if one of
//                                 the following is true:
//                   1) pExplicitAccessList is a NULL pointer.
//                   2) Inside one of the ACTRL_ACCESS_ENTRY structures specified
//                      by the client, either
//                      i) the grfAccessPermissions field contained an invalid
//                         access mask, or
//                      ii) the grfAccessMode field was neither ACTRL_ACCESS_ALLOWED
//                          nor ACTRL_ACCESS_DENIED, or
//                      iii) the grfInheritace field was not NO_INHERITANCE or
//                      iv) the pMultipleTrustee field in the TRUSTEE_W structure
//                          was not NULL, or
//                      v) the MultipleTrusteeOperation field in the TRUSTEE_W
//                         structure was not NO_MULTIPLE_TRUSTEE, or
//                      vi) the TrusteeType field in the TRUSTEE_Wstructure was
//                          TRUSTEE_IS_UNKNOWN, or
//                      vii) the ptstrNameFiled in the TRUSTEE_W structure was
//                           NULL, or
//                      On Windows 95 only:
//                      viii) the TrusteeForm field inside the TRUSTEE_W
//                            structure was TRUSTEE_IS_SID.
//                   E_OUTOFMEMORY: The system ran out of memory for crucial
//                                  operation.
//                   CO_E_ACNOTINITIALIZED: The DCOM IAccessCOntrol object was
//                                        not initialized by the load method
//                                        before this method is called.
//                   CO_E_WRONGTRUSTEENAMESYNTAX: The trustee name in the
//                          TRUSTEE_W structure inside one of the ACTRL_ACCESS_ENTRY
//                          structure specified by the client didn't conform to the
//                          <Domain>\<Account> syntax.
//                   CO_E_INVALIDSID: The security identifier in the TRUSTEE_W
//                                    structure inside one of the ACTRL_ACCESS_ENTRY
//                                    structure specified by the client was
//                                    invalid.
//                   (The following error codes are for Windows NT only)
//                   CO_E_NOMATCHINGNAMEFOUND: No matching account name
//                          could be found for one of the security identifiers
//                          specified by the client.
//                   CO_E_LOOKUPACCSIDFAILED: The system function,
//                          LookupAccountSID, failed during the reprocessing
//                          of the ACL. The client can call GetLastError to
//                          obtain extended error inforamtion.
//                   CO_E_NOMATCHINGSIDFOUND: No matching security identifier
//                                            could be found for one of the
//                                            trustee name specified by the
//                                            client.
//                   CO_E_LOOKUPACCNAMEFAILED: The system function,
//                          LookupAccountName, failed during the reprocessing
//                          of the ACL. The client can call GetLastError to
//                          obtain extended error information.
//
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M
STDMETHODIMP_(HRESULT)
COAccessControl::CImpAccessControl::SetAccessRights
(
PACTRL_ACCESSW pAccessList
)
{
    ACL_DESCRIPTOR     ACLDescBackup;      // Backup copy of the object's
                                           // original ACL descriptor
    PCB                pcbBackup;          // Backup copy of the object's
                                           // original pickle control
                                           // block
    STREAM_ACE        *pStreamACEReqs;     // Pointer to an array
                                           // of stream ACEs
                                           // converted from the
                                           // access request list
    ULONG             ulEstPickledSize;
    HRESULT           hr = S_OK;
    void             *pACEReqs;
    ULONG             cGrant;
    ULONG             cDeny;

    if(!m_bInitialized)
        return CO_E_ACNOTINITIALIZED;

    if (FAILED(hr = ValidateAndTransformAccReqList( pAccessList
                                                  , &pStreamACEReqs
                                                  , &pACEReqs
                                                  , &ulEstPickledSize
                                                  , &cGrant
                                                  , &cDeny )))
    {
        return hr;
    } // if

    EnterCriticalSection(&m_ACLLock);

    // Take a snapshot of the old ACL descriptor and the old PCB
    memcpy(&ACLDescBackup, &m_ACLDesc, sizeof(ACL_DESCRIPTOR));
    memset(&m_ACLDesc, 0, sizeof(ACL_DESCRIPTOR));

    memcpy(&pcbBackup, &m_pcb, sizeof(PCB));
    memset(&m_pcb, 0, sizeof(PCB));

    // Try to add the new entries.
    hr = AddAccessList( pStreamACEReqs, pACEReqs, ulEstPickledSize, cGrant,
                        cDeny );

    // If successful, move some resources from the backup
    if (SUCCEEDED(hr))
    {
#if 0 // #ifdef _CHICAGO_
        // Reuse the old dummy file name
        m_ACLDesc.DenyACL.pACL->acc1_resource_name  =
            ACLDescBackup.DenyACL.pACL->acc1_resource_name;
        m_ACLDesc.GrantACL.pACL->acc1_resource_name =
            ACLDescBackup.GrantACL.pACL->acc1_resource_name;
#else
        memcpy(&(m_ACLDesc.SecDesc),&(ACLDescBackup.SecDesc), sizeof(SECURITY_DESCRIPTOR));
        ACLDescBackup.SecDesc.Owner  = NULL;
        ACLDescBackup.SecDesc.Group  = NULL;
        m_ACLDesc.bDirtyACL          = TRUE;
#endif
        m_pcb.PickleHandle     = pcbBackup.PickleHandle;
        pcbBackup.PickleHandle = NULL;

        // Free the old ACL descriptor and PCB
        CleanAllMemoryResources(&ACLDescBackup, &pcbBackup);
    }

    // Restore the orignal ACL and PCB
    else
    {
        // Free the new ACL descriptor and PCB
        CleanAllMemoryResources(&m_ACLDesc, &m_pcb);

        memcpy(&m_ACLDesc, &ACLDescBackup, sizeof(ACL_DESCRIPTOR));
        memcpy(&m_pcb, &pcbBackup, sizeof(PCB));
    }
    LeaveCriticalSection(&m_ACLLock);

    CleanupAccessList( FAILED(hr), pStreamACEReqs, pACEReqs, cGrant, cDeny );
    return hr;

} // COAccessControl::CImpAccessControl::SetAccessRights

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: COAccessControl::CImpAccessControl::RevokeAccessRights()
//         , public
//
// Summary: This function removes all ACEs (both ACTRL_ACCESS_ALLOWED mode and
//          ACTRL_ACCESS_DENIED mode entries) associated with the list of of trustees
//          listed in pTrustee from the object's internal ACL.
//
// Args:
//       LPWSTR    lpProperty [in] - Property name, must be NULL.
//       ULONG     cCount     [in] - Number of trustee to be revoked from the
//                                   ACL.
//       TRUSTEE_W pTrustee   [in] - A list of trustees to be revoked.
//
// Return: HRESULT - S_OK: Succeeded.
//                   CO_E_ACNOTINITIALIZED
//                   E_INVALIDARG: Either pTrustee was NULL, or cCount was
//                                 zero, or one of the following was true
//                                 about at least one of the TRUSTEE_W structure
//                                 specified by the user:
//
//            1) The value of the pMultipleTrustee field in the TRUSTEE_W
//               structure was not NULL.
//            2) The value of the MultipleTrusteeOperation field in the
//               TRUSTEE_W structure was not NO_MULTIPLE_TRUSTEE.
//            3) The value of the TrusteeType field in the TRUSTEE_W
//               structure was TRUSTEE_IS_UNKNOWN.
//            4) The value of the ptstrName field in the TRUSTEE_W structure
//               was NULL.
//            On Windows 95 only:
//            5) The value of the TrusteeForm field in the TRUSTEE_W structure
//               was TRUSTEE_IS_SID.
//                   CO_E_WORNGTRUSTEENAMESYNTAX: At least one of the TRUSTEE_W
//                                                structures specified by the
//                                                user contained a trustee name
//                                                that did not conform to the
//                                                <Domain>/<Account Name>
//                                                syntax.
//                   CO_E_INVALIDSID: At least one of the TRUSTEE_W structures
//                                    specified by the user contained an invalid
//                                    security identifier.
//                   E_OUTOFMEMORY: There was not enough memory for allocating
//                                  a string conversion buffer.
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M
STDMETHODIMP_(HRESULT)
COAccessControl::CImpAccessControl::RevokeAccessRights
(
LPWSTR    lpProperty,
ULONG     cCount,
TRUSTEE_W pTrustee[]
)
{
    BOOL     bDeleted = FALSE;    // This flag indicates if any entry is
                                  // removed from theACL.
    ULONG     i;                  // Loop counter
    HRESULT   hr;                 // Function return code
    TRUSTEE_W *pLocalTrustee;     // Pointer for traversing the list of
                                  // trustees.
#if 0 // #ifdef _CHICAGO_
    ULONG       ulStrLen;         // Length of the trustee string in
                                  // multibyte characters
    ULONG       ulMaxLen = 0;     // Maximum length of all the trustee names
                                  // converted into multibyte strings.
    CHAR        *pcszTrusteeName; // Pointer to trustee name in multibyte
                                  // characters.
#endif


    if(!m_bInitialized)
        return CO_E_ACNOTINITIALIZED;

    if (cCount == 0 || lpProperty != NULL)
    {
        return E_INVALIDARG;
    } // if


    // The following loop validates the TRUSTEE_W structures
    // specified by the user. On Windows 95, this function
    // will also determine the length of the longest trustee
    // name in multibyte characters.
    pLocalTrustee = pTrustee;
    for (i = 0; i < cCount; i++, pLocalTrustee++)
    {

        if(FAILED(hr = ValidateTrustee(pLocalTrustee)))
        {
            return hr;
        } // if

#if 0 // #ifdef _CHICAGO_
        ulStrLen = WideCharToMultiByte( g_uiCodePage
                                      , WC_COMPOSITECHECK | WC_SEPCHARS
                                      , pLocalTrustee->ptstrName
                                      , -1
                                      , NULL
                                      , NULL
                                      , NULL
                                      , NULL );
        if (ulStrLen > ulMaxLen)
        {
            ulMaxLen = ulStrLen;
        } //if
#endif
    } // for

#if 0 // #ifdef _CHICAGO_

    // Allocate a buffer for converting Unicode trustee name into
    // multibyte trustee name. An extra 5 bytes is allocated for
    // extra safety.
    ulMaxLen += 5;
    pcszTrusteeName = (CHAR *)LocalMemAlloc(ulMaxLen);
    if(pcszTrusteeName == NULL)
    {
        return E_OUTOFMEMORY;
    } // if
#endif

    EnterCriticalSection(&m_ACLLock);


    pLocalTrustee = pTrustee;
    for (i = 0; i < cCount ; i++, pLocalTrustee++)
    {
#if 0 // #ifdef _CHICAGO_
        ulStrLen = WideCharToMultiByte ( g_uiCodePage
                                       , WC_COMPOSITECHECK | WC_SEPCHARS
                                       , pLocalTrustee->ptstrName
                                       , -1
                                       , pcszTrusteeName
                                       , ulMaxLen
                                       , NULL
                                       , NULL);
        pcszTrusteeName[ulStrLen] = '\0';
#endif
        if (DeleteACEFromStreamACL( pLocalTrustee
                                  , ACTRL_ACCESS_DENIED
                                  , &m_ACLDesc
                                  , &m_pcb))
        {
#if 0 // #ifdef _CHICAGO_
            DeleteACEFromACLImage( pcszTrusteeName
            , &(m_ACLDesc.DenyACL));
            m_ACLDesc.DenyACL.bDirtyACL = TRUE;
#endif
            bDeleted = TRUE;
        } // if

        if (DeleteACEFromStreamACL( pLocalTrustee
                                  , ACTRL_ACCESS_ALLOWED
                                  , &m_ACLDesc
                                  , &m_pcb))
        {
#if 0 // #ifdef _CHICAGO_
            DeleteACEFromACLImage( pcszTrusteeName
                                 , &(m_ACLDesc.GrantACL));
            m_ACLDesc.GrantACL.bDirtyACL = TRUE;
#endif
            bDeleted = TRUE;
        } // if

    } // for

    if (bDeleted)
    {
        m_bDirty = TRUE;
#ifndef _CHICAGO_
        m_ACLDesc.bDirtyACL = TRUE;
#endif
        // Fix up the cache
        m_Cache.FlushCache();
        m_pcb.bPickled = FALSE;
    } // if

#if 0 // #ifdef _CHICAGO_
    LocalMemFree(pcszTrusteeName);
#endif

    LeaveCriticalSection(&m_ACLLock);

    return S_OK;

} // COAccessControl::CImpAccessControl::RevokeAccessRights

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: COAccessControl::CImpAccessControl::IsAccessAllowed(), public
//
// Summary: This function performs access checking for the client.
//          Only the execute permission is supported at this moment and the
//          the trustee specified by the client must be the client itself.
//
// Args:
//       TRUSTEE      *pTrustee     [in]     - Pointer to the trustee to
//                                             perform access check for.
//       LPWSTR        lpProperty   [in]     - Must be NULL.
//       ACCESS_RIGHTS AccessRights [in]     - A bit mask representing the set
//                                             of permissions the client wants
//                                             to check.
//       BOOL         *pfAccessAllowed [out] - Set TRUE only if trustee has
//                                             requested access.
//
// Common on both Windows 95 and Windows NT:
// Return: HRESULT - S_OK: Succeeded, and the requested access was granted to
//                         the trustee.
//                   CO_E_ACNOTINITIALIZED: The COM IAccessControl object
//                                        was not initialized before
//                                        this method was called.
//                   E_ACCESSDENIED: The requested access was denied
//                                   from the trustee.
//                   E_INVALIDARG: Either one of the following was true:
//
//            1) The value of the pMultipleTrustee field in the TRUSTEE_W
//               structure was not NULL.
//            2) The value of the MultipleTrusteeOperation field in the
//               TRUSTEE_W structure was not NO_MULTIPLE_TRUSTEE.
//            3) The value of the TrusteeType field in the TRUSTEE_W
//               structure was TRUSTEE_IS_UNKNOWN.
//            4) The value of the ptstrName field in the TRUSTEE_W structure
//               was NULL.
//
//                   CO_E_TRUSTEEDOESNTMATCHCLIENT: The trustee specified by the
//                                                  client was not the current
//                                                  ORPC client.
//                   CO_E_WRONGTRUSTEENAMESYNTAX: The trustee name inside the
//                                                TRUSTEE_W structure specified
//                                                by the user is not of the
//                                                form <Domain>\<Account Name>.
//                   CO_E_FAILEDTOQUERYCLIENTBLANKET: Unable to query for the
//                                                    client's security blanket.
//                   E_UNEXPECTED: This function should not return E_UNEXPECTED
//                                 under all circumstances.
//
//
// On Windows 95
// Return: HRESULT - E_INVALIDARG: In addition to the four cases stated above,
//                                 E_INVALIDARG will be returned if the
//                                 TrusteeForm field of the TRUSTEE_W structure
//                                 pointed to by the pTrustee parameter is
//                                 TRUSTEE_IS_SID.
//                   CO_E_NETACCESSAPIFAILED: Either the NetAccessAdd API or
//                                            the NetAccessDel APi returned
//                                            an error code in
//                                            ComputeEffectiveAccess.
//                   CO_E_CONVERSIONFAILED: WideCharToMultiByte returned zero.
//                                          The caller can get extended error
//                                          information by calling GetLastError.
//                   E_OUTOFMEMORY: Either there was not enough memory to
//                                  convert the Unicode trustee name into a
//                                  multibyte string in
//                                  ValidateAccessCheckClient of there
//                                  was not enough memory to do the same in
//                                  ComputeEffectiveAccess.
// On Windows NT:
//                   CO_E_FAILEDTOGETSECCTX: Failed to obtain an IServerSecurity
//                                           pointer to the current server
//                                           security context.
//                   CO_E_FAILEDTOIMPERSONATE: The GetEffAccUsingSID/Name was
//                                             unable to impersonate
//                                             the client who calls this
//                                             function.
//                   CO_E_FAILEDOPENTHREADTOKEN: The GetEffAccUsingSID/Name
//                                               method was unable to open the
//                                               access token assciated
//                                               with the current thread. The
//                                               client of this method can
//                                               call GetLastError to get
//                                               extended error information.
//                   CO_E_FAILEDTOGETTOKENINFO: The GetEffAccUsingSID/Name
//                                              method was unable to obtain
//                                              obtain information from the
//                                              access token associated with
//                                              the current thread. The client
//                                              of this method can call
//                                              GetLastError to get extended
//                                              error information.
//                   CO_E_ACCESSCHECKFAILED: The system function, AccessCheck,
//                                           returned FALSE in
//                                           ComputeEffectiveAccess. The
//                                           caller of this method can call
//                                           GetLastError to obtain extended
//                                           error information.
//                   CO_E_INVALIDSID: At least one of the TRUSTEE_W structures
//                                    specified by the user contained an invalid
//                                    security identifier.
//                   CO_E_FAILEDTOSETDACL: SetSecurityDescriptorDacl returned
//                                         false inside PutStreamACLIntoSecDesc.
//                                         The client of this method can call
//                                         GetLastError to get extended error
//                                         information.
//                   E_OUTOFMEMORY: The system ran out of memory for mapping the
//                                  DCOM IAccessControl object's STREAM_ACL
//                                  structure to an NT ACL or the system
//                                  could not allocate memory for the TOKEN_USER
//                                  structure returned by GetTokenInformation.
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M
STDMETHODIMP_(HRESULT)
COAccessControl::CImpAccessControl::IsAccessAllowed
(
TRUSTEE_W     *pTrustee,
LPWSTR         lpProperty,
ACCESS_RIGHTS  AccessRights,
BOOL          *pfAccessAllowed
)
{
    DWORD   dwPermissions = 0;
    HRESULT hr;

    // Initialize access allowed to FALSE.
    if (pfAccessAllowed == NULL)
    {
        return E_INVALIDARG;
    }
    *pfAccessAllowed = FALSE;

    // Validate the arguments.
    if (!IsValidAccessMask(AccessRights) ||
        lpProperty != NULL)
    {
        return E_INVALIDARG;
    } // if
    if (FAILED(hr = ValidateAccessCheckClient(pTrustee)))
    {
        return hr;
    } // if

    if(!m_bInitialized)
        return CO_E_ACNOTINITIALIZED;

#if 0 // #ifdef _CHICAGO_
    EnterCriticalSection(&m_ACLLock);
    if (!m_Cache.LookUpEntry(pTrustee->ptstrName, &dwPermissions))
    {
        if(FAILED(hr = ComputeEffectiveAccess( pTrustee->ptstrName
                                             , &dwPermissions
                                             , &m_ACLDesc)))
        {
            LeaveCriticalSection(&m_ACLLock);
            return hr;
        } // if
        m_Cache.WriteEntry(pTrustee->ptstrName, dwPermissions);
    } // if

    LeaveCriticalSection(&m_ACLLock);
#else

    hr = GetEffAccRights( pTrustee , &dwPermissions );

    if(FAILED(hr))
    {
        return hr;
    }
#endif

    // Indicate failure by setting pfAccessAllowed.
    if ((dwPermissions & AccessRights) == AccessRights)
    {
        *pfAccessAllowed = TRUE;
    }
    return S_OK;

} // COAccessControl::CImpAccessControl::IsAccessAllowed

#if 1 // #ifndef _CHICAGO_
//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: COAccessControl::CImpAccessControl::GetEffAccRights, Private
//
// Summary: Given a Unicode string representing the name of a user, this
//          function computes the effective access permission that the
//          specified user has on the secured object. Notice that the current
//          implementation of this method limits the trustee specified by the
//          client to be the name of the same client calling this method.
//
// Args: LPWSTR pwszTrusteeName [in] - Pointer to a Unicode string
//                                     representing the user whose effective
//                                     access permissions on the secured object
//                                     is about to be determined by this
//                                     method. Notice that this parameter must
//                                     specify the name of the client calling
//                                     this function.
//       DWORD *pdwRights [out] - Address of an access mask representing the
//                                set of effective access rights the user
//                                specified by the pwszTrusteeName parameter
//                                has on the secured object.
//
// Return: HRESULT - S_OK: Succeeded.
//                   CO_E_FAILEDTOGETSECCTX: Failed to obtain an IServerSecurity
//                                           pointer to the current server
//                                           security context.
//                   CO_E_FAILEDTOIMPERSONATE: This method was unable to
//                                             impersonate the client who calls
//                                             this function.
//                   CO_E_FAILEDOPENTHREADTOKEN: This method was unable to
//                                               open the access token assciated
//                                               with the current thread. The
//                                               client of this method can call
//                                               GetLastError to get extended
//                                               error information.
//                   CO_E_FAILEDTOGETTOKENINFO: This method was unable to obtain
//                                              obtain information from the
//                                              access token associated with
//                                              the current thread. The client
//                                              of this method can call
//                                              GetLAstError to get extended
//                                              error information.
//                   CO_E_FAILEDTOQUERYCLIENTBLANKET: Failed to query for the
//                                                    client's security blanket.
//                   CO_E_ACCESSCHECKFAILED: The system function, AccessCheck,
//                                           returned FALSE in
//                                           ComputeEffectiveAccess. The
//                                           caller of this method can call
//                                           GetLastError to obtain extended
//                                           error information.
//                   CO_E_FAILEDTOSETDACL: SetSecurityDescriptorDacl returned
//                                         false inside PutStreamACLIntoSecDesc.
//                                         The client of this method can call
//                                         GetLastError to get extended error
//                                         information.
//                   E_OUTOFMEMORY: The system ran out of memory for mapping the
//                                  DCOM IAccessControl object's STREAM_ACL
//                                  structure to an NT ACL or the system
//                                  could not allocate memory for the TOKEN_USER
//                                  structure returned by GetTokenInformation.
//
// Remarks: It is neccessary for this method to impersonate the client
//          in order to obtain the client's access token for access checking.
//          If the call context has the impersonate flag TRUE, the server
//          may be impersonating anyone and we must save the current thread
//          token and restore it before returning.  We cannot call Revert
//          because that would change the server's state.  If the call
//          context does not have the impersonate flag TRUE, we can do
//          anything to the thread token after impersonating because Revert
//          will restore the token that was on the thread on entry to this
//          method.
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M
STDMETHODIMP_(HRESULT)
COAccessControl::CImpAccessControl::GetEffAccRights
(
TRUSTEE_W *pTrustee,
DWORD     *pdwRights
)
{
    IServerSecurity *pSSec                 = NULL;
    HRESULT          hr                    = S_OK;
    BOOL             bImpersonatingOnEnter = FALSE;
    BOOL             bImpersonated         = FALSE;
    HANDLE           hEnter                = INVALID_HANDLE_VALUE;
    HANDLE           hImpersonate          = INVALID_HANDLE_VALUE;
    TOKEN_STATISTICS sTokenStatistics;
    DWORD            dwInfoLength          = sizeof(sTokenStatistics);
    BOOL             bSuccess;

    // Call get call context to obtain an IServerSecurity
    // pointer corresponding to the call context of the
    // current thread.
    hr = CoGetCallContext( IID_IServerSecurity
                         , (void **)&pSSec);
    if (FAILED(hr))
    {
        return CO_E_FAILEDTOGETSECCTX;
    } // if

    EnterCriticalSection(&m_ACLLock);

    // Check if the server is already impersonating someone.  If so,
    // save that token.  Ignore errors since there is no possible recovery.
    bImpersonatingOnEnter = pSSec->IsImpersonating();
    if (bImpersonatingOnEnter)
    {
        OpenThreadToken( GetCurrentThread(), TOKEN_READ, TRUE, &hEnter );
    } // if

    // Impersonate the server's current caller.
    hr = pSSec->ImpersonateClient();
    if (FAILED(hr))
    {
        hr = CO_E_FAILEDTOIMPERSONATE;
        goto Error;
    } // if
    bImpersonated = TRUE;

    // Open the current thread token, it should be the
    // access token of the client.
    bSuccess = OpenThreadToken( GetCurrentThread()
                              , TOKEN_READ
                              , TRUE
                              , &hImpersonate);
    if (!bSuccess)
    {
        hr = CO_E_FAILEDTOOPENTHREADTOKEN;
        goto Error;
    } // if

    // Remove the thread token so the APIs below succeed.  Ignore errors
    // because there is no possible recovery.
    SetThreadToken( NULL, NULL );

    // Get the SID from the access token for cache lookup
    bSuccess = GetTokenInformation( hImpersonate
                                  , TokenStatistics
                                  , &sTokenStatistics
                                  , dwInfoLength
                                  , &dwInfoLength );
    if (!bSuccess)
    {
        hr = CO_E_FAILEDTOGETTOKENINFO;
        goto Error;
    } // if

#ifndef _CHICAGO_
    // Use the SID inside ClientInfo to lookup the
    // the effective access rights in the cache
    bSuccess = m_Cache.LookUpEntry(sTokenStatistics.ModifiedId, pdwRights);
    if (!bSuccess)
    {
        // Perform access checking
        hr = ComputeEffectiveAccess( &m_ACLDesc
                                   , &(m_pcb.StreamACL)
                                   , hImpersonate
                                   , pdwRights);
        if (FAILED(hr))
        {
            goto Error;
        } // if
        m_Cache.WriteEntry(sTokenStatistics.ModifiedId, *pdwRights);
    } // if
#endif

Error:
    LeaveCriticalSection(&m_ACLLock);

    // Release the impersonation token handle
    if (hImpersonate != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hImpersonate);
    } // if

    // Restore the impersonation status
    if (bImpersonated)
    {
        // If the server was impersonating, don't Revert.
        if (bImpersonatingOnEnter)
            SetThreadToken( NULL, hEnter );
        else
            pSSec->RevertToSelf();
    } // if

    // Release the saved token handle
    if (hEnter != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hEnter);
    } // if

    // Release the IServerSecurity pointer
    if (pSSec != NULL)
    {
        pSSec->Release();
    } // if

    return hr;

} // COAccessControl::CImpAccessControl:GetEffAccRights
#endif

//M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
// Method: COAccessControl::CImpAccessControl::GetAllAccessRights(), public
//
// Summary: This function returns an array of ACTRL_ACCESS_ENTRY structures which
//          represents the ACL that belongs to the secured object. Notice
//          that memory is allocated by the callee for the array of
//          structures and the trustee string within each
//          structure.  The client of this method must call
//          CoTaskMemFree to free those memory blocks when they are no longer
//          in use. Notice that in a multi-threaded environment, the array
//          returned may not accurately represent the object's ACL by
//          the time the caller receives it.
//
// Return: HRESULT - S_OK: Succeeded.
//                   E_OUTOFMEMORY: Not enough memory to allocate the
//                                  ACTRL_ACCESS_ENTRY array to be return.
//                   E_INVALIDARG: If one of the arguments passed in is NULL
//                   CO_E_ACNOTINITIALIZED: The DCOM IAccessControl implementation
//                                        object was not initialized properly
//                                        by the load method before this method
//                                        was called.
//
//M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M
STDMETHODIMP_(HRESULT)
COAccessControl::CImpAccessControl::GetAllAccessRights
(
LPWSTR              lpProperty,
PACTRL_ACCESSW     *ppAccessList,
PTRUSTEEW          *ppOwner,
PTRUSTEEW          *ppGroup
)
{
    HRESULT  hr = S_OK;

    if(!m_bInitialized)
        return CO_E_ACNOTINITIALIZED;

    // Validate the arguments
    if (lpProperty != NULL || ppAccessList == NULL)
    {
        return E_INVALIDARG;
    } // if

    if (ppOwner != NULL)
    {
        *ppOwner = NULL;
    }
    if (ppGroup != NULL)
    {
        *ppGroup = NULL;
    }

    EnterCriticalSection(&m_ACLLock);

    hr = MapStreamACLToAccessList( &m_pcb, ppAccessList );

    LeaveCriticalSection(&m_ACLLock);
    return hr;
} // COAccessControl::CImpAccessControl::GetAllAccessRights

//////////////////////////////////////////////////////////////////////////////
// Miscellaneous utility functions
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// functions that are common on both platform
//////////////////////////////////////////////////////////////////////////////

//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: ResizePicklingBuff
//
// Summary: This function resize the pickling buffer within a pickling
//          control block. Note that this function doesn't copy the content
//          in the old buffer over to the new buffer.
//
// Args: PCB *ppcb [in,out] - Pointer to the pickling control block
//                            that contains the pickling buffer to be resized.
//       ULONG ulBytesRequired [in] - Number of bytes required in the new
//                                    pickling buffer.
//
// Return: HRESULT - S_OK: Success.
//                   E_OUTOFMEMORY: Out of memory.
//
// Called by: COAccessControl::CImpAccessControl::Load
//            AddACEToACL
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
HRESULT ResizePicklingBuff
(
PCB    *ppcb,
ULONG  ulBytesRequired
)
{
    CHAR *pNewTruePointer;

    if (ulBytesRequired > ppcb->ulPicklingBuffSize)
    {
        pNewTruePointer = (CHAR *)LocalMemAlloc((ulBytesRequired + 7));
            // At most 7 more bytes are needed to align the pickling buffer
        if (pNewTruePointer == NULL)
        {
            return E_OUTOFMEMORY;
        } // if

        LocalMemFree(ppcb->pTruePicklingBuff);

        ppcb->pTruePicklingBuff = pNewTruePointer;
        // 8-byte align the pickling buffer
        ppcb->pPicklingBuff = (char *)(((ULONG_PTR)(pNewTruePointer + 7))&~7);
        ppcb->ulPicklingBuffSize = ulBytesRequired;
        ppcb->bDirtyHandle = TRUE;
    } // if
    return S_OK;
} // ResizePicklingBuff

//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: FreePicklingBuff
//
// Summary: This function releases the memmory allocated for a pickling
//          buffer.
//
// Args: PCB *ppcb [in] - Pickling control block that contains the pickling
//                        buffer to be released
//
// Return: void
//
// Called by: CleanAllMemoryResources
//            COAccessControl::CImpAccessControl::Load
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
void FreePicklingBuff
(
PCB *ppcb
)
{
  LocalMemFree(ppcb->pTruePicklingBuff);
  ppcb->pPicklingBuff = NULL;
  ppcb->pTruePicklingBuff = NULL;
  ppcb->ulPicklingBuffSize = 0;

} // FreePicklingBuff

//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: EnlargeStreamACL
//
// Summary: This function reallocates the stream ACE array inside a pickle
//          control block to a bigger memory block in order to accomodate the
//          the extra number of stream ACEs needed by the user.
//
// Args: PCB *ppcb [in] - Pickle control block containing the stream ACE array
//                        to be resized.
//
// Return: HRESULT - S_OK: Success
//                   E_OUTOFMEMORY: Out of memory
//
// Called by: AddACEToACL
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
HRESULT EnlargeStreamACL
(
PCB   *ppcb,
ULONG ulNumOfEntries
)
{
    ULONG         ulNewSize;
    ULONG         ulOldSize;
    STREAM_ACE    *pNewStreamACL;

    if (ulNumOfEntries + ppcb->ulNumOfStreamACEs > ppcb->ulMaxNumOfStreamACEs)
    {
        ulNewSize = ppcb->ulMaxNumOfStreamACEs + ulNumOfEntries;

        pNewStreamACL = (STREAM_ACE *)midl_user_allocate((ulNewSize + 10)
                      * sizeof(STREAM_ACE));
        if (pNewStreamACL == NULL)
        {
            return E_OUTOFMEMORY;
        } // if

        if (ppcb->StreamACL.pACL != NULL)
        {
            memcpy( pNewStreamACL
                  , ppcb->StreamACL.pACL
                  , ppcb->ulNumOfStreamACEs * sizeof(STREAM_ACE));
            midl_user_free(ppcb->StreamACL.pACL);
        } // if

        ppcb->ulMaxNumOfStreamACEs = ulNewSize;
        ppcb->StreamACL.pACL = pNewStreamACL;
    } // if

    return S_OK;
} // EnlargeStreamACL

//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: ReadACLFromStream
//
// Summary: This function reads an ACL from an IStream object into the
//          STREAM_ACL struture of an pickle control block.
//
// Args: IStream *pStm [in] - Pointer to an IStream object containing
//                           an ACL.
//       PCB *ppcb [in,out] - Pointer to a PCB structure containing the
//                            STREAM_ACL into which the ACL in the IStream
//                            object is going to be decoded.
//
// Return: HRESULT - S_OK: Success.
//                   E_OUTOFMEMORY: The system ran out of memory for some
//                                  crucial operation.
//                   CO_E_SETSERLHNDLFAILED: Unable to (re)set a serialization
//                                           handle.
//                   CO_E_DECODEFAILED: Unable to decode the ACL in the
//                                      IStream object.
//                   CO_E_INCOMPATIBLESTREAMVERSION: The version code in the
//                                                   stream header was not
//                                                   supported by this version
//                                                   of IAccessControl.
//                   CO_E_FAILEDTOCLOSEHANDLE: Unable to close a serialization
//                                             handle.
//                   CO_E_EXCEEDSYSACLLIMIT: The number of ACEs in the ACL
//                                           provided by the user exceeded the
//                                           limit imposed by the system that
//                                           is loading the ACL. On Windows 95,
//                                           the system can handle 32767
//                                           ACTRL_ACCESS_DENIED ACEs and 32767
//                                           ACTRL_ACCESS_ALLOWED ACEs. On Windows NT,
//                                           the system can only handle 32767
//                                           ACTRL_ACCESS_DENIED and ACTRL_ACCESS_ALLOWED ACEs
//                                           combined.
//                   E_INVALIDARG: This method will return E_INVALIDARG if
//                                 either
//                                 a) the ACL in the stream provided by the
//                                    user contains an invalid access mask, or
//                                 b) one of STREAM_ACE structure in the ACL
//                                    provided by the user contains a null
//                                    pTrusteeName pointer.
//                   CO_E_ACESINWRONGORDER: Not all ACTRL_ACCESS_DENIED ACEs in the ACL
//                                          provided by the user were arranged
//                                          in front of the ACTRL_ACCESS_ALLOWED ACEs.
//                   CO_E_WRONGTRUSTEENAMESYNTAX: The ACL provided by the user
//                                                contained a trustee name
//                                                string that didn't conform
//                                                to the <Domain>\<Account>
//                                                syntax.
//                   CO_E_LOOKUPACCNAMEFAILED: (Window NT only) The system call,
//                                             LookupAccountName, failed. The user can
//                                             call GetLastError to obtain extended error
//                                             information.
//                   CO_E_NOMATCHINGSIDFOUND: No matching security identifier
//                                            could be found for one of the
//                                            trustee name specified by the
//                                            client.
//
// Called by: COAccessControl:CImpAccessControl::Load
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
HRESULT ReadACLFromStream
(
IStream *pStm,
PCB     *ppcb
#if 1 // #ifndef _CHICAGO_
,ACL_DESCRIPTOR *pACLDesc
#endif
)
{
    HRESULT       hr = S_OK;
    ULONG         ulBuffSize = 0;
    STREAM_HEADER StreamHeader;
    ULONG         ulTotalSIDSize;
    ULONG         ulEstAdditionalSIDSize;

    if (FAILED(hr = ResizePicklingBuff(ppcb, g_ulHeaderSize)))
    {
        return hr;
    } // if

    // Set up fixed buffer decoding handle
    if ( MesDecodeBufferHandleCreate( ppcb->pPicklingBuff
                                    , g_ulHeaderSize
                                    , &(ppcb->PickleHandle)) != RPC_S_OK )
    {
        return CO_E_SETSERLHNDLFAILED;
    } // if

    if (FAILED(hr = pStm->Read((void *)(ppcb->pPicklingBuff), g_ulHeaderSize, NULL)))
    {
        return hr;
    } // if

    // Decode the stream header
    RpcTryExcept
    {
        STREAM_HEADER_Decode(ppcb->PickleHandle, &StreamHeader);
    }
    RpcExcept(1)
    {
        return CO_E_DECODEFAILED;
    }
    RpcEndExcept

    if (StreamHeader.ulStreamVersion != STREAM_VERSION)
    {
        return CO_E_INCOMPATIBLESTREAMVERSION;
    } // if

    ulBuffSize = StreamHeader.ulPickledSize;

    // Allocate a buffer that is big enough to hold the
    // the stream
    if (FAILED(hr = ResizePicklingBuff(ppcb, ulBuffSize + 800)))
    {
        return hr;
    } // if

    if(FAILED(hr = pStm->Read((void *)(ppcb->pPicklingBuff), ulBuffSize, NULL)))
    {
        return hr;
    } // if

    // Re-create a decoding handle
    if (MesBufferHandleReset( ppcb->PickleHandle
                            , MES_FIXED_BUFFER_HANDLE
                            , MES_DECODE
                            , &(ppcb->pPicklingBuff)
                            , ppcb->ulPicklingBuffSize
                            , &(ppcb->ulBytesUsed)) != RPC_S_OK)
    {
        return CO_E_SETSERLHNDLFAILED;
    } // if

    // Decode the stream content into the stream ACL
    RpcTryExcept
    {
        STREAM_ACL_Decode(ppcb->PickleHandle, &(ppcb->StreamACL));
    }
    RpcExcept(1)
    {
        return CO_E_DECODEFAILED;
    }
    RpcEndExcept

    ppcb->ulBytesUsed = ulBuffSize;

    // Free the decoding handle
    hr = MesHandleFree(ppcb->PickleHandle);
    ppcb->PickleHandle = NULL;
    if (hr != RPC_S_OK)
    {
        return CO_E_FAILEDTOCLOSEHANDLE;
    } // if

    ppcb->bPickled = TRUE;

    // Validate the stream ACL
#if 0 // #ifdef _CHICAGO_
    if(FAILED(hr = ValidateAndFixStreamACL(&(ppcb->StreamACL))))
#else
    if(FAILED(hr = ValidateAndFixStreamACL( &(ppcb->StreamACL)
                                          , &ulTotalSIDSize
                                          , &ulEstAdditionalSIDSize)))
#endif
    {
        if((hr != CO_E_NOMATCHINGSIDFOUND) && (hr != CO_E_LOOKUPACCNAMEFAILED))
        {
            return hr;
        } // if
    } // if

#ifndef _CHICAGO_
    // Windows NT, the size of the ACL may have changed after
    // fixing the stream ACL so we may have to reallocate the
    // pickling buffer
    if (ulEstAdditionalSIDSize > 0)
    {
        if(FAILED(hr = ResizePicklingBuff( ppcb
                                         , ppcb->ulBytesUsed
                                         + ulEstAdditionalSIDSize
                                         + 800)))
        {
            return hr;
        } // if
        ppcb->bPickled = FALSE;
    } // if

    pACLDesc->ulSIDSize = ulTotalSIDSize;

#endif
    return hr;
} // ReadACLFromStream

//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: AddACEToStreamACL
//
// Summary: This function inserts a STREAM_ACE structure into an existing
//          STREAM_ACE array in a PCB structure. This function assumes that
//          the STREAM_ACL inside the pcb is large enough to hold the new entry.
//
// Args: STREAM_ACE *pStreamACE [in] - Pointer to the StreamACE structure to be added
//
//       PCB *ppcb [in,out] - Pointer to the pickle control block that contains
//                            the stream ACL to which the new stream ACE is added.
//
// Return: void
//
// Called by: COAccessControl:CImpAccessControl::GrantAccessRights
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
void AddACEToStreamACL
(
STREAM_ACE       *pStreamACE,
PCB              *ppcb
)
{
    STREAM_ACE *pLastEntry;         // Pointer to the last ACE with the specified
                                    // access mode
    STREAM_ACE *pInsertionPoint;    // Pointer to STREAM_ACE slot in the STREAM_ACE
                                    // array that the new STREAM_ACE structure will be
                                    // inserted.

    pLastEntry = ppcb->StreamACL.pACL
               + ppcb->ulNumOfStreamACEs;
    if (pStreamACE->grfAccessMode == ACTRL_ACCESS_DENIED)
    {
        pInsertionPoint = ppcb->StreamACL.pACL
                        + ppcb->StreamACL.ulNumOfDenyEntries;
        memcpy(pLastEntry, pInsertionPoint, sizeof(STREAM_ACE));
        ppcb->StreamACL.ulNumOfDenyEntries++;
    }
    else
    {
        pInsertionPoint = pLastEntry;
        ppcb->StreamACL.ulNumOfGrantEntries++;
    }

    memcpy(pInsertionPoint, pStreamACE, sizeof(STREAM_ACE));
    ppcb->ulNumOfStreamACEs++;

} // AddACEToStreamACL

//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: IsValidAccessMask
//
// Summary:  This function checks if an access permission mask provided by
//           the user is valid or not.
//
// Args: DWORD stdmask [in] - Standard mask to be validated.
//
// Return: BOOL - TRUE: The mask is valid
//                FALSE: Otherwise
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
BOOL IsValidAccessMask
(
DWORD stdmask
)
{
    return ((stdmask & ~COM_RIGHTS_ALL) ? FALSE : TRUE);
} // IsValidAccessMask

//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: DeleteACEFromStreamACL
//
// Summary: This function remove all the ACEs that matches the input trustee
//          name from the stream ACL.
//
// Args: LPWSTR pTrustee [in] - Pointer to the trustee string that identifies
//                              the ACE to be removed from the stream ACL.
//       ULONG AccessMode [in] - Access mode of the entry that the
//                                     the caller is interested in removing.
//       SID_TRUSTEE *pSIDTrustee [out] - (Windows NT only) Pointer to
//                   a SID_TRUSTEE structure. This structure is used to pass
//                   out the string name and the SID of first ACE removed from
//                   the STREAM_ACL. These two pieces of information are
//                   used by the caller to update the cache and the
//                   caller must free the memory for the SID and
//                   trustee name afterwards.
//       PCB *ppcb [in,out] - Pointer to the pickle control block which
//                            contains a STREAM_ACL structure.
//
// Return: BOOL FALSE: Successful completion of the operation but the trustee
//                     could not be found in the relevant portion of the
//                     STREAM_ACE array inside the STREAM_ACL structure.
//              TRUE: Successful completion of the operation. All the
//                    ACEs that have a matching trustee name from the
//                    relevant portion of STREAM_ACE array.
//
// Called by: COAccessControl::CImpAccessControl::RevokeAccessRights.
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
BOOL DeleteACEFromStreamACL
(
PTRUSTEE_W     pTrustee,
ULONG          AccessMode,
#if 1 // #ifndef _CHICAGO_
ACL_DESCRIPTOR *pACLDesc,
#endif
PCB            *ppcb
)
{
    ULONG      i;                       // Loop counter
    STREAM_ACE *pStreamACE;             // Pointer for traversing the array
                                        // of STREAM_ACE structures inside the
                                        // STREAM_ACL structure of the pickle control block.
    STREAM_ACE *pLastEntry;             // Pointer to the 'last' ACE with the
                                        // the specified access mode.
    ULONG      *pulNumOfEntries;        // The total number of ACEs in the STREAM_ACL
                                        // structure with the specified
                                        // acces mode.
    BOOL       bResult = FALSE;         // Internal function return code.

    switch (AccessMode)
    {
        case ACTRL_ACCESS_DENIED:
            pulNumOfEntries = &(ppcb->StreamACL.ulNumOfDenyEntries);
            pStreamACE = ppcb->StreamACL.pACL;
            break;
        case ACTRL_ACCESS_ALLOWED:
            pulNumOfEntries = &(ppcb->StreamACL.ulNumOfGrantEntries);
            pStreamACE = ppcb->StreamACL.pACL
                       + ppcb->StreamACL.ulNumOfDenyEntries;
            break;
    } // switch

    pLastEntry = ppcb->StreamACL.pACL
               + ppcb->StreamACL.ulNumOfGrantEntries
               + ppcb->StreamACL.ulNumOfDenyEntries - 1;

    for (i = 0; i < *pulNumOfEntries ; i++ )
    {

        // The following while loop is necessary to handle
        // cases where the matching STREAM_ACEs are bunched
        // up at the 'end' of the relevant portion of the
        // STREAM_ACE array.
#if 0 // #ifdef _CHICAGO_
        while( (i < *pulNumOfEntries) &&
               (lstrcmpiW( pTrustee->ptstrName
                            , pStreamACE->pTrusteeName) == 0))

#else
        while( (i < *pulNumOfEntries) &&
               (((pTrustee->TrusteeForm == TRUSTEE_IS_NAME) &&
                 (lstrcmpiW( pTrustee->ptstrName
                           , pStreamACE->pTrusteeName) == 0)) ||
                ((pTrustee->TrusteeForm == TRUSTEE_IS_SID) &&
                 (pStreamACE->pSID != NULL &&
                  EqualSid( (PSID)(pTrustee->ptstrName)
                          , (PSID)(pStreamACE->pSID))))))
#endif
        {
            (*pulNumOfEntries)--;
            ppcb->ulNumOfStreamACEs--;
#ifndef _CHICAGO_
            if (pStreamACE->pSID != NULL)
            {
                pACLDesc->ulSIDSize -= GetLengthSid(pStreamACE->pSID);
                midl_user_free(pStreamACE->pSID);
            } // if
#endif
            midl_user_free(pStreamACE->pTrusteeName);
            switch(AccessMode)
            {
                case ACTRL_ACCESS_DENIED:
                    if (i < (*pulNumOfEntries))
                    {
                        memcpy( pStreamACE
                              , ppcb->StreamACL.pACL + *pulNumOfEntries
                              , sizeof(STREAM_ACE));
                    } // if
                    memcpy( ppcb->StreamACL.pACL + *pulNumOfEntries
                          , pLastEntry
                          , sizeof(STREAM_ACE));

                    break;
                case ACTRL_ACCESS_ALLOWED:
                    if (i < (*pulNumOfEntries))
                    {
                        memcpy(pStreamACE, pLastEntry, sizeof(STREAM_ACE));
                    } //  if
                    break;
            } // switch

            memset(pLastEntry, 0, sizeof(STREAM_ACE));
            pLastEntry--;
            bResult = TRUE;
        } // while
        pStreamACE++;
    } // for
    return bResult;

} // DeleteACEFromStreamACL

//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: MapStreamACLToAccessList
//
// Summary: This function maps a stream ACL to an array of
//          ACTRL_ACCESS_ENTRY structures. This function allocates all
//          memory needed for the output access list.  It cleans up all
//          memory in case of error.
//
// Return: HRESULT S_OK: Succeeded
//                 E_OUTOFMEMORY: The system ran out of memory for allocating
//                                the trustee identifiers to be returned.
//
// Called by: COAccessControl::CImpAccessControl::GetAllAccessRights
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
HRESULT MapStreamACLToAccessList
(
PCB                *ppcb,
PACTRL_ACCESSW     *ppAccessList
)
{
    PACTRL_ACCESSW             pAccessList;
    PACTRL_PROPERTY_ENTRYW     pProperty;
    PACTRL_ACCESS_ENTRY_LISTW  pEntryList;
    PACTRL_ACCESS_ENTRYW       pEntry;
    PACTRL_ACCESS_ENTRYW       pCurrEntry;
    char                      *pTrusteeName;

    STREAM_ACE         *pStreamACEsPtr;          // Pointer for stepping through
                                                 // the stream ACL
    ULONG              i = 0;
    LPWSTR             pwszName;                 // Pointer to the trustee name
                                                 // inside the stream ACE of the
                                                 // current iteration
    ULONG              ulNumOfEntries;           // Total number of stream ACEs to map
    ULONG              ulSize;

    // Compute the amount of memory needed for the trustee names and sids.
    ulNumOfEntries = ppcb->ulNumOfStreamACEs;
    pStreamACEsPtr = ppcb->StreamACL.pACL;
    ulSize         = 0;
    for (i = 0; i < ulNumOfEntries; i++)
    {
#ifndef _CHICAGO_
        if(pStreamACEsPtr->TrusteeForm == TRUSTEE_IS_NAME)
        {
#endif
            ulSize += (lstrlenW(pStreamACEsPtr->pTrusteeName) + 1) *
                      sizeof(WCHAR);
#ifndef _CHICAGO_
        }
        else
        {
            ulSize += GetLengthSid((PISID)pStreamACEsPtr->pSID);
        } // if
#endif
        pStreamACEsPtr++;
    } // for

    // Allocate memory for everything
    ulSize += sizeof(ACTRL_ACCESSW) + sizeof(ACTRL_PROPERTY_ENTRYW) +
              sizeof(ACTRL_ACCESS_ENTRY_LISTW) +
              sizeof(ACTRL_ACCESS_ENTRYW) * ulNumOfEntries;
    pAccessList    = (PACTRL_ACCESSW) LocalMemAlloc( ulSize );
    if (pAccessList == NULL)
    {
        *ppAccessList = NULL;
        return E_OUTOFMEMORY;
    }
    pProperty      = (PACTRL_PROPERTY_ENTRYW) (pAccessList + 1);
    pEntryList     = (PACTRL_ACCESS_ENTRY_LISTW) (pProperty + 1);
    if (ulNumOfEntries != 0)
    {
        pEntry       = (PACTRL_ACCESS_ENTRYW) (pEntryList + 1);
        pTrusteeName = (char *) (pEntry + ulNumOfEntries);
    }
    else
    {
        pEntry       = NULL;
    }

    // Initialize the top three levels of structures.
    pAccessList->cEntries            = 1;
    pAccessList->pPropertyAccessList = pProperty;
    pProperty->lpProperty            = NULL;
    pProperty->pAccessEntryList      = pEntryList;
    pProperty->fListFlags            = 0;
    pEntryList->cEntries             = ulNumOfEntries;
    pEntryList->pAccessList          = pEntry;

    pCurrEntry     = pEntry;
    pStreamACEsPtr = ppcb->StreamACL.pACL;
    for (i = 0; i < ulNumOfEntries; i++)
    {
        pwszName = pStreamACEsPtr->pTrusteeName;

        // On Windows 95, the only form of trustee identifier supported is
        // a Unicode string while a security identifier or a Unicode string
        // can be used to specify a trustee on Windows NT.
#ifndef _CHICAGO_
        if(pStreamACEsPtr->TrusteeForm == TRUSTEE_IS_NAME)
        {
#endif
            ulSize = (lstrlenW(pwszName) + 1) * sizeof(WCHAR);
            memcpy( pTrusteeName, pwszName, ulSize );
#ifndef _CHICAGO_
        }
        else
        {
            ulSize = GetLengthSid((PISID)pStreamACEsPtr->pSID);
            CopySid(ulSize, (PSID)pTrusteeName, pStreamACEsPtr->pSID);
        } // if
#endif
        pCurrEntry->Trustee.ptstrName        = (WCHAR *) pTrusteeName;
        pCurrEntry->Trustee.TrusteeType      = pStreamACEsPtr->TrusteeType;
        pCurrEntry->Trustee.TrusteeForm      = pStreamACEsPtr->TrusteeForm;
        pCurrEntry->Trustee.pMultipleTrustee = NULL;       // Not supported
        pCurrEntry->Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE; // Not supported
        pCurrEntry->Access                   = pStreamACEsPtr->grfAccessPermissions;
        pCurrEntry->ProvSpecificAccess       = 0;
        pCurrEntry->Inheritance              = NO_INHERITANCE; // Not supported
        pCurrEntry->lpInheritProperty        = NULL;
        pCurrEntry->fAccessFlags             = pStreamACEsPtr->grfAccessMode;
        pTrusteeName                        += ulSize;
        pStreamACEsPtr++;
        pCurrEntry++;
    } // for

    *ppAccessList = pAccessList;
    return S_OK;
} // MapStreamACLToAccessList

//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: CleanAllMemoryResources()
//
// Summary: This function frees all the memory allocated for an initialized
//          COAccessControl object. On Windows 95, this function will release
//          all the memory allocated for the ACL_DESCRIPTOR structure except
//          for the two resource name in the LAN Manager ACL embedded in the
//          ACL_DESCRIPTOR structure. The idea behind such an arrange is to
//          reuse existing resource as much as possible so that performanace
//          can be improved.
//
// Args: ACL_DESCRIPTOR *pACLDesc [in,out] - This structure describes
//                      how DCOM IAccessControl implementaion object packages
//                      platform specific ACL.
//       PCB *ppcb [in,out] - The pickling control block owned by the
//                            same object.
//
// Return: void
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
void CleanAllMemoryResources
(
ACL_DESCRIPTOR *pACLDesc,
PCB            *ppcb
)
{
    // Clean up old Stream ACL
    FreePicklingBuff(ppcb);
    MesHandleFree(ppcb->PickleHandle);
    CleanUpStreamACL(&(ppcb->StreamACL));

    // Cleanup the ACL images
#if 0 // #ifdef _CHICAGO_
    CleanUpACLImage(&(pACLDesc->DenyACL));
    CleanUpACLImage(&(pACLDesc->GrantACL));
#else
    LocalMemFree(pACLDesc->pACLBuffer);
    LocalMemFree(pACLDesc->SecDesc.Owner);
    LocalMemFree(pACLDesc->SecDesc.Group);
#endif

} // CleanAllMemoryResources

#if 0 // #ifdef _CHICAGO_
//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: ComputeEffectiveAccess, Chicago version
//
// Summary: Given the trustee name, and the ACL descritpor, this function
//          computes the effective access rights that a the trustee has.
//
// Args: LPWSTR pTrustee [in] - Pointer to a NULL terminated Unicode string
//                              that represents the trustee.
//       DWORD *pEffectiveRights [out] - Reference to a 32-bit bit mask that
//                                       represents the set of access rights
//                                       the trustee has.
//       ACL_DESCRIPTOR *pACLDesc [in] - Platform dependent representation
//                                       of the ACL.
//
// Return: HRESULT - S_OK: Succeeded.
//                   E_OUTOFMEMORY: Not enough memory to transform the Unicode
//                                  trustee string to a multibyte string.
//                   CO_E_CONVERSIONFAILED: WideCharToMultiByte returned
//                                          error. The user can call
//                                          GetLastError to get extended
//                                          error information.
//                   CO_E_NETACCESSAPIFAILED: One one the NetAccess functions
//                                            called in this function
//                                            returned an error code.
//
// Called by: COAccessControl::CImpAccessControl::IsAccessAllowed
//            COAccessControl::CImpAccessControl::GetEffectiveAccessRights
//
// Notes: NetAccessAdd on some machines adds "*" when you call with a list
//        with no entries.
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
HRESULT ComputeEffectiveAccess
(
LPWSTR pTrustee,
DWORD  *pEffectivePermissions,
ACL_DESCRIPTOR *pACLDesc
)
{
    CHAR          *pName;
    API_RET_TYPE  uReturnCode;
    CHAR          *pResource;
    access_info_1 *pACLHeader;
    USHORT        uResult;
    HRESULT       hr = S_OK;

    if(FAILED(hr = WStringToMBString(pTrustee, &pName)))
    {
        return hr;
    }
    // Start checking from the list of deny entries

    // See if the deny mode list is dirty, and update the registry if necessary
    pACLHeader = pACLDesc->DenyACL.pACL;
    pResource  = pACLHeader->acc1_resource_name;

    // Skip this if the ACL is empty.
    if (pACLHeader->acc1_count != 0)
    {
        if (pACLDesc->DenyACL.bDirtyACL)
        {
            NetAccessDel(NULL, pResource);

            // Notice that NetAccessAdd puts data into the registry
            if( NERR_Success != NetAccessAdd( NULL
                                            , 2
                                            , (char *)pACLHeader
                                            , sizeof(access_info_1)
                                            + pACLHeader->acc1_count
                                            * sizeof(access_list_2)))
            {
                hr = CO_E_NETACCESSAPIFAILED;
                goto Error;
            } // if
            pACLDesc->DenyACL.bDirtyACL = FALSE;
        } // if

        if ( NERR_Success != NetAccessCheck( NULL
                                           , pName
                                           , pResource
                                           , CHICAGO_RIGHTS_EXECUTE
                                           , &uResult) )
        {
            hr = CO_E_NETACCESSAPIFAILED;
            goto Error;
        } // if

        // Negate the result of access checking on the deny list.
        // I.e. if the result is positive, the user is explicitly denied
        // access to the object.

        if (uResult == 0)
        {
            *pEffectivePermissions = 0; // hard coded to zero
            LocalMemFree(pName);
            return S_OK;
        } // if
    }

    // If the previous result is negative, we have to
    // move on to see if the user is granted access through
    // the grant ACL.
    pACLHeader = pACLDesc->GrantACL.pACL;
    pResource  = pACLHeader->acc1_resource_name;

    // If there are no Allow ACEs, deny access.
    if (pACLHeader->acc1_count == 0)
    {
        *pEffectivePermissions = 0; // hard coded to zero
        LocalMemFree(pName);
        return S_OK;
    } // if

    // See if the grant mode list is dirty and update the registry if necessary
    if (pACLDesc->GrantACL.bDirtyACL)
    {
        NetAccessDel(NULL, pResource);

        if( NERR_Success != NetAccessAdd( NULL
                                        , 2
                                        , (char *)pACLHeader
                                        , sizeof(access_info_1)
                                        + pACLHeader->acc1_count
                                        * sizeof(access_list_2)))
        {
            hr = CO_E_NETACCESSAPIFAILED;
            goto Error;
        } // if
        pACLDesc->GrantACL.bDirtyACL = FALSE;
    } // if

    if ( NERR_Success != NetAccessCheck( NULL
                                       , pName
                                       , pResource
                                       , CHICAGO_RIGHTS_EXECUTE
                                       , &uResult) )
    {
        hr = CO_E_NETACCESSAPIFAILED;
        goto Error;
    } // if

    if (uResult == 0)
    {
        *pEffectivePermissions = COM_RIGHTS_EXECUTE;
    }
    else
    {
        *pEffectivePermissions = 0;
    } // if


Error:
    LocalMemFree(pName);
    return hr;

} // ComputeEffectiveAccess
#else

//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: ComputeEffectiveAccess, NT version
//
// Summary: Given a handle to an access token representing a user, an
//          ACL_DESCRIPTOR structure and a STREAM_ACL structure , this function
//          will compute the effective access permissions that the user
//          represented by the access token has.
//
// Args: ACL_DESCRIPTOR *pACLDesc [in,out] - Pointer to the NT version of the
//                      ACL_DESCRIPTOR structure. Thsi structure should contain
//                      a buffer for the NT ACL structure, a NT security
//                      descriptor, a control flag and size information.
//       STREAM_ACL *pStreamACL [in] - It may be the case that the STREAM_ACL
//                  structure of an DCOM IAccessControl implementation object
//                  has not been mapped into the security descriptor's dacl
//                  inside the ACL_DESCRIPTOR, so it is necessary that object
//                  that calls this function to pass in its STREAM_ACL
//                  structure. In fact, this is only place where a STREAM_ACL
//                  will be mapped into a dacl.
//       HANDLE TokenHandle [in] - This should be the access token of the
//              user that the caller wants to compute the effective access
//              permissions for.
//       DWORD *pdwRights [out] - Address of the effective access permissions
//                                that the user corresponding to the
//                                access token specified in the TokenHandle
//                                has on the secured object.
//
// Return: HRESULT - S_OK: Succeeded.
//                   E_OUTOFMEMORY: The system ran out of memory for
//                                  allocating the NT ACL.
//                   CO_E_FAILEDTOSETDACL: SetSecurityDescriptorDacl returned
//                                         false inside PutStreamACLIntoSecDesc.
//                                         The client of this method can call
//                                         GetLastError to get extended error
//                                         information.
//                   CO_E_ACCESSCHECKFAILED: The system function, AccessCheck,
//                                           returned FALSE in
//                                           ComputeEffectiveAccess. The
//                                           caller of this method can call
//                                           GetLastError to obtain extended
//                                           error information.
//
//
// Called by: COAccessControl:CImpAccessControl:GetEffAccRights
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
HRESULT ComputeEffectiveAccess
(
ACL_DESCRIPTOR *pACLDesc,
STREAM_ACL     *pStreamACL,
HANDLE         TokenHandle,
DWORD          *pdwRights
)
{
    HRESULT         hr = S_OK;
    ACCESS_MASK     AccessMaskOut = 0; // Access mask returned by
                                       // AccessCheck
    ACCESS_MASK     AccessMaskIn = 0;  // Access permissions to check for
    BOOL            bAccessStatus;     // Access checking status.
                                       // TRUE - Access granted.
                                       // FALSE - Access denied.
                                       // This function doesn't really care
                                       // about this result, all it wants
                                       // is the set the of permissions
                                       // that a user effectively has.
    DWORD           dwSetLen;          // Length of the privilege set.

    dwSetLen = sizeof(gDummyPrivilege);

    // If the ACL has not been set into the security
    // security inside the ACL descriptor, do so now.
    if (pACLDesc->bDirtyACL)
    {
        if(FAILED(hr = PutStreamACLIntoSecDesc( pStreamACL
                                              , pACLDesc)))
        {
            return hr;
        } // if

    } // if

    // Call access check
    if(!AccessCheck( &(pACLDesc->SecDesc)
                   , TokenHandle
                   , NT_RIGHTS_ALL
                   , &gDummyMapping
                   , &gDummyPrivilege
                   , &dwSetLen
                   , &AccessMaskOut
                   , &bAccessStatus))
    {
        return CO_E_ACCESSCHECKFAILED;
    } // if

    // Convert the NT access mask back to IAccessControl access mask.
    NTMaskToStandardMask(&AccessMaskOut, pdwRights);

    return S_OK;


} // ComputeEffectiveAccess

#endif


//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: ValidateAndTransformAccReqList
//
// Summary: This function validates the fields inside a list of ACCESS_REQUEST
//          structures and transform it into a list of stream ACE structures.
//          This function is
//          also responsible for estimating the total size of the STREAM_ACE
//          structures returned to the caller if they are serialized into a
//          buffer using RPC serialization service. On WIndows 95, this function
//          will set up an array of access_list_2 structures representing the
//          input access request list for the caller. On Windows NT, this function
//          will lookup the SID or the trustee name for each access request depending
//          on which one is specified by the caller.
//
// Args: PACCESS_REQUEST_W pAccReqList [in] - Pointer to the access request to
//                                            be validated and transformed.
//       ULONG ulNumOfRequestIn [in] - Number of ACCESS_REQUEST_W structures
//       STREAM_ACE **ppStreamACEs [out] - Pointer to an array of stream ACEs
//                  transformed from the access request list. The array of
//                  STREAM_ACE structures and the SID and trustee name inside
//                  each of the STREAM_ACE structure returned are allocated by
//                  this function using midl_user_allocate so the caller should
//                  release the memory allocated for these structures using
//                  midl_user_allocate.
//       access_list_2 **ppACEs [out] - (Chicago only)Address of a pointer to
//                     an array of access_list_2 structures to be returned to the
//                     caller. Notice that this function will allocate memory
//                     for the array and the User/group name in each of
//                     access_list_2 structure returned using LocalMemAlloc.
//                     Once the caller receives this output parameter, it
//                     becomes the caller's responsiblility to release the
//                     memory allocated for this structure when it is no
//                     longer in use.
//       ULONG *pulEstPickledSize [out] - Pointer to the estimated number of
//                                        bytes needed for serializing the
//                                        STREAM_ACE structures returned. The
//                                        estimated
//                                        number of bytes required to serialize
//                                        a STREAM_ACE structure into a buffer
//                                        using RPC serialization service is
//                                        computed by the folowing formula:
//       Size of the Unicode trustee string + Size of the SID + Size of the
//       STREAM_ACE structure + 48
//       The number 48 is an arbitrary large number that should account for
//       all the extra space required by RPC to align the data structure and
//       to add additional information to the header.
//
// Return: HRESULT - S_OK: Succeeded.
//                   E_OUTOFMEMORY: The system ran out of memory for some
//                                  crucial operations.
//                   E_INVALIDARG: The access mask in one of the
//                                 ACCESS_REQUEST_W structures was invalid of
//                                 the TRUSTEE structure provided by the user
//                                 was invalid.
//                   CO_E_CONVERSIONFAILED: WideCharToMultiByte returned zero.
//                                          The caller can get extended error
//                                          information by calling GetLastError.
//                   CO_E_INVALIDSID: At least one of the TRUSTEE_W structures
//                                    specified by the user contained an invalid
//                                    security identifier.
//                   CO_E_NOMATCHINGNAMEFOUND: No matching account name
//                          could be found for one of the security identifiers
//                          specified by the client.
//                   CO_E_LOOKUPACCSIDFAILED: The system function,
//                          LookupAccountSID, failed. The client can call
//                          GetLastError to obtain extended error inforamtion.
//                   CO_E_NOMATCHINGSIDFOUND: No matching security identifier
//                                            could be found for one of the
//                                            trustee name specified by the
//                                            client.
//                   CO_E_LOOKUPACCNAMEFAILED: The system function,
//                          LookupAccountName, failed. The client can call
//                          GetLastError to obtain extended error information.
//
// Called by: COAccessControl::CImpAccessControl::GrantAccessRights
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
HRESULT ValidateAndTransformAccReqList
(
PACTRL_ACCESSW      pAccessList,
STREAM_ACE        **ppStreamACEs,
void              **ppACEs,
ULONG              *pulEstPickledSize,
ULONG              *pcGrant,
ULONG              *pcDeny
)
{
    HRESULT               hr = S_OK;
    STREAM_ACE           *pStreamACEs;    // Pointer to an array of stream ACEs
    STREAM_ACE           *pStreamACEsPtr; // Pointer for traversing the
                                          // array of stream ACEs
    PACTRL_ACCESS_ENTRYW  pCurrEntry;     // Pointer for traversing the
                                          // access request list
    PTRUSTEE_W            pTrustee;       // Pointer to the TRUSTEE structure in
                                          // the access request structure
#if 0 // #ifdef _CHICAGO_
    DWORD                 dwLastError;    // GetLastError return code holder
    access_list_2        *pACEs;          // Pointer to an array of access_list_2
                                          // structures to be returned to the caller
    access_list_2        *pACEsPtr;       // Pointer for traversing the array of
                                          // access_list_2 structures.
#else
    ULONG                 ulSIDLen;       // Length of the SID that is currently being
                                          // examined.
#endif
    ULONG                 ulStrLen;       // Length of the trustee string in number
                                          // of Unicode characters
    ULONG                 i,j;            // Loop counters
    ULONG                 ulEstPickledSize = 0; // Estimated pickled size of the access
                                          // requests if they all turn into stream ACEs
    TRUSTEE_TYPE          TrusteeType = TRUSTEE_IS_UNKNOWN;
    ULONG                 cCount;

    // Initialize ACE counts.
    *pcGrant = 0;
    *pcDeny  = 0;

    // Validate the top three levels of the structure.
    if (pAccessList == NULL                                  ||
        pAccessList->cEntries != 1                           ||
        pAccessList->pPropertyAccessList == NULL             ||
        pAccessList->pPropertyAccessList->lpProperty != NULL ||
        pAccessList->pPropertyAccessList->fListFlags != 0    ||
        pAccessList->pPropertyAccessList->pAccessEntryList == NULL)
    {
        return E_INVALIDARG;
    }
    cCount = pAccessList->pPropertyAccessList->pAccessEntryList->cEntries;
    pCurrEntry = pAccessList->pPropertyAccessList->pAccessEntryList->pAccessList;
    if (cCount != 0 && pCurrEntry == NULL)
    {
        return E_INVALIDARG;
    }

    // Allocate an array of stream ACEs
    pStreamACEs = (STREAM_ACE *)LocalMemAlloc( sizeof(STREAM_ACE) * cCount);
    if (pStreamACEs == NULL)
    {
        return E_OUTOFMEMORY;
    } // if

#if 0 // #ifdef _CHICAGO_
    pACEs = (access_list_2 *)midl_user_allocate( sizeof(access_list_2)
                                               * cCount);

    if (pACEs == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }
    pACEsPtr = pACEs;
#endif

    // Map the access requests to stream ACEs and validates the fields in
    // of the access requests as we go along
    pStreamACEsPtr = pStreamACEs;
    for (i = 0; i < cCount; i++)
    {
        pTrustee = &(pCurrEntry->Trustee);
        TrusteeType = pTrustee->TrusteeType;

        // Validate this entry.
        if (!IsValidAccessMask(pCurrEntry->Access))
        {
            hr = E_INVALIDARG;
            goto Error;
        } // if
        if(FAILED(hr = ValidateTrustee(pTrustee)))
        {
            goto Error;
        }
        if (pCurrEntry->ProvSpecificAccess != 0       ||
            pCurrEntry->Inheritance != NO_INHERITANCE ||
            pCurrEntry->lpInheritProperty != NULL     ||
            (pCurrEntry->fAccessFlags != ACTRL_ACCESS_ALLOWED &&
             pCurrEntry->fAccessFlags != ACTRL_ACCESS_DENIED))
        {
            hr = E_INVALIDARG;
            goto Error;
        }

#ifndef _CHICAGO_
        if (pTrustee->TrusteeForm == TRUSTEE_IS_NAME)
        {
#endif
            ulStrLen                     = lstrlenW(pTrustee->ptstrName);
            ulEstPickledSize            += (ulStrLen + 1) * sizeof(WCHAR);
            pStreamACEsPtr->pTrusteeName = (LPWSTR)
                midl_user_allocate( (ulStrLen + 1) * sizeof(WCHAR));
            if (pStreamACEsPtr->pTrusteeName == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto Error;
            }

            memcpy( pStreamACEsPtr->pTrusteeName
                  , pTrustee->ptstrName
                  , sizeof(WCHAR) * (ulStrLen + 1));
            pStreamACEsPtr->pSID = NULL;
#ifndef _CHICAGO_

            if (FAILED(hr = GetSIDFromName( (void **)&(pStreamACEsPtr->pSID)
                                          , pStreamACEsPtr->pTrusteeName
                                          , &TrusteeType)))
            {
                LocalMemFree(pStreamACEsPtr->pTrusteeName);
                goto Error;
            } // if
            ulEstPickledSize += GetLengthSid(pStreamACEsPtr->pSID);
        }
        else
        {

            // Copy the SID to the stream ACE strusture
            ulSIDLen             = GetLengthSid((PISID)(pTrustee->ptstrName));
            ulEstPickledSize    += ulSIDLen;
            pStreamACEsPtr->pSID = (PSTREAM_SID)midl_user_allocate(ulSIDLen);
            if (pStreamACEsPtr->pSID == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto Error;
            } //if
            CopySid(ulSIDLen, (PSID)(pStreamACEsPtr->pSID),
                    (PSID)(pTrustee->ptstrName));

            if(FAILED(hr = GetNameFromSID( &(pStreamACEsPtr->pTrusteeName)
                                         , (PSID)(pStreamACEsPtr->pSID)
                                         , &TrusteeType)))
            {
                LocalMemFree(pStreamACEsPtr->pSID);
                goto Error;
            } // if

            ulEstPickledSize += lstrlenW(pStreamACEsPtr->pTrusteeName);
        } // if

#endif
        pStreamACEsPtr->TrusteeForm          = pCurrEntry->Trustee.TrusteeForm;
        pStreamACEsPtr->grfAccessPermissions = pCurrEntry->Access;
        pStreamACEsPtr->TrusteeType          = TrusteeType;
        pStreamACEsPtr->grfAccessMode        = (ACCESS_MODE) pCurrEntry->fAccessFlags;
        if (pCurrEntry->fAccessFlags == ACTRL_ACCESS_ALLOWED)
        {
            (*pcGrant)++;
        }
        else
        {
            (*pcDeny)++;
        }
        pStreamACEsPtr++;

#if 0 // #ifdef _CHICAGO_
        if (FAILED(hr = WStringToMBString(pTrustee->ptstrName, &(pACEsPtr->acl2_ugname))))
        {
            LocalMemFree(pStreamACEsPtr->pTrusteeName);
            goto Error;
        } // if
        StandardMaskToLANManagerMask( &(pCurrEntry->Access)
                                    , &(pACEsPtr->acl2_access));
        if (pTrustee->TrusteeType == TRUSTEE_IS_GROUP)
        {
            pACEsPtr->acl2_access |= ACCESS_GROUP;
        } // if

        pACEsPtr++;
#endif
        pCurrEntry++;

    } // for

#if 0 // #ifdef _CHICAGO_
    *ppACEs = pACEs;
#endif
    *ppStreamACEs = pStreamACEs;
    *pulEstPickledSize = ulEstPickledSize
                       + cCount
                       * (sizeof(WCHAR)
                       + 48 + sizeof(STREAM_ACE));
    return S_OK;

Error:
    pStreamACEsPtr = pStreamACEs;
#if 0 // #ifdef _CHICAGO_
    pACEsPtr = pACEs;
#endif

    // Release the memory allocated for the
    // trustee strings and SIDs inside the
    // each of the STREAM_ACE and access_list_2
    // structures.
    for ( j = 0; j < i; j++, pStreamACEsPtr++)
    {
        LocalMemFree(pStreamACEsPtr->pTrusteeName);
#if 0 // #ifdef _CHICAGO_
        LocalMemFree(pACEsPtr->acl2_ugname);
        pACEsPtr++;
#else
        LocalMemFree(pStreamACEsPtr->pSID);
#endif
    } // for

#if 0 // #ifdef _CHICAGO_
    // Release the array of access_list_2 structures
    if (pACEs != NULL)
    {
        LocalMemFree(pACEs);

    } // if
#endif

    // Release the array of STREAM_ACE structures
    if (pStreamACEs != NULL)
    {
        LocalMemFree(pStreamACEs);
    }
    *pulEstPickledSize = 0;
    *ppStreamACEs = NULL;
    return hr;

} // ValidateAndTransformAccessRequests


//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: ValidateAndFixStreamACL
//
// Summary: This function validates the fields in a STREAM_ACL structure and all
//          the STREAM_ACE structures that it contains. On Windows 95, this function
//          will make sure that the value of the TrusteeType field in
//          each of the STREAM_ACE structure is TRUSTEE_IS_NAME. On Windows NT,
//          this function will make sure that each STREAM_ACE structure contains
//          both the trustee name and the SID. Besides making sure that both the
//          trustee name and the SID are in every STREAM_ACE structure, this function
//          has to compute the total size in bytes of all the SIDs in the
//          stream ACL and the estimated "pickled" size of all the SIDs that
//          this function has found missing in the original stream ACL on
//          Windows NT.
//
// Args: STREAM_ACL *pStreamACL [in] - Pointer to the STREAM_ACL strucutre to be
//                                     validated.
//       On Windows NT:
//       ULONG *pulTotalSIDSize [out] - Address of the total size of all the SIDs
//                                      in the stream ACL in bytes. This number
//                                      is used by other parts of the module to
//                                      compute the expected size of the NT
//                                      ACL.
//       ULONG *pulEstAdditionalSIDSize [out] - Address of the estimated total
//                                              size of all the missing SID
//                                              that this function has filled-
//                                              in when they are serialized into
//                                              a buffer using the RPC serialization
//                                              service. This number is used
//                                              by the caller to estimate
//                                              size of the buffer required to
//                                              serialize the STREAM_ACL structure.
//                                              The estimated number of bytes
//                                              required for serializing each
//                                              additonal SID is computed by
//                                              the following formula:
//                    Size of the SID + 32
//         Notice that it is neccessary to add extra bytes to the estimate
//         because RPC may need extra bytes for alignment and additional
//         information in the header. 32 is an arbitrary number that should
//         be big enough to accomodate the extra bytes required for alignment
//         and extra header information. Any estimate that produces a number
//         greater than or equal to the actual serialized size of an SID
//         should be considered as good asthe the one provided above.
//
// Return: HRESULT - S_OK: Success.
//                   CO_E_EXCEEDSYSACLLIMIT: The number of ACEs in the ACL
//                                           provided by the user exceeded the
//                                           limit imposed by the system that
//                                           is loading the ACL. On Windows 95,
//                                           the system can handle 32767
//                                           ACTRL_ACCESS_DENIED ACEs and 32767
//                                           ACTRL_ACCESS_ALLOWED ACEs. On Windows NT,
//                                           the system can only handle 32767
//                                           ACTRL_ACCESS_DENIED and ACTRL_ACCESS_ALLOWED ACEs
//                                           combined.
//                   E_INVALIDARG: This function will return E_INVALIDARG if
//                                 either
//                                 a) the ACL in the stream provided by the
//                                    user contains an invalid access mask, or
//                                 b) one of STREAM_ACE structure in the ACL
//                                    provided by the user contains a null
//                                    pTrusteeName pointer.
//                   CO_E_ACESINWRONGORDER: Not all ACTRL_ACCESS_DENIED ACEs in the ACL
//                                          provided by the user were arranged
//                                          in front of the ACTRL_ACCESS_ALLOWED ACEs.
//                   CO_E_WRONGTRUSTEENAMESYNTAX: The ACL provided by the user
//                                                contained a trustee name
//                                                string that didn't conform
//                                                to the <Domain>\<Account>
//                                                syntax.
//                   CO_E_LOOKUPACCNAMEFAILED: (Window NT only) The system call,
//                                             LookupAccountName, failed. The user can
//                                             call GetLastError to obtain extended error
//                                             information.
//                   E_OUTOFMEMORY: The system ran out of memory for some
//                                  crucial operation.
//                   CO_E_NOMATCHINGSIDFOUND: (Windows NT only) At least one of the trustee
//                                            name in the ACL provided by the user had
//                                            no corresponding security identifier.
//
// Called by: ReadACLFromStream
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
HRESULT ValidateAndFixStreamACL
(
#if 0 // #ifdef _CHICAGO_
STREAM_ACL *pStreamACL
#else
STREAM_ACL *pStreamACL,
ULONG      *pulTotalSIDSize,
ULONG      *pulEstAdditionalSIDSize
#endif
)
{
    ULONG        ulNumOfDenyEntries;
    ULONG        ulNumOfEntries;
    STREAM_ACE   *pStreamACEsPtr;
    ULONG        i;
    ULONG        AccessMode;
    HRESULT      hr = S_OK;

#ifndef _CHICAGO_
    *pulTotalSIDSize = 0;
    *pulEstAdditionalSIDSize = 0;
#endif

    AccessMode = ACTRL_ACCESS_DENIED;
    ulNumOfDenyEntries = pStreamACL->ulNumOfDenyEntries;
    ulNumOfEntries = ulNumOfDenyEntries + pStreamACL->ulNumOfGrantEntries;

// Chicago cannot handle more than 32767 entries in each list
#if 0 // #ifdef _CHICAGO_
    if(ulNumOfDenyEntries > 32767 || pStreamACL->ulNumOfGrantEntries > 32767)
    {
        return CO_E_EXCEEDSYSACLLIMIT;
    } // if
#else // NT cannot handle more than 32767 entries combined
    if(ulNumOfEntries > 32767)
    {
        return CO_E_EXCEEDSYSACLLIMIT;
    } // if
#endif

    for ( i = 0, pStreamACEsPtr = pStreamACL->pACL
        ; i < ulNumOfEntries
        ; i++, pStreamACEsPtr++)
    {
        if (i == ulNumOfDenyEntries)
        {
            AccessMode = ACTRL_ACCESS_ALLOWED;
        } // if

        if (!IsValidAccessMask(pStreamACEsPtr->grfAccessPermissions) ||
            ((pStreamACEsPtr->TrusteeType != TRUSTEE_IS_USER) &&
             (pStreamACEsPtr->TrusteeType != TRUSTEE_IS_GROUP)))
        {
            hr = E_INVALIDARG;
            break;
        } // if
        if((ULONG) pStreamACEsPtr->grfAccessMode != AccessMode)
        {
            // The stream ACL is either a) not in proper order, or
            //                          b) doesn't contain the number of stream ACEs
            //                             stated in the header.
            hr = CO_E_ACESINWRONGORDER;
            break;
        } // if

        if (FAILED(hr = ValidateTrusteeString(pStreamACEsPtr->pTrusteeName) ))
        {
            break;
        } // if

#if 0 // #ifdef _CHICAGO_
        pStreamACEsPtr->TrusteeForm = TRUSTEE_IS_NAME;
#else
        if(pStreamACEsPtr->pSID == NULL)
        {
            if(!(FAILED(hr = GetSIDFromName( (void **)&(pStreamACEsPtr->pSID)
                                           , pStreamACEsPtr->pTrusteeName
                                           , &pStreamACEsPtr->TrusteeType))))
            {
                // 32 more bytes is added to the estimated pickled size of the SID
                // because the RPC serialization mechanism may need extra space
                // in the header and alignment.
                *pulEstAdditionalSIDSize += GetLengthSid(pStreamACEsPtr->pSID)
                                         + 32;
            } // if


        } // if
        else
        {
            if(!IsValidSid(pStreamACEsPtr->pSID))
            {
                hr = CO_E_INVALIDSID;
                break;
            } // if
        } // if

        if(pStreamACEsPtr->pSID != NULL)
        {
            *pulTotalSIDSize += GetLengthSid(pStreamACEsPtr->pSID);
        }
        else
        {
            pStreamACEsPtr->TrusteeType = TRUSTEE_IS_UNKNOWN;
        } // if

#endif

    } // for
    return hr;

} // ValidateAndFixStreamACL

//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: ValidateTrusteeString
//
// Summary: This function checks if a trustee string is not NULL.
//
// Args: LPWSTR pTrusteeName [in] - Pointer to the trustee name to be
//                                  validated.
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
HRESULT ValidateTrusteeString
(
LPWSTR pTrusteeName
)
{
    if(pTrusteeName == NULL)
    {
        return E_INVALIDARG;
    } //if

    // If we see the magic string that specifies everyone,
    // we return S_OK.
    if(pTrusteeName[0] == L'*' && pTrusteeName[1] == L'\0')
    {
        return S_OK;
    } // if

    // A more sophisticated check can be put in here
    while(*pTrusteeName != L'\0')
    {
        if (*pTrusteeName == L'\\')
            return S_OK;
        pTrusteeName++;
    }
    return CO_E_WRONGTRUSTEENAMESYNTAX;
} // ValidateTrusteeString

//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: ValidateTrustee
//
// Summary: This function validates the fields in a TRUSTEE_Wstructure.
//
// Args: PTRUSTEE_W pTrustee [in] - Pointer to the TRUSTEE_W structure
//                                  to be validated.
//
// Return: HRESULT - S_OK: The TRUSTEE structure provided by the user was valid.
//                   E_INVALIDARG: The TRUSTEE structure provided by the user
//                                 contained values that were not supported by
//                                 the COM implementation of IAccessControl.
//                   CO_E_WRONGTRUSTEENAMESYNTAX: The trustee string doesn't
//                                                contain the '\' character.
//                   Windows NT only
//                   CO_E_INVALIDSID: At least one of the TRUSTEE_W structures
//                                    specified by the user contained an invalid
//                                    security identifier.
//
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
HRESULT ValidateTrustee
(
PTRUSTEE_W pTrustee
)
{
    HRESULT hr = S_OK;

    if( (pTrustee == NULL)                                           ||
        (pTrustee->pMultipleTrustee != NULL)                         ||
         (pTrustee->MultipleTrusteeOperation != NO_MULTIPLE_TRUSTEE) ||
#if 0 // #ifdef _CHICAGO_
         (pTrustee->TrusteeForm != TRUSTEE_IS_NAME)                  ||
#else
         ((pTrustee->TrusteeForm != TRUSTEE_IS_NAME) &&
          (pTrustee->TrusteeForm != TRUSTEE_IS_SID))                 ||
#endif
         ((pTrustee->TrusteeType != TRUSTEE_IS_USER) &&
          (pTrustee->TrusteeType != TRUSTEE_IS_GROUP))               ||
         (pTrustee->ptstrName == NULL) )
    {
        return E_INVALIDARG;
    }

#if 0 // #ifdef _CHICAGO_
    if (pTrustee->ptstrName[0] == L'*' &&
        pTrustee->ptstrName[1] == L'\0' &&
        pTrustee->TrusteeType != TRUSTEE_IS_GROUP)
    {
        return E_INVALIDARG;
    } // if

#else
    if (pTrustee->TrusteeForm == TRUSTEE_IS_NAME)
    {
#endif
        if(FAILED(hr = ValidateTrusteeString(pTrustee->ptstrName)))
        {
            return hr;
        }
    }
    else
    {
        if(!IsValidSid((PSID)(pTrustee->ptstrName)))
        {
            return CO_E_INVALIDSID;
        }
    } // if

    return S_OK;
} // ValidateTrustee

//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: ValidateAccessCheckClient
//
// Summary: This function checks to see if the current ORPC client matches
//          the trustee name provided for access checking and it also validates
//          the fields in the TRUSTEE structure.
//          The SID case is not optimized because DCOM doesn't use it and
//          this class is meant to be used only by DCOM.
//
// Args: PTRUSTEE_W pTrustee [in] - Pointer to the trustee structure
//                                  which contains the trustee name for
//                                  comparison with the name with the current
//                                  ORPC client.
//
// Return: HRESULT S_OK: The TRUSTEE structure provided by the user was valid
//                       and it specfied the current ORPC client.
//                   CO_E_TRUSTEEDOESNTMATCHCLIENT: The trustee specified by the
//                                                  client was not the current
//                                                  ORPC client.
//                   CO_E_FAILEDTOQUERYCLIENTBLANKET: Unable to query for the
//                                                    client's security blanket.
//                   CO_E_WRONGTRUSTEENAMESYNTAX: The trustee name inside the
//                                                TRUSTEE_W structure specified
//                                                by the user is not of the
//                                                form <Domain>\<Account Name>.
//                   E_INVALIDARG: The TRUSTEE structure provided by the user
//                                 contained values that were not supported by
//                                 the COM implementation of IAccessControl.
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
HRESULT ValidateAccessCheckClient
(
PTRUSTEE_W pTrustee
)
{

    WCHAR   *pwcszClientName;        // Pointer to the name of the ORPC client
                                     // in multibyte format.
    HRESULT       hr;
    BOOL          fSuccess;
    HANDLE        hClient     = NULL;
    BYTE          aMemory[256];
    TOKEN_USER   *pTokenUser  = (TOKEN_USER *) &aMemory;
    DWORD         lIgnore;

    if (FAILED(hr = ValidateTrustee(pTrustee)))
    {
        return hr;
    }

    // Validate the name.
    if (pTrustee->TrusteeForm == TRUSTEE_IS_NAME)
    {
        if(FAILED(CoQueryClientBlanket( NULL
                                      , NULL
                                      , NULL
                                      , NULL
                                      , NULL
                                      , (RPC_AUTHZ_HANDLE *)&pwcszClientName
                                      , NULL)))
        {
            return CO_E_FAILEDTOQUERYCLIENTBLANKET;
        } // if

        if (lstrcmpiW(pwcszClientName, pTrustee->ptstrName) != 0)
        {
            return CO_E_TRUSTEEDOESNTMATCHCLIENT;
        } // if
    }

    // Validate the SID.
    else
    {
#if 0 // #ifdef _CHICAGO_
        // SIDs aren't allowed on Chicago.
        return E_INVALIDARG;
#endif

        // Impersonate.
        hr = CoImpersonateClient();

        // Open the thread token.
        if (SUCCEEDED(hr))
        {
            fSuccess = OpenThreadToken( GetCurrentThread(), TOKEN_READ, TRUE,
                                        &hClient );
            if (!fSuccess)
                hr = CO_E_FAILEDTOOPENTHREADTOKEN;
        }

        // Check the SID.
        if (SUCCEEDED(hr))
        {
            fSuccess = GetTokenInformation( hClient, TokenUser, pTokenUser,
                                            sizeof(aMemory), &lIgnore );
            if (!fSuccess)
                hr = CO_E_FAILEDTOGETTOKENINFO;
            else if (!EqualSid( pTokenUser->User.Sid, (SID *) pTrustee->ptstrName ))
                hr = CO_E_TRUSTEEDOESNTMATCHCLIENT;
        }

        // Revert.
        CoRevertToSelf();

        // Close the token handle.
        if (hClient != NULL)
            CloseHandle( hClient );
    }
    return hr;

} // ValidateAccessCheckClient

//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: LocalMemAlloc
//
// Summary: This fucntion makes memory allocation more efficient by using the
//          cached g_pIMalloc pointer.
//
// Args: ULONG cb [in] = Number of bytes to be allocated.
//
// Return: void * - Pointer to the a newly allocated memory block.
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
void * LocalMemAlloc(SIZE_T cb)
{
    return g_pIMalloc->Alloc(cb);
} // LocalMemAlloc

//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: LocalMemFree
//
// Summary: This function frees memory allocated by LocalMemAlloc.
//
// Args: void *pBlock - Pointer to the memory block to be freed.
//
// Return: void
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
void LocalMemFree(void *pBlock)
{
    g_pIMalloc->Free(pBlock);
} // LocalMemFree

//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: CleanUpStreamACL, Common
//
// Summary: This function releases all the memory allocated for the array
//          of STREAM_ACE structures inside a STREAM_ACL structure. This
//          includes all the trustee string and SID inside each of the
//          STREAM_ACE structure.
//
// Args:  STREAM_ACL *pStreamACL [in] - Pointer to the stream ACL structure
//                                      to be cleaned up.
//
// Return: void
//
// Called by: COAccessControl::CImpAccessControl::Load()
//            COAccessControl::CImpAccessControl::ReplaceAllAccessRights()
//            CleanAllMemoryResources
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
void CleanUpStreamACL
(
STREAM_ACL *pStreamACL
)
{
    ULONG      ulNumOfEntries; // Total number of entries in the stream ACL
    ULONG      i;              // Loop index
    STREAM_ACE *pACE;          // Pointer to elements in the stream ACL

    ulNumOfEntries = pStreamACL->ulNumOfDenyEntries
                   + pStreamACL->ulNumOfGrantEntries;

    pACE = pStreamACL->pACL;

    for (i = 0; i < ulNumOfEntries; i++)
    {
        midl_user_free(pACE->pTrusteeName);
        midl_user_free(pACE->pSID);
        pACE++;
    } // for

    pStreamACL->ulNumOfDenyEntries = 0;
    pStreamACL->ulNumOfGrantEntries = 0;

    // free the stream ACL itself and set the pointer to NULL
    midl_user_free(pStreamACL->pACL);
    pStreamACL->pACL = NULL;

} // CleanUpStreamACL

/////////////////////////////////////////////////////////////////////////////
// Functions that are specific to the Chicago platform
/////////////////////////////////////////////////////////////////////////////
#if 0 // #ifdef _CHICAGO_
//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: AddACEToACLImage
//
// Summary: This function adds an ACE to an ACL image and it assumes that the
//          ACL image has enough space to hold the new entry.
//
// Args: access_list_2 *pNewACE [in] - The new access_list_2 structure to be
//                                     added to the LAN Manager ACL in the
//                                     ACL image.
//       ULONG AccessMode [in] - Grant or Deny
//       ACL_DESCRIPTOR ACLDesc [in,out] - Contains the grant and deny
//                                       Chicago ACL image structures.
//                                       The new access_list_2 structure is
//                                       added to the appropriate one.
//
// Return: void
//
// Called by: AddACEToACL
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
void AddACEToACLImage
(
access_list_2     *pNewACE,
ULONG              AccessMode,
ACL_DESCRIPTOR    *ACLDesc
)
{
    ULONG          ulStrLen;
    access_list_2 *pACE;
    ACL_IMAGE     *pACLImage = AccessMode == ACTRL_ACCESS_ALLOWED ? &ACLDesc->GrantACL :
                                                            &ACLDesc->DenyACL;

    pACE = (access_list_2 *)(pACLImage->pACL + 1)
         + pACLImage->pACL->acc1_count;

    memcpy(pACE, pNewACE, sizeof(access_list_2));
    pACLImage->pACL->acc1_count++;

} // AddACEToACLImage

//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: CleanFileResource
//
// Summary: This function deletes the dummy file created for an ACL image and
//          removes the security entries associated with that file in the system
//          registry.
// Args: ACL_IMAGE *pACLImage [in,out] - Pointer to the ACL image that contains
//                                       the dummy file name.
//
// Return: void
//
// Called by: COAccessControl::CImpAccessControl::~CImpAccessControl
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
void CleanFileResource
(
ACL_IMAGE *pACLImage
)
{
    CHAR *pszFileName;

    pszFileName = pACLImage->pACL->acc1_resource_name;
    NetAccessDel(NULL, pszFileName);
    DeleteFileA(pszFileName);
    LocalMemFree(pszFileName);

} // CleanFileResource

//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: DeleteACEFromACLImage, Chicago specific
//
// Summary: This function removes the ACEs of a trustee from an ACL image.
//
// Args: LPWSTR pTrustee [in] - Pointer to the trustee to be removed from the
//                              ACL image.
//       ACL_IMAGE *pACLImage [in,out] - Pointer to the ACL image to remove the
//                                       trustee from
//
// Return: void
//
// Called by: COAccessControl::CImpAccessControl::RevokeAccessRights
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
void DeleteACEFromACLImage
(
CHAR      *pcszTrusteeName,
ACL_IMAGE *pACLImage
)
{
    SHORT          i = 0;             // Loop counter
    access_list_2 *pACE;              // Pointer for browsing LAN Manager ACEs
                                      // in the ACL image
    access_list_2 *pLast;

    pACE = (access_list_2 *)(pACLImage->pACL + 1);
    pLast = pACE + pACLImage->pACL->acc1_count - 1;
    while (i < pACLImage->pACL->acc1_count)
    {
        if (lstrcmpiA(pcszTrusteeName, pACE->acl2_ugname) == 0)
        {
            pACLImage->pACL->acc1_count--;
            LocalMemFree(pACE->acl2_ugname);

            // If the current entry is not the last entry in the ACL image
            if (i < pACLImage->pACL->acc1_count)
            {
                memcpy(pACE, pLast, sizeof(access_list_2));
                pLast--;
            } // if
        } // if
        else
        {
            i++;
            pACE++;
        } // else
    } // while

} // DeleteACEFromACLImage

//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: AllocACLImage, Chicago specific
//
// Summary: This function allocates memory for an ACL image large enough to hold
//          the specified number of ACEs excluding the user name inside the
//          access_list_2 structure.
//
// Args: ACL_IMAGE *pACLImage [in,out] - Pointer to the ACL image to allocate
//                                       memory for.
//       SHORT sNumOfEntries [in] - Number of ACEs to be allocated.
//
// Return: HRESULT - S_OK: Success.
//                   E_OUTOFMEMORY: Not enough memory to allocate the LAN
//                                  Manager ACL.
//
// Called by: COAccessControl::CImpAccessControl::Load
//            EnsureACLImage
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
HRESULT AllocACLImage
(
ACL_IMAGE *pACLImage,
SHORT     sNumOfEntries
)
{
    ULONG ulACLSize;

    ulACLSize = sizeof(access_info_1) + sNumOfEntries * sizeof(access_list_2);

    if ((pACLImage->pACL = (access_info_1 *)LocalMemAlloc(ulACLSize)) == NULL)
    {
        return E_OUTOFMEMORY;
    } // if

    // It is not really necessary to set the ACL buffer to zero, but is safer
    // to do so.
    memset(pACLImage->pACL, 0, ulACLSize);
    pACLImage->sMaxNumOfACEs = sNumOfEntries;

    return S_OK;

} // AllocACLImage

//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: EnsureACLImage, Chicago specific
//
// Summary: This function enlarge an existing ACL image to accomodate more ACEs.
//
// Args: ACL_IMAGE *pACLImage [in] - Pointer to the ACL image to be enlarged.
//       SHORT sAddEntries [out] - Number of free slots to be added.
//
// Return: HRESULT S_OK: Success
//                 E_OUTOFMEMORY: Out of memory.
//
// Called by: AddACEToACLImage
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
HRESULT EnsureACLImage
(
ACL_IMAGE *pACLImage,
ULONG      lAddEntries
)
{
    ACL_IMAGE LocalImage;    // A local ACL_IMAGE structure for backing up the
                             // the old list
    SHORT     sNewSize;      // The new size of the ACL
    HRESULT   hr = S_OK;

    // If there is no ACL, just make one.
    if (pACLImage->pACL == NULL)
        return AllocACLImage( pACLImage, (SHORT) lAddEntries + EXTRA_ACES );

    // If the ACL is large enough, return.
    if (pACLImage->pACL->acc1_count + lAddEntries <
        (ULONG) pACLImage->sMaxNumOfACEs)
        return S_OK;
    sNewSize = (SHORT) (pACLImage->pACL->acc1_count + lAddEntries + EXTRA_ACES);

    // Take a snapshot of the old list
    memcpy(&LocalImage, pACLImage, sizeof(ACL_IMAGE));

    if(FAILED(hr = AllocACLImage(pACLImage, sNewSize)))
    {
        goto Error;
    } // if

    // Copy the content of the old list over to the new list
    memcpy( pACLImage->pACL
          , LocalImage.pACL
          , sizeof(access_info_1)
          + sizeof(access_list_2)
          * LocalImage.pACL->acc1_count);

    // free the memory used by the old list
    LocalMemFree(LocalImage.pACL);
    return S_OK;

Error:
    // Restore the old list
    memcpy(pACLImage, &LocalImage, sizeof(ACL_IMAGE));
    return hr;

} // EnsureACLImage

//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: CleanUpACLImage, Chicago specific
//
// Summary: This function releases the memory that has been allocated for
//          an ACL image except for the resource name in the ACL header.
//
// Args: ACL_IMAGE *pACLImage [in] - Pointer to the ACL image to be released.
//
// Return: void
//
// Called by: COAccessControl::CImpAccessControl::Load
//            COAccessControl::CImpAccessControl::ReplaceAllAccessRights
//            CleanAllMemoryResources()
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
void CleanUpACLImage
(
ACL_IMAGE *pACLImage
)
{
    access_list_2 *pACE; // Pointer for traversing the LAN Manager ACL
    SHORT sNumOfACEs;    // Total number of LAN Manager ACEs to release
    SHORT i;             // Loop counter

    pACE = (access_list_2 *)(pACLImage->pACL + 1);
    sNumOfACEs = pACLImage->pACL->acc1_count;

    // For each access_list_2 structure in the LAN Manager ACL, we have
    // to free the user/group name string in it.
    for (i = 0; i < sNumOfACEs; i++, pACE++)
    {
        LocalMemFree(pACE->acl2_ugname);
    } // for

    LocalMemFree(pACLImage->pACL);
    pACLImage->pACL = NULL;
} // CleanUpACLImage

//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: WStringToMBString
//
// Summary: This function converts a Unicode string into a multibyte string
//          using the current console code page. This function will allocate
//          memory for the mulitbyte string which is returned to the caller
//          so the caller must free the string when the string is no longer
//          in use. Notice that the WC_COMPOSITECHECK and the WC_SEPCHARS
//          flags are hard-coded in the conversion but this may not be
//          the perfect setting for all languages. A more suitable approach
//          is to set up a global mask that defines the proper behaviour of
//          converting composite character when the server is started.
//
// Args: LPWSTR pwszString [in] - The Unicode string to be converted.
//       CHAR   **pcszString [out] - Address of the pointer to the
//                                   converted multibyte string.
//
// Return: HRESULT - S_OK: Succeeded.
//                   CO_E_CONVERSIONFAILED: WideCharToMultiByte returned zero.
//                                          The caller can get extended error
//                                          information by calling GetLastError.
//                   E_OUTOFMEMORY: The system ran out of memory for the
//                                  converted string.
//
// Called by: ComputeEffectiveAccess
//            ValidateAndTransformAccReqList
//
// Remarks: This function relies on the global variable, g_uiCodePage, for
//          the conversion.
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
HRESULT WStringToMBString
(
LPWSTR pwszString,
CHAR   **ppcszString
)
{
    ULONG ulStrLen; // Lenght of the multibyte string

    // The first call to WideCharToMultiByte is to figure out the length
    // of the converted string so that enough memoy can be allocated for
    // it.
    ulStrLen = WideCharToMultiByte( g_uiCodePage
                                  , WC_SEPCHARS | WC_COMPOSITECHECK
                                  , pwszString
                                  , -1
                                  , NULL
                                  , NULL
                                  , NULL
                                  , NULL );
    if (ulStrLen == 0)
    {
        return CO_E_CONVERSIONFAILED;
    } // if

    *ppcszString = (CHAR *)LocalMemAlloc(ulStrLen + 1);
    if (*ppcszString == NULL)
    {
        return E_OUTOFMEMORY;
    } // if

    WideCharToMultiByte( g_uiCodePage
                       , WC_SEPCHARS | WC_COMPOSITECHECK
                       , pwszString
                       , -1
                       , *ppcszString
                       , ulStrLen + 1
                       , NULL
                       , NULL );

    return S_OK;
} // WStringToMBString

//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: GenerateFile, Chicago specific
//
// Summary: This function generates a file on the system with a (supposed)
//          unique name composed by a randomly generated uuid and the current
//          process id. Notice that this function allocates memory for the
//          gernerated filename to be returned to the caller and it also
//          creates the file with the generated filename on the file system,
//          so it is up to the caller to release these sytem resorces when
//          they are no longer in use. The syntax fo the file name generated
//          can be described by the expression:
//          <Windows directory>/<Current process ID>_<UUID>.tmp
//
// Args:  LPTSTR *pFileName [out] - Address of the generated filename string
//                                  which is returned to the caller.
//
// Return: HRESULT - S_OK: Succeeded.
//                   E_OUTOFMEMORY: The system ran out of memory for some
//                                  crucial operation.
//                   CO_E_FAILEDTOGETWINDIR: (Windows 95 only)Unable to obtain
//                                           the Windows directory.
//                   CO_E_PATHTOOLONG: (Windows 95 only)The path generated by
//                                     the GenerateFile function was longer
//                                     than the system's limit.
//                   CO_E_FAILEDTOGENUUID: (Windows 95 only)Unable to generate
//                                         a uuid using the UuidCreate funciton.
//                   CO_E_FAILEDTOCREATEFILE: (Windows 95 only)Unable to create
//                                            a dummy file.
//
// Called by: COAccessControl::CImpAccessControl::Load()
//
// Remarks: This function relies on the fact that there is global variable
//          named g_dwProcessID containing the current process ID.
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
HRESULT GenerateFile
(
LPTSTR *pFileName
)
{
    HRESULT       hr = S_OK;    // Function return code
    UUID          uuid;         // The UUID generated by CreateUuid
    LPTSTR        pszPathName;  // Pointer to the full pathname
    LPTSTR        pszFileName;  // Pointer to the filename
    SHORT         sStrLen;      // Temporary variable to keep track of the
                                // intermediate length of the path
    HANDLE        FileHandle;   // Handle for file management.

    pszPathName = NULL;

    // Allocate memory for the full path of the file that is going to be
    // generated
    pszPathName = (LPTSTR)LocalMemAlloc(sizeof(TCHAR) * MAX_PATH);
    if (pszPathName == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    } // if


    sStrLen = GetWindowsDirectory(pszPathName, MAX_PATH);
    if(sStrLen == 0)
    {
        hr = CO_E_FAILEDTOGETWINDIR;
        goto Error;
    } // if

    // We should worry about the case where the Windows directory is the
    // root directory where the '\' character has already been added to
    // the path at the end. We should add the '\' character at the
    // end of the Windows path otherwise.
    if(pszPathName[sStrLen - 1] != '\\')
    {
        pszPathName[sStrLen] = '\\';
        sStrLen++;
    } //if

    pszFileName = pszPathName + sStrLen;
    // Compose the filename with the process id
    _ultoa( g_dwProcessID, pszFileName, 16 );
    sStrLen = sStrLen + strlen(pszFileName);
    pszFileName = pszPathName + sStrLen;
    *(pszFileName++) = '_';
    sStrLen         += 1;

    // See if the buffer can hold everything..
    // UUID and extension etc.
    if (sStrLen + 43 > MAX_PATH)
    {
        hr = CO_E_PATHTOOLONG;
        goto Error;
    } // if

    // Compose the filename with a UUID
    hr = UuidCreate(&uuid);
    if (hr != RPC_S_OK && hr != RPC_S_UUID_LOCAL_ONLY)
    {
        hr = CO_E_FAILEDTOGENUUID;
        goto Error;
    } // if
    hr = S_OK;

    // Put the uuid into the filename
    wStringFromGUID2A( uuid, pszFileName, GUID_SIZE+1 );

    // Attach a .tmp extension to the end
    strcpy(pszFileName + GUID_SIZE, ".tmp");

    // return the string to caller
    *pFileName = pszPathName;

    // Create the file
    if ((FileHandle = CreateFileA( pszPathName
                                , GENERIC_READ | GENERIC_WRITE
                                , FILE_SHARE_READ
                                , NULL
                                , CREATE_NEW
                                , FILE_ATTRIBUTE_TEMPORARY
                                , NULL )) == INVALID_HANDLE_VALUE )
    {
        // There are two distinct possibilities that an error creating the file may occur:
        // 1. The filename generated by GenerateFile has already existed in the file system.
        //    This is highly improbable because an UUID is used in the filename generation.
        // 2. The system runs out of memory
        hr = CO_E_FAILEDTOCREATEFILE;
        goto Error;
    } // if


    // Close the file immediately since we don't really
    // access the file
    if (!CloseHandle(FileHandle))
    {
        Win4Assert( !"Unable to close file handle." );
    } // if

    return hr;

    Error:
        if (pszPathName != NULL)
        {
            LocalMemFree(pszPathName);
        } // if
        *pFileName = NULL;
        return hr;

} // GenerateFile

//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: MapStreamACLToChicagoACL, Chicago specific
//
// Summary: This function maps a standard stream format ACL to a preallocated
//          in-Femory ACL image specifically designed to work with the
//          LAN Manager API supported on Chicago.
//
// Args: STREAM_ACE *pStreamACEs [in] - Pointer to an array of ACEs in
//                                      standard stream format.
//       ACL_IMAGE  *pACLImage [in,out] - The in memory representation of an
//                                        ACL image.
//       SHORT      sNumOfEntries [in] - The number of stream format ACEs to
//                                       be mapped to the in-memory ACL image.
//
//
// Return: HRESULT - S_OK: Succeeded.
//                   CO_E_CONVERSIONFAILED: WideCharToMultiByte returned zero.
//                                          The caller can get extended error
//                                          information by calling GetLastError.
//                   E_OUTOFMEMORY: The system ran out of memory for the
//                                  converted string.
//
// Called by: COAccessControl::CImpAccessControl::Load
//            COAccessControl::CImpAccessControl::ReplaceAllAccessRights
//            ComputeEffectiveAccess
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
HRESULT MapStreamACLToChicagoACL
(
STREAM_ACE     *pStreamACEs,
ACL_IMAGE      *pACLImage,
SHORT          sNumOfEntries
)
{
    USHORT         i,j;             // Loop counters
    STREAM_ACE     *pStreamACEsPtr; // Pointer to an array of stream format ACEs
    access_list_2  *pACE;           // Pointer to ACEs in the LAN Manager ACL
    ULONG          ulStrLen;        // Length of the trustee string
    HRESULT        hr;

    // Set up the ACL header
    pACLImage->pACL->acc1_attr = 0;  // Audit all by default
    pACLImage->pACL->acc1_count = sNumOfEntries;

    // Set the stream ACE pointer to point to the first stream ACE
    pStreamACEsPtr = pStreamACEs;

    pACE = (access_list_2 *)(pACLImage->pACL + 1);

    for (i = 0; i < sNumOfEntries; i++)
    {

        if (FAILED(hr = WStringToMBString( pStreamACEsPtr->pTrusteeName
                                         , &(pACE->acl2_ugname))))
        {
            goto Error;
        } // if

        // Map stream security mask to Chicago security mask
        StandardMaskToLANManagerMask( &(pStreamACEsPtr->grfAccessPermissions)
                                    , &(pACE->acl2_access));

        // Set up the group bit if necessary
        if (pStreamACEsPtr->TrusteeType == TRUSTEE_IS_GROUP)
        {
                pACE->acl2_access |= ACCESS_GROUP;
        } // if

        pACE++;

        pStreamACEsPtr++;

    } // for

    return S_OK;

Error:
    pACE = (access_list_2 *)(pACLImage->pACL + 1);
    for (j = 0; j < i; j++, pACE++)
    {
        LocalMemFree(pACE->acl2_ugname);
    } // for
    return hr;

} // MapStreamToChicagoACL

//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: StandardMaskToLANManagerMask, Chicago specific
//
// Summary: This function maps the content of a access permissions
//          supported by IAccessControl to the corresponding LAN
//          Mamager access mask.
//
// Args:  DWORD *pStdMask [in] - The standard mask to be converted to NT
//                               mask.
//        ACCESS_MASK *pNTMask [out] - Reference to the converted mask.
//
//
// Return: void
//
// Called by:
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
SHORT StandardMaskToLANManagerMask
(
DWORD       *pStdMask,
USHORT       *pLMMask
)
{
    *pLMMask= 0;


    if ((*pStdMask & COM_RIGHTS_EXECUTE) != 0)
    {
        *pLMMask |= CHICAGO_RIGHTS_EXECUTE;
    } // if

    return 0;

} // StandardMaskToLANManagerMask

#else

//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: lstrcmpiW, Chicago specific
//
// Summary: This function is equivalent to lstrcmpiW on Windows NT.
//          Unlike the Windows NT version of lstrcmpiW, this function can
//          treats a null pointer as a null string instead of spewing out an
//          access violation error.
//
// Remarks: See the section on lstrcmpi inside the Win32 SDK documentation.
//          This function relies on a global variable named g_uiCodePage
//          storing the current console code page.
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
SHORT FoolstrcmpiW(LPWSTR pwsz1, LPWSTR pwsz2)
{
    SHORT  sResult;          // The result of the comparision
    WCHAR  *pwchar1 = pwsz1; // Pointer for browsing through the first string
                             // character by character.
    WCHAR  *pwchar2 = pwsz2; // Pointer for browsing through the second string
                             // character by character.
    WCHAR  wchar1;
    WCHAR  wchar2;

    // The following block of code handles case where
    // either one of the input string is a NULL pointer.
    // By convention a string represented by a NULL pointer
    // is an empty string.
    if(pwchar1 == NULL)
    {
        if(pwchar2 == NULL)
        {
            return 0;
        }
        else
        {
            return -1;
        } // if
    }
    else if (pwchar2 == NULL)
    {
        return 1;
    } // if

    for(;;)
    {
        wchar1 = *pwchar1;
        wchar2 = *pwchar2;

#if 0
        // Checking to see if the current code page is the
        // ANSI code page may not be enough to cover all the
        // cases where a language has the concept of upper and lower
        // case letters.
        if (g_uiCodePage == CP_ACP)
        {
#endif
            // All lower-case characters in the both strings are
            // converted to upper-case characters before
            // making the comparison.
            if ((L'a' <= *pwchar1)&& (*pwchar1 <= L'z'))
            {
                wchar1 = *pwchar1 - L'a' + L'A';
            } // if

            if ((L'a' <= *pwchar2) && (*pwchar2 <= L'z'))
            {
                wchar2 = *pwchar2 - L'a' + L'A';
            } // if
#if 0
        } // if
#endif
        if(wchar1 == 0 && wchar2 == 0)
        {
            return 0;
        }
        else if (wchar1 > wchar2)
        {
            return 1;
        }
        else if (wchar1 < wchar2)
        {
            return -1;
        } // if

        // Increment the string pointers to point to the next character
        // for comparison
        pwchar1++;
        pwchar2++;
    } // if
} // if

/////////////////////////////////////////////////////////////////////////////
// Functions that are specific to the Windows NT platform
/////////////////////////////////////////////////////////////////////////////

//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: InitSecDescInACLDesc, NT specific
//
// Summary: This function initializes the group field and the user field of the
//          security descriptor in an ACL_DESCRIPTOR structure the user SID of
//          the current process.
//
// Args: ACL_DESCRIPTOR pACLDesc [in,out] - Pointer to ACL descriptor containing
//                                          the security identifier to be
//                                          initialized.
//
// Return: HRESULT - S_OK: Succeeded.
//                   CO_E_FAILEDTOOPENPROCESSTOKEN: The system call,
//                                                  OpenProcessToken, failed.
//                                                  The user can get extended
//                                                  information by calling
//                                                  GetLastError.
//                   CO_E_FAILEDTOGETTOKENINFO: The system call,
//                                              GetTokenInformation, failed.
//                                              The user can call GetLastError
//                                              to get extended error
//                                              information.
//                   E_OUTOFMEMORY: There was not enough memory for allocating
//                                  the SIDs in the security descriptor.
//
// Called by: COAccessControl:CImpAccessControl:Load
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
HRESULT InitSecDescInACLDesc
(
ACL_DESCRIPTOR *pACLDesc
)
{
    // Set up a security descriptor with the current process owner
    // and primary group
    TOKEN_USER *pTokenUser = NULL;
    HANDLE     hToken;
    ULONG      ulLen;
    HANDLE     hProcess;
    DWORD      dwLastError;
    PSID       pOwner = NULL;
    PSID       pGroup = NULL;
    DWORD      dwSIDLen;
    HRESULT    hr = S_OK;

    hProcess = GetCurrentProcess();

    if(!OpenProcessToken( hProcess
                        , TOKEN_QUERY
                        , &hToken ))
    {
        hr = CO_E_FAILEDTOOPENPROCESSTOKEN;
        goto Error;
    } // if

    GetTokenInformation( hToken
                       , TokenUser
                       , pTokenUser
                       , 0
                       , &ulLen);
    dwLastError = GetLastError();
    if (dwLastError == ERROR_INSUFFICIENT_BUFFER)
    {
        pTokenUser = (TOKEN_USER *)LocalMemAlloc(ulLen);
        if (pTokenUser == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Error;
        } // if

        if(!GetTokenInformation( hToken
                               , TokenUser
                               , pTokenUser
                               , ulLen
                               , &ulLen))
        {
            hr = CO_E_FAILEDTOGETTOKENINFO;
            goto Error;
        }

    }
    else
    {
        hr = CO_E_FAILEDTOGETTOKENINFO;
        goto Error;
    } // if

    dwSIDLen = GetLengthSid(pTokenUser->User.Sid);

    pOwner = (PSID)LocalMemAlloc(dwSIDLen);
    if(pOwner == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    } // if

    pGroup = (PSID)LocalMemAlloc(dwSIDLen);
    if(pGroup == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    } // if

    CopySid(dwSIDLen, pOwner, pTokenUser->User.Sid);
    CopySid(dwSIDLen, pGroup, pTokenUser->User.Sid);

    InitializeSecurityDescriptor( &(pACLDesc->SecDesc)
                                , SECURITY_DESCRIPTOR_REVISION);
    pACLDesc->SecDesc.Owner = pOwner;
    pACLDesc->SecDesc.Group = pGroup;

    // Close the token handle
    CloseHandle(hToken);
    // Free the token user buffer
    LocalMemFree(pTokenUser);

    pACLDesc->bDirtyACL = TRUE;
    return hr;

Error:
    if (pTokenUser != NULL)
    {
        LocalMemFree(pTokenUser);
    } // if
    if (pOwner != NULL)
    {
        LocalMemFree(pOwner);
    } // if
    if (pGroup != NULL)
    {
        LocalMemFree(pGroup);
    } // if
    return hr;

} // InitSecDescInACLDesc

//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: GetSIDFromName, NT specific
//
// Summary: This function takes an account name of the form <Domain>\<User name>
//          as an input and returns the corresponding security identifier (SID).
//          This function will automatically allocates memory for the SID
//          returned to the caller so the caller should release the SID pointer
//          using LocalMemFree as soon as the SID is no longer in use.
//
// Args: PSID   *ppSID [out] - Address of the pointer to the returned security
//                             identifier. The caller must free the memory
//                             allocated for the securrity identifier using
//                             LocalMemFree when the security identifier is no
//                             longer in use.
//       LPWSTR pwszTrustee [in] - Pointer to the trustee name of the form
//                                 <Domain>\<User name>. The SID returned
//                                 should belong to this trustee.
//       TRUSTEE_TYPE TrusteeType [in] - Type of the trustee which is either
//                                       TRUSTE_IS_NAME or TRUSTEE_IS_GROUP
//
// Return: HRESULT - S_OK: Succeeded.
//                   CO_E_NOMATCHINGSIDFOUND: No matching security identifier
//                                            could be found for the
//                                            trustee name specified by the
//                                            client.
//                   CO_E_LOOKUPACCNAMEFAILED: The system function,
//                          LookupAccountName, failed. The client can
//                          call GetLastError to obtain extended error
//                          information.
//                   E_OUTOFMEMORY: The system ran out of memory for
//                                  allocating the SID to be returned
//                                  the caller.
//
//
// Called by: ValidateAndFixStreamACL
//            ValidateAndTransformAccReqList
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
HRESULT GetSIDFromName
(
PSID            *ppSID,
LPWSTR          pwszTrustee,
TRUSTEE_TYPE    *pTrusteeType
)
{
    PSID            pSID           = NULL;
    DWORD           dwSIDSize;          // Buffer size for the SID
    LPWSTR          pwszUserName;       // Pointer to the user name portion of the
                                        // trustee
    DWORD           dwLastError;        // Error code obtained from GetLastError
    DWORD           dwDomainLength;     // Length of domain name
    LPWSTR          pwszDomainName = NULL;
    SID_NAME_USE    SIDUse;             // The type of SID returned.
    HRESULT         hr;

    // We trap the magic string "*' which specifies everyone
    if (pwszTrustee[0] == L'*' && pwszTrustee[1] == L'\0')
    {
        if (*pTrusteeType != TRUSTEE_IS_GROUP)
        {
            return E_INVALIDARG;
        } // if

        if(*ppSID = (PSID)LocalMemAlloc(sizeof(gEveryone)))
        {
            CopySid(sizeof(gEveryone), *ppSID, &gEveryone);
            return S_OK;
        }
        else
        {
            return E_OUTOFMEMORY;
        } // if
    } // if

#if 0
    // Note: On NT5 LookupAccountName handles this correctly, so the
    // special case can be removed.


    // NT 4 does not map the domain NT Authority correctly
    if (lstrcmpiW(pwszTrustee, L"NT Authority\\system") == 0)
    {
        if (*pTrusteeType != TRUSTEE_IS_USER)
        {
            return E_INVALIDARG;
        } // if

        if(*ppSID = (PSID)LocalMemAlloc(sizeof(gSystem)))
        {
            CopySid(sizeof(gSystem), *ppSID, &gSystem);
            return S_OK;
        }
        else
        {
            return E_OUTOFMEMORY;
        } // if
    } // if
#endif

    // Assign an arbitrarily large SID size so that the function
    // can avoid LookupAccountName twice for most of the time.
    pwszUserName   = pwszTrustee;
    dwDomainLength = 64;
    dwSIDSize      = 64;
    pSID           = (PSID)midl_user_allocate(dwSIDSize);
    if (pSID == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    } // if

    dwDomainLength++;
    pwszDomainName = (LPWSTR)LocalMemAlloc(sizeof(WCHAR) * dwDomainLength);
    if (pwszDomainName == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    } // if

    if (!LookupAccountNameW( NULL
                           , pwszUserName
                           , pSID
                           , &dwSIDSize
                           , pwszDomainName
                           , &dwDomainLength
                           , &SIDUse))

    {
        dwLastError = GetLastError();

        if (dwLastError == ERROR_INSUFFICIENT_BUFFER)
        {

            // If it is not the domain buffer that is too small, it must be
            // the SID that is too small. In this cas, we should expand the
            // buffer and call LookupAccountW again.
            midl_user_free(pSID);
            pSID = (PSID)midl_user_allocate(dwSIDSize);
            if (pSID== NULL)
            {
                hr = E_OUTOFMEMORY;
                goto Error;
            } // if

            if(!LookupAccountNameW( NULL
                                  , pwszUserName
                                  , pSID
                                  , &dwSIDSize
                                  , pwszDomainName
                                  , &dwDomainLength
                                  , &SIDUse ))
            {
                // If LookupAccountW crashes again, we quit and return
                // an error code.
                hr = CO_E_LOOKUPACCNAMEFAILED;
                goto Error;
            } // if
        }
        else
        {
            // LookupAccountW may not be able to find the SID for the
            // trustee or some other fatal errors occured. In any case, we
            // return an error code and the caller can look at the details
            // by calling GetLastError
            hr = CO_E_LOOKUPACCNAMEFAILED;
            goto Error;
        } // if
    } // if

    // Check to see if the trustee type provided by the caller matches the SID
    // type obtained from LookupAccountName. If not, we're in trouble.  All
    // well known SIDs are of type SidTypeWellKnownGroup.
    if( !(SIDUse == SidTypeUser && *pTrusteeType == TRUSTEE_IS_USER) &&
        !(SIDUse == SidTypeGroup && *pTrusteeType == TRUSTEE_IS_GROUP) &&
        SIDUse != SidTypeWellKnownGroup && SIDUse != SidTypeAlias)
    {
        hr = CO_E_NOMATCHINGSIDFOUND;
        goto Error;
    } // if

    LocalMemFree(pwszDomainName);
    *ppSID = pSID;
    return 0;

Error:
    if (pwszDomainName != NULL)
    {
        LocalMemFree(pwszDomainName);
    }
    if (pSID != NULL)
    {
        midl_user_free(pSID);
    }
    return hr;
} // GetSIDFromName

//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: GetNameFromSID, NT specific
//
// Summary: This function takes a security identifier (SID) as an input
//          and finds the trustee name in the form <Domain>\<User name> that
//          corresponds to the SID. This function will allocate memory for
//          the trustee name returned to the caller so the caller should
//          release the trustee name pointer using LocalMemFree whem the
//          trustee name is no longer in use.
//
// Args: LPWSTR *ppwszTrustee [out] - Address of the pointer to the trustee
//                                    name to be returned to the caller. The
//                                    trustee name returned is in the form
//                                    <Domain>\<User name>. The caller is
//                                    responsible for releasiung the memory
//                                    allocated for the trustee string once
//                                    it is no longer in use.
//
//       PSID   pSID [in] - Pointer to a security identifier. This function
//                          will return the trustee name corresponding to
//                          this security identifier through the ppwszTrustee
//                          argument.
//
//       TRUSTEE_TYPE TrusteeType [in] - The type associating with the
//                                       trustee name that the caller is
//                                       expecting.
//
// Return: HRESULT - S_OK: Succeeded.
//                   CO_E_NOMATCHINGNAMEFOUND: No matching account name
//                          could be found for one of the security identifiers
//                          specified by the client.
//                   CO_E_LOOKUPACCSIDFAILED: The system function,
//                          LookupAccountSID, failed. The client can call
//                          GetLastError to obtain extended error inforamtion.
//                   E_OUTOFMEMORY: The system ran out of memory.
//
// Called by: ValidateAndTransformAccReqList
//
// Notes: On error LookupAccountSid returns strlen+1, on success it returns
//        only strlen.
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
HRESULT GetNameFromSID
(
LPWSTR          *ppwszTrustee,
PSID            pSID,
TRUSTEE_TYPE    *pTrusteeType
)
{
    LPWSTR          pwszDomainName  = NULL;
    DWORD           dwDomainLength;  // Length of the domain string
    LPWSTR          pwszAccountName = NULL;
    DWORD           dwAccountLength; // Length of the account string
    LPWSTR          pwszTrustee;     // Pointer to the trustee string in the form
                                     // <Domain>\<User name>
    DWORD           dwLastError;     // Return code obtained from GetLastError
    HRESULT         hr = S_OK;
    SID_NAME_USE    SIDUse;          // An enumerated variable indicating
                                     // what the SID returned by LookupAccountSD.

    // We trap the magic SID that specifies everyone
    if (EqualSid(&gEveryone, pSID))
    {

        if (*pTrusteeType != TRUSTEE_IS_GROUP)
        {
            return E_INVALIDARG;
        } // if

        if (*ppwszTrustee = (LPWSTR)LocalMemAlloc(2*sizeof(WCHAR)))
        {
            (*ppwszTrustee)[0] = L'*';
            (*ppwszTrustee)[1] = L'\0';
            *pTrusteeType = TRUSTEE_IS_GROUP;
            return S_OK;
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    } // if


    // Assign some arbitrary large number as the size of the domain name and
    // the account name. Hopefully, these numbers are large enough so that
    // the function can avoid calling LookupAccountSidW the second time
    dwDomainLength = 32;
    dwAccountLength = 64;

    // Initilize the domain name pointer and the account name pointer to NULL
    pwszDomainName = NULL;
    pwszAccountName = NULL;

    // Allocate big buffers for the domain name and the account name
    // to minimize the chance of call LookupAccountSid twice.
    pwszDomainName = (LPWSTR)LocalMemAlloc(dwDomainLength * sizeof(WCHAR));

    if (pwszDomainName == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    } // if

    pwszAccountName = (LPWSTR)LocalMemAlloc(dwAccountLength * sizeof(WCHAR));
    if (pwszAccountName == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    } // if

    if(!LookupAccountSidW( NULL
                         , pSID
                         , pwszAccountName
                         , &dwAccountLength
                         , pwszDomainName
                         , &dwDomainLength
                         , &SIDUse))
    {
        dwLastError = GetLastError();
        if (dwLastError == ERROR_INSUFFICIENT_BUFFER)
        {
            if(dwDomainLength > 32)
            {
                LocalMemFree(pwszDomainName);
                pwszDomainName = (LPWSTR)LocalMemAlloc(dwDomainLength *
                                                       sizeof(WCHAR));
                if (pwszDomainName == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    goto Error;
                } //if
            } // if

            if(dwAccountLength > 64)
            {
                LocalMemFree(pwszAccountName);
                pwszAccountName = (LPWSTR)LocalMemAlloc(dwAccountLength *
                                                        sizeof(WCHAR));
                if (pwszAccountName == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    goto Error;
                } // if
            } // if

            if(!LookupAccountSidW( NULL
                                 , pSID
                                 , pwszAccountName
                                 , &dwAccountLength
                                 , pwszDomainName
                                 , &dwDomainLength
                                 , &SIDUse ))
            {
                // Either the SID doesn't belong to any account or something
                // has gone terribly wrong. In either case, the caller should
                // call GetLastError to get more information about the error
                hr = CO_E_LOOKUPACCSIDFAILED;
                goto Error;
            } // if

        } // if
        else
        {
            // The caller should call GetLastError to obtain more information
            hr = CO_E_LOOKUPACCSIDFAILED;
            goto Error;
        } // if

    } // if

    // Check to see if the SIDtype retuned by LookupAccountSidW matches the
    // trustee type provided by the caller. If not, we're in trouble.
    // SidTypeWellKnownGroup and SidTypeAlias can be either.
    if( !(SIDUse == SidTypeUser && *pTrusteeType == TRUSTEE_IS_USER)   &&
        !(SIDUse == SidTypeGroup && *pTrusteeType == TRUSTEE_IS_GROUP) &&
        SIDUse != SidTypeWellKnownGroup && SIDUse != SidTypeAlias)
    {
        hr = CO_E_NOMATCHINGSIDFOUND;
        goto Error;
    } // if

    // Allocate memory for the trustee string to be returned
    // Add 2 for null terminating the string and '\\'

    // We need to use the correct lengths now. The docs for LookUpAccountSID
    // do not promise that it returns corrected lengths upon success.
    dwDomainLength = lstrlenW(pwszDomainName);
    dwAccountLength = lstrlenW(pwszAccountName);

    pwszTrustee = (LPWSTR)midl_user_allocate( (dwDomainLength
                                               + dwAccountLength
                                               + 2) * sizeof(WCHAR)
                                            );

    if (pwszTrustee == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    } // if

    // Compose the trustee string
    memcpy(pwszTrustee, pwszDomainName, dwDomainLength * sizeof(WCHAR));
    pwszTrustee[dwDomainLength] = L'\\';
    memcpy(&pwszTrustee[dwDomainLength+1], pwszAccountName, 
                (dwAccountLength+1) * sizeof(WCHAR));   //copies NULL terminator

    *ppwszTrustee = pwszTrustee;

Error:
    // Release the domain name string and the account name string
    if (pwszAccountName != NULL)
    {
        LocalMemFree(pwszAccountName);
    } // if
    if (pwszDomainName != NULL)
    {
        LocalMemFree(pwszDomainName);
    } // if
    return hr;
} // GetNameFromSID

//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: PutStreamACLIntoSecDesc, NT specific
//
// Summary: This functions takes a STREAM_ACL structure and maps it to a
//          discretionary ACL in a security descriptor. The buffer for the
//          discretionary ACL and the security descriptor are packaged
//          into the NT version of ACL_DESCRICPTOR.
//
// Args: STREAM_ACL *pStreamACL [in] - The STREAM_ACL structure to be mapped
//                                     to a discretionary ACL.
//       ACL_DESCRIPTOR *pACLDesc [in,out] - The NT version of ACL_DESCRIPTOR
//                                           structure. This structure contains
//                                           a buffer for the discretionary
//                                           ACL, a security descriptor, size
//                                           information, and a control flag.
//
// Return: HRESULT - S_OK: Succeeded.
//                   CO_E_FAILEDTOSETDACL: SetSecurityDescriptorDacl returned
//                                         false inside PutStreamACLIntoSecDesc.
//                                         The client of this method can call
//                                         GetLastError to get extended error
//                                         information.
//                   E_OUTOFMEMORY: The system ran out of memory for allocating
//                                  the NT ACL.
//
// Called by: ComputeEffectiveAccess
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
HRESULT PutStreamACLIntoSecDesc
(
STREAM_ACL     *pStreamACL,
ACL_DESCRIPTOR *pACLDesc
)
{
    ACL        *pACLHeader;         // Pointer to the ACL structure in the ACL
                                    // buffer.
    ULONG      i;                   // Loop counter
    CHAR       *pBufferPtr;         // Pointer for traversing the ACL buffer.
    ULONG      ulNumOfStreamACEs;   // Total number of STREAM_ACE structures to map.
    STREAM_ACE *pStreamACEsPtr;     // Pointer for traversing the array of
                                    // of STREAM_ACE structures to be mapped.
    ACE_HEADER *pACEHeader;         // Pointer to the header of an ACE.
    ULONG      ulACLSize;
    WORD       wSIDSize;            // Size of the SID to be copied into an ACE.

    // Compute the total size of the ACL buffer
    ulACLSize = pACLDesc->ulSIDSize
              + (pStreamACL->ulNumOfGrantEntries + pStreamACL->ulNumOfDenyEntries)
              * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD))
              + sizeof(ACL);

    // Reallocate a new buffer for the NT ACL if the current buffer is not
    // big enough. Note that an extra 64 bytes is padded at the end to
    // minimize the need for reallocating the buffer if the internal ACL
    // is changed in a minor way.
    if (pACLDesc->ulACLBufferSize < ulACLSize)
    {
        LocalMemFree(pACLDesc->pACLBuffer);
        pACLDesc->pACLBuffer = (CHAR *)LocalMemAlloc(ulACLSize + 64);
        if (pACLDesc->pACLBuffer == NULL)
        {
            pACLDesc->ulACLBufferSize = 0;
            return E_OUTOFMEMORY;
        } // if
        pACLDesc->ulACLBufferSize = ulACLSize + 64;
    } // if

    // Map the stream ACL to the NT ACL
    ulNumOfStreamACEs = pStreamACL->ulNumOfDenyEntries
                      + pStreamACL->ulNumOfGrantEntries;

    // Set up the ACL header first
    pACLHeader = (ACL *)(pACLDesc->pACLBuffer);
    pACLHeader->AclRevision = ACL_REVISION2;
    pACLHeader->AclSize = (USHORT)ulACLSize;
    pACLHeader->AceCount = (USHORT)ulNumOfStreamACEs;


    pBufferPtr = (CHAR *)(pACLDesc->pACLBuffer) + sizeof(ACL);
    pStreamACEsPtr = pStreamACL->pACL;

    // The following for loop maps the STREAM_ACE structures into the
    // ACL buffer for NT.
    for (i = 0; i < ulNumOfStreamACEs; i++)
    {
        // ACCESS_ALLOWED_ACE and ACCESS_DENIED_ACE are
        // structurally equivalent, so I may as well use one of them
        pACEHeader = &(((ACCESS_ALLOWED_ACE *)pBufferPtr)->Header);

        // Skip ACEs with NULL SID
        if(pStreamACEsPtr->pSID == NULL)
        {
            continue;
        } // if

        if (pStreamACEsPtr->grfAccessMode == ACTRL_ACCESS_DENIED)
        {
            pACEHeader->AceType = ACCESS_DENIED_ACE_TYPE;
        }
        else
        {
            pACEHeader->AceType = ACCESS_ALLOWED_ACE_TYPE;
        } // if

        pACEHeader->AceFlags = NULL;
        StandardMaskToNTMask( &(pStreamACEsPtr->grfAccessPermissions)
                            , &(((ACCESS_ALLOWED_ACE *)pBufferPtr)->Mask));
        wSIDSize = (USHORT)GetLengthSid(pStreamACEsPtr->pSID);
        CopySid( wSIDSize
               , &(((ACCESS_ALLOWED_ACE *)pBufferPtr)->SidStart)
               , pStreamACEsPtr->pSID);
        pACEHeader->AceSize = sizeof(ACCESS_ALLOWED_ACE)
                            - sizeof(DWORD)
                            + wSIDSize;

        // Increment the ACL buffer to the next available slot
        // for the the next ACE
        pBufferPtr += pACEHeader->AceSize;

        // Increment the stream ACE porinter to point to the next
        // STREAM_ACE structure to be mapped
        pStreamACEsPtr++;
    } // for

    // Call SetSecurityDescriptorDACL to put the mapped
    // NT ACL into the security desriptor. The security should be initialized
    // with a group SID and a group SID by now. See the
    // COAccessControl::CImpAccessControl:Load method for details.
    if(!SetSecurityDescriptorDacl( &(pACLDesc->SecDesc)
                                 , TRUE
                                 , (ACL *)(pACLDesc->pACLBuffer)
                                 , FALSE))
    {
        return CO_E_FAILEDTOSETDACL;
    } // if

    pACLDesc->bDirtyACL = FALSE;
    return 0;

} // PutStreamACLIntoSecurityDescriptor

/////////////////////////////////////////////////////////////////////////////
//
// The access mask conversion routines
//
// Notes: The DCOM implementation of IAccessControl only supports the
//        execute permission and so the following functions are hard-coded to
//        convert the execute permission only. However, these function can be
//        extended to support a wider range of permissions without
//        substantantial changes in the rest of the code. For an even more
//        generic architecture, a table of mask conversion can be used.
//
/////////////////////////////////////////////////////////////////////////////

//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: StandardMaskToNTMask
//
// Summary: This function maps the content of a access permissions
//          supported by IAccessControl to the corresponding NT
//          security access mask.
//
// Args:  DWORD *pStdMask [in] - The standard mask to be converted to NT
//                               mask.
//        ACCESS_MASK *pNTMask [out] - Reference to the converted mask.
//
//
// Return: void
//
// Called by: PutStreamACLIntoSecDesc
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
void StandardMaskToNTMask
(
DWORD       *pStdMask,
ACCESS_MASK *pNTMask
)
{
    *pNTMask= 0;


    if ((*pStdMask & COM_RIGHTS_EXECUTE) != 0)
    {
        *pNTMask |= NT_RIGHTS_EXECUTE;
    } // if

} // StandardMaskToNTMask

//F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F
// Function: NTMaskToStandardMask, NT specific
//
// Summary: This function maps the content of an NT access mask to a
//          corresponding IAccessControl access mask.
//
// Args:  ACCESS_MASK *pNTMask [in] - Address of the NT mask to be covnverted.
//        DWORD *pStdMask [in] - Address of the converted IAccessControl
//                               access mask.
//
// Return: void
//
// Called by: ComputeEffectiveAccess
//
//F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F-F
void NTMaskToStandardMask
(
ACCESS_MASK *pNTMask,
DWORD       *pStdMask
)
{
    *pStdMask= 0;

    if ((*pNTMask & NT_RIGHTS_EXECUTE) != 0)
    {
        *pStdMask |= COM_RIGHTS_EXECUTE;
    } // if

} // NTMaskToStandardMask

#endif // #ifdef _CHICAGO_, #else
// End of caccctrl.cxx
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\accctrl\daytona\makefile.inc ===
!include ..\makeidl.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\accctrl\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=   accctrl
TARGETPATH=   obj
TARGETTYPE=   LIBRARY

INCLUDES= $(O)
INCLUDES= $(INCLUDES);..\..\inc;..\..\..\ih;..\..\dcomrem;..\..\objact
INCLUDES= $(INCLUDES);..\..\..\idl\public\$(DEST_TREE)\$(O)
INCLUDES= $(INCLUDES);..\..\..\idl\internal\$(DEST_TREE)\$(O)
INCLUDES= $(INCLUDES);..\..\..\idl\private\$(DEST_TREE)\$(O)
INCLUDES= $(INCLUDES);$(BASE_INC_PATH);$(SDK_INC_PATH)


C_DEFINES=    \
              $(C_DEFINES)  \
              -D_WIN32_DCOM

SOURCES=      \
              $(O)\acpickl_c.c   \
              ..\acsrv.cxx  \
              ..\cache.cxx  \
              ..\caccctrl.cxx

# Generate stubs from idl files
NTTARGETFILE0=allidl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\accctrl\chicago\makefile.inc ===
!include ..\makeidl.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\apcompat\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=   apcompat
TARGETPATH=   obj
TARGETTYPE=   LIBRARY

INCLUDES    = obj
INCLUDES=     $(INCLUDES);..\..\..\idl\public\daytona\$(O)
INCLUDES=     $(INCLUDES);..\..\..\idl\private\daytona
INCLUDES=     $(INCLUDES);..\..\..\idl\private\daytona\$(O)
INCLUDES=     $(INCLUDES);..\..\..\ih
INCLUDES=     $(INCLUDES);..\..\inc
INCLUDES=     $(INCLUDES);$(BASE_INC_PATH)


C_DEFINES=    $(C_DEFINES) -DDARWIN_ENABLED -DMSWMSG

SOURCES=      $(SOURCES)                                      \
              ..\apcompat.cxx

UMTYPE=       windows
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\apcompat\apcompat.cxx ===
//+-------------------------------------------------------------------
//
//  File:       apcompat.cxx
//
//  Contents:   Code that provides information about app compatibility 
//              flags for the current process
//
//  Classes:    None
//
//  Functions:  GetAppCompatInfo
//              UseFTMFromCurrentApartment
//              ValidateInPointers
//              ValidateOutPointers
//              ValidateCodePointers
//              ValidateInterfaces
//              ValidateIIDs
//              
//
//  History:    05-Apr-2000   mfeingol
//
//--------------------------------------------------------------------

#include <ole2int.h>

#include "apcompat.hxx"


STDAPI_(BOOL) UseFTMFromCurrentApartment()
{
    return (BOOL)APPCOMPATFLAG(KACF_FTMFROMCURRENTAPT);
}

STDAPI_(BOOL) DisallowDynamicORBindingChanges()
{
    return (BOOL)APPCOMPATFLAG(KACF_DISALLOWORBINDINGCHANGES);
}


STDAPI_(BOOL) ValidateInPointers()
{
    return (BOOL)APPCOMPATFLAG(KACF_OLE32VALIDATEPTRS);
}

STDAPI_(BOOL) ValidateOutPointers()
{
    // For now, we'll just use the same flag for all validations
    return ValidateInPointers();
}

STDAPI_(BOOL) ValidateCodePointers()
{
    // For now, we'll just use the same flag for all validations
    return ValidateInPointers();
}

STDAPI_(BOOL) ValidateInterfaces()
{
    // For now, we'll just use the same flag for all validations
    return ValidateInPointers();
}

STDAPI_(BOOL) ValidateIIDs()
{
    // For now, we'll just use the same flag for all validations
    return ValidateInPointers();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\catalog\cache.cxx ===
/* cache.cxx */

#include <windows.h>
#include <comdef.h>

#include "notify.hxx"

#include "cache.hxx"

#if DBG
#include "partitions.h"    // ICacheControl
#endif

#include "catdbg.hxx"

#pragma warning(disable:4200)   /* zero-sized array in ELEMENT */

#define MIN_NOTIFY_TICKS    (100U)  /* minimum mS between notify checks */
#define ELEMENT_TIMEOUT_TICKS (30000)  /* minimum ticks before timing out unused elements */

typedef struct tagElement
{
    struct tagElement  *pNext;
    DWORD               iHashValue;
    DWORD               dwTickCountLastUsed;
    USHORT              fValueFlags;
    USHORT              cbKey;
    IUnknown           *pUnknown;
    BYTE                abKey[ /* cbKey */ 0 ];
} ELEMENT;


/* class CCache */

CCache::CCache(BOOL bTraceElementLastTimeUsed)
{
    m_paBuckets = NULL;
    m_cBuckets = 0;
    m_cElements = 0;
    m_cNotify = 0;
    m_dwLastNotifyTickCount = GetTickCount();
    m_bTraceElementLastTimeUsed = bTraceElementLastTimeUsed;
    m_Lock.Initialize();
}


CCache::~CCache(void)
{
    CleanupNotify();	
    Flush(CCACHE_F_ALL);

    m_Lock.Cleanup();
}


HRESULT STDMETHODCALLTYPE CCache::SetupNotify
(
HKEY hKeyParent,
const WCHAR *pwszSubKeyName
)
{
    HRESULT hr;

    m_Lock.AcquireWriterLock();

    Flush(CCACHE_F_ALL);

    if ( m_cNotify < MAX_CACHE_NOTIFY )
    {
        hr = m_Notify[m_cNotify].CreateNotify(hKeyParent, pwszSubKeyName);

        m_cNotify++;
    }
    else
    {
        hr = E_FAIL;
    }

    m_Lock.ReleaseWriterLock();

    return(hr);
}


HRESULT STDMETHODCALLTYPE CCache::CheckNotify
(
int fForceCheck,
int *pfChanged
)
{
    int iNotify;
    int fChanged;

    *pfChanged = FALSE;

    if ((!fForceCheck) &&
        ((GetTickCount() - m_dwLastNotifyTickCount) < MIN_NOTIFY_TICKS))
    {
        return(S_OK);
    }

    for (iNotify = 0; iNotify < m_cNotify; iNotify++)
    {
        m_Notify[iNotify].QueryNotify(&fChanged);

        if (fChanged)
        {
            *pfChanged = TRUE;
        }
    }

    m_dwLastNotifyTickCount = GetTickCount();

    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CCache::CleanupNotify (void)
{
    HRESULT hr = S_OK;

    m_Lock.AcquireWriterLock();

    while (m_cNotify > 0)
    {
        hr = SUCCEEDED(hr) ? m_Notify[--m_cNotify].DeleteNotify() : hr;
    }

    m_Lock.ReleaseWriterLock();

    return(hr);
}

// This is the real work-horse version of this method... all the work is
// really done based on a single key blob.  (This gets called directly when
// you've got a single key.)
HRESULT STDMETHODCALLTYPE CCache::AddElement
(
DWORD iHashValue,
BYTE *pbKey,
USHORT cbKey,
USHORT *pfValueFlags,
IUnknown *pUnknown,
IUnknown **ppExistingUnknown
)

{
    DWORD iHashBucket;
    ELEMENT *pElement;
    int fForceCheck;
    int fChanged;
#if DBG
    ICacheControl *pControl;
#endif

    if ( ppExistingUnknown )
    {
        *ppExistingUnknown = NULL;
    }

    if ( (pbKey == NULL) || (cbKey == 0) )
    {
        return(E_CACHE_BAD_KEY);
    }

    m_Lock.AcquireWriterLock();

    /* see if this key is already present */

    if ( m_cBuckets != 0 )
    {
        iHashBucket = iHashValue % m_cBuckets;

        for ( pElement = m_paBuckets[iHashBucket];
            pElement != NULL;
            pElement = pElement->pNext )
        {
            if ( (pElement->iHashValue == iHashValue) &&
                 (pElement->cbKey == cbKey) &&
                 (memcmp(pElement->abKey, pbKey, cbKey) == 0) )
            {
                if ( pElement->fValueFlags & CCACHE_F_NOTREGISTERED )
                {
                    fForceCheck = TRUE;
                }
                else
                {
                    fForceCheck = FALSE;
                }

                CheckNotify(fForceCheck, &fChanged);

                if ( fChanged )
                {
                    Flush(CCACHE_F_ALL);
                    break;
                }

                if ( ppExistingUnknown != NULL )
                {
                    *ppExistingUnknown = pElement->pUnknown;

                    if ( pElement->pUnknown != NULL )
                    {
                        pElement->pUnknown->AddRef();
                    }

                    *pfValueFlags = pElement->fValueFlags;
                }

                m_Lock.ReleaseWriterLock();
                return E_CACHE_DUPLICATE;
            }
        }
    }


    /* time to grow the cache? */

    if ( (m_cElements + 1) > m_cBuckets )
    {
        DWORD cBucketsNew;
        ELEMENT **paBucketsNew;

        cBucketsNew = m_cBuckets * 2 + 16;     // 0, 16, 48, 112, ...

        paBucketsNew = (ELEMENT **) new ELEMENT *[cBucketsNew];
        if ( paBucketsNew == NULL )
        {
            if ( m_cBuckets == 0 )
            {
                m_Lock.ReleaseWriterLock();
                return E_CACHE_NO_MEMORY;
            }
        }
        else
        {
            memset(paBucketsNew, 0, sizeof(ELEMENT *) * cBucketsNew);

            for ( iHashBucket = 0; iHashBucket < m_cBuckets; iHashBucket++ )
            {
                pElement = m_paBuckets[iHashBucket];

                while ( pElement != NULL )
                {
                    ELEMENT *pElementNext;
                    DWORD iHashBucketNew;

                    pElementNext = pElement->pNext;

                    iHashBucketNew = pElement->iHashValue % cBucketsNew;

                    pElement->pNext = paBucketsNew[iHashBucketNew];
                    paBucketsNew[iHashBucketNew] = pElement;

                    pElement = pElementNext;
                }
            }

            if ( m_paBuckets != NULL )
            {
                delete m_paBuckets;
            }

            m_paBuckets = paBucketsNew;
            m_cBuckets = cBucketsNew;

            iHashBucket = iHashValue % m_cBuckets;
        }
    }

    pElement = (ELEMENT *) new BYTE[sizeof(ELEMENT) + cbKey];
    if ( pElement == NULL )
    {
        m_Lock.ReleaseWriterLock();
        return E_CACHE_NO_MEMORY;
    }

    pElement->fValueFlags = *pfValueFlags;
    pElement->cbKey = cbKey;
    pElement->iHashValue = iHashValue;

    if (m_bTraceElementLastTimeUsed)
    {
      pElement->dwTickCountLastUsed = GetTickCount();
    }
    else
      pElement->dwTickCountLastUsed = -1;

    pElement->pUnknown = pUnknown;
    memcpy(pElement->abKey, pbKey, cbKey);

    pElement->pNext = m_paBuckets[iHashBucket];
    m_paBuckets[iHashBucket] = pElement;

    if ( pUnknown != NULL )
    {
        pUnknown->AddRef();
#if DBG
        if ( pUnknown->QueryInterface(IID_ICacheControl, (void **) &pControl) == S_OK )
        {
            pControl->CacheAddRef();
            pControl->Release();
        }
#endif
    }

    m_cElements++;

    m_Lock.ReleaseWriterLock();
    return S_OK;
}


// This version of AddElement takes two keys and fuses them into a single
// key.
HRESULT STDMETHODCALLTYPE CCache::AddElement
(
DWORD iHashValue,
BYTE *pbKey,
USHORT cbKey,
BYTE *pbKey2,
USHORT cbKey2,
USHORT *pfValueFlags,
IUnknown *pUnknown,
IUnknown **ppExistingUnknown
)
{
    BYTE *pbSingleKey = (BYTE *)_alloca(cbKey + cbKey2);

    if ((pbKey == NULL) || (cbKey == 0))
    {
        return E_CACHE_BAD_KEY;
    }

    memcpy(pbSingleKey, pbKey, cbKey);

    if (cbKey2 && pbKey2)
        memcpy (pbSingleKey + cbKey, pbKey2, cbKey2);

    return AddElement (iHashValue,
                       pbSingleKey,
                       cbKey + cbKey2,
                       pfValueFlags,
                       pUnknown,
                       ppExistingUnknown);
}

// This version of AddElement takes an arbitrary number of keys
// and fuses them into a single key.
HRESULT STDMETHODCALLTYPE CCache::AddElement
(
DWORD iHashValue,
USHORT cKeys,
BYTE **pbKey,
USHORT *cbKey,
USHORT *pfValueFlags,
IUnknown *pUnknown,
IUnknown **ppExistingUnknown
)
{
    BYTE *pbSingleKey = NULL;
    USHORT cbSingleKey = 0;
    USHORT i;
    HRESULT hr;

    for (i=0; i < cKeys; i++)
    {
		if (pbKey[i] != NULL) 
			cbSingleKey += cbKey[i];
    }

    if (cbSingleKey)
    {
        pbSingleKey = (BYTE *)_alloca(cbSingleKey);

        cbSingleKey = 0;
        for (i=0; i < cKeys; i++)
        {
			if (!((pbKey[i] == NULL) || (cbKey[i] == 0)))
			{
				memcpy (pbSingleKey + cbSingleKey, pbKey[i], cbKey[i]);
				cbSingleKey += cbKey[i];
			}
        }

        hr = AddElement(iHashValue,
                        pbSingleKey,
                        cbSingleKey,
                        pfValueFlags,
                        pUnknown,
                        ppExistingUnknown);
    }
    else
        hr = E_CACHE_BAD_KEY;

    return hr;
}

// Like AddElement, the single-key version is the one that does all the work.
HRESULT STDMETHODCALLTYPE CCache::GetElement
(
DWORD iHashValue,
BYTE *pbKey,
USHORT cbKey,
USHORT *pfValueFlags,
IUnknown **ppUnknown
)
{
    DWORD iHashBucket;
    ELEMENT *pElement;
    int fForceCheck;
    int fChanged = FALSE;

    *ppUnknown = NULL;

    if ( (pbKey == NULL) || (cbKey == 0) )
    {
        return(E_CACHE_BAD_KEY);
    }

    m_Lock.AssertNotHeld();
    m_Lock.AcquireReaderLock();

    if ( m_cBuckets != 0 )
    {
        iHashBucket = iHashValue % m_cBuckets;

        for ( pElement = m_paBuckets[iHashBucket];
            pElement != NULL;
            pElement = pElement->pNext )
        {
            if ( (pElement->iHashValue == iHashValue) &&
                 (pElement->cbKey == cbKey) &&
                 (memcmp(pElement->abKey, pbKey, cbKey) == 0) )
            {
                if ( pElement->fValueFlags & ( CCACHE_F_NOTREGISTERED | CCACHE_F_ALWAYSCHECK ) )
                {
                    fForceCheck = TRUE;
                }
                else
                {
                    fForceCheck = FALSE;
                }

                CheckNotify(fForceCheck, &fChanged);

                if ( fChanged )
                {
                    break;
                }

                if ( pElement->pUnknown != NULL )
                {
                    pElement->pUnknown->AddRef();
                }

                *ppUnknown = pElement->pUnknown;
                *pfValueFlags = pElement->fValueFlags;

                // Store the time of the access
                if (m_bTraceElementLastTimeUsed)
                  pElement->dwTickCountLastUsed = GetTickCount();
                
                m_Lock.ReleaseReaderLock();

				CatalogDebugOut((DEB_CACHE, "CComCatalog-- CACHE HIT! %d\n", m_cElements));
                return S_OK;
            }
        }
    }

    m_Lock.ReleaseReaderLock();

    if (fChanged)
    {
        Flush(CCACHE_F_ALL);
    }

	CatalogDebugOut((DEB_CACHE, "CComCatalog-- CACHE MISS! %d\n", m_cElements));
    return E_CACHE_NOT_FOUND;
}


// This version of GetElement takes two keys and fuses them into a single
// key.
HRESULT STDMETHODCALLTYPE CCache::GetElement
(
DWORD iHashValue,
BYTE *pbKey,
USHORT cbKey,
BYTE *pbKey2,
USHORT cbKey2,
USHORT *pfValueFlags,
IUnknown **ppUnknown
)
{
    BYTE *pbSingleKey = (BYTE *)_alloca(cbKey + cbKey2);

    if ((pbKey == NULL) || (cbKey == 0))
    {
        return E_CACHE_BAD_KEY;
    }

    memcpy(pbSingleKey, pbKey, cbKey);

    if (cbKey2 && pbKey2)
        memcpy (pbSingleKey + cbKey, pbKey2, cbKey2);

    return GetElement (iHashValue,
                       pbSingleKey,
                       cbKey + cbKey2,
                       pfValueFlags,
                       ppUnknown);
}

// This version of GetElement takes an arbitrary number of keys
// and fuses them into a single key.
HRESULT STDMETHODCALLTYPE CCache::GetElement
(
DWORD iHashValue,
USHORT cKeys,
BYTE **pbKey,
USHORT *cbKey,
USHORT *pfValueFlags,
IUnknown **ppUnknown
)
{
    BYTE  *pbSingleKey = NULL;
    USHORT cbSingleKey = 0;
    USHORT i;
    HRESULT hr;

    for (i=0; i < cKeys; i++)
    {
		if (pbKey[i] != NULL)
			cbSingleKey += cbKey[i];
    }

    if (cbSingleKey)
    {
        pbSingleKey = (BYTE *)_alloca(cbSingleKey);

        cbSingleKey = 0;
        for (i=0; i < cKeys; i++)
        {
			if (!((pbKey[i] == NULL) || (cbKey[i] == 0)))
			{
				memcpy (pbSingleKey + cbSingleKey, pbKey[i], cbKey[i]);
				cbSingleKey += cbKey[i];
			}
        }

        hr = GetElement(iHashValue,
                        pbSingleKey,
                        cbSingleKey,
                        pfValueFlags,
                        ppUnknown);
    }
    else
        hr = E_CACHE_BAD_KEY;

    return hr;
}


HRESULT STDMETHODCALLTYPE CCache::Flush
(
USHORT fValueFlags
)
{
    DWORD iHashBucket;
#if DBG
    ICacheControl *pControl;
#endif

	CatalogDebugOut((DEB_CACHE, "CComCatalog-- CACHE FLUSH! %d\n", m_cElements));

    m_Lock.AcquireWriterLock();

    for ( iHashBucket = 0; iHashBucket < m_cBuckets; iHashBucket++ )
    {
        ELEMENT *pElement = m_paBuckets[iHashBucket];

        while ( pElement != NULL )
        {
            ELEMENT *pElementNext = pElement->pNext;

            if ( pElement->pUnknown != NULL )
            {
#if DBG
                if ( pElement->pUnknown->QueryInterface(IID_ICacheControl, (void **) &pControl) == S_OK )
                {
                    pControl->CacheRelease();
                    pControl->Release();
                }
#endif
                pElement->pUnknown->Release();
            }

            delete pElement;

            pElement = pElementNext;
        }
    }

    if ( m_paBuckets != NULL )
    {
        delete m_paBuckets;
    }

    m_paBuckets = NULL;
    m_cBuckets = 0;
    m_cElements = 0;

    m_Lock.ReleaseWriterLock();
    return(S_OK);
}


//
//  Function:  CCache::FlushStaleElements
//
//  Synopsis:  Removes old elements from the cache.
//             First checks for said stale elements
//             under a reader lock to avoid contention
//             in the common case.   Only if old items
//             are found will it take the write lock.
//
//  Returns:   S_OK
//
HRESULT CCache::FlushStaleElements()
{
  BOOL bWeHaveStaleElements;
  
  // Can't flush if we're not tracking access times
  if (!m_bTraceElementLastTimeUsed)
    return S_OK;

  CheckForAndMaybeRemoveStaleElements(FALSE, &bWeHaveStaleElements);

  if (bWeHaveStaleElements)
  {
    //  call it again, this time removing the dead ones
    CheckForAndMaybeRemoveStaleElements(TRUE, &bWeHaveStaleElements);
  }

  return S_OK;
};

//
//  Function:  CCache::CheckForAndMaybeRemoveStaleElements
//
//  Synopsis:  Enumerates thru the items in the cache.  If any
//             any old items are found, and bRemove is TRUE, then
//             those items will be removed; if bRemove is FALSE 
//             they will be left alone.  *pbHadStaleItems will be
//             set to TRUE if old elements were found, FALSE otherwise.
// 
//  Returns:   S_OK
//
HRESULT STDMETHODCALLTYPE CCache::CheckForAndMaybeRemoveStaleElements(BOOL bRemove, BOOL* pbHadStaleItems)
{
  DWORD iHashBucket;
  DWORD dwTickCountNow = GetTickCount();

  *pbHadStaleItems = FALSE;

  if (bRemove)
    m_Lock.AcquireWriterLock();
  else
    m_Lock.AcquireReaderLock();
  
  for ( iHashBucket = 0; iHashBucket < m_cBuckets; iHashBucket++ )
  {
    ELEMENT* pPrevious =                           // points to the previous element; note that when 1st initialized,
         (ELEMENT*)&(m_paBuckets[iHashBucket]);    // this really only points to the an array element; we can do
                                                   // this since pNext is the first member of the struct

    ELEMENT* pElement = m_paBuckets[iHashBucket];  // points to the current element 
    
    while ( pElement != NULL )
    { 
      if ( (dwTickCountNow - pElement->dwTickCountLastUsed) >= ELEMENT_TIMEOUT_TICKS)
      {        
        *pbHadStaleItems = TRUE;

        if (bRemove)
        {
          // Found an old cache element, nuke it
          if ( pElement->pUnknown != NULL )
          {
            pElement->pUnknown->Release();
          }
        
          // Unlink it from the chain
          ELEMENT* pDeletedElem;
          pPrevious->pNext = pElement->pNext;
          pDeletedElem = pElement;
          pElement = pElement->pNext;

          // Delete the memory
          pDeletedElem->dwTickCountLastUsed = -2;
          delete pDeletedElem;
        }
        else
        {
          pPrevious = pElement;
          pElement = pElement->pNext;
        }
      }
      else
      {
        pPrevious = pElement;
        pElement = pElement->pNext;
      }
    }
  }

  if (bRemove)
    m_Lock.ReleaseWriterLock();
  else
    m_Lock.ReleaseReaderLock();
  
  return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\catalog\catalog.cxx ===
/* catalog.cxx */
#include <windows.h>
#include <comdef.h>
#include <debnot.h>

#define CATALOG_DEFINES
#include "globals.hxx"
#undef CATALOG_DEFINES

#include "catalog.h"        // from catalog.idl
#include "catalog_i.c"      // from catalog.idl
#include "partitions.h"     // from partitions.idl

#include "notify.hxx"       // CNotify needed for CCache
#include "cache.hxx"        // CCache

#include "catalog.hxx"      // CComCatalog
#include "regcat.hxx"       // Registry Catalog interface
#include "sxscat.hxx"       // side-by-side catalog interface

#include "noclass.hxx"      // CComNoClassInfo
#include "services.hxx"     // Hash()

#define MIN_CLB_LOAD_TICKS  (100U)  /* min. mS between attempts to load */

#define MAX_SID             (128)   /* 28 is typical */

/*
 *  globals
 */

LONG g_bInSCM=FALSE;

const WCHAR g_wszCLSID[] = L"Software\\Classes\\CLSID";
const WCHAR g_wszClasses[] = L"Software\\Classes";
const WCHAR g_wszCom3[] = L"Software\\Microsoft\\COM3";
const char g_szCLBCATQDLL[] = "CLBCATQ.DLL";
const WCHAR g_wszCom3ActivationValue[] = L"Com+Enabled";

CComCatalog s_catalogObject;
CCache* s_pCacheClassInfo = NULL;         // CLSID->ClassInfo cache
CCache* s_pCacheApplicationInfo = NULL;   // APPID->ApplicationInfo cache
CCache* s_pCacheProcessInfo = NULL;       // ProcessID->ProcessInfo cache
CCache* s_pCacheServerGroupInfo = NULL;
CCache* s_pCacheRetQueueInfo = NULL;
CCache* s_pCacheProgID = NULL;            // ProgID->ClassInfo cache

DECLARE_INFOLEVEL(Catalog);               // Catalog debug tracing

/* need this here.... */

static void * __cdecl operator new(size_t cbAlloc, size_t cbExtra)
{
    return(::new char[cbAlloc + cbExtra]);
}

BOOL CatalogDllMain (
    HINSTANCE hInst,
    DWORD dwReason,
    LPVOID lpReserved
)
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        g_CatalogLock.Initialize();
        break;

    case DLL_PROCESS_DETACH:
        g_CatalogLock.Cleanup();
        break;
    }

    return(TRUE);
}


STDAPI GetCatalogHelper
(
/* [in] */ REFIID riid,
/* [out, iis_is(riid)] */ void ** ppv
)
{
    return s_catalogObject.QueryInterface(riid, ppv);
}


HRESULT CComCatalogCF_CreateInstance (IUnknown *pUnkOuter, REFIID riid, void** ppv)
{
    if (ppv == NULL)
    {
        return E_INVALIDARG;
    }
    else if (pUnkOuter)
    {
        return CLASS_E_NOAGGREGATION;
    }
    else
    {
        return s_catalogObject.QueryInterface(riid, ppv);
    }
}

/*
 *  class CComCatalog
 */

CComCatalog::CComCatalog(void) : m_pCatalogRegNative(NULL), m_pCatalogRegNonNative(NULL), m_pCatalogCOMBaseInCLB(NULL),
								 m_pCatalogCLB(NULL), m_cRef(0), m_CombaseInCLBState(CLBCATQ_LOCKED), 
								 m_CLBCATQState(CLBCATQ_LOCKED), m_bTriedToLoadComBaseCLBAtLeastOnce(FALSE), 
								 m_bTriedToLoadCLBAtLeastOnce(FALSE), m_pCatalogSxS(NULL)
{
}


STDMETHODIMP CComCatalog::QueryInterface
(
    REFIID riid,
    LPVOID FAR* ppvObj
)
{
    HRESULT hr;

    *ppvObj = NULL;

    if (riid == IID_IComCatalog)
    {
        *ppvObj = (LPVOID) (IComCatalog *) this;
    }
	else if (riid == IID_IComCatalog2)
	{
		*ppvObj = (LPVOID) (IComCatalog2 *) this;
	}
    else if (riid == IID_IComCatalogSCM)
    {
        *ppvObj = (LPVOID) (IComCatalogSCM *) this;
    }
    else if (riid == IID_IComCatalogInternal)
    {
        *ppvObj = (LPVOID) (IComCatalogInternal *) this;
    }
	else if (riid == IID_IComCatalog2Internal)
	{
		*ppvObj = (LPVOID) (IComCatalog2Internal *) this;
	}
    else if (riid == IID_IUnknown)
    {
        *ppvObj = (LPVOID) (IComCatalog *) this;
    }

    if (*ppvObj != NULL)
    {
        ((LPUNKNOWN) *ppvObj)->AddRef();

        return(NOERROR);
    }

    /* maybe the Component Library's catalog interface supports this mystery IID */

    if (m_pCatalogCLB != NULL)
    {
        hr = m_pCatalogCLB->QueryInterface(riid, ppvObj);
        if (hr == S_OK)
        {
            return(hr);
        }
    }

	if (m_pCatalogCOMBaseInCLB != NULL)
	{
		hr = m_pCatalogCOMBaseInCLB->QueryInterface(riid, ppvObj);
		if (hr == S_OK)
		{
			return (hr);
		}
	}

	/* maybe the registry's catalog interface supports this mystery IID */

    if (m_pCatalogRegNative != NULL)
    {
        hr = m_pCatalogRegNative->QueryInterface(riid, ppvObj);
        if (hr == S_OK)
        {
            return(hr);
        }
    }

    /* maybe the side by side catalog supports this mystery IID */

    if (m_pCatalogSxS != NULL)
    {
        hr = m_pCatalogSxS->QueryInterface(riid, ppvObj);
        if (hr == S_OK)
        {
            return(hr);
        }
    }

    return(E_NOINTERFACE);
}


STDMETHODIMP_(ULONG) CComCatalog::AddRef(void)
{
    long cRef;

    if ( m_CLBCATQState != CLBCATQ_RESOLVED)
    {
        TryToLoadCLB();
    }

	if (m_CombaseInCLBState != CLBCATQ_RESOLVED)
	{
		TryToLoadCombaseInCLB();
	}

	g_CatalogLock.AcquireWriterLock();

    if ( m_cRef == 0 )
    {
        /* Start up registry and COM+ catalog providers */

        /* Use the process default registry             */
        GetRegCatalogObject(IID_IComCatalogInternal, 
                            (void **) &m_pCatalogRegNative, 
                            0);
        
        GetSxSCatalogObject(IID_IComCatalogInternal,
                            (void **) &m_pCatalogSxS);

#if defined(_WIN64)
        /* On Win64, the SCM needs to have a look at the 32 bit registry too */

        /* Note: the logic in here that decides when we create the non-native registry provider needs to be
           the same as the logic in com1x/src/comcat/catalogqueries/clbcatq/legcat.cxx that decides when to 
           request a non-native registry provider.  If they get out of sync, bad things will happen. */

        if (g_bInSCM)
        {
            GetRegCatalogObject(IID_IComCatalogInternal, 
                                (void **) &m_pCatalogRegNonNative,
                                KEY_WOW64_32KEY);
        }
#endif

        /* Initializes caches */
        /* If you comment out one of these "new" calls and the associated */
        /* SetupNotify's, that will safely disable the particular cache */
        if (s_pCacheClassInfo == NULL)
        {
            s_pCacheClassInfo = new CCache;
        }
            
        if(s_pCacheClassInfo)
        {
            s_pCacheClassInfo->SetupNotify(HKEY_LOCAL_MACHINE, g_wszClasses);
            s_pCacheClassInfo->SetupNotify(HKEY_LOCAL_MACHINE, g_wszCom3);
            s_pCacheClassInfo->SetupNotify(HKEY_USERS, NULL);
        }

        if (s_pCacheProgID == NULL)
        {
            s_pCacheProgID = new CCache;
        }

        if (s_pCacheProgID)
        {
            s_pCacheProgID->SetupNotify(HKEY_LOCAL_MACHINE, g_wszClasses);
            s_pCacheProgID->SetupNotify(HKEY_USERS, NULL);

            s_pCacheProgID->SetupNotify(HKEY_LOCAL_MACHINE, g_wszCom3);
        }
            
        if (s_pCacheApplicationInfo == NULL)
        {
            s_pCacheApplicationInfo = new CCache;
        }
            
        if(s_pCacheApplicationInfo)
        {
            s_pCacheApplicationInfo->SetupNotify(HKEY_LOCAL_MACHINE, g_wszCom3);
            s_pCacheApplicationInfo->SetupNotify(HKEY_LOCAL_MACHINE, g_wszCLSID);
        }
            
        if (s_pCacheProcessInfo == NULL)
        {
            s_pCacheProcessInfo = new CCache;
        }
            
        if(s_pCacheProcessInfo)
        {
            s_pCacheProcessInfo->SetupNotify(HKEY_LOCAL_MACHINE, g_wszClasses);
            s_pCacheProcessInfo->SetupNotify(HKEY_LOCAL_MACHINE, g_wszCom3);
            s_pCacheProcessInfo->SetupNotify(HKEY_USERS, NULL);
        }

        if (s_pCacheServerGroupInfo == NULL)
        {
            s_pCacheServerGroupInfo = new CCache;
        }
            
        if(s_pCacheServerGroupInfo)
        {
            s_pCacheServerGroupInfo->SetupNotify(HKEY_LOCAL_MACHINE, g_wszCom3);
        }

        if (s_pCacheRetQueueInfo == NULL)
        {
            s_pCacheRetQueueInfo = new CCache;
        }

        if(s_pCacheRetQueueInfo)
        {
            s_pCacheRetQueueInfo->SetupNotify(HKEY_LOCAL_MACHINE, g_wszCom3);
            s_pCacheRetQueueInfo->SetupNotify(HKEY_LOCAL_MACHINE, g_wszCLSID);
        }
    }

    cRef = ++m_cRef;

    g_CatalogLock.ReleaseWriterLock();

    return(cRef);
}


STDMETHODIMP_(ULONG) CComCatalog::Release(void)
{
    long cRef;

    g_CatalogLock.AcquireWriterLock();

	cRef = --m_cRef;
	if ( m_cRef == 0 )
	{
		if (s_pCacheClassInfo != NULL)
		{
			s_pCacheClassInfo->CleanupNotify();
			s_pCacheClassInfo->Flush(CCACHE_F_ALL);

            delete s_pCacheClassInfo;
            s_pCacheClassInfo = NULL;
		}

        if (s_pCacheProgID != NULL)
        {
            s_pCacheProgID->CleanupNotify();
            s_pCacheProgID->Flush(CCACHE_F_ALL);

            delete s_pCacheProgID;
            s_pCacheProgID = NULL;
        }

		if (s_pCacheApplicationInfo != NULL)
		{
			s_pCacheApplicationInfo->CleanupNotify();
			s_pCacheApplicationInfo->Flush(CCACHE_F_ALL);

            delete s_pCacheApplicationInfo;
            s_pCacheApplicationInfo = NULL;       
		}

		if (s_pCacheProcessInfo != NULL)
		{
			s_pCacheProcessInfo->CleanupNotify();
			s_pCacheProcessInfo->Flush(CCACHE_F_ALL);

            delete s_pCacheProcessInfo;
            s_pCacheProcessInfo = NULL; 
		}

		if (s_pCacheServerGroupInfo != NULL)
		{
			s_pCacheServerGroupInfo->CleanupNotify();
			s_pCacheServerGroupInfo->Flush(CCACHE_F_ALL);

            delete s_pCacheServerGroupInfo;
            s_pCacheServerGroupInfo = NULL;  
		}

		if (s_pCacheRetQueueInfo != NULL)
		{
			s_pCacheRetQueueInfo->CleanupNotify();
			s_pCacheRetQueueInfo->Flush(CCACHE_F_ALL);
			
            delete s_pCacheRetQueueInfo;
            s_pCacheRetQueueInfo = NULL;  
		}

        if (m_pCatalogRegNative != NULL)
        {
            m_pCatalogRegNative->Release();
            m_pCatalogRegNative = NULL;
        }

        if (m_pCatalogRegNonNative != NULL)
        {
            m_pCatalogRegNonNative->Release();
            m_pCatalogRegNonNative = NULL;
        }

		if ( m_pCatalogCLB != NULL )
		{
			m_pCatalogCLB->Release();
            m_pCatalogCLB = NULL;
		}

		if (m_pCatalogCOMBaseInCLB != NULL)
		{
			m_pCatalogCOMBaseInCLB->Release();
			m_pCatalogCOMBaseInCLB = NULL;
		}

		m_CLBCATQState = CLBCATQ_LOCKED; 
		m_CombaseInCLBState = CLBCATQ_LOCKED; 

		m_bTriedToLoadCLBAtLeastOnce = FALSE;
		m_bTriedToLoadComBaseCLBAtLeastOnce = FALSE;

        if (m_pCatalogSxS != NULL)
        {
            m_pCatalogSxS->Release();
            m_pCatalogSxS = NULL;
        }
	}

    g_CatalogLock.ReleaseWriterLock();

    return(cRef);
}


/* IComCatalog methods */

HRESULT STDMETHODCALLTYPE CComCatalog::GetClassInfo
(
/* [in] */ REFGUID guidConfiguredClsid,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv
)
{
    HRESULT hr;

	CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfo (IComCatalog)\n"));

    hr = GetClassInfoInternal (CLSCTX_ALL, NULL, guidConfiguredClsid, riid, 
                               ppv, NULL);

	CatalogDebugOut((DEB_CLASSINFO, 
					 "CComCatalog::GetClassInfo (IComCatalog) returning 0x%08x\n", hr));

    return(hr);
}


HRESULT STDMETHODCALLTYPE CComCatalog::GetApplicationInfo
(
/* [in] */ REFGUID guidApplId,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv
)
{
    HRESULT hr;

    hr = GetApplicationInfo (NULL, guidApplId, riid, ppv, NULL);

    return(hr);
}


HRESULT STDMETHODCALLTYPE CComCatalog::GetProcessInfo
(
/* [in] */ REFGUID guidProcess,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv
)
{
    HRESULT hr;

    hr = GetProcessInfoInternal (0, NULL, guidProcess, riid, ppv, NULL);

    return(hr);
}


HRESULT STDMETHODCALLTYPE CComCatalog::GetServerGroupInfo
(
/* [in] */ REFGUID guidServerGroup,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv
)
{
    HRESULT hr;

    hr = GetServerGroupInfo (NULL, guidServerGroup, riid, ppv, NULL);

    return(hr);
}


HRESULT STDMETHODCALLTYPE CComCatalog::GetRetQueueInfo
(
/* [string][in] */ WCHAR __RPC_FAR *wszFormatName,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv
)
{
    HRESULT hr;

    hr = GetRetQueueInfo (NULL, wszFormatName, riid, ppv, NULL);

    return(hr);
}


HRESULT STDMETHODCALLTYPE CComCatalog::GetApplicationInfoForExe
(
/* [string][in] */ WCHAR __RPC_FAR *pwszExeName,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv
)
{
    HRESULT hr;

    hr = GetApplicationInfoForExe (NULL, pwszExeName, riid, ppv, NULL);

    return(hr);
}


HRESULT STDMETHODCALLTYPE CComCatalog::GetTypeLibrary
(
/* [in] */ REFGUID guidTypeLib,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv
)
{
    HRESULT hr;

    hr = GetTypeLibrary (NULL, guidTypeLib, riid, ppv, NULL);

    return(hr);
}


HRESULT STDMETHODCALLTYPE CComCatalog::GetInterfaceInfo
(
/* [in] */ REFIID iidInterface,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv
)
{
    HRESULT hr;

    hr = GetInterfaceInfo (NULL, iidInterface, riid, ppv, NULL);

    return(hr);
}


HRESULT STDMETHODCALLTYPE CComCatalog::FlushCache(void)
{
    g_CatalogLock.AcquireWriterLock();

    if (s_pCacheClassInfo != NULL) s_pCacheClassInfo->Flush(CCACHE_F_ALL);
    if (s_pCacheProgID != NULL) s_pCacheProgID->Flush(CCACHE_F_ALL);
    if (s_pCacheApplicationInfo != NULL) s_pCacheApplicationInfo->Flush(CCACHE_F_ALL);
    if (s_pCacheProcessInfo != NULL) s_pCacheProcessInfo->Flush(CCACHE_F_ALL);
    if (s_pCacheServerGroupInfo != NULL) s_pCacheServerGroupInfo->Flush(CCACHE_F_ALL);
    if (s_pCacheRetQueueInfo != NULL) s_pCacheRetQueueInfo->Flush(CCACHE_F_ALL);

    if (m_pCatalogCLB != NULL)
    {
        m_pCatalogCLB->FlushCache();
    }

	if (m_pCatalogCOMBaseInCLB != NULL)
	{
		m_pCatalogCOMBaseInCLB->FlushCache();
	}

	if (m_pCatalogRegNative != NULL)
	{
		m_pCatalogRegNative->FlushCache();
	}

	if (m_pCatalogRegNonNative != NULL)
	{	
		m_pCatalogRegNonNative->FlushCache();
	}

    // The SxS catalog does not have a cache, but to be uniform with the rest of the providers,
    // we'll tell it to flush its cache.
    if (m_pCatalogSxS != NULL)
    {
        m_pCatalogSxS->FlushCache();
    }

    g_CatalogLock.ReleaseWriterLock();
    return(S_OK);
}

//
//  FlushIdleEntries
// 
//  A directive to flush idle and otherwise recently-unused
//  elements.
//
HRESULT STDMETHODCALLTYPE CComCatalog::FlushIdleEntries()
{
    // This method was once used to flush out idle cached
    // tokens.  Now we don't cache tokens.  So this is a 
    // noop.  Might be useful in future though.

    return S_OK;
}


HRESULT STDMETHODCALLTYPE CComCatalog::GetClassInfoFromProgId
(
/* [in] */ WCHAR __RPC_FAR *wszProgID,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv
)
{
    HRESULT hr;

    hr = GetClassInfoFromProgId (NULL, wszProgID, riid, ppv, NULL);

    return(hr);
}

/* IComCatalog2 methods */

HRESULT STDMETHODCALLTYPE CComCatalog::GetClassInfoByPartition
(
    /* [in] */ REFGUID guidConfiguredClsid,
    /* [in] */ REFGUID guidPartitionId,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv
)
{
	HRESULT hr;

	hr = GetClassInfoByPartition(NULL, guidConfiguredClsid, guidPartitionId, riid, ppv, NULL);

	return(hr);
}

HRESULT STDMETHODCALLTYPE CComCatalog::GetClassInfoByApplication
(
    /* [in] */ REFGUID guidConfiguredClsid,
    /* [in] */ REFGUID guidPartitionId,
    /* [in] */ REFGUID guidApplId,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv
)
{
	HRESULT hr;

	hr = GetClassInfoByApplication(NULL, guidConfiguredClsid, guidPartitionId, guidApplId, riid, ppv, NULL);

	return(hr);
}

/* IComCatalogSCM methods */

HRESULT STDMETHODCALLTYPE CComCatalog::GetClassInfo
(
/* [in] */ DWORD flags,
/* [in] */ IUserToken* pUserToken,
/* [in] */ REFGUID guidConfiguredClsid,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv
)
{
    HRESULT hr;

	CatalogDebugOut((DEB_CLASSINFO, 
					 "CComCatalog::GetClassInfo (IComCatalogSCM) flags = %x\n",flags));

    hr = GetClassInfoInternal (flags, pUserToken, guidConfiguredClsid, riid, 
                               ppv, NULL);

	CatalogDebugOut((DEB_CLASSINFO, 
					 "CComCatalog::GetClassInfo (IComCatalogSCM) returning 0x%08x\n", hr));

    return(hr);
}


HRESULT STDMETHODCALLTYPE CComCatalog::GetApplicationInfo
(
/* [in] */ IUserToken* pUserToken,
/* [in] */ REFGUID guidApplId,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv
)
{
    HRESULT hr;

    hr = GetApplicationInfo (pUserToken, guidApplId, riid, ppv, NULL);

    return(hr);
}


HRESULT STDMETHODCALLTYPE CComCatalog::GetProcessInfo
(
/* [in] */ DWORD flags,
/* [in] */ IUserToken *pUserToken,
/* [in] */ REFGUID guidProcess,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv
)
{
    HRESULT hr;

    hr = GetProcessInfoInternal (flags, pUserToken, guidProcess, riid, 
                                 ppv, NULL);

    return(hr);
}


HRESULT STDMETHODCALLTYPE CComCatalog::GetServerGroupInfo
(
/* [in] */ IUserToken *pUserToken,
/* [in] */ REFGUID guidServerGroup,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv
)
{
    HRESULT hr;

    hr = GetServerGroupInfo (pUserToken, guidServerGroup, riid, ppv, NULL);

    return(hr);
}


HRESULT STDMETHODCALLTYPE CComCatalog::GetRetQueueInfo
(
/* [in] */ IUserToken* pUserToken,
/* [string][in] */ WCHAR __RPC_FAR *wszFormatName,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv
)
{
    HRESULT hr;

    hr = GetRetQueueInfo (pUserToken, wszFormatName, riid, ppv, NULL);

    return(hr);
}


HRESULT STDMETHODCALLTYPE CComCatalog::GetApplicationInfoForExe
(
/* [in] */ IUserToken* pUserToken,
/* [string][in] */ WCHAR __RPC_FAR *pwszExeName,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv
)
{
    HRESULT hr;

    hr = GetApplicationInfoForExe (pUserToken, pwszExeName, riid, ppv, NULL);

    return(hr);
}


HRESULT STDMETHODCALLTYPE CComCatalog::GetTypeLibrary
(
/* [in] */ IUserToken* pUserToken,
/* [in] */ REFGUID guidTypeLib,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv
)
{
    HRESULT hr;

    hr = GetTypeLibrary (pUserToken, guidTypeLib, riid, ppv, NULL);

    return(hr);
}


HRESULT STDMETHODCALLTYPE CComCatalog::GetInterfaceInfo
(
/* [in] */ IUserToken* pUserToken,
/* [in] */ REFIID iidInterface,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv
)
{
    HRESULT hr;

    hr = GetInterfaceInfo (pUserToken, iidInterface, riid, ppv, NULL);

    return(hr);
}


HRESULT STDMETHODCALLTYPE CComCatalog::GetClassInfoFromProgId
(
/* [in] */ IUserToken* pUserToken,
/* [in] */ WCHAR __RPC_FAR *wszProgID,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv
)
{
    HRESULT hr;

    hr = GetClassInfoFromProgId (pUserToken, wszProgID, riid, ppv, NULL);

    return(hr);
}


/* IComCatalogInternal methods */

HRESULT STDMETHODCALLTYPE CComCatalog::GetClassInfo
(
/* [in] */ IUserToken *pUserToken,
/* [in] */ REFGUID guidConfiguredClsid,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
/* [in] */ void __RPC_FAR *pComCatalog
)
{
    return GetClassInfoInternal (CLSCTX_ALL, pUserToken, guidConfiguredClsid,
                                 riid, ppv, pComCatalog);
}

HRESULT STDMETHODCALLTYPE CComCatalog::GetApplicationInfo
(
/* [in] */ IUserToken *pUserToken,
/* [in] */ REFGUID guidApplId,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
/* [in] */ void __RPC_FAR *pComCatalog
)
{
    HRESULT hr;
    IUnknown *pApplicationInfo = NULL;
    IUnknown *pPrevious = NULL;
    USHORT fValueFlags;
    BYTE *pSid = NULL;
    USHORT cbSid;

    *ppv = NULL;

    if (pUserToken != NULL)
    {
        pUserToken->GetUserSid(&pSid, &cbSid);
    }
    else
    {
        pSid = NULL;
        cbSid = 0;
    }

    // Give the side-by-side catalog first crack at providing the data because
    // it needs to override any cached definitions.
    if (m_pCatalogSxS != NULL)
    {
        hr = m_pCatalogSxS->GetApplicationInfo(pUserToken, guidApplId, riid, (void **) &pApplicationInfo, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            fValueFlags = CCACHE_F_SXS;
            goto addToCache;
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    if (s_pCacheApplicationInfo != NULL)
    {
        hr = s_pCacheApplicationInfo->GetElement(
            guidApplId.Data1,
            (BYTE *) &guidApplId,
            sizeof(GUID),
            pSid,
            cbSid,
            &fValueFlags,
            &pApplicationInfo);
        if (hr == S_OK)
        {
            hr = pApplicationInfo->QueryInterface(riid, ppv);

            pApplicationInfo->Release();

            return(hr);
        }
    }

    if (m_pCatalogCLB != NULL)
    {
        hr = m_pCatalogCLB->GetApplicationInfo(pUserToken, guidApplId, riid, (void **) &pApplicationInfo, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            fValueFlags = CCACHE_F_REGDB;

            goto addToCache;
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    if (m_pCatalogRegNative != NULL)
    {
        hr = m_pCatalogRegNative->GetApplicationInfo(pUserToken, guidApplId, riid, (void **) &pApplicationInfo, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            fValueFlags = CCACHE_F_CLASSIC;

            goto addToCache;
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    if (m_pCatalogRegNonNative != NULL)
    {
        hr = m_pCatalogRegNonNative->GetApplicationInfo(pUserToken, guidApplId, riid, (void **) &pApplicationInfo, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            fValueFlags = CCACHE_F_CLASSIC32;

            goto addToCache;
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    return(E_FAIL);

 addToCache:

    if (s_pCacheApplicationInfo != NULL && fValueFlags & CCACHE_F_CACHEABLE)
    {
        hr = s_pCacheApplicationInfo->AddElement(
            guidApplId.Data1,
            (BYTE *) &guidApplId,
            sizeof(GUID),
            pSid,
            cbSid,
            &fValueFlags,
            pApplicationInfo,
            &pPrevious);

        if (hr == E_CACHE_DUPLICATE)
        {
            pApplicationInfo->Release();

            hr = pPrevious->QueryInterface(riid, (void **) &pApplicationInfo);

            pPrevious->Release();

            if (hr != S_OK)
            {
                return(hr);
            }
        }
    }

    *ppv = pApplicationInfo;

    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComCatalog::GetProcessInfo
(
/* [in] */ IUserToken *pUserToken,
/* [in] */ REFGUID guidProcess,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
/* [in] */ void __RPC_FAR *pComCatalog
)
{
    return GetProcessInfoInternal (0, pUserToken, guidProcess, riid, ppv,
                                   pComCatalog);
}


//
// This is the static helper version of GetProcessInfoInternal.
// This is called by the CComClassInfo object to get the associated 
// CComProcessInfo.
//
HRESULT STDMETHODCALLTYPE CComCatalog::GetProcessInfoInternal
(
/* [in] */ DWORD flags,
/* [in] */ IUserToken *pUserToken,
/* [in] */ REFGUID guidProcess,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv
)
{
    HRESULT hr;
    IUnknown *pProcessInfo = NULL;
    IUnknown *pPrevious = NULL;
    USHORT fValueFlags;
    BYTE *pSid = NULL;
    USHORT cbSid;

    *ppv = NULL;

    if (pUserToken != NULL)
    {
        pUserToken->GetUserSid(&pSid, &cbSid);
    }
    else
    {
        pSid = NULL;
        cbSid = 0;
    }

    // Check the side-by-side catalog before checking the cache because the active activation context
    // must take precedent over any cached activation metadata.
    if (s_catalogObject.m_pCatalogSxS != NULL)
    {
        hr = s_catalogObject.m_pCatalogSxS->GetProcessInfo(pUserToken, guidProcess, riid, (void **) &pProcessInfo, NULL);
        if (hr == S_OK)
        {
            fValueFlags = CCACHE_F_SXS;
            goto addToCache;
        }
    }

    if (s_pCacheProcessInfo != NULL)
    {
        hr = s_pCacheProcessInfo->GetElement(
            guidProcess.Data1,
            (BYTE *) &guidProcess,
            sizeof(GUID),
            pSid,
            cbSid,
            &fValueFlags,
            &pProcessInfo);
        if (hr == S_OK)
        {
            hr = pProcessInfo->QueryInterface(riid, ppv);

            pProcessInfo->Release();

            return(hr);
        }
    }

    //See which catalog is needed...
    if (flags & CAT_REG32_ONLY)
    {
        //This should only happen if we're getting a request from a
        //CComClassInfo object that the SCM created from the 32 bit registry.
        Win4Assert (g_bInSCM);
        Win4Assert (s_catalogObject.m_pCatalogRegNonNative);

        //Force to lookup in the 32bit registry...
        hr = s_catalogObject.m_pCatalogRegNonNative->GetProcessInfo(pUserToken, guidProcess, riid, (void **)&pProcessInfo, NULL);

        fValueFlags = CCACHE_F_CLASSIC32;
    }
    else
    {
        //Lookup in default registry...
        hr = s_catalogObject.m_pCatalogRegNative->GetProcessInfo(pUserToken, guidProcess, riid, (void **) &pProcessInfo, NULL);

        fValueFlags = CCACHE_F_CLASSIC;
    }

    if (hr != S_OK)
    {
        return(hr);
    }

addToCache:

    if (s_pCacheProcessInfo != NULL && fValueFlags & CCACHE_F_CACHEABLE)
    {
        hr = s_pCacheProcessInfo->AddElement(
            guidProcess.Data1,
            (BYTE *) &guidProcess,
            sizeof(GUID),
            pSid,
            cbSid,
            &fValueFlags,
            pProcessInfo,
            &pPrevious);

        if (hr == E_CACHE_DUPLICATE)
        {
            pProcessInfo->Release();

            hr = pPrevious->QueryInterface(riid, (void **) &pProcessInfo);

            pPrevious->Release();

            if (hr != S_OK)
            {
                return(hr);
            }
        }
    }

    *ppv = pProcessInfo;

    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComCatalog::GetServerGroupInfo
(
/* [in] */ IUserToken *pUserToken,
/* [in] */ REFGUID guidServerGroup,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
/* [in] */ void __RPC_FAR *pComCatalog
)
{
    HRESULT hr;
    IUnknown *pServerGroupInfo = NULL;
    IUnknown *pPrevious = NULL;
    USHORT fValueFlags;
    BYTE *pSid = NULL;
    USHORT cbSid;

    *ppv = NULL;

    if (pUserToken != NULL)
    {
        pUserToken->GetUserSid(&pSid, &cbSid);
    }
    else
    {
        pSid = NULL;
        cbSid = 0;
    }

    // Check the side-by-side catalog before checking the cache because the active activation context
    // must take precedent over any cached activation metadata.
    if (m_pCatalogSxS != NULL)
    {
        hr = m_pCatalogSxS->GetServerGroupInfo(pUserToken, guidServerGroup, riid, (void **) &pServerGroupInfo, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            fValueFlags = CCACHE_F_SXS;

            goto addToCache;
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    if (s_pCacheServerGroupInfo != NULL)
    {
        hr = s_pCacheServerGroupInfo->GetElement(
            guidServerGroup.Data1,
            (BYTE *) &guidServerGroup,
            sizeof(GUID),
            pSid,
            cbSid,
            &fValueFlags,
            &pServerGroupInfo);
        if (hr == S_OK)
        {
            hr = pServerGroupInfo->QueryInterface(riid, ppv);

            pServerGroupInfo->Release();

            return(hr);
        }
    }

    if (m_pCatalogCLB != NULL)
    {
        hr = m_pCatalogCLB->GetServerGroupInfo(pUserToken, guidServerGroup, riid, (void **) &pServerGroupInfo, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            fValueFlags = CCACHE_F_REGDB;

            goto addToCache;
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    if (m_pCatalogRegNative != NULL)
    {
        hr = m_pCatalogRegNative->GetServerGroupInfo(pUserToken, guidServerGroup, riid, (void **) &pServerGroupInfo, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            fValueFlags = CCACHE_F_CLASSIC;

            goto addToCache;
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    if (m_pCatalogRegNonNative != NULL)
    {
        hr = m_pCatalogRegNonNative->GetServerGroupInfo(pUserToken, guidServerGroup, riid, (void **) &pServerGroupInfo, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            fValueFlags = CCACHE_F_CLASSIC32;

            goto addToCache;
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    return(E_FAIL);

 addToCache:

    if (s_pCacheServerGroupInfo != NULL && fValueFlags & CCACHE_F_CACHEABLE)
    {
        hr = s_pCacheServerGroupInfo->AddElement(
            guidServerGroup.Data1,
            (BYTE *) &guidServerGroup,
            sizeof(GUID),
            pSid,
            cbSid,
            &fValueFlags,
            pServerGroupInfo,
            &pPrevious);

        if (hr == E_CACHE_DUPLICATE)
        {
            pServerGroupInfo->Release();

            hr = pPrevious->QueryInterface(riid, (void **) &pServerGroupInfo);

            pPrevious->Release();

            if (hr != S_OK)
            {
                return(hr);
            }
        }
    }

    *ppv = pServerGroupInfo;

    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComCatalog::GetRetQueueInfo
(
/* [in] */ IUserToken *pUserToken,
/* [string][in] */ WCHAR __RPC_FAR *wszFormatName,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
/* [in] */ void __RPC_FAR *pComCatalog
)
{
    HRESULT hr;
    IUnknown *pRetQueueInfo = NULL;
    IUnknown *pPrevious = NULL;
    USHORT fValueFlags;
    USHORT cbFormatName;
    DWORD iHashValue;
    BYTE *pSid = NULL;
    USHORT cbSid;

    *ppv = NULL;

    cbFormatName = 2 * lstrlenW(wszFormatName);

    iHashValue = Hash((byte *) wszFormatName, cbFormatName);

    if (pUserToken != NULL)
    {
        pUserToken->GetUserSid(&pSid, &cbSid);
    }
    else
    {
        pSid = NULL;
        cbSid = 0;
    }

    // Check the side-by-side catalog before checking the cache because the active activation context
    // must take precedent over any cached activation metadata.
    if (m_pCatalogSxS != NULL)
    {
        hr = m_pCatalogSxS->GetRetQueueInfo(pUserToken, wszFormatName, riid, (void **) &pRetQueueInfo, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            fValueFlags = CCACHE_F_SXS;

            goto addToCache;
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    if (s_pCacheRetQueueInfo != NULL)
    {
        hr = s_pCacheRetQueueInfo->GetElement(
            iHashValue,
            (BYTE *) wszFormatName,
            cbFormatName,
            pSid,
            cbSid,
            &fValueFlags,
            &pRetQueueInfo);
        if (hr == S_OK)
        {
            hr = pRetQueueInfo->QueryInterface(riid, ppv);

            pRetQueueInfo->Release();

            return(hr);
        }
    }

    if (m_pCatalogCLB != NULL)
    {
        hr = m_pCatalogCLB->GetRetQueueInfo(pUserToken, wszFormatName, riid, (void **) &pRetQueueInfo, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            fValueFlags = CCACHE_F_REGDB;

            goto addToCache;
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    if (m_pCatalogRegNative != NULL)
    {
        hr = m_pCatalogRegNative->GetRetQueueInfo(pUserToken, wszFormatName, riid, (void **) &pRetQueueInfo, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            fValueFlags = CCACHE_F_CLASSIC;

            goto addToCache;
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }


    if (m_pCatalogRegNonNative != NULL)
    {
        hr = m_pCatalogRegNonNative->GetRetQueueInfo(pUserToken, wszFormatName, riid, (void **) &pRetQueueInfo, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            fValueFlags = CCACHE_F_CLASSIC32;

            goto addToCache;
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    return(E_FAIL);

 addToCache:

    if (s_pCacheRetQueueInfo != NULL && fValueFlags & CCACHE_F_CACHEABLE)
    {
        hr = s_pCacheRetQueueInfo->AddElement(
            iHashValue,
            (BYTE *) wszFormatName,
            cbFormatName,
            pSid,
            cbSid,
            &fValueFlags,
            pRetQueueInfo,
            &pPrevious);

        if (hr == E_CACHE_DUPLICATE)
        {
            pRetQueueInfo->Release();

            hr = pPrevious->QueryInterface(riid, (void **) &pRetQueueInfo);

            pPrevious->Release();

            if (hr != S_OK)
            {
                return(hr);
            }
        }
    }

    *ppv = pRetQueueInfo;

    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComCatalog::GetApplicationInfoForExe
(
/* [in] */ IUserToken *pUserToken,
/* [string][in] */ WCHAR __RPC_FAR *pwszExeName,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
/* [in] */ void __RPC_FAR *pComCatalog
)
{
    HRESULT hr;

    *ppv = NULL;

    // Check the side-by-side catalog before any others (including a cache) because the active activation context
    // must take precedent over any cached activation metadata.
    if (m_pCatalogSxS != NULL)
    {
        hr = m_pCatalogSxS->GetApplicationInfoForExe(pUserToken, pwszExeName, riid, ppv, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            return(hr);
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    if (m_pCatalogCLB != NULL)
    {
        hr = m_pCatalogCLB->GetApplicationInfoForExe(pUserToken, pwszExeName, riid, ppv, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            return(hr);
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    if (m_pCatalogRegNative != NULL)
    {
        hr = m_pCatalogRegNative->GetApplicationInfoForExe(pUserToken, pwszExeName, riid, ppv, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            return(hr);
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    if (m_pCatalogRegNonNative != NULL)
    {
        hr = m_pCatalogRegNonNative->GetApplicationInfoForExe(pUserToken, pwszExeName, riid, ppv, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            return(hr);
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    return(E_FAIL);
}


HRESULT STDMETHODCALLTYPE CComCatalog::GetTypeLibrary
(
/* [in] */ IUserToken *pUserToken,
/* [in] */ REFGUID guidTypeLib,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
/* [in] */ void __RPC_FAR *pComCatalog
)
{
    HRESULT hr;

    *ppv = NULL;

    // Check the side-by-side catalog before any others (including a cache) because the active activation context
    // must take precedent over any cached activation metadata.
    if (m_pCatalogSxS != NULL)
    {
        hr = m_pCatalogSxS->GetTypeLibrary(pUserToken, guidTypeLib, riid, ppv, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            return(hr);
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    if (m_pCatalogCLB != NULL)
    {
        hr = m_pCatalogCLB->GetTypeLibrary(pUserToken, guidTypeLib, riid, ppv, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            return(hr);
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    if (m_pCatalogRegNative != NULL)
    {
        hr = m_pCatalogRegNative->GetTypeLibrary(pUserToken, guidTypeLib, riid, ppv, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            return(hr);
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    if (m_pCatalogRegNonNative != NULL)
    {
        hr = m_pCatalogRegNonNative->GetTypeLibrary(pUserToken, guidTypeLib, riid, ppv, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            return(hr);
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    return(E_FAIL);
}


HRESULT STDMETHODCALLTYPE CComCatalog::GetInterfaceInfo
(
/* [in] */ IUserToken *pUserToken,
/* [in] */ REFIID iidInterface,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
/* [in] */ void __RPC_FAR *pComCatalog
)
{
    HRESULT hr;

    *ppv = NULL;

    // Check the side-by-side catalog before any others (including a cache) because the active activation context
    // must take precedent over any cached activation metadata.
    if (m_pCatalogSxS != NULL)
    {
        hr = m_pCatalogSxS->GetInterfaceInfo(pUserToken, iidInterface, riid, ppv, (void **) this);
        if (hr == S_OK)
        {
            return(hr);
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    if (m_pCatalogCLB != NULL)
    {
        hr = m_pCatalogCLB->GetInterfaceInfo(pUserToken, iidInterface, riid, ppv, (void **) this);
        if (hr == S_OK)
        {
            return(hr);
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    if (m_pCatalogRegNative != NULL)
    {
        hr = m_pCatalogRegNative->GetInterfaceInfo(pUserToken, iidInterface, riid, ppv, (void **) this);
        if (hr == S_OK)
        {
            return(hr);
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    if (m_pCatalogRegNonNative != NULL)
    {
        hr = m_pCatalogRegNonNative->GetInterfaceInfo(pUserToken, iidInterface, riid, ppv, (void **) this);
        if (hr == S_OK)
        {
            return(hr);
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    return(E_FAIL);
}


HRESULT STDMETHODCALLTYPE CComCatalog::GetClassInfoFromProgId
(
/* [in] */ IUserToken *pUserToken,
/* [in] */ WCHAR __RPC_FAR *wszProgID,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
/* [in] */ void __RPC_FAR *pComCatalog
)
{
    HRESULT hr;
    IUnknown *pClassInfo = NULL;
    IUnknown *pPrevious = NULL;
    IUnknown *pNoClassInfo = NULL;
    USHORT fValueFlags;


    *ppv = NULL;

    if (wszProgID == NULL)
        return E_INVALIDARG;

    // Check the side-by-side catalog before any others (including a cache) because the active activation context
    // must take precedent over any cached activation metadata.
    if (m_pCatalogSxS != NULL)
    {
        hr = m_pCatalogSxS->GetClassInfoFromProgId(pUserToken, wszProgID, riid, ppv, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            return(hr);
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    // I got this hash from COM+'s map_t.h.
    DWORD dwHash = 0x01234567;
    WCHAR *pwc = wszProgID;
    while (*pwc) dwHash = (dwHash << 5) + (dwHash >> 27) + *pwc++;
    USHORT cbProgID = (USHORT)((pwc - wszProgID + 1) * sizeof(WCHAR));

    if ( m_CLBCATQState != CLBCATQ_RESOLVED)
    {
        TryToLoadCLB();
    }

	if (m_CombaseInCLBState != CLBCATQ_RESOLVED)
	{
		TryToLoadCombaseInCLB();
	}

    if (s_pCacheProgID != NULL)
    {
        hr = s_pCacheClassInfo->GetElement(dwHash,
                                           (BYTE *)wszProgID,
                                           cbProgID,
                                           &fValueFlags,
                                           &pClassInfo);
        if (hr == S_OK)
        {
            if (pClassInfo != NULL)
            {
                hr = pClassInfo->QueryInterface(riid, ppv);
                
                pClassInfo->Release();
                
                if ((hr == S_OK) && (fValueFlags & CCACHE_F_NOTREGISTERED))
                {
                    hr = S_FALSE;
                }
            }
            else
            {
                hr = REGDB_E_CLASSNOTREG;
            }

            return(hr);
        }
    }

    if (m_pCatalogCLB != NULL)
    {
        hr = m_pCatalogCLB->GetClassInfoFromProgId(pUserToken, wszProgID, riid, (void **)&pClassInfo, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            fValueFlags = CCACHE_F_REGDB;            
            goto addToCache;
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

	if (m_pCatalogCOMBaseInCLB != NULL)
	{
		hr = m_pCatalogCOMBaseInCLB->GetClassInfoFromProgId(pUserToken, wszProgID, riid, (void **)&pClassInfo, (IComCatalogInternal *) this);
		if (hr == S_OK)
		{
            fValueFlags = CCACHE_F_REGDB;
            goto addToCache;
		}
		else if (hr == E_NOINTERFACE)
		{
			return(hr);
		}
	}


    if (m_pCatalogRegNative != NULL)
    {
        hr = m_pCatalogRegNative->GetClassInfoFromProgId(pUserToken, wszProgID, riid, (void **)&pClassInfo, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            // Or with CCACHE_F_ALWAYSCHECK to force a re-read of the
            // registry when things are cached and the registry changes.
            fValueFlags = CCACHE_F_CLASSIC | CCACHE_F_ALWAYSCHECK;
            goto addToCache;
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

/****
 * Just skip it... I don't think I need to worry about bitness issues here.
 * If I do, I also need to modify the implementation of 
 * CComRegCatalog::GetClassInfoFromProgId.
 *
 *  if (m_pCatalogRegNonNative != NULL)
 *  {
 *      hr = m_pCatalogRegNonNative->GetClassInfoFromProgId(pUserToken, wszProgID, riid, (void **)&pClassInfo, (IComCatalogInternal *) this);
 *      if (hr == S_OK)
 *      {
 *          fValueFlags = CCACHE_F_CLASSIC32;
 *          goto addToCache;
 *      }
 *      else if (hr == E_NOINTERFACE)
 *      {
 *          return(hr);
 *      }
 *  }
 */

    pNoClassInfo = (IUnknown *)(IComClassInfo *) new CComNoClassInfo(wszProgID);
    if (pNoClassInfo == NULL)
    {
        return(E_OUTOFMEMORY);
    }

    hr = pNoClassInfo->QueryInterface(riid, (void **) &pClassInfo);

    if (hr != S_OK)
    {
		delete pClassInfo;
        return(hr);
    }

    fValueFlags = CCACHE_F_NOTREGISTERED;

 addToCache:

    if (s_pCacheClassInfo != NULL && fValueFlags & CCACHE_F_CACHEABLE)
    {
        hr = s_pCacheClassInfo->AddElement(dwHash,
                                           (BYTE *)wszProgID,
                                           cbProgID,
                                           &fValueFlags,
                                           pClassInfo,
                                           &pPrevious);
        if (hr == E_CACHE_DUPLICATE)
        {
            if (pClassInfo != NULL)
            {
                pClassInfo->Release();
            }

            if (pPrevious != NULL)
            {
                hr = pPrevious->QueryInterface(riid, (void **)&pClassInfo);
                pPrevious->Release();
            }
            else
            {
                hr = REGDB_E_CLASSNOTREG;
            }

            if (hr != S_OK)
                return(hr);
        }
    }

    *ppv = pClassInfo;

    if (fValueFlags & CCACHE_F_NOTREGISTERED)
    {
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }

    return hr;
}


/* IComCatalog2Internal */

HRESULT STDMETHODCALLTYPE CComCatalog::GetClassInfoByPartition
(
/* [in] */ IUserToken *pUserToken,
/* [in] */ REFGUID guidConfiguredClsid,
/* [in] */ REFGUID guidPartitionId,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
/* [in] */ void __RPC_FAR *pComCatalog
)
{
	HRESULT hr;
	IUnknown *pClassInfo = NULL;
	IUnknown *pPrevious = NULL;
	USHORT fValueFlags;
	IUnknown *pNoClassInfo = NULL;
	BYTE *pSid = NULL;
	USHORT cbSid;

	*ppv = NULL;

	if ( m_CLBCATQState != CLBCATQ_RESOLVED)
	{
		TryToLoadCLB();
	}

	if (m_CombaseInCLBState != CLBCATQ_RESOLVED)
	{
		TryToLoadCombaseInCLB();
	}

	if (pUserToken != NULL)
	{
		pUserToken->GetUserSid(&pSid, &cbSid);
	}
	else
	{
		pSid = NULL;
		cbSid = 0;
	}

	CLSID key[2];
	key[0] = guidConfiguredClsid;
	key[1] = guidPartitionId;

	if (s_pCacheClassInfo != NULL)
	{
		hr = s_pCacheClassInfo->GetElement(
										  guidConfiguredClsid.Data1,
										  (BYTE *) key,
										  sizeof(key),
										  pSid,
										  cbSid,
										  &fValueFlags,
										  &pClassInfo);
		if (hr == S_OK)
		{
			if (pClassInfo != NULL)
			{
				hr = pClassInfo->QueryInterface(riid, ppv);

				pClassInfo->Release();

				if ((hr == S_OK) && (fValueFlags & CCACHE_F_NOTREGISTERED))
				{
					hr = S_FALSE;
				}
			}
			else
			{
				hr = REGDB_E_CLASSNOTREG;
			}

			return(hr);
		}

	}

	if (m_pCatalogCLB != NULL)
	{
		IComCatalog2Internal *pCatalogCLB2 = NULL;
		hr = m_pCatalogCLB->QueryInterface(IID_IComCatalog2Internal, (void**) &pCatalogCLB2);

		if(SUCCEEDED(hr))
		{
			hr = pCatalogCLB2->GetClassInfoByPartition(pUserToken, guidConfiguredClsid, guidPartitionId, riid, (void **) &pClassInfo, (IComCatalogInternal *) this);
			pCatalogCLB2->Release();

			if (hr == S_OK)
			{
				fValueFlags = CCACHE_F_REGDB;

				goto addToCache;
			}
			else if (hr != REGDB_E_CLASSNOTREG)
			{
				return(hr);
			}
		}
		else
		{
			hr = REGDB_E_CLASSNOTREG;
		}
	}

	pNoClassInfo = (IUnknown *)(IComClassInfo *) new CComNoClassInfo(guidConfiguredClsid);
	if (pNoClassInfo == NULL)
	{
		return(E_OUTOFMEMORY);
	}

	hr = pNoClassInfo->QueryInterface(riid, (void **) &pClassInfo);
	if (hr != S_OK)
	{
		delete pClassInfo;
		return(hr);
	}
  
	fValueFlags = CCACHE_F_NOTREGISTERED;

	addToCache:

	if (s_pCacheClassInfo != NULL && fValueFlags & CCACHE_F_CACHEABLE)
	{
		hr = s_pCacheClassInfo->AddElement(
										  guidConfiguredClsid.Data1,
										  (BYTE *) key,
										  sizeof(key),
										  pSid,
										  cbSid,
										  &fValueFlags,
										  pClassInfo,
										  &pPrevious);

		if (hr == E_CACHE_DUPLICATE)
		{
			if (pClassInfo != NULL)
			{
				pClassInfo->Release();
			}

			if (pPrevious != NULL)
			{
				hr = pPrevious->QueryInterface(riid, (void **) &pClassInfo);

				pPrevious->Release();
			}
			else
			{
				hr = REGDB_E_CLASSNOTREG;
			}

			if (hr != S_OK)
			{
				return(hr);
			}
		}
	}

	*ppv = pClassInfo;

	if (fValueFlags & CCACHE_F_NOTREGISTERED)
	{
		hr = S_FALSE;
	}
	else
	{
		hr = S_OK;
	}

	return(hr);
}

HRESULT STDMETHODCALLTYPE CComCatalog::GetClassInfoByApplication
(
/* [in] */ IUserToken *pUserToken,
/* [in] */ REFGUID guidConfiguredClsid,
/* [in] */ REFGUID guidPartitionId,
/* [in] */ REFGUID guidApplId,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
/* [in] */ void __RPC_FAR *pComCatalog
)
{
	HRESULT hr;
	IUnknown *pClassInfo = NULL;
	IUnknown *pPrevious = NULL;
	USHORT fValueFlags;
	IUnknown *pNoClassInfo = NULL;
	BYTE *pSid = NULL;
	USHORT cbSid;

	*ppv = NULL;

	if ( m_CLBCATQState != CLBCATQ_RESOLVED)
	{
		TryToLoadCLB();
	}

	if (m_CombaseInCLBState != CLBCATQ_RESOLVED)
	{
		TryToLoadCombaseInCLB();
	}

	if (pUserToken != NULL)
	{
		pUserToken->GetUserSid(&pSid, &cbSid);
	}
	else
	{
		pSid = NULL;
		cbSid = 0;
	}

	CLSID key[3];
	key[0] = guidConfiguredClsid;
	key[1] = guidPartitionId;
	key[2] = guidApplId;

	if (s_pCacheClassInfo != NULL)
	{
		hr = s_pCacheClassInfo->GetElement(
										  guidConfiguredClsid.Data1,
										  (BYTE *) key,
										  sizeof(key),
										  pSid,
										  cbSid,
										  &fValueFlags,
										  &pClassInfo);
		if (hr == S_OK)
		{
			if (pClassInfo != NULL)
			{
				hr = pClassInfo->QueryInterface(riid, ppv);

				pClassInfo->Release();

				if ((hr == S_OK) && (fValueFlags & CCACHE_F_NOTREGISTERED))
				{
					hr = S_FALSE;
				}
			}
			else
			{
				hr = REGDB_E_CLASSNOTREG;
			}

			return(hr);
		}

	}

	if (m_pCatalogCLB != NULL)
	{
		IComCatalog2Internal *pCatalogCLB2 = NULL;
		hr = m_pCatalogCLB->QueryInterface(IID_IComCatalog2Internal, (void**) &pCatalogCLB2);

		if(SUCCEEDED(hr))
		{
			hr = pCatalogCLB2->GetClassInfoByApplication(pUserToken, guidConfiguredClsid, guidPartitionId, guidApplId, riid, (void **) &pClassInfo, (IComCatalogInternal *) this);
			pCatalogCLB2->Release();

			if (hr == S_OK)
			{
				fValueFlags = CCACHE_F_REGDB;

				goto addToCache;
			}
			else if (hr != REGDB_E_CLASSNOTREG)
			{
				return(hr);
			}
		}
		else
		{
			hr = REGDB_E_CLASSNOTREG;
		}
	}

	pNoClassInfo = (IUnknown *)(IComClassInfo *) new CComNoClassInfo(guidConfiguredClsid);
	if (pNoClassInfo == NULL)
	{
		return(E_OUTOFMEMORY);
	}

	hr = pNoClassInfo->QueryInterface(riid, (void **) &pClassInfo);
	if (hr != S_OK)
	{
		delete pClassInfo;
		return(hr);
	}
  
	fValueFlags = CCACHE_F_NOTREGISTERED;

	addToCache:

	if (s_pCacheClassInfo != NULL && fValueFlags & CCACHE_F_CACHEABLE)
	{
		hr = s_pCacheClassInfo->AddElement(
										  guidConfiguredClsid.Data1,
										  (BYTE *) key,
										  sizeof(key),
										  pSid,
										  cbSid,
										  &fValueFlags,
										  pClassInfo,
										  &pPrevious);

		if (hr == E_CACHE_DUPLICATE)
		{
			if (pClassInfo != NULL)
			{
				pClassInfo->Release();
			}

			if (pPrevious != NULL)
			{
				hr = pPrevious->QueryInterface(riid, (void **) &pClassInfo);

				pPrevious->Release();
			}
			else
			{
				hr = REGDB_E_CLASSNOTREG;
			}

			if (hr != S_OK)
			{
				return(hr);
			}
		}
	}

	*ppv = pClassInfo;

	if (fValueFlags & CCACHE_F_NOTREGISTERED)
	{
		hr = S_FALSE;
	}
	else
	{
		hr = S_OK;
	}

	return(hr);
}


// Allows a way for somebody to get a reference on our legacy pure-registry-based
// catalog providers.
HRESULT STDMETHODCALLTYPE CComCatalog::GetNativeRegistryCatalog(REFIID riid, void** ppv)
{
	return m_pCatalogRegNative ? m_pCatalogRegNative->QueryInterface(riid, ppv) : E_OUTOFMEMORY;
}

HRESULT STDMETHODCALLTYPE CComCatalog::GetNonNativeRegistryCatalog(REFIID riid, void** ppv)
{
	return m_pCatalogRegNonNative ? m_pCatalogRegNonNative->QueryInterface(riid, ppv) : E_OUTOFMEMORY;
}

/* private methods */


HRESULT STDMETHODCALLTYPE CComCatalog::GetClassInfoInternal
(
/* [in] */ DWORD flags,
/* [in] */ IUserToken *pUserToken,
/* [in] */ REFGUID guidConfiguredClsid,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
/* [in] */ void __RPC_FAR *pComCatalog
)
{
    HRESULT hr;
    IUnknown *pClassInfo = NULL;
    IUnknown *pPrevious = NULL;
    IComClassInfo *pICCI = NULL;
    USHORT fValueFlags;
    IUnknown *pNoClassInfo = NULL;
    BYTE *pSid = NULL;
    USHORT cbSid;
    DWORD clsctxFilter;
    DWORD clsctxPrevious;

    // The keys for the cache.   
    BYTE   *apKey[3];
    USHORT  acbKey[3];


	CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal flags=%x\n", flags));
	CatalogDebugOut((DEB_CLASSINFO, 
					 "CComCatalog::GetClassInfoInternal CLSID=%x-%x-%x-%x\n", 
					 ((DWORD *)&guidConfiguredClsid)[0],
					 ((DWORD *)&guidConfiguredClsid)[1],
					 ((DWORD *)&guidConfiguredClsid)[2],
					 ((DWORD *)&guidConfiguredClsid)[3]));

    *ppv = NULL;

    if ( m_CLBCATQState != CLBCATQ_RESOLVED)
    {
        TryToLoadCLB();
    }

	if (m_CombaseInCLBState != CLBCATQ_RESOLVED)
	{
		TryToLoadCombaseInCLB();
	}

    if (pUserToken != NULL)
    {
        pUserToken->GetUserSid(&pSid, &cbSid);
    }
    else
    {
        pSid = NULL;
        cbSid = 0;
    }

    // Check the side-by-side catalog before any others (including a cache) because the active 
    // activation context  must take precedent over any cached activation metadata.
	if (m_pCatalogSxS)
	{
		CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Look in COM SxS Catalog...\n"));	
		hr = m_pCatalogSxS->GetClassInfo(pUserToken, guidConfiguredClsid, riid, (void **) &pClassInfo, (IComCatalogInternal *) this);
		if (hr == S_OK)
		{
			CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Found in COM SxS Catalog!\n"));
			fValueFlags = CCACHE_F_SXS;

            //If the caller specified, Make sure that this classinfo can 
            //actually be used.
            if (flags & (~CAT_REG_MASK))
            {
				CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Validate vs. flags...\n"));
                clsctxFilter = 0;

                hr = pClassInfo->QueryInterface(IID_IComClassInfo, (void **)&pICCI);
                if (SUCCEEDED(hr))
                {
                    hr = pICCI->GetClassContext((CLSCTX)(flags & ~CAT_REG_MASK),
                                                (CLSCTX *)&clsctxFilter);
					pICCI->Release();
                }
            } 
            else 
            {
                clsctxFilter = 1;
            }

            if (SUCCEEDED(hr) && clsctxFilter)
			{
				CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Acceptable!\n"));
                goto addToCache; // REVIEW: Do you really need to do this?
			}
		}
		else if (hr != REGDB_E_CLASSNOTREG)
		{
			return(hr);
		}
	}

    if (pClassInfo)
    {
        pClassInfo->Release();
        pClassInfo = NULL;
    }

    // Fill in the keys for cache lookup.
    apKey[0]  = (BYTE *)&guidConfiguredClsid; // Key 1: CLSID
    acbKey[0] = sizeof(CLSID);
    apKey[1]  = pSid;                         // Key 2: SID
    acbKey[1] = cbSid;
    apKey[2]  = (BYTE *)&flags;               // Key 3: Validation flags
    acbKey[2] = sizeof(DWORD);
    
    if (s_pCacheClassInfo != NULL)
    {
        // Use the multi-key version lookup
		CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Look in cache\n"));

        hr = s_pCacheClassInfo->GetElement(guidConfiguredClsid.Data1,
                                           3,
                                           apKey,
                                           acbKey,
                                           &fValueFlags,
                                           &pClassInfo);
        if (hr == S_OK)
        {
            // There is no need to validate the response from the cache as
            // we would other pieces-- if the data got into the cache with
            // the matching flags, then it had already passed all the 
            // reqirements.
			CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Found in cache!\n"));
            if (pClassInfo != NULL)
            {
                hr = pClassInfo->QueryInterface(riid, ppv);

                pClassInfo->Release();

                if ((hr == S_OK) && (fValueFlags & CCACHE_F_NOTREGISTERED))
                {
                    hr = S_FALSE;
                }
            }
            else
            {
                hr = REGDB_E_CLASSNOTREG;
            }

            return(hr);
        }

    }

    if (pClassInfo)
    {
        pClassInfo->Release();
        pClassInfo = NULL;
    }

    if (m_pCatalogCLB != NULL)
    {
		CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Look in REGDB\n"));
        hr = m_pCatalogCLB->GetClassInfo(pUserToken, guidConfiguredClsid, riid, (void **) &pClassInfo, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
			CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Found in REGDB!\n"));
            fValueFlags = CCACHE_F_REGDB;

            //If the caller specified, Make sure that this classinfo can 
            //actually be used.
            if (flags & (~CAT_REG_MASK))
            {
				CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Validate vs. flags...\n"));
                clsctxFilter = 0;

                hr = pClassInfo->QueryInterface(IID_IComClassInfo, (void **)&pICCI);
                if (SUCCEEDED(hr))
                {
                    hr = pICCI->GetClassContext((CLSCTX)(flags & ~CAT_REG_MASK),
                                                (CLSCTX *)&clsctxFilter);
					pICCI->Release();
                }
            } 
            else 
            {
                clsctxFilter = 1;
            }

            if (SUCCEEDED(hr) && clsctxFilter)
			{
				CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Acceptable!\n"));
                goto addToCache;
			}
        }
        else if (hr != REGDB_E_CLASSNOTREG)
        {
            return(hr);
        }
    }

    if (pClassInfo)
    {
        pClassInfo->Release();
        pClassInfo = NULL;
    }

	if (m_pCatalogCOMBaseInCLB)
	{
		CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Look in COM Base CLB...\n"));	
		hr = m_pCatalogCOMBaseInCLB->GetClassInfo(pUserToken, guidConfiguredClsid, riid, (void **) &pClassInfo, (IComCatalogInternal *) this);
		if (hr == S_OK)
		{
			CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Found in COM Base CLB!\n"));
			fValueFlags = CCACHE_F_REGDB;

            //If the caller specified, Make sure that this classinfo can 
            //actually be used.
            if (flags & (~CAT_REG_MASK))
            {
				CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Validate vs. flags...\n"));
                clsctxFilter = 0;

                hr = pClassInfo->QueryInterface(IID_IComClassInfo, (void **)&pICCI);
                if (SUCCEEDED(hr))
                {
                    hr = pICCI->GetClassContext((CLSCTX)(flags & ~CAT_REG_MASK),
                                                (CLSCTX *)&clsctxFilter);
					pICCI->Release();
                }
            } 
            else 
            {
                clsctxFilter = 1;
            }

            if (SUCCEEDED(hr) && clsctxFilter)
			{
				CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Acceptable!\n"));
                goto addToCache;
			}
		}
		else if (hr != REGDB_E_CLASSNOTREG)
		{
			return(hr);
		}
	}

    if (pClassInfo)
    {
        pClassInfo->Release();
        pClassInfo = NULL;
    }


    //
    // The registry catalog providers.
    //
    // Since the introduction of reflection in the 64bit world, things are not so pretty.
    // We need to make sure that we are always on the correct side of the registry.  Instead
    // of trying to invent some generic mechanism for deciding among all of the different
    // providers, though, I'm just going to hard-code the logic for the registry provider
    // here.  
    //
    // 1. If the CLSID provided by the 64bit registry supports CLSCTX_LOCAL_SERVER, choose
    //    it.
    // 2. If the CLSID provided by the 32bit registry supports CLSCTX_LOCAL_SERVER, choose
    //    IT.
    // 3. Otherwise, choose the 64bit registry provider.
    //
    // This is only in a 64bit SCM.
    //
    if ((m_pCatalogRegNative != NULL) && !(flags & CAT_REG32_ONLY))
    {
		CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Look in registry...\n"));
        hr = m_pCatalogRegNative->GetClassInfo(pUserToken, guidConfiguredClsid, riid, (void **) &pClassInfo, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
			CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Found in registry!\n"));
            fValueFlags = CCACHE_F_CLASSIC;

            //If the caller specified, Make sure that this classinfo can 
            //actually be used.
            if (flags & (~CAT_REG_MASK))
            {
				CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Validate vs. flags...\n"));
                clsctxFilter = 0;

                hr = pClassInfo->QueryInterface(IID_IComClassInfo, (void **)&pICCI);
                if (SUCCEEDED(hr))
                {
                    hr = pICCI->GetClassContext((CLSCTX)(flags & ~CAT_REG_MASK),
                                                (CLSCTX *)&clsctxFilter);
					pICCI->Release();
                }

                // SPECIAL REGISTRY CATALOG LOGIC
                if (SUCCEEDED(hr) && clsctxFilter)
                {
                    // If we asked for LOCAL_SERVER, make sure we get the right one here.
                    if ((clsctxFilter & CLSCTX_LOCAL_SERVER) || !(flags & CLSCTX_LOCAL_SERVER))
                    {
                        CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Acceptable!\n"));
                        if (pPrevious)
                        {
                            pPrevious->Release();
                            pPrevious = NULL;
                        }
                        goto addToCache;
                    }
                    else
                    {
                        CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Not quite acceptable, but all right...\n"));
                        CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: ...so we'll check the next provider.\n"));

                        // Hold on to this result so we can use it in the 32bit registry (next)
                        clsctxPrevious = clsctxFilter;
                        pPrevious = pClassInfo;
                        pPrevious->AddRef();
                    }
                }
            }
            else 
            {
				CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Acceptable (by default)!\n"));
                goto addToCache;
            }
        }
        else if (hr != REGDB_E_CLASSNOTREG)
        {
            return(hr);
        }
    }

    if (pClassInfo)
    {
        pClassInfo->Release();
        pClassInfo = NULL;
    }

    if ((m_pCatalogRegNonNative != NULL) && !(flags & CAT_REG64_ONLY))
    {
		CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Look in 32bit registry...\n"));
        hr = m_pCatalogRegNonNative->GetClassInfo(pUserToken, guidConfiguredClsid, riid, (void **) &pClassInfo, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
			CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Found in 32bit registry!\n"));
            fValueFlags = CCACHE_F_CLASSIC32;

            //If the caller wants, make sure that this classinfo can 
            //actually be used.
            if (flags & (~CAT_REG_MASK))
            {
				CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Validate vs. flags...\n"));
                clsctxFilter = 0;

                hr = pClassInfo->QueryInterface(IID_IComClassInfo, (void **)&pICCI);
                if (SUCCEEDED(hr))
                {
                    hr = pICCI->GetClassContext((CLSCTX)(flags & ~CAT_REG_MASK),
                                                (CLSCTX *)&clsctxFilter);
					pICCI->Release();
                }

                // SPECIAL REGISTRY CATALOG LOGIC
                if (SUCCEEDED(hr) && clsctxFilter)
                {
                    // If we asked for LOCAL_SERVER, make sure we get the right one here.
                    if ((clsctxFilter & CLSCTX_LOCAL_SERVER) || !(flags & CLSCTX_LOCAL_SERVER))
                    {
                        CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Acceptable!\n"));
                        if (pPrevious)
                        {
                            pPrevious->Release();
                            pPrevious = NULL;
                        }
                        goto addToCache;
                    }
                    else
                    {
                        CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Not quite acceptable, but all right...\n"));
                        if (pPrevious)
                        {
                            // Favor 64bit in this situation.
                            CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: ...so we favor the previous result.\n"));
                            pClassInfo->Release();
                            pClassInfo = pPrevious;
                            pPrevious = NULL;
                        }
                        else
                        {
                            CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: ...so we take it anyway.\n"));
                        }

                        // OBVIOUS SPECIAL CASE:
                        // go to addToCache here because it's a success at the end of the line.
                        goto addToCache;
                    }
                }
            }
            else 
            {
                CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Acceptable (by default)!\n"));
                goto addToCache;
            }
        }
        else if (hr != REGDB_E_CLASSNOTREG)
        {
            return(hr);
        }
    }

    if (pPrevious)
    {
        CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: ...nothing else was better.  Take it.\n"));
        pClassInfo = pPrevious;
        pPrevious = NULL;
        goto addToCache;
    }

	CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Not found...\n"));
    pNoClassInfo = (IUnknown *)(IComClassInfo *) new CComNoClassInfo(guidConfiguredClsid);
    if (pNoClassInfo == NULL)
    {
        return(E_OUTOFMEMORY);
    }

    hr = pNoClassInfo->QueryInterface(riid, (void **) &pClassInfo);

    if (hr != S_OK)
    {
		delete pClassInfo;
        return(hr);
    }

    fValueFlags = CCACHE_F_NOTREGISTERED;

 addToCache:

    if (s_pCacheClassInfo != NULL && fValueFlags & CCACHE_F_CACHEABLE)
    {
		CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal: Add to cache...\n"));
        // Use the multi-key version
        hr = s_pCacheClassInfo->AddElement(
            guidConfiguredClsid.Data1,
            3,
            apKey,
            acbKey,
            &fValueFlags,
            pClassInfo,
            &pPrevious);

        if (hr == E_CACHE_DUPLICATE)
        {
            if (pClassInfo != NULL)
            {
                pClassInfo->Release();
            }

            if (pPrevious != NULL)
            {
                hr = pPrevious->QueryInterface(riid, (void **) &pClassInfo);

                pPrevious->Release();
            }
            else
            {
                hr = REGDB_E_CLASSNOTREG;
            }

            if (hr != S_OK)
            {
                return(hr);
            }
        }
    }

    *ppv = pClassInfo;

    if (fValueFlags & CCACHE_F_NOTREGISTERED)
    {
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }

	CatalogDebugOut((DEB_CLASSINFO, "CComCatalog::GetClassInfoInternal returning 0x%08x\n", hr));
    return(hr);
}



HRESULT STDMETHODCALLTYPE CComCatalog::GetProcessInfoInternal
(
/* [in] */ DWORD flags,
/* [in] */ IUserToken *pUserToken,
/* [in] */ REFGUID guidProcess,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
/* [in] */ void __RPC_FAR *pComCatalog
)
{
    HRESULT hr;
    IUnknown *pProcessInfo = NULL;
    IUnknown *pPrevious = NULL;
    USHORT fValueFlags;
    BYTE *pSid = NULL;
    USHORT cbSid;

    // The keys for the cache.
    BYTE   *apKey[3];
    USHORT  acbKey[3];

    *ppv = NULL;

    if ( m_CLBCATQState != CLBCATQ_RESOLVED)
    {
        TryToLoadCLB();
    }

	if (m_CombaseInCLBState != CLBCATQ_RESOLVED)
	{
		TryToLoadCombaseInCLB();
	}

    if (pUserToken != NULL)
    {
        pUserToken->GetUserSid(&pSid, &cbSid);
    }
    else
    {
        pSid = NULL;
        cbSid = 0;
    }

    // Check the side-by-side catalog before any others (including a cache) because the active activation context
    // must take precedent over any cached activation metadata.
    if (m_pCatalogSxS != NULL)
    {
        hr = m_pCatalogSxS->GetProcessInfo(pUserToken, guidProcess, riid, (void **) &pProcessInfo, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            fValueFlags = CCACHE_F_SXS;

            goto addToCache;
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    // Fill in the keys for cache lookup.
    apKey[0]  = (BYTE *)&guidProcess;  // Key 1: Process GUID
    acbKey[0] = sizeof(CLSID);
    apKey[1]  = pSid;                  // Key 2: SID
    acbKey[1] = cbSid;
    apKey[2]  = (BYTE *)&flags;        // Key 3: Validation flags
    acbKey[2] = sizeof(DWORD);

    if (s_pCacheProcessInfo != NULL)
    {
        hr = s_pCacheProcessInfo->GetElement(
            guidProcess.Data1,
            3,
            apKey,
            acbKey,
            &fValueFlags,
            &pProcessInfo);
        if (hr == S_OK)
        {
            hr = pProcessInfo->QueryInterface(riid, ppv);

            pProcessInfo->Release();

            return(hr);
        }
    }

    if (m_pCatalogCLB != NULL)
    {
        hr = m_pCatalogCLB->GetProcessInfo(pUserToken, guidProcess, riid, (void **) &pProcessInfo, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            fValueFlags = CCACHE_F_REGDB;

            goto addToCache;
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }


    // If the SCM requests it, we can ignore this catalog.
    if ((m_pCatalogRegNative != NULL) && !(flags & CAT_REG32_ONLY))
    {
        hr = m_pCatalogRegNative->GetProcessInfo(pUserToken, guidProcess, riid, (void **) &pProcessInfo, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            fValueFlags = CCACHE_F_CLASSIC;

            goto addToCache;
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    // The SCM can also request to ignore this catalog.
    if ((m_pCatalogRegNonNative != NULL) && !(flags & CAT_REG64_ONLY))
    {
        hr = m_pCatalogRegNonNative->GetProcessInfo(pUserToken, guidProcess, riid, (void **) &pProcessInfo, (IComCatalogInternal *) this);
        if (hr == S_OK)
        {
            fValueFlags = CCACHE_F_CLASSIC32;

            goto addToCache;
        }
        else if (hr == E_NOINTERFACE)
        {
            return(hr);
        }
    }

    return(E_FAIL);

 addToCache:

    if (s_pCacheProcessInfo != NULL && fValueFlags & CCACHE_F_CACHEABLE)
    {
        hr = s_pCacheProcessInfo->AddElement(
            guidProcess.Data1,
            (BYTE *) &guidProcess,
            sizeof(GUID),
            pSid,
            cbSid,
            &fValueFlags,
            pProcessInfo,
            &pPrevious);

        if (hr == E_CACHE_DUPLICATE)
        {
            pProcessInfo->Release();

            hr = pPrevious->QueryInterface(riid, (void **) &pProcessInfo);

            pPrevious->Release();

            if (hr != S_OK)
            {
                return(hr);
            }
        }
    }

    *ppv = pProcessInfo;

    return(S_OK);
}


HRESULT CComCatalog::TryToLoadCLB(void)
{

    if ( !m_bTriedToLoadCLBAtLeastOnce || ((GetTickCount() - m_dwLastCLBTickCount) > MIN_CLB_LOAD_TICKS) )
    {
        g_CatalogLock.AcquireWriterLock();

        m_dwLastCLBTickCount = GetTickCount();
        switch ( m_CLBCATQState )
        {

            //  This state should only occur during setup,
            //    or the first time we're loading....
        case CLBCATQ_LOCKED:
        {
			HKEY hCom3Key = NULL;
			LONG lStatus = RegOpenKeyExW ( 
				HKEY_LOCAL_MACHINE,
				g_wszCom3,
				0,
				KEY_READ,
				&hCom3Key 
			);

			if (lStatus == ERROR_SUCCESS)
            {
				DWORD dwData = 0, dwType = REG_DWORD, dwDataSize = sizeof (dwData);
				
				lStatus = RegQueryValueExW ( 
					hCom3Key,
					g_wszCom3ActivationValue,
					0,
					&dwType,
					(BYTE*) &dwData,
					&dwDataSize 
				);


				if (lStatus == ERROR_SUCCESS && dwData != 0)
                {
                    m_CLBCATQState = CLBCATQ_UNLOCKED;
                }

				RegCloseKey (hCom3Key);
            }
        }

        //  Fall through here, for startup
        //  Because we may fall through, check for UNLOCKED state
        case CLBCATQ_UNLOCKED:
            if ( m_CLBCATQState == CLBCATQ_UNLOCKED )
            {
                HINSTANCE hInst;
                FN_GetCatalogObject *pfnGetCatalogObject = NULL;
                LockCookie lockCookie;

				//
				// This code may be called with the loader lock already held.
				// Release the lock to prevent deadlocks.
				//

                g_CatalogLock.ReleaseLock(&lockCookie);

                hInst = LoadLibraryA(g_szCLBCATQDLL);
                if ( hInst != NULL )
                {
                    pfnGetCatalogObject = (FN_GetCatalogObject *) GetProcAddress(hInst, "GetCatalogObject");
                }

                g_CatalogLock.RestoreLock(&lockCookie);

                if ((m_CLBCATQState != CLBCATQ_UNLOCKED) && hInst)
                {
                    //
                    // someone beat us, release the library
                    //
                    g_CatalogLock.ReleaseLock(&lockCookie);
                    FreeLibrary(hInst);
                    g_CatalogLock.RestoreLock(&lockCookie);
                }
                else
                {
                    if ( pfnGetCatalogObject != NULL )
                    {
                        HRESULT hr = pfnGetCatalogObject(IID_IComCatalogInternal, (void **) &m_pCatalogCLB);
                        if ( SUCCEEDED(hr) )
                        {
                            // Set SCM location
                            IComCatalogLocation* pCatLocation = NULL;

                            hr = m_pCatalogCLB->QueryInterface (IID_IComCatalogLocation, (void **) &pCatLocation);
                            if (SUCCEEDED (hr) && pCatLocation != NULL)
                            {
                                // Best effort
                                pCatLocation->SetCatalogLocation (g_bInSCM);
                                pCatLocation->Release();
                            }

                            FlushCache();
                        }
                        else
                        {
                            m_pCatalogCLB = NULL;
                        }
                    }

                    if (((pfnGetCatalogObject == NULL) || (m_pCatalogCLB == NULL)) &&
                        (hInst != NULL))
                    {
                        //
                        // something went wrong, release the library
                        //
                        g_CatalogLock.ReleaseLock(&lockCookie);
                        FreeLibrary(hInst);
                        g_CatalogLock.RestoreLock(&lockCookie);
                    }

                    m_CLBCATQState = CLBCATQ_RESOLVED;
                }
            }
            break;

        case CLBCATQ_RESOLVED:
        default:
            break;
        }

        g_CatalogLock.ReleaseWriterLock();
    }
	
    m_bTriedToLoadCLBAtLeastOnce = TRUE;

    return(S_OK);
}

//
// this is basically a parallel implementation of TryToLoadCLB, except that it uses a
// different entry point into clbcatq.dll.    Doing it this makes us flexible about running
// with either the COM+ 1.0 or 1.x versions of clbcatq.dll (if it's not there we just keep
// going without hiccups).
//
HRESULT CComCatalog::TryToLoadCombaseInCLB(void)
{
	HRESULT hr;

	if ( !m_bTriedToLoadComBaseCLBAtLeastOnce || ((GetTickCount() - m_dwLastCombaseInCLBTickCount) > MIN_CLB_LOAD_TICKS) )
	{
		g_CatalogLock.AcquireWriterLock();

		m_dwLastCombaseInCLBTickCount= GetTickCount();
		switch ( m_CombaseInCLBState )
		{

		//  This state should only occur during setup,
		//    or the first time we're loading....
		case CLBCATQ_LOCKED:
			{

                HKEY hCom3Key = NULL;
				LONG lStatus = RegOpenKeyExW (
				    HKEY_LOCAL_MACHINE,
				    g_wszCom3,
				    0,
				    KEY_READ,
				    &hCom3Key
				    );

                if (lStatus == ERROR_SUCCESS)
		        {
                    DWORD dwData = 0, dwType = REG_DWORD, dwDataSize = sizeof (dwData);
                    
		            lStatus = RegQueryValueExW (
		                hCom3Key,
		                g_wszCom3ActivationValue,
		                0,
		                &dwType,
		                (BYTE*) &dwData,
		                &dwDataSize
		                );

		            if (lStatus == ERROR_SUCCESS && dwData != 0)
		            {
		                m_CombaseInCLBState = CLBCATQ_UNLOCKED;
		            }

		            RegCloseKey (hCom3Key);
		        }       
			}

			//  Fall through here, for startup
			//  Because we may fall through, check for UNLOCKED state
		case CLBCATQ_UNLOCKED:
			if ( m_CombaseInCLBState == CLBCATQ_UNLOCKED )
			{
				HINSTANCE hInst;
				FN_GetCatalogObject *pfnGetCatalogObject2 = NULL;
                LockCookie lockCookie;

				//
				// This code may be called with the loader lock already held.
				// Release the lock to prevent deadlocks.
				//

                g_CatalogLock.ReleaseLock(&lockCookie);

				hInst = LoadLibraryA(g_szCLBCATQDLL);
				if ( hInst != NULL )
				{
					// GetCatalogObject2 was added in 1.x to support combase classes configured 
					// in regdb.   It will not exist for 1.0 versions of clbcatq.dll.
					pfnGetCatalogObject2 = (FN_GetCatalogObject *) GetProcAddress(hInst, "GetCatalogObject2");
				}

                g_CatalogLock.RestoreLock(&lockCookie);

				if ((m_CombaseInCLBState != CLBCATQ_UNLOCKED) && hInst)
				{
					//
					// someone beat us, release the library
					//
                    g_CatalogLock.ReleaseLock(&lockCookie);
					FreeLibrary(hInst);
                    g_CatalogLock.RestoreLock(&lockCookie);
				}
				else
				{
					if ( pfnGetCatalogObject2 != NULL)
					{
						hr = pfnGetCatalogObject2(IID_IComCatalogInternal, (void **) &m_pCatalogCOMBaseInCLB);
						if (SUCCEEDED(hr))
						{
						    // Set SCM location
                            IComCatalogLocation* pCatLocation = NULL;

                            hr = m_pCatalogCOMBaseInCLB->QueryInterface (IID_IComCatalogLocation, (void **) &pCatLocation);
                            if (SUCCEEDED (hr) && pCatLocation != NULL)
                            {
                                // Best effort
                                pCatLocation->SetCatalogLocation (g_bInSCM);
                                pCatLocation->Release();
                            }
                            
							FlushCache();
						}
						else
						{
							m_pCatalogCOMBaseInCLB = NULL;
						}
					}

					if (((pfnGetCatalogObject2 == NULL) || 
						 (m_pCatalogCOMBaseInCLB == NULL)) &&
						(hInst != NULL))
					{
						//
						// something went wrong, release the library
						//
                        g_CatalogLock.ReleaseLock(&lockCookie);
						FreeLibrary(hInst);
                        g_CatalogLock.RestoreLock(&lockCookie);
					}
					
					if (m_pCatalogCOMBaseInCLB)
					{
						m_CombaseInCLBState = CLBCATQ_RESOLVED;
					}
				}
			}
			break;

		case CLBCATQ_RESOLVED:
		default:
			break;
		}

		g_CatalogLock.ReleaseWriterLock();
	}
	
	m_bTriedToLoadComBaseCLBAtLeastOnce = TRUE;

	return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\catalog\noenum.cxx ===
/* noenum.cxx */

#include <windows.h>
#include <comdef.h>

#include "globals.hxx"

#include "noenum.hxx"


/*
 *  class CNoEnum
 */

CNoEnum::CNoEnum(void)
{
    m_cRef = 0;
}


/* IUnknown methods */

STDMETHODIMP CNoEnum::QueryInterface(
        REFIID riid,
        LPVOID FAR* ppvObj)
{
    *ppvObj = NULL;

    if ((riid == IID_IEnumUnknown) || (riid == IID_IUnknown))
    {
        *ppvObj = (LPVOID) (IEnumUnknown *) this;
    }

    if (*ppvObj != NULL)
    {
        ((LPUNKNOWN)*ppvObj)->AddRef();

        return(NOERROR);
    }

    return(E_NOINTERFACE);
}


STDMETHODIMP_(ULONG) CNoEnum::AddRef(void)
{
    long cRef;

    cRef = InterlockedIncrement(&m_cRef);

    return(cRef);
}


STDMETHODIMP_(ULONG) CNoEnum::Release(void)
{
    long cRef;

    cRef = InterlockedDecrement(&m_cRef);

    if (cRef == 0)
    {
        delete this;
    }

    return(cRef);
}


/* IEnumUnknown methods */

HRESULT STDMETHODCALLTYPE CNoEnum::Next
(
    /* [in] */ ULONG celt,
    /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched
)
{
    if (pceltFetched != NULL)
    {
        *pceltFetched = 0;
    }

    if (celt == 0)
    {
        return(S_OK);
    }
    else
    {
        return(S_FALSE);
    }
}


HRESULT STDMETHODCALLTYPE CNoEnum::Skip
(
    /* [in] */ ULONG celt
)
{
    if (celt == 0)
    {
        return(S_OK);
    }
    else
    {
        return(S_FALSE);
    }
}


HRESULT STDMETHODCALLTYPE CNoEnum::Reset(void)
{
    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CNoEnum::Clone
(
    /* [out] */ IEnumUnknown __RPC_FAR *__RPC_FAR *ppenum
)
{
    AddRef();

    *ppenum = this;

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\catalog\class.cxx ===
/* class.cxx */

#include <windows.h>
#include <appmgmt.h>
#include <comdef.h>
#include <string.h>
#include <wow64reg.h>

#include "globals.hxx"
#include "services.hxx"

#include "catalog.h"
#include "partitions.h"
#include "class.hxx"
#include "catalog.hxx"

#if DBG
#include <debnot.h>
#endif

const WCHAR g_wszInprocServer32[] = L"InprocServer32";
const WCHAR g_wszInprocHandler32[] = L"InprocHandler32";
const WCHAR g_wszLocalServer32[] = L"LocalServer32";
const WCHAR g_wszLocalServer16[] = L"LocalServer";
const WCHAR g_wszInprocServer16[] = L"InprocServer";
const WCHAR g_wszRemoteServerName[] = L"RemoteServerName";
const WCHAR g_wszInprocHandler16[] = L"InprocHandler";
const WCHAR g_wszInprocServerX86[] = L"InprocServerX86";
const WCHAR g_wszInprocHandlerX86[] = L"InprocHandlerX86";
const WCHAR g_wszThreadingModel[] = L"ThreadingModel";
const WCHAR g_wszOle32Dll[] = L"OLE32.DLL";
const WCHAR g_wszApartment[] = L"Apartment";
const WCHAR g_wszBoth[] = L"Both";
const WCHAR g_wszFree[] = L"Free";
const WCHAR g_wszNeutral[] = L"Neutral";
const WCHAR g_wszProgId[] = L"Progid";
const WCHAR g_wszProcessId[] = L"AppID";
const WCHAR g_wszAppidTemplate[] = L"AppID\\{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}";
const WCHAR g_wszLocalService[] = L"LocalService";
const WCHAR g_wszDllSurrogate[] = L"DllSurrogate";
const WCHAR g_wszDebugSurrogate[] = L"DebugSurrogate";
const WCHAR g_wszDllHostSlashProcessId[] = L"DllHost.exe /Processid:";
const WCHAR g_wszEmbedding[] = L" -Embedding";

#define STRLEN_WCHAR(s) ((sizeof((s)) / sizeof((s)[0])) -1)

#define STRLEN_OLE32DLL (STRLEN_WCHAR(g_wszOle32Dll))

#ifdef _WIN64

enum FileType { COM_32BIT_BINARY, COM_64BIT_BINARY, COM_UNKNOWN_BINARY };

//
// File type code
//
                    
HRESULT InternalGetFileType (LPCWSTR pwszFile, FileType* pFileType)
{
    HRESULT hr = S_OK;    
    HANDLE hFile = INVALID_HANDLE_VALUE, hFileMapping = NULL;
    HMODULE hModNtdll = NULL;
    LPVOID pBase = NULL;

    typedef PIMAGE_NT_HEADERS (*RtlImageNtHeader) (PVOID);

    PIMAGE_NT_HEADERS pImage;
    RtlImageNtHeader pRtlImageNtHeader;
    USHORT uMachine;

    // Verify args
    if (pwszFile == NULL || pFileType == NULL) return E_INVALIDARG;

    *pFileType = COM_UNKNOWN_BINARY;

    // CreateFile can't handle a path with quotes.  @#$%@#$%@#$%!!!!
    Win4Assert (pwszFile[0] != L'\"');
 
    // Memmap the requested file
    hFile = CreateFile (
        pwszFile,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_FLAG_SEQUENTIAL_SCAN,
        NULL
        );

    if (hFile == INVALID_HANDLE_VALUE && GetLastError() == ERROR_FILE_NOT_FOUND)
    {
        TCHAR* pszFullPath = (TCHAR*) _alloca (MAX_PATH * sizeof (TCHAR)), * pszFileName;
        
        DWORD dwRetVal = SearchPath (
            NULL,
            pwszFile,
            NULL,
            MAX_PATH,
            pszFullPath,
            &pszFileName
            );

        if (dwRetVal == 0)
        {
            hr = HRESULT_FROM_WIN32 (GetLastError());
            goto Cleanup;
        }

        hFile = CreateFile (
            pszFullPath,
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            FILE_FLAG_SEQUENTIAL_SCAN,
            NULL
            );
    }
    
    if (hFile == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32 (GetLastError());
        goto Cleanup;
    }

    hFileMapping = CreateFileMapping (
        hFile,
        NULL,
        PAGE_READONLY,
        0,
        0,
        NULL
        );
    
    if (hFileMapping == NULL)
    {
        hr = HRESULT_FROM_WIN32 (GetLastError());
        goto Cleanup;
    }

    pBase = MapViewOfFile (hFileMapping, FILE_MAP_READ, 0, 0, 0);
    if (pBase == NULL)
    {
        hr = HRESULT_FROM_WIN32 (GetLastError());
        goto Cleanup;
    }

    // Get address of ntdll!RtlImageNtHeader
    hModNtdll = LoadLibraryW (L"ntdll.dll");
    if (hModNtdll == NULL)
    {
        hr = HRESULT_FROM_WIN32 (GetLastError());
        goto Cleanup;
    }

    pRtlImageNtHeader = (RtlImageNtHeader) GetProcAddress (hModNtdll, "RtlImageNtHeader");
    if (pRtlImageNtHeader == NULL)
    {
        hr = HRESULT_FROM_WIN32 (GetLastError());
        goto Cleanup;
    }

    // Get image header
    pImage = pRtlImageNtHeader (pBase);
    if (pImage == NULL)
    {
        hr = HRESULT_FROM_WIN32 (GetLastError());
        goto Cleanup;
    }

    // Determine type
    uMachine = pImage->FileHeader.Machine;

    if (uMachine & IMAGE_FILE_32BIT_MACHINE)
    {
        *pFileType = COM_32BIT_BINARY;
    }
    else
    {
        switch (uMachine)
        {
        case IMAGE_FILE_MACHINE_IA64:
        case IMAGE_FILE_MACHINE_AXP64:
            *pFileType = COM_64BIT_BINARY;
            break;

        default:
            // Couldn't determine type
            hr = E_INVALIDARG;
            break;
        }
    }

Cleanup:

    if (hModNtdll != NULL) FreeLibrary (hModNtdll);
    if (pBase != NULL) UnmapViewOfFile (pBase);
    if (hFileMapping != NULL) CloseHandle (hFileMapping);
    if (hFile != INVALID_HANDLE_VALUE && hFile != NULL) CloseHandle (hFile); 

    return hr;
}


HRESULT GetFileTypeFromRegString (LPCWSTR pwszRegString, FileType* pFileType)
{
    // We need to get the file type of the binary in the inputstring.
    // However, there may be cmd line arguments at the end complicating matters.
    //
    // As a heuristic, we'll look for an initial quote.
    // If there's a quote, then we'll scan to the end of the quote 
    // and cut off everything else off.
    // If there isn't a quote, we'll scan until we hit a space

    HRESULT hr;

    size_t stDiff, stStrLen = wcslen (pwszRegString) + 1;
    WCHAR* pwsEnd, * pwszFileName = (WCHAR*) _alloca (stStrLen * sizeof (WCHAR));

    if (pwszRegString[0] == L'\"')
    {
        // Search for the end quote
        pwsEnd = wcsstr (pwszRegString + 1, L"\"");
        if (pwsEnd == NULL)
        {
            // Ill formed string;  copy without the quote and hope it works
            wcscpy (pwszFileName, pwszRegString + 1);
        }
        else
        {
            // Copy everything inside the quotes, stripping the quotes
            // because Create Process doesn't like quotes
            // This covers cases like: "C:\Program Files\Directory\Exe.exe" or 
            // "C:\Program Files\Directory\Exe.exe" /Surrogate
            stDiff = pwsEnd - pwszRegString - 1;
            wcsncpy (pwszFileName, pwszRegString + 1, stDiff);
            pwszFileName[stDiff] = L'\0';
        }
    }
    else
    {
        // Search for a space
        pwsEnd = wcsstr (pwszRegString + 1, L" ");
        if (pwsEnd == NULL)
        {
            // Just copy the line
            // This covers cases like: C:\Progra~1\Directory\Exe.exe
            wcscpy (pwszFileName, pwszRegString);
        }
        else
        {
            // Copy to the space
            // This covers cases like: C:\Progra~1\Directory\Exe.exe /Surrogate
            stDiff = pwsEnd - pwszRegString;
            wcsncpy (pwszFileName, pwszRegString, stDiff);
            pwszFileName[stDiff] = L'\0';
        }
    }

    // Now that we have the right kind of string, get the file type
    hr = InternalGetFileType (pwszFileName, pFileType);

    return hr;
}

#endif

/*
 *  class CComClassInfo
 */

CComClassInfo::CComClassInfo
    (
    IUserToken *pUserToken,
    const GUID *pClsid,
    WCHAR *pwszClsidString,
    HKEY hKey,
    REGSAM regType
    )
{
    m_cRef = 0;
#if DBG
    m_cRefCache = 0;
#endif
    m_cLocks = 0;
    m_hKeyClassesRoot = NULL;
    m_clsid = *pClsid;
    m_fValues = VALUE_NONE;
    m_clsctx = 0;
    wcscpy(m_wszClsidString, pwszClsidString);
    m_pwszProgid = NULL;
    m_pwszClassName = NULL;

    m_regType = regType;

    m_pwszInprocServer32 = NULL;
    m_pwszInprocHandler32 = NULL;
    m_pwszLocalServer = NULL;
    m_pwszInprocServer16 = NULL;
    m_pwszRemoteServerName = NULL;
    m_pwszInprocHandler16 = NULL;
    m_pwszInprocServerX86 = NULL;
    m_pwszInprocHandlerX86 = NULL;
    m_pwszSurrogateCommand = NULL;

    m_pUserToken = pUserToken;
    if ( m_pUserToken != NULL )
    {
        m_pUserToken->AddRef();
    }
}


#define DELETE_CLASS_STRING(p)                      \
    if (((p) != NULL) && ((p) != g_wszEmptyString)) \
    {                                               \
        delete (p);                                 \
    }


CComClassInfo::~CComClassInfo()
{
    DELETE_CLASS_STRING(m_pwszProgid);
    DELETE_CLASS_STRING(m_pwszClassName);
    DELETE_CLASS_STRING(m_pwszInprocServer32);
    DELETE_CLASS_STRING(m_pwszInprocHandler32);
    DELETE_CLASS_STRING(m_pwszLocalServer);
    DELETE_CLASS_STRING(m_pwszInprocServer16);
    DELETE_CLASS_STRING(m_pwszRemoteServerName);
    DELETE_CLASS_STRING(m_pwszInprocHandler16);
    DELETE_CLASS_STRING(m_pwszInprocServerX86);
    DELETE_CLASS_STRING(m_pwszInprocHandlerX86);
    DELETE_CLASS_STRING(m_pwszSurrogateCommand);

    Win4Assert (m_hKeyClassesRoot == NULL);

    if ( m_pUserToken != NULL )
    {
        m_pUserToken->Release();
    }
}


/* IUnknown methods */

STDMETHODIMP CComClassInfo::QueryInterface(
                                          REFIID riid,
                                          LPVOID FAR* ppvObj)
{
    *ppvObj = NULL;

    if ( riid == IID_IComClassInfo )
    {
        *ppvObj = (LPVOID) (IComClassInfo *) this;
    }
    else if ( riid == IID_IClassClassicInfo )
    {
        *ppvObj = (LPVOID) (IClassClassicInfo *) this;
    }
#if DBG
    else if ( riid == IID_ICacheControl )
    {
        *ppvObj = (LPVOID) (ICacheControl *) this;
    }
#endif
    else if ( riid == IID_IUnknown )
    {
        *ppvObj = (LPVOID) (IComClassInfo *) this;
    }

    if ( *ppvObj != NULL )
    {
        ((LPUNKNOWN)*ppvObj)->AddRef();

        return NOERROR;
    }

    return(E_NOINTERFACE);
}


STDMETHODIMP_(ULONG) CComClassInfo::AddRef(void)
{
    long cRef;

    cRef = InterlockedIncrement(&m_cRef);

    return(cRef);
}


STDMETHODIMP_(ULONG) CComClassInfo::Release(void)
{
    long cRef;

    cRef = InterlockedDecrement(&m_cRef);

    if ( cRef == 0 )
    {
#if DBG
        //Win4Assert((m_cRefCache == 0) && "attempt to release an un-owned ClassInfo object");
#endif
        delete this;
    }

    return(cRef);
}


/* IComClassInfo methods */

HRESULT STDMETHODCALLTYPE CComClassInfo::GetConfiguredClsid
    (
    /* [out] */ GUID __RPC_FAR *__RPC_FAR *ppguidClsid
    )
{
    *ppguidClsid = &m_clsid;

    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComClassInfo::GetProgId
    (
    /* [out] */ WCHAR __RPC_FAR *__RPC_FAR *pwszProgid
    )
{
    HKEY hKey;

    if ( (m_fValues & VALUE_PROGID) == 0 )
    {
        g_CatalogLock.AcquireWriterLock();

        if ( (m_fValues & VALUE_PROGID) == 0 )
        {
            GetClassesRoot();

            if ( ERROR_SUCCESS == RegOpenKeyExW(m_hKeyClassesRoot, m_wszClsidString, 0, KEY_READ | m_regType, &hKey) )
            {
                GetRegistryStringValue(hKey, g_wszProgId, NULL, RQ_ALLOWQUOTEQUOTE, &m_pwszProgid);
                RegCloseKey(hKey);
            }

            ReleaseClassesRoot();

            m_fValues |= VALUE_PROGID;
        }

        g_CatalogLock.ReleaseWriterLock();
    }

    *pwszProgid = m_pwszProgid;

    if ( m_pwszProgid != NULL && m_pwszProgid[0] != L'\0' )
    {
        return(S_OK);
    }
    else
    {
        return(E_FAIL);
    }
}


HRESULT STDMETHODCALLTYPE CComClassInfo::GetClassName
    (
    /* [out] */ WCHAR __RPC_FAR *__RPC_FAR *pwszClassName
    )
{
    HKEY hKey;

    if ( (m_fValues & VALUE_CLASSNAME) == 0 )
    {
        g_CatalogLock.AcquireWriterLock();

        if ( (m_fValues & VALUE_CLASSNAME) == 0 )
        {
            GetClassesRoot();

            if (ERROR_SUCCESS == RegOpenKeyExW(m_hKeyClassesRoot, m_wszClsidString, 0, KEY_READ | m_regType, &hKey))
            {
                GetRegistryStringValue(hKey, NULL, NULL, RQ_ALLOWQUOTEQUOTE, &m_pwszClassName);
                RegCloseKey(hKey);
            }

            ReleaseClassesRoot();

            m_fValues |= VALUE_CLASSNAME;
        }

        g_CatalogLock.ReleaseWriterLock();
    }

    *pwszClassName = m_pwszClassName;

    if ( (m_pwszClassName != NULL) && (*m_pwszClassName != L'\0') )
    {
        return(S_OK);
    }
    else
    {
        return(E_FAIL);
    }
}


HRESULT STDMETHODCALLTYPE CComClassInfo::GetApplication
    (
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv
    )
{
    return(E_FAIL);
}

#ifdef DARWIN_ENABLED
HRESULT CComClassInfo::GetDarwinIdentifier(HKEY hKey, LPCWSTR wszInprocServerRegValue, LPWSTR *lpwszInprocServerKey)
{
    // The Darwin identifiers are stored in a named value of the same name as the
    // server subkey.  Thus a LocalServer32 named value could exist under the
    // LocalSever32 CLSID subkey, or an InprocServer32 named value could exist
    // under the InprocServer32 subkey.  16 bit servers are not supported.
    //
    // Additional details can be found in the ZAW spec on
    // \\popcorn\razzle1\src\spec\zawdes.doc.
    LPWSTR pwszDarwinId=NULL;

    // Read Darwin identifier if present
    HRESULT hr = GetRegistryStringValue(hKey, wszInprocServerRegValue, wszInprocServerRegValue, RQ_MULTISZ, &pwszDarwinId);
    if (SUCCEEDED(hr))
    {
        // Found a Darwin descriptor
        // Call Darwin and use the returned path as IPS32
        hr=GetPathFromDarwinDescriptor(pwszDarwinId, lpwszInprocServerKey);

        DELETE_CLASS_STRING(pwszDarwinId);

        if (SUCCEEDED(hr))
        {
            // Darwin might give back a quoted string: unquote it
            if ((*lpwszInprocServerKey)[0] == L'"')
            {
                size_t cbValue = wcslen(*lpwszInprocServerKey);

                if ((cbValue >= 2) && ((*lpwszInprocServerKey)[cbValue - 1] == L'"'))
                {
                    WCHAR *t = *lpwszInprocServerKey;
                    WCHAR *s = t + 1;

                    (*lpwszInprocServerKey)[cbValue - 1] = L'\0';

                    while (*t++ = *s++)
                    {
                        /* slide the string down */
                    }
                }
            }
        }
    }

    return hr;
}
#endif


HRESULT STDMETHODCALLTYPE CComClassInfo::GetClassContext
    (
    /* [in] */ CLSCTX clsctxFilter,
    /* [out] */ CLSCTX __RPC_FAR *pclsctx
    )
{
    HRESULT hr;
    LONG res;
    HKEY hKey = NULL;
    HKEY hKey2;
    WCHAR *pwsz;
    int clsctxNotValid;
    _GUID *pguidProcess;

    // If there's any chance we'll need hKey, get it now so we don't have to
    // open it once for the Darwin code and again down below. If another
    // thread beats us in, then we wind up not using hKey after all, but
    // that's okay - we optimize the normal case.
    if ( clsctxFilter & ~m_fValues )
    {
        GetClassesRoot();

        res = RegOpenKeyExW(m_hKeyClassesRoot, m_wszClsidString, 0, KEY_READ | m_regType, &hKey);
        if (res != ERROR_SUCCESS)
        {       
            ReleaseClassesRoot();
            return HRESULT_FROM_WIN32(res);
        }
    }

#ifdef DARWIN_ENABLED
    WCHAR   *pwszDarwinLocalServer = NULL;
    WCHAR   *pwszDarwinInprocServer32 = NULL;
    WCHAR   *pwszDarwinInprocServerX86 = NULL;

    // See if we *might* need to get class info from Darwin. We don't want to
    // serialize threads through possibly lengthy Darwin code, so we accept the
    // fact that multiple threads could pass through here for the same class.
    // We take care to avoid updating any member variables in this unprotected
    // section.

    clsctxNotValid = clsctxFilter & ~m_fValues & (CLSCTX_INPROC_SERVER|CLSCTX_LOCAL_SERVER);

    if ( clsctxNotValid & CLSCTX_INPROC_SERVER )
    {
        hr = GetDarwinIdentifier(hKey, g_wszInprocServer32, &pwszDarwinInprocServer32);
        //Win4Assert( SUCCEEDED(hr) || pwszDarwinInprocServer32 == NULL);

        if (FAILED(hr))
        {
            hr = GetDarwinIdentifier(hKey, g_wszInprocServerX86, &pwszDarwinInprocServerX86);
            //Win4Assert( SUCCEEDED(hr) || pwszDarwinInprocServerX86 == NULL);
        }
    }

    if ( clsctxNotValid & CLSCTX_LOCAL_SERVER )
    {
        // The Darwin identifiers are stored in a named value of the same name as the
        // server subkey.  Thus a LocalServer32 named value could exist under the
        // LocalSever32 CLSID subkey, or an InprocServer32 named value could exist
        // under the InprocServer32 subkey.  16 bit servers are not supported.
        //
        // Additional details can be found in the ZAW spec on
        // \\popcorn\razzle1\src\spec\zawdes.doc.
        LPWSTR pwszDarwinId = NULL;

        // Read Darwin identifier if present
        hr = GetRegistryStringValue(hKey, g_wszLocalServer32, g_wszLocalServer32, RQ_MULTISZ, &pwszDarwinId);
        if ( SUCCEEDED(hr) )
        {
            // Found a Darwin descriptor
            // We purposefully resolve Darwin ids in the client as well so that
            // we can see the install UI.  This is not possible from rpcss since
            // it is not in Winsta0.

            // Get the path from Darwin: this can cause files to be copied, registry keys to
            // be written or pretty much anything else...
            hr = GetPathFromDarwinDescriptor(pwszDarwinId, &pwszDarwinLocalServer);
            //Win4Assert( SUCCEEDED(hr) || pwszDarwinLocalServer == NULL);

            DELETE_CLASS_STRING(pwszDarwinId);
        }
    }
#endif

    // Second pass through after loading all Darwin info...
    if ( clsctxFilter & ~m_fValues )
    {
        g_CatalogLock.AcquireWriterLock();

        clsctxNotValid = clsctxFilter & ~m_fValues & ~CLSCTX_REMOTE_SERVER;

        if ( clsctxNotValid & CLSCTX_INPROC_SERVER )
        {
#ifdef DARWIN_ENABLED
            if (pwszDarwinInprocServer32)
            {
                m_clsctx |= CLSCTX_INPROC_SERVER;

                m_pwszInprocServer32 = pwszDarwinInprocServer32;
                pwszDarwinInprocServer32 = NULL;

                goto foundInprocServer;
            }
            else if (pwszDarwinInprocServerX86)
            {
                m_clsctx |= CLSCTX_INPROC_SERVERX86;
                m_pwszInprocServerX86 = pwszDarwinInprocServerX86;
                pwszDarwinInprocServerX86 = NULL;
                m_fValues |= VALUE_INPROC_SERVERX86;

                goto foundInprocServer;
            }
#endif

            hr = GetRegistryStringValue(hKey, g_wszInprocServer32, NULL, 0, &m_pwszInprocServer32);
            if ( SUCCEEDED(hr) )
            {
                if ( m_pwszInprocServer32 && *m_pwszInprocServer32 )
                {
                    m_clsctx |= CLSCTX_INPROC_SERVER;
                }
                else
                {
                    DELETE_CLASS_STRING(m_pwszInprocServer32);
                    m_pwszInprocServer32=NULL;
                }
            }
            else
            {
                //  If the native key is not specified see if the x86 key is.
                hr = GetRegistryStringValue(hKey, g_wszInprocServerX86, NULL, 0, &m_pwszInprocServerX86);
                if ( SUCCEEDED(hr) )
                {
                    if ( m_pwszInprocServerX86 && *m_pwszInprocServerX86 )
                    {
                        //  Indicate we tried and found the x86 server key
                        m_clsctx |= VALUE_INPROC_SERVERX86;
                        m_fValues |= VALUE_INPROC_SERVERX86;
                    }
                    else
                    {
                        DELETE_CLASS_STRING(m_pwszInprocServerX86);
                        m_pwszInprocServerX86=NULL;
                    }
                }
            }
            foundInprocServer:
           
            m_fValues |= VALUE_INPROC_SERVER;
        }

        if ( clsctxNotValid & CLSCTX_INPROC_HANDLER )
        {
            hr = GetRegistryStringValue(hKey, g_wszInprocHandler32, NULL, 0, &m_pwszInprocHandler32);
            if ( SUCCEEDED(hr) )
            {
                if ( m_pwszInprocHandler32 && *m_pwszInprocHandler32 )
                {
                    m_clsctx |= CLSCTX_INPROC_HANDLER;
                }
                else
                {
                    DELETE_CLASS_STRING(m_pwszInprocHandler32);
                    m_pwszInprocHandler32=NULL;
                }
            }
            else
            {
                //  If the native key is not specified see if the x86 key is
                hr = GetRegistryStringValue(hKey, g_wszInprocHandlerX86, NULL, 0, &m_pwszInprocHandlerX86);
                if ( SUCCEEDED(hr) )
                {
                    if ( m_pwszInprocHandlerX86 && *m_pwszInprocHandlerX86 )
                    {
                        m_clsctx |= CLSCTX_INPROC_HANDLERX86;
                        m_fValues |= VALUE_INPROC_HANDLERX86;
                    }
                    else
                    {
                        DELETE_CLASS_STRING(m_pwszInprocHandlerX86);
                        m_pwszInprocHandlerX86=NULL;
                    }
                }
            }
            m_fValues |= VALUE_INPROC_HANDLER;
        }

        if ( clsctxNotValid & CLSCTX_LOCAL_SERVER )
        {                    
#ifdef DARWIN_ENABLED
            if (pwszDarwinLocalServer)
            {
                m_clsctx |= CLSCTX_LOCAL_SERVER;
                m_pwszLocalServer = pwszDarwinLocalServer;
                pwszDarwinLocalServer = NULL;
                m_fValues |= VALUE_LOCALSERVERIS32;
                goto foundLocalServer;
            }
#endif

            hr = GetRegistryStringValue(hKey, g_wszLocalServer32, NULL, 0, &m_pwszLocalServer);
            if ( SUCCEEDED(hr) )
            {
                Win4Assert(m_pwszLocalServer != NULL);

#ifdef _WIN64
                BOOL fValid = TRUE;

                // Because all the AppID settings are not reflected, we need to
                // make sure we're dealing with the correct side of the registry.
                //
                // In RPCSS, the bitness of the executable in the LocalServer32 
                // key must match our bitness.  In practice, we only check if we 
                // are not the 32bit registry.  (If there turn out to be more registries
                // later, we will need to change this.... hahaha)
                if (g_bInSCM && (m_regType != KEY_WOW64_32KEY))
                {
                    FileType processType;
                    RPC_STATUS status;

                    // Best effort impersonate before hitting the disk, because rpcss
                    // credentials may not have access to the file

                    status = RpcImpersonateClient (NULL);

                    if (SUCCEEDED (GetFileTypeFromRegString (m_pwszLocalServer, &processType)))
                    {
                        // If this is the processType that gets the other
                        // side of the registry, then *I* am not qualified
                        // to answer *ANY* configuration questions about this class.
                        // Go bother someone else.
                        if (processType == COM_32BIT_BINARY)
                        {
                            CatalogDebugOut((DEB_CLASSINFO,
                                             "CComClassInfo appears valid, but is for the wrong process type.\n"));

                            delete m_pwszLocalServer; 
                            m_pwszLocalServer = NULL;

                            fValid = FALSE;
                        }
                    }
                    else
                    {
                        // If GetProcessType failed then I say the LocalServer32
                        // key is invalid.
                        delete m_pwszLocalServer; 
                        m_pwszLocalServer = NULL;

                        fValid = FALSE;
                    }

                    if (status == RPC_S_OK)
                    {
                        RpcRevertToSelf();
                    }
                }

                if (fValid)
#endif
                {
                    m_clsctx |= CLSCTX_LOCAL_SERVER;
                    m_fValues |= VALUE_LOCALSERVERIS32;
                    goto foundLocalServer;
                }
            }

            hr = GetRegistryStringValue(hKey, g_wszLocalServer16, NULL, 0, &m_pwszLocalServer);            
            if ( SUCCEEDED(hr) )
            {
                m_clsctx |= CLSCTX_LOCAL_SERVER;
                goto foundLocalServer;
            }

            hr = GetProcessId(&pguidProcess);
            if ( hr == S_OK )
            {
				WCHAR wszAppidString[45];

                wcscpy(wszAppidString, g_wszAppidTemplate);
                GUIDToString(pguidProcess, wszAppidString + 7);

                res = RegOpenKeyExW (m_hKeyClassesRoot, wszAppidString, 0, KEY_READ | m_regType, &hKey2);
                if ( ERROR_SUCCESS == res )
                {
                    const DWORD cchValue = 10;
                    WCHAR wszValue [cchValue + 1];
                    DWORD cbValue = 0;
                    
                    res = RegQueryValueExW(hKey2, g_wszDllSurrogate, NULL, NULL, NULL, &cbValue);
                    if (ERROR_SUCCESS == res && cbValue > 1)
                    {
                        WCHAR* pwszSurrogate = (WCHAR*) _alloca (cbValue + sizeof (WCHAR));
                        res = RegQueryValueExW(hKey2, g_wszDllSurrogate, NULL, NULL, (BYTE *) pwszSurrogate, &cbValue);
                        if (ERROR_SUCCESS == res)
                        {
                            BOOL bAcceptable = TRUE;
                            
                            // We found a surrogate
                            //
                            // We need to be careful, though - if we're in the 64 bit registry
                            // and the surrogate is a custom surrogate and it's 32 bit, 
                            // we shouldn't add local server to our acceptable contexts because 
                            // this way we'll fall through to a 32 bit classinfo that will do the right thing
#ifdef _WIN64
                            if (g_bInSCM && m_regType != KEY_WOW64_32KEY && pwszSurrogate[0] != L'\0')
                            {
                                FileType processType;
                                RPC_STATUS status;
            
                                status = RpcImpersonateClient (NULL);

                                hr = GetFileTypeFromRegString (pwszSurrogate, &processType);
                                if (FAILED (hr) || processType != COM_64BIT_BINARY)
                                {
                                    bAcceptable = FALSE;
                                }

                                if (status == RPC_S_OK)
                                {
                                    RpcRevertToSelf();
                                }
                            }
#endif
                            if (bAcceptable)
                            {
                                RegCloseKey(hKey2);
                                m_clsctx |= CLSCTX_LOCAL_SERVER;
                                goto foundLocalServer;
                            }
                        }
                    }
                    
                    cbValue = (DWORD) (cchValue * sizeof(WCHAR));

                    res = RegQueryValueExW(hKey2, g_wszLocalService, NULL, NULL, (BYTE *) wszValue, &cbValue);

                    if ((cbValue > 3) &&
                        ((ERROR_SUCCESS == res) || (ERROR_MORE_DATA == res)))
                    {
                        RegCloseKey(hKey2);
                        m_clsctx |= CLSCTX_LOCAL_SERVER;
                        goto foundLocalServer;
                    }

                    RegCloseKey(hKey2);
                }
            }

            foundLocalServer:

            m_fValues |= VALUE_LOCAL_SERVER;
        }

        if ( clsctxNotValid & CLSCTX_INPROC_SERVER16 )
        {
            hr = GetRegistryStringValue(hKey, g_wszInprocServer16, NULL, 0, &m_pwszInprocServer16);

            if ( SUCCEEDED(hr) )
            {
                m_clsctx |= CLSCTX_INPROC_SERVER16;
            }
            m_fValues |= VALUE_INPROC_SERVER16;
        }

        if ( clsctxNotValid & CLSCTX_INPROC_HANDLER16 )
        {
            hr = GetRegistryStringValue(hKey, g_wszInprocHandler16, NULL, 0, &m_pwszInprocHandler16);

            if ( SUCCEEDED(hr) )
            {
                m_clsctx |= CLSCTX_INPROC_HANDLER16;
            }
            m_fValues |= VALUE_INPROC_HANDLER16;
        }

        if ( clsctxNotValid & CLSCTX_INPROC_SERVERX86 )
        {
            hr = GetRegistryStringValue(hKey, g_wszInprocServerX86, NULL, 0, &m_pwszInprocServerX86);

            if ( SUCCEEDED(hr) )
            {
                m_clsctx |= CLSCTX_INPROC_SERVERX86;
            }
            m_fValues |= VALUE_INPROC_SERVERX86;
        }

        if ( clsctxNotValid & CLSCTX_INPROC_HANDLERX86 )
        {
            hr = GetRegistryStringValue(hKey, g_wszInprocHandlerX86, NULL, 0, &m_pwszInprocHandlerX86);

            if ( SUCCEEDED(hr) )
            {
                m_clsctx |= CLSCTX_INPROC_HANDLERX86;
            }
            m_fValues |= VALUE_INPROC_HANDLERX86;
        }

        g_CatalogLock.ReleaseWriterLock();
    }

    if (hKey)
    {
        RegCloseKey(hKey);
        ReleaseClassesRoot();
    }


    *pclsctx = (CLSCTX) (((int) clsctxFilter) & (m_clsctx | 
                                                 CLSCTX_REMOTE_SERVER |  
                                                 CLSCTX_INPROC_HANDLER | 
                                                 CLSCTX_INPROC_HANDLER16 | 
                                                 CLSCTX_NO_WX86_TRANSLATION | 
                                                 CLSCTX_NO_FAILURE_LOG));

    //  The masking above makes sure only the selected context information
    //  is returned.  The problem is we want x86 INPROC context information
    //  returned when only INPROC information is requested.  For example, if
    //  CLSCTX_INPROC_SERVER is requested and CLSCTX_INPROC_SERVERX86 is
    //  available, then we want it returned.  The code below ensures this is
    //  done.

    if ( !((*pclsctx) & CLSCTX_NO_WX86_TRANSLATION) )
    {
        if ( (clsctxFilter & CLSCTX_INPROC_SERVER) && (m_clsctx & CLSCTX_INPROC_SERVERX86) )
        {
            *pclsctx = (CLSCTX) (*pclsctx | CLSCTX_INPROC_SERVERX86);
        }

        if ( (clsctxFilter & CLSCTX_INPROC_HANDLER) && (m_clsctx & CLSCTX_INPROC_HANDLERX86) )
        {
            *pclsctx = (CLSCTX) (*pclsctx | CLSCTX_INPROC_HANDLERX86);
        }
    }

#ifdef DARWIN_ENABLED
    // Normally, these are assigned to member variables, but if we had multiple
    // threads racing through the unprotected Darwin calls, we might need to
    // free memory that was allocated by the "losing" thread(s).
    DELETE_CLASS_STRING(pwszDarwinInprocServer32);
    DELETE_CLASS_STRING(pwszDarwinInprocServerX86);
    DELETE_CLASS_STRING(pwszDarwinLocalServer);
#endif

    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComClassInfo::GetCustomActivatorCount
    (
    /* [in] */ ACTIVATION_STAGE activationStage,
    /* [out] */ unsigned long __RPC_FAR *pulCount
    )
{
    *pulCount = 0;

    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComClassInfo::GetCustomActivatorClsids
    (
    /* [in] */ ACTIVATION_STAGE activationStage,
    /* [out] */ GUID __RPC_FAR *__RPC_FAR *prgguidClsid
    )
{
    *prgguidClsid = NULL;

    return(E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE CComClassInfo::GetCustomActivators
    (
    /* [in] */ ACTIVATION_STAGE activationStage,
    /* [out] */ ISystemActivator __RPC_FAR *__RPC_FAR *__RPC_FAR *prgpActivator
    )
{
    *prgpActivator = NULL;
    return(S_FALSE);
}


HRESULT STDMETHODCALLTYPE CComClassInfo::GetTypeInfo
    (
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv
    )
{
    *ppv = NULL;

    return(E_NOTIMPL);        
}


HRESULT STDMETHODCALLTYPE CComClassInfo::IsComPlusConfiguredClass
    (
    /* [out] */ BOOL __RPC_FAR *pfComPlusConfiguredClass
    )
{
    *pfComPlusConfiguredClass = FALSE;

    return(S_OK);
}


/* IClassClassicInfo methods */

HRESULT STDMETHODCALLTYPE CComClassInfo::GetThreadingModel
    (
    /* [out] */ ThreadingModel __RPC_FAR *pthreadmodel
    )
{
    HRESULT hr;
    HKEY hKey;
    CLSCTX clsctx;

    if ( (m_fValues & VALUE_THREADINGMODEL) == 0 )
    {
        g_CatalogLock.AcquireWriterLock();

        if ( (m_fValues & VALUE_THREADINGMODEL) == 0 )
        {
            m_threadingmodel = SingleThreaded;  /* default */

            if ( (m_fValues & VALUE_INPROC_SERVER) == 0 )
            {
                GetClassContext(CLSCTX_INPROC_SERVER, &clsctx);
            }

            if ( m_pwszInprocServer32 != NULL )
            {
                /* OLE32.DLL is always BOTH */

                /* check for "ole32.dll" or anypath+"\ole32.dll" */

                const size_t cch = wcslen(m_pwszInprocServer32);

                if ( ((cch == STRLEN_OLE32DLL) ||
                      ((cch > STRLEN_OLE32DLL) && (m_pwszInprocServer32[cch - STRLEN_OLE32DLL - 1] == L'\\')))
                     && ( _wcsicmp(m_pwszInprocServer32 + cch - STRLEN_OLE32DLL, g_wszOle32Dll) == 0) )
                {
                    m_threadingmodel = BothThreaded;
                }
                else
                {
                    GetClassesRoot();

                    if ( ERROR_SUCCESS == RegOpenKeyExW(m_hKeyClassesRoot, m_wszClsidString, 0, KEY_READ | m_regType, &hKey) )
                    {
						WCHAR wszValue[25];

                        hr = ReadRegistryStringValue(hKey,
                                                     g_wszInprocServer32,
													 g_wszThreadingModel,
                                                     FALSE, 
													 wszValue, 
													 sizeof(wszValue)/sizeof(WCHAR));
                        if ( SUCCEEDED(hr) )
                        {
                            if ( _wcsicmp(wszValue, g_wszApartment) == 0 )
                            {
                                m_threadingmodel = ApartmentThreaded;
                            }
                            else if ( _wcsicmp(wszValue, g_wszBoth) == 0 )
                            {
                                m_threadingmodel = BothThreaded;
                            }
                            else if ( _wcsicmp(wszValue, g_wszFree) == 0 )
                            {
                                m_threadingmodel = FreeThreaded;
                            }
                            else if ( _wcsicmp(wszValue, g_wszNeutral) == 0 )
                            {
                                m_threadingmodel = NeutralThreaded;
                            }
                            else if ( *wszValue == L'\0' )
                            {
                                // Treat this as if the value wasn't specified at all
                            }
                            else if ( _wcsicmp(wszValue, L"Single") == 0 )
                            {
                              // NT #339216 - Some vendors thought ThreadingModel=Single
                              // was valid. Treat this as if the value wasn't specified at all
                            }
                            else
                            {
                                m_threadingmodel = -1;  /* unrecognized */
                            }
                        }

                        RegCloseKey(hKey);
                    }

                    ReleaseClassesRoot();
                }
            }

            m_fValues |= VALUE_THREADINGMODEL;
        }

        g_CatalogLock.ReleaseWriterLock();
    }

    if ( m_threadingmodel != -1 )
    {
        *pthreadmodel = (ThreadingModel) m_threadingmodel;

        return(S_OK);
    }
    else
    {
        return(REGDB_E_INVALIDVALUE);
    }
}


HRESULT STDMETHODCALLTYPE CComClassInfo::GetModulePath
    (
    /* [in] */ CLSCTX clsctx,
    /* [out] */ WCHAR __RPC_FAR *__RPC_FAR *pwszDllName
    )
{
    int clsctxAvailable;
    WCHAR *pwsz;

    *pwszDllName = NULL;

    /* make sure exactly one context is requested */

    if ( (clsctx & (clsctx - 1)) != 0 )
    {
        return(E_FAIL);
    }

    GetClassContext(clsctx, (CLSCTX *) &clsctxAvailable);

    if ( clsctx & clsctxAvailable )
    {
        switch ( clsctx )
        {
        case CLSCTX_INPROC_SERVER:
            pwsz = m_pwszInprocServer32;
            break;

        case CLSCTX_INPROC_HANDLER:
            pwsz = m_pwszInprocHandler32;
            break;

        case CLSCTX_LOCAL_SERVER:
            pwsz = m_pwszLocalServer;
            break;

        case CLSCTX_INPROC_SERVER16:
            pwsz = m_pwszInprocServer16;
            break;

        case CLSCTX_REMOTE_SERVER:
            GetRemoteServerName(&pwsz);
            break;

        case CLSCTX_INPROC_HANDLER16:
            pwsz = m_pwszInprocHandler16;
            break;

        case CLSCTX_INPROC_SERVERX86:
            pwsz = m_pwszInprocServerX86;
            break;

        case CLSCTX_INPROC_HANDLERX86:
            pwsz = m_pwszInprocHandlerX86;
            break;
        }

        if ( pwsz != NULL )
        {
            *pwszDllName = pwsz;

            return(S_OK);
        }
    }

    return(E_FAIL);
}


HRESULT STDMETHODCALLTYPE CComClassInfo::GetImplementedClsid
    (
    /* [out] */ GUID __RPC_FAR *__RPC_FAR *ppguidClsid
    )
{
    *ppguidClsid = &m_clsid;

    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CComClassInfo::GetProcess
    (
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv
    )
{
    *ppv = NULL;

    _GUID *pProcessId;

    HRESULT hr = GetProcessId(&pProcessId);
    if ( hr == S_OK )
    {		
        DWORD flags = 0;

		// Make sure that if we're a 32bit ClassInfo we take the 
		// 32bit ProcessInfo
		if (m_regType == KEY_WOW64_32KEY)
			flags = CAT_REG32_ONLY;

        hr = CComCatalog::GetProcessInfoInternal(flags, m_pUserToken, m_guidProcessId, riid, ppv);
    }
    else
    {
        hr = E_FAIL;
    }

    return(hr);
}


HRESULT STDMETHODCALLTYPE CComClassInfo::GetRemoteServerName
    (
    /* [out] */ WCHAR __RPC_FAR *__RPC_FAR *pwszServerName
    )
{
    HRESULT hr;

    if ( (m_fValues & VALUE_REMOTE_SERVER) == 0 )
    {
        g_CatalogLock.AcquireWriterLock();

        if ( (m_fValues & VALUE_REMOTE_SERVER) == 0 )
        {
			_GUID *pguidProcess;

            hr = GetProcessId(&pguidProcess);
            if ( hr == S_OK )
            {
                GetClassesRoot();

				WCHAR wszAppidString[45];

                wcscpy(wszAppidString, g_wszAppidTemplate);

                GUIDToString(pguidProcess, wszAppidString + 7);

				HKEY hKey;

                if (ERROR_SUCCESS == RegOpenKeyExW(m_hKeyClassesRoot, wszAppidString, 0, KEY_READ | m_regType, &hKey))
                {
                    hr = GetRegistryStringValue(hKey, NULL, g_wszRemoteServerName, (RQ_MULTISZ | RQ_ALLOWQUOTEQUOTE), &m_pwszRemoteServerName);
                    if ( SUCCEEDED(hr) )
                    {
                        m_clsctx |= CLSCTX_REMOTE_SERVER;
                    }

                    RegCloseKey(hKey);
                }

                ReleaseClassesRoot();
            }

            m_fValues |= VALUE_REMOTE_SERVER;
        }

        g_CatalogLock.ReleaseWriterLock();
    }

    *pwszServerName = m_pwszRemoteServerName;

    if ( m_pwszRemoteServerName != NULL )
    {
        return(S_OK);
    }
    else
    {
        return(E_FAIL);
    }
}


HRESULT STDMETHODCALLTYPE CComClassInfo::GetLocalServerType
    (
    /* [out] */ LocalServerType __RPC_FAR *pType
    )
{
    CLSCTX clsctx;

    GetClassContext(CLSCTX_LOCAL_SERVER, &clsctx);

    if ( m_pwszLocalServer == NULL )
    {
        return(E_FAIL);
    }
    else if ( m_fValues & VALUE_LOCALSERVERIS32 )
    {
        *pType = LocalServerType32;
    }
    else
    {
        *pType = LocalServerType16;
    }

    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComClassInfo::GetSurrogateCommandLine
    (
    /* [out] */ WCHAR __RPC_FAR *__RPC_FAR *pwszSurrogateCommandLine
    )
{
    HRESULT hr;
    IComProcessInfo *pProcess;
    size_t cch;
    _GUID *pguidProcess;

    if ( (m_fValues & VALUE_SURROGATE_COMMAND) == 0 )
    {
        g_CatalogLock.AcquireWriterLock();

        if ( (m_fValues & VALUE_SURROGATE_COMMAND) == 0 )
        {
            hr = GetProcessId(&pguidProcess);
            if ( hr == S_OK )
            {
                GetClassesRoot();

                WCHAR wszAppidString[45];

                wcscpy(wszAppidString, g_wszAppidTemplate);
                GUIDToString(pguidProcess, wszAppidString + 7);

                HKEY hKey;
                DWORD res = RegOpenKeyExW (m_hKeyClassesRoot, wszAppidString, 0, KEY_READ | m_regType, &hKey);
                if (res != ERROR_SUCCESS)
                    hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, res );
                else
                {
                    hr = GetRegistryStringValue(hKey, NULL, g_wszDebugSurrogate, 0, &m_pwszSurrogateCommand);
                    RegCloseKey(hKey);
                }

                ReleaseClassesRoot();

                if ( SUCCEEDED(hr) )
                {
                    goto gotCommandLine;
                }
            }

            hr = GetProcess(IID_IComProcessInfo, (void **) &pProcess);
            if ( hr == S_OK )
            {
                ProcessType eProcessType;

                hr = pProcess->GetProcessType(&eProcessType);
                if ( hr == S_OK )
                {
                    if ( eProcessType == ProcessTypeComPlus )
                    {
                        WCHAR wszSystemDirectory[MAX_PATH] = L"";
                        
                        if (m_regType == KEY_WOW64_32KEY)
                        {
                            // Point over to the 32bit dllhost instead of the 64bit one.
                            cch = GetSystemWow64Directory(wszSystemDirectory, STRLEN_WCHAR(wszSystemDirectory));
                        } 
                        else 
                        {
                            cch = GetSystemDirectory(wszSystemDirectory, STRLEN_WCHAR(wszSystemDirectory));
                        }

                        if (cch > 0)
                        {
                        
                            if ( wszSystemDirectory[cch - 1] != L'\\' )
                            {
                                wszSystemDirectory[cch] = L'\\';
                                cch++;
                                wszSystemDirectory[cch] = L'\0';
                            }
                            
                            m_pwszSurrogateCommand = new WCHAR[
                                cch + STRLEN_WCHAR(g_wszDllHostSlashProcessId) + STRLEN_CURLY_GUID + 1];
                            if ( m_pwszSurrogateCommand != NULL )
                            {
                                wcscpy(m_pwszSurrogateCommand, wszSystemDirectory);
                                wcscpy(m_pwszSurrogateCommand + cch, g_wszDllHostSlashProcessId);
                                cch += STRLEN_WCHAR(g_wszDllHostSlashProcessId);
                                GUIDToCurlyString(&m_guidProcessId,
                                    m_pwszSurrogateCommand + cch);
                                cch += STRLEN_CURLY_GUID;
                                m_pwszSurrogateCommand[cch] = L'\0';
                            }
                        }
                    }
                    else if ( eProcessType == ProcessTypeLegacySurrogate )
                    {
					    WCHAR *pwszSurrogatePath;

                        hr = pProcess->GetSurrogatePath(&pwszSurrogatePath);
                        if ( hr == S_OK )
                        {
                            cch = wcslen(pwszSurrogatePath);

                            m_pwszSurrogateCommand = new WCHAR[
                                cch + 1 + STRLEN_CURLY_GUID + STRLEN_WCHAR(g_wszEmbedding) + 1];
                            if ( m_pwszSurrogateCommand != NULL )
                            {
                                wcscpy(m_pwszSurrogateCommand, pwszSurrogatePath);
                                m_pwszSurrogateCommand[cch] = L' ';
                                cch += 1;
                                GUIDToCurlyString(&m_clsid, m_pwszSurrogateCommand + cch);
                                cch += STRLEN_CURLY_GUID;
                                wcscpy(m_pwszSurrogateCommand + cch, g_wszEmbedding);
                            }
                        }
                    }
                }
                
                pProcess->Release();
            }
            
gotCommandLine:
            
            m_fValues |= VALUE_SURROGATE_COMMAND;
        }
        
        g_CatalogLock.ReleaseWriterLock();
    }

    if ( m_pwszSurrogateCommand != NULL )
    {
        *pwszSurrogateCommandLine = m_pwszSurrogateCommand;

        return(S_OK);
    }
    else
    {
        return(E_OUTOFMEMORY);
    }
}


HRESULT STDMETHODCALLTYPE CComClassInfo::MustRunInClientContext
    (
    /* [out] */ BOOL __RPC_FAR *pbMustRunInClientContext
    )
{
    *pbMustRunInClientContext = FALSE;
    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComClassInfo::GetVersionNumber
    (
    /* [out] */ DWORD __RPC_FAR *pdwVersionMS,
    /* [out] */ DWORD __RPC_FAR *pdwVersionLS
    )
{
    return(E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE CComClassInfo::Lock(void)
{
    /* Like GetClassesRoot, but defer actually opening the */
    /* key, in case this object is already fully rendered. */

    g_CatalogLock.AcquireWriterLock();

    m_cLocks ++;

    g_CatalogLock.ReleaseWriterLock();

    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComClassInfo::Unlock(void)
{
    ReleaseClassesRoot();

    return(S_OK);
}


#if DBG
/* ICacheControl methods */

STDMETHODIMP_(ULONG) CComClassInfo::CacheAddRef(void)
{
    long cRef;

    cRef = InterlockedIncrement(&m_cRefCache);

    return(cRef);
}


STDMETHODIMP_(ULONG) CComClassInfo::CacheRelease(void)
{
    long cRef;

    cRef = InterlockedDecrement(&m_cRefCache);

    return(cRef);
}
#endif


/* private methods */

HRESULT STDMETHODCALLTYPE CComClassInfo::GetProcessId
    (
    /* [out] */ GUID __RPC_FAR *__RPC_FAR *ppguidProcessId
    )
{
    HRESULT hr;
    HKEY hKey;

    if ( (m_fValues & VALUE_PROCESSID) == 0 )
    {
        g_CatalogLock.AcquireWriterLock();

        if ( (m_fValues & VALUE_PROCESSID) == 0 )
        {
            GetClassesRoot();

            if ( ERROR_SUCCESS == RegOpenKeyExW(m_hKeyClassesRoot, m_wszClsidString, 0, KEY_READ | m_regType, &hKey) )
            {
				WCHAR wszValue[50];

                hr = ReadRegistryStringValue(hKey, NULL, g_wszProcessId, FALSE, wszValue, sizeof(wszValue)/sizeof(WCHAR));

                if ( SUCCEEDED(hr) )
                {
                    if ( CurlyStringToGUID(wszValue, &m_guidProcessId) == TRUE )
                    {
                        m_fValues |= VALUE_PROCESSID_VALID;
                    }
                }

                RegCloseKey(hKey);
            }

            ReleaseClassesRoot();

            m_fValues |= VALUE_PROCESSID;
        }

        g_CatalogLock.ReleaseWriterLock();
    }

    if ( m_fValues & VALUE_PROCESSID_VALID )
    {
        *ppguidProcessId = &m_guidProcessId;

        return(S_OK);
    }
    else
    {
        *ppguidProcessId = NULL;

        return(E_FAIL);
    }
}

HRESULT STDMETHODCALLTYPE CComClassInfo::GetClassesRoot(void)
{
    long res;
	HRESULT hr = S_OK;

    g_CatalogLock.AcquireWriterLock();

    m_cLocks++;

    if ( m_hKeyClassesRoot == NULL )
    {
        if ( m_pUserToken != NULL )
        {
            m_pUserToken->GetUserClassesRootKey(&m_hKeyClassesRoot);
        }
        else
        {
            m_hKeyClassesRoot = HKEY_CLASSES_ROOT;
        }
    }

    g_CatalogLock.ReleaseWriterLock();

    return(hr);
}


HRESULT STDMETHODCALLTYPE CComClassInfo::ReleaseClassesRoot(void)
{
    g_CatalogLock.AcquireWriterLock();

    Win4Assert (m_cLocks > 0);
	
    if ( --m_cLocks == 0 && m_hKeyClassesRoot != NULL)
    {
        if ( m_pUserToken != NULL )
        {
			m_pUserToken->ReleaseUserClassesRootKey();
        }

        m_hKeyClassesRoot = NULL;
    }

    g_CatalogLock.ReleaseWriterLock();

    return(S_OK);
}


#ifdef DARWIN_ENABLED
HINSTANCE ghMsi = 0;
PFNMSIPROVIDECOMPONENTFROMDESCRIPTORW gpfnMsiProvideComponentFromDescriptor=NULL;
PFNMSISETINTERNALUI gpfnMsiSetInternalUI=NULL;


//-------------------------------------------------------------------------
//
// CComClassInfo::GetPathFromDarwinDescriptor
//
// Looks for Darwin identifiers for a CLSID in the registry, and calls
// MSI apis to process the identifiers into real paths.
//
// This method can cause Darwin applications to be installed for the calling
// user.  It should always be called before trying to load full CLSID settings.
//
//
//-------------------------------------------------------------------------
HRESULT CComClassInfo::GetPathFromDarwinDescriptor(LPWSTR pszDarwinId, LPWSTR* ppszPath)
{
    INSTALLUILEVEL  OldUILevel;
    WCHAR       wszPath[MAX_PATH];
    WCHAR *     pwszPath;
    DWORD       PathLength;
    int         MsiStatus;
    HRESULT     hr;

    *ppszPath = 0;

    hr = S_OK;
    pwszPath = wszPath;
    PathLength = sizeof(wszPath) / sizeof(WCHAR);

    if ( g_bInSCM )
    {
        if ( ! ghMsi )
        {
            ghMsi = LoadLibrary( L"msi.dll" );

            if ( ! ghMsi )
                return(CO_E_MSI_ERROR);
        }

        if ( ! gpfnMsiSetInternalUI )
        {
            gpfnMsiSetInternalUI =
                (PFNMSISETINTERNALUI) GetProcAddress( ghMsi, "MsiSetInternalUI" );

            if ( ! gpfnMsiSetInternalUI )
                return(CO_E_MSI_ERROR);
        }

        // Though we attempt to force all install actions to be done in the client,
        // there may still be instances when Darwin will want to put up install
        // UI when called from SCM.  So we explicitly set the UI level to none
        // to prevent any possible UI calls from hanging this thread.
        OldUILevel = (*gpfnMsiSetInternalUI)( INSTALLUILEVEL_NONE, NULL );

        //
        // Impersonate so that Darwin can figure out the proper
        // HKU Software\Classes subkey.
        //
        if (RpcImpersonateClient( 0 ) != RPC_S_OK) 
        {
            // Reset the UI level before we leave...
            (*gpfnMsiSetInternalUI)( OldUILevel, NULL );            
            return CO_E_MSI_ERROR;
        }
    }

    for ( ;; )
    {
        //
        // On input, PathLength is number of wchars in pwszPath.  On output
        // it is the length of the (needed) returned path in wchars, not including
        // the null.
        //
        MsiStatus = CommandLineFromMsiDescriptor( pszDarwinId, pwszPath, &PathLength );

        PathLength++;

        if ( ERROR_MORE_DATA == MsiStatus )
        {
            pwszPath = (WCHAR *) new WCHAR[PathLength];
            if ( ! pwszPath )
            {
                hr = E_OUTOFMEMORY;
                break;
            }
            continue;
        }

        if ( MsiStatus != ERROR_SUCCESS )
            hr = CO_E_MSI_ERROR;

        break;
    }

    if ( g_bInSCM )
    {
        RevertToSelf();
        (*gpfnMsiSetInternalUI)( OldUILevel, NULL );
    }

    if ( S_OK == hr )
    {
        *ppszPath = new WCHAR[PathLength];

        if ( *ppszPath )
            wcscpy( *ppszPath, pwszPath );
    }

    if ( pwszPath != wszPath )
        delete pwszPath;

    if ( hr != S_OK )
        return(hr);

    if ( ! *ppszPath )
        return(E_OUTOFMEMORY);

    return hr;
}

#endif // DARWIN_ENABLED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\catalog\noclass.cxx ===
/* noclass.cxx */

#include <windows.h>
#include <comdef.h>

#include "globals.hxx"

#include "catalog.h"
#include "partitions.h"
#include "noclass.hxx"

#if DBG
#include <debnot.h>
#endif


/*
 *  class CComNoClassInfo
 */

CComNoClassInfo::CComNoClassInfo(REFGUID rclsid)
{
    m_cRef = 0;
#if DBG
    m_cRefCache = 0;
#endif
    m_clsid = rclsid;
    m_wszProgID = NULL;

    m_ValueFlags = NCI_HAVECLSID;
}

CComNoClassInfo::CComNoClassInfo(WCHAR *wszProgID)
{
    m_cRef = 0;
#if DBG
    m_cRefCache = 0;
#endif
    m_clsid = GUID_NULL;

    SIZE_T cchProgID = lstrlenW(wszProgID) + 1;
    m_wszProgID = new WCHAR[cchProgID];
    if (m_wszProgID)
    {
        m_ValueFlags = NCI_HAVEPROGID;
        memcpy(m_wszProgID, wszProgID, cchProgID * sizeof(WCHAR));
    }
}

CComNoClassInfo::CComNoClassInfo(REFGUID rclsid, WCHAR *wszProgID)
{
    m_cRef = 0;
#if DBG
    m_cRefCache = 0;
#endif
    m_clsid = rclsid;
    m_ValueFlags = NCI_HAVECLSID;

    SIZE_T cchProgID = lstrlenW(wszProgID) + 1;
    m_wszProgID = new WCHAR[cchProgID];
    if (m_wszProgID)
    {
        m_ValueFlags |= NCI_HAVEPROGID;
        memcpy(m_wszProgID, wszProgID, cchProgID * sizeof(WCHAR));
    }
}


STDMETHODIMP CComNoClassInfo::QueryInterface(
        REFIID riid,
        LPVOID FAR* ppvObj)
{
    *ppvObj = NULL;

    if (riid == IID_IComClassInfo)
    {
        *ppvObj = (LPVOID) (IComClassInfo *) this;
    }
#if DBG
    else if (riid == IID_ICacheControl)
    {
        *ppvObj = (LPVOID) (ICacheControl *) this;
    }
#endif
    else if (riid == IID_IUnknown)
    {
        *ppvObj = (LPVOID) (IComClassInfo *) this;
    }

    if (*ppvObj != NULL)
    {
        ((LPUNKNOWN)*ppvObj)->AddRef();

        return(NOERROR);
    }

    return(E_NOINTERFACE);
}


STDMETHODIMP_(ULONG) CComNoClassInfo::AddRef(void)
{
    long cRef;

    cRef = InterlockedIncrement(&m_cRef);

    return(cRef);
}


STDMETHODIMP_(ULONG) CComNoClassInfo::Release(void)
{
    long cRef;

    cRef = InterlockedDecrement(&m_cRef);

    if (cRef == 0)
    {
#if DBG
        //Win4Assert((m_cRefCache == 0) && "attempt to release an un-owned NoClassInfo object");
#endif

        delete this;
    }

    return(cRef);
}


/* IComClassInfo methods */

HRESULT STDMETHODCALLTYPE CComNoClassInfo::GetConfiguredClsid
(
    /* [out] */ GUID __RPC_FAR *__RPC_FAR *ppguidClsid
)
{
    if (m_ValueFlags & NCI_HAVECLSID)
    {
        *ppguidClsid = &m_clsid;

        return(S_OK);
    }
    
    return(REGDB_E_CLASSNOTREG);
}


HRESULT STDMETHODCALLTYPE CComNoClassInfo::GetProgId
(
    /* [out] */ WCHAR __RPC_FAR *__RPC_FAR *pwszProgid
)
{
    if (m_ValueFlags & NCI_HAVEPROGID)
    {
        *pwszProgid = m_wszProgID;

        return (S_OK);
    }

    return(REGDB_E_CLASSNOTREG);
}


HRESULT STDMETHODCALLTYPE CComNoClassInfo::GetClassName
(
    /* [out] */ WCHAR __RPC_FAR *__RPC_FAR *pwszClassName
)
{
    return(REGDB_E_CLASSNOTREG);
}


HRESULT STDMETHODCALLTYPE CComNoClassInfo::GetApplication
(
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv
)
{
    return(REGDB_E_CLASSNOTREG);
}


HRESULT STDMETHODCALLTYPE CComNoClassInfo::GetClassContext
(
    /* [in] */ CLSCTX clsctxFilter,
    /* [out] */ CLSCTX __RPC_FAR *pclsctx
)
{
    return(REGDB_E_CLASSNOTREG);
}


HRESULT STDMETHODCALLTYPE CComNoClassInfo::GetCustomActivatorCount
(
    /* [in] */ ACTIVATION_STAGE activationStage,
    /* [out] */ unsigned long __RPC_FAR *pulCount
)
{
    // This does not return REGDB_E_CLASSNOTREG because the main activation
    // paths will blow up and not attempt class downloads.  (see GetInstanceHelper,
    // ICoCreateInstanceEx, and ICoGetClassObject in objact.cxx).  Plus
    // returning zero is an honest answer for an unregistered class...
    *pulCount = 0;
    return S_OK;
}


HRESULT STDMETHODCALLTYPE CComNoClassInfo::GetCustomActivatorClsids
(
    /* [in] */ ACTIVATION_STAGE activationStage,
    /* [out] */ GUID __RPC_FAR *__RPC_FAR *prgguidClsid
)
{
    return(REGDB_E_CLASSNOTREG);
}


HRESULT STDMETHODCALLTYPE CComNoClassInfo::GetCustomActivators
(
    /* [in] */ ACTIVATION_STAGE activationStage,
    /* [out] */ ISystemActivator __RPC_FAR *__RPC_FAR *__RPC_FAR *prgpActivator
)
{
    return(REGDB_E_CLASSNOTREG);
}


HRESULT STDMETHODCALLTYPE CComNoClassInfo::GetTypeInfo
(
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv
)
{
    return(REGDB_E_CLASSNOTREG);
}


HRESULT STDMETHODCALLTYPE CComNoClassInfo::IsComPlusConfiguredClass
(
    /* [out] */ BOOL __RPC_FAR *pfComPlusConfiguredClass
)
{
    return(REGDB_E_CLASSNOTREG);
}


HRESULT STDMETHODCALLTYPE CComNoClassInfo::MustRunInClientContext
(
    /* [out] */ BOOL __RPC_FAR *pbMustRunInClientContext
)
{
    return(REGDB_E_CLASSNOTREG);
}


HRESULT STDMETHODCALLTYPE CComNoClassInfo::GetVersionNumber
(
    /* [out] */ DWORD __RPC_FAR *pdwVersionMS,
    /* [out] */ DWORD __RPC_FAR *pdwVersionLS
)
{
    return(REGDB_E_CLASSNOTREG);
}


HRESULT STDMETHODCALLTYPE CComNoClassInfo::Lock(void)
{
    return(REGDB_E_CLASSNOTREG);
}


HRESULT STDMETHODCALLTYPE CComNoClassInfo::Unlock(void)
{
    return(REGDB_E_CLASSNOTREG);
}


/* IClassClassicInfo methods */

HRESULT STDMETHODCALLTYPE CComNoClassInfo::GetThreadingModel
(
    /* [out] */ ThreadingModel __RPC_FAR *pthreadmodel
)
{
    return(REGDB_E_CLASSNOTREG);
}


HRESULT STDMETHODCALLTYPE CComNoClassInfo::GetModulePath
(
    /* [in] */ CLSCTX clsctx,
    /* [out] */ WCHAR __RPC_FAR *__RPC_FAR *pwszDllName
)
{
    return(REGDB_E_CLASSNOTREG);
}


HRESULT STDMETHODCALLTYPE CComNoClassInfo::GetImplementedClsid
(
    /* [out] */ GUID __RPC_FAR *__RPC_FAR *ppguidClsid
)
{
    *ppguidClsid = &m_clsid;

    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComNoClassInfo::GetProcess
(
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv
)
{
    return(REGDB_E_CLASSNOTREG);
}


HRESULT STDMETHODCALLTYPE CComNoClassInfo::GetRemoteServerName
(
    /* [out] */ WCHAR __RPC_FAR *__RPC_FAR *pwszServerName
)
{
    return(REGDB_E_CLASSNOTREG);
}


HRESULT STDMETHODCALLTYPE CComNoClassInfo::GetLocalServerType
(
    /* [out] */ LocalServerType __RPC_FAR *pType
)
{
    return(REGDB_E_CLASSNOTREG);
}


HRESULT STDMETHODCALLTYPE CComNoClassInfo::GetSurrogateCommandLine
(
    /* [out] */ WCHAR __RPC_FAR *__RPC_FAR *pwszSurrogateCommandLine
)
{
    return(REGDB_E_CLASSNOTREG);
}


#if DBG
/* ICacheControl methods */

STDMETHODIMP_(ULONG) CComNoClassInfo::CacheAddRef(void)
{
    long cRef;

    cRef = InterlockedIncrement(&m_cRefCache);

    return(cRef);
}


STDMETHODIMP_(ULONG) CComNoClassInfo::CacheRelease(void)
{
    long cRef;

    cRef = InterlockedDecrement(&m_cRefCache);

    return(cRef);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\catalog\notify.cxx ===
/* notify.cxx */
#include <nt.h> 
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <ntregapi.h>


#include <windows.h>

#include <comdef.h>
#include <string.h>
#include "globals.hxx"

#include "notify.hxx"

#define NO_KEY ((void *) (1))


/*
 *  class CNotify
 */

CNotify::CNotify(void)
{
    m_hKey = NULL;
    m_hEvent = NULL;
}


CNotify::~CNotify()
{
    DeleteNotify();
}


#define IS_PREDEFINED_HKEY(h)	(((ULONG_PTR) (h)) & 0x80000000)

HRESULT STDMETHODCALLTYPE CNotify::CreateNotify
(
    HKEY hKeyParent,
    const WCHAR *pwszSubKeyName
)
{
    LONG res;

    DeleteNotify();

    if (IS_PREDEFINED_HKEY(hKeyParent) && ((pwszSubKeyName == NULL) || *pwszSubKeyName == '\0'))
    {
        res = CreateHandleFromPredefinedKey(hKeyParent, &m_hKey);
    }
    else
    {
    	res=RegOpenKeyW(hKeyParent, pwszSubKeyName, &m_hKey);
    }

	// PREfix says that RegOpenKeyW can make m_hKey NULL in low memory, and still
	// return ERROR_SUCCESS.  So we'll just code defensively here.
    if ((ERROR_SUCCESS!=res) || (m_hKey == NULL))
    {
        m_hKey = NULL;

        m_hEvent = NO_KEY;  /* no polling needed */

        goto failed;

        //Log(L"Created notify %08X with no key %ls\r\n", this, pwszSubKeyName);
    }
    else
    {
        m_hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (m_hEvent == NULL)
        {
            goto failed;
        }

        res=RegNotifyChangeKeyValue(m_hKey, TRUE,
                REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_CHANGE_LAST_SET,
                m_hEvent, TRUE);
        if (ERROR_SUCCESS!=res)
        {
            goto failed;
        }

        //Log(L"Created notify %08X on %ls\r\n", this, pwszSubKeyName);
    }

    return(S_OK);

failed:

    //Log(L"Create notify %08X on %ls FAILED\r\n", this, pwszSubKeyName);

    DeleteNotify();

    return(E_FAIL);
}


HRESULT STDMETHODCALLTYPE CNotify::DeleteNotify(void)
{
    if (m_hKey != NULL)
    {
	    RegCloseKey(m_hKey);
        m_hKey = NULL;
    }

    if ((m_hEvent != NULL) && (m_hEvent != NO_KEY))
    {
        CloseHandle(m_hEvent);
        m_hEvent = NULL;
    }

    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CNotify::QueryNotify
(
    int *pfChanged
)
{
    HRESULT hr;

    if (m_hEvent == NULL)
    {
        *pfChanged = TRUE;

        //Log(L"Notify %08X forced TRUE\r\n", this);
    }
    else if (m_hEvent == NO_KEY)
    {
        *pfChanged = FALSE;

        //Log(L"No key for notify %08X\r\n", this);
    }
    else
    {
        hr = WaitForSingleObject(m_hEvent, 0);
        if (hr == WAIT_OBJECT_0)
        {
            *pfChanged = TRUE;

            (void) ResetEvent (m_hEvent);
            hr = RegNotifyChangeKeyValue(m_hKey, TRUE,
                    REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_CHANGE_LAST_SET,
                    m_hEvent, TRUE);
            if (hr != ERROR_SUCCESS)
            {
                DeleteNotify();

                //Log(L"Re-set notify %08X FAILED\r\n", this);
            }

            //Log(L"Notify %08X advanced to %d\r\n", this, m_lInstance);
        }
        else if (hr == WAIT_TIMEOUT)
        {
            *pfChanged = FALSE;

            //Log(L"Notify %08X FALSE\r\n", this);
        }
        else
        {
            *pfChanged = TRUE;

            //Log(L"Unexpected wait return 0x%08X\r\n", hr);
        }
    }

    return(S_OK);
}


DWORD CNotify::RegKeyOpen(HKEY hKeyParent, LPCWSTR szKeyName, REGSAM samDesired, HKEY *phKey )
{
    NTSTATUS            Status;
    UNICODE_STRING      UnicodeString;
    OBJECT_ATTRIBUTES   OA;

    RtlInitUnicodeString(&UnicodeString, szKeyName);
    InitializeObjectAttributes(&OA, &UnicodeString, OBJ_CASE_INSENSITIVE, hKeyParent, NULL);

    Status = NtOpenKey((PHANDLE)phKey, samDesired, &OA);
    
    return RtlNtStatusToDosError( Status );
}


DWORD CNotify::CreateHandleFromPredefinedKey(HKEY hkeyPredefined, HKEY *hkeyNew)
{

    struct{
        HKEY hKey;
        LPWSTR wszKeyString;
    }KeyMapping[] = {

        {HKEY_CLASSES_ROOT,  L"\\REGISTRY\\MACHINE\\SOFTWARE\\CLASSES"},
        {HKEY_CURRENT_USER,  L"\\REGISTRY\\CURRENT_USER"},
        {HKEY_USERS,         L"\\REGISTRY\\USER"},
        {HKEY_LOCAL_MACHINE, L"\\REGISTRY\\MACHINE"},
    };

    for(int i = 0; i < sizeof(KeyMapping)/sizeof(*KeyMapping); i++)
    {

        if(KeyMapping[i].hKey == hkeyPredefined)
        {
            return RegKeyOpen(NULL, KeyMapping[i].wszKeyString, KEY_NOTIFY, hkeyNew );
        }
    }

    return ERROR_FILE_NOT_FOUND;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\catalog\regcat.cxx ===
/* regcat.cxx */

#include <windows.h>
#include <comdef.h>
#include <debnot.h>

#include "globals.hxx"

#include "catalog.h"        // from catalog.idl
#include "partitions.h"     // from partitions.idl
#include "partitions_i.c"   // from partitions.idl

#include "regcat.hxx"       // CComRegCatalog
#include "class.hxx"        // CComClassInfo
#include "process.hxx"      // CComProcessInfo
#include "noclass.hxx"      // CComNoClassInfo
#include "services.hxx"

#include "catdbg.hxx"



/*
 *  globals
 */

const WCHAR g_wszClsidTemplate[] = L"CLSID\\{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}";
const WCHAR g_wszAppidTemplate[] = L"AppID\\{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}";
const WCHAR g_wszTreatAs[] = L"TreatAs";
const WCHAR g_wszOle32[] = L"ole32.dll";

typedef HRESULT (__stdcall *pfnCFOC)(LPCWSTR, LPCLSID, BOOL);
pfnCFOC pfnCLSIDFromOle1Class = NULL;

/*
 *  (DLL export) GetRegCatalogObject()
 */

HRESULT __stdcall GetRegCatalogObject
(
    /* [in] */ REFIID riid,
    /* [out, iis_is(riid)] */ void ** ppv,
    /* [in] */ REGSAM regType
)
{
	CComRegCatalog *pRegCatalogObject;
    HRESULT hr = S_OK;

    *ppv = NULL;

    // Because the regcat object will be needing it, get pfnCLSIDFromOle1Class
    // Ignore failures.
    if (pfnCLSIDFromOle1Class == NULL)
    {
        HMODULE hOle32 = GetModuleHandle(g_wszOle32);
        if (hOle32)
        {
            pfnCLSIDFromOle1Class = (pfnCFOC)GetProcAddress(hOle32, "CLSIDFromOle1Class");
        }
    }

	pRegCatalogObject = new CComRegCatalog(regType);

    if ( pRegCatalogObject == NULL )
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {   
        pRegCatalogObject->AddRef();
        hr = pRegCatalogObject->QueryInterface(riid, ppv);
        pRegCatalogObject->Release();
    }

    return(hr);
};


/*
 *  class CComRegCatalog
 */
CComRegCatalog::CComRegCatalog(REGSAM regType)
{
    m_cRef      = 0;
    m_regType   = regType;
}


STDMETHODIMP CComRegCatalog::QueryInterface(
        REFIID riid,
        LPVOID FAR* ppvObj)
{
    *ppvObj = NULL;

    if ((riid == IID_IComCatalogInternal) || (riid == IID_IUnknown))
    {
        *ppvObj = (LPVOID) (IComCatalogInternal *) this;
    }

    if (*ppvObj != NULL)
    {
        ((LPUNKNOWN) *ppvObj)->AddRef();

        return NOERROR;
    }

    return(E_NOINTERFACE);
}


STDMETHODIMP_(ULONG) CComRegCatalog::AddRef(void)
{
    long cRef;

    cRef = InterlockedIncrement(&m_cRef);

    return(cRef);
}


STDMETHODIMP_(ULONG) CComRegCatalog::Release(void)
{
    long cRef;

    g_CatalogLock.AcquireWriterLock();

    cRef = InterlockedDecrement(&m_cRef);

    if ( cRef == 0 )
    {
		delete this;
    }

    g_CatalogLock.ReleaseWriterLock();

    return(cRef);
}


/* IComCatalogInternal methods */

HRESULT STDMETHODCALLTYPE CComRegCatalog::GetClassInfo
(
    /* [in] */ IUserToken *pUserToken,
    /* [in] */ REFGUID guidConfiguredClsid,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
    /* [in] */ void __RPC_FAR *pComCatalog
)
{
    HRESULT hr;
    LONG res;
    WCHAR wszClassString[45];
    WCHAR wszTreatAsString[100];
    const GUID *pGuid;
    GUID guidTreatAsCLSID;
    HKEY hKey;
    IComClassInfo *pClassInfo;
    long cbValue;
    int cTreatAsHops;
    HKEY hKeyRoot;

#define TREATAS_HOPS_MAX (50)

    *ppv = NULL;
    cTreatAsHops = 0;

    lstrcpyW(wszClassString, g_wszClsidTemplate);

    hr = REGDB_E_CLASSNOTREG;

    pGuid = &guidConfiguredClsid;

    if (pUserToken != NULL)
    {
        pUserToken->GetUserClassesRootKey(&hKeyRoot);
    }
    else
    {
        hKeyRoot = HKEY_CLASSES_ROOT;
    }

    if (hKeyRoot == NULL)
        return E_OUTOFMEMORY;

    do
    {
        GUIDToString(pGuid, wszClassString + 7);

        res=RegOpenKeyExW(hKeyRoot, wszClassString, 0,
						  KEY_READ | m_regType, &hKey);
        if (ERROR_SUCCESS!=res)
        {
            break;
        }

        cbValue = sizeof(wszTreatAsString);

        res = RegQueryValueW(hKey, g_wszTreatAs, wszTreatAsString, &cbValue);

        if ((ERROR_SUCCESS==res) &&
            ((cbValue / 2) >= 37) &&
            (CurlyStringToGUID(wszTreatAsString, &guidTreatAsCLSID) == TRUE))
        {
            RegCloseKey(hKey);

            pGuid = &guidTreatAsCLSID;
        }
        else
        {
            pClassInfo = (IComClassInfo *) new CComClassInfo(pUserToken, pGuid, wszClassString, hKey, m_regType);

            RegCloseKey(hKey);

            if (pClassInfo == NULL)
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            pClassInfo->AddRef();
            hr = pClassInfo->QueryInterface(riid, ppv);
            pClassInfo->Release();

            break;
        }

    } while (cTreatAsHops++ < TREATAS_HOPS_MAX);

	if (pUserToken)
        pUserToken->ReleaseUserClassesRootKey();

    return(hr);
}


HRESULT STDMETHODCALLTYPE CComRegCatalog::GetApplicationInfo
(
    /* [in] */ IUserToken *pUserToken,
    /* [in] */ REFGUID guidApplId,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
    /* [in] */ void __RPC_FAR *pComCatalog
)
{
    *ppv = NULL;

    return(E_FAIL);
}


HRESULT STDMETHODCALLTYPE CComRegCatalog::GetProcessInfo
(
    /* [in] */ IUserToken *pUserToken,
    /* [in] */ REFGUID guidProcess,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
    /* [in] */ void __RPC_FAR *pComCatalog
)
{
    HRESULT hr;
    LONG res;
    WCHAR wszAppidString[45];
    HKEY hKey;
    IComProcessInfo *pProcessInfo;
    HKEY hKeyRoot;

    *ppv = NULL;

    if (pUserToken != NULL)
    {
        pUserToken->GetUserClassesRootKey(&hKeyRoot);
    }
    else
    {
        hKeyRoot = HKEY_CLASSES_ROOT;
    }

    if (hKeyRoot == NULL)
        return E_OUTOFMEMORY;

    lstrcpyW(wszAppidString, g_wszAppidTemplate);
    GUIDToString(&guidProcess, wszAppidString + 7);

    res = RegOpenKeyExW(hKeyRoot, wszAppidString, 0, 
						KEY_READ | m_regType, &hKey);
    if (ERROR_SUCCESS==res)
    {
        pProcessInfo = (IComProcessInfo *) new CComProcessInfo(pUserToken, guidProcess, wszAppidString, hKey);
        if (pProcessInfo == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            pProcessInfo->AddRef();
            hr = pProcessInfo->QueryInterface(riid, ppv);
            pProcessInfo->Release();
        }

        RegCloseKey(hKey);
    }
    else
    {
        hr = E_FAIL;
    }

	if (pUserToken)
        pUserToken->ReleaseUserClassesRootKey();

    return(hr);
}

HRESULT STDMETHODCALLTYPE CComRegCatalog::GetServerGroupInfo
(
    /* [in] */ IUserToken *pUserToken,
    /* [in] */ REFGUID guidServerGroup,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
    /* [in] */ void __RPC_FAR *pComCatalog
)
{
    *ppv = NULL;

    return(E_FAIL);
}


HRESULT STDMETHODCALLTYPE CComRegCatalog::GetRetQueueInfo
(
    /* [in] */ IUserToken *pUserToken,
    /* [string][in] */ WCHAR __RPC_FAR *wszFormatName,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
    /* [in] */ void __RPC_FAR *pComCatalog
)
{
    *ppv = NULL;

    return(E_FAIL);
}


HRESULT STDMETHODCALLTYPE CComRegCatalog::GetApplicationInfoForExe
(
    /* [in] */ IUserToken *pUserToken,
    /* [string][in] */ WCHAR __RPC_FAR *pwszExeName,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
    /* [in] */ void __RPC_FAR *pComCatalog
)
{
    *ppv = NULL;

    return(E_FAIL);
}


HRESULT STDMETHODCALLTYPE CComRegCatalog::GetTypeLibrary
(
    /* [in] */ IUserToken *pUserToken,
    /* [in] */ REFGUID guidTypeLib,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
    /* [in] */ void __RPC_FAR *pComCatalog
)
{
    *ppv = NULL;

    return(E_NOTIMPL);  
}


HRESULT STDMETHODCALLTYPE CComRegCatalog::GetInterfaceInfo
(
    /* [in] */ IUserToken *pUserToken,
    /* [in] */ REFIID iidInterface,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
    /* [in] */ void __RPC_FAR *pComCatalog
)
{
    *ppv = NULL;

    return(E_NOTIMPL);  
}


HRESULT STDMETHODCALLTYPE CComRegCatalog::FlushCache(void)
{
    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComRegCatalog::GetClassInfoFromProgId
(
    /* [in] */ IUserToken __RPC_FAR *pUserToken,
    /* [in] */ WCHAR __RPC_FAR *pwszProgID,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
    /* [in] */ void __RPC_FAR *pComCatalog
)
{
    HRESULT hr;
    CLSID clsid;

    *ppv = NULL;

    // Classic implementation resides in OLE32, but answer the question
    // here so we can cache things.
    if (pfnCLSIDFromOle1Class)
    {
        hr = pfnCLSIDFromOle1Class(pwszProgID, &clsid, FALSE);
        if (SUCCEEDED(hr))
        {
            // If the catalog supports IComCatalogSCM then we'll use that, so we can
            // explicitly turn off CLSCTX validation, otherwise, we'll use IComCatalogInternal
            // and hope for the best.
            //
            IComCatalogSCM *pCCS = NULL;
            hr = ((IUnknown *)pComCatalog)->QueryInterface(IID_IComCatalogSCM, (void **)&pCCS);
            if (SUCCEEDED(hr))
            {
                hr = pCCS->GetClassInfo(0, pUserToken, clsid, riid, ppv);
                pCCS->Release();
            }
            else
            {            
                IComCatalogInternal *pCCI = NULL;
                hr = ((IUnknown *)pComCatalog)->QueryInterface(IID_IComCatalogInternal, (void **)&pCCI);
                Win4Assert(SUCCEEDED(hr) && "pComCatalog doesn't support IComCatalogInternal??");
            
                hr = pCCI->GetClassInfo(pUserToken, clsid, riid, ppv, pComCatalog);
                pCCI->Release();
            }

            if (hr != S_OK)
            {
                // pfnCLSIDFromOle1Class succeeded, but the class is not
                // actually registered.  Create a class info here that has
                // the CLSID and the ProgID right, but nothing else.
                //
                // This has interesting cache implications.  In this case,
                // the ClassInfo cache for GetClassInfo will have a failure
                // entry in it, which means that it will always check the
                // registry on the next access, while the cache for 
                // GetClassInfoFromProgId will have a success in it.  The
                // only saving grace here is that the catalog already treats
                // success from this function with suspicion, and so always
                // checks the registry for changes.
                if (*ppv)
                {
                     ((IUnknown *)(*ppv))->Release();
                     *ppv = NULL;
                }

                // Created with zero references...
                CComNoClassInfo *pNoClassInfo = new CComNoClassInfo(clsid, pwszProgID);
                if (pNoClassInfo)
                {
                    // Adds the first reference...
                    hr = pNoClassInfo->QueryInterface(riid, ppv);
                    if (hr != S_OK)
                    {
                        *ppv = NULL;
                        delete pNoClassInfo;
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        } 
        else 
        {
            // Put forward a kosher response.
            hr = REGDB_E_CLASSNOTREG;
        }
    }
    else
    {
        hr = E_NOTIMPL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\catalog\regmisc.c ===
#include <nt.h> 
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <ntregapi.h>

//HACKHACK: Stolen from registry redirector people, only for debug out.
BOOL
HandleToKeyName ( 
    HANDLE Key,
    PWCHAR KeyName,
    DWORD * dwLen
    )
/*++

Routine Description:

    Determine the text equivalent for key handle

Arguments:

    Key - is key handle for which to obtain its text
    KeyName - Unicode string to receive the Name of the key.
    dwLen   - Length of the buffer pointed by KeyName. (Number of unicode char)

Return Value:

    TRUE if the handle text is fetched OK.  FALSE if not (ie. error or
    Key is an illegal handle, etc.)

--*/
{
    NTSTATUS Status;
    ULONG Length;

    POBJECT_NAME_INFORMATION ObjectName;

    CHAR Buffer[sizeof(OBJECT_NAME_INFORMATION) +STATIC_UNICODE_BUFFER_LENGTH*2];
    ObjectName = (POBJECT_NAME_INFORMATION)Buffer;

    if (Key == NULL)
        return FALSE;

    Status = NtQueryObject(Key,
                       ObjectNameInformation,
                       ObjectName,
                       sizeof(Buffer),
                       &Length
                       );

    if (!NT_SUCCESS(Status) || !Length || Length >= sizeof(Buffer))
        return FALSE;

    //
    //  buffer overflow condition check
    //

    if (*dwLen < (ObjectName->Name.Length/sizeof(WCHAR) + 1) ) {
        *dwLen = 1 + ObjectName->Name.Length / sizeof(WCHAR) + 1;
        return FALSE;  //buffer overflow
    }

    wcsncpy(KeyName, ObjectName->Name.Buffer, ObjectName->Name.Length/sizeof(WCHAR));
    KeyName[ObjectName->Name.Length/sizeof(WCHAR)]=UNICODE_NULL;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\catalog\process.cxx ===
/* process.cxx */

#include <windows.h>
#include <comdef.h>
#include <string.h>
#include <winsafer.h>

#include "globals.hxx"

#include "catalog.h"
#include "partitions.h"
#include "process.hxx"
#include "noenum.hxx"
#include "services.hxx"

#include <debnot.h>
#include "catdbg.hxx"


const WCHAR g_wszRunAs[] = L"RunAs";
const WCHAR g_wszInteractive_User[] = L"Interactive User";
const WCHAR g_wszActivateAtStorage[] = L"ActivateAtStorage";
const WCHAR g_wszLaunchPermission[] = L"LaunchPermission";
const WCHAR g_wszAccessPermission[] = L"AccessPermission";
const WCHAR g_wszAuthenticationLevel[] = L"AuthenticationLevel";
const WCHAR g_wszHKLMOle[] = L"Software\\Microsoft\\OLE";
const WCHAR g_wszDefaultLaunchPermission[] = L"DefaultLaunchPermission";
const WCHAR g_wszDefaultAccessPermission[] = L"DefaultAccessPermission";
const WCHAR g_wszLegacyAuthenticationLevel[] = L"LegacyAuthenticationLevel";
const WCHAR g_wszLegacyImpersonationLevel[] = L"LegacyImpersonationLevel";
const WCHAR g_wszLocalService[] = L"LocalService";
const WCHAR g_wszServiceParameters[] = L"ServiceParameters";
const WCHAR g_wszDllSurrogate[] = L"DllSurrogate";
const WCHAR g_wszRemoteServerName[] = L"RemoteServerName";
const WCHAR g_wszSRPTrustLevel[] = L"SRPTrustLevel";

// The domain name to use if no domain name is specified in the RunAs key.
// We use . instead  of the local machine name because the local machine name
// does not work if we are on a Domain Controller, . works in all cases.

static WCHAR gpwszLocalMachineDomain[] = L".";


#define DELETE_PROCESS_STRING(p)                    \
    if (((p) != NULL) && ((p) != g_wszEmptyString)) \
    {                                               \
        delete (p);                                 \
    }


/*
 *  class CComProcessInfo
 */

CComProcessInfo::CComProcessInfo
    (
    IUserToken *pUserToken,
    REFGUID rclsid,
    WCHAR *pwszAppidString,
    HKEY hKey
    )
{
    HRESULT hr;
    LONG res;
    DWORD cbValue;
    DWORD cbService;
    DWORD cbParameters;
    DWORD cchValue;
    DWORD dwValueType;
    DWORD cchComputerName;
    WCHAR *pwch;
    WCHAR wszValue[256];
    WCHAR wszService[256];
    WCHAR wszParameters[256];
    WCHAR wszComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    HKEY hKeyOle;
    DWORD dwValue;
    DWORD dwCapabilities=0;

    m_cRef = 0;
#if DBG
    m_cRefCache = 0;
#endif
    m_guidProcessId = rclsid;
    m_pwszProcessName = NULL;
    m_pwszServiceName = NULL;
    m_pwszServiceParameters = NULL;
    m_pwszRunAsUser = NULL;
    m_pwszSurrogatePath = NULL;
    m_pLaunchPermission = NULL;
    m_pAccessPermission = NULL;

    m_pDefaultLaunchPermission = NULL;
    m_pDefaultAccessPermission = NULL;

    m_pwszRemoteServerName = NULL;
    m_dwFlags = 0;

    m_dwSaferTrustLevel = 0xFFFFFFFF;

    /* get m_pwszProcessName from default value */

    GetRegistryStringValue(hKey, NULL, NULL, RQ_ALLOWQUOTEQUOTE, &m_pwszProcessName);

    /* check for local service */

    hr = GetRegistryStringValue(hKey, NULL, g_wszLocalService, RQ_ALLOWQUOTEQUOTE, &m_pwszServiceName);
    if ( SUCCEEDED(hr) && m_pwszServiceName && *m_pwszServiceName )
    {
    m_eProcessType = ProcessTypeService;

    GetRegistryStringValue(hKey, NULL, g_wszServiceParameters, RQ_ALLOWQUOTEQUOTE, &m_pwszServiceParameters);
    }
    else
    {
    if ( m_pwszServiceName )
    {
        DELETE_PROCESS_STRING(m_pwszServiceName);
        m_pwszServiceName=NULL;
    }

    /* check for DLL surrogate */

    hr = GetRegistryStringValue(hKey, NULL, g_wszDllSurrogate, 0, &m_pwszSurrogatePath);
    if ( SUCCEEDED(hr) )
    {
        /* DLL surrogate */

        if ( m_pwszSurrogatePath == g_wszEmptyString )
        {
        m_eProcessType = ProcessTypeComPlus;
        }
        else
        {
        /* DllSurrogate value is present, use it */

        m_eProcessType = ProcessTypeLegacySurrogate;
        }
    }
    else
    {
        /* no DLL surrogate value */

        m_eProcessType = ProcessTypeNormal;
    }
    }

    m_eRunAsType = RunAsLaunchingUser;

    hr = ReadRegistryStringValue(hKey, NULL, g_wszRunAs, FALSE, wszValue, sizeof(wszValue)/2);
    if ( SUCCEEDED(hr) && (wszValue[0] != L'\0') )
    {
    if ( lstrcmpiW(wszValue, g_wszInteractive_User) == 0 )
    {
        m_eRunAsType = RunAsInteractiveUser;
    }
    else
    {
        m_eRunAsType = RunAsSpecifiedUser;

        cchValue = lstrlenW(wszValue);

        pwch = wszValue;

        while ( *pwch != L'\0' )
        {
        if ( *pwch == L'\\' )
        {
            break;
        }

        pwch++;
        }

        if ( *pwch == L'\0' )
        {
        m_pwszRunAsUser = (WCHAR *) new WCHAR[(sizeof(gpwszLocalMachineDomain)/sizeof(WCHAR)) + cchValue + 1];
        if ( m_pwszRunAsUser != NULL )
        {
            lstrcpyW(m_pwszRunAsUser, gpwszLocalMachineDomain);
            m_pwszRunAsUser[(sizeof(gpwszLocalMachineDomain)/sizeof(WCHAR))-1] = L'\\';
            lstrcpyW(m_pwszRunAsUser + (sizeof(gpwszLocalMachineDomain)/sizeof(WCHAR)), wszValue);
        }
        }
        else
        {
        m_pwszRunAsUser = (WCHAR *) new WCHAR[cchValue + 1];
        if ( m_pwszRunAsUser != NULL )
        {
            lstrcpyW(m_pwszRunAsUser, wszValue);
        }
        }
    }
    }

    m_fActivateAtStorage = FALSE;

    hr = ReadRegistryStringValue(hKey, NULL, g_wszActivateAtStorage, FALSE, wszValue, sizeof(wszValue)/2);
    if ( SUCCEEDED(hr) )
    {
    if ( (wszValue[0] == L'Y') || (wszValue[0] == L'y') )
    {
        m_fActivateAtStorage = TRUE;
    }
    }

    hr = GetRegistrySecurityDescriptor( hKey, g_wszLaunchPermission, &m_pLaunchPermission, NULL, &m_cbLaunchPermission);
    if ( SUCCEEDED(hr) )
    {
    m_dwFlags |= PROCESS_LAUNCHPERMISSION;
    }
    else if ( hr == REGDB_E_KEYMISSING )
    {
    m_dwFlags |= PROCESS_LAUNCHPERMISSION_DEFAULT;
    }

    dwCapabilities=0;
    hr = GetRegistrySecurityDescriptor( hKey, g_wszAccessPermission, &m_pAccessPermission, &dwCapabilities, &m_cbAccessPermission);
    if ( SUCCEEDED(hr) && dwCapabilities==0 )
    {
    m_dwFlags |= PROCESS_ACCESSPERMISSION;
    }
    else if ( hr == REGDB_E_KEYMISSING )
    {
    m_dwFlags |= PROCESS_ACCESSPERMISSION_DEFAULT;
    }

    if ( m_fGotLegacyLevels == FALSE )
    {
    g_CatalogLock.AcquireWriterLock();

    if ( m_fGotLegacyLevels == FALSE )
    {
        res=RegOpenKeyW(HKEY_LOCAL_MACHINE, g_wszHKLMOle, &hKeyOle);
        if ( ERROR_SUCCESS==res )
        {
        if ( m_pDefaultLaunchPermission != NULL )
        {
            delete m_pDefaultLaunchPermission;
        }

        if ( m_pDefaultAccessPermission != NULL )
        {
            delete m_pDefaultAccessPermission;
            m_pDefaultAccessPermission=NULL;
        }

        hr = GetRegistrySecurityDescriptor( hKeyOle, g_wszDefaultLaunchPermission, &m_pDefaultLaunchPermission, NULL, &m_cbDefaultLaunchPermission);
        if ( FAILED(hr) )
        {
            CatalogMakeSecDesc(&m_pDefaultLaunchPermission, NULL);
        }

        dwCapabilities=0;
        hr = GetRegistrySecurityDescriptor( hKeyOle, g_wszDefaultAccessPermission, &m_pDefaultAccessPermission, &dwCapabilities, &m_cbDefaultAccessPermission);
        if ( FAILED(hr) )
        {
            dwCapabilities=0;
            CatalogMakeSecDesc(&m_pDefaultAccessPermission, &dwCapabilities);
        }

        cbValue = sizeof(DWORD);

        res = RegQueryValueExW(hKeyOle, g_wszLegacyAuthenticationLevel, NULL, &dwValueType,
                       (unsigned char *) &dwValue, &cbValue);
        if ( (ERROR_SUCCESS==res) && (dwValueType == REG_DWORD) && (cbValue == sizeof(DWORD)) )
        {
            m_dwLegacyAuthenticationLevel = dwValue;
        }

        cbValue = sizeof(DWORD);

        res = RegQueryValueExW(hKeyOle, g_wszLegacyImpersonationLevel, NULL, &dwValueType,
                       (unsigned char *) &dwValue, &cbValue);
        if ( (ERROR_SUCCESS==res) && (dwValueType == REG_DWORD) && (cbValue == sizeof(DWORD)) )
        {
            m_dwLegacyImpersonationLevel = dwValue;
        }

        RegCloseKey(hKeyOle);
        }
    }

    g_CatalogLock.ReleaseWriterLock();
    }

    cbValue = sizeof(DWORD);

    res=RegQueryValueExW(hKey, g_wszAuthenticationLevel, NULL, &dwValueType, (unsigned char *) &m_dwAuthenticationLevel, &cbValue);
    if ( (ERROR_SUCCESS!=res ) || (dwValueType != REG_DWORD) || (cbValue != sizeof(m_dwAuthenticationLevel)) )
    {
    m_dwAuthenticationLevel = m_dwLegacyAuthenticationLevel;
    }

    GetRegistryStringValue(hKey, NULL, g_wszRemoteServerName, (RQ_MULTISZ | RQ_ALLOWQUOTEQUOTE), &m_pwszRemoteServerName);
	
    // Read SAFER trust level, if it's there
    DWORD dwTrustLevelTemp;
    cbValue = sizeof(DWORD);
    res = RegQueryValueExW(hKey, g_wszSRPTrustLevel, NULL, &dwValueType, (unsigned char *)&dwTrustLevelTemp, &cbValue);
    if ( (ERROR_SUCCESS==res ) && (dwValueType == REG_DWORD) && (cbValue == sizeof(dwTrustLevelTemp)) )
    {
        m_dwSaferTrustLevel = dwTrustLevelTemp;
        m_dwFlags |= PROCESS_SAFERTRUSTLEVEL;
    }
}


CComProcessInfo::~CComProcessInfo()
{
    DELETE_PROCESS_STRING(m_pwszProcessName);
    DELETE_PROCESS_STRING(m_pwszServiceName);
    DELETE_PROCESS_STRING(m_pwszServiceParameters);
    DELETE_PROCESS_STRING(m_pwszRunAsUser);
    DELETE_PROCESS_STRING(m_pwszSurrogatePath);
    DELETE_PROCESS_STRING(m_pwszRemoteServerName);

    if ( m_pLaunchPermission != NULL )
    {
    delete m_pLaunchPermission;
    }

    if ( m_pAccessPermission != NULL )
    {
    delete m_pAccessPermission;
    }
    if ( m_pDefaultLaunchPermission != NULL )
    {
    delete m_pDefaultLaunchPermission;
    }

    if ( m_pDefaultAccessPermission != NULL )
    {
    delete m_pDefaultAccessPermission;
    }
}


/* IUnknown methods */

STDMETHODIMP CComProcessInfo::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    *ppvObj = NULL;

    if ( riid == IID_IComProcessInfo )
    {
    *ppvObj = (LPVOID) (IComProcessInfo *) this;
    }
    else if ( riid == IID_IComProcessInfo2 )
    {
    *ppvObj = (LPVOID) (IComProcessInfo2 *) this;
    }
    else if ( riid == IID_IProcessServerInfo )
    {
    *ppvObj = (LPVOID) (IProcessServerInfo *) this;
    }
#if DBG
    else if ( riid == IID_ICacheControl )
    {
    *ppvObj = (LPVOID) (ICacheControl *) this;
    }
#endif
    else if ( riid == IID_IUnknown )
    {
    *ppvObj = (LPVOID) (IComProcessInfo *) this;
    }


    if ( *ppvObj != NULL )
    {
    ((LPUNKNOWN)*ppvObj)->AddRef();

    return NOERROR;
    }

    return(E_NOINTERFACE);
}


STDMETHODIMP_(ULONG) CComProcessInfo::AddRef(void)
{
    long cRef;

    cRef = InterlockedIncrement(&m_cRef);

    return(cRef);
}


STDMETHODIMP_(ULONG) CComProcessInfo::Release(void)
{
    long cRef;

    cRef = InterlockedDecrement(&m_cRef);

    if ( cRef == 0 )
    {
#if DBG
    //Win4Assert((m_cRefCache == 0) && "attempt to release an un-owned ProcessInfo object");
#endif

    delete this;
    }

    return(cRef);
}


/* IComProcessInfo methods */

HRESULT STDMETHODCALLTYPE CComProcessInfo::GetProcessId
    (
    /* [out] */ GUID __RPC_FAR *__RPC_FAR *ppguidProcessId
    )
{
    *ppguidProcessId = &m_guidProcessId;

    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComProcessInfo::GetProcessName
    (
    /* [out] */ WCHAR __RPC_FAR *__RPC_FAR *pwszProcessName
    )
{
    *pwszProcessName = m_pwszProcessName;

    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComProcessInfo::GetProcessType
    (
    /* [out] */ ProcessType __RPC_FAR *pType
    )
{
    *pType = m_eProcessType;

    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComProcessInfo::GetSurrogatePath
    (
    /* [out] */ WCHAR __RPC_FAR *__RPC_FAR *pwszSurrogatePath
    )
{
    *pwszSurrogatePath = m_pwszSurrogatePath;

    if ( m_pwszSurrogatePath != NULL )
    {
    return(S_OK);
    }
    else
    {
    return(E_FAIL);
    }
}


HRESULT STDMETHODCALLTYPE CComProcessInfo::GetServiceName
    (
    /* [out] */ WCHAR __RPC_FAR *__RPC_FAR *pwszServiceName
    )
{
    *pwszServiceName = m_pwszServiceName;

    if ( m_pwszServiceName != NULL )
    {
    return(S_OK);
    }
    else
    {
    return(E_FAIL);
    }
}


HRESULT STDMETHODCALLTYPE CComProcessInfo::GetServiceParameters
    (
    /* [out] */ WCHAR __RPC_FAR *__RPC_FAR *pwszServiceParameters
    )
{
    *pwszServiceParameters = m_pwszServiceParameters;

    if ( m_pwszServiceName != NULL )
    {
    return(S_OK);
    }
    else
    {
    return(E_FAIL);
    }
}


HRESULT STDMETHODCALLTYPE CComProcessInfo::GetActivateAtStorage
    (
    /* [out] */ BOOL __RPC_FAR *pfActivateAtStorage
    )
{
    *pfActivateAtStorage = m_fActivateAtStorage;

    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComProcessInfo::GetRunAsType
    (
    /* [out] */ RunAsType __RPC_FAR *pRunAsType
    )
{
    *pRunAsType = m_eRunAsType;

    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComProcessInfo::GetRunAsUser
    (
    /* [out] */ WCHAR __RPC_FAR *__RPC_FAR *pwszUserName
    )
{
    *pwszUserName = m_pwszRunAsUser;

    if ( m_pwszRunAsUser != NULL )
    {
    return(S_OK);
    }
    else
    {
    return(E_FAIL);
    }
}


HRESULT STDMETHODCALLTYPE CComProcessInfo::GetLaunchPermission
    (
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppsdLaunch,
    /* [out] */ DWORD __RPC_FAR *pdwDescriptorLength
    )
{
    if ( m_dwFlags & PROCESS_LAUNCHPERMISSION )
    {
    *ppsdLaunch = m_pLaunchPermission;
    *pdwDescriptorLength = m_cbLaunchPermission;
    }
    else if ( m_dwFlags & PROCESS_LAUNCHPERMISSION_DEFAULT )
    {
    *ppsdLaunch = m_pDefaultLaunchPermission;
    *pdwDescriptorLength = m_cbDefaultLaunchPermission;
    }
    else
    {
    *ppsdLaunch = NULL;
    *pdwDescriptorLength = 0;

    return(REGDB_E_INVALIDVALUE);
    }

    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComProcessInfo::GetAccessPermission
    (
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppsdAccess,
    /* [out] */ DWORD __RPC_FAR *pdwDescriptorLength
    )
{
#if 0
    if ( m_dwAuthenticationLevel == RPC_C_AUTHN_LEVEL_NONE )
    {
    *ppsdAccess = NULL;
    *pdwDescriptorLength = 0;
    }
    else if ( m_dwFlags & PROCESS_ACCESSPERMISSION )
    {
    *ppsdAccess = m_pAccessPermission;
    *pdwDescriptorLength = m_cbAccessPermission;
    }
    else if ( m_dwFlags & PROCESS_ACCESSPERMISSION_DEFAULT )
    {
    *ppsdAccess = m_pDefaultAccessPermission;
    *pdwDescriptorLength = m_cbDefaultAccessPermission;
    }
    else
    {
    *ppsdAccess = NULL;
    *pdwDescriptorLength = 0;

    return(REGDB_E_INVALIDVALUE);
    }
#else
    *ppsdAccess = (void **) &m_guidProcessId;
    *pdwDescriptorLength = sizeof(GUID);
#endif

    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComProcessInfo::GetAuthenticationLevel
    (
    /* [out] */ DWORD __RPC_FAR *pdwAuthnLevel
    )
{
    *pdwAuthnLevel = m_dwAuthenticationLevel;

    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComProcessInfo::GetImpersonationLevel
    (
    /* [out] */ DWORD __RPC_FAR *pdwImpLevel
    )
{
    *pdwImpLevel = m_dwLegacyImpersonationLevel;

    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComProcessInfo::GetAuthenticationCapabilities
    (
    /* [out] */ DWORD __RPC_FAR *pdwAuthenticationCapabilities
    )
{
    *pdwAuthenticationCapabilities = EOAC_APPID;

    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComProcessInfo::GetEndpoints
    (
    /* [out] */ DWORD __RPC_FAR *pdwNumEndpoints,
    /* [size_is][size_is][out] */ DCOM_ENDPOINT __RPC_FAR *__RPC_FAR *ppEndPoints
    )
{
    *pdwNumEndpoints = 0;

    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComProcessInfo::GetRemoteServerName
    (
    /* [out] */ WCHAR __RPC_FAR *__RPC_FAR *pwszServerName
    )
{
    *pwszServerName = m_pwszRemoteServerName;

    if ( m_pwszRemoteServerName != NULL )
    {
    return(S_OK);
    }
    else
    {
    return(E_FAIL);
    }
}


HRESULT STDMETHODCALLTYPE CComProcessInfo::SendsProcessEvents
    (
    /* [out] */ BOOL __RPC_FAR *pbSendsEvents
    )
{
    return(E_NOTIMPL);
}

HRESULT STDMETHODCALLTYPE CComProcessInfo::GetManifestLocation
	(
		/* [out] */ WCHAR** wszManifestLocation
	)
{
	return(E_NOTIMPL);
}

HRESULT STDMETHODCALLTYPE CComProcessInfo::GetSaferTrustLevel
	( 
		/* [out] */ DWORD* pdwSaferTrustLevel
	)
{
    HRESULT hr;
    
    if (m_dwFlags & PROCESS_SAFERTRUSTLEVEL)
    {
        *pdwSaferTrustLevel = m_dwSaferTrustLevel;
        hr = S_OK;
    }
    else
    {
        // If registry did not explicitly specify, then we will 
        // use the safer level of the .exe, in other places...
        hr = E_FAIL;
    }

    return hr;
}



/* IProcessServerInfo methods */

HRESULT STDMETHODCALLTYPE CComProcessInfo::GetShutdownIdleTime
    (
    /* [out] */ unsigned long __RPC_FAR *pulTime
    )
{
    *pulTime = 0;

    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComProcessInfo::GetCrmLogFileName
    (
    /* [out] */ WCHAR __RPC_FAR *__RPC_FAR *pwszFileName
    )
{
    return(E_FAIL);
}


HRESULT STDMETHODCALLTYPE CComProcessInfo::EnumApplications
    (
    /* [out] */ IEnumUnknown __RPC_FAR *__RPC_FAR *ppEnum
    )
{
    *ppEnum = new CNoEnum;
    if ( *ppEnum == NULL )
    {
    return(E_OUTOFMEMORY);
    }

    (*ppEnum)->AddRef();

    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComProcessInfo::EnumRetQueues
    (
    /* [out] */ IEnumUnknown __RPC_FAR *__RPC_FAR *ppEnum
    )
{
    *ppEnum = new CNoEnum;
    if ( *ppEnum == NULL )
    {
    return(E_OUTOFMEMORY);
    }

    (*ppEnum)->AddRef();

    return(S_OK);
}


#if DBG
/* ICacheControl methods */

STDMETHODIMP_(ULONG) CComProcessInfo::CacheAddRef(void)
{
    long cRef;

    cRef = InterlockedIncrement(&m_cRefCache);

    return(cRef);
}


STDMETHODIMP_(ULONG) CComProcessInfo::CacheRelease(void)
{
    long cRef;

    cRef = InterlockedDecrement(&m_cRefCache);

    return(cRef);
}
#endif

BOOL CComProcessInfo::m_fGotLegacyLevels = FALSE;
DWORD CComProcessInfo::m_dwLegacyAuthenticationLevel = RPC_C_AUTHN_LEVEL_CONNECT;
DWORD CComProcessInfo::m_dwLegacyImpersonationLevel = RPC_C_IMP_LEVEL_IDENTIFY;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\catalog\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=   catalog
TARGETPATH=   obj
TARGETTYPE=   LIBRARY

INCLUDES    = obj
INCLUDES=     $(INCLUDES);..\..\..\idl\public\daytona\$(O)
INCLUDES=     $(INCLUDES);..\..\..\idl\private\daytona
INCLUDES=     $(INCLUDES);..\..\..\idl\private\daytona\$(O)
INCLUDES=     $(INCLUDES);..\..\..\ih
INCLUDES=     $(INCLUDES);..\..\inc
INCLUDES=     $(INCLUDES);$(BASE_INC_PATH)


C_DEFINES=    $(C_DEFINES) -DDARWIN_ENABLED -DMSWMSG

SOURCES=      $(SOURCES)                                      \
              ..\cache.cxx                                    \
              ..\catalog.cxx                                  \
              ..\class.cxx                                    \
              ..\noclass.cxx                                  \
              ..\noenum.cxx                                   \
              ..\notify.cxx                                   \
              ..\process.cxx                                  \
              ..\regcat.cxx                                   \
              ..\services.cxx                                 \
              ..\sxscat.cxx                                   \
              ..\sxsclass.cxx                                 \
              ..\regmisc.c

UMTYPE=       windows
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\catalog\services.cxx ===
/* services.cxx */

#ifdef _WIN64
#include <ole2int.h> // Get OLE2INT_ROUND_UP
#endif

#include <comdef.h>
#include <string.h>
#include "globals.hxx"

#include "services.hxx"

#include "catdbg.hxx" // Support for tracing and logging

// Moved this from ole32\com\dcomrem\security.cxx

// Versions of the permissions in the registry.
const WORD COM_PERMISSION_SECDESC = 1;
const WORD COM_PERMISSION_ACCCTRL = 2;

// This leaves space for 8 sub authorities.  Currently NT only uses 6 and
// Cairo uses 7.
const DWORD SIZEOF_SID          = 44;

// This leaves space for 2 access allowed ACEs in the ACL.
const DWORD SIZEOF_ACL          = sizeof(ACL) + 2 * sizeof(ACCESS_ALLOWED_ACE) +
                                  2 * SIZEOF_SID;

const DWORD SIZEOF_TOKEN_USER   = sizeof(TOKEN_USER) + SIZEOF_SID;

const SID   LOCAL_SYSTEM_SID    = {SID_REVISION, 1, {0,0,0,0,0,5},
                                   SECURITY_LOCAL_SYSTEM_RID };

const SID   RESTRICTED_SID      = {SID_REVISION, 1, {0,0,0,0,0,5},
                                   SECURITY_RESTRICTED_CODE_RID };


// End security.cxx

HANDLE g_ProcessHeap = NULL;


//  abcdefgh-ijkl-mnop-qrst-uvwxyzABCDEF
//  0000000000111111111122222222223333333
//  0123456789012345678901234567890123456

//  00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15
//  gh ef cd ab kl ij op mn qr st uv wx yz AB CD EF

#define SEPARATOR1 (8)
#define SEPARATOR2 (13)
#define SEPARATOR3 (18)
#define SEPARATOR4 (23)

int guidByteToStringPosition[] =
{
#if defined(_X86_) || defined(_ALPHA_) || defined(_IA64_) || defined(_AMD64_)
    6, 4, 2, 0, 11, 9, 16, 14, 19, 21, 24, 26, 28, 30, 32, 34, -1
#else
#error Processor-specific code needed in services.cxx
#endif
};

//  {abcdefgh-ijkl-mnop-qrst-uvwxyzABCDEF}
//  000000000011111111112222222222333333333
//  012345678901234567890123456789012345678

#define CURLY_OPEN  (0)
#define CURLY_CLOSE (37)


void GUIDToString(const _GUID *pGuid, WCHAR *pwszString)
{
    int *pPosition = guidByteToStringPosition;
    BYTE *pGuidByte = (BYTE *) pGuid;
    WCHAR c;
    WCHAR *pchOut;
    BYTE b;

    while (*pPosition >= 0)
    {
        pchOut = pwszString + *pPosition++;
        b = *pGuidByte++;

        c = (WCHAR) ((b >> 4) & 0x0F) + '0';
        if (c > '9')
        {
            c += ('A' - '0' - 10);
        }

        *pchOut++ = c;

        c = (WCHAR) (b & 0x0F) + '0';
        if (c > '9')
        {
            c += ('A' - '0' - 10);
        }

        *pchOut = c;
    }

    pwszString[SEPARATOR1] = '-';
    pwszString[SEPARATOR2] = '-';
    pwszString[SEPARATOR3] = '-';
    pwszString[SEPARATOR4] = '-';
}


bool StringToGUID(const WCHAR *pwszString, _GUID *pGuid)
{
    int *pPosition = guidByteToStringPosition;
    BYTE *pGuidByte = (BYTE *) pGuid;
    WCHAR c;
    const WCHAR *pchIn;
    BYTE b;

    while (*pPosition >= 0)
    {
        pchIn = pwszString + *pPosition++;

        c = *pchIn++;

        if ((c >= '0') && (c <= '9'))
        {
            b = c - '0';
        }
        else if ((c >= 'A') && (c <= 'Z'))
        {
            b = c - 'A' + 10;
        }
        else if ((c >= 'a') && (c <= 'z'))
        {
            b = c - 'a' + 10;
        }
        else
        {
            return(FALSE);
        }

        b <<= 4;

        c = *pchIn++;

        if ((c >= '0') && (c <= '9'))
        {
            b |= (c - '0');
        }
        else if ((c >= 'A') && (c <= 'Z'))
        {
            b |= (c - 'A' + 10);
        }
        else if ((c >= 'a') && (c <= 'z'))
        {
            b |= (c - 'a' + 10);
        }
        else
        {
            return(FALSE);
        }

        *pGuidByte++ = b;
    }

    if ((pwszString[SEPARATOR1] != '-') ||
        (pwszString[SEPARATOR2] != '-') ||
        (pwszString[SEPARATOR3] != '-') ||
        (pwszString[SEPARATOR4] != '-'))
    {
        return(FALSE);
    }

    return(TRUE);
}


void GUIDToCurlyString(const _GUID *pGuid, WCHAR *pszString)
{
    pszString[CURLY_OPEN] = L'{';
    pszString[CURLY_CLOSE] = L'}';

    GUIDToString(pGuid, pszString + 1);
}


bool CurlyStringToGUID(const WCHAR *pszString, _GUID *pGuid)
{
    if ((pszString[CURLY_OPEN] == '{') &&
        (pszString[CURLY_CLOSE] == '}'))
    {
        return(StringToGUID(pszString + 1, pGuid));
    }
    else
    {
        return(FALSE);
    }
}

#define MAX_VALUE_CHARS (500)

const WCHAR g_wszEmptyString[] = L"\0";   /* an empty MULTI_SZ string */
const WCHAR g_wszQuoteQuote[] = L"\"\"";  /* a string consisting of two quotes */

HRESULT GetRegistryStringValue
(
    HKEY hParent,
    const WCHAR *pwszSubKeyName,
    const WCHAR *pwszValueName,
    DWORD dwQueryFlags,
    WCHAR **ppwszValue
)
{
    LONG res;
    HKEY hKey;
    LPWSTR pszValue = NULL;
    BOOL fMultiSz = dwQueryFlags & RQ_MULTISZ;
    BOOL fAllowQuoteQuote = dwQueryFlags & RQ_ALLOWQUOTEQUOTE;

    *ppwszValue = NULL;

#ifdef DBG
	if (CatalogInfoLevel & DEB_READREGISTRY)
	{
		LPWSTR pszValueDebug = new WCHAR[MAX_VALUE_CHARS + 2];

		if (NULL == pszValueDebug)
		{
			return E_OUTOFMEMORY;
		}

		// Sometimes we add two trailing NUL characters after the character array, so allocate 2 extra bytes

		DWORD cchValue = MAX_VALUE_CHARS ;			// character count

		BOOL ret = HandleToKeyName(hParent, pszValueDebug, &cchValue);
		
		CatalogDebugOut((DEB_READREGISTRY, 
						 "GetRegistryStringValue: %ws%ws%ws%ws%ws\n",
						 (ret ? pszValueDebug : L"???"),
						 (pwszSubKeyName ? L"\\" : L""),
						 (pwszSubKeyName ? pwszSubKeyName : L""),
						 (pwszValueName  ? L"\\" : L""),
						 (pwszValueName  ? pwszValueName  : L"")));

		delete [] pszValueDebug;
	}
#endif

    /* read value */

    if (pwszSubKeyName != NULL)
    {
        res = RegOpenKeyW(hParent, pwszSubKeyName, &hKey);
        if (ERROR_SUCCESS!=res)
        {
			HRESULT hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, res );
			CatalogDebugOut((DEB_READREGISTRY, "GetRegistryStringValue Fail RegOpenKeyW hr = 0x%08x\n", hr));
            return hr;
        }
    }
    else
    {
        hKey = hParent;
    }

    pszValue = new WCHAR[MAX_VALUE_CHARS + 2];

    if (NULL == pszValue)
    {
	return E_OUTOFMEMORY;
    }

    DWORD cbValue = sizeof(WCHAR) * MAX_VALUE_CHARS;
	DWORD dwValueType = REG_NONE;

    memset(pszValue, 0, cbValue);  // need to init buffer for rest of logic to work

    res = RegQueryValueExW(hKey, pwszValueName, NULL, &dwValueType, (unsigned char *) pszValue, &cbValue);

    if (pwszSubKeyName != NULL)
    {
        RegCloseKey(hKey);
    }

    if (ERROR_SUCCESS != res)
    {
		HRESULT hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, res );
		CatalogDebugOut((DEB_READREGISTRY, "GetRegistryStringValue Fail RegQueryValueEx hr = 0x%08x\n", hr));

		delete [] pszValue;
		return hr;
    }

    if (dwValueType == REG_NONE)
    {
        dwValueType = REG_SZ;
        cbValue = 0;
    }

    DWORD cchValue = MAX_VALUE_CHARS ;

    /* expand environment strings if indicated */

    if (dwValueType == REG_EXPAND_SZ)
    {
        pszValue[cchValue] = L'\0';

		LPWSTR pszValueTranslated = new WCHAR[MAX_VALUE_CHARS + 2];

		if (NULL == pszValueTranslated)
		{
			delete [] pszValue;
			return E_OUTOFMEMORY;
		}

        cchValue = ExpandEnvironmentStringsW( pszValue, pszValueTranslated, MAX_VALUE_CHARS);

		delete [] pszValue;
		pszValue = NULL;

        if ((cchValue == 0) || (cchValue > MAX_VALUE_CHARS))
        {
            return(REGDB_E_INVALIDVALUE);
        }

        dwValueType = REG_SZ;

        pszValue = pszValueTranslated;
    }

    /* make sure it's a string, or multi if allowed */

    if ((dwValueType != REG_SZ) && ((dwValueType != REG_MULTI_SZ) || !fMultiSz))
    {
        CatalogDebugOut((DEB_READREGISTRY, "GetRegistryStringValue hr = 0x%08x\n", REGDB_E_INVALIDVALUE));

        delete [] pszValue;
        return(REGDB_E_INVALIDVALUE);
    }


    /* trim appropriately */

    while ((cchValue >= 1) && (pszValue[cchValue - 1] == L'\0'))
    {
        cchValue--;     /* discard trailing NULs */
    }

    if (!fMultiSz)
    {
        while ((cchValue >= 1) && (pszValue[cchValue - 1] == L' '))
        {
            cchValue--; /* discard trailing blanks */
        }

        while ((cchValue >= 1) && (pszValue[0] == L' '))
        {
            cchValue--; /* discard leading blanks */
            pszValue++;
        }

///////////////////////////////////////////////////////////////////////////
//
//  NT #319961 - why did we ever strip quotes off those darn strings?
//
//        if ((cchValue >= 2) &&
//            (pszValue[0] == L'"') &&
//            (pszValue[cchValue - 1] == L'"'))
//        {
//            cchValue -= 2;  /* discard matching quotes */
//            pszValue++;
//        }
//
///////////////////////////////////////////////////////////////////////////

    }

    /* don't allocate empty strings; return static instance instead */
    if (cchValue == 0)
    {
        *ppwszValue = (WCHAR*)g_wszEmptyString;
        delete [] pszValue;
        return(S_OK);
    }

    // Some people put "" in the registry, caller can say he
    // doesn't want to accept them.
    if (!fAllowQuoteQuote)
    {
        if (!lstrcmpW(pszValue, g_wszQuoteQuote))
        {
            delete [] pszValue;
            return(REGDB_E_INVALIDVALUE);
        }
    }

    pszValue[cchValue++] = L'\0';       /* terminate REG_SZ */

    if (fMultiSz)
    {
        pszValue[cchValue++] = L'\0';  /* terminate REG_MULTI_SZ */
    }

    /* allocate & return copy of polished string */

    LPWSTR pwszResult = new WCHAR[cchValue];

    if (pwszResult == NULL)
    {
        CatalogDebugOut((DEB_READREGISTRY, "GetRegistryStringValue hr = 0x%08x\n", E_OUTOFMEMORY));
        delete [] pszValue;
        return(E_OUTOFMEMORY);
    }

    memcpy(pwszResult, pszValue, sizeof(WCHAR) * cchValue);

    *ppwszValue = pwszResult;

    delete [] pszValue;

    CatalogDebugOut((DEB_READREGISTRY, "GetRegistryStringValue returning %ws\n", pwszResult));

    return(S_OK);
}


HRESULT ReadRegistryStringValue
(
    HKEY hParent,
    const WCHAR *pwszSubKeyName,
    const WCHAR *pwszValueName,
    BOOL fMultiSz,
    WCHAR *pwszValueBuffer,
    DWORD cchBuffer
)
{
    LONG res;
    HKEY hKey;

#ifdef DBG
	if (CatalogInfoLevel & DEB_READREGISTRY)
	{
		LPWSTR pszValueDebug = new WCHAR[MAX_VALUE_CHARS + 2];
		
		if (NULL == pszValueDebug)
		{
			return E_OUTOFMEMORY;
		}

		DWORD cch = MAX_VALUE_CHARS;

		BOOL ret = HandleToKeyName(hParent, pszValueDebug, &cch);
		
		CatalogDebugOut((DEB_READREGISTRY, 
						 "ReadRegistryStringValue: %ws%ws%ws%ws%ws\n",
						 (ret ? pszValueDebug : L"???"),
						 (pwszSubKeyName ? L"\\" : L""),
						 (pwszSubKeyName ? pwszSubKeyName : L""),
						 (pwszValueName  ? L"\\" : L""),
						 (pwszValueName  ? pwszValueName  : L"")));

		delete [] pszValueDebug;
	}
#endif

    /* read value */

    if (pwszSubKeyName != NULL)
    {
        res = RegOpenKeyW(hParent, pwszSubKeyName, &hKey);
        if (ERROR_SUCCESS!=res)
        {
			HRESULT hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, res );
			CatalogDebugOut((DEB_READREGISTRY, "ReadRegistryStringValue Fail RegOpenKeyW hr = 0x%08x\n", hr));
            return hr;
        }
    }
    else
    {
        hKey = hParent;
    }

    DWORD cbValue = sizeof(WCHAR) * cchBuffer;
	DWORD dwValueType = REG_NONE;

    res=RegQueryValueExW(hKey, pwszValueName, NULL, &dwValueType, (unsigned char *) pwszValueBuffer, &cbValue);

    if (pwszSubKeyName != NULL)
    {
        RegCloseKey(hKey);
    }

    if (ERROR_SUCCESS!=res)
    {
		HRESULT hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, res );
		CatalogDebugOut((DEB_READREGISTRY, "ReadRegistryStringValue Fail RegQueryValueExW hr = 0x%08x\n", hr));
        return hr;
    }

    if (dwValueType == REG_NONE)
    {
        dwValueType = REG_SZ;
        cbValue = 0;
    }

    DWORD cchValue = cbValue / sizeof(WCHAR);

    /* expand environment strings if indicated */

    if (dwValueType == REG_EXPAND_SZ)
    {
        pwszValueBuffer[cchValue] = L'\0';

		LPWSTR pszValueTranslated = new WCHAR[MAX_VALUE_CHARS + 2];

		if (NULL == pszValueTranslated)
		{
			return E_OUTOFMEMORY;
		}

        cchValue = ExpandEnvironmentStringsW( pwszValueBuffer, pszValueTranslated, MAX_VALUE_CHARS);

        if ((cchValue == 0) || (cchValue > MAX_VALUE_CHARS))
        {
			delete [] pszValueTranslated;

            return(REGDB_E_INVALIDVALUE);
        }

        dwValueType = REG_SZ;

        memcpy(pwszValueBuffer, pszValueTranslated, sizeof(WCHAR) * (cchValue + 1));

		delete [] pszValueTranslated;
    }


    /* make sure it's a string, or multi if allowed */

    if ((dwValueType != REG_SZ) && ((dwValueType != REG_MULTI_SZ) || !fMultiSz))
    {
		CatalogDebugOut((DEB_READREGISTRY, "ReadRegistryStringValue hr = 0x%08x\n", REGDB_E_INVALIDVALUE));
        return(REGDB_E_INVALIDVALUE);
    }

    /* trim & terminate appropriately */

    while ((cchValue >= 1) && (pwszValueBuffer[cchValue - 1] == L'\0'))
    {
        cchValue--;
    }

    if (!fMultiSz)
    {
        while ((cchValue >= 1) && (pwszValueBuffer[cchValue - 1] == L' '))
        {
            cchValue--;
        }

        while ((cchValue >= 1) && (pwszValueBuffer[0] == L' '))
        {
            DWORD cch;
            WCHAR *p;

            cchValue--;

            for (cch = cchValue, p = pwszValueBuffer; cch > 0; cch--, p++)
            {
                *p = *(p+1);
            }
        }

        if ((cchValue >= 2) &&
            (pwszValueBuffer[0] == L'"') &&
            (pwszValueBuffer[cchValue - 1] == L'"'))
        {
            DWORD cch;
            WCHAR *p;

            cchValue -= 2;

            for (cch = cchValue, p = pwszValueBuffer; cch > 0; cch--, p++)
            {
                *p = *(p+1);
            }
        }

        pwszValueBuffer[cchValue++] = L'\0';
    }
    else
    {
        pwszValueBuffer[cchValue++] = L'\0';
        pwszValueBuffer[cchValue++] = L'\0';
    }

	CatalogDebugOut((DEB_READREGISTRY, "ReadRegistryStringValue returning %ws\n", pwszValueBuffer));
    return(S_OK);
}



HRESULT GetRegistrySecurityDescriptor
(
    /* [in] */  HKEY hKey,
    /* [in] */  const WCHAR *pValue,
    /* [out] */ SECURITY_DESCRIPTOR **ppSD,
    /* [out] */ DWORD *pCapabilities,
    /* [out] */ DWORD *pdwDescriptorLength
)
{
    DWORD   cbSD;
    DWORD   cbSD2;
    LONG    res;
    DWORD   dwType;
    SECURITY_DESCRIPTOR *pSD;
    WORD    wVersion=0;
    *ppSD = NULL;

    cbSD = 0;
    *pdwDescriptorLength = 0;

    res = RegQueryValueExW( hKey, pValue, NULL, &dwType, NULL, &cbSD );
    if (res == ERROR_FILE_NOT_FOUND)
    {
        return(REGDB_E_KEYMISSING);
    }
    else if (((res != ERROR_SUCCESS) && (res != ERROR_MORE_DATA)) ||
        (dwType != REG_BINARY) ||
        (cbSD < sizeof(WORD)))
    {
        return(REGDB_E_INVALIDVALUE);
    }

    cbSD2 = cbSD;

#ifdef _WIN64
    {
        DWORD deltaSize;

        deltaSize = sizeof( SECURITY_DESCRIPTOR ) - sizeof( SECURITY_DESCRIPTOR_RELATIVE );
        // Win4Assert (deltaSize < sizeof( SECURITY_DESCRIPTOR ));
        deltaSize = OLE2INT_ROUND_UP( deltaSize, sizeof(PVOID) );

        cbSD2 = cbSD2 + deltaSize;
    }
#endif // _WIN64

    pSD = (SECURITY_DESCRIPTOR *) new unsigned char[cbSD2];
    if (pSD == NULL)
    {
        return(E_OUTOFMEMORY);
    }

    res = RegQueryValueExW( hKey, pValue, NULL, &dwType, (unsigned char *) pSD, &cbSD );
    if (res != ERROR_SUCCESS)
    {
        delete pSD;

        return(REGDB_E_READREGDB);
    }

    //if (!pCapabilities)
    //{
        // LaunchPermission SD is being read: fix it up if necessary
        wVersion= *((WORD*) pSD);
        if ((wVersion == COM_PERMISSION_SECDESC) &&
            (cbSD >= sizeof(SECURITY_DESCRIPTOR)))
        {

#ifdef _WIN64
            if ( MakeAbsoluteSD2( pSD, &cbSD2 ) == FALSE )   {
                delete pSD;
                return(REGDB_E_INVALIDVALUE);
            }
#else  // !_WIN64

            pSD->Control &= ~SE_SELF_RELATIVE;

            pSD->Sacl = NULL;

            if (pSD->Dacl != NULL)
            {
                if ((cbSD < (sizeof(SECURITY_DESCRIPTOR) + sizeof(ACL))) ||
                    (cbSD < (((ULONG) pSD->Dacl) + sizeof(ACL))))
                {
                    delete pSD;

                    return(REGDB_E_INVALIDVALUE);
                }

                pSD->Dacl = (ACL *) (((BYTE *) pSD) + ((ULONG) pSD->Dacl));

                if (cbSD < (pSD->Dacl->AclSize + sizeof(SECURITY_DESCRIPTOR)))
                {
                    delete pSD;

                    return(REGDB_E_INVALIDVALUE);
                }
            }

            if ((pSD->Group == 0) ||
                (pSD->Owner == 0) ||
                (cbSD < (((ULONG) pSD->Group) + sizeof(SID))) ||
                (cbSD < (((ULONG) pSD->Owner) + sizeof(SID))))
            {
                delete pSD;

                return(REGDB_E_INVALIDVALUE);
            }

            pSD->Group = (SID *) (((BYTE *) pSD) + (ULONG) pSD->Group);
            pSD->Owner = (SID *) (((BYTE *) pSD) + (ULONG) pSD->Owner);

#endif // !_WIN64

        }
        else if (wVersion == COM_PERMISSION_ACCCTRL)
        {
            *pdwDescriptorLength = cbSD;
        }
        else
        {
            delete pSD;
            return (REGDB_E_INVALIDVALUE);
        }
    //}
    //else
    //{
    //    // pCapabilities !=NULL: AccessPermission being requested: don't fix it up
    //}

    *ppSD = pSD;

    return(S_OK);
}


//+-------------------------------------------------------------------
//
//  Function:   MakeSecDesc, private
//
//  Synopsis:   Make a security descriptor that allows the current user
//              and local system access.
//
//  NOTE: Compute the length of the sids used rather then using constants.
//
//--------------------------------------------------------------------
HRESULT CatalogMakeSecDesc( SECURITY_DESCRIPTOR **pSD, DWORD *pCapabilities)
{
    HRESULT            hr         = S_OK;
    ACL               *pAcl;
    DWORD              lSidLen;
    SID               *pGroup;
    SID               *pOwner;
    BYTE               aMemory[SIZEOF_TOKEN_USER];
    TOKEN_USER        *pTokenUser  = (TOKEN_USER *) &aMemory;
    HANDLE             hToken      = NULL;
    DWORD              lIgnore;
    HANDLE             hThread;

    //Win4Assert( *pSD == NULL );

    // Open the process's token.
    if (!OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY, &hToken ))
    {
        // If the thread has a token, remove it and try again.
        if (!OpenThreadToken( GetCurrentThread(), TOKEN_IMPERSONATE, TRUE,
                              &hThread ))
        {
            //Win4Assert( !"How can both OpenThreadToken and OpenProcessToken fail?" );
            return MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );
        }
        if (!SetThreadToken( NULL, NULL ))
        {
            hr =MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );
            CloseHandle( hThread );
            return hr;
        }
        if (!OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY, &hToken ))
            hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );
        SetThreadToken( NULL, hThread );
        CloseHandle( hThread );
        if (FAILED(hr))
            return hr;
    }

    // Lookup SID of process token.
    if (!GetTokenInformation( hToken, TokenUser, pTokenUser, sizeof(aMemory),
                                 &lIgnore ))
        goto last_error;

    // Compute the length of the SID.
    lSidLen = GetLengthSid( pTokenUser->User.Sid );
    //Win4Assert( lSidLen <= SIZEOF_SID );

    // Allocate the security descriptor.
    *pSD = (SECURITY_DESCRIPTOR *) new unsigned char[
                  sizeof(SECURITY_DESCRIPTOR) + 3*lSidLen + SIZEOF_ACL ];
    if (*pSD == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }
    pGroup = (SID *) (*pSD + 1);
    pOwner = (SID *) (((BYTE *) pGroup) + lSidLen);
    pAcl   = (ACL *) (((BYTE *) pOwner) + lSidLen);

    // Initialize a new security descriptor.
    if (!InitializeSecurityDescriptor(*pSD, SECURITY_DESCRIPTOR_REVISION))
        goto last_error;

    // Initialize a new ACL.
    if (!InitializeAcl(pAcl, SIZEOF_ACL, ACL_REVISION2))
        goto last_error;

    // Allow the current user access.
    if (!AddAccessAllowedAce( pAcl, ACL_REVISION2, COM_RIGHTS_EXECUTE,
                              pTokenUser->User.Sid))
        goto last_error;

    // Allow local system access.
    if (!AddAccessAllowedAce( pAcl, ACL_REVISION2, COM_RIGHTS_EXECUTE,
                              (void *) &LOCAL_SYSTEM_SID ))
        goto last_error;

    // TEMPORARY TEMPORARY TEMPORARY
    // Allow Restricted access.
    if (!AddAccessAllowedAce( pAcl, ACL_REVISION2, COM_RIGHTS_EXECUTE,
                              (void *) &RESTRICTED_SID ))
        goto last_error;
    // TEMPORARY TEMPORARY TEMPORARY

    // Add a new ACL to the security descriptor.
    if (!SetSecurityDescriptorDacl( *pSD, TRUE, pAcl, FALSE ))
        goto last_error;

    // Set the group.
    memcpy( pGroup, pTokenUser->User.Sid, lSidLen );
    if (!SetSecurityDescriptorGroup( *pSD, pGroup, FALSE ))
        goto last_error;

    // Set the owner.
    memcpy( pOwner, pTokenUser->User.Sid, lSidLen );
    if (!SetSecurityDescriptorOwner( *pSD, pOwner, FALSE ))
        goto last_error;

    // Check the security descriptor.
#if DBG==1
    if (!IsValidSecurityDescriptor( *pSD ))
    {
        //Win4Assert( !"COM Created invalid security descriptor." );
        goto last_error;
    }
#endif

    goto cleanup;
last_error:
    hr= MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );

cleanup:
    if (hToken != NULL)
        CloseHandle( hToken );
    if (FAILED(hr))
    {
        delete  *pSD;
        *pSD = NULL;
    }
    return hr;
}

DWORD Hash(const BYTE *pbKey, DWORD cbKey)
{
    DWORD hash;

    hash = (DWORD) -1;

    while (cbKey--)
    {
        hash ^= (hash << 3) ^ *pbKey++;
    }

    return(hash);
}

#ifdef COMREG_TRACE

HANDLE g_hFile=INVALID_HANDLE_VALUE;

HANDLE GetTraceFile()
{
    if (g_hFile==INVALID_HANDLE_VALUE)
    {
        DWORD dwPID=GetCurrentProcessId();
        char szPath[_MAX_PATH];
        WCHAR wszFileName[_MAX_PATH];
        HANDLE hFile=NULL;
        HANDLE hFilePrev=INVALID_HANDLE_VALUE;
        GetModuleFileNameA(NULL, szPath, sizeof(szPath));
        int i=lstrlenA(szPath);
        while (i>0 && szPath[i] != '\\')
        {
            i--;
        }
        if (szPath[i]=='\\')
            i++;
        wsprintfW(wszFileName, L"c:\\crlog\\cr_%04x_%hs.log", dwPID, (LPSTR) &szPath[i]);

        hFile=CreateFile(wszFileName, GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (hFile!=INVALID_HANDLE_VALUE)
        {
            if (g_hFile==INVALID_HANDLE_VALUE)
            {
                hFilePrev=(HANDLE) InterlockedExchange((LONG*) &g_hFile, (LONG) hFile);
            }
            if (hFilePrev!=INVALID_HANDLE_VALUE)
            {
                InterlockedExchange((LONG*) &g_hFile, (LONG) hFilePrev);
                CloseHandle(hFile);
                hFile=hFilePrev;
            }
            else
            {
                DWORD dwWritten=0;
                WriteFile(hFile, szPath, lstrlenA(szPath), &dwWritten, NULL);
                WriteFile(hFile, "\n\r", sizeof("\r\n")-1, &dwWritten, NULL);
                FlushFileBuffers(hFile);
            }
        }
    }
    return g_hFile;
}

LONG RegOpenKeyWTrace(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult)
{
#undef RegOpenKeyW
    LONG res=RegOpenKeyW(hKey, lpSubKey, phkResult);
    HANDLE hFile=GetTraceFile();
    if (hFile!=INVALID_HANDLE_VALUE)
    {
        DWORD dwWritten=0;
        char szBuffer[256];
        wsprintfA(szBuffer, "Open : %08x (%08x) - %08x \\ %S\r\n", *phkResult, res, hKey, lpSubKey);
        WriteFile(hFile, szBuffer, lstrlenA(szBuffer), &dwWritten, NULL);
        FlushFileBuffers(hFile);
    }
    return res;
}

LONG RegCloseKeyTrace(HKEY hKey)
{
#undef RegCloseKey
    LONG res=RegCloseKey(hKey);
    HANDLE hFile=GetTraceFile();
    if (hFile!=INVALID_HANDLE_VALUE)
    {
        DWORD dwWritten=0;
        char szBuffer[256];
        wsprintfA(szBuffer, "Close: %08x (%08x)\r\n", hKey, res);
        WriteFile(hFile, szBuffer, lstrlenA(szBuffer), &dwWritten, NULL);
        FlushFileBuffers(hFile);
    }
    return res;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\catalog\sxscat.cxx ===
typedef unsigned short USHORT;

#if defined(_NATIVE_WCHAR_T_DEFINED)
typedef wchar_t WCHAR;
#else
typedef unsigned short WCHAR;
#endif

typedef WCHAR *LPWSTR, *PWSTR;
typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
#ifdef MIDL_PASS
    [size_is(MaximumLength / 2), length_is((Length) / 2) ] USHORT * Buffer;
#else // MIDL_PASS
    PWSTR  Buffer;
#endif // MIDL_PASS
} UNICODE_STRING;
typedef UNICODE_STRING *PUNICODE_STRING;
typedef const UNICODE_STRING *PCUNICODE_STRING;
typedef long NTSTATUS;
/* sxscat.cxx */

#include <windows.h>
#include <comdef.h>

#include "globals.hxx"

#include "catalog.h"        // from catalog.idl
#include "partitions.h"     // from partitions.idl

#include "sxscat.hxx"       // CComSxSCatalog
#include "sxsclass.hxx"     // CComSxSClassInfo
#include "services.hxx"
#include <sxstypes.h>


/*
 *  globals
 */

CComSxSCatalog *g_pSxSCatalogObject = NULL;

/*
 *  (DLL export) GetSxSCatalogObject()
 */

HRESULT __stdcall GetSxSCatalogObject
(
    /* [in] */ REFIID riid,
    /* [out, iis_is(riid)] */ void ** ppv
)
{
    HRESULT hr;

    *ppv = NULL;

    g_CatalogLock.AcquireWriterLock();

    if ( g_pSxSCatalogObject == NULL )
    {
        g_pSxSCatalogObject = new CComSxSCatalog;
    }

    if ( g_pSxSCatalogObject == NULL )
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        g_pSxSCatalogObject->AddRef();
        hr = g_pSxSCatalogObject->QueryInterface(riid, ppv);
        if (0 == g_pSxSCatalogObject->Release())
        {
            g_pSxSCatalogObject = NULL;
        }
    }

    g_CatalogLock.ReleaseWriterLock();
    return(hr);
};


/*
 *  class CComSxSCatalog
 */

CComSxSCatalog::CComSxSCatalog(void)
{
    m_cRef = 0;
}


STDMETHODIMP CComSxSCatalog::QueryInterface(
        REFIID riid,
        LPVOID FAR* ppvObj)
{
    *ppvObj = NULL;

    if ((riid == IID_IComCatalogInternal) || (riid == IID_IUnknown))
    {
        *ppvObj = (LPVOID) (IComCatalogInternal *) this;
    }

    if (*ppvObj != NULL)
    {
        ((LPUNKNOWN) *ppvObj)->AddRef();

        return NOERROR;
    }

    return(E_NOINTERFACE);
}


STDMETHODIMP_(ULONG) CComSxSCatalog::AddRef(void)
{
    long cRef;

    cRef = InterlockedIncrement(&m_cRef);

    return(cRef);
}


STDMETHODIMP_(ULONG) CComSxSCatalog::Release(void)
{
    long cRef;

    g_CatalogLock.AcquireWriterLock();

    cRef = InterlockedDecrement(&m_cRef);

    if ( cRef == 0 )
    {
    g_pSxSCatalogObject = NULL;

    delete this;
    }

    g_CatalogLock.ReleaseWriterLock();

    return(cRef);
}


HRESULT STDMETHODCALLTYPE CComSxSCatalog::GetClassInfo
(
    /* [in] */ IUserToken *pUserToken,
    /* [in] */ REFGUID guidConfiguredClsid,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
    /* [in] */ void __RPC_FAR *pComCatalog
)
{
    HRESULT hr;
    IComClassInfo *pClassInfo;
    PCACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION pComServerRedirection = NULL;
    ACTCTX_SECTION_KEYED_DATA askd;

    askd.cbSize = sizeof(askd);

    if (!::FindActCtxSectionGuid(
                FIND_ACTCTX_SECTION_KEY_RETURN_HACTCTX,     // dwFlags
                NULL,                                       // lpExtensionGuid
                ACTIVATION_CONTEXT_SECTION_COM_SERVER_REDIRECTION,
                &guidConfiguredClsid,
                &askd))
    {
        const DWORD dwLastError = ::GetLastError();

        if ((dwLastError == ERROR_SXS_KEY_NOT_FOUND) ||
            (dwLastError == ERROR_SXS_SECTION_NOT_FOUND))
            return REGDB_E_CLASSNOTREG;

        return HRESULT_FROM_WIN32(dwLastError);
    }

    // Hey, we have one.  Let's do some validation...
    if ((askd.ulLength < sizeof(ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION)) ||
        (askd.ulDataFormatVersion != ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_FORMAT_WHISTLER))
    {
        ::ReleaseActCtx(askd.hActCtx);
        return REGDB_E_INVALIDVALUE;
    }

    pComServerRedirection = (PCACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION) askd.lpData;

    if ((pComServerRedirection->Size < sizeof(ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION)) ||
        (pComServerRedirection->Size > askd.ulLength) ||
        (pComServerRedirection->Flags != 0))
    {
        ::ReleaseActCtx(askd.hActCtx);
        return REGDB_E_INVALIDVALUE;
    }

    pClassInfo = (IComClassInfo *) new CComSxSClassInfo(
                askd.hActCtx,
                guidConfiguredClsid,
                pComServerRedirection,
                askd.ulLength,
                askd.lpSectionBase,
                askd.ulSectionTotalLength);
    if (pClassInfo == NULL)
    {
        ::ReleaseActCtx(askd.hActCtx);
        return E_OUTOFMEMORY;
    }

    ::ReleaseActCtx(askd.hActCtx);

    pClassInfo->AddRef();
    hr = pClassInfo->QueryInterface(riid, ppv);
    pClassInfo->Release();

    return hr;
}


HRESULT STDMETHODCALLTYPE CComSxSCatalog::GetApplicationInfo
(
    /* [in] */ IUserToken *pUserToken,
    /* [in] */ REFGUID guidApplId,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
    /* [in] */ void __RPC_FAR *pComCatalog
)
{
    *ppv = NULL;

    return(E_FAIL);
}


HRESULT STDMETHODCALLTYPE CComSxSCatalog::GetProcessInfo
(
    /* [in] */ IUserToken *pUserToken,
    /* [in] */ REFGUID guidProcess,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
    /* [in] */ void __RPC_FAR *pComCatalog
)
{
    *ppv = NULL;
    return E_FAIL;
}


HRESULT STDMETHODCALLTYPE CComSxSCatalog::GetProcessInfoInternal
(
    /* [in] */ IUserToken *pUserToken,
    /* [in] */ REFGUID guidProcess,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv
)
{
    *ppv = NULL;
    return E_FAIL;
}


HRESULT STDMETHODCALLTYPE CComSxSCatalog::GetServerGroupInfo
(
    /* [in] */ IUserToken *pUserToken,
    /* [in] */ REFGUID guidServerGroup,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
    /* [in] */ void __RPC_FAR *pComCatalog
)
{
    *ppv = NULL;
    return(E_FAIL);
}


HRESULT STDMETHODCALLTYPE CComSxSCatalog::GetRetQueueInfo
(
    /* [in] */ IUserToken *pUserToken,
    /* [string][in] */ WCHAR __RPC_FAR *wszFormatName,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
    /* [in] */ void __RPC_FAR *pComCatalog
)
{
    *ppv = NULL;

    return(E_FAIL);
}


HRESULT STDMETHODCALLTYPE CComSxSCatalog::GetApplicationInfoForExe
(
    /* [in] */ IUserToken *pUserToken,
    /* [string][in] */ WCHAR __RPC_FAR *pwszExeName,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
    /* [in] */ void __RPC_FAR *pComCatalog
)
{
    *ppv = NULL;

    return(E_FAIL);
}


HRESULT STDMETHODCALLTYPE CComSxSCatalog::GetTypeLibrary
(
    /* [in] */ IUserToken *pUserToken,
    /* [in] */ REFGUID guidTypeLib,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
    /* [in] */ void __RPC_FAR *pComCatalog
)
{
    *ppv = NULL;

    return(E_NOTIMPL);  //BUGBUG
}


HRESULT STDMETHODCALLTYPE CComSxSCatalog::GetInterfaceInfo
(
    /* [in] */ IUserToken *pUserToken,
    /* [in] */ REFIID iidInterface,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
    /* [in] */ void __RPC_FAR *pComCatalog
)
{
    *ppv = NULL;

    return(E_NOTIMPL);  //BUGBUG
}


HRESULT STDMETHODCALLTYPE CComSxSCatalog::FlushCache(void)
{
    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComSxSCatalog::GetClassInfoFromProgId
(
    /* [in] */ IUserToken __RPC_FAR *pUserToken,
    /* [in] */ WCHAR __RPC_FAR *pwszProgID,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv,
    /* [in] */ void __RPC_FAR *pComCatalog
)
{
    HRESULT hr;
    ACTCTX_SECTION_KEYED_DATA askd;
    PCACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION RedirectionData = NULL;
    GUID *ConfiguredClsid = NULL;

    askd.cbSize = sizeof(askd);

    if (ppv != NULL)
        *ppv = NULL;

    if (!::FindActCtxSectionStringW(
                FIND_ACTCTX_SECTION_KEY_RETURN_HACTCTX,     // dwFlags
                NULL,                                       // lpExtensionGuid
                ACTIVATION_CONTEXT_SECTION_COM_PROGID_REDIRECTION,
                pwszProgID,
                &askd))
    {
        const DWORD dwLastError = ::GetLastError();

        if ((dwLastError == ERROR_SXS_KEY_NOT_FOUND) ||
            (dwLastError == ERROR_SXS_SECTION_NOT_FOUND))
            return REGDB_E_CLASSNOTREG;

        return HRESULT_FROM_WIN32(dwLastError);
    }

    // If the blob returned doesn't have the right format/version identifier, or isn't
    // big enough to actually contain an ACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION
    // struct, bail.
    if ((askd.ulDataFormatVersion != ACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION_FORMAT_WHISTLER) ||
        (askd.ulLength < sizeof(ACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION)))
    {
        return REGDB_E_INVALIDVALUE;
    }

    RedirectionData = (PCACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION) askd.lpData;

    // If the blob's recorded header size isn't big enough (or thinks that it's larger than
    // the total blob size), or there are flags set that we don't know how to interpret
    // we have to bail.
    if ((RedirectionData->Size < sizeof(ACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION)) ||
        (RedirectionData->Size > askd.ulLength) ||
        (RedirectionData->Flags != 0))
    {
        return REGDB_E_INVALIDVALUE;
    }

    ConfiguredClsid = (GUID *) (((ULONG_PTR) askd.lpSectionBase) + RedirectionData->ConfiguredClsidOffset);

    // We now have the clsid; use our existing implementation of clsid->class info mapping.
    return this->GetClassInfo(pUserToken, *ConfiguredClsid, riid, ppv, pComCatalog);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\catalog\sxsclass.cxx ===
typedef unsigned short USHORT;

#if defined(_NATIVE_WCHAR_T_DEFINED)
typedef wchar_t WCHAR;
#else
typedef unsigned short WCHAR;
#endif
typedef WCHAR *LPWSTR, *PWSTR;
typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
#ifdef MIDL_PASS
    [size_is(MaximumLength / 2), length_is((Length) / 2) ] USHORT * Buffer;
#else // MIDL_PASS
    PWSTR  Buffer;
#endif // MIDL_PASS
} UNICODE_STRING;
typedef UNICODE_STRING *PUNICODE_STRING;
typedef const UNICODE_STRING *PCUNICODE_STRING;
typedef long NTSTATUS;
/* sxsclass.cxx */

#include <windows.h>
#include <appmgmt.h>
#include <comdef.h>
#include <string.h>
#include <stdio.h>

#include "globals.hxx"
#include "services.hxx"

#include "catalog.h"
#include "partitions.h"
#include "sxsclass.hxx"
#include "catalog.hxx"

#define STRLEN_WCHAR(s) ((sizeof((s)) / sizeof((s)[0])) -1)
#define STRLEN_OLE32DLL (STRLEN_WCHAR(g_wszOle32Dll))


#if 0               // Whistler#352094 Too Much Debug Spew in Checked Builds
#include <debnot.h>


class CComSxSClassInfoTracer
{
public:
    CComSxSClassInfoTracer(PCSTR pszFileName, int nLine, PCSTR pszFunctionName)
        : m_pszFileName(pszFileName), m_nLine(nLine), m_pszFunctionName(pszFunctionName)
    {
        char rgchBuffer[1024];
        _snprintf(rgchBuffer, sizeof(rgchBuffer) / sizeof(rgchBuffer[0]), "%s(%d): Entering %s\n", m_pszFileName, m_nLine, m_pszFunctionName);
        ::OutputDebugStringA(rgchBuffer);
    }

    ~CComSxSClassInfoTracer()
    {
        char rgchBuffer[1024];
        _snprintf(rgchBuffer, sizeof(rgchBuffer) / sizeof(rgchBuffer[0]), "%s(%d): Leaving %s\n", m_pszFileName, m_nLine, m_pszFunctionName);
        ::OutputDebugStringA(rgchBuffer);
    }

protected:
    PCSTR m_pszFileName;
    int m_nLine;
    PCSTR m_pszFunctionName;
};

#define TRACE_MEMBER_FUNCTION(_x) CComSxSClassInfoTracer __tracer(__FILE__, __LINE__, "CComSxSClassInfo::" #_x)
#else
#define TRACE_MEMBER_FUNCTION(_x) (#_x)
#endif


/*
 *  class CComSxSClassInfo
 */

CComSxSClassInfo::CComSxSClassInfo
    (
    HANDLE hActCtx,
    REFGUID rguidConfiguredClsid,
    PCACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION pData,
    ULONG ulDataLength,
    PVOID pBase,
    ULONG ulSectionLength
    )
{
    TRACE_MEMBER_FUNCTION(CComSxSClassInfo);

    m_cRef = 0;
#if DBG
    m_cRefCache = 0;
#endif
    m_cLocks = 0;
    m_cLocksExternal = 0;

    m_hActCtx = hActCtx;
    ::AddRefActCtx(m_hActCtx);
    m_pData = pData;
    m_ulDataLength = ulDataLength;
    m_pSectionBase = pBase;
    m_ulSectionLength = ulSectionLength;
    m_bufModulePath[0]= L'\0';
}


CComSxSClassInfo::~CComSxSClassInfo()
{
    TRACE_MEMBER_FUNCTION(~CComSxSClassInfo);

    ::ReleaseActCtx(m_hActCtx);
}


/* IUnknown methods */

STDMETHODIMP CComSxSClassInfo::QueryInterface(
                                          REFIID riid,
                                          LPVOID FAR* ppvObj)
{
    TRACE_MEMBER_FUNCTION(QueryInterface);

    *ppvObj = NULL;

    if ( riid == IID_IComClassInfo )
    {
        *ppvObj = (LPVOID) static_cast<IComClassInfo *>(this);
    }
    else if ( riid == IID_IClassClassicInfo )
    {
        *ppvObj = (LPVOID) static_cast<IClassClassicInfo *>(this);
    }
#if DBG
    else if ( riid == IID_ICacheControl )
    {
        *ppvObj = (LPVOID) static_cast<ICacheControl *>(this);
    }
#endif
    else if ( riid == IID_IUnknown )
    {
        *ppvObj = (LPVOID) static_cast<IComClassInfo *>(this);
    }

    if ( *ppvObj != NULL )
    {
        ((LPUNKNOWN)*ppvObj)->AddRef();

        return NOERROR;
    }

    return(E_NOINTERFACE);
}


STDMETHODIMP_(ULONG) CComSxSClassInfo::AddRef(void)
{
    TRACE_MEMBER_FUNCTION(AddRef);

    long cRef;

    cRef = InterlockedIncrement(&m_cRef);

    return(cRef);
}


STDMETHODIMP_(ULONG) CComSxSClassInfo::Release(void)
{
    TRACE_MEMBER_FUNCTION(Release);

    long cRef;

    cRef = InterlockedDecrement(&m_cRef);

    if ( cRef == 0 )
    {
#if DBG
        //Win4Assert((m_cRefCache == 0) && "attempt to release an un-owned ClassInfo object");
#endif
        delete this;
    }

    return(cRef);
}

/* IComClassInfo methods */

HRESULT STDMETHODCALLTYPE CComSxSClassInfo::GetConfiguredClsid
    (
    /* [out] */ GUID __RPC_FAR *__RPC_FAR *ppguidClsid
    )
{
    TRACE_MEMBER_FUNCTION(GetConfiguredClsid);

    *ppguidClsid = const_cast<GUID *>(&m_pData->ConfiguredClsid);
    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComSxSClassInfo::GetProgId
    (
    /* [out] */ WCHAR __RPC_FAR *__RPC_FAR *pwszProgid
    )
{
    TRACE_MEMBER_FUNCTION(GetProgId);

    // The existing COM implementation seems to just return a pointer to their own copy,
    // so we'll do the same...

    if (m_pData->ProgIdOffset != 0)
    {
        *pwszProgid = (PWSTR) (((ULONG_PTR) m_pData) + m_pData->ProgIdOffset);
        return S_OK;
    }

    *pwszProgid = NULL;
    return E_FAIL;
}


HRESULT STDMETHODCALLTYPE CComSxSClassInfo::GetClassName
    (
    /* [out] */ WCHAR __RPC_FAR *__RPC_FAR *pwszClassName
    )
{
    TRACE_MEMBER_FUNCTION(GetClassName);

    *pwszClassName = NULL;
    return E_FAIL;
}


HRESULT STDMETHODCALLTYPE CComSxSClassInfo::GetApplication
    (
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv
    )
{
    TRACE_MEMBER_FUNCTION(GetApplication);

    *ppv = NULL;
    return(E_FAIL);
}

HRESULT STDMETHODCALLTYPE CComSxSClassInfo::GetClassContext
    (
    /* [in] */ CLSCTX clsctxFilter,
    /* [out] */ CLSCTX __RPC_FAR *pclsctx
    )
{
    TRACE_MEMBER_FUNCTION(GetClassContext);

    *pclsctx = CLSCTX_INPROC_SERVER;
    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComSxSClassInfo::GetCustomActivatorCount
    (
    /* [in] */ ACTIVATION_STAGE activationStage,
    /* [out] */ unsigned long __RPC_FAR *pulCount
    )
{
    TRACE_MEMBER_FUNCTION(GetCustomActivatorCount);

    *pulCount = 0;
    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComSxSClassInfo::GetCustomActivatorClsids
    (
    /* [in] */ ACTIVATION_STAGE activationStage,
    /* [out] */ GUID __RPC_FAR *__RPC_FAR *prgguidClsid
    )
{
    TRACE_MEMBER_FUNCTION(GetCustomActivatorGuids);

    *prgguidClsid = NULL;
    return(E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE CComSxSClassInfo::GetCustomActivators
    (
    /* [in] */ ACTIVATION_STAGE activationStage,
    /* [out] */ ISystemActivator __RPC_FAR *__RPC_FAR *__RPC_FAR *prgpActivator
    )
{
    TRACE_MEMBER_FUNCTION(GetCustomActivators);

    *prgpActivator = NULL;
    return(S_FALSE);
}


HRESULT STDMETHODCALLTYPE CComSxSClassInfo::GetTypeInfo
    (
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv
    )
{
    TRACE_MEMBER_FUNCTION(GetTypeInfo);

    *ppv = NULL;
    return(E_NOTIMPL);        //BUGBUG
}


HRESULT STDMETHODCALLTYPE CComSxSClassInfo::IsComPlusConfiguredClass
    (
    /* [out] */ BOOL __RPC_FAR *pfComPlusConfiguredClass
    )
{
    TRACE_MEMBER_FUNCTION(IsComPlusConfiguredClass);

    *pfComPlusConfiguredClass = FALSE;

    return(S_OK);
}


/* IClassClassicInfo methods */

HRESULT STDMETHODCALLTYPE CComSxSClassInfo::GetThreadingModel
    (
    /* [out] */ ThreadingModel __RPC_FAR *pthreadmodel
    )
{
    TRACE_MEMBER_FUNCTION(GetThreadingModel);

    switch (m_pData->ThreadingModel)
    {
    case ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_APARTMENT:
        *pthreadmodel = ApartmentThreaded;
        break;

    case ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_FREE:
        *pthreadmodel = FreeThreaded;
        break;

    case ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_SINGLE:
        *pthreadmodel = SingleThreaded;
        break;

    case ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_BOTH:
        *pthreadmodel = BothThreaded;
        break;

    case ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_NEUTRAL:
        *pthreadmodel = NeutralThreaded;
        break;

    default:
        return REGDB_E_INVALIDVALUE;
    }

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CComSxSClassInfo::GetModulePath
    (
    /* [in] */ CLSCTX clsctx,
    /* [out] */ WCHAR __RPC_FAR *__RPC_FAR *pwszDllName
    )
{
    TRACE_MEMBER_FUNCTION(GetModulePath);

    *pwszDllName = NULL;

    /* make sure exactly one context is requested */

    if ( (clsctx & (clsctx - 1)) != 0 )
    {
        return(E_FAIL);
    }

    if (clsctx != CLSCTX_INPROC_SERVER)
        return E_FAIL;

    if (m_pData->ModuleOffset == 0)
        return E_FAIL;

    if (m_bufModulePath[0] == L'\0') 
    {
        //
        // find a full qualified filepath for the sxs redirected dll
        //
        WCHAR *pwsz = (PWSTR) (((ULONG_PTR) m_pSectionBase) + m_pData->ModuleOffset); // bare filename
        DWORD dwLen = SearchPathW(NULL, pwsz, NULL, STRLEN_WCHAR(m_bufModulePath), m_bufModulePath, NULL);
        if ((dwLen== 0) || (dwLen > STRLEN_WCHAR(m_bufModulePath)))
        {
            return HRESULT_FROM_WIN32(::GetLastError());
        }
    }

    *pwszDllName = m_bufModulePath;
    return S_OK;
}


HRESULT STDMETHODCALLTYPE CComSxSClassInfo::GetImplementedClsid
    (
    /* [out] */ GUID __RPC_FAR *__RPC_FAR *ppguidClsid
    )
{
    TRACE_MEMBER_FUNCTION(GetImplementedClsid);

    *ppguidClsid = const_cast<GUID *>(&m_pData->ImplementedClsid);
    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComSxSClassInfo::GetProcess
    (
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv
    )
{
    TRACE_MEMBER_FUNCTION(GetProcess);

    *ppv = NULL;
    return E_FAIL;
}


HRESULT STDMETHODCALLTYPE CComSxSClassInfo::GetRemoteServerName
    (
    /* [out] */ WCHAR __RPC_FAR *__RPC_FAR *pwszServerName
    )
{
    TRACE_MEMBER_FUNCTION(GetRemoteServerName);

    *pwszServerName = NULL;
    return E_FAIL;
}

HRESULT STDMETHODCALLTYPE CComSxSClassInfo::GetLocalServerType
    (
    /* [out] */ LocalServerType __RPC_FAR *pType
    )
{
    TRACE_MEMBER_FUNCTION(GetLocalServerType);

    return E_FAIL;
}


HRESULT STDMETHODCALLTYPE CComSxSClassInfo::GetSurrogateCommandLine
    (
    /* [out] */ WCHAR __RPC_FAR *__RPC_FAR *pwszSurrogateCommandLine
    )
{
    TRACE_MEMBER_FUNCTION(GetSurrogateCommandLine);

    *pwszSurrogateCommandLine = NULL;
    return E_FAIL;
}


HRESULT STDMETHODCALLTYPE CComSxSClassInfo::MustRunInClientContext
    (
    /* [out] */ BOOL __RPC_FAR *pbMustRunInClientContext
    )
{
    TRACE_MEMBER_FUNCTION(MustRunInClientContext);

    *pbMustRunInClientContext = FALSE;
    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComSxSClassInfo::GetVersionNumber
    (
    /* [out] */ DWORD __RPC_FAR *pdwVersionMS,
    /* [out] */ DWORD __RPC_FAR *pdwVersionLS
    )
{
    TRACE_MEMBER_FUNCTION(GetVersionNumber);

    return(E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE CComSxSClassInfo::Lock(void)
{
    TRACE_MEMBER_FUNCTION(Lock);

    /* Like GetClassesRoot, but defer actually opening the */
    /* key, in case this object is already fully rendered. */

    g_CatalogLock.AcquireWriterLock();

    m_cLocks++;
    m_cLocksExternal++;

    g_CatalogLock.ReleaseWriterLock();

    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CComSxSClassInfo::Unlock(void)
{
    TRACE_MEMBER_FUNCTION(Unlock);

    g_CatalogLock.AcquireWriterLock();

    if ( m_cLocksExternal != 0 )
    {
        m_cLocksExternal--;
    }

    g_CatalogLock.ReleaseWriterLock();

    return(S_OK);
}


#if DBG
/* ICacheControl methods */

STDMETHODIMP_(ULONG) CComSxSClassInfo::CacheAddRef(void)
{
    TRACE_MEMBER_FUNCTION(CacheAddRef);

    long cRef;

    cRef = InterlockedIncrement(&m_cRefCache);

    return(cRef);
}


STDMETHODIMP_(ULONG) CComSxSClassInfo::CacheRelease(void)
{
    TRACE_MEMBER_FUNCTION(CacheRelease);

    long cRef;

    cRef = InterlockedDecrement(&m_cRefCache);

    return(cRef);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\class\compapi.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       compapi.cxx
//
//  Contents:   API for the compobj dll
//
//  Classes:
//
//  Functions:
//
//  History:    31-Dec-93   ErikGav     Chicago port
//              28-Mar-94   BruceMa     CLSID_NULL undoes TreatAs emulation
//              20-Apr-94   Rickhi      CClassExtMap, commenting, cleanup
//              03-May-94   BruceMa     Corrected IsOle1Class w/ OLE 2.01
//              04-May-94   BruceMa     Conformed CoTreatAsClass to 16-bit OLE
//              12-Dec-94   BruceMa     Support CoGetClassPattern on Chicago
//              03-Jan-95   BruceMa     Support Chicago style pattern matching
//                                       on NT if CoInitialize has not been
//                                       called
//              28-Aug-95   MurthyS     StringFromGUID2 and StringFromGUID2A
//                                       no longer use sprintf or wsprintf
//              07-Sep-95   MurthyS     Only do validation in API rtns with
//                                       work done by worker routines.  Commonly
//                                       used (internally) worker routines moved
//                                       to common\ccompapi.cxx
//              04-Feb-96   BruceMa      Add per-user registry support
//              12-Nov-98   SteveSw     CLSIDFromProgID, CLSIDFromProgIDEx, and
//                                       ProgIDFromClSID implemented on top of
//                                       Catalog
//                                      CoGetClassVersion implemented
//
//----------------------------------------------------------------------------

#include <ole2int.h>

#include "ole1guid.h"
#include "pattbl.hxx"           // CProcessPatternTable
#include "pexttbl.hxx"          // CProcessExtensionTable
#include "objact.hxx"           // CheckDownloadRegistrySettings
#include <dbgpopup.hxx>
#include <tracelog.hxx>
#include <appmgmt.h>

// forward references

INTERNAL wCoMarshalHresult(IStream FAR* pstm, HRESULT hresult);
INTERNAL wCoUnmarshalHresult(IStream FAR* pstm, HRESULT FAR * phresult);

//+-------------------------------------------------------------------------
//
//  Function:   wCoMarshalHresult    (internal)
//
//  Synopsis:   writes an hresult into the stream
//
//  Arguments:  [pStm]    - the stream to write into
//              [hresult] - the hresult to write
//
//  Returns:    results from the write
//
//--------------------------------------------------------------------------
inline INTERNAL wCoMarshalHresult(IStream FAR* pstm, HRESULT hresult)
{
	return pstm->Write(&hresult,sizeof(hresult),NULL);
}


//+-------------------------------------------------------------------------
//
//  Function:   wCoUnMarshalHresult    (internal)
//
//  Synopsis:   reads an hresult from the stream
//
//  Arguments:  [pStm]    - the stream to write into
//              [hresult] - the hresult to write
//
//  Returns:    results from the write
//
//--------------------------------------------------------------------------
inline INTERNAL wCoUnmarshalHresult(IStream FAR* pstm, HRESULT FAR * phresult)
{
	SCODE sc;

	HRESULT hresult = pstm->Read(&sc,sizeof(sc),NULL);
	CairoleAssert((hresult == NOERROR)
				  && "CoUnmarshalHresult: Stream read error");
	if (hresult == NOERROR)
	{
		*phresult = sc;
	}

	return hresult;
}


//+-------------------------------------------------------------------------
//
//  Function:   wCoGetCallerTID (internal)
//
//  Synopsis:   gets the TID of the ORPC client that called us.
//
//  Arguments:  [pTIDCaller] - where to put the result.
//
//--------------------------------------------------------------------------
inline HRESULT wCoGetCallerTID(DWORD *pTIDCaller)
{
	HRESULT hr;
	COleTls tls(hr);

	if (SUCCEEDED(hr))
	{
		*pTIDCaller = tls->dwTIDCaller;
		return(tls->dwFlags & OLETLS_LOCALTID) ? S_OK : S_FALSE;
	}

	return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   wCoGetCurrentLogicalThreadId (internal)
//
//  Synopsis:   Gets the current logical thread id that this physical
//              thread is operating under. The current physical thread
//              takes on the logical tid of any client application that
//              makes an Rpc call into this app.  The function is exported
//              so that the tools infrastructure (conformance suite, logger,
//              etc) can use it.
//
//  Arguments:  [pguid] - where to return the logical thread id
//
//  Returns:    [S_OK]  - got the logical thread id
//              [E_OUTOFMEMORY] - cant allocate resources
//
//--------------------------------------------------------------------------
inline INTERNAL wCoGetCurrentLogicalThreadId(GUID *pguid)
{
	GUID *pguidTmp = TLSGetLogicalThread();
	if (pguidTmp != NULL)
	{
		*pguid = *pguidTmp;
		return S_OK;
	}

	return E_OUTOFMEMORY;
}

NAME_SEG(CompApi)
ASSERTDATA


CProcessPatternTbl      *g_pPatTbl = NULL;
CProcessExtensionTbl    *g_pExtTbl = NULL;

//
//  string constants used throughout this file
//

WCHAR wszInterfaceKey[]   = L"Interface\\";
ULONG ulInterfaceKeyLen   = ((sizeof(wszInterfaceKey)/sizeof(WCHAR))-1);

WCHAR wszClasses[]  = L"Software\\Classes\\";

WCHAR wszTreatAs[]        = L"TreatAs";
WCHAR wszAutoTreatAs[]    = L"AutoTreatAs";

WCHAR wszProxyStubClsid[] = L"\\ProxyStubClsid32";
WCHAR wszProxyStubClsid16[] = L"\\ProxyStubClsid";

extern WCHAR wszOle1Class[];	// defined in common\ccompapi.cxx

// Constant for inprocess marshaling - this s/b big enough to cover most
// cases since reallocations just waste time.
#define EST_INPROC_MARSHAL_SIZE 256

//+-------------------------------------------------------------------------
//
//  Function:   CoMarshalHresult    (public)
//
//  Synopsis:   writes an hresult into the stream
//
//  Arguments:  [pStm]    - the stream to write into
//              [hresult] - the hresult to write
//
//  Returns:    results from the write
//
//--------------------------------------------------------------------------
STDAPI CoMarshalHresult(IStream FAR* pstm, HRESULT hresult)
{
	OLETRACEIN((API_CoMarshalHresult, PARAMFMT("pstm= %p, hresult= %x"), pstm, hresult));
	CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IStream,(IUnknown **)&pstm);

	HRESULT hr;

	if (IsValidInterface(pstm))
	{
		hr = wCoMarshalHresult(pstm, hresult);

	}
	else
	{
		hr = E_INVALIDARG;
	}

	OLETRACEOUT((API_CoMarshalHresult, hr));
	return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   CoUnMarshalHresult    (public)
//
//  Synopsis:   reads an hresult from the stream
//
//  Arguments:  [pStm]    - the stream to write into
//              [hresult] - the hresult to write
//
//  Returns:    results from the write
//
//--------------------------------------------------------------------------
STDAPI CoUnmarshalHresult(IStream FAR* pstm, HRESULT FAR * phresult)
{
	HRESULT hr;
	OLETRACEIN((API_CoUnmarshalHresult, PARAMFMT("pstm= %p, phresult= %p"), pstm, phresult));
	CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IStream,(IUnknown **)&pstm);

	if (IsValidInterface(pstm) &&
		IsValidPtrOut(phresult, sizeof(*phresult)))
	{
		hr = wCoUnmarshalHresult(pstm, phresult);
	}
	else
	{
		hr = E_INVALIDARG;
	}

	OLETRACEOUT((API_CoUnmarshalHresult, hr));
	return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   CoGetCallerTID  (exported, but not in header files)
//
//  Synopsis:   gets the TID of the current calling application
//
//  Arguments:  [pTIDCaller] - where to return the caller TID
//
//  Returns:    [S_TRUE] - caller TID set, caller in SAME process
//              [S_FALSE] = caller TID set, caller in different process
//              [E_OUTOFMEMORY] - caller TID not set
//
//--------------------------------------------------------------------------
STDAPI CoGetCallerTID(DWORD *pTIDCaller)
{
	OLETRACEIN((API_CoGetCallerTID, PARAMFMT("pTIDCaller= %p"), pTIDCaller));
	HRESULT hr;

	if (IsValidPtrOut(pTIDCaller, sizeof(*pTIDCaller)))
	{
		hr = wCoGetCallerTID(pTIDCaller);
	}
	else
	{
		hr = E_INVALIDARG;
	}

	OLETRACEOUT((API_CoGetCallerTID, hr));
	return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   CoGetCurrentLogicalThreadId (exported, but not in header files)
//
//  Synopsis:   Gets the current logical thread id that this physical
//              thread is operating under. The current physical thread
//              takes on the logical tid of any client application that
//              makes an Rpc call into this app.  The function is exported
//              so that the tools infrastructure (conformance suite, logger,
//              etc) can use it.
//
//  Arguments:  [pguid] - where to return the logica thread id
//
//  Returns:    [S_OK]  - got the logical thread id
//              [E_OUTOFMEMORY] - cant allocate resources
//
//--------------------------------------------------------------------------
STDAPI CoGetCurrentLogicalThreadId(GUID *pguid)
{
	OLETRACEIN((API_CoGetCurrentLogicalThreadId, PARAMFMT("pguid= %p"), pguid));
	HRESULT hr;

	if (IsValidPtrOut(pguid, sizeof(*pguid)))
	{
		hr = wCoGetCurrentLogicalThreadId(pguid);
	}
	else
	{
		hr = E_INVALIDARG;
	}

	OLETRACEOUT((API_CoGetCurrentLogicalThreadId, hr));
	return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   StringFromGUID2     (public)
//
//  Synopsis:   converts GUID into {...} form without leading identifier;
//
//  Arguments:  [rguid] - the guid to convert
//              [lpszy] - buffer to hold the results
//              [cbMax] - sizeof the buffer
//
//  Returns:    amount of data copied to lpsz if successful
//              0 if buffer too small.
//
//--------------------------------------------------------------------------
STDAPI_(int)  StringFromGUID2(REFGUID rguid, LPWSTR lpsz, int cbMax)
{
	OLETRACECMNIN((API_StringFromGUID2, PARAMFMT("rguid= %I, lpsz= %p, cbMax= %d"),
				   &rguid, lpsz, cbMax));
	int iRet = 0;
	if ((&rguid != NULL) &&
		IsValidPtrIn(&rguid, sizeof(rguid)) &&
		IsValidPtrOut(lpsz, cbMax))
	{
		if (cbMax >= GUIDSTR_MAX)
		{
			iRet = wStringFromGUID2(rguid, lpsz, cbMax);
		}
	}


	OLETRACECMNOUTEX((API_StringFromGUID2, RETURNFMT("%d"), iRet));
	return iRet;
}

//+-------------------------------------------------------------------------
//
//  Function:   GUIDFromString    (private)
//
//  Synopsis:   parse above format;  always writes over *pguid.
//
//  Arguments:  [lpsz]  - the guid string to convert
//              [pguid] - guid to return
//
//  Returns:    TRUE if successful
//
//--------------------------------------------------------------------------
STDAPI_(BOOL) GUIDFromString(LPCWSTR lpsz, LPGUID pguid)
{

	if ((lpsz != NULL) &&
		IsValidPtrIn(lpsz, GUIDSTR_MAX) &&
		IsValidPtrOut(pguid, sizeof(*pguid)))
	{
		if (lstrlenW(lpsz) < (GUIDSTR_MAX - 1))
			return(FALSE);

		return(wGUIDFromString(lpsz, pguid));
	}
	return(FALSE);
}


//+-------------------------------------------------------------------------
//
//  Function:   StringFromCLSID (public)
//
//  Synopsis:   converts GUID into {...} form.
//
//  Arguments:  [rclsid] - the guid to convert
//              [lplpsz] - ptr to buffer for results
//
//  Returns:    NOERROR
//              E_OUTOFMEMORY
//
//--------------------------------------------------------------------------
STDAPI  StringFromCLSID(REFCLSID rclsid, LPWSTR FAR* lplpsz)
{
	OLETRACEIN((API_StringFromCLSID, PARAMFMT("rclsid= %I, lplpsz= %p"), &rclsid, lplpsz));
	HRESULT hr;

	if ((&rclsid != NULL) &&
		IsValidPtrIn(&rclsid, sizeof(rclsid)) &&
		IsValidPtrOut(lplpsz, sizeof(*lplpsz)))
	{
		hr = wStringFromCLSID(rclsid, lplpsz);
	}
	else
	{
		hr = E_INVALIDARG;
	}

	OLETRACEOUT((API_StringFromCLSID, hr));
	return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   CLSIDFromString (public)
//
//  Synopsis:   converts string {...} form int guid
//
//  Arguments:  [lpsz] - ptr to buffer for results
//              [lpclsid] - the guid to convert
//
//  Returns:    NOERROR
//              CO_E_CLASSSTRING
//
//--------------------------------------------------------------------------
STDAPI CLSIDFromString(LPWSTR lpsz, LPCLSID lpclsid)
{
	HRESULT hr;

	OLETRACEIN((API_CLSIDFromString, PARAMFMT("lpsz= %ws, lpclsid= %p"),
				lpsz, lpclsid));

//  Note:  Should be doing IsValidPtrIn(lpsz, CLSIDSTR_MAX) but can't because
//  what comes in might be a ProgId.

	if (IsValidPtrIn(lpsz, 1) &&
		IsValidPtrOut(lpclsid, sizeof(*lpclsid)))
	{
		hr = wCLSIDFromString(lpsz, lpclsid);
	}
	else
	{
		hr = E_INVALIDARG;
	}

	OLETRACEOUT((API_CLSIDFromString, hr));
	return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   CLSIDFromOle1Class      (public)
//
//  Synopsis:   translate Ole1Class into clsid
//
//  Arguments:  [lpsz] - ptr to buffer for results
//              [lpclsid] - the guid to convert
//
//  Returns:    NOERROR
//              E_INVALIDARG
//              CO_E_CLASSSTRING    (not ole1 class)
//              REGDB_E_WRITEREGDB
//
//--------------------------------------------------------------------------
STDAPI  CLSIDFromOle1Class(LPCWSTR lpsz, LPCLSID lpclsid, BOOL fForceAssign)
{
	if ((lpsz != NULL) &&
		IsValidPtrIn(lpsz,1) &&
		IsValidPtrOut(lpclsid, sizeof(*lpclsid)))
	{
		if (lpsz[0] == 0)
		{
			// NOTE - This check wasn't in shipped versions of this
			// code.  In prior versions the empty string would be passed
			// down into the guts of the 1.0 CLSID support and would
			// fail there with CO_E_CLASSSTRING.  That code path depended
			// on an assert being broken to function properly.  With that
			// assert fixed, this new check is required.

			*lpclsid = CLSID_NULL;
			return CO_E_CLASSSTRING;
		}


		return(wCLSIDFromOle1Class(lpsz, lpclsid, fForceAssign));
	}
	return(E_INVALIDARG);

}

//+---------------------------------------------------------------------------
//
//  Function:   Ole1ClassFromCLSID2
//
//  Synopsis:   translate CLSID into Ole1Class
//              REVIEW: might want to have CLSIDFromOle1Class instead of having
//              CLSIDFromString do the work.
//
//  Arguments:  [rclsid] --
//              [lpsz] --
//              [cbMax] --
//
//  Returns:
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI_(int) Ole1ClassFromCLSID2(REFCLSID rclsid, LPWSTR lpsz, int cbMax)
{
	if ((&rclsid != NULL) &&
		IsValidPtrIn(&rclsid, sizeof(rclsid)) &&
		IsValidPtrOut(lpsz, cbMax))
	{
		return(wOle1ClassFromCLSID2(rclsid, lpsz, cbMax));
	}
	return(E_INVALIDARG);
}

//+-------------------------------------------------------------------------
//
//  Function:   StringFromIID   (public)
//
//  Synopsis:   converts GUID into {...} form.
//
//  Arguments:  [rclsid] - the guid to convert
//              [lplpsz] - ptr to buffer for results
//
//  Returns:    NOERROR
//              E_OUTOFMEMORY
//
//--------------------------------------------------------------------------
STDAPI StringFromIID(REFIID rclsid, LPWSTR FAR* lplpsz)
{
	OLETRACEIN((API_StringFromIID, PARAMFMT("rclsid= %I, lplpsz= %p"), &rclsid, lplpsz));
	HRESULT hr = NOERROR;

	if ((&rclsid != NULL) &&
		IsValidPtrIn(&rclsid, sizeof(rclsid)) &&
		IsValidPtrOut(lplpsz, sizeof(*lplpsz)))
	{
		hr = wStringFromIID(rclsid, lplpsz);
	}
	else
	{
		hr = E_INVALIDARG;

	}

	OLETRACEOUT((API_StringFromIID, hr));
	return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IIDFromString   (public)
//
//  Synopsis:   converts string {...} form int guid
//
//  Arguments:  [lpsz]  - ptr to buffer for results
//              [lpiid] - the guid to convert
//
//  Returns:    NOERROR
//              CO_E_CLASSSTRING
//
//--------------------------------------------------------------------------
STDAPI IIDFromString(LPWSTR lpsz, LPIID lpiid)
{
	OLETRACEIN((API_IIDFromString, PARAMFMT("lpsz= %ws, lpiid= %p"), lpsz, lpiid));

	HRESULT hr = E_INVALIDARG;
	if (IsValidPtrIn(lpsz, IIDSTR_MAX) &&
		IsValidPtrOut(lpiid, sizeof(*lpiid)))
	{
		if ((lpsz == NULL) ||
			(lstrlenW(lpsz) == (IIDSTR_MAX - 1)))
		{
			hr = wIIDFromString(lpsz, lpiid);
		}

	}
	OLETRACEOUT((API_IIDFromString, hr));
	return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   CoIsOle1Class   (public)
//
//  Synopsis:   reads the Ole1Class entry in the registry for the given clsid
//
//  Arguments:  [rclsid]    - the classid to look up
//
//  Returns:    TRUE if Ole1Class
//              FALSE otherwise
//
//--------------------------------------------------------------------------
STDAPI_(BOOL) CoIsOle1Class(REFCLSID rclsid)
{
	if ((&rclsid != NULL) &&
		IsValidPtrIn(&rclsid, sizeof(rclsid)))
	{
		return(wCoIsOle1Class(rclsid));
	}
	return(FALSE);
}


//+-------------------------------------------------------------------------
//
//  Function:   ProgIDFromCLSID     (public)
//
//  Synopsis:   convert clsid into progid
//
//  Arguments:  [rclsid]    - the classid to look up
//              [pszProgID] - returned progid
//
//  Returns:    E_INVALIDARG, E_OUTOFMEMORY,
//              REGDB_E_CLASSNOTREG, REGDB_E_READREGDB
//
//--------------------------------------------------------------------------
STDAPI ProgIDFromCLSID(REFCLSID rclsid, LPWSTR FAR* ppszProgID)
{
	HRESULT hr = E_INVALIDARG;
	IComClassInfo* pICCI = NULL;

	if ((&rclsid != NULL) && ppszProgID != NULL &&
		IsValidPtrIn(&rclsid, sizeof(rclsid)) &&
		IsValidPtrOut(ppszProgID, sizeof(*ppszProgID)))
	{
		*ppszProgID = NULL;

		// Do not use Catalog for Ole1 clsids since it returns the Progid for
		// clsid of the TreatAs class instead of the queried clsid.
		if (!wCoIsOle1Class(rclsid))
		{
			hr = InitializeCatalogIfNecessary();

			if (SUCCEEDED(hr))
			{
				hr = gpCatalog->GetClassInfo (rclsid, IID_IComClassInfo, (void**) &pICCI);
			}

			if (SUCCEEDED(hr) && pICCI != NULL)
			{
				WCHAR* pszProgID = NULL;
 
				hr = pICCI->GetProgId( &pszProgID );

				if (SUCCEEDED(hr) && pszProgID != NULL)
				{
					*ppszProgID = UtDupString (pszProgID);
					hr = (*ppszProgID != NULL) ? S_OK : E_OUTOFMEMORY;
				}

				pICCI->Release();
			}
		}

		if (*ppszProgID == NULL && hr != E_OUTOFMEMORY)
		{
			hr = wkProgIDFromCLSID(rclsid, ppszProgID);
		}
	}

	return(hr);
}


//+-------------------------------------------------------------------------
//
//  Function:   CLSIDFromProgID     (public)
//
//  Synopsis:   convert progid into clsid
//
//  Arguments:  [pszProgID]  - the progid to convert
//              [pclsid]     - the returned classid
//
//  Returns:    E_INVALIDARG, CO_E_CLASSSTRING (not ole1 class)
//              REGDB_E_WRITEREGDB
//
//--------------------------------------------------------------------------
STDAPI  CLSIDFromProgID(LPCWSTR pszProgID, LPCLSID pclsid)
{
	HRESULT hr = E_INVALIDARG;

	if ((pszProgID != NULL) && (pclsid != NULL) &&
		IsValidPtrIn(pszProgID,1) &&
		IsValidPtrOut(pclsid, sizeof(*pclsid)))
	{
		*pclsid = CLSID_NULL;

		if (pszProgID[0] == 0)
		{
			hr = CO_E_CLASSSTRING;
		}
		else
		{
			IComClassInfo* pICCI = NULL;

			hr = InitializeCatalogIfNecessary();

			if ( SUCCEEDED(hr) )
			{
				hr = gpCatalog->GetClassInfoFromProgId ( (WCHAR *) pszProgID, IID_IComClassInfo, (void**) &pICCI);
			}

			if ( (hr == S_OK) && (pICCI != NULL) )
			{
				LPCLSID pTempClsid = NULL;
				hr = pICCI->GetConfiguredClsid( (GUID**) &pTempClsid );
				if ( pTempClsid == NULL )
				{
					hr = E_UNEXPECTED;
				}
				else
				{
					*pclsid = *pTempClsid;
				}
			}
            else
            {
                hr = CO_E_CLASSSTRING;
            }

            if (pICCI)
                pICCI->Release();

            //
            // REVIEW: Should not hit this path anymore, since RegCat knows
            // how to answer this question (and does so with CLSIDFromOle1Class)
            //
			// if ( FAILED(hr) )
			// {
            //     hr = CLSIDFromOle1Class(pszProgID, pclsid);
			// }            
		}
	}

	return(hr);
}

//+-------------------------------------------------------------------------
//
//  Function:   CoGetClassVersion     (public)
//
//  Synopsis:   fetch versions for a class
//
//  Arguments:  [pClassSpec]   - [in] identifies the class (must be a CLSID)
//              [pdwVersionMS] - [out] version info
//              [pdwVersoinLS] - [out] version info
//
//  Returns:    E_INVALIDARG   - if pClassSpec is not a CLSID
//              errors from InitializeCatalogIfNecessary
//              errors from GetClassInfo
//              errors from GetVersionNumber
//
//--------------------------------------------------------------------------
STDAPI  CoGetClassVersion(/* [in] */ uCLSSPEC *pClassSpec,
						  /* [out] */ DWORD* pdwVersionMS,
						  /* [out] */ DWORD* pdwVersionLS)
{
	HRESULT hr = S_OK;
	IComClassInfo* pICCI = NULL;

	if (pClassSpec == NULL || pClassSpec->tyspec != TYSPEC_CLSID ||
		pdwVersionMS == NULL || pdwVersionLS == NULL )
	{
		hr = E_INVALIDARG;
	}

	if ( SUCCEEDED(hr) )
	{
		*pdwVersionMS = *pdwVersionLS = 0;
		hr = InitializeCatalogIfNecessary();
	}

	if ( SUCCEEDED(hr) )
	{
		hr = gpCatalog->GetClassInfo ( pClassSpec->tagged_union.clsid, IID_IComClassInfo, (void**) &pICCI );
	}

	if ( SUCCEEDED(hr) && pICCI != NULL )
	{
		hr = pICCI->GetVersionNumber ( pdwVersionMS, pdwVersionLS );
		pICCI->Release();
	}

	return hr;
}

#ifdef DIRECTORY_SERVICE

//+-------------------------------------------------------------------------
//
//  Function:   CLSIDFromProgIDEx     (public)
//
//  Synopsis:   convert progid into clsid, trigger ClassStore download if necessary
//
//  Arguments:  [pszProgID]  - the progid to convert
//              [pclsid]     - the returned classid
//
//  Returns:    E_INVALIDARG, CO_E_CLASSSTRING (not ole1 class)
//              REGDB_E_WRITEREGDB
//
//--------------------------------------------------------------------------
STDAPI  CLSIDFromProgIDEx(LPCWSTR pszProgID, LPCLSID pclsid)
{
	HRESULT hr=CLSIDFromProgID(pszProgID, pclsid);

    // If the call failed, check our code download policy
    // and attempt to install the application if the latter allows downloads
	if (FAILED(hr) && CheckDownloadRegistrySettings())
	{
		INSTALLDATA InstallData;

		InstallData.Type = PROGID;
		InstallData.Spec.ProgId = (PWCHAR) pszProgID;

		InstallApplication( &InstallData );
		hr=CLSIDFromProgID(pszProgID, pclsid);
	}

	return hr;
}

#endif

//+-------------------------------------------------------------------------
//
//  Function:   CoOpenClassKey      (public)
//
//  Synopsis:   opens a registry key for specified class
//
//  Arguments:  [rclsid]    - the classid to look up
//              [pszProgID] - returned progid
//
//  Returns:    REGDB_CLASSNOTREG, REGDB_E_READREGDB
//
//--------------------------------------------------------------------------
STDAPI CoOpenClassKey(REFCLSID clsid, BOOL bOpenForWrite, HKEY *lphkeyClsid)
{
	if ((&clsid != NULL) &&
		IsValidPtrIn(&clsid, sizeof(clsid)) &&
		IsValidPtrOut(lphkeyClsid, sizeof(*lphkeyClsid)))
	{
		return(wRegOpenClassKey(clsid,KEY_READ | (bOpenForWrite ? KEY_WRITE : 0), lphkeyClsid));
	}
	return(E_INVALIDARG);
}

//+-------------------------------------------------------------------------
//
//  Function:   CoGetTreatAsClass   (public)
//
//  Synopsis:   get current treat as class if any
//
//  Arguments:  [clsidOld]  - the classid to look up
//              [pclsidNew] - returned classid
//
//  Returns:    S_OK when there is a TreatAs entry.
//              S_FALSE when there is no TreatAs entry.
//              REGDB_E_READREGDB or same as CLSIDFromString
//
//--------------------------------------------------------------------------
STDAPI  CoGetTreatAsClass(REFCLSID clsidOld, LPCLSID lpClsidNew)
{
	if ((&clsidOld != NULL) &&
		IsValidPtrIn(&clsidOld, sizeof(clsidOld)) &&
		IsValidPtrOut(lpClsidNew, sizeof(*lpClsidNew)))
	{
		return(wCoGetTreatAsClass(clsidOld, lpClsidNew));
	}
	return(E_INVALIDARG);
}


//+-------------------------------------------------------------------------
//
//  Function:   CoTreatAsClass      (public)
//
//  Synopsis:   set current treat as class if any
//
//  Arguments:  [clsidOld]  - the old classid to look up
//              [clsidNew]  - the new classid
//
//  Returns:    S_OK if successful
//              REGDB_E_CLASSNOTREG, REGDB_E_READREGDB, REGDB_E_WRITEREGDB
//
//--------------------------------------------------------------------------
STDAPI  CoTreatAsClass(REFCLSID clsidOld, REFCLSID clsidNew)
{
	if ((&clsidOld != NULL) &&
		(&clsidNew != NULL) &&
		IsValidPtrIn(&clsidOld, sizeof(clsidOld)) &&
		IsValidPtrIn(&clsidNew, sizeof(clsidNew)))
	{
		return(wCoTreatAsClass(clsidOld, clsidNew));
	}
	return(E_INVALIDARG);
}

//+-------------------------------------------------------------------------
//
//  Function:   CoMarshalInterThreadInterfaceInStream, public
//
//  Synopsis:   helper function to a marshaled buffer to be passed
//              between threads.
//
//  Arguments:  [riid]      - interface id
//              [pUnk]      - ptr to interface we want to marshal
//              [ppStm]     - stream we want to give back to caller
//
//  Returns:    NOERROR     - Stream returned
//              E_INVALIDARG - Input parameters are invalid
//              E_OUTOFMEMORY - memory stream could not be created.
//
//  Algorithm:  Validate pointers. Create a stream and finally marshal
//              the input interface into the stream.
//
//  History:    03-Nov-94   Ricksa       Created
//
//--------------------------------------------------------------------------
HRESULT CoMarshalInterThreadInterfaceInStream(
											 REFIID riid,
											 LPUNKNOWN pUnk,
											 LPSTREAM *ppStm)
{
	HRESULT hr = E_INVALIDARG;
	LPSTREAM pStm = NULL;

	// Validate parameters
	if ((&riid != NULL)
		&& IsValidPtrIn(&riid, sizeof(riid))
		&& IsValidInterface(pUnk)
		&& IsValidPtrOut(ppStm, sizeof(*ppStm)))
	{
		return(wCoMarshalInterThreadInterfaceInStream(riid, pUnk, ppStm));
	}
	return(E_INVALIDARG);
}





//+-------------------------------------------------------------------------
//
//  Function:   CoGetInterfaceAndReleaseStream, public
//
//  Synopsis:   Helper to unmarshal object from stream for inter-thread pass
//
//  Arguments:  [riid]      - interface id
//              [pStm]      - stream we want to give back to caller
//              [ppv]       - pointer for returned object
//
//  Returns:    NOERROR     - Unmarshaled object returned
//              E_OUTOFMEMORY - out of memory
//
//  Algorithm:  Validate the input parameters. Unmarshal the stream and
//              finally release the stream pointer.
//
//  History:    03-Nov-94   Ricksa       Created
//
//  Notes:      This always releases the input stream if stream is valid.
//
//--------------------------------------------------------------------------
HRESULT CoGetInterfaceAndReleaseStream(
									  LPSTREAM pstm,
									  REFIID riid,
									  LPVOID *ppv)
{
	// Validate parameters.
	if (IsValidInterface(pstm) &&
		(&riid != NULL) &&
		IsValidPtrIn(&riid, sizeof(riid)) &&
		IsValidPtrOut(ppv, sizeof(*ppv)))
	{
		return(wCoGetInterfaceAndReleaseStream(pstm, riid, ppv));
	}
	return(E_INVALIDARG);
}

// The real working section...worker routines.  Assume parameter
// validation has already been done and therefore can be used
// internally by COM, STG, SCM etc

WCHAR wszOle1Class[]      = L"Ole1Class";
WCHAR wszProgID[]         = L"ProgID";
WCHAR wszClassKey[]       = L"CLSID\\";
#define ulClassKeyLen     ((sizeof(wszClassKey)/sizeof(WCHAR))-1)

//+-------------------------------------------------------------------------
//
//  Function:   wIsInternalProxyStubIID  (internal)
//
//  Synopsis:   returns the proxystub clsid associated with the specified
//              interface IID.
//
//  Arguments:  [riid]      - the interface iid to lookup
//              [lpclsid]   - where to return the clsid
//
//  Returns:    S_OK if successfull
//              E_OUTOFMEMORY if interface is not an internal one.
//
//  Algorithm:  See if it is one of the standard format internal IIDs.
//              If it is not one of the Automation ones, return our internal
//              proxy clsid
//
//  History:    15-Feb-95   GregJen     create
//
//--------------------------------------------------------------------------
INTERNAL wIsInternalProxyStubIID(REFIID riid, LPCLSID lpclsid)
{
	DWORD *ptr = (DWORD *) lpclsid;
	HRESULT hr = E_OUTOFMEMORY;

	if (*(ptr+1) == 0x00000000 &&	//  all internal iid's have these
		*(ptr+2) == 0x000000C0 &&	//   common values
		*(ptr+3) == 0x46000000)
	{
		// make sure it is not an automation iid
		if ( *ptr < 0x00020400 )
		{
			memcpy( lpclsid, &CLSID_PSOlePrx32, sizeof(CLSID));
			hr = S_OK;
		}
	}

	return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   wCoTreatAsClass      (internal)
//
//  Synopsis:   set current treat as class if any
//
//  Arguments:  [clsidOld]  - the old classid to look up
//              [clsidNew]  - the new classid
//
//  Returns:    S_OK if successful
//              REGDB_E_CLASSNOTREG, REGDB_E_READREGDB, REGDB_E_WRITEREGDB
//
//--------------------------------------------------------------------------
INTERNAL  wCoTreatAsClass(REFCLSID clsidOld, REFCLSID clsidNew)
{
	TRACECALL(TRACE_REGISTRY, "wCoTreatAsClass");

	HRESULT   hresult = S_OK;
	HKEY      hkeyClsid = NULL;
	WCHAR     szClsid[VALUE_LEN];
	LONG      cb = sizeof(szClsid);
	CLSID     clsidNewTmp;

	// The class had better be registered
	hresult = wRegOpenClassKey (clsidOld, KEY_READ | KEY_WRITE, &hkeyClsid);
	if (hresult != S_OK)
	{
		return hresult;
	}

	// Save the new clsid because it's a const and we may write into it
	clsidNewTmp = clsidNew;

	// Convert the new CLSID to a string
	Verify(StringFromCLSID2(clsidNew, szClsid, sizeof(szClsid)) != 0);

	// If the new CLSID equals the old CLSID, then convert AutoTreatAs, if
	// any, to TreatAs.
	if (IsEqualCLSID(clsidOld, clsidNew))
	{
		if (RegQueryValue(hkeyClsid, wszAutoTreatAs, szClsid, &cb) ==
			ERROR_SUCCESS)
		{
			if (wCLSIDFromString(szClsid, &clsidNewTmp) != S_OK)
			{
				return REGDB_E_INVALIDVALUE;
			}
		}

		// If no AutoTreatAs, remove any TreatAs
		else
		{
			clsidNewTmp = CLSID_NULL;
		}
	}

	// Make sure the new CLSID is not an OLE 1 class
	if (CoIsOle1Class(clsidNew))
	{
		return E_INVALIDARG;
	}

	// If the new CLSID is CLSID_NULL, then undo the emulation
	if (IsEqualCLSID(clsidNewTmp, CLSID_NULL))
	{
		LONG err = RegDeleteKey(hkeyClsid, wszTreatAs);
		if (err != ERROR_SUCCESS)
		{
			hresult = REGDB_E_WRITEREGDB;
		}
		else
		{
			hresult = S_OK;
		}
		Verify (ERROR_SUCCESS == RegCloseKey(hkeyClsid));
		return hresult;
	}

	if (RegSetValue(hkeyClsid, wszTreatAs, REG_SZ, (LPWSTR) szClsid,
					lstrlenW(szClsid)) != ERROR_SUCCESS)
	{
		hresult = REGDB_E_WRITEREGDB;
	}

	Verify (ERROR_SUCCESS == RegCloseKey(hkeyClsid));
	return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function:   wCLSIDFromString (internal)
//
//  Synopsis:   converts string {...} form int guid
//
//  Arguments:  [lpsz] - ptr to buffer for results
//              [lpclsid] - the guid to convert
//
//  Returns:    NOERROR
//              CO_E_CLASSSTRING
//
//--------------------------------------------------------------------------
INTERNAL wCLSIDFromString(LPWSTR lpsz, LPCLSID lpclsid)
{

	if (lpsz == NULL)
	{
		*lpclsid = CLSID_NULL;
		return NOERROR;
	}
	if (*lpsz == 0)
	{
		return(CO_E_CLASSSTRING);
	}

	if (lpsz[0] != '{')
	{
		return wCLSIDFromOle1Class(lpsz, lpclsid);
	}

	return wGUIDFromString(lpsz,lpclsid)
	? NOERROR : CO_E_CLASSSTRING;

}

// translate CLSID into Ole1Class
// REVIEW: might want to have CLSIDFromOle1Class instead of having
// CLSIDFromString do the work.
INTERNAL_(int) wOle1ClassFromCLSID2(REFCLSID rclsid, LPWSTR lpsz, int cbMax)
{
	if (wRegQueryClassValue(rclsid, wszOle1Class, lpsz, cbMax) != ERROR_SUCCESS)
	{
		// Use lookup table
		return Ole10_StringFromCLSID (rclsid, lpsz, cbMax) == NOERROR
		? lstrlenW (lpsz) : 0;
	}
	return lstrlenW(lpsz);
}

//+-------------------------------------------------------------------------
//
//  Function:   wCLSIDFromOle1Class      (internal)
//
//  Synopsis:   translate Ole1Class into clsid
//
//  Arguments:  [lpsz] - ptr to buffer for results
//              [lpclsid] - the guid to convert
//
//  Returns:    NOERROR
//              E_INVALIDARG
//              CO_E_CLASSSTRING    (not ole1 class)
//              REGDB_E_WRITEREGDB
//
//--------------------------------------------------------------------------
INTERNAL  wCLSIDFromOle1Class(LPCWSTR lpsz, LPCLSID lpclsid, BOOL fForceAssign)
{
	// lookup lpsz\\clsid and call CLSIDFromString on the result;
	// in a pathological case, this could infinitely recurse.
	HRESULT hr;
	WCHAR  sz[256];
	LONG cbValue = sizeof(sz);
	HKEY hkProgID;
	DWORD dwType;

	if (lpsz == NULL)
	{
		return(E_INVALIDARG);
	}

	if (*lpsz == 0)
	{
		return(CO_E_CLASSSTRING);
	}

	hr = wRegOpenProgIDKey(lpsz, &hkProgID);
	if (SUCCEEDED(hr))
	{
		if (RegQueryValue(hkProgID, L"CLSID", sz, &cbValue) != ERROR_SUCCESS)
		{
            // Attempt to go to the current version...
            WCHAR *szCurVer = NULL;
            if (RegQueryValue(hkProgID, L"CurVer", NULL, &cbValue) == ERROR_SUCCESS)
            {
                szCurVer = (WCHAR *)alloca(cbValue);
                if (RegQueryValue(hkProgID, L"CurVer", szCurVer, &cbValue) == ERROR_SUCCESS)
                {
                    // Recurse on the current version.
                    if (lstrcmpiW(szCurVer, lpsz) != 0)
                    {
                        RegCloseKey(hkProgID);
                        
                        return wCLSIDFromOle1Class(szCurVer, lpclsid, fForceAssign);
                    }
                }
            }

            // Just a failure code so we don't return immediately.
            hr = E_FAIL; 
		}
		RegCloseKey(hkProgID);
	}

	if (SUCCEEDED(hr))
	{
		hr = wCLSIDFromString(sz, lpclsid);
	}
	else
	{
		// Use lookup table or hash string to create CLSID for OLE 1 class.
		hr = Ole10_CLSIDFromString (lpsz, lpclsid, fForceAssign);
	}

	return hr;
}



//+-------------------------------------------------------------------------
//
//  Function:   wCoGetTreatAsClass   (internal)
//
//  Synopsis:   get current treat as class if any
//
//  Arguments:  [clsidOld]  - the classid to look up
//              [pclsidNew] - returned classid
//
//  Returns:    S_OK when there is a TreatAs entry.
//              S_FALSE when there is no TreatAs entry.
//              REGDB_E_READREGDB or same as CLSIDFromString
//
//--------------------------------------------------------------------------
INTERNAL  wCoGetTreatAsClass(REFCLSID clsidOld, LPCLSID lpClsidNew)
{
	TRACECALL(TRACE_REGISTRY, "wCoGetTreatAsClass");

	// lookup HKEY_CLASSES_ROOT\CLSID\{rclsid}\TreatAs

	HRESULT hresult;
	HKEY    hkeyClsid = NULL;
	WCHAR   szClsid[VALUE_LEN];
	LONG    cb = sizeof(szClsid);

	VDATEPTROUT (lpClsidNew, CLSID);

	hresult = wRegOpenClassKey (clsidOld, KEY_READ, &hkeyClsid);
	if (hresult != NOERROR)
	{
		// same as no TreatAs case below
		*lpClsidNew = clsidOld;
		return S_FALSE;
	}

	CairoleDebugOut((DEB_REG, "RegQueryValue(%ws)\n", wszTreatAs));

	// Fetch the TreatAs class from the registry
	if (RegQueryValue(hkeyClsid, wszTreatAs, szClsid, &cb) == ERROR_SUCCESS)
	{
		hresult = wCLSIDFromString(szClsid, lpClsidNew);
	}

	// There is no TreatAs
	else
	{
		*lpClsidNew = clsidOld;
		hresult = S_FALSE;
	}

	Verify (ERROR_SUCCESS==RegCloseKey(hkeyClsid));
	return hresult;
}
//+-------------------------------------------------------------------------
//
//  Function:   wRegQueryPSClsid     (private)
//
//  Synopsis:   reads the proxystub clsid entry out of the registry.
//
//  Arguments:  [riid]      - the interface iid to lookup
//              [lpclsid]   - where to return the clsid
//
//  Returns:    S_OK if successfull
//              REGDB_E_IIDNOTREG if interface is not registered.
//              REGDB_E_READREGDB if any other error
//
//  Notes:      this is an internal function used only if the requested IID
//              entry is not in the shared memory table and the table is full.
//
//  History:    07-Apr-94   Rickhi      extracted from original source
//              04-Feb-96   BruceMa     Per-user registry support
//
//--------------------------------------------------------------------------
INTERNAL wRegQueryPSClsid(REFIID riid, LPCLSID lpclsid)
{
	// lookup HKEY_CLASSES_ROOT\Interface\{iid}\ProxyStubClsid

	HRESULT hr = REGDB_E_IIDNOTREG;
	WCHAR szValue[VALUE_LEN];
	ULONG cbValue = sizeof(szValue);
	HKEY hkInterface;
	HKEY  hIf;
	DWORD dwType;
	int err;

	hr = wRegOpenInterfaceKey(riid, &hkInterface);
	if (SUCCEEDED(hr))
	{
		err = RegOpenKeyEx(hkInterface, L"ProxyStubClsid32", NULL, KEY_READ, &hIf);
		if (ERROR_SUCCESS == err)
		{
			// The unnamed value is the clsid for this iid
			err = RegQueryValueEx(hIf, NULL, NULL, &dwType, (BYTE *) szValue, &cbValue);
			if (ERROR_SUCCESS == err)
			{
				hr = wCLSIDFromString(szValue, lpclsid);
			}
			RegCloseKey(hIf);
		}
		else
		{
			// If the key is missing, check to see if it is IDispatch
			//
			// There wasn't a ProxyStubClsid32 for this interface.
			// Because many applications install with interfaces
			// that are variations on IDispatch, we are going to check
			// to see if there is a ProxyStubClsid. If there is, and its
			// class is that of IDispatch, then the OLE Automation DLL is
			// the correct one to use. In that particular case, we will
			// pretend that ProxyStubClsid32 existed, and that it is
			// for IDispatch.

			err = RegOpenKeyEx(hkInterface, L"ProxyStubClsid", NULL, KEY_READ, &hIf);
			if (ERROR_SUCCESS == err)
			{
				// The unnamed value is the clsid for this iid
				err = RegQueryValueEx(hIf, NULL, NULL, &dwType, (BYTE *) szValue, &cbValue);
				if (ERROR_SUCCESS == err)
				{
					CLSID clsid;

					hr = wCLSIDFromString(szValue, &clsid);
					if (SUCCEEDED(hr) &&
						IsEqualCLSID(CLSID_PSDispatch, clsid))
					{
						CairoleDebugOut((DEB_WARN,
										 "Substituting IDispatch based on ProxyStubClsid\n"));
						*lpclsid = CLSID_PSDispatch;
						hr = S_OK;
					}
				}
				RegCloseKey(hIf);
			}
		}
		RegCloseKey(hkInterface);
	}

	return hr;
}
//+-------------------------------------------------------------------------
//
//  Function:   wRegQuerySyncIIDFromAsyncIID     (private)
//
//  Synopsis:   maps an async IID to a sync IID using the registry
//
//  Arguments:  [riidAsync]   - async IID in
//              [lpiidSync]   - corresponding sync IID out
//
//  Returns:    S_OK if successfull
//              REGDB_E_IIDNOTREG if interface is not registered.
//              REGDB_E_READREGDB if any other error
//
//  History:    MattSmit 26-Sep-97  Created - loosely copied from wRegQueryPSClsid
//
//--------------------------------------------------------------------------
INTERNAL wRegQuerySyncIIDFromAsyncIID(REFIID riid, LPCLSID lpiidSync)
{
	// lookup HKEY_CLASSES_ROOT\Interface\{iid}\ProxyStubClsid

	HRESULT hr = REGDB_E_IIDNOTREG;
	WCHAR szValue[VALUE_LEN];
	ULONG cbValue = sizeof(szValue);
	HKEY hkInterface;
	HKEY  hIf;
	DWORD dwType;
	int err;

	hr = wRegOpenInterfaceKey(riid, &hkInterface);
	if (SUCCEEDED(hr))
	{
		err = RegOpenKeyEx(hkInterface, L"SynchronousInterface", NULL, KEY_READ, &hIf);
		hr =  REGDB_E_READREGDB;
		if (ERROR_SUCCESS == err)
		{
			// The unnamed value is the sync iid for this iid
			err = RegQueryValueEx(hIf, NULL, NULL, &dwType, (BYTE *) szValue, &cbValue);
			if (ERROR_SUCCESS == err)
			{
				hr = wCLSIDFromString(szValue, lpiidSync);
			}
			RegCloseKey(hIf);
		}
		RegCloseKey(hkInterface);
	}

	return hr;
}
//+-------------------------------------------------------------------------
//
//  Function:   wRegQueryAsyncIIDFromSyncIID     (private)
//
//  Synopsis:   maps a sync iid to an async iid using the registry
//
//  Arguments:  [riid]        - the interface iid to lookup
//              [lpiidAsync]   - corresponding async iid
//
//  Returns:    S_OK if successfull
//              REGDB_E_IIDNOTREG if interface is not registered.
//              REGDB_E_READREGDB if any other error
//
//  History:    MattSmit 26-Sep-97  Created - loosely copied from wRegQueryPSClsid
//
//--------------------------------------------------------------------------
INTERNAL wRegQueryAsyncIIDFromSyncIID(REFIID riid, LPCLSID lpiidAsync)
{
	// lookup HKEY_CLASSES_ROOT\Interface\{iid}\ProxyStubClsid

	HRESULT hr = REGDB_E_IIDNOTREG;
	WCHAR szValue[VALUE_LEN];
	ULONG cbValue = sizeof(szValue);
	HKEY hkInterface;
	HKEY  hIf;
	DWORD dwType;
	int err;

	hr = wRegOpenInterfaceKey(riid, &hkInterface);
	if (SUCCEEDED(hr))
	{
		err = RegOpenKeyEx(hkInterface, L"AsynchronousInterface", NULL, KEY_READ, &hIf);
		hr =  REGDB_E_READREGDB;
		if (ERROR_SUCCESS == err)
		{
			// The unnamed value is the sync iid for this iid
			err = RegQueryValueEx(hIf, NULL, NULL, &dwType, (BYTE *) szValue, &cbValue);
			if (ERROR_SUCCESS == err)
			{
				hr = wCLSIDFromString(szValue, lpiidAsync);
			}
			RegCloseKey(hIf);
		}
		RegCloseKey(hkInterface);
	}

	return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   wCoGetClassExt   (internal)
//
//  Synopsis:   returns the clsid for files with the specified file extension
//
//  Arguments:  [pszExt] - the file extension to look up
//              [pclsid] - where to return the clsid
//
//  Returns:    S_OK if successfull
//              REGDB_E_CLASSNOTREG if extension is not registered.
//              REGDB_E_READREGDB   if any other error
//
//  History:    07-Apr-94   Rickhi      added caching
//              26-Sep-96   t-KevinH    New caching scheme
//
//--------------------------------------------------------------------------
INTERNAL wCoGetClassExt(LPCWSTR pwszExt, LPCLSID pclsid)
{
	TRACECALL(TRACE_REGISTRY, "wCoGetClassExt");

	if (!g_pExtTbl)
	{
		ASSERT_LOCK_NOT_HELD(gTblLck);
		LOCK(gTblLck);

		if (!g_pExtTbl)
		{
			g_pExtTbl = new CProcessExtensionTbl;
		}

		UNLOCK(gTblLck);
		ASSERT_LOCK_NOT_HELD(gTblLck);

		if (!g_pExtTbl)
		{
			return E_OUTOFMEMORY;
		}
	}

	return g_pExtTbl->GetClsid(pwszExt, pclsid);
}

//+-------------------------------------------------------------------------
//
//  Function:   wRegGetClassExt  (private)
//
//  Synopsis:   returns the clsid for files with the specified file extension
//
//  Arguments:  [pszExt] - the file extension to look up
//              [pclsid] - where to return the clsid
//
//  Returns:    S_OK if successfull
//              REGDB_E_CLASSNOTREG if extension is not registered.
//              REGDB_E_READREGDB   if any other error
//
//  Notes:
//
//  History:    07-Apr-94   Rickhi      added caching
//              04-Feb-96   BruceMa     Per-user registry support
//
//--------------------------------------------------------------------------
INTERNAL wRegGetClassExt(LPCWSTR lpszExt, LPCLSID pclsid)
{
	TRACECALL(TRACE_REGISTRY, "wRegGetClassExt");

	HRESULT hr;
	HKEY  hExt;
	int   err;
	WCHAR szKey[KEY_LEN];
	WCHAR szValue[VALUE_LEN];
	LONG  cbValue = sizeof(szValue);
	DWORD dwType;

	// Open the key
	hr = wRegOpenFileExtensionKey(lpszExt, &hExt);
	if (SUCCEEDED(hr))
	{
		// The ProgId is this key's unnamed value
		err = RegQueryValueEx(hExt, NULL, NULL, &dwType, (BYTE *) szValue,
							  (ULONG *) &cbValue);

		if (ERROR_SUCCESS == err)
		{
			hr = wCLSIDFromProgID(szValue, pclsid);
		}
		else
		{
			hr = REGDB_E_CLASSNOTREG;
		}
		RegCloseKey(hExt);
	}
	return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   wCoGetClassPattern   (internal)
//
//  Synopsis:   attempts to determine the class of a file by looking
//              at byte patterns in the file.
//
//  Arguments:  [hfile] - handle of file to look at
//              [pclsid] - the class of object to create
//
//  Returns:    S_OK - a pattern match was found, pclisd contains the clsid
//              MK_E_CANTOPENFILE - cant open the file.
//              REGDB_E_CLASSNOTREG - no pattern match was made
//
//--------------------------------------------------------------------------
INTERNAL wCoGetClassPattern(HANDLE hfile, CLSID *pclsid)
{
	TRACECALL(TRACE_REGISTRY, "wCoGetClassPattern");

	HRESULT hr = S_OK;

	// Check whether our pattern table has been initialized
	if (g_pPatTbl == NULL)
	{
		ASSERT_LOCK_NOT_HELD(gTblLck);
		LOCK(gTblLck);

		if (g_pPatTbl == NULL)
		{
			hr = E_OUTOFMEMORY;

			// load the cache
			g_pPatTbl = new CProcessPatternTbl(hr);

			if (FAILED(hr))
			{
				delete g_pPatTbl;
				g_pPatTbl = NULL;
			}
		}

		UNLOCK(gTblLck);
	}

	if (SUCCEEDED(hr))
	{
		// Check the file for registered patterns
		hr = g_pPatTbl->FindPattern(hfile, pclsid);
	}

	return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   wCoMarshalInterThreadInterfaceInStream, (internal)
//
//  Synopsis:   helper function to a marshaled buffer to be passed
//              between threads.
//
//  Arguments:  [riid]      - interface id
//              [pUnk]      - ptr to interface we want to marshal
//              [ppStm]     - stream we want to give back to caller
//
//  Returns:    NOERROR     - Stream returned
//              E_INVALIDARG - Input parameters are invalid
//              E_OUTOFMEMORY - memory stream could not be created.
//
//  Algorithm:  Create a stream and finally marshal
//              the input interface into the stream.
//
//  History:    03-Nov-94   Ricksa       Created
//
//--------------------------------------------------------------------------
INTERNAL_(HRESULT) wCoMarshalInterThreadInterfaceInStream(
														 REFIID riid,
														 LPUNKNOWN pUnk,
														 LPSTREAM *ppStm)
{
	HRESULT hr;
	LPSTREAM pStm = NULL;

	// Assume error
	hr = E_OUTOFMEMORY;

	// Create a stream
	pStm = CreateMemStm(EST_INPROC_MARSHAL_SIZE, NULL);

	if (pStm != NULL)
	{
		// Marshal the interface into the stream
		hr = CoMarshalInterface(pStm, riid, pUnk, MSHCTX_INPROC, NULL,
								MSHLFLAGS_NORMAL);
	}

	if (SUCCEEDED(hr))
	{
		// Reset the stream to the begining
		LARGE_INTEGER li;
		LISet32(li, 0);
		pStm->Seek(li, STREAM_SEEK_SET, NULL);

		// Set the return value
		*ppStm = pStm;
	}
	else
	{
		// Cleanup if failure
		if (pStm != NULL)
		{
			pStm->Release();
		}

		*ppStm = NULL;
	}

	// Assert

	// Return the result
	return hr;
}





//+-------------------------------------------------------------------------
//
//  Function:   wCoGetInterfaceAndReleaseStream, (internal)
//
//  Synopsis:   Helper to unmarshal object from stream for inter-thread pass
//
//  Arguments:  [riid]      - interface id
//              [pStm]      - stream we want to give back to caller
//              [ppv]       - pointer for returned object
//
//  Returns:    NOERROR     - Unmarshaled object returned
//              E_OUTOFMEMORY - out of memory
//
//  Algorithm:  Unmarshal the stream and
//              finally release the stream pointer.
//
//  History:    03-Nov-94   Ricksa       Created
//
//  Notes:      This always releases the input stream if stream is valid.
//
//--------------------------------------------------------------------------
INTERNAL_(HRESULT) wCoGetInterfaceAndReleaseStream(
												  LPSTREAM pstm,
												  REFIID riid,
												  LPVOID *ppv)
{
	HRESULT hr;

	// Unmarshal the interface
	hr = CoUnmarshalInterface(pstm, riid, ppv);

	// Release the stream since that is the way the function is defined.
	pstm->Release();

	return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   wStringFromCLSID (internal)
//
//  Synopsis:   converts GUID into {...} form.
//
//  Arguments:  [rclsid] - the guid to convert
//              [lplpsz] - ptr to buffer for results
//
//  Returns:    NOERROR
//              E_OUTOFMEMORY
//
//--------------------------------------------------------------------------
INTERNAL  wStringFromCLSID(REFCLSID rclsid, LPWSTR FAR* lplpsz)
{
	WCHAR sz[CLSIDSTR_MAX];

	Verify(StringFromCLSID2(rclsid, sz, CLSIDSTR_MAX) != 0);

	*lplpsz = UtDupString(sz);

	return *lplpsz != NULL ? NOERROR : E_OUTOFMEMORY;
}


//+-------------------------------------------------------------------------
//
//  Function:   wStringFromIID   (internal)
//
//  Synopsis:   converts GUID into {...} form.
//
//  Arguments:  [rclsid] - the guid to convert
//              [lplpsz] - ptr to buffer for results
//
//  Returns:    NOERROR
//              E_OUTOFMEMORY
//
//--------------------------------------------------------------------------
INTERNAL wStringFromIID(REFIID rclsid, LPWSTR FAR* lplpsz)
{
	WCHAR sz[IIDSTR_MAX];
	*lplpsz = NULL;

	if (StringFromIID2(rclsid, sz, IIDSTR_MAX) != 0)
	{
		*lplpsz = UtDupString(sz);
	}

	return *lplpsz != NULL ? NOERROR : E_OUTOFMEMORY;
}


//+-------------------------------------------------------------------------
//
//  Function:   wIIDFromString   (internal)
//
//  Synopsis:   converts string {...} form int guid
//
//  Arguments:  [lpsz]  - ptr to buffer for results
//              [lpiid] - the guid to convert
//
//  Returns:    NOERROR
//              CO_E_CLASSSTRING
//
//--------------------------------------------------------------------------
INTERNAL wIIDFromString(LPWSTR lpsz, LPIID lpiid)
{
	if (lpsz == NULL)
	{
		*lpiid = IID_NULL;
		return NOERROR;
	}

	return wGUIDFromString(lpsz, lpiid)
	? NOERROR : CO_E_IIDSTRING;
}


//+-------------------------------------------------------------------------
//
//  Function:   wCoIsOle1Class   (internal)
//
//  Synopsis:   reads the Ole1Class entry in the registry for the given clsid
//
//  Arguments:  [rclsid]    - the classid to look up
//
//  Returns:    TRUE if Ole1Class
//              FALSE otherwise
//
//  History:    Gopalk  Oct 30,96  Changed to check HIWORD before hitting
//                                 registry
//
//--------------------------------------------------------------------------
INTERNAL_(BOOL) wCoIsOle1Class(REFCLSID rclsid)
{
	TRACECALL(TRACE_REGISTRY, "wCoIsOle1Class");
	CairoleDebugOut((DEB_REG, "wCoIsOle1Class called.\n"));

	//  since we now have guid, Ole1Class = would indicate OLE 1.0 nature.
	//  lookup HKEY_CLASSES_ROOT\{rclsid}\Ole1Class
	WCHAR szValue[VALUE_LEN];
	WORD hiWord;

	hiWord = HIWORD(rclsid.Data1);
	if (hiWord==3 || hiWord==4)
		if (wRegQueryClassValue(rclsid, wszOle1Class, szValue, sizeof(szValue))==ERROR_SUCCESS)
			return TRUE;

	return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Function:   wkProgIDFromCLSID     (internal)
//              (wProgIDFromCLSID name is already in use)
//
//  Synopsis:   convert clsid into progid
//
//  Arguments:  [rclsid]    - the classid to look up
//              [pszProgID] - returned progid
//
//  Returns:    E_INVALIDARG, E_OUTOFMEMORY,
//              REGDB_CLASSNOTREG, REGDB_E_READREGDB
//
//--------------------------------------------------------------------------
INTERNAL wkProgIDFromCLSID(REFCLSID rclsid, LPWSTR FAR* ppszProgID)
{
	HRESULT hr;
	TRACECALL(TRACE_REGISTRY, "wkProgIDFromCLSID");

	WCHAR szProgID[KEY_LEN];

	*ppszProgID = NULL;

	hr = wRegQueryClassValue (rclsid, wszProgID, szProgID, sizeof(szProgID));

	if (SUCCEEDED(hr))
	{
		*ppszProgID = UtDupString (szProgID);
		hr = (*ppszProgID != NULL) ? NOERROR : E_OUTOFMEMORY;
	}

	return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   wRegOpenKeyEx      (internal)
//
//  Synopsis:   Opens a registry key.  HKEY_CLASSES_ROOT is a special case.
//              First, we try to open the per-user key under
//              HKEY_CURRENT_USER\Software\Classes.  Second, we try to
//              open the key under HKEY_LOCAL_MACHINE\Software\Classes.
//
//  Returns:    ERROR_SUCCESS
//
//--------------------------------------------------------------------------
INTERNAL_(LONG) wRegOpenKeyEx(
							 HKEY hKey,	 // handle of open key
							 LPCWSTR lpSubKey,	 // address of name of subkey to open
							 DWORD ulOptions,	 // reserved
							 REGSAM samDesired,	 // security access mask
							 PHKEY phkResult	 // address of handle of open key
							 )
{
	LONG status;

	status = RegOpenKeyEx(hKey,
						  lpSubKey,
						  ulOptions,
						  samDesired,
						  phkResult);

	return status;
}

//+-------------------------------------------------------------------------
//
//  Function:   wRegQueryClassValue  (Internal)
//
//  Synopsis:   reads the specified subkey of the specified clsid
//
//  Arguments:  [rclsid]     - the classid to look up
//              [lpszSubKey] - subkey to read
//              [lpszValue]  - buffer to hold returned value
//              [cbMax]      - sizeof the buffer
//
//  Returns:    REGDB_E_CLASSNOTREG, REGDB_E_READREGDB
//
//  Notes:      We search both the per-user and per-machine registry.
//
//--------------------------------------------------------------------------
INTERNAL wRegQueryClassValue(REFCLSID rclsid, LPCWSTR lpszSubKey,
							 LPWSTR lpszValue, int cbMax)
{
	HRESULT hr;
	HKEY hkeyClsid;
	LONG cbValue = cbMax;

	hr = wRegOpenClassKey (rclsid, KEY_READ, &hkeyClsid);
	if (SUCCEEDED(hr))
	{
		long status;

		status = RegQueryValue(hkeyClsid, lpszSubKey, lpszValue, &cbValue);

		switch (status)
		{
		case ERROR_SUCCESS:
			hr = S_OK;
			break;

			// win32 will return file not found instead of bad key
		case ERROR_FILE_NOT_FOUND:
		case ERROR_BADKEY:
			hr = REGDB_E_CLASSNOTREG;
			break;

		default:
			hr = REGDB_E_READREGDB;
			break;
		}

		//Close the key.
		Verify (ERROR_SUCCESS == RegCloseKey(hkeyClsid));
	}

	CairoleDebugOut((DEB_REG, "ReqQueryValue(%ws)\n", lpszSubKey));
	return hr;
}


//+-------------------------------------------------------------------------
/*
	Function:   HandlerInRegistry           (internal)

	Synopsis:   given a CLSTX value and a classid, determines
					   if a handler for that context exists in the
					   registry for that class

	Parameters: [in] clsid          -  ClassID
						[in] dwClsCtx  -   Context

	Returns:      REGDB_E_CLASSNOTREG, S_OK

	History:       Dec. 10, 1997   RahulTh         created
*/
//+--------------------------------------------------------------------------
HRESULT HandlerInRegistry (
						  REFCLSID    clsid,
						  DWORD       dwClsCtx)
{
	HKEY hkClsid = NULL;
	DWORD dwReserved = 0;
	HKEY hkSubkey = NULL;
	HRESULT hr;

	//first see if the clsid exists in the registry
	if (FAILED(wRegOpenClassKey(clsid, KEY_READ, &hkClsid)))
	{
		return REGDB_E_CLASSNOTREG;
	}

	//if clsid exists in the registry, check if the required server is registered
	if (dwClsCtx & CLSCTX_LOCAL_SERVER)
	{
		hr = RegOpenKeyEx(hkClsid, L"LocalServer32", dwReserved,
						  KEY_READ, &hkSubkey);
		goto exit_HandlerInRegistry;
	}

	if (dwClsCtx & CLSCTX_INPROC_SERVER)
	{
		hr = RegOpenKeyEx(hkClsid, L"InprocServer32", dwReserved,
						  KEY_READ, &hkSubkey);
		goto exit_HandlerInRegistry;
	}

	if (dwClsCtx & CLSCTX_INPROC_HANDLER)
	{
		hr = RegOpenKeyEx(hkClsid, L"InprocHandler32", dwReserved,
						  KEY_READ, &hkSubkey);
		goto exit_HandlerInRegistry;
	}

	exit_HandlerInRegistry:

	Verify (hkSubkey?(ERROR_SUCCESS == RegCloseKey(hkSubkey)):TRUE);
	Verify (hkClsid?(ERROR_SUCCESS == RegCloseKey(hkClsid)):TRUE);

	if (SUCCEEDED(hr))
		return S_OK;
	else
		return REGDB_E_CLASSNOTREG;
}


//+-------------------------------------------------------------------------
//
//  Function:   wRegOpenClassKey      (internal)
//
//  Synopsis:   opens a registry key for specified class
//
//  Returns:    REGDB_CLASSNOTREG, REGDB_E_READREGDB
//
//--------------------------------------------------------------------------
INTERNAL wRegOpenClassKey(
						 REFCLSID clsid,
						 REGSAM samDesired,
						 HKEY FAR* lphkeyClsid)
{
	long status;
	WCHAR szKey[KEY_LEN];

	TRACECALL(TRACE_REGISTRY, "wRegOpenClassKey");

	if (IsEqualCLSID(clsid, CLSID_NULL))
		return REGDB_E_CLASSNOTREG;

	*lphkeyClsid = NULL;

	lstrcpyW (szKey, wszClassKey);
	Verify (StringFromCLSID2 (clsid, szKey+ulClassKeyLen,
							  sizeof(szKey)-ulClassKeyLen) != 0);

	status = wRegOpenKeyEx(HKEY_CLASSES_ROOT,
						   szKey,
						   0,
						   samDesired,
						   lphkeyClsid);

	switch (status)
	{
	case ERROR_SUCCESS:
		return NOERROR;

		// win32 will return file not found instead of bad key
	case ERROR_FILE_NOT_FOUND:
	case ERROR_BADKEY:
		return REGDB_E_CLASSNOTREG;

	default:
		return REGDB_E_READREGDB;
	}
}

//+-------------------------------------------------------------------------
//
//  Function:   wRegOpenClassSubkey  (Internal)
//
//  Synopsis:   Opens the specified subkey of the specified clsid
//
//  Arguments:  [rclsid]      - the classid to look up
//              [lpszSubKey]  - subkey to read
//              [phkeySubkey] - returned value HKEY
//
//  Returns:    Return value of RegOpenKeyEx
//
//--------------------------------------------------------------------------
INTERNAL wRegOpenClassSubkey(
							REFCLSID rclsid,
							LPCWSTR lpszSubkey,
							HKEY *phkeySubkey)
{
	WCHAR szKey[KEY_LEN];
	int ccClsid, ccLen;

	lstrcpyW(szKey, wszClassKey);

	ccLen = ulClassKeyLen;

	// translate rclsid into string
	ccClsid = StringFromCLSID2(rclsid,
							   &szKey[ccLen],
							   KEY_LEN-ccLen);

	CairoleAssert((ccClsid != 0) && "wReqOpenClassSubkey");

	ccLen += ccClsid-1;

	szKey[ccLen++] = L'\\';
	lstrcpyW(&szKey[ccLen], lpszSubkey);

	CairoleDebugOut((DEB_REG, "wReqOpenClassSubkey(%ws)\n", szKey));
	if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_CLASSES_ROOT,
									  szKey,
									  0, KEY_READ,
									  phkeySubkey))
	{
		return REGDB_E_READREGDB;
	}
	return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Function:   wRegOpenInterfaceKey      (internal)
//
//  Synopsis:   opens a registry key for specified interface
//
//  Returns:    REGDB_CLASSNOTREG, REGDB_E_READREGDB
//
//--------------------------------------------------------------------------
INTERNAL wRegOpenInterfaceKey(REFIID riid, HKEY * lphkeyIID)
{
	long status;

	TRACECALL(TRACE_REGISTRY, "wRegOpenIIDKey");

	WCHAR szKey[KEY_LEN];
	lstrcpyW(szKey, wszInterfaceKey);
	int cbIid = StringFromIID2(riid, &szKey[ulInterfaceKeyLen],
							   sizeof(szKey)-ulInterfaceKeyLen);

	status = wRegOpenKeyEx(HKEY_CLASSES_ROOT,
						   szKey,
						   0,
						   KEY_READ,
						   lphkeyIID);

	switch (status)
	{
	case ERROR_SUCCESS:
		return NOERROR;

		// win32 will return file not found instead of bad key
	case ERROR_FILE_NOT_FOUND:
	case ERROR_BADKEY:
		return REGDB_E_IIDNOTREG;

	default:
		return REGDB_E_READREGDB;
	}
}

//+-------------------------------------------------------------------------
//
//  Function:   wRegOpenProgIDKey      (internal)
//
//  Synopsis:   opens a registry key for specified ProgID.
//
//  Returns:    REGDB_CLASSNOTREG, REGDB_E_READREGDB
//
//--------------------------------------------------------------------------
INTERNAL wRegOpenProgIDKey(LPCWSTR pszProgID, HKEY FAR* lphkeyClsid)
{
	long status;

	TRACECALL(TRACE_REGISTRY, "wRegOpenProgIDKey");

	status = wRegOpenKeyEx(HKEY_CLASSES_ROOT,
						   pszProgID,
						   0,
						   KEY_READ,
						   lphkeyClsid);

	switch (status)
	{
	case ERROR_SUCCESS:
		return NOERROR;

		// win32 will return file not found instead of bad key
	case ERROR_FILE_NOT_FOUND:
	case ERROR_BADKEY:
		return REGDB_E_CLASSNOTREG;

	default:
		return REGDB_E_READREGDB;
	}
}



//+-------------------------------------------------------------------------
//
//  Function:   wRegOpenFileExtensionKey      (internal)
//
//  Synopsis:   opens a registry key for specified file extension.
//
//  Arguments:  [pszFileExt]- the file extension to look up
//
//  Returns:    REGDB_CLASSNOTREG, REGDB_E_READREGDB
//
//--------------------------------------------------------------------------
INTERNAL wRegOpenFileExtensionKey(LPCWSTR pszFileExt, HKEY FAR* lphkeyClsid)
{
	long status;

	TRACECALL(TRACE_REGISTRY, "wRegOpenFileExtensionKey");

	status = wRegOpenKeyEx(HKEY_CLASSES_ROOT,
						   pszFileExt,
						   0,
						   KEY_READ,
						   lphkeyClsid);

	switch (status)
	{
	case ERROR_SUCCESS:
		return S_OK;

		// win32 will return file not found instead of bad key
	case ERROR_FILE_NOT_FOUND:
	case ERROR_BADKEY:
		return REGDB_E_CLASSNOTREG;

	default:
		return REGDB_E_READREGDB;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\class\cocrguid.cxx ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1994.
//
//  File:       CoCreateGuid.cpp
//
//  Contents:   Guid creation
//
//  Classes:
//
//  Functions:  CoCreateGuid
//
//  History:    12-Apr-94   BruceMa    Created
//              19-Apr-94   BruceMa    Fixes chicago build
//              20-Apr-94   BruceMa    Uniqueness algorithm improved
//              28-Apr-94   Rickhi     Added UuidCreate
//              27-Jun-94   BruceMa    Use RPC system API instead of
//                                      original code
//              26-Sep-94   BruceMa    Fix incorect error code
//
//----------------------------------------------------------------------

#include <ole2int.h>
#include <rpcdce.h>

// forward reference
INTERNAL wCoCreateGuid(GUID *pGuid);

//+---------------------------------------------------------------------
//
//  Function:   CoCreateGuid
//
//  Synopsis:   Calls UuidCreate() to create a new guid.
//
//  Arguments:  [pGuid] -- Pointer to guid structure to create
//
//  Returns:    S_OK             Success
//              RPC_S_xxxx       Failure creating GUID
//
//
//----------------------------------------------------------------------
STDAPI CoCreateGuid(GUID *pGuid)
{
    OLETRACEIN((API_CoCreateGuid, PARAMFMT("pGuid= %p"), pGuid));

    HRESULT hr;

    if (!IsValidPtrOut(pGuid, sizeof(*pGuid)))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = wCoCreateGuid(pGuid);
    }

    OLETRACEOUT((API_CoCreateGuid, hr));
    return hr;
}



//+---------------------------------------------------------------------
//
//  Function:   wCoCreateGuid               (internal)
//
//  Synopsis:   Calls UuidCreate() to create a new guid.
//
//  Arguments:  [pGuid] -- Pointer to guid structure to create
//
//  Returns:    S_OK             Success
//              RPC_S_xxxx       Failure creating GUID
//
//
//----------------------------------------------------------------------
INTERNAL wCoCreateGuid(GUID *pGuid)
{
    int err;

    // We simply use the RPC system supplied API
    if ((err = UuidCreate(pGuid)) != RPC_S_UUID_LOCAL_ONLY)
    {
        return err ? HRESULT_FROM_WIN32(err) : S_OK;
    }

    return S_OK;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\class\alocdbg.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows:
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       alocdbg.cxx
//
//  Contents:   Supports symbolic stack trace dumps for leaked memory
//              allocations
//
//  Classes:    AllocArenaDump
//
//  Functions:  CoGetMalloc
//
//  History:    04-Nov-93 AlexT     Created
//              09-Nov-95 BruceMa   Added this header
//                                  Use imagehlp.dll rather than symhelp.dll
//
//--------------------------------------------------------------------------



/*
 * This file implements an arena that tracks memory allocations and frees.
 *      Isaache
 */

#if !defined(_CHICAGO_)
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
}
#endif

#include <ole2int.h>

#if DBG == 1

#include <imagehlp.h>
#include <except.hxx>
#include <alocdbg.h>

#pragma optimize( "y", off )

DECLARE_INFOLEVEL( heap );
DECLARE_DEBUG( heap );
#define heapDebugOut(x) heapInlineDebugOut x

/*
 * The maximum number of AllocArenaCreate's we expect
 */
static const    MAXARENAS       = 5;

/*
 * When printing leak dumps, the max number we will print out.  Note, we keep
 * track of all of them, we just don't want to take forever to terminate a
 * process
 */
static const    MAXDUMP         = 50;

/*
 * The maximum size we'll let any single debug arena get
 */
static const ULONG ARENASIZE    = 1024*1024;

/*
 * The unit of growth for the arena holding the AllocArena data.
 * Must be a power of 2
 */
static const ALLOCRECINCR       = 128;


// The maximum symbol length we allow
static const ULONG MAXNAMELENGTH = 128;


static AllocArena *AllocArenas[ MAXARENAS + 1 ];


// This is our interface to symhelp for address translation
ULONG RealTranslate ( ULONG_PTR, LPSTR, ULONG );


ULONG MissingTranslate (
    ULONG Address,
    LPSTR Name,
    ULONG MaxNameLength )
{
    return _snprintf( Name, MaxNameLength, "0x%08x [imagehlp.dll missing]", Address );

}





//+---------------------------------------------------------------------------
//
//  Function:   RealTranslate
//
//  Synopsis:   Interfaces to imagehlp!SymGetSymFromAddr
//
//  Arguments:  [cFrameSkipped] --  How many stack frames to skip over and
//
//  Returns:    BOOL
//
//  History:    09-Nov-95   BruceMa     Created
//
//----------------------------------------------------------------------------
ULONG RealTranslate ( ULONG_PTR address, LPSTR name, ULONG maxNameLength )
{
    IMAGEHLP_MODULE  mod;
    char             dump[sizeof(IMAGEHLP_SYMBOL) + MAXNAMELENGTH];
    char             UnDDump[ MAXNAMELENGTH ];
    PIMAGEHLP_SYMBOL pSym = (PIMAGEHLP_SYMBOL) &dump;
    ULONG_PTR         dwDisplacement = 0;

    // Fetch the module name
    mod.SizeOfStruct = sizeof(IMAGEHLP_MODULE);
    if (!SymGetModuleInfo(GetCurrentProcess(), address, &mod))
    {
        sprintf(name, "%08lx !\0", address);
    }
    else
    {
        // Copy the address and module name
        sprintf(name, "%08lx %s!\0", address, mod.ModuleName);
    }


    // Have to do this because size of sym is dynamically determined
    pSym->SizeOfStruct = sizeof(dump);
    pSym->MaxNameLength = MAXNAMELENGTH;

    // Fetch the symbol
    if (SymGetSymFromAddr(GetCurrentProcess(),
                               address,
                               &dwDisplacement,
                               pSym))
    {
        SymUnDName( pSym, UnDDump, sizeof(UnDDump ) );
        // Copy the symbol
        strcat(name, UnDDump );
    }

    // Copy the displacement
    char szDisplacement[16];

    strcat(name, "+");
    sprintf(szDisplacement, "0x%x\0", dwDisplacement);
    strcat(name, szDisplacement);

    return TRUE;
}






//+---------------------------------------------------------------------------
//
//  Function:   RecordStack functions(s) below...per processor type
//
//  Synopsis:   Record a stack backtrace into fTrace
//
//  Arguments:  [cFrameSkipped] --  How many stack frames to skip over and
//                      not record
//              [fTrace] -- The recorded frames are put in here
//
//  Returns:    A checksum of the stack frames for fast initial lookups
//
//  Notes:      If we can do stack backtracing for whatever processor we're
//              compiling for, the #define CANDOSTACK
//
//----------------------------------------------------------------------------

#if defined (_CHICAGO_)

static inline DWORD
RecordStack( int cFrameSkipped, void *fTrace[ DEPTHTRACE ] )
{
    return 0;
}


#else

#define CANDOSTACK
#define SYM_HANDLE      GetCurrentProcess( )
#if defined(_M_IX86)
#define MACHINE_TYPE  IMAGE_FILE_MACHINE_I386
#elif defined(_M_MRX000)
#define MACHINE_TYPE  IMAGE_FILE_MACHINE_R4000
#elif defined(_M_ALPHA)
#define MACHINE_TYPE  IMAGE_FILE_MACHINE_ALPHA
#elif defined(_M_PPC)
#define MACHINE_TYPE  IMAGE_FILE_MACHINE_POWERPC
#elif defined(_M_IA64)
#define MACHINE_TYPE  IMAGE_FILE_MACHINE_IA64
#elif defined(_M_AMD64)
#define MACHINE_TYPE  IMAGE_FILE_MACHINE_AMD64
#else
#error( "unknown target machine" );
#endif

inline int
SaveOffExceptionContext( void * fTrace[ DEPTHTRACE],
                         DWORD & sum,
                         EXCEPTION_POINTERS * pPtrs )
{
    CONTEXT         Context;
    STACKFRAME      StackFrame;

    Context = *(pPtrs->ContextRecord);
    ZeroMemory( &StackFrame, sizeof(StackFrame) );

#if defined(_M_IX86)
    StackFrame.AddrPC.Offset       = Context.Eip;
    StackFrame.AddrPC.Mode         = AddrModeFlat;
    StackFrame.AddrFrame.Offset    = Context.Ebp;
    StackFrame.AddrFrame.Mode      = AddrModeFlat;
    StackFrame.AddrStack.Offset    = Context.Esp;
    StackFrame.AddrStack.Mode      = AddrModeFlat;
#endif

    int i = 3;
    BOOL rVal = TRUE;

    // skip spurious stack frames from RaiseException and ourselves
    while ( (i-- > 0 ) && rVal )
    {
        // skip our own stack frame
        rVal = StackWalk( MACHINE_TYPE,
                          SYM_HANDLE,
                          0,
                          &StackFrame,
                          &Context,
                          (PREAD_PROCESS_MEMORY_ROUTINE) ReadProcessMemory,
                          SymFunctionTableAccess,
                          SymGetModuleBase,
                          NULL );
    }

    // now process the interesting stack frames
    i = 0;
    while ( (i < DEPTHTRACE) && rVal )
    {

        rVal = StackWalk( MACHINE_TYPE,
                          SYM_HANDLE,
                          0,
                          &StackFrame,
                          &Context,
                          (PREAD_PROCESS_MEMORY_ROUTINE) ReadProcessMemory,
                          SymFunctionTableAccess,
                          SymGetModuleBase,
                          NULL );

        if (rVal )
        {
        fTrace[i++] =       (void*) StackFrame.AddrPC.Offset;
        sum +=              (DWORD) StackFrame.AddrPC.Offset;
        }
    }

    return EXCEPTION_EXECUTE_HANDLER;
}
#endif

#if !defined(_CHICAGO_)

static inline DWORD
RecordStack( int cFrameSkipped, void *fTrace[ DEPTHTRACE ] )
{

        // we need a context record, and there isn't any clean way to
        // get our own context, so we deliberately cause an exception
        // and catch it, then save off and look at the context record.

        DWORD sum = 0;

        __try
        {
            EXCEPTION_RECORD    Except;
            ZeroMemory( &Except, sizeof(Except) );

            // we raise the exception 0!
            RtlRaiseException( &Except );

        }
        // the exception handler puts everything in the trace block, and
        // fills in the sum
        __except( SaveOffExceptionContext( fTrace,
                                           sum,
                                           GetExceptionInformation() ) )
        {
        }

        return sum;

}
#endif // !defined(_CHICAGO_)

//
// This allows external monitoring of heap activity by caiheap.exe
//
STDAPI_( AllocArena ** )
AllocArenaAddr( void )
{
        return AllocArenas;
}

//
// Create an arena for recording allocation statistics.  Return the arena
// pointer to the caller
//
STDAPI_( AllocArena * )
AllocArenaCreate( DWORD memctx, char FAR *comment )
{
        // the first time through, we set up the symbol handler
        static int FirstTime = TRUE;
        if ( FirstTime )
        {
            SymSetOptions( SYMOPT_DEFERRED_LOADS );
#if !defined(_CHICAGO_)
            SymInitialize( SYM_HANDLE, NULL, TRUE );
#endif // !defined(_CHICAGO_)
            FirstTime = FALSE;
        }

        struct AllocArena *paa = NULL;

        if( memctx == MEMCTX_TASK ) {
#if     defined( CANDOSTACK )
                if( heapInfoLevel & DEB_WARN ) {

                        paa = (struct AllocArena *)VirtualAlloc(
                                NULL, ARENASIZE, MEM_RESERVE, PAGE_NOACCESS );
                        if( paa == NULL )
                                return NULL;

                        paa = (AllocArena *)VirtualAlloc( paa,
                           sizeof(*paa)+(ALLOCRECINCR-1)*sizeof(HeapAllocRec),
                           MEM_COMMIT, PAGE_READWRITE );

                }
                else
#endif
                {
                        paa = (struct AllocArena *)LocalAlloc( LPTR, sizeof(*paa) );
                }
        }

        if( paa == NULL )
                return NULL;

        memcpy( paa->Signature,HEAPSIG,sizeof(HEAPSIG));
        if( comment )
                strncpy(paa->comment, comment, sizeof(paa->comment) );
		
        NTSTATUS status;
        status = RtlInitializeCriticalSection( &paa->csExclusive );
        if (!NT_SUCCESS(status))
        {
            LocalFree(paa);
            return NULL;
        }

        for( int i=0; i < MAXARENAS; i++ )
                if( AllocArenas[i] == 0 ) {
                        AllocArenas[i] = paa;
                        break;
                }

#if     defined( CANDOSTACK )
        if(!(heapInfoLevel & DEB_ITRACE))
#endif
        {
                paa->flags.KeepStackTrace = 0;
                paa->AllocRec[0].paa = paa;
                return paa;
        }

#if     defined( CANDOSTACK )
        paa->cRecords = ALLOCRECINCR;
        paa->cTotalRecords = ALLOCRECINCR;
        paa->flags.KeepStackTrace = 1;

        return paa;
#endif
}

//+---------------------------------------------------------------------------
//
//  Function:   AllocArenaRecordAlloc
//
//  Synopsis:   Keep a hash table of the stack backtraces of the allocations
//              we've done.
//
//  Arguments:  [paa] -- Return value from AllocArenaCreate() above
//              [bytes] -- the number of bytes being allocated by the caller.
//                      This value is recorded in the stack backtrace entry.
//
//  Algorithm:  The arena for the AllocArena is created with VirtualAlloc.
//                      pAllocArena->cRecords is the index of the next
//                      free record.  The first ALLOCRECINCR records are heads
//                      of separate lists of the records.
//
//  Returns:    A pointer to the AllocRec structure recording the entry.
//              Can return NULL if we can't record the allocation.
//
//----------------------------------------------------------------------------
STDAPI_( HeapAllocRec FAR * )
AllocArenaRecordAlloc( AllocArena *paa, size_t bytes )
{
        if( paa == NULL )
                return NULL;

        EnterCriticalSection( &paa->csExclusive );

        if( bytes ) {
                paa->cAllocs++;
                paa->cBytesNow += bytes;
                paa->cBytesTotal += bytes;
        } else {
                paa->czAllocs++;
        }

        //
        // Record 'size' in the histogram of requests
        //
        for( int i=31; i>=0; i-- )
                if( bytes & (1<<i) ) {
                        ++(paa->Histogram.total[i]);
                        if( paa->Histogram.simul[i] < ++(paa->Histogram.now[i]))
                                paa->Histogram.simul[i] = paa->Histogram.now[i];
                        break;
                }

        LeaveCriticalSection( &paa->csExclusive );

#if     defined( CANDOSTACK )
        if( paa->flags.KeepStackTrace == 0 )
#endif
                return &paa->AllocRec[0];

#if     defined( CANDOSTACK )

        DWORD sum;
        struct HeapAllocRec *phar,*hp;
        void *fTrace[ DEPTHTRACE ];

        //
        // See if we find an existing record of this stack backtrace
        //
        memset( fTrace, '\0', sizeof( fTrace ) );
        sum = RecordStack( 1, fTrace );

        hp = &paa->AllocRec[ sum & (ALLOCRECINCR-1) ];

        EnterCriticalSection( &paa->csExclusive );

        for( phar = hp; phar != NULL; phar = phar->u.next )
                if( phar->sum == sum && !memcmp(phar->fTrace,fTrace,sizeof(fTrace)))
                {
                        phar->count++;
                        phar->bytes += bytes;
                        phar->total.bytes += bytes;
                        phar->total.count++;
                        phar->paa = paa;
                        LeaveCriticalSection( &paa->csExclusive );
                        return phar;
                }
        //
        // We have no record of this allocation.  Make one!
        //
        if( hp->total.count && paa->cRecords == paa->cTotalRecords ) {
                //
                // The arena is currently full.  Grow it by ALLOCRECINCR
                //
                AllocArena *npHeap;

                npHeap = (AllocArena *)VirtualAlloc(
                        paa,
                        sizeof(AllocArena)+
                        ((paa->cTotalRecords + ALLOCRECINCR) *
                                sizeof(HeapAllocRec) ),
                        MEM_COMMIT, PAGE_READWRITE );

                if( npHeap != paa ) {
                        paa->cMissed++;
                        LeaveCriticalSection( &paa->csExclusive );
                        return NULL;
                }

                paa->cTotalRecords += ALLOCRECINCR;
        }

        if( hp->total.count == 0 ) {
                phar = hp;
        } else {
                phar = &paa->AllocRec[ paa->cRecords++ ];
                phar->u.next = hp->u.next;
                hp->u.next = phar;
        }

        paa->cPaths++;

        memcpy( phar->fTrace, fTrace, sizeof( fTrace ) );
        phar->count = phar->total.count = 1;
        phar->bytes = phar->total.bytes = bytes;
        phar->sum = sum;
        phar->paa = paa;
        LeaveCriticalSection( &paa->csExclusive );
        return phar;
#endif
}

//+---------------------------------------------------------------------------
//
//  Function:   AllocArenaRecordReAlloc
//
//  Synopsis:   Update the record to reflect the fact that we've ReAlloc'd
//              the memory chunk.
//
//  Arguments:  [vp] -- Return value from AllocArenaRecordAlloc() above
//              [oldbytes] -- size of the memory before ReAllocation
//              [newbytes] -- new size of the memory
//
//----------------------------------------------------------------------------
STDAPI_( void )
AllocArenaRecordReAlloc( HeapAllocRec FAR *vp, size_t oldbytes, size_t newbytes)
{
        if( vp == NULL )
                return;

        struct AllocArena *paa = vp->paa;

        EnterCriticalSection( &paa->csExclusive );

        paa->cReAllocs++;
        paa->cBytesNow -= oldbytes;
        paa->cBytesNow += newbytes;

        if( newbytes > oldbytes )
                paa->cBytesTotal += newbytes - oldbytes;

        //
        // Take 'oldbytes' out of the histogram of requests
        //
        for( int i=31; i>=0; i-- )
                if( oldbytes & (1<<i) ) {
                        --(paa->Histogram.now[i]);
                        break;
                }

        //
        // Record 'newbytes' in the histogram of requests
        //
        for( i=31; i>=0; i-- )
                if( newbytes & (1<<i) ) {
                        ++(paa->Histogram.total[i]);
                        if( paa->Histogram.simul[i] < ++(paa->Histogram.now[i]))
                                paa->Histogram.simul[i] = paa->Histogram.now[i];
                        break;
                }

#if     defined( CANDOSTACK )
        if( paa->flags.KeepStackTrace ) {
                vp->bytes -= oldbytes;
                vp->bytes += newbytes;
                vp->total.count++;
                if( newbytes > oldbytes )
                        vp->total.bytes += newbytes;
        }
#endif

        LeaveCriticalSection( &paa->csExclusive );
}

//+---------------------------------------------------------------------------
//
//  Function:   AllocArenaRecordFree
//
//  Synopsis:   Caller has freed memory -- keep accounting up to date
//
//  Arguments:  [vp] -- Value returned by AllocArenaRecordAlloc() above
//              [bytes] -- The number of bytes being freed
//
//  Algorithm:  AllocRec structures, once allocated, are never actually
//                      freed back to the Hash memory arena.  This helps us
//                      understand historical use of the heap.
//
//----------------------------------------------------------------------------
STDAPI_( void )
AllocArenaRecordFree( HeapAllocRec FAR *vp, size_t bytes )
{
        if( vp == NULL )
                return;

        struct AllocArena *paa = vp->paa;

        EnterCriticalSection( &paa->csExclusive );

        //
        // Record this free in the histogram
        //
        for( int i=31; i>=0; i-- )
                if( bytes & (1<<i) ) {
                        --(paa->Histogram.now[i]);
                        break;
                }

        paa->cFrees++;
        paa->cBytesNow -= bytes;

#if     defined( CANDOSTACK )
        if( paa->flags.KeepStackTrace ) {
                vp->count--;
                vp->bytes -= bytes;
        }
#endif

        LeaveCriticalSection( &paa->csExclusive );
}

STDAPI_( void )
AllocArenaDumpRecord( HeapAllocRec FAR *bp, BOOL fDumpSymbols )
{

        char achBuffer[ MAX_PATH ], *p;
        static int FirstTime = TRUE;

        // make sure we print the nice undecorated names
        if ( FirstTime && fDumpSymbols)
        {
            SymSetOptions( SYMOPT_UNDNAME | SYMOPT_DEFERRED_LOADS );
            FirstTime = FALSE;
        }


        heapDebugOut((DEB_WARN, "*** %d allocs, %u bytes:\n",
                         bp->count, bp->bytes ));

        for( int j=0; j<DEPTHTRACE && bp->fTrace[j]; j++ )
        {
            if(fDumpSymbols)
            {
                RealTranslate((ULONG_PTR)bp->fTrace[j],
                             achBuffer,
                             sizeof(achBuffer));

                if( p = strchr( achBuffer, '\n' ) )
                        *p = '\0';
                heapDebugOut((DEB_WARN, "       %s\n", achBuffer));
            }
            else
                heapDebugOut((DEB_WARN, "       0x%08x\n", bp->fTrace[j]));
        }

}

extern "C" ULONG DbgPrint( PCH Format, ... );

STDAPI_( void )
AllocArenaDump( AllocArena *paa, BOOL fDumpSymbols )
{
        if( paa == NULL ) {
                for( int i = 0; i < MAXARENAS && AllocArenas[i]; i++ )
                        AllocArenaDump( AllocArenas[i], fDumpSymbols );
                return;
        }

        char *cmdline = GetCommandLineA();

        if( cmdline == NULL )
                cmdline = "???";

        HeapAllocRec *bp = paa->AllocRec;
        HeapAllocRec *ep = bp + paa->cRecords;

        if( paa->cBytesNow )
                heapDebugOut((DEB_WARN, "***** %u bytes leaked mem for %s in '%s'\n", paa->cBytesNow, paa->comment, cmdline ));

#if     defined( CANDOSTACK )
        if( paa->cBytesNow && paa->flags.KeepStackTrace )
        {
                int cleaks = 0;

                for( ; bp < ep; bp++) {
                        if( bp->count )
                                ++cleaks;
                }

                if( cleaks ) {
                        heapDebugOut((DEB_WARN, "***** %s %u MEM LEAKS\n",
                                paa->comment, cleaks ));

                        if( heapInfoLevel & DEB_TRACE ) {
                                HeapAllocRec *bp;
                                UINT maxdump = MAXDUMP;
                                for( bp = paa->AllocRec; maxdump && bp<ep; bp++)
                                        if( bp->count ) {
                                                heapDebugOut((DEB_TRACE, "\n"));
                                                AllocArenaDumpRecord( bp, fDumpSymbols );
                                                maxdump--;
                                        }
                        } else if( cleaks )
                                heapDebugOut((DEB_WARN, "** Set ole32!heapInfoLevel to x707 for leak backtrace\n"));

                }
        }
#endif

        if( (heapInfoLevel & DEB_TRACE) && paa->cBytesTotal )
        {
                heapDebugOut((DEB_TRACE,"\n"));
                heapDebugOut((DEB_TRACE,
                        "'%s' Memory Stats: %u allocations, %u frees\n",
                        cmdline, paa->cAllocs, paa->cFrees ));

                if( paa->czAllocs )
                        heapDebugOut((DEB_TRACE,
                                "\t%u zero allocs\n", paa->czAllocs ));

                heapDebugOut((DEB_TRACE,
                                "\t%u bytes allocated\n", paa->cBytesTotal ));

                heapDebugOut((DEB_TRACE,
                                "*** Histogram of Allocated Mem Sizes ***\n"));

                heapDebugOut((DEB_TRACE, "  Min    Max\t  Tot\t Simul\n" ));
                for( int i=0; i < 32; i++ )
                        if( paa->Histogram.total[i] )
                        {
                                heapDebugOut((DEB_TRACE,
                                        "%6u -> %6u\t%6u\t%6u\n",
                                        1<<i, (1<<(i+1))-1,
                                        paa->Histogram.total[i],
                                        paa->Histogram.simul[i]
                                ));
                        }
        }
}

#endif  // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\class\cerror.cxx ===
//+-------------------------------------------------------------------
//
//  File:       cerror.cxx
//
//  Contents:   Implements COM extended error information.
//
//  Classes:    CErrorObject - Implements the COM error object.
//
//  Functions:  CoCreateErrorInfo = CreateErrorInfo
//              CoGetErrorInfo    = GetErrorInfo
//              CoSetErrorInfo    = SetErrorInfo
//
//  History:    20-Jun-96   MikeHill    Added more OleAut32 wrappers.
//
//--------------------------------------------------------------------
#include <ole2int.h>
#include <oleauto.h>
#include <chock.hxx>
#include <privoa.h>     // PrivSys* routines

HRESULT NdrStringRead(IStream *pStream, LPWSTR *psz);
ULONG   NdrStringSize(LPCWSTR psz);
HRESULT NdrStringWrite(IStream *pStream, LPCWSTR psz);

struct ErrorObjectData
{
    DWORD  dwVersion;
    DWORD  dwHelpContext;
    IID    iid;
};

class CErrorObject : public IErrorInfo, public ICreateErrorInfo, public IMarshal
{
private:
    long   _refCount;
    ErrorObjectData _data;
    LPWSTR _pszSource;
    LPWSTR _pszDescription;
    LPWSTR _pszHelpFile;

    ~CErrorObject();

public:
    CErrorObject();

    /*** IUnknown methods ***/
    HRESULT STDMETHODCALLTYPE QueryInterface(
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppv);

    ULONG STDMETHODCALLTYPE AddRef( void);

    ULONG STDMETHODCALLTYPE Release( void);

    /*** IMarshal methods ***/
    HRESULT STDMETHODCALLTYPE GetUnmarshalClass(
        /* [in] */ REFIID riid,
        /* [unique][in] */ void __RPC_FAR *pv,
        /* [in] */ DWORD dwDestContext,
        /* [unique][in] */ void __RPC_FAR *pvDestContext,
        /* [in] */ DWORD mshlflags,
        /* [out] */ CLSID __RPC_FAR *pCid);

    HRESULT STDMETHODCALLTYPE GetMarshalSizeMax(
        /* [in] */ REFIID riid,
        /* [unique][in] */ void __RPC_FAR *pv,
        /* [in] */ DWORD dwDestContext,
        /* [unique][in] */ void __RPC_FAR *pvDestContext,
        /* [in] */ DWORD mshlflags,
        /* [out] */ DWORD __RPC_FAR *pSize);

    HRESULT STDMETHODCALLTYPE MarshalInterface(
        /* [unique][in] */ IStream __RPC_FAR *pStm,
        /* [in] */ REFIID riid,
        /* [unique][in] */ void __RPC_FAR *pv,
        /* [in] */ DWORD dwDestContext,
        /* [unique][in] */ void __RPC_FAR *pvDestContext,
        /* [in] */ DWORD mshlflags);

    HRESULT STDMETHODCALLTYPE UnmarshalInterface(
        /* [unique][in] */ IStream __RPC_FAR *pStm,
        /* [in] */ REFIID riid,
        /* [out] */ void __RPC_FAR *__RPC_FAR *ppv);

    HRESULT STDMETHODCALLTYPE ReleaseMarshalData(
        /* [unique][in] */ IStream __RPC_FAR *pStm);

    HRESULT STDMETHODCALLTYPE DisconnectObject(
        /* [in] */ DWORD dwReserved);

    /*** IErrorInfo methods ***/
    HRESULT STDMETHODCALLTYPE GetGUID(
        /* [out] */ GUID __RPC_FAR *pGUID);

    HRESULT STDMETHODCALLTYPE GetSource(
        /* [out] */ BSTR __RPC_FAR *pBstrSource);

    HRESULT STDMETHODCALLTYPE GetDescription(
        /* [out] */ BSTR __RPC_FAR *pBstrDescription);

    HRESULT STDMETHODCALLTYPE GetHelpFile(
        /* [out] */ BSTR __RPC_FAR *pBstrHelpFile);

    HRESULT STDMETHODCALLTYPE GetHelpContext(
        /* [out] */ DWORD __RPC_FAR *pdwHelpContext);

    /*** ICreateErrorInfo methods ***/
    HRESULT STDMETHODCALLTYPE SetGUID(
        /* [in] */ REFGUID rguid);

    HRESULT STDMETHODCALLTYPE SetSource(
        /* [in] */ LPOLESTR szSource);

    HRESULT STDMETHODCALLTYPE SetDescription(
        /* [in] */ LPOLESTR szDescription);

    HRESULT STDMETHODCALLTYPE SetHelpFile(
        /* [in] */ LPOLESTR szHelpFile);

    HRESULT STDMETHODCALLTYPE SetHelpContext(
        /* [in] */ DWORD dwHelpContext);

};

//+-------------------------------------------------------------------
//
//  Function:   CoCreateErrorInfo
//
//  Synopsis:   Creates a COM error object.
//
//  Returns:    S_OK, E_OUTOFMEMORY, E_INVALIDARG.
//
//--------------------------------------------------------------------
WINOLEAPI
CoCreateErrorInfo(ICreateErrorInfo **ppCreateErrorInfo)
{
    HRESULT hr = S_OK;
    CErrorObject *pTemp;

    __try
    {
        *ppCreateErrorInfo = NULL;

        pTemp = new CErrorObject;

        if(pTemp != NULL)
        {
            *ppCreateErrorInfo = (ICreateErrorInfo *) pTemp;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CErrorObjectCF_CreateInstance
//
//  Synopsis:   Creates a COM error object.
//
//  Returns:    S_OK, E_OUTOFMEMORY, E_INVALIDARG.
//
//--------------------------------------------------------------------
HRESULT CErrorObjectCF_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void** ppv)
{
    Win4Assert(pUnkOuter == NULL);
    return CoCreateErrorInfo((ICreateErrorInfo **)ppv);
}

//+-------------------------------------------------------------------
//
//  Function:   CoGetErrorInfo
//
//  Synopsis:   Gets the error object for the current thread.
//
//  Returns:    S_OK, S_FALSE, E_INVALIDARG, E_NOINTERFACE.
//
//  Notes:      If sucessful, this function clears the error object
//              for the current thread.
//
//--------------------------------------------------------------------
WINOLEAPI
CoGetErrorInfo(DWORD dwReserved, IErrorInfo ** ppErrorInfo)
{
    HRESULT hr = S_OK;
    COleTls tls(hr);

    if(FAILED(hr))
    {
        //Could not access TLS.
        return hr;
    }

    if(dwReserved != 0)
    {
        return E_INVALIDARG;
    }

    __try
    {
        *ppErrorInfo = NULL;

        if(tls->punkError != NULL)
        {
            hr = tls->punkError->QueryInterface(IID_IErrorInfo, (void **) ppErrorInfo);
            if(SUCCEEDED(hr))
            {
                //Clear the error object.
                tls->punkError->Release();
                tls->punkError = NULL;
                hr = S_OK;
            }
        }
        else
        {
            hr = S_FALSE;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CoSetErrorInfo
//
//  Synopsis:   Sets the COM extended error information for the
//              current thread.
//
//  Returns:    S_OK, E_OUTOFMEMORY, E_INVALIDARG.
//
//--------------------------------------------------------------------
WINOLEAPI
CoSetErrorInfo(unsigned long dwReserved, IErrorInfo * pErrorInfo)
{
    HRESULT hr = S_OK;
    COleTls tls(hr);

    if(FAILED(hr))
    {
        //Could not access TLS.
        return hr;
    }

    if(dwReserved != 0)
    {
        return E_INVALIDARG;
    }

    __try
    {
        // Do this first, so that if the Release() reenters,
        // we're not pointing at them.
        // Some ADO destructor code will, indeed, do just that.
        //
        IUnknown * punkErrorOld = tls->punkError;
	tls->punkError = NULL;        

        //Release the old error object.
        if(punkErrorOld != NULL)
        {
            punkErrorOld->Release();
        }
	
        //AddRef the new error object.
        if(pErrorInfo != NULL)
        {
            pErrorInfo->AddRef();
        }
        
        // Set the error object for the current thread.
	tls->punkError = pErrorInfo;

        hr = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorObject::CErrorObject
//
//  Synopsis:   Constructor for COM error object.
//
//----------------------------------------------------------------------------
CErrorObject::CErrorObject()
  : _refCount(1),
    _pszSource(NULL),
    _pszDescription(NULL),
    _pszHelpFile(NULL)
{
    _data.dwVersion = 0;
    _data.dwHelpContext = 0;
    _data.iid = GUID_NULL;
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorObject::~CErrorObject
//
//  Synopsis:   Destructor for COM error object.
//
//----------------------------------------------------------------------------
CErrorObject::~CErrorObject()
{
    if(_pszSource != NULL)
        PrivMemFree(_pszSource);

    if(_pszDescription != NULL)
        PrivMemFree(_pszDescription);

    if(_pszHelpFile != NULL)
        PrivMemFree(_pszHelpFile);
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorObject::QueryInterface
//
//  Synopsis:   Gets a pointer to the specified interface.  The error object
//              supports the IErrorInfo, ICreateErrorInfo, IMarshal, and
//              IUnknown interfaces.
//
//  Returns:    S_OK, E_NOINTERFACE, E_INVALIDARG.
//
//  Notes:      Bad parameters will raise an exception.  The exception
//              handler catches exceptions and returns E_INVALIDARG.
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CErrorObject::QueryInterface(
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppv)
{
    HRESULT hr = S_OK;

    _try
    {
        *ppv = NULL;

        if (IsEqualIID(riid, IID_IMarshal))
        {
            AddRef();
            *ppv = (IMarshal *) this;
        }
        else if (IsEqualIID(riid, IID_IUnknown) ||
                 IsEqualIID(riid, IID_ICreateErrorInfo))
        {
            AddRef();
            *ppv = (ICreateErrorInfo *) this;
        }
        else if(IsEqualIID(riid, IID_IErrorInfo))
        {
            AddRef();
            *ppv = (IErrorInfo *) this;
        }
        else
        {
            hr = E_NOINTERFACE;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorObject::AddRef
//
//  Synopsis:   Increments the reference count.
//
//  Returns:    Reference count.
//
//----------------------------------------------------------------------------
ULONG STDMETHODCALLTYPE CErrorObject::AddRef()
{
    Win4Assert(_refCount > 0);

    InterlockedIncrement(&_refCount);
    return _refCount;
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorObject::Release
//
//  Synopsis:   Decrements the reference count.
//
//  Returns:    Reference count.
//
//----------------------------------------------------------------------------
ULONG STDMETHODCALLTYPE CErrorObject::Release()
{
    ULONG count = _refCount - 1;

    Win4Assert(_refCount > 0);

    if(0 == InterlockedDecrement(&_refCount))
    {
        delete this;
        count = 0;
    }
    return count;
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorObject::GetUnmarshalClass
//
//  Synopsis:   Get the CLSID of the COM error object.
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CErrorObject::GetUnmarshalClass(
    /* [in] */ REFIID riid,
    /* [unique][in] */ void __RPC_FAR *pv,
    /* [in] */ DWORD dwDestContext,
    /* [unique][in] */ void __RPC_FAR *pvDestContext,
    /* [in] */ DWORD mshlflags,
    /* [out] */ CLSID __RPC_FAR *pClassID)
{
    *pClassID = CLSID_ErrorObject;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorObject::GetMarshalSizeMax
//
//  Synopsis:   Get the size of the marshalled COM error object.
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CErrorObject::GetMarshalSizeMax(
    /* [in] */ REFIID riid,
    /* [unique][in] */ void __RPC_FAR *pv,
    /* [in] */ DWORD dwDestContext,
    /* [unique][in] */ void __RPC_FAR *pvDestContext,
    /* [in] */ DWORD mshlflags,
    /* [out] */ DWORD __RPC_FAR *pSize)
{
    ULONG cb;

    cb = sizeof(_data);
    cb += NdrStringSize(_pszSource);
    cb += NdrStringSize(_pszDescription);
    cb += NdrStringSize(_pszHelpFile);

    *pSize = cb;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorObject::MarshalInterface
//
//  Synopsis:   Marshal the COM error object.
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CErrorObject::MarshalInterface(
    /* [unique][in] */ IStream __RPC_FAR *pStream,
    /* [in] */ REFIID riid,
    /* [unique][in] */ void __RPC_FAR *pv,
    /* [in] */ DWORD dwDestContext,
    /* [unique][in] */ void __RPC_FAR *pvDestContext,
    /* [in] */ DWORD mshlflags)
{
    HRESULT hr;

    hr = pStream->Write(&_data, sizeof(_data), NULL);

    if(SUCCEEDED(hr))
        hr = NdrStringWrite(pStream, _pszSource);

    if(SUCCEEDED(hr))
        hr = NdrStringWrite(pStream, _pszDescription);

    if(SUCCEEDED(hr))
        hr = NdrStringWrite(pStream, _pszHelpFile);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorObject::UnmarshalInterface
//
//  Synopsis:   Unmarshal the COM error object.
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CErrorObject::UnmarshalInterface(
    /* [unique][in] */ IStream __RPC_FAR *pStream,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv)
{
    HRESULT hr;

    *ppv = NULL;

    //Clear the error object.
    if(_pszSource != NULL)
    {
        PrivMemFree(_pszSource);
        _pszSource = NULL;
    }

    if(_pszDescription != NULL)
    {
        PrivMemFree(_pszDescription);
        _pszDescription = NULL;
    }

    if(_pszHelpFile != NULL)
    {
        PrivMemFree(_pszHelpFile);
        _pszHelpFile = NULL;
    }

    hr = pStream->Read(&_data, sizeof(_data), NULL);

    if(SUCCEEDED(hr))
        hr = NdrStringRead(pStream, &_pszSource);

    if(SUCCEEDED(hr))
        hr = NdrStringRead(pStream, &_pszDescription);

    if(SUCCEEDED(hr))
        hr = NdrStringRead(pStream, &_pszHelpFile);

    //Check the version.
    if(_data.dwVersion > 0)
    {
        _data.dwVersion = 0;
    }

    if(SUCCEEDED(hr))
    {
        hr = QueryInterface(riid, ppv);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorObject::ReleaseMarshalData
//
//  Synopsis:   Release a marshalled COM error object.
//
//  Notes:      Just seek to the end of the marshalled error object.
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CErrorObject::ReleaseMarshalData(
    /* [unique][in] */ IStream __RPC_FAR *pStm)
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorObject::DisconnectObject
//
//  Synopsis:   Disconnect the object.
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CErrorObject::DisconnectObject(
    /* [in] */ DWORD dwReserved)
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorObject::GetDescription
//
//  Synopsis:   Gets a textual description of the error.
//
//  Returns:    S_OK, E_OUTOFMEMORY, E_INVALIDARG.
//
//  Notes:      Not thread-safe.
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CErrorObject::GetDescription(
    /* [out] */ BSTR __RPC_FAR *pBstrDescription)
{
    HRESULT hr = S_OK;
    BSTR pTemp;

    __try
    {
        *pBstrDescription = NULL;

        if(_pszDescription != NULL)
        {
            pTemp = PrivSysAllocString(_pszDescription);
            if(pTemp != NULL)
            {
                *pBstrDescription = pTemp;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorObject::GetGUID
//
//  Synopsis:   Gets the IID of the interface that defined the error.
//
//  Returns:    S_OK, E_INVALIDARG.
//
//  Notes:      Not thread-safe.
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CErrorObject::GetGUID(
    /* [out] */ GUID __RPC_FAR *pGUID)
{
    HRESULT hr = S_OK;

    __try
    {
        *pGUID = _data.iid;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorObject::GetHelpContext
//
//  Synopsis:   Gets the Help context ID for the error.
//
//  Returns:    S_OK, E_INVALIDARG.
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CErrorObject::GetHelpContext(
    /* [out] */ DWORD __RPC_FAR *pdwHelpContext)
{
    HRESULT hr = S_OK;

    __try
    {
        *pdwHelpContext = _data.dwHelpContext;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorObject::GetHelpFile
//
//  Synopsis:   Gets the path of the help file that describes the error.
//
//  Returns:    S_OK, E_OUTOFMEMORY, E_INVALIDARG.
//
//  Notes:      Not thread-safe.
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CErrorObject::GetHelpFile(
    /* [out] */ BSTR __RPC_FAR *pBstrHelpFile)
{
    HRESULT hr = S_OK;
    BSTR pTemp;

    __try
    {
        *pBstrHelpFile = NULL;

        if(_pszHelpFile != NULL)
        {
            pTemp = PrivSysAllocString(_pszHelpFile);
            if(pTemp != NULL)
            {
                *pBstrHelpFile = pTemp;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorObject::GetSource
//
//  Synopsis:   Gets the ProgID of the class that is the source of the error.
//
//  Returns:    S_OK, E_OUTOFMEMORY, E_INVALIDARG.
//
//  Notes:      Not thread-safe.
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CErrorObject::GetSource(
    /* [out] */ BSTR __RPC_FAR *pBstrSource)
{
    HRESULT hr = S_OK;
    BSTR pTemp;

    __try
    {
        *pBstrSource = NULL;

        if(_pszSource != NULL)
        {
            pTemp = PrivSysAllocString(_pszSource);
            if(pTemp != NULL)
            {
                *pBstrSource = pTemp;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Method:     CErrorObject::SetDescription
//
//  Synopsis:   Sets the textual description of the error.
//
//  Returns:    S_OK, E_OUTOFMEMORY, E_INVALIDARG.
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CErrorObject::SetDescription(
    /* [in] */ LPOLESTR pszDescription)
{
    HRESULT hr = S_OK;
    LPOLESTR pTemp = NULL;
    ULONG cb;

    __try
    {
        if(pszDescription != NULL)
        {
            cb = (wcslen(pszDescription) + 1) * sizeof(OLECHAR);
            pTemp = (LPOLESTR) PrivMemAlloc(cb);
            if(pTemp != NULL)
            {
                memcpy(pTemp, pszDescription, cb);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        if(SUCCEEDED(hr))
        {
            pTemp = (LPOLESTR) InterlockedExchangePointer((PVOID *)&_pszDescription,
                                                          (PVOID) pTemp);
            if(pTemp != NULL)
            {
                PrivMemFree(pTemp);
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorObject::SetGUID
//
//  Synopsis:   Sets the IID of the interface that defined the error.
//
//  Returns:    S_OK, E_INVALIDARG.
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CErrorObject::SetGUID(
    /* [in] */ REFGUID rguid)
{
    HRESULT hr = S_OK;

    __try
    {
        _data.iid = rguid;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorObject::SetHelpContext
//
//  Synopsis:   Sets the Help context ID for the error.
//
//  Returns:    S_OK.
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CErrorObject::SetHelpContext(
    /* [in] */ DWORD dwHelpContext)
{
    _data.dwHelpContext = dwHelpContext;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorObject::SetHelpFile
//
//  Synopsis:   Sets the path of the Help file that describes the error.
//
//  Returns:    S_OK, E_OUTOFMEMORY, E_INVALIDARG.
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CErrorObject::SetHelpFile(
    /* [in] */ LPOLESTR pszHelpFile)
{
    HRESULT hr = S_OK;
    LPOLESTR pTemp = NULL;
    ULONG cb;

    __try
    {
        if(pszHelpFile != NULL)
        {
            cb = (wcslen(pszHelpFile) + 1) * sizeof(OLECHAR);
            pTemp = (LPOLESTR) PrivMemAlloc(cb);
            if(pTemp != NULL)
            {
                memcpy(pTemp, pszHelpFile, cb);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        if(SUCCEEDED(hr))
        {
            pTemp = (LPOLESTR) InterlockedExchangePointer((PVOID *)&_pszHelpFile,
                                                          (PVOID) pTemp);
            if(pTemp != NULL)
            {
                PrivMemFree(pTemp);
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorObject::SetSource
//
//  Synopsis:   Sets the source of the error.
//
//  Returns:    S_OK, E_OUTOFMEMORY, E_INVALIDARG.
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CErrorObject::SetSource(
    /* [in] */ LPOLESTR pszSource)
{
    HRESULT hr = S_OK;
    LPOLESTR pTemp = NULL;
    ULONG cb;

    __try
    {
        if(pszSource != NULL)
        {
            cb = (wcslen(pszSource) + 1) * sizeof(OLECHAR);
            pTemp = (LPOLESTR) PrivMemAlloc(cb);
            if(pTemp != NULL)
            {
                memcpy(pTemp, pszSource, cb);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        if(SUCCEEDED(hr))
        {
            pTemp = (LPOLESTR) InterlockedExchangePointer((PVOID *)&_pszSource,
                                                          (PVOID) pTemp);
            if(pTemp != NULL)
            {
                PrivMemFree(pTemp);
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }
    return hr;
}


struct NdrStringHeader
{
    DWORD dwMax;
    DWORD dwOffset;
    DWORD dwActual;
};

struct NdrStringPtrHeader
{
    DWORD dwUnique;
    DWORD dwMax;
    DWORD dwOffset;
    DWORD dwActual;
};

//+---------------------------------------------------------------------------
//
//  Function:   NdrStringRead
//
//  Synopsis:   Reads a string from a stream in NDR format.
//
//  Notes:      The NDR format of a string is the following.
//              DWORD - Represents the unique pointer.
//              DWORD - Maximum number of elements.
//              DWORD - offset.
//              DWORD - Actual number of elements.
//              NULL terminated UNICODE string.
//
//----------------------------------------------------------------------------
HRESULT NdrStringRead(IStream *pStream, LPWSTR *ppsz)
{
    HRESULT hr = S_OK;
    DWORD dwUnique = 0;
    ULONG cbRead = 0;

    *ppsz = NULL;

    //Check for a NULL pointer.
    hr = pStream->Read(&dwUnique, sizeof(dwUnique), &cbRead);

    if(FAILED(hr))
        return hr;

    Win4Assert(sizeof(dwUnique) == cbRead);

    if(dwUnique != 0)
    {
        LPWSTR pTemp = NULL;
        NdrStringHeader hdr;

        hr = pStream->Read(&hdr, sizeof(hdr), &cbRead);

        if(FAILED(hr))
            return hr;

        Win4Assert(sizeof(hdr) == cbRead);
        Win4Assert(hdr.dwMax >= hdr.dwOffset + hdr.dwActual);
        Win4Assert(0 == hdr.dwOffset);

        pTemp = (LPWSTR) PrivMemAlloc(hdr.dwMax * sizeof(WCHAR));

        if(pTemp != NULL)
        {
            hr = pStream->Read(pTemp,
                               hdr.dwActual * sizeof(WCHAR),
                               &cbRead);
            if(SUCCEEDED(hr))
            {
                Win4Assert(hdr.dwActual * sizeof(WCHAR) == cbRead);
                *ppsz = pTemp;
                hr = S_OK;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   NdrStringSize
//
//  Synopsis:   Computes the size of a marshalled string.
//
//----------------------------------------------------------------------------
ULONG NdrStringSize(LPCWSTR psz)
{
    ULONG cb;

    if(psz != NULL)
    {
        cb = sizeof(NdrStringPtrHeader);
        cb += (wcslen(psz) + 1) * sizeof(WCHAR);
    }
    else
    {
        cb = sizeof(DWORD);
    }

    return cb;
}

//+---------------------------------------------------------------------------
//
//  Function:   NdrStringWrite
//
//  Synopsis:   Writes a string to a stream in NDR format.
//
//  Notes:      The NDR format of a string is shown below.
//              DWORD - Represents the unique pointer.
//              DWORD - Maximum number of elements.
//              DWORD - offset.
//              DWORD - Number of elements.
//              NULL terminated UNICODE string.
//
//----------------------------------------------------------------------------
HRESULT NdrStringWrite(IStream *pStream, LPCWSTR psz)
{
    HRESULT hr = S_OK;
    ULONG cbWritten;

    //Check for a NULL pointer.
    if(psz != NULL)
    {
        NdrStringPtrHeader hdr;

        //Write the header.
        hdr.dwUnique = 0xFFFFFFFF;
        hdr.dwMax = wcslen(psz) + 1;
        hdr.dwOffset = 0;
        hdr.dwActual = hdr.dwMax;
        hr = pStream->Write(&hdr, sizeof(hdr), &cbWritten);

        if(SUCCEEDED(hr))
        {
            hr = pStream->Write(psz, hdr.dwActual * sizeof(WCHAR), &cbWritten);
        }
    }
    else
    {
        DWORD dwUnique = 0;

        //Write a NULL unique pointer.
        hr = pStream->Write(&dwUnique, sizeof(dwUnique), &cbWritten);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\class\compobj.cxx ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1994.
//
//  File:       d:\nt\private\cairole\com\class\compobj.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:  GetInfoLevel
//              DllMain
//              CheckAndStartSCM
//              CoGetCurrentProcess
//              CoBuildVersion
//              SetOleThunkWowPtr
//              CoInitializeWOW
//              CoInitialize
//              CoInitializeEx
//              CoUninitialize
//
//  History:    09-Jun-94   BruceMa    Added this file header
//              09-Jun-94   BruceMa    Distinguish CoInitialize errors
//              14-Jun-94   BruceMa    Ensure single threading
//              17-Jun-94   Bradlo     Add SetState/GetState
//              06-Jul-94   BruceMa    Support for CoGetCurrentProcess
//              28-Jul-94   BruceMa    Allow CoGetCurrentProcess to do a
//                                     partial CoInitialize (because Publisher
//                                     didn't call CoInitialize (!))
//              29-Aug-94   AndyH      set the locale for the CRT
//              29-Sep-94   AndyH      remove setlocale call
//              06-Oct-94   BruceMa    Allow CoGetCurrentProcess to work even
//                                     if that thread didn't call CoInitialize
//              09-Nov-94   BruceMa    Initialize/Delete IMallocSpy
//                                      critical section
//              12-Dec-94   BruceMa    Delete Chicago pattern table at
//                                      CoUninitialize
//              09-Jan-95   BruceMa    Initialize/Delete ROT
//                                      critical section
//              10-May-95   KentCe     Defer Heap Destruction to the last
//                                      process detach.
//              28-Aug-95   BruceMa    Close g_hRegPatTblEvent at
//                                      ProcessUninitialize
//              25-Sep-95   BruceMa    Check that scm is started during
//                                      CoInitialize
//              25-Oct-95   Rickhi     Improve CoInit Time.
//              20-Jan-96   RichN      Add Rental model
//              04-Dec-97   ronan      Com Internet Services - self registration for objrefs
//              10-Feb-99   TarunA     Allow async sends to finish
//
//----------------------------------------------------------------------
// compobj.cpp - main file for the compobj dll

#include <ole2int.h>
#include <verole.h>     // for CoBuildVersion
#include <thunkapi.hxx> // For interacting with the VDM
#include <hkole32.h>    // For InitHookOle

#include <cevent.hxx>
#include <olespy.hxx>

#include "pattbl.hxx"
#include "pexttbl.hxx"

#include <olepfn.hxx>
#include "..\dcomrem\channelb.hxx"
#include "..\dcomrem\call.hxx"
#include "..\dcomrem\context.hxx"
#include "..\dcomrem\crossctx.hxx"
#include "..\dcomrem\aprtmnt.hxx"
#include "..\objact\actvator.hxx"
#include "..\objact\dllcache.hxx"
#include <excepn.hxx>       // Exception filter routines

#include "rwlock.hxx"

//extern HINSTANCE g_hCallFrameLib;

#if DBG==1
#include <outfuncs.h>
#endif

#if LOCK_PERF==1
void OutputHashPerfData();
#endif

NAME_SEG(CompObj)
ASSERTDATA

HRESULT Storage32DllGetClassObject(REFCLSID clsid, REFIID iid, void **ppv);
HRESULT MonikerDllGetClassObject(REFCLSID clsid, REFIID iid, void **ppv);
HRESULT Ole232DllGetClassObject(REFCLSID clsid, REFIID iid, void **ppv);
EXTERN_C HINSTANCE hProxyDll;
EXTERN_C HRESULT PrxDllRegisterServer(void);
EXTERN_C HRESULT ComcatDllRegisterServer(void);
EXTERN_C HRESULT ObjrefDllRegisterServer(void);
EXTERN_C HRESULT TxfDllRegisterServer(void);
EXTERN_C HRESULT ProxyDllGetClassObject(REFCLSID clsid, REFIID iid, void **ppv);

extern BOOL CatalogDllMain (
    HINSTANCE hInst,
    DWORD dwReason,
    LPVOID lpReserved
);

extern "C"
BOOL WINAPI TxfDllMain (
	HINSTANCE hInstance, 
	DWORD dwReason, 
	LPVOID /*lpReserved*/
);

HRESULT FixUpPipeRegistry(void);

HRESULT MallocInitialize(BOOL fForceRetailAlloc);
BOOL    MallocUninitialize(BOOL fDumpSymbols);

STDAPI  OleReleaseEnumVerbCache();
extern void ClipboardProcessUninitialize();
extern void CleanROTForApartment();
extern HRESULT DllHostProcessInitialize();
extern void DllHostThreadUninitialize();
extern void DllHostProcessUninitialize();
extern BOOL IsMTAHostInitialized();
extern ULONG gcHostProcessInits;
extern ULONG gcNAHosts;
extern void GIPTableProcessUninitialize();
extern void GIPTableApartmentUninitialize();
extern void CleanupTlsMap(BOOL fDynamic);
extern void ProcessUninitTlsCleanup(void);
extern void AssertDebugInit();

extern CProcessPatternTbl *g_pPatTbl;
extern CProcessExtensionTbl *g_pExtTbl;

extern void ScmGetThreadId( DWORD * pThreadID );

static long g_cCoSetState = 0;          // # of outstanding CoSetState calls
static HINSTANCE g_hOleAut32 = NULL;    // module handle of oleaut32
static COleStaticMutexSem g_mxsCoSetState;

STDAPI CoSetState(IUnknown *punkStateNew);
WINOLEAPI CoSetErrorInfo(DWORD dwReserved, IErrorInfo * pErrorInfo);

void ProcessUninitialize( void );
void DoThreadSpecificCleanup();
void WaitForPendingAsyncSends();

COleStaticMutexSem  g_mxsSingleThreadOle; // CS to prevent both STA/MTA init races
COleStaticMutexSem  gMTAInitLock;         // CS to protect MTA init races
DWORD               gcInitingMTA;         // Number of threads trying to init MTA

// The following pointer is used to hold an interface to the
// WOW thunk interface.

LPOLETHUNKWOW     g_pOleThunkWOW = NULL;

// The following is the count of per-process CoInitializes that have been done.
DWORD             g_cProcessInits  = 0;     // total per process inits
DWORD             g_cMTAInits      = 0;     // # of multi-threaded inits
DWORD             g_cSTAInits      = 0;     // # of apartment-threaded inits
BOOL              g_fShutdownHosts = FALSE; // Shutdown hosts
CObjectContext   *g_pMTAEmptyCtx   = NULL;  // MTA empty context
CObjectContext   *g_pNTAEmptyCtx   = NULL;  // NTA empty context

// Holds the process id of SCM.  DCOM uses this to unmarshal an object
// interface on the SCM.  See MakeSCMProxy in dcomrem\ipidtbl.cxx.
DWORD gdwScmProcessID = 0;

extern CComApartment* gpMTAApartment;     // global MTA Apartment
extern CComApartment* gpNTAApartment;     // global NTA Apartment

INTERNAL CleanupLeakedDomainStack (COleTls& Tls, CObjectContext* pCorrectCtx);


#if DBG==1
//---------------------------------------------------------------------------
//
//  function:   GetInfoLevel
//
//  purpose:    This routine is called when a process attaches. It extracts
//              the debug info levels values from win.ini.
//
//---------------------------------------------------------------------------

//  externals used below in calls to this function

extern "C" unsigned long heapInfoLevel;     //  memory tracking
//Set ole32!heapInfoLevel != 0 to use the OLE debug allocator in debug build.
//Set ole32!heapInfoLevel & DEB_ITRACE for backtrace of memory leaks in debug build.

extern "C" unsigned long olInfoLevel;       //  lower layer storage
extern "C" unsigned long msfInfoLevel;      //  upper layer storage
extern "C" unsigned long filestInfoLevel;   //  Storage file ILockBytes
extern "C" unsigned long simpInfoLevel;     //  Simple mode storage
extern "C" unsigned long astgInfoLevel;     //  Async storage
extern "C" unsigned long LEInfoLevel;       //  linking and embedding
extern "C" unsigned long RefInfoLevel;      //  CSafeRef class
extern "C" unsigned long DDInfoLevel;       //  Drag'n'drop
extern "C" unsigned long mnkInfoLevel;      //  Monikers
extern "C" unsigned long propInfoLevel;     //  properties

extern DWORD g_dwInfoLevel;

DECLARE_INFOLEVEL(intr);                  // For 1.0/2.0 interop
DECLARE_INFOLEVEL(UserNdr);               // For Oleprxy32 and NDR
DECLARE_INFOLEVEL(Stack);                 // For stack switching
DECLARE_INFOLEVEL(ClsCache);              // Class Cache
DECLARE_INFOLEVEL(RefCache);              // Reference Cache
DECLARE_INFOLEVEL(Call);                  // Call tracing
DECLARE_INFOLEVEL(Context);               // Context


ULONG GetInfoLevel(CHAR *pszKey, ULONG *pulValue, CHAR *pszdefval)
{
    CHAR    szValue[20];
    DWORD   cbValue = sizeof(szValue);

    // if the default value has not been overridden in the debugger,
    // then get it from win.ini.

    if (*pulValue == (DEB_ERROR | DEB_WARN))
    {
        if (GetProfileStringA("CairOLE InfoLevels", // section
                          pszKey,               // key
                          pszdefval,             // default value
                          szValue,              // return buffer
                          cbValue))
        {
            *pulValue = strtoul (szValue, NULL, 16);
        }
    }

    return  *pulValue;
}
// stack switching is by defaul on

extern ULONG g_dwInterceptLevel;

VOID GetInterceptorLevel()
{
    CHAR    szValue[20];
    DWORD   cbValue = sizeof(szValue);
    CHAR   *pszdefval = "0x10000001";               // ON | NOINOUT    

    if (GetProfileStringA("CairOLE",                // section
                          "Interceptors",           // key
                          pszdefval,                // default value
                          szValue,                  // return buffer
                          cbValue))
    {
        g_dwInterceptLevel = strtoul (szValue, NULL, 16);
    }
}

BOOL fSSOn = TRUE;

#endif // DBG


//+-------------------------------------------------------------------------
//
//  Function:   ObjRefDllRegisterServer
//
//  Synopsis:   add OBJREF moniker to the registry
//
//  History:    21-Jan-98 RonanS    Created
//
//--------------------------------------------------------------------------
STDAPI ObjrefDllRegisterServer(void)
{
    HKEY hKeyCLSID, hKeyInproc32,  hkObjref, hkProgId;
    DWORD dwDisposition;
    HRESULT hr;

    // create clsid key
    hr = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                    _T("CLSID\\{00000327-0000-0000-C000-000000000046}"),
                    NULL, _T(""), REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                    &hKeyCLSID, &dwDisposition);

    if (SUCCEEDED(hr))
    {
        // set short name
        hr = RegSetValueEx(hKeyCLSID, _T(""), NULL, REG_SZ, (BYTE*) _T("objref"), sizeof(TCHAR)*(lstrlen(_T("objref"))+1));
        if (SUCCEEDED(hr))
        {
            // set up inproc server
            hr = RegCreateKeyEx(hKeyCLSID,
                          _T("InprocServer32"),
                          NULL, _T(""), REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                          &hKeyInproc32, &dwDisposition);

            if (SUCCEEDED(hr))
            {
                TCHAR szName[] = _T("OLE32.DLL");
                hr = RegSetValueEx(hKeyInproc32, _T(""), NULL, REG_SZ, (BYTE*) szName, sizeof(TCHAR)*(lstrlen(szName)+1));

                if (SUCCEEDED(hr))
                    hr = RegSetValueEx(hKeyInproc32, _T("ThreadingModel"), NULL, REG_SZ, (BYTE*) _T("Both"), sizeof(_T("Both")));

                RegCloseKey(hKeyInproc32);
            }

            // set up progid
            if (SUCCEEDED(hr))
                hr = RegCreateKeyEx(hKeyCLSID,
                       _T("ProgID"),
                       NULL, _T(""), REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                       &hkProgId, &dwDisposition);

            if (SUCCEEDED(hr))
            {
                TCHAR szProgId[] = _T("objref");
                hr = RegSetValueEx(hkProgId, _T(""), NULL, REG_SZ, (BYTE*) szProgId, sizeof(TCHAR)*(lstrlen(szProgId)+1));
                RegCloseKey(hkProgId);
            }
        }

        RegCloseKey(hKeyCLSID);
    }

    if (FAILED(hr))
        return E_UNEXPECTED;

    // RegCreateKeyEx will open the key if it exists
    hr = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                    _T("objref"),
                    NULL, _T(""), REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                    &hkObjref, &dwDisposition);

    if (SUCCEEDED(hr))
    {
        // set short name
        hr = RegSetValueEx(hkObjref, _T(""), NULL, REG_SZ, (BYTE*) _T("objref"), sizeof(TCHAR)*(lstrlen(_T("objref"))+1));


        if (SUCCEEDED(hr))
            hr = RegCreateKeyEx(hkObjref,
                     _T("CLSID"),
                     NULL, _T(""), REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                     &hKeyCLSID, &dwDisposition);

        if (SUCCEEDED(hr))
        {
             TCHAR szClsid[] = _T("{00000327-0000-0000-C000-000000000046}");
             hr = RegSetValueEx(hKeyCLSID, _T(""), NULL, REG_SZ, (BYTE*) szClsid, sizeof(TCHAR)*(lstrlen(szClsid)+1));
             RegCloseKey(hKeyCLSID);
        }

        RegCloseKey(hkObjref);
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   ObjRefDllUnRegisterServer
//
//  Synopsis:   remove OBJREF moniker from the registry
//
//  History:    21-Jan-98 RonanS    Created
//
//--------------------------------------------------------------------------
STDAPI ObjrefDllUnregisterServer(void)
{
    if (RegDeleteKeyT(HKEY_CLASSES_ROOT,
           _T("CLSID\\{00000327-0000-0000-C000-000000000046}\\InprocServer32"))!=ERROR_SUCCESS)
    {
        return E_UNEXPECTED;
    }
    if (RegDeleteKeyT(HKEY_CLASSES_ROOT,
           _T("CLSID\\{00000327-0000-0000-C000-000000000046}\\ProgID"))!=ERROR_SUCCESS)
    {
        return E_UNEXPECTED;
    }
    if (RegDeleteKeyT(HKEY_CLASSES_ROOT,
           _T("CLSID\\{00000327-0000-0000-C000-000000000046}"))!=ERROR_SUCCESS)
    {
        return E_UNEXPECTED;
    }

    if (RegDeleteKeyT(HKEY_CLASSES_ROOT,
           _T("objref\\CLSID"))!=ERROR_SUCCESS)
    {
        return E_UNEXPECTED;
    }

    if (RegDeleteKeyT(HKEY_CLASSES_ROOT,
               _T("objref"))!=ERROR_SUCCESS)
    {
       return E_UNEXPECTED;
    }

    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Function:   DllRegisterServer
//
//  Synopsis:   Dll entry point
//
//  Arguments:  none
//
//  Returns:    S_OK - class register successfully.
//
//  History:    10-Mar-97 YongQu    Created
//
//  Note:       merge component category
//--------------------------------------------------------------------------
STDAPI  DllRegisterServer(void)
{
    HRESULT hr;

    hr = PrxDllRegisterServer();
    if (FAILED(hr))
        return hr;

    hr = ObjrefDllRegisterServer();
    if (FAILED(hr))
        return hr;

    hr = ComcatDllRegisterServer();
    if (FAILED(hr))
        return hr;

    hr = Storage32DllRegisterServer();
    if (FAILED(hr))
        return hr;

    hr = FixUpPipeRegistry();
	if (FAILED(hr))
		return hr;

	hr = TxfDllRegisterServer();

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Dll entry point
//
//  Arguments:  [clsid] - class id for new class
//              [iid] - interface required of class
//              [ppv] - where to put new interface
//
//  Returns:    S_OK - class object created successfully created.
//
//  History:    21-Jan-94 Ricksa    Created
//
//--------------------------------------------------------------------------
STDAPI  DllGetClassObject(REFCLSID clsid, REFIID iid, void **ppv)
{
    OLETRACEIN((API_DllGetClassObject, PARAMFMT("rclsid= %I,iid= %I,ppv= %p"),
               &clsid, &iid, ppv));

    // try proxy dll first, since it is the most common case.
    HRESULT hr = ProxyDllGetClassObject(clsid, iid, ppv);
    if (FAILED(hr))
    {
        // second most common case
        hr = ComDllGetClassObject( clsid, iid, ppv );
        if (FAILED(hr))
        {
            hr = Storage32DllGetClassObject(clsid, iid, ppv);
            if (FAILED(hr))
            {
                hr = MonikerDllGetClassObject(clsid, iid, ppv);
                if (FAILED(hr))
                {
                    // Ole232 will succeed for any class id so it MUST
                    // be the last one in the list.
                    if (IsEqualCLSID(clsid, CLSID_ATHostActivator))
                    {
                        hr = REGDB_E_CLASSNOTREG;
                    }
                    else
                    {
                        hr = Ole232DllGetClassObject(clsid, iid, ppv);
                    }
                }
            }
        }
    }

    OLETRACEOUT((API_DllGetClassObject, hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   PrintLeaks      Private
//
//  History:    15-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
#if DBG==1
void __cdecl PrintLeaks()
{
    MallocUninitialize(TRUE);
}
#endif
//+-------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   Dll entry point for OLE/COM
//
//  Arguments:  [hDll]          - a handle to the dll instance
//              [dwReason]      - the reason LibMain was called
//              [lpvReserved]   - NULL - called due to FreeLibrary
//                              - non-NULL - called due to process exit
//
//  Returns:    TRUE on success, FALSE otherwise
//
//  Notes:
//              If we are called because of FreeLibrary, then we should do as
//              much cleanup as we can. If we are called because of process
//              termination, we should not do any cleanup, as other threads in
//              this process will have already been killed, potentially while
//              holding locks around resources.
//
//              The officially approved DLL entrypoint name is DllMain. This
//              entry point will be called by the CRT Init function.
//
//  History:    06-Dec-93 Rickhi    dont do cleanup on process exit
//              09-Nov-94 BruceMa   Initialize/Delete IMallocSpy
//                                   critical section
//              16-Jan-95 KevinRo   Changed to DllMain to remove a bunch
//                                  of unneeded code and calls
//
//--------------------------------------------------------------------------
extern "C" BOOL WINAPI DllMain(
    HANDLE hInstance,
    DWORD dwReason,
    LPVOID lpvReserved)
{
    HRESULT hr;

    //Initialize hInstance for PrxDllRegisterServer.
    hProxyDll = (HINSTANCE) hInstance;

    if (dwReason == DLL_PROCESS_DETACH)
    {
        CairoleDebugOut((DEB_DLL,
                         "DLL_PROCESS_DETACH: %s\n",
                         lpvReserved?"Process Exit":"Dll Unload"));

        // Process is exiting so lets clean up if we have to
#if LOCK_PERF==1
        OutputHashPerfData();
#endif

#if DBG==1
        // Update state to indicate process detach
        CairoleAssert (g_fDllState == DLL_STATE_NORMAL);
        g_fDllState = DLL_STATE_PROCESS_DETACH;
#endif

        // Do Thread specific cleanup
        ThreadNotification((HINSTANCE)hInstance, dwReason, lpvReserved);

        //
        // When there is a FreeLibrary, and we still have initialized OLE
        // com threads, then try to get rid of all of the global process
        // stuff we are maintaining.
        //
        if (g_cProcessInits != 0 && lpvReserved == NULL )
        {
            // Cleanup process
            ProcessUninitialize();

            // UnInitialize HookOle.
            // This unloads the Hookole dll.
            UninitHookOle();
        }

        //  Clean up catalog
        (void) CatalogDllMain ( (HINSTANCE) hInstance, dwReason, lpvReserved);

        //  Clean up txfaux
        (void) TxfDllMain ( (HINSTANCE) hInstance, dwReason, lpvReserved);

        // Cleanup TLS map
        CleanupTlsMap(lpvReserved ? FALSE : TRUE);

        // Uninitialize memory allocator
        MallocUninitialize(TRUE);

#if DBG==1
        CloseDebugSinks();
#endif

        //
        //  Only bother to rundown the static mutex pool if we're being
        //  unloaded w/o exiting the process
        //

#if LOCK_PERF!=1
        // When monitoring the locks, we do need individual lock cleanup.
        if (lpvReserved == NULL)
        {
#endif
            // Cleanup Reader-Writer locks
            gPSRWLock.Cleanup();
            CClassCache::_mxs.Cleanup();

            //
            //      Destruct the static mutex pool
            //

            while (g_pInitializedStaticMutexList != NULL)
            {
                COleStaticMutexSem * pMutex;

                pMutex = g_pInitializedStaticMutexList;
                g_pInitializedStaticMutexList = pMutex->pNextMutex;
                pMutex->Destroy();
            }

#if LOCK_PERF!=1
        }
#endif

        DeleteCriticalSection (&g_OleMutexCreationSem);
        DeleteCriticalSection (&g_OleGlobalLock);

#if LOCK_PERF==1
        // This must be done after the cleanup block for locks above
        // The destroy routines of locks report contention counts etc.
        gLockTracker.OutputPerfData();
#endif


#if DBG==1
        // Update state to indicate that static objects are
        // being destroyed
        g_fDllState = DLL_STATE_STATIC_DESTRUCTING;
#endif

        return TRUE;
    }


    else if (dwReason == DLL_PROCESS_ATTACH)
    {
        // Initialize the mutex package. Do this BEFORE doing anything
        // else, as even a DebugOut will fault if the critical section
        // is not initialized.
		
        NTSTATUS status;
        status = RtlInitializeCriticalSection(&g_OleMutexCreationSem);
        if (!NT_SUCCESS(status))
            return FALSE;

        status = RtlInitializeCriticalSection(&g_OleGlobalLock);
        if (!NT_SUCCESS(status))
            return FALSE;

#if LOCK_PERF==1
        hr = gLockTracker.Init(); //static initialization function
        CairoleAssert(SUCCEEDED(hr));
#endif
        // Initialize Reader-Writer locks
        CStaticRWLock::InitDefaults();
        gPSRWLock.Initialize();
        CClassCache::_mxs.Initialize();


        ComDebOut((DEB_DLL,"DLL_PROCESS_ATTACH:\n"));

        //
        //  Initialize catalog
        //

        (void) CatalogDllMain ( (HINSTANCE) hInstance, dwReason, lpvReserved);


#if DBG==1

        // Can't use Win4Assert (NULL == GetModuleHandle(_T("csrsrv.dll")));
        // because a window will attempt to be created by MessageBox which crashes
        // CSRSS.

        if (GetModuleHandle(_T("csrsrv.dll")) != NULL)
        {
            // Loaded into CSRSS, so debug output and breakpoint
            CairoleDebugOut((DEB_ERROR, "OLE32 can't be loaded into CSRSS. File a bug against code loading OLE32, not OLE32 itself!\n"));
            DebugBreak();
        }

        // Note that we've completed running the static constructors

        CairoleAssert (g_fDllState == DLL_STATE_STATIC_CONSTRUCTING);

        g_fDllState = DLL_STATE_NORMAL;

#endif


#if DBG==1
        AssertDebugInit();
        OpenDebugSinks(); // Set up for logging

        //  set the various info levels
        GetInfoLevel("cairole", &CairoleInfoLevel, "0x0003");
        GetInfoLevel("ol", &olInfoLevel, "0x0003");
        GetInfoLevel("msf", &msfInfoLevel, "0x0003");
        GetInfoLevel("filest", &filestInfoLevel, "0x0003");
        GetInfoLevel("simp", &simpInfoLevel, "0x0003");
        GetInfoLevel("astg", &astgInfoLevel, "0x0003");
        GetInfoLevel("LE", &LEInfoLevel, "0x0003");
        GetInfoLevel("Ref", &RefInfoLevel, "0x0003");
        GetInfoLevel("DD", &DDInfoLevel, "0x0003");
        GetInfoLevel("mnk", &mnkInfoLevel, "0x0003");
        GetInfoLevel("intr", &intrInfoLevel, "0x0003");
        GetInfoLevel("UserNdr", &UserNdrInfoLevel, "0x0003");
        GetInfoLevel("Stack", &StackInfoLevel, "0x0003");
        GetInfoLevel("ClsCache", &ClsCacheInfoLevel, "0x0003");
        GetInfoLevel("RefCache", &RefCacheInfoLevel, "0x0003");
        GetInfoLevel("Call", &CallInfoLevel, "0x0003");
        GetInfoLevel("Context", &ContextInfoLevel, "0x0003");
        GetInfoLevel("prop", &propInfoLevel, "0x0003");
        StgDebugInit();

        // Set whether interception is on/off/conditional
        GetInterceptorLevel();

        ULONG dummy;

        // Get API trace level
        dummy = DEB_WARN|DEB_ERROR;
        GetInfoLevel("api", &dummy, "0x0000");
        g_dwInfoLevel = (DWORD) dummy;

        fSSOn = (BOOL)GetInfoLevel("StackOn", &dummy, "0x0003");

        GetInfoLevel("heap", &heapInfoLevel, "0x00");
        if(heapInfoLevel != 0)
        {
            //Initialize the OLE debug memory allocator.
            hr = MallocInitialize(FALSE);
        }
        else

#endif //DBG==1

            //Initialize the OLE retail memory allocator.
            hr = MallocInitialize(TRUE);

        if(FAILED(hr))
        {
            ComDebOut((DEB_ERROR, "Failed to init memory allocator hr:%x",hr));
            return FALSE;
        }
        
        //  Fire up TxfAux
        if (!TxfDllMain ( (HINSTANCE) hInstance, dwReason, lpvReserved))
        {
            ComDebOut((DEB_ERROR, "Failed to init txfdllmain; gle:%d", GetLastError()));
            return E_OUTOFMEMORY;
        }

        //
        // this will be needed for the J version
        //        setlocale(LC_CTYPE, "");
        //
        g_hmodOLE2 = (HMODULE)hInstance;
        g_hinst    = (HINSTANCE)hInstance;

        InitializeOleSpy(OLESPY_TRACE);

#ifdef  TRACELOG
        if (!sg_pTraceLog)
        {
            sg_pTraceLog = (CTraceLog *) new CTraceLog();
            if (sg_pTraceLog)
            {
            	if (sg_pTraceLog->FInit() == FALSE)
            	{
            	    delete sg_pTraceLog;
            	    sg_pTraceLog = NULL;
            	}
            }
            CairoleAssert(sg_pTraceLog && "Create Trace Log Failed");
        }
#endif  // TRACELOG

        //
        // Initialize HookOle.
        // This checks the state of the global hook switch
        // and initializes hookole if it is on.
        //
        InitHookOle();

    }

    return ThreadNotification((HINSTANCE)hInstance, dwReason, lpvReserved);
}

//+---------------------------------------------------------------------------
//
//  Function:   ProcessInitialize, private
//
//  Synopsis:   Performs all of the process initialization.  Happens when
//              the first com thread calls CoInitialize.
//
//  Arguments:  None.
//
//  Returns:    S_OK, CO_E_INIT_RPC_CHANNEL, E_FAIL
//
//  History:    29-Aug-95   RickHi  Created
//
//----------------------------------------------------------------------------
HRESULT ProcessInitialize()
{
    HRESULT hr = S_OK;

    // Initialize the OleSpy
    InitializeOleSpy(OLESPY_CLIENT);

    // Initialize Access Control.
    if (SUCCEEDED(hr))
    {
        hr = InitializeAccessControl();

        if (SUCCEEDED(hr))
        {
            // Initialize wrapper objects. This is needed
            // for the creation of the context objects in CoInit.
            CStdWrapper::Initialize();

            // init the dll host objects
            hr = DllHostProcessInitialize();
            if (SUCCEEDED(hr))
            {
                // Initialize activation
                hr = ActivationProcessInit();
            }
        }
    }

    ComDebErr(FAILED(hr), "ProcessInitialize failed\n");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   ProcessUninitialize, private
//
//  Synopsis:   Performs all of the process de-initialization.  Happens when
//              the last com thread calls CoUninitialize, or when the
//              DLL_PROCESS_DETACH notification comes through.
//
//  Arguments:  None.
//
//  Returns:    Nothing.
//
//  History:    29-Aug-94   RickHi  Created
//
//----------------------------------------------------------------------------
void ProcessUninitialize()
{
    // clean up clipboard window class registration
    ClipboardProcessUninitialize();

    // Free Enum verb cache
    OleReleaseEnumVerbCache();

    // cleanup activation entries
    ActivationProcessCleanup();

    // cleanup GIP Table entries
    GIPTableProcessUninitialize();

    // clean up the rot
    DestroyRunningObjectTable();

    // Cleanup wrapper objects
    CStdWrapper::Cleanup();

    // Turn off RPC
    ChannelProcessUninitialize();

    // Cleanup Access Control.
    UninitializeAccessControl();

    // Release references on catalog objects held in
    // the Dll Cache.
    CCReleaseCatalogObjects();

    // Clean up catalog
    UninitializeCatalog();

    // Free loaded Dlls class cache
    CCCleanUpDllsForProcess();

    // Delete the per process pattern lookup table
    if (g_pPatTbl != NULL)
    {
        delete g_pPatTbl;
        g_pPatTbl = NULL;
    }

    // Delete the per process extension lookup table
    if (g_pExtTbl != NULL)
    {
        delete g_pExtTbl;
        g_pExtTbl = NULL;
    }

#ifdef  TRACELOG
    if (sg_pTraceLog)
    {
        CTraceLog *pTraceLog = sg_pTraceLog;
        sg_pTraceLog = NULL;         //  prevent more entries into the log
        delete pTraceLog;            //  delete the log, also dumps it.
    }
#endif  // TRACELOG

    UninitializeOleSpy(OLESPY_TRACE);

    // If WOW is going down, disable it.
    // WARNING: IsWOWThread & IsWOWProcess will no longer return valid results!!!!
    g_pOleThunkWOW = NULL;

    // Cleanup relavant TLS entries at process uninit time
    ProcessUninitTlsCleanup();
}


//+---------------------------------------------------------------------------
//
//  Function:   FinishShutdown     Private
//
//  Synopsis:   This routine cleans up all the apartment bound structures
//              that could potentially make outgoing calls
//
//  History:    07-Jul-98  GopalK   Created
//              17-May-01  Jsimmons Added exception handlers around calls into
//                                  user code to make us more robust during shutdown.
//                                  (this also hides user bugs, unfortunately).
//
//----------------------------------------------------------------------------
void FinishShutdown()
{
    __try
    {
        // cleanup per apartment registered LocalServer class table
        CCCleanUpLocalServersForApartment();
    }
    __except(AppInvokeExceptionFilter(GetExceptionInformation(), IID_IUnknown, 0))
    {
    }

    // cleanup per apartment object activation server objects
    ActivationAptCleanup();

    // clean up the Dll Host Apartments
    DllHostThreadUninitialize();

    __try
    {
        // cleanup the gip table for the current apartment
        GIPTableApartmentUninitialize();
    }
    __except(AppInvokeExceptionFilter(GetExceptionInformation(), IID_IUnknown, 0))
    {
    }

    __try
    {
        // cleanup per apartment identity objects
        gOIDTable.ThreadCleanup();
        gPIDTable.ThreadCleanup();
    }
    __except(AppInvokeExceptionFilter(GetExceptionInformation(), IID_IUnknown, 0))
    {
    }

    __try
    {
        // cleanup per apartment ROT.
        CleanROTForApartment();
    }
    __except(AppInvokeExceptionFilter(GetExceptionInformation(), IID_IUnknown, 0))
    {
    }

    __try
    {
        // cleanup per apartment Dll class table.
        CCCleanUpDllsForApartment();
    }
    __except(AppInvokeExceptionFilter(GetExceptionInformation(), IID_IUnknown, 0))
    {
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   ThreadStop
//
//  Synopsis:   Per thread uninitialization
//
//  History:    ??-???-??  ?         Created
//              05-Jul-94  AlexT     Separated thread and process uninit
//              11-Feb-98  JohnStra  Made NTA aware
//              02-Jul-98  GopalK    Simplified
//
//  Notes:      We are holding the single thread mutex during this call
//
//--------------------------------------------------------------------------
STDAPI_(BOOL) ThreadStop(BOOL fHostThread)
{
    ComDebOut((DEB_CALLCONT, "ThreadStop entered. fHostThread:%x\n", fHostThread));

    BOOL fStopped = TRUE;

    // Get the local apartment object
    CComApartment *pComApt = NULL;
    GetCurrentComApartment(&pComApt);

    if (pComApt != NULL)
    {
        // Mark the apartment as stopped
        pComApt->StopServer();

        // Check if dispatched calls have rehydrated the apartment
        if(!fHostThread)
        {
            COleTls Tls;

            // Check apartment type
            if(Tls->dwFlags & OLETLS_APARTMENTTHREADED)
            {
                if(Tls->cComInits > 1)
                {
                    ComDebOut((DEB_CALLCONT, "STA reinited in ThreadStop\n"));
                    fStopped = FALSE;
                }
            }
            else
            {
                if((IsMTAHostInitialized() ? (g_cMTAInits-1) : g_cMTAInits) > 1)
                {
                    ComDebOut((DEB_CALLCONT, "MTA reinited in ThreadStop\n"));
                    fStopped = FALSE;
                }
            }

            // Check for rehydrated apartments
            if(!fStopped)
            {
                pComApt->StartServer();
            }
        }

        pComApt->Release();
    }

    WaitForPendingAsyncSends();

    ComDebOut((DEB_CALLCONT,
               "ThreadStop returning %s\n", fStopped ? "TRUE" : "FALSE"));    
    return(fStopped);
}

//+-------------------------------------------------------------------------
//
//  Function:   WaitForPendingAsyncSends
//
//  Synopsis:   Wait for async sends to complete
//
//  History:    10-Feb-99   TarunA      Created
//
//  Notes:      
//
//--------------------------------------------------------------------------
void WaitForPendingAsyncSends()
{
    ComDebOut((DEB_CALLCONT, "WaitForPendingAsyncSends entered\n"));
    COleTls Tls;
    // Wait for a random period of time to allow
    // async sends to complete
    DWORD i = 0;
    while((0 < Tls->cAsyncSends) && i < 10)
    {
        // Wait in an alertable state to receive callback 
        // notifications from RPC
        SleepEx(5,TRUE);
        i++;
    }
    if(0 < Tls->cAsyncSends)
    {
        // Sanity check
        Win4Assert(NULL != Tls->pAsyncCallList);
        // Cleanup the list
        Tls->cAsyncSends = 0;    
        while(NULL != Tls->pAsyncCallList)
        {
            CAsyncCall* pCall = Tls->pAsyncCallList;
            Tls->pAsyncCallList = Tls->pAsyncCallList->_pNext;
            // Decrement the extra addref taken before calling RPC
            pCall->Release();
        }
    }
    ComDebOut((DEB_CALLCONT, "WaitForPendingAsyncSends returning\n"));
}

//+---------------------------------------------------------------------------
//
//  Function:   NAUninitialzie, private
//
//  Synopsis:   Uninitialize the neutral apartment.
//
//  History:    15-May-98   Johnstra  Created
//
//----------------------------------------------------------------------------
void NAUninitialize()
{
    // Switch thread into the NA.
    CObjectContext *pSavedCtx = EnterNTA(g_pNTAEmptyCtx);

    // Stop the apartment
    ThreadStop(TRUE);

    // Cleanup NTA
    FinishShutdown();
    ChannelThreadUninitialize();

    // Free global neutral apartment object
    if (gpNTAApartment)
    {
        gpNTAApartment->Release();
        gpNTAApartment = NULL;
    }

    // Release the global NA empty context
    if (g_pNTAEmptyCtx)
    {
        g_pNTAEmptyCtx->InternalRelease();
        COleTls Tls;
        Tls->pCurrentCtx = NULL;
        Tls->ContextId = (ULONGLONG)-1;
        g_pNTAEmptyCtx = NULL;
    }

    // Switch thread back to the original apartment
    LeaveNTA(pSavedCtx);
}

//+---------------------------------------------------------------------------
//
//  Function:   ApartmentUninitialize, private
//
//  Synopsis:   Performs all of the process uninitialization needed when a
//              Single-Threaded Apartment uninitializes, and when the
//              Multi-Threaded apartment uninitializes.
//
//  returns:    TRUE - uninit complete
//              FALSE - uninit aborted
//
//  History:    11-Mar-96   RickHi  Created
//              02-Jul-98   GopalK  Modified for NA shutdown
//
//----------------------------------------------------------------------------
BOOL ApartmentUninitialize(BOOL fHostThread)
{
    // Sanity check
    ASSERT_LOCK_NOT_HELD(g_mxsSingleThreadOle);

    // NOTE: The following sequence of uninitializes is critical:
    //
    // 1) Prevent incoming calls
    // 2) LocalServer class cache
    // 3) object activation (objact) server object
    // 4) Dll host server object
    // 5) standard identity table
    // 6) running object table
    // 7) Dll class cache
    // 8) Channel cleanup - should not touch proxies/stubs
    COleTls tls;
    BOOL fSTA = tls->dwFlags & OLETLS_APARTMENTTHREADED;
    BOOL fUnlock = FALSE;

    // Shutdown the apartment
    BOOL fStopped = ThreadStop(fHostThread);

    if(fSTA)
    {
        if(!fStopped)
        {
            return(FALSE);
        }
            
    }
    else
    {
        if(fStopped)
        {
            // Acquire MTA init lock to prevent MTA from getting reinited
            // while we are shutting down the apartment
            LOCK(gMTAInitLock);
            fUnlock = TRUE;                        
            if(g_cMTAInits > (DWORD)(IsMTAHostInitialized() ? 2 : 1))
            {
                fStopped = FALSE;
            }
                
        }
    }

    // Finish all outgoing calls from the apartment
    if(fStopped)
    {
        // This should always succeed
        HRESULT hr = CleanupLeakedDomainStack (tls, tls->pNativeCtx);
        Win4Assert (SUCCEEDED (hr));

        FinishShutdown();
    }

    // Unlock MTA init lock if neccessary
    if(fUnlock)
    {
        UNLOCK(gMTAInitLock);
    }

    // Acquire lock
    LOCK(g_mxsSingleThreadOle);
    if(!fStopped)
    {
        return(FALSE);
    }
        

    // Check for the need to cleanup Dll host threads
    if(!fHostThread && !g_fShutdownHosts &&
       (g_cProcessInits-1 == gcHostProcessInits-gcNAHosts))
    {
        // Update state to indicate that host aparments
        // are being shutdown
        g_fShutdownHosts = TRUE;

        // Note that the following function yields the lock
        // and the init counts can change. ThreadStop ignores
        // app code reinits host apartments. We need to honors
        // reinits for MTA host apartment only
        DllHostProcessUninitialize();

        // Restore state to indicate that host apartment shutdown
        // is complete
        g_fShutdownHosts = FALSE;
    }

    // NOTE: g_mxsSingleThreadOle should not be released
    //       from this point onwards. GopalK
    ASSERT_LOCK_HELD(g_mxsSingleThreadOle);

    // Check if we have to re-start the MTA
    if(!fSTA)
    {
        if(g_cMTAInits > 1)
        {
            ComDebOut((DEB_WARN, "MTA reinited during last shutdown\n"));
            if(gpMTAApartment)
                gpMTAApartment->StartServer();
            return(FALSE);
        }
    }

    // Uninit NA if needed
    if(1 == g_cProcessInits)
        NAUninitialize();

    // Cleanup apartment channel
    ChannelThreadUninitialize();

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Function:   SetOleThunkWowPtr
//
//  Synopsis:   Sets the value of g_pOleThunkWOW, as part of CoInitializeWow
//              and OleInitializeWow. This function is called by these
//              routines.
//
//  Effects:
//
//  Arguments:  [pOleThunk] --  VTable pointer to OleThunkWow interface
//
//  Returns:    none
//
//  History:    4-05-94   kevinro   Created
//----------------------------------------------------------------------------
void SetOleThunkWowPtr(LPOLETHUNKWOW lpthk)
{
    //
    // The theory here is that the lpthk parameter is the address into the
    // olethk32.dll and once loaded will never change. Therefore it only
    // needs to be set on the first call. After that, we can ignore the
    // subsequent calls, since they should be passing in the same value.
    //
    // If g_pOleThunkWOW is set to INVALID_HANDLE_VALUE, then OLETHK32 had
    // been previously unloaded, but is reloading
    //
    // I don't belive there is a multi-threaded issue here, since the pointer
    // value will always set as the same. Therefore, if two threads set it,
    // no problem.
    //

    if(!IsWOWThreadCallable())
    {
        g_pOleThunkWOW = lpthk;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   CoInitializeWOW, private
//
//  Synopsis:   Entry point to initialize the 16-bit WOW thunk layer.
//
//  Effects:    This routine is called when OLE32 is loaded by a VDM.
//              It serves two functions: It lets OLE know that it is
//              running in a VDM, and it passes in the address to a set
//              of functions that are called by the thunk layer. This
//              allows normal 32-bit processes to avoid loading the WOW
//              DLL since the thunk layer references it.
//
//  Arguments:  [vlpmalloc] -- 16:16 pointer to the 16 bit allocator.
//              [lpthk] -- Flat pointer to the OleThunkWOW virtual
//                         interface. This is NOT an OLE/IUnknown style
//                         interface.
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    3-15-94   kevinro   Created
//
//  Notes:
//
//      Note that vlpmalloc is a 16:16 pointer, and cannot be called directly
//----------------------------------------------------------------------------
STDAPI CoInitializeWOW( LPMALLOC vlpmalloc, LPOLETHUNKWOW lpthk )
{
    //
    // At the moment, there was no need to hang onto the 16bit vlpmalloc
    // routine for this thread. That may change once we get to the threaded
    // model
    //

    vlpmalloc;

    HRESULT hr;

    OLETRACEIN((API_CoInitializeWOW, PARAMFMT("vlpmalloc= %x, lpthk= %p"), vlpmalloc, lpthk));

    // Get (or allocate) the per-thread data structure
    COleTls Tls(hr);

    if (FAILED(hr))
    {
        ComDebOut((DEB_ERROR, "CoInitializeWOW Tls OutOfMemory"));
        return CO_E_INIT_TLS;
    }
    Tls->dwFlags |= OLETLS_WOWTHREAD;

    SetOleThunkWowPtr(lpthk);

    // WOW may be calling CoInitialize on multiple threads
    hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);

    OLETRACEOUT((API_CoInitializeWOW, hr));

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CoUnloadingWow
//
//  Synopsis:   Entry point to notify OLE32 that OLETHK32 is unloading
//
//  Effects:    This routine is called by OLETHK32 when it is being unloaded.
//              The key trick is to make sure that we uninitialize the current
//              thread before OLETHK32 goes away, and set the global thunk
//              vtbl pointer to INVALID_HANDLE_VALUE before it does go away.
//
//              Otherwise, we run a risk that OLE32 will attempt to call
//              back to OLETHK32
//
//  Arguments:  fProcessDetach - whether this is a process detach
//
//  Requires:   IsWOWProcess must be TRUE
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    3-18-95   kevinro   Created
//
//  Notes:
//
//      This routine is only called by PROCESS_DETACH in OLETHK32.DLL.
//      Because of this, there shouldn't be any threading protection needed,
//      since the loader will protect us.
//
//----------------------------------------------------------------------------
STDAPI CoUnloadingWOW(BOOL fProcessDetach)
{
    //
    // First, cleanup this thread
    //
    DoThreadSpecificCleanup();

    //
    // Now, set the global WOW thunk pointer to an invalid value. This
    // will prevent it from being called in the future.
    //
    if (fProcessDetach)
    {
        g_pOleThunkWOW = (OleThunkWOW *) INVALID_HANDLE_VALUE;
    }

    return(NOERROR);

}

//+-------------------------------------------------------------------------
//
//  Function:   CoRegisterInitializeSpy
//
//  Synopsis:   Register an IInitializeSpy interface for this thread.
//
//  Arguments:  pSpy       IInitializeSpy to register
//              pdwCookie  Out parameter containing the cookie which should
//                         be used to unregister the spy later.
//
//  Returns:    HRESULT
//
//  History:    12-Dec-01 JohnDoty   Created
//
//--------------------------------------------------------------------------
STDAPI CoRegisterInitializeSpy(IInitializeSpy *pSpy, ULARGE_INTEGER *puliCookie)
{
    IInitializeSpy *pRealSpy = NULL;
    HRESULT hr = S_OK;

    if (pSpy == NULL)
        return E_INVALIDARG;
    if (puliCookie == NULL)
        return E_INVALIDARG;

    puliCookie->QuadPart = (ULONGLONG)(-1);

    COleTls Tls(hr);    
    if (FAILED(hr))
        return CO_E_INIT_TLS;

    hr = pSpy->QueryInterface(IID_IInitializeSpy, (void **)&pRealSpy);
    if (SUCCEEDED(hr))
    {        
        InitializeSpyNode *pNode = Tls->pFirstFreeSpyReg;
        if (pNode == NULL)
        {
            pNode = (InitializeSpyNode *)CoTaskMemAlloc(sizeof(InitializeSpyNode));            
            if (pNode != NULL)
            {
                // New node, new cookie.
                pNode->dwCookie = Tls->dwMaxSpy;
                Tls->dwMaxSpy++;
                if (Tls->dwMaxSpy == 0)
                {
                    Tls->dwMaxSpy--;
                    CoTaskMemFree(pNode);
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            Tls->pFirstFreeSpyReg = pNode->pNext;
            pNode->pNext = NULL;
        }

        if (SUCCEEDED(hr))
        {
            // Fill out the node (cookie already set)
            pNode->pNext    = Tls->pFirstSpyReg;
            pNode->pPrev    = NULL;
            pNode->dwRefs   = 1;
            pNode->pInitSpy = pRealSpy;

            // Link into the list
            if (Tls->pFirstSpyReg)
                Tls->pFirstSpyReg->pPrev = pNode;
            Tls->pFirstSpyReg = pNode;

            // Return the cookie
            puliCookie->LowPart  = pNode->dwCookie;
            puliCookie->HighPart = GetCurrentThreadId();
            
            hr = S_OK;
        }
        else
        {
            pRealSpy->Release();
        }
    }

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   UnlinkSpyNode
//
//  Synopsis:   Unlinks an InitializeSpyNode from the list in TLS.
//
//  Arguments:  pNode      Node to un-link.
//
//  Returns:    void
//
//  History:    12-Dec-01 JohnDoty   Created
//
//--------------------------------------------------------------------------
void UnlinkSpyNode(InitializeSpyNode *pNode)
{
    COleTls Tls;

    if (pNode->pNext) pNode->pNext->pPrev = pNode->pPrev;
    if (pNode->pPrev) pNode->pPrev->pNext = pNode->pNext;
    
    if (pNode == Tls->pFirstSpyReg)
        Tls->pFirstSpyReg = pNode->pNext;
    
    // Link the node into the free list.
    pNode->pPrev = NULL;
    pNode->pNext = Tls->pFirstFreeSpyReg;
    Tls->pFirstFreeSpyReg = pNode;    
}

//+-------------------------------------------------------------------------
//
//  Function:   CoRevokeInitializeSpy
//
//  Synopsis:   Revoke an IInitializeSpy registration for this thread.
//
//  Arguments:  dwCookie   Cookie received from previous call to 
//                         CoRegisterInitializeSpy
//
//  Returns:    HRESULT
//
//  History:    12-Dec-01 JohnDoty   Created
//
//--------------------------------------------------------------------------
STDAPI CoRevokeInitializeSpy(ULARGE_INTEGER uliCookie)
{
    HRESULT hr;
    COleTls Tls(hr);    
    if (FAILED(hr))
        return CO_E_INIT_TLS;

    // Check the high part-- it's the thread ID.
    // If it doesn't match, then this is the wrong thread to do the revoke.
    if (GetCurrentThreadId() != uliCookie.HighPart)
        return E_INVALIDARG;

    DWORD dwCookie = uliCookie.LowPart;
    InitializeSpyNode *pNode  = Tls->pFirstSpyReg;
    while (pNode != NULL)
    {
        if (pNode->dwCookie == dwCookie)
        {
            if (pNode->pInitSpy == NULL)
                return E_INVALIDARG;  // Already been revoked

            pNode->pInitSpy->Release();
            pNode->pInitSpy = NULL;

            pNode->dwRefs--;
            if (pNode->dwRefs == 0)
            {
                // Nobody else is holding on to this.  Unlink the node.
                UnlinkSpyNode(pNode);
            }

            return S_OK;
        }

        pNode = pNode->pNext;
    }

    return E_INVALIDARG;
}

//+-------------------------------------------------------------------------
//
//  Function:   NotifyInitializeSpies
//
//  Synopsis:   Notify all registered Initialize Spies about an event.
//
//  Arguments:  fInitialize   TRUE if CoInitialize, FALSE if CoUninitialize
//              fPreNotify    TRUE if this is a Pre* notification, FALSE if
//                            this is a Post* notification.
//              dwFlags       Flags parameter for Initialize notifications.
//              hrInit        HRESULT for PostInitialize notification.
//
//  Returns:    HRESULT
//
//  History:    12-Dec-01 JohnDoty  Created
//
//--------------------------------------------------------------------------
HRESULT NotifyInitializeSpies(BOOL fInitialize, 
                              BOOL fPreNotify, 
                              DWORD dwFlags = 0,
                              HRESULT hrInit = S_OK)
{
    HRESULT hr = hrInit;
    
    COleTls Tls;
    InitializeSpyNode *pSpyNode = Tls->pFirstSpyReg;
    while (pSpyNode)
    {
        // Take a reference on this node-- this node will not be deleted until
        // we get finished sending this notification.
        pSpyNode->dwRefs++;

        // Take a reference on the spy, since the spy might unregister itself
        // during this notification.
        IInitializeSpy *pSpy = pSpyNode->pInitSpy;
        if (pSpy)
        {
            pSpy->AddRef();

            // Notify the spy appropriately.
            if (fInitialize)
            {
                if (fPreNotify)
                {
                    // hr ignored on purpose (by design)
                    pSpy->PreInitialize(dwFlags, Tls->cComInits);
                }
                else
                {
                    hr = pSpy->PostInitialize(hr, dwFlags, Tls->cComInits);
                }
            }
            else
            {
                if (fPreNotify)
                {
                    // hr ignored on purpose (by design)
                    pSpy->PreUninitialize(Tls->cComInits);
                }
                else
                {
                    // hr ignored on purpose (by design)
                    pSpy->PostUninitialize(Tls->cComInits);
                }
            }

            pSpy->Release();
        }

        // Remember what the next node is, since we might unlink the current
        // node now.
        InitializeSpyNode *pNext = pSpyNode->pNext;
        
        // Release our reference on this node, and unlink it if necessary.
        pSpyNode->dwRefs--;
        if (pSpyNode->dwRefs == 0)
        {
            // Nobody's holding onto this node anymore.  Unlink it.
            UnlinkSpyNode(pSpyNode);
        }

        pSpyNode = pNext;
    }

    return hr;
}                              

//+-------------------------------------------------------------------------
//
//  Function:   CoInitialize
//
//  Synopsis:   COM Initializer
//
//  Arguments:  [pvReserved]
//
//  Returns:    HRESULT
//
//  History:    09-Nov-94 Ricksa    Added this function comment & modified
//                                  to get rid of single threaded init flag.
//
//--------------------------------------------------------------------------
STDAPI CoInitialize(LPVOID pvReserved)
{
    HRESULT hr;

    OLETRACEIN((API_CoInitialize, PARAMFMT("pvReserved= %p"), pvReserved));

    hr = CoInitializeEx( pvReserved, COINIT_APARTMENTTHREADED);

    OLETRACEOUT((API_CoInitialize, hr));

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IsRunningInSCM
//
//  Synopsis:   Figure out if we're running in the RPCSS process.  This is
//              used by CoInitialize to disallow COM in the SCM.
//
//  History:    16-Jan-01 JohnDoty  Created
//
//--------------------------------------------------------------------------
BOOL IsRunningInSCM()
{
    const WCHAR  wszRPCSS[] = L"\\system32\\rpcss.dll";
    const size_t cchRPCSS   = (sizeof(wszRPCSS) / sizeof(WCHAR)); 

    // GetSystemWindowsDirectory returns enough space for the NULL.
    unsigned cchBufferSize = (GetSystemWindowsDirectory(NULL, 0) - 1)
                           + cchRPCSS;

    WCHAR *wszFullPath = (WCHAR *)alloca(cchBufferSize * sizeof(WCHAR));
    
    GetSystemWindowsDirectory(wszFullPath, cchBufferSize);
    lstrcat(wszFullPath, wszRPCSS);

    return (GetModuleHandle(wszFullPath)) ? TRUE : FALSE;
}

//+-------------------------------------------------------------------------
//
//  Function:   CoInitializeEx
//
//  Synopsis:   COM Initializer
//
//  Arguments:  [pMalloc]
//              [flags]
//
//  Returns:    HRESULT
//
//  History:    06-Apr-94 AlexT     Added this function comment,
//                                  Cleaned up pMalloc usage
//              25-May-94 AlexT     Make success return code more closely
//                                  match 16-bit OLE
//              28-Aug-94 AndyH     pMalloc must be NULL except for Excel
//              16-Jan-01 JohnDoty  Don't allow CoInitializeEx in rpcss!
//
//  Notes:      If we're going to return successfully, we return one of the
//              following two values:
//
//              S_OK if caller passed in a NULL pMalloc and we accepted it
//              S_OK if caller passed in NULL pMalloc and this was the first
//                  successful call on this thread
//              S_FALSE if caller passed in NULL pMalloc and this was not the
//                  first successful call on this thread
//
//              This is slightly different from 16-bit OLE, because 16-bit OLE
//              didn't allow task allocations before CoInitialize was called
//              (we do), and 16-bit OLE allowed the app to change the allocator.
//
//              For chicago: SSAPI(x) expands to SSx; the x api is in
//              stkswtch.cxx which switches to the 16 bit stack first and
//              calls then SSx.
//
//--------------------------------------------------------------------------
STDAPI SSAPI(CoInitializeEx)(LPVOID pMalloc, ULONG flags)
{
    ComDebOut((DEB_TRACE, "CoInitializeEx pMalloc:%x flags:%x\n", pMalloc, flags));

    if ((flags &
        (COINIT_DISABLE_OLE1DDE|COINIT_APARTMENTTHREADED|COINIT_SPEED_OVER_MEMORY))
        != flags)
    {
        ComDebOut((DEB_ERROR, "CoInitializeEx(%x,%x) illegal flag", pMalloc, flags));
        return E_INVALIDARG;
    }

    if (NULL != pMalloc)
    {
        // Allocator NOT replaceable!  When called from 16-bits, the Thunk
        // layer always pases a NULL pMalloc.

#ifndef _CHICAGO_
        // EXCEL50 for NT supplies an allocator. We dont use it, but we
        // dont return error either, or we would break them.

        if (!IsTaskName(L"EXCEL.EXE"))
#endif
        {
            ComDebOut((DEB_ERROR, "CoInitializeEx(%x,%x) illegal pMalloc", pMalloc, flags));
            return E_INVALIDARG;
        }
    }

    // CoInitializeEx cannot be called from within rpcss.
    // This effectively stops all remoting inside the SCM.
    if (IsRunningInSCM())
    {
        ComDebOut((DEB_ERROR, "Cannot CoInitializeEx in RPCSS\n"));
        return E_UNEXPECTED;
    }

    // Get (or allocate) the per-thread data structure
    HRESULT hr;
    COleTls Tls(hr);

    if (FAILED(hr))
    {
        ComDebOut((DEB_ERROR, "CoInitializeEx Tls OutOfMemory"));
        return CO_E_INIT_TLS;
    }

    // Notify Initialize spies we are beginning initialization of this thread
    NotifyInitializeSpies(TRUE /* CoInit */, TRUE /* Pre */, flags);

    // Disallow CoInitialize from the neutral apartement.
    if (IsThreadInNTA())
    {
        ComDebOut((DEB_ERROR, "Attempt to CoInitialize from neutral apt.\n"));
        hr = RPC_E_CHANGED_MODE;
        goto ExitCoInit;
    }

    // Check for dispatch thread
    if (Tls->dwFlags & OLETLS_DISPATCHTHREAD)
    {
        // Don't allow a creation of STA on dispatch threads
        if(flags & COINIT_APARTMENTTHREADED)
        {
            ComDebOut((DEB_TRACE,"Attempt to create STA on a dispatch thread.\n" ));
            hr = RPC_E_CHANGED_MODE;
            goto ExitCoInit;
        }
        // Simply return for creation of MTA on dispatch threads
        else
        {
            ComDebOut((DEB_TRACE,"Attempt to create MTA on a dispatch thread.\n" ));
            hr = S_FALSE;
            goto ExitCoInit;
        }
    }

    // Don't allow chaning mode
    if (( (flags & COINIT_APARTMENTTHREADED) && (Tls->dwFlags & OLETLS_MULTITHREADED)) ||
        (!(flags & COINIT_APARTMENTTHREADED) && (Tls->dwFlags & OLETLS_APARTMENTTHREADED)))
    {

        ComDebOut((DEB_ERROR,"CoInitializeEx Attempt to change threadmodel\n"));

        hr = RPC_E_CHANGED_MODE;
        goto ExitCoInit;
    }

    // This flag can be set at any time.  It cannot be disabled.
    if (flags & COINIT_SPEED_OVER_MEMORY)
    {
        gSpeedOverMem = TRUE;
    }

    // increment the per-thread init count
    if (1 == ++(Tls->cComInits))
    {
        // first time for thread, might also be first time for process
        // so go check that now.

        // Prevent races initing/uniniting MTA
        if(!(flags & COINIT_APARTMENTTHREADED))
        {
            LOCK(gMTAInitLock);
            ++gcInitingMTA;
        }

        // Single thread CoInitialize/CoUninitialize to guarantee
        // that no race conditions occur where two threads are
        // simultaneously initializing and uninitializing the library.
        LOCK(g_mxsSingleThreadOle);
        hr = wCoInitializeEx(Tls, flags);
        UNLOCK(g_mxsSingleThreadOle);

        if(FAILED(hr))
            Tls->cComInits--;

        // Release MTA lock
        if(!(flags & COINIT_APARTMENTTHREADED))
        {
            --gcInitingMTA;
            UNLOCK(gMTAInitLock);
        }

        goto ExitCoInit;
    }
    else if(Tls->dwFlags & OLETLS_PENDINGUNINIT)
    {
        // Sanity check
        Win4Assert(Tls->cCalls && Tls->cComInits==2);

        // Update state
        Tls->cComInits = 1;
        Tls->dwFlags &= ~OLETLS_PENDINGUNINIT;

        hr = S_OK;
        goto ExitCoInit;
    }

    // this is the 2nd or greater successful call on this thread
    hr = S_FALSE;
    goto ExitCoInit;

ExitCoInit:

    // Notify spies that we are finishing initialization of this thread.
    hr = NotifyInitializeSpies(TRUE /* CoInit */, FALSE /* Post */, flags, hr);

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   InitializeNTA
//
//  Synopsis:   Initialization function for the NTA.
//
//  History:    20-Feb-98   Johnstra  Created
//
//+-------------------------------------------------------------------------
INTERNAL InitializeNTA()
{
    // Sanity checks
    ASSERT_LOCK_HELD(g_mxsSingleThreadOle);
    Win4Assert(gpNTAApartment == NULL);

    // Enter NTA
    CObjectContext *pSavedCtx = EnterNTA(g_pNTAEmptyCtx);

    // Create the NA apartment object.
    HRESULT hr = E_OUTOFMEMORY;
    gpNTAApartment = new CComApartment(APTKIND_NEUTRALTHREADED);
    if (gpNTAApartment != NULL)
    {
        // Create the NTA Empty context
        g_pNTAEmptyCtx = CObjectContext::CreateObjectContext(NULL, CONTEXTFLAGS_DEFAULTCONTEXT);
        if (g_pNTAEmptyCtx != NULL)
        {
            // Freeze the NA empty context.
            g_pNTAEmptyCtx->Freeze();

            // Indicate that the NTA has been initialized.
            hr = S_OK;
        }
        else
        {
            // Clean up the apartment object.
            gpNTAApartment->Release();
            gpNTAApartment = NULL;
        }
    }

    // Leave NTA
    LeaveNTA(pSavedCtx);

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   InitAptCtx
//
//  Synopsis:   Worker routine for wCoInitializeEx.  Sets up a new COM threads
//              object context and apartment info in TLS, allocating new
//              objects if specified.
//
//  Arguments:  pEmptyCtx   - ref to threads empty object context ptr
//              pNativeApt  - ref to threads native apt object ptr
//              tls         - ref to threads tls structure
//              fAlloc      - specifies whether empty object context and
//                            native apt need to be allocated
//
//  History:    28-Mar-98   Johnstra  Created
//
//+-------------------------------------------------------------------------
INTERNAL InitThreadCtx(
    CObjectContext*& pEmptyCtx,
    CComApartment*&  pNativeApt,
    COleTls&         tls,
    BOOL             fAlloc,
    APTKIND          AptKind
    )
{
    HRESULT hr = S_OK;
    if (fAlloc)
    {
        hr = E_OUTOFMEMORY;

        // Create an apartment object.  Note: the apartment object
        // must be created and placed into TLS before we create the
        // object context because the context's constructor expects
        // to find an apartment object in TLS.

        // Make sure that we do not overwrite an existing apartment.
        Win4Assert((NULL == tls->pNativeApt) && (NULL == pNativeApt));

        pNativeApt = new CComApartment(AptKind);
        if (pNativeApt != NULL)
        {
            // Initialize thread's native and current apartment.
            tls->pNativeApt = pNativeApt;

            // Make sure that we do not overwrite an existing context.
            Win4Assert((NULL == tls->pNativeCtx) && (NULL == pEmptyCtx));

            // Now create an object context.
            pEmptyCtx = CObjectContext::CreateObjectContext(NULL, CONTEXTFLAGS_DEFAULTCONTEXT);
            if (pEmptyCtx != NULL)
            {
                // Freeze the new empty context.
                pEmptyCtx->Freeze();

                // Init thread's native and current object context.
                tls->pNativeCtx = pEmptyCtx;
                tls->pNativeCtx->InternalAddRef();
                tls->pCurrentCtx = tls->pNativeCtx;
                tls->ContextId = tls->pCurrentCtx->GetId();

                hr = S_OK;
            }
            else
            {
                pNativeApt->Release();
                pNativeApt = NULL;
                tls->pNativeApt = NULL;
            }
        }
    }
    else
    {
        // Init threads native and current apartment.
        tls->pNativeApt = pNativeApt;
        tls->pNativeApt->AddRef();

        // Init threads native and current object context.
        tls->pNativeCtx = pEmptyCtx;
        tls->pNativeCtx->InternalAddRef();
        tls->pCurrentCtx = tls->pNativeCtx;
        tls->ContextId = tls->pCurrentCtx->GetId();
    }

    tls->pContextStack = NULL;

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   CleanupLeakedDomainStack
//
//  Synopsis:   Worker routine for wCoInitializeEx.  Cleans up leaked service domain
//              contexts and notifies them of their abandonment
//
//  Arguments:  tls         - ref to threads tls structure
//              pCorrectCtx - the context we should be in
//
//  History:    14-Mar-01   mfeingol  Created
//
//+-------------------------------------------------------------------------
INTERNAL CleanupLeakedDomainStack (COleTls& Tls, CObjectContext* pCorrectCtx)
{
    HRESULT hr = S_OK;

    if (Tls->pContextStack)
    {
        Win4Assert (pCorrectCtx);
        Win4Assert (!"Unbalanced CoEnterServiceDomain and CoLeaveServiceDomain");

        // Restore correct context if necessary
        if (Tls->pCurrentCtx != pCorrectCtx)
        {
            Tls->pCurrentCtx->NotifyContextAbandonment();
            Tls->pCurrentCtx->InternalRelease();    // Balance internaladdref in EnterForCallback
            Tls->pCurrentCtx = pCorrectCtx;
            Tls->ContextId = pCorrectCtx->GetId();
        }

        // Handle leaked service domain stack
        while (Tls->pContextStack)
        {
            ContextStackNode csnCtxNode = {0};
            hr = PopServiceDomainContext (&csnCtxNode);
            if (FAILED (hr))
            {
                // Should never fail unless we're out of stack nodes
                Win4Assert (!"Out of stack nodes  - should never happen");
                return hr;
            }

            // Release ps, delete call objects
            csnCtxNode.pPS->Release();

            delete csnCtxNode.pClientCall;
            delete csnCtxNode.pServerCall;

            // Stop if we find the correct context
            if (csnCtxNode.pSavedContext == pCorrectCtx) break;

            // Tell the leaked context about its predicament
            csnCtxNode.pSavedContext->NotifyContextAbandonment();
            csnCtxNode.pSavedContext->InternalRelease();  // Balance internaladdref in EnterForCallback
            }
    }

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   wCoInitializeEx
//
//  Synopsis:   worker routine for CoInitialize.
//
//  Arguments:  [tls]   - tls ptr for this thread
//              [flags] - initialization flags
//
//  History:    10-Apr-96   Rickhi  Created
//              29-Jun-98   GopalK  Modified cleanup logic
//
//  Notes:      When called by the DLLHost threads that are initializing,
//              the g_mxsSingleThreadOle mutex is being held by the requesting
//              thread, so it is still safe to muck with global state.
//
//+-------------------------------------------------------------------------
INTERNAL wCoInitializeEx(COleTls &Tls, ULONG flags)
{
    HRESULT hr = S_OK;

    if(1 == InterlockedIncrement((LONG *) &g_cProcessInits))
    {
        // first time for process, do per-process initialization
        hr = ProcessInitialize();
        if(FAILED(hr))
        {
            // ProcessInitialize failed, we must call ProcessUninitialize
            // to cleanup *before* we release the lock.
            goto ErrorReturn;
        }
    }

    if(flags & COINIT_APARTMENTTHREADED)
    {
        // apartment threaded, count 1 more STA init, mark the thread
        // as being apartment threaded, and conditionally disable
        // OLE1.

        Tls->dwFlags |= OLETLS_APARTMENTTHREADED;
        if(flags & COINIT_DISABLE_OLE1DDE)
            Tls->dwFlags |= OLETLS_DISABLE_OLE1DDE;

        // Initialize the threads context and apartment objects.
        hr = InitThreadCtx(Tls->pEmptyCtx, Tls->pNativeApt, Tls, TRUE,
                           APTKIND_APARTMENTTHREADED);
        if(FAILED(hr))
            goto ErrorReturn;

        if(1 == InterlockedIncrement((LONG *)&g_cSTAInits))
        {
            // If this is the first STA init, then the previous main
            // thread, if there was one, should have been cleaned up.
            Win4Assert(gdwMainThreadId == 0);
            
            // Register a window class for this and all future STA's
            hr = RegisterOleWndClass();
            if(FAILED(hr))
            {
                InterlockedDecrement((LONG *) &g_cSTAInits);
                goto ErrorReturn;
            }
        }

        // If we do not currently have a thread considered to be the
        // main STA, make this one be it.  This is a relaxation of 
        // the code from NT4\W2K -- in those days, we said that the
        // main STA had better be the last STA to go away, and things
        // sometimes didn't work if that rule was not honored.  Now
        // we just go with the flow.
        if (gdwMainThreadId == 0)
        {
            hr = InitMainThreadWnd();
            if (FAILED(hr))
            {
                if (0 == InterlockedDecrement((LONG *) &g_cSTAInits))
                {
                    // Don't need the window class now
                    UnRegisterOleWndClass();
                }
                goto ErrorReturn;
            }
            else if (hr == S_OK)
            {
                Win4Assert(gdwMainThreadId == GetCurrentThreadId());
                Win4Assert(ghwndOleMainThread != NULL);
            }
            // else returns S_FALSE in the WOW thread case
        }
    }
    else
    {
        // multi threaded, count 1 more MTA init, mark the thread
        // as being multi-threaded, and always disable OLE1
        Tls->dwFlags |= (OLETLS_DISABLE_OLE1DDE | OLETLS_MULTITHREADED);

        Win4Assert((g_cMTAInits != 0) ||
                   ((NULL == gpMTAApartment) && (NULL == g_pMTAEmptyCtx)));
        // Initialze the threads context and apartment objects.
        hr = InitThreadCtx(g_pMTAEmptyCtx, gpMTAApartment, Tls,
                           (g_cMTAInits == 0) ? TRUE : FALSE,
                           APTKIND_MULTITHREADED);
        if(FAILED(hr))
            goto ErrorReturn;

        InterlockedIncrement((LONG *) &g_cMTAInits);
    }

    // Initialize the neutral apartment if it has not yet been initialized.
    if(NULL == gpNTAApartment)
    {
        hr = InitializeNTA();
        if (FAILED(hr))
            goto ErrorReturn;
    }

    // this is the first successful call on this thread. make
    // sure to return S_OK and not some other random success code.
    ComDebOut((DEB_TRACE, "CoInitializeEx returned S_OK\n"));
    return S_OK;


ErrorReturn:
    // An error occurred. Fixup our tls init counter and
    // undo the TLS state change

    // cleanup our counter if the intialization failed so
    // that other threads waiting on the lock wont assume
    // that ProcessInitialize has been done.
    Tls->dwFlags = OLETLS_LOCALTID | (Tls->dwFlags & OLETLS_UUIDINITIALIZED);

    if(Tls->pNativeCtx)
    {
        Tls->pNativeCtx->InternalRelease();
        Tls->pNativeCtx = NULL;
        Tls->pCurrentCtx = NULL;
        Tls->ContextId = (ULONGLONG)-1;
    }

    if (Tls->pNativeApt)
    {
        Tls->pNativeApt->Release();
        Tls->pNativeApt = NULL;
    }

    if(flags & COINIT_APARTMENTTHREADED)
    {
        if(Tls->pEmptyCtx)
        {
            Tls->pEmptyCtx->InternalRelease();
            Tls->pEmptyCtx = NULL;
        }
    }
    else if(g_cMTAInits == 0)
    {
        if(g_pMTAEmptyCtx)
        {
            g_pMTAEmptyCtx->InternalRelease();
            g_pMTAEmptyCtx = NULL;
        }
        if(gpMTAApartment)
        {
            gpMTAApartment->Release();
            gpMTAApartment = NULL;
        }
    }

    if(0 == InterlockedDecrement((LONG *) &g_cProcessInits))
    {
        ProcessUninitialize();      
    }

    ComDebOut((DEB_ERROR,"CoInitializeEx Failed %x\n", hr));
    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   SSAPI(CoUnInitialize)
//
//  Synopsis:   COM UnInitializer, normally called from OleUninitialize
//              when the app is going away.
//
//  Effects:    Cleans up per apartment state, and if this is the last
//              apartment, cleans up global state.
//
//  Arguments:  none
//
//  Returns:    nothing
//
//  History:    24-Jun-94 Rickhi    Added this function comment,
//                                  Cleaned up pMalloc usage
//              29-Jun-94 AlexT     Rework so that we don't own the mutex
//                                  while we might yield.
//
//  Notes:      It is critical that we not own any mutexes when we might
//              make a call that would allow a different WOW thread to run
//              (which could otherwise lead to deadlock).  Examples of such
//              calls are Object RPC, SendMessage, and Yield.
//
//--------------------------------------------------------------------------
STDAPI_(void) SSAPI(CoUninitialize)(void)
{
    OLETRACEIN((API_CoUninitialize, NOPARAM));
    TRACECALL(TRACE_INITIALIZE, "CoUninitialize");

    // Get the thread init count.
    COleTls Tls(TRUE);
    if (!Tls.IsNULL())
    {
        // Notify spies that we are beginning to uninit this thread.
        NotifyInitializeSpies(FALSE /* CoUninit */, TRUE /* Pre */);

        if (Tls->cComInits > 0)
        {
            // Sanity check
            Win4Assert(!(Tls->dwFlags & OLETLS_DISPATCHTHREAD) ||
                       !(Tls->dwFlags & OLETLS_APARTMENTTHREADED));
            
            // Disallow CoUnitialize from the neutral apartement.
            if (IsThreadInNTA())
            {
                ComDebOut((DEB_ERROR, "Attempt to uninitialize neutral apt.\n"));
            }
            else
            {
                if (1 == Tls->cComInits)
                {
                    // Check for outstanding calls on the thread
                    if(Tls->cCalls && !(Tls->dwFlags & OLETLS_INTHREADDETACH))
                    {
                        Tls->dwFlags |= OLETLS_PENDINGUNINIT;
                    }
                    else
                    {
                        wCoUninitialize(Tls, FALSE);
                    }
                }
                else
                {
                    // Sanity check
                    Win4Assert(!(Tls->dwFlags & OLETLS_PENDINGUNINIT));
                    Tls->cComInits--;
                }
            }
        }
        else
        {
            ComDebOut((DEB_ERROR,
                       "(0 == thread inits) Unbalanced call to CoUninitialize\n"));
        }

        // Notify spies that we are finished uninitializing this thread.
        NotifyInitializeSpies(FALSE /* CoUninit */, FALSE /* Post */);        
    }

    OLETRACEOUTEX((API_CoUninitialize, NORETURN));
    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   wCoUnInitialize
//
//  Synopsis:   worker routine for CoUninitialize, and special entry point
//              for DLLHost threads when cleaning up.
//
//  Effects:    Cleans up apartment state.
//
//  History:    10-Apr-96   Rickhi  Created
//
//  Notes:      When called with fHostThread == TRUE, the g_mxsSingleThreadOle
//              critical section is already held by the main thread that is
//              uninitializing, currently waiting in DllHostProcessUninitialize
//              for the host threads to exit. The host threads use this
//              uninitializer to avoid taking the CS and deadlocking with the
//              main thread.
//
//--------------------------------------------------------------------------
INTERNAL_(void) wCoUninitialize(COleTls &Tls, BOOL fHostThread)
{
    ComDebOut((DEB_COMPOBJ, "CoUninitialize Thread\n"));

    if (fHostThread)
    {
        // If this is a host thread, we haven't notified initialize spies yet.
        // Notify spies that we are beginning to uninit this thread.
        NotifyInitializeSpies(FALSE /* CoUninit */, TRUE /* Pre */);
    }

    if(Tls->dwFlags & OLETLS_THREADUNINITIALIZING)
    {
        // somebody called CoUninitialize while inside CoUninitialize. Since
        // we dont subtract the thread init count until after init is done.
        // we can end up here. Just warn the user about the problem and
        // return without doing any more work.
        ComDebOut((DEB_WARN, "Unbalanced Nested call to CoUninitialize\n"));
        goto exit;
    }

    // mark the thread as uninitializing
    Tls->dwFlags |= OLETLS_THREADUNINITIALIZING;

    if(Tls->dwFlags & OLETLS_APARTMENTTHREADED)
    {
        // do per-apartment cleanup
        if(!ApartmentUninitialize(fHostThread))
        {
            // uninit was aborted while waiting for pending calls to complete.
            Tls->dwFlags &= ~OLETLS_THREADUNINITIALIZING;
            ComDebOut((DEB_WARN, "CoUninitialize Aborted\n"));
            goto exit;
        }

        // Release empty context
        Tls->pEmptyCtx->InternalRelease();
        Tls->pEmptyCtx = NULL;
        Win4Assert((Tls->pNativeCtx == NULL) && (Tls->pCurrentCtx == NULL));

        // Release apartment object.
        Tls->pNativeApt->Release();
        Tls->pNativeApt = NULL;

        // Ensure that the lock is held
        ASSERT_LOCK_HELD(g_mxsSingleThreadOle);

        // Check for the main STA going away (this call is a no-op
        // if this thread is not the main STA).  We need to call this 
        // here because the main thread wnd will not always be cleaned
        // up by the time we get here.
        UninitMainThreadWnd();

        // Check for the last STA
        if(1 == g_cSTAInits)
        {
            // If so, don't need the window class anymore
            UnRegisterOleWndClass();
        }
        InterlockedDecrement((LONG *) &g_cSTAInits);
    }
    else
    {
        // MTA. Prevent races
        ASSERT_LOCK_NOT_HELD(g_mxsSingleThreadOle);
        LOCK(g_mxsSingleThreadOle);

        while(TRUE)
        {
            // Check for the last MTA
            BOOL fUninitMTA = (g_cMTAInits == 1)
                              ? TRUE
                              : (g_cProcessInits == 2)
                                ? (!fHostThread && IsMTAHostInitialized())
                                : FALSE;
            if(fUninitMTA)
            {
                // Release the lock
                UNLOCK(g_mxsSingleThreadOle);
                ASSERT_LOCK_NOT_HELD(g_mxsSingleThreadOle);
    
                // Unint MTA apartment
                if(ApartmentUninitialize(fHostThread))
                {
                    // Release MTA empty context
                    g_pMTAEmptyCtx->InternalRelease();
                    g_pMTAEmptyCtx = NULL;
    
                    // Release MTA apartment object
                    gpMTAApartment->Release();
                    gpMTAApartment = NULL;

                    // Update tls state
                    Win4Assert((Tls->pNativeCtx == NULL) && (Tls->pCurrentCtx == NULL));
                    Tls->pNativeApt = NULL;
                    break;
                }
    
                // Ensure that the lock is held
                ASSERT_LOCK_HELD(g_mxsSingleThreadOle);
            }
            else
            {
                gPSTable.ThreadCleanup(FALSE);
                Tls->pNativeApt->Release();
                Tls->pNativeApt = NULL;
                break;
            }
        }

        // Decrement MTA count
        InterlockedDecrement((LONG *) &g_cMTAInits);
    }

    // Ensure that the lock is held
    ASSERT_LOCK_HELD(g_mxsSingleThreadOle);

    // Check for the last apartment
    if (!fHostThread)
    {
        if (1 == g_cProcessInits)
        {
            CairoleDebugOut((DEB_COMPOBJ, "CoUninitialize Process\n"));
            Win4Assert(Tls->cComInits == 1);
            ProcessUninitialize();                                
        }
    }

    // Decrement process count
    InterlockedDecrement((LONG *) &g_cProcessInits);
    Win4Assert(!fHostThread || g_cProcessInits>0);

    // Allow future Coinits/CoUninits
    UNLOCK(g_mxsSingleThreadOle);
    ASSERT_LOCK_NOT_HELD(g_mxsSingleThreadOle);

    //Release the per-thread error object.
    CoSetErrorInfo(0, NULL);

    // Release the per-thread "state" object (regardless of whether we
    // are Apartment or Free threaded. This must be done now since the
    // OLE Automation Dll tries to free this in DLL detach, which may
    // try to call back into the OLE32 dll which may already be detached!

    CoSetState(NULL);
#ifdef WX86OLE
    // make sure wx86 state is also freed
    if (gcwx86.SetIsWx86Calling(TRUE))
    {
        CoSetState(NULL);
    }
#endif

    // mark the thread as finished uninitializing and turn off all flags
    // and reset the count of initializations.
    Tls->dwFlags = OLETLS_LOCALTID | (Tls->dwFlags & OLETLS_UUIDINITIALIZED);
    Tls->cComInits = 0;

exit:

    if (fHostThread)
    {
        // If this is a host thread, we haven't notified initialize spies yet.
        // Notify spies that we are finished uninitializing this thread.
        NotifyInitializeSpies(FALSE /* CoUninit */, FALSE /* Post */);
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   IsApartmentInitialized
//
//  Synopsis:   Check if the current apartment is initialized
//
//  Returns:    TRUE  - apartment initialized, TLS data guaranteed to exist
//                      for this thread.
//              FALSE - apartment not initialized
//
//  History:    09-Aug-94   Rickhi      commented
//
//--------------------------------------------------------------------------
BOOL IsApartmentInitialized()
{
    HRESULT hr;
    COleTls Tls(hr);

    // initialized if any MTA apartment exists, or if the current thread has
    // been initialized, or if the current thread is in the NA.

    return (SUCCEEDED(hr) &&
            (g_cMTAInits > 0 || Tls->cComInits != 0 || IsThreadInNTA()))
           ? TRUE : FALSE;
}
//+---------------------------------------------------------------------
//
//  Function:   CoGetCurrentProcess
//
//  Synopsis:   Returns a unique value for the current thread. This routine is
//              necessary because hTask values from Windows get reused
//              periodically.
//
//  Arguments:  -
//
//  Returns:    DWORD
//
//  History:    28-Jul-94   BruceMa    Created.
//
//  Notes:
//
//----------------------------------------------------------------------
STDAPI_(DWORD) CoGetCurrentProcess(void)
{
    HRESULT hr;

    OLETRACEIN((API_CoGetCurrentProcess, NOPARAM));

    COleTls Tls(hr);

    if ( FAILED(hr) )
    {
        OLETRACEOUTEX((API_CoGetCurrentProcess, RETURNFMT("%ud"), 0));
        return 0;
    }

    // Get our OLE-specific thread id
    if ( Tls->dwApartmentID == 0 )
    {
        // This sets our dwApartmentID.
        ScmGetThreadId( &Tls->dwApartmentID );
        // On Win95 Tls->dwApartmentID can be 0 if the resolver fails initialization
        if ( Tls->dwApartmentID == 0 )
        {
            Tls->dwApartmentID = GetTickCount();
        }
    }

    Win4Assert(Tls->dwApartmentID);
    OLETRACEOUTEX((API_CoGetCurrentProcess, RETURNFMT("%ud"), Tls->dwApartmentID));

    return Tls->dwApartmentID;
}

//+-------------------------------------------------------------------------
//
//  Function:   CoBuildVersion
//
//  Synopsis:   Return build version DWORD
//
//  Returns:    DWORD hiword = 23
//              DWORD loword = build number
//
//  History:    16-Feb-94 AlexT     Use verole.h rmm for loword
//
//  Notes:      The high word must always be constant for a given platform.
//              For Win16 it must be exactly 23 (because that's what 16-bit
//              OLE 2.01 shipped with).  We can choose a different high word
//              for other platforms.  The low word must be greater than 639
//              (also because that's what 16-bit OLE 2.01 shipped with).
//
//--------------------------------------------------------------------------
STDAPI_(DWORD)  CoBuildVersion( VOID )
{
    WORD wLowWord;
    WORD wHighWord;

    OLETRACEIN((API_CoBuildVersion, NOPARAM));

    wHighWord = 23;
    wLowWord  = rmm;    //  from ih\verole.h

    Win4Assert(wHighWord == 23 && "CoBuildVersion high word magic number");
    Win4Assert(wLowWord > 639 && "CoBuildVersion low word not large enough");

    DWORD dwVersion;

    dwVersion = MAKELONG(wLowWord, wHighWord);

    OLETRACEOUTEX((API_CoBuildVersion, RETURNFMT("%x"), dwVersion));

    return dwVersion;
}

//+-------------------------------------------------------------------------
//
//  Function:   CoSetState
//              CoGetState
//
//  Synopsis:   These are private APIs, exported for use by the
//              OLE Automation DLLs, which allow them to get and
//              set a single per thread "state" object that is
//              released at CoUninitialize time.
//
//  Arguments:  [punk/ppunk] the object to set/get
//
//  History:    15-Jun-94 Bradlo    Created
//
//--------------------------------------------------------------------------
STDAPI CoSetState(IUnknown *punkStateNew)
{
    OLETRACEIN((API_CoSetState, PARAMFMT("punk= %p"), punkStateNew));

    HRESULT hr;
    COleTls Tls(hr);
#ifdef WX86OLE
    // Make sure we get the flag on our stack before any callouts
    BOOL fWx86Thread = gcwx86.IsWx86Calling();
#endif

    if (SUCCEEDED(hr))
    {
        IUnknown *punkStateOld;

        //  Note that either the AddRef or the Release below could (in
        //  theory) cause a reentrant call to us.  By keeping
        //  punkStateOld in a stack variable, we handle this case.

        if (NULL != punkStateNew)
        {
            //  We're going to replace the existing state with punkStateNew;
            //  take a reference right away

            //  Note thate even if this AddRef reenters TLSSetState we're
            //  okay because we haven't touched pData->punkState yet.
            punkStateNew->AddRef();

            // Single thread CoSetState/CoGetState
            COleStaticLock lck(g_mxsCoSetState);
            if (++g_cCoSetState == 1)
            {
                // The first time CoSetState is called by OA.
                // We do a load lib here so OA won't go away while we hold
                // the per state pointer.
                //
                Win4Assert(g_hOleAut32 == NULL);
                g_hOleAut32 = LoadLibraryA("oleaut32.dll");
#if DBG==1
                if (g_hOleAut32 == NULL)
                {
                    CairoleDebugOut((DEB_DLL,
                        "CoSetState: LoadLibrary oleaut32.dll failed\n"));
                }
#endif
            }
        }

#ifdef WX86OLE
        // If this was called from x86 code via wx86 thunk layer then use
        // alternate location in TLS.
        if (fWx86Thread)
        {
            punkStateOld = Tls->punkStateWx86;
            Tls->punkStateWx86 = punkStateNew;
        } else {
            punkStateOld = Tls->punkState;
            Tls->punkState = punkStateNew;
        }
#else
        punkStateOld = Tls->punkState;
        Tls->punkState = punkStateNew;
#endif

        if (NULL != punkStateOld)
        {
            //  Once again, even if this Release reenters TLSSetState we're
            //  okay because we're not going to touch pData->punkState again
            punkStateOld->Release();

            HINSTANCE hOleAut32 = NULL;     //

            {
                // Single thread CoSetState/CoGetState
                COleStaticLock lck(g_mxsCoSetState);
                if (--g_cCoSetState == 0)
                {
                    // Release the last ref to OA per thread state.
                    // We do a free lib here so OA may go away if it wants to.
                    //
                    Win4Assert(g_hOleAut32 != NULL);
                    hOleAut32 = g_hOleAut32;
                    g_hOleAut32 = NULL;
                }
                // release the lock implicitly
            }                               // in case dll detatch calls back
            if (hOleAut32)
                FreeLibrary(hOleAut32);
        }

        OLETRACEOUT((API_CoSetState, S_OK));
        return S_OK;
    }

    OLETRACEOUT((API_CoSetState, S_FALSE));
    return S_FALSE;
}

STDAPI CoGetState(IUnknown **ppunk)
{
    OLETRACEIN((API_CoGetState, PARAMFMT("ppunk= %p"), ppunk));

    HRESULT hr;
    COleTls Tls(hr);
#ifdef WX86OLE
    // Make sure we get the flag on our stack before any callouts
    BOOL fWx86Thread = gcwx86.IsWx86Calling();
#endif
    IUnknown *punk;

    if (SUCCEEDED(hr))
    {
#ifdef WX86OLE
        // If this was called from x86 code via wx86 thunk layer then use
        // alternate location in TLS.
        punk = fWx86Thread ? Tls->punkStateWx86 :
                             Tls->punkState;
#else
        punk = Tls->punkState;
#endif
       if (punk)
       {
           punk->AddRef();
           *ppunk = punk;

           OLETRACEOUT((API_CoGetState, S_OK));
           return S_OK;
       }
    }

    *ppunk = NULL;

    OLETRACEOUT((API_CoGetState, S_FALSE));
    return S_FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   CoQueryReleaseObject, private
//
//  Synopsis:   Determine if this object is one that should be released during
//              shutdown.
//
//  Effects:    Turns out that some WOW applications don't cleanup properly.
//              Specifically, sometimes they don't release objects that they
//              really should have. Among the problems caused by this are that
//              some objects don't get properly cleaned up. Storages, for
//              example, don't get closed. This leaves the files open.
//              Monikers are being released, which eat memory.
//
//              This function is called by the thunk manager to determine
//              if an object pointer is one that is known to be leaked, and
//              if the object should be released anyway. There are several
//              classes of object that are safe to release, and some that
//              really must be released.
//
//  Arguments:  [punk] -- Unknown pointer to check
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    8-15-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD adwQueryInterfaceTable[QI_TABLE_END] = { 0 , 0 };
STDAPI CoQueryReleaseObject(IUnknown *punk)
{
    OLETRACEIN((API_CoQueryReleaseObject, PARAMFMT("punk= %p"), punk));
    CairoleDebugOut((DEB_ITRACE,
                     "CoQueryReleaseObject(%x)\n",
                     punk));
    //
    // A punk is a pointer to a pointer to a vtbl. We are going to check the
    // vtbl to see if we can release it.
    //

    DWORD pQueryInterface;
    HRESULT hr;

    if (!IsValidReadPtrIn(punk,sizeof(DWORD)))
    {
        hr = S_FALSE;
        goto ErrorReturn;
    }

    if (!IsValidReadPtrIn(*(DWORD**)punk,sizeof(DWORD)))
    {
        hr = S_FALSE;
        goto ErrorReturn;
    }

    // Pick up the QI function pointer
    pQueryInterface = **(DWORD **)(punk);

    CairoleDebugOut((DEB_ITRACE,
                     "CoQueryReleaseObject pQueryInterface = %x\n",
                     pQueryInterface));

    //
    // adwQueryInterfaceTable is an array of known QueryInterface pointers.
    // Either the value in the table is zero, or it is the address of the
    // classes QueryInterface method. As each object of interest is created,
    // it will fill in its reserved entry in the array. Check olepfn.hxx for
    // details
    //

    if( pQueryInterface != 0)
    {
        for (int i = 0 ; i < QI_TABLE_END ; i++)
        {
            if (adwQueryInterfaceTable[i] == pQueryInterface)
            {
                CairoleDebugOut((DEB_ITRACE,
                                 "CoQueryReleaseObject punk matched %x\n",i));
                hr = NOERROR;
                goto ErrorReturn;
            }
        }
    }
    CairoleDebugOut((DEB_ITRACE,
                     "CoQueryReleaseObject No match on punk\n"));
    hr = S_FALSE;

ErrorReturn:
    OLETRACEOUT((API_CoQueryReleaseObject, hr));

    return hr;
}

#if defined(_CHICAGO_)
//+---------------------------------------------------------------------------
//
//  Function:   CoCreateAlmostGuid
//
//  Synopsis:   Creates a GUID for internal use that is going to be unique
//              as long as something has OLE32 loaded. We don't need a true
//              GUID for the uses of this routine, since the values are only
//              used on this local machine, and are used in data structures
//              that are not persistent.
//  Effects:
//
//  Arguments:  [pGuid] --  The output goes here.
//
//  History:    5-08-95   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CoCreateAlmostGuid(GUID *pGuid)
{
    static LONG gs_lNextGuidIndex = 0x1;
    DWORD *pGuidPtr = (DWORD *)pGuid;

    //
    // Note: As long as we increment the value, we don't
    // care what it is. This, in combination with the PID,TID, and TickCount
    // make this GUID unique enough for what we need. We would need to allocate
    // 4 gig of UUID's to run the NextGuidIndex over.
    //

    InterlockedIncrement(&gs_lNextGuidIndex);

    pGuidPtr[0] = gs_lNextGuidIndex;
    pGuidPtr[1] = GetTickCount();
    pGuidPtr[2] = GetCurrentThreadId();
    pGuidPtr[3] = GetCurrentProcessId();
    return(S_OK);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\class\cspytbl.cxx ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:       cspytbl.cxx
//
//  Contents:   Used by CTaskMemory::* (memapi.cxx) to support IMallocSpy
//
//  Synopsis:   The requirements are to efficiently store, locate and remove
//              entries in a table that may have to be expanded.  Therefore
//              the choice is a dynamically expandable hash table.  It is
//              fast and removals do not require compaction.  Expansion is
//              always to twice the current number of entries, so excessive
//              expansions will not be done.
//
//  Classes:    CSpyTable
//
//  Functions:  
//
//  History:    27-Oct-94  BruceMa      Created
//
//----------------------------------------------------------------------


#include <ole2int.h>
#include "cspytbl.hxx"





//+-------------------------------------------------------------------------
//
//  Member:	CSpyTable::CSpyTable, public
//
//  Synopsis:	Constructor
//
//  Arguments:	BOOl *  -       Indicates construction success
//
//  Algorithm:	
//
//  History:	27-Oct-94  Brucema       Created
//
//  Notes:	
//
//--------------------------------------------------------------------------
CSpyTable::CSpyTable(BOOL *pfOk)
{
    // Allocate and initialize the hash table
    m_cAllocations = 0;
    m_cEntries = INITIALENTRIES;
    m_table = (LPAENTRY) LocalAlloc(LMEM_FIXED, m_cEntries * sizeof(AENTRY));
    if (m_table == NULL)
    {
        *pfOk = FALSE;
        return;
    }

    // Initialize the table
    // m_table[*].dwCollision = FALSE;
    // m_table[*].allocation = NULL;
    memset(m_table, 0, m_cEntries * sizeof(AENTRY));

    // Return success
    *pfOk = TRUE;

}






//+-------------------------------------------------------------------------
//
//  Member:	CSpyTable::~CSpyTable, public
//
//  Synopsis:	Destructor
//
//  Arguments:	-
//
//  Algorithm:	
//
//  History:	27-Oct-94  Brucema       Created
//
//  Notes:	
//
//--------------------------------------------------------------------------
CSpyTable::~CSpyTable()
{
    // Delete the table
    LocalFree(m_table);
}
    




//+-------------------------------------------------------------------------
//
//  Member:	CSpyTable::Add, public
//
//  Synopsis:	Add an entry to the hash table
//
//  Arguments:	void *  -       The allocation to add
//
//  Algorithm:	
//
//  Returns:    TRUE     -       Entry added
//              FALSE    -       Memory failure expanding table
//
//  History:	27-Oct-94  Brucema       Created
//
//  Notes:	(1) This can only fail on a memory allocation failure
//
//              (2) The j == j0 test guarantees the table is full since
//                  the algorithm is wrapping at a collision using a prime
//                  number which is relatively prime to m_cEntries
//
//--------------------------------------------------------------------------
BOOL CSpyTable::Add(void *allocation)
{
    ULONG j0, j;

    // Don't add null entries
    if (allocation == NULL)
    {
        return FALSE;
    }
    
    // Search for an available entry

    // Do until success or the table is full
    j = j0 = PtrToUlong(allocation) % m_cEntries;
    do
    {
        j = (j + PRIME) % m_cEntries;
        if (m_table[j].pAllocation != NULL)
        {
            m_table[j].dwCollision = TRUE;
        }
    } until_(m_table[j].pAllocation == NULL  ||  j == j0);

    // Found an available entry
    if (j != j0)
    {
        m_table[j].pAllocation = allocation;
        m_cAllocations++;
        return TRUE;
    }

    // The table is full
    else
    {
        // Expand the hash table
        if (!Expand())
        {
            return FALSE;
        }

        // Call ourself recusively to add
        return Add(allocation);
    }
}






//+-------------------------------------------------------------------------
//
//  Member:	CSpyTable::Remove, public
//
//  Synopsis:	Remove an entry from the table
//
//  Arguments:	void *  -       The allocation to remove
//
//  Algorithm:	
//
//  Returns:    TRUE     -       Entry removed
//              FALSE    -       Entry not found
//
//  History:	27-Oct-94  Brucema       Created
//
//  Notes:	
//
//--------------------------------------------------------------------------
BOOL CSpyTable::Remove(void *allocation)
{
    ULONG j0, j;
    
    // Search for the entry
    if (Find(allocation, &j))
    {
        // Remove the entry
        m_table[j].pAllocation = NULL;

        // Remove collison markers from here backward until
        // a non-empty entry (if next forward entry is not empty)
        if (m_table[j].dwCollision)
        {
            j0 = (j + PRIME) % m_cEntries;
            if (m_table[j].pAllocation == NULL  &&  !m_table[j].dwCollision)
            {
                j0 = j;
                do
                {
                    m_table[j].dwCollision = FALSE;
                    j = (j - PRIME + m_cEntries) % m_cEntries;
                } until_(m_table[j].pAllocation != NULL  ||  j == j0);
            }
        }
        m_cAllocations--;
        return TRUE;
    }

    // Otherwise the entry was not found
    else
    {
        return FALSE;
    }
}






//+-------------------------------------------------------------------------
//
//  Member:	CSpyTable::Find, public
//
//  Synopsis:	Find an entry in the table
//
//  Arguments:	void *  -       The allocation to find
//              ULONG * -       Out parameter to store the index of
//                              the found entry
//
//  Algorithm:	
//
//  Returns:    TRUE     -       Entry found
//              FALSE    -       Entry not found
//
//  History:	27-Oct-94  Brucema       Created
//
//  Notes:	
//
//--------------------------------------------------------------------------
BOOL  CSpyTable::Find(void *allocation, ULONG *pulIndex)
{
    ULONG j0, j;

    // Don't search for null entries
    if (allocation == NULL)
    {
        return FALSE;
    }
    
    // Search for the entry

    // Do until success or end of the table is reached
    j = j0 = PtrToUlong(allocation) % m_cEntries;
    do
    {
        j = (j + PRIME) % m_cEntries;
    } until_(m_table[j].pAllocation == allocation  ||
             (m_table[j].pAllocation == NULL  &&
              m_table[j].dwCollision == FALSE)    ||
             j == j0);

    // Return result
    if (m_table[j].pAllocation == allocation)
    {
        *pulIndex = j;
        return TRUE;
    }

    // Else not found
    else
    {
        return FALSE;
    }
}






//+-------------------------------------------------------------------------
//
//  Member:	CSpyTable::Expand, private
//
//  Synopsis:	Expand the hash table
//
//  Arguments:	-
//
//  Algorithm:	
//
//  Returns:    TRUE    -       Expansion successful
//              FALSE   -       Memory allocation failure during expansion
//
//  History:	27-Oct-94  Brucema       Created
//
//  Notes:	To allow starting with a small table but not to do too many
//              expansions in a large application, we expand by twice the
//              current number of entries.
//
//--------------------------------------------------------------------------
BOOL CSpyTable::Expand(void)
{
    LPAENTRY pOldTable;

    // Save the current table
    pOldTable = m_table;

    // Allocate a new table
    m_cEntries *= 2;
    m_table = (LPAENTRY) LocalAlloc(LMEM_FIXED, m_cEntries * sizeof(AENTRY));
    if (m_table == NULL)
    {
        m_table = pOldTable;
        return FALSE;
    }

    // Initialize it
    for (ULONG j = 0; j < m_cEntries; j++)
    {
        m_table[j].dwCollision = FALSE;
        m_table[j].pAllocation = NULL;
    }

    // Restore the entries in the old table
    m_cAllocations = 0;
    for (j = 0; j < m_cEntries / 2; j++)
    {
        if (pOldTable[j].pAllocation != NULL)
        {
            Add(pOldTable[j].pAllocation);
        }
    }

    // Clean up
    LocalFree(pOldTable);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\class\hkole32.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    hkole.cpp

Abstract:

    This file contains all functions used for hookole support.
        InitHookOle         (called from ProcessAttach routine)
        UninitHookOle       (called from ProcessDetach routine)
        EnableHookObject    (exported function)
        GetHookInterface    (exported function)
        HkOleRegisterObject (exported function)

    This code was originally added to compobj.cxx in the form of macros that
    existed in hkole32.h

Author:

    Dan Lafferty (danl) 04-Jun-1996

Environment:

    User Mode - Win32

Revision History:

    04-Jun-1996 danl
    Created

--*/
//
// INCLUDES
//
#include <ole2int.h>
#include <windows.h>
#include <hkole32.h>

//#include <tchar.h>


//
// Registry Key Strings
//
#define szCLSIDKey      "CLSID"
#define HookBase        HKEY_LOCAL_MACHINE
#define szHookKey       "Software\\Microsoft\\HookOleObject"
#define KEY_SEP         "\\"

//
// Event Name used for Global Hook Switch.
//
#define szHookEventName    "HookSwitchHookEnabledEvent"

//
// Length of CLSID string including NUL terminator.
//
#define MAX_CLSID  39

//
//  IHookOleObject used to satisfy usage in GetHookInterface
//  (This is copied from the oletools\hookole\inc\hookole.h file).
//    NOTE:  This is just a dummy used to pass the pointer through.
//
interface IHookOleObject : IUnknown{};

//
// Function Types.
//
typedef HRESULT (STDAPICALLTYPE * LPFNINITHOOKOLE)(VOID);
typedef HRESULT (STDAPICALLTYPE * LPFNUNINITHOOKOLE)(VOID);

typedef HRESULT (STDAPICALLTYPE * LPFNENABLEHOOKOBJECT)(
            BOOL    bEnabled,
            PBOOL    pbPrevious);

typedef HRESULT (STDAPICALLTYPE * LPFNGETHOOKINTERFACE)(
            IHookOleObject **ppNewHook);

typedef HRESULT (STDAPICALLTYPE * LPFNHKOLEREGISTEROBJECT)(
            REFCLSID    rclsid,
            REFIID      riid,
            LPVOID      pvObj,
            BOOL    fNewInstance);

//
// GLOBALS
//
    HINSTANCE               glhHookDll = NULL;

    LPFNINITHOOKOLE         pfnInitHookOle         =NULL;
    LPFNUNINITHOOKOLE       pfnUninitHookOle       =NULL;
    LPFNENABLEHOOKOBJECT    pfnEnableHookObject    =NULL;
    LPFNGETHOOKINTERFACE    pfnGetHookInterface    =NULL;
    LPFNHKOLEREGISTEROBJECT pfnHkOleRegisterObject = NULL;

//
// Local Function Prototypes and Inline Functions
//
VOID
HkFindAndLoadDll(
    VOID
    );

HINSTANCE
HkLoadInProcServer(
    REFCLSID rclsid
    );

inline HRESULT CLSIDFromStringA(LPSTR lpsz, LPCLSID lpclsid)
{
    LPWSTR lpwsz = new WCHAR[strlen(lpsz)+1];

    if (NULL == lpwsz)
        return E_OUTOFMEMORY;

    MultiByteToWideChar (
        CP_ACP,
        MB_PRECOMPOSED,
        lpsz,
        -1,
        lpwsz,
        lstrlenA(lpsz)+1);

    HRESULT hr = CLSIDFromString(lpwsz, lpclsid);
    delete lpwsz;
    return hr;
}

VOID
InitHookOle(
    VOID
    )

/*++

Routine Description:

    This routine is called from the OLE32 PROCESS_ATTACH routine.
    It checks the state of the global hook switch.  If in the ON state,
    the HookOle DLL is loaded and the global procedure addresses are
    obtained.  If the HookOle pfcnInitHookOle pointer was obtained,
    then that function is called so that HookOle.DLL is properly initialized.

Arguments:

    none.

Return Value:
    none.  Success or failure is determined by the state of the globals.

--*/
{
    HANDLE  hHookEvent  = NULL;
    HKEY    hRegKey     = NULL;
    DWORD   status;

    LPFNGETCLASSOBJECT pfnGCO;

    //
    // See if the hook switch exists.  If not, hooking can't be on.
    //
    hHookEvent  = OpenEventA(EVENT_ALL_ACCESS,FALSE, szHookEventName);
    if (hHookEvent == NULL) {
        //
        // Hooking is OFF.
        //
        return;
    }

    //
    // See if the hook switch is on.
    //
    status = WaitForSingleObject(hHookEvent,0);
    if (status != WAIT_OBJECT_0) {
        //
        // The event is not-signaled.  Hooking is OFF.
        //
        goto CleanExit;
    }

    //
    // Hooking is ON.  Now find the hookole dll name and load it.
    //
    HkFindAndLoadDll();

    //
    // Call the InitHookOle function in HookOle.DLL
    // NOTE:  This InitHookOle has a return value.
    //
    if (pfnInitHookOle != NULL) {
        if (pfnInitHookOle() != S_OK) {

            //
            // If HookOLE failed and is unusable, then release the DLL.
            // and function pointers
            //
            UninitHookOle();
        }
    }

CleanExit:
    if (hHookEvent != NULL) {
        CloseHandle(hHookEvent);
        hHookEvent = NULL;
    }
}

VOID
UninitHookOle(
    VOID
    )

/*++

Routine Description:

    This routine is called from the OLE32 PROCESS_DETACH routine.
    It unloads the HookOLE DLL and sets the global pointers to a safe (NULL)
    state.

Arguments:
    none.

Return Value:
    none.

--*/
{
    //
    // Tell HookOLE DLL to uninitialize.
    //
    if (pfnUninitHookOle != NULL) {
        pfnUninitHookOle();
    }

    //
    // Remove all the procedure function pointers
    //
    pfnInitHookOle          =NULL;
    pfnUninitHookOle        =NULL;
    pfnEnableHookObject     =NULL;
    pfnGetHookInterface     =NULL;
    pfnHkOleRegisterObject  =NULL;

    //
    // Free the DLL
    //
    if (glhHookDll != NULL) {
        FreeLibrary(glhHookDll);
    }

    return;
}

STDAPI_(HRESULT)
EnableHookObject(
    IN  BOOL    bEnabled,
    OUT BOOL*   pbPrevious
    )

/*++

Routine Description:

    This function is used by components to turn off hooking for the
    current process.  This is required by components such as OleLogger
    where not doing so would cause new log entries to be generated
    whenever a log entry was being removed from the HookOleLog circular
    queue.

Arguments:

    bEnabled - TRUE if hooking is to be enabled.  FALSE if it is to be
    disabled.

    pbPrevious - TRUE if hooking was previously enabled.  FALSE if hooking
    was previously disabled.

Return Value:
    S_OK - if the operation was successful.
    otherwise an appropriate error is returned.

--*/
{
    //
    // If the caller wants to enable hookole, but the hookole dll isn't
    // loaded, then load the dll.
    //
    if ((bEnabled == TRUE) && (glhHookDll == NULL)) {
        HkFindAndLoadDll();
    }

    //
    // Call the EnableHookObject function in HookOle.DLL
    //
    if (pfnEnableHookObject != NULL) {
        return(pfnEnableHookObject(bEnabled,pbPrevious));
    }
    else {
        return(E_UNEXPECTED);
    }
}

STDAPI_(HRESULT)
GetHookInterface(
    OUT IHookOleObject** ppNewHook
    )

/*++

Routine Description:

    This function is used by components to obtain the pointer to the
    IHookOle interface created to hook interfaces in this process.
    The interface pointer is AddRef'd by GetHookInterface so the
    caller is required to Release the pointer when finished with it.

    This is currently called from the QueryContainedInterface calls in
    CIHookOleClass and CIHookOleInstance.  It is also called during
    wrapper DLL process attach.


Arguments:

    ppNewHook - Location where the pointer to the IHookOle interface is
    to be returned.

Return Value:

    S_OK - if the operation was successful.
    E_NOINTERFACE - The interface pointer doesn't exist.
    E_INVALIDARG - ppNewHook is an invalid pointer.

--*/
{
    if (pfnGetHookInterface != NULL) {
        return(pfnGetHookInterface(ppNewHook));
    }
    return(E_NOINTERFACE);
}

STDAPI_(HRESULT)
HkOleRegisterObject(
    IN  REFCLSID    rclsid,
    IN  REFIID      riid,
    IN  LPVOID      pvObj,
    IN  BOOL    fNewInstance
    )

/*++

Routine Description:

    This routine can be called from application programs that desire to
    register a newly created object with hookole.

Arguments:

    rclsid - pointer to the clsid for the object being registered.

    riid - pointer to the iid for the object being registered.

    pvObj - pointer to the object that is being registered.

Return Value:

    S_OK - if the operation was successful.
    E_NOINTERFACE - HookOle isn't loaded.

--*/
{
    if (pfnHkOleRegisterObject != NULL) {
        return(pfnHkOleRegisterObject(rclsid,riid,pvObj,fNewInstance));
    }
    return(E_NOINTERFACE);
}

VOID
HkFindAndLoadDll(
    VOID
    )

/*++

Routine Description:

    Obtains the DLL path name from the registry and loads the dll and obtains
    all the relevant procedure addresses.

Arguments:

    none

Return Value:

    none - success is determined by examining the global handle to the dll
        and the procedure function pointers.  If they were successfully
        obtained, they will be non-NULL.

--*/
{
    DWORD    status;
    CLSID   HookClsid;
    CHAR    szClsidText[MAX_PATH];
    DWORD   dwType;
    DWORD   dwSize;
    HKEY    hRegKey;

    //
    // Open key to "\\Software\\Microsoft\\HookOleObject"
    //
    status = RegOpenKeyA(HookBase,szHookKey,&hRegKey);
    if (status != ERROR_SUCCESS) {
        goto CleanExit;
    }

    //
    // Read the CLSID string from the registry
    //
    dwSize = sizeof(szClsidText);
    status = RegQueryValueExA(
                    hRegKey,
                    szCLSIDKey,
                    NULL,
                    &dwType,
                    (LPBYTE)&szClsidText,
                    &dwSize);

    if (status != ERROR_SUCCESS) {
        //
        // Failed to obtain the CLSID for HookOleObject
        //
        goto CleanExit;
    }

    //
    // Make CLSID out of the text string.
    //
    if (!SUCCEEDED(CLSIDFromStringA(szClsidText,&HookClsid))) {
        //
        // could not find clsid for HookOleObject in registry
        //
        goto CleanExit;
    }

    //
    // Load the HookOle Dll identifed by the CLSID.
    // Store the handle in a global location.
    //
    glhHookDll = HkLoadInProcServer(HookClsid);
    if (!glhHookDll) {
        //
        // dll would not load or could not be found
        //
        goto CleanExit;
    }

    //
    // Get the entry point for DllGetClassObject.
    //
    pfnInitHookOle        = (LPFNINITHOOKOLE)
                            GetProcAddress(glhHookDll,"InitHookOle");

    pfnUninitHookOle      = (LPFNUNINITHOOKOLE)
                            GetProcAddress(glhHookDll,"UninitHookOle");

    pfnEnableHookObject   = (LPFNENABLEHOOKOBJECT)
                            GetProcAddress(glhHookDll,"EnableHookObject");

    pfnGetHookInterface   = (LPFNGETHOOKINTERFACE)
                            GetProcAddress(glhHookDll,"GetHookInterface");

    pfnHkOleRegisterObject= (LPFNHKOLEREGISTEROBJECT)
                            GetProcAddress(glhHookDll,"HkOleRegisterObject");

CleanExit:
    if (hRegKey != NULL) {
        RegCloseKey(hRegKey);
        hRegKey = NULL;
    }
}

HINSTANCE
HkLoadInProcServer(
    REFCLSID rclsid
    )
/*++

Routine Description:

    This routine loads the DLL for the InProc server identified by the
    rclsid.

Arguments:

    rclsid - CLSID for the inproc server dll that is to be loaded.

Return Value:

    hDLL - the handle for the DLL is returned.  If this function failed,
        a NULL is returned.

--*/
{
    CHAR        szInProc32[] = "InprocServer32";
    CHAR        szClsidKey[MAX_PATH];
    CHAR        szDllName[MAX_PATH];
    WCHAR       szClsidW[MAX_CLSID];
    CHAR        szClsid[MAX_CLSID];
    LONG        lSize = sizeof(szDllName);
    DWORD       status;
    HRESULT     hr;
    HINSTANCE   hDll = NULL;

    hr = StringFromGUID2(rclsid, szClsidW, MAX_CLSID);
    if (SUCCEEDED(hr)) {

        WideCharToMultiByte (
            CP_ACP,
            WC_COMPOSITECHECK,
            szClsidW,
            -1,
            szClsid,
            sizeof(szClsid),
            NULL,
            NULL);

        //
        // "CLSID\\classid-string\\InprocServer32"
        //
        strcpy(szClsidKey, szCLSIDKey);
        strcat(szClsidKey, KEY_SEP);
        strcat(szClsidKey,szClsid);
        strcat(szClsidKey,KEY_SEP);
        strcat(szClsidKey,szInProc32);

        status = RegQueryValueA(
                    HKEY_CLASSES_ROOT,
                    szClsidKey,
                    szDllName,
                    &lSize);

        if (status == ERROR_SUCCESS) {
            hDll = LoadLibraryA(szDllName);
        }
    }
    return(hDll);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\class\ole1guid.h ===
/* ole1guid.h

	Contains prototypes for OLE10 class string <--> CLSID conversion
	functions in ole1guid.cpp

	These functions are to be called only if the information
	is not available in the reg db.

	Copyright (c) 1992  Microsoft Corporation
*/


INTERNAL Ole10_StringFromCLSID
	(REFCLSID clsid,
	LPWSTR szOut,
	int cbMax);

INTERNAL Ole10_CLSIDFromString
	(LPCWSTR szOle1,
	CLSID FAR* pclsid,
	BOOL fForceAssign);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\class\longpath.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	longpath.cxx
//
//  Contents:	GetLongPathName implementation
//
//  History:	25-Aug-94	DrewB	Created from Win32 sources for
//                                      GetShortPathName
//              06-Sep-94       DrewB   Rewrote using Win32 for portability
//              11-Nov-94       BruceMa Use this version for both Chicago
//                               and NT
//
//----------------------------------------------------------------------------

#include <ole2int.h>
#include <widewrap.h>
#include <longname.h>

#define ARGUMENT_PRESENT2(p) ((p) != NULL)

//+---------------------------------------------------------------------------
//
//  Function:	IsLongComponent, public
//
//  Synopsis:	Determines whether the current path component is a legal
//              8.3 name or not.  If not, it is considered to be a long
//              component.
//
//  Arguments:	[pwcsPath] - Path to check
//              [ppwcsEnd] - Return for end of component pointer
//
//  Returns:	BOOL
//
//  Modifies:	[ppwcsEnd]
//
//  History:	28-Aug-94	DrewB	Created
//
//  Notes:      An empty path is considered to be long
//              The following characters are not valid in file name domain:
//              * + , : ; < = > ? [ ] |
//
//----------------------------------------------------------------------------

BOOL IsLongComponent(LPCWSTR pwcsPath,
                     PWSTR *ppwcsEnd)
{
    LPWSTR pwcEnd, pwcDot;
    BOOL fLongNameFound;
    WCHAR wc;

    pwcEnd = (LPWSTR)pwcsPath;
    fLongNameFound = FALSE;
    pwcDot = NULL;

    while (TRUE)
    {
	wc = *pwcEnd;

	if (wc == L'\\' || wc == 0)
        {
            *ppwcsEnd = pwcEnd;

            // We're at a component terminator, so make the
            // determination of whether what we've seen is a long
            // name or short one

            // If we've aready seen illegal characters or invalid
            // structure for a short name, don't bother to check lengths
            if (pwcEnd-pwcsPath > 0 && !fLongNameFound)
            {
                // If this component fits in 8.3 then it is a short name
                if ((!pwcDot && (ULONG)(pwcEnd - pwcsPath) <= 8) ||
                    (pwcDot && ((ULONG)(pwcEnd - pwcDot) <= 3 + 1 &&
                                (ULONG)(pwcEnd - pwcsPath) <= 8 + 3 + 1)))
                {
                    return FALSE;
                }
            }

            return TRUE;
        }

        // Handle dots
	if (wc == L'.')
        {
	    // If two or more '.' or the base name is longer than
	    // 8 characters or no base name at all, it is an illegal dos
            // file name
            if (pwcDot != NULL ||
                ((ULONG)(pwcEnd - pwcsPath)) > 8 ||
                (pwcEnd == pwcsPath && *(pwcEnd + 1) != L'\\'))
            {
		fLongNameFound = TRUE;
            }

	    pwcDot = pwcEnd;
        }

        // Check for characters which aren't valid in short names
	else if (wc <= L' ' ||
                 wc == L'*' ||
                 wc == L'+' ||
                 wc == L',' ||
                 wc == L':' ||
                 wc == L';' ||
                 wc == L'<' ||
                 wc == L'=' ||
                 wc == L'>' ||
                 wc == L'?' ||
                 wc == L'[' ||
                 wc == L']' ||
                 wc == L'|')
        {
	    fLongNameFound = TRUE;
        }

	pwcEnd++;
    }
}

//
// The following code was stolen from NT's RTL in curdir.c
//

#define IS_PATH_SEPARATOR(wch) \
    ((wch) == L'\\' || (wch) == L'/')

typedef enum
{
    PATH_TYPE_UNKNOWN,
    PATH_TYPE_UNC_ABSOLUTE,
    PATH_TYPE_LOCAL_DEVICE,
    PATH_TYPE_ROOT_LOCAL_DEVICE,
    PATH_TYPE_DRIVE_ABSOLUTE,
    PATH_TYPE_DRIVE_RELATIVE,
    PATH_TYPE_ROOTED,
    PATH_TYPE_RELATIVE
} PATH_TYPE;

PATH_TYPE
DetermineDosPathNameType(
    IN PCWSTR DosFileName
    )

/*++

Routine Description:

    This function examines the Dos format file name and determines the
    type of file name (i.e.  UNC, DriveAbsolute, Current Directory
    rooted, or Relative.

Arguments:

    DosFileName - Supplies the Dos format file name whose type is to be
        determined.

Return Value:

    PATH_TYPE_UNKNOWN - The path type can not be determined

    PATH_TYPE_UNC_ABSOLUTE - The path specifies a Unc absolute path
        in the format \\server-name\sharename\rest-of-path

    PATH_TYPE_LOCAL_DEVICE - The path specifies a local device in the format
        \\.\rest-of-path this can be used for any device where the nt and
        Win32 names are the same. For example mailslots.

    PATH_TYPE_ROOT_LOCAL_DEVICE - The path specifies the root of the local
        devices in the format \\.

    PATH_TYPE_DRIVE_ABSOLUTE - The path specifies a drive letter absolute
        path in the form drive:\rest-of-path

    PATH_TYPE_DRIVE_RELATIVE - The path specifies a drive letter relative
        path in the form drive:rest-of-path

    PATH_TYPE_ROOTED - The path is rooted relative to the current disk
        designator (either Unc disk, or drive). The form is \rest-of-path.

    PATH_TYPE_RELATIVE - The path is relative (i.e. not absolute or rooted).

--*/

{
    PATH_TYPE ReturnValue;

    if ( IS_PATH_SEPARATOR(*DosFileName) )
    {
        if ( IS_PATH_SEPARATOR(*(DosFileName+1)) )
        {
            if ( DosFileName[2] == L'.' )
            {
                if ( IS_PATH_SEPARATOR(*(DosFileName+3)) )
                {
                    ReturnValue = PATH_TYPE_LOCAL_DEVICE;
                }
                else if ( (*(DosFileName+3)) == 0 )
                {
                    ReturnValue = PATH_TYPE_ROOT_LOCAL_DEVICE;
                }
                else
                {
                    ReturnValue = PATH_TYPE_UNC_ABSOLUTE;
                }
            }
            else
            {
                ReturnValue = PATH_TYPE_UNC_ABSOLUTE;
            }
        }
        else
        {
            ReturnValue = PATH_TYPE_ROOTED;
        }
    }
    else if (*(DosFileName+1) == L':')
    {
        if (IS_PATH_SEPARATOR(*(DosFileName+2)))
        {
            ReturnValue = PATH_TYPE_DRIVE_ABSOLUTE;
        }
        else
        {
            ReturnValue = PATH_TYPE_DRIVE_RELATIVE;
        }
    }
    else
    {
        ReturnValue = PATH_TYPE_RELATIVE;
    }

    return ReturnValue;
}

//+---------------------------------------------------------------------------
//
//  Function:	InternalGetLongPathName, public
//
//  Synopsis:	Expand each component of the given path into its
//              long form
//
//  Arguments:	[pwcsPath] - Path
//              [pwcsLongPath] - Long path return buffer
//              [cchLongPath] - Size of return buffer in characters
//
//  Returns:	0 for errors
//              Number of characters needed for buffer if buffer is too small
//                includes NULL terminator
//              Length of long path, doesn't include NULL terminator
//
//  Modifies:	[pwcsLongPath]
//
//  History:	28-Aug-94	DrewB	Created
//              11-Nov-94       BruceMa Modifed to use for Chicago at
//                                      FindFirstFile
//
//  Notes:	The source and destination buffers can be the same memory
//              Doesn't handle paths with internal . and .., although
//              they are handled at the beginning
//
//----------------------------------------------------------------------------

ULONG
APIENTRY
InternalGetLongPathNameW(LPCWSTR pwcsPath,
                 LPWSTR  pwcsLongPath,
                 ULONG   cchLongPath)
{
    PATH_TYPE pt;
    HANDLE h;
    LPWSTR pwcsLocalLongPath;
    ULONG cchReturn, cb, cch, cchOutput;
    LPWSTR pwcStart = NULL;
    LPWSTR pwcEnd;
    LPWSTR pwcLong;
    WCHAR wcSave;
    BOOL fLong;
    WIN32_FIND_DATA wfd;
    cchReturn = 0;
    pwcsLocalLongPath = NULL;


    if (!ARGUMENT_PRESENT2(pwcsPath))
    {
	return 0;
    }

    __try
    {
	//
	// First, run down the string checking for tilde's. Any path
	// that has a short name section to it will have a tilde. If
	// there are no tilde's, then we already have the long path,
	// so we can return the string.
	//
	fLong = TRUE;
	for (pwcLong = (LPWSTR)pwcsPath; *pwcLong != 0; pwcLong++)
	{
	    if (*pwcLong == L'~')
	    {
		fLong = FALSE;
	    }
	}
	//
	// This derives the number of characters, including the NULL
	//
	cch = (ULONG)(pwcLong - pwcsPath) + 1; // Limit to 4GB on Win64

	//
	// If it isn't a long path already, then we are going to have
	// to parse it.
	//
	if (!fLong)
	{
	    // Decide the path type, we want find out the position of
	    // the first character of the first name
	    pt = DetermineDosPathNameType(pwcsPath);
	    switch(pt)
	    {
		// Form: "\\server_name\share_name\rest_of_the_path"
	    case PATH_TYPE_UNC_ABSOLUTE:
		if ((pwcStart = wcschr(pwcsPath + 2, L'\\')) != NULL &&
		    (pwcStart = wcschr(pwcStart + 1, L'\\')) != NULL)
		{
		    pwcStart++;
		}
		else
		{
		    pwcStart = NULL;
		}
		break;

		// Form: "\\.\rest_of_the_path"
	    case PATH_TYPE_LOCAL_DEVICE:
		pwcStart = (LPWSTR)pwcsPath + 4;
		break;

		// Form: "\\."
	    case PATH_TYPE_ROOT_LOCAL_DEVICE:
		pwcStart = NULL;
		break;

		// Form: "D:\rest_of_the_path"
	    case PATH_TYPE_DRIVE_ABSOLUTE:
		pwcStart = (LPWSTR)pwcsPath + 3;
		break;

		// Form: "rest_of_the_path"
	    case PATH_TYPE_RELATIVE:
		pwcStart = (LPWSTR) pwcsPath;
		goto EatDots;

		// Form: "D:rest_of_the_path"
	    case PATH_TYPE_DRIVE_RELATIVE:
		pwcStart = (LPWSTR)pwcsPath+2;

	    EatDots:
		// Handle .\ and ..\ cases
		while (*pwcStart != 0 && *pwcStart == L'.')
		{
		    if (pwcStart[1] == L'\\')
		    {
			pwcStart += 2;
		    }
		    else if (pwcStart[1] == L'.' && pwcStart[2] == L'\\')
		    {
			pwcStart += 3;
		    }
		    else
		    {
			break;
		    }
		}
		break;

		// Form: "\rest_of_the_path"
	    case PATH_TYPE_ROOTED:
		pwcStart = (LPWSTR)pwcsPath + 1;
		break;

	    default:
		pwcStart = NULL;
		break;
	    }
	}

        // In the special case where we have no work to do, exit quickly
        // This saves a lot of instructions for trivial cases
        // In one case the path as given requires no processing
	// The middle case, we determine there were no tilde's in the path
        // In the other, the path only has one component and it is already
        // long
	///
	if (pwcStart == NULL ||
	    (fLong == TRUE) ||
            ((fLong = IsLongComponent(pwcStart, &pwcEnd)) &&
             *pwcEnd == 0))
        {
	    // Nothing to convert, copy down the source string
	    // to the buffer if necessary

	    if (pwcStart != NULL)
            {
                cch = (ULONG)(pwcEnd - pwcsPath + 1);
            }

            if (cchLongPath >= cch)
            {
                // If there's an output buffer which is different from
                // the input buffer, fill it in
		if (ARGUMENT_PRESENT2(pwcsLongPath) &&
                    pwcsLongPath != pwcsPath)
                {
                    memcpy(pwcsLongPath, pwcsPath, cch * sizeof(WCHAR));
                }

                cchReturn = cch - 1;
                goto gsnTryExit;
            }
            else
            {
                cchReturn = cch;
                goto gsnTryExit;
            }
        }

	// Make a local buffer so that we won't overlap the
	// source pathname in case the long name is longer than the
	// source name.
	if (cchLongPath > 0 && ARGUMENT_PRESENT2(pwcsLongPath))
        {
	    pwcsLocalLongPath = (PWCHAR)PrivMemAlloc(cchLongPath * sizeof(WCHAR));
            if (pwcsLocalLongPath == NULL)
            {
                goto gsnTryExit;
	    }
        }

        // Set up pointer to copy output to
        pwcLong = pwcsLocalLongPath;
        cchOutput = 0;

        // Copy the portions of the path that we skipped initially
        cch = (ULONG)(pwcStart-pwcsPath);   //limit to 4Gb on Win64
        cchOutput += cch;
	if (cchOutput <= cchLongPath && ARGUMENT_PRESENT2(pwcsLongPath))
        {
            memcpy(pwcLong, pwcsPath, cch*sizeof(WCHAR));
            pwcLong += cch;
        }

        for (;;)
        {
            // Determine whether the current component is long or short
            cch = (ULONG)(pwcEnd-pwcStart)+1;  //Limit to 4GB on Win64
            cb = cch*sizeof(WCHAR);

            if (fLong)
            {
                // If the component is already long, just copy it into
                // the output.  Copy the terminating character along with it
                // so the output remains properly punctuated

                cchOutput += cch;
		if (cchOutput <= cchLongPath && ARGUMENT_PRESENT2(pwcsLongPath))
                {
                    memcpy(pwcLong, pwcStart, cb);
                    pwcLong += cch;
                }
            }
            else
            {
                WCHAR wcsTmp[MAX_PATH];

                // For a short component we need to determine the
                // long name, if there is one.  The only way to
                // do this reliably is to enumerate for the child

                wcSave = *pwcEnd;
                *pwcEnd = 0;

                h = FindFirstFile(pwcsPath, &wfd);
                *pwcEnd = wcSave;

                if (h == INVALID_HANDLE_VALUE)
                {
                    goto gsnTryExit;
                }

                FindClose(h);

                lstrcpyW(wcsTmp, wfd.cFileName);

                // Copy the filename returned by the query into the output
                // Copy the terminator from the original component into
                // the output to maintain punctuation
                cch = lstrlenW(wcsTmp)+1;
                cchOutput += cch;
		if (cchOutput <= cchLongPath && ARGUMENT_PRESENT2(pwcsLongPath))
                {
                    memcpy(pwcLong, wcsTmp, (cch-1)*sizeof(WCHAR));
                    pwcLong += cch;
                    *(pwcLong-1) = *pwcEnd;
                }
            }

            if (*pwcEnd == 0)
            {
                break;
            }

            // Update start pointer to next component
            pwcStart = pwcEnd+1;
            fLong = IsLongComponent(pwcStart, &pwcEnd);
        }

        // Copy local output buffer to given output buffer if necessary
	if (cchLongPath >= cchOutput && ARGUMENT_PRESENT2(pwcsLongPath))
        {
            memcpy(pwcsLongPath, pwcsLocalLongPath, cchOutput * sizeof(WCHAR));
            cchReturn = cchOutput-1;
        }
	else
        {
            cchReturn = cchOutput;
        }

gsnTryExit:;
    }
    __finally
    {
        if (pwcsLocalLongPath != NULL)
        {
	    PrivMemFree(pwcsLocalLongPath);
            pwcsLocalLongPath = NULL;
        }
    }

    return cchReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\class\memapi.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows:
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       MemAPI.CXX
//
//  Contents:   Memory allocation routines and IMallocSpy support
//
//  Classes:    CDebugMalloc
//              CRetailMalloc
//              CSpyMalloc
//
//  Functions:  CoGetMalloc
//              CoRegisterMallocSpy
//              CoRevokeMallocSpy
//              CoTaskMemAlloc
//              CoTaskMemFree
//              MIDL_user_allocate
//              MIDL_user_free
//
//  History:
//      04-Nov-93 AlexT     Created
//      25-Jan-94 AlexT     Add CTaskMemory
//      25-Jan-94 alexgo    added PubMemRealloc
//      08-Feb-94 AlexT     Fix MIPS alignment
//      24-Oct-94 BruceMa   Add API's CoRegisterMallocSpy and
//                          CoRevokeMallocSpy, and support for
//                          IMallocSpy
//      01-Nov-94 BruceMa   Improve performance of retail IMalloc
//      27-Sep-95 ShannonC  Rewrote in C to improve performance.
//
//  Notes:
//    OLE implements IMalloc using a single, static instance of CMalloc.
//    CoGetMalloc always returns the same IMalloc pointer.  When necessary,
//    OLE can change the behavior of CMalloc by changing the lpVtbl.
//
//    The CMalloc object has three interchangeable vtables.  Normally,
//    the CMalloc object uses either the CRetailMallocVtbl or the
//    CDebugMallocVtbl. If an IMallocSpy is registered, OLE will switch
//    to the CSpyMallocVtbl in order to add IMallocSpy support. Note that
//    we will not change vtables when the IMallocSpy is revoked.  Once OLE
//    switches to the CSpyMallocVtbl, it can never change back.
//
//--------------------------------------------------------------------------
#include <ole2int.h>
#include <memapi.hxx>
#include "cspytbl.hxx"

#if DBG==1
#include <alocdbg.h>
#endif  // DBG==1

//+-------------------------------------------------------------------------
//
//  Class:          CMalloc
//
//  Purpose:    Base class for OLE memory allocators.
//
//  Interface:  IMalloc
//
//  See Also:   CDebugMalloc, CRetailMalloc, CSpyMalloc
//
//--------------------------------------------------------------------------
HRESULT __stdcall CMalloc_QueryInterface(IMalloc * pThis,
                                         REFIID riid,
                                         void **ppvObject);

ULONG   __stdcall CMalloc_AddRef(IMalloc * pThis);

ULONG   __stdcall CMalloc_Release(IMalloc * pThis);

typedef struct IMallocVtbl
{
    HRESULT ( __stdcall *QueryInterface )(IMalloc * pThis,
                                          REFIID riid,
                                          void ** ppvObject);

    ULONG ( __stdcall *AddRef )(IMalloc * pThis);

    ULONG ( __stdcall *Release )(IMalloc * pThis);

    void *( __stdcall *Alloc )(IMalloc * pThis, SIZE_T cb);

    void *( __stdcall *Realloc )(IMalloc * pThis, void *pv, SIZE_T cb);

    void ( __stdcall *Free )(IMalloc * pThis, void *pv);

    SIZE_T ( __stdcall *GetSize )(IMalloc * pThis, void *pv);

    int ( __stdcall *DidAlloc )(IMalloc * pThis, void *pv);

    void ( __stdcall *HeapMinimize )(IMalloc * pThis);

} IMallocVtbl;

typedef struct CMalloc
{
    IMallocVtbl *lpVtbl;
} CMalloc;

//Global variables

//g_lpVtblMalloc points to CDebugMallocVtbl or CRetailMallocVtbl.
IMallocVtbl *   g_lpVtblMalloc = 0;

//WARNING: g_CMalloc.lpVtbl may change at runtime.
//Initially, g_CMalloc.lpVtbl points to either
//CDebugMallocVtbl or CRetailMallocVtbl.  When an IMallocSpy is
//registered, g_CMalloc.lpVtbl changes so it points to CSpyMallocVtbl.
CMalloc         g_CMalloc;
IMalloc *       g_pMalloc = (IMalloc *) &g_CMalloc;

//+-------------------------------------------------------------------------
//
//  Class:      CDebugMalloc
//
//  Purpose:    OLE debug memory allocator.
//
//  Interface:  IMalloc
//
//--------------------------------------------------------------------------
#if DBG==1

//function prototypes.
void *  __stdcall CDebugMalloc_Alloc(IMalloc *pThis, SIZE_T cb);

void *  __stdcall CDebugMalloc_Realloc(IMalloc *pThis, void *pv, SIZE_T cb);

void    __stdcall CDebugMalloc_Free(IMalloc *pThis, void *pv);

SIZE_T   __stdcall CDebugMalloc_GetSize(IMalloc *pThis, void *pv);

int     __stdcall CDebugMalloc_DidAlloc(IMalloc *pThis, void *pv);

void    __stdcall CDebugMalloc_HeapMinimize(IMalloc *pThis);

//CDebugMalloc vtbl.
IMallocVtbl CDebugMallocVtbl =
{
    CMalloc_QueryInterface,
    CMalloc_AddRef,
    CMalloc_Release,
    CDebugMalloc_Alloc,
    CDebugMalloc_Realloc,
    CDebugMalloc_Free,
    CDebugMalloc_GetSize,
    CDebugMalloc_DidAlloc,
    CDebugMalloc_HeapMinimize
};

//Global variables
COleStaticMutexSem _mxsTaskMemory;
SIZE_T g_BytesAllocated = 0;
SIZE_T g_MemoryBlocksAllocated = 0;

typedef struct
{
    DWORD dwSig;    //  Memory block signature
    SIZE_T ulSize;       //  Allocated size
    SIZE_T cbCommit;     //  Count of committed bytes
    struct HeapAllocRec FAR *pArenaRecord; //  Arena record
} MEMINFO, *PMEMINFO;

#define OLEMEM_SIG         0x5f4d454d     // MEM_
#define OLEMEM_ALLOCBYTE       0xde
#define OLEMEM_FREEBYTE        0xed

#if defined(_X86_) && !defined(_CHICAGO_)
# define OLEMEM_ALIGN_SIZE   4
#else
#ifdef _WIN64
# define OLEMEM_ALIGN_SIZE   16
#else
# define OLEMEM_ALIGN_SIZE   8
#endif
#endif

#endif //DBG==1


//+-------------------------------------------------------------------------
//
//  Class:      CRetailMalloc
//
//  Purpose:    OLE retail memory allocator.  This memory allocator uses
//              the NT heap.
//
//  Interface:  IMalloc
//
//--------------------------------------------------------------------------

//Function prototypes.
void *  __stdcall CRetailMalloc_Alloc(IMalloc *pThis, SIZE_T cb);

void *  __stdcall CRetailMalloc_Realloc(IMalloc *pThis, void *pv, SIZE_T cb);

void    __stdcall CRetailMalloc_Free(IMalloc *pThis, void *pv);

SIZE_T   __stdcall CRetailMalloc_GetSize(IMalloc *pThis, void *pv);

int     __stdcall CRetailMalloc_DidAlloc(IMalloc *pThis, void *pv);

void    __stdcall CRetailMalloc_HeapMinimize(IMalloc *pThis);

// Makes serialized heap access obvious
const DWORD HEAP_SERIALIZE = 0;

//CRetailMalloc vtbl.
IMallocVtbl CRetailMallocVtbl =
{
    CMalloc_QueryInterface,
    CMalloc_AddRef,
    CMalloc_Release,
    CRetailMalloc_Alloc,
    CRetailMalloc_Realloc,
    CRetailMalloc_Free,
    CRetailMalloc_GetSize,
    CRetailMalloc_DidAlloc,
    CRetailMalloc_HeapMinimize
};

//+-------------------------------------------------------------------------
//
//  Class:      CSpyMalloc
//
//  Purpose:    OLE spy memory allocator.
//
//  Interface:  IMalloc
//
//--------------------------------------------------------------------------

//function prototypes.
void *  __stdcall CSpyMalloc_Alloc(IMalloc *pThis, SIZE_T cb);

void *  __stdcall CSpyMalloc_Realloc(IMalloc *pThis, void *pv, SIZE_T cb);

void    __stdcall CSpyMalloc_Free(IMalloc *pThis, void *pv);

SIZE_T __stdcall CSpyMalloc_GetSize(IMalloc *pThis, void *pv);

int     __stdcall CSpyMalloc_DidAlloc(IMalloc *pThis, void *pv);

void    __stdcall CSpyMalloc_HeapMinimize(IMalloc *pThis);

//CSpyMalloc vtbl.
IMallocVtbl CSpyMallocVtbl =
{
    CMalloc_QueryInterface,
    CMalloc_AddRef,
    CMalloc_Release,
    CSpyMalloc_Alloc,
    CSpyMalloc_Realloc,
    CSpyMalloc_Free,
    CSpyMalloc_GetSize,
    CSpyMalloc_DidAlloc,
    CSpyMalloc_HeapMinimize
};

// Globals for the IMallocSpy code
//
// IMallocSpy instance supplied by the user
LPMALLOCSPY      g_pMallocSpy = NULL;

// The thread id (via CoGetCurrentProcess) which registered the IMallocSpy
DWORD            g_dwMallocSpyRegistrationTID = 0;

// Semaphore used while spying
COleStaticMutexSem g_SpySem;

// Indicates whether a revoke was attempted with allocation count > 0
BOOL             g_fRevokePending = FALSE;

// Table of IMallocSpy allocations not yet freed
LPSPYTABLE       g_pAllocTbl = NULL;





//+-------------------------------------------------------------------------
//
//  Function:   MallocInitialize
//
//  Synopsis:   Initializes the memory allocator.
//
//--------------------------------------------------------------------------
HRESULT MallocInitialize(BOOL fForceRetailAlloc)
{
    HRESULT hr = S_OK;

    g_hHeap = GetProcessHeap();

    if(0 == g_hHeap)
    {
        return E_OUTOFMEMORY;
    }

#if DBG==1

    if(!fForceRetailAlloc)
    {
        //Use the OLE debug memory allocator.
        g_lpVtblMalloc = &CDebugMallocVtbl;
    }
    else

#endif // DBG==1

        //Use the OLE retail memory allocator.
        g_lpVtblMalloc = &CRetailMallocVtbl;

    g_CMalloc.lpVtbl = g_lpVtblMalloc;

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   MallocUninitialize
//
//  Synopsis:   Clean up and check for local memory leaks
//
//  Effects:    Prints out messages on debug terminal if there are leaks
//
//  Returns:    If no leaks, TRUE
//              Otherwise, FALSE
//
//--------------------------------------------------------------------------
BOOL MallocUninitialize(BOOL fDumpSymbols)
{
    BOOL bResult = TRUE;

    VDATEHEAP();

#if DBG==1
    if(&CDebugMallocVtbl == g_lpVtblMalloc)
    {
        //Check for memory leaks from the debug heap.
        if (g_MemoryBlocksAllocated > 0)
        {
            CairoleDebugOut((DEB_ERROR,
                             "Leaked %ld bytes (%ld allocations)\n",
                             g_BytesAllocated,
                             g_MemoryBlocksAllocated));

            bResult = FALSE;
        }
        AllocArenaDump( NULL, fDumpSymbols );
    }
#endif //DBG==1

    return bResult;
}



//+-------------------------------------------------------------------------
//
//  Function:   CoGetMalloc
//
//  Synopsis:   returns system provided IMalloc
//
//  Arguments:  [dwContext] - type of allocator to return
//              [ppMalloc] - where to return the allocator
//
//--------------------------------------------------------------------------
STDAPI CoGetMalloc(DWORD dwContext, IMalloc **ppMalloc)
{
    HRESULT hr;

    switch (dwContext)
    {
    case MEMCTX_TASK:
        //We use a static IMalloc object so
        //we don't need to AddRef it here.
        *ppMalloc = g_pMalloc;
        hr = S_OK;
        break;

    case MEMCTX_SHARED:
        CairoleDebugOut((DEB_WARN, "CoGetMalloc(MEMCTX_SHARED, ...) not "
                         "supported for 32-bit OLE\n"));

        //  fall through to E_INVALIDARG
    default:
        *ppMalloc = NULL;
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------
//
//  Function:   CoRegisterMallocSpy
//
//  Synopsis:   Registers the supplied implementation instance of
//              IMallocSpy
//
//  Arguments:  [pMallocSpy]
//
//  Returns:    CO_E_OBJISREG   -       A spy is already registered
//              E_INVALIDARG    -       The QueryInterface for
//                                      IID_IMallocSpy failed
//              S_OK            -       Spy registered ok
//
//----------------------------------------------------------------------
STDAPI CoRegisterMallocSpy(LPMALLOCSPY pMallocSpy)
{
    HRESULT     hr = S_OK;

    OLETRACEIN((API_CoRegisterMallocSpy, PARAMFMT("pMallocSpy = %p"), pMallocSpy));

    if(pMallocSpy != 0)
    {
        LPMALLOCSPY pMSpy;

        hr = pMallocSpy->QueryInterface(IID_IMallocSpy, (void **) &pMSpy);

        if(SUCCEEDED(hr))
        {
            g_SpySem.Request();

            if (0 == g_pMallocSpy)
            {
                BOOL fOk = FALSE;

                // Initialize
                g_fRevokePending = FALSE;
                if (g_pAllocTbl)
                {
                    delete g_pAllocTbl;
                }

                g_pAllocTbl = new CSpyTable(&fOk);

                if (g_pAllocTbl && fOk)
                {
                    // Register the new one
                    CairoleDebugOut((DEB_TRACE, "IMallocSpy registered: %x\n", pMSpy));
                    g_pMallocSpy = pMSpy;
                    g_dwMallocSpyRegistrationTID = CoGetCurrentProcess();

                    //Switch the IMalloc lpVtbl to CSpyMallocVtbl.
                    g_CMalloc.lpVtbl = &CSpyMallocVtbl;

                    hr = S_OK;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                // An IMallocSpy is already registered. Deny this registration.
                CairoleDebugOut((DEB_ERROR, "Registering IMallocSpy %x over %x\n",
                                 pMallocSpy, g_pMallocSpy));

                hr = CO_E_OBJISREG;
            }

            if(FAILED(hr))
            {
                pMSpy->Release();
            }

            g_SpySem.Release();
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    OLETRACEOUT((API_CoRegisterMallocSpy, hr));

    return hr;
}


//+---------------------------------------------------------------------
//
//  Function:   CoRevokeMallocSpy
//
//  Synopsis:   Revokes any registered IMallocSpy instance
//
//  Returns:    CO_E_OBJNOTREG  -       No spy is currently registered
//              E_ACCESSDENIED  -       A spy is registered but there are
//                                      outstanding allocations done while
//                                      the spy was active which have not
//                                      yet been freed
//              S_OK            -       Spy revoked successfully
//
//----------------------------------------------------------------------
STDAPI CoRevokeMallocSpy(void)
{
    HRESULT hr = S_OK;

    OLETRACEIN((API_CoRevokeMallocSpy, NOPARAM));

    // Make revoking thread safe
    g_SpySem.Request();

    // Check that an IMallocSpy instance is registered
    if (g_pMallocSpy != 0)
    {
        if (0 == g_pAllocTbl->m_cAllocations)
        {
            // Attempt to release it
            CairoleDebugOut((DEB_TRACE, "IMallocSpy revoked: %x\n", g_pMallocSpy));
            g_pMallocSpy->Release();
            g_pMallocSpy = NULL;
            g_fRevokePending = FALSE;
            delete g_pAllocTbl;
            g_pAllocTbl = NULL;
            g_dwMallocSpyRegistrationTID = 0;
            hr = S_OK;
        }
        else
        {
            // If there are still outstanding Alloc/Realloc's which have not yet
            // been Free'd, then deny the revoke
            g_fRevokePending = TRUE;
            hr = E_ACCESSDENIED;
        }
    }
    else
    {
        CairoleDebugOut((DEB_WARN, "Attempt to revoke NULL IMallocSpy\n"));
        hr = CO_E_OBJNOTREG;
    }

    g_SpySem.Release();

    OLETRACEOUT((API_CoRevokeMallocSpy, hr));

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   CoTaskMemAlloc
//
//  Synopsis:   Allocate public memory (using task IMalloc)
//
//  Arguments:  [ulcb] -- memory block size
//
//  Returns:    Pointer to allocated memory or NULL
//
//--------------------------------------------------------------------------
STDAPI_(LPVOID) CoTaskMemAlloc(SIZE_T stcb)
{
    return g_pMalloc->Alloc(stcb);
}

//+-------------------------------------------------------------------------
//
//  Function:   CoTaskMemFree
//
//  Synopsis:   Free public memory
//
//  Arguments:  [pv] -- pointer to memory block
//
//  Requires:   pv must have been allocated with the task allocator
//
//--------------------------------------------------------------------------
STDAPI_(void) CoTaskMemFree(void *pv)
{
        g_pMalloc->Free(pv);
}

//+-------------------------------------------------------------------------
//
//  Function:   CoTaskMemRealloc
//
//  Synopsis:   Re-Allocate public memory (using task IMalloc)
//
//  Arguments:  [pv]   -- pointer to the memory to be resized
//              [ulcb] -- memory block size
//
//  Returns:    Pointer to allocated memory or NULL
//
//--------------------------------------------------------------------------
STDAPI_(LPVOID) CoTaskMemRealloc(LPVOID pv, SIZE_T stcb)
{
    return g_pMalloc->Realloc(pv, stcb);
}

//+-------------------------------------------------------------------------
//
//  Function:   MIDL_user_allocate
//
//  Purpose:    allocates memory on behalf of midl-generated stubs
//
//--------------------------------------------------------------------------
extern "C" void * __RPC_API MIDL_user_allocate(size_t cb)
{
    return PrivMemAlloc8(cb);
}

//+-------------------------------------------------------------------------
//
//  Function:   MIDL_user_free
//
//  Purpose:    frees memory allocated by MIDL_user_allocate
//
//--------------------------------------------------------------------------
extern "C" void __RPC_API MIDL_user_free(void *pv)
{
    PrivMemFree8(pv);
}


//-------------------------------------------------------------------------
//
// On Chicago, heap allocations don't happen on 8 byte boundaries.  This
// causes a problem for RPC marshalling/unmarshalling.  If OLE code were
// consistent and used complementary routines for allocating and freeeing
// we would only have to change PrivMemAlloc8 and PrivMemFree8.  But since
// this is not the case, we have to change PrivMemAlloc and PrivMemFree.
//
// These Inline functions guarantee allocations are 8-byte aligned on all
// platforms.
//
//-------------------------------------------------------------------------

// compute number of extra bytes to allocate
inline SIZE_T PreAlign8(SIZE_T stcb)
{
    return stcb;
}

// modify the pointer so it is 8byte aligned
inline LPVOID PostAlign8(LPVOID pv)
{
    return pv;
}

// return the original allocated pointer
inline LPVOID Unalign8(LPVOID pv)
{
    return pv;
}

// return the number of padding bytes
inline SIZE_T Align8Pad(LPVOID pv)
{
    return 0;
}

// Called in place of PostAlign8 when doing a ReAlloc. ReAligns the data
// if necessary.
inline LPVOID Realign8(LPVOID pv, SIZE_T stOriginalPad, SIZE_T cbData)
{
    return pv;
}


//+-------------------------------------------------------------------------
//
//  Function:   CMalloc_QueryInterface
//
//  Synopsis:   QueryInterface on the memory allocator.
//
//  Arguments:  riid - Supplies the IID.
//
//  Returns:
//
//--------------------------------------------------------------------------
HRESULT __stdcall CMalloc_QueryInterface(IMalloc * pThis,
                                         REFIID riid,
                                         void **ppvObject)
{
    HRESULT hr;

    if (IsEqualIID(riid,IID_IUnknown) || IsEqualIID(riid,IID_IMalloc))
    {
        //We use a static IMalloc object so
        //we don't need to AddRef it here.
        *ppvObject = pThis;
        hr = S_OK;
    }
    else
    {
        *ppvObject = 0;
        hr = E_NOINTERFACE;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   CMalloc_AddRef
//
//  Synopsis:   AddRef the memory allocator.
//
//--------------------------------------------------------------------------
ULONG   __stdcall CMalloc_AddRef(IMalloc * pThis)
{
    //We use a static IMalloc object so
    //we don't need to AddRef it here.
    return 1;
}

//+-------------------------------------------------------------------------
//
//  Function:   CMalloc_Release
//
//  Synopsis:   Release the memory allocator.
//
//--------------------------------------------------------------------------
ULONG   __stdcall CMalloc_Release(IMalloc * pThis)
{
    //We use a static IMalloc object so
    //we don't need to Release it here.
    return 1;
}


#if DBG==1
//+-------------------------------------------------------------------------
//
//  Member:         GetMemInfo
//
//  Synopsis:   Retrieves memory info block pointer
//
//  Arguments:  [pv] - memory address
//
//  Requires:   pv != NULL
//
//  Returns:    If valid memory address, memory info block pointer
//              Otherwise, NULL
//
//  Algorithm:  The memory info block is always located before the address at
//              the beginning of the page.
//
//--------------------------------------------------------------------------
PMEMINFO GetMemInfo(void *pv)
{
    SYSTEM_INFO si;
    PMEMINFO pmi;

    CairoleAssert(pv != NULL && "GetMemInfo bad input");

    //  Retrieve page size
    GetSystemInfo(&si);

    pmi = (PMEMINFO) ((((ULONG_PTR) pv) - sizeof(MEMINFO)) & ~((ULONG_PTR)si.dwPageSize-1));

    //  Make sure we can access it
    if (!IsValidReadPtrIn(pmi, si.dwPageSize))
    {
        CairoleDebugOut((DEB_WARN,
                        "GetMemInfo - no read access\n"));
    }
    else if (pmi->dwSig != OLEMEM_SIG)
    {
        CairoleDebugOut((DEB_WARN,
                        "GetMemInfo - bad mem signature\n"));
    }
    else
    {
        return(pmi);
    }

    return(NULL);
}

//+-------------------------------------------------------------------------
//
//  Member:     CDebugMalloc_Alloc
//
//  Synopsis:   Local memory allocator
//
//  Arguments:  [cb] -- memory block size
//
//  Returns:    Memory block pointer
//
//  Modifies:   Heap
//
//  Algorithm:  reserve memory including guard pages
//              commit memory
//              initialize committed memory
//              initialize control block
//              return pointer such that tail is on guard page
//
//--------------------------------------------------------------------------
void * __stdcall CDebugMalloc_Alloc(IMalloc *pThis, SIZE_T cb)
{
    SYSTEM_INFO si;
    SIZE_T cbAlloc;
    SIZE_T cbCommit;
    SIZE_T cbReserve;
    void *pvReserve;
    void *pvCommit;
    PMEMINFO pmi;
    void *pvRet = 0;

#ifndef _WIN64
    // Parameter validation
    if (cb > 0x7FFFFFFF)
    return 0;
#endif

    //  Retrieve page size
    GetSystemInfo(&si);

    {
        static BOOL s_dump = FALSE;

        if (s_dump)
        {
            s_dump = FALSE;
            AllocArenaDump(NULL, TRUE);
        }
    }
    // For x86, align the memory on a 4 byte boundary.
    // For non-x86 platforms, align the memory on an 8 byte boundary.
    // For CHICAGO, align on an 8 byte boundary for all platforms.
    // For 64 bit platforms, align on a 16 byte boundary
    cbAlloc = (cb + OLEMEM_ALIGN_SIZE - 1)
              & ~(OLEMEM_ALIGN_SIZE - 1);

    // Calculate pages necessary for both requested size and our
    // control info
    cbCommit = (cbAlloc + sizeof(MEMINFO) + si.dwPageSize - 1)
               & ~(SIZE_T)(si.dwPageSize - 1);

    //  Reserve enough for allocation and guard pages
    cbReserve = cbCommit + si.dwPageSize;

    //  Reserve cbReserve pages
    pvReserve = VirtualAlloc(
                NULL,
                cbReserve,
                MEM_RESERVE,
                PAGE_NOACCESS);

    if (pvReserve != 0)
    {
        // Commit cbCommit pages
        pvCommit = VirtualAlloc(pvReserve,
                                cbCommit,
                                MEM_COMMIT,
                                PAGE_EXECUTE_READWRITE);

        if (pvCommit != 0)
        {
            // Initialize pages
            memset(pvCommit, OLEMEM_ALLOCBYTE, cbCommit);

            //  write sMemInfo data
            pmi = (PMEMINFO) pvCommit;

            pmi->dwSig = OLEMEM_SIG;
            pmi->ulSize = cb;
            pmi->cbCommit = cbCommit;

            // Increment local count
            {
                COleStaticLock lck(_mxsTaskMemory);
                static AllocArena *pAllocArena = (AllocArena *)-1;

                if (pAllocArena == (AllocArena *)-1)
                {
                    pAllocArena = AllocArenaCreate( MEMCTX_TASK, "CDebugMalloc");
                }

                pmi->pArenaRecord = AllocArenaRecordAlloc(pAllocArena, cb);

                g_BytesAllocated += pmi->ulSize;
                g_MemoryBlocksAllocated++;
            }

            // Calculate return pointer
            pvRet = ((BYTE *) pvCommit) + cbCommit - cbAlloc;

            //  Public memory guaranteed to be aligned
            CairoleAssert(((ULONG_PTR)pvRet & (OLEMEM_ALIGN_SIZE - 1)) == NULL &&
                          "public memory allocation not aligned");

        }
        else
        {
            CairoleDebugOut((DEB_WARN,
                             "CDebugMalloc_Alloc(%ld) couldn't commit - %lx\n",
                             cbCommit, GetLastError()));

            //  Release reserved pages.
            VirtualFree(pvReserve, 0, MEM_RELEASE);
        }
    }
    else
    {
        CairoleDebugOut((DEB_WARN,
                        "CDebugMalloc_Alloc(%ld) couldn't reserve - %lx\n",
                        cbReserve, GetLastError()));
    }
    return pvRet;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDebugMalloc_Realloc
//
//  Synopsis:   Reallocated local memory
//
//  Arguments:  [pv] -- original memory block
//              [cb] -- new size
//
//  Returns:    new memory block
//
//--------------------------------------------------------------------------
void * __stdcall CDebugMalloc_Realloc(IMalloc * pThis, void * pv, SIZE_T cb)
{
    void *pvNew = 0;

    if (pv != 0)
    {
        PMEMINFO pmi = GetMemInfo(pv);
        CairoleAssert(pmi != 0 && "CDebugMalloc_Realloc - bad pointer");

        if(pmi != 0)
        {
            if (cb != 0)
            {
                //  Allocate a new memory block.
                pvNew = CDebugMalloc_Alloc(pThis, cb);

                if(pvNew != 0)
                {
                    // Copy data from the old memory block.
                    memcpy(pvNew, pv, min(pmi->ulSize, cb));

                    // Free the old memory block.
                   CDebugMalloc_Free(pThis, pv);
                }
                else
                {
                    // We could not allocate a new memory block.
                    // Leave the old memory block unchanged.
                }
            }
            else
            {
                // Free the old memory block.
                CDebugMalloc_Free(pThis, pv);
            }
        }
    }
    else
    {
        // Treat this as an Alloc
        pvNew = CDebugMalloc_Alloc(pThis, cb);
    }

    return pvNew;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDebugMalloc_Free
//
//  Synopsis:   release local memory
//
//  Arguments:  [pv] -- memory address
//
//  Algorithm:
//        get control information
//        validate memory block
//        verify that bytes between header and pv are untouched
//        set to known bad value
//        decommit
//        unreserve
//
//--------------------------------------------------------------------------
void __stdcall CDebugMalloc_Free(IMalloc *pThis, void * pv)
{
    if(pv != 0)
    {
        PMEMINFO pmi = GetMemInfo(pv);
        CairoleAssert(pmi != NULL && "CDebugMalloc_Free - bad pointer");

        if(pmi != 0)
        {
            BOOL     bResult;
            MEMINFO  mi = *pmi;
            void    *pvCommit = pmi;;
            BYTE    *pbCheck = ((BYTE *) pvCommit) + sizeof(MEMINFO);

            // Verify that bytes between header and pvNew are untouched
            while (pbCheck < (BYTE *) pv && *pbCheck == OLEMEM_ALLOCBYTE)
            {
                pbCheck++;
            }

            CairoleAssert(pbCheck == (BYTE *) pv &&
                          "CDebugMalloc_Free - header region dirty");

            // Verify that bytes between allocation and end of page are untouched
            pbCheck = ((BYTE *) pv) + mi.ulSize;
            while (pbCheck < (BYTE *) pvCommit + mi.cbCommit &&
                   *pbCheck == OLEMEM_ALLOCBYTE)
            {
                pbCheck++;
            }

            CairoleAssert(pbCheck == ((BYTE *) pvCommit) + mi.cbCommit &&
                          "CDebugMalloc_Free - tail region dirty");

            // Set to known bad value
            memset(pvCommit, OLEMEM_FREEBYTE, mi.cbCommit);

            // Decommit
            bResult = VirtualFree(pvCommit, mi.cbCommit, MEM_DECOMMIT);
            CairoleAssert(bResult && "CDebugMalloc_Free - VirtualFree(DECOMMIT) failed");

            // Unreserve
            bResult = VirtualFree(pvCommit, 0, MEM_RELEASE);
            CairoleAssert(bResult && "CDebugMalloc_Free - VirtualFree(RELEASE) failed");

            // Decrement local count
            {
                COleStaticLock lck(_mxsTaskMemory);

                CairoleAssert(mi.ulSize <= g_BytesAllocated &&
                              "Public memory tracking broken");
                CairoleAssert(g_MemoryBlocksAllocated > 0 &&
                              "Public memory tracking broken");

                g_BytesAllocated -= mi.ulSize;
                g_MemoryBlocksAllocated--;
            }

            AllocArenaRecordFree(mi.pArenaRecord, mi.ulSize);
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Member:         CDebugMalloc_GetSize
//
//  Synopsis:   Return size of memory block
//
//  Arguments:  [pv] -- memory address
//
//  Returns:    If valid memory, the size of the block
//              Otherwise, 0
//
//--------------------------------------------------------------------------
SIZE_T __stdcall CDebugMalloc_GetSize(IMalloc *pThis, void * pv)
{
    SIZE_T ulSize = (SIZE_T) -1;

    if (pv != 0)
    {
        PMEMINFO pmi = GetMemInfo(pv);
        CairoleAssert(pmi != NULL && "CDebugMalloc_GetSize - bad pointer");

        if (pmi != 0)
        {
            // Fetch the size of the allocation
            ulSize = pmi->ulSize;
        }
    }
    return ulSize;
}

//+-------------------------------------------------------------------------
//
//  Member:         CDebugMalloc_DidAlloc
//
//  Synopsis:   Return whether this allocator allocated the block
//
//  Arguments:  [pv] -- memory address
//
//  Returns:    If allocated by this allocator, TRUE
//              Otherwise, FALSE
//
//--------------------------------------------------------------------------
int __stdcall CDebugMalloc_DidAlloc(IMalloc *pThis, void * pv)
{
    int   fDidAlloc = FALSE;

    if (pv != 0)
    {
        PMEMINFO pmi = GetMemInfo(pv);

        if (pmi != NULL)
        {
            fDidAlloc = TRUE;
        }
    }
    else
    {
        fDidAlloc = -1;
    }

    return fDidAlloc;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDebugMalloc_HeapMinimize
//
//  Synopsis:   Minimize heap
//
//--------------------------------------------------------------------------
void __stdcall CDebugMalloc_HeapMinimize(IMalloc *pThis)
{
    CairoleAssert(g_hHeap != 0 && "GetProcessHeap failed");

    // Compact the heap
    HeapCompact(g_hHeap, HEAP_SERIALIZE);
}
#endif //DBG==1



//+-------------------------------------------------------------------------
//
//  Function:   CRetailMalloc_Alloc
//
//  Synopsis:   Allocate a block of memory.
//
//  Arguments:  [cb] -- Specifies the size of the memory block to allocate.
//
//  Returns:    Pointer to allocated memory or NULL
//
//--------------------------------------------------------------------------
void * __stdcall CRetailMalloc_Alloc(IMalloc *pThis, SIZE_T cb)
{
    CairoleAssert(g_hHeap != 0 && "GetProcessHeap failed");

    return PostAlign8((LPVOID) HeapAlloc(g_hHeap, HEAP_SERIALIZE, PreAlign8(cb)));
}

//+-------------------------------------------------------------------------
//
//  Function:   CRetailMalloc_DidAlloc
//
//  Synopsis:   Determine if the memory block was allocated by this
//              memory allocator.
//
//  Arguments:  [pv] -- pointer to the memory block
//
//  Notes:      The OLE spec requires that -1 be returned for
//              NULL pointers.
//
//--------------------------------------------------------------------------
int __stdcall CRetailMalloc_DidAlloc(IMalloc *pThis, void * pv)
{
    int fDidAlloc = -1;

    CairoleAssert(g_hHeap != 0 && "GetProcessHeap failed");

    if (pv != 0)
    {
        fDidAlloc = HeapValidate(g_hHeap, HEAP_SERIALIZE, Unalign8(pv));
    }

    return fDidAlloc;
}

//+-------------------------------------------------------------------------
//
//  Function:   CRetailMalloc_Free
//
//  Synopsis:   Free a memory block previously allocated via CRetailMalloc_Alloc.
//
//  Arguments:  [pv] -- pointer to the memory block to be freed.
//
//--------------------------------------------------------------------------
void __stdcall CRetailMalloc_Free(IMalloc *pThis, void * pv)
{
    CairoleAssert(g_hHeap != 0 && "GetProcessHeap failed");

    if (pv != 0)
    {
        HeapFree(g_hHeap, HEAP_SERIALIZE, Unalign8(pv));
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   CRetailMalloc_GetSize
//
//  Synopsis:   Gets the size of a memory block.
//
//  Arguments:  [pv] -- pointer to the memory block
//
//  Notes:      The OLE spec requires that -1 be returned for
//              NULL pointers.
//
//--------------------------------------------------------------------------
SIZE_T __stdcall CRetailMalloc_GetSize(IMalloc * pThis, void * pv)
{
    CairoleAssert(g_hHeap != 0 && "GetProcessHeap failed");

    if (0 == pv)
    {
        return((SIZE_T) -1);
    }
    return ((SIZE_T)(HeapSize(g_hHeap, HEAP_SERIALIZE, Unalign8(pv)) - Align8Pad(pv)));
}

//+-------------------------------------------------------------------------
//
//  Function:   CRetailMalloc_Minimize
//
//  Synopsis:   Compact the heap.
//
//--------------------------------------------------------------------------
void __stdcall CRetailMalloc_HeapMinimize(IMalloc * pThis)
{
    CairoleAssert(g_hHeap != 0 && "GetProcessHeap failed");

    // Compact the heap
    HeapCompact(g_hHeap, HEAP_SERIALIZE);
}

//+-------------------------------------------------------------------------
//
//  Function:   CRetailMalloc_Realloc
//
//  Synopsis:   Changes the size of a memory block previously allocated
//              via CRetailMalloc_Alloc.
//
//  Arguments:  [pv] -- Points to the memory block to be reallocated.
//              [cb] -- Specifies the new size of the memory block.
//
//  Returns:    Pointer to allocated memory or NULL.
//
//--------------------------------------------------------------------------
void * __stdcall CRetailMalloc_Realloc(IMalloc *pThis, void * pv, SIZE_T cb)
{
    LPVOID pvNew = 0;

    CairoleAssert(g_hHeap != 0 && "GetProcessHeap failed");

    if (pv != 0)
    {
        if (cb != 0)
        {
            int cbPad = (int) Align8Pad(pv);
            pvNew = (LPVOID) HeapReAlloc(g_hHeap, HEAP_SERIALIZE,
                                         Unalign8(pv), PreAlign8(cb));
            pvNew = Realign8(pvNew, cbPad, cb);
        }
        else
        {
            //Treat this as a free.
            HeapFree(g_hHeap, HEAP_SERIALIZE, pv);
            pvNew = 0;
        }
    }
    else
    {
        //Treat this as an alloc.
        pvNew = PostAlign8((LPVOID) HeapAlloc(g_hHeap, HEAP_SERIALIZE, PreAlign8(cb)));
    }

    return pvNew;
}

//+-------------------------------------------------------------------------
//
//  Member:         CSpyMalloc::Alloc
//
//  Synopsis:   Local memory allocator
//
//  Arguments:  [cb] -- memory block size
//
//  Returns:    Pointer to new memory block.
//
//--------------------------------------------------------------------------
void * __stdcall CSpyMalloc_Alloc(IMalloc *pThis, SIZE_T cb)
{
    void *pvRet = NULL;

    g_SpySem.Request();

    // If an IMallocSpy is active, call the pre method
    if (g_pMallocSpy)
    {
        SIZE_T cbAlloc = g_pMallocSpy->PreAlloc(cb);

        // The pre method forces failure by returning 0
        if ((cbAlloc != 0) || (0 == cb))
        {
            // Allocate the memory
            pvRet = g_lpVtblMalloc->Alloc(pThis, cbAlloc);

            // Call the post method
            pvRet = g_pMallocSpy->PostAlloc(pvRet);

            // Update the spy table.
            if (pvRet != NULL)
            {
                g_pAllocTbl->Add(pvRet);
            }
        }
    }
    else
    {
        // Allocate the memory
        pvRet = g_lpVtblMalloc->Alloc(pThis, cb);
    }

    g_SpySem.Release();

    return pvRet;
}

//+-------------------------------------------------------------------------
//
//  Member:         CSpyMalloc_Realloc
//
//  Synopsis:   Reallocated local memory
//
//  Arguments:  [pv] -- original memory block
//              [cb] -- new size
//
//  Returns:    Pointer to new memory block
//
//--------------------------------------------------------------------------
void *CSpyMalloc_Realloc(IMalloc *pThis, void * pv, SIZE_T cb)
{
    void *pvNew = 0;

    if(pv != 0)
    {
        if(cb != 0)
        {
            g_SpySem.Request();

            // If an IMallocSpy is active, call the pre method
            if (g_pMallocSpy != 0)
            {
                void *pvTemp = 0;
                ULONG j = 0;
                BOOL  fSpyed = g_pAllocTbl->Find(pv, &j);
                SIZE_T cbAlloc = g_pMallocSpy->PreRealloc(pv, cb, &pvTemp, fSpyed);

                // The pre method forces failure by returning 0
                if (cbAlloc != 0)
                {
                    //Reallocate the memory
                    pvTemp = g_lpVtblMalloc->Realloc(pThis, pvTemp, cbAlloc);

                    // Call the post method
                    pvNew = g_pMallocSpy->PostRealloc(pvTemp, fSpyed);

                    // Update the spy table.
                    if (pvNew != 0)
                    {
                        if (fSpyed)
                        {
                            g_pAllocTbl->Remove(pv);
                        }

                        g_pAllocTbl->Add(pvNew);
                    }
                }
            }
            else
            {
                //Reallocate the memory.
                pvNew = g_lpVtblMalloc->Realloc(pThis, pv, cb);
            }

            g_SpySem.Release();
        }
        else
        {
            //Treat this as a Free.
            pThis->Free(pv);
        }
    }
    else
    {
        //Treat this as an Alloc.
        pvNew = pThis->Alloc(cb);
    }

    return pvNew;
}

//+-------------------------------------------------------------------------
//
//  Member:     CSpyMalloc_Free
//
//  Synopsis:   release local memory
//
//  Arguments:  [pv] -- memory address
//
//--------------------------------------------------------------------------
void __stdcall CSpyMalloc_Free(IMalloc *pThis, void * pv)
{
    if(pv != 0)
    {
        g_SpySem.Request();

        // If an IMallocSpy is active, call the pre method
        if (g_pMallocSpy)
        {
            ULONG j;
            BOOL  fSpyed = g_pAllocTbl->Find(pv, &j);
            void *pvNew = g_pMallocSpy->PreFree(pv, fSpyed);

            // Free the buffer
            g_lpVtblMalloc->Free(pThis, pvNew);

            // If an IMallocSpy is active, call the post method
            g_pMallocSpy->PostFree(fSpyed);

            // Update the spy table.
            if (fSpyed)
            {
                g_pAllocTbl->Remove(pv);
            }

            if (g_pAllocTbl->m_cAllocations == 0  &&  g_fRevokePending)
            {
                CoRevokeMallocSpy();
            }
        }
        else
        {
            // Free the buffer
            g_lpVtblMalloc->Free(pThis, pv);
        }

        g_SpySem.Release();
    }
}


//+-------------------------------------------------------------------------
//
//  Member:         CSpyMalloc_GetSize
//
//  Synopsis:   Return size of memory block
//
//  Arguments:  [pv] -- memory address
//
//  Returns:    If valid memory, the size of the block
//              Otherwise, 0
//
//  Notes:      The OLE spec requires that -1 be returned for
//              NULL pointers.
//
//--------------------------------------------------------------------------
SIZE_T __stdcall CSpyMalloc_GetSize(IMalloc *pThis, void * pv)
{
    SIZE_T ulSize = (ULONG) -1;

    if (pv != 0)
    {
        g_SpySem.Request();

        // If an IMallocSpy is active, call the pre method
        if (g_pMallocSpy)
        {
            ULONG j;
            BOOL  fSpyed = g_pAllocTbl->Find(pv, &j);
            void *pvNew = g_pMallocSpy->PreGetSize(pv, fSpyed);

            // Fetch the size of the allocation
            ulSize = g_lpVtblMalloc->GetSize(pThis, pvNew);

            // Call the post method
            ulSize = g_pMallocSpy->PostGetSize(ulSize, fSpyed);
        }
        else
        {
            // Fetch the size of the allocation
            ulSize = g_lpVtblMalloc->GetSize(pThis, pv);
        }

        g_SpySem.Release();
    }

    return ulSize;
}


//+-------------------------------------------------------------------------
//
//  Member:         CSpyMalloc_DidAlloc
//
//  Synopsis:   Return whether this allocator allocated the block
//
//  Arguments:  [pv] -- memory address
//
//  Returns:    If allocated by this allocator, TRUE
//              Otherwise, FALSE
//
//  Notes:      The OLE spec requires that -1 be returned for
//              NULL pointers.
//
//--------------------------------------------------------------------------
int __stdcall CSpyMalloc_DidAlloc(IMalloc *pThis, void * pv)
{
    int   fDidAlloc = (ULONG) -1;

    if (pv != 0)
    {
        g_SpySem.Request();

        // If an IMallocSpy is active, call the pre method
        if (g_pMallocSpy)
        {
            ULONG j;
            BOOL  fSpyed = g_pAllocTbl->Find(pv, &j);
            void *pvNew = g_pMallocSpy->PreDidAlloc(pv, fSpyed);

            // Check the allocation
            fDidAlloc = g_lpVtblMalloc->DidAlloc(pThis, pvNew);

            // Call the post method
            fDidAlloc = g_pMallocSpy->PostDidAlloc(pv, fSpyed, fDidAlloc);
        }
        else
        {
            // Check the allocation
            fDidAlloc = g_lpVtblMalloc->DidAlloc(pThis, pv);
        }

        g_SpySem.Release();
    }

    return fDidAlloc;
}



//+-------------------------------------------------------------------------
//
//  Member:         CSpyMalloc_HeapMinimize
//
//  Synopsis:   Minimize heap
//
//--------------------------------------------------------------------------
void __stdcall CSpyMalloc_HeapMinimize(IMalloc *pThis)
{
    g_SpySem.Request();

    // If an IMallocSpy is active, call the pre method
    if (g_pMallocSpy)
    {
        g_pMallocSpy->PreHeapMinimize();

        // Compact the heap
        g_lpVtblMalloc->HeapMinimize(pThis);

        // Call the post method
        g_pMallocSpy->PostHeapMinimize();
    }
    else
    {
        // Compact the heap
        g_lpVtblMalloc->HeapMinimize(pThis);
    }

    g_SpySem.Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\class\ole1guid.cxx ===
/*

copyright (c) 1992  Microsoft Corporation

Module Name:

    Ole1Guid.cpp

Abstract:

    This module converts 1.0 class names to GUIDs (CLSIDs).
	See the ole2issues database (bug 318) for a description of this
	whole mechanism.

Author:

	Jason Fuller	(jasonful)	19-October-1992
*/

// ErikGav 31-Dec-93  Chicago port

#include <ole2int.h>

// CLSID_* declarations
#include <ole1cls.h>

#define STR_MAX 80
ASSERTDATA

typedef unsigned short HASH;

typedef struct ENTRY
{
	LPCWSTR  sz;		// class name
	const CLSID FAR* pclsid;	// corresponding CLSID
} ENTRY;


// This is the map.
// The +6 removes "CLSID_"
// It does unnatural things with the pre-processor, but it ensures that
// the map and ole1cls.h will always be in sync.

// REVIEW OPTIMIZATION
// If it is a problem that the strings in this map are in the data segment,
// we can use yet more pre-processor tricks to define a code-segment LPCSTR
// variable for each string, then put these variables in the map.

static ENTRY rgentMap[] =
{
	#define DEFINE_OLE1GUID(clsid,x,xx,xxx,sz) sz, &clsid, /##/
	#include "ole1cls.h"
	#undef DEFINE_OLE1GUID

	NULL, NULL

};



#pragma SEG(VerifyIs10Class)
// verify name is ole1class; errors: CO_E_CLASSSTRING
static INTERNAL VerifyIs10Class(LPCWSTR szOle1)
{
	HKEY hkey = NULL;	
	HKEY hkey2 = NULL;	
	HRESULT hresult = NOERROR;

    if (ERROR_SUCCESS != RegOpenKey (HKEY_CLASSES_ROOT, (LPWSTR) szOle1, &hkey) ||
		ERROR_SUCCESS != RegOpenKey (hkey, L"protocol\\StdFileEditing", &hkey2))
	{
		// This string is not an OLE 1 server, so we do not know
		// what it is.
		hresult = ReportResult (0, CO_E_CLASSSTRING, 0, 0);
	}
	if (hkey)
		RegCloseKey (hkey);
	if (hkey2)
		RegCloseKey (hkey2);
	return hresult;
}



#pragma SEG(Hash)
// hash ole1 class name; errors: none
static INTERNAL_(HASH) Hash(LPCWSTR sz)
{
	HASH hash = 0;
	Assert (sizeof (HASH) == 2);  // This is vital

	while (*sz)
		hash = 257 * hash + *sz++;

	return hash;
}



#define RegCall(f)                                              \
    if ((f) != ERROR_SUCCESS)                                   \
    {                                                           \
        CairoleDebugOut((DEB_WARN,                              \
                         "WriteToRegDb: 2.0 registration failed\n")); \
        if (hkey) RegCloseKey (hkey);                           \
        return ResultFromScode (REGDB_E_WRITEREGDB);            \
    }

#pragma SEG(WriteToRegDb)
// errors: REGDB_E_WRITEREGDB
static INTERNAL WriteToRegDb
    (LPCWSTR szOle1,	  // OLE1 class name e.g. "ExcelWorksheet"
	LPCWSTR szClsid)	  // "{...0046}"
{
	WCHAR szKey [256];
	WCHAR szUserName [256];
	LONG cbUserName = 256;
	HKEY hkey=NULL;

	Assert (szClsid[0] == '{');
	Assert (szOle1 [0] != '{');

	// szOle1 = User type Name
	// 		clsid = {...0046}        <- write this
	RegCall (RegOpenKey (HKEY_CLASSES_ROOT, (LPWSTR) szOle1, &hkey))
	RegCall (RegQueryValue (hkey, NULL, szUserName, &cbUserName))
	RegCall (RegSetValue (hkey, L"Clsid", REG_SZ, (LPWSTR) szClsid, lstrlenW(szClsid)))

	if (0==lstrcmpW(szClsid, L"{00030003-0000-0000-C000-000000000046}"))
	{
		// Word
		RegSetValue (hkey, L"PackageOnFileDrop", REG_SZ, (LPWSTR)NULL, 0);
	}

	RegCall (RegCloseKey (hkey))
	hkey=NULL;

	// write this:
	// CLSID
	//		{...00046} = User Type Name
	//				Ole1Class = szOle1
	//				ProgID    = szOle1
	wsprintf (szKey, L"CLSID\\%ws", szClsid);
	RegCall (RegSetValue (HKEY_CLASSES_ROOT, (LPWSTR) szKey, REG_SZ, szUserName,
						(cbUserName/sizeof(WCHAR))-1))
	RegCall (RegOpenKey (HKEY_CLASSES_ROOT, (LPWSTR) szKey, &hkey))
	RegCall (RegSetValue (hkey, L"Ole1Class", REG_SZ, (LPWSTR) szOle1, lstrlenW(szOle1)))
	RegCall (RegSetValue (hkey, L"ProgID", REG_SZ, (LPWSTR) szOle1, lstrlenW(szOle1)))
	RegCall (RegCloseKey (hkey))
	return NOERROR;
}

#undef RegCall

#pragma SEG(Ole10_CLSIDFromString)

// Ole10_CLSIDFromString
//
// This function must only be called when the CLSID is NOT in the reg db
// (under key "Clsid")
//
// errors: CO_E_CLASSSTRING (not ole1 class); REGDB_E_WRITEREGDB (errors with reg.dat)
//
INTERNAL 	Ole10_CLSIDFromString
	(LPCWSTR szOle1,
	CLSID FAR* pclsid,
	BOOL	fForceAssign) // always assign a CLSID, even if not in reg db
{
	WCHAR szClsid[STR_MAX];
	ENTRY FAR* pent;

	*pclsid = CLSID_NULL;

	#ifdef _DEBUG
	{
		// This function should not be called if the CLSID is in the reg db
		HKEY hkey, hkey2;
		if (ERROR_SUCCESS==RegOpenKey (HKEY_CLASSES_ROOT, szOle1, &hkey))
		{
			Assert (ERROR_SUCCESS != RegOpenKey (hkey, L"Clsid", &hkey2));
			RegCloseKey (hkey);
		}
	}
	#endif

	// Look for class name in Map
	for (pent = (ENTRY FAR*) rgentMap; pent->sz != NULL; pent++)
	{
		// Because atoms and reg db keys are case-insensitive, OLE 1.0
		// was case insensitive.  So let's be case-insensitive also.
		if (0==lstrcmpiW(szOle1, pent->sz))
		{
			*pclsid = *pent->pclsid;
			Verify(StringFromCLSID2 (*pent->pclsid, szClsid, STR_MAX) != 0);
			break;
		}
	}
			
	if (IsEqualGUID(*pclsid, CLSID_NULL))
	{
		HRESULT hresult;

		if (!fForceAssign &&
			(NOERROR != (hresult = VerifyIs10Class (szOle1))))
		{
			// This happens when trying to get a CLSID for a packaged
			// object, e.g., trying to get a CLSID for "txtfile"
			// because someone called GetClassFile("foo.txt").
			// So do not assert
			return hresult;
		}

		
		// Class name is not in our table, so make up a GUID by hashing
		HASH hash = Hash (szOle1);
		wsprintf (szClsid, L"{0004%02X%02X-0000-0000-C000-000000000046}",
				  LOBYTE(hash), HIBYTE(hash));
		Verify(CLSIDFromString (szClsid, pclsid) == NOERROR);
	}

        Assert((!IsEqualGUID(*pclsid, CLSID_NULL)) &&
               "About to write NULL GUID into registry");

	HRESULT hresult = WriteToRegDb (szOle1, szClsid);
	// If forcing the assignment of a CLSID even if the string
	// is not in the reg db, then WriteToRegDb is allowed to fail.
	return fForceAssign ? NOERROR : hresult;
}

#pragma SEG(Ole10_StringFromCLSID)

// Ole10_StringFromCLSID
//
// Only call this function if the "Ole1Class" key is NOT yet in the reg db
//
// errors: E_UNEXPECTED (clsid not a known ole1 class)
//
INTERNAL Ole10_StringFromCLSID(
	REFCLSID clsid,
	LPWSTR szOut,
	int cbMax)
{
	ENTRY FAR* pent;
	LPWSTR szClsid = NULL;

	// Look it up in Map
	for (pent = (ENTRY FAR*) rgentMap; pent->sz != NULL; pent++)
	{
		if (IsEqualGUID(clsid, *pent->pclsid))
		{
			if (lstrlenW (pent->sz) +1 > cbMax)
			{
				// unlikely
				return E_OUTOFMEMORY;
			}
			lstrcpyW (szOut, pent->sz);
			
			if (NOERROR==StringFromCLSID (clsid, &szClsid))
			{
				// If the info had already been in the reg db, then
				// this function wouldn't have been called.  So write
				// the info now.  This happens when we a 1.0 object (and CLSID)
				// in a 2.0 file comes from a machine where the server is
				// registered to one where it is not.
				WriteToRegDb (pent->sz, szClsid);
				PubMemFree(szClsid);
			}
			return NOERROR;
		}
	}

	// We could not find the CLSID.
	// We could iterate through the reg db and assign CLSIDs to all 1.0
	// servers that do not yet have a CLSID, until we find one that matches.
	// We decided it is not worth doing this because if the server
	// was in the reg db, it probably would have been assigned a CLSID
	// already.
	// If not found, it is a hashed CLSID for a server that
	// is not in our map and has not been assigned a CLSID (perhaps
	// because it does not exist on this machine).
	return E_UNEXPECTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\class\cairo\makefile.inc ===
obj\i386\compob32.def: compob32.src
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\class\perfmnce.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       perfmnce.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    3-06-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------

#include <ole2int.h>
#include <olerem.h>

#include "ole1guid.h"
#include <perfmnce.hxx>

#ifdef _PERF_BUILD_

PerfRg perfrg =
{
    32,
    {
    { 0x0000, "LoadLibraryOle      ", 0, 0, 0, 0  },
    { 0x1000, "OleInitialize       ", 0, 0, 0, 0  },
    { 0x1000, "CoInitialize        ", 0, 0, 0, 0  },
    { 0x2300, "ChannelProcessInit  ", 0, 0, 0, 0  },
    { 0x2400, "ChannelThreadInit   ", 0, 0, 0, 0  },
    { 0x0000, "CreateFileMap       ", 0, 0, 0, 0  },
    { 0x0000, "CreateFileMapConvert", 0, 0, 0, 0  },
    { 0x2500, "CheckAndStartScm    ", 0, 0, 0, 0  },
    { 0x0000, "EndScm              ", 0, 0, 0, 0  },
    { 0x0000, "ISLClassCacheList   ", 0, 0, 0, 0  },
    { 0x0000, "ISLCreateAllocator  ", 0, 0, 0, 0  },
    { 0x0000, "ISLInProcList       ", 0, 0, 0, 0  },
    { 0x0000, "ISLLocSrvList       ", 0, 0, 0, 0  },
    { 0x0000, "ISLScmRot           ", 0, 0, 0, 0  },
    { 0x2100, "InitClassCache      ", 0, 0, 0, 0  },
    { 0x0000, "InitRot             ", 0, 0, 0, 0  },
    { 0x0000, "InitSharedLists     ", 0, 0, 0, 0  },
    { 0x0000, "MDFDllMain          ", 0, 0, 0, 0  },
    { 0x0000, "ServiceListen       ", 0, 0, 0, 0  },
    { 0x2200, "ShrdTbl             ", 0, 0, 0, 0  },
    { 0x2000, "StartScm            ", 0, 0, 0, 0  },
    { 0x2510, "StartScmX1          ", 0, 0, 0, 0  },
    { 0x2520, "StartScmX2          ", 0, 0, 0, 0  },
    { 0x2530, "StartScmX3          ", 0, 0, 0, 0  },
    { 0x2000, "ThreadInit          ", 0, 0, 0, 0  },
    { 0x0000, "CoUnitialzie        ", 0, 0, 0, 0  },
    { 0x0000, "DllMain             ", 0, 0, 0, 0  },
    { 0x2410, "RpcService          ", 0, 0, 0, 0  },
    { 0x2420, "RpcListen           ", 0, 0, 0, 0  },
    { 0x2430, "RpcReqProtseq       ", 0, 0, 0, 0  },
    { 0x2440, "ChannelControl      ", 0, 0, 0, 0  },
    { 0x0000, "27                  ", 0, 0, 0, 0  }
    }
};


class CPerformance : public IPerformance
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef) (THIS);
    STDMETHOD_(ULONG,Release) (THIS);
    // *** IPerformance methods ***
    STDMETHOD (Init) (THIS_ );
    STDMETHOD (Print) (THIS_ DWORD PrntDest);
    STDMETHOD (Reset) (THIS_ );

    CPerformance(PPerfRg pPFRg)
    {
	_pPerfRg = pPFRg;
    }

private:
    ULONG	 _refs;
    PPerfRg 	_pPerfRg;

};


STDMETHODIMP CPerformance::QueryInterface (REFIID riid, LPVOID FAR* ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IPerformance *) this;
        AddRef();
        return S_OK;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CPerformance::AddRef
//
//  Synopsis:   increments reference count
//
//  History:    27-Dec-93 Johann Posch (johannp)  Created
//
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPerformance::AddRef ()
{
    InterlockedIncrement( (long *) &_refs );
    return _refs;
}

//+-------------------------------------------------------------------------
//
//  Method:     CPerformance::Release
//
//  Synopsis:   decrements reference count
//
//  History:    27-Dec-93 Johann Posch (johannp)  Created
//
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPerformance::Release ()
{
    if (InterlockedDecrement( (long*) &_refs ) == 0)
    {
        delete this;
        return 0;
    }
    return _refs;
}


//+-------------------------------------------------------------------------
//
//  Method:     CPerformance::
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:    27-Dec-93 Johann Posch (johannp)  Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CPerformance::Print (DWORD PrntDest)
{
    DWORD i;
    WORD j,k,l,m;
    char szOutStr[256];
    char szTabStr[33];
    WORD wPos;

    LARGE_INTEGER liFrequency;
    QueryPerformanceFrequency(&liFrequency);

    for (i= 0x0000; i <= 0xf000 ; i+=0x1000)
    {
	for (j= 0x0000; j <= 0x0fff ; j+=0x0100)
	{
	    for (k= 0x0000; k <= 0x00ff ; k+=0x0010)
	    {
		for (l= 0x0000; l <= 0x000f ; l+=0x0001)
		{
		    wPos = ((WORD)i)|j|k|l;

		    szTabStr[5]= '\0';
		    szTabStr[4]= '\0.';
		    szTabStr[3]= '\0';
		    szTabStr[2]= '\0';
		    szTabStr[1]= '\0';
		    szTabStr[0]= '\0';

		    if (l)
		    {
			szTabStr[3]= '.';
			szTabStr[2]= '.';
			szTabStr[1]= '.';
			szTabStr[0]= '.';
		    }
		    else if (k)
		    {
			szTabStr[2]= '.';
			szTabStr[1]= '.';
			szTabStr[0]= '.';
		    }
		    else if (j)
		    {
			szTabStr[1]= '.';
			szTabStr[0]= '.';
		    }
		    else if (i)
			szTabStr[0]= '.';

		    for (m=0; m < 32 ; m++)
		    {
			if (   _pPerfRg->rgPerfData[m].wPos
			    && _pPerfRg->rgPerfData[m].wPos == wPos)
			{
                            LARGE_INTEGER liTime;
			    LARGE_INTEGER liTemp;

			    liTime.QuadPart = _pPerfRg->rgPerfData[m].liEnd.QuadPart - _pPerfRg->rgPerfData[m].liStart.QuadPart;
			    liTemp.QuadPart = liTime.QuadPart * 1000000;
			    liTemp.QuadPart /= liFrequency.QuadPart;
                            //if (liTemp.LowPart)
			    {
				switch (PrntDest)
				{
				case Consol:
				    printf("%s %10luus -> %s\n",szTabStr,
						liTemp.LowPart, _pPerfRg->rgPerfData[m].szName);
				    break;
				case DebugTerminal:
				default:
				    wsprintfA(szOutStr,"%s %luus -> %s\n", szTabStr, liTemp.LowPart, _pPerfRg->rgPerfData[m].szName);
				    OutputDebugString(szOutStr);
				    break;
				}
			    }

                         }
		    }

		}
	    }
	}
    }
    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Method:     CPerformance::
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:    27-Dec-93 Johann Posch (johannp)  Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CPerformance::Init (void)
{
    return NOERROR;
}
//+-------------------------------------------------------------------------
//
//  Method:     CPerformance::
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:    27-Dec-93 Johann Posch (johannp)  Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CPerformance::Reset (void)
{
    return NOERROR;
}

STDAPI CoGetPerformance(PPerformance *ppPerformance)
{
    if (ppPerformance )
    {
	*ppPerformance = (PPerformance) new CPerformance((PPerfRg) &perfrg);
    }
    return NOERROR;
}
#endif // !_PERF_BUILD_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\class\tls.cxx ===
//+---------------------------------------------------------------
//
//  File:       tls.cxx
//
//  Contents:   Thread Local Storage initialization and cleanup.
//
//  History:    18-Apr-94   CraigWi     Split off of channelb.cxx
//              06-Jul-94   BruceMa     Support for CoGetCurrentProcess
//              30-Jan-95   BruceMa     DLL_PROCESS_DETACH can interrupt
//                                       DLL_THREAD_DETACH so delete pData
//                                       carefully
//
//----------------------------------------------------------------
#include <ole2int.h>
#include <..\dcomrem\locks.hxx>

// Thread Local Storage index.
#ifdef _CHICAGO_
DWORD             gTlsIndex;
#endif

// Heap Handle
extern  HANDLE    g_hHeap;
#define HEAP_SERIALIZE 0

#if !defined(_CHICAGO_)   // multiple shared heap support for docfiles
#define MULTIHEAP
#endif


//+-------------------------------------------------------------------------
//
// per-thread tls entry
//
//+-------------------------------------------------------------------------
typedef struct tagTLSMapEntry
{
    DWORD        dwThreadId;    // tid of thread that owns this entry
    SOleTlsData *ptls;          // ptr to TLS structure for this thread
} TLSMapEntry;

COleStaticMutexSem  gTlsLock;   // CS to protect the global map
TLSMapEntry        *gpTlsMap            = NULL;
ULONG               gcTlsTotalEntries   = 0;
ULONG               gcTlsUsedEntries    = 0;
LONG                giTlsNextFreeEntry  = -1;

//+-------------------------------------------------------------------------
//
//  Function:   TLSLookupThreadId
//
//  Synopsis:   Finds the Tls structure associated with a given threadid
//
//  Returns:    ptr to structure if found in the map, NULL otherwise
//
//  History:    12-May-98   Rickhi
//
//--------------------------------------------------------------------------
SOleTlsData *TLSLookupThreadId(DWORD dwThreadId)
{
    Win4Assert(gpTlsMap != NULL);
    ASSERT_LOCK_NOT_HELD(gTlsLock);
    LOCK(gTlsLock);

    // walk the map looking for a match on the threadid
    TLSMapEntry *pMapEntry  = gpTlsMap;
    TLSMapEntry *pTlsMapEnd = &gpTlsMap[gcTlsTotalEntries];
    while (pMapEntry < pTlsMapEnd)
    {
        if (pMapEntry->dwThreadId == dwThreadId &&
            pMapEntry->ptls != NULL)
        {
            UNLOCK(gTlsLock);
            return pMapEntry->ptls;
        }

        pMapEntry++;
    }

    UNLOCK(gTlsLock);
    return NULL;
}

//+-------------------------------------------------------------------------
//
//  Function:   TLSGrowMap
//
//  Synopsis:   Grows the global tls map.
//
//  History:    12-May-98   Rickhi
//
//--------------------------------------------------------------------------
BOOL TLSGrowMap()
{
    ASSERT_LOCK_HELD(gTlsLock);

    // need to grow the map
    ULONG cNew = (gcTlsTotalEntries) ? gcTlsTotalEntries*2 : 40;
    TLSMapEntry *pNewMap = (TLSMapEntry *)HeapAlloc(g_hHeap, HEAP_SERIALIZE,
                                                    cNew * sizeof(TLSMapEntry));
    if (pNewMap == NULL)
    {
        // could not grow the map
        return FALSE;
    }

    // copy the old map into the new one, free the old one
    memcpy(pNewMap, gpTlsMap, gcTlsTotalEntries * sizeof(TLSMapEntry));
    if (gpTlsMap)
        HeapFree(g_hHeap, HEAP_SERIALIZE, gpTlsMap);
    gpTlsMap           = pNewMap;
    giTlsNextFreeEntry = gcTlsTotalEntries;

    // initialize the remaining entries
    for (LONG i=giTlsNextFreeEntry; i<(LONG)cNew; i++)
    {
        gpTlsMap[i].dwThreadId = i+1;
        gpTlsMap[i].ptls       = NULL;
    }

    // mark the last entry
    gpTlsMap[cNew-1].dwThreadId = -1;
    gcTlsTotalEntries             = cNew;
    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:   TLSAddToMap
//
//  Synopsis:   Adds the Tls structure associated with a given threadid to
//              the global map.
//
//  History:    12-May-98   Rickhi
//
//--------------------------------------------------------------------------
BOOL TLSAddToMap(SOleTlsData *ptls)
{
    ASSERT_LOCK_NOT_HELD(gTlsLock);
    LOCK(gTlsLock);

    if (giTlsNextFreeEntry == -1)
    {
        // need to grow the map
        if (!TLSGrowMap())
        {
            ptls->TlsMapIndex = -1;
            UNLOCK(gTlsLock);
            return FALSE;
        }
    }

    // get the entry pointer, update the next free slot, and
    // fill in the entry
    ptls->TlsMapIndex   = giTlsNextFreeEntry;
    TLSMapEntry *pEntry = &gpTlsMap[giTlsNextFreeEntry];
    giTlsNextFreeEntry  = pEntry->dwThreadId;
    pEntry->dwThreadId  = GetCurrentThreadId();
    pEntry->ptls        = ptls;

    // Increment number of initialized threads
    ++gcTlsUsedEntries;

    UNLOCK(gTlsLock);
    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Function:   ProcessUninitTlsCleanup
//
//  Synopsis:   Cleansup relavant TLS entries at process uninit time
//
//  History:    18-oct-99   Gopalk
//
//--------------------------------------------------------------------------
void ProcessUninitTlsCleanup()
{
    if(gpTlsMap)
    {
        // Sanity check
        ASSERT_LOCK_NOT_HELD(gTlsLock);
        
        // Acquire TLS lock
        LOCK(gTlsLock);

        // Check for the need to cleanup any remaining tls entries
        if(gcTlsUsedEntries)
        {
            for(ULONG i=0;i<gcTlsTotalEntries;i++)
            {
                if(gpTlsMap[i].ptls)
                {
                    gpTlsMap[i].ptls->pCurrentCtx = NULL;
                    gpTlsMap[i].ptls->ContextId = (ULONGLONG)-1;
                }
            }
        }
        
        // Release TLS lock
        UNLOCK(gTlsLock);
    }

    return;
}


//+-------------------------------------------------------------------------
//
//  Function:   CleanupTlsMap
//
//  Synopsis:   Cleansup remaining TLS entries in the map
//
//  History:    03-June-98   Gopalk
//
//--------------------------------------------------------------------------
void CleanupTlsMap(BOOL fSafe)
{
    // No need to hold the lock as the routine is called from inside
    // DllMain which is single threaded by the OS
    if(gpTlsMap)
    {
        // Check for the need to cleanup any remaining tls entries
        if(gcTlsUsedEntries)
        {
            for(ULONG i=0;i<gcTlsTotalEntries;i++)
            {
                if(gpTlsMap[i].ptls)
                    CleanupTlsState(gpTlsMap[i].ptls, fSafe);
            }
        }

        // Sanity check
        Win4Assert(gcTlsUsedEntries == 0);

        // Free TLS map
        HeapFree(g_hHeap, HEAP_SERIALIZE, gpTlsMap);
        gpTlsMap = NULL;
    }

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   TLSRemoveFromMap
//
//  Synopsis:   Removes a Tls structure associated with a given threadid
//              from the global map.
//
//  History:    12-May-98   Rickhi
//
//--------------------------------------------------------------------------
void TLSRemoveFromMap(SOleTlsData *ptls)
{
    ASSERT_LOCK_NOT_HELD(gTlsLock);
    LOCK(gTlsLock);

    LONG index          = ptls->TlsMapIndex;
    Win4Assert(index != -1);
    TLSMapEntry *pEntry = &gpTlsMap[index];
    Win4Assert(pEntry->ptls == ptls);
    pEntry->ptls        = NULL;
    pEntry->dwThreadId  = giTlsNextFreeEntry;
    giTlsNextFreeEntry  = index;
    --gcTlsUsedEntries;

    UNLOCK(gTlsLock);

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   TLSAllocData
//
//  Synopsis:   Allocates the thread local storage block
//
//  Returns:    S_OK - allocated the data
//              E_OUTOFMEMORY - could not allocate the data
//
//  History:    09-Aug-94   Rickhi      commented
//
//--------------------------------------------------------------------------
HRESULT COleTls::TLSAllocData(void)
{
#ifdef _CHICAGO_
    Win4Assert(TlsGetValue(gTlsIndex) == 0);
#endif
    Win4Assert(g_hHeap != NULL);

    _pData = (SOleTlsData *) HeapAlloc(g_hHeap, HEAP_SERIALIZE,
                                       sizeof(SOleTlsData));

    if (_pData)
    {
        // This avoids having to set most fields to NULL, 0, etc and
        // is needed cause on debug builds memory is not guaranteed to
        // be zeroed.
        memset(_pData, 0, sizeof(SOleTlsData));

        // fill in the non-zero values
        _pData->dwFlags = OLETLS_LOCALTID;

        // add it to the global map
        if (TLSAddToMap(_pData))
        {
#ifdef _CHICAGO_
            // store the data ptr in TLS
            if (TlsSetValue(gTlsIndex, _pData))
                return S_OK;

            TLSRemoveFromMap(_pData);
#else
            NtCurrentTeb()->ReservedForOle = _pData;
            _pData->ppTlsSlot = &(NtCurrentTeb()->ReservedForOle);
            return S_OK;
#endif
        }

        // error, cleanup and fallthru to error exit
        HeapFree(g_hHeap, HEAP_SERIALIZE, _pData);
        _pData = NULL;
    }

    ComDebOut((DEB_ERROR, "TLSAllocData failed.\n"));
    return E_OUTOFMEMORY;
}


//+-------------------------------------------------------------------------
//
//  Function:   TLSGetLogicalThread
//
//  Synopsis:   gets the logical threadid of the current thread,
//              allocating one if necessary
//
//  Returns:    ptr to GUID
//              NULL if error
//
//  History:    09-Aug-94   Rickhi      commented
//
//--------------------------------------------------------------------------
IID *TLSGetLogicalThread()
{
    HRESULT hr;
    RPC_STATUS sc;
    COleTls tls(hr);

    if (SUCCEEDED(hr))
    {
        if (!(tls->dwFlags & OLETLS_UUIDINITIALIZED))
        {
#ifdef _CHICAGO_
            CoCreateAlmostGuid(&(tls->LogicalThreadId));
#else
            sc = UuidCreate(&(tls->LogicalThreadId));
	    Win4Assert(sc == RPC_S_OK);
#endif
            tls->dwFlags |= OLETLS_UUIDINITIALIZED;
        }

        return &(tls->LogicalThreadId);
    }

    return NULL;
}

//+---------------------------------------------------------------------------
//
//  Function:   CleanupTlsState
//
//  Synopsis:   Cleans up state maintained inside tls
//
//  History:    June-04-98   Gopalk   Created
//
//----------------------------------------------------------------------------
void CleanupTlsState(SOleTlsData *pTls, BOOL fSafe)
{
    IUnknown* pUnkRelease = NULL;
    void* pMem = NULL;
    HWND hwndClose = NULL;
    HANDLE hClose = NULL;

    // Sanity check
    Win4Assert(pTls);

    // Cleanup initialization spies
    //   Revoke outstanding registrations
    InitializeSpyNode *pSpyNode = pTls->pFirstSpyReg;
    pTls->pFirstSpyReg = NULL; 
    while (pSpyNode)
    {
        InitializeSpyNode *pNext = pSpyNode->pNext;
        if (pSpyNode->pInitSpy)
            pSpyNode->pInitSpy->Release();
        CoTaskMemFree(pSpyNode);
        
        pSpyNode = pNext;
    }
    //   Free the free list
    pSpyNode = pTls->pFirstFreeSpyReg;
    pTls->pFirstFreeSpyReg = NULL;
    while (pSpyNode)
    {
        InitializeSpyNode *pNext = pSpyNode->pNext;
        CoTaskMemFree(pSpyNode);        
        pSpyNode = pNext;
    }
    

    // Cleanup sandbox state
    if(pTls->punkActiveXSafetyProvider)
    {
        pUnkRelease = pTls->punkActiveXSafetyProvider;
        pTls->punkActiveXSafetyProvider = NULL;
        pUnkRelease->Release();
    }

    // Cleanup call objects cached in the tls
    CleanupThreadCallObjects(pTls);

#if defined(MULTIHEAP)
    // Release the docfile shared memory allocator
    if (pTls->pSmAllocator != NULL)
    {
        pUnkRelease = (IUnknown*)pTls->pSmAllocator;
        pTls->pSmAllocator = NULL;
        pUnkRelease->Release();
    }
#endif

    // Cleanup cancel state
    if(pTls->hThread)
    {
        hClose = pTls->hThread;
        pTls->hThread = NULL;
        CloseHandle(hClose);
    }

    // Cleanup DDE state
    if (pTls->hwndDdeServer != NULL)
    {
        hwndClose = pTls->hwndDdeServer;
        pTls->hwndDdeServer = NULL;
        SSDestroyWindow(hwndClose);
    }
    if (pTls->hwndDdeClient != NULL)
    {
        hwndClose = pTls->hwndDdeClient;
        pTls->hwndDdeClient = NULL;
        SSDestroyWindow(hwndClose);
    }

    // Cleanup OLE state
    if(pTls->pDragCursors)
    {
        pMem = pTls->pDragCursors;
        pTls->pDragCursors = NULL;
        PrivMemFree(pMem);
    }

    if (pTls->hwndClip != NULL)
    {
        hwndClose = pTls->hwndClip;
        pTls->hwndClip = NULL;
        SSDestroyWindow(hwndClose);
    }

    if (pTls->hRevert != NULL)
    {
        hClose = pTls->hRevert;
        pTls->hRevert = NULL;
        CloseHandle(hClose);
    }

    // Ensure there are no outstanding call objects
    Win4Assert(pTls->pFreeClientCall == NULL);
    Win4Assert(pTls->pFreeAsyncCall  == NULL);

    // Free up lock state
    LockEntry *pNextEntry = pTls->lockEntry.pNext;
    LockEntry *pFreeEntry;

    pTls->lockEntry.pNext = NULL;

    while(pNextEntry)
    {
        pFreeEntry = pNextEntry;
        pNextEntry = pFreeEntry->pNext;
        HeapFree(g_hHeap, HEAP_SERIALIZE, pFreeEntry);
    }

    if(fSafe)
        *(pTls->ppTlsSlot) = NULL;

    // Remove the entry from the global map
    TLSRemoveFromMap(pTls);

    // Free up tls memory
    HeapFree(g_hHeap, HEAP_SERIALIZE, pTls);
}

//+---------------------------------------------------------------------------
//
//  Function:   DoThreadSpecificCleanup
//
//  Synopsis:   Called to perform cleanup on all this threads data
//              structures, and to call CoUninitialize() if needed.
//
//              Could be called by DLL_THREAD_DETACH or DLL_PROCESS_DETACH
//
//  History:    3-18-95   kevinro   Created
//
//----------------------------------------------------------------------------
void DoThreadSpecificCleanup()
{
    CairoleDebugOut((DEB_DLL | DEB_ITRACE,"_IN DoThreadSpecificCleanup\n"));

#ifdef _CHICAGO_
    SOleTlsData *pTls = (SOleTlsData *) TlsGetValue(gTlsIndex);
#else
    SOleTlsData *pTls = (SOleTlsData *) (NtCurrentTeb()->ReservedForOle);
#endif

    if (pTls == NULL)
    {
        // there is no TLS for this thread, so there can't be anything
        // to cleanup.
        return;
    }

    if (pTls->dwFlags & OLETLS_THREADUNINITIALIZING)
    {
        // this thread is already uninitializing.
        return;
    }

    if (IsWOWThread() && IsWOWThreadCallable() && pTls->cComInits != 0)
    {
        // OLETHK32 needs a chance to prepare, here is where we tell it
        // to fail any future callbacks.
        g_pOleThunkWOW->PrepareForCleanup();
    }

    // Because of the DLL unload rules in NT we need to be careful
    // what we do in clean up. We notify the routines with special
    // behavior here.

    pTls->dwFlags |= OLETLS_INTHREADDETACH;

    while (pTls->cComInits != 0)
    {
        // cleanup per-thread initializations;
        ComDebOut((DEB_WARN, "Unbalanced call to CoInitialize for thread %ld\n",
                   GetCurrentThreadId()));

        CoUninitialize();
    }

    // Cleanup TLS state
    CleanupTlsState(pTls, TRUE);

    // reset the index so we dont find this data again.
#ifdef _CHICAGO_
    TlsSetValue(gTlsIndex, NULL);
#else
    Win4Assert(NtCurrentTeb()->ReservedForOle == NULL);
#endif
#if LOCK_PERF==1
    FreeLockPerfPvtTlsData();
#endif //LOCK_PERF==1

    ComDebOut((DEB_DLL | DEB_ITRACE,"OUT DoThreadSpecificCleanup\n"));
}


//+-------------------------------------------------------------------------
//
//  Function:   ThreadNotification
//
//  Synopsis:   Dll entry point
//
//  Arguments:  [hDll]          -- a handle to the dll instance
//              [dwReason]      -- the reason LibMain was called
//              [lpvReserved]   - NULL - called due to FreeLibrary
//                              - non-NULL - called due to process exit
//
//  Returns:    TRUE on success, FALSE otherwise
//
//  Notes:      other one time initialization occurs in ctors for
//              global objects
//
//  WARNING:    if we are called because of FreeLibrary, then we should do as
//              much cleanup as we can. If we are called because of process
//              termination, we should not do any cleanup, as other threads in
//              this process will have already been killed, potentially while
//              holding locks around resources.
//
//  History:    09-Aug-94   Rickhi      commented
//
//--------------------------------------------------------------------------
STDAPI_(BOOL) ThreadNotification(HINSTANCE hDll, DWORD dwReason, LPVOID lpvReserved )
{
    switch (dwReason)
    {
    case DLL_THREAD_ATTACH:
        // new thread is starting
        ComDebOut((DEB_DLL,"DLL_THREAD_ATTACH:\n"));
#if LOCK_PERF==1
        HRESULT hr;
        hr = AllocLockPerfPvtTlsData();
        if (FAILED(hr)) 
        {
            ComDebOut((DEB_ERROR, "AllocLockPerfPvtTlsData failed.\n"));
            return FALSE;
        }
#endif
        break;

    case DLL_THREAD_DETACH:
        // Thread is exiting, clean up resources associated with threads.
        ComDebOut((DEB_DLL,"DLL_THREAD_DETACH:\n"));

        DoThreadSpecificCleanup();

        ASSERT_LOCK_NOT_HELD(gComLock);
        break;

    case DLL_PROCESS_ATTACH:
        // Get and cache the module name and the module name size.
        gcImagePath = GetModuleFileName(NULL, gawszImagePath, MAX_PATH);

#ifdef _CHICAGO_
        // Initial setup. Get a thread local storage index for use by OLE
        gTlsIndex = TlsAlloc();

        if (gTlsIndex == 0xffffffff)
        {
         Win4Assert("Could not get TLS Index.");
         return FALSE;
        }
#endif // _CHICAGO_
#if LOCK_PERF==1
        gTlsLockPerfIndex = TlsAlloc();
        Win4Assert( gTlsLockPerfIndex!=0xffffffff );
        hr = AllocLockPerfPvtTlsData();
        if ((gTlsLockPerfIndex==0xFFFFFFFF) || FAILED(hr)) 
        {
            ComDebOut((DEB_ERROR, "TlsAlloc OR AllocLockPerfPvtTlsData failed.\n"));
            return FALSE;
        }
#endif  //LOCK_PERF==1
        break;

    case DLL_PROCESS_DETACH:
        if (NULL == lpvReserved)
        {
            // exiting because of FreeLibrary, so try to cleanup

            //
            // According the to the rules, OLETHK32 should have called over to
            // remove the global pointer (used for testing the IsWOWxxx situations)
            // before going away. It should have done this BEFORE this
            // DLL_PROCESS_DETACH was dispatched.
            //
            Win4Assert(!(IsWOWProcess() && IsWOWThreadCallable()));

            //
            // DLL_PROCESS_DETACH is called when we unload. The thread that is
            // currently calling has not done thread specific cleanup yet.
            //
            DoThreadSpecificCleanup();

#ifdef _CHICAGO_
            TlsFree(gTlsIndex);
#endif // _CHICAGO_

#if LOCK_PERF==1
            TlsFree(gTlsLockPerfIndex);
            gTlsLockPerfIndex = 0xffffffff;
#endif  //LOCK_PERF==1
        }
        break;
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:   TLSIsWOWThread
//
//  Synopsis:   indicates definitively if current thread is 16-bit WOW thread
//
//  Returns:    TRUE/FALSE
//
//  History:    15-Nov-94   MurthyS     Created
//
//--------------------------------------------------------------------------
BOOLEAN TLSIsWOWThread()
{
    COleTls tls;

    return((BOOLEAN) (tls->dwFlags & OLETLS_WOWTHREAD));
}

//+-------------------------------------------------------------------------
//
//  Function:   TLSIsThreadDetaching
//
//  Synopsis:   indicates if thread cleanup is in progress
//
//  Returns:    TRUE/FALSE
//
//  History:    29-Jan-95   MurthyS     Created
//
//--------------------------------------------------------------------------
BOOLEAN TLSIsThreadDetaching()
{
    COleTls tls;

    return((BOOLEAN) (tls->dwFlags & OLETLS_INTHREADDETACH));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\class\privoa.cxx ===
//+============================================================================
//
//  File:   PrivOA.cxx
//
//  This file provides private wrapper routines for the OleAut32.dll
//  exports which are called from ole32.dll.  We don't want to link 
//  ole32 directly to oleaut32 for performance reasons.  So, for
//  each export, there is a corresponding function pointer and
//  "Load" routine.
//
//  For example, pfnSysAllocString initially points to LoadSysAllocString.
//  The first time it is called, the Load routine loads oleaut32 (if
//  necessary), does a GetProcAddr on "SysAllocString", puts
//  pointer into pfnSysAllocString, then makes the call.  All subsequent
//  calls to pfnSysAllocString thus go straight to oleaut32.
//
//+============================================================================



#include <ole2int.h>
#include <oleauto.h>
#include <privoa.h>     // PrivSys* routines

SYS_ALLOC_STRING       *pfnSysAllocString      = LoadSysAllocString;
SYS_FREE_STRING        *pfnSysFreeString       = LoadSysFreeString;
SYS_REALLOC_STRING_LEN *pfnSysReAllocStringLen = LoadSysReAllocStringLen;
SYS_STRING_BYTE_LEN    *pfnSysStringByteLen    = LoadSysStringByteLen;

SAFE_ARRAY_ACCESS_DATA      *pfnSafeArrayAccessData     = LoadSafeArrayAccessData;
SAFE_ARRAY_GET_L_BOUND      *pfnSafeArrayGetLBound      = LoadSafeArrayGetLBound;
SAFE_ARRAY_GET_DIM          *pfnSafeArrayGetDim         = LoadSafeArrayGetDim;
SAFE_ARRAY_GET_ELEM_SIZE    *pfnSafeArrayGetElemsize    = LoadSafeArrayGetElemsize;
SAFE_ARRAY_GET_U_BOUND      *pfnSafeArrayGetUBound      = LoadSafeArrayGetUBound;
SAFE_ARRAY_GET_VARTYPE      *pfnSafeArrayGetVartype     = LoadSafeArrayGetVartype;
SAFE_ARRAY_UNACCESS_DATA    *pfnSafeArrayUnaccessData   = LoadSafeArrayUnaccessData;
SAFE_ARRAY_CREATE_EX        *pfnSafeArrayCreateEx       = LoadSafeArrayCreateEx;

BSTR_USER_SIZE              *pfnBSTR_UserSize           = LoadBSTR_UserSize;
BSTR_USER_MARSHAL           *pfnBSTR_UserMarshal        = LoadBSTR_UserMarshal;
BSTR_USER_UNMARSHAL         *pfnBSTR_UserUnmarshal      = LoadBSTR_UserUnmarshal;
BSTR_USER_FREE              *pfnBSTR_UserFree           = LoadBSTR_UserFree;

LPSAFEARRAY_USER_SIZE       *pfnLPSAFEARRAY_UserSize        = LoadLPSAFEARRAY_UserSize;
LPSAFEARRAY_USER_MARSHAL    *pfnLPSAFEARRAY_UserMarshal     = LoadLPSAFEARRAY_UserMarshal;
LPSAFEARRAY_USER_UNMARSHAL  *pfnLPSAFEARRAY_UserUnmarshal   = LoadLPSAFEARRAY_UserUnmarshal;
LPSAFEARRAY_USER_FREE       *pfnLPSAFEARRAY_UserFree        = LoadLPSAFEARRAY_UserFree;




#define OLEAUT_FNPTR( fname )   FNTYPE_##fname  *pfn##fname=Load##fname;

#define LoadAut1( fname, type1 )            \
OLEAUT_FNPTR( fname );                      \
HRESULT STDAPICALLTYPE                      \
Load##fname( type1 farg1 )                  \
{                                           \
    HRESULT hr = LoadOleAut32Export( #fname, reinterpret_cast<void**>(&pfn##fname) ); \
    if( SUCCEEDED( hr ) )                   \
        hr = pfn##fname( farg1 );           \
    return ( hr );                          \
}

#define LoadAut1r( retType, fname, type1 )  \
OLEAUT_FNPTR( fname );                      \
retType STDAPICALLTYPE                      \
Load##fname( type1 farg1 )                  \
{                                           \
    retType tmp=0;                          \
    HRESULT hr = LoadOleAut32Export( #fname, reinterpret_cast<void**>(&pfn##fname) ); \
    if( SUCCEEDED( hr ) )                   \
        tmp = pfn##fname( farg1 );          \
    return ( tmp );                         \
}

#define LoadAut1v( fname, type1 )           \
OLEAUT_FNPTR( fname );                      \
void STDAPICALLTYPE                         \
Load##fname( type1 farg1 )                  \
{                                           \
    HRESULT hr = LoadOleAut32Export( #fname, reinterpret_cast<void**>(&pfn##fname) ); \
    if( SUCCEEDED( hr ) )                   \
        pfn##fname( farg1 );                \
}

#define LoadAut2( fname, type1, type2 )                     \
OLEAUT_FNPTR( fname );                                      \
HRESULT STDAPICALLTYPE                                      \
Load##fname( type1 farg1, type2 farg2 )                     \
{                                                           \
    HRESULT hr = LoadOleAut32Export( #fname, reinterpret_cast<void**>(&pfn##fname) ); \
    if( SUCCEEDED( hr ) )                                   \
        hr = pfn##fname( farg1, farg2 );                    \
    return ( hr );                                          \
}

#define LoadAut3( fname, type1, type2, type3 )              \
OLEAUT_FNPTR( fname );                                      \
HRESULT STDAPICALLTYPE                                      \
Load##fname( type1 farg1, type2 farg2, type3 farg3 )        \
{                                                           \
    HRESULT hr = LoadOleAut32Export( #fname, reinterpret_cast<void**>(&pfn##fname) ); \
    if( SUCCEEDED( hr ) )                                   \
        hr = pfn##fname( farg1, farg2, farg3 );             \
    return ( hr );                                          \
}

#define LoadAut3r( retType, fname, type1, type2, type3 )    \
OLEAUT_FNPTR( fname );                                      \
retType STDAPICALLTYPE                                      \
Load##fname( type1 farg1, type2 farg2, type3 farg3 )        \
{                                                           \
    retType tmp=0;                                          \
    HRESULT hr = LoadOleAut32Export( #fname, reinterpret_cast<void**>(&pfn##fname) ); \
    if( SUCCEEDED( hr ) )                                   \
        tmp = pfn##fname( farg1, farg2, farg3 );            \
    return ( tmp );                                         \
}


#define LoadAut5( fname, type1, type2, type3, type4, type5 ) \
OLEAUT_FNPTR( fname );                                       \
HRESULT STDAPICALLTYPE                                       \
Load##fname( type1 farg1, type2 farg2, type3 farg3, type4 farg4, type5 farg5 )        \
{                                                            \
    HRESULT hr = LoadOleAut32Export( #fname, reinterpret_cast<void**>(&pfn##fname) ); \
    if( SUCCEEDED( hr ) )                                   \
        hr = pfn##fname( farg1, farg2, farg3, farg4, farg5 );  \
    return ( hr );                                          \
}



//+----------------------------------------------------------------------------
//
//  Load oleaut32.dll routines
//
//  These routines are represent all the oleaut32 exports that are called
//  by ole32.dll.  Each corresponds to an oleaut32 export, and each is 
//  initially pointed to by a global pfn function ptr.  The load routine
//  loads the export into the pfn, then calls it.  Thus all future
//  calls on the pfn function pointer go directly to oleaut32.
//
//
//+----------------------------------------------------------------------------

HRESULT
LoadOleAut32Export( CHAR *szExport, void **ppfn )
{
    static HINSTANCE  hOleAut32 = NULL;
    void *pfn = NULL;

    HRESULT hr = S_OK;
    if( NULL == hOleAut32)
    {
        hOleAut32 = LoadLibraryA("oleaut32.dll");
        if( NULL == hOleAut32 )
            return( HRESULT_FROM_WIN32( GetLastError() ));
    }

    pfn = GetProcAddress(hOleAut32, szExport );
    if( NULL == pfn )
        return( HRESULT_FROM_WIN32( GetLastError() ));
    
    *ppfn = pfn;
    return( S_OK );
}

BSTR STDAPICALLTYPE
LoadSysAllocString(LPCOLESTR pwsz)
{
    BSTR bstr = NULL;

    if( SUCCEEDED(LoadOleAut32Export( "SysAllocString", reinterpret_cast<void**>(&pfnSysAllocString) )))
       bstr = pfnSysAllocString(pwsz);

    return bstr;
}

VOID STDAPICALLTYPE
LoadSysFreeString(BSTR bstr)
{
    if( SUCCEEDED(LoadOleAut32Export( "SysFreeString", reinterpret_cast<void**>(&pfnSysFreeString) )))
       pfnSysFreeString(bstr);

    return;
}

BOOL STDAPICALLTYPE
LoadSysReAllocStringLen(BSTR FAR *pbstr, OLECHAR FAR *pwsz, UINT cch)
{
    BOOL fRet = FALSE;

    if( SUCCEEDED(LoadOleAut32Export( "SysReAllocStringLen", reinterpret_cast<void**>(&pfnSysReAllocStringLen) )))
        fRet = (*pfnSysReAllocStringLen)(pbstr, pwsz, cch);

    return( fRet );
}

UINT STDAPICALLTYPE
LoadSysStringByteLen(BSTR bstr)
{
    UINT uiLen = 0;

    if( SUCCEEDED(LoadOleAut32Export( "SysStringByteLen", reinterpret_cast<void**>(&pfnSysStringByteLen) )))
       uiLen = (*pfnSysStringByteLen)(bstr);

    return( uiLen );
}

LoadAut1r( UINT, SysStringLen, BSTR );


HRESULT STDAPICALLTYPE
LoadSafeArrayAccessData( SAFEARRAY * psa, void HUGEP** ppvData )
{
    HRESULT hr = S_OK;

    hr = LoadOleAut32Export( "SafeArrayAccessData", reinterpret_cast<void**>(&pfnSafeArrayAccessData) );
    if( SUCCEEDED(hr) )
        hr = pfnSafeArrayAccessData( psa, ppvData );

    return( hr );

}

HRESULT STDAPICALLTYPE
LoadSafeArrayGetLBound( SAFEARRAY *psa, UINT nDim, LONG * plLbound )
{
    HRESULT hr = S_OK;

    hr = LoadOleAut32Export( "SafeArrayGetLBound", reinterpret_cast<void**>(&pfnSafeArrayGetLBound) );
    if( SUCCEEDED(hr) )
        hr = pfnSafeArrayGetLBound( psa, nDim, plLbound );

    return( hr );
}

HRESULT STDAPICALLTYPE
LoadSafeArrayGetUBound( SAFEARRAY *psa, UINT nDim, LONG * plUbound )
{
    HRESULT hr = S_OK;

    hr = LoadOleAut32Export( "SafeArrayGetUBound", reinterpret_cast<void**>(&pfnSafeArrayGetUBound) );
    if( SUCCEEDED(hr) )
        hr = pfnSafeArrayGetUBound( psa, nDim, plUbound );

    return( hr );
}

UINT STDAPICALLTYPE
LoadSafeArrayGetDim( SAFEARRAY *psa )
{
    UINT ui = 0;
    HRESULT hr = S_OK;

    hr = LoadOleAut32Export( "SafeArrayGetDim", reinterpret_cast<void**>(&pfnSafeArrayGetDim) );
    if( SUCCEEDED(hr) )
        ui = pfnSafeArrayGetDim( psa );

    return( ui );
}


UINT STDAPICALLTYPE
LoadSafeArrayGetElemsize( SAFEARRAY * psa )
{
    HRESULT hr;
    UINT ui = 0;

    hr = LoadOleAut32Export( "SafeArrayGetElemsize", reinterpret_cast<void**>(&pfnSafeArrayGetElemsize) );
    if( SUCCEEDED(hr) )
        ui = pfnSafeArrayGetElemsize( psa );

    return( ui );
}


HRESULT STDAPICALLTYPE
LoadSafeArrayGetVartype( SAFEARRAY *psa, VARTYPE *pvt )
{
    HRESULT hr = S_OK;

    hr = LoadOleAut32Export( "SafeArrayGetVartype", reinterpret_cast<void**>(&pfnSafeArrayGetVartype) );
    if( SUCCEEDED(hr) )
        hr = pfnSafeArrayGetVartype( psa, pvt );

    return( hr );
}



HRESULT STDAPICALLTYPE
LoadSafeArrayUnaccessData( SAFEARRAY *psa )
{
    HRESULT hr;

    hr = LoadOleAut32Export( "SafeArrayUnaccessData", reinterpret_cast<void**>(&pfnSafeArrayUnaccessData) );
    if( SUCCEEDED(hr) )
        hr = pfnSafeArrayUnaccessData( psa );

    return( hr );
}


SAFEARRAY * STDAPICALLTYPE
LoadSafeArrayCreateEx( VARTYPE vt, UINT cDims, SAFEARRAYBOUND * rgsabound, PVOID pvExtra)
{
    HRESULT hr;
    SAFEARRAY *psa = NULL;

    hr = LoadOleAut32Export( "SafeArrayCreateEx", reinterpret_cast<void**>(&pfnSafeArrayCreateEx) );
    if( SUCCEEDED(hr) )
        psa = pfnSafeArrayCreateEx( vt, cDims, rgsabound, pvExtra );

    return( psa );
}

LoadAut3r( SAFEARRAY*, SafeArrayCreate, VARTYPE, UINT, SAFEARRAYBOUND* );
LoadAut3( SafeArrayPutElement, SAFEARRAY*, long*, void* );
LoadAut1( SafeArrayDestroy, SAFEARRAY* );

LoadAut1v( VariantInit, VARIANT* );
LoadAut1( VariantClear, VARIANTARG* );
LoadAut2( VariantCopy, VARIANTARG*, VARIANTARG* );
LoadAut5( VariantChangeTypeEx, VARIANTARG *, VARIANTARG *, LCID, USHORT, VARTYPE );



// The following routines are optimized so that if they are called twice,
// they don't re-getprocaddr the pfn.  This is because oleprx32\proxy\prop_p.c
// must have a constant function pointer for its function tables.

EXTERN_C unsigned long 
LoadBSTR_UserSize( unsigned long __RPC_FAR *pul, unsigned long ul, BSTR __RPC_FAR * pbstr )
{
    HRESULT hr = S_OK;
    unsigned long ulRet = 0;

    if( LoadBSTR_UserSize == pfnBSTR_UserSize )
        hr = LoadOleAut32Export( "BSTR_UserSize", reinterpret_cast<void**>(&pfnBSTR_UserSize) );
    if( SUCCEEDED(hr) )
        ulRet = pfnBSTR_UserSize( pul, ul, pbstr );
    return( ulRet );
}


EXTERN_C unsigned char __RPC_FAR * 
LoadBSTR_UserMarshal(  unsigned long __RPC_FAR *pul, unsigned char __RPC_FAR *puc, BSTR __RPC_FAR *pbstr )
{
    HRESULT hr = S_OK;
    unsigned char *pucRet = NULL;

    if( LoadBSTR_UserMarshal == pfnBSTR_UserMarshal )
        hr = LoadOleAut32Export( "BSTR_UserMarshal", reinterpret_cast<void**>(&pfnBSTR_UserMarshal) );
    if( SUCCEEDED(hr) )
        pucRet = pfnBSTR_UserMarshal( pul, puc, pbstr );
    return( pucRet );
}

EXTERN_C unsigned char __RPC_FAR * 
LoadBSTR_UserUnmarshal(unsigned long __RPC_FAR *pul, unsigned char __RPC_FAR *puc, BSTR __RPC_FAR *pbstr )
{
    HRESULT hr = S_OK;
    unsigned char *pucRet = NULL;

    if( LoadBSTR_UserUnmarshal == pfnBSTR_UserUnmarshal )
        hr = LoadOleAut32Export( "BSTR_UserUnmarshal", reinterpret_cast<void**>(&pfnBSTR_UserUnmarshal) );
    if( SUCCEEDED(hr) )
        pucRet = pfnBSTR_UserUnmarshal( pul, puc, pbstr );
    return( pucRet );
}

EXTERN_C void 
LoadBSTR_UserFree( unsigned long __RPC_FAR *pul, BSTR __RPC_FAR *pbstr )
{
    HRESULT hr = S_OK;

    if( LoadBSTR_UserFree == pfnBSTR_UserFree )
        hr = LoadOleAut32Export( "BSTR_UserFree", reinterpret_cast<void**>(&pfnBSTR_UserFree) );
    if( SUCCEEDED(hr) )
        pfnBSTR_UserFree( pul, pbstr );
}

EXTERN_C unsigned long 
LoadLPSAFEARRAY_UserSize(     unsigned long __RPC_FAR *pul, unsigned long            ul, LPSAFEARRAY __RPC_FAR *ppsa )
{
    HRESULT hr = S_OK;
    unsigned long ulRet = 0;

    if( LoadLPSAFEARRAY_UserSize == pfnLPSAFEARRAY_UserSize )
        hr = LoadOleAut32Export( "LPSAFEARRAY_UserSize", reinterpret_cast<void**>(&pfnLPSAFEARRAY_UserSize) );
    if( SUCCEEDED(hr) )
        ulRet = pfnLPSAFEARRAY_UserSize( pul, ul, ppsa );
    return( ulRet );
}

EXTERN_C unsigned char __RPC_FAR * 
LoadLPSAFEARRAY_UserMarshal(  unsigned long __RPC_FAR *pul, unsigned char __RPC_FAR *puc, LPSAFEARRAY __RPC_FAR *ppsa )
{
    HRESULT hr = S_OK;
    unsigned char *pucRet = NULL;

    if( LoadLPSAFEARRAY_UserMarshal == pfnLPSAFEARRAY_UserMarshal )
        hr = LoadOleAut32Export( "LPSAFEARRAY_UserMarshal", reinterpret_cast<void**>(&pfnLPSAFEARRAY_UserMarshal) );
    if( SUCCEEDED(hr) )
        pucRet = pfnLPSAFEARRAY_UserMarshal( pul, puc, ppsa );
    return( pucRet );
}

EXTERN_C unsigned char __RPC_FAR * 
LoadLPSAFEARRAY_UserUnmarshal(unsigned long __RPC_FAR *pul, unsigned char __RPC_FAR *puc, LPSAFEARRAY __RPC_FAR *ppsa )
{
    HRESULT hr = S_OK;
    unsigned char *pucRet = NULL;

    if( LoadLPSAFEARRAY_UserUnmarshal == pfnLPSAFEARRAY_UserUnmarshal )
        hr = LoadOleAut32Export( "LPSAFEARRAY_UserUnmarshal", reinterpret_cast<void**>(&pfnLPSAFEARRAY_UserUnmarshal) );
    if( SUCCEEDED(hr) )
        pucRet = pfnLPSAFEARRAY_UserUnmarshal( pul, puc, ppsa );

    return( pucRet );
}

EXTERN_C void          
LoadLPSAFEARRAY_UserFree(     unsigned long __RPC_FAR *pul, LPSAFEARRAY __RPC_FAR *ppsa )
{
    HRESULT hr = S_OK;

    if( LoadLPSAFEARRAY_UserFree == pfnLPSAFEARRAY_UserFree )
        hr = LoadOleAut32Export( "LPSAFEARRAY_UserFree", reinterpret_cast<void**>(&pfnLPSAFEARRAY_UserFree) );
    if( SUCCEEDED(hr) )
        pfnLPSAFEARRAY_UserFree( pul, ppsa );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\class\tracelog.cxx ===
//+-------------------------------------------------------------------
//
//  File:       tracelog.cxx
//
//  Contents:   trace log implementation
//
//  Classes:    CTraceLog   - class for logging traces
//              CTraceCall  - class for logging one function call
//
//  Functions:  none
//
//  History:    23-Aug-93   Rickhi      Created
//
//  Notes:      The trace log is used to record call information in a
//              process global ring buffer.  The information can be used
//              to assist debugging, by allowing you to see what events
//              have taken place that lead up to some problem, and also
//              to provide profiling the CairOLE subsystem.
//
//  CODEWORK:   add call nesting depth
//              add logical thread id
//              get input parms from ini file
//
//--------------------------------------------------------------------

#include    <ole2int.h>

#ifdef  TRACELOG

#include    <tracelog.hxx>
#include    <stdlib.h>

//  these prototypes must be here because the cairo headers and Nt headers
//  conflict with each other, so i cant include the latter.

extern "C" {
#define NTAPI __stdcall                    // winnt

LONG
NTAPI
NtQueryPerformanceCounter (
    LARGE_INTEGER *PerformanceCounter,
    LARGE_INTEGER *PerformanceFrequency
    );

LARGE_INTEGER
NTAPI
RtlLargeIntegerSubtract (
    LARGE_INTEGER Minuend,
    LARGE_INTEGER Subtrahend
    );

LARGE_INTEGER
NTAPI
RtlLargeIntegerDivide (
    LARGE_INTEGER Dividend,
    LARGE_INTEGER Divisor,
    LARGE_INTEGER *Remainder
    );

LARGE_INTEGER
NTAPI
RtlExtendedIntegerMultiply (
    LARGE_INTEGER Multiplicand,
    LONG Multiplier
    );

}   //  extern "C"



//  globals

DWORD           sg_dwTraceFlag = 0x0;               //  what to trace
CTraceLog       *sg_pTraceLog = NULL;               //  ptr to log
LARGE_INTEGER   sg_liFreq;                          //  counter frequency


//------------------------------------------------------------------------
//
//  function:   MapFlagToName
//
//  synopsis:   returns an ascii name equivalent for the trace flag value
//
//------------------------------------------------------------------------

CHAR * MapFlagToName(DWORD dwFlag)
{
    if (dwFlag & TRACE_RPC)
        return  "RPC";
    else if (dwFlag & TRACE_MARSHAL)
        return  "MSH";
    else if (dwFlag & TRACE_ACTIVATION)
        return  "ACT";
    else if (dwFlag & TRACE_REGISTRY)
        return  "REG";
    else if (dwFlag & TRACE_DLL)
        return  "DLL";
    else if (dwFlag & TRACE_INITIALIZE)
        return  "INI";
    else if (dwFlag & TRACE_CALLCONT)
        return  "CCT";
    else if (dwFlag & TRACE_APP)
	return	"APP";
    else
        return  "???";
}



//------------------------------------------------------------------------
//
//  member:     CTraceCall::CTraceCall
//
//  synopsis:   constructor is called on entry to each function that we wish
//              to trace. the constructor matches the trace flag passed in
//              against the global trace mask, and if a match is made then
//              an entry is made in the trace log for this function call.
//
//------------------------------------------------------------------------

CTraceCall::CTraceCall(DWORD dwFlags, CHAR *pszMsg) :
    _dwFlags(dwFlags),
    _pszMsg(pszMsg)
{
    //  compare the flag value with the global mask to determine if this
    //  call should be traced or not.
    if ((_dwFlags & sg_dwTraceFlag) && sg_pTraceLog)
    {
        //  trace the call
        _dwThreadId = GetCurrentThreadId();

        LARGE_INTEGER liEndTime, liFreq;
        liEndTime.LowPart = 0;
        liEndTime.HighPart = 0;

        NtQueryPerformanceCounter(&_liStartTime, &liFreq);
        sg_pTraceLog->TraceEntry(_dwFlags, _pszMsg, _dwThreadId, _liStartTime, liEndTime);
    }
}


//------------------------------------------------------------------------
//
//  member:     CTraceCall::~CTraceCall
//
//  synopsis:   destructor is called class placed on the stack in each function that we wish to
//              trace. the constructor matches the trace flag passed in
//              against the global trace mask, and if a match is made then
//              an entry is made in the trace log for this function call.
//
//------------------------------------------------------------------------

CTraceCall::~CTraceCall(void)
{
    //  if we traced the entry, then we'll trace the exit too.
    if ((_dwFlags & sg_dwTraceFlag) && sg_pTraceLog)
    {
        LARGE_INTEGER   liEndTime, liFreq;
        NtQueryPerformanceCounter(&liEndTime, &liFreq);
        sg_pTraceLog->TraceEntry(_dwFlags, _pszMsg, _dwThreadId, liEndTime, _liStartTime);
    }
}


//------------------------------------------------------------------------
//
//  member:     CTraceLog
//
//  synopsis:   constructor called at process entry time.
//
//------------------------------------------------------------------------

CTraceLog::CTraceLog(void) :
    _dwTraceFlag(0),
    _pLogStart(NULL),
    _pLogCurr(NULL),
    _pLogEnd(NULL),
    _fDump(TRUE),
    _ulLevel(0)
{
    ULONG ulLogSize = 0;

    //  init the mutex semaphore
    _mxs.Init();

    //  read the execution parameters from win.ini, or use defaults.
    CHAR    szRead[20];
    GetProfileStringA("CairOLE", "LogFlags", "0", szRead, sizeof(szRead));
    sscanf(szRead, "%li", &_dwTraceFlag);

    if (_dwTraceFlag != 0)
    {
	GetProfileStringA("CairOLE", "LogSize", "1000", szRead, sizeof(szRead));
        sscanf(szRead, "%li", &ulLogSize);

        GetProfileStringA("CairOLE", "LogDump", "Y", szRead, sizeof(szRead));
        _fDump = (_stricmp(szRead, "Y")) ? FALSE : TRUE;

        if (ulLogSize > 0)
        {
            //  allocate the logfile and set the pointers appropriately.
            _pLogStart = (STraceEntry *) VirtualAlloc(NULL,
                                          sizeof(STraceEntry)*ulLogSize,
                                          MEM_COMMIT,
                                          PAGE_READWRITE);
            Win4Assert(_pLogStart);

            _pLogCurr = _pLogStart;
            _pLogEnd = _pLogStart + ulLogSize;

            //  clear the trace log
            memset((BYTE *)_pLogStart, 0, ulLogSize*sizeof(STraceEntry));

	    //	get the startup time
            NtQueryPerformanceCounter(&_liStartTime, &sg_liFreq);

	    GetProfileStringA("CairOLE", "WaitForStart", "N", szRead, sizeof(szRead));
	    if (!_stricmp(szRead, "N"))
	    {
		//  start logging right away otherwise wait for
		//  start signal.
		StartTrace("Auto Tracing Started");
	    }
	}
    }

    CairoleDebugOut((DEB_ITRACE, "TraceLog: LogFlags=%ld  LogSize=%ld  LogDump=%ld\n",
                     sg_dwTraceFlag, ulLogSize, _fDump));
}


//------------------------------------------------------------------------
//
//  member:     ~CTraceLog
//
//  synopsis:   destructor called at process exit time.
//
//------------------------------------------------------------------------

CTraceLog::~CTraceLog(void)
{
    //  if the user requested logging to a file, do it now
    if (_pLogStart)
    {
        if (_fDump)
        {
            LogToFile();
        }

        //  delete the log file
        VirtualFree(_pLogStart,0,MEM_RELEASE);
    }
}


//------------------------------------------------------------------------
//
//  member:     TraceEntry
//
//  synopsis:   adds a function call entry to the log file
//
//------------------------------------------------------------------------

void CTraceLog::TraceEntry(DWORD dwFlags, CHAR *pszMsg, DWORD dwThreadId,
                           LARGE_INTEGER liCurrTime, LARGE_INTEGER liStartTime)
{
    if (!_pLogStart)
        return;

    CLock           lck(_mxs);      //  lock the log file while we play

    //  record an entry in the logfile to designate function entry

    _pLogCurr->dwThreadId = dwThreadId;
    _pLogCurr->dwFlags = dwFlags;
    _pLogCurr->pszMsg = pszMsg;
    _pLogCurr->liCurrTime = liCurrTime;
    _pLogCurr->liStartTime = liStartTime;

    if (liStartTime.HighPart == 0 && liStartTime.LowPart == 0)
    {
        _pLogCurr->fExit = FALSE;
        _pLogCurr->ulLevel = _ulLevel++;
    }
    else
    {
        _pLogCurr->fExit = TRUE;
        _pLogCurr->ulLevel = --_ulLevel;
    }


    //  update logfile ptr to next entry

    if (++_pLogCurr == _pLogEnd)
        _pLogCurr = _pLogStart;
}


//------------------------------------------------------------------------
//
//  member:     LogToFile
//
//  synopsis:   Dumps the tracelog to a file.
//
//------------------------------------------------------------------------

void CTraceLog::LogToFile(void)
{
    CairoleDebugOut((DEB_ITRACE, "Dumping TraceLog to file.\n"));

    CLock   lck(_mxs);          //  lock just for safety

    //  extract the program name from the command line and use it
    //  to generate a file name for the log file.

    CHAR szFileName[MAX_PATH];
    CHAR *pszNameStart = GetCommandLineA();
    CHAR *pszNameEnd = pszNameStart;

    while (*pszNameEnd && 
           *pszNameEnd != ' ' &&
           *pszNameEnd != '\t' &&
           *pszNameEnd != '.')
        pszNameEnd++;

    ULONG ulLen = pszNameEnd-pszNameStart;
    strncpy(szFileName, pszNameStart, ulLen);
    szFileName[ulLen] = '\0';
    strcat(szFileName, ".log");


    //  open the logging file

    FILE *fpLog = fopen(szFileName, "at");
    Win4Assert(fpLog && "Can't Open TraceLog File");
    if (!fpLog)
        return;


    //  print the title and column header
    fprintf(fpLog, "\t\t%s\n\n", szFileName);
    fprintf(fpLog, "Thread    Elapsed      Delta       Call Flg D Function\n");


    //  loop, writing the entries. we start at the current pointer (which
    //  is currently the oldest entry in the logfile) and write each one.
    //  in case we have not yet wrapped the log, we skip any blank entries.

    CHAR szBlank[MAX_PATH];
    memset(szBlank, ' ', sizeof(szBlank));

    STraceEntry    *pEntry = _pLogCurr;
    BOOL            fFirst = TRUE;
    LARGE_INTEGER   liPrev;

    do
    {
        //  write the entry
        if (pEntry->pszMsg)
        {
            //  we want the first time delta to be zero, so liPrev gets set
            //  to the value of the first entry that we write.
            if (fFirst)
                liPrev = pEntry->liCurrTime;

            //  compute the time deltas
            LARGE_INTEGER liElapsed = PerfDelta(pEntry->liCurrTime, _liStartTime);
            LARGE_INTEGER liDeltaPrev = PerfDelta(pEntry->liCurrTime, liPrev);
            LARGE_INTEGER liDeltaCall;

            if (pEntry->fExit)
            {
                liDeltaCall  = PerfDelta(pEntry->liCurrTime, pEntry->liStartTime);
            }
            else
            {
                liDeltaCall.LowPart = 0;
                liDeltaCall.HighPart = 0;
            }

            //  get the ascii name for the flag
            CHAR *pszFlagName = MapFlagToName(pEntry->dwFlags);

            //  null terminate the blank padding string that prefixes the
            //  pszMsg. this gives the illusion of call nesting level in
            //  the output, by shifting the output right ulLevel characters.
            szBlank[pEntry->ulLevel] = '\0';

            fprintf(fpLog, "%6ld %10lu %10lu %10lu %s %c %s%s\n",
                    pEntry->dwThreadId,
                    liElapsed.LowPart,
                    liDeltaPrev.LowPart,
                    liDeltaCall.LowPart,
                    pszFlagName,
                    (pEntry->fExit) ? '<' : '>',
                    szBlank,
                    pEntry->pszMsg);

            //  restore the padding string
            szBlank[pEntry->ulLevel] = ' ';

            fFirst = FALSE;
            liPrev = pEntry->liCurrTime;
        }

        //  update the current pointer
        if (++pEntry == _pLogEnd)
            pEntry = _pLogStart;

    } while (pEntry != _pLogCurr);


    //  close the logging file
    fclose(fpLog);
}


//------------------------------------------------------------------------
//
//  member:     LogToDebug
//
//  synopsis:   dumps the trace log to the debugger
//
//------------------------------------------------------------------------

void CTraceLog::LogToDebug(void)
{
    CairoleDebugOut((DEB_ITRACE, "Dumping TraceLog to Debugger.\n"));
}


//------------------------------------------------------------------------
//
//  function:   PerfDelta
//
//  synopsis:   computes the different between two Performace Counter values
//
//------------------------------------------------------------------------

LARGE_INTEGER CTraceLog::PerfDelta(LARGE_INTEGER liNow, LARGE_INTEGER liStart)
{
    LARGE_INTEGER liDelta, liRemainder;

    liDelta = RtlLargeIntegerSubtract (liNow, liStart);
    liDelta = RtlExtendedIntegerMultiply (liDelta, 1000000);
    liDelta = RtlLargeIntegerDivide (liDelta, sg_liFreq, &liRemainder);

    return  liDelta;
}


void CTraceLog::StartTrace(LPSTR pszMsg)    //	start log tracing
{
    CHAR    szMsg[260];
    strcpy(szMsg, "\n*** Start Trace\n");
    strcat(szMsg, pszMsg);

    sg_dwTraceFlag = _dwTraceFlag;

    CTraceCall trc(0xffffffff, szMsg);
}

void CTraceLog::StopTrace(LPSTR pszMsg)	    //	stop tracing
{
    CHAR    szMsg[260];
    strcpy(szMsg, "\n*** Stop Trace\n");
    strcat(szMsg, pszMsg);

    CTraceCall trc(0xffffffff, szMsg);

    sg_dwTraceFlag = 0;
}



STDAPI StartTrace(LPSTR pszMsg)
{
    if (sg_pTraceLog)
        sg_pTraceLog->StartTrace(pszMsg);
    return 0;
}

STDAPI StopTrace(LPSTR pszMsg)
{
    if (sg_pTraceLog)
        sg_pTraceLog->StopTrace(pszMsg);
    return 0;
}


#endif  //  TRACELOG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\class\pexttbl.cxx ===
//+------------------------------------------------------------------------
//
//  File:       pexttbl.cxx
//
//  Contents:   Table to support (per process) file extension to CLSID
//              registry caching
//
//  Classes:    CProcessExtensionTbl
//
//  History:	26-Sep-96   t-KevinH	Created
//
//-------------------------------------------------------------------------

#include <ole2int.h>
#include <olesem.hxx>

#include <pexttbl.hxx>       // class definition


#define EXT_ENTRIES_PER_PAGE		32

COleStaticMutexSem gTblLck;	// Table Lock

//+------------------------------------------------------------------------
//
//  Hash table buckets. This is defined as a global
//  so that we dont have to run any code to initialize the hash table.
//
//+------------------------------------------------------------------------
SHashChain ExtBuckets[23] =
{
    {&ExtBuckets[0],  &ExtBuckets[0]},
    {&ExtBuckets[1],  &ExtBuckets[1]},
    {&ExtBuckets[2],  &ExtBuckets[2]},
    {&ExtBuckets[3],  &ExtBuckets[3]},
    {&ExtBuckets[4],  &ExtBuckets[4]},
    {&ExtBuckets[5],  &ExtBuckets[5]},
    {&ExtBuckets[6],  &ExtBuckets[6]},
    {&ExtBuckets[7],  &ExtBuckets[7]},
    {&ExtBuckets[8],  &ExtBuckets[8]},
    {&ExtBuckets[9],  &ExtBuckets[9]},
    {&ExtBuckets[10], &ExtBuckets[10]},
    {&ExtBuckets[11], &ExtBuckets[11]},
    {&ExtBuckets[12], &ExtBuckets[12]},
    {&ExtBuckets[13], &ExtBuckets[13]},
    {&ExtBuckets[14], &ExtBuckets[14]},
    {&ExtBuckets[15], &ExtBuckets[15]},
    {&ExtBuckets[16], &ExtBuckets[16]},
    {&ExtBuckets[17], &ExtBuckets[17]},
    {&ExtBuckets[18], &ExtBuckets[18]},
    {&ExtBuckets[19], &ExtBuckets[19]},
    {&ExtBuckets[20], &ExtBuckets[20]},
    {&ExtBuckets[21], &ExtBuckets[21]},
    {&ExtBuckets[22], &ExtBuckets[22]}
};


//+-------------------------------------------------------------------
//
//  Function:   CleanupExtEntry
//
//  Synopsis:   Call the ExtensionTbl to cleanup an entry. This is called
//              by the hash table cleanup code.
//
//  History:    26-Sep-96   t-KevinH  Created
//
//--------------------------------------------------------------------
void CleanupExtEntry(SHashChain *pNode)
{
    if (((SExtEntry *)pNode)->m_wszExt != ((SExtEntry *)pNode)->m_wszBuf)
    {
	PrivMemFree(((SExtEntry *)pNode)->m_wszExt);
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CProcessExtensionTbl::CProcessExtensionTbl, public
//
//  Synopsis:   Initialize the table
//
//  History:    26-Sep-96   t-KevinH      Created
//
//-------------------------------------------------------------------------
CProcessExtensionTbl::CProcessExtensionTbl()
{
    LOCK(gTblLck);
    _HashTbl.Initialize(ExtBuckets, &gTblLck );
    _palloc.Initialize(sizeof(SExtEntry), EXT_ENTRIES_PER_PAGE, &gTblLck );
    UNLOCK(gTblLck);
}

//+------------------------------------------------------------------------
//
//  Member:     CProcessExtensionTbl::~CProcessExtensionTbl, public
//
//  Synopsis:   Cleanup the Registered Interface Table.
//
//  History:    26-Sep-96   t-KevinH      Created
//
//-------------------------------------------------------------------------
CProcessExtensionTbl::~CProcessExtensionTbl()
{
    LOCK(gTblLck);
    _HashTbl.Cleanup(CleanupExtEntry);
    _palloc.Cleanup();
    UNLOCK(gTblLck);
}

//+-------------------------------------------------------------------
//
//  Member:     CProcessExtensionTbl::GetClsid, public
//
//  Synopsis:   Finds the ExtEntry in the table for the given extension,
//              adds an entry if one is not found.
//
//  History:    26-Sep-96   t-KevinH      Created
//
//--------------------------------------------------------------------
HRESULT CProcessExtensionTbl::GetClsid(LPCWSTR pwszExt, CLSID *pclsid)
{
    HRESULT hr = S_OK;
    WCHAR wszExtLower[MAX_PATH];	// The extension in lower case

    lstrcpyW(wszExtLower, pwszExt);
    CharLowerW(wszExtLower);

    // look for the classid in the table.
    DWORD iHash = _HashTbl.Hash(wszExtLower);

    LOCK(gTblLck);

    SExtEntry *pExtEntry = (SExtEntry *) _HashTbl.Lookup(iHash, wszExtLower);

    if (pExtEntry == NULL)
    {
	// no entry exists for this extension, add one.

	hr = wRegGetClassExt(wszExtLower, pclsid);

	if (SUCCEEDED(hr))
	{
	    hr = AddEntry(*pclsid, wszExtLower, iHash);
	}
    }
    else
    {
        // found an entry, return the clsid
        *pclsid = pExtEntry->m_clsid;
    }

    UNLOCK(gTblLck);

    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CProcessExtensionTbl::AddEntry, private
//
//  Synopsis:   allocates and entry, fills in the values, and adds it
//              to the hash table.
//
//  History:    26-Sep-96   t-KevinH      Created
//
//--------------------------------------------------------------------
HRESULT CProcessExtensionTbl::AddEntry(REFCLSID rclsid,
				       LPCWSTR pwszExt,
				       DWORD iHash)
{
    SExtEntry *pExtEntry = (SExtEntry *) _palloc.AllocEntry();

    if (pExtEntry)
    {
	pExtEntry->m_clsid = rclsid;

	ULONG ulExtLength = lstrlenW(pwszExt);
	if (EXT_BUFSIZE <= ulExtLength)
	{
	    pExtEntry->m_wszExt = (WCHAR *)PrivMemAlloc((ulExtLength + 1) * sizeof(WCHAR));
	}
	else
	{
	    pExtEntry->m_wszExt = pExtEntry->m_wszBuf;
	}
        lstrcpyW(pExtEntry->m_wszExt, pwszExt);

        // add to the hash table
        _HashTbl.Add(iHash, pExtEntry->m_wszExt, &pExtEntry->m_node);

        return S_OK;
    }

    return E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\class\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=   class
TARGETPATH=   obj
TARGETTYPE=   LIBRARY

INCLUDES=     ..\..\..\ih;..;..\..\..\common;..\..\..\actprops
INCLUDES=     $(INCLUDES);..\..\objact
INCLUDES=     $(INCLUDES);..\..\inc;..\..\moniker2;..\..\dcomrem
INCLUDES=     $(INCLUDES);..\..\..\idl\public\$(DEST_TREE)\$(O)
INCLUDES=     $(INCLUDES);..\..\..\idl\internal\$(DEST_TREE)\$(O)
INCLUDES=     $(INCLUDES);..\..\..\idl\private\$(DEST_TREE)\$(O)

SOURCES=      \
            ..\alocdbg.cxx  \
            ..\cerror.cxx   \
            ..\cocrguid.cxx \
            ..\compapi.cxx  \
            ..\compobj.cxx  \
            ..\cspytbl.cxx  \
	    ..\longpath.cxx \
            ..\memapi.cxx   \
            ..\ole1guid.cxx \
            ..\tls.cxx      \
            ..\tracelog.cxx \
            ..\hkole32.cxx  \
            ..\pexttbl.cxx  \
            ..\privoa.cxx

UMTYPE=       windows

!include ..\..\precomp2.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\class\chicago\longname.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	longname.c
//
//  Contents:	GetLongPathName implementation
//
//  History:	25-Aug-94	DrewB	Created from Win32 sources for
//                                      GetShortPathName
//              06-Sep-94       DrewB   Rewrote using Win32 for portability
//
//----------------------------------------------------------------------------

#include <windows.h>
#include <widewrap.h>
#include <longname.h>

#define ARGUMENT_PRESENT(p) ((p) != NULL)

//+---------------------------------------------------------------------------
//
//  Function:	IsLongComponent, public
//
//  Synopsis:	Determines whether the current path component is a legal
//              8.3 name or not.  If not, it is considered to be a long
//              component.
//
//  Arguments:	[pwcsPath] - Path to check
//              [ppwcsEnd] - Return for end of component pointer
//
//  Returns:	BOOL
//
//  Modifies:	[ppwcsEnd]
//
//  History:	28-Aug-94	DrewB	Created
//
//  Notes:      An empty path is considered to be long
//              The following characters are not valid in file name domain:
//              * + , : ; < = > ? [ ] |
//
//----------------------------------------------------------------------------

BOOL IsLongComponent(LPCWSTR pwcsPath,
                     PWSTR *ppwcsEnd)
{
    LPWSTR pwcEnd, pwcDot;
    BOOL fLongNameFound;
    WCHAR wc;

    pwcEnd = (LPWSTR)pwcsPath;
    fLongNameFound = FALSE;
    pwcDot = NULL;

    while (TRUE)
    {
	wc = *pwcEnd;

	if (wc == L'\\' || wc == 0)
        {
            *ppwcsEnd = pwcEnd;

            // We're at a component terminator, so make the
            // determination of whether what we've seen is a long
            // name or short one

            // If we've aready seen illegal characters or invalid
            // structure for a short name, don't bother to check lengths
            if (pwcEnd-pwcsPath > 0 && !fLongNameFound)
            {
                // If this component fits in 8.3 then it is a short name
                if ((!pwcDot && (ULONG)(pwcEnd - pwcsPath) <= 8) ||
                    (pwcDot && ((ULONG)(pwcEnd - pwcDot) <= 3 + 1 &&
                                (ULONG)(pwcEnd - pwcsPath) <= 8 + 3 + 1)))
                {
                    return FALSE;
                }
            }

            return TRUE;
        }

        // Handle dots
	if (wc == L'.')
        {
	    // If two or more '.' or the base name is longer than
	    // 8 characters or no base name at all, it is an illegal dos
            // file name
            if (pwcDot != NULL ||
                ((ULONG)(pwcEnd - pwcsPath)) > 8 ||
                (pwcEnd == pwcsPath && *(pwcEnd + 1) != L'\\'))
            {
		fLongNameFound = TRUE;
            }

	    pwcDot = pwcEnd;
        }

        // Check for characters which aren't valid in short names
	else if (wc <= L' ' ||
                 wc == L'*' ||
                 wc == L'+' ||
                 wc == L',' ||
                 wc == L':' ||
                 wc == L';' ||
                 wc == L'<' ||
                 wc == L'=' ||
                 wc == L'>' ||
                 wc == L'?' ||
                 wc == L'[' ||
                 wc == L']' ||
                 wc == L'|')
        {
	    fLongNameFound = TRUE;
        }

	pwcEnd++;
    }
}

//
// The following code was stolen from NT's RTL in curdir.c
//

#define IS_PATH_SEPARATOR(wch) \
    ((wch) == L'\\' || (wch) == L'/')

typedef enum
{
    PATH_TYPE_UNKNOWN,
    PATH_TYPE_UNC_ABSOLUTE,
    PATH_TYPE_LOCAL_DEVICE,
    PATH_TYPE_ROOT_LOCAL_DEVICE,
    PATH_TYPE_DRIVE_ABSOLUTE,
    PATH_TYPE_DRIVE_RELATIVE,
    PATH_TYPE_ROOTED,
    PATH_TYPE_RELATIVE
} PATH_TYPE;

PATH_TYPE
DetermineDosPathNameType(
    IN PCWSTR DosFileName
    )

/*++

Routine Description:

    This function examines the Dos format file name and determines the
    type of file name (i.e.  UNC, DriveAbsolute, Current Directory
    rooted, or Relative.

Arguments:

    DosFileName - Supplies the Dos format file name whose type is to be
        determined.

Return Value:

    PATH_TYPE_UNKNOWN - The path type can not be determined

    PATH_TYPE_UNC_ABSOLUTE - The path specifies a Unc absolute path
        in the format \\server-name\sharename\rest-of-path

    PATH_TYPE_LOCAL_DEVICE - The path specifies a local device in the format
        \\.\rest-of-path this can be used for any device where the nt and
        Win32 names are the same. For example mailslots.

    PATH_TYPE_ROOT_LOCAL_DEVICE - The path specifies the root of the local
        devices in the format \\.

    PATH_TYPE_DRIVE_ABSOLUTE - The path specifies a drive letter absolute
        path in the form drive:\rest-of-path

    PATH_TYPE_DRIVE_RELATIVE - The path specifies a drive letter relative
        path in the form drive:rest-of-path

    PATH_TYPE_ROOTED - The path is rooted relative to the current disk
        designator (either Unc disk, or drive). The form is \rest-of-path.

    PATH_TYPE_RELATIVE - The path is relative (i.e. not absolute or rooted).

--*/

{
    PATH_TYPE ReturnValue;

    if ( IS_PATH_SEPARATOR(*DosFileName) )
    {
        if ( IS_PATH_SEPARATOR(*(DosFileName+1)) )
        {
            if ( DosFileName[2] == L'.' )
            {
                if ( IS_PATH_SEPARATOR(*(DosFileName+3)) )
                {
                    ReturnValue = PATH_TYPE_LOCAL_DEVICE;
                }
                else if ( (*(DosFileName+3)) == 0 )
                {
                    ReturnValue = PATH_TYPE_ROOT_LOCAL_DEVICE;
                }
                else
                {
                    ReturnValue = PATH_TYPE_UNC_ABSOLUTE;
                }
            }
            else
            {
                ReturnValue = PATH_TYPE_UNC_ABSOLUTE;
            }
        }
        else
        {
            ReturnValue = PATH_TYPE_ROOTED;
        }
    }
    else if (*(DosFileName+1) == L':')
    {
        if (IS_PATH_SEPARATOR(*(DosFileName+2)))
        {
            ReturnValue = PATH_TYPE_DRIVE_ABSOLUTE;
        }
        else
        {
            ReturnValue = PATH_TYPE_DRIVE_RELATIVE;
        }
    }
    else
    {
        ReturnValue = PATH_TYPE_RELATIVE;
    }

    return ReturnValue;
}

//+---------------------------------------------------------------------------
//
//  Function:	GetLongPathName, public
//
//  Synopsis:	Expand each component of the given path into its
//              long form
//
//  Arguments:	[pwcsPath] - Path
//              [pwcsLongPath] - Long path return buffer
//              [cchLongPath] - Size of return buffer
//
//  Returns:	0 for errors
//              Number of characters needed for buffer if buffer is too small
//                includes NULL terminator
//              Length of long path, doesn't include NULL terminator
//
//  Modifies:	[pwcsLongPath]
//
//  History:	28-Aug-94	DrewB	Created
//
//  Notes:	The source and destination buffers can be the same memory
//              Doesn't handle paths with internal . and .., although
//              they are handled at the beginning
//
//----------------------------------------------------------------------------

ULONG
APIENTRY
GetLongPathNameW(LPCWSTR pwcsPath,
                 LPWSTR  pwcsLongPath,
                 ULONG   cchLongPath)
{
    PATH_TYPE pt;
    HANDLE h;
    LPWSTR pwcsLocalLongPath;
    ULONG cchReturn, cb, cch, cchOutput;
    LPWSTR pwcStart, pwcEnd;
    LPWSTR pwcLong;
    WCHAR wcSave;
    BOOL fLong;
    WIN32_FIND_DATA wfd;

    cchReturn = 0;
    pwcsLocalLongPath = NULL;


    if (!ARGUMENT_PRESENT(pwcsPath))
    {
	return 0;
    }

    try
    {
	// Decide the path type, we want find out the position of
	// the first character of the first name
        pt = DetermineDosPathNameType(pwcsPath);
	switch(pt)
        {
	    // Form: "\\server_name\share_name\rest_of_the_path"
        case PATH_TYPE_UNC_ABSOLUTE:
            if ((pwcStart = wcschr(pwcsPath + 2, L'\\')) != NULL &&
                (pwcStart = wcschr(pwcStart + 1, L'\\')) != NULL)
            {
                pwcStart++;
            }
            else
            {
                pwcStart = NULL;
            }
            break;

	    // Form: "\\.\rest_of_the_path"
        case PATH_TYPE_LOCAL_DEVICE:
            pwcStart = (LPWSTR)pwcsPath + 4;
            break;

	    // Form: "\\."
        case PATH_TYPE_ROOT_LOCAL_DEVICE:
            pwcStart = NULL;
            break;

	    // Form: "D:\rest_of_the_path"
        case PATH_TYPE_DRIVE_ABSOLUTE:
            pwcStart = (LPWSTR)pwcsPath + 3;
            break;

	    // Form: "rest_of_the_path"
        case PATH_TYPE_RELATIVE:
            pwcStart = (LPWSTR) pwcsPath;
            goto EatDots;

	    // Form: "D:rest_of_the_path"
        case PATH_TYPE_DRIVE_RELATIVE:
            pwcStart = (LPWSTR)pwcsPath+2;

        EatDots:
            // Handle .\ and ..\ cases
            while (*pwcStart != 0 && *pwcStart == L'.')
            {
                if (pwcStart[1] == L'\\')
                {
                    pwcStart += 2;
                }
                else if (pwcStart[1] == L'.' && pwcStart[2] == L'\\')
                {
                    pwcStart += 3;
                }
                else
                {
                    break;
                }
            }
            break;

	    // Form: "\rest_of_the_path"
        case PATH_TYPE_ROOTED:
            pwcStart = (LPWSTR)pwcsPath + 1;
            break;

        default:
            pwcStart = NULL;
            break;
        }

        // In the special case where we have no work to do, exit quickly
        // This saves a lot of instructions for trivial cases
        // In one case the path as given requires no processing
        // In the other, the path only has one component and it is already
        // long
	if (pwcStart == NULL ||
            ((fLong = IsLongComponent(pwcStart, &pwcEnd)) &&
             *pwcEnd == 0))
        {
	    // Nothing to convert, copy down the source string
	    // to the buffer if necessary

	    if (pwcStart == NULL)
            {
                cch = lstrlenW(pwcsPath) + 1;
            }
	    else
            {
                cch = (ULONG)(pwcEnd - pwcsPath + 1);
            }

            if (cchLongPath >= cch)
            {
                // If there's an output buffer which is different from
                // the input buffer, fill it in
                if (ARGUMENT_PRESENT(pwcsLongPath) &&
                    pwcsLongPath != pwcsPath)
                {
                    memcpy(pwcsLongPath, pwcsPath, cch * sizeof(WCHAR));
                }

                cchReturn = cch - 1;
                goto gsnTryExit;
            }
            else
            {
                cchReturn = cch;
                goto gsnTryExit;
            }
        }

	// Make a local buffer so that we won't overlap the
	// source pathname in case the long name is longer than the
	// source name.
        if (cchLongPath > 0 && ARGUMENT_PRESENT(pwcsLongPath))
        {
	    pwcsLocalLongPath = (PWCHAR)CoTaskMemAlloc(cchLongPath * sizeof(WCHAR));
            if (pwcsLocalLongPath == NULL)
            {
                goto gsnTryExit;
	    }
        }

        // Set up pointer to copy output to
        pwcLong = pwcsLocalLongPath;
        cchOutput = 0;

        // Copy the portions of the path that we skipped initially
        cch = pwcStart-pwcsPath;
        cchOutput += cch;
        if (cchOutput <= cchLongPath && ARGUMENT_PRESENT(pwcsLongPath))
        {
            memcpy(pwcLong, pwcsPath, cch*sizeof(WCHAR));
            pwcLong += cch;
        }

        for (;;)
        {
            // Determine whether the current component is long or short
            cch = pwcEnd-pwcStart+1;
            cb = cch*sizeof(WCHAR);

            if (fLong)
            {
                // If the component is already long, just copy it into
                // the output.  Copy the terminating character along with it
                // so the output remains properly punctuated

                cchOutput += cch;
                if (cchOutput <= cchLongPath && ARGUMENT_PRESENT(pwcsLongPath))
                {
                    memcpy(pwcLong, pwcStart, cb);
                    pwcLong += cch;
                }
            }
            else
            {
                // For a short component we need to determine the
                // long name, if there is one.  The only way to
                // do this reliably is to enumerate for the child

                wcSave = *pwcEnd;
                *pwcEnd = 0;

                h = FindFirstFile(pwcsPath, &wfd);

                *pwcEnd = wcSave;

                if (h == INVALID_HANDLE_VALUE)
                {
                    goto gsnTryExit;
                }

                FindClose(h);

                // Copy the filename returned by the query into the output
                // Copy the terminator from the original component into
                // the output to maintain punctuation
                cch = lstrlenW(wfd.cFileName)+1;
                cchOutput += cch;
                if (cchOutput <= cchLongPath && ARGUMENT_PRESENT(pwcsLongPath))
                {
                    memcpy(pwcLong, wfd.cFileName, (cch-1)*sizeof(WCHAR));
                    pwcLong += cch;
                    *(pwcLong-1) = *pwcEnd;
                }
            }

            if (*pwcEnd == 0)
            {
                break;
            }

            // Update start pointer to next component
            pwcStart = pwcEnd+1;
            fLong = IsLongComponent(pwcStart, &pwcEnd);
        }

        // Copy local output buffer to given output buffer if necessary
        if (cchLongPath >= cchOutput && ARGUMENT_PRESENT(pwcsLongPath))
        {
            memcpy(pwcsLongPath, pwcsLocalLongPath, cchOutput * sizeof(WCHAR));
            cchReturn = cchOutput-1;
        }
	else
        {
            cchReturn = cchOutput;
        }

gsnTryExit:;
    }
    finally
    {
        if (pwcsLocalLongPath != NULL)
        {
	    CoTaskMemfree(pwcsLocalLongPath);
            pwcsLocalLongPath = NULL;
        }
    }

    return cchReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\coll\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=   coll
TARGETPATH=   obj
TARGETTYPE=   LIBRARY

INCLUDES=     ..\..\..\common\$(DEST_TREE);..\..\..\ih;..\..\inc
INCLUDES=     $(INCLUDES);..\..\..\idl\public\$(DEST_TREE)\$(O);
INCLUDES=     $(INCLUDES);..\..\..\idl\internal\$(DEST_TREE)\$(O);
INCLUDES=     $(INCLUDES);..\..\..\idl\private\$(DEST_TREE)\$(O);
INCLUDES=     $(INCLUDES);$(BASE_INC_PATH)

C_DEFINES=    \
              $(C_DEFINES)          \


SOURCES=      \
              ..\array_fv.cxx

UMTYPE=       windows

!include ..\..\precomp2.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\coll\plex.cxx ===
// This is a part of the Microsoft Foundation Classes C++ library. 
// Copyright (C) 1992 Microsoft Corporation 
// All rights reserved. 
//  
// This source code is only intended as a supplement to the 
// Microsoft Foundation Classes Reference and Microsoft 
// QuickHelp documentation provided with the library. 
// See these sources for detailed information regarding the 
// Microsoft Foundation Classes product. 

#include <ole2int.h>
//#include <compobj.seg>
#pragma SEG(plex)

#include "plex.h"
ASSERTDATA

// Collection support
#ifdef OLE_COLL_SEG
#pragma code_seg(OLE_COLL_SEG)
#endif


#pragma SEG(CPlex_Create)  
CPlex FAR* CPlex::Create(CPlex FAR* FAR& pHead, DWORD mp, UINT nMax, UINT cbElement)
{
	CairoleAssert(nMax > 0 && cbElement > 0);
	CPlex FAR* p = (CPlex FAR*)CoMemAlloc(sizeof(CPlex) + nMax * cbElement, mp, NULL);
	if (p == NULL)
		return NULL;

	p->nMax = nMax;
	p->nCur = 0;
	p->pNext = pHead;
	pHead = p;  // change head (adds in reverse order for simplicity)
	return p;
}

#pragma SEG(CPlex_FreeDataChain)  
void CPlex::FreeDataChain(DWORD mp)     // free this one and links
{
    CPlex FAR* pThis;
    CPlex FAR* pNext;

    for (pThis = this; pThis != NULL; pThis = pNext) {
        pNext = pThis->pNext;
        pThis->pNext = NULL; // So compiler won't do nasty optimizations
		CoMemFree(pThis, mp);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\coll\array_fv.cxx ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1994.
//
//  File:       d:\nt\private\cairole\com\coll\array_fv.cxx
//
//  Contents:   Implementation of Array of values
//
//  Classes:    CArrayFValue
//
//  Functions:  CArrayFValue::CArrayFValue
//              CArrayFValue::~CArrayFValue
//              CArrayFValue::SetSize
//              CArrayFValue::FreeExtra
//              CArrayFValue::_GetAt
//              CArrayFValue::SetAt
//              CArrayFValue::SetAtGrow
//              CArrayFValue::InsertAt
//              CArrayFValue::RemoveAt
//              CArrayFValue::IndexOf
//              CArrayFValue::AssertValid
//
//  History:    26-Jul-94   BruceMa    Created this file header
//              26-Jul-94   BruceMa    Memory sift fix
//
//----------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
// NOTE: we allocate an array of 'm_nMaxSize' elements, but only
//  the current size 'm_nSize' contains properly initialized elements

#include <ole2int.h>
//#include <compobj.seg>
#pragma SEG(array_fv)
ASSERTDATA

#include "valid.h"
#include "array_fv.h"

#include <limits.h>
#define SIZE_T_MAX  UINT_MAX            /* max size for a size_t */


/////////////////////////////////////////////////////////////////////////////

#pragma SEG(CArrayFValue_ctor)
CArrayFValue::CArrayFValue(UINT cbValue)
{
	m_pData = NULL;
	m_cbValue = cbValue;
	m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

#pragma SEG(CArrayFValue_dtor)
CArrayFValue::~CArrayFValue()
{
	ASSERT_VALID(this);

	PrivMemFree(m_pData);
}

// set new size; return FALSE if OOM

#pragma SEG(CArrayFValue_SetSize)
BOOL CArrayFValue::SetSize(int nNewSize, int nGrowBy /* = -1 */)
{
	ASSERT_VALID(this);
	Assert(nNewSize >= 0);

	if (nGrowBy != -1)
		m_nGrowBy = nGrowBy;    // set new size

	if (nNewSize == 0)
	{
		// shrink to nothing
		PrivMemFree(m_pData);
		m_pData = NULL;
		m_nSize = m_nMaxSize = 0;
	}
	else if (m_pData == NULL)
	{
		// create one with exact size
		Assert((long)nNewSize * m_cbValue <= SIZE_T_MAX);    // no overflow

		m_pData = (BYTE FAR*)PrivMemAlloc(nNewSize * m_cbValue);
		if (m_pData == NULL)
                {
                    m_nSize = m_nMaxSize = 0;
                    return FALSE;
                }

		memset(m_pData, 0, nNewSize * m_cbValue);        // zero fill
		m_nSize = m_nMaxSize = nNewSize;
	}
	else if (nNewSize <= m_nMaxSize)
	{
		// it fits
		if (nNewSize > m_nSize)
		{
			// initialize the new elements
			memset(&m_pData[m_nSize * m_cbValue], 0, (nNewSize-m_nSize) * m_cbValue);
		}
		m_nSize = nNewSize;
	}
	else
	{
		// Otherwise grow array
		int nNewMax;
		if (nNewSize < m_nMaxSize + m_nGrowBy)
			nNewMax = m_nMaxSize + m_nGrowBy;   // granularity
		else
			nNewMax = nNewSize; // no slush

		Assert((long)nNewMax * m_cbValue <= SIZE_T_MAX); // no overflow

		BYTE FAR* pNewData = (BYTE FAR*)PrivMemAlloc(nNewMax * m_cbValue);
		if (pNewData == NULL)
			return FALSE;

		// copy new data from old
		memcpy(pNewData, m_pData, m_nSize * m_cbValue);

		// construct remaining elements
		Assert(nNewSize > m_nSize);
		memset(&pNewData[m_nSize * m_cbValue], 0, (nNewSize-m_nSize) * m_cbValue);

		// get rid of old stuff (note: no destructors called)
		PrivMemFree(m_pData);
		m_pData = pNewData;
		m_nSize = nNewSize;
		m_nMaxSize = nNewMax;
	}
	ASSERT_VALID(this);

	return TRUE;
}

#pragma SEG(CArrayFValue_FreeExtra)
void CArrayFValue::FreeExtra()
{
	ASSERT_VALID(this);

	if (m_nSize != m_nMaxSize)
	{
		// shrink to desired size
		Assert((long)m_nSize * m_cbValue <= SIZE_T_MAX); // no overflow

		BYTE FAR* pNewData = (BYTE FAR*)PrivMemAlloc(m_nSize * m_cbValue);
		if (pNewData == NULL)
			return;					// can't shrink; don't to anything

		// copy new data from old
		memcpy(pNewData, m_pData, m_nSize * m_cbValue);

		// get rid of old stuff (note: no destructors called)
		PrivMemFree(m_pData);
		m_pData = pNewData;
		m_nMaxSize = m_nSize;
	}
	ASSERT_VALID(this);
}

/////////////////////////////////////////////////////////////////////////////

#pragma SEG(CArrayFValue__GetAt)
LPVOID CArrayFValue::_GetAt(int nIndex) const
{
	ASSERT_VALID(this);
	Assert(nIndex >= 0 && nIndex < m_nSize);
	return &m_pData[nIndex * m_cbValue];
}

#pragma SEG(CArrayFValue_SetAt)
void CArrayFValue::SetAt(int nIndex, LPVOID pValue)
{
	ASSERT_VALID(this);
	Assert(nIndex >= 0 && nIndex < m_nSize);

	memcpy(&m_pData[nIndex * m_cbValue], pValue, m_cbValue);
}

#pragma SEG(CArrayFValue_SetAtGrow)
BOOL CArrayFValue::SetAtGrow(int nIndex, LPVOID pValue)
{
	ASSERT_VALID(this);
	Assert(nIndex >= 0);
	if (nIndex >= m_nSize && !SetSize(nIndex+1))
		return FALSE;

	SetAt(nIndex, pValue);

	return TRUE;
}

#pragma SEG(CArrayFValue_InsertAt)
BOOL CArrayFValue::InsertAt(int nIndex, LPVOID pValue, int nCount /*=1*/)
{
	ASSERT_VALID(this);
	Assert(nIndex >= 0);        // will expand to meet need
	Assert(nCount > 0);     // zero or negative size not allowed

	if (nIndex >= m_nSize)
	{
		// adding after the end of the array
		if (!SetSize(nIndex + nCount))       // grow so nIndex is valid
			return FALSE;
	}
	else
	{
		// inserting in the middle of the array
		int nOldSize = m_nSize;
		if (!SetSize(m_nSize + nCount)) // grow it to new size
			return FALSE;

		// shift old data up to fill gap
		memmove(&m_pData[(nIndex+nCount) * m_cbValue],
			&m_pData[nIndex * m_cbValue],
			(nOldSize-nIndex) * m_cbValue);

		// re-init slots we copied from
		memset(&m_pData[nIndex * m_cbValue], 0, nCount * m_cbValue);
	}

	// insert new value in the gap
	Assert(nIndex + nCount <= m_nSize);
	while (nCount--)
		memcpy(&m_pData[nIndex++ * m_cbValue], pValue, m_cbValue);

	ASSERT_VALID(this);

	return TRUE;
}

#pragma SEG(CArrayFValue_RemoveAt)
void CArrayFValue::RemoveAt(int nIndex, int nCount /* = 1 */)
{
	ASSERT_VALID(this);
	Assert(nIndex >= 0);
	Assert(nIndex < m_nSize);
	Assert(nCount >= 0);
	Assert(nIndex + nCount <= m_nSize);

	// just remove a range
	int nMoveCount = m_nSize - (nIndex + nCount);
	if (nMoveCount)
		memcpy(&m_pData[nIndex * m_cbValue],
			&m_pData[(nIndex + nCount) * m_cbValue],
			nMoveCount * m_cbValue);
	m_nSize -= nCount;
}


/////////////////////////////////////////////////////////////////////////////


#pragma SEG(CArrayFValue_IndexOf)
// find element given part of one; offset is offset into value; returns
// -1 if element not found; use IndexOf(NULL, cb, offset) to find zeros;
// will be optimized for appropriate value size and param combinations
int CArrayFValue::IndexOf(LPVOID pData, UINT cbData, UINT offset)
{
	Assert(offset <= m_cbValue);
	Assert(cbData <= m_cbValue);
	Assert((long)offset + cbData <= m_cbValue);
	Assert(IsValidReadPtrIn(pData, cbData));

#ifdef LATER
	if (cbData == sizeof(WORD) && m_cbValue == sizeof(WORD))
	{
		int iwRet;
		_asm
		{
			push di
			les di,pData			;* get value
			mov ax,es:[di]			;*    from *(WORD FAR*)pData
			les di,this
			mov cx,[di].m_nSize		;* get size (in WORDs) of array
			les di,[di].m_pData		;* get ptr to WORD array
			repne scasw				;* look for *(WORD FAR*)pData
			jeq retcx				;* brif found
			xor cx,cx				;* return -1
		retcx:
			dec cx
			mov iwRet,cx
			pop di
		}

		return iwRet;
	}
#endif
	BYTE FAR* pCompare = m_pData + offset;	// points to the value to compare
	int nIndex = 0;

	if (cbData == sizeof(WORD)) {
		for (; nIndex < m_nSize; pCompare += m_cbValue, nIndex++)
		{
			if (*(WORD FAR*)pCompare == *(WORD FAR*)pData)
				return nIndex;
		}
	} else if (cbData == sizeof(LONG)) {
		for (; nIndex < m_nSize; pCompare += m_cbValue, nIndex++)
		{
			if (*(LONG FAR*)pCompare == *(LONG FAR*)pData)
				return nIndex;
		}
	} else {
		for (; nIndex < m_nSize; pCompare += m_cbValue, nIndex++)
		{
			if (memcmp(pCompare, pData, cbData) == 0)
				return nIndex;
		}
	}

	return -1;
}


/////////////////////////////////////////////////////////////////////////////


#pragma SEG(CArrayFValue_AssertValid)
void CArrayFValue::AssertValid() const
{
#ifdef _DEBUG
	if (m_pData == NULL)
	{
		Assert(m_nSize == 0);
		Assert(m_nMaxSize == 0);
	}
	else
	{
		Assert(m_nSize <= m_nMaxSize);
		Assert((long)m_nMaxSize * m_cbValue <= SIZE_T_MAX);    // no overflow
		Assert(IsValidReadPtrIn(m_pData, m_nMaxSize * m_cbValue));
	}

	// some collections live as global variables in the libraries, but
	// have their existance in some context.  Also, we can't check shared
	// collections since we might be checking the etask collection
	// which would cause an infinite recursion.
#endif //_DEBUG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dcomrem\aprtmnt.cxx ===
//+----------------------------------------------------------------------------
//
//  File:       aprtmnt.cxx
//
//  Contents:   Maintains per-apartment state.
//
//  Classes:    CComApartment
//
//  History:    25-Feb-98   Johnstra      Created
//
//-----------------------------------------------------------------------------
#include <ole2int.h>
#include "locks.hxx"    // LOCK macros
#include "aprtmnt.hxx"  // class definition
#include "resolver.hxx" // gLocalMID
#include "remoteu.hxx"  // CRemoteUnknown


// STA apartments are chained off of TLS.
CComApartment* gpMTAApartment = NULL;   // global MTA Apartment
CComApartment* gpNTAApartment = NULL;   // global NTA Apartment


// count of multi-threaded apartment inits (see CoInitializeEx)
extern DWORD g_cMTAInits;


//+-------------------------------------------------------------------
//
//  Function:   GetCurrentComApartment, public
//
//  Synopsis:   Gets the CComApartment object of the current apartment
//
//  History:    26-Oct-98   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT GetCurrentComApartment(CComApartment **ppComApt)
{
    ComDebOut((DEB_OXID,"GetCurrentComApartment ppComApt:%x\n", ppComApt));
    *ppComApt = NULL;

    HRESULT hr;
    COleTls tls(hr);

    if (SUCCEEDED(hr))
    {
        APTKIND AptKind = GetCurrentApartmentKind(tls);
        switch (AptKind)
        {
        case APTKIND_MULTITHREADED :
            *ppComApt = gpMTAApartment;
            break;

        case APTKIND_NEUTRALTHREADED :
            *ppComApt = gpNTAApartment;
            break;

        case APTKIND_APARTMENTTHREADED :
            *ppComApt = tls->pNativeApt;
            break;

        default:
            Win4Assert(*ppComApt == NULL);
            break;
        }

        if (*ppComApt)
        {
            (*ppComApt)->AddRef();
            (*ppComApt)->AssertValid();
            hr = S_OK;
        }
        else
        {
            hr = CO_E_NOTINITIALIZED;
        }
    }

    ComDebOut((DEB_OXID,"GetCurrentComApartment hr:%x pComApt:%x\n", hr, *ppComApt));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Method:     IUnknown methods
//
//  Synopsis:   Clean up the native apartment object for the thread.
//
//  History:    20-Feb-98   Johnstra      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CComApartment::QueryInterface(REFIID riid, void **ppv)
{
    if (riid == IID_IUnknown)
    {
        *ppv = this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    ((IUnknown*)*ppv)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) CComApartment::AddRef()
{
    return InterlockedIncrement((LONG *) &_cRefs);
}

STDMETHODIMP_(ULONG) CComApartment::Release()
{
    ULONG refs = InterlockedDecrement((LONG *) &_cRefs);
    if (refs == 0)
    {
        delete this;
    }
    return refs;
}

//+-------------------------------------------------------------------
//
//  Method:     CComApartment::GetRemUnk, Public
//
//  Synopsis:   Obtains the RemUnk proxy for the apartment
//
//  History:    30-Jun-98   GopalK       Created
//
//+-------------------------------------------------------------------
HRESULT CComApartment::GetRemUnk(IRemUnknownN **ppRemUnk)
{
    ComDebOut((DEB_OXID,"CComApartment::GetRemUnk this:%x\n", this));
    ASSERT_LOCK_NOT_HELD(gOXIDLock);

    HRESULT hr;

    *ppRemUnk = NULL;

    // Check if the apartment is still valid
    if (IsInited() && !IsStopPending())
    {
        ASSERT_LOCK_NOT_HELD(gOXIDLock);
        LOCK(gOXIDLock);
        ASSERT_LOCK_HELD(gOXIDLock);

        OXIDEntry* pOXID = _pOXIDEntry;
        if(NULL == pOXID)
        {
            UNLOCK(gOXIDLock);
            hr = RPC_E_DISCONNECTED;
            goto Cleanup;
        }

        AssertValid();
        
        // Stabilize OXID entry
        pOXID->IncRefCnt();

        ASSERT_LOCK_HELD(gOXIDLock);
        UNLOCK(gOXIDLock);
        ASSERT_LOCK_NOT_HELD(gOXIDLock);

        // Get the RemUnk proxy from OXID entry
        hr = pOXID->GetRemUnk((IRemUnknown **) ppRemUnk);
        if(SUCCEEDED(hr))
            (*ppRemUnk)->AddRef();
        else
            *ppRemUnk = NULL;

        // Fixup the refcount on OXID entry
        pOXID->DecRefCnt();
    }
    else
    {
        hr = RPC_E_DISCONNECTED;
    }

Cleanup:
    
    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    ComDebOut((DEB_OXID,"CComApartment::GetRemUnk hr:%x pRemUnk:%x\n", hr, *ppRemUnk));
    return(hr);
}

//+--------------------------------------------------------------------------
//
//  Member:     CComApartment::GetPreRegMOID, public
//
//  Synopsis:   Get an OID that has been pre-registered with the Ping
//              Server for this apartment.
//
//  Parameters: [pmoid] - where to return the OID
//
//  History:    06-Nov-95   Rickhi      Created.
//              02-Nov-98   Rickhi      Moved from resolver code.
//
//  Notes: careful. The oids are dispensed in reverse order [n]-->[0], so the
//         unused ones are from [0]-->[cPreRegOidsAvail-1]. CanRundownOID
//         depends on this behavior.
//
//----------------------------------------------------------------------------
HRESULT CComApartment::GetPreRegMOID(MOID *pmoid)
{
    ComDebOut((DEB_OXID,"CComApartment::GetPreRegMOID this:%x\n", this));
    AssertValid();

    // CODEWORK:
    // sometimes the NTA is not initialized because we call InitChannel while
    // in the STA/MTA, then switch to the NTA to do some work. For example,
    // CoGetStandardMarshal does this. This should be fixed and the NTA init
    // done in InitChannelIfNecessary.

    HRESULT hr = InitRemoting();
    if (FAILED(hr))
        return hr;

    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    LOCK(gOXIDLock);

    if (_cPreRegOidsAvail == 0)
    {
        // wait until no other threads are calling ServerAllocOIDs
        hr = WaitForAccess();

        if (SUCCEEDED(hr))
        {
            // have exclusive access now, check the count again.
            if (_cPreRegOidsAvail == 0)
            {
                // still none, need to really go get more.
                hr = CallTheResolver();
            }

            // wakeup any threads waiting for access to this code
            CheckForWaiters();
        }
    }

    // Careful here.  CallTheResolver can return success even
    // when rpcss failed to allocate even one new oid.   
    if (SUCCEEDED(hr) && (_cPreRegOidsAvail > 0))
    {
        // take the next available OID
        Win4Assert(_cPreRegOidsAvail <= MAX_PREREGISTERED_OIDS);
        _cPreRegOidsAvail--;
        MOIDFromOIDAndMID(_arPreRegOids[_cPreRegOidsAvail], gLocalMid, pmoid);

        // mark it so we know it is taken (helps debugging) by turning on high bit.
        _arPreRegOids[_cPreRegOidsAvail] |= 0xf000000000000000;
    }
    else if (SUCCEEDED(hr))
    {
        // Don't have an oid to give back, even after all that work.  Bummer.
        Win4Assert(_cPreRegOidsAvail == 0);
        hr = E_OUTOFMEMORY;
    }

    UNLOCK(gOXIDLock);
    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    ComDebOut((DEB_OXID,"CComApartment::GetPreRegMOID hr:%x moid:%I\n", hr, pmoid));
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CComApartment::FreePreRegMOID, public
//
//  Synopsis:   Free an OID that has been pre-registered with the Ping
//              Server for this apartment. The Free'd OID will be returned
//              to the ping server so it can cleanup it's state.
//
//  Parameters: [rmoid] - MOID to return the OID
//
//  History:    10-Feb-99   Rickhi      Created.
//
//  Notes:      The list maintained by this code is used to tell the resolver
//              about OIDs that are no longer used. This list is also checked
//              by the Rundown thread. If the OID is in this list, it is OK
//              to rundown, and it will be removed from the list at that time.
//              By returning OIDs to the resolver in a timely fashion, we can
//              reduce memory consumption in the resolver, and reduce and almost
//              eliminate calls to RundownOID.
//
//----------------------------------------------------------------------------
HRESULT CComApartment::FreePreRegMOID(REFMOID rmoid)
{
    ComDebOut((DEB_OXID,"CComApartment::FreePreRegMOID this:%x moid:%I\n",
              this, &rmoid));
    AssertValid();

    HRESULT hr = S_OK;
    OID oid;
    OIDFromMOID(rmoid, &oid);

    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    LOCK(gOXIDLock);

    while (_cOidsReturn >= MAX_PREREGISTERED_OIDS_RETURN)
    {
        // no space in the list, go call the resolver to free
        // up space in the list. Note that we release the lock
        // over this call, so it is possible some other thread
        // adds more entries to the list and fills it up before
        // we return, hence the loop.

        // wait until no other threads are calling the resolver
        // for this apartment.
        hr = WaitForAccess();

        if (SUCCEEDED(hr))
        {
            // have exclusive access now, check the count again.
            if (_cOidsReturn >= MAX_PREREGISTERED_OIDS_RETURN)
            {
                // still no room, need to really go free some more.
                hr = CallTheResolver();
            }

            // wakeup any threads waiting for access to this code
            CheckForWaiters();
        }

        if (FAILED(hr))
            break;
    }

    if (_cOidsReturn < MAX_PREREGISTERED_OIDS_RETURN)
    {
#if DBG==1
        // make sure there are no duplicates
        for (ULONG i=0; i<_cOidsReturn; i++)
            Win4Assert(_arOidsReturn[i] != oid);
#endif

        // add the OID to the list
        _arOidsReturn[_cOidsReturn++] = oid;
    }

    UNLOCK(gOXIDLock);
    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    ComDebOut((DEB_OXID,"CComApartment::FreePreRegMOID hr:%x _cOidsReturn:%x\n",
              hr, _cOidsReturn));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CComApartment::CanRundownOID, public
//
//  Synopsis:   Determine if OK to rundown the specified OID.
//
//  History:    06-Nov-95   Rickhi      Created.
//              02-Nov-98   Rickhi      Moved from resolver code.
//
//--------------------------------------------------------------------
void CComApartment::CanRundownOIDs(ULONG cOids, OID arOid[],
                                   RUNDOWN_RESULT arResult[])
{
    ComDebOut((DEB_OXID,
        "CComApartment::CanRundownOIDs this:%x cOids:%x arOid:%x arRes:%x\n",
        this, cOids, arOid, arResult));
    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    LOCK(gOXIDLock);
    AssertValid();

    for (ULONG i=0; i<cOids; i++)
    {
        if (IsOidInPreRegList(arOid[i]))
        {
            // found the OID still in the pre-reg list.
            // although we could keep it incase we have to hand another
            // one out in the future, we'll actually return it in order
            // to quiet down the system and prevent future calls to Rundown.
            arResult[i] = RUNDWN_RUNDOWN;
        }
        else if (IsOidInReturnList(arOid[i]))
        {
            // found the OID in the return list. We're done with
            // this oid so OK to rundown.
            arResult[i] = RUNDWN_RUNDOWN;
        }
        else
        {
            // OID is not in any of our lists. We don't know that state
            // of it.
            arResult[i] = RUNDWN_UNKNOWN;
        }
    }

    UNLOCK(gOXIDLock);
    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    return;
}

//+-------------------------------------------------------------------
//
//  Member:     CComApartment::WaitForAccess, private
//
//  Synopsis:   waits until there are no threads allocting OIDs in this
//              apartment.
//
//  History:    06-Nov-95   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT CComApartment::WaitForAccess()
{
    ASSERT_LOCK_HELD(gOXIDLock);

    if (_dwState & APTFLAG_REGISTERINGOIDS)
    {
        // some other thread is busy registering OIDs for this OXID
        // so lets wait for it to finish. This should only happen in
        // the MTA apartment.
        Win4Assert(IsMTAThread() || IsThreadInNTA());

        if (_hEventOID == NULL)
        {
            _hEventOID = CreateEvent(NULL, FALSE, FALSE, NULL);
            if (_hEventOID == NULL)
            {
                return HRESULT_FROM_WIN32(GetLastError());
            }
        }

        // count one more waiter
        _cWaiters++;

        do
        {
            // release the lock before we block so the other thread can wake
            // us up when it returns.
            UNLOCK(gOXIDLock);
            ASSERT_LOCK_NOT_HELD(gOXIDLock);

            ComDebOut((DEB_WARN,"WaitForOXIDEntry wait on hEvent:%x\n", _hEventOID));
            DWORD rc = WaitForSingleObject(_hEventOID, INFINITE);
            Win4Assert(rc == WAIT_OBJECT_0);

            ASSERT_LOCK_NOT_HELD(gOXIDLock);
            LOCK(gOXIDLock);

        } while (_dwState & APTFLAG_REGISTERINGOIDS);

        // one less waiter
        _cWaiters--;
    }

    // mark the entry as busy by us
    _dwState |= APTFLAG_REGISTERINGOIDS;

    ASSERT_LOCK_HELD(gOXIDLock);
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CComApartment::CheckForWaiters, private
//
//  Synopsis:   wakes up any threads waiting to get an OID for this
//              apartment.
//
//  History:    06-Nov-95   Rickhi      Created.
//
//--------------------------------------------------------------------
void CComApartment::CheckForWaiters()
{
    ASSERT_LOCK_HELD(gOXIDLock);

    if (_cWaiters > 0)
    {
        // some other thread is busy waiting for the current thread to
        // finish registering so signal him that we are done.

        Win4Assert(_hEventOID != NULL);
        ComDebOut((DEB_TRACE,"CheckForWaiters signalling hEvent:%x\n", _hEventOID));
        SetEvent(_hEventOID);
    }

    // mark the entry as no longer busy by us
    _dwState &= ~APTFLAG_REGISTERINGOIDS;

    ASSERT_LOCK_HELD(gOXIDLock);
}

//+-------------------------------------------------------------------
//
//  Member:     CComApartment::CallTheResolver, private
//
//  Synopsis:   calls the resolver to return the OIDs in the Return list,
//              and allocate more OIDs for the PreReg list.
//
//  History:    10-Feb-99   Rickhi      Created from other pieces.
//
//--------------------------------------------------------------------
HRESULT CComApartment::CallTheResolver()
{
    ComDebOut((DEB_OXID,
        "CComApartment::CallTheResolver this:%x cToFree:%x cToAlloc:%x\n",
        this, _cOidsReturn, MAX_PREREGISTERED_OIDS - _cPreRegOidsAvail));
    AssertValid();
    Win4Assert(_pOXIDEntry != NULL);
    ASSERT_LOCK_HELD(gOXIDLock);

    // Tell the resolver about the ones we are done with.
    ULONG cOidsReturn = _cOidsReturn;
    OID arOidsReturn[MAX_PREREGISTERED_OIDS_RETURN];
    memcpy(arOidsReturn, _arOidsReturn, _cOidsReturn * sizeof(OID));
    _cOidsReturn = 0;

    // make up a list of pre-registered OIDs on our stack. Allocate only
    // enough to fill up the available space in the list.
    ULONG cOidsAlloc = MAX_PREREGISTERED_OIDS - _cPreRegOidsAvail;
    OID   arOidsAlloc[MAX_PREREGISTERED_OIDS];


    // we can safely release the lock now.
    UNLOCK(gOXIDLock);
    ASSERT_LOCK_NOT_HELD(gOXIDLock);

    // ask the OXIDEntry to go get more OIDs and release the ones
    // we are done with.
    HRESULT hr = CO_E_NOTINITIALIZED;
    if (_pOXIDEntry)
    {
        hr = _pOXIDEntry->AllocOIDs(&cOidsAlloc, arOidsAlloc,
                                    cOidsReturn, arOidsReturn);
    }

    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    LOCK(gOXIDLock);

    if (SUCCEEDED(hr))
    {
        // copy the newly created OIDs into the list.
        ULONG cOidsCopy = min(cOidsAlloc, MAX_PREREGISTERED_OIDS - _cPreRegOidsAvail);
        Win4Assert(cOidsCopy == cOidsAlloc);
        memcpy(_arPreRegOids + _cPreRegOidsAvail, arOidsAlloc, cOidsCopy * sizeof(OID));
        _cPreRegOidsAvail += cOidsAlloc;
    }

    ASSERT_LOCK_HELD(gOXIDLock);
    ComDebOut((DEB_OXID, "CComApartment::CallTheResolver hr%x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CComApartment::GetOXIDEntry, public
//
//  Synopsis:   Creates and/or returns the OXIDEntry for this apartment
//
//  History:    06-Nov-98   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT CComApartment::GetOXIDEntry(OXIDEntry **ppOXIDEntry)
{
    AssertValid();

    HRESULT hr = S_OK;
    if (_pOXIDEntry == NULL)
    {
        hr = InitRemoting();
        if (hr == S_FALSE)
        {
            hr = S_OK;
        }
    }

    *ppOXIDEntry = _pOXIDEntry;
    ComDebOut((DEB_OXID,"CComApartment::GetOXIDEntry this:%x hr:%x pOXIDEntry:%x\n",
              this, hr, *ppOXIDEntry));
    return hr;
}

//--------------------------------------------------------------------
//
//  Member:     CComApartment::InitRemoting, private
//
//  Synopsis:   Initialized the apartment for serving remote objects.
//
//  History:    02-Nov-98   Rickhi      Moved from channel init code.
//
//  Notes:      Marshalling the remote unknown causes recursion back to
//              this function.  The recursion is terminated because
//              GetLocalOXIDEntry is not NULL on the second call.
//
//              If there is a failure, whatever work-in-progress has
//              been completed is left alone and cleaned up later when
//              the apartment is uninitialized.
//
//--------------------------------------------------------------------
HRESULT CComApartment::InitRemoting()
{
    ComDebOut((DEB_OXID,"CComApartment::InitRemoting: this:%x [IN]\n", this));
    AssertValid();

    if (IsInited())
        // it is initialized already
        return S_OK;

    // handle re-entrancy on the same thread. Note that when we create the
    // CRemUnknown below, it calls back to InitRemoting, so we want to
    // pretend like InitRemoting has already completed.
    HRESULT hr;
    COleTls tls(hr);
    if (FAILED(hr))
        return hr;

    if ((tls->dwFlags & OLETLS_APTINITIALIZING))
        // it is already being initialized by the current thread.
        return S_FALSE;
    else
        // re-entrancy protection
        tls->dwFlags |= OLETLS_APTINITIALIZING;


    // Make sure the apartment's CoInit counts are OK.
    if (_AptKind == APTKIND_MULTITHREADED && g_cMTAInits == 0)
    {
        // CoInitializeEx(MULTITHREADED) has not been called
        hr = CO_E_NOTINITIALIZED;
    }
    else if (_AptKind == APTKIND_APARTMENTTHREADED)
    {
        if (tls->cComInits == 0 ||
           (tls->dwFlags & OLETLS_THREADUNINITIALIZING))
            // CoInitialize has not been called for this apartment
            hr = CO_E_NOTINITIALIZED;
    }


    if (SUCCEEDED(hr))
    {
        // ensure channel process initialization has been done.
        hr = ChannelProcessInitialize();

        if (SUCCEEDED(hr))
        {
            ComDebOut((DEB_OXID,"CComApartment::InitRemoting: this:%x\n", this));
            
            // Always switch to deafult context for initializing remoting
            COleTls Tls;
            CObjectContext *pSavedCtx = Tls->pCurrentCtx;
            CObjectContext *pDefaultCtx;
            if (_AptKind == APTKIND_NEUTRALTHREADED)
            {
                Win4Assert(IsThreadInNTA());
                pDefaultCtx = g_pNTAEmptyCtx;
            }
            else
            {
                Win4Assert(!IsThreadInNTA());
                pDefaultCtx = IsSTAThread() ? Tls->pNativeCtx : g_pMTAEmptyCtx;
            }
            Tls->pCurrentCtx = pDefaultCtx;
            Win4Assert(pDefaultCtx);
            Tls->ContextId = pDefaultCtx->GetId();

            ASSERT_LOCK_NOT_HELD(gOXIDLock);
            LOCK(gOXIDLock);

            // only allow one thread to come through this initialization
            hr = WaitForAccess();

            if (SUCCEEDED(hr))
            {
                if (_pOXIDEntry == NULL)
                {
                    // create the OXIDEntry for this apartment. Note that it is
                    // only partially initialized at this point.
                    hr = gOXIDTbl.MakeServerEntry(&_pOXIDEntry);

                    if (SUCCEEDED(hr))
                    {
                        // initialize the OXIDEntry remoting
                        hr = _pOXIDEntry->InitRemoting();
                    }
                }

                if (SUCCEEDED(hr) && _pRemUnk == NULL)
                {
                    // Marshal the remote unknown. Note this causes recursion back to
                    // CComApartment::GetOXIDEntry, but the recursion is terminated
                    // because GetOXIDEntry returns the partially initialized OXIDEntry
                    // on the second call. Don't hold the critical section over this,
                    // single-threaded is guaranteed by WaitForAccess above.

                    UNLOCK(gOXIDLock);
                    ASSERT_LOCK_NOT_HELD(gOXIDLock);

                    IPID  ipidRundown;
                    hr = E_OUTOFMEMORY;
                    CRemoteUnknown *pRemUnk = new CRemoteUnknown(hr, &ipidRundown);

                    ASSERT_LOCK_NOT_HELD(gOXIDLock);
                    LOCK(gOXIDLock);

                    if (SUCCEEDED(hr))
                    {
                        // need to complete the initialization of the OXIDEntry
                        Win4Assert(_pRemUnk == NULL);
                        _pRemUnk = pRemUnk;
                        _pOXIDEntry->InitRundown(ipidRundown);
                    }
                }

                if (SUCCEEDED(hr) && !(_dwState & APTFLAG_REMOTEINITIALIZED))
                {
                    // Register the OXID and pre-registered OIDs for this
                    // apartment. Do this after creating the IRemUnknown, since
                    // the registration requires the IRemUnknown IPID.
                    hr = CallTheResolver();
                    if (SUCCEEDED(hr))
                    {
                        // remoting is really initialized now.
                        _dwState |= APTFLAG_REMOTEINITIALIZED;
                    }
                }

                // OK to let other threads through now
                CheckForWaiters();
            }

            UNLOCK(gOXIDLock);
            ASSERT_LOCK_NOT_HELD(gOXIDLock);

            // restore the original context, if there was one
            Win4Assert(Tls->pCurrentCtx == pDefaultCtx);
            Tls->pCurrentCtx = pSavedCtx;
            Tls->ContextId = pSavedCtx ? pSavedCtx->GetId() : (ULONGLONG)-1;
        }
    }

    // thread is no longer initing the apartment object
    tls->dwFlags &= ~OLETLS_APTINITIALIZING;

    ComDebOut((DEB_OXID,"CComApartment::InitRemoting: this:%x hr:%x [OUT]\n",
              this, hr));
    return hr;
}

//--------------------------------------------------------------------
//
//  Member:     CComApartment::CleanupRemoting, public
//
//  Synopsis:   Cleans up the state created by InitRemoting
//
//  History:    02-Nov-98   Rickhi      Moved from channel init code.
//
//--------------------------------------------------------------------
HRESULT CComApartment::CleanupRemoting()
{
    ComDebOut((DEB_OXID,"CComApartment::CleanupRemoting: this:%x\n", this));
    AssertValid();

    HRESULT hr = S_OK;
    OXIDEntry *pOXIDEntry = NULL;
    CRemoteUnknown *pRemUnk = NULL;

    // Stop the server again incase the apartment got reinit'd
    StopServer();

    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    LOCK(gOXIDLock);

    if (_pOXIDEntry != NULL)
    {
        // cleanup the OXIDEntry and RemoteUnknown for this apartment
        Win4Assert(!(_dwState & APTFLAG_SERVERSTARTED));
        Win4Assert(_pOXIDEntry->IsStopped());

        // store remote unknown for cleanup after the lock is released
        pRemUnk = _pRemUnk;
        _pRemUnk = NULL;

        // save the OXIDEntry to release after we release the lock
        pOXIDEntry = _pOXIDEntry;
        _pOXIDEntry = NULL;

        // cleanup the transport stuff. this might release the lock.
        pOXIDEntry->CleanupRemoting();

        // Free any pre-registered OIDs since these are registered for the
        // current apartment. We get a new OXID if the thread is re-initialized.
        pOXIDEntry->FreeOXIDAndOIDs(_cPreRegOidsAvail, _arPreRegOids);
        _cPreRegOidsAvail = 0;

        // mark state as uninitialized and not stopped
        _dwState &= ~(APTFLAG_REMOTEINITIALIZED | APTFLAG_STOPPENDING);
    }

    UNLOCK(gOXIDLock);
    ASSERT_LOCK_NOT_HELD(gOXIDLock);

    // delete the remote unknown (if any) now that we have released the lock.
    if (pRemUnk)
        delete pRemUnk;

    // release the OXIDEntry (if any) now that we have released the lock.
    if (pOXIDEntry)
        pOXIDEntry->DecRefCnt();


    ComDebOut((DEB_OXID,"CComApartment::CleanupRemoting: this:%x hr:%x\n",
              this, hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Method:     CComApartment::StartServerExternal
//
//  Synopsis:   Starts the apartment servicing incoming remote calls.
//              This method can be called from outside the apartment
//              (but it only works on the NA.  ^_^)
//
//  History:    28-Mar-01   JohnDoty    Created
//
//--------------------------------------------------------------------
HRESULT CComApartment::StartServerExternal()
{
    ComDebOut((DEB_OXID, "CComApartment::StartServerExternal this:%x [IN]\n", this));
    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    AssertValid();

    // Only the NA can be started from outside the NA.
    if (GetAptId() != NTATID)
        return S_FALSE;
    
    HRESULT hr = S_OK;
    if (!IsInited())
    {
        CObjectContext *pSavedCtx = EnterNTA(g_pNTAEmptyCtx); 

        hr = StartServer();

        LeaveNTA(pSavedCtx);
    }

    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    ComDebOut((DEB_OXID, "CComApartment::StartServerExternal this:%x [OUT] hr:%x\n",
              this, hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Method:     CComApartment::StartServer
//
//  Synopsis:   Starts the apartment servicing incoming remote calls.
//
//  History:    02-Nov-98   Rickhi      Moved from ChannelThreadUninitialize
//
//--------------------------------------------------------------------
HRESULT CComApartment::StartServer()
{
    ComDebOut((DEB_OXID, "CComApartment::StartServer this:%x [IN]\n", this));
    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    AssertValid();

    HRESULT hr = S_OK;

    // if server started or is stopping don't do anything
    if (!(_dwState & (APTFLAG_SERVERSTARTED | APTFLAG_STOPPENDING)))
    {
        // initialize remoting for this apartment. Note that this returns
        // S_FALSE if the current thread is recursing during the
        // initialization, in which case we skip the rest of this function.
        hr = InitRemoting();
        if (SUCCEEDED(hr))
        {
            if (hr != S_FALSE)
            {
                ASSERT_LOCK_NOT_HELD(gOXIDLock);
                LOCK(gOXIDLock);

                if (!(_dwState & APTFLAG_SERVERSTARTED))
                {
                    // Turn off the STOPPED bit so we can accept incoming calls again.
                    hr = _pOXIDEntry->StartServer();
                    if (SUCCEEDED(hr))
                    {
                        _dwState |= APTFLAG_SERVERSTARTED;
                    }
                }

                UNLOCK(gOXIDLock);
                ASSERT_LOCK_NOT_HELD(gOXIDLock);
            }
            else
            {
                hr = S_OK;
            }            
        }
    }

    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    ComDebOut((DEB_OXID, "CComApartment::StartServer this:%x [OUT] hr:%x\n",
              this, hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Method:     CComApartment::StopServer
//
//  Synopsis:   Stops the apartment servicing incoming remote calls.
//
//  History:    02-Nov-98   Rickhi  Moved from ChannelThreadUninitialize
//
//--------------------------------------------------------------------
HRESULT CComApartment::StopServer()
{
    ComDebOut((DEB_OXID, "CComApartment::StopServer this:%x\n", this));
    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    AssertValid();

    if (_dwState & APTFLAG_SERVERSTARTED)
    {
        if (_pOXIDEntry)
        {
            _pOXIDEntry->StopServer();
        }

        // mark the server as pending stop and not started
        _dwState |= APTFLAG_STOPPENDING;
        _dwState &= ~APTFLAG_SERVERSTARTED;
    }

    ASSERT_LOCK_NOT_HELD(gOXIDLock);
    ComDebOut((DEB_OXID, "CComApartment::StopServer this:%x\n", this));
    return S_OK;
}

#if DBG==1
//+-------------------------------------------------------------------
//
//  Method:     CComApartment::AssertValid
//
//  Synopsis:   Verifies the integrity of the internal state
//
//  History:    02-Nov-98   Rickhi      Created
//
//--------------------------------------------------------------------
void CComApartment::AssertValid()
{
    if (_dwState & APTFLAG_REMOTEINITIALIZED)
    {
        Win4Assert(_pOXIDEntry);
    }

    if (_pOXIDEntry)
    {
        // make sure the apartment types match
        switch (_AptKind)
        {
        case APTKIND_MULTITHREADED :
            Win4Assert(_pOXIDEntry->IsMTAServer());
            break;

        case APTKIND_NEUTRALTHREADED :
            Win4Assert(_pOXIDEntry->IsNTAServer());
            break;

        case APTKIND_APARTMENTTHREADED :
            Win4Assert(_pOXIDEntry->IsSTAServer());
            break;

        default:
            break;
        }

        // make sure the OXIDEntry is valid
        _pOXIDEntry->AssertValid();
    }
}
#endif // DBG==1


//+-------------------------------------------------------------------
//
//  Function:   GetPreRegMOID, public
//
//  Synopsis:   Gets a pre-registered MOID from the current apartment
//
//  History:    06-Nov-95   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT GetPreRegMOID(MOID *pmoid)
{
    // find the current apartment
    CComApartment *pComApt;
    HRESULT hr = GetCurrentComApartment(&pComApt);
    if (SUCCEEDED(hr))
    {
        // ask it for a reserved MOID
        hr = pComApt->GetPreRegMOID(pmoid);
        pComApt->Release();
    }

    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   FreePreRegMOID, public
//
//  Synopsis:   Gets a pre-registered MOID from the current apartment
//
//  History:    06-Nov-95   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT FreePreRegMOID(REFMOID rmoid)
{
    // find the current apartment
    CComApartment *pComApt;
    HRESULT hr = GetCurrentComApartment(&pComApt);
    if (SUCCEEDED(hr))
    {
        // ask it for a reserved MOID
        pComApt->FreePreRegMOID(rmoid);
        pComApt->Release();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dcomrem\aggid.cxx ===
//+-------------------------------------------------------------------
//
//  File:       aggid.cxx
//
//  Contents:   aggregated identity object and creation function
//
//  History:    30-Oct-96   Rickhi      Created
//
//--------------------------------------------------------------------
#include <ole2int.h>
#include <aggid.hxx>        // CAggStdId


//+-------------------------------------------------------------------
//
//  Member:     CAggId::CAggId, public
//
//  Synopsis:   ctor for aggregated identity object
//
//  Arguments:  [ppunkInternal] - returned IUnknown of CStdIdentity
//
//  History:    30-Oct-96   Rickhi      Created
//              10-Jan-97   Gopalk      Added the clsid argument
//              12-Mar-98   Gopalk      Modified for new ID Tables
//
//--------------------------------------------------------------------
CAggId::CAggId(REFCLSID clsid, HRESULT &hr)
    : _cRefs(1),
      _punkInner(NULL)
{
    // Create StdID as an inner object
    hr = CreateIdentityHandler((IUnknown *) this,
                               STDID_CLIENT | STDID_AGGID,
                               NULL, GetCurrentApartmentId(),
                               IID_IStdIdentity,
                               (void **) &_pStdId);
    _pStdId->SetHandlerClsid(clsid);

    ComDebOut((DEB_MARSHAL, "CAggId::CAggId created %x\n", this));
}

//+-------------------------------------------------------------------
//
//  Member:     CAggId::~CAggId, private
//
//  Synopsis:   dtor for aggregated identity object
//
//  History:    30-Oct-96   Rickhi      Created
//
//--------------------------------------------------------------------
CAggId::~CAggId()
{
    ComDebOut((DEB_MARSHAL, "CAggId::~CAggId called. this:%x\n", this));

    ULONG RefsOnStdId;
    IUnknown *punkInner = _punkInner;
    _punkInner = NULL;

    if (punkInner)
    {
        punkInner->Release();
    }

    // release the last reference on the internal unk that was added
    // when the internal unk was initially created.
    RefsOnStdId = (_pStdId->GetInternalUnk())->Release();
    Win4Assert(RefsOnStdId==0);

    ComDebOut((DEB_MARSHAL, "CAggId::~CAggId destroyed %x\n", this));
}

//+-------------------------------------------------------------------
//
//  Member:     CAggId::QueryInterface, public
//
//  Synopsis:   Queries for the requested interface
//
//  Arguments:  [riid]   - interface iid to return to caller
//              [ppv]    - where to put that interface
//
//  History:    31-Oct-96   Rickhi  Created.
//              13-Jan-97   Gopalk  Create handler as the inner object
//                                  (if needed due to race conditions
//                                  during unmarshaling)
//
//--------------------------------------------------------------------
STDMETHODIMP CAggId::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr = IsImplementedInterface(riid, ppv);
    if (FAILED(hr))
    {
        // Create handler as the inner object if needed. This case can
        // arise if interfaces on the server object are being
        // unmarshaled simulataneously
        if(!_punkInner)
            hr = CreateHandler(_pStdId->GetHandlerClsid());

        // Delegate the QI to the handler
        if(_punkInner)
            hr = _punkInner->QueryInterface(riid, ppv);
    }
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CAggId::QueryMultipleInterfaces, public
//
//  Synopsis:   return interfaces asked for.
//
//  Arguements: [cMQIs] - count of MULTI_QI structs
//              [pMQIs] - array of MULTI_QI structs
//
//  History:    31-Oct-96   Rickhi  Created.
//
//--------------------------------------------------------------------
STDMETHODIMP CAggId::QueryMultipleInterfaces(ULONG cMQIs, MULTI_QI *pMQIs)
{
    HRESULT hr = S_OK;

    // fill in the interfaces this object supports
    ULONG     cMissing = 0;
    MULTI_QI *pMQINext = pMQIs;

    for (ULONG i=0; i<cMQIs; i++, pMQINext++)
    {
        if (pMQINext->pItf == NULL)
        {
            // higher level guy did not yet fill in the interface. Check
            // if we support it.

            pMQINext->hr = IsImplementedInterface(*(pMQINext->pIID),
                                                  (void **)&pMQINext->pItf);
            if (FAILED(pMQINext->hr))
            {
                cMissing++; // count one more missing interface
            }
        }
    }

    if (cMissing > 0)
    {
        // there are more interfaces left, QI the handler to get the
        // rest of the interfaces.
        IMultiQI *pMQI = NULL;
        hr = _punkInner->QueryInterface(IID_IMultiQI, (void **)&pMQI);
        if (SUCCEEDED(hr))
        {
            // handler implements MultiQI, use it.
            hr = pMQI->QueryMultipleInterfaces(cMQIs, pMQIs);
            pMQI->Release();
        }
    }

    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CAggId::IsImplementedInterface, private
//
//  Synopsis:   Internal routine common to QueryInterface and
//              QueryMultipleInterfaces. Returns interfaces supported
//              by this object.
//
//  Arguments:  [riid]   - interface iid to return to caller
//              [ppv]    - where to put that interface
//
//  History:    31-Oct-96   Rickhi  Created.
//
//--------------------------------------------------------------------
HRESULT CAggId::IsImplementedInterface(REFIID riid, void **ppv)
{
    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IMultiQI))
    {
        *ppv = (IMultiQI *)this;
    }
    else if (IsEqualIID(riid, IID_IStdIdentity))
    {
        *ppv = (void *)_pStdId;
    }
    else
    {
        return E_NOINTERFACE;
    }

    ((IUnknown *)(*ppv))->AddRef();
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CAggId::AddRef, public
//
//  Synopsis:   increments the reference count on the object
//
//  History:    31-Oct-96   Rickhi  Created.
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CAggId::AddRef(void)
{
    InterlockedIncrement((LONG *)&_cRefs);
    return _cRefs;
}

//+-------------------------------------------------------------------
//
//  Member:     CAggId::Release, public
//
//  Synopsis:   decrements the reference count on the object
//
//  History:    31-Oct-96   Rickhi  Created.
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CAggId::Release(void)
{
    // decrement the refcnt. if the refcnt went to zero it will be marked
    // as being in the dtor, and fTryToDelete will be true.
    ULONG cNewRefs;
    BOOL  fTryToDelete = InterlockedDecRefCnt(&_cRefs, &cNewRefs);

    while (fTryToDelete)
    {
        // refcnt went to zero, try to delete this entry
        if (IsOKToDeleteClientObject(_pStdId, &_cRefs))
        {
            // the refcnt did not change while we acquired the lock
            // (i.e. the idtable did not just hand out a reference).
            // OK to delete the identity object.
            delete this;
            break;  // all done. the entry has been deleted.
        }

        // the entry was not deleted because some other thread changed
        // the refcnt while we acquired the lock. Try to restore the refcnt
        // to turn off the CINDESTRUCTOR bit. Note that this may race with
        // another thread changing the refcnt, in which case we may decide to
        // try to loop around and delete the object once again.
        fTryToDelete = InterlockedRestoreRefCnt(&_cRefs, &cNewRefs);
    }

    return (cNewRefs & ~CINDESTRUCTOR);
}

//+-------------------------------------------------------------------
//
//  Member:     CAggId::SetHandler, public
//
//  Synopsis:   Sets the handler
//
//  Arguments:  [punkInner] [in]  - IUnknown pointer to inner object
//
//  History:    13-Jan-97   Gopalk  Created. This method is also used
//                                  during Default handler creation
//--------------------------------------------------------------------
STDMETHODIMP CAggId::SetHandler(IUnknown *punkInner)
{
    ComDebOut((DEB_MARSHAL,
               "CAggId::SetHandler this:%x punkInner:%x _punkInner:%x\n",
               this, punkInner, _punkInner));
    Win4Assert(punkInner);

    // Initialize hr to return E_FAIL
    HRESULT hr = E_FAIL;

    // Set the _punkInner after aquiring the lock
    if (InterlockedCompareExchangePointer((void **)&_punkInner,
                                          punkInner, NULL) == NULL)
    {
        // AddRef the new handler as it is an IN parameter and
        // we are caching a pointer to it
        _punkInner->AddRef();
        hr = S_OK;
    }

    ComDebOut((DEB_MARSHAL, "CAggId::SetHandler this:%x hr:%x\n", this, hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CAggId::CreateHandler, private
//
//  Synopsis:   creates the client handler
//
//  Arguments:  [rclsid] - class of client handler to create
//
//  History:    31-Oct-96   Rickhi  Created.
//
//--------------------------------------------------------------------
HRESULT CAggId::CreateHandler(REFCLSID rclsid)
{
    ComDebOut((DEB_MARSHAL,
        "CAggId::CreateHandler this:%x clsid:%I\n", this, &rclsid));

    // create the handler, 'this' acts as the controlling unknown.
    IUnknown *punkOuter = (IUnknown *)this;
    IUnknown *punkInner = NULL;

    DWORD dwFlags = CLSCTX_INPROC_HANDLER | CLSCTX_NO_CODE_DOWNLOAD;
    dwFlags |= (gCapabilities & EOAC_NO_CUSTOM_MARSHAL) ? CLSCTX_NO_CUSTOM_MARSHAL : 0;

    HRESULT hr = CoCreateInstance(rclsid, punkOuter, dwFlags,
                                  IID_IUnknown, (void **)&punkInner);

    if (SUCCEEDED(hr))
    {
        // set the handler
        SetHandler(punkInner);

        // it is possible for two or more threads to simultaneously
        // unmarshal the interface. Consequently the following will
        // release the handler instances that have not been utilized
        // as the inner object
        punkInner->Release();
    }

    ComDebOut((DEB_MARSHAL,
        "CAggId::CreateHandler this:%x hr:%x _punkInner:%x\n",
        this, hr, _punkInner));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CreateClientHandler, private
//
//  Synopsis:   Creates a client side identity object that aggregates
//              an application supplied handler object.
//
//  Arguments:  [rclsid] - class of handler to create
//              [rmoid]  - Identity of object
//              [ppStdId]- place to return identity
//
//  History:    30-Oct-96   Rickhi      Created
//
//--------------------------------------------------------------------
INTERNAL CreateClientHandler(REFCLSID rclsid, REFMOID rmoid,DWORD dwAptId,
                             CStdIdentity **ppStdId)
{
    ComDebOut((DEB_MARSHAL, "CreateClientHandler rclsid:%I rmoid:%I ppStdId:%x\n",
        &rclsid, &rmoid, ppStdId));
    ASSERT_LOCK_NOT_HELD(gComLock);

    // First thing we do is create an instance of the CAggId, which
    // will serve as the system-supplied controlling unknown for the
    // client object, as well as the OID for the OID table and the
    // marshaling piece.

    HRESULT hr = E_OUTOFMEMORY;

	// CAggId::CAggId ends up calling CreateIdentityHandler which must be called WITHOUT
	// the gComLock
    CAggId *pAID = new CAggId(rclsid, hr);
    if(SUCCEEDED(hr))
    {
		// We have now created a new CAggId which aggregates a CStdIdentity.
		// Check to see whether another thread beat us to registering it.  If not, 
		// then we will set this one.
	    LOCK(gComLock);
	    CStdIdentity *pTempId = NULL;
		HRESULT hrTemp = ObtainStdIDFromOID(rmoid, dwAptId, TRUE, &pTempId);
		if(FAILED(hrTemp))
		{
			// There still wasn't an entry, so set our entry and continue
			// Once we've registered the ID, it's OK to release the lock.
			hr = pAID->SetOID(rmoid);
			UNLOCK(gComLock);
		}
		else
		{
			// Another thread beat us, use their entry, and we're done (no need to continue on 
			// with creating the handler, so we Exit).
			UNLOCK(gComLock);
			*ppStdId = pTempId;
			goto Exit;
		}
    }
		
    // Make sure we don't hold the lock while creating the
    // handler since this involves running app code.
    ASSERT_LOCK_NOT_HELD(gComLock);

    if (SUCCEEDED(hr))
    {
        // now create an instance of the handler. the handler will
        // create an aggregated instance of the remoting piece via
        // a nested call to the CoGetStdMarshalEx API. The
        // end result is the client handler sandwiched between the
        // CAggId controling unknown and the
        // CStdIdentity::CInternalUnk. That way, the system
        // controlls the inner and outer pieces of the object.

        hr = pAID->CreateHandler(rclsid);

        if (SUCCEEDED(hr))
        {
            hr = pAID->QueryInterface(IID_IStdIdentity, (void **)ppStdId);
        }
    }

Exit:

    ASSERT_LOCK_NOT_HELD(gComLock);

	if(pAID)
        pAID->Release();

    ComDebOut((DEB_MARSHAL, "CreateClientHandler hr:%x *ppStdId:%x\n",
            hr, *ppStdId));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\coll\map_kv.cxx ===
/////////////////////////////////////////////////////////////////////////////
// class CMapKeyToValue - a mapping from 'KEY's to 'VALUE's, passed in as
// pv/cb pairs.  The keys can be variable length, although we optmizize the
// case when they are all the same.
//
/////////////////////////////////////////////////////////////////////////////

#include <ole2int.h>
//#include <compobj.seg>
#pragma SEG(map_kv)

#include "map_kv.h"

#include "plex.h"
ASSERTDATA


/////////////////////////////////////////////////////////////////////////////


#pragma SEG(CMapKeyToValue_ctor)  
CMapKeyToValue::CMapKeyToValue(DWORD memctx, UINT cbValue, UINT cbKey,
	int nBlockSize, LPFNHASHKEY lpfnHashKey, UINT nHashSize)
{
	Assert(nBlockSize > 0);

	m_cbValue = cbValue;
	m_cbKey = cbKey;
	m_cbKeyInAssoc = cbKey == 0 ? sizeof(CKeyWrap) : cbKey;

	m_pHashTable = NULL;
	m_nHashTableSize = nHashSize;
	m_lpfnHashKey = lpfnHashKey;

	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks = NULL;
	m_nBlockSize = nBlockSize;
	if (memctx == MEMCTX_SAME)
		memctx = CoMemctxOf(this);
	m_memctx = memctx;
	Assert(m_memctx != MEMCTX_UNKNOWN);
}

#pragma SEG(CMapKeyToValue_dtor)  
CMapKeyToValue::~CMapKeyToValue()
{
	ASSERT_VALID(this);
	RemoveAll();
	Assert(m_nCount == 0);
}


#pragma SEG(MKVDefaultHashKey)  
// simple, default hash function
// REVIEW: need to check the value in this for GUIDs and strings
STDAPI_(UINT) MKVDefaultHashKey(LPVOID pKey, UINT cbKey)
{
	UINT hash = 0;
	BYTE FAR* lpb = (BYTE FAR*)pKey;

	while (cbKey-- != 0)
		hash = 257 * hash + *lpb++;

	return hash;
}


#pragma SEG(CMapKeyToValue_InitHashTable)  
BOOL CMapKeyToValue::InitHashTable()
{
	ASSERT_VALID(this);
	Assert(m_nHashTableSize  > 0);
	
	if (m_pHashTable != NULL)
		return TRUE;

	Assert(m_nCount == 0);

	if ((m_pHashTable = (CAssoc FAR* FAR*)CoMemAlloc(m_nHashTableSize * sizeof(CAssoc FAR*), m_memctx, NULL)) == NULL)
		return FALSE;

	memset(m_pHashTable, 0, sizeof(CAssoc FAR*) * m_nHashTableSize);

	ASSERT_VALID(this);

	return TRUE;
}


#pragma SEG(CMapKeyToValue_RemoveAll)  
void CMapKeyToValue::RemoveAll()
{
	ASSERT_VALID(this);

	// free all key values and then hash table
	if (m_pHashTable != NULL)
	{
		// destroy assocs
		for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
		{
			register CAssoc FAR* pAssoc;
			for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
			  pAssoc = pAssoc->pNext)
				// assoc itself is freed by FreeDataChain below
				FreeAssocKey(pAssoc);
		}

		// free hash table
		CoMemFree(m_pHashTable, m_memctx);
		m_pHashTable = NULL;
	}

	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks->FreeDataChain(m_memctx);
	m_pBlocks = NULL;

	ASSERT_VALID(this);
}

/////////////////////////////////////////////////////////////////////////////
// Assoc helpers
// CAssoc's are singly linked all the time

#pragma SEG(CMapKeyToValue_NewAssoc)  
CMapKeyToValue::CAssoc  FAR*
    CMapKeyToValue::NewAssoc(UINT hash, LPVOID pKey, UINT cbKey, LPVOID pValue)
{
	if (m_pFreeList == NULL)
	{
		// add another block
		CPlex FAR* newBlock = CPlex::Create(m_pBlocks, m_memctx, m_nBlockSize, SizeAssoc());

		if (newBlock == NULL)
			return NULL;

		// chain them into free list
		register BYTE  FAR* pbAssoc = (BYTE FAR*) newBlock->data();
		// free in reverse order to make it easier to debug
		pbAssoc += (m_nBlockSize - 1) * SizeAssoc();
		for (int i = m_nBlockSize-1; i >= 0; i--, pbAssoc -= SizeAssoc())
		{
			((CAssoc FAR*)pbAssoc)->pNext = m_pFreeList;
			m_pFreeList = (CAssoc FAR*)pbAssoc;
		}
	}
	Assert(m_pFreeList != NULL); // we must have something

	CMapKeyToValue::CAssoc  FAR* pAssoc = m_pFreeList;

	// init all fields except pNext while still on free list
	pAssoc->nHashValue = hash;
	if (!SetAssocKey(pAssoc, pKey, cbKey))
		return NULL;

	SetAssocValue(pAssoc, pValue);

	// remove from free list after successfully initializing it (except pNext)
	m_pFreeList = m_pFreeList->pNext;
	m_nCount++;
	Assert(m_nCount > 0);       // make sure we don't overflow

	return pAssoc;
}


#pragma SEG(CMapKeyToValue_FreeAssoc)  
// free individual assoc by freeing key and putting on free list
void CMapKeyToValue::FreeAssoc(CMapKeyToValue::CAssoc  FAR* pAssoc)
{
	pAssoc->pNext = m_pFreeList;
	m_pFreeList = pAssoc;
	m_nCount--;
	Assert(m_nCount >= 0);      // make sure we don't underflow

	FreeAssocKey(pAssoc);
}


#pragma SEG(CMapKeyToValue_GetAssocAt)  
// find association (or return NULL)
CMapKeyToValue::CAssoc  FAR*
CMapKeyToValue::GetAssocAt(LPVOID pKey, UINT cbKey, UINT FAR& nHash) const
{
	if (m_lpfnHashKey)
	    nHash = (*m_lpfnHashKey)(pKey, cbKey) % m_nHashTableSize;
	else
	    nHash = MKVDefaultHashKey(pKey, cbKey) % m_nHashTableSize;

	if (m_pHashTable == NULL)
		return NULL;

	// see if it exists
	register CAssoc  FAR* pAssoc;
	for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
		if (CompareAssocKey(pAssoc, pKey, cbKey))
			return pAssoc;
	}
	return NULL;
}


#pragma SEG(CMapKeyToValue_CompareAssocKey)  
BOOL CMapKeyToValue::CompareAssocKey(CAssoc FAR* pAssoc, LPVOID pKey2, UINT cbKey2) const
{
	LPVOID pKey1;
	UINT cbKey1;

	GetAssocKeyPtr(pAssoc, &pKey1, &cbKey1);
	return cbKey1 == cbKey2 && memcmp(pKey1, pKey2, cbKey1) == 0;
}


#pragma SEG(CMapKeyToValue_SetAssocKey)  
BOOL CMapKeyToValue::SetAssocKey(CAssoc FAR* pAssoc, LPVOID pKey, UINT cbKey) const
{
	Assert(cbKey == m_cbKey || m_cbKey == 0);

	if (m_cbKey == 0)
	{
		Assert(m_cbKeyInAssoc == sizeof(CKeyWrap));

		// alloc, set size and pointer
		if ((pAssoc->key.pKey = CoMemAlloc(cbKey, m_memctx, NULL)) == NULL)
			return FALSE;

		pAssoc->key.cbKey = cbKey;
	}

	LPVOID pKeyTo;

	GetAssocKeyPtr(pAssoc, &pKeyTo, &cbKey);

	memcpy(pKeyTo, pKey, cbKey);

	return TRUE;
}


#pragma SEG(CMapKeyToValue_GetAssocKeyPtr)  
// gets pointer to key and its length
void CMapKeyToValue::GetAssocKeyPtr(CAssoc FAR* pAssoc, LPVOID FAR* ppKey,UINT FAR* pcbKey) const
{
	if (m_cbKey == 0)
	{
		// variable length key; go indirect
		*ppKey = pAssoc->key.pKey;
		*pcbKey = pAssoc->key.cbKey;
	}
	else
	{
		// fixed length key; key in assoc
		*ppKey = (LPVOID)&pAssoc->key;
		*pcbKey = m_cbKey;
	}
}


#pragma SEG(CMapKeyToValue_FreeAssocKey)  
void CMapKeyToValue::FreeAssocKey(CAssoc FAR* pAssoc) const
{
	if (m_cbKey == 0)
		CoMemFree(pAssoc->key.pKey, m_memctx);
}


#pragma SEG(CMapKeyToValue_GetAssocValuePtr)  
void CMapKeyToValue::GetAssocValuePtr(CAssoc FAR* pAssoc, LPVOID FAR* ppValue) const
{
	*ppValue = (char FAR*)&pAssoc->key + m_cbKeyInAssoc;
}


#pragma SEG(CMapKeyToValue_GetAssocValue)  
void CMapKeyToValue::GetAssocValue(CAssoc FAR* pAssoc, LPVOID pValue) const
{
	LPVOID pValueFrom;
	GetAssocValuePtr(pAssoc, &pValueFrom);
	Assert(pValue != NULL);
	memcpy(pValue, pValueFrom, m_cbValue);
}


#pragma SEG(CMapKeyToValue_SetAssocValue)  
void CMapKeyToValue::SetAssocValue(CAssoc FAR* pAssoc, LPVOID pValue) const
{
	LPVOID pValueTo;
	GetAssocValuePtr(pAssoc, &pValueTo);
	if (pValue == NULL)
		memset(pValueTo, 0, m_cbValue);
	else
		memcpy(pValueTo, pValue, m_cbValue);
}


/////////////////////////////////////////////////////////////////////////////

#pragma SEG(CMapKeyToValue_Lookup)  
// lookup value given key; return FALSE if key not found; in that
// case, the value is set to all zeros
BOOL CMapKeyToValue::Lookup(LPVOID pKey, UINT cbKey, LPVOID pValue) const
{
	UINT nHash;
	return LookupHKey((HMAPKEY)GetAssocAt(pKey, cbKey, nHash), pValue);
}


#pragma SEG(CMapKeyToValue_LookupHKey)  
// lookup value given key; return FALSE if NULL (or bad) key; in that
// case, the value is set to all zeros
BOOL CMapKeyToValue::LookupHKey(HMAPKEY hKey, LPVOID pValue) const
{
	// REVIEW: would like some way to verify that hKey is valid
	register CAssoc  FAR* pAssoc = (CAssoc FAR*)hKey;
	if (pAssoc == NULL)
	{
		memset(pValue, 0, m_cbValue);
		return FALSE;       // not in map
	}

	ASSERT_VALID(this);

	GetAssocValue(pAssoc, pValue);
	return TRUE;
}


#pragma SEG(CMapKeyToValue_LookupAdd)  
// lookup and if not found add; returns FALSE only if OOM; if added, 
// value added and pointer passed are set to zeros.
BOOL CMapKeyToValue::LookupAdd(LPVOID pKey, UINT cbKey, LPVOID pValue) const
{
	if (Lookup(pKey, cbKey, pValue))
		return TRUE;

	// value set to zeros since lookup failed

	return ((CMapKeyToValue FAR*)this)->SetAt(pKey, cbKey, NULL);
}


#pragma SEG(CMapKeyToValue_SetAt)  
// the only place new assocs are created; return FALSE if OOM;
// never returns FALSE if keys already exists
BOOL CMapKeyToValue::SetAt(LPVOID pKey, UINT cbKey, LPVOID pValue)
{
	UINT nHash;
	register CAssoc  FAR* pAssoc;

	ASSERT_VALID(this);

	if ((pAssoc = GetAssocAt(pKey, cbKey, nHash)) == NULL)
	{
		if (!InitHashTable())
			// out of memory
			return FALSE;

		// it doesn't exist, add a new Association
		if ((pAssoc = NewAssoc(nHash, pKey, cbKey, pValue)) == NULL)
			return FALSE;

		// put into hash table
		pAssoc->pNext = m_pHashTable[nHash];
		m_pHashTable[nHash] = pAssoc;

		ASSERT_VALID(this);
	}
	else
	{
		SetAssocValue(pAssoc, pValue);
	}

	return TRUE;
}


#pragma SEG(CMapKeyToValue_SetAtHKey)  
// set existing hkey to value; return FALSE if NULL or bad key
BOOL CMapKeyToValue::SetAtHKey(HMAPKEY hKey, LPVOID pValue)
{
	// REVIEW: would like some way to verify that hKey is valid
	register CAssoc  FAR* pAssoc = (CAssoc FAR*)hKey;
	if (pAssoc == NULL)
		return FALSE;       // not in map

	ASSERT_VALID(this);

	SetAssocValue(pAssoc, pValue);
	return TRUE;
}


#pragma SEG(CMapKeyToValue_RemoveKey)  
// remove key - return TRUE if removed
BOOL CMapKeyToValue::RemoveKey(LPVOID pKey, UINT cbKey)
{
	ASSERT_VALID(this);

	if (m_pHashTable == NULL)
		return FALSE;       // nothing in the table

	register CAssoc  FAR* FAR* ppAssocPrev;
	UINT i;
	if (m_lpfnHashKey)
	    i = (*m_lpfnHashKey)(pKey, cbKey) % m_nHashTableSize;
	else
	    i = MKVDefaultHashKey(pKey, cbKey) % m_nHashTableSize;

	ppAssocPrev = &m_pHashTable[i];

	CAssoc  FAR* pAssoc;
	for (pAssoc = *ppAssocPrev; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
		if (CompareAssocKey(pAssoc, pKey, cbKey))
		{
			// remove it
			*ppAssocPrev = pAssoc->pNext;       // remove from list
			FreeAssoc(pAssoc);
			ASSERT_VALID(this);
			return TRUE;
		}
		ppAssocPrev = &pAssoc->pNext;
	}
	return FALSE;   // not found
}


#pragma SEG(CMapKeyToValue_RemoveHKey)  
// remove key based on pAssoc (HMAPKEY)
BOOL CMapKeyToValue::RemoveHKey(HMAPKEY hKey)
{
	ASSERT_VALID(this);

	if (m_pHashTable == NULL)
		return FALSE;       // nothing in the table

	// REVIEW: would like some way to verify that hKey is valid
	CAssoc  FAR* pAssoc = (CAssoc FAR*)hKey;
	if (pAssoc == NULL || pAssoc->nHashValue >= m_nHashTableSize)
		// null hkey or bad hash value
		return FALSE;

	register CAssoc  FAR* FAR* ppAssocPrev;
	ppAssocPrev = &m_pHashTable[pAssoc->nHashValue];

	while (*ppAssocPrev != NULL)
	{
		if (*ppAssocPrev == pAssoc)
		{
			// remove it
			*ppAssocPrev = pAssoc->pNext;       // remove from list
			FreeAssoc(pAssoc);
			ASSERT_VALID(this);
			return TRUE;
		}
		ppAssocPrev = &(*ppAssocPrev)->pNext;
	}

	return FALSE;   // not found (must have a messed up list or passed 
					// a key from another list)
}


#pragma SEG(CMapKeyToValue_GetHKey)  
HMAPKEY CMapKeyToValue::GetHKey(LPVOID pKey, UINT cbKey) const
{
	UINT nHash;

	ASSERT_VALID(this);

	return (HMAPKEY)GetAssocAt(pKey, cbKey, nHash);
}


/////////////////////////////////////////////////////////////////////////////
// Iterating

// for fixed length keys, copies key to pKey; pcbKey can be NULL;
// for variable length keys, copies pointer to key to pKey; sets pcbKey.

#pragma SEG(CMapKeyToValue_GetNextAssoc)  
void CMapKeyToValue::GetNextAssoc(POSITION FAR* pNextPosition, 
		LPVOID pKey, UINT FAR* pcbKey, LPVOID pValue) const
{
	ASSERT_VALID(this);

	Assert(m_pHashTable != NULL);       // never call on empty map

	register CAssoc  FAR* pAssocRet = (CAssoc  FAR*)*pNextPosition;
	Assert(pAssocRet != NULL);

	if (pAssocRet == (CAssoc  FAR*) BEFORE_START_POSITION)
	{
		// find the first association
		for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
				break;
		Assert(pAssocRet != NULL);  // must find something
	}

	// find next association
	CAssoc  FAR* pAssocNext;
	if ((pAssocNext = pAssocRet->pNext) == NULL)
	{
		// go to next bucket
		for (UINT nBucket = pAssocRet->nHashValue + 1;
		  nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
				break;
	}

	// fill in return data
	*pNextPosition = (POSITION) pAssocNext;

	// fill in key/pointer to key
	LPVOID pKeyFrom;
	UINT cbKey;
	GetAssocKeyPtr(pAssocRet, &pKeyFrom, &cbKey);
	if (m_cbKey == 0)
		// variable length key; just return pointer to key itself
		*(void FAR* FAR*)pKey = pKeyFrom;
	else
		memcpy(pKey, pKeyFrom, cbKey);

	if (pcbKey != NULL)
		*pcbKey = cbKey;

	// get value
	GetAssocValue(pAssocRet, pValue);
}

/////////////////////////////////////////////////////////////////////////////

#pragma SEG(CMapKeyToValue_AssertValid)  
void CMapKeyToValue::AssertValid() const
{
#ifdef _DEBUG
	Assert(m_cbKeyInAssoc == (m_cbKey == 0 ? sizeof(CKeyWrap) : m_cbKey));

	Assert(m_nHashTableSize > 0);
	Assert(m_nCount == 0 || m_pHashTable != NULL);

	if (m_pHashTable != NULL)
		Assert(IsValidReadPtrIn(m_pHashTable, m_nHashTableSize * sizeof(CAssoc FAR*)));

	if (m_lpfnHashKey)
	    Assert(IsValidCodePtr((FARPROC)m_lpfnHashKey));

	if (m_pFreeList != NULL)
		Assert(IsValidReadPtrIn(m_pFreeList, SizeAssoc()));

	if (m_pBlocks != NULL)
		Assert(IsValidReadPtrIn(m_pBlocks, SizeAssoc() * m_nBlockSize));

	// some collections live as global variables in the libraries, but 
	// have their existance in some context.  Also, we can't check shared
	// collections since we might be checking the etask collection
	// which would cause an infinite recursion.
	// REVIEW: Assert(m_memctx == MEMCTX_SHARED || 
	// CoMemctxOf(this) == MEMCTX_UNKNOWN || CoMemctxOf(this) == m_memctx);
#endif //_DEBUG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dcomrem\call.cxx ===
//+-------------------------------------------------------------------
//
//  File:       call.cxx
//
//  Contents:   code to support COM calls
//
//  Functions:  CCallTable methods
//              CallObject methods
//
//  History:    14-May-97   Gopalk      Created
//              10-Feb-99   TarunA      Receive SendComplete notifications
//
//--------------------------------------------------------------------
#include <ole2int.h>
#include <channelb.hxx>
#include <call.hxx>
#include <threads.hxx>
#include <callctrl.hxx>
#include <callmgr.hxx>

/***************************************************************************/
/* Class globals. */

// critical section guarding call objects
COleStaticMutexSem  gCallLock;

CAsyncCall    *CAsyncCall::_aList[CALLCACHE_SIZE] =
        { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };
DWORD          CAsyncCall::_iNext          = 0;
void          *CClientCall::_aList[CALLCACHE_SIZE] =
        { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };
DWORD          CClientCall::_iNext        = 0;


CCallTable     gCallTbl;                            // Global call table
BOOL           CCallTable::m_fInitialized  = FALSE; // Is call table initialized?
CPageAllocator CCallTable::m_Allocator;             // Allocator for call entries


//+-------------------------------------------------------------------
//
//  Method:     CCallTable::SetEntry     public
//
//  Synopsis:   Sets the given call object as the top call object on
//              the call object stack.
//
//+-------------------------------------------------------------------
HRESULT CCallTable::SetEntry(ICancelMethodCalls *pObject)
{
    CallDebugOut((DEB_CALL, "CThreadTable::SetEntry pObject:%x\n",pObject));

    HRESULT hr;
    COleTls tls(hr);
    if (FAILED(hr))
        return hr;

    // hold a reference to the call object
    pObject->AddRef();

    if (tls->CallEntry.pvObject == NULL)
    {
        // we can take the fast path since the CallEntry in
        // tls is currently unused.
        tls->CallEntry.pvObject = pObject;
        return S_OK;
    }

    ASSERT_LOCK_NOT_HELD(gCallLock);
    LOCK(gCallLock);

    Initialize();     // Make sure this table is initialized.

    // Create a new stack entry
    CallEntry *pStackEntry = (CallEntry *) m_Allocator.AllocEntry();
    if(pStackEntry)
    {
        // link it in
        pStackEntry->pNext      = tls->CallEntry.pNext;
        pStackEntry->pvObject   = tls->CallEntry.pvObject;
        tls->CallEntry.pNext    = pStackEntry;
        tls->CallEntry.pvObject = pObject;
        pObject = NULL;

        // One more call is using the table
        ++m_cCalls;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    UNLOCK(gCallLock);
    ASSERT_LOCK_NOT_HELD(gCallLock);

    if (pObject)
    {
        pObject->Release();
    }

    return hr;
}

//+-------------------------------------------------------------------
//
//  Method:     CCallTable::ClearEntry     public
//
//  Synopsis:   Removes the top call object from the call object stack.
//
//+-------------------------------------------------------------------
ICancelMethodCalls *CCallTable::ClearEntry(ICancelMethodCalls *pCall)
{
    CallDebugOut((DEB_CALL, "CThreadTable::ClearEntry pCall:%x\n",pCall));
    ASSERT_LOCK_HELD(gCallLock);

    HRESULT hr;
    COleTls tls(hr);
    if (FAILED(hr))
        return NULL;

    if (tls->CallEntry.pvObject == NULL)
        return NULL;

    // tls has a pointer to the call object
    ICancelMethodCalls *pvObject = (ICancelMethodCalls *) tls->CallEntry.pvObject;
    tls->CallEntry.pvObject = NULL;

    // ensure we are poping the call we think we are
    Win4Assert(pCall == NULL || pCall == pvObject);

    if (tls->CallEntry.pNext)
    {
        // there is a nested call, make tls point to the previous call
        // and release the previous call.
        CallEntry *pTmp          = (CallEntry *)tls->CallEntry.pNext;
        tls->CallEntry.pvObject  = pTmp->pvObject;
        tls->CallEntry.pNext     = pTmp->pNext;
        m_Allocator.ReleaseEntry((PageEntry *) pTmp);

        // One less thread is using the table
        --m_cCalls;
        if(m_fInitialized == FALSE)
            PrivateCleanup();
    }

    ASSERT_LOCK_HELD(gCallLock);
    return pvObject;
}

//+-------------------------------------------------------------------
//
//  Method:     CCallTable::GetEntry     public
//
//  Synopsis:   Finds thread entry corresponding to the ThreadId
//              passed in and returns its stack top call object
//
//+-------------------------------------------------------------------
ICancelMethodCalls *CCallTable::GetEntry(DWORD dwThreadId)
{
    CallDebugOut((DEB_CALL, "CThreadTable::GetEntry dwThreadId:%x\n",dwThreadId));
    ASSERT_LOCK_NOT_HELD(gCallLock);
    LOCK(gCallLock);

    ICancelMethodCalls *pObject = NULL;

    // Find the tls pointer
    SOleTlsData *tls = TLSLookupThreadId(dwThreadId);
    if (tls != NULL)
    {
        // obtain its call object
        pObject = (ICancelMethodCalls *)tls->CallEntry.pvObject;
        if(pObject)
            pObject->AddRef();
    }

    UNLOCK(gCallLock);
    ASSERT_LOCK_NOT_HELD(gCallLock);
    CallDebugOut((DEB_CALL, "CThreadTable::GetEntry returned pObject:%x\n", pObject));
    return pObject;
}

//+-------------------------------------------------------------------
//
//  Method:     CCallTable::CancelPendingCalls     public
//
//  Synopsis:   Walks the call object stack of the specified thread
//              and cancels calls that are pending
//
//+-------------------------------------------------------------------
void CCallTable::CancelPendingCalls()
{
    CallDebugOut((DEB_CALL|DEB_CANCEL, "CCallTable::CancelPendingCalls\n"));
    ASSERT_LOCK_NOT_HELD(gCallLock);
    LOCK(gCallLock);

    // Find the tls pointer
    SOleTlsData *tls = TLSLookupThreadId(GetCurrentThreadId());
    if (tls != NULL)
    {
        // obtain its call object
        CallEntry *pCallEntry = &tls->CallEntry;
        while (pCallEntry->pvObject)
        {
            // cancel the calls in the call object stack
            ((ICancelMethodCalls *) pCallEntry->pvObject)->Cancel(0);
            pCallEntry = (CallEntry *) pCallEntry->pNext;
        }
    }

    UNLOCK(gCallLock);
    ASSERT_LOCK_NOT_HELD(gCallLock);
    return;
}

//+-------------------------------------------------------------------
//
//  Method:     CCallTable::Initialize     public
//
//  Synopsis:   Initializes the call table
//
//+-------------------------------------------------------------------
void CCallTable::Initialize()
{
    CallDebugOut((DEB_CALL, "CCallTable::Initialize\n"));

    ASSERT_LOCK_DONTCARE(gCallLock);
    LOCK(gCallLock);

    if(!m_fInitialized)
    {
        // Really initialze only if needed
        if(m_cCalls == 0)
            m_Allocator.Initialize(sizeof(CallEntry), CALLS_PER_PAGE, &gCallLock);

        // Mark the state as initialized
        m_fInitialized = TRUE;
    }

    UNLOCK(gCallLock);
    ASSERT_LOCK_DONTCARE(gCallLock);
    return;
}

//+-------------------------------------------------------------------
//
//  Method:     CCallTable::Cleanup     public
//
//  Synopsis:   Cleanup call table
//
//+-------------------------------------------------------------------
void CCallTable::Cleanup()
{
    CallDebugOut((DEB_CALL, "CCallTable::Cleanup\n"));
    ASSERT_LOCK_NOT_HELD(gCallLock);
    LOCK(gCallLock);

    m_fInitialized = FALSE;
    if(m_cCalls == 0)
        PrivateCleanup();

    UNLOCK(gCallLock);
    ASSERT_LOCK_NOT_HELD(gCallLock);
    return;
}

//+-------------------------------------------------------------------
//
//  Method:     CCallTable::PrivateCleanup     public
//
//  Synopsis:   Really Cleanup call table
//
//+-------------------------------------------------------------------
void CCallTable::PrivateCleanup()
{
    CallDebugOut((DEB_CALL, "CCallTable::PrivateCleanup\n"));
    ASSERT_LOCK_HELD(gCallLock);
    Win4Assert(m_cCalls == 0);

    // Cleanup allocator
    m_Allocator.Cleanup();

    ASSERT_LOCK_HELD(gCallLock);
    return;
}



//---------------------------------------------------------------------------
//
//  Method:     CMessageCall::CMessageCall
//
//  Synopsis:   CMessageCall ctor.
//
//---------------------------------------------------------------------------
CMessageCall::CMessageCall()
{
    CallDebugOut((DEB_CALL, "CMessageCall::CMessageCall this:%x\n",this));
    _pHeader  = NULL;
    _pHandle  = NULL;
    _hEvent   = NULL;
    _pContext = NULL;
    _hSxsActCtx = INVALID_HANDLE_VALUE;
}

//---------------------------------------------------------------------------
//
//  Method:     CMessageCall::~CMessageCall
//
//  Synopsis:   CMessageCall destructor.
//
//---------------------------------------------------------------------------
CMessageCall::~CMessageCall()
{
    CallDebugOut((DEB_CALL, "CMessageCall::~CMessageCall this:%x\n",this));
    Win4Assert(_pHeader == NULL);
    Win4Assert(_pHandle == NULL);

    if (_hEvent != NULL)
    {
        // Release the event.
        gEventCache.Free(_hEvent);
    }

    SetSxsActCtx(INVALID_HANDLE_VALUE);
}

//---------------------------------------------------------------------------
//
//  Method:     CMessageCall::InitCallobject
//
//  Synopsis:   Initializes the call object before a call starts
//
//---------------------------------------------------------------------------
HRESULT CMessageCall::InitCallObject(CALLCATEGORY       callcat,
                                     RPCOLEMESSAGE     *original_msg,
                                     DWORD              flags,
                                     REFIPID            ipidServer,
                                     DWORD              destctx,
                                     COMVERSION         version,
                                     CChannelHandle    *handle)
{
    CallDebugOut((DEB_CALL, "CMessageCall::InitCallObject this:%x\n",this));
    ASSERT_LOCK_NOT_HELD(gCallLock); // no need to hold lock over this init code
    Win4Assert(_pHeader == NULL);
    Win4Assert(_pHandle == NULL);

    _iFlags = flags;     // set flags first

    if (_hEvent == NULL && (_iFlags & (client_cs | proxy_cs)))
    {
        // don't have an event yet, go get one
        // only needed for process-local calls
        HRESULT hr = gEventCache.Get(&_hEvent);
        if (FAILED(hr))
            return hr;
    }

    // the event should never be in the signalled state at this point
    Win4Assert(((_hEvent == NULL) || (WaitForSingleObject(_hEvent, 0) == WAIT_TIMEOUT)) &&
                       "InitCallObject: _hEvent Signalled in call object!\n");

    // set the destination context & version
    _destObj.SetDestCtx(destctx);
    _destObj.SetComVersion(version);

    _callcat               = callcat;
    _hResult               = S_OK;
    _ipid                  = ipidServer;
    _dwErrorBufSize 	   = 0;
    message                = *original_msg;
    hook.iid               = *MSG_TO_IIDPTR( original_msg );
    hook.cbSize            = sizeof(hook);

    _pHandle               = handle;
    if(_pHandle != NULL)
    {
        message.reserved1  = _pHandle->_hRpc;
        _pHandle->AddRef();  // AddRef interface pointers kept by the call.
    }

    m_ulCancelTimeout      = INFINITE;
    m_dwStartCount         = 0;
    m_pClientCtxCall       = NULL;
    m_pServerCtxCall       = NULL;

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Method:     CMessageCall::UninitCallobject
//
//  Synopsis:   Uninitializes the call object after a call completes
//
//---------------------------------------------------------------------------
void CMessageCall::UninitCallObject()
{
    CallDebugOut((DEB_CALL, "CMessageCall::UninitCallObject this:%x\n",this));
    ASSERT_LOCK_NOT_HELD(gCallLock); // no need to hold lock over this uninit code

    if(IsClientSide() && _pHeader != NULL)
    {
        // On the client side, Release the buffer
        if (ProcessLocal())
            PrivMemFree8(_pHeader);
        else if (message.Buffer)
            I_RpcFreeBuffer( (RPC_MESSAGE *) &message );
    }
    _pHeader = NULL;

    if (_pHandle != NULL)
    {
        // Release the handle.
        _pHandle->Release();
        _pHandle = NULL;
    }

    if (_pContext != NULL)
    {
        _pContext->Release();
        _pContext = NULL;
    }
}

//---------------------------------------------------------------------------
//
//  Method:     CMessageCall::SetCallerHwnd
//
//  Synopsis:   Set the calling thread's hWnd for the reply and free the
//              reply event (if any).
//
//---------------------------------------------------------------------------
HRESULT CMessageCall::SetCallerhWnd()
{
    // In 32bit, replies are done via Events, but for 16bit, replies
    // are done with PostMessage, so we dont need an event.  Not having
    // an event makes the callctrl modal loop a little faster.

    OXIDEntry *pLocalOXIDEntry;
    HRESULT hr = GetLocalOXIDEntry(&pLocalOXIDEntry);
    if (SUCCEEDED(hr))
    {
        _hWndCaller = pLocalOXIDEntry->GetServerHwnd();

        if(_hEvent != NULL)
        {
            gEventCache.Free(_hEvent);
            _hEvent = NULL;
        }
    }

    return hr;
}


//---------------------------------------------------------------------------
//
//  Method:     CAsyncCall::CAsyncCall
//
//  Synopsis:   Initialize the async state and call the CMessageCall
//              constructor
//
//---------------------------------------------------------------------------
CAsyncCall::CAsyncCall()
{
    CallDebugOut((DEB_CALL, "CAsyncCall::CAsyncCall this:%x\n",this));
    ASSERT_LOCK_NOT_HELD(gCallLock);

    _iRefCount          = 1;
    _lFlags             = 0;
    _pChnlObj           = NULL;
    _pRequestBuffer     = NULL;
    _pNext              = NULL;
}

//---------------------------------------------------------------------------
//
//  Method:     CAsyncCall::~CAsyncCall
//
//  Synopsis:   Cleanup the async state and call the CMessageCall
//              dtor
//
//---------------------------------------------------------------------------
CAsyncCall::~CAsyncCall()
{
    CallDebugOut((DEB_CALL, "CAsyncCall::~CAsyncCall this:%x\n",this));
    Win4Assert(_pChnlObj == NULL);
    Win4Assert(_pContext == NULL);
    Win4Assert(_iRefCount == 0);

#if DBG == 1
    _dwSignature = 0;
#endif
}

//---------------------------------------------------------------------------
//
//  Method:     CAsyncCall::InitCallObject
//
//  Synopsis:   Initialize the async state and the CMessageCall before
//              a call starts.
//
//---------------------------------------------------------------------------
HRESULT CAsyncCall::InitCallObject(CALLCATEGORY       callcat,
                                   RPCOLEMESSAGE     *pMsg,
                                   DWORD              flags,
                                   REFIPID            ipidServer,
                                   DWORD              destctx,
                                   COMVERSION         version,
                                   CChannelHandle    *handle)
{
    CallDebugOut((DEB_CALL, "CAsyncCall::InitCallObject this:%x\n",this));

    _lApt = GetCurrentApartmentId();

    // initialize the message call object
    HRESULT hr = CMessageCall::InitCallObject(callcat, pMsg, flags, ipidServer,
                                              destctx, version, handle);
    if (SUCCEEDED(hr))
    {
        // init async state structure to give to RPC
        RPC_STATUS sc = RpcAsyncInitializeHandle(&_AsyncState, sizeof(_AsyncState));
        if (RPC_S_OK == sc) 
        {
            _AsyncState.Flags                 = 0;
            _AsyncState.Event                 = RpcCallComplete;
            _AsyncState.NotificationType      = RpcNotificationTypeCallback;
            _AsyncState.u.NotificationRoutine = ThreadSignal;
            _eSignalState                     = none_ss;
            
            if ((message.rpcFlags & RPC_BUFFER_ASYNC) == 0)
                _iFlags |= fake_async_cs;
            
            message.rpcFlags |= RPC_BUFFER_ASYNC;
            
            if (pMsg->rpcFlags & RPC_BUFFER_ASYNC)
                SetClientAsync();
            
            if (flags & (client_cs | proxy_cs))
            {
                // on the client side
                if (FakeAsync())
                {
                    // Push this call object onto call stack which holds a reference.
                    hr = gCallTbl.PushCallObject(this);
                    Win4Assert(SUCCEEDED(hr) ? (_iRefCount == 2) : (_iRefCount == 1));
                    if(SUCCEEDED(hr))
                        _lFlags |= CALLFLAG_ONCALLSTACK;
                }
                else
                {
                    hr = S_OK;
                }
            }
        }
        else
        {
            hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, sc ); 
            Win4Assert(SUCCEEDED(hr));
        }
        // Make sure the DCOM_CALL_STATE does not overlap the CALLFLAG.
        Win4Assert( CALLFLAG_USERMODEBITS < 0x10000 );
    }

#if DBG==1
    _dwSignature = 0xAAAACA11;
    if(IsSTAThread())
        _lFlags |= CALLFLAG_STATHREAD;
    if(IsWOWThread())
        _lFlags |= CALLFLAG_WOWTHREAD;
#endif

    return hr;
}

//---------------------------------------------------------------------------
//
//  Method:     CAsyncCall::UninitCallObject
//
//  Synopsis:   Clean up the async call state after a call completes
//
//---------------------------------------------------------------------------
void CAsyncCall::UninitCallObject()
{
    CallDebugOut((DEB_CALL, "CAsyncCall::UninitCallObject this:%x\n",this));

    // reset state
    _pChnlObj = NULL;
    _lFlags = 0;

    // uninitialize the base class call object
    CMessageCall::UninitCallObject();
}

//+-------------------------------------------------------------------
//
//  Method:     CAsyncCall::InitClientHwnd, public
//
//  Synopsis:   Initializes the hwnd of the call object
//
//+-------------------------------------------------------------------
void CAsyncCall::InitClientHwnd()
{
    ASSERT_LOCK_NOT_HELD(gCallLock);
    if (IsSTAThread())
    {
        // Save the OXID we can post a message
        // when this thread needs to be Signaled.
        OXIDEntry *pOXIDEntry;
        GetLocalOXIDEntry(&pOXIDEntry);
        Win4Assert(pOXIDEntry);     // this can't fail at this time
        _hwndSTA = pOXIDEntry->GetServerHwnd();
    }
    else
    {
        _hwndSTA = 0;
    }
}

//---------------------------------------------------------------------------
//
//  Method:     CAsyncCall::InitForSendComplete
//
//  Synopsis:   Initialize the async state to receive send complete 
//              notifications
//
//---------------------------------------------------------------------------
HRESULT CAsyncCall::InitForSendComplete()
{                                   
    CallDebugOut((DEB_CALL, "CAsyncCall::InitForSendComplete this:%x\n",this));
    HRESULT hr = S_OK;
    // init async state structure to give to RPC
    RPC_STATUS sc = RpcAsyncInitializeHandle(&_AsyncState, sizeof(_AsyncState));
    if (RPC_S_OK == sc) {
       _AsyncState.Flags                       = 0;
       _AsyncState.Event                       = RpcSendComplete;
       _AsyncState.NotificationType            = RpcNotificationTypeApc;
       _AsyncState.u.APC.NotificationRoutine   = ThreadSignal;
       _AsyncState.u.APC.hThread               = 0;
       return hr;
    }
    hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, sc ); 
    Win4Assert(SUCCEEDED(hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Method:     CClientCall::CClientCall     public
//
//  Synopsis:   Constructor for the client call object
//
//+-------------------------------------------------------------------
CClientCall::CClientCall()
{
    CallDebugOut((DEB_CALL, "CClientCall::CClientCall this:%x\n", this));
    ASSERT_LOCK_NOT_HELD(gCallLock);

    m_cRefs   = 1;
    m_dwFlags = 0;

    m_dwThreadId = GetCurrentThreadId();

#if DBG == 1
    m_dwSignature      = 0xCCCCCA11;
    m_dwWorkerThreadId = 0;
#endif
}

//+-------------------------------------------------------------------
//
//  Method:     CClientCall::~CClientCall     public
//
//  Synopsis:   destructor for the client call object
//
//+-------------------------------------------------------------------
CClientCall::~CClientCall()
{
    CallDebugOut((DEB_CALL, "CClientCall::~CClientCall this:%x\n", this));
    Win4Assert(m_cRefs == 0);
}

//+-------------------------------------------------------------------
//
//  Method:     CClientCall::InitCallObject,  public
//
//  Synopsis:   Initialize the call object state before a call starts
//
//+-------------------------------------------------------------------
HRESULT CClientCall::InitCallObject(CALLCATEGORY       callcat,
                                    RPCOLEMESSAGE     *message,
                                    DWORD              flags,
                                    REFIPID            ipidServer,
                                    DWORD              destctx,
                                    COMVERSION         version,
                                    CChannelHandle    *handle)
{
    CallDebugOut((DEB_CALL, "CClientCall::InitCallObject this:%x\n",this));
    ASSERT_LOCK_NOT_HELD(gCallLock);

    // initialize the message call object
    HRESULT hr = CMessageCall::InitCallObject(callcat, message, flags, ipidServer,
                                              destctx, version, handle);
    if (SUCCEEDED(hr))
    {
        // Intialize the member variables
        m_hThread = 0;

        // Push this call object onto call stack
        if (flags & (client_cs | proxy_cs))
        {
            hr = gCallTbl.PushCallObject(this);
            Win4Assert(SUCCEEDED(hr) ? (m_cRefs == 2) : (m_cRefs == 1));
            if(SUCCEEDED(hr))
                m_dwFlags |= CALLFLAG_ONCALLSTACK;
        }
    }

#if DBG==1
    if(IsSTAThread())
            m_dwFlags |= CALLFLAG_STATHREAD;
    if(IsWOWThread())
            m_dwFlags |= CALLFLAG_WOWTHREAD;
#endif

    return hr;
}

//+-------------------------------------------------------------------
//
//  Method:     CClientCall::UninitCallObject,     public
//
//  Synopsis:   Cleanup call state after a call has completed.
//
//+-------------------------------------------------------------------
void CClientCall::UninitCallObject()
{
    CallDebugOut((DEB_CALL, "CClientCall::UninitCallObject this:%x\n",this));

#if DBG==1
    if (IsClientSide())
    {
        // Assert that the call finished
        Win4Assert(!(m_dwFlags & CALLFLAG_ONCALLSTACK) ||
                           (m_dwFlags & CALLFLAG_CALLFINISHED));;
        Win4Assert(!IsCallDispatched() || IsCallCompleted());
    }
#endif

    // turn off all except the STA & WOW thread markings
    m_dwFlags = 0;

    if (_pContext != NULL)
    {
        _pContext->Release();
        _pContext = NULL;
    }

    // uninitialize the message call object
    CMessageCall::UninitCallObject();
}

//---------------------------------------------------------------------------
//
//  Function:   GetCallObject, public
//
//  Synopsis:   Accquires either an async call object or client call object
//
//---------------------------------------------------------------------------
INTERNAL GetCallObject(BOOL fAsync, CMessageCall **ppCall)
{
    ASSERT_LOCK_NOT_HELD(gCallLock);

    HRESULT hr;
    COleTls tls(hr);
    if (SUCCEEDED(hr))
    {
        if (fAsync)
        {
            // find/create an async call object
            if (tls->pFreeAsyncCall)
            {
                // found an entry in TLS, take it
                *ppCall = (CMessageCall *) tls->pFreeAsyncCall;
                (*ppCall)->AddRef();
                tls->pFreeAsyncCall = NULL;
            }
            else
            {
                // not found, try the cache
                *ppCall = CAsyncCall::AllocCallFromList();
                if (*ppCall != NULL)
                {
                    (*ppCall)->AddRef();
                }
                else
                {
                    // still don't have one, go make a new one in the heap
                    *ppCall = (CMessageCall *) new CAsyncCall();
                }
            }
        }
        else
        {
            // find/create an client call object
            if (tls->pFreeClientCall)
            {
                // found an entry in TLS, take it
                *ppCall = (CMessageCall *) tls->pFreeClientCall;
                (*ppCall)->AddRef();
                tls->pFreeClientCall = NULL;
            }
            else
            {
                // not found, create one, either from the cache, or from the heap
                *ppCall = (CMessageCall *) new CClientCall();
            }
        }

        hr = (*ppCall == NULL) ? E_OUTOFMEMORY : S_OK;
    }
    else
        *ppCall = NULL;

    return hr;
}

//---------------------------------------------------------------------------
//
//  Method:     CAsyncCall::QueryInterface
//
//  Synopsis:   Queries an interface.
//
//---------------------------------------------------------------------------
STDMETHODIMP CAsyncCall::QueryInterface( REFIID riid, LPVOID FAR* ppvObj)
{
    if (IsEqualIID(riid, IID_ICancelMethodCalls) ||
        IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (ICancelMethodCalls *) this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Method:     CAsyncCall::AddRef
//
//  Synopsis:   Add a reference.
//
//---------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CAsyncCall::AddRef( )
{
    return InterlockedIncrement((long *)&_iRefCount);
}

//---------------------------------------------------------------------------
//
//  Method:     CAsyncCall::Release
//
//  Synopsis:   Release a reference.
//
//---------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CAsyncCall::Release( )
{
    ULONG lRef = InterlockedDecrement((long*)&_iRefCount);
    if (lRef == 0)
    {
        // uninitialize the call object
        UninitCallObject();

        // if there is room in tls, and this call belongs to the
        // current apartment, place the call object into TLS,
        // otherwise, delete it (which returns it to a cache)
        COleTls tls(TRUE);
        if ( !tls.IsNULL() &&
             tls->pFreeAsyncCall == NULL &&
             !(tls->dwFlags & OLETLS_THREADUNINITIALIZING) &&
             _lApt == GetCurrentApartmentId())
        {
            tls->pFreeAsyncCall = this;
        }
        else
        {
            // Add the structure to the list if the list is not full and
            // if the process is still initialized (since latent threads may try
            // to return stuff).
            if (!ReturnCallToList(this))
            {
                // no room in the cache, delete it
                delete this;
            }
        }
    }
    return lRef;
}

//+-------------------------------------------------------------------
//
//  Method:     CAsyncCall::GetState     public
//
//  Synopsis:   Returns the current status of call object
//
//+-------------------------------------------------------------------
HRESULT CAsyncCall::GetState(DWORD *pdwState)
{
    CallDebugOut((DEB_CALL, "CAsyncCall::GetState\n"));
    ASSERT_LOCK_NOT_HELD(gCallLock);

    if (ProcessLocal())
    {
        // For process local calls, check the call state.
        *pdwState = _lFlags & CALLFLAG_USERMODEBITS;
    }
    else
    {
        // Otherwise ask RPC
        RPC_STATUS status;

        if (IsClientSide())
        {
            // On the client, check for complete.
            status = RpcAsyncGetCallStatus( &_AsyncState );
            if (status == RPC_S_ASYNC_CALL_PENDING)
                *pdwState = DCOM_NONE;
            else
                *pdwState = DCOM_CALL_COMPLETE;
        }
        else
        {
            // On the server, check for cancel.
            status = RpcServerTestCancel( _hRpc );
            if (status == RPC_S_OK)
                *pdwState = DCOM_CALL_CANCELED;
            else
                *pdwState = DCOM_NONE;
        }
    }

    ASSERT_LOCK_NOT_HELD(gCallLock);
    return S_OK;
}


//+-------------------------------------------------------------------
//
//  Method:     CAsyncCall::CallCompleted     private
//
//  Synopsis:   This method is called when the reply for a call is
//              received.  If the call is canceled after this method
//              is invoked the reply must be freed.
//
//+-------------------------------------------------------------------
void CAsyncCall::CallCompleted(HRESULT hrRet)
{
#if DBG==1
    ULONG debFlags = DEB_CALL;
    if((CallInfoLevel & DEB_CANCEL) && IsCallCanceled())
            debFlags |= DEB_CANCEL;
    CallDebugOut((debFlags, "CAsyncCall::HRESULTCallComplete(0x%x, 0x%x)\n",
                              this, hrRet));
#endif
    Win4Assert(!(_lFlags & CALLFLAG_CALLCOMPLETED));

    // Aquire lock
    ASSERT_LOCK_NOT_HELD(gCallLock);
    LOCK(gCallLock);

    // Mark the call as having completed
    _lFlags |= CALLFLAG_CALLCOMPLETED;

    // Remove any pending cancel requests as the call has
    // completed before the client thread could detect
    // cancel
    if(_lFlags & CALLFLAG_CANCELISSUED)
    {
        Win4Assert(_lFlags & CALLFLAG_CALLCANCELED);
        _lFlags &= ~CALLFLAG_CANCELISSUED;
        _lFlags |= CALLFLAG_CLIENTNOTWAITING;
    }

    // Release lock
    UNLOCK(gCallLock);
    ASSERT_LOCK_NOT_HELD(gCallLock);
}

//+-------------------------------------------------------------------
//
//  Method:     CAsyncCall::CallCompleted     private
//
//  Synopsis:   This method is called for process local calls when
//              the server sends the reply.  It changes the state
//              and returns the previous state atomicly.
//
//+-------------------------------------------------------------------
void CAsyncCall::CallCompleted( BOOL *pCanceled )
{
#if DBG==1
    ULONG debFlags = DEB_CALL;
    if((CallInfoLevel & DEB_CANCEL) && IsCallCanceled())
        debFlags |= DEB_CANCEL;
    CallDebugOut((debFlags, "CAsyncCall::BOOLCallComplete(0x%x, 0x%x)\n",
                  this, pCanceled));
#endif
    Win4Assert(!(_lFlags & CALLFLAG_CALLCOMPLETED));

    // Aquire lock
    ASSERT_LOCK_NOT_HELD(gCallLock);
    LOCK(gCallLock);

    // Mark the call as having completed
    _lFlags   |= CALLFLAG_CALLCOMPLETED;
    *pCanceled = _lFlags & CALLFLAG_CALLCANCELED;

    // Release lock
    UNLOCK(gCallLock);
    ASSERT_LOCK_NOT_HELD(gCallLock);
}

//+-------------------------------------------------------------------
//
//  Method:     CAsyncCall::CallFinished     private
//
//  Synopsis:   This function is called when all normal activity on a call
//              is complete (ie, when SendReceive gets a transmission error
//              or FreeBuffer completes).  The only way a call can continue
//              to exist after this method is called is if someone has a
//              pointer to the cancel interface on the call.
//
//+-------------------------------------------------------------------
void CAsyncCall::CallFinished()
{
    CallDebugOut((DEB_CALL, "CAsyncCall::CallFinished this:%x\n",this));

    // Sanity check
    Win4Assert(!FakeAsync() || (_lFlags & CALLFLAG_ONCALLSTACK));

    // Aquire lock
    ASSERT_LOCK_NOT_HELD(gCallLock);
    LOCK(gCallLock);

    // Mark the call as having finished
    _lFlags |= CALLFLAG_CALLFINISHED;

    // Pop the call from the call stack for fake async calls
    if(FakeAsync())
    {
        gCallTbl.PopCallObject((ICancelMethodCalls *)this);
        _lFlags &= ~CALLFLAG_ONCALLSTACK;
    }

    // Release lock
    UNLOCK(gCallLock);
    ASSERT_LOCK_NOT_HELD(gCallLock);

    if(FakeAsync())
    {
        // Fix up the refcount
        Release();
    }

    return;
}

//+-------------------------------------------------------------------
//
//  Method:     CAsyncCall::CallSent     private
//
//  Synopsis:   This method is called when the request has been sent.
//              Cancels that arrive before this method is invoked are
//              flagged.  Cancels that arrive after this method is
//              invoked can use the RPC cancel APIs.
//
//+-------------------------------------------------------------------
HRESULT CAsyncCall::CallSent()
{
    CallDebugOut((DEB_CALL, "CAsyncCall::CallSent this:%x\n",this));
    Win4Assert(!(_lFlags & CALLFLAG_CALLSENT));

    HRESULT hr = S_OK;

    // Aquire lock
    ASSERT_LOCK_NOT_HELD(gCallLock);
    LOCK(gCallLock);

    // Mark the call as having been sent.
    _lFlags |= CALLFLAG_CALLSENT;

    // Check if the call was canceled before it was sent
    if((_lFlags & CALLFLAG_CALLCANCELED) && !FakeAsync())
        hr = RPC_E_CALL_CANCELED;

    // Release lock
    UNLOCK(gCallLock);
    ASSERT_LOCK_NOT_HELD(gCallLock);

    return hr;
}

//+-------------------------------------------------------------------
//
//  Method:     CAsyncCall::WOWMsgArrived     private
//
//  Synopsis:   For WOW threads, there is a time lag between server
//              thread posting the OLE call completion message and
//              the client thread receiving the message. This method
//              is invoked by the client WOW thread that made the COM
//              call after it receives the OLE call completion message
//
//+-------------------------------------------------------------------
HRESULT CAsyncCall::WOWMsgArrived()
{
    CallDebugOut((DEB_CALL, "CAsyncCall::WOWMsgArrived this:%x\n",this));
    ASSERT_LOCK_NOT_HELD(gCallLock);
    LOCK(gCallLock);

    // Mark the call as having finished
    _lFlags |= CALLFLAG_WOWMSGARRIVED;

    UNLOCK(gCallLock);
    ASSERT_LOCK_NOT_HELD(gCallLock);
    return(S_OK);
}

//+-------------------------------------------------------------------
//
//  Method:     CAsyncCall::CanDispatch     public
//
//  Synopsis:   Returns S_OK if the call has not already been canceled
//              This calls handles the case when the call is canceled
//              between the GetBuffer and SendReceive
//
//+-------------------------------------------------------------------
HRESULT CAsyncCall::CanDispatch()
{
    CallDebugOut((DEB_CALL, "CAsyncCall::CanDispatch this:%x\n",this));

    HRESULT hr;
    ASSERT_LOCK_NOT_HELD(gCallLock);
    LOCK(gCallLock);

    // Check if the call has been canceled
    if (_lFlags & CALLFLAG_CALLCANCELED && (m_ulCancelTimeout == 0))
    {
        hr = RPC_E_CALL_CANCELED;
    }
    else
    {
        // Update state
        hr = S_OK;
        m_dwStartCount = GetTickCount();
        _lFlags |= CALLFLAG_CALLDISPATCHED;
    }

    UNLOCK(gCallLock);
    ASSERT_LOCK_NOT_HELD(gCallLock);
    return(hr);
}

//+-------------------------------------------------------------------
//
//  Method:     CAsyncCall::Cancel     public
//
//  Synopsis:   Updates current status of call object
//
//  Descrption: This method is valid only on the client side for
//              canceling call
//
//+-------------------------------------------------------------------
HRESULT CAsyncCall::Cancel(ULONG ulTimeout)
{
    return Cancel(FALSE, ulTimeout);
}

//+-------------------------------------------------------------------
//
//  Method:     CAsyncCall::Cancel     public
//
//  Synopsis:   Updates current status of call object
//
//  Descrption: Since the async call object is not copied, the _iFlags
//              field always has the proxy bit set.
//
//+-------------------------------------------------------------------
HRESULT CAsyncCall::Cancel(BOOL fModalLoop, ULONG ulTimeout)
{
    CallDebugOut((DEB_CALL|DEB_CANCEL, "CAsyncCall::Cancel(0x%x, 0x%x, 0x%x)\n",
                              this, fModalLoop, ulTimeout));

    HRESULT hr;
    BOOL    fCancel = FALSE, fSignal = FALSE;

    // Assert that the call object is on the client side
    Win4Assert(IsClientSide());

    // check if cancel is enabled
    if (!(CancelEnabled() || fModalLoop))
    {
        HRESULT hr = CO_E_CANCEL_DISABLED;
        CallDebugOut((DEB_CALL|DEB_CANCEL,
                      "CAsyncCall::Cancel this:0x%x returning 0x%x - cancel disabled\n",
                       this, hr));
        return(hr);
    }

    // Assert that modal loop cancels have 0 timeout value
    Win4Assert(!fModalLoop || ulTimeout==0);

    // Validate arguments
    if(!fModalLoop && (_lFlags & CALLFLAG_WOWTHREAD))
    {
        // Support cancel for calls made by WOW threads
        // only from modal loop
        return(E_NOTIMPL);
    }
    else if(_callcat == CALLCAT_INPUTSYNC)
    {
        // Do not provide cancel support for Input Sync calls
        return(E_FAIL);
    }

    // Aquire COM lock
    ASSERT_LOCK_NOT_HELD(gCallLock);
    LOCK(gCallLock);

    // Check state
    do
    {
        // Initialize
        hr = S_OK;

        if(_lFlags & (CALLFLAG_CALLCOMPLETED | CALLFLAG_CALLFINISHED))
        {
            // Call has completed
            hr = RPC_E_CALL_COMPLETE;
        }
        else if(_lFlags & CALLFLAG_CALLCANCELED)
        {
            // Do not support increasing cancel timeout
            if(m_ulCancelTimeout < ulTimeout)
                    hr = RPC_E_CALL_CANCELED;
        }
        else if(!FakeAsync() && (ulTimeout>0 && ulTimeout!=(ULONG)INFINITE))
        {
            // RPC does not support cancel timeout for async calls

            // Release lock
            UNLOCK(gCallLock);
            ASSERT_LOCK_NOT_HELD(gCallLock);

            // Check if TLS is initialized
            COleTls Tls(FALSE);

            // Call RPC to perform advisory cancel
            // We don't really care about the return code here....
            // but PREfix complains when we don't check it.  
            RPC_STATUS ignore = RpcAsyncCancelCall(&_AsyncState, FALSE);

            // Block this thread for the requested time
            if(Tls.IsNULL() || IsMTAThread())
            {
                Sleep(ulTimeout*1000);
            }
            else
            {
                // Create modal loop object
                // Since this is an async call, the callcat must
                // be CALLCAT_ASYNC. INPUTSYNC is explicitly
                // prevented above
                CCliModalLoop CML(0, gMsgQInputFlagTbl[CALLCAT_ASYNC], 0);

                // Start timer
                CML.StartTimer(ulTimeout*1000);

                // Loop till timer expires
                while (!CML.IsTimerAtZero())
                {
                    CML.BlockFn(NULL, 0, NULL);
                }
            }

            // Reset timeout
            ulTimeout = 0;

            // Reaquire COM lock
            ASSERT_LOCK_NOT_HELD(gCallLock);
            LOCK(gCallLock);

            // Loop back to check state
            hr = S_FALSE;
        }
    } while(hr == S_FALSE);

    if(hr == S_OK)
    {
        // Check if the thread that made the call is aware of
        // an earlier cancel request with timeout
        if(_lFlags & CALLFLAG_CANCELISSUED)
        {
            // Assert that this is a fake async call
            Win4Assert(FakeAsync());
            // Assert that we do not land here for calls made
            // by WOW threads
            Win4Assert(!(_lFlags & CALLFLAG_WOWTHREAD));

            // Just change the timeout to the new value as
            // the thread that made the call is still not aware
            // of the earlier cancel reuest
            Win4Assert(_lFlags & CALLFLAG_CALLCANCELED);
            m_ulCancelTimeout = ulTimeout;

            // If cancel is happening from inside the modal loop
            // wait on the event to revert its state
            if(fModalLoop)
            {
                Win4Assert(!ProcessLocal() && FakeAsync());
                Win4Assert(_hEvent);
                WaitForSingleObject(_hEvent, INFINITE);

                // Update state for modal loop cancels before
                // issuing RPC cancel
                _lFlags &= ~CALLFLAG_CANCELISSUED;

                // Cancel the call using RPC
                fCancel = TRUE;
            }
            // Else there is no more work to do as the thread that
            // made the call will wake up and process the
            // earlier cancel request
        }
        else
        {
            // Update the state
            if(!(_lFlags & CALLFLAG_CALLCANCELED))
                m_dwStartCount = GetTickCount();
            _lFlags |= CALLFLAG_CALLCANCELED;
            m_ulCancelTimeout = ulTimeout;

            // Assert that cancel from modal loop happens only after the
            // call has been dispatched
            Win4Assert(!fModalLoop || (FakeAsync() && IsCallDispatched()));

            // Assert that calls made by WOW threads can only be canceled
            // from inside modal loop
            Win4Assert(!(_lFlags & CALLFLAG_WOWTHREAD) || fModalLoop);

            // For pure async calls, there is no need to issue
            // cancel if the call has not yet been sent.
            // For FakeAsync calls, wake up the client thread
            // for positive cancel timeout values only if the call
            // has not been dispatched yet
            if(FakeAsync() ? (IsCallDispatched() || m_ulCancelTimeout>0) :
               IsCallSent())
            {
                if(ProcessLocal())
                {
                    // Assert that the call object does not represent
                    // a fake async call
                    Win4Assert(!FakeAsync());
                    Win4Assert(!fModalLoop);

                    // WOW threads cannot make async calls because there
                    // is no support for them in the thunking code
                    Win4Assert(!(_lFlags & CALLFLAG_WOWTHREAD));

                    // Inform the client that the call was canceled
                    if(ulTimeout == 0)
                    {
                        _lFlags |= CALLFLAG_CLIENTNOTWAITING;
                        fSignal = TRUE;
                    }
                }
                else
                {
                    // Check for fake async calls
                    if(FakeAsync())
                    {
                        Win4Assert(_hEvent);

                        // Do not call RPC async cancel function holding
                        // our lock
                        if(fModalLoop)
                        {
                            // Cancel the call using RPC
                            fCancel = TRUE;
                        }
                        else
                        {
                            // Wake up the actual client thread from the modal
                            // loop after updating state so that it knows
                            // there is timeout value
                            _lFlags |= CALLFLAG_CANCELISSUED;
                            SetEvent(_hEvent);
                        }
                    }
                    else
                    {
                        // For true async calls, cancel the call using RPC
                        // directly
                        fCancel = TRUE;
                    }
                }
            }
        }
    }

    // Release lock
    UNLOCK(gCallLock);
    ASSERT_LOCK_NOT_HELD(gCallLock);

    // Check for the need to cancel
    if(fSignal)
    {
        SignalTheClient(this);
    }
    else
    {
        // REVIEW: For normal async calls, the call could have completed
        //         after we released the lock above. The call completion
        //         might have called I_RpcFreeBuffer making the RPC state
        //         associated for the cancel stale
        if(fCancel)
        {
	   // Narrow the window for the race mentioned above
	   if(_lFlags & (CALLFLAG_CALLCOMPLETED | CALLFLAG_CALLFINISHED))
	   {
	       // Call has completed
	       hr = RPC_E_CALL_COMPLETE;
	   }
	   else
	   {
	      CallDebugOut((DEB_CALL|DEB_CANCEL,
			   "0x%x --> RpcAsyncCancelCall(0x%x, 0x%x)\n",
			    this, &_AsyncState, TRUE));
	      RPC_STATUS rpcStatus = RpcAsyncCancelCall(&_AsyncState, TRUE);
	      CallDebugOut((DEB_CALL|DEB_CANCEL,
			    "0x%x <-- RpcAsyncCancelCall returns 0x%x\n",
			     this, rpcStatus));
	      if(rpcStatus==RPC_S_OK)
	      {
		  if(fModalLoop)
		  {
		      Win4Assert(_hEvent);
		      WaitForSingleObject(_hEvent, INFINITE);
		  }
	      }
	      else
		  CallDebugOut((DEB_WARN,
			       "This: 0x%x RpcAsyncCancelCall failed returning 0x%x\n",
				this, rpcStatus));
	   }
        }
    }

    CallDebugOut((DEB_CALL|DEB_CANCEL,
                "CAsyncCall::Cancel this:0x%x returning 0x%x\n", this, hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CAsyncCall::TestCancel     public
//
//  Synopsis:   Answers whether the current call has been canceled
//
//+-------------------------------------------------------------------
STDMETHODIMP CAsyncCall::TestCancel()
{
    CallDebugOut((DEB_CALL, "CAsyncCall::TestCancel this:%x\n",this));
    ASSERT_LOCK_NOT_HELD(gCallLock);

    HRESULT hr = RPC_S_CALLPENDING;
    if(IsClientSide() || ProcessLocal())
    {
        if(_lFlags & CALLFLAG_CALLCANCELED)
            hr = RPC_E_CALL_CANCELED;
        else if(_lFlags & CALLFLAG_CALLCOMPLETED)
            hr = RPC_E_CALL_COMPLETE;
    }
    else
    {
        if(RpcServerTestCancel(_hRpc) == RPC_S_OK)
            hr = RPC_E_CALL_CANCELED;
    }

    return(hr);
}

//+-------------------------------------------------------------------
//
//  Method:     CAsyncCall::AdvCancel     public
//
//  Synopsis:   Implements advisory cancel for async calls
//              Called from inside modal loop
//
//+-------------------------------------------------------------------
HRESULT CAsyncCall::AdvCancel()
{
    // Sanity check
    ASSERT_LOCK_NOT_HELD(gCallLock);
    Win4Assert(FakeAsync());

    // Call RPC to perform advisory cancel
    CallDebugOut((DEB_CALL|DEB_CANCEL,
                  "0x%x --> RpcAsyncCancelCall(0x%x, 0x%x)\n",
                   this, &_AsyncState, FALSE));
    RPC_STATUS rpcStatus = RpcAsyncCancelCall(&_AsyncState, FALSE);
    CallDebugOut((DEB_CALL|DEB_CANCEL,
                  "0x%x <-- RpcAsyncCancelCall returns 0x%x\n",
                   this, rpcStatus));

    if (rpcStatus == RPC_S_OK)
        return S_OK;

    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
//  Function:   ThreadSignal
//
//  Synopsis:   Called by RPC to notify state changes of async calls.
//              Invokes the call's ISynchronize::Signal.
//
//----------------------------------------------------------------------------
void ThreadSignal(struct _RPC_ASYNC_STATE *hAsync, void *Context,
                  RPC_ASYNC_EVENT event )
{
    CAsyncCall *pCall = (CAsyncCall *)
                       (((char *) hAsync) - offsetof(CAsyncCall, _AsyncState));

    CallDebugOut((DEB_CALL|DEB_CANCEL,
                 "ThreadSignal(Call:0x%x, Context:0x%x, Event:0x%x)\n",
                  pCall, Context, event));
        
    // If TLS can't be initialized, give up.
    HRESULT hr;
    COleTls Tls(hr);
    if (FAILED(hr))
        return;

    // Client side
    if(RpcCallComplete == event)
    {
        Win4Assert( pCall->_eSignalState == pending_ss );
        pCall->_eSignalState = signaled_ss;
        
        if (pCall->_pChnlObj != NULL)
        {
            // Signal the Client.
    
            // Assert this is normal async call
            Win4Assert(!pCall->FakeAsync());
    
            // Inform call object about call completion
            pCall->CallCompleted(S_OK);
    
            SignalTheClient(pCall);
        }
        else
        {
            // Set the call event.
#if DBG==1
            pCall->Signaled();
#endif
    
            // Assert that this is fake async call
            Win4Assert(pCall->FakeAsync());
    
            // Inform call object about call completion
            pCall->CallCompleted(S_OK);
    
            // Wake up client thread after ensuring that
            // it is waiting
            if(pCall->IsClientWaiting())
                SetEvent(pCall->GetEvent());
    
            // Async call objects are addrefed before calling RPC
            pCall->Release();
        }
    }
    // Server side
    else if(RpcSendComplete == event) 
    {
        Win4Assert(0 < Tls->cAsyncSends);
        // Unchain it from the list
        Win4Assert(Tls->pAsyncCallList);
        CAsyncCall* pThis = Tls->pAsyncCallList;
        CAsyncCall* pPrev = NULL;
        while((NULL != pThis) && (pThis != pCall))
        {
            pPrev = pThis;
            pThis = pThis->_pNext; 
        }
        // Found a match
        if(pThis == pCall)
        {
            // Decrement the number of async sends outstanding
            Tls->cAsyncSends--;
            if(NULL == pPrev)
            {
                // First element in the list matched
                Tls->pAsyncCallList = Tls->pAsyncCallList->_pNext; 
            }
            else
            {
                // Element is in the middle of the list
                pPrev->_pNext = pThis->_pNext;
            }
            // Async call objects are addrefed before calling RPC
            pCall->Release();
        }
        else
        {
            Win4Assert(FALSE && 
                       "Callback from RPC for non-existent call object");
        }
    }
    else
    {
        Win4Assert("Unexpected callback from RPC to ThreadSignal");
    }
}

//---------------------------------------------------------------------------
//
//  Method:     CAsyncCall::Cleanup
//
//  Synopsis:   Free all elements in the cache.
//
//---------------------------------------------------------------------------
/* static */
void CAsyncCall::Cleanup()
{
    ASSERT_LOCK_NOT_HELD(gCallLock);
    LOCK(gCallLock);

    if (_iNext <= CALLCACHE_SIZE)
    {
        // Release all calls.
        for (DWORD i = 0; i < _iNext; i++)
        {
            if (_aList[i] != NULL)
            {
                delete _aList[i];
                _aList[i] = NULL;
            }
        }
        _iNext = 0;
    }

    UNLOCK(gCallLock);
    ASSERT_LOCK_NOT_HELD(gCallLock);
}

//+---------------------------------------------------------------------------
//
//  Function:   SignalTheClient
//
//  Synopsis:   Propgates the signal for a finished async cal to the correct
//              client.
//
//----------------------------------------------------------------------------
void  SignalTheClient(CAsyncCall *pCall)
{
    ComDebOut((DEB_CHANNEL, "SignalTheClient[in] pCall:0x%x\n", pCall));
    ASSERT_LOCK_NOT_HELD(gCallLock);

    Win4Assert(GetCurrentApartmentKind() != APTKIND_NEUTRALTHREADED);

#if DBG==1
    pCall->Signaled();
#endif
    CChannelObject *pChnlObj = pCall->_pChnlObj;
    pCall->_pChnlObj = NULL;

    if (pCall->_lApt == NTATID)
    {
        COleTls tls;
        if (tls.IsNULL() == FALSE) //com1.x bug 25441. If we can't allocate tls, can't enter NTA. This hangs client, though.
        {
            CObjectContext *pSaveContext = EnterNTA(g_pNTAEmptyCtx);
            ComSignal(pChnlObj);
            pSaveContext = LeaveNTA(pSaveContext);
            Win4Assert(pSaveContext == g_pNTAEmptyCtx);
        }
    }
    else if (pCall->_lApt == MTATID)
    {
        // caller is in the MTA
        if (IsSTAThread())
        {
            // send to a cached MTA thread
            CacheCreateThread(ComSignal, pChnlObj);
        }
        else
        {
            // We are already on an MTA thread, probably on an RPC
            // thread.  Just signal the call directly from this
            // thread.
            Win4Assert(!IsThreadInNTA());
            ComSignal(pChnlObj);
        }
    }
    else
    {
        Win4Assert(pCall->_hwndSTA);

        // there is a window for us to call back
        // on.  this means we need to switch threads so
        // the signal will happen in the callers apartment

        // if this fails, there's not much we can do about it,
        // since we can't call release from this apartment.  Worst
        // case would be that the object leaks, however, if the
        // PostMessage fails it is probably because the apartment
        // has alread shut down.

        if (!PostMessage(pCall->_hwndSTA, WM_OLE_SIGNAL,
                         WMSG_MAGIC_VALUE, (LPARAM) pChnlObj))
        {
            ComDebOut((DEB_ERROR, "SignalTheClient: PostMessage to switch threads failed!\n"));
        }
    }

    ComDebOut((DEB_CHANNEL, "SignalTheClient[out] \n"));
}

//+---------------------------------------------------------------------------
//
//  Function:   ComSignal
//
//  Synopsis:   Called after switching to the correct apartment.  Signals
//              the caller and then releases the reference we hold during
//              the call.
//
//----------------------------------------------------------------------------
DWORD _stdcall ComSignal(void *pParam)
{
    ASSERT_LOCK_NOT_HELD(gCallLock);
    CChannelObject *pChnlObj = (CChannelObject *) pParam;
    ComDebOut((DEB_CHANNEL, "ComSignal [in] pChnlObj:0x%x\n", pChnlObj));

    pChnlObj->Signal();

    ComDebOut((DEB_CHANNEL, "ComSignal [out]\n"));
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Method:     CClientCall::QueryInterface     public
//
//  Synopsis:   QI behavior of client call object
//
//+-------------------------------------------------------------------
STDMETHODIMP CClientCall::QueryInterface(REFIID riid, LPVOID *ppv)
{
    CallDebugOut((DEB_CALL, "CClientCall::QueryInterface this:%x riid:%I\n",
                              this, &riid));

    if(IsEqualIID(riid, IID_ICancelMethodCalls) ||
       IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (ICancelMethodCalls *) this;
    }
    else
    {
        *ppv = NULL;
        return(E_NOINTERFACE);
    }

    // AddRef the interface before return
    ((IUnknown *) (*ppv))->AddRef();
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Method:     CClientCall::AddRef     public
//
//  Synopsis:   AddRefs client call object
//
//+-------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClientCall::AddRef()
{
    CallDebugOut((DEB_CALL, "CClientCall::AddRef this:%x\n",this));

    ULONG cRefs = InterlockedIncrement((LONG *)& m_cRefs);
    if(m_dwFlags & CALLFLAG_INDESTRUCTOR)
    {
        // Always return 0 when inside the destructor
        cRefs = 0;
    }

    return(cRefs);
}

//+-------------------------------------------------------------------
//
//  Method:     CClientCall::Release     public
//
//  Synopsis:   Release client call object. Gaurds against
//              double destruction that can happen if it aggregates
//              another object and gets nested AddRef and Release on
//              the thread invoking the destructor
//
//+-------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClientCall::Release()
{
    CallDebugOut((DEB_CALL, "CClientCall::Release this:%x\n",this));

    ULONG cRefs = InterlockedDecrement((LONG *) &m_cRefs);
    if(cRefs == 0)
    {
        // uninitialize the call object
        UninitCallObject();

        // if there is room, place this call object into TLS,
        // otherwise, delete it.
        COleTls tls(TRUE);
        if ( !tls.IsNULL() &&
             tls->pFreeClientCall == NULL &&
             !(tls->dwFlags & OLETLS_THREADUNINITIALIZING) &&
             m_dwThreadId == GetCurrentThreadId())
        {
            tls->pFreeClientCall = this;
        }
        else
        {
            // Mark as in destructor & delete the call
             m_dwFlags |= CALLFLAG_INDESTRUCTOR;
             delete this;
        }
    }

    return(cRefs);
}

//+-------------------------------------------------------------------
//
//  Method:     CClientCall::operator new     public
//
//  Synopsis:   new operator for client call object
//
//+-------------------------------------------------------------------
void *CClientCall::operator new(size_t size)
{
    Win4Assert(size == sizeof(CClientCall) &&
               "Client Call object should not be inherited");

    void *pCall = NULL;

    ASSERT_LOCK_NOT_HELD(gCallLock);
    LOCK(gCallLock);
    if (_iNext > 0 && _iNext < CALLCACHE_SIZE+1)
    {
        // Get the last entry from the cache.
        _iNext--;
        pCall = _aList[_iNext];
        _aList[_iNext] = NULL;
    }
    UNLOCK(gCallLock);
    ASSERT_LOCK_NOT_HELD(gCallLock);

    if (pCall == NULL)
    {
        // None available in the cache, allocate a new one. Don't
        // hold the lock over heap allocations
        pCall = PrivMemAlloc(size);
    }

    return pCall;
}

//+-------------------------------------------------------------------
//
//  Method:     CClientCall::operator delete     public
//
//  Synopsis:   delete operator for Client call object
//
//+-------------------------------------------------------------------
void CClientCall::operator delete(void *pCall)
{
    // Add the structure to the list if the list is not full and
    // if the process is still initialized (since latent threads may try
    // to return stuff).

    ASSERT_LOCK_NOT_HELD(gCallLock);
    LOCK(gCallLock);
    if (_iNext < CALLCACHE_SIZE && gfChannelProcessInitialized)
    {
        _aList[_iNext] = pCall;
        _iNext++;
        pCall = NULL;  // don't need to memfree
    }
    UNLOCK(gCallLock);
    ASSERT_LOCK_NOT_HELD(gCallLock);

    if (pCall)
    {
        // no room in cache, return to heap.
        // don't hold lock over heap free
        PrivMemFree(pCall);
    }
}

//+-------------------------------------------------------------------
//
//  Method:     CClientCall::Cleanup     public
//
//  Synopsis:   Either performs cleanup or updates the state such that
//              cleanup is performed when the last object is destroyed
//
//+-------------------------------------------------------------------
/* static */
void CClientCall::Cleanup()
{
    CallDebugOut((DEB_CALL, "CClientCall::Cleanup\n"));
    ASSERT_LOCK_NOT_HELD(gCallLock);
    LOCK(gCallLock);

    if (_iNext <= CALLCACHE_SIZE)
    {
        // Release all calls.
        for (DWORD i = 0; i < _iNext; i++)
        {
            if (_aList[i] != NULL)
            {
                delete _aList[i];
                _aList[i] = NULL;
            }
        }
        _iNext = 0;
    }

    UNLOCK(gCallLock);
    ASSERT_LOCK_NOT_HELD(gCallLock);
}

//+-------------------------------------------------------------------
//
//  Method:     CClientCall::GetState     public
//
//  Synopsis:   Returns the current status of call object
//
//+-------------------------------------------------------------------
HRESULT CClientCall::GetState(DWORD *pdwState)
{
    CallDebugOut((DEB_CALL, "CClientCall::GetState this:%x\n",this));
    ASSERT_LOCK_NOT_HELD(gCallLock);

    *pdwState = (m_dwFlags & CALLFLAG_USERMODEBITS);
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Method:     CClientCall::CallCompleted     private
//
//  Synopsis:   Completes the specified call. To avoid race condtions
//              between cancel and complete, both Complete and Cancel
//              methods should use the same synchronization event for
//              waking up the thread that made the call.
//
//              This method is invoked by the server thread for process local
//              calls and by the thread that made the RPC call for
//              process remote calls
//
//              To prevent the race in canceling RPC calls, the thread
//              waits alertably if the call completes successfully
//              after it was canceled, so that any pending user mode
///             cancel APC enqueued by RPC would be removed
//
//+-------------------------------------------------------------------
void CClientCall::CallCompleted(HRESULT hrRet)
{
#if DBG==1
    ULONG debFlags = DEB_CALL;
    if((CallInfoLevel & DEB_CANCEL) && IsCallCanceled())
            debFlags |= DEB_CANCEL;
#endif
    CallDebugOut((debFlags, "CClientCall::CallComplete(0x%x, 0x%x)\n",
                              this, hrRet));

    // Assert that this method is invoked only once
    Win4Assert(!(m_dwFlags & CALLFLAG_CALLCOMPLETED));

    // Assert that the method is invoked by the thread that
    // made the actual call
    Win4Assert(m_dwWorkerThreadId == GetCurrentThreadId());

    // Aquire lock
    ASSERT_LOCK_NOT_HELD(gCallLock);
    LOCK(gCallLock);

    // Mark the call as having completed
    m_dwFlags |= CALLFLAG_CALLCOMPLETED;

    // Update state
    if(m_dwFlags & CALLFLAG_CALLCANCELED)
    {
        // Check if the call is process local
        if(ProcessLocal())
        {
            // Remove any pending cancel requests as the call has
            // completed before the client thread could detect
            // cancel
            if(m_dwFlags & CALLFLAG_CANCELISSUED)
            {
                m_dwFlags &= ~CALLFLAG_CANCELISSUED;
                m_dwFlags |= CALLFLAG_CLIENTNOTWAITING;
            }
        }
        else
        {
            // Assert that STA threads do not make cross process
            // SYNC calls
            Win4Assert(!(m_dwFlags & CALLFLAG_STATHREAD) &&
                               "STA thread is making a SYNC call");

            // Prevent the race in canceling RPC calls
            if(hrRet != RPC_E_CALL_CANCELED)
            {
                if(_hEvent)
                {
                    // Wait on the call event alertably to remove
                    // pending Cancel APC enqueued by RPC runtime
                    WaitForSingleObjectEx(_hEvent, 0, TRUE);
                }
                else
                {
                    // Sleep alertably for zero seconds. Note that
                    // this makes the thread forgo the rest of the
                    // CPU time slice
                    SleepEx(0, TRUE);
                }
            }
        }
    }

    // Release lock
    UNLOCK(gCallLock);
    ASSERT_LOCK_NOT_HELD(gCallLock);
}

//+-------------------------------------------------------------------
//
//  Method:     CClientCall::CallFinished     private
//
//  Synopsis:   The specified call is marked as finished. This method
//              is invoked by the thread that made the COM call when
//              it is unblocked.
//
//              NOTE: The call object might be destroyed in this method
//                    call. The caller should be careful not to touch
//                    any member variables of the call object after
//                    this method call
//+-------------------------------------------------------------------
void CClientCall::CallFinished()
{
    CallDebugOut((DEB_CALL, "CClientCall::CallFinished this:%x\n",this));

    // Ensure that the method is invoked by the thread that
    // made the COM call
    Win4Assert(m_dwThreadId == GetCurrentThreadId());
    Win4Assert(m_dwFlags & CALLFLAG_ONCALLSTACK);

    // Aquire lock
    ASSERT_LOCK_NOT_HELD(gCallLock);
    LOCK(gCallLock);

    // Mark the call as having finished
    m_dwFlags |= CALLFLAG_CALLFINISHED;

    // Pop this call object from the call stack
    gCallTbl.PopCallObject((ICancelMethodCalls *)this);
    m_dwFlags &= ~CALLFLAG_ONCALLSTACK;

    // Release lock
    UNLOCK(gCallLock);
    ASSERT_LOCK_NOT_HELD(gCallLock);

    // Fixup the refcount
    Release();
}

//+-------------------------------------------------------------------
//
//  Method:     CClientCall::WOWMsgArrived     private
//
//  Synopsis:   For WOW threads, there is a time lag between server
//              thread posting the OLE call completion message and
//              the client thread receiving the message. This method
//              is invoked by the client WOW thread that made the COM
//              call after it receives the OLE call completion message
//
//+-------------------------------------------------------------------
HRESULT CClientCall::WOWMsgArrived()
{
    CallDebugOut((DEB_CALL, "CClientCall::WOWMsgArrived this:%x\n",this));
    ASSERT_LOCK_NOT_HELD(gCallLock);

    // Ensure that the method is invoked by the thread that
    // made the COM call
    Win4Assert(m_dwThreadId == GetCurrentThreadId());

    // Aquire lock
    LOCK(gCallLock);

    // Mark the call as having finished
    m_dwFlags |= CALLFLAG_WOWMSGARRIVED;

    // Release lock
    UNLOCK(gCallLock);

    ASSERT_LOCK_NOT_HELD(gCallLock);
    return(S_OK);
}


//+-------------------------------------------------------------------
//
//  Method:     CClientCall::CanDispatch     public
//
//  Synopsis:   Returns S_OK if the call has not already been canceled
//              This calls handles the case when the call is canceled
//              between the GetBuffer and SendReceive
//
//              IMPORTANT NOTE: This method should be invoked on the
//                              thread that is going to make RPC call
//
//+-------------------------------------------------------------------
HRESULT CClientCall::CanDispatch()
{
    CallDebugOut((DEB_CALL, "CClientCall::CanDispatch this:%x\n",this));
    ASSERT_LOCK_NOT_HELD(gCallLock);

    HRESULT hr;
    BOOL fRet;
    HANDLE hThread = NULL;
    DWORD dwThreadId = GetCurrentThreadId();

#if DBG == 1
    
    // Ensure that for process local calls, the thread making the call
    // is different from thread that made the COM call
    
    if(ProcessLocal() && !Neutral() && !IsNAToMTAFlagSet() && !IsNAToSTAFlagSet())
        Win4Assert(m_dwThreadId != dwThreadId);
    
    // NOTE:The original test is not valid for calls from the NA on a proxy
    // because before the call is dispatched we leave the NA
    // Hence added the new flag. Also the original test was
    // checking if the current thread is in the NA. This is
    // wrong, the correct test is to check if the server is in the NA -Sajia.
	
    if (!ProcessLocal())
    {
       // Ensure that MTA threads make direct RPC calls
       if(!(m_dwFlags & CALLFLAG_STATHREAD))
	   Win4Assert(m_dwThreadId == dwThreadId);
       // Ensure that STA threads do not make direct RPC calls
       else
	   Win4Assert(IsThreadInNTA() || m_dwThreadId != dwThreadId);
       // NOTE: the STA check above is useless because remote calls 
       // from the STA are always async, so we don't get here -Sajia.
    }
    // Save the worker thread id
    m_dwWorkerThreadId = dwThreadId;
#endif

    // Aquire lock
    LOCK(gCallLock);

    // Check if the call has been canceled
    if((m_dwFlags & CALLFLAG_CALLCANCELED) && (m_ulCancelTimeout == 0))
    {
        hr = RPC_E_CALL_CANCELED;
    }
    else
    {
        // Initialize the return value
        hr = S_OK;
        m_dwStartCount = GetTickCount();

        // Obtain non psuedo handle to the thread for calls
        // other than process local calls
        if(!ProcessLocal())
        {
            COleTls Tls(hr);

            // Initialize
            if(SUCCEEDED(hr))
                    hThread = Tls->hThread;

            // Assert that STA threads do not make cross process
            // SYNC calls
            Win4Assert(!(m_dwFlags & CALLFLAG_STATHREAD) &&
                               "STA thread is making a SYNC call");

            // MTA threads make direct RPC calls
            if(SUCCEEDED(hr) && !hThread)
            {
                // The system call below should not fail
                fRet = DuplicateHandle(GetCurrentProcess(), GetCurrentThread(),
                                       GetCurrentProcess(), &Tls->hThread,
                                       0, FALSE, DUPLICATE_SAME_ACCESS);

                // Set the default cancel time out to 0 seconds
                if(fRet)
                {
                    hThread = Tls->hThread;
                    RPC_STATUS st = RpcMgmtSetCancelTimeout(0);
                    Win4Assert(st == RPC_S_OK);
                }
                else
                {
                    CallDebugOut((DEB_WARN,
                                  "This: 0x%x Duplicate handle failed\n", this));
                    hr = RPC_E_SYS_CALL_FAILED;
                }
            }
        }

        // Update state
        if(SUCCEEDED(hr))
        {
            m_dwFlags |= CALLFLAG_CALLDISPATCHED;
            m_hThread = hThread;
        }
    }

    // Release lock
    UNLOCK(gCallLock);
    ASSERT_LOCK_NOT_HELD(gCallLock);
    return(hr);
}

//+-------------------------------------------------------------------
//
//  Method:     CClientCall::Cancel     public
//
//  Synopsis:   Attempts to cancel this call
//
//+-------------------------------------------------------------------
STDMETHODIMP CClientCall::Cancel(ULONG ulTimeout)
{
    return Cancel(FALSE, ulTimeout);
}

//+-------------------------------------------------------------------
//
//  Method:     CClientCall::Cancel     public
//
//  Synopsis:   Worker routine that implements functionality to
//              cancel this call
//
//+-------------------------------------------------------------------
HRESULT CClientCall::Cancel(BOOL fModalLoop, ULONG ulTimeout)
{
    CallDebugOut((DEB_CALL|DEB_CANCEL, "CClientCall::Cancel(0x%x, 0x%x, 0x%x)\n",
                              this, fModalLoop, ulTimeout));
    ASSERT_LOCK_NOT_HELD(gCallLock);

    // Assert that the call object is on the
    // client side
    Win4Assert(IsClientSide());

    // check if cancel is enabled
    if (!(CancelEnabled() || fModalLoop))
    {
        HRESULT hr = CO_E_CANCEL_DISABLED;
        CallDebugOut((DEB_CALL|DEB_CANCEL,
                     "CClientCall::Cancel this:0x%x returning 0x%x - cancel disabled\n",
                      this, hr));
        return(hr);
    }


    HRESULT hr = S_OK;
    DWORD dwThreadId;
    CallEntry *pEntry;


    // Assert that modal loop cancels have 0 timeout value
    Win4Assert(!fModalLoop || ulTimeout==0);

    // Validate arguments
    if(!fModalLoop && (m_dwFlags & CALLFLAG_WOWTHREAD))
    {
        // Support cancel for calls made by WOW threads
        // only from modal loop
        return(E_NOTIMPL);
    }
    else if(_callcat == CALLCAT_INPUTSYNC)
    {
        // Do not provide cancel support for Input Sync calls
        return(E_FAIL);
    }

    // Aquire COM lock
    LOCK(gCallLock);

    // Check if the state has changed while we waited to aquire the lock
    if(m_dwFlags & (CALLFLAG_CALLCOMPLETED | CALLFLAG_CALLFINISHED))
    {
        // Call has completed
        hr = RPC_E_CALL_COMPLETE;
    }
    else if(m_dwFlags & CALLFLAG_CALLCANCELED)
    {
        // Do not support increasing cancel timeout
        if(m_ulCancelTimeout < ulTimeout)
            hr = RPC_E_CALL_CANCELED;
    }

    if(hr == S_OK)
    {
        // Check if the thread that made the call is aware of
        // an earlier cancel request
        if(m_dwFlags & CALLFLAG_CANCELISSUED)
        {
            // Assert that we do not end up here for calls made
            // by WOW threads
            Win4Assert(!(m_dwFlags & CALLFLAG_WOWTHREAD));

            // Just change the timeout to the new value as
            // the thread that made the call is still not aware
            // of the earlier cancel reuest
            Win4Assert(m_dwFlags & CALLFLAG_CALLCANCELED);
            m_ulCancelTimeout = ulTimeout;

            // If cancel is happening from inside the modal loop
            // wait on the event to revert its state
            if(fModalLoop)
            {
                Win4Assert(_hEvent);
                WaitForSingleObject(_hEvent, INFINITE);

                m_dwFlags &= ~CALLFLAG_CANCELISSUED;
                m_dwFlags |= CALLFLAG_CLIENTNOTWAITING;
            }
            // Else there is no more work to do as the thread that
            // made the call will wake up and process the
            // earlier cancel request
        }
        else
        {
            // Update the state
            if(!(m_dwFlags & CALLFLAG_CALLCANCELED))
                m_dwStartCount = GetTickCount();
            m_dwFlags |= CALLFLAG_CALLCANCELED;
            m_ulCancelTimeout = ulTimeout;

            // Assert that calls made by WOW threads can only be canceled
            // from inside modal loop
            Win4Assert(!(m_dwFlags & CALLFLAG_WOWTHREAD) || fModalLoop);

            // Wake up the client thread for positive cancel timeout
            // values only if the call has not yet been dispatched
            if(IsCallDispatched() || m_ulCancelTimeout>0)
            {
                // Unblock the thread that made the call
                if(ProcessLocal())
                {
                    // For STA threads, the call can be canceled by the
                    // same thread that made the call. This can happen
                    // either inside modal loop or when a new call is
                    // dispatched to the STA thread

                    // NOTE: Irrespective of the threading model of the
                    // caller thread, calls to RTA are executed directly
                    // on the thread making the call. As calling thread
                    // is not blocked waiting for call completion, cancels
                    // on such are inherently advisory in nature. Gopalk

                    // Check for the modal loop case
                    if(fModalLoop)
                    {
                        // The thread has already unblocked
                        // Nothing more to do

                        // Mark the client thread as not waiting
                        m_dwFlags |= CALLFLAG_CLIENTNOTWAITING;
                    }
                    else if(m_ulCancelTimeout != (ULONG) INFINITE)
                    {
                        // Wake up the thread that made the call
                        m_dwFlags |= CALLFLAG_CANCELISSUED;
                        Win4Assert(_hEvent);
                        SetEvent(_hEvent);
                    }
                }
                else
                {
                    // STA threads do not make cross process sync calls
                    Win4Assert(!fModalLoop && !(m_dwFlags & CALLFLAG_STATHREAD));

                    // Cancel the RPC call
                    if (_destObj.GetDestCtx() != MSHCTX_DIFFERENTMACHINE)
                    {
                        // RPC has not yet implemented cancel facility for
                        // LRPC calls.
                        hr = E_NOTIMPL;
                    }
                    else
                    {
                        // Must be a remote call
                        RPC_STATUS rpcStatus;

                        Win4Assert(m_hThread);
                        CallDebugOut((DEB_CALL|DEB_CANCEL,
                                     "0x%x --> RpcCancelThreadEx(0x%x, 0x%x)\n",
                                      this, m_hThread, m_ulCancelTimeout));
                        rpcStatus = RpcCancelThreadEx(m_hThread, m_ulCancelTimeout);
                        CallDebugOut((DEB_CALL|DEB_CANCEL,
                                      "0x%x <-- RpcCancelThreadEx returns 0x%x\n",
                                       this, rpcStatus));
                    }
                }
            }
	    else if (!IsCallDispatched() && ProcessLocal() && fModalLoop) 
	    {
	       //Process local call, cancelled before dispatch
	       // mark the client as not waiting, if we are called
	       // from the modal loop
	       m_dwFlags |= CALLFLAG_CLIENTNOTWAITING;
	    }
        }
    }

    // Release lock
    UNLOCK(gCallLock);
    ASSERT_LOCK_NOT_HELD(gCallLock);

    CallDebugOut((DEB_CALL|DEB_CANCEL,
                 "CClientCall::Cancel this:0x%x returning 0x%x\n", this, hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CClientCall::TestCancel     public
//
//  Synopsis:   Answers whether the current call has been canceled
//
//+-------------------------------------------------------------------
STDMETHODIMP CClientCall::TestCancel()
{
    CallDebugOut((DEB_CALL|DEB_CANCEL, "CClientCall::TestCancel this:%x\n",this));
    ASSERT_LOCK_NOT_HELD(gCallLock);

    HRESULT hr = RPC_S_CALLPENDING;

    if(m_dwFlags & CALLFLAG_CALLCANCELED)
        hr = RPC_E_CALL_CANCELED;
    else if(m_dwFlags & CALLFLAG_CALLCOMPLETED)
        hr = RPC_E_CALL_COMPLETE;

    CallDebugOut((DEB_CALL|DEB_CANCEL,
                  "CClientCall::TestCancel this:0x%x hr 0x%x\n", this, hr));
    return(hr);
}

//+-------------------------------------------------------------------
//
//  Method:     CClientCall::AdvCancel     public
//
//  Synopsis:   Implements advisory cancel for sync calls
//              It is a No Op for sync calls
//
//+-------------------------------------------------------------------
HRESULT CClientCall::AdvCancel()
{
    return(S_OK);
}

//+-------------------------------------------------------------------
//
//  Method:     CMessageCall::GetTimeout     private
//
//  Synopsis:   Retuns the timeout value in milliseconds
//
//+-------------------------------------------------------------------
DWORD CMessageCall::GetTimeout()
{
    DWORD dwTimeout = 0;
    long lRemTime, lElapsedTime;

    if(m_ulCancelTimeout == (ULONG) INFINITE)
        dwTimeout = (DWORD) INFINITE;
    else if(m_ulCancelTimeout > 0)
    {
        lElapsedTime = GetTickCount() - m_dwStartCount;
        lRemTime = m_ulCancelTimeout*1000 - lElapsedTime;
        if(lRemTime > 0)
            dwTimeout = lRemTime;
    }

    return(dwTimeout);
}

//+-------------------------------------------------------------------
//
//  Method:     CClientCall::ResolveCancel     private
//
//  Synopsis:   Called by STA threads from inside modal loop and MTA
//              threads immediatly after unblocking
//
//+-------------------------------------------------------------------
HRESULT CMessageCall::RslvCancel(DWORD &dwSignal, HRESULT hrIn,
                                 BOOL fPostMsg, CCliModalLoop *pCML)
{
#if DBG==1
    ULONG debFlags = DEB_LOOP;
    if((CallInfoLevel & DEB_CANCEL) && IsCallCanceled())
        debFlags |= DEB_CANCEL;
#endif
    CallDebugOut((debFlags,
                  "CMessageCall::RslvCancel(0x%x, 0x%x, 0x%x, 0x%x, 0x%x\n",
                   this, dwSignal, hrIn, fPostMsg, pCML));


    HRESULT hrOut = RPC_S_CALLPENDING;
    BOOL fCancel = FALSE, fAdvCancel = FALSE, fReset = FALSE;
    DWORD dwTimeout;

    // Sanity checks
    Win4Assert((hrIn==S_OK) == (dwSignal==WAIT_OBJECT_0));
    Win4Assert(hrIn==RPC_S_CALLPENDING || hrIn==S_OK || hrIn==RPC_E_CALL_CANCELED);

    // X-Process calls made by WOW threads use event
    // Process local calls made WOW threads use messages
    // for call completion notification
    Win4Assert(fPostMsg == (IsWOWThread() && ProcessLocal()));

    // Check the status of call
    if((dwSignal - WAIT_OBJECT_0) == 0)
    {
        if(!IsCancelIssued())
        {
            // Call was completed normally, take the fast path exit
            CallDebugOut((debFlags,
                         "CMessageCall::RslvCancel this:0x%x returning hr:0x%x\n",
                          this, S_OK));
           return S_OK;
        }

        // Acquire lock
        LOCK(gCallLock);

        // Check for event getting signaled due to the
        // call being canceled
        if (IsCancelIssued())
        {
            // Obtain timeout
            dwTimeout = GetTimeout();
            if(dwTimeout)
                fAdvCancel = TRUE;
            else
                fCancel = TRUE;

            // Acknowledge cancel request
            AckCancel();

            CallDebugOut((debFlags, "CMessageCall::RslvCancel CancelIssued "
                         "this:0x%x Timeout:0x%x\n", this, dwTimeout));
        }
        else
        {
            // Assert that the call has completed
            Win4Assert(!IsCallDispatched() || IsCallCompleted());
            Win4Assert(hrIn == S_OK);
            hrOut = S_OK;

            CallDebugOut((debFlags, "CMessageCall::RslvCancel CallCompleted "
                         "this:0x%x hrOut:0x%x\n", this, hrOut));
        }

        // Release lock
        UNLOCK(gCallLock);
    }
    else if(hrIn == RPC_S_CALLPENDING)
    {
        // Calls made by WOW threads can only be canceled
        // from inside modal loop
        if(fPostMsg)
        {
            // Check for call completion
            if(HasWOWMsgArrived())
                hrOut = S_OK;

            CallDebugOut((debFlags, "CMessageCall::RslvCancel WOWCall "
                         "this:0x%x hrOut:0x%x\n", this, hrOut));
        }
        else if(IsCallCanceled())
        {
            // Obtain timeout
            dwTimeout = GetTimeout();
            if(dwTimeout == 0)
                fCancel = TRUE;

            CallDebugOut((debFlags, "CMessageCall::RslvCancel CancelPending "
                         "this:0x%x Timeout:0x%x\n", this, dwTimeout));
        }
    }

    // Check for the need to cancel call
    if(fCancel || hrIn==RPC_E_CALL_CANCELED)
    {
        // The call was canceled from inside modal loop
        // or due to cancel timeout
        // Inform call object about cancel
        hrIn = Cancel(TRUE, 0);

        CallDebugOut((debFlags, "CMessageCall::RslvCancel this:0x%x "
                     "ModalLoop Cancel returned hr:0x%x\n", this, hrIn));

        if(hrIn == RPC_E_CALL_COMPLETE)
        {
            // Wait for the call to finish
            if(fPostMsg)
            {
                // The thread needs to pump messages till the completion
                // message is received
                if(HasWOWMsgArrived())
                    hrOut = S_OK;
                else
                    fReset = TRUE;
            }
            else
            {
                WaitForSingleObject(_hEvent, INFINITE);
                hrOut = S_OK;
            }
        }
        else if(hrIn == RPC_E_CALL_CANCELED)
        {
            // Assert that we never end up here
            Win4Assert(!"Modal Loop cancel returning RPC_E_CALL_CANCELED");
        }
        else
        {
            Win4Assert(hrIn == S_OK);
            hrOut = RPC_E_CALL_CANCELED;
        }
    }
    else if(fAdvCancel)
    {
        // Inform the server that the client is no longer interested
        // in results of this call
        hrIn = AdvCancel();
        fReset = TRUE;

        CallDebugOut((debFlags, "CMessageCall::RslvCancel this:0x%x "
                     "ModalLoop AdvCancel returned hr:0x%x\n", this, hrIn));
    }

    // Reset state if returning back to modal loop
    if(fReset && pCML)
    {
        pCML->ResetState();
        dwSignal = 0xFFFFFFFF;
    }

    CallDebugOut((debFlags, "CMessageCall::RslvCancel this:0x%x returning hr:0x%x\n",
                  this, hrOut));
    return(hrOut);
}

//+-------------------------------------------------------------------
//
//  Function:   CoGetCancelObject
//
//  Synopsis:   Obtains the cancel object of the topmost call
//
//+-------------------------------------------------------------------
WINOLEAPI CoGetCancelObject(DWORD dwThreadId, REFIID iid, void **ppUnk)
{
    CallDebugOut((DEB_CALL|DEB_CANCEL, "CoGetCancelObject(0x%x, 0x%x)\n",
                              dwThreadId, ppUnk));
    ASSERT_LOCK_NOT_HELD(gCallLock);

    HRESULT hr = S_OK;
    ICancelMethodCalls *pCancel;

    // Validate argument
    if(!IsValidPtrOut(ppUnk, sizeof(void *)))
        hr = E_INVALIDARG;

    if(SUCCEEDED(hr))
    {
        // Check for the need to get current thread id
        if(dwThreadId == 0)
            dwThreadId = GetCurrentThreadId();

        // Get the entry for the given thread
        pCancel = gCallTbl.GetEntry(dwThreadId);

        if(pCancel)
        {
            // Check if the desired interface is IID_ICancelMethodCalls
            if(IsEqualIID(iid, IID_ICancelMethodCalls))
            {
                *ppUnk = pCancel;
            }
            else
            {
                // QI for the desired interface
                hr = pCancel->QueryInterface(iid, ppUnk);

                // Fix up the ref count
                pCancel->Release();
            }
        }
        else
            hr = RPC_E_NO_CONTEXT;
    }

    ASSERT_LOCK_NOT_HELD(gCallLock);
    CallDebugOut((DEB_CALL|DEB_CANCEL, "CoGetCancelObject returning 0x%x\n",
                              hr));
    return(hr);
}

//+-------------------------------------------------------------------
//
//  Function:   CoSetCancelObject
//
//  Synopsis:   Sets the cancel object for the topmost call
//
//+-------------------------------------------------------------------
WINOLEAPI CoSetCancelObject(IUnknown *pUnk)
{
    CallDebugOut((DEB_CALL|DEB_CANCEL, "CoSetCancelObject(0x%x)\n", pUnk));
    ASSERT_LOCK_NOT_HELD(gCallLock);

    HRESULT hr = S_OK;

    // Validate argument
    if(pUnk && !IsValidInterface(pUnk))
        hr = E_INVALIDARG;

    if(SUCCEEDED(hr))
    {
        ICancelMethodCalls *pCancel = NULL;

        if(pUnk)
        {
            // QI for ICancelMethodCalls interface
            hr = pUnk->QueryInterface(IID_ICancelMethodCalls, (void **) &pCancel);
        }

        if(SUCCEEDED(hr))
        {
            // Set or clear the entry for the current thread
            if (pCancel)
            {
                hr = gCallTbl.PushCallObject(pCancel);
                pCancel->Release();
            }
            else
            {
                LOCK(gCallLock);
                IUnknown *pUnkCall = gCallTbl.PopCallObject(NULL);
                UNLOCK(gCallLock);
                if (pUnkCall)
                {
                    pUnkCall->Release();
                }
            }
        }
    }

    ASSERT_LOCK_NOT_HELD(gCallLock);
    CallDebugOut((DEB_CALL|DEB_CANCEL, "CoSetCancelObject returning 0x%x\n", hr));
    return(hr);
}

//+-------------------------------------------------------------------
//
//  Function:   CoCancelCall
//
//  Synopsis:   Cancels the topmost call of the given thread
//
//+-------------------------------------------------------------------
WINOLEAPI CoCancelCall(DWORD dwThreadId, ULONG ulTimeout)
{
    CallDebugOut((DEB_CALL|DEB_CANCEL, "CoCancelCall(0x%x)\n", dwThreadId));
    ASSERT_LOCK_NOT_HELD(gCallLock);

    // Obtain the cancel object for the given thread
    ICancelMethodCalls *pCancel;
    HRESULT hr = CoGetCancelObject(dwThreadId, IID_ICancelMethodCalls, (void **)&pCancel);
    if(SUCCEEDED(hr))
    {
        // Cancel the call
        hr = pCancel->Cancel(ulTimeout);
        pCancel->Release();
    }

    ASSERT_LOCK_NOT_HELD(gCallLock);
    CallDebugOut((DEB_CALL|DEB_CANCEL, "CoCancelCall returning 0x%x\n", hr));
    return(hr);
}

//+-------------------------------------------------------------------
//
//  Function:   CoTestCancel
//
//  Synopsis:   Called by the server to check if the cuurent call has
//              been canceled by the client
//
//+-------------------------------------------------------------------
WINOLEAPI CoTestCancel()
{
    CallDebugOut((DEB_CALL|DEB_CANCEL, "CoTestCancel()\n"));
    ASSERT_LOCK_NOT_HELD(gCallLock);

    // Obtain the cancel object for the given thread
    ICancelMethodCalls *pCancel;
    HRESULT hr = CoGetCallContext(IID_ICancelMethodCalls, (void **) &pCancel);
    if(SUCCEEDED(hr))
    {
        // Test for cancel
        hr = pCancel->TestCancel();
        pCancel->Release();
    }

    ASSERT_LOCK_NOT_HELD(gCallLock);
    CallDebugOut((DEB_CALL|DEB_CANCEL, "CoTestCancel returning 0x%x\n", hr));
    return(hr);
}

//+-------------------------------------------------------------------
//
//  Function:   CoEnableCallCancellation
//
//  Synopsis:   Called by the client to enable cancellation of calls
//
//+-------------------------------------------------------------------
WINOLEAPI CoEnableCallCancellation(void *pReserved)
{
    CallDebugOut((DEB_CALL|DEB_CANCEL, "CoEnableCallCancellation()\n"));
    ASSERT_LOCK_NOT_HELD(gCallLock);

    HRESULT hr;

    if (pReserved != NULL)
        return E_INVALIDARG;

    COleTls tls(hr);
    if (FAILED(hr))
        return hr;

    // Increment thread callCancellation count
    tls->cCallCancellation++;

    ASSERT_LOCK_NOT_HELD(gCallLock);
    return(hr);
}

//+-------------------------------------------------------------------
//
//  Function:   CoDisableCallCancellation
//
//  Synopsis:   Called by the client to disable call cancellation (default)
//
//+-------------------------------------------------------------------
WINOLEAPI CoDisableCallCancellation(void *pReserved)
{
    CallDebugOut((DEB_CALL|DEB_CANCEL, "CoDisableCallCancellation()\n"));
    ASSERT_LOCK_NOT_HELD(gCallLock);

    HRESULT hr;

    if (pReserved != NULL)
        return E_INVALIDARG;

    COleTls tls(hr);
    if (FAILED(hr))
        return hr;

    if (tls->cCallCancellation < 1)
        return CO_E_CANCEL_DISABLED;

    // decrement thread callCancellation count
    tls->cCallCancellation--;

    ASSERT_LOCK_NOT_HELD(gCallLock);
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Function:   ReleaseMarshalBuffer
//
//  Synopsis:   Called by channel when call is aborted to release
//              interface pointers in the marshal buffer.
//
//+-------------------------------------------------------------------
INTERNAL ReleaseMarshalBuffer(
   RPCOLEMESSAGE *pMessage,
   IUnknown      *punk,
   BOOL           fOutParams
   )
{
#if 0
    if (CairoleInfoLevel == 0)
    {
        CallDebugOut((DEB_WARN, "ReleaseMarshalBuffer() doing nothing\n"));
        return S_OK;
    }
#endif

    // If fOutParams is TRUE, then we're supposed to be freeing out parameters.
    // Otherwise, we're supposed to be freeing in parameters.
    //
    // These are the magic numbers that tell RPC what to do.
#define RELEASE_IN   (0)
#define RELEASE_OUT  (1)
    DWORD dwFlags = (fOutParams) ? RELEASE_OUT : RELEASE_IN;

    HRESULT hr;
    IReleaseMarshalBuffers *pRMB = NULL;
    hr = punk->QueryInterface(IID_IReleaseMarshalBuffers, (void**)&pRMB);
    if (SUCCEEDED(hr))
    {
        hr = pRMB->ReleaseMarshalBuffer(pMessage, dwFlags, NULL);
        pRMB->Release();
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dcomrem\callctrl.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       callctrl.cxx
//
//  Contents:   Contains the ORPC CallControl code
//
//  History:    21-Dec-93 Johannp   Original Version
//              04-Nov-94 Rickhi    ReWrite as layer over channel
//
//--------------------------------------------------------------------------
#include <ole2int.h>
#include <thkreg.h>             // OLETHK_ defines
#include <dde.h>
#include <callctrl.hxx>
#include <objsrv.h>             // IID_ILocalSystemActivator
#include <callmgr.hxx>
#include <ctxchnl.hxx>          // gCtxHook

#ifdef _CHICAGO_
#include <userapis.h>           // bypass stack switching for USER apis.
#endif // _CHICAGO_


// private defines used only in this file
#define WM_SYSTIMER             0x0118
#define SYS_ALTDOWN             0x2000
#define WM_NCMOUSEFIRST         WM_NCMOUSEMOVE
#define WM_NCMOUSELAST          WM_NCMBUTTONDBLCLK


// empty slot in window registration
#define WD_EMPTY    (HWND)-1

BOOL gAutoInputSync = FALSE;

// the following table is used to quickly determine what windows
// message queue inputflag to specify for the various categories of
// outgoing calls in progress. The table is indexed by CALLCATEGORY.

DWORD gMsgQInputFlagTbl[4] = {
    QS_ALLINPUT | QS_TRANSFER | QS_ALLPOSTMESSAGE,  // NOCALL
    QS_ALLINPUT | QS_TRANSFER | QS_ALLPOSTMESSAGE,  // SYNCHRONOUS
    QS_ALLINPUT | QS_TRANSFER | QS_ALLPOSTMESSAGE,  // ASYNC
    QS_SENDMESSAGE};                                // INPUTSYNC


// the following table is used to map bit flags in the Rpc Message to
// the equivalent OLE CALLCATEGORY.

DWORD gRpcFlagToCallCatMap[3] = {
    CALLCAT_SYNCHRONOUS,                // no flags set
    CALLCAT_INPUTSYNC,                  // RPCFLG_INPUT_SYNCHRONOUS
    CALLCAT_ASYNC};                     // RPCFLG_ASYNCHRONOUS


// prototypes
HRESULT CopyMsgForRetry(RPCOLEMESSAGE *pMsg,
                        IInternalChannelBuffer *pChnl,
                        HRESULT hrIn);

//+-------------------------------------------------------------------------
//
//  Function:   CoRegisterMessageFilter, public
//
//  Synopsis:   registers an applications message filter with the call control
//
//  Arguments:  [pMsgFilter] - message filter to register
//              [ppMsgFilter] - optional, where to return previous IMF
//
//  Returns:    S_OK - registered successfully
//
//  History:    21-Dec-93 JohannP  Created
//
//--------------------------------------------------------------------------
STDAPI CoRegisterMessageFilter(LPMESSAGEFILTER  pMsgFilter,
                               LPMESSAGEFILTER *ppMsgFilter)
{
    ComDebOut((DEB_MFILTER, "CoRegisterMessageFilter pMF:%x ppMFOld:%x\n",
               pMsgFilter, ppMsgFilter));
    CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IMessageFilter,(IUnknown **)&pMsgFilter);

    // validate the parameters. NULL acceptable for either or both parameters.
    if (pMsgFilter != NULL && !IsValidInterface(pMsgFilter))
    {
        return E_INVALIDARG;
    }

    if(ppMsgFilter != NULL && !IsValidPtrOut(ppMsgFilter, sizeof(ppMsgFilter)))
    {
        return E_INVALIDARG;
    }

    // this operation is not allowed on MTA Threads
    if (IsMTAThread())
        return CO_E_NOT_SUPPORTED;

    // find the callcontrol for this apartment and replace the existing
    // message filter. if no callctrl has been created yet, just stick
    // the pMsgFilter in tls.

    COleTls tls;
    CAptCallCtrl *pACC = tls->pCallCtrl;

    IMessageFilter *pOldMF;

    if (pACC)
    {
        pOldMF = pACC->InstallMsgFilter(pMsgFilter);
    }
    else
    {
        pOldMF = tls->pMsgFilter;

        if (pMsgFilter)
        {
            pMsgFilter->AddRef();
        }
        tls->pMsgFilter = pMsgFilter;
    }
    if (ppMsgFilter)
    {
        // return old MF to the caller
        *ppMsgFilter = pOldMF;
    }
    else if (pOldMF)
    {
        // release the old MF
        pOldMF->Release();
    }

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CAptCallCtrl::InstallMsgFilter
//
//  Synopsis:   called to install a new application provided message filter
//
//  Arguments:  [pMF] - new message filter to install (or NULL)
//
//  Returns:    previous message filter if there was one
//
//  History:    20-Dec-93   JohannP Created
//
//--------------------------------------------------------------------------
INTERNAL_(IMessageFilter *) CAptCallCtrl::InstallMsgFilter(IMessageFilter *pMF)
{
    IMessageFilter *pMFOld = _pMF;      //  save the old one to return

    _pMF = pMF;                         //  install the new one
    if (_pMF)
    {
        _pMF->AddRef();
    }

    return pMFOld;
}

//+-------------------------------------------------------------------------
//
//  Method:     CAptCallCtrl::CAptCallCtrl
//
//  Synopsis:   constructor for per apartment call control state
//
//  History:    11-Nov-94   Rickhi      Created
//
//--------------------------------------------------------------------------
CAptCallCtrl::CAptCallCtrl() :
    _fInMsgFilter(FALSE),
    _pTopCML(NULL)
{
    // The first one is reserved for ORPC. An hWnd value of WD_EMPTY
    // means the slot is available.
    _WD[0].hWnd = WD_EMPTY;

    // The second slot has fixed values for DDE
    _WD[1].hWnd      = NULL;
    _WD[1].wFirstMsg = WM_DDE_FIRST;
    _WD[1].wLastMsg  = WM_DDE_LAST;

    // put our pointer into thread local storage, and retrieve any previously
    // registered message filter.

    COleTls tls;
    tls->pCallCtrl = this;

    _pMF = tls->pMsgFilter;
    tls->pMsgFilter = NULL;
}

//+-------------------------------------------------------------------------
//
//  Method:     CAptCallCtrl::~CAptCallCtrl
//
//  Synopsis:   destructor for per apartment call control state
//
//  History:    11-Nov-94   Rickhi      Created
//
//--------------------------------------------------------------------------
CAptCallCtrl::~CAptCallCtrl()
{
    Win4Assert(_pTopCML == NULL);   // no outgoing calls.

    if (_pMF)
    {
        _pMF->Release();
    }

    // remove our pointer from thread local storage
    COleTls tls;
    tls->pCallCtrl = NULL;
}

//+-------------------------------------------------------------------------
//
//  Method:     CAptCallCtrl::Register/Revoke
//
//  Synopsis:   register or revoke RPC window data
//
//  Arguments:  [hWnd]      - window handle to look for calls on
//              [wFirstMsg] - msgid of first message in range to look for
//              [wLastMsg]  - msgid of last message in range to look for
//
//  Returns:    nothing
//
//  Notes:      This code is only ever called by the RpcChannel and by
//              the DDE layer, and so error checking is kept to a minimum.
//
//  History:    30-Apr-95 Rickhi    Created
//
//--------------------------------------------------------------------------
void CAptCallCtrl::Register(HWND hWnd, UINT wFirstMsg, UINT wLastMsg)
{
    Win4Assert(_WD[0].hWnd == WD_EMPTY && "Register Out of Space");

    _WD[0].hWnd      = hWnd;
    _WD[0].wFirstMsg = wFirstMsg;
    _WD[0].wLastMsg  = wLastMsg;
}

void CAptCallCtrl::Revoke(HWND hWnd)
{
    Win4Assert(_WD[0].hWnd == hWnd && "Revoke not found");
    _WD[0].hWnd = WD_EMPTY;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetSlowTimeFactor
//
//  Synopsis:   Get the time slowing factor for Wow apps
//
//  Returns:    The factor by which we need to slow time down.
//
//  Algorithm:  If there is a factor in the registry, we open and read the
//              registry. Otherwise we just set it to the default.
//
//  History:    22-Jul-94 Ricksa    Created
//              09-Jun-95 Susia     ANSI Chicago optimization
//
//--------------------------------------------------------------------------
#ifdef _CHICAGO_
#undef  RegOpenKeyEx
#define RegOpenKeyEx    RegOpenKeyExA
#undef  RegQueryValueEx
#define RegQueryValueEx RegQueryValueExA
#endif
DWORD GetSlowTimeFactor(void)
{
    // Default slowing time so we can just exit if there is no key which
    // is assumed to be the common case.
    DWORD dwSlowTimeFactor = OLETHK_DEFAULT_SLOWRPCTIME;

    // Key for reading the value from the registry
    HKEY hkeyOleThk;

    // Get the Ole Thunk special value key
    LONG lStatus = RegOpenKeyEx(HKEY_CLASSES_ROOT, OLETHK_KEY, 0, KEY_READ,
        &hkeyOleThk);

    if (lStatus == ERROR_SUCCESS)
    {
        DWORD dwType;
        DWORD dwSizeData = sizeof(dwSlowTimeFactor);

        lStatus = RegQueryValueEx(hkeyOleThk, OLETHK_SLOWRPCTIME_VALUE, NULL,
            &dwType, (LPBYTE) &dwSlowTimeFactor, &dwSizeData);

        if ((lStatus != ERROR_SUCCESS) || dwType != REG_DWORD)
        {
            // Guarantee that value is reasonable if something went wrong.
            dwSlowTimeFactor = OLETHK_DEFAULT_SLOWRPCTIME;
        }

        // Close the key since we are done with it.
        RegCloseKey(hkeyOleThk);
    }

    return dwSlowTimeFactor;
}

//+-------------------------------------------------------------------------
//
//  Function:   CanMakeOutCall
//
//  Synopsis:   called when the client app wants to make an outgoing call to
//              determine if it is OK to do it now or not. Common subroutine
//              to CAptRpcChnl::GetBuffer and RemoteReleaseRifRef
//
//  Arguments:  [dwCallCatOut] - call category of call the app wants to make
//              [pChnl] - ptr to channel call is being made on
//              [riid] - interface call is being made on
//
//  Returns:    S_OK - ok to make the call
//              RPC_E_CANTCALLOUT_INEXTERNALCALL - inside IMessageFilter
//              RPC_E_CANTCALLOUT_INASYNCCALL - inside async call
//              RPC_E_CANTCALLOUT_ININPUTSYNCCALL - inside input sync or SendMsg
//
//  History:    21-Dec-93 Johannp   Original Version
//              04-Nov-94 Rickhi    ReWrite
//              03-Oct-95 Rickhi    Made into common subroutine
//
//--------------------------------------------------------------------------
INTERNAL CanMakeOutCall(DWORD dwCallCatOut, REFIID riid, RPCOLEMESSAGE *pMsg)
{
    // get the topmost incoming call state from Tls.

    HRESULT hr;
    COleTls tls(hr);
    if (FAILED(hr))
        return hr;

    CSrvCallState *pSCS = tls->pTopSCS;

    DWORD dwCallCatIn = (pSCS) ? pSCS->GetCallCatIn() : CALLCAT_NOCALL;

    // if handling an incoming ASYNC call, only allow ASYNC outgoing calls,
    // and local calls on IRemUnknown (which locally is actually IRundown).

    if (dwCallCatIn  == CALLCAT_ASYNC &&
        dwCallCatOut != CALLCAT_ASYNC &&
        !IsEqualGUID(riid, IID_IRundown) )
    {
        return RPC_E_CANTCALLOUT_INASYNCCALL;
    }

    // if handling an incoming INPUTSYNC call, or if we are handling a
    // SendMessage, dont allow SYNCHRONOUS calls out or we could deadlock
    // since SYNC uses PostMessage and INPUTSYNC uses SendMessage.

    if (dwCallCatOut == CALLCAT_SYNCHRONOUS &&
        (dwCallCatIn == CALLCAT_INPUTSYNC ||
            (SSInSendMessageEx(NULL) & ISMEX_SEND) ))
    {
        if(pMsg != NULL && TRUE == gAutoInputSync)
        {
            //Convert the synchronous call to an input_sync call
            //so that we can make an outgoing call while
            //processing a SendMessage.  Some ActiveX controls and DocObjects
            //require this behavior in order to run cross-thread or cross-process.

            pMsg->rpcFlags |= RPCFLG_INPUT_SYNCHRONOUS;
        }
        else
        {
            return RPC_E_CANTCALLOUT_ININPUTSYNCCALL;
        }
    }

    return S_OK;
}

#ifdef _CHICAGO_
//+-------------------------------------------------------------------------
//
//  Function:   CanMakeOutCallHelper
//
//  Synopsis:   called when the Win95 client app wants to make an outgoing call to
//              determine if it is OK to do it now or not. Called before calling
//              in-proc SCM to make sure that we won't fail later.
//
//  Arguments:  [dwCallCatOut] - call category of call the app wants to make
//              [riid] - interface call is being made on
//
//  Returns:    S_OK - ok to make the call
//              RPC_E_CANTCALLOUT_INEXTERNALCALL - inside IMessageFilter
//              RPC_E_CANTCALLOUT_INASYNCCALL - inside async call
//              RPC_E_CANTCALLOUT_ININPUTSYNCCALL - inside input sync or SendMsg
//
//  History:    17-May-96 MurthyS   Original Version
//
//--------------------------------------------------------------------------
INTERNAL CanMakeOutCallHelper(DWORD dwCallCatOut, REFIID riid)
{
    if (IsSTAThread())
    {
        // dont allow the application to call out while handling an
        // IMessageFilter call because it screws up the call sequencing.

        COleTls tls;
        CAptCallCtrl *pACC = tls->pCallCtrl;

        if (pACC && pACC->InMsgFilter())
        {
            ComDebOut((DEB_ERROR, "Illegal callout from within IMessageFilter\n"));
            return RPC_E_CANTCALLOUT_INEXTERNALCALL;
        }
        return CanMakeOutCall(dwCallCatOut, riid, NULL);
    }

    return S_OK;
}
#endif // _CHICAGO_

//+-------------------------------------------------------------------------
//
//  Method:     CAptRpcChnl::CAptRpcChnl/~CAptRpcChnl
//
//  Synopsis:   constructor/destructor
//
//  Parameters: [pStdId] - std identity for the object
//              [pOXIDEntry] - OXIDEntry for the object server
//              [eState] - state flags passed thru to CRpcChannelBuffer
//                         (ignored by CAptRpcCnl).
//
//  History:    11-Nov-94   Rickhi      Created
//
//--------------------------------------------------------------------------
CAptRpcChnl::CAptRpcChnl(CStdIdentity *pStdId,
                         OXIDEntry *pOXIDEntry,
                         DWORD eState) :
    CRpcChannelBuffer(pStdId, pOXIDEntry, eState),
    _dwTIDCallee(pOXIDEntry->GetTid()),
    _dwAptId(GetCurrentApartmentId())
{
    ComDebOut((DEB_CALLCONT,"CAptRpcChnl::CAptRpcChnl this:%x\n", this));
}

CAptRpcChnl::~CAptRpcChnl()
{
    ComDebOut((DEB_CALLCONT,"CAptRpcChnl::~CAptRpcChnl this:%x\n", this));
}

//+-------------------------------------------------------------------------
//
//  Method:     CAptRpcChnl::GetBuffer
//
//  Synopsis:   Ensure it is legal to call out now, then get a buffer.
//
//  Parameters: [pMsg] - ptr to message structure
//              [riid] - interface call is being made on
//
//  History:    11-Nov-94   Rickhi      Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CAptRpcChnl::GetBuffer(RPCOLEMESSAGE *pMsg, REFIID riid)
{
    HRESULT hr = S_OK;

    // Make sure we are allowed to make this outgoing call. We do that here
    // so that we dont marshal all the parameters only to discover that we
    // cant call out and then have to free all the marshalled parameters
    // (especially the ones where marshalling has side effects).

    if (!(_dwAptId == GetCurrentApartmentId() || CallableOnAnyApt()))
    {
        // we are not being called in the correct apartment
        return RPC_E_WRONG_THREAD;
    }

    // If we are on the server side, everything is ok.
    if (IsClientSide())
    {
        if (IsMTAThread())
        {
            if (pMsg->rpcFlags & RPCFLG_INPUT_SYNCHRONOUS)
            {
                // dont allow INPUTSYNC calls from an MTA apartment to anybody.
                return RPC_E_CANTCALLOUT_ININPUTSYNCCALL;
            }

            // All ASYNC calls from an MTA apartment are treated as SYNCHRONOUS,
            // so convert the call category here before proceeding.

            pMsg->rpcFlags &= ~RPCFLG_ASYNCHRONOUS;
        }
        else
        {
            // dont allow the application to call out while handling an
            // IMessageFilter call because it screws up the call sequencing.

            COleTls tls;
            CAptCallCtrl *pACC = tls->pCallCtrl;
            if (pACC && pACC->InMsgFilter())
            {
                ComDebOut((DEB_ERROR, "Illegal callout from within IMessageFilter\n"));
                return RPC_E_CANTCALLOUT_INEXTERNALCALL;
            }

            // Only set the old style async bit for the two old style interfaces.
            if ((pMsg->rpcFlags & RPC_BUFFER_ASYNC) &&
                (riid == IID_AsyncIAdviseSink || riid == IID_AsyncIAdviseSink2))
                pMsg->rpcFlags |= RPCFLG_ASYNCHRONOUS;

            // if the call is async and remote, or async and to an MTA apartment,
            // then change the category to sync, since we dont support async remotely
            // or to MTA apartments locally. This must be done before calling
            // CanMakeOutCall in order to avoid deadlocks. If the call is input sync
            // and remote or to an MTA apartment, dissallow the call.

            if (pMsg->rpcFlags & (RPCFLG_ASYNCHRONOUS | RPCFLG_INPUT_SYNCHRONOUS))
            {
                DWORD dwCtx;
                CRpcChannelBuffer::GetDestCtx(&dwCtx, NULL);

                if (dwCtx == MSHCTX_DIFFERENTMACHINE ||
                    (GetOXIDEntry()->IsMTAServer()))
                {
                    if (pMsg->rpcFlags & RPCFLG_INPUT_SYNCHRONOUS)
                        return RPC_E_CANTCALLOUT_ININPUTSYNCCALL;

                    // turn off the async flag so that the call looks (and acts)
                    // like it is synchronous.
                    pMsg->rpcFlags &= ~RPCFLG_ASYNCHRONOUS;
                }
            }

            // Make sure we are allowed to make this outgoing call. We do that here
            // so that we dont marshal all the parameters only to discover that we
            // cant call out and then have to free all the marshalled parameters
            // (especially the ones where marshalling has side effects).

            // figure out the call category of this call by looking at bit
            // values in the rpc message flags.

            DWORD dwCallCatOut = RpcFlagToCallCat(pMsg->rpcFlags);

            // check other outgoing call restrictions common to multi and single
            // threaded apartments

            hr = CanMakeOutCall(dwCallCatOut, riid, pMsg);
        }
    }

    if (hr == S_OK)
    {
        // ask the real channel for a buffer.
        hr =  CRpcChannelBuffer::GetBuffer(pMsg, riid);
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method:     CAptRpcChnl::SendReceive
//
//  Synopsis:   in MTA, just call the channel directly.
//              in STA, instantiate a modal loop object and then transmit the call
//
//  Parameters: [pMsg] - ptr to message structure
//              [pulStatus] - place to return a status code
//
//  History:    11-Nov-94   Rickhi      Created
//              11-Feb-98   JohnStra    Added NTA support.
//
//--------------------------------------------------------------------------
STDMETHODIMP CAptRpcChnl::SendReceive(RPCOLEMESSAGE *pMsg, ULONG *pulStatus)
{
    // Get the local OXID Entry
    OXIDEntry* pOXIDEntry = GetOXIDEntry();

    if (IsMTAThread() ||
        (pOXIDEntry->IsNTAServer() &&
         pOXIDEntry->IsInLocalProcess()))
    {
        // We are in the MTA, or, the server we are calling is in the NTA.
        // Just call the channel directly.
        return CRpcChannelBuffer::SendReceive( pMsg, pulStatus );
    }

    // STA. Construct a modal loop object for the call that is about to
    // be made. It maintains the call state and exits when the call has
    // been completed, cancelled, or rejected.
    CCliModalLoop CML(_dwTIDCallee, GetMsgQInputFlag(pMsg), 0);

    HRESULT hr;

    do
    {
        hr = CML.SendReceive(pMsg, pulStatus, this);

        if (hr == RPC_E_SERVERCALL_RETRYLATER)
        {
            // the call was rejected by the server and the client Msg Filter
            // decided to retry the call. We have to make a copy of the
            // message and re-send it.
            hr = CopyMsgForRetry(pMsg);
        }
        else if (hr == RPC_E_CALL_REJECTED)
        {
            // the call was rejected by the server and the client Msg Filter
            // decided NOT to retry the call. We have to free the buffer
            // that was returned since the proxy is not expecting it.
            CAptRpcChnl::FreeBuffer(pMsg);
        }

    }  while (hr == RPC_E_SERVERCALL_RETRYLATER);

    return hr;
}

//--------------------------------------------------------------------------
//
//  Method:     CAptRpcChnl::Send
//
//  Description:Used during pipe calls to send data.
//
//  Return:     S_OK, E_FAULT, E_SERVER_FAULT
//
//  Notes:      This is also used on the server side since we need
//              a modal loop there also.
//
//--------------------------------------------------------------------------
STDMETHODIMP CAptRpcChnl::Send(RPCOLEMESSAGE *pMsg, ULONG *pulStatus)
{
    if (IsMTAThread())
    {
        // MTA, just call the channel directly
        return CRpcChannelBuffer::Send(pMsg, pulStatus);
    }

    // STA. Construct a modal loop object for the call that is about to
    // be made. It maintains the call state and exits when the call has
    // been completed, cancelled, or rejected.

    CCliModalLoop CML(_dwTIDCallee, GetMsgQInputFlag(pMsg), 0);
    return CML.Send(pMsg, pulStatus, this);
}

//--------------------------------------------------------------------------
//
//  Method:     CAptRpcChnl::Send (IAsyncRpcChannelBuffer)
//
//  Description:Used for async calls
//
//  Return:     S_OK, E_FAULT, E_SERVER_FAULT
//
//--------------------------------------------------------------------------
STDMETHODIMP CAptRpcChnl::Send(RPCOLEMESSAGE *pMsg, ISynchronize *pISync)
{
    AsyncDebOutTrace((DEB_TRACE, "CAptRpcChnl::Send [in] pMsg:0x%x, pISync:0x%x\n",
                 pMsg, pISync));

    HRESULT hr = S_OK;
    if (pISync)
    {
        hr = RegisterAsync(pMsg, (IAsyncManager *) pISync);
    }

    if (SUCCEEDED(hr))
    {
        ULONG status;
        hr = Send(pMsg, &status);
        if (FAILED(hr))
        {
            pISync->Signal();
            pISync->Release();
        }
    }

    AsyncDebOutTrace((DEB_TRACE, "CAptRpcChnl::Send [out] hr:0x%x\n", hr));
    return hr;
}

//--------------------------------------------------------------------------
//
//  Method:     CAptRpcChnl::Receive
//
// Description: Used to receive data during pipe calls.
//
//  Return:     S_OK, E_FAULT, E_SERVER_FAULT
//
//--------------------------------------------------------------------------
STDMETHODIMP CAptRpcChnl::Receive(RPCOLEMESSAGE *pMsg, ULONG uSize, ULONG *pulStatus)
{
    if (IsMTAThread())
    {
        // MTA, just call the channel directly
        return CRpcChannelBuffer::Receive(pMsg, uSize, pulStatus);
    }

    // STA. Construct a modal loop object for the call that is about to
    // be made. It maintains the call state and exits when the call has
    // been completed, cancelled, or rejected.

    CCliModalLoop CML(_dwTIDCallee, GetMsgQInputFlag(pMsg), 0);
    return CML.Receive(pMsg, uSize, pulStatus, this);
}

//--------------------------------------------------------------------------
//
//  Method:     CAptRpcChnl::Receive (IAsyncRpcChannelBuffer)
//
// Description: Used to receive data during async calls.
//
//  Return:     S_OK, E_FAULT, E_SERVER_FAULT
//
//--------------------------------------------------------------------------
STDMETHODIMP CAptRpcChnl::Receive(RPCOLEMESSAGE *pMsg, ULONG *pulStatus)
{
    AsyncDebOutTrace((DEB_TRACE, "CAptRpcChnl::Receive [in] pMsg:0x%x, pulStatus:0x%x\n",
                 pMsg, pulStatus));
    HRESULT hr = Receive(pMsg, 0, pulStatus);
    AsyncDebOutTrace((DEB_TRACE, "CAptRpcChnl::Receive [out] hr:0x%x\n", hr));
    return hr;
}

//--------------------------------------------------------------------------
//
//  Function:   GetMsgQInputFlag
//
// Description: Determines the callcat of the call
//
//--------------------------------------------------------------------------
DWORD GetMsgQInputFlag(RPCOLEMESSAGE *pMsg)
{
    // Figure out the call category of this call by looking at the bit
    // values in the rpc message flags.

    DWORD dwCallCatOut    = RpcFlagToCallCat(pMsg->rpcFlags);
    DWORD dwMsgQInputFlag = gMsgQInputFlagTbl[dwCallCatOut];

    // Now for a spectacular hack. IRemUnknown::Release had slightly
    // different dwMsgQInputFlag semantic in the old code base, so we
    // check for that one case here and set the flag accordingly. Not
    // doing this would allow SYSCOMMAND calls in during Release which
    // we throw away, thus preventing an app from shutting down correctly.
    // SimpSvr.exe is a good example of this.

    if ((pMsg->iMethod & ~RPC_FLAGS_VALID_BIT) == 5 &&
        (IsEqualIID(IID_IRundown, *MSG_TO_IIDPTR(pMsg)) ||
         IsEqualIID(IID_IRemUnknown, *MSG_TO_IIDPTR(pMsg))))
    {
        dwMsgQInputFlag = (QS_POSTMESSAGE | QS_SENDMESSAGE | QS_TRANSFER |
                           QS_ALLPOSTMESSAGE);
    }

    return dwMsgQInputFlag;
}

//+-------------------------------------------------------------------------
//
//  Method:     CAptRpcChnl::CopyMsgForRetry
//
//  Synopsis:   Makes a copy of the message we sent. We have to ask Rpc
//              for another buffer and then copy the original buffer into
//              the new one so we can make another call.
//
//  Parameters: [pMsg] - ptr to message structure to copy
//
//  History:    11-Nov-94   Rickhi      Created
//
//--------------------------------------------------------------------------
HRESULT CAptRpcChnl::CopyMsgForRetry(RPCOLEMESSAGE *pMsg)
{
    ComDebOut((DEB_CALLCONT,"CAptRpcChnl::CopyMsgForRetry pMsg:%x\n", pMsg));

    // CODEWORK: this is dumb, but the channel blows chunks in FreeBuffer
    // if i dont do this double copy.

    void *pTmpBuf = PrivMemAlloc(pMsg->cbBuffer);
    if (pTmpBuf)
    {
        memcpy(pTmpBuf, pMsg->Buffer, pMsg->cbBuffer);
    }

    // save copy of the contents of the old message so we can free it later

    HRESULT hr = E_OUTOFMEMORY;
    CCtxCall *pCtxCall = ((CMessageCall *) pMsg->reserved1)->GetClientCtxCall();

    // Free current message
    CAptRpcChnl::FreeBuffer(pMsg);

    if (pTmpBuf)
    {
        // Inform context hook that the call is being retried
        gCtxHook.PrepareForRetry(pCtxCall);

        // Store context call object in TLS
        COleTls Tls;
        CCtxCall *pCurCall = pCtxCall->StoreInTLS(Tls);

        // allocate a new message, dont have to worry about checking the
        // CanMakeOutCall again, so we just ask the Rpc channel directly.
        pMsg->reserved1 = NULL;

#ifdef _WIN64
        // On a message retry we need to redo what the proxy did during transfer
        // protocol negotiation.
        hr = S_OK;

        if (IsNDRSyntaxNegotiated())
        {
            ClearNDRSyntaxNegotiated();     //Set "Not Negotiated" so errors cases in NegotiateSyntax work
            hr = NegotiateSyntax(pMsg);
        }
        if (SUCCEEDED(hr))
        {
            hr = CRpcChannelBuffer::GetBuffer(pMsg, *MSG_TO_IIDPTR(pMsg));
        }
#else
        hr = CRpcChannelBuffer::GetBuffer(pMsg, *MSG_TO_IIDPTR(pMsg));
#endif

        // Revoke context call object from TLS
        pCtxCall->RevokeFromTLS(Tls, pCurCall);

        if (SUCCEEDED(hr))
        {
            // Save the context call object inside message call
            ((CMessageCall *) pMsg->reserved1)->SetClientCtxCall(pCtxCall);

            // copy the temp buffer into the new buffer
            memcpy(pMsg->Buffer, pTmpBuf, pMsg->cbBuffer);
            hr = RPC_E_SERVERCALL_RETRYLATER;
        }

        PrivMemFree(pTmpBuf);
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CCliModalLoop::SendReceive
//
//  Synopsis:   called to transmit a call to the server and enter a modal
//              loop.
//
//  Arguments:  [pMsg] - message to send
//              [pulStatus] - place to return status code
//              [pChnl] - IRpcChannelBuffer pointer
//
//  Returns:    result of the call. May return RETRYLATER if the call should
//              be retransmitted.vv
//
//  History:    11-Nov-94       Rickhi      Created
//
//--------------------------------------------------------------------------
INTERNAL CCliModalLoop::SendReceive(RPCOLEMESSAGE *pMsg, ULONG *pulStatus,
                                    IInternalChannelBuffer *pChnl)
{
    // SendReceive is a blocking call. The channel will transmit the call
    // asynchronously then call us back in BlockFn where we wait for an
    // event such as the call completing, or a windows message arriving,
    // or the user cancelling the call. Because of the callback, we need
    // to set _hr before calling SR.

    _hr = RPC_S_CALLPENDING;
    _hr = pChnl->SendReceive2(pMsg, pulStatus);

    // By this point the call has completed. Now check if it was rejected
    // and if so, whether we need to retry immediately, later, or never.
    // Handling of Rejected calls must occur here, not in the BlockFn, due
    // to the fact that some calls and some protocols are synchronous, and
    // other calls and protocols are asynchronous.

    if (_hr == RPC_E_CALL_REJECTED || _hr == RPC_E_SERVERCALL_RETRYLATER)
    {
        // this function decides on 1 of 3 different courses of action
        // 1. fail the call     - sets the state to Call_Rejected
        // 2. retry immediately - sets _hr to RETRYLATER, fall out
        // 3. retry later       - starts the timer, we block below

        _hr = HandleRejectedCall(pChnl);

        // if a timer was installed to retry the call later, then we have
        // to go into modal loop until the timer expires. if the call is
        // cancelled while in this loop, the loop will be exited.

        while (!IsTimerAtZero())
        {
            BlockFn(NULL, 0, NULL);
        }

        // Either it is time to retransmit the call, or the call was
        // cancelled or rejected.
    }

    return _hr;
}

//--------------------------------------------------------------------------
//
// Member:      CCliModalLoop::Send
//
// Description: Used for pipe calls.
//
//  History:    15-Feb-97       RichN      Created
//
//--------------------------------------------------------------------------
INTERNAL CCliModalLoop::Send(RPCOLEMESSAGE *pMsg, ULONG *pulStatus,
                             IInternalChannelBuffer *pChnl)
{
    _hr = RPC_S_CALLPENDING;
    _hr = pChnl->Send2(pMsg, pulStatus);
    return _hr;
}

//--------------------------------------------------------------------------
//
// Member:      CCliModalLoop::Receive
//
// Description: Used for pipe calls.
//
//  History:    15-Feb-97       RichN      Created
//
//--------------------------------------------------------------------------
INTERNAL CCliModalLoop::Receive(RPCOLEMESSAGE *pMsg,
                                ULONG uSize,
                                ULONG *pulStatus,
                                IInternalChannelBuffer *pChnl)
{
    _hr = RPC_S_CALLPENDING;
    _hr = pChnl->Receive2(pMsg, uSize, pulStatus);
    return _hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CCliModalLoop::HandleRejectedCall
//
//  Synopsis:   called when the response to a remote call is rejected or
//              retry later.
//
//  Arguments:  [pChnl] - channel we are calling on.
//
//  Returns:    RPC_E_CALL_REJECTED - call is rejected
//              RPC_E_SERVERCALL_RETRYLATER - the call should be retried
//                      (Timer is set if retry is to be delayed)
//
//  Algorithm:  Calls the app's message filter (if there is one) to
//              determine whether the call should be failed, retried
//              immediately, or retried at some later time. If there is
//              no message filter, or the client is on a different machine,
//              then the call is always rejected.
//
//  History:    21-Dec-93 Johannp   Created
//              30-Apr-95 Rickhi    ReWrite
//
//--------------------------------------------------------------------------
INTERNAL CCliModalLoop::HandleRejectedCall(IInternalChannelBuffer *pChnl)
{
    // default return value - rejected
    DWORD dwRet = 0xffffffff;

    DWORD dwDestCtx;
    HRESULT hr = ((IRpcChannelBuffer3 *)pChnl)->GetDestCtx(&dwDestCtx, NULL);

    if (SUCCEEDED(hr) && dwDestCtx != MSHCTX_DIFFERENTMACHINE)
    {
        // the call is local to this machine, ask the message filter
        // what to do.  For remote calls we never allow retry, since
        // the parameters were not sent back to us in the packet.

        IMessageFilter *pMF = _pACC->GetMsgFilter();
        if (pMF)
        {
            ComDebOut((DEB_MFILTER,
                "pMF->RetryRejectedCall(dwTIDCallee:%x ElapsedTime:%x Type:%x)\n",
                    _dwTIDCallee, GetElapsedTime(),
                    (_hr == RPC_E_CALL_REJECTED) ? SERVERCALL_REJECTED
                                                 : SERVERCALL_RETRYLATER));

            dwRet = pMF->RetryRejectedCall((MF_HTASK)LongToPtr(_dwTIDCallee), GetElapsedTime(),
                         (_hr == RPC_E_CALL_REJECTED) ? SERVERCALL_REJECTED
                                                      : SERVERCALL_RETRYLATER);

            ComDebOut((DEB_MFILTER,"pMF->RetryRejected() dwRet:%x\n", dwRet));

            _pACC->ReleaseMsgFilter();
        }
    }

    if (dwRet == 0xffffffff)
    {
        // Really rejected. Mark it as such incase it was actually
        // Call_RetryLater, also ensures that IsWaiting returns FALSE
        return RPC_E_CALL_REJECTED;
    }
    else if (dwRet >= 100)
    {
        // Retry Later. Start the timer. This ensures that IsTimerAtZero
        // returns FALSE and IsWaiting returns TRUE
        return StartTimer(dwRet);
    }
    else
    {
        // Retry Immediately. The state is set so that IsTimerAtZero
        // returns TRUE.

        Win4Assert(IsTimerAtZero());
        return RPC_E_SERVERCALL_RETRYLATER;
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   OleModalLoopBlockFn
//
//  Synopsis:   Called by the RpcChannel during an outgoing call while
//              waiting for the reply message.
//
//  Arguments:  [pvWnd] - Window handle to expect the reply on
//              [pvCtx] - Call Context (the CCliModalLoop)
//              [hCallWaitEvent] - optional event to have CallControl wait on
//
//  Returns:    result of the call
//
//  Algorithm:  pvCtx is the topmost modal loop for the current apartment.
//              Just call it's block function.
//
//  History:    Dec-93   JohannP    Created
//
//--------------------------------------------------------------------------
RPC_STATUS SSAPI(OleModalLoopBlockFn(void *pvWnd, void *pvCtx, HANDLE hCallWaitEvent))
{
    Win4Assert( pvCtx != NULL );
    if (hCallWaitEvent == NULL)
        return ((CCliModalLoop *) pvCtx)->BlockFn(&hCallWaitEvent, 0, NULL);
    else
        return ((CCliModalLoop *) pvCtx)->BlockFn(&hCallWaitEvent, 1, NULL);
}

#ifdef _CHICAGO_
// Stack Switching Wrapper - W95 only, for switching to the 16bit stack in WOW.
RPC_STATUS OleModalLoopBlockFn(void *pvWnd, void *pvCtx, HANDLE hCallWaitEvent)
{
    StackDebugOut((DEB_ITRACE, "SSOleModalLoopBlockFn\n"));
    if (SSONBIGSTACK())
    {
        StackDebugOut((DEB_STCKSWTCH, "Stack switch(16) on OleModalLoopBlockFn\n"));
        return SSCall(12 ,SSF_SmallStack, (LPVOID)SSOleModalLoopBlockFn,
                         (DWORD)pvWnd, (DWORD)pvCtx, (DWORD)hCallWaitEvent);
    }
    else
    {
        return SSOleModalLoopBlockFn(pvWnd, pvCtx, hCallWaitEvent);
    }
}
#endif  // _CHICAGO_

//+-------------------------------------------------------------------------
//
//  Member:     CCliModalLoop::BlockFn (private)
//
//  Synopsis:   Implements the blocking part of the modal loop. This function
//              blocks until an event of interest occurs, then it goes and
//              processes that event and returns.
//
//  Arguments:  [hCallWaitEvent] - event to wait on (optional)
//
//  Returns:    RPC_S_CALLPENDING - the call is still pending a reply
//              RPC_E_CALL_CANCELLED - the call was cancelled.
//              RPC_E_SERVERCALL_RETRYLATER - the call should be retried later
//
//  History:    Dec-93   JohannP    Created
//              30-Apr-95 Rickhi    ReWrite
//
//--------------------------------------------------------------------------
HRESULT CCliModalLoop::BlockFn(HANDLE *ahEvent, DWORD cEvents,
                               LPDWORD lpdwSignaled)
{
    ComDebOut((DEB_CALLCONT,
        "CCliModalLoop::BlockFn this:%x dwMsgQInputFlag:%x ahEvent:%x\n",
        this, _dwMsgQInputFlag, ahEvent));
    Win4Assert( cEvents != 0 || IsWaiting() && "ModalLoop::BlockFn - not waiting on call");

    // First, we wait for an event of interest to occur, either for the call
    // to complete, or a new windows message to arrive on the queue.

    DWORD   dwWakeReason  = WAIT_TIMEOUT;

    if (cEvents != 0)
    {
        // Check if an event is already signalled. This ensures that
        // when we return from nested calls and the upper calls have already
        // been acknowledged, that no windows messages can come in.

        ComDebOut((DEB_CALLCONT, "WaitForMultipleObject cEvent:%x\n", cEvents));

        dwWakeReason = WaitForMultipleObjectsEx(cEvents,
                                                ahEvent,
                                                _dwWaitFlags&COWAIT_WAITALL,
                                                0,
                                                _dwWaitFlags&COWAIT_ALERTABLE);
    }

    if (dwWakeReason == WAIT_TIMEOUT)
    {
        DWORD dwWaitTime = TicksToWait();

        // If we want to wake up for a posted message, we need to make
        // sure that we haven't missed any because of the queue status
        // being affected by prior PeekMessages. We don't worry about
        // QS_SENDMESSAGE because if PeekMessage got called, the pending
        // send got dispatched. Further, if we are in an input sync call,
        // we don't want to start dispatching regular RPC calls here by
        // accident.

        if (_dwMsgQInputFlag & QS_POSTMESSAGE)
        {
            DWORD dwStatus = GetQueueStatus(_dwMsgQInputFlag);

            // We care about any message on the queue not just new messages
            // because PeekMessage affects the queue state. It resets the
            // state so even if a message is not processed, the queue state
            // represents this as an old message even though no one has
            // ever looked at it. So even though the message queue tells us
            // there are no new messages in the queue. A new message we are
            // interested in could be in the queue.

            WORD wNew = (WORD) dwStatus | HIWORD(dwStatus);

            // Note that we look for send as well as post because our
            // queue status could have reset the state of the send message
            // bit and therefore, MsgWaitForMultipleObject below will not
            // wake up to dispatch the send message.

            if (wNew & (QS_POSTMESSAGE | QS_SENDMESSAGE))
            {
                // the acknowledge message might be already in the queue
                if (PeekRPCAndDDEMessage())
                {
                    // we know that *some* RPC message came in and was
                    // processed. It could have been the Reply we were waiting
                    // for OR some other incoming call. Since we cant tell
                    // which, we return to RPC land. If it was not our Reply
                    // then RPC will call our modal loop again.
                    return _hr;
                }
            }

#ifdef _CHICAGO_
            //Note:POSTPPC
            WORD wOld = HIWORD(dwStatus);

            if (wOld & (QS_POSTMESSAGE))
            {
                 ComDebOut((DEB_CALLCONT, "Set timeout time to 100\n"));
                 dwWaitTime = 100;
            }
#endif //_CHICAGO_
        }

        ComDebOut((DEB_CALLCONT,
            "Call MsgWaitForMultiple time:%ld, cEvents:%x pEvent:%x,\n",
            dwWaitTime, cEvents, ahEvent ));

        DWORD dwFlags = (_dwWaitFlags & COWAIT_WAITALL) ? MWMO_WAITALL : 0;
        dwFlags |= (_dwWaitFlags & COWAIT_ALERTABLE) ? MWMO_ALERTABLE : 0;

        dwWakeReason = MsgWaitForMultipleObjectsEx(cEvents,
                                                 ahEvent,
                                                 dwWaitTime,
                                                 _dwMsgQInputFlag,
                                                 dwFlags);

        ComDebOut((DEB_CALLCONT,
            "MsgWaitForMultipleObjects hr:%ld\n", dwWakeReason));
    }
    else if (dwWakeReason == WAIT_FAILED)
    {
        // Wait occasionally fails on Win95. Not much we can do here except
        // just exit and retransmit the call
        ComDebOut((DEB_ERROR, "WaitForSingleObject error:%ld\n", GetLastError()));
        Win4Assert((FALSE) && "CCliModalLoop::BlockFn WaitForSingleObject error");
        return(_hr = RPC_E_SERVERCALL_RETRYLATER);
    }


    // OK, we've done whatever blocking we were going to do and now we have
    // been woken up, so figure out what event of interest occured to wake
    // us up and go handle it.

    if (dwWakeReason == (WAIT_OBJECT_0 + cEvents))
    {
        // Windows message came in - go process it
        ComDebOut((DEB_CALLCONT, "BlockFn: Windows Message Arrived\n"));
        HandleWakeForMsg();
    }
    else if (dwWakeReason == WAIT_TIMEOUT)
    {
        if (_hr == RPC_S_WAITONTIMER && IsTimerAtZero())
        {
            // The Retrytimer timed out - just exit and retransmit the call
            ComDebOut((DEB_CALLCONT, "BlockFn: Timer at zero\n"));
            _hr = RPC_E_SERVERCALL_RETRYLATER;
        }
        else
        {
            // we may have missed a message before we called MsgWaitForMult...
            // so we go check now for any incoming messages.
            ComDebOut((DEB_CALLCONT, "BlockFn: Timeout-Look for msgs\n"));
            HandleWakeForMsg();
        }
    }
    else  if (dwWakeReason == 0xffffffff)
    {
        // Wait occasionally fails on Win95. Not much we can do except
        // just exit and retransmit the call.
        ComDebOut((DEB_ERROR, "MsgWaitForMultipleObjects error:%ld\n", GetLastError()));
        Win4Assert((FALSE) && "CCliModalLoop::BlockFn MsgWaitForMultipleObjects error");
        return(_hr = RPC_E_SERVERCALL_RETRYLATER);
    }
    else
    {
        // CallComplete signalled - the call is done.
        ComDebOut((DEB_CALLCONT, "BlockFn: CallComplete Event Signaled\n"));
        if (lpdwSignaled != NULL)
            *lpdwSignaled = dwWakeReason - WAIT_OBJECT_0;
        _hr = S_OK;
    }

    ComDebOut((DEB_CALLCONT, "CCliModalLoop::BlockFn this:%x returns:%x\n",
        this, _hr));
    return _hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CCliModalLoop::HandleWakeForMsg (private)
//
//  Synopsis:   Handle wake for the arrival of some kind of message
//
//  Returns:    nothing
//              fClearedQueue flag set if appropriate
//
//  Algorithm:  If this is called to wake up for a posted message, we
//              check the queue status. If the message queue status indicates
//              that there is some kind of a modal loop going on, then we
//              clear all the keyboard and mouse messages in our queue. Then
//              if we wake up for all input, we check the message queue to
//              see whether we need to notify the application that a message
//              has arrived. Then, we dispatch any messages that have to do
//              with the ORPC system. Finally we yield just in case we need
//              to dispatch a send message in the VDM. For an input sync
//              RPC, all we do is a call that will yield to get the pending
//              send message dispatched.
//
//  History:    Dec-93   JohannP    Created
//              13-Aug-94 Ricksa    Created
//
//--------------------------------------------------------------------------
INTERNAL_(void) CCliModalLoop::HandleWakeForMsg()
{
    MSG msg;    // Used for various peeks.

    // Is this an input sync call?
    if (_dwMsgQInputFlag != QS_SENDMESSAGE)
    {
        // No, so we have to worry about the state of the message queue.
        // We have to be careful that we aren't holding the input focus
        // on an input synchronized queue.

        // So what is the state of the queue? - note we or QS_TRANSFER because
        // this an undocumented flag which tells us the the input focus has
        // changed to us.

        DWORD dwQueueFlags = GetQueueStatus(QS_ALLINPUT | QS_TRANSFER);
        ComDebOut((DEB_CALLCONT, "Queue Status %lx\n", dwQueueFlags));

        // Call through to the application if we are going to. We do this here
        // so that the application gets a chance to process any
        // messages that it wants to and also allows the call control to
        // dispatch certain messages that it knows how to, thus making the
        // queue more empty.

        if (((_dwMsgQInputFlag & QS_ALLINPUT) == QS_ALLINPUT) &&
              FindMessage(dwQueueFlags))
        {
            // pending message in the queue
            HandlePendingMessage();
        }

        // Did the input focus change to us?
        if ((LOWORD(dwQueueFlags) & QS_TRANSFER) || _dwFlags & CMLF_CLEAREDQUEUE)
        {
            ComDebOut((DEB_CALLCONT, "Message Queue is being cleared\n"));
            _dwFlags |= CMLF_CLEAREDQUEUE;

            // Try to clear the queue as best we can of any messages that
            // might be holding off some other modal loop from executing.
            // So we eat all mouse and key events.
            if (HIWORD(dwQueueFlags) & QS_KEY)
            {
                while (MyPeekMessage(&msg, NULL, WM_KEYFIRST, WM_KEYLAST,
                    PM_REMOVE | PM_NOYIELD))
                {
                    ;
                }
            }

            // Clear mouse releated messages if there are any
            if (HIWORD(dwQueueFlags) & QS_MOUSE)
            {
                while (MyPeekMessage(&msg, NULL, WM_MOUSEFIRST, WM_MOUSELAST,
                    PM_REMOVE | PM_NOYIELD))
                {
                    ;
                }

                while (MyPeekMessage(&msg, NULL, WM_NCMOUSEFIRST,
                    WM_NCMOUSELAST, PM_REMOVE | PM_NOYIELD))
                {
                    ;
                }

                while (MyPeekMessage(&msg, NULL, WM_QUEUESYNC, WM_QUEUESYNC,
                    PM_REMOVE  | PM_NOYIELD))
                {
                    ;
                }
            }

            // Get rid of paint message if we can as well -- this makes
            // the screen look so much better.
            if (HIWORD(dwQueueFlags) & QS_PAINT)
            {
                if (MyPeekMessage(&msg, NULL, WM_PAINT, WM_PAINT, PM_REMOVE | PM_NOYIELD))
                {
                    ComDebOut((DEB_CALLCONT, "Dispatch paint\n"));
                    MyDispatchMessage(&msg);
                }
            }
        }
    }
    else if (!IsWOWThread() || !IsWOWThreadCallable())
    {
        // We need to give user control so that the send message
        // can get dispatched. Thus the following is simply a no-op
        // which gets into user to let it dispatch the message.
        PeekMessage(&msg, 0, WM_NULL, WM_NULL, PM_NOREMOVE);
    }

    if (IsWOWThread() && IsWOWThreadCallable())
    {
        // In WOW, a genuine yield is the only thing to guarantee
        // that SendMessage will get through
        ComDebOut((DEB_CALLCONT, "YieldTask16\n"));
        g_pOleThunkWOW->YieldTask16();
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CCliModalLoop::PeekRPCAndDDEMessage
//
//  Synopsis:   Called when a windows message arrives to look for incoming
//              Rpc messages which might be the reply to an outstanding call
//              or may be new incoming request messages. Also looks for
//              DDE messages.
//
//  Returns:    TRUE  - found and processed an RPC message
//              FALSE - did not find an RPC message
//
//  History:    21-Dec-93 JohannP   Created
//              30-Apr-95 Rickhi    ReWrite
//
//--------------------------------------------------------------------------
BOOL CCliModalLoop::PeekRPCAndDDEMessage()
{
    // loop over all windows looking for incoming Rpc messages. Note that
    // it is possible for a dispatch here to cause one of the windows to
    // be deregistered or another to be registered, so our loop has to account
    // for that, hence the check for NULL hWnd.

    BOOL fRet = FALSE;
    MSG  Msg;

    for (UINT i = 0; i < 2; i++)
    {
        // get window info and peek on it if the hWnd is still OK
        SWindowData *pWD = _pACC->GetWindowData(i);

        if (pWD->hWnd != WD_EMPTY)
        {
            if (MyPeekMessage(&Msg, pWD->hWnd, pWD->wFirstMsg, pWD->wLastMsg,
                           PM_REMOVE | PM_NOYIELD))
            {
                Win4Assert(IsWaiting());
                MyDispatchMessage(&Msg);

                // exit on the first dispatched message. If the message was
                // not the reply we were waiting for, then the channel will
                // call us back again.
                return TRUE;
            }
        }
    }

    return FALSE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CCliModalLoop::FindMessage
//
//  Synopsis:   Called by HandleWakeForMsg when a message arrives on the
//              windows msg queue.  Determines if there is something of
//              interest to us, and pulls timer msgs. Dispatches RPC, DDE,
//              and RPC timer messages.
//
//  Arguments:  [dwStatus] - current Queue status (from GetQueueStatus)
//
//  Returns:    TRUE  - there is a message to process
//              FALSE - no messages to process
//
//  Algorithm:  Find the next message in the queue by using the following
//              priority list:
//
//              1. RPC and DDE messages
//              2. mouse and keyboard messages
//              3. other messages
//
//  History:    21-Dec-93 Johannp   Created
//
//--------------------------------------------------------------------------
INTERNAL_(BOOL) CCliModalLoop::FindMessage(DWORD dwStatus)
{
    WORD wOld = HIWORD(dwStatus);
    WORD wNew = (WORD) dwStatus;

    if (!wNew)
    {
        if (!(wOld & QS_POSTMESSAGE))
            return FALSE;   // no messages to take care of
        else
            wNew |= QS_POSTMESSAGE;
    }

    MSG Msg;

    // Priority 1: look for RPC and DDE messages
    if (wNew & (QS_POSTMESSAGE | QS_SENDMESSAGE | QS_TIMER))
    {
        if (PeekRPCAndDDEMessage())
        {
            // we know that *some* RPC message came in, might be our
            // reply or may be some incoming call. In any case, return to
            // the modal loop to guy so we can figure out if we need to
            // keep going.
            return FALSE;
        }
    }

    if (wNew & QS_TIMER)
    {
        // throw the system timer messages away
        while (MyPeekMessage(&Msg, 0, WM_SYSTIMER, WM_SYSTIMER, PM_REMOVE | PM_NOYIELD))
            ;
    }

    // Priority 2: messages from the hardware queue
    if (wNew & (QS_KEY | QS_MOUSEMOVE | QS_MOUSEBUTTON))
    {
        return TRUE;        // these messages are always removed
    }
    else if (wNew & QS_TIMER)
    {
        if (MyPeekMessage(&Msg, 0, WM_TIMER, WM_TIMER, PM_NOREMOVE | PM_NOYIELD) )
            return TRUE;
    }
    else if (wNew & QS_PAINT)
    {
        return TRUE;        // this  message might not get removed
    }
    else if (wNew & (QS_POSTMESSAGE | QS_SENDMESSAGE))
    {
        if (MyPeekMessage(&Msg, 0, 0, 0, PM_NOREMOVE))
            return TRUE;    // Priority 3: all other messages
    }

    return FALSE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CCliModalLoop::HandlePendingMessage
//
//  Synopsis:   this function is called for system messages and other
//              pending messages
//
//  Arguments:  none
//
//  Returns:    nothing, _hr may be updated if call is cancelled.
//
//  Algorithm:
//
//  History:    21-Dec-93 Johannp   Created
//              30-Apr-95 Rickhi    ReWrite
//
//--------------------------------------------------------------------------
INTERNAL_(void) CCliModalLoop::HandlePendingMessage()
{
    // get and call the message filter if there is one
    IMessageFilter *pMF = _pACC->GetMsgFilter();

    if (pMF)
    {
        ComDebOut((DEB_MFILTER,
            "pMF->MessagePending(dwTIDCallee:%x ElapsedTime:%x Type:%x)\n",
            _dwTIDCallee, GetElapsedTime(),
            (_pPrev) ? PENDINGTYPE_NESTED : PENDINGTYPE_TOPLEVEL));

        DWORD dwRet = pMF->MessagePending((MF_HTASK)LongToPtr(_dwTIDCallee),
                                          GetElapsedTime(),
                                          (_pPrev) ? PENDINGTYPE_NESTED
                                                   : PENDINGTYPE_TOPLEVEL);

        ComDebOut((DEB_MFILTER,"pMF->MessagePending() dwRet:%x\n", dwRet));


        _pACC->ReleaseMsgFilter();

        if (dwRet == PENDINGMSG_CANCELCALL)
        {
            _hr = RPC_E_CALL_CANCELED;
            return;
        }

        Win4Assert((dwRet == PENDINGMSG_WAITDEFPROCESS ||
                    dwRet == PENDINGMSG_WAITNOPROCESS) &&
                    "Invalid return value from pMF->MessagePending");
    }

    // if we get here we are going to do the default message processing.
    // Default Processing: Continue to wait for the call return and
    // don't dispatch the new message. Perform default processing on
    // special system messages.

    MSG  msg;

    // we have to take out all syscommand messages
    if (MyPeekMessage(&msg, 0, WM_SYSCOMMAND, WM_SYSCOMMAND, PM_REMOVE | PM_NOYIELD))
    {
        // only dispatch some syscommands
        if (msg.wParam == SC_HOTKEY || msg.wParam == SC_TASKLIST)
        {
            ComDebOut((DEB_CALLCONT,">>>> Dispatching SYSCOMMAND message: %x; wParm: %x \r\n",msg.message, msg.wParam));
            MyDispatchMessage(&msg);
        }
        else
        {
            ComDebOut((DEB_CALLCONT,">>>> Received/discarded SYSCOMMAND message: %x; wParm: %x \r\n",msg.message, msg.wParam));
            MessageBeep(0);
        }
    }
    else if (MyPeekMessage(&msg, 0, WM_SYSKEYDOWN, WM_SYSKEYDOWN, PM_NOREMOVE | PM_NOYIELD))
    {
        if (msg.message == WM_KEYDOWN)
        {
            if (msg.wParam != VK_CONTROL && msg.wParam != VK_SHIFT)
                MessageBeep(0);
        }
        else if (msg.message == WM_SYSKEYDOWN && msg.lParam & SYS_ALTDOWN &&
                 (msg.wParam == VK_TAB || msg.wParam == VK_ESCAPE))
        {
            MyPeekMessage(&msg, 0, WM_SYSKEYDOWN, WM_SYSKEYDOWN, PM_REMOVE | PM_NOYIELD);
            TranslateMessage(&msg);
            MyDispatchMessage(&msg);
        }
    }
    else if (MyPeekMessage(&msg, 0, WM_ACTIVATE, WM_ACTIVATE, PM_REMOVE | PM_NOYIELD)
          || MyPeekMessage(&msg, 0, WM_ACTIVATEAPP, WM_ACTIVATEAPP, PM_REMOVE | PM_NOYIELD)
          || MyPeekMessage(&msg, 0, WM_NCACTIVATE, WM_NCACTIVATE, PM_REMOVE | PM_NOYIELD) )
    {
        MyDispatchMessage(&msg);
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CCliModalLoop::MyPeekMessage
//
//  Synopsis:   This function is called whenever we want to do a PeekMessage.
//              It intercepts WM_QUIT messages and remembers them so that
//              they can be reposted when the modal loop is exited.
//
//  Arguments:  [pMsg] - message structure
//              [hWnd] - window to peek on
//              [min/max] - min and max message numbers
//              [wFlag] - peek flags
//
//  Returns:    TRUE  - a message is available
//              FALSE - no messages available
//
//  History:    21-Dec-93 Johannp       Created
//
//--------------------------------------------------------------------------
INTERNAL_(BOOL) CCliModalLoop::MyPeekMessage(MSG *pMsg, HWND hwnd,
                                             UINT min, UINT max, WORD wFlag)
{
    BOOL fRet = PeekMessage(pMsg, hwnd, min, max, wFlag);

    while (fRet)
    {
        ComDebOut((DEB_CALLCONT, "MyPeekMessage: hwnd:%x msg:%d time:%ld\n",
            pMsg->hwnd, pMsg->message, pMsg->time));

        if (pMsg->message != WM_QUIT)
        {
            // it is not a QUIT message so exit the loop and return TRUE
            break;
        }

        // just remember that we saw a QUIT message. we will ignore it for
        // now and repost it after our call has completed.

        ComDebOut((DEB_CALLCONT, "WM_QUIT received.\n"));
        _wQuitCode = (ULONG) pMsg->wParam;
        _dwFlags  |= CMLF_QUITRECEIVED;

        if (!(wFlag & PM_REMOVE))   // NOTE: dont use PM_NOREMOVE
        {
            // quit message is still on queue so pull it off
            PeekMessage(pMsg, hwnd, WM_QUIT, WM_QUIT, PM_REMOVE | PM_NOYIELD);
        }

        // peek again to see if there is another message
        fRet = PeekMessage(pMsg, hwnd, min, max, wFlag);
    }

    return fRet;
}

//+-------------------------------------------------------------------------
//
//  Member:     CCliModalLoop::MyDispatchMessage
//
//  Synopsis:   This function is called whenever we want to dispatch a
//              message we have peeked.
//
//  Arguments:  [pMsg] - message structure
//
//--------------------------------------------------------------------------
inline INTERNAL_(void) CCliModalLoop::MyDispatchMessage(MSG *pMsg)
{
    ComDebOut((DEB_CALLCONT, "Dispatching Message hWnd:%x msg:%d wParam:%x\n",
        pMsg->hwnd, pMsg->message, pMsg->wParam));

    DispatchMessage(pMsg);
}

//+-------------------------------------------------------------------------
//
//  Member:     CCliModalLoop::GetElapsedTime
//
//  Synopsis:   Get the elapsed time for an RPC call
//
//  Returns:    Elapsed time of current call
//
//  Algorithm:  This checks whether we have the slow time factor. If not,
//              and we are in WOW we read it from the registry. Otherwise,
//              it is just set to one. Then we calculate the time of the
//              RPC call and divide it by the slow time factor.
//
//  History:    22-Jul-94 Ricksa    Created
//
//--------------------------------------------------------------------------
INTERNAL_(DWORD) CCliModalLoop::GetElapsedTime()
{
    // Define slow time factor to something invalid
    static dwSlowTimeFactor = 0;

    if (dwSlowTimeFactor == 0)
    {
        if (IsWOWProcess())
        {
            // Get time factor from registry otherwise set to the default
            dwSlowTimeFactor = GetSlowTimeFactor();
        }
        else
        {
            // Time is unmodified for 32 bit apps
            dwSlowTimeFactor = 1;
        }
    }

    DWORD dwTickCount = GetTickCount();
    DWORD dwElapsedTime = dwTickCount - _dwTimeOfCall;
    if (dwTickCount < _dwTimeOfCall)
    {
        // the timer wrapped
        dwElapsedTime = 0xffffffff - _dwTimeOfCall + dwTickCount;
    }

    return  (dwElapsedTime / dwSlowTimeFactor);
}

//+-------------------------------------------------------------------------
//
//  Member:     CCliModalLoop::FindPrevCallOnLID        [server side]
//
//  Synopsis:   When an incoming call arrives this is used to find any
//              previous call for the same logical thread, ignoring
//              INTERNAL calls.  The result is used to determine if this
//              is a nested call or not.
//
//  Arguments:  [lid] - logical threadid of incoming call
//
//  Returns:    pCML - if a previous CliModalLoop found for this lid
//              NULL - otherwise
//
//  Algorithm:  just walk backwards on the _pPrev chain
//
//  History:    17-Dec-93 JohannP    Created
//              30-Apr-95 Rickhi     ReWrite
//
//--------------------------------------------------------------------------
CCliModalLoop *CCliModalLoop::FindPrevCallOnLID(REFLID lid)
{
    CCliModalLoop *pCML = this;

    do
    {
        if (pCML->_lid == lid)
        {
            break;      // found a match, return it
        }

    } while ((pCML = pCML->_pPrev) != NULL);

    return pCML;
}

//+-------------------------------------------------------------------------
//
//  Function:   STAInvoke
//
//  Synopsis:   Called whenever an incoming call arrives in a single-threaded
//              apartment. It asks the apps message filter (if there is one)
//              whether it wants to handle the call or not, and dispatches
//              the call if OK.
//
//  Arguments:  [pMsg] - Incoming Rpc message
//              [CallCatIn] - callcat of incoming call
//              [pStub] - stub to call if MF says it is OK
//              [pChnl] - channel ptr to give to stub
//              [pv] - real interface being called
//              [pdwFault] - where to store fault code if there is a fault
//
//  Returns:    result for MF or from call to stub
//
//  History:    21-Dec-93 Johannp   Original Version
//              22-Jul-94 Rickhi    ReWrite
//
//--------------------------------------------------------------------------
INTERNAL STAInvoke(RPCOLEMESSAGE *pMsg, DWORD CallCatIn, IRpcStubBuffer *pStub,
                   IInternalChannelBuffer *pChnl, void *pv,
                   IPIDEntry *pIPIDEntry, DWORD *pdwFault)
{
    ComDebOut((DEB_CALLCONT,
        "STAInvoke pMsg:%x CallCatIn:%x pStub:%x pChnl:%x\n",
         pMsg, CallCatIn, pStub, pChnl));

    HRESULT hr = HandleIncomingCall(*MSG_TO_IIDPTR(pMsg),
                                    (WORD)pMsg->iMethod,
                                    CallCatIn, pv);
    if (hr == S_OK)
    {
        // the message filter says its OK to invoke the call.

        // construct a server call state. This puts the current incoming
        // call's CallCat in Tls so we can check it if the server tries to
        // make an outgoing call while handling this call. See CanMakeOutCall.
        CSrvCallState SCS(CallCatIn);

        // invoke the call
        hr = MTAInvoke(pMsg, CallCatIn, pStub, pChnl, pIPIDEntry, pdwFault);
    }
    else if (hr == RPC_E_CALL_REJECTED || hr == RPC_E_SERVERCALL_RETRYLATER)
    {
        // server is rejecting the call, try to copy the incomming buffer so
        // that the client has the option of retrying the call.
        hr = CopyMsgForRetry(pMsg, pChnl, hr);
    }

    ComDebOut((DEB_CALLCONT,"STAInvoke returns:%x\n",hr));
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   HandleIncomingCall, internal
//
//  Synopsis:   Called whenever an incoming call arrives in a single-threaded
//              apartment. It asks the app's message filter (if there is one)
//              whether it wants to handle the call or not
//
//  Arguments:  [piid] - ptr to interface the call is being made on
//              [iMethod] - method number being called
//              [CallCatIn] - category of incoming call
//              [pv] - real interface being called
//
//  Returns:    result from MF
//
//  History:    11-Oct-96 Rickhi   Separated from STAInvoke
//              12-Feb-98 Johnstra Made NTA aware
//
//--------------------------------------------------------------------------
INTERNAL HandleIncomingCall(REFIID riid, WORD iMethod, DWORD CallCatIn, void *pv)
{
    ComDebOut((DEB_CALLCONT,
        "HandleIncomingCall iid:%I iMethod:%x CallCatIn:%x pv:%x:%x\n",
         &riid, iMethod, CallCatIn, pv));

    COleTls tls;
    if (IsThreadInNTA() || !(tls->dwFlags & OLETLS_APARTMENTTHREADED))
    {
        // free-threaded apartments don't have a message filter
        return S_OK;
    }

    HRESULT hr = S_OK;
    CAptCallCtrl *pACC = tls->pCallCtrl;


    // We dont call the message filter for IUnknown since older versions
    // of OLE did not, and doing so (unfortunately) breaks compatibility.
    // Also check for IRundown since local clients call on it instead of
    // IRemUnknown.

    IMessageFilter *pMF = (riid == IID_IRundown ||
                           riid == IID_IRemUnknown ||
                           riid == IID_IRemUnknown2)
                          ? NULL : pACC->GetMsgFilter();

    if (pMF)
    {
        //  the app has installed a message filter, call it.

        INTERFACEINFO IfInfo;
        IfInfo.pUnk = (IUnknown *)pv;
        IfInfo.iid = riid;
        IfInfo.wMethod = iMethod;

        ComDebOut((DEB_CALLCONT, "Calling iMethod:%x riid:%I\n",
            IfInfo.wMethod, &IfInfo.iid));

        CCliModalLoop *pCML = NULL;
        REFLID lid          = tls->LogicalThreadId;
        DWORD  TIDCaller    = tls->dwTIDCaller;

        DWORD dwCallType    = pACC->GetCallTypeForInCall(&pCML, lid, CallCatIn);
        DWORD dwElapsedTime = (pCML) ? pCML->GetElapsedTime() : 0;

        // The DDE layer doesn't provide any interface information. This
        // was true on the 16-bit implementation, and has also been
        // brought forward into this implementation to insure
        // compatibility. However, the CallCat of the IfInfo is still
        // provided.
        //
        // Therefore, if pIfInfo has its pUnk member set to NULL, then
        // we are going to send a NULL pIfInfo to the message filter.

        ComDebOut((DEB_MFILTER,
         "pMF->HandleIncomingCall(dwCallType:%x TIDCaller:%x dwElapsedTime:%x IfInfo:%x)\n",
         dwCallType, TIDCaller, dwElapsedTime, (IfInfo.pUnk) ? &IfInfo : NULL));

        DWORD dwRet = pMF->HandleInComingCall(dwCallType,
                                              (MF_HTASK)LongToPtr(TIDCaller),
                                              dwElapsedTime,
                                              IfInfo.pUnk ? &IfInfo : NULL);

        ComDebOut((DEB_MFILTER,"pMF->HandleIncomingCall() dwRet:%x\n", dwRet));

        pACC->ReleaseMsgFilter();

        // strict checking of app return code for win32
        Win4Assert(dwRet == SERVERCALL_ISHANDLED  ||
                   dwRet == SERVERCALL_REJECTED   ||
                   dwRet == SERVERCALL_RETRYLATER ||
                   IsWOWThread() && "Invalid Return code from App IMessageFilter");


        if (dwRet != SERVERCALL_ISHANDLED)
        {
            if (CallCatIn == CALLCAT_ASYNC || CallCatIn == CALLCAT_INPUTSYNC)
            {
                // Note: input-sync and async calls can not be rejected
                // Even though they can not be rejected, we still have to
                // call the MF above to maintain 16bit compatability.
                hr = S_OK;
            }
            else if (dwRet == SERVERCALL_REJECTED)
            {
                hr = RPC_E_CALL_REJECTED;
            }
            else if (dwRet == SERVERCALL_RETRYLATER)
            {
                hr = RPC_E_SERVERCALL_RETRYLATER;
            }
            else
            {
                // 16bit OLE let bogus return codes go through and of course
                // apps rely on that behaviour so we let them through too, but
                // we are more strict on 32bit.
                hr = (IsWOWThread()) ? S_OK : RPC_E_UNEXPECTED;
            }
        }
    }

    ComDebOut((DEB_CALLCONT, "HandleIncomingCall hr:%x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   MTAInvoke
//
//  Synopsis:   Multi-Threaded Apartment Invoke. Called whenever an incoming
//              call arrives in the MTA apartment (or as a subroutine to
//              STAInvoke). It just dispatches to a common sub-routine.
//
//  Arguments:  [pMsg] - Incoming Rpc message
//              [pStub] - stub to call if MF says it is OK
//              [pChnl] - channel ptr to give to stub
//              [pdwFault] - where to store fault code if there is a fault
//
//  Returns:    result from calling the stub
//
//  History:    03-Oct-95   Rickhi  Made into subroutine from STAInvoke
//
//--------------------------------------------------------------------------
INTERNAL MTAInvoke(RPCOLEMESSAGE *pMsg, DWORD CallCatIn, IRpcStubBuffer *pStub,
                   IInternalChannelBuffer *pChnl, IPIDEntry *pIPIDEntry,
                   DWORD *pdwFault)
{
#if DBG==1
    ComDebOut((DEB_CALLCONT,
        "MTAInvoke pMsg:%x CallCatIn:%x pStub:%x pChnl:%x\n",
         pMsg, CallCatIn, pStub, pChnl));
    IID iid       = *MSG_TO_IIDPTR(pMsg);
    DWORD iMethod = pMsg->iMethod;
    DebugPrintORPCCall(ORPC_INVOKE_BEGIN, iid, iMethod, CallCatIn);
    RpcSpy((CALLIN_BEGIN, NULL, iid, iMethod, 0));
#endif

    // call a common subroutine to do the dispatch. The subroutine also
    // catches exceptions and provides some debug help.

    HRESULT hr = pChnl->ContextInvoke(pMsg, pStub, pIPIDEntry, pdwFault);

#if DBG==1
    RpcSpy((CALLIN_END, NULL, iid, iMethod, hr));
    DebugPrintORPCCall(ORPC_INVOKE_END, iid, iMethod, CallCatIn);
    ComDebOut((DEB_CALLCONT,"MTAInvoke returns:%x\n",hr));
#endif

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   CopyMsgForRetry
//
//  Synopsis:   Makes a copy of the server-side message buffer to return to
//              the client so that the client can retry the call later.
//              Returns an error if the client is on a different machine.
//
//  Parameters: [pMsg] - ptr to message to copy
//              [pChnl] - ptr to channel call is being made on
//              [hr] - result code
//
//  History:    30-05-95    Rickhi  Created
//
//+-------------------------------------------------------------------------
HRESULT CopyMsgForRetry(RPCOLEMESSAGE *pMsg, IInternalChannelBuffer *pChnl,
                        HRESULT hrIn)
{
    ComDebOut((DEB_CALLCONT,"CopyMsgForRetry pMsg:%x pChnl:%x pBuffer:%x\n",
        pMsg, pChnl, pMsg->Buffer));

    DWORD dwDestCtx;
    HRESULT hr = ((IRpcChannelBuffer3 *) pChnl)->GetDestCtx(&dwDestCtx, NULL);

    if (SUCCEEDED(hr) && dwDestCtx != MSHCTX_DIFFERENTMACHINE &&
        !IsEqualGUID(IID_ILocalSystemActivator, *MSG_TO_IIDPTR(pMsg)))
    {
        // client on same machine as server.
        void *pSavedBuffer = pMsg->Buffer;

        // Store context call object in TLS
        COleTls Tls;
        CCtxCall *pCtxCall = NULL;
        CCtxCall *pCurCall = NULL;

        if(pMsg->reserved1)
        {
            pCtxCall = ((CMessageCall *) pMsg->reserved1)->GetServerCtxCall();
            pCurCall = pCtxCall->StoreInTLS(Tls);
        }

        // Obtain a new buffer from the apartment channel
        hr = pChnl->GetBuffer2(pMsg, *MSG_TO_IIDPTR(pMsg));

        if(pCtxCall)
        {
            // Revoke context call object from TLS
            pCtxCall->RevokeFromTLS(Tls, pCurCall);
        }

        // Check for success
        if (SUCCEEDED(hr))
        {
            // copy original buffer to the new buffer
            memcpy(pMsg->Buffer, pSavedBuffer, pMsg->cbBuffer);
            hr = hrIn;
        }
    }
    else
    {
        // client on different machine than server, or the call was on
        // the activation interface, fail the call and dont send back
        // a copy of the parameter packet.
        hr = RPC_E_CALL_REJECTED;
    }

    ComDebOut((DEB_CALLCONT,"CopyMsgForRetry pBuffer:%x hr:%x\n",
        pMsg->Buffer, hr));
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method:     CAptCallCtrl::GetCallTypeForInCall
//
//  Synopsis:   called when an incoming call arrives in order to determine
//              what CALLTYPE to pass to the applications message filter.
//
//  Arguments:  [ppCML] - Client Modal Loop of prev call on same lid (if any)
//              [lid]   - logical thread id of this call
//              [dwCallCat] - call category of incoming call
//
//  Returns:    the CALLTYPE to give to the message filter
//
//  History:    21-Dec-93 Johannp       Created
//              30-Apr-95 Rickhi        ReWrite
//
//  Notes:
//
//  1 = CALLTYPE_TOPLEVEL  // sync or inputsync call - no outgoing call
//  2 = CALLTYPE_NESTED    // callback on behalf of previous outgoing call
//  3 = CALLTYPE_ASYNC     // asynchronous call - no outstanding call
//  4 = CALLTYPE_TOPLEVEL_CALLPENDING // call with new LID - outstand call
//  5 = CALLTYPE_ASYNC_CALLPENDING    // async call - outstanding call
//
//--------------------------------------------------------------------------
DWORD CAptCallCtrl::GetCallTypeForInCall(CCliModalLoop **ppCML,
                                         REFLID lid, DWORD dwCallCatIn)
{
    DWORD CallType;
    CCliModalLoop *pCML = GetTopCML();

    if (dwCallCatIn == CALLCAT_ASYNC)       // asynchronous call has arrived
    {
        if (pCML == NULL)
            CallType = CALLTYPE_ASYNC;      // no outstanding calls
        else
            CallType = CALLTYPE_ASYNC_CALLPENDING;  // outstanding call
    }
    else                                    // non-async call has arrived
    {
        if (pCML == NULL)
            CallType = CALLTYPE_TOPLEVEL;  // no outstanding call
        else if ((*ppCML = pCML->FindPrevCallOnLID(lid)) != NULL)
            CallType = CALLTYPE_NESTED;    // outstanding call on same lid
        else
            CallType = CALLTYPE_TOPLEVEL_CALLPENDING; // different lid
    }

    ComDebOut((DEB_CALLCONT,"GetCallTypeForInCall return:%x\n", CallType));
    return CallType;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dcomrem\callmgr.cxx ===
//+-------------------------------------------------------------------
//
//  File:       callmgr.cxx
//
//  Contents:   class managing asynchronous calls
//
//  Classes:    CClientCallMgr
//              CServerCallMgr
//              CChannelObject
//
//  History:    22-Sep-97  MattSmit    Created
//              22-Jul-98  GopalK      Shutdown and Architectural changes
//
//--------------------------------------------------------------------
#include <ole2int.h>
#include "callmgr.hxx"
#include "locks.hxx"
#include "ctxchnl.hxx"
#include "sync.hxx"
#include "riftbl.hxx"

// Head Node for the MTA pending call list.
struct
{
    PVOID pv1;
    PVOID pv2;
} MTAPendingCallList = {NULL, NULL};


// critical section protecting channel call object state
COleStaticMutexSem  gChnlCallLock;

//+-------------------------------------------------------------------------------
//
//  Member:     CChannelObject::CChannelObject
//
//  Synopsis:   CChannelObject represents channel part of the Call object
//              It implements functionality to track the state of the call
//              and features needed for auto completion, currently pending
//              async calls, etc.
//
//  History:    23-Jun-98   GopalK    Architectural changes
//
//--------------------------------------------------------------------------------
CChannelObject::CChannelObject(CClientCallMgr *pCallMgr, CCtxComChnl *pChnl)
:
_cRefs(1),
#ifdef _WIN64
_dwState(STATE_READYFORNEGOTIATE),
#else
_dwState(STATE_READYFORGETBUFFER),
#endif
_pChnl(pChnl),
_pCall(NULL),
_pCallMgr(pCallMgr),
_hr(S_OK),
_pSync(NULL)
{
    AsyncDebOutTrace((DEB_CHANNEL,
                      "CChannelObject::CChannelObject this:0x%x\n",
                      this));
    // Sanity check
    Win4Assert(_pChnl);
    Win4Assert(_pCallMgr);

    // Initialize
    _dwAptID = GetCurrentApartmentId();
    _pendingCall.pNext = NULL;
    _pendingCall.pPrev = NULL;
    _pendingCall.pChnlObj = this;

    _pChnl->AddRef();
}


//+-------------------------------------------------------------------------------
//
//  Member:     CChannelObject::~CChannelObject
//
//  Synopsis:   Destructor for the channel call object. It completes auto
//              complete calls as it is guaranteed to be called when the response
//              to such a call has arrived
//
//  History:    23-Jun-98   GopalK    Architectural changes
//
//--------------------------------------------------------------------------------
CChannelObject::~CChannelObject()
{
    AsyncDebOutTrace((DEB_CHANNEL,
                      "CChannelObject::~CChannelObject [in] this:0x%x\n", this));

    if (_dwState == STATE_READYFORRECEIVE)
    {
        HRESULT hr;
        COleTls Tls(hr);
        ULONG status;
        Win4Assert(SUCCEEDED(hr));
	if (SUCCEEDED(hr))
        {
            hr = Receive(&_msg, &status);
            if (SUCCEEDED(hr))
            {
                // Release any marshaled interface pointers in the marshal
                // buffer before freeing the buffer.
                if (status == RPC_S_CALL_CANCELLED)
                {
                    Win4Assert(_pChnl);
                    ReleaseMarshalBuffer(&_msg, 
                                         (IRpcStubBuffer *)_pChnl->GetIPIDEntry()->pStub,
                                         FALSE);
                }
                
                FreeBuffer(&_msg);            
            }
        }
    }

    _pChnl->Release();

    AsyncDebOutTrace((DEB_CHANNEL,
                      "CChannelObject::~CChannelObject [out] this:0x%x\n", this));
}


//+-------------------------------------------------------------------
//
//  Method:     CChannelObject::QueryInterface     public
//
//  Synopsis:   QI behavior of CChannelObject
//
//  History:    23-Jun-98   GopalK    Architectural changes
//
//+-------------------------------------------------------------------
STDMETHODIMP CChannelObject::QueryInterface( REFIID riid, LPVOID FAR* ppvObj)
{
    IUnknown * pUnk = 0;
    if ((riid == IID_IUnknown) ||
        (riid == IID_IAsyncRpcChannelBuffer) ||
        (riid == IID_IRpcChannelBuffer) ||
        (riid == IID_IRpcChannelBuffer2))
    {
        pUnk = (IAsyncRpcChannelBuffer *) this;
    }
#ifdef _WIN64
    else if (riid == IID_IRpcSyntaxNegotiate)
    {
        pUnk = (IRpcSyntaxNegotiate *)this;
    }
#endif    
    else if (riid == IID_ICancelMethodCalls)
    {
        pUnk = (ICancelMethodCalls *)this;
    }
    else if (riid == IID_IClientSecurity)
    {
        pUnk = (IClientSecurity *) this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    pUnk->AddRef();
    *ppvObj = pUnk;
    return S_OK;
}


//+-------------------------------------------------------------------
//
//  Method:     CChannelObject::QueryInterface     public
//
//  Synopsis:   AddRefs CChannelObject
//
//  History:    23-Jun-98   GopalK    Architectural changes
//
//+-------------------------------------------------------------------
STDMETHODIMP_(ULONG) CChannelObject::AddRef( void )
{
    return(ULONG) InterlockedIncrement((PLONG) &_cRefs);
}


//+-------------------------------------------------------------------
//
//  Method:     CChannelObject::QueryInterface     public
//
//  Synopsis:   Releases CChannelObject. For auto complete calls
//              it defers destruction till the call to completes
//
//  History:    23-Jun-98   GopalK    Architectural changes
//
//+-------------------------------------------------------------------
STDMETHODIMP_(ULONG) CChannelObject::Release( void )
{
    ULONG cRefs = (ULONG) InterlockedDecrement((PLONG) &_cRefs);
    if (cRefs == 0)
    {
        delete this;
    }

    return cRefs;
}

void CChannelObject::MakeAutoComplete(void)
{
     ASSERT_LOCK_HELD(gChnlCallLock);
     _pSync = NULL;
     _pCallMgr = NULL;
}


//+-------------------------------------------------------------------------------
//
//  Member:     CChannelObject::Signal
//
//  Synopsis:   Marks the call as complete
//
//  History:    23-Jun-98   GopalK    Created
//
//--------------------------------------------------------------------------------
void CChannelObject::Signal()
{
    // Update state to indicate arrival of response
    DWORD dwState = InterlockedExchange((LONG *) &_dwState, STATE_READYFORRECEIVE);
    Win4Assert((dwState == STATE_SENDING) ||
               (dwState == STATE_RECEIVING) ||
               (dwState == STATE_ERROR) ||
               (dwState == STATE_READYFORSIGNAL));

    // Check for auto complete calls
    LOCK(gChnlCallLock);
    Win4Assert((_pSync==NULL) == (_pCallMgr==NULL));
    ISynchronize *pSync = _pSync;
    if (pSync)
        pSync->AddRef();
    UNLOCK(gChnlCallLock);

    // Check for the need to signal client
    if (pSync)
    {
        pSync->Signal();
        pSync->Release();
    }

    // Release the reference taken in Send()

    Release();

    return;
}
#ifdef _WIN64
//-------------------------------------------------------------------------
//
//  Member:     CRpcChannelBuffer::NegotiateSyntax
//
//  Synopsis:   Called by the proxy to negotiate NDR Transfer
//              Syntax
//              
//  History:    10-Jan-2000   Sajia  Created
//              
//-------------------------------------------------------------------------
STDMETHODIMP CChannelObject::NegotiateSyntax( RPCOLEMESSAGE *pMessage)
{
   AsyncDebOutTrace((DEB_CHANNEL,
		     "CChannelObject::NegotiateSyntax [IN] pMessage:0x%x\n",
		     pMessage));
   HRESULT hr = E_UNEXPECTED;
   
   // Prevent concurrent async calls on the same call object
   
   // Note: The assumption here is that in a client process, there
   // will be only one type of proxy for a given interface. ie; 
   // the proxy will either be legacy or new. Thus, it is impossible
   // for two different types of proxies to hold onto the same
   // channel object. If this were possible, we will need to 
   // protect against concurrency better. As such, we just need to
   // protect against concurrent calls on the same proxy.
   
   
   DWORD dwState = _dwState;
   if (dwState <= STATE_READYFORNEGOTIATE)
   {
       dwState = InterlockedCompareExchange((LONG *) &_dwState,
					    STATE_AMBIGUOUS,
					    dwState);
       if (dwState <= STATE_READYFORNEGOTIATE)
	   hr = S_OK;
   }

   if (SUCCEEDED(hr))
   {
      // Delegate to base channel
      hr = _pChnl->NegotiateSyntax(pMessage);
   
      if (SUCCEEDED(hr))
      {
	  dwState = InterlockedExchange((LONG *) &_dwState, STATE_READYFORGETBUFFER);
      }
      else
      {
	  dwState = InterlockedExchange((LONG *) &_dwState, STATE_ERROR);
      }
      // Sanity check
      Win4Assert(dwState == STATE_AMBIGUOUS);
   }
   AsyncDebOutTrace((DEB_CHANNEL,
		     "CChannelObject::NegotiateSyntax [OUT] hr:0x%x\n",
		     hr));
   return hr;
}
#endif
//+-------------------------------------------------------------------------------
//
//  Member:     CChannelObject::GetBuffer
//
//  Synopsis:   Implements IAsyncRpcChannelBuffer::GetBuffer
//
//  History:    13-Jun-98   GopalK    Architectural changes
//
//--------------------------------------------------------------------------------
STDMETHODIMP CChannelObject::GetBuffer(RPCOLEMESSAGE *pMessage, REFIID riid)
{
    AsyncDebOutTrace((DEB_CHANNEL,
                      "CChannelObject::GetBuffer [IN] pMessage:0x%x,  riid:%I\n",
                      pMessage, &riid));

    HRESULT hr = E_UNEXPECTED;

    // Prevent concurrent async calls on the same call object
    DWORD dwState = _dwState;
    if (dwState <= STATE_READYFORGETBUFFER)
    {
        dwState = InterlockedCompareExchange((LONG *) &_dwState,
                                             STATE_AMBIGUOUS,
                                             dwState);
        if (dwState <= STATE_READYFORGETBUFFER)
            hr = S_OK;
    }

    // Delegate to base channel
    if (SUCCEEDED(hr))
    {
        // Sanity check
        Win4Assert(_pCall == NULL);

        hr = _pChnl->GetBuffer(pMessage, riid);
        if (SUCCEEDED(hr))
        {
            _pCall = (CAsyncCall *) pMessage->reserved1;
            _pCall->AddRef();
            dwState = InterlockedExchange((LONG *) &_dwState, STATE_READYFORSEND);
        }
        else
        {
            dwState = InterlockedExchange((LONG *) &_dwState, STATE_ERROR);
        }

        // Sanity check
        Win4Assert(dwState == STATE_AMBIGUOUS);
    }

    AsyncDebOutTrace((DEB_CHANNEL,
                      "CChannelObject::GetBuffer [OUT] hr:0x%x\n",
                      hr));
    return hr;
}


//+-------------------------------------------------------------------------------
//
//  Member:     CChannelObject::Send
//
//  Synopsis:   Implements IAsyncRpcChannelBuffer::Send. It adds the call to the
//              pending call list of the current apartment
//
//  History:    13-Jun-98   GopalK    Architectural changes
//
//--------------------------------------------------------------------------------
STDMETHODIMP CChannelObject::Send(RPCOLEMESSAGE *pMsg, ISynchronize *pSync,
                                  ULONG *pulStatus)
{
    HRESULT hr;

#if DBG==1
    // Ensure that proxy passed the correct call object
    CClientCallMgr *pCallMgr = NULL;
    hr = pSync->QueryInterface(IID_IStdCallObject, (void **) &pCallMgr);
    Win4Assert(SUCCEEDED(hr));
    Win4Assert(pCallMgr == _pCallMgr);
    pCallMgr->Release();
#endif

    // Ensure that GetBuffer was called before
    DWORD dwState = InterlockedCompareExchange((LONG *) &_dwState,
                                               STATE_SENDING,
                                               STATE_READYFORSEND);
    if (dwState == STATE_READYFORSEND)
        hr = S_OK;
    else
        hr = E_UNEXPECTED;

    // Delegate to base channel
    if (SUCCEEDED(hr))
    {
        // Add the call to the pending call list so that all pending calls
        // can be canceled during uninit
        LOCK(gChnlCallLock);
        CallPending();
        UNLOCK(gChnlCallLock);

        // Hold reference to ChannelObject across the call, this
        // is released in the Signal method. This must be done before
        // Send is called below.
        AddRef();

        // Send request
        hr = pSync->Reset();
        if (SUCCEEDED(hr))
        {
            _pSync = pSync;
            hr = _pChnl->Send(pMsg, (ISynchronize *)this, pulStatus);
        }
        
        // Update state
        if (SUCCEEDED(hr))
        {
            _msg = *pMsg;
            dwState = InterlockedCompareExchange((LONG *) &_dwState,
                                                 STATE_READYFORSIGNAL,
                                                 STATE_SENDING);
            Win4Assert((dwState == STATE_SENDING) ||
                       (dwState == STATE_READYFORRECEIVE));
        }
        else
        {
            LOCK(gChnlCallLock);
            CallFinished();
            IUnknown *pCall = _pCall;
            _pCall = NULL;
            UNLOCK(gChnlCallLock);

            pCall->Release();
            _hr = hr;
            dwState = InterlockedExchange((LONG *) &_dwState, STATE_ERROR);
            Win4Assert(dwState == STATE_SENDING);
            // Signal the call is complete
            Signal();
        }
    }

    return hr;
}


//+-------------------------------------------------------------------------------
//
//  Member:     CChannelObject::Receive
//
//  Synopsis:   Implements IAsyncRpcChannelBuffer::Receive. It deletes the call from
//              the pending call list of the current apartment for error returns
//
//  History:    13-Jun-98   GopalK    Architectural changes
//
//--------------------------------------------------------------------------------
STDMETHODIMP CChannelObject::Receive(RPCOLEMESSAGE *pMsg, ULONG *pulStatus)
{
    HRESULT hr = E_UNEXPECTED;

    // Ensure that Send succeeded before
    DWORD dwState = _dwState;
    if ((dwState == STATE_READYFORRECEIVE) ||
        (dwState == STATE_READYFORSIGNAL))
    {
        dwState = InterlockedCompareExchange((LONG *) &_dwState,
                                             STATE_RECEIVING,
                                             dwState);
        if ((dwState == STATE_READYFORRECEIVE) ||
            (dwState == STATE_READYFORSIGNAL))
            hr = S_OK;
    }
    else
    {
        if (dwState == STATE_ERROR)
        {
            dwState = InterlockedCompareExchange((LONG *) &_dwState,
#ifdef _WIN64
						 STATE_READYFORNEGOTIATE,
#else
                                                 STATE_READYFORGETBUFFER,
#endif						 
                                                 STATE_ERROR);
            if (dwState == STATE_ERROR)
            {
                hr = _hr;
                _hr = S_OK;
            }
        }
        Win4Assert(FAILED(hr));
    }

    // Delegate to base channel
    if (SUCCEEDED(hr))
    {
        // Ensure that the signal has been called before
        // calling receive
        if (dwState == STATE_READYFORSIGNAL)
            _pCallMgr->Wait(0, INFINITE);

        // Receive response
        hr = _pChnl->Receive(pMsg, pulStatus);
        if (SUCCEEDED(hr))
        {
            dwState = InterlockedExchange((LONG *) &_dwState, STATE_READYFORFREEBUFFER);
        }
        else
        {
            LOCK(gChnlCallLock);
            CallFinished();
            IUnknown *pCall = _pCall;
            _pCall = NULL;
            UNLOCK(gChnlCallLock);
            pCall->Release();
#ifdef _WIN64
	    dwState = InterlockedExchange((LONG *) &_dwState, STATE_READYFORNEGOTIATE);
#else            
	    dwState = InterlockedExchange((LONG *) &_dwState, STATE_READYFORGETBUFFER);
#endif	    
        }

        // Sanity check
        Win4Assert((dwState == STATE_RECEIVING) ||
                   (dwState == STATE_READYFORRECEIVE));
    }

    return hr;
}


//+-------------------------------------------------------------------------------
//
//  Member:     CChannelObject::FreeBuffer
//
//  Synopsis:   Implements IAsyncRpcChannelBuffer::FreeBuffer. It deletes the call
//              from the pending call list of the current apartment
//
//  History:    13-Jun-98   GopalK    Architectural changes
//
//--------------------------------------------------------------------------------
STDMETHODIMP CChannelObject::FreeBuffer(RPCOLEMESSAGE *pMessage)
{
    HRESULT hr = E_UNEXPECTED;
    IUnknown *pCall;

    // Ensure that it is legal to call freebuffer
    DWORD dwState = _dwState;
    if ((dwState == STATE_READYFORFREEBUFFER) ||
        (dwState == STATE_READYFORSEND))
    {
        dwState = InterlockedCompareExchange((LONG *) &_dwState,
                                             STATE_AMBIGUOUS,
                                             dwState);
        if ((dwState == STATE_READYFORFREEBUFFER) ||
            (dwState == STATE_READYFORSEND))
            hr = S_OK;
    }

    // Deleate to base channel
    if (SUCCEEDED(hr))
    {
        LOCK(gChnlCallLock);
        if (dwState == STATE_READYFORFREEBUFFER)
            CallFinished();
        IUnknown *pCall = _pCall;
        _pCall = NULL;
        UNLOCK(gChnlCallLock);
        hr = _pChnl->FreeBuffer(pMessage);
        pCall->Release();
#ifdef _WIN64
        dwState = InterlockedExchange((LONG *) &_dwState, STATE_READYFORNEGOTIATE);
#else        
	dwState = InterlockedExchange((LONG *) &_dwState, STATE_READYFORGETBUFFER);
#endif	
        Win4Assert(dwState == STATE_AMBIGUOUS);
    }

    return hr;
}


//+-------------------------------------------------------------------------------
//
//  Member:     CChannelObject::SendReceive
//
//  Synopsis:   not implemented
//
//  History:    13-Jun-98   GopalK    Architectural changes
//
//--------------------------------------------------------------------------------
STDMETHODIMP CChannelObject::SendReceive(RPCOLEMESSAGE *pMessage, ULONG *pulStatus)
{
    return E_NOTIMPL;
}


//+-------------------------------------------------------------------------------
//
//  Member:     CChannelObject::GetDestCtx
//
//  Synopsis:   delegate to channel
//
//--------------------------------------------------------------------------------
STDMETHODIMP CChannelObject::GetDestCtx (DWORD FAR* lpdwDestCtx,
                                         LPVOID FAR* lplpvDestCtx )
{
    return _pChnl->GetDestCtx(lpdwDestCtx, lplpvDestCtx);
}


//+-------------------------------------------------------------------------------
//
//  Member:     CChannelObject::Isconnected
//
//  Synopsis:   delegate to channel
//
//  History:    13-Jun-98   GopalK    Architectural changes
//
//--------------------------------------------------------------------------------
STDMETHODIMP CChannelObject::IsConnected ( void )
{
    return _pChnl->IsConnected();
}

//+-------------------------------------------------------------------------------
//
//  Member:     CChannelObject::GetProtocolVersion
//
//  Synopsis:   delegate to channel
//
//  History:    13-Jun-98   GopalK    Architectural changes
//
//--------------------------------------------------------------------------------
STDMETHODIMP CChannelObject::GetProtocolVersion(DWORD *pdwVersion)
{
    return _pChnl->GetProtocolVersion(pdwVersion);
}

//+-------------------------------------------------------------------------------
//
//  Member:     CChannelObject::GetDestCtxEx
//
//  Synopsis:   delegate to channel
//
//  History:    13-Jun-98   GopalK    Architectural changes
//
//--------------------------------------------------------------------------------
STDMETHODIMP CChannelObject::GetDestCtxEx(RPCOLEMESSAGE *pMsg, DWORD *pdwDestContext,
                                          void **ppvDestContext )
{
    return _pChnl->GetDestCtxEx(pMsg, pdwDestContext, ppvDestContext);
}


//+----------------------------------------------------------------------------
//
//  Member:     CChannelObject::Cancel
//
//  Synopsis:   Cancels the current call.  Delegates to call object
//
//  History:    27-Jan-98  MattSmit  Created
//              13-Jun-98   GopalK    Architectural changes
//
//-----------------------------------------------------------------------------
STDMETHODIMP CChannelObject::Cancel(ULONG ulSeconds)
{
    ComDebOut((DEB_CHANNEL|DEB_CANCEL,
               "CChannelObject::Cancel IN ulSeconds:%d\n",
               ulSeconds));

    HRESULT hr;
    CMessageCall *pCall = NULL;

    // Check if a call is in progress
    LOCK(gChnlCallLock);
    if (_pCall)
    {
        pCall = _pCall;
        pCall->AddRef();
    }
    else
        hr = E_UNEXPECTED;
    UNLOCK (gChnlCallLock);

    // Delgate to base cancel code
    if (pCall)
    {
        hr = pCall->Cancel(ulSeconds);
        pCall->Release();
    }

    ComDebOut((DEB_CHANNEL|DEB_CANCEL, "CChannelObject::Cancel OUT hr:0x%x\n", hr));
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:     CChannelObject::TestCancel
//
//  Synopsis:   Test to see if the current call is cancelled. Delegates to
//              call object
//
//  History:    27-Jan-98  MattSmit  Created
//              13-Jun-98   GopalK    Architectural changes
//
//-----------------------------------------------------------------------------
STDMETHODIMP CChannelObject::TestCancel()
{
    ComDebOut((DEB_CHANNEL|DEB_CANCEL,
               "CClientCallMbr::TestCancel IN \n"));

    HRESULT hr = S_OK;
    CMessageCall *pCall = NULL;

    // Check if a call is in progress
    LOCK(gChnlCallLock);
    if (_pCall)
    {
        pCall = _pCall;
        pCall->AddRef();
    }
    else
        hr = RPC_E_CALL_COMPLETE;
    UNLOCK (gChnlCallLock);

    // Delgate to base cancel code
    if (pCall)
    {
        hr = pCall->TestCancel();
        pCall->Release();
    }

    ComDebOut((DEB_CHANNEL|DEB_CANCEL,
               "CClientCallMbr::TestCancel OUT hr:0x%x\n", hr));
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:     QueryBlanket
//
//  Synopsis:   dispatched to the call object's query
//
//  History:    6-Mar-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CChannelObject::QueryBlanket(
                                         IUnknown                *pProxy,
                                         DWORD                   *pAuthnSvc,
                                         DWORD                   *pAuthzSvc,
                                         OLECHAR                **pServerPrincName,
                                         DWORD                   *pAuthnLevel,
                                         DWORD                   *pImpLevel,
                                         void                   **pAuthInfo,
                                         DWORD                   *pCapabilities
                                         )
{
    HRESULT hr;
    ComDebOut((DEB_CHANNEL, "CChannelObject::QueryBlanket IN"
               " pProxy:0x%x, pAuthnSvc:0x%x, pAuthzSvc:0x%x, "
               "pServerPrincName:0x%x, pAuthnLevel:0x%x, pImpLevel:0x%x, "
               "pAuthInfo:0x%x, pCapabilities:0x%x\n", pProxy, pAuthnSvc,
               pAuthzSvc, pServerPrincName, pAuthnLevel, pImpLevel,
               pAuthInfo, pCapabilities));

    hr = _pCallMgr->VerifyInterface(pProxy);
    if (FAILED(hr))
    {
        return hr;
    }
    LOCK(gComLock);

    hr = QueryBlanketFromChannel(_pChnl, pAuthnSvc, pAuthzSvc, pServerPrincName,
                                 pAuthnLevel, pImpLevel, pAuthInfo, pCapabilities);
    UNLOCK(gComLock);

    ComDebOut((DEB_CHANNEL, "CChannelObject::QueryBlanket OUT hr:0x%x\n", hr));
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:     CChannelObject::SetBlanket
//
//  Synopsis:   a copy is performed, and the call dispatched to the call
//              object's setblanket
//
//  History:    23-Apr-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CChannelObject::SetBlanket(
                                       IUnknown                 *pProxy,
                                       DWORD                     AuthnSvc,
                                       DWORD                     AuthzSvc,
                                       OLECHAR                  *pServerPrincName,
                                       DWORD                     AuthnLevel,
                                       DWORD                     ImpLevel,
                                       void                     *pAuthInfo,
                                       DWORD                     Capabilities
                                       )
{
    CCtxComChnl *pNewChnl;
    HRESULT hr;

    ComDebOut((DEB_CHANNEL, "CChannelObject::SetBlanket IN "
               "pProxy:0x%x, AuthnSvc:0x%x, AuthzSvc:0x%x, pServerPrincName:0x%x,"
               " AuthnLevel:0x%x, ImpLevel:0x%x, pAuthInfo:0x%x, Capabilities:0x%x\n",
               pProxy, AuthnSvc, AuthzSvc, pServerPrincName, AuthnLevel, ImpLevel,
               pAuthInfo, Capabilities));

    hr = _pCallMgr->VerifyInterface(pProxy);
    if (FAILED(hr))
    {
        return hr;
    }

    //
    // copy the channel so the state change is localized to
    // this object only.
    //

    hr = E_OUTOFMEMORY;
    pNewChnl = _pChnl->Copy(_pChnl->GetOXIDEntry(), GUID_NULL, GUID_NULL);


    
    if (pNewChnl)
    {
        Win4Assert(_pChnl->GetIPIDEntry());
        pNewChnl->SetIPIDEntry(_pChnl->GetIPIDEntry());
        
        LOCK(gComLock);
        hr = SetBlanketOnChannel(pNewChnl, AuthnSvc, AuthzSvc, pServerPrincName,
                                 AuthnLevel, ImpLevel, pAuthInfo, Capabilities);
        if (SUCCEEDED(hr))
        {
            _pChnl->Release();
            _pChnl = pNewChnl;
            _pChnl->AddRef();
        }
        UNLOCK(gComLock);
        
        pNewChnl->Release();
    }



    ComDebOut((DEB_CHANNEL, "CChannelObject::SetBlanket OUT hr:0x%x\n", hr));
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:     CChannelObject::CopyProxy
//
//  Synopsis:   not implemented
//
//  History:    23-Apr-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CChannelObject::CopyProxy(IUnknown  *pProxy, IUnknown **ppCopy)
{
    return E_NOTIMPL;
}

//+--------------------------------------------------------------------------------
//
//  Function:      CChannelObject::CallPending
//
//  Synopsis:      Add the call to the list of pending calls
//
//  History:       15-Jul-98    GopalK    Created
//
//---------------------------------------------------------------------------------
void CChannelObject::CallPending()
{
    ASSERT_LOCK_HELD(gChnlCallLock);

    // Obtain pending call list for the current apartment
    SPendingCall *pHeadNode = GetPendingCallList();

    // Add the new item to it
    _pendingCall.pPrev = pHeadNode;
    _pendingCall.pNext = pHeadNode->pNext;
    pHeadNode->pNext->pPrev = &_pendingCall;
    pHeadNode->pNext = &_pendingCall;

    return;
}


//+--------------------------------------------------------------------------------
//
//  Function:      CChannelObject::CallFinished
//
//  Synopsis:      Removes the call to the list of pending calls
//
//  History:       15-Jul-98    GopalK    Created
//
//---------------------------------------------------------------------------------
void CChannelObject::CallFinished()
{
    ASSERT_LOCK_HELD(gChnlCallLock);

    // Update pending call list
    _pendingCall.pNext->pPrev = _pendingCall.pPrev;
    _pendingCall.pPrev->pNext = _pendingCall.pNext;
    _pendingCall.pNext = NULL;
    _pendingCall.pPrev = NULL;

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   CancelPendingCalls, Internal
//
//  Synopsis:   Cancel outstanding async calls
//
//--------------------------------------------------------------------------
void CancelPendingCalls(HWND hwnd)
{
    LOCK(gChnlCallLock);
    SPendingCall *pHead = GetPendingCallList();
    while (pHead->pNext != pHead)
    {
        // Obtain the last pending async call
        SPendingCall *pPendingCall = pHead->pNext;
        ComDebOut((DEB_ERROR, "Async call(0x%x) still pending\n",
                   pPendingCall->pChnlObj));

        // Stablize pending async call
        pPendingCall->pChnlObj->AddRef();

        UNLOCK(gChnlCallLock);

        // Cancel the call
        HRESULT hr = pPendingCall->pChnlObj->Cancel(0);
        ComDebOut((DEB_ERROR, "Canceling it returned 0x%x\n", hr));
        pPendingCall->pChnlObj->Release();

        // Wait for it to return
        while (pHead->pNext == pPendingCall)
        {
            // REVIEW: Change to a wait on event.
            //         Should we care for broken apps.
            //         GopalK
	    // The broken app comment above alludes
	    // to apps that autocomplete, but leak the 
	    // call object. It is better to hang here, 
	    // rather than exit normally-so that such apps 
	    // can be debugged and fixed.
	    // Sajia
	    
            ComDebOut((DEB_ERROR, "Sleeping for a second for pCall:%x\n",
                       pPendingCall));
            Sleep(100);

            // STA needs to pump message for the call to complete
            if (hwnd)
            {
                PeekTillDone(hwnd);
            }
        }

        // Reacquire lock
        LOCK(gChnlCallLock);
    }

    UNLOCK(gChnlCallLock);
}

//+-------------------------------------------------------------------
//
//  Member:     CClientCallMgr::CPrivUnknown::AddRef    public
//
//  Synopsis:   Implements inner unknown for CClientCallMgr that supports
//              aggregation
//
//  History:    15-Jul-98       GopalK      Created
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClientCallMgr::CPrivUnknown::AddRef()
{
    CClientCallMgr *pCallMgr = GETPPARENT(this, CClientCallMgr, _privUnk);
    ULONG cRefs = InterlockedIncrement((long *) &(pCallMgr->_cRefs));
    return cRefs;
}


//+-------------------------------------------------------------------
//
//  Member:     CClientCallMgr::CPrivUnknown::Release    public
//
//  Synopsis:   Implements inner unknown for CClientCallMgr that supports
//              aggregation
//
//  History:    15-Jul-98       GopalK      Created
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClientCallMgr::CPrivUnknown::Release()
{
    CClientCallMgr *pCallMgr = GETPPARENT(this, CClientCallMgr, _privUnk);

    // decrement the refcnt. if the refcnt went to zero it will be marked
    // as being in the dtor, and fTryToDelete will be true.
    ULONG cNewRefs;
    BOOL fTryToDelete = InterlockedDecRefCnt(&pCallMgr->_cRefs, &cNewRefs);

    while (fTryToDelete)
    {
        // refcnt went to zero, try to delete this entry
        BOOL fActuallyDeleted = FALSE;

        ASSERT_LOCK_NOT_HELD(gChnlCallLock);
        LOCK(gChnlCallLock);

        if (pCallMgr->_cRefs == CINDESTRUCTOR)
        {
            // the refcnt did not change while we acquired the lock.
            // OK to delete.
            pCallMgr->_pChnlObj->MakeAutoComplete();
            fActuallyDeleted = TRUE;
        }

        UNLOCK(gChnlCallLock);
        ASSERT_LOCK_NOT_HELD(gChnlCallLock);

        if (fActuallyDeleted == TRUE)
        {
            delete pCallMgr;
            break;  // all done. the entry has been deleted.
        }

        // the entry was not deleted because some other thread changed
        // the refcnt while we acquired the lock. Try to restore the refcnt
        // to turn off the CINDESTRUCTOR bit. Note that this may race with
        // another thread changing the refcnt, in which case we may decide to
        // try to loop around and delete the object once again.
        fTryToDelete = InterlockedRestoreRefCnt(&pCallMgr->_cRefs, &cNewRefs);
    }

    return(cNewRefs & ~CINDESTRUCTOR);
}


//+-------------------------------------------------------------------
//
//  Member:     CClientCallMgr::CPrivUnknown::QueryInterface    public
//
//  Synopsis:   Implements inner unknown for CClientCallMgr that supports
//              aggregation
//
//  History:    15-Jul-98       GopalK      Created
//--------------------------------------------------------------------
STDMETHODIMP CClientCallMgr::CPrivUnknown::QueryInterface(REFIID riid, void **ppv)
{
    CClientCallMgr *pCallMgr = GETPPARENT(this, CClientCallMgr, _privUnk);
    return pCallMgr->QueryInterfaceImpl(riid, ppv);
}


//+----------------------------------------------------------------------------
//
//  Member:        CClientCallMgr::CClientCallMgr
//
//  Synopsis:      Constructs client side call object
//
//  History:       22-Sep-97    MattSmit       Created
//                 15-Jul-98    GopalK         Aggregation support and
//                                             Shutdown changes
//
//-----------------------------------------------------------------------------
CClientCallMgr::CClientCallMgr(IUnknown *pUnkOuter, REFIID syncIID, REFIID asyncIID,
                               CStdIdentity *pStdId, CClientCallMgr *pNextMgr,
                               HRESULT &hr, IUnknown **ppInnerUnk)
:
_cRefs(1),
_dwFlags(0),
_pUnkOuter(pUnkOuter ? pUnkOuter : &_privUnk),
_asyncIID(asyncIID),
_cStdEvent(NULL),
_pChnlObj(NULL),
_pProxyObj(NULL),
_pICMC(NULL),
_pICS(NULL),
_pNextMgr(pNextMgr)
{
    AsyncDebOutTrace((DEB_TRACE,
                      "CClientCallMgr::CClientCallMgr IN -- this:0x%x",
                      this));
    ASSERT_LOCK_NOT_HELD(gChnlCallLock);

    // Initialize state
    _pStdId = pStdId;
    Win4Assert(_pStdId);
    _pStdId->AddRef();


    // Init the out parameters
    hr = S_OK;
    *ppInnerUnk = &_privUnk;

    Win4Assert((syncIID != IID_IUnknown) && (syncIID != IID_IMultiQI));

    // Create a synchronization object.
    HANDLE hEvent;
    CChannelObject *pChnlObj = NULL;
    IRpcProxyBuffer *pProxyObj = NULL;

    // Create a manual reset event
    hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (hEvent)
        hr = _cStdEvent.SetEventHandle(&hEvent);
    else
        hr = MAKE_WIN32(GetLastError());
    if (SUCCEEDED(hr))
    {
        
        // Find the IPID entry for this interface

        // Acquire lock
        LOCK(gIPIDLock);
        IPIDEntry *pIPID;

        if (syncIID == IID_IRemUnknown)
        {
            // Special case IRemUnknown, since it might be IRemUnknown
            // or IRundown.
            hr = _pStdId->FindIPIDEntryByIID(IID_IRundown, &pIPID);
            if (FAILED(hr))
            {
                hr = _pStdId->FindIPIDEntryByIID(IID_IRemUnknown, &pIPID);
            }
        }
        else
        {
            hr = _pStdId->FindIPIDEntryByIID(syncIID, &pIPID);
        }

        // Release the lock
        UNLOCK(gIPIDLock);
        
        // Create proxy call object
        if (SUCCEEDED(hr))
        {
            IUnknown *pProxy;

            // QIing on the interface implemented by the proxy
            // for ICallFactory. GopalK
            hr = GetAsyncCallObject(pIPID->pStub, GetControllingUnknown(), _asyncIID,
                                    IID_IRpcProxyBuffer, &pProxy,
                                    (void **) &pProxyObj);
            if (SUCCEEDED(hr))
            {
                // Fixup the refcount on the proxy call object
                pProxy->Release();

                // Assume OOF
                hr = E_OUTOFMEMORY;

                // Create channel call object
                Win4Assert(pIPID->pChnl);
                pChnlObj = new CChannelObject(this, pIPID->pChnl);
                if (pChnlObj)
                {
                    // Connect the channel call object to proxy call object
                    hr = pProxyObj->Connect(pChnlObj);
                    if (SUCCEEDED(hr))
                    {
                        // Update state
                        _pProxyObj = pProxyObj;
                        pProxyObj = NULL;

                        _pChnlObj = pChnlObj;
                        pChnlObj = NULL;
                    }
                }
            }

        }
    }
    // Cleanup
    if (pChnlObj)
        pChnlObj->Release();
    if (pProxyObj)
        pProxyObj->Release();


    AsyncDebOutTrace((DEB_TRACE,
                      "CClientCallMgr::CClientCallMgr OUT -- hr:0x%x\n",
                      hr));
}


//+----------------------------------------------------------------------------
//
//  Member:        CClientCallMgr::~CClientCallMgr
//
//  Synopsis:      Destroys client side call object. As a potential side effect
//                 of destruction, the current pending call will get marked
//                 for auto completion.
//
//  History:       22-Sep-97    MattSmit       Created
//                 15-Jul-98    GopalK         Aggregation support and
//                                             Shutdown changes
//
//-----------------------------------------------------------------------------
CClientCallMgr::~CClientCallMgr()
{
    AsyncDebOutTrace((DEB_TRACE,
                      "CClientCallMgr::~CClientCallMgr IN -- this:0x%x\n",
                      this));
    if (_pStdId)
        _pStdId->Release();
    // Sanity checks
    Win4Assert(_pICMC == NULL);
    Win4Assert(_pICS == NULL);


    // Release proxy call object
    if (_pProxyObj)
    {
        _pProxyObj->Disconnect();
        _pProxyObj->Release();
    }

    // Release channel call object at the end to prevent shutdown races
    if (_pChnlObj)
        _pChnlObj->Release();


    AsyncDebOutTrace((DEB_TRACE,
                      "CClientCallMgr::~CClientCallMgr OUT -- this:0x%x\n",
                      this));
}


//+--------------------------------------------------------------------------------
//
//  Interface:     IUnknown
//
//  Synopsis:      Basic reference counting implementation, QI handed off to
//                 QueryInterfaceImpl, so code can be reused by objects enapsulating
//                 this one w/o causing loops
//
//  History:       22-Sep-97    MattSmit       Created
//                 15-Jul-98    GopalK         Aggregation support and
//                                             Shutdown changes
//
//---------------------------------------------------------------------------------
STDMETHODIMP CClientCallMgr::QueryInterface(REFIID riid, LPVOID *ppv)
{
    return _pUnkOuter->QueryInterface(riid, ppv);
}

STDMETHODIMP_(ULONG) CClientCallMgr::AddRef()
{
    return _pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) CClientCallMgr::Release()
{
    return _pUnkOuter->Release();
}

HRESULT CClientCallMgr::QueryInterfaceImpl(REFIID riid, LPVOID *ppv)
{
    ComDebOut((DEB_CHANNEL,
               "CClientCallMgr::QueryInterfaceImpl riid:%I, ppv:0x%x\n",
               &riid, ppv));

    HRESULT hr = E_NOINTERFACE;

    *ppv = 0;
    if (riid == IID_IUnknown)
    {
        *ppv = (ISynchronize *) this;
    }
    else if (riid == IID_ISynchronize)
    {
        *ppv = (ISynchronize *) this;
    }
    else if (riid == IID_IClientSecurity)
    {
        *ppv = (IClientSecurity *) this;
    }
    else if (riid == IID_ICancelMethodCalls)
    {
        *ppv = (ICancelMethodCalls *) this;
    }
    else if (riid == IID_ISynchronizeHandle)
    {
        *ppv = (ISynchronizeHandle *) this;
    }
    else if (riid == IID_IStdCallObject)
    {
        *ppv = this;
    }
    else if (riid == _asyncIID)
    {
        // hand off to the proxy call manager
        return _pProxyObj->QueryInterface(riid, ppv);
    }

    if (*ppv)
    {
        ((IUnknown *) *ppv)->AddRef();
        hr = S_OK;
    }

    return hr;
}


//+--------------------------------------------------------------------------------
//
//  Interface:     IClientSecurity
//
//  Synopsis:      IClientSecurity methods are delegated to the channel call object
//
//  History:       22-Sep-97    MattSmit       Created
//
//---------------------------------------------------------------------------------
STDMETHODIMP CClientCallMgr::QueryBlanket(
                                         IUnknown                *pProxy,
                                         DWORD                   *pAuthnSvc,
                                         DWORD                   *pAuthzSvc,
                                         OLECHAR                **pServerPrincName,
                                         DWORD                   *pAuthnLevel,
                                         DWORD                   *pImpLevel,
                                         void                   **pAuthInfo,
                                         DWORD                   *pCapabilites
                                         )
{
    AsyncDebOutTrace((DEB_TRACE,
                      "CClientCallMgr::QueryBlanket IN pProxy:0x%x, pAuthnSvc:0x%x, "
                      "pAuthzSvc:0x%x, pServerPrincName:0x%x, "
                      "pAuthnLevel:0x%x, pImpLevel:0x%x, pAuthInfo:0x%x, "
                      "pCapabilites:0x%x\n",
                      pProxy, pAuthnSvc, pAuthzSvc, pServerPrincName,
                      pAuthnLevel, pImpLevel, pAuthInfo, pCapabilites));

    IClientSecurity *pICS = _pChnlObj ? _pChnlObj->GetSecurityInterface() : _pICS;
    Win4Assert(pICS);
    HRESULT hr =  pICS->QueryBlanket(pProxy, pAuthnSvc, pAuthzSvc,
                                     pServerPrincName, pAuthnLevel,
                                     pImpLevel, pAuthInfo, pCapabilites);

    AsyncDebOutTrace((DEB_TRACE,
                      "CClientCallMgr::QueryBlanket OUT hr:0x%x\n", hr));
    return hr;

}

STDMETHODIMP CClientCallMgr::SetBlanket(
                                       IUnknown                 *pProxy,
                                       DWORD                     AuthnSvc,
                                       DWORD                     AuthzSvc,
                                       OLECHAR                  *pServerPrincName,
                                       DWORD                     AuthnLevel,
                                       DWORD                     ImpLevel,
                                       void                     *pAuthInfo,
                                       DWORD                     Capabilities
                                       )
{
    AsyncDebOutTrace((DEB_TRACE,
                      "CClientCallMgr::SetBlanket IN pProxy:0x%x, AuthnSvc:0x%x,"
                      " AuthzSvc:0x%x, pServerPrincName:0x%x, AuthnLevel:0x%x, "
                      "ImpLevel:0x%x, pAuthInfo:0x%x, Capabilities:0x%x\n",
                      pProxy, AuthnSvc, AuthzSvc, pServerPrincName, AuthnLevel,
                      ImpLevel, pAuthInfo, Capabilities));

    IClientSecurity *pICS = _pChnlObj ? _pChnlObj->GetSecurityInterface() : _pICS;
    Win4Assert(pICS);
    HRESULT hr = pICS->SetBlanket(pProxy, AuthnSvc, AuthzSvc, pServerPrincName,
                                  AuthnLevel, ImpLevel, pAuthInfo, Capabilities);

    AsyncDebOutTrace((DEB_TRACE,
                      "CClientCallMgr::SetBlanket OUT hr:0x%x\n", hr));
    return hr;
}

STDMETHODIMP CClientCallMgr::CopyProxy(
                                      IUnknown  *pProxy,
                                      IUnknown **ppCopy
                                      )
{
    AsyncDebOutTrace((DEB_TRACE,
                      "CClientCallMgr::CopyProxy IN pProxy:0x%x, ppCopy:0x%x\n",
                      pProxy, ppCopy));

    IClientSecurity *pICS = _pChnlObj ? _pChnlObj->GetSecurityInterface() : _pICS;
    Win4Assert(pICS);
    HRESULT hr = pICS->CopyProxy(pProxy, ppCopy);

    AsyncDebOutTrace((DEB_TRACE,
                      "CClientCallMgr::CopyProxy OUT hr:0x%x\n",
                      hr));
    return hr;
}

HRESULT CClientCallMgr::VerifyInterface(IUnknown *pProxy)
{
    HRESULT hr;
    IUnknown *pUnk;

    if (!IsValidInterface(pProxy))
    {
        return E_INVALIDARG;
    }
    _privUnk.QueryInterface(_asyncIID, (LPVOID *) &pUnk);
    pUnk->Release();
    return(pProxy == pUnk) ? S_OK : E_INVALIDARG;

}

//+----------------------------------------------------------------------------
//
//  Interface:     ICancelMethodCalls
//
//  Synopsis:      ICancelMethodCalls methods are delegated to the channel
//                 call object
//
//  History:       27-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CClientCallMgr::Cancel(ULONG ulSeconds)
{
    AsyncDebOutTrace((DEB_TRACE,
                      "CClientCallMgr::Cancel IN ulSeconds:%d\n",
                      ulSeconds));

    ICancelMethodCalls *pICMC = _pChnlObj ? _pChnlObj->GetCancelInterface() : _pICMC;
    Win4Assert(pICMC);
    HRESULT hr = pICMC->Cancel(ulSeconds);

    AsyncDebOutTrace((DEB_TRACE,
                      "CClientCallMgr::Cancel OUT hr:0x%x\n",
                      hr));
    return hr;
}

STDMETHODIMP CClientCallMgr::TestCancel()
{
    AsyncDebOutTrace((DEB_TRACE,
                      "CClientCallMgr::TestCancel IN \n"));

    ICancelMethodCalls *pICMC = _pChnlObj ? _pChnlObj->GetCancelInterface() : _pICMC;
    Win4Assert(pICMC);
    HRESULT hr = pICMC->TestCancel();

    AsyncDebOutTrace((DEB_TRACE,
                      "CClientCallMgr::TestCancel OUT hr:0x%x\n",
                      hr));
    return hr;
}


//+-------------------------------------------------------------------
//
//  Interface:     ISynchronize
//
//  Synopsis:      ISynchronize methods are delegated to the StdEvent
//                 object
//
//  History:       21-Jul-98    GopalK    Created
//
//--------------------------------------------------------------------
STDMETHODIMP CClientCallMgr::Wait(DWORD dwFlags, DWORD dwTimeout)
{
    return _cStdEvent.Wait(dwFlags, dwTimeout);
}

STDMETHODIMP CClientCallMgr::Signal()
{
    return _cStdEvent.Signal();
}

STDMETHODIMP CClientCallMgr::Reset()
{
    return _cStdEvent.Reset();
}


//+-------------------------------------------------------------------
//
//  Interface:     ISynchronizeHandle
//
//  Synopsis:      ISynchronizeHanle method is delegated to the StdEvent
//                 object
//
//  History:       21-Jul-98    GopalK    Created
//
//--------------------------------------------------------------------
STDMETHODIMP CClientCallMgr::GetHandle(HANDLE *pHandle)
{
    return _cStdEvent.GetHandle(pHandle);
}





//+--------------------------------------------------------------------------------
//
//  Interface:      AsyncIUnknown
//
//  Synopsis:       Async version of IUnknown.  Uses internal AsyncIRemUnknown
//                  to talk to server asynchronously
//
//  History:        20-Jan-98 MattSmit       Created
//
//---------------------------------------------------------------------------------


CAsyncUnknownMgr::CAsyncUnknownMgr(IUnknown *pUnkOuter, REFIID syncIID, REFIID asyncIID,
                                         CStdIdentity *pStdId, CClientCallMgr *pNextMgr,
                                         HRESULT &hr, IUnknown **ppInnerUnk) :
_cRefs(1),
_dwFlags(0),
_pUnkOuter(pUnkOuter ? pUnkOuter : &_privUnk),
_pNextMgr(pNextMgr)
{
    AsyncDebOutTrace((DEB_TRACE,
                      "CClientCallMgr::CClientCallMgr IN -- this:0x%x",
                      this));
    ASSERT_LOCK_NOT_HELD(gComLock);

    // Initialize state
    _pStdId = pStdId;
    Win4Assert(_pStdId);
    _pStdId->AddRef();

    _pARUObj = NULL;
    _pQIC = NULL;
    _ppMQI = NULL;
    _pIIDs = NULL;
    _pMQISave = NULL;

    // Init the out parameters
    hr = S_OK;
    *ppInnerUnk = &_privUnk;

    if (syncIID == IID_IUnknown)
    {
        _dwFlags |= AUMGR_IUNKNOWN;
    }
    else if (syncIID == IID_IMultiQI)
    {
        _dwFlags |= AUMGR_IMULTIQI;
    }
    else
    {
        Win4Assert(!"Bad Synchronous IID for CAsyncUnknownMgr");
    }


    IUnknown *pARUObj;
    AsyncIRemUnknown2 *pARU;


    hr = _pStdId->GetAsyncRemUnknown(GetControllingUnknown(), &pARU, &pARUObj);
    if (SUCCEEDED(hr))
    {
        // fix up reference count
        GetControllingUnknown()->Release();
        
        // Update state
        _pARUObj = pARUObj;
        pARUObj = NULL;
        _pARU = pARU;
        pARU = NULL;

    }
}

CAsyncUnknownMgr::~CAsyncUnknownMgr()
{
    if (_pStdId)
        _pStdId->Release();
    if (_pARUObj)
        _pARUObj->Release();
    PrivMemFree(_pQIC);
    PrivMemFree(_ppMQI);
    PrivMemFree(_pIIDs);
    PrivMemFree(_pMQISave);
}


//+-------------------------------------------------------------------
//
//  Member:     CAsyncUnknownMgr::CPrivUnknown::AddRef    public
//
//  Synopsis:   Implements inner unknown for CAsyncUnknownMgr that supports
//              aggregation
//
//  History:    15-Jul-98       GopalK      Created
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CAsyncUnknownMgr::CPrivUnknown::AddRef()
{
    CAsyncUnknownMgr *pCallMgr = GETPPARENT(this, CAsyncUnknownMgr, _privUnk);
    CairoleDebugOut((DEB_ERROR, "CAsyncUnknownMgr::CPrivUnknown::AddRef() _cRefs: %d\n",
                    pCallMgr->_cRefs+1));
    ULONG cRefs = InterlockedIncrement((long *) &(pCallMgr->_cRefs));
    return cRefs;
}


//+-------------------------------------------------------------------
//
//  Member:     CAsyncUnknownMgr::CPrivUnknown::Release    public
//
//  Synopsis:   Implements inner unknown for CAsyncUnknownMgr that supports
//              aggregation
//
//  History:    15-Jul-98       GopalK      Created
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CAsyncUnknownMgr::CPrivUnknown::Release()
{
    CAsyncUnknownMgr *pCallMgr = GETPPARENT(this, CAsyncUnknownMgr, _privUnk);

    CairoleDebugOut((DEB_ERROR, "CAsyncUnknownMgr::CPrivUnknown::Release() _cRefs: %d\n",
                    pCallMgr->_cRefs-1));
    ULONG cRefs = (ULONG) InterlockedDecrement((PLONG) &pCallMgr->_cRefs);
    if (cRefs == 0)
    {
        delete pCallMgr;
    }

    return cRefs;
}


//+-------------------------------------------------------------------
//
//  Member:     CAsyncUnknownMgr::CPrivUnknown::QueryInterface    public
//
//  Synopsis:   Implements inner unknown for CAsyncUnknownMgr that supports
//              aggregation
//
//  History:    15-Jul-98       GopalK      Created
//--------------------------------------------------------------------
STDMETHODIMP CAsyncUnknownMgr::CPrivUnknown::QueryInterface(REFIID riid, void **ppv)
{
    CAsyncUnknownMgr *pCallMgr = GETPPARENT(this, CAsyncUnknownMgr, _privUnk);
    return pCallMgr->QueryInterfaceImpl(riid, ppv);
}

STDMETHODIMP CAsyncUnknownMgr::QueryInterface(REFIID riid, LPVOID *ppv)
{
    return _pUnkOuter->QueryInterface(riid, ppv);
}

STDMETHODIMP_(ULONG) CAsyncUnknownMgr::AddRef()
{
    return _pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) CAsyncUnknownMgr::Release()
{
    return _pUnkOuter->Release();
}


HRESULT CAsyncUnknownMgr::QueryInterfaceImpl(REFIID riid, LPVOID *ppv)
{
    ComDebOut((DEB_CHANNEL,
               "CAsyncUnknownMgr::QueryInterfaceImpl riid:%I, ppv:0x%x\n",
               &riid, ppv));

    HRESULT hr = E_NOINTERFACE;

    *ppv = 0;
    if (riid == IID_IUnknown)
    {
        *ppv = this;
    }
    else if ((riid == IID_ISynchronize) ||
             (riid == IID_IClientSecurity) ||
             (riid == IID_ICancelMethodCalls) ||
             (riid == IID_ISynchronizeHandle) ||
             (riid == IID_IStdCallObject))
    {
        return _pARUObj->QueryInterface(riid, ppv);
    }
    else if ((riid == IID_AsyncIUnknown) &&
             (_dwFlags & AUMGR_IUNKNOWN))
    {
        *ppv = (AsyncIUnknown  *) this;
    }
    else if ((riid == IID_AsyncIMultiQI) &&
             (_dwFlags & AUMGR_IMULTIQI))
    {
        *ppv = (AsyncIMultiQI  *) this;
    }


    if (*ppv)
    {
        ((IUnknown *) *ppv)->AddRef();
        hr = S_OK;
    }

    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:        Begin_QueryInterface
//
//  Synopsis:      Starts an asynchronous QueryInterface. Delegates
//                 to Begin_QueryMultipleInterfaces
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAsyncUnknownMgr::Begin_QueryInterface(REFIID riid)
{
    ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::Begin_QueryInterface IN riid:%I\n", &riid));
    HRESULT hr;

    hr = EnterBegin(GetControllingUnknown());
    if (FAILED(hr))
    {
        ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::Begin_Queryface EnterBegin FAILED hr:\n", hr));
        return hr;
    }

    _MQI.pIID = &riid;
    _MQI.pItf = NULL;

    hr =  IBegin_QueryMultipleInterfaces(1, &_MQI);

    ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::Begin_QueryInterface hr:0x%x\n", hr));
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:        CAsyncUnknownMgr::Finish_QueryInterface
//
//  Synopsis:      Completes an QueryInterface call. Delegates to
//                 Finish_QueryInterfaces
//
//  History:       23-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAsyncUnknownMgr::Finish_QueryInterface(LPVOID *ppv)
{
    ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::Finish_QueryInterface IN ppv:0x%x\n", ppv));

    HRESULT hr;
    hr = EnterFinish(GetControllingUnknown());
    if (FAILED(hr))
    {
        ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::Finish_QueryInterface EnterFinish FAILED hr:0x%x \n", hr));
        return hr;
    }


    hr = IFinish_QueryMultipleInterfaces(&_MQI);
    if (SUCCEEDED(hr))
    {
        hr = _MQI.hr;
        if (SUCCEEDED(hr))
        {
            *ppv = _MQI.pItf;
        }
    }

    LeaveFinish();

    ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::Finish_QueryInterface OUT hr:0x%x\n", hr));
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:        CAsyncUnknownMgr::Begin_QueryMultipleInterfaces
//
//  Synopsis:      Wrapper for IBegin_QueryMultipleInterfaces
//
//  History:       29-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAsyncUnknownMgr::Begin_QueryMultipleInterfaces(ULONG cMQIs, MULTI_QI *pMQIs)
{
    ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::Begin_QueryMultipleInterfaces IN cMQIs:%d, pMQIs:0x%x\n", cMQIs, pMQIs));
    HRESULT hr;
    hr = EnterBegin(GetControllingUnknown());
    if (FAILED(hr))
    {
        ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::Begin_QueryMultipleInterfaces EnterBegin FAILED hr:\n", hr));
        return hr;
    }

    hr = IBegin_QueryMultipleInterfaces(cMQIs, pMQIs);

    ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::Begin_QueryMultipleInterfaces OUT hr:0x%x\n", hr));
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:        CAsyncUnknownMgr::Finish_QueryMultipleInterfaces
//
//  Synopsis:      Wrapper for IFinish_QueryMultipleInterfaces
//
//  History:       29-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAsyncUnknownMgr::Finish_QueryMultipleInterfaces(MULTI_QI *pMQIs)
{
    ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::Finish_QueryMultipleInterfaces IN \n"));
    HRESULT hr;
    hr = EnterFinish(GetControllingUnknown());
    if (FAILED(hr))
    {
        ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::Finish_QueryMultipleInterfaces EnterFinish FAILED hr:0x%x \n", hr));
        return hr;
    }
    hr = IFinish_QueryMultipleInterfaces(pMQIs);
    LeaveFinish();
    ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::Finish_QueryMultipleInterfaces OUT hr:0x%x\n", hr));
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:        CAsyncUnknownMgr::IBegin_QueryMultipleInterfaces
//
//  Synopsis:      Starts and async QueryMultipleInterfaces call. If all the
//                 requests can be filled locally then the call is signaled
//                 immediately.  Otherwise a remote call is made and the
//                 call is completed when it completes
//
//  History:       23-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAsyncUnknownMgr::IBegin_QueryMultipleInterfaces(ULONG cMQIs, MULTI_QI *pMQIs)
{
    ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::IBegin_QueryMultipleInterfaces IN cMQIs:0x%d, pMQIs:0x%x\n", cMQIs, pMQIs));

    HRESULT hr;
    IRemUnknown *pRU;

    // Make sure TLS is initialized.
    COleTls tls(hr);
    if (FAILED(hr))
    {
        ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::IBegin_QueryMultipleInterfaces FAILED tls not initiated\n"));
        return AbortBegin(GetControllingUnknown(), hr);
    }

    // ensure it is callable in the current apartment
    hr = _pStdId->IsCallableFromCurrentApartment();
    if (FAILED(hr))
    {
        ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::IBegin_QueryMultipleInterfaces FAILED not callable from current apartment\n"));
        return AbortBegin(GetControllingUnknown(), hr);

    }

    _pMQISave = (MULTI_QI *)  PrivMemAlloc(sizeof(MULTI_QI) * cMQIs);
    if (!_pMQISave)
    {
        ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::IBegin_QueryMultipleInterfaces FAILED cannot allocate memory\n"));
        return AbortBegin(GetControllingUnknown(), E_OUTOFMEMORY);
    }

    _pStdId->AssertValid();

    //
    // clone the in parameters
    //
    memcpy(_pMQISave, pMQIs, sizeof(MULTI_QI) * cMQIs);
    _cMQIs = cMQIs;

    // allocate some space on the stack for the intermediate results. declare
    // working pointers and remember the start address of the allocations.
    MULTI_QI  **ppMQIAlloc = (MULTI_QI **)_alloca(sizeof(MULTI_QI *) * cMQIs);
    IID       *pIIDAlloc   = (IID *)      _alloca(sizeof(IID) * cMQIs);

    USHORT cPending = _pStdId->m_InternalUnk.QueryMultipleInterfacesLocal(cMQIs, _pMQISave, ppMQIAlloc, pIIDAlloc, &_cAcquired);

    if (cPending > 0)
    {
        // some interfaces cannot be obtained locally so we will
        // query them remotely
        ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::IBegin_QueryMultipleInterfaces Some interfaces not local, calling out\n"));

        hr = E_OUTOFMEMORY;

        _pQIC = (QICONTEXT *) PrivMemAlloc(QICONTEXT::SIZE(_pStdId, cPending));
        _ppMQI = (MULTI_QI **) PrivMemAlloc(sizeof(MULTI_QI*) * cPending);
        _pIIDs = (IID *) PrivMemAlloc(sizeof(IID) * cPending);
        if (_pQIC && _ppMQI && _pIIDs)
        {
            // begin can succeed
            hr = S_OK;

            // set up the context for the remote call
            _pQIC->Init(cPending);
            _pQIC->dwFlags |= QIC_ASYNC;
            _pQIC->pARU = _pARU;

            // copy the data for later
            memcpy(_ppMQI, ppMQIAlloc, (sizeof(MULTI_QI*) * cPending));
            memcpy(_pIIDs, pIIDAlloc, (sizeof(IID) * cPending));
            _pStdId->Begin_QueryRemoteInterfaces(cPending, _pIIDs, _pQIC);


            if (!(_pQIC->dwFlags & QIC_BEGINCALLED))
            {
                hr = SignalObject(GetControllingUnknown());
            }
        }
        else
        {
            hr = AbortBegin(GetControllingUnknown(), hr);
        }
    }
    else
    {
        // signal the client since RPC won't
        _dwFlags |= AUMGR_ALLLOCAL;
        hr = SignalObject(GetControllingUnknown());

    }

    ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::IBegin_QueryMultipleInterfaces OUT hr:0x%x\n", hr));
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:        CAsyncUnknownMgr::IFinish_QueryMultipleInterfaces
//
//  Synopsis:      Completes the QueryMultipleInterfaces call by copying data
//                 recieved remotely to the data structure supplied by the
//                 application
//
//  History:       23-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAsyncUnknownMgr::IFinish_QueryMultipleInterfaces(MULTI_QI *pMQI)
{

    ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::IFinish_QueryMultipleInterfaces IN \n"));

    if (!(_dwFlags & AUMGR_ALLLOCAL))
    {
        // there were interfaces which we queried for remotely

        SQIResult *pQIResult = (SQIResult*) _alloca(sizeof(SQIResult) * _pQIC->cIIDs);

        // no need to check errors because _pQIC is always filled in
        _pStdId->Finish_QueryRemoteInterfaces(pQIResult, _pQIC);

        CopyToMQI(_pQIC->cIIDs, pQIResult, _ppMQI, &_cAcquired);
    }

    // copy to the out array
    // CODEWORK: this can be optimized. currently this information is copied
    // twice.
    ULONG i;
    for (i=0, _cAcquired=0; i<_cMQIs; i++)
    {
        if (SUCCEEDED(_pMQISave[i].hr))
        {
            pMQI[i].hr = _pMQISave[i].pItf->QueryInterface(*pMQI[i].pIID, (void **) &pMQI[i].pItf);
            _pMQISave[i].pItf->Release();
            if (SUCCEEDED(pMQI[i].hr))
            {
                _cAcquired++;
            }
        }
    }

    // if we got all the interfaces, return S_OK. If we got none of the
    // interfaces, return E_NOINTERFACE. If we got some, but not all, of
    // the interfaces, return S_FALSE;
    HRESULT hr;
    if (_cAcquired == _cMQIs)
        hr = S_OK;
    else if (_cAcquired > 0)
        hr = S_FALSE;
    else
        hr = E_NOINTERFACE;

    ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::IFinish_QueryMultipleInterfaces OUT hr:0x%x\n", hr));
    return hr;

}


//+----------------------------------------------------------------------------
//
//  Member:        CAsyncUnknownMgr::Begin_AddRef
//
//  Synopsis:      Addrefs the proxy manager and signals the client.
//
//  History:       23-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAsyncUnknownMgr::Begin_AddRef()
{
    ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::Begin_AddRef IN \n" ));
    HRESULT hr;
    hr = EnterBegin(GetControllingUnknown());
    if (FAILED(hr))
    {
        ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::Begin_AddRef EnterBegin FAILED hr:\n", hr));
        return hr;
    }

    _ulRefs = AddRef();

    SignalObject(GetControllingUnknown());

    ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::Begin_AddRef OUT \n"));
    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Member:        CAsyncUnknownMgr::Finish_AddRef
//
//  Synopsis:      Completes the call, filling in the references returned by
//                 the addref in the begin call.
//
//  History:       23-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CAsyncUnknownMgr::Finish_AddRef()
{
    ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::Finish_AddRef IN ulrefs:%d\n", _ulRefs ));
    HRESULT hr;
    hr = EnterFinish(GetControllingUnknown());
    if (FAILED(hr))
    {
        ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::Finish_AddRef EnterFinish FAILED hr:0x%x \n", hr));
        return hr;
    }
    ULONG ret = _ulRefs;
    LeaveFinish();
    ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::Finish_AddRef OUT ret:%d\n", ret ));
    return ret;

}


//+----------------------------------------------------------------------------
//
//  Member:        CAsyncUnknownMgr::Begin_Release
//
//  Synopsis:      Starts a release call. Flags that if a need to go remote
//                 arises, it should be done asyncronously.
//
//  History:       23-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAsyncUnknownMgr::Begin_Release()
{
    ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::Begin_Release IN \n"));
    HRESULT hr;
    hr = EnterBegin(GetControllingUnknown());
    if (FAILED(hr))
    {
        ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::Begin_Release EnterBegin FAILED hr:\n", hr));
        return hr;
    }

    _ulRefs = InterlockedDecrement((PLONG) &_cRefs);
    Win4Assert(_pStdId);
    if (_ulRefs == 0)
    {
        _cRefs = 1000;
        COleTls tls(hr);
        if (SUCCEEDED(hr))
        {
            // put the controlling unknown in TLS to pass through to
            // the destructor.

            // CODEWORK:: temporary solution. we will be using the
            // ref cache to handle async release in the future..
            tls->pAsyncRelease = _pARUObj;

            _ulRefs = _pStdId->Release();
            _pStdId = NULL;

            if (tls->pAsyncRelease)
            {
                SignalObject(tls->pAsyncRelease);
                tls->pAsyncRelease = NULL;
            }
        }
        else
        {
            hr = AbortBegin(GetControllingUnknown(), hr);
        }
    }
    else
    {
        SignalObject(GetControllingUnknown());
    }

    ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::Begin_Release OUT 0x%x\n", hr));
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:        CAsyncUnknownMgr::Finish_Release
//
//  Synopsis:      Complete the call, fill in the return code.
//
//  History:       23-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CAsyncUnknownMgr::Finish_Release()
{
    ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::Finish_Release IN \n"));
    HRESULT hr;
    hr = EnterFinish(GetControllingUnknown());
    if (FAILED(hr))
    {
        ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::Finish_Release EnterFinish FAILED hr:0x%x \n", hr));
        return hr;
    }
    ULONG ret = _ulRefs;
    if (_ulRefs == 0)
    {
        delete this;
    }
    else
    {
        LeaveFinish();
    }

    ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::Finish_Release OUT ret:%d\n", ret));

    return ret;
}


//+----------------------------------------------------------------------------
//
//  Member:        CAsyncUnknownMgr::ResetStateForCall
//
//  Synopsis:      Resets per call object state
//
//  History:       29-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
HRESULT CAsyncUnknownMgr::ResetStateForCall()
{
    ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::ResetStateForCall IN \n"));
    HRESULT hr = S_OK;

    // in this function we should reset all actions which are owned
    // by this object. Specifically, the ALLLOCAL flag and freeing
    // memory allocated.  Notice that none of the objects _inside_
    // pQIC are released.  This should have been handled by the lower
    // levels which created them.
    _dwFlags &= !(AUMGR_ALLLOCAL);
    PrivMemFree(_pQIC);
    PrivMemFree(_ppMQI);
    PrivMemFree(_pIIDs);
    PrivMemFree(_pMQISave);
    _pQIC = NULL;
    _ppMQI = NULL;
    _pIIDs = NULL;
    _pMQISave = NULL;

    ComDebOut((DEB_CHANNEL, "CAsyncUnknownMgr::ResetStateForCall OUT hr:0x%x\n", hr));
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:        CAsyncStateMachine::InitObject
//
//  Synopsis:      Initialize per call state
//
//  History:       29-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
HRESULT CAsyncStateMachine::InitObject(IUnknown *pCtl)
{
    ComDebOut((DEB_CHANNEL, "CAsyncStateMachine::InitObject IN \n"));
    HRESULT hr;

    _hr = S_OK;
    hr = ResetStateForCall();
    if (SUCCEEDED(hr))
    {
        hr = ResetObject(pCtl);
    }

    if (FAILED(hr))
    {
        AbortBegin(pCtl, hr);
    }
    ComDebOut((DEB_CHANNEL, "CAsyncStateMachine::InitObject OUT hr:0x%x\n", hr));
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:        CAsyncStateMachine::EnterBegin
//
//  Synopsis:      Verifies object is in a state that a begin call can be made.
//                 and initializes per call object state
//
//  History:       28-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
HRESULT CAsyncStateMachine::EnterBegin(IUnknown *pCtl)
{
    ComDebOut((DEB_CHANNEL, "CAsyncStateMachine::EnterBegin IN pCtl:0x%x\n", pCtl));

    HRESULT hr;

    // CODEWORK:: We could use Interlocked* operations instead of gChnlCallLock

    LOCK(gChnlCallLock);
    if ((_dwState != STATE_WAITINGFORBEGIN) &&
        (_dwState != STATE_BEGINABORTED))
    {
        hr =  RPC_S_CALLPENDING;
    }
    else
    {
        hr = S_OK;
        _dwState = STATE_INITIALIZINGOBJECT;

    }
    UNLOCK(gChnlCallLock);

    if (SUCCEEDED(hr))
    {
        // initialize and reset the object
        hr = InitObject(pCtl);
        if (SUCCEEDED(hr))
        {
            _dwState = STATE_WAITINGFORFINISH;
        }
    }


    ComDebOut((DEB_CHANNEL, "CAsyncStateMachine::EnterBegin OUT hr:0x%x\n", hr));
    return hr;

}


//+----------------------------------------------------------------------------
//
//  Member:        CAsyncStateMachine::AbortBegin
//
//  Synopsis:      Called from begin upon determining that the call cannot
//                 complete successfully.  Signals the client and stores the
//                 HRESULT to give back in EnterFinish()
//
//  History:       29-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
HRESULT CAsyncStateMachine::AbortBegin(IUnknown *pCtl, HRESULT hr)
{
    ComDebOut((DEB_CHANNEL, "CAsyncStateMachine::AbortBegin IN pCtl:0x%x, hr:0x%x\n", pCtl, hr));
    HRESULT hr2;
    Win4Assert(FAILED(hr));
    _hr = hr;
    _dwState = STATE_BEGINABORTED;
    hr2 = SignalObject(pCtl);
    if (FAILED(hr2))
    {
        hr = hr2;
    }

    ComDebOut((DEB_CHANNEL, "CAsyncStateMachine::AbortBegin OUT hr:0x%x\n", hr));
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:        CAsyncStateMachine::EnterFinish
//
//  Synopsis:      Verifies object is in a state that a Finish call can be made
//
//  History:       28-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
HRESULT CAsyncStateMachine::EnterFinish(IUnknown *pCtl)
{
    ComDebOut((DEB_CHANNEL, "CAsyncStateMachine::EnterFinish IN \n"));
    HRESULT hr;
    hr = WaitObject(pCtl, 0,  INFINITE);
    if (SUCCEEDED(hr))
    {
        LOCK(gChnlCallLock);
        if ((_dwState != STATE_WAITINGFORFINISH) &&
            (_dwState != STATE_BEGINABORTED))
        {
            hr =  E_UNEXPECTED;
        }
        else if (_dwState == STATE_BEGINABORTED)
        {
            Win4Assert(FAILED(_hr));
            hr = _hr;
            _dwState = STATE_WAITINGFORBEGIN;

        }
        else
        {
            hr = S_OK;
            _dwState = STATE_EXECUTINGFINISH;
        }
        UNLOCK(gChnlCallLock);
    }

    ComDebOut((DEB_CHANNEL, "CAsyncStateMachine::EnterFinish OUT hr:0x%x\n", hr));
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:        CAsyncStateMachine::LeaveFinish
//
//  Synopsis:      Called when finish completes.
//
//  History:       29-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
void CAsyncStateMachine::LeaveFinish()
{
    ComDebOut((DEB_CHANNEL, "CAsyncStateMachine::LeaveFinish IN \n"));
    Win4Assert(_dwState == STATE_EXECUTINGFINISH);
    _dwState = STATE_WAITINGFORBEGIN;
    ComDebOut((DEB_CHANNEL, "CAsyncStateMachine::LeaveFinish OUT\n"));
}


//+--------------------------------------------------------------------------------
//
//  Translation Functions
//
//---------------------------------------------------------------------------------

//+--------------------------------------------------------------------------------
//
//  Function:       GetSyncIIDFromAsyncIID
//
//  Params:         rasynciid -   [in] async IID
//                  psynciid  -   [out] where to place sync IID
//
//  Returns:        S_OK/failure
//
//  Synopsis:       Maps a synchrounous IID to its corresponding asynchronous IID
//                  using the registry.
//
//  History:        22-Sep-97 MattSmit       Created
//
//---------------------------------------------------------------------------------
HRESULT GetSyncIIDFromAsyncIID(REFIID rasynciid, IID *psynciid)
{
    //
    // check see if this is an internal IID.
    // if so just flip the bits.
    //
    DWORD *ptr = (DWORD *) &rasynciid;
    if (*(ptr+1) == 0x00000000 &&   //  all internal iid's have these
        *(ptr+2) == 0x000000C0 &&   //   common values
        *(ptr+3) == 0x46000000 &&
        (*(ptr) & 0xffff0000) == 0x000e0000)
    {
        *psynciid = rasynciid;

        *((DWORD *) psynciid) &= 0x0000ffff;
        return S_OK;
    }

    if (rasynciid == IID_AsyncIAdviseSink)
    {
        // save a registry call since we know this one
        *psynciid = IID_IAdviseSink;
        return S_OK;
    }
    else if (rasynciid == IID_AsyncIAdviseSink2)
    {
        // save a registry call since we know this one
        *psynciid = IID_IAdviseSink2;
        return S_OK;
    }

    return gRIFTbl.SyncFromAsync(rasynciid, psynciid);
}


//+--------------------------------------------------------------------------------
//
//  Function:       GetAsyncIIDFromSyncIID
//
//  Params:         rasynciid -   [in] async IID
//                  psynciid  -   [out] where to place sync IID
//
//  Returns:        S_OK/failure
//
//  Synopsis:       Maps a synchrounous IID to its corresponding asynchronous IID
//                  using the registry
//
//  History:        22-Sep-97 MattSmit       Created
//
//---------------------------------------------------------------------------------
HRESULT GetAsyncIIDFromSyncIID(REFIID rsynciid, IID *pasynciid)
{
    DWORD *ptr = (DWORD *) &rsynciid;

    //
    // check see if this is an internal IID.
    // if so just flip the bits.
    //

    if (*(ptr+1) == 0x00000000 &&   //  all internal iid's have these
        *(ptr+2) == 0x000000C0 &&   //   common values
        *(ptr+3) == 0x46000000 &&
        (*(ptr) & 0xffff0000) == 0x00000000)
    {
        *pasynciid = rsynciid;

        *((DWORD *) pasynciid) |= 0x000e0000;
        return S_OK;
    }

    if (rsynciid == IID_IAdviseSink)
    {
        // save a registry call since we know this one
        *pasynciid = IID_AsyncIAdviseSink;
        return S_OK;
    }
    else if (rsynciid == IID_IAdviseSink2)
    {
        // save a registry call since we know this one
        *pasynciid = IID_AsyncIAdviseSink2;
        return S_OK;
    }

    return gRIFTbl.AsyncFromSync(rsynciid, pasynciid);
}


//+----------------------------------------------------------------------------
//
//  Function:      GetAsyncCallObject
//
//  Synopsis:      Gets an async call object from a sync object
//
//  History:       9-Feb-98  MattSmit  Created
//                13-Jul-98  GopalK    Simplified
//
//-----------------------------------------------------------------------------
HRESULT GetAsyncCallObject(IUnknown *pSyncObj, IUnknown *pControl, REFIID IID_async,
                           REFIID IID_Return, IUnknown **ppInner, void **ppv)
{
    ComDebOut((DEB_CHANNEL,
               "GetAsyncCallObject IN pSyncObj:0x%x, pControl:0x%x, IID_async:%I, "
               "ppUnkInner:0x%x, ppv:0x%x\n", pSyncObj, pControl,
               &IID_async, ppInner, ppv));

    HRESULT hr;
    ICallFactory *pCF = NULL;
    IUnknown *pUnkInner = NULL;
    void *pv = NULL;

    // Try creating the async call object
    hr = pSyncObj->QueryInterface(IID_ICallFactory, (void **) &pCF);
    if (SUCCEEDED(hr))
    {
        hr = pCF->CreateCall(IID_async, pControl, IID_IUnknown, (IUnknown **) &pUnkInner);
        if (SUCCEEDED(hr))
        {
            hr = pUnkInner->QueryInterface(IID_Return, &pv);
            if (SUCCEEDED(hr))
            {
                *ppv = pv;
                pv = NULL;
                *ppInner = pUnkInner;
                pUnkInner = NULL;
            }
            if (pUnkInner)
                pUnkInner->Release();
        }
        pCF->Release();
    }

    ComDebOut((DEB_CHANNEL, "GetAsyncCallObject OUT hr:0x%x\n", hr));
    return hr;
}


//+--------------------------------------------------------------------------------
//
//  Pending Call List
//
//---------------------------------------------------------------------------------

//+--------------------------------------------------------------------------------
//
//  Function:       GetPendingCallList
//
//  Params:         none
//
//  Return:         pointer to list head node
//
//  Synopsis:       Gets the right head node for the list of pending calls,
//                  depending on the apartment type
//
//  History:        22-Sep-97 MattSmit       Created
//
//---------------------------------------------------------------------------------
SPendingCall *GetPendingCallList()
{
    AsyncDebOutTrace((DEB_TRACE, "GetPendingCallList [IN] \n"));
    ASSERT_LOCK_HELD(gChnlCallLock);

    // Obatin the list head
    SPendingCall *pHead;
    if (IsSTAThread())
    {
        COleTls tls;
        pHead = (SPendingCall *) &tls->pvPendingCallsFront;
    }
    else
    {
        pHead = (SPendingCall *) &::MTAPendingCallList;
    }

    // Initialize the head if not already done
    if (pHead->pNext == NULL)
    {
        pHead->pNext = pHead;
        pHead->pPrev = pHead;
    }

    AsyncDebOutTrace((DEB_TRACE, "GetPendingCallListHeadNode [OUT] - Head:0x%x\n", pHead));
    return pHead;
}

//+----------------------------------------------------------------------------
//
//  Function:      CopyToMQI
//
//  Synopsis:      copy to the MULTI_QI structure.
//
//  History:       31-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------

void CopyToMQI(ULONG cIIDs, SQIResult *pSQIPending, MULTI_QI **ppMQIPending, ULONG *pcAcquired)
{
    ComDebOut((DEB_CHANNEL, "CopyToMQI IN pSQIPending:0x%x, ppMQIPending:0x%x, pcAquired:0x%x\n",
               pSQIPending, ppMQIPending, pcAcquired));

    ULONG &cAcquired = *pcAcquired;

    // got some interfaces, loop over the remote QI structure filling
    // in the rest of the MULTI_QI structure to return to the caller.
    // the proxies are already AddRef'd.

    ULONG i;

    for (i=0; i<cIIDs; i++, pSQIPending++, ppMQIPending++)
    {
        MULTI_QI *pMQI = *ppMQIPending;
        pMQI->pItf = (IUnknown *)(pSQIPending->pv);
        pMQI->hr   = pSQIPending->hr;

        if (SUCCEEDED(pMQI->hr))
        {
            // count one more acquired interface
            cAcquired++;
        }
    }

    ComDebOut((DEB_CHANNEL, "CopyToMQI OUT cAcquired:%d\n", cAcquired));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dcomrem\chancont.cxx ===
//----------------------------------------------------------------------------
//
//  copyright (c) 1992  Microsoft Corporation
//
//  File:       chancont.cxx
//
//  Abstract:   This module contains thread switching code for the single
//              threaded mode.
//
//  History:    29 Dec 1993 Alex Mitchell   Creation.
//              Mar 1994    JohannP         Added call category support.
//              19 Jul 1994 CraigWi         Added support for ASYNC calls
//              27-Jan-95   BruceMa         Don't get on CChannelControl list unless
//                                          constructor is successsful
//              01-Nov-96   RichN           Add pipe support.
//              17-Oct-97   RichN           Remove pipes.
//
//----------------------------------------------------------------------------
#include <ole2int.h>
#include <userapis.h>
#include <chancont.hxx>
#include <channelb.hxx>
#include <threads.hxx>
#include <objerror.h>
#include <callctrl.hxx>
#include <service.hxx>
#include <ipidtbl.hxx>
#include <giptbl.hxx>
#include <callmgr.hxx>
#include <ole2int.h>      // CacheCreateThread

//----------------------------------------------------------------------------
// Prototypes.

HRESULT DispatchOnNewThread         (CMessageCall *);
HRESULT TransmitCall                ( OXIDEntry *, CMessageCall * );
void    WakeUpWowClient             (CMessageCall *pcall);
#ifdef _CHICAGO_
STDAPI_(LRESULT) OleNotificationProc(UINT wMsg, WPARAM wParam, LPARAM lParam);
#endif // _CHICAGO_

//----------------------------------------------------------------------------
// Globals.

// Event cache.
CEventCache         gEventCache;

HANDLE CEventCache::_list[] = {0,0,0,0,0,0,0,0,0,0,
                               0,0,0,0,0,0,0,0,0,0};
DWORD  CEventCache::_ifree  = 0;
COleStaticMutexSem CEventCache::_mxsEventCache;


extern LPTSTR       gOleWindowClass;
extern BOOL         gfDestroyingMainWindow;

//----------------------------------------------------------------------------
//
//  Function:   GetToSTA
//
//  Synopsis:   Sends or Posts a message to an STA and waits for the reply.
//
//  Notes:      For W95 WOW we switch back to the 16bit stack on entry to
//              this routine, since this may Post/Send windows messages and
//              Peek/Dispatch them in the modal loop.
//
//----------------------------------------------------------------------------
HRESULT SSAPI(GetToSTA)(OXIDEntry *pOXIDEntry, CMessageCall *pCall)
{
    TRACECALL(TRACE_RPC, "GetToSTA");
    ComDebOut((DEB_CHANNEL, "GetToSTA pCall:%x\n", pCall));
    gOXIDTbl.ValidateOXID();
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT result = S_OK;

    Win4Assert(pCall->IsClientSide());
    Win4Assert(pCall->ProcessLocal());

    // keep the OXIDEntry around for the call
    pOXIDEntry->IncRefCnt();

    // Addref the call object before dispatch
    pCall->AddRef();

    CALLCATEGORY category = pCall->GetCallCategory();

    if (category == CALLCAT_INPUTSYNC)
    {
        // send the call
        result = pOXIDEntry->SendCallToSTA(pCall);

        if (SUCCEEDED(result))
            result = pCall->GetResult();

        if (!pCall->IsCallCompleted())
        {
           // fixup reference count
           pCall->Release();
        }
    }
    else      // sync call
    {
        Win4Assert(category == CALLCAT_SYNCHRONOUS);
        Win4Assert(pCall->GetEvent());

        // Dispatch the call
        result = pOXIDEntry->PostCallToSTA(pCall);

        // If the above post failed, release call object object
        if(FAILED(result))
            pCall->Release();

        if (result == S_OK)
        {
            // Wait for the either the call to complete
            // or get canceled or timeout to occur
            result = RPC_S_CALLPENDING;
            while(result == RPC_S_CALLPENDING)
            {
                DWORD dwTimeout = pCall->GetTimeout();
                DWORD dwReason  = WaitForSingleObject(pCall->GetEvent(), dwTimeout);

                if(dwReason==WAIT_OBJECT_0)
                {
                    result = S_OK;
                }
                else if(dwReason==WAIT_TIMEOUT)
                {
                    result = RPC_E_CALL_CANCELED;
                    Win4Assert(pCall->GetTimeout() == 0);
                }
                else
                {
                    result = RPC_E_SYS_CALL_FAILED;
                    break;
                }

                result = pCall->RslvCancel(dwReason, result, FALSE, NULL);
            }

            if(result == S_OK)
                result = pCall->GetResult();

            // CallCompleted is invoked on the server
            // thread. Assert that it has been called
            Win4Assert(pCall->IsCallCanceled() || pCall->IsCallCompleted() ||
                       !pCall->IsCallDispatched());
        }
    } // sync call

    pOXIDEntry->DecRefCnt();

    ASSERT_LOCK_NOT_HELD(gComLock);
    gOXIDTbl.ValidateOXID();
    return result;
}

//----------------------------------------------------------------------------
//
//  Function:   ModalLoop
//
//  Synopsis:   Calls the Modal Loop BlockFn to wait for an outgoing call to
//              complete.
//
//----------------------------------------------------------------------------
HRESULT ModalLoop( CMessageCall *pcall )
{
    ASSERT_LOCK_NOT_HELD(gComLock);
    DWORD result;

    // we should only enter the modal loop for synchronous calls or input
    // synchronous calls to another process or to an MTA apartment within
    // the current process.

    Win4Assert(pcall->GetCallCategory() == CALLCAT_SYNCHRONOUS ||
               pcall->GetCallCategory() == CALLCAT_INPUTSYNC);


    // detemine if we are using an event or a postmessage for the call
    // completion signal.  We use PostMessage only for process local
    // calls in WOW, otherwise we use events and the OleModalLoop determines
    // if the call completed or not.

    BOOL           fMsg  = (pcall->ProcessLocal() && IsWOWThread());
    BOOL           fWait = TRUE;
    DWORD       dwSignal = 0xFFFFFFFF;
    CAptCallCtrl  *pACC  = GetAptCallCtrl();
    CCliModalLoop *pCML  = pACC->GetTopCML();

    ComDebOut((DEB_CALLCONT,"ModalLoop: wait on %s\n",(fMsg) ? "Msg" : "Event"));

    // Wait at least once so the event is returned to the cache in the
    // unsignalled state.
    Win4Assert(fMsg || pcall->GetEvent());
    do
    {
        // Enter modal loop
        HANDLE hEvent = pcall->GetEvent();
        result = pCML->BlockFn(&hEvent, hEvent ? 1 : 0, &dwSignal);
        result = pcall->RslvCancel(dwSignal, result, fMsg, pCML);

        // Unblock if the call is still not pending
        if(result != RPC_S_CALLPENDING)
            fWait = FALSE;
    } while (fWait);

    ASSERT_LOCK_NOT_HELD(gComLock);
    return result;
}

//----------------------------------------------------------------------------
//
//  Function:   SwitchSTA
//
//  Synopsis:   Sends or Posts a message to an STA and waits for the reply
//              in a modal loop.
//
//  Notes:      For W95 WOW we switch back to the 16bit stack on entry to
//              this routine, since this may Post/Send windows messages and
//              Peek/Dispatch them in the modal loop.
//
//----------------------------------------------------------------------------
HRESULT SSAPI(SwitchSTA)( OXIDEntry *pOXIDEntry, CMessageCall **ppCall )
{
    TRACECALL(TRACE_RPC, "SwitchSTA");
    ComDebOut((DEB_CHANNEL, "SwitchSTA hWnd:%x pCall:%x hEvent:%x\n",
    (*ppCall)->GetCallerhWnd(), (*ppCall), (*ppCall)->GetEvent()));
    gOXIDTbl.ValidateOXID();
    ASSERT_LOCK_NOT_HELD(gComLock);

    // Transmit the call.
    HRESULT result = TransmitCall( pOXIDEntry, *ppCall );

    // the transmit was successful and the reply isn't already here so wait.
    if (result == RPC_S_CALLPENDING)
    {
        // This is a single-threaded apartment so enter the modal loop.
        result = ModalLoop( *ppCall );
    }

    if (result == S_OK)
        result = (*ppCall)->GetResult();

    ASSERT_LOCK_NOT_HELD(gComLock);
    gOXIDTbl.ValidateOXID();
    ComDebOut((DEB_CHANNEL, "SwitchSTA hr:%x\n", result));
    return result;
}

#ifdef _CHICAGO_
//+---------------------------------------------------------------------------
//
//  Function:   GetToSTA
//
//  Synopsis:   Switches to 16 bit stack and calls GetToSTA
//
//----------------------------------------------------------------------------
HRESULT GetToSTA(OXIDEntry *pOXIDEntry, CMessageCall *pCallInfo)
{
    StackDebugOut((DEB_ITRACE, "SSGetToSTA\n"));
    if (SSONBIGSTACK())
    {
        StackDebugOut((DEB_STCKSWTCH, "Stack switch(16) on GetToSTA\n"));
        return SSCall(8 ,SSF_SmallStack, (LPVOID)SSGetToSTA,
                         (DWORD)pOXIDEntry, (DWORD)pCallInfo);
    }
    else
    {
        return SSGetToSTA(pOXIDEntry, pCallInfo);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   SwitchSTA
//
//  Synopsis:   Switches to 16 bit stack and calls SwitchSTA
//
//----------------------------------------------------------------------------
HRESULT SwitchSTA(OXIDEntry *pOXIDEntry, CMessageCall **ppCallInfo)
{
    StackDebugOut((DEB_ITRACE, "SSSwitchSTA\n"));
    if (SSONBIGSTACK())
    {
        StackDebugOut((DEB_STCKSWTCH, "Stack switch(16) on SwitchSTA\n"));
        return SSCall(8 ,SSF_SmallStack, (LPVOID)SSSwitchSTA,
                         (DWORD)pOXIDEntry, (DWORD)ppCallInfo);
    }
    else
    {
        return SSSwitchSTA(pOXIDEntry, ppCallInfo);
    }
}
#endif // _CHICAGO_

//----------------------------------------------------------------------------
//
//  Function:   ThreadDispatch
//
//  Synopsis:   This routine is called by the OLE Worker thread on the client
//              side, and by ThreadWndProc on the server side.
//
//  Notes:      For the client case, it calls ThreadSendReceive which will send
//              the data over to the server side.
//              This routine notifies the COM thread when the call is complete.
//              If the call is canceled before completion, the routine cleans up.
//
//----------------------------------------------------------------------------
DWORD _stdcall ThreadDispatch( void *param )
{
    HRESULT       result   = S_OK;
    CMessageCall *pcall    = (CMessageCall *) param;

    gOXIDTbl.ValidateOXID();
    Win4Assert( !pcall->IsClientSide() || pcall->ProcessLocal());


    // NOTE: there is an implied reference on *ppcall which is taken
    //       for us by whoever sent/posted the message.  It is our
    //       responsibility to release it.

    // This code path is also executed by the worker thread
    // for process local STA to MTA calls

    // For process local calls, ask call object whether it is OK to
    // dispatch
    if  (pcall->ProcessLocal())
        result = pcall->CanDispatch();

    if (SUCCEEDED(result))
    {
        // Dispatch the call
        result = ComInvoke(pcall);
    }
    else
    {
        // Cleanup resources
        PrivMemFree(pcall->message.Buffer);
        pcall->_pHeader = NULL;
    }

    // If the call became async, the app will complete it later.  Don't
    // do anything now.
    if (pcall->ServerAsync())
    {
        // Release the the implied reference.  See note above.
        pcall->Release();
        return 0;
    }

    // Update the return code in the call
    pcall->SetResult(result);

    // Complete sync process local calls
    if (pcall->ProcessLocal())
        pcall->CallCompleted( result );

    // Check call type
    if (pcall->ProcessLocal())
    {
        // Don't do anything if the call was canceled
        if(pcall->IsClientWaiting())
        {
            // Check the call category
            if (pcall->GetCallCategory() == CALLCAT_SYNCHRONOUS)
            {
                // Check for calls into NTA
                if (!pcall->ThreadLocal())
                {
                    if (IsWOWThread())
                    {
                        WakeUpWowClient(pcall);
                    }
                    else
                    {
                        ComDebOut((DEB_CHANNEL, "SetEvent pInfo:%x hEvent:%x\n",
                              pcall, pcall->GetEvent()));
                        SetEvent( pcall->GetEvent() );
                    }
                }
            }
            else if((pcall->GetCallCategory() == CALLCAT_ASYNC))
            {
                SignalTheClient((CAsyncCall *)pcall);
            }
        }
    }
    else
    {
        // On the server side of a machine remote or process remote call. We
        // lied and told RPC it was async.  Send the reply using the async APIs.
        ((CAsyncCall *) pcall)->ServerReply();
    }

    // Release the the implied reference.  See note above.
    pcall->Release();

    gOXIDTbl.ValidateOXID();
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   WakeUpWowClient
//
//  Synopsis:   Wakes up the waiting client.
//
//----------------------------------------------------------------------------
void WakeUpWowClient(CMessageCall *pcall)
{
    ComDebOut((DEB_CHANNEL,"WakeUpWowClient"));

    //  NOTE NOTE NOTE NOTE NOTE NOTE NOTE
    //  16bit OLE used to do PostMessage for the Reply; we
    //  tried using SetEvent (which is faster) but this caused
    //  compatibility problems for applications which had bugs that
    //  were hidden by the 16bit OLE DLLs because messages happened
    //  to be dispatched in a particular order (see NtBug 21616 for
    //  an example).  To retain the old behavior, we do a
    //  PostMessage here.

    ComDebOut((DEB_CHANNEL,
      "PostMessage Reply hWnd:%x pCall:%x hEvent:%x\n",
       pcall->GetCallerhWnd(), pcall, pcall->GetEvent()));

    // Pass the thread id to aid debugging.
    Verify(PostMessage(pcall->GetCallerhWnd(),
                     WM_OLE_ORPC_DONE,
                     WMSG_MAGIC_VALUE, (LPARAM)pcall));
}

//+-------------------------------------------------------------------------
//
//  Member:     GetOrCreateSTAWindow
//
//  Synopsis:   Apartment model only.  Setup the window used for
//              local thread switches and the call control.  Helper func
//              for ThreadStart.  Also, on Win95 helper function for
//              GetOleNotificationWnd() in com\dcomrem\notify.cxx so that
//              we can lazily finish registering classes
//
//  History:    09-26-96    MurthyS  Created
//
//--------------------------------------------------------------------------
HWND GetOrCreateSTAWindow()
{
    HWND hwnd;

    Win4Assert(IsSTAThread());

    // We have already created one on Win95
    if (!(hwnd = TLSGethwndSTA()))
    {
        if (GetCurrentThreadId() == gdwMainThreadId && ghwndOleMainThread != NULL)
        {
            // this is the main thread, we can just re-use the already
            // existing gMainThreadWnd.

            hwnd = ghwndOleMainThread;
        }
        else
        {
            // Create a new window for use by the current thread for the
            // apartment model. The window is destroyed in ThreadStop.
#ifdef _CHICAGO_
            // On Win95, the system does not broadcast to Ole's window class
            HWND hwndParent = NULL;
#else
            // On NT, we have to inherit from a new window class.
            HWND hwndParent = HWND_MESSAGE;

#endif
            Win4Assert(gOleWindowClass != NULL);

#ifdef _CHICAGO_
            hwnd = SSCreateWindowExA(0,
#else
            hwnd = CreateWindowExW(0,
#endif
                              gOleWindowClass,
                              TEXT("OLEChannelWnd"),
                              // must use WS_POPUP so the window does not get
                              // assigned a hot key by user.
                              (WS_DISABLED | WS_POPUP),
                              CW_USEDEFAULT,
                              CW_USEDEFAULT,
                              CW_USEDEFAULT,
                              CW_USEDEFAULT,
                              hwndParent,
                              NULL,
                              g_hinst,
                              NULL);

        }

        TLSSethwndSTA(hwnd);
    }

    return(hwnd);
}

//--------------------------------------------------------------------------
//
//  Function:   PeekTillDone
//
//  Synopsis:   Pulls all remaining messages off the windows message queue.
//
//--------------------------------------------------------------------------
void PeekTillDone(HWND hWnd)
{
    MSG    msg;
    BOOL   got_quit = FALSE;
    WPARAM quit_val;

    while(PeekMessage(&msg, hWnd, WM_USER,
                      0x7fff, PM_REMOVE | PM_NOYIELD))
    {
        if (msg.message == WM_QUIT)
        {
            got_quit = TRUE;
            quit_val = msg.wParam;
        }
        else
        {
            DispatchMessage(&msg);
        }
    }

    if (got_quit)
    {
        PostQuitMessage( (int) quit_val );
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   ThreadWndProc, Internal
//
//  Synopsis:   Dispatch COM windows messages.  This routine is only called
//              for Single-Threaded Apartments. It dispatches calls and call
//              complete messages.  If it does not recognize the message, it
//              calls DefWindowProc to dispatch it.
//
//--------------------------------------------------------------------------
LRESULT ThreadWndProc(HWND window, UINT message, WPARAM wparam, LPARAM params)
{
    Win4Assert(IsSTAThread());

    // First, check to see if we have got a message that doesn't belong
    //  to us. In that case, do the default processing from the final
    //  "else" statement below

    if ( (LOWORD(wparam) != WMSG_MAGIC_VALUE ) || params == NULL)
    {
        // when the window is first created we are holding the lock, and the
        // creation of the window causes some messages to be dispatched.
        ASSERT_LOCK_DONTCARE(gComLock);

        // check if the window is being destroyed because of UninitMainWindow
        // or because of system shut down. Only destroy it in the former case.
        if ((message == WM_DESTROY || message == WM_CLOSE) &&
            window == ghwndOleMainThread &&
            gfDestroyingMainWindow == FALSE)
        {
            ComDebOut((DEB_WARN, "Attempted to destroy window outside of UninitMainThreadWnd"));
            return 0;
        }

        // Otherwise let the default window procedure have the message.
        ComDebOut((DEB_CHANNEL,"->DefWindowProc(window=0x%x, msg=0x%x, wparam=0x%x, lparams=0x%x)\n",
                    window, message, wparam, params));
        LRESULT result = DefWindowProc(window, message, wparam, params);
        ComDebOut((DEB_CHANNEL,"<-DefWindowProx(status=0x%x)\n", result));
        return result;
    }
    else if (message == WM_OLE_ORPC_POST || message == WM_OLE_ORPC_SEND)
    {
        // wparam is a magic cookie used by USER to ensure correct focus mgmt
        Win4Assert(LOWORD(wparam) == WMSG_MAGIC_VALUE);
        ASSERT_LOCK_NOT_HELD(gComLock);

        CMessageCall *call = (CMessageCall *) params;
        ComDebOut((DEB_CHANNEL, "ThreadWndProc: Incoming Call pCall:%x\n", call));

        // Dispatch all calls through ThreadDispatch.  Local calls may be
        // canceled.  Server-side, non-local calls cannot be canceled.  Send
        // message calls (event == NULL) are handled as well.
        ThreadDispatch( call );

        ASSERT_LOCK_NOT_HELD(gComLock);
        return 1; //return a non-zero code because the message was processed; if SendMessage itself doesn't fail, it will return this error code
    }
    else if (message == WM_OLE_ORPC_DONE)
    {
        // wparam is a magic cookie used by USER to ensure correct focus mgmt
        Win4Assert(LOWORD(wparam) == WMSG_MAGIC_VALUE);
        ASSERT_LOCK_NOT_HELD(gComLock);

        // call completed - only happens InWow()
        CMessageCall *call = (CMessageCall *) params;
        ComDebOut((DEB_CHANNEL, "ThreadWndProc: Call Completed hWnd:%x pCall:%x\n", window, call));

        // Inform call object that the call completion message
        // has arrived
        call->WOWMsgArrived();

        ASSERT_LOCK_NOT_HELD(gComLock);
        return 0;
    }
    else if (message == WM_OLE_ORPC_RELRIFREF)
    {
        // wparam is a magic cookie used by USER to ensure correct focus mgmt
        Win4Assert(LOWORD(wparam) == WMSG_MAGIC_VALUE);
        ASSERT_LOCK_NOT_HELD(gComLock);

        // delayed call to Release due to being in an async or inputsync call.
        HandlePostReleaseRifRef(params);

        ASSERT_LOCK_NOT_HELD(gComLock);
        return 0;
    }
    else if (message == WM_OLE_GIP_REVOKE)
    {
        Win4Assert(LOWORD(wparam) == WMSG_MAGIC_VALUE);
        ASSERT_LOCK_NOT_HELD(gComLock);
        // revoke the globally registered interface.
        // params is the cookie.
        gGIPTbl.RevokeInterfaceFromGlobal((DWORD)params);

        ASSERT_LOCK_NOT_HELD(gComLock);
        return 0;
    }
    else if (message == WM_OLE_GETCLASS)
    {
        // wparam is a magic cookie used by USER to ensure correct focus mgmt
        Win4Assert(LOWORD(wparam) == WMSG_MAGIC_VALUE);
        // CoGetClassObject (single-threaded)
        return OleMainThreadWndProc(window, message, wparam, params);
    }
    else if (message == WM_OLE_SIGNAL)
    {
        // wparam is a magic cookie used by USER to ensure correct focus mgmt
        Win4Assert(LOWORD(wparam) == WMSG_MAGIC_VALUE);
        ComSignal((void *) params);
        return 0;
    }
#ifdef _CHICAGO_
    else if (message == WM_OLE_ORPC_NOTIFY)
    {
        // wparam is a magic cookie used by USER to ensure correct focus mgmt
        Win4Assert(LOWORD(wparam) == WMSG_MAGIC_VALUE);
        // got the initialization message
        return OleNotificationProc(message, wparam, params);
    }
#endif // _CHICAGO_
    else
    {
        // This default message processing is also at the top of the routine,
        //  when we can tell that we've got a message we don't care about

        // when the window is first created we are holding the lock, and the
        // creation of the window causes some messages to be dispatched.
        ASSERT_LOCK_DONTCARE(gComLock);

        // check if the window is being destroyed because of UninitMainWindow
        // or because of system shut down. Only destroy it in the former case.
        if ((message == WM_DESTROY || message == WM_CLOSE) &&
          window == ghwndOleMainThread &&
          gfDestroyingMainWindow == FALSE)
        {
            ComDebOut((DEB_WARN, "Attempted to destroy window outside of UninitMainThreadWnd"));
            return 0;
        }
        // Otherwise let the default window procedure have the message.
        ComDebOut((DEB_CHANNEL,"->DefWindowProc(window=0x%x, msg=0x%x, wparam=0x%x, lparams=0x%x)\n",
                   window, message, wparam, params));
        LRESULT result = DefWindowProc(window, message, wparam, params);
        ComDebOut((DEB_CHANNEL,"<-DefWindowProx(status=0x%x)\n", result));
        return result;
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   TransmitCall
//
//  Synopsis:   Return S_OK if the call completed successfully.
//              Return RPC_S_CALL_PENDING if the caller should block.
//              Return an error if the call failed.
//
//+-------------------------------------------------------------------------
HRESULT TransmitCall( OXIDEntry *pOXIDEntry, CMessageCall *pCall )
{
    ComDebOut((DEB_CHANNEL, "TransmitCall pCall:%x\n", pCall));
    ASSERT_LOCK_NOT_HELD(gComLock);
    Win4Assert( pCall->GetCallCategory() != CALLCAT_ASYNC );
    Win4Assert( pCall->ProcessLocal() );
    // Assert that this code path is only taken on the
    // client side
    Win4Assert(pCall->IsClientSide());


    BOOL    fDispCall = FALSE;
    BOOLEAN wait = FALSE;
    HRESULT result = S_OK;
    HANDLE  hSxsActCtx = INVALID_HANDLE_VALUE;

    // Don't touch the call hresult after the other thread starts,
    // otherwise we might erase the results of the other thread.
    // Since we never want signalled events returned to the cache, always
    // wait on the event at least once.  For example, the post message
    // succeeds and the call completes immediately.  Return RPC_S_CALLPENDING
    // even though the call already has a S_OK in it.

    // Mark the call as pending
    pCall->SetResult(RPC_S_CALLPENDING);

    // Addref the call object before dispatch
    pCall->AddRef();

    // Get the sxs context before sending
    if (GetCurrentActCtx(&hSxsActCtx))
        pCall->SetSxsActCtx(hSxsActCtx);
    else
    {
        pCall->Release();
        result = HRESULT_FROM_WIN32(GetLastError());
        if (SUCCEEDED(result))
            result = E_FAIL;
        Win4Assert(result != S_OK);
        goto Exit;
    }

    if (!(pOXIDEntry->IsMTAServer()))
    {
        // server is in STA
        if (pCall->GetCallCategory() == CALLCAT_INPUTSYNC)
        {
            result = pOXIDEntry->SendCallToSTA(pCall);

            // Check CompleteStatus instead of result since the call
            // could have been partially processed by the server when
            // when the window handle went bad.
            if (!pCall->IsCallCompleted())
            {
                // fix up reference count
                pCall->Release();
            }
        }
        else
        {
            Win4Assert(pCall->GetCallCategory() == CALLCAT_SYNCHRONOUS);

            // Local Sync call and STA server. Post the message and wait
            // for a reply.

            if (IsWOWThread())
            {
                // In 32bit, replies are done via Events, but for 16bit, replies
                // are done with PostMessage, so get the hWnd for the reply.
                pCall->SetCallerhWnd();
            }

            // Post to the server window
            result = pOXIDEntry->PostCallToSTA(pCall);

            // If the above post failed, release call object
            if (FAILED(result))
            {
                pCall->Release();
            }
            else
            {
                wait = TRUE;
            }
        }
    }
    else
    {
        ComDebOut(( DEB_CHANNEL, "DispatchOnNewThread, pCall: %x \n", pCall));

        // Process local STA to MTA. Transmit the call by having
        // a worker thread invoke the server directly.
        wait = TRUE;

        // On the server side, the call event should have already
        // been created
        Win4Assert(pCall->GetEvent());

        // Dispatch the call
        result = CacheCreateThread( ThreadDispatch, pCall );

        if(FAILED(result))
        {
            // Fix up the reference count
            pCall->Release();
        }
    }
Exit:
    if (result != S_OK)
    {
        pCall->SetResult(result);
        wait = FALSE;
    }

    ComDebOut((DEB_CHANNEL, "TransmitCall pCall->hResult:%x fWait:%x\n",
               pCall->GetResult(), wait));

    ASSERT_LOCK_NOT_HELD(gComLock);
    Win4Assert(wait || pCall->GetResult() != RPC_S_CALLPENDING);
    return (wait) ? RPC_S_CALLPENDING : pCall->GetResult();
}

//+-------------------------------------------------------------------------
//
//  Member:     CEventCache::Cleanup
//
//  Synopsis:   Empty the event cache
//
//  Notes:      This function must be thread safe because Canceled calls
//              can complete at any time.
//
//--------------------------------------------------------------------------
void CEventCache::Cleanup(void)
{
    ASSERT_LOCK_NOT_HELD(_mxsEventCache);
    LOCK(_mxsEventCache);

    while (_ifree > 0)
    {
        _ifree--;               // decrement the index first!
        Verify(CloseHandle(_list[_ifree]));
        _list[_ifree] = NULL;   // NULL slot so we dont need to re-init
    }

    // reset the index to 0 so reinitialization is not needed
    _ifree = 0;

    UNLOCK(_mxsEventCache);
    ASSERT_LOCK_NOT_HELD(_mxsEventCache);
}

//+-------------------------------------------------------------------------
//
//  Member:     CEventCache::Free
//
//  Synopsis:   returns an event to the cache if there are any available
//              slots, frees the event if not.
//
//  Notes:      This function must be thread safe because Canceled calls
//              can complete at any time.
//
//--------------------------------------------------------------------------
void CEventCache::Free( HANDLE hEvent )
{
    // there better be an event
    Win4Assert(hEvent != NULL);

    ASSERT_LOCK_NOT_HELD(_mxsEventCache);
    LOCK(_mxsEventCache);

    // dont return anything to the cache if the process is no longer init'd.
    if (_ifree < CEVENTCACHE_MAX_EVENT && gfChannelProcessInitialized)
    {
        // there is space, save this event.

#if DBG==1
        // in debug, ensure slot is NULL
        Win4Assert(_list[_ifree] == NULL && "Free: _list[_ifree] != NULL");

        //  ensure not already in the list
        for (ULONG j=0; j<_ifree; j++)
        {
            Win4Assert(_list[j] != hEvent && "Free: event already in cache!");
        }

        // ensure that the event is in the non-signalled state
        Win4Assert(WaitForSingleObject(hEvent, 0) == WAIT_TIMEOUT &&
                "Free: Signalled event returned to cache!\n");
#endif

        _list[_ifree] = hEvent;
        _ifree++;
        hEvent = NULL;
    }

    UNLOCK(_mxsEventCache);
    ASSERT_LOCK_NOT_HELD(_mxsEventCache);

    if (hEvent)
    {
        // still have it, really free it.
        Verify(CloseHandle(hEvent));
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CEventCache::Get
//
//  Synopsis:   gets an event from the cache if there are any available,
//              allocates one if not.
//
//  Notes:      This function must be thread safe because Canceled calls
//              can complete at any time.
//
//--------------------------------------------------------------------------
HRESULT CEventCache::Get( HANDLE *hEvent )
{
    ASSERT_LOCK_NOT_HELD(_mxsEventCache);
    LOCK(_mxsEventCache);

    Win4Assert(_ifree <= CEVENTCACHE_MAX_EVENT);

    if (_ifree > 0)
    {
        // there is an event in the cache, use it.
        _ifree--;
        *hEvent = _list[_ifree];

#if DBG==1
        //  in debug, NULL the slot.
        _list[_ifree] = NULL;
#endif

        UNLOCK(_mxsEventCache);
        ASSERT_LOCK_NOT_HELD(_mxsEventCache);
        return S_OK;
    }

    UNLOCK(_mxsEventCache);
    ASSERT_LOCK_NOT_HELD(_mxsEventCache);

    // no free event in the cache, allocate a new one.
#ifdef _CHICAGO_
    *hEvent = CreateEventA( NULL, FALSE, FALSE, NULL );
#else  //_CHICAGO_
    *hEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
#endif //_CHICAGO_

    return (*hEvent) ? S_OK : RPC_E_OUT_OF_RESOURCES;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dcomrem\channelb.cxx ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       channelb.cxx
//
//  Contents:   This module contains thunking classes that allow proxies
//              and stubs to use a buffer interface on top of RPC for NT
//
//  Classes:    CRpcChannelBuffer
//
//  Functions:
//              ChannelThreadInitialize
//              Channelprocessinitialize
//              ChannelRegisterProtseq
//              ChannelThreadUninitialize
//              ChannelProcessUninitialize
//              CRpcChannelBuffer::AddRef
//              CRpcChannelBuffer::AppInvoke
//              CRpcChannelBuffer::CRpcChannelBuffer
//              CRpcChannelBuffer::FreeBuffer
//              CRpcChannelBuffer::GetBuffer
//              CRpcChannelBuffer::QueryInterface
//              CRpcChannelBuffer::Release
//              CRpcChannelBuffer::SendReceive
//              CRpcChannelBuffer::Send
//              CrpcChannelBuffer::Receive
//              CRpcChannelBuffer::CleanUpCanceledOrFailed
//              DllDebugObjectRPCHook
//              ThreadInvoke
//              ThreadSendReceive
//
//  History:    22 Jun 93 AlexMi        Created
//              31 Dec 93 ErikGav       Chicago port
//              15 Mar 94 JohannP       Added call category support.
//              09 Jun 94 BruceMa       Get call category from RPC message
//              19 Jul 94 CraigWi       Added support for ASYNC calls
//              01-Aug-94 BruceMa       Memory sift fix
//              12-Dec-96 Gopalk        Support for updating connection
//                                      status maintained by Std Identity
//              02-Jan-97 RichN         Add pipe support
//              17-Oct-97 RichN         Remove pipes.
//
//----------------------------------------------------------------------

#include <ole2int.h>
#include <ctxchnl.hxx>
#include <hash.hxx>         // CUUIDHashTable
#include <riftbl.hxx>       // gRIFTbl
#include <callctrl.hxx>     // CAptRpcChnl, AptInvoke
#include <threads.hxx>      // CRpcThreadCache
#include <service.hxx>      // StopListen
#include <resolver.hxx>     // CRpcResolver
#include <giptbl.hxx>       // CGIPTbl
#include <refcache.hxx>     // gROIDTbl

extern "C"
{
#include "orpc_dbg.h"
}

#include <rpcdcep.h>
#include <rpcndr.h>
#include <obase.h>
#include <ipidtbl.hxx>
#include <security.hxx>
#include <chock.hxx>
#include <sync.hxx>         // CAutoComplete::QueryInterface
#include "aprtmnt.hxx"      // Apartment object.
#include <events.hxx>       // Event logging functions
#include <callmgr.hxx>
#include <excepn.hxx>       // Exception filter routines


// This is needed for the debug hooks.  See orpc_dbg.h
#pragma code_seg(".orpc")

extern CObjectContext *g_pNTAEmptyCtx;  // NTA empty context
extern HRESULT GetAsyncIIDFromSyncIID(REFIID rSyncIID, IID *pAsyncIID);
extern HINSTANCE g_hComSvcs;            // module handle of com svcs.


/***************************************************************************/
/* Defines. */
// This should just return a status to runtime, but runtime does not
// support both comm and fault status yet.
#ifdef _CHICAGO_
#define RETURN_COMM_STATUS( status ) return (status)
#else
#define RETURN_COMM_STATUS( status ) RpcRaiseException( status )
#endif

// Default size of hash table.
const int INITIAL_NUM_BUCKETS = 20;

/***************************************************************************/
/* Macros. */

// Compute the size needed for the implicit this pointer including the
// various optional headers.
inline DWORD SIZENEEDED_ORPCTHIS( BOOL local, DWORD debug_size )
{
    if (debug_size == 0)
        return sizeof(WireThisPart1) + ((local) ? sizeof(LocalThis) : 0);
    else
        return sizeof(WireThisPart2) + ((local) ? sizeof(LocalThis) : 0) +
            debug_size;
}

inline DWORD SIZENEEDED_ORPCTHAT( DWORD debug_size )
{
    if (debug_size == 0)
        return sizeof(WireThatPart1);
    else
        return sizeof(WireThatPart2) + debug_size;
}

inline CALLCATEGORY GetCallCat( void *header )
{
    WireThis *pInb = (WireThis *) header;
    if (pInb->c.flags & ORPCF_ASYNC)
        return CALLCAT_ASYNC;
    else if (pInb->c.flags & ORPCF_INPUT_SYNC)
        return CALLCAT_INPUTSYNC;
    else
        return CALLCAT_SYNCHRONOUS;
}

inline HRESULT FIX_WIN32( HRESULT result )
{
    if ((ULONG) result > 0xfffffff7 || (ULONG) result < 0x2000)
        return MAKE_WIN32( result );
    else
        return result;
}

/***************************************************************************/
/* Globals. */

// Should the debugger hooks be called?
BOOL               DoDebuggerHooks = FALSE;
LPORPC_INIT_ARGS   DebuggerArg     = NULL;

// The extension identifier for debug data.
const uuid_t DEBUG_EXTENSION =
{ 0xf1f19680, 0x4d2a, 0x11ce, {0xa6, 0x6a, 0x00, 0x20, 0xaf, 0x6e, 0x72, 0xf4}};

// this is a special IID to get a pointer to the  C++ object itself
// on a CRpcChannelBuffer object  It is not exposed to the outside
// world.
const IID IID_CPPRpcChannelBuffer = {0x00000152,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};


#if DBG == 1
// strings that prefix the call
WCHAR *wszDebugORPCCallPrefixString[8] = { L"In ",     // Invoke
                                           L"In ",
                                           L"Out",     // SendReceive
                                           L"Out",
                                           L"Snd",     // Send
                                           L"Snd",
                                           L"Rcv",     // Receive
                                           L"Rcv" };
// strings for call categories
WCHAR *wszCallCat[7] = { L"no call   ",
                         L"sync      ",
                         L"async     ",
                         L"input_sync",
                         L"sync      ",
                         L"input_sync",
                         L"SCM call  "};
#endif



// flag whether or not the channel has been initialized for current process
BOOL    gfChannelProcessInitialized = 0;
COleStaticMutexSem  gChannelInitLock;   // critical section to guard (un)init

// Channel debug hook object.
CDebugChannelHook gDebugHook;

// Channel error hook object.
CErrorChannelHook gErrorHook;

// Context hook
CCtxHook gCtxHook;

//******************************************************************************
// Prototypes
//
HRESULT CreateHandle  ( OXIDEntry *pOXIDEntry, DWORD eChannel,
                        CChannelHandle **ppHandle );
HRESULT ComInvokeWithLockAndIPID( CMessageCall *pCall, IPIDEntry *pIPIDEntry);

#if DBG==1
//-------------------------------------------------------------------------
//
//  Function:   GetInterfaceName
//
//  synopsis:   Gets the human readable name of an Interface given it's IID.
//
//  History:    12-Jun-95   Rickhi  Created
//
//-------------------------------------------------------------------------
LONG GetInterfaceName(REFIID riid, WCHAR *pwszName)
{
    // convert the iid to a string
    CDbgGuidStr dbgsIID(riid);

    // Read the registry entry for the interface to get the interface name
    LONG ulcb=256;
    WCHAR szKey[80];

    pwszName[0] = L'\0';
    szKey[0] = L'\0';
    lstrcatW(szKey, L"Interface\\");
    lstrcatW(szKey, dbgsIID._wszGuid);

    LONG result = RegQueryValue(
               HKEY_CLASSES_ROOT,
               szKey,
               pwszName,
               &ulcb);

    return result;
}

//---------------------------------------------------------------------------
//
//  Function:   DebugPrintORPCCall
//
//  synopsis:   Prints the interface name and method number to the debugger
//              to allow simple ORPC call tracing.
//
//  History:    12-Jun-95   Rickhi  Created
//
//---------------------------------------------------------------------------
void DebugPrintORPCCall(DWORD dwFlag, REFIID riid, DWORD iMethod, DWORD CallCat)
{
    if(dwFlag >= 8)
        return;

    if (CairoleInfoLevel & DEB_RPCSPY)
    {
        COleTls tls;

        // construct the debug strings
        WCHAR *pwszDirection = wszDebugORPCCallPrefixString[dwFlag];
        WCHAR *pszCallCat = wszCallCat[CallCat];
        WCHAR *pszBeginEnd = L"{";
        WCHAR wszName[100];
        WCHAR wszIndent[20];
        int i;

        GetInterfaceName(riid, wszName);

        // adjust the nesting level for this thread.
        switch(dwFlag)
        {
        case ORPC_INVOKE_END:
        case ORPC_SENDRECEIVE_END:
        case ORPC_SEND_END:
            if(tls->cORPCNestingLevel > 0)
            {
                tls->cORPCNestingLevel--;
            }
            else
            {
                tls->cORPCNestingLevel = 0;
            }
            pszBeginEnd = L"}";
            break;
        default:
            break;
        }

        for(i = 0; i <= tls->cORPCNestingLevel && i < 10; i++)
        {
           wszIndent[i] = L' ';
        }
        wszIndent[i] = L'\0';

        ComDebOut((DEB_RPCSPY, "%ws %ws %d%ws%ws::%d %ws\n", pszCallCat,
            pwszDirection, tls->cORPCNestingLevel, wszIndent,
            wszName, iMethod & ~0x8000, pszBeginEnd));

        // adjust the nesting level for this thread.
        switch(dwFlag)
        {
        case ORPC_INVOKE_BEGIN:
        case ORPC_SENDRECEIVE_BEGIN:
        case ORPC_SEND_BEGIN:
            tls->cORPCNestingLevel++;
            break;
        default:
            break;
        }
    }
}
#endif

#if LOCK_PERF==1
//---------------------------------------------------------------------------
//
//  Function:   OutputHashPerfData, public
//
//  Synopsis:   Dumps the statistics gathered by the various hash tables
//              in the system.
//
//---------------------------------------------------------------------------
void OutputHashPerfData()
{
    char szHashPerfBuf[256];
    wsprintfA(szHashPerfBuf,"\n\n ============= HASH TABLE MAX SIZES ===========\n");
    OutputDebugStringA(szHashPerfBuf);

    OutputHashEntryData("gOIDTable ", gOIDTable.s_OIDHashTbl);
    OutputHashEntryData("gPIDTable ", gPIDTable.s_PIDHashTbl);
    OutputHashEntryData("gROIDTbl  ", gROIDTbl._ClientRegisteredOIDs);
    OutputHashEntryData("gPSTable  ", gPSTable.s_PSHashTbl);
    OutputHashEntryData("gMIDTbl   ", gMIDTbl._HashTbl);
    OutputHashEntryData("gRIFTbl   ", gRIFTbl._HashTbl);
}
#endif // LOCK_PERF

/***************************************************************************/
void ByteSwapThis( DWORD drep, WireThis *pInb )
{
    if ((drep & NDR_INT_REP_MASK) != NDR_LOCAL_ENDIAN)
    {
        // Extensions are swapped later.  If we ever use the reserved field,
        // swap it.
        ByteSwapShort( pInb->c.version.MajorVersion );
        ByteSwapShort( pInb->c.version.MinorVersion );
        ByteSwapLong( pInb->c.flags );
        // ByteSwapLong( pInb->c.reserved1 );
        ByteSwapLong( pInb->c.cid.Data1 );
        ByteSwapShort( pInb->c.cid.Data2 );
        ByteSwapShort( pInb->c.cid.Data3 );
    }
}

/***************************************************************************/
void ByteSwapThat( DWORD drep, WireThat *pOutb )
{
    if ((drep & NDR_INT_REP_MASK) != NDR_LOCAL_ENDIAN)
    {
        // Extensions are swapped later.
        ByteSwapLong( pOutb->c.flags );
    }
}

//+-------------------------------------------------------------------
//
//  Function:   CChannelHandle::AddRef
//
//  Synopsis:   Increase reference count on object.
//
//--------------------------------------------------------------------
void CChannelHandle::AddRef()
{
    InterlockedIncrement( (long *) &_cRef );
}

//+-------------------------------------------------------------------
//
//  Function:   CChannelHandle::AdjustToken
//
//  Synopsis:   Adjust the thread token to the one RPC needs to see
//              to get the DCOM cloaking model.  The cases are as
//              follows.
//
//              Cross apartment
//                  Do nothing
//
//              Cross machine and cross process
//                  Set Blanket
//                      If no cloaking, set NULL token
//                      Else do nothing
//                  SendReceive
//                      Do nothing
//
//--------------------------------------------------------------------
void CChannelHandle::AdjustToken( DWORD dwCase, BOOL *pResume, HANDLE *pThread )
{
    // Return if cross apartment.
    *pResume = FALSE;
    if (pThread != NULL)
        *pThread = NULL;
    if (_eState & process_local_hs)
        return;

    // Handle the set blanket cases.
    if (dwCase == SET_BLANKET_AT)
    {

        // Set the thread token NULL for cross machine no cloaking.
        {
            if ((_eState & any_cloaking_hs) == 0)
            {
                // Return the current thread token.
                OpenThreadToken( GetCurrentThread(), TOKEN_IMPERSONATE,
                                 TRUE, pThread );

                // Set the thread token NULL.
                if (*pThread != NULL)
                {
                    SetThreadToken( NULL, NULL );
                    *pResume = TRUE;
                }
            }
        }
    }

//              Cross process
//                  SendReceive
//                      If static cloaking, set saved token
//                      If no cloaking, set NULL token
//                      If dynamic cloaking, do nothing

    // Handle the send receive cases.
    else if (_eState & machine_local_hs)
    {

        // Set the thread token NULL for no cloaking machine local.
        if ((_eState & any_cloaking_hs) == 0)
        {
            // Return the current thread token.
            OpenThreadToken( GetCurrentThread(), TOKEN_IMPERSONATE,
                             TRUE, pThread );

            // Set the thread token NULL.
            if (*pThread != NULL)
            {
                SetThreadToken( NULL, NULL );
                *pResume = TRUE;
            }
        }
    }
}

//+-------------------------------------------------------------------
//
//  Function:   CChannelHandle::CChannelHandle
//
//  Synopsis:   Construct a channel handle.
//
//--------------------------------------------------------------------
CChannelHandle::CChannelHandle( DWORD lAuthn, DWORD lImp,
                                DWORD dwCapabilities, OXIDEntry *pOXIDEntry,
                                DWORD eChannel, HRESULT *phr )
{
    RPC_STATUS      status = RPC_S_OK;

    // Initialize the members.
    _hRpc       = NULL;
    _hToken     = NULL;
    _lAuthn     = lAuthn;
    _lImp       = lImp;
    _cRef       = 1;
    _fFirstCall = TRUE;
    _eState     = 0;

    if (dwCapabilities & EOAC_STATIC_CLOAKING)
        _eState |= static_cloaking_hs;
    if (dwCapabilities & EOAC_DYNAMIC_CLOAKING)
        _eState |= dynamic_cloaking_hs;
    if (eChannel & process_local_cs)
        _eState |= process_local_hs;
    else if (pOXIDEntry->IsOnLocalMachine())
        _eState |= machine_local_hs;
    if (eChannel & app_security_cs)
        _eState |= app_security_hs;

    // For process local handles, get a token.
    *phr = S_OK;
    if (eChannel & process_local_cs)
    {
        // Only save the token if authentication and static cloaking are enabled.
        if (lAuthn != RPC_C_AUTHN_LEVEL_NONE &&
            (_eState & static_cloaking_hs))
            *phr = OpenThreadTokenAtLevel( _lImp, &_hToken );
    }

    // For remote handles get an RPC binding handle.
    else
    {
        // If the OXID has a binding handle, copy it.
        if (pOXIDEntry->_pRpc != NULL)
            status = RpcBindingCopy(pOXIDEntry->_pRpc->_hRpc, &_hRpc);

        // Otherwise create a binding handle from the OXID string bindings.
        else
            status = RpcBindingFromStringBinding((TCHAR *)pOXIDEntry->GetBinding()->aStringArray,
                                                  &_hRpc );
        // Turn off serialization.
        if (status == RPC_S_OK)
            status = RpcBindingSetOption( _hRpc, RPC_C_OPT_BINDING_NONCAUSAL,
                                          TRUE );
        if (status != RPC_S_OK)
            *phr = MAKE_WIN32(status);
    }
}

//+-------------------------------------------------------------------
//
//  Function:   CChannelHandle::CChannelHandle
//
//  Synopsis:   Copy a channel handle for a local call with dynamic
//              impersonation.  The copied channel contains the new
//              thread token.
//
//--------------------------------------------------------------------
CChannelHandle::CChannelHandle( CChannelHandle *pOrig, DWORD eChannel,
                                HRESULT *phr )
{
    // Copy the members.
    Win4Assert( pOrig->_eState & dynamic_cloaking_hs );
    Win4Assert( pOrig->_eState & process_local_hs );
    Win4Assert( pOrig->_lAuthn != RPC_C_AUTHN_LEVEL_NONE );

    _hRpc   = NULL;
    _hToken = NULL;
    _lAuthn = pOrig->_lAuthn;
    _lImp   = pOrig->_lImp;
    _eState = pOrig->_eState & ~(allow_hs | deny_hs);
    _cRef   = 1;

    // Get a token.
    *phr = OpenThreadTokenAtLevel( _lImp, &_hToken );
}

//+-------------------------------------------------------------------
//
//  Function:   CChannelHandle::~CChannelHandle
//
//  Synopsis:   Destroy a channel handle.
//
//--------------------------------------------------------------------
CChannelHandle::~CChannelHandle()
{
    if (_hRpc != NULL)
        RpcBindingFree( &_hRpc );
    if (_hToken != NULL)
        CloseHandle( _hToken );
}

//+-------------------------------------------------------------------
//
//  Function:   CChannelHandle::Release
//
//  Synopsis:   Decrease reference count on object and delete if zero.
//
//--------------------------------------------------------------------
void CChannelHandle::Release()
{
    if (InterlockedDecrement( (long*) &_cRef ) == 0)
        delete this;
}

//+-------------------------------------------------------------------
//
//  Function:   CChannelHandle::RestoreToken
//
//  Synopsis:   If the resume flag is true, set the thread token to the
//              specified token.
//
//--------------------------------------------------------------------
void CChannelHandle::RestoreToken( BOOL fResume, HANDLE hThread )
{
    if (fResume)
    {
        SetThreadToken( NULL, hThread );
        if (hThread != NULL)
            CloseHandle( hThread );
    }
}

//+-------------------------------------------------------------------
//
//  Function:   ChannelProcessInitialize, public
//
//  Synopsis:   Initializes the channel subsystem per process data.
//
//  History:    23-Nov-93   AlexMit        Created
//
//--------------------------------------------------------------------
STDAPI ChannelProcessInitialize()
{
    TRACECALL(TRACE_RPC, "ChannelProcessInitialize");
    ComDebOut((DEB_COMPOBJ, "ChannelProcessInitialize [IN]\n"));

    // check if already initialized
    if (gfChannelProcessInitialized)
        return S_OK;

    // Dont want to do process-wide channel initialization from the
    // NA - dont know what all might be affected.  So if thread is
    // in the NA, switch it out and switch it back on the way out.

    BOOL fRestoreThreadToNA = IsThreadInNTA();
    COleTls Tls;
    CObjectContext *pSavedCtx;
    CObjectContext *pDefaultCtx = IsSTAThread() ? Tls->pNativeCtx : g_pMTAEmptyCtx;
    if (fRestoreThreadToNA)
        pSavedCtx = LeaveNTA(pDefaultCtx);

    Win4Assert( (sizeof(WireThisPart1) & 7) == 0 );
    Win4Assert( (sizeof(WireThisPart2) & 7) == 0 );
    Win4Assert( (sizeof(LocalThis) & 7) == 0 );
    Win4Assert( (sizeof(WireThatPart1) & 7) == 0 );
    Win4Assert( (sizeof(WireThatPart2) & 7) == 0 );

    // we want to take the gChannelInitLock since that prevents other Rpc
    // threads from accessing anything we are about to create, in
    // particular, the event cache and CMessageCall cache are accessed
    // by Rpc worker threads of cancelled calls.

    // Initialize policy set table
    CPSTable::Initialize();

    ASSERT_LOCK_NOT_HELD(gChannelInitLock);
    LOCK(gChannelInitLock);

    HRESULT hr = S_OK;

    if (!gfChannelProcessInitialized)
    {
        // Initialize the interface hash tables, the OID hash table, and
        // the MID hash table. We dont need to cleanup these on errors.

        gMIDTbl.Initialize();
        gOXIDTbl.Initialize();
        gRIFTbl.Initialize();
        gIPIDTbl.Initialize();
        gSRFTbl.Initialize();
        gGIPTbl.Initialize();
        gROIDTbl.Initialize();
        CServerSecurity::Initialize();

        // ronans - initialize endpoints table
        gEndpointsTable.Initialize();

        // Initialize CtxComChnl
        CCtxComChnl::Initialize(sizeof(CCtxComChnl));

        // Register the debug channel hook.
        hr = CoRegisterChannelHook( DEBUG_EXTENSION, &gDebugHook );

        // Register the error channel hook.
        if(SUCCEEDED(hr))
        {
            hr = CoRegisterChannelHook( ERROR_EXTENSION, &gErrorHook );
        }

        // Register the context hook.
        if(SUCCEEDED(hr))
        {
            hr = CoRegisterChannelHook( CONTEXT_EXTENSION, &gCtxHook );
        }

        // initialize the rest of the channel hooks
        InitHooksIfNecessary();

        // Initialize security.
        if (SUCCEEDED(hr))
        {
#if 0 // #ifdef _CHICAGO_
            if (gfThisIsRPCSS)
                hr = CoInitializeSecurity( NULL, -1, NULL, NULL,
                                           RPC_C_AUTHN_LEVEL_NONE,
                                           RPC_C_IMP_LEVEL_IMPERSONATE,
                                           NULL, EOAC_NONE, NULL );
            else
#endif
                hr = InitializeSecurity();
        }

        // Make sure lrpc has been registered.
        if (SUCCEEDED(hr))
            hr = CheckLrpc();

        // Initialize COM events reporting
        LogEventInitialize();

        // always set to TRUE if we initialized ANYTHING, regardless of
        // whether there were any errors. That way, ChannelProcessUninit
        // will cleanup anything we have initialized.
        gfChannelProcessInitialized = TRUE;

        if (FAILED(hr))
        {
            // cleanup anything we have created thus far. Do this without
            // releasing the lock since we want to ensure that another
            // thread blocked above waiting on the lock does not get to
            // run and think the channel is initialized.
            ChannelProcessUninitialize();
        }
    }

    UNLOCK(gChannelInitLock);
    ASSERT_LOCK_NOT_HELD(gChannelInitLock);

    if (fRestoreThreadToNA)
    {
        pSavedCtx = EnterNTA(pSavedCtx);
        Win4Assert(pSavedCtx == pDefaultCtx);
    }

    ComDebOut((DEB_COMPOBJ, "ChannelProcessInitialize [OUT] hr:%x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   ChannelProcessUninitialize, public
//
//  Synopsis:   Uninitializes the channel subsystem global data.
//
//  History:    23-Nov-93   Rickhi       Created
//              12-Feb-98   JohnStra     Made NTA aware
//
//  Notes:      This is called at process uninitialize, not thread
//              uninitialize.
//
//--------------------------------------------------------------------
STDAPI_(void) ChannelProcessUninitialize(void)
{
    TRACECALL(TRACE_RPC, "ChannelProcessUninitialize");
    ComDebOut((DEB_COMPOBJ, "ChannelProcessUninitialize [IN]\n"));

    // Note: This function may have been called by ChannelProcessInitialize
    // if the Initialization failed. In that case, the lock will still be
    // held. We need to do this to ensure that Init and cleanup on failure
    // is an atomic operation.
    ASSERT_LOCK_DONTCARE(gChannelInitLock);

    // revoke any entries still in the GIP table before taking
    // the lock (with exception for failed Init as indicated above).
    gGIPTbl.RevokeAllEntries();

    if (gfChannelProcessInitialized)
    {
        // Stop accepting calls from the object resolver and flag that service
        // is no longer initialized.  This can result in calls being
        // dispatched.  Do not hold the lock around this call.

        UnregisterDcomInterfaces();
    }

#if 1 // #ifndef _CHICAGO_
    gResolver.ReleaseSCMProxy();
#else
    ReleaseRPCSSProxy();
#endif

    // we want to take the ChannelInitLock since that prevents other Rpc
    // threads from accessing anything we are about to cleanup, in
    // particular, the event cache and CMessageCall are accessed by
    // Rpc worker threads for cancelled calls.
    ASSERT_LOCK_DONTCARE(gChannelInitLock);
    LOCK(gChannelInitLock);

    if (gfChannelProcessInitialized)
    {
        // Uninitialize COM events reporting.
        LogEventCleanup();

        // Release the interface tables.  This causes RPC to stop dispatching
        // DCOM calls. This can result in calls being dispatched, thus we can't
        // be holding other Locks around this. UnRegisterServerInterface
        // releases and reaquires the riftable lock each time it is called.

        gRIFTbl.Cleanup();

        // Stop the MTA and NTA apartment remoting. Do this after the RIFTble
        // cleanup so we are not processing any calls while it happens.
        if (gpMTAApartment)
        {
            gpMTAApartment->CleanupRemoting();
        }
        if (gpNTAApartment)
        {
            gpNTAApartment->CleanupRemoting();
        }

        // cleanup the GIP, IPID, OXID, and MID tables
        gGIPTbl.Cleanup();
        CRefCache::Cleanup();
        gOXIDTbl.FreeExpiredEntries(GetTickCount()+1);
        gIPIDTbl.Cleanup();
        gOXIDTbl.Cleanup();
        gMIDTbl.Cleanup();
        gSRFTbl.Cleanup();

        if (gpsaCurrentProcess)
        {
            // delete the string bindings for the current process
            PrivMemFree(gpsaCurrentProcess);
            gpsaCurrentProcess = NULL;
        }

        // cleanup endpoints table
        gEndpointsTable.Cleanup();

        // Cleanup the OID registration table.
        gROIDTbl.Cleanup();

        // Cleanup the call caches.
        CAsyncCall::Cleanup();
        CClientCall::Cleanup();
        CServerSecurity::Cleanup();
        gCallTbl.Cleanup();

        // Release all cached threads.
        gRpcThreadCache.ClearFreeList();

        // cleanup the event cache
        gEventCache.Cleanup();

        // Cleanup the channel hooks.
        CleanupChannelHooks();

        // Cleanup CtxComChnl
        CCtxComChnl::Cleanup();
    }

    // Free the comsvcs dll if the handle is still non-null
    HINSTANCE hComSvc = (HINSTANCE) InterlockedExchangePointer((PVOID *)&g_hComSvcs, NULL);

    if(hComSvc)
    {
        FreeLibrary(hComSvc);
        hComSvc = NULL;
    }

    // Always cleanup the RPC OXID resolver since security may initialize it.
    gResolver.Cleanup();

    // Cleanup security.
    UninitializeSecurity();

    // mark the channel as no longer intialized for this process
    gfChannelProcessInitialized = FALSE;

    // Cleanup contexts related stuff
    CObjectContext::Cleanup();

    // release the static unmarshaler
    if (gpStdMarshal)
    {
        ((CStdIdentity *) gpStdMarshal)->UnlockAndRelease();
        gpStdMarshal = NULL;
    }

    // Release the lock
    UNLOCK(gChannelInitLock);
    ASSERT_LOCK_DONTCARE(gChannelInitLock);

    // Cleanup policy set table
    CPSTable::Cleanup();

    ComDebOut((DEB_COMPOBJ, "ChannelProcessUninitialize [OUT]\n"));
    return;
}

//+-------------------------------------------------------------------
//
//  Function:   ChannelThreadUninitialize, private
//
//  Synopsis:   Uninitializes the channel subsystem per thread data.
//
//  History:    23-Nov-93   Rickhi       Created
//              12-Feb-98   JohnStra     Made NTA aware
//
//  Notes:      This is called at thread uninitialize, not process
//              uninitialize.
//
//--------------------------------------------------------------------
STDAPI_(void) ChannelThreadUninitialize(void)
{
    TRACECALL(TRACE_RPC, "ChannelThreadUninitialize");
    ComDebOut((DEB_COMPOBJ, "ChannelThreadUninitialize [IN]\n"));

    // release the per-thread call objects if any
    COleTls tls;
    CleanupThreadCallObjects(tls);

    // release the remoting stuff for this apartment
    CComApartment *pComApt = NULL;
    if (SUCCEEDED(GetCurrentComApartment(&pComApt)))
    {
        pComApt->CleanupRemoting();
        pComApt->Release();
    }

    APTKIND AptKind = GetCurrentApartmentKind(tls);
    if (AptKind != APTKIND_NEUTRALTHREADED)
    {
        // Cleanup policy set table for this thread
        gPSTable.ThreadCleanup(TRUE);
    }

    // mark the thread as no longer intialized for the channel
    tls->dwFlags &= ~OLETLS_CHANNELTHREADINITIALZED;

    ComDebOut((DEB_COMPOBJ, "ChannelThreadUninitialize [OUT]\n"));
}

//+-------------------------------------------------------------------
//
//  Function:   CleanupThreadCallObjects, public
//
//  Synopsis:   Deletes each call object held in TLS cache. Called
//              during ChannelThreadUnintialize or THREAD_DETACH.
//
//+-------------------------------------------------------------------
INTERNAL_(void) CleanupThreadCallObjects(SOleTlsData *pTls)
{
    if (pTls->pFreeClientCall)
    {
        CClientCall* pCallToDelete = pTls->pFreeClientCall;
        pTls->pFreeClientCall = NULL;
        delete pCallToDelete;
    }

    if (pTls->pFreeAsyncCall)
    {
        CAsyncCall* pCallToDelete = pTls->pFreeAsyncCall;
        pTls->pFreeAsyncCall = NULL;
        delete pCallToDelete;
    }
}

//+-------------------------------------------------------------------
//
//  Function:   InitChannelIfNecessary, private
//
//  Synopsis:   Checks if the ORPC channel has been initialized for
//              the current apartment and initializes if not. This is
//              required by the delayed initialization logic.
//
//  History:    26-Oct-95   Rickhi      Created
//
//--------------------------------------------------------------------
INTERNAL InitChannelIfNecessary()
{
    ASSERT_LOCK_NOT_HELD(gComLock);

    // get the current apartment and start it listening
    CComApartment *pComApt;
    HRESULT hr = GetCurrentComApartment(&pComApt);
    if (SUCCEEDED(hr))
    {
        hr = pComApt->StartServer();
        pComApt->Release();
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    return hr;
}


/***************************************************************************/
STDMETHODIMP_(ULONG) CRpcChannelBuffer::AddRef( THIS )
{
    // can't call AssertValid(FALSE) since it is used in asserts
    return InterlockedIncrement( (long *) &_cRefs );
}

/***************************************************************************/
HRESULT AppInvoke( CMessageCall      *pCall,
                   CRpcChannelBuffer *pChannel,
                   IRpcStubBuffer    *pStub,
                   void              *pv,
                   void              *pStubBuffer,
                   IPIDEntry         *pIPIDEntry,
                   LocalThis         *pLocalb)
{
    ASSERT_LOCK_NOT_HELD(gComLock);

    RPCOLEMESSAGE   *pMessage        = &pCall->message;
    void            *pDispatchBuffer = pMessage->Buffer;
    WireThat        *pOutb           = NULL;
    HRESULT          hresult;
    DWORD            dwFault;

    // Save a pointer to the inbound header.
    pCall->_pHeader = pMessage->Buffer;

    // Adjust the buffer.
    pMessage->cbBuffer  -= (ULONG) ((char *) pStubBuffer - (char *) pMessage->Buffer);
    pMessage->Buffer     = pStubBuffer;
    pMessage->iMethod   &= ~RPC_FLAGS_VALID_BIT;
    pMessage->reserved1  = pCall;

    // if the incoming call is from a non-NDR client, then set a bit in
    // the message flags field so the stub can figure out how to dispatch
    // the call.  This allows a 32bit server to simultaneously service a
    // 32bit client using NDR and a 16bit client using non-NDR, in particular,
    // to support OLE Automation.
    if (pLocalb != NULL && pLocalb->flags & LOCALF_NONNDR)
      pMessage->rpcFlags |= RPCFLG_NON_NDR;

    if (IsMTAThread() || IsThreadInNTA())
    {
        // do multi-threaded apartment invoke
        hresult = MTAInvoke( pMessage, GetCallCat( pCall->_pHeader ),
                             pStub, pChannel, pIPIDEntry, &dwFault );
    }
    else
    {
        // do single-threaded apartment invoke
        hresult = STAInvoke( pMessage, GetCallCat( pCall->_pHeader ),
                             pStub, pChannel, pv, pIPIDEntry, &dwFault );
    }

    // Don't do anything for async calls.
    ASSERT_LOCK_NOT_HELD(gComLock);
    if (pCall->ServerAsync())
        return S_OK;

    pCall->SetFault(dwFault);

    // For local calls, just free the in buffer. For non-local calls,
    // the RPC runtime does this for us.
    if (pMessage->rpcFlags & RPCFLG_LOCAL_CALL)
    {
         PrivMemFree8( pDispatchBuffer );
         pDispatchBuffer = NULL;

         // Set the complete bit.
         pMessage->rpcFlags |= RPC_BUFFER_COMPLETE;
    }

    // Find the header if a new buffer was returned.
    if (pMessage->Buffer != pStubBuffer && pMessage->Buffer != NULL)
    {
        // An out buffer exists, get the pointer to the channel header.
        Win4Assert( pCall->_pHeader != pDispatchBuffer );
        pMessage->cbBuffer += (ULONG) ((char *) pMessage->Buffer - (char *) pCall->_pHeader);
        pMessage->Buffer    = pCall->_pHeader;
        pOutb               = (WireThat *) pMessage->Buffer;
    }
    // Restore the pointer to the original buffer.
    else
        pMessage->Buffer = pDispatchBuffer;

    // Handle failures.
    if (hresult != S_OK)
    {
        if (hresult == RPC_E_CALL_REJECTED)
        {
            // Call was rejected.  If the caller is on another machine, just fail the
            // call.
            if (pCall->GetDestCtx() != MSHCTX_DIFFERENTMACHINE && pOutb != NULL)
            {
                // Otherwise return S_OK so the buffer gets back, but set the flag
                // to indicate it was rejected.
                pOutb->c.flags = ORPCF_LOCAL | ORPCF_REJECTED;
                hresult = S_OK;
            }
        }
        else if (hresult == RPC_E_SERVERCALL_RETRYLATER)
        {
            // Call was rejected.  If the caller is on another machine, just fail the
            // call.
            if (pCall->GetDestCtx() != MSHCTX_DIFFERENTMACHINE && pOutb != NULL)
            {
                // Otherwise return S_OK so the buffer gets back, but set the flag
                // to indicate it was rejected with retry later.
                pOutb->c.flags = ORPCF_LOCAL | ORPCF_RETRY_LATER;
                hresult = S_OK;
            }
        }
        // Maybe something should be cleaned up.
        else
        {
            pCall->_pHeader = NULL;
            if (pMessage->Buffer != pDispatchBuffer)
            {
                // call failed and the call is local, free the out buffer. For
                // non-local calls the RPC runtime does this for us.
                if (pMessage->rpcFlags & RPCFLG_LOCAL_CALL)
                    PrivMemFree8( pMessage->Buffer );
            }
        }
    }

    return hresult;
}



//+---------------------------------------------------------------------------
//
//  Function:   SyncStubInvoke
//
//  Synopsis:   Dispatch a call Synchronously
//
//  History:    June 08, 98      Gopalk     Created
//----------------------------------------------------------------------------
HRESULT SyncStubInvoke(RPCOLEMESSAGE *pMsg, REFIID riid,
                       CIDObject *pID, IRpcChannelBuffer *pChnl,
                       IRpcStubBuffer *pStub, DWORD *pdwFault)
{
#ifdef WX86OLE
    if(!gcwx86.IsN2XProxy(pStub))
    {
        IUnknown *pActual;
        HRESULT hr1;

        hr1 = pStub->DebugServerQueryInterface((void **)&pActual);
        if (SUCCEEDED(hr1))
        {
            if (gcwx86.IsN2XProxy(pActual))
            {
                // If we are going to invoke a native stub that is
                // connected to an object on the x86 side then
                // set a flag in the Wx86 thread environment to
                // let the thunk layer know that the call is a
                // stub invoked call and allow any in or out
                // custom interface pointers to be thunked as
                // IUnknown rather than failing the interface thunking
                gcwx86.SetStubInvokeFlag((BOOL)1);
            }
            pStub->DebugServerRelease(pActual);
        }
    }
#endif

    // Increment the call count on the server object
    HRESULT hr = S_OK;
    if(pID)
        hr = pID->IncrementCallCount();

    if(SUCCEEDED(hr))
    {
        _try
        {
            TRACECALL(TRACE_RPC, "SyncStubInvoke");

            hr = pStub->Invoke(pMsg, pChnl);
        }
        _except(AppInvokeExceptionFilter(GetExceptionInformation(), riid, pMsg->iMethod))
        {
            hr = RPC_E_SERVERFAULT;
            *pdwFault = GetExceptionCode();
        }

        // Unlock the server
        if(pID)
            pID->DecrementCallCount();
    }

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   AsyncStubInvoke
//
//  Synopsis:   Dispatch a call Asynchronously
//
//  History:    June 08, 98      Gopalk     Rewritten to handle server
//                                          exceptions and server lifetime
//                                          issues
//----------------------------------------------------------------------------
HRESULT AsyncStubInvoke(RPCOLEMESSAGE *pMsg, REFIID riid, CStdIdentity *pStdID,
                        IRpcChannelBuffer *pChnl, IRpcStubBuffer *pStub,
                        IPIDEntry *pIPIDEntry, DWORD *pdwFault, HRESULT *pAsyncHr)
{
    // Determine if the server supports async functionality
    CRpcChannelBuffer::CServerCallMgr *pStubAsync = NULL;
    HRESULT hr = CO_E_NOT_SUPPORTED;
    *pAsyncHr = hr;
    CMessageCall *_pCall  = (CMessageCall *) pMsg->reserved1;

    if((pIPIDEntry != NULL) /* DDE call */ &&
       _pCall->GetCallCategory() != CALLCAT_INPUTSYNC /* not input-sync call*/ &&
       (pStdID->GetServerPolicySet() == NULL) /* Default context */ &&
       ((!(pIPIDEntry->dwFlags & IPIDF_TRIED_ASYNC) /* not sure yet */) ||
        (pIPIDEntry->dwFlags & IPIDF_ASYNC_SERVER) /* definitely async */))
    {
        // Try creating an async call manager object
        hr = GetChannelCallMgr(pMsg, pStub, (IUnknown *)pIPIDEntry->pv, &pStubAsync);

        // Update the IPID about succeess or failure
        if(SUCCEEDED(hr))
        {
            // Sanity check
            Win4Assert(pStubAsync);
            pIPIDEntry->dwFlags |= (IPIDF_TRIED_ASYNC | IPIDF_ASYNC_SERVER);

            // Transfer context call object from TLS to async call object
            CCtxCall *pCtxCall = new CCtxCall(((CMessageCall *) pMsg->reserved1)->GetServerCtxCall());
            if(pCtxCall)
                pStubAsync->GetCall()->SetServerCtxCall(pCtxCall);
            else
                hr = E_OUTOFMEMORY;
            if(SUCCEEDED(hr))
            {
                CRpcChannelBuffer *pCChnl = CRpcChannelBuffer::SafeCast(pChnl);
                hr = pCChnl->RegisterAsync(pMsg, NULL);
                if(SUCCEEDED(hr))
                {
                    // Increment call count
                    CIDObject *pID = pStdID->GetIDObject();
                    if(pID)
                        hr = pID->IncrementCallCount();
                    if(SUCCEEDED(hr))
                    {
                        // AddRef async call object
                        pStubAsync->AddRef();

                        // Set the StdID on the async call mgr
                        pStubAsync->SetStdID(pStdID);

                        // Lock server
                        pStdID->RelockServer();

                        if(SUCCEEDED(hr))
                        {
                            // Call successfully registered as async. Invoke the begin method
                            ComDebOut((DEB_CHANNEL,
                                       "StubInvoke:: dispatching call asynchronously\n"));

                            _try
                            {
                                // Dispatch asynchronously
                                hr = pStubAsync->Invoke(pMsg, pChnl);
                            }
                            _except(AppInvokeExceptionFilter(GetExceptionInformation(),
                                                             riid, pMsg->iMethod))
                            {
                                hr = RPC_E_SERVERFAULT;
                                *pdwFault = GetExceptionCode();
                            }
                        }

                        // Check for failure
                        if(FAILED(hr))
                        {
                            // CODEWORK:: This type of error checking can be
                            // accomplished much more clearly by getting between
                            // the channel and the stub call object.

                            ComDebOut((DEB_CHANNEL,
                                       "StubInvoke:: invoke on async call object "
                                       "failed! hr = 0x%x\n",
                                       hr));

                            // Inform async call manager about failure returns
                            pStubAsync->MarkError(hr);
                        }
                    }
                }
            }
            // Pass real HRESULT to StubInvoke
            *pAsyncHr = hr;
            hr = S_OK;

            // Release async call object
            pStubAsync->Release();
        }
        else
        {
            hr = CO_E_NOT_SUPPORTED; //Force Async call not supported
            if(!(pIPIDEntry->dwFlags & IPIDF_TRIED_ASYNC))
            {
                // Sanity check
                Win4Assert(pStubAsync == NULL);
                pIPIDEntry->dwFlags |= IPIDF_TRIED_ASYNC;
            }
        }
    }

    return hr;
}


/***************************************************************************/
#if DBG == 1
DWORD AppInvoke_break = 0;
DWORD AppInvoke_count = 0;
#endif

HRESULT StubInvoke(RPCOLEMESSAGE *pMsg, CStdIdentity *pStdID,
                   IRpcStubBuffer *pStub, IRpcChannelBuffer *pChnl,
                   IPIDEntry *pIPIDEntry, DWORD *pdwFault)
{
    ComDebOut((DEB_CHANNEL, "StubInvoke pMsg:%x pStub:%x pChnl:%x pIPIDEntry:%x pdwFault:%x\n",
        pMsg, pStub, pChnl, pIPIDEntry, pdwFault));
    ASSERT_LOCK_NOT_HELD(gComLock);

    REFIID riid = pMsg->reserved2[1] ? *MSG_TO_IIDPTR(pMsg) : GUID_NULL;

#if DBG==1
    // Output debug statements
    ComDebOut((DEB_CHANNEL, "StubInvoke on iid:%I, iMethod:%d\n", &riid, pMsg->iMethod));
    Win4Assert((riid != IID_AsyncIAdviseSink) && (riid != IID_AsyncIAdviseSink));

    // On a debug build, we are able to break on a call by serial number.
    // This isn't really 100% thread safe, but is still extremely useful
    // when debugging a problem.
    DWORD dwBreakCount = ++AppInvoke_count;
    ComDebOut((DEB_CHANNEL, "AppInvoke(0x%x) calling method 0x%x iid %I\n",
               dwBreakCount, pMsg->iMethod, &riid));
    if(AppInvoke_break == dwBreakCount)
    {
        DebugBreak();
    }
#endif

    //
    // if VISTA event logging is turned on, log the call event.
    //
    ULONG_PTR RpcValues[6];     // LogEventStubException has one more argument
    BOOL fLogEventIsActive = pIPIDEntry && LogEventIsActive();
    if(fLogEventIsActive)
    {
        RpcValues[0] = (ULONG_PTR) &pIPIDEntry->ipid;   // Target handle
        RpcValues[1] = (ULONG_PTR) pIPIDEntry->pOXIDEntry->GetMoxidPtr(); // Apartment ID
        RpcValues[2] = (ULONG_PTR) &pMsg;                   // CorrelationID
        RpcValues[3] = (ULONG_PTR) &riid;         // IID
        RpcValues[4] = (ULONG_PTR) pMsg->iMethod;           // Method index

        // Log event before call into server
        LogEventStubEnter(RpcValues);
    }

    // Try dispatching the call asynchronously
    HRESULT hrAsync = S_OK;
    HRESULT hr = AsyncStubInvoke(pMsg, riid, pStdID, pChnl, pStub,
                                 pIPIDEntry, pdwFault, &hrAsync);
    if(hr == CO_E_NOT_SUPPORTED)
    {
        // Dispatch synchronously
        hr = SyncStubInvoke(pMsg, riid,
                            pStdID ? pStdID->GetIDObject() : NULL,
                            pChnl, pStub, pdwFault);
    }
    else
    {
        //Assert that Async call was attempted
        Win4Assert((hr==S_OK));
        // Async call was attempted, use that HRESULT
        hr = hrAsync;
    }

    if(fLogEventIsActive)
    {
        // Log event after return from server
        if(hr == RPC_E_SERVERFAULT)
        {
            RpcValues[5] = (ULONG_PTR) *pdwFault;
            LogEventStubException(RpcValues);
        }
        else
        {
            LogEventStubLeave(RpcValues);
        }
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ComDebOut((DEB_CHANNEL, "StubInvoke hr:%x dwFault:%x\n", hr, *pdwFault));
    return hr;
}


/***************************************************************************/
HRESULT ComInvoke( CMessageCall *pCall)
{
    ComDebOut((DEB_CHANNEL, "ComInvoke pCall:%x\n", pCall));
    HRESULT hr = RPC_E_SERVER_DIED_DNE;
    IPIDEntry *pIPIDEntry = NULL;
    OXIDEntry *pOXIDEntry = NULL;
    HANDLE hSxsActCtx = INVALID_HANDLE_VALUE;
    ULONG_PTR ulActCtxCookie;
    BOOL fActivated = FALSE;

#if DBG == 1
    // Catch exceptions that might keep the lock.
    _try
    {
#endif
        ASSERT_LOCK_NOT_HELD(gIPIDLock);
        LOCK(gIPIDLock);

        // Find the IPID entry.  Fail if the IPID or the OXID are not ready.
        // If OK to dispatch, the OXIDEntry returned is AddRef'd.
        hr = gIPIDTbl.LookupFromIPIDTables(pCall->GetIPID(), &pIPIDEntry, &pOXIDEntry);
        if (SUCCEEDED(hr))
        {
            // Dispatch the call. This subroutine releases the lock
            // Get and activate sxs context if we're activating in-process
            if ((hSxsActCtx = pCall->GetSxsActCtx()) != INVALID_HANDLE_VALUE)
                fActivated = ActivateActCtx(hSxsActCtx, &ulActCtxCookie);

            // before returning.
            hr = ComInvokeWithLockAndIPID(pCall, pIPIDEntry);
            ASSERT_LOCK_NOT_HELD(gIPIDLock);

            // If we activated, deactivate.
            if (fActivated && !DeactivateActCtx(0, ulActCtxCookie))
                hr = HRESULT_FROM_WIN32(GetLastError());

            // release the OXIDEntry.
            pOXIDEntry->DecRefCnt();
        }
        else
        {
            UNLOCK(gIPIDLock);
            ASSERT_LOCK_NOT_HELD(gIPIDLock);

            Win4Assert(hr == RPC_E_DISCONNECTED ||
                       hr == E_NOINTERFACE);
        }

  // Catch exceptions that might keep the lock.
#if DBG == 1
    }
    _except( ComInvokeExceptionFilter(GetExceptionCode(),
                                      GetExceptionInformation()) )
    {
    }
#endif

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    ComDebOut((DEB_CHANNEL, "ComInvoke pCall:%x hr:%x\n", pCall, hr));
    return hr;
}

/***************************************************************************/
HRESULT ComInvokeWithLockAndIPID(CMessageCall *pCall, IPIDEntry *pIPIDEntry)
{
    ComDebOut((DEB_CHANNEL, "ComInvokeWithLockAndIPID call:%x header:%x\n",
               pCall, pCall->message.Buffer));
    ASSERT_LOCK_HELD(gIPIDLock);
    Win4Assert(pIPIDEntry);

    // while still holding gIPIDLock, do the bare minimum amount of work
    // necessary to keep the object and apartment alive, then release the
    // lock and go on to do the rest of the work.

    // Ensure TLS is intialized, as EnterNTA requires it.
    HRESULT result;
    COleTls tls(result);
    if (FAILED(result))
    {
        UNLOCK(gIPIDLock);
        return CO_E_INIT_TLS;
    }

    // Tell the OXID there is one more incoming call. This keeps the OXID
    // object alive during the call.
    OXIDEntry *pOXIDEntry = pIPIDEntry->pOXIDEntry;
    pOXIDEntry->IncCallCnt();

    // If the server is in the NA, switch the thread to the NA.
    BOOL fSwitchedToNA = FALSE;
    BOOL fSwitchedFromNA = FALSE;
    CObjectContext *pDefaultCtx;
    CObjectContext *pSavedCtx;
    if (pOXIDEntry->IsNTAServer())
    {
        if (!IsThreadInNTA())
        {
            pSavedCtx = EnterNTA(g_pNTAEmptyCtx);
            fSwitchedToNA = TRUE;
        }
    }
    else
    {
        if (IsThreadInNTA())
        {
            pDefaultCtx = IsSTAThread() ? tls->pNativeCtx : g_pMTAEmptyCtx;
            pSavedCtx = LeaveNTA(pDefaultCtx);
            fSwitchedFromNA = TRUE;
        }
    }

    // Lock StdID
    CRpcChannelBuffer *pChannel = pIPIDEntry->pChnl;
    Win4Assert( pChannel != NULL && pChannel->_pStdId != NULL );
    pChannel->_pStdId->LockServer();

    // We don't need the lock anymore, so release it.
    UNLOCK(gIPIDLock);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // Ensure this thread has a causality ID. Do this before
    // CServerSecurity has a chance to autoimpersonate because UUIDCreate
    // can access the registry.
    if (!(tls->dwFlags & OLETLS_UUIDINITIALIZED))
    {
        RPC_STATUS st = UuidCreate(&tls->LogicalThreadId);
        Win4Assert(SUCCEEDED(st));
        tls->dwFlags |= OLETLS_UUIDINITIALIZED;
    }

    // Increment per thread outstanding call count
    ++tls->cCalls;

    RPCOLEMESSAGE *pMessage = &pCall->message;

    // Create a security object which may do auto impersonation now.
    result = E_OUTOFMEMORY;
    CServerSecurity *security = new CServerSecurity(pCall, pMessage->reserved1, &result);
    if(FAILED(result))
    {
        if (security)
            security->RestoreSecurity( TRUE );
    }
    else
    {
        WireThis   *pInb = (WireThis *) pMessage->Buffer;
        LocalThis  *localb;
        BOOL fSetDispatchThread = FALSE;

        // Save the original threadid & copy in the new one.
        UUID saved_threadid   = tls->LogicalThreadId;
        tls->LogicalThreadId  = pInb->c.cid;
        ComDebOut((DEB_CALLCONT, "ComInvoke: LogicalThreads Old:%I New:%I\n",
            &saved_threadid, &tls->LogicalThreadId));

        // Ensure dispatch threads are marked
        if(!(tls->dwFlags & (OLETLS_APARTMENTTHREADED |
                             OLETLS_MULTITHREADED |
                             OLETLS_DISPATCHTHREAD)))
        {
            fSetDispatchThread = TRUE;
            tls->dwFlags |= OLETLS_DISPATCHTHREAD;
        }
        BOOL fDispThread = (tls->dwFlags & OLETLS_DISPATCHTHREAD);
        Win4Assert(!fDispThread || tls->cComInits==0);

        // Save the security context in TLS.
        IUnknown *save_context = tls->pCallContext;
        tls->pCallContext = (IServerSecurity *) security;

        // Save dynamic cloaking flag in CServerSecurity
        security->_fDynamicCloaking = pInb->c.flags & ORPCF_DYNAMIC_CLOAKING;

        // See if the caller is allowed access.
        result = CheckAccess( pIPIDEntry, pCall );
        if (SUCCEEDED(result))
        {
            // Create a new context call object
            CCtxCall ctxCall(CTXCALLFLAG_SERVER, pMessage->dataRepresentation);
            pCall->SetServerCtxCall(&ctxCall);

            // Save the call info in TLS.
            CMessageCall *next_call = tls->pCallInfo;
            tls->pCallInfo          = pCall;

            // Store context call object in TLS
            CCtxCall *pCurCall = ctxCall.StoreInTLS(tls);

            // Call the channel hooks.  Set up as much TLS data as possible before
            // calling the hooks so they can access it.
            char *stub_data;

            pCall->hook.uCausality    = pInb->c.cid;
            pCall->hook.dwServerPid   = pIPIDEntry->pOXIDEntry->GetPid();
            pCall->hook.iMethod       = pMessage->iMethod & ~RPC_FLAGS_VALID_BIT;
            pCall->hook.pObject       = pIPIDEntry->pv;
            result = ServerNotify( (WireThis *) pMessage->Buffer,
                                   pMessage->cbBuffer,
                                   (void **) &stub_data,
                                   pMessage->dataRepresentation,
                                   pCall );

            // Revoke context call object from TLS
            ctxCall.RevokeFromTLS(tls, pCurCall);

            // Find the local header.
            if (pInb->c.flags & ORPCF_LOCAL)
            {
                localb     = (LocalThis *) stub_data;
                stub_data += sizeof( LocalThis );
            }
            else
                localb = NULL;

            // Set the caller TID.  This is needed by some interop code in order
            // to do focus management via tying queues together. We first save the
            // current one so we can restore later to deal with nested calls
            // correctly.
            DWORD TIDCallerSaved  = tls->dwTIDCaller;
            BOOL fLocalSaved      = tls->dwFlags & OLETLS_LOCALTID;
            tls->dwTIDCaller      = localb != NULL ? localb->client_thread : 0;

            // Set the process local flag in TLS.
            if (pCall->ProcessLocal())
              tls->dwFlags |= OLETLS_LOCALTID;
            else
              tls->dwFlags &= ~OLETLS_LOCALTID;

            // Continue dispatching the call.
            if (result == S_OK)
            {
                result = AppInvoke( pCall, pChannel,
                                    (IRpcStubBuffer *) pIPIDEntry->pStub,
                                    pIPIDEntry->pv, stub_data, pIPIDEntry, localb );
            }

            // Restore the call info, dest context and thread id.
            tls->pCallInfo       = next_call;
            tls->dwTIDCaller     = TIDCallerSaved;

            if (fLocalSaved)
                tls->dwFlags |= OLETLS_LOCALTID;
            else
                tls->dwFlags &= ~OLETLS_LOCALTID;
        }

        // Restore the original thread id, security context and revert any
        // outstanding impersonation.
        tls->pCallContext    = save_context;
        security->RestoreSecurity( !pCall->ServerAsync() );
        tls->LogicalThreadId = saved_threadid;

        // Turn off dispatch bit if we set it
        if (fSetDispatchThread)
           tls->dwFlags &= ~OLETLS_DISPATCHTHREAD;

        // Ensure that cancellation is turned off
        // for any pooled threads.
        if (fDispThread)
           tls->cCallCancellation = 0;
    }

    // Unlock StdID
    pChannel->_pStdId->UnlockServer();

    // If we entered or left the NA before dispatching, switch the thread back
    // to its the previous state.
    if (fSwitchedToNA == TRUE)
    {
        pSavedCtx = LeaveNTA(pSavedCtx);
        Win4Assert(pSavedCtx == g_pNTAEmptyCtx);
    }
    else if (fSwitchedFromNA == TRUE)
    {
        pSavedCtx = EnterNTA(pSavedCtx);
        Win4Assert(pSavedCtx == pDefaultCtx);
    }

    // Decrement the call count. Do this *after* calling UnLockServer
    // so the other thread does not blow away the server.
    pOXIDEntry->DecCallCnt();

    // Decrement per thread outstanding call count
    --tls->cCalls;
    Win4Assert((LONG) tls->cCalls >= 0);

    // Clear any pending uninit
    if((tls->dwFlags & OLETLS_PENDINGUNINIT) && (tls->cCalls == 0))
        CoUninitialize();

    if (security != NULL)
    {
        security->Release();
    }

    ComDebOut((DEB_CHANNEL, "ComInvokeWithLockAndIPID pCall:%x hr:%x\n", pCall, result));
    return result;
}


/***************************************************************************/
void CRpcChannelBuffer::UpdateCopy(CRpcChannelBuffer *chan)
{
    Win4Assert( !(state & server_cs) );

    chan->state       = proxy_cs | (state & ~client_cs);

    return;
}

/***************************************************************************

     Method:       CRpcChannelBuffer::GetHandle

     Synopsis:     Pick a handle to use for the call.

     Description:

          If the channel is using standard security, use either the default
     channel handle or the saved channel handle in the OXID.  If the channel
     is using custom security, use the custom channel handle.

     Addref the handle returned because the caller will release it.

     _hRpcDefault starts out NULL and changes once to the default handle.
     There after it does not change until the channel is released.  Thus
     _hRpcDefault can be accessed without holding the lock.

     _hRpcCustom starts out NULL and changes each time someone calls
     SetBlanket.  In a multithreaded apartment, it can change at any\
     moment so take the lock when accessing it.

***************************************************************************/
HRESULT CRpcChannelBuffer::GetHandle( CChannelHandle **ppHandle, BOOL fSave )
{
    HRESULT         result  = S_OK;
    BOOL            fLock   = _pRpcCustom != NULL;
    CChannelHandle *pHandle;

    // If there is a custom channel handle, take the lock because it
    // might be switched while we access it.
    if (fLock)
    {
        LOCK(gComLock);
        pHandle = _pRpcCustom;
    }
    else
        pHandle = _pRpcDefault;

    if (pHandle == NULL)
    {
        // this channel doesn't have a handle, figure out how to get one.
        if ((gCapabilities & EOAC_STATIC_CLOAKING) == 0 && !ProcessLocal())
        {
            // process remote call with no static cloaking, use the OXID handle.
            if (_pOXIDEntry->_pRpc == NULL)
            {
                // no handle on the OXIDEntry yet, create it.
                result = CreateHandle(_pOXIDEntry, state, &pHandle);

                if (InterlockedCompareExchangePointer((void **)&_pOXIDEntry->_pRpc,
                                                       pHandle, NULL) != NULL)
                {
                    // another thread created it first, release the one we just
                    // created and use the other one.
                    pHandle->Release();
                }
            }

            pHandle = _pOXIDEntry->_pRpc;

            // Going to be handing this one back, AddRef it now.
            if (pHandle)
                pHandle->AddRef();
        }
        else
        {
            // process local call or static cloaking, use one handle per proxy.
            result = CreateHandle( _pOXIDEntry, state, &pHandle );

            // Don't save handles created by QueryBlanket since they have
            // the wrong identity.
            if (fSave && SUCCEEDED(result))
            {
                if (InterlockedCompareExchangePointer((void **)&_pRpcDefault,
                                                       pHandle, NULL) != NULL)
                {
                    // another thread created it first, release the one we just
                    // created and use the other one.
                    pHandle->Release();
                    pHandle = _pRpcDefault;
                }

                // Going to be handing this back, AddRef it now.
                if (pHandle)
                    pHandle->AddRef();
            }
            else
            {
                // There's no need to do anything here-- we'll just be
                // giving away the reference we created. (As opposed to
                // putting another reference on the thread.)
                // fAddRef = FALSE;
            }
        }
    }
    else
    {
        pHandle->AddRef();
    }

    if (pHandle != NULL)
    {
        // For dynamic impersonation, get a handle with the current token.
        if (pHandle->_lAuthn != RPC_C_AUTHN_LEVEL_NONE &&
            (pHandle->_eState & (dynamic_cloaking_hs | process_local_hs)) ==
             (dynamic_cloaking_hs | process_local_hs))
        {
            // Save the original handle so it doesn't float away.
            CChannelHandle *pOrig = pHandle;
            // Create a new channel handle...
            pHandle = new CChannelHandle( pOrig, state, &result );
            // Release the original one.
            pOrig->Release();

            if (pHandle == NULL)
                result = E_OUTOFMEMORY;
            else if (FAILED(result))
            {
                pHandle->Release();
                pHandle = NULL;
            }
        }
    }

    // If there is a custom channel handle, the lock was held for this function.
    if (fLock)
        UNLOCK(gComLock);
    *ppHandle = pHandle;

    return result;
}

/***************************************************************************/
HRESULT CreateHandle( OXIDEntry *pOXIDEntry, DWORD eChannel,
                      CChannelHandle **ppHandle )
{
    ASSERT_LOCK_DONTCARE(gComLock);
    HRESULT         result  = S_OK;

    // Create a handle.
    CChannelHandle *pHandle = new CChannelHandle(gAuthnLevel,  gImpLevel,
                                                 gCapabilities, pOXIDEntry,
                                                 eChannel, &result );
    if (pHandle == NULL)
    {
        result = E_OUTOFMEMORY;
    }
    else if (SUCCEEDED(result) && (pHandle->_eState & process_local_hs) == 0)
    {
        // Setup the default security.
        SBlanket        sBlanket;
        HANDLE          hThread = NULL;
        DWORD           lSvcIndex;

        LOCK(gComLock);

        // Compute the default authentication service if unknown,
        // otherwise find the specified one in the bindings
        if (pOXIDEntry->GetAuthnSvc() == RPC_C_AUTHN_DEFAULT)
            lSvcIndex = DefaultAuthnSvc(pOXIDEntry);
        else
            lSvcIndex = GetAuthnSvcIndexForBinding (pOXIDEntry->GetAuthnSvc(),
                                                     pOXIDEntry->GetBinding());

        // Compute the default security blanket.
        sBlanket._lAuthnLevel = RPC_C_AUTHN_LEVEL_DEFAULT;
        result = DefaultBlanket( lSvcIndex, pOXIDEntry, &sBlanket );

        // Only set security for secure or cross process binding handles.
        if (SUCCEEDED(result) &&
            (sBlanket._lAuthnLevel != RPC_C_AUTHN_LEVEL_NONE
             || (pHandle->_eState & machine_local_hs)
            ))
        {
            // If the default authentication level is secure and the
            // server is on another machine, there must be a matching
            // security provider.
            if (pOXIDEntry->GetAuthnSvc() >= pOXIDEntry->GetBinding()->wNumEntries &&
                (!pOXIDEntry->IsOnLocalMachine()))
                result = RPC_E_NO_GOOD_SECURITY_PACKAGES;

            // Remove the thread token for cross machine, no cloaking.
            else if ((pHandle->_eState & any_cloaking_hs) == 0)
                SuspendImpersonate( &hThread );

            // Set the default security on the binding handle.
            if (SUCCEEDED(result))
            {
                // Enable mutual authentication for machine local calls.
                if (sBlanket._pPrincipal != NULL)
                    sBlanket._sQos.Capabilities |= RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH;

                // Sergei O. Ivanov (a-sergiv)  9/17/99  NTBUG #403493
                // Disable mutual auth for SSL. For reasons obscure, this is unavoidable.
                if(sBlanket._lAuthnSvc == RPC_C_AUTHN_GSS_SCHANNEL)
                    sBlanket._sQos.Capabilities &= ~RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH;

                // RPC wants authentication service winnt for
                // unsecure same machine calls.
                if (sBlanket._lAuthnLevel == RPC_C_AUTHN_LEVEL_NONE &&
                    sBlanket._lAuthnSvc   == RPC_C_AUTHN_NONE       &&
                    (pHandle->_eState & machine_local_hs))
                    sBlanket._lAuthnSvc = RPC_C_AUTHN_WINNT;

                result = RpcBindingSetAuthInfoExW(
                                   pHandle->_hRpc,
                                   sBlanket._pPrincipal,
                                   sBlanket._lAuthnLevel,
                                   sBlanket._lAuthnSvc,
                                   sBlanket._pAuthId,
                                   sBlanket._lAuthzSvc,
                                   &sBlanket._sQos );
                if (result != RPC_S_OK)
                    result = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, result );
            }

            // Restore the thread token.
            ResumeImpersonate( hThread );
        }

        UNLOCK(gComLock);
    }

    // If something failed, release the binding handle.
    if (FAILED(result) && pHandle != NULL)
    {
        pHandle->Release();
        pHandle = NULL;
    }

    *ppHandle = pHandle;

    ASSERT_LOCK_DONTCARE(gComLock);
    return result;
}

/***************************************************************************/
HRESULT CRpcChannelBuffer::InitClientSideHandle( CChannelHandle **pHandle )
{
    if (_pInterfaceInfo == NULL)
    {
        // Lookup the interface info. This cant fail.
        void *pInterfaceInfo = gRIFTbl.GetClientInterfaceInfo(_pIPIDEntry->iid);
        InterlockedCompareExchangePointer((void **)&_pInterfaceInfo,
                                          pInterfaceInfo, NULL);
    }

    return GetHandle( pHandle, TRUE );
}

/***************************************************************************/
CRpcChannelBuffer::CRpcChannelBuffer(CStdIdentity *standard_identity,
                              OXIDEntry       *pOXIDEntry,
                              DWORD            eState )
{
    ComDebOut((DEB_MARSHAL, "CRpcChannelBuffer %s Created this:%x pOXID:%x\n",
               (eState & client_cs) ? "CLIENT" : "SERVER", this, pOXIDEntry));

    DWORD dwDestCtx;

    // Fill in the easy fields first.
    _cRefs         = 1;
    _pStdId        = standard_identity;
    _pRpcDefault   = NULL;
    _pRpcCustom    = NULL;
    _pOXIDEntry    = pOXIDEntry;
    _pIPIDEntry    = NULL;
    _pInterfaceInfo= NULL;
    state          = eState;

    // Set process local flags.
    if (_pOXIDEntry->GetPid() == GetCurrentProcessId())
    {
        state |= process_local_cs;

        // If the object is in the NTA, mark the channel so it knows to
        // dispatch calls on the same thread.
        if (_pOXIDEntry->IsNTAServer())
        {
            ComDebOut((DEB_MARSHAL, "CRpcChannelBuffer %x marked NEUTRAL\n",this));
            state |= neutral_cs;
        }
    }

    if (state & (client_cs | proxy_cs))
    {
        // Determine the destination context.
        if (_pOXIDEntry->IsOnLocalMachine())
            if (!IsWOWThread() && (state & process_local_cs))
                dwDestCtx = MSHCTX_INPROC;
            else
                dwDestCtx = MSHCTX_LOCAL;
        else
            dwDestCtx = MSHCTX_DIFFERENTMACHINE;
    }
    else
    {
        // On the server side, the destination context isn't known
        // until a call arrives.
        dwDestCtx = -1;
    }

    // Initialize
    _destObj.SetDestCtx(dwDestCtx);
    _destObj.SetComVersion(_pOXIDEntry->GetComVersion());
}

/***************************************************************************/
CRpcChannelBuffer::~CRpcChannelBuffer()
{
    ComDebOut((DEB_MARSHAL, "CRpcChannelBuffer %s Deleted this:%x\n",
                          Server() ? "SERVER" : "CLIENT", this));

    if (_pRpcDefault != NULL)
        _pRpcDefault->Release();
    if (_pRpcCustom != NULL)
        _pRpcCustom->Release();
}

/***************************************************************************/
STDMETHODIMP CRpcChannelBuffer::FreeBuffer( RPCOLEMESSAGE *pMessage )
{
    TRACECALL( TRACE_RPC, "CRpcChannelBuffer::FreeBuffer" );
    ASSERT_LOCK_NOT_HELD(gComLock);
    AssertValid( FALSE, TRUE );

    if (pMessage->Buffer == NULL)
        return S_OK;

    CMessageCall *pCall = (CMessageCall *) pMessage->reserved1;
    Win4Assert( pCall );
    Win4Assert( pCall->_pHeader );
    Win4Assert( IsClientSide() );

    // Free the buffer.
    if(pCall->ProcessLocal())
    {
        PrivMemFree( pCall->_pHeader );
    }
    else
    {
        pMessage->Buffer = pCall->_pHeader;
        I_RpcFreeBuffer( (RPC_MESSAGE *) &pCall->message );
    }
    pMessage->Buffer = NULL;

    // Reset header as it has been freed
    pCall->_pHeader = NULL;

    // Release the AddRef we did earlier. Note that we can't do this until
    // after I_RpcFreeBuffer since it may release a binding handle that
    // I_RpcFreeBuffer needs.
    if (pCall->Locked())
        _pStdId->UnlockClient();

    pMessage->reserved1 = NULL;

    // Inform call object about call completion
    pCall->CallFinished();
    pCall->Release();

    ASSERT_LOCK_NOT_HELD(gComLock);
    return S_OK;
}

//-------------------------------------------------------------------------
//
//  Member:     CRpcChannelBuffer::GetBuffer
//
//  Synopsis:   Calls ClientGetBuffer or ServerGetBuffer
//
//-------------------------------------------------------------------------
STDMETHODIMP CRpcChannelBuffer::GetBuffer( RPCOLEMESSAGE *pMessage,
                                           REFIID riid )
{
    gOXIDTbl.ValidateOXID();
    if (Proxy())
        return ClientGetBuffer( pMessage, riid );
    else
        return ServerGetBuffer( pMessage, riid );
}
#ifdef _WIN64
//-------------------------------------------------------------------------
//
//  Member:     CRpcChannelBuffer::InitCallObject
//
//  Synopsis:   Common initialization for both ClientGetBuffer() and
//              NegotiateSyntax ()
//
//  History:    10-Jan-2000   Sajia  Created
//
//-------------------------------------------------------------------------

HRESULT CRpcChannelBuffer::InitCallObject( RPCOLEMESSAGE *pMessage,
                       CALLCATEGORY   *pcallcat,
                       DWORD dwCase,
                       CChannelHandle **ppHandle)
{


   RPC_STATUS      status;
   CMessageCall   *pCall      = (CMessageCall *) pMessage->reserved1;

   // pCall should be NULL here.
   Win4Assert(!pCall);

   HRESULT hr;
   COleTls tls(hr);
   if (FAILED(hr))
       return hr;

   *pcallcat    = CALLCAT_SYNCHRONOUS;
   // Initialize Buffer to NULL
   pMessage->Buffer = NULL;

   // Don't allow remote calls if DCOM is disabled.
   if (gDisableDCOM && _destObj.GetDestCtx() == MSHCTX_DIFFERENTMACHINE)
       return RPC_E_REMOTE_DISABLED;

   // Don't allow message calls.
   if (pMessage->rpcFlags & RPCFLG_MESSAGE)
       return E_NOTIMPL;

   // Determine if the call category is sync, async, or input sync.
   if (pMessage->rpcFlags & RPC_BUFFER_ASYNC)
   {
       *pcallcat = CALLCAT_ASYNC;
   }
   else if (pMessage->rpcFlags & RPCFLG_ASYNCHRONOUS)
   {
       Win4Assert( !"The old async flag is not supported" );
       return E_NOTIMPL;
   }
   else if (pMessage->rpcFlags & RPCFLG_INPUT_SYNCHRONOUS)
   {
       *pcallcat = CALLCAT_INPUTSYNC;
   }
   // Note - RPC requires that the 16th bit of the proc num be set because
   // we use the rpcFlags field of the RPC_MESSAGE struct.
   pMessage->iMethod |= RPC_FLAGS_VALID_BIT;

    // Determine the flags for the call.
    if (state & process_local_cs)
    {
        pMessage->rpcFlags |= RPCFLG_LOCAL_CALL;
    }

    status = InitClientSideHandle(ppHandle);
    if (status != S_OK)
    {
       return status;
    }

   // Initialize transfet syntax and interface info
    if (GET_BUFFER_AT == dwCase) {
       // RPC will not negotiate for proxies that support NDR64 only.
       // In this case, the proxy will supply the RpcInterfaceInformation
       // in RPC_MESSAGE and we use it.
       // RPC will not negotiate for proxies that support NDR20 only.
       // In this case, the RpcInterfaceInformation in RPC_MESSAGE is
       // NULL and we use the fake one.
       if (!pMessage->reserved2[1]) {
      pMessage->reserved2[0]  = 0;
      pMessage->reserved2[1]  = _pInterfaceInfo;
       }
    }
    BOOL fAsyncCallObj = (pMessage->rpcFlags & RPC_BUFFER_ASYNC ||
                       (IsSTAThread() && !ProcessLocal()) ||
                       (IsMTAThread() && (tls->cCallCancellation > 0) && MachineLocal() && !ProcessLocal())
                       ) ? TRUE : FALSE;
    status = GetCallObject(fAsyncCallObj, &pCall);

    if(SUCCEEDED(status))
    {
        status = pCall->InitCallObject(*pcallcat, pMessage, state, _pIPIDEntry->ipid,
                                    _destObj.GetDestCtx(), _destObj.GetComVersion(),
                                    *ppHandle);
        if(FAILED(status))
            pCall->Release();
    }

    // Check for failure and cleanup
    if(FAILED(status))
    {
        (*ppHandle)->Release();
        return status;
    }
    pMessage->reserved1  = pCall;
    return S_OK;
}
//-------------------------------------------------------------------------
//
//  Member:     CRpcChannelBuffer::NegotiateSyntax
//
//  Synopsis:   Called by the proxy to negotiate NDR Transfer
//              Syntax
//
//  History:    10-Jan-2000   Sajia  Created
//
//-------------------------------------------------------------------------
STDMETHODIMP CRpcChannelBuffer::NegotiateSyntax( RPCOLEMESSAGE *pMessage)
{
   TRACECALL(TRACE_RPC, "CRpcChannelBuffer::NegotiateSyntax");
   ASSERT_LOCK_NOT_HELD(gComLock);
   CALLCATEGORY   callcat;
   CChannelHandle *pHandle;
   BOOL            resume     = FALSE;
   HANDLE          thread;


   // Sanity check
   Win4Assert(pMessage->reserved1 == NULL);


   // Create a call object and an RPC binding handle wrapper object
   RPC_STATUS status = InitCallObject(pMessage, &callcat, SYNTAX_NEGOTIATE_AT, &pHandle);
   if (status != RPC_S_OK)
     return MAKE_WIN32(status);

   // For process local calls,  return S_FALSE so proxy
   // knows it is a local call.
   if (state & process_local_cs)
   {
      SetNDRSyntaxNegotiated();
      return S_FALSE;
   }

   CMessageCall   *pCall = (CMessageCall *) pMessage->reserved1;
   Win4Assert(pCall);
   if (pHandle->_fFirstCall) {
      pHandle->AdjustToken( SYNTAX_NEGOTIATE_AT, &resume, &thread );
   }

   // call RPC to do Syntax Negotiation
   status = I_RpcNegotiateTransferSyntax ((RPC_MESSAGE *) &pCall->message);

   pHandle->RestoreToken( resume, thread );
   pHandle->Release();
   if (status != RPC_S_OK)
   {
       // For connection oriented protocols, I_RpcNegotiateTransferSyntax establishes
       // connection with the server process. Use its return value to
       // update connection status maintained by standard identity
       if(status == RPC_S_SERVER_UNAVAILABLE)
       _pStdId->SetConnectionStatus(MAKE_WIN32(status));

       pMessage->cbBuffer  = 0;
       pMessage->Buffer = NULL;
       pMessage->reserved1 = NULL;

       // Mark the call as finished
       pCall->CallFinished();
       pCall->Release();
       return MAKE_WIN32( status );
   }

   // copy back the negotiated syntax ID so that the proxy can
   // use it
   ((PRPC_SYNTAX_IDENTIFIER)(pMessage->reserved2))->SyntaxGUID =
      ((PRPC_SYNTAX_IDENTIFIER)(pCall->message.reserved2))->SyntaxGUID;

   // Mark the channel as negotiated, so that the GetBuffer stage knows
   SetNDRSyntaxNegotiated();
   ASSERT_LOCK_NOT_HELD(gComLock);
   return S_OK;
}

//-------------------------------------------------------------------------
//
//  Member:     CRpcChannelBuffer::ClientGetBuffer
//
//  Synopsis:   Gets a buffer and sets up client side stuff
//
//-------------------------------------------------------------------------
HRESULT CRpcChannelBuffer::ClientGetBuffer( RPCOLEMESSAGE *pMessage,
                                            REFIID riid )
{
    TRACECALL(TRACE_RPC, "CRpcChannelBuffer::ClientGetBuffer");
    ASSERT_LOCK_NOT_HELD(gComLock);

    CALLCATEGORY   callcat = CALLCAT_SYNCHRONOUS;
    RPC_STATUS      status;
    ULONG           debug_size;
    ULONG           num_extent;
    WireThis       *pInb;
    LocalThis      *localb;
    IID            *logical_thread;
    CMessageCall   *pCall      = (CMessageCall *) pMessage->reserved1;
    BOOL            resume     = FALSE;
    HANDLE          thread;
    CChannelHandle *pHandle;
    BOOL            old_async  = FALSE;


    Win4Assert(Proxy());
    AssertValid(FALSE, TRUE);
    #if DBG==1
    logical_thread = (GUID *)&GUID_NULL;
    #endif


    if (!pCall)
    {
       // If we don't have a call object here, then go get one
       // This means that the channel has not been called to
       // negotiate NDR syntax (ie; legacy proxy).
       Win4Assert(!IsNDRSyntaxNegotiated());
       status = InitCallObject(pMessage, &callcat, GET_BUFFER_AT, &pHandle);
       if (RPC_S_OK != status)
      return MAKE_WIN32( status );
       else
       {
      pCall = (CMessageCall *) pMessage->reserved1;
      Win4Assert(pCall);
       }
    }
    else
    {
       // If we get here, this means that the channel has been called to
       // negotiate NDR syntax (ie; new proxy).We need to initialize
       // some fields in our copy of RPCOLEMESSAGE struct
       Win4Assert(IsNDRSyntaxNegotiated());
       pHandle = pCall->_pHandle;
       pHandle->AddRef();
       callcat = pCall->GetCallCategory();
       pCall->message.cbBuffer = pMessage->cbBuffer;
//
//  Should not set flag on the code path involving negotiation.
//       pCall->message.iMethod |= RPC_FLAGS_VALID_BIT;
//
       pCall->message.dataRepresentation = pMessage->dataRepresentation;
       ((PRPC_SYNTAX_IDENTIFIER)(pCall->message.reserved2))->SyntaxGUID =
             ((PRPC_SYNTAX_IDENTIFIER)(pMessage->reserved2))->SyntaxGUID;
    }
    if (CALLCAT_ASYNC == callcat)
    {
        // Set the callcat async only for these 2 special interfaces.
        if (riid == IID_AsyncIAdviseSink || riid == IID_AsyncIAdviseSink2)
        {
            // Calls from MTA apartments are not old style async.
            old_async = IsSTAThread();
	    
	    // these 2 interface are now truly async. But 
	    // we need to keep the CID of the caller (if any)
	    // otherwise we break casuality
	    logical_thread = TLSGetLogicalThread();
	    if (logical_thread == NULL)
	    {
	       return RPC_E_OUT_OF_RESOURCES;
	    }
        }
    }
    else
    {
       logical_thread = TLSGetLogicalThread();
       if (logical_thread == NULL)
       {
	  return RPC_E_OUT_OF_RESOURCES;
       }
    }

    HRESULT hr;
    COleTls tls(hr);
    if (FAILED(hr))
        return hr;

    //Set cancel enabled for call object
    if ((tls->cCallCancellation > 0) || (pMessage->rpcFlags & RPC_BUFFER_ASYNC))
        pCall->SetCancelEnabled();


    // Fill in the hook data.
    pCall->hook.dwServerPid   = _pOXIDEntry->GetPid();
    pCall->hook.iMethod       = pMessage->iMethod & ~RPC_FLAGS_VALID_BIT;
    pCall->hook.pObject       = NULL;

    // Determine the causality id.
    if ((pMessage->rpcFlags & RPC_BUFFER_ASYNC) && 
	(riid != IID_AsyncIAdviseSink && 
	 riid != IID_AsyncIAdviseSink2))
    {
       RPC_STATUS st = UuidCreate( &pCall->hook.uCausality );
       Win4Assert(SUCCEEDED(st));
    }
    else
    {
        Win4Assert(logical_thread != (GUID *)&GUID_NULL);
        pCall->hook.uCausality = *logical_thread;
    }

    // Find out if we need hook data.
    debug_size = ClientGetSize( &num_extent, pCall );
    pCall->message.cbBuffer += SIZENEEDED_ORPCTHIS(
                                   _pOXIDEntry->IsOnLocalMachine(),
                                   debug_size );

    // Adjust the thread token to the one RPC needs to see for this case.
    if (!IsNDRSyntaxNegotiated() && pHandle->_fFirstCall)
      pHandle->AdjustToken( GET_BUFFER_AT, &resume, &thread );

    // Get a buffer.
    if ( (pMessage->rpcFlags & RPCFLG_LOCAL_CALL))
    {
        pCall->message.dataRepresentation = NDR_ASCII_CHAR | NDR_LOCAL_ENDIAN |
                                           NDR_IEEE_FLOAT;
        pCall->message.Buffer = PrivMemAlloc8( pCall->message.cbBuffer );
        Win4Assert(((ULONG_PTR)pCall->message.Buffer & 0x7) == 0 &&
                   "Buffer not aligned properly");

        if (pCall->message.Buffer == NULL)
            status = RPC_S_OUT_OF_MEMORY;
        else
            status = RPC_S_OK;
    }
    else
    {
        TRACECALL(TRACE_RPC, "I_RpcGetBufferWithObject");
        ComDebOut((DEB_CHANNEL, "->I_RpcGetBufferWithObject(pmsg=0x%x,ipid=%I)\n",
                  (RPC_MESSAGE *) &pCall->message, &_pIPIDEntry->ipid));
        status = I_RpcGetBufferWithObject((RPC_MESSAGE *) &pCall->message,
                                          &_pIPIDEntry->ipid);
        pCall->_hRpc = pCall->message.reserved1;
        ComDebOut((DEB_CHANNEL, "<-I_RpcGetBufferWithObject(status=0x%x)\n",status));
    }
    pCall->_pHeader  = pCall->message.Buffer;
    pMessage->Buffer = pCall->message.Buffer;

    // Restore the thread token.
    pHandle->RestoreToken( resume, thread );

    if (status != RPC_S_OK)
    {
        // For connection oriented protocols, I_RpcGetBuffer establishes
        // connection with the server process. Use its return value to
        // update connection status maintained by standard identity
        if(status == RPC_S_SERVER_UNAVAILABLE)
            _pStdId->SetConnectionStatus(MAKE_WIN32(status));

        // Cleanup.
        pCall->_pHeader  = NULL;
        pMessage->cbBuffer  = 0;
        pMessage->Buffer = NULL;
        pMessage->reserved1 = NULL;

        // Mark the call as finished
        pCall->CallFinished();
        pCall->Release();
        pHandle->Release();
        return MAKE_WIN32( status );
    }

    // Save the impersonation flag.
    if (pMessage->rpcFlags & RPC_BUFFER_ASYNC)
        ((CAsyncCall *) pCall)->_pRequestBuffer = pCall->message.Buffer;

    // Fill in the COM header.
    pMessage->reserved1  = pCall;
    pInb                 = (WireThis *) pCall->_pHeader;
    pInb->c.version      = _pOXIDEntry->GetComVersion();
    pInb->c.reserved1    = 0;
    pInb->c.cid          = pCall->hook.uCausality;

    // Set the private flag for local calls.
    if (_pOXIDEntry->IsOnLocalMachine())
        pInb->c.flags = ORPCF_LOCAL;
    else
        pInb->c.flags = ORPCF_NULL;

    // Fill in any hook data and adjust the buffer pointer.
    if (debug_size != 0)
    {
        pMessage->Buffer = FillBuffer( &pInb->d.ea, debug_size, num_extent,
                                       TRUE, pCall );
        pInb->c.unique = 0x77646853; // Any non-zero value.
    }
    else
    {
        pMessage->Buffer    = (void *) &pInb->d.ea;
        pInb->c.unique       = FALSE;
    }

    // Fill in the local header.
    if (_pOXIDEntry->IsOnLocalMachine())
    {
        localb                      = (LocalThis *) pMessage->Buffer;
        localb->client_thread       = GetCurrentApartmentId();
        localb->flags               = 0;
        pMessage->Buffer            = localb + 1;
        if ((pMessage->rpcFlags & RPC_BUFFER_ASYNC) &&
            (((riid == IID_AsyncIAdviseSink) || (riid == IID_AsyncIAdviseSink2))
             ? old_async
             : FALSE
            ))
        {
            // this is what will determine if the server considers this
            // an async call.
            pInb->c.flags |= ORPCF_ASYNC;
        }
        else if (callcat == CALLCAT_INPUTSYNC)
            pInb->c.flags |= ORPCF_INPUT_SYNC;

        // if the caller is using a non-NDR proxy, set a bit in the local
        // header flags so that server side stub knows which way to unmarshal
        // the parameters. This lets a 32bit server simultaneously service calls
        // from 16bit non-NDR clients and 32bit NDR clients, in particular, to
        // support OLE Automation.

        if (_pIPIDEntry->dwFlags & (IPIDF_NONNDRPROXY | IPIDF_NONNDRSTUB))
            localb->flags |= LOCALF_NONNDR;
        if (pHandle->_eState & dynamic_cloaking_hs)
            pInb->c.flags |= ORPCF_DYNAMIC_CLOAKING;
    }

    pHandle->Release();

    Win4Assert(pMessage->Buffer > (void *)0x010);
    ComDebOut((DEB_CALLCONT, "ClientGetBuffer: LogicalThreadId:%I\n",
               &pInb->c.cid));
    ASSERT_LOCK_NOT_HELD(gComLock);
    return S_OK;
}
#else
//-------------------------------------------------------------------------
//
//  Member:     CRpcChannelBuffer::ClientGetBuffer
//
//  Synopsis:   Gets a buffer and sets up client side stuff
//
//-------------------------------------------------------------------------
HRESULT CRpcChannelBuffer::ClientGetBuffer( RPCOLEMESSAGE *pMessage,
                                            REFIID riid )
{
    TRACECALL(TRACE_RPC, "CRpcChannelBuffer::ClientGetBuffer");
    ASSERT_LOCK_NOT_HELD(gComLock);

    RPC_STATUS      status;
    CALLCATEGORY    callcat    = CALLCAT_SYNCHRONOUS;
    ULONG           debug_size;
    ULONG           num_extent;
    WireThis       *pInb;
    LocalThis      *localb;
    IID            *logical_thread;
    CMessageCall   *pCall      = (CMessageCall *) pMessage->reserved1;
    BOOL            resume     = FALSE;
    HANDLE          thread;
    CChannelHandle *pHandle;
    BOOL            old_async  = FALSE;
    DWORD           flags      = state;


    Win4Assert(Proxy());
    AssertValid(FALSE, TRUE);
    #if DBG==1
    logical_thread = (GUID *)&GUID_NULL;
    #endif

    // Initialize Buffer to NULL
    pMessage->Buffer = NULL;

    // Don't allow remote calls if DCOM is disabled.
    if (gDisableDCOM && _destObj.GetDestCtx() == MSHCTX_DIFFERENTMACHINE)
        return RPC_E_REMOTE_DISABLED;

    // Don't allow message calls.
    if (pMessage->rpcFlags & RPCFLG_MESSAGE)
        return E_NOTIMPL;

    // Determine if the call category is sync, async, or input sync.
    if (pMessage->rpcFlags & RPC_BUFFER_ASYNC)
    {
        // Set the callcat async only for these 2 special interfaces.
        if (riid == IID_AsyncIAdviseSink || riid == IID_AsyncIAdviseSink2)
        {
            // Calls from MTA apartments are not old style async.
            old_async = IsSTAThread();
	    
	    // these 2 interface are now truly async. But 
	    // we need to keep the CID of the caller (if any)
	    // otherwise we break casuality
	    
	    logical_thread = TLSGetLogicalThread();
	    if (logical_thread == NULL)
	    {
		return RPC_E_OUT_OF_RESOURCES;
	    }
        }

        callcat = CALLCAT_ASYNC;
    }
    else if (pMessage->rpcFlags & RPCFLG_ASYNCHRONOUS)
    {
        Win4Assert( !"The old async flag is not supported" );
        return E_NOTIMPL;
    }
    else
    {
        logical_thread = TLSGetLogicalThread();
        if (logical_thread == NULL)
        {
            return RPC_E_OUT_OF_RESOURCES;
        }
        if (pMessage->rpcFlags & RPCFLG_INPUT_SYNCHRONOUS)
        {
            callcat = CALLCAT_INPUTSYNC;
        }
    }

    // Note - RPC requires that the 16th bit of the proc num be set because
    // we use the rpcFlags field of the RPC_MESSAGE struct.
    pMessage->iMethod |= RPC_FLAGS_VALID_BIT;

    // Determine the flags for the call.
    if (state & process_local_cs)
    {
        pMessage->rpcFlags |= RPCFLG_LOCAL_CALL;
    }

    // Complete the channel initialization if needed.
    status = InitClientSideHandle( &pHandle );
    if (status != S_OK)
    {
        return status;
    }

    // Initialize transfet syntax and interface info
    pMessage->reserved2[0]  = 0;
    pMessage->reserved2[1]  = _pInterfaceInfo;

    HRESULT hr;
    COleTls tls(hr);
    if (FAILED(hr))
        return hr;

    // Allocate and initialize a call record.
    Win4Assert(pCall == NULL && "GetBuffer call was not NULL.");
    BOOL fAsyncCallObj = (pMessage->rpcFlags & RPC_BUFFER_ASYNC ||
                       (IsSTAThread() && !ProcessLocal()) ||
                       (IsMTAThread() && (tls->cCallCancellation > 0) && MachineLocal() && !ProcessLocal())
                       ) ? TRUE : FALSE;
    status = GetCallObject(fAsyncCallObj, &pCall);

    if(SUCCEEDED(status))
    {
        status = pCall->InitCallObject(callcat, pMessage, flags, _pIPIDEntry->ipid,
                                    _destObj.GetDestCtx(), _destObj.GetComVersion(),
                                    pHandle);
        if(FAILED(status))
            pCall->Release();
    }

    // Check for failure and cleanup
    if(FAILED(status))
    {
        pHandle->Release();
        return status;
    }

    //Set cancel enabled for call object
    if ((tls->cCallCancellation > 0) || (pMessage->rpcFlags & RPC_BUFFER_ASYNC))
        pCall->SetCancelEnabled();


    // Fill in the hook data.
    pCall->hook.dwServerPid   = _pOXIDEntry->GetPid();
    pCall->hook.iMethod       = pMessage->iMethod & ~RPC_FLAGS_VALID_BIT;
    pCall->hook.pObject       = NULL;

    // Determine the causality id.
    if ((pMessage->rpcFlags & RPC_BUFFER_ASYNC) && 
	(riid != IID_AsyncIAdviseSink && 
	 riid != IID_AsyncIAdviseSink2))
    {
       RPC_STATUS st = UuidCreate( &pCall->hook.uCausality );
       Win4Assert(SUCCEEDED(st));
    }
    else
    {
        Win4Assert(logical_thread != (GUID *)&GUID_NULL);
        pCall->hook.uCausality = *logical_thread;
    }

    // Find out if we need hook data.
    debug_size = ClientGetSize( &num_extent, pCall );
    pCall->message.cbBuffer += SIZENEEDED_ORPCTHIS(
                                   _pOXIDEntry->IsOnLocalMachine(),
                                   debug_size );

    // Adjust the thread token to the one RPC needs to see for this case.
    if (pHandle->_fFirstCall)
      pHandle->AdjustToken( GET_BUFFER_AT, &resume, &thread );

    // Get a buffer.
    if ( (pMessage->rpcFlags & RPCFLG_LOCAL_CALL))
    {
        pCall->message.dataRepresentation = NDR_ASCII_CHAR | NDR_LOCAL_ENDIAN |
                                           NDR_IEEE_FLOAT;
        pCall->message.Buffer = PrivMemAlloc8( pCall->message.cbBuffer );
        Win4Assert(((ULONG_PTR)pCall->message.Buffer & 0x7) == 0 &&
                   "Buffer not aligned properly");

        if (pCall->message.Buffer == NULL)
            status = RPC_S_OUT_OF_MEMORY;
        else
            status = RPC_S_OK;
    }
    else
    {
        TRACECALL(TRACE_RPC, "I_RpcGetBufferWithObject");
        ComDebOut((DEB_CHANNEL, "->I_RpcGetBufferWithObject(pmsg=0x%x,ipid=%I)\n",
                  (RPC_MESSAGE *) &pCall->message, &_pIPIDEntry->ipid));
        status = I_RpcGetBufferWithObject((RPC_MESSAGE *) &pCall->message,
                                          &_pIPIDEntry->ipid);
        pCall->_hRpc = pCall->message.reserved1;
        ComDebOut((DEB_CHANNEL, "<-I_RpcGetBufferWithObject(status=0x%x)\n",status));
    }
    pCall->_pHeader  = pCall->message.Buffer;
    pMessage->Buffer = pCall->message.Buffer;

    // Restore the thread token.
    pHandle->RestoreToken( resume, thread );

    if (status != RPC_S_OK)
    {
        // For connection oriented protocols, I_RpcGetBuffer establishes
        // connection with the server process. Use its return value to
        // update connection status maintained by standard identity
        if(status == RPC_S_SERVER_UNAVAILABLE)
            _pStdId->SetConnectionStatus(MAKE_WIN32(status));

        // Cleanup.
        pCall->_pHeader  = NULL;
        pMessage->cbBuffer  = 0;
        pMessage->Buffer = NULL;
        pMessage->reserved1 = NULL;

        // Mark the call as finished
        pCall->CallFinished();
        pCall->Release();
        pHandle->Release();
        return MAKE_WIN32( status );
    }

    // Save the impersonation flag.
    if (pMessage->rpcFlags & RPC_BUFFER_ASYNC)
        ((CAsyncCall *) pCall)->_pRequestBuffer = pCall->message.Buffer;

    // Fill in the COM header.
    pMessage->reserved1  = pCall;
    pInb                 = (WireThis *) pCall->_pHeader;
    pInb->c.version      = _pOXIDEntry->GetComVersion();
    pInb->c.reserved1    = 0;
    pInb->c.cid          = pCall->hook.uCausality;

    // Set the private flag for local calls.
    if (_pOXIDEntry->IsOnLocalMachine())
        pInb->c.flags = ORPCF_LOCAL;
    else
        pInb->c.flags = ORPCF_NULL;

    // Fill in any hook data and adjust the buffer pointer.
    if (debug_size != 0)
    {
        pMessage->Buffer = FillBuffer( &pInb->d.ea, debug_size, num_extent,
                                       TRUE, pCall );
        pInb->c.unique = 0x77646853; // Any non-zero value.
    }
    else
    {
        pMessage->Buffer    = (void *) &pInb->d.ea;
        pInb->c.unique       = FALSE;
    }

    // Fill in the local header.
    if (_pOXIDEntry->IsOnLocalMachine())
    {
        localb                      = (LocalThis *) pMessage->Buffer;
        localb->client_thread       = GetCurrentApartmentId();
        localb->flags               = 0;
        pMessage->Buffer            = localb + 1;
        if ((pMessage->rpcFlags & RPC_BUFFER_ASYNC) &&
            (((riid == IID_AsyncIAdviseSink) || (riid == IID_AsyncIAdviseSink2))
             ? old_async
             : FALSE
            ))
        {
            // this is what will determine if the server considers this
            // an async call.
            pInb->c.flags |= ORPCF_ASYNC;
        }
        else if (callcat == CALLCAT_INPUTSYNC)
            pInb->c.flags |= ORPCF_INPUT_SYNC;

        // if the caller is using a non-NDR proxy, set a bit in the local
        // header flags so that server side stub knows which way to unmarshal
        // the parameters. This lets a 32bit server simultaneously service calls
        // from 16bit non-NDR clients and 32bit NDR clients, in particular, to
        // support OLE Automation.

        if (_pIPIDEntry->dwFlags & (IPIDF_NONNDRPROXY | IPIDF_NONNDRSTUB))
            localb->flags |= LOCALF_NONNDR;
        if (pHandle->_eState & dynamic_cloaking_hs)
            pInb->c.flags |= ORPCF_DYNAMIC_CLOAKING;
    }

    pHandle->Release();

    Win4Assert(pMessage->Buffer > (void *)0x010);
    ComDebOut((DEB_CALLCONT, "ClientGetBuffer: LogicalThreadId:%I\n",
               &pInb->c.cid));
    ASSERT_LOCK_NOT_HELD(gComLock);
    return S_OK;
}
#endif
//-------------------------------------------------------------------------
//
//  Member:     CRpcChannelBuffer::ServerGetBuffer
//
//  Synopsis:   Gets a buffer and sets up server side stuff
//
//  Note: For async calls the stub must use its own copy of the buffer.
//        Otherwise pMessage will equal pCall->message.
//
//-------------------------------------------------------------------------
HRESULT CRpcChannelBuffer::ServerGetBuffer( RPCOLEMESSAGE *pMessage,
                                            REFIID riid )
{
    TRACECALL(TRACE_RPC, "CRpcChannelBuffer::ServerGetBuffer");
    ASSERT_LOCK_NOT_HELD(gComLock);

    RPC_STATUS            status;
    ULONG                 debug_size = 0;
    ULONG                 size;
    ULONG                 num_extent = 0;
    HRESULT               result     = S_OK;
    WireThis             *pInb;
    WireThat             *pOutb;
    CMessageCall         *pCall = (CMessageCall *) pMessage->reserved1;
    void                 *stub_data;
    DWORD                 orig_size = pMessage->cbBuffer;

    // Debug checks
    Win4Assert( Server() );
    Win4Assert( pCall != NULL );
    AssertValid(FALSE, TRUE);

    // Tell RPC that we have set the flags field.
    pCall->message.iMethod  |= RPC_FLAGS_VALID_BIT;

    // Find out if we need debug data.
    debug_size = ServerGetSize( &num_extent, pCall );

    // Compute the total size.
    size = pMessage->cbBuffer + SIZENEEDED_ORPCTHAT( debug_size );

    // Get a buffer.
    pCall->message.cbBuffer       = size;
    pCall->_dwErrorBufSize = size;
    
    if (pMessage->rpcFlags & RPCFLG_LOCAL_CALL)
    {
        // NDR_DREP_ASCII | NDR_DREP_LITTLE_ENDIAN | NDR_DREP_IEEE
        pMessage->dataRepresentation = 0x00 | 0x10 | 0x0000;
        pCall->message.Buffer         = PrivMemAlloc8( size );

        Win4Assert(((ULONG_PTR)pCall->message.Buffer & 0x7) == 0 &&
                   "Buffer not aligned properly");

        if (pCall->message.Buffer == NULL)
            status = RPC_S_OUT_OF_MEMORY;
        else
            status = RPC_S_OK;
    }
    else
    {
        TRACECALL(TRACE_RPC, "I_RpcGetBuffer");
        ComDebOut((DEB_CHANNEL, "->I_RpcGetBuffer(pmsg=0x%x)\n",(RPC_MESSAGE *) &pCall->message));

        pCall->message.reserved1 = pCall->_hRpc;
        status = I_RpcGetBuffer((RPC_MESSAGE *) &pCall->message);

        ComDebOut((DEB_CHANNEL, "<-I_RpcGetBuffer(status=0x%x)\n",status));
        Win4Assert( pCall->_pHeader != pCall->message.Buffer ||
                    status != RPC_S_OK );
        pCall->message.reserved1 = pCall;
    }

    // If the buffer allocation failed, give up.
    pCall->_pHeader = pCall->message.Buffer;
    if (status != RPC_S_OK)
    {
        pMessage->cbBuffer = 0;
        pMessage->Buffer   = NULL;

        return MAKE_WIN32( status );
    }

    pMessage->cbBuffer = orig_size;
    // Fill in the outbound COM header.
    pOutb = (WireThat *) pCall->message.Buffer;
    if (pCall->GetDestCtx() == MSHCTX_DIFFERENTMACHINE)
        pOutb->c.flags = ORPCF_NULL;
    else
        pOutb->c.flags = ORPCF_LOCAL;
    if (debug_size != 0)
    {
        stub_data = FillBuffer( &pOutb->d.ea, debug_size, num_extent, FALSE,
                                pCall );
        pOutb->c.unique  = 0x77646853; // Any non-zero value.
        pMessage->Buffer = stub_data;
    }
    else
    {
        pOutb->c.unique    = 0;
        pMessage->Buffer   = &pOutb->d.ea;
    }

    ComDebOut((DEB_CHANNEL, "ServerGetBuffer\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);
    return S_OK;
}

/***************************************************************************/
STDMETHODIMP CRpcChannelBuffer::GetProtocolVersion(DWORD *pdwVersion)
{
    TRACECALL(TRACE_RPC, "CRpcChannelBuffer::GetProtocolVersion");
    AssertValid(FALSE, FALSE);

    if (pdwVersion == NULL)
        return E_INVALIDARG;

    COMVERSION version;
    if (state & (client_cs | proxy_cs))
    {
        // On the client side, get the version from the channel's OXIDEntry.
        version = _pOXIDEntry->GetComVersion();
    }
    else
    {
        // On the server side, get the version from TLS.
        COleTls tls;
        Win4Assert( tls->pCallInfo != NULL );
        version = ((CMessageCall *) tls->pCallInfo)->GetComVersion();
    }

    *pdwVersion = MAKELONG(version.MajorVersion, version.MinorVersion);
    ComDebOut((DEB_CHANNEL,"GetProtocolVersion ver:%x hr:%x\n",*pdwVersion,S_OK));
    return S_OK;
}

/***************************************************************************/
STDMETHODIMP CRpcChannelBuffer::GetDestCtx( DWORD FAR* lpdwDestCtx,
                           LPVOID FAR* lplpvDestCtx )
{
    TRACECALL(TRACE_RPC, "CRpcChannelBuffer::GetDestCtx");
    AssertValid(FALSE, FALSE);

    DWORD dwDestCtx;
    IDestInfo *pDestInfo;

    if (state & (client_cs | proxy_cs))
    {
        // On the client side, get the destination context from the channel.
        dwDestCtx = _destObj.GetDestCtx();
        pDestInfo = (IDestInfo *) &_destObj;
    }
    else
    {
        // On the server side, get the destination context from TLS.
        COleTls tls;
        if (tls->pCallInfo != NULL)
        {
            dwDestCtx = tls->pCallInfo->GetDestCtx();
            pDestInfo = (IDestInfo *) &tls->pCallInfo->_destObj;
        }
        else
            return RPC_E_NO_CONTEXT;
    }

    *lpdwDestCtx = dwDestCtx;
    if (lplpvDestCtx != NULL)
    {
        if(dwDestCtx == MSHCTX_DIFFERENTMACHINE)
            *lplpvDestCtx = pDestInfo;
        else
            *lplpvDestCtx = NULL;
    }

    return S_OK;
}

/***************************************************************************/
STDMETHODIMP CRpcChannelBuffer::IsConnected( THIS )
{
    // must be on right thread because it is only called by proxies and stubs.
    AssertValid(FALSE, TRUE);

    // Server channels never know if they are connected.  The only time the
    // client side knows it is disconnected is after the standard identity
    // has disconnected the proxy from the channel.  In that case it doesn't
    // matter.
    return S_OK;
}

/***************************************************************************/
STDMETHODIMP CRpcChannelBuffer::QueryInterface( THIS_ REFIID riid, LPVOID FAR* ppvObj)
{
  AssertValid(FALSE, FALSE);

  // IMarshal is queried more frequently than any other interface, so
  // check for that first.

  if (IsEqualIID(riid, IID_IMarshal))
  {
    *ppvObj = (IMarshal *) this;
  }
  else if (IsEqualIID(riid, IID_IUnknown)      ||
      IsEqualIID(riid, IID_IRpcChannelBuffer)  ||
      IsEqualIID(riid, IID_IRpcChannelBuffer2) ||
      IsEqualIID(riid, IID_IRpcChannelBuffer3))
  {
    *ppvObj = (IRpcChannelBuffer3 *) this;
  }
  else if (IsEqualIID(riid, IID_INonNDRStub) &&
          (Proxy()) && _pIPIDEntry &&
          (_pIPIDEntry->dwFlags & IPIDF_NONNDRSTUB))
  {
    // this interface is used to tell proxies whether the server side speaks
    // NDR or not. Returns S_OK if NOT NDR.
    *ppvObj = (IRpcChannelBuffer3 *) this;
  }
  else if (IsEqualIID(riid, IID_IAsyncRpcChannelBuffer))
  {
      *ppvObj = (IAsyncRpcChannelBuffer *) this;
  }
#ifdef _WIN64
  // Sajia - Support NDR Transfer Syntax Negotiation
  else if (IsEqualIID(riid, IID_IRpcSyntaxNegotiate))
  {
      *ppvObj = (IRpcSyntaxNegotiate *) this;
  }
#endif
  else if (IsEqualIID(riid, IID_CPPRpcChannelBuffer))
  {
      // this is a special IID to get a pointer to the
      // C++ object itself.  It is not exposed to the outside
      // world.
      *ppvObj = this;
  }
  else
  {
    *ppvObj = NULL;
    return E_NOINTERFACE;
  }

  AddRef();
  return S_OK;
}

/***************************************************************************/
STDMETHODIMP_(ULONG) CRpcChannelBuffer::Release( THIS )
{
    // can't call AssertValid(FALSE) since it is used in asserts
    ULONG lRef = InterlockedDecrement( (long*) &_cRefs );
    if (lRef == 0)
    {
        delete this;
    }
    return lRef;
}

//-------------------------------------------------------------------------
//
//  Member:     CRpcChannelBuffer::Cancel
//
//  Synopsis:   Cancels an asynchronous call.  Notifies the other side
//              that the call is complete an deletes the call if necessary.
//
//-------------------------------------------------------------------------

STDMETHODIMP CRpcChannelBuffer::Cancel( RPCOLEMESSAGE *pMessage )
{
    CAsyncCall   *pCall = (CAsyncCall *) pMessage->reserved1;

    ComDebOut((DEB_CHANNEL, "CRpcChannelBuffer::Cancel\n"));

    // Make sure there is a call
    if (pCall == NULL)
        return RPC_E_CALL_COMPLETE;

    // Don't allow cancel on the server side.
    if (!IsClientSide())
        return E_NOTIMPL;

    // Cancel it.
    return pCall->Cancel(FALSE, 0);
}

//-------------------------------------------------------------------------
//
//  Member:     CRpcChannelBuffer::GetCallContext
//
//  Synopsis:   Returns the context object for a call.
//
//-------------------------------------------------------------------------
STDMETHODIMP CRpcChannelBuffer::GetCallContext( RPCOLEMESSAGE *pMessage,
                                                REFIID riid,
                                                void **pInterface )
{
    CAsyncCall *pCall = (CAsyncCall *) pMessage->reserved1;

    // Make sure there is a call
    if (pCall == NULL)
        return RPC_E_CALL_COMPLETE;

    // Get the requested interface.
    ComDebOut((DEB_CHANNEL, "CRpcChannelBuffer::GetCallContext\n"));
    if (pCall->_pContext != NULL)
        return pCall->_pContext->QueryInterface( riid, pInterface );
    else
        return RPC_E_NO_CONTEXT;
}

//-------------------------------------------------------------------------
//
//  Member:     CRpcChannelBuffer::GetDestCtxEx
//
//  Synopsis:   Gets the destination context of an asynchronous calls.
//              Since there may be multiple calls outstanding, the
//              context must be retrieved from the call stored in the
//              message rather then TLS.
//
//-------------------------------------------------------------------------
STDMETHODIMP CRpcChannelBuffer::GetDestCtxEx( RPCOLEMESSAGE *pMessage,
                                              DWORD *pdwDestContext,
                                              void **ppvDestContext )
{
    CAsyncCall *pCall = (CAsyncCall *) pMessage->reserved1;

    // Make sure there is a call
    if (pCall == NULL)
        return RPC_E_CALL_COMPLETE;

    // Get the dest context.
    *pdwDestContext = pCall->GetDestCtx();
    if (ppvDestContext != NULL)
    {
        if(pCall->GetDestCtx() == MSHCTX_DIFFERENTMACHINE)
            *ppvDestContext = (IDestInfo *) &pCall->_destObj;
        else
            *ppvDestContext = NULL;
    }

    ComDebOut((DEB_CHANNEL, "CRpcChannelBuffer::GetDestCtxEx\n"));
    return S_OK;
}

//-------------------------------------------------------------------------
//
//  Member:     CRpcChannelBuffer::GetState
//
//  Synopsis:   Gets the current status of an asynchronous call.
//
//-------------------------------------------------------------------------
STDMETHODIMP CRpcChannelBuffer::GetState( RPCOLEMESSAGE *pMessage,
                                          DWORD *pState )
{
    ComDebOut((DEB_CHANNEL, "CRpcChannelBuffer::GetState\n"));
    CAsyncCall *pCall = (CAsyncCall *) pMessage->reserved1;

    // Make sure there is a call
    if (pCall == NULL)
        return RPC_E_CALL_COMPLETE;

    // Get the state from the call.
    return pCall->GetState( pState );
}

//-------------------------------------------------------------------------
//
//  Member:     CRpcChannelBuffer::RegisterAsync
//
//  Synopsis:   Registers the completion object to associate with a call.
//
//-------------------------------------------------------------------------
HRESULT CRpcChannelBuffer::RegisterAsync( RPCOLEMESSAGE *pMessage,
                                          IAsyncManager *pComplete )
{
    CMessageCall   *pCall = (CMessageCall *) pMessage->reserved1;
    HRESULT         result;

    // Make sure there is a call
    ComDebOut((DEB_CHANNEL, "CRpcChannelBuffer::RegisterAsync\n"));
    if (pCall == NULL)
        return RPC_E_CALL_COMPLETE;

    // Register async with RPC.  This has already been done for remote
    // calls to STA.
    if (!pCall->ProcessLocal() &&
        (Proxy() || IsMTAThread()))
    {
        if(!Proxy())
            pCall->message.reserved1 = pCall->_hRpc;
        result = I_RpcAsyncSetHandle((RPC_MESSAGE *) &pCall->message,
                                      &(((CAsyncCall *) pCall)->_AsyncState));
        if(!Proxy())
            pCall->message.reserved1 = pCall;
        if (result != RPC_S_OK)
            result = MAKE_WIN32( result );
    }
    else
        result = S_OK;

    // Change our state.
    if (SUCCEEDED(result))
    {
        // REVIEW: The assumption the call is CAsyncCall is
        //        not valid for process local sync calls made
        //        by the client that became async on the server
        //        side. GopalK

         
        // Mark the call as async.
        if (Proxy())
            pCall->SetClientAsync();
        else
            pCall->SetServerAsync();

        // On the server, save or replace the synchronize and save the
        // call context.
        if (Server())
        {
            // Keep the call alive
            pCall->AddRef();

            // Get the call context.
            if (pCall->_pContext == NULL)
            {
                COleTls tls;
                pCall->_pContext = tls->pCallContext;
                pCall->_pContext->AddRef();
            }

            // Mark the call as async.
            pMessage->rpcFlags      |= RPC_BUFFER_ASYNC;
            pCall->message.rpcFlags |= RPC_BUFFER_ASYNC;
        }
        // On the client side save the synchronize.
        else
        {
            Win4Assert(pComplete);
            ((CAsyncCall *)pCall)->_pChnlObj = (CChannelObject *) pComplete;
        }
    }
    else if(Proxy())
    {
        // Make sure FreeBuffer doesn't try to free the in buffer.
        pMessage->Buffer = NULL;

        // If the call failed, clean up.
        result = ClientNotify( NULL, 0, NULL, 0, result,
                               pCall );

        // Clean up the call.
        pCall->CallFinished();
        pCall->Release();
        pMessage->reserved1 = NULL;

        // Update connection status maintained by standard identity
        if (result == RPC_E_SERVER_DIED     ||
            result == RPC_E_SERVER_DIED_DNE ||
            result == RPC_E_DISCONNECTED    ||
            result == MAKE_WIN32(RPC_S_SERVER_UNAVAILABLE))
           _pStdId->SetConnectionStatus(result);
    }

    return result;
}

//-------------------------------------------------------------------------
//
//  Member:     CRpcChannelBuffer::Send
//
//  Synopsis:   Wrapper for send.  Used when no apartment call control
//              wraps the channel
//
//-------------------------------------------------------------------------
STDMETHODIMP CRpcChannelBuffer::Send( RPCOLEMESSAGE *pMessage,
                                      ULONG *pulStatus )
{
    return Send2( pMessage, pulStatus );
}
//-------------------------------------------------------------------------
//
//  Member:     CRpcChannelBuffer::Send
//
//  Synopsis:   Wrapper for send.  Used when no apartment call control
//              wraps the channel
//
//-------------------------------------------------------------------------
STDMETHODIMP CRpcChannelBuffer::Send(RPCOLEMESSAGE *pMsg, ISynchronize *pSync, PULONG pulStatus)
{
    HRESULT hr = S_OK;
    if (Proxy())
    {
        Win4Assert(pSync);
        hr = RegisterAsync(pMsg, ((IAsyncManager *) pSync));
    }
    else
        Win4Assert(!pSync && "ISynchronize supplied on the server side");

    if (SUCCEEDED(hr))
        hr = CRpcChannelBuffer::Send2(pMsg, pulStatus);

    return hr;
}

//-------------------------------------------------------------------------
//
//  Member:     CRpcChannelBuffer::Send2
//
//  Synopsis:   Pick whether to use PipeSend or AsyncSend
//
//-------------------------------------------------------------------------
STDMETHODIMP CRpcChannelBuffer::Send2( RPCOLEMESSAGE *pMessage,
                                       ULONG *pulStatus )
{
    if ( pMessage->rpcFlags & RPC_BUFFER_PARTIAL )
        return E_INVALIDARG;

    return AsyncSend( pMessage, pulStatus );
}

//-------------------------------------------------------------------------
//
//  Member:     CRpcChannelBuffer::AsyncSend
//
//  Synopsis:   Sends a packet for an asynchronous call.  On the client
//              side it sends the request.  On the server side it sends
//              the reply.
//
//-------------------------------------------------------------------------
HRESULT CRpcChannelBuffer::AsyncSend( RPCOLEMESSAGE *pMessage, ULONG *pulStatus )
{
    TRACECALL(TRACE_RPC, "CRpcChannelBuffer::AsyncSend");
    ComDebOut((DEB_CHANNEL, "CRpcChannelBuffer::AsyncSend pChnl:%x pMsg:%x\n",
        this, pMessage));

    AssertValid(FALSE, TRUE);
    gOXIDTbl.ValidateOXID();
    ASSERT_LOCK_NOT_HELD(gComLock);
    Win4Assert( pMessage->rpcFlags & RPC_BUFFER_ASYNC );

    HRESULT      result;
    CAsyncCall  *pCall = (CAsyncCall *) pMessage->reserved1;
    BOOL         fCanceled;

    // Return an error if the call is canceled.
    if (pCall == NULL)
        return RPC_E_CALL_CANCELED;

    // Client side.
    if (Proxy())
    {
        // we must ensure that we dont go away during this call. we will Release
        // ourselves in the FreeBuffer call, or in the error handling at the
        // end of this function.
        _pStdId->LockClient();

        pCall->InitClientHwnd(); // get the hwnd for the client thread

        // Send the request.
        if (pCall->ProcessLocal())
        {
            // Make the same changes to the message that RPC would.
            pCall->message.rpcFlags    |= RPC_BUFFER_COMPLETE;
            pCall->message.reserved2[3] = NULL;

            // get a reference to give to the thread
            pCall->AddRef();

            if (_pOXIDEntry->IsMTAServer())
            {
                result = CacheCreateThread( ThreadDispatch, pCall );
            }
            else
            {
                result = _pOXIDEntry->PostCallToSTA(pCall);
            }

            if (FAILED(result))
            {
                // fix up the reference count if we fail to get
                // to the other thread.
                pCall->Release();
            }
        }
        else
        {
            LOCK(gComLock);
            Win4Assert( pCall->_eSignalState != pending_ss );
            pCall->_eSignalState = pending_ss;
            UNLOCK(gComLock);

            result = I_RpcSend( (RPC_MESSAGE *) &pCall->message );
            if (result != S_OK)
            {
                result = FIX_WIN32( result );
                pCall->_eSignalState = failed_ss;
        pCall->_pHeader   = NULL;
            }
        }

        if(SUCCEEDED(result))
        {
            pCall->_pHandle->_fFirstCall = FALSE;
            if(FAILED(pCall->CallSent()))
                pCall->Cancel(FALSE, 0);
        }

        // Make sure FreeBuffer doesn't try to free the in buffer.
        pMessage->Buffer = NULL;

        // If the call failed, clean up.
        if (result != S_OK)
        {
            result = ClientNotify( NULL, 0, NULL, 0, result,
                                   pCall );

            // Clean up the call.
            _pStdId->UnlockClient();
            pCall->CallFinished();
            pCall->Release();
            pMessage->reserved1 = NULL;

            // Update connection status maintained by standard identity
            if (result == RPC_E_SERVER_DIED     ||
                result == RPC_E_SERVER_DIED_DNE ||
                result == RPC_E_DISCONNECTED    ||
                result == MAKE_WIN32(RPC_S_SERVER_UNAVAILABLE))
               _pStdId->SetConnectionStatus(result);
        }

        // Make sure the call gets unlocked in FreeBuffer or Cancel.
        else
        {
            pCall->Lock();
        }
    }
    // Server side.
    else
    {
        // Prevent app from trying to resend the reply.
        pMessage->reserved1 = NULL;
        result              = S_OK;

        // Local
        if (pCall->ProcessLocal())
        {
            // Free request buffer
            PrivMemFree8( pCall->_pRequestBuffer );

            // Clean up the call context and server signal.
            if (pCall->_pContext)
            {
                pCall->_pContext->Release();
                pCall->_pContext = NULL;
            }

            // Send reply
            pMessage->cbBuffer += (ULONG) ((char *) pMessage->Buffer -
                                  (char *) pCall->_pHeader);
            pMessage->Buffer    = pCall->_pHeader;

            // Change call state only after updating call completion
            // state
            pCall->CallCompleted( &fCanceled );

            // If the client is still waiting, wake him up.
            if (!fCanceled)
                SignalTheClient(pCall);

            // Balance the AddRef in RegisterAsync
            pCall->Release();
        }
        // Remote
        else
        {
            pCall->message.reserved1          = pCall->_hRpc;
            pCall->message.cbBuffer           = pMessage->cbBuffer +
                                               (ULONG) ((char *) pMessage->Buffer -
                                                (char *) pCall->_pHeader);
            pCall->message.Buffer             = pCall->_pHeader;
            pCall->message.dataRepresentation = pMessage->dataRepresentation;

            HRESULT result2 = S_OK;
            BOOL fSetNotification = FALSE;
            COleTls Tls(result);
            if(SUCCEEDED(result))
            {
                // We are interested in setting callback notifications for
                // (1) Threads that have been initialized so that we can
                // clean up pending async state at uninitialize time.
                // (2) Cross-machine calls
                if(((OLETLS_APARTMENTTHREADED & Tls->dwFlags) ||
                   (OLETLS_MULTITHREADED & Tls->dwFlags)) &&
                   !pCall->_destObj.MachineLocal())
                {
                    // Init the state to receive send complete notifications
                    result = pCall->InitForSendComplete();
                    if(SUCCEEDED(result))
                    {
                        // set the handle to receive send complete notifications
                        result = I_RpcAsyncSetHandle((RPC_MESSAGE *) &pCall->message,
                                                    &(pCall->_AsyncState));
                        if(SUCCEEDED(result))
                        {
                            fSetNotification = TRUE;
                        }
                    }
                }
            }

            // Send reply.  Ignore errors because replies can fail.
            result2 = I_RpcSend( (RPC_MESSAGE *) &pCall->message );

            if (FAILED(result2))
            {
                // If the send fails then we will not receive a notification
                fSetNotification = FALSE;

                ComDebOut((DEB_ERROR, "CRpcChannelBuffer::AsyncSend: I_RpcSend failure when sending reply: 0x%x\n",
                           result2));
            }
            else
            {
                if(fSetNotification)
                {
                    // Increment the count of number of sends outstanding
                    Tls->cAsyncSends++;
                    // Chain to the list
                    pCall->_pNext = Tls->pAsyncCallList;
                    Tls->pAsyncCallList = pCall;

                    // Enter an alertable wait state to receive the
                    // callback notification from RPC. If the callback
                    // does not arrive by the end of the wait period
                    // then it will be handled at CoUninitialize
                    SleepEx(10,TRUE);
                }
            }

            if(!fSetNotification)
            {
                // Release the reference on the call object which
                // would have been released in the notification method
                // had we set the notification
                pCall->Release();
            }
        }
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    gOXIDTbl.ValidateOXID();
    ComDebOut((DEB_CHANNEL, "CRpcChannelBuffer::AsyncSend hr:%x\n", result));
    *pulStatus = result;
    return result;
}

//-------------------------------------------------------------------------
//
//  Member:     CRpcChannelBuffer::Receive
//
//  Synopsis:   Wrapper for receive.  Used when no apartment call controller
//              wraps the channel.
//
//-------------------------------------------------------------------------
STDMETHODIMP CRpcChannelBuffer::Receive( RPCOLEMESSAGE *pMessage,
                                         ULONG uSize, ULONG *pulStatus )
{
    return Receive2( pMessage, uSize, pulStatus );
}

//-------------------------------------------------------------------------
//
//  Member:     CRpcChannelBuffer::Receive
//
//  Synopsis:   Wrapper for receive.  Used when no apartment call controller
//              wraps the channel.
//
//-------------------------------------------------------------------------
STDMETHODIMP CRpcChannelBuffer::Receive( RPCOLEMESSAGE *pMessage, ULONG *pulStatus )
{
    return Receive( pMessage, 0, pulStatus );
}

//-------------------------------------------------------------------------
//
//  Member:     CRpcChannelBuffer::Receive2
//
//  Synopsis:   Forwards to PipeReceive or AsyncReceive.
//
//-------------------------------------------------------------------------
HRESULT CRpcChannelBuffer::Receive2( RPCOLEMESSAGE *pMessage,
                                     ULONG uSize, ULONG *pulStatus )
{
    if ( pMessage->rpcFlags & RPC_BUFFER_PARTIAL )
        return E_INVALIDARG;

    return AsyncReceive( pMessage, uSize, pulStatus );
}

//-------------------------------------------------------------------------
//
//  Member:     CRpcChannelBuffer::AsyncReceive
//
//  Synopsis:   Receives the reply for an asynchronous call.  Cleans up
//              the call and deletes it if necessary.
//
//-------------------------------------------------------------------------
HRESULT CRpcChannelBuffer::AsyncReceive( RPCOLEMESSAGE *pMessage,
                                         ULONG uSize, ULONG *pulStatus )
{
    TRACECALL(TRACE_RPC, "CRpcChannelBuffer::AsyncReceive");
    ComDebOut((DEB_CHANNEL, "CRpcChannelBuffer::AsyncReceive pChnl:%x pMsg:%x\n",
        this, pMessage));

    AssertValid(FALSE, TRUE);
    Win4Assert( Proxy() );
    Win4Assert( pMessage->rpcFlags & RPC_BUFFER_ASYNC );
    gOXIDTbl.ValidateOXID();
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT          result;
    HRESULT          tmp;
    CAsyncCall      *pCall = (CAsyncCall *) pMessage->reserved1;
    WireThat        *pOutb = NULL;
    char            *stub_data;

    // Return an error if the call is canceled.
    if (pCall == NULL)
        return RPC_E_CALL_CANCELED;

    // Receive the reply buffer
    if (pCall->ProcessLocal())
    {
        // Make sure the call completed.
        if (pCall->IsCallCompleted())
        {
            pOutb  = (WireThat *) pCall->_pHeader;
            result = pCall->GetResult();
        }
        else if (pCall->IsCallCanceled() && pCall->GetTimeout()==0)
            result = RPC_E_CALL_CANCELED;
        else
            result = RPC_S_CALLPENDING;
    }
    else
    {
        // Ask unto RPC for the reply.
        result = I_RpcReceive( (RPC_MESSAGE *) &pCall->message, 0 );

        // Byte swap the reply header.  Fail the call if the buffer is too
        // small.
        if (result == RPC_S_OK)
        {
            pCall->_pHeader = pCall->message.Buffer;
            pOutb           = (WireThat *) pCall->_pHeader;
            if (pCall->message.cbBuffer >= sizeof(WireThatPart1))
            {
                ByteSwapThat( pCall->message.dataRepresentation, pOutb);
            }
            else
            {
                pOutb = NULL;
                I_RpcFreeBuffer( (RPC_MESSAGE *) &pCall->message );
                result = RPC_E_INVALID_HEADER;
            }
        }

        // Convert status pending to HRESULT pending.
        else if (result == RPC_S_ASYNC_CALL_PENDING)
            result = RPC_S_CALLPENDING;
        else
            result = FIX_WIN32( result );
    }

    // Don't clean up or complete it if the call is still pending.
    if (result == RPC_S_CALLPENDING)
    {
        *pulStatus = result;
        return result;
    }

    // If the apartment is bad, fail the call and clean up.
    if (GetCurrentApartmentId() != pCall->_lApt)
        result = RPC_E_WRONG_THREAD;

    // Figure out when to retry.
    //    FreeThreaded - treat retry as a failure.
    //    Apartment    - return the buffer and let call control decide.
    if (result == S_OK)
    {
        if (IsMTAThread())
        {
            if (pOutb->c.flags & ORPCF_REJECTED)
                result = RPC_E_CALL_REJECTED;
            else if (pOutb->c.flags & ORPCF_RETRY_LATER)
                result = RPC_E_SERVERCALL_RETRYLATER;
            else
                *pulStatus = S_OK;
        }
        else if (pOutb->c.flags & ORPCF_REJECTED)
            *pulStatus = (ULONG) RPC_E_CALL_REJECTED;
        else if (pOutb->c.flags & ORPCF_RETRY_LATER)
            *pulStatus = (ULONG) RPC_E_SERVERCALL_RETRYLATER;
        else
            *pulStatus = S_OK;
    }

    // Check the packet extensions.
    stub_data = (char *) pCall->_pHeader;
    tmp       = ClientNotify( pOutb, pCall->message.cbBuffer,
                              (void **) &stub_data,
                              pCall->message.dataRepresentation,
                              result, pCall );

    // If the packet header was bad, clean up the call.
    if (SUCCEEDED(result) && FAILED(tmp))
    {
        Win4Assert( !pCall->ProcessLocal() );
        I_RpcFreeBuffer( (RPC_MESSAGE *) &pCall->message );
        result           = tmp;
    }

    // Call succeeded.
    if (result == S_OK)
    {
        // Set up the proxy's message.
        pMessage->Buffer       = stub_data;
        pMessage->cbBuffer     = pCall->message.cbBuffer -
                                 (ULONG)(stub_data - (char *) pCall->_pHeader);
        pMessage->dataRepresentation = pCall->message.dataRepresentation;
        result                 = *pulStatus;
    }
    else
    {
        // Make sure FreeBuffer doesn't try to free the in buffer.
        pMessage->Buffer = NULL;
        if(!pCall->ProcessLocal())
            pCall->_pHeader  = NULL;

        // If the result is server fault, get the exception code from the CMessageCall.
        if (result == RPC_E_SERVERFAULT)
        {
            *pulStatus = pCall->GetFault();
        }
        // Everything else is a comm fault.
        else if (result != S_OK)
        {
            *pulStatus = result;
            result = RPC_E_FAULT;
        }

        // Clean up the call.
        if (pCall->Locked())
            _pStdId->UnlockClient();
        pCall->CallFinished();
        pCall->Release();
        pMessage->reserved1 = NULL;

        // Since result is almost always mapped to RPC_E_FAULT, display the
        // real error here to assist debugging.
        if (*pulStatus != S_OK)
        {
            ComDebOut((DEB_CHANNEL, "ORPC call failed. status = %x\n", *pulStatus));

            // Update connection status maintained by standard identity
            if(*pulStatus==RPC_E_SERVER_DIED ||
               *pulStatus==RPC_E_SERVER_DIED_DNE ||
               *pulStatus==RPC_E_DISCONNECTED ||
               *pulStatus==(ULONG)MAKE_WIN32(RPC_S_SERVER_UNAVAILABLE))
               _pStdId->SetConnectionStatus(*pulStatus);
        }
    }

    // Update connection status if the call succeeded
    if(*pulStatus==S_OK && _pStdId->GetConnectionStatus()!=S_OK)
        _pStdId->SetConnectionStatus(S_OK);

    ASSERT_LOCK_NOT_HELD(gComLock);
    gOXIDTbl.ValidateOXID();
    ComDebOut((DEB_CHANNEL, "CRpcChannelBuffer::AsyncReceive hr:%x\n", result));
    return result;
}

/***************************************************************************/
STDMETHODIMP CRpcChannelBuffer::SendReceive( THIS_ RPCOLEMESSAGE *pMessage,
                                             ULONG *status )
{
    return CRpcChannelBuffer::SendReceive2(pMessage, status);
}


/***************************************************************************/
STDMETHODIMP CRpcChannelBuffer::SendReceive2( THIS_ RPCOLEMESSAGE *pMessage,
                                              ULONG *status )
{
    TRACECALL(TRACE_RPC, "CRpcChannelBuffer::SendReceive2");
    ComDebOut((DEB_CHANNEL, "CRpcChannelBuffer::SendReceive2 pChnl:%x pMsg:%x\n",
      this, pMessage));

    gOXIDTbl.ValidateOXID();
    AssertValid(FALSE, TRUE);
    Win4Assert( Proxy() );
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT          result;
    HRESULT          resultSave = S_OK;
    WireThat        *pOutb;
    char            *stub_data;
    BOOL            bEnumRpcErrorInfo = FALSE;
    BOOL            bSaveResult = FALSE;
    RPC_ERROR_ENUM_HANDLE EnumHandle;
    RPC_EXTENDED_ERROR_INFO ErrorInfo;
    CMessageCall *pCall = (CMessageCall *) pMessage->reserved1;
    Win4Assert( pCall != NULL );
    Win4Assert( (pMessage->rpcFlags & RPC_BUFFER_ASYNC) == 0 );

    // Set up the header pointers.
    WireThis *pInb = (WireThis *) pCall->_pHeader;
    IID iid = *MSG_TO_IIDPTR( &pCall->message );

    // we must ensure that we dont go away during this call. we will Release
    // ourselves in the FreeBuffer call, or in the error handling at the
    // end of this function.
    _pStdId->LockClient();

    #if DBG==1
    DWORD CallCat = GetCallCat( pInb );
    DebugPrintORPCCall(ORPC_SENDRECEIVE_BEGIN, iid, pCall->message.iMethod, CallCat);
    RpcSpy((CALLOUT_BEGIN, pInb, iid, pCall->message.iMethod, 0));
    #endif

    BOOL fLogEventIsActive = LogEventIsActive();
    ULONG_PTR RpcValues[5];               // Store for logging parameters

    if (fLogEventIsActive)            // Log before/after the call if necessary
    {
        RpcValues[0] = (ULONG_PTR) (_pIPIDEntry ? &_pIPIDEntry->ipid         : &GUID_NULL);
        RpcValues[1] = (ULONG_PTR) (_pOXIDEntry ? _pOXIDEntry->GetMoxidPtr() : &GUID_NULL);
        RpcValues[2] = (ULONG_PTR) &pMessage;               // CorrelationID
        RpcValues[3] = (ULONG_PTR) &iid;                    // IID
        RpcValues[4] = (ULONG_PTR) pCall->message.iMethod;  // Method index

        LogEventClientCall(RpcValues);
    }


    // If it is local we have to set the rpcFlags like the rpc runtime would.
    // Don't set the flag for remote calls, RPC complains.
    if (pCall->ProcessLocal())
        pCall->message.rpcFlags |= RPC_BUFFER_COMPLETE;

    // Send the request.
    result = SwitchAptAndDispatchCall( &pCall );

    if (fLogEventIsActive)
    {
        LogEventClientReturn(RpcValues);
    }

    #if DBG==1
    DebugPrintORPCCall(ORPC_SENDRECEIVE_END, iid, pMessage->iMethod, CallCat);
    RpcSpy((CALLOUT_END, pInb, iid, pMessage->iMethod, result));
    #endif

    pOutb = (WireThat *) pCall->_pHeader;
    ULONG cMax = pCall->message.cbBuffer;
    // Figure out when to retry.
    //    FreeThreaded - treat retry as a failure.
    //    Apartment    - return the buffer and let call control decide.

    if (result == S_OK)
    {
        if (IsMTAThread())
        {
            if (pOutb->c.flags & ORPCF_REJECTED)
                result = RPC_E_CALL_REJECTED;
            else if (pOutb->c.flags & ORPCF_RETRY_LATER)
                result = RPC_E_SERVERCALL_RETRYLATER;
            else
                *status = S_OK;
        }
        else if (pOutb->c.flags & ORPCF_REJECTED)
            *status = (ULONG) RPC_E_CALL_REJECTED;
        else if (pOutb->c.flags & ORPCF_RETRY_LATER)
            *status = (ULONG) RPC_E_SERVERCALL_RETRYLATER;
        else
            *status = S_OK;
    }
    else
    {
       // see if we have extended error information in the 
       // fault PDU
       RPC_STATUS status;
       status = RpcErrorStartEnumeration(&EnumHandle);
#if DBG==1
       if (RPC_S_OK != status && RPC_S_ENTRY_NOT_FOUND != status) 
       {
	  ComDebOut((DEB_CHANNEL, "CRpcChannelBuffer::SendReceive2 RpcErrorStartEnumeration:%x \n",
	    status));
       }
#endif       
       if (RPC_S_OK == status)
	  bEnumRpcErrorInfo = TRUE;
       while(RPC_S_OK == status)
       {
	  ErrorInfo.Version = RPC_EEINFO_VERSION;
	  ErrorInfo.Flags = 0;
	  ErrorInfo.NumberOfParameters = 4;
	  status = RpcErrorGetNextRecord(&EnumHandle, FALSE, &ErrorInfo);	  
#if DBG==1
	  if (RPC_S_OK != status && RPC_S_ENTRY_NOT_FOUND != status) 
	  {
	     ComDebOut((DEB_CHANNEL, "CRpcChannelBuffer::SendReceive2 RpcErrorStartEnumeration:%x \n",
			status));
	  }
#endif       
	  if (RPC_S_OK != status) 
	  {
	     break;
	  }
	  if (ErrorInfo.GeneratingComponent == EEInfoGCCOM &&
	      ErrorInfo.NumberOfParameters == 1 &&
	      ErrorInfo.Parameters[0].ParameterType == eeptBinary) 
	  {
	     cMax = ErrorInfo.Parameters[0].u.BVal.Size;
	     pOutb = (WireThat *)ErrorInfo.Parameters[0].u.BVal.Buffer;
	     Win4Assert(ErrorInfo.Status == result);
	     bSaveResult = TRUE;
	     resultSave = result;
	     result = S_OK;
	  }
       }
    }

    stub_data = (char *) pOutb;
    result = ClientNotify( pOutb, cMax,
                           (void **) &stub_data,
                           pCall->message.dataRepresentation,
                           result, pCall );

    if (bEnumRpcErrorInfo) 
    {
       RpcErrorEndEnumeration(&EnumHandle);       
    }
    if (bSaveResult && result == S_OK) 
    {
       result = resultSave;
    }
    // Call succeeded.
    if (result == S_OK)
    {
        // The locked flag lets FreeBuffer know that it has to call
        // RH->UnlockClient.
        pCall->Lock();
        pMessage->Buffer       = stub_data;
        pMessage->cbBuffer     = pCall->message.cbBuffer -
                                 (ULONG)(stub_data - (char *) pCall->_pHeader);
        pMessage->dataRepresentation = pCall->message.dataRepresentation;
        result                 = *status;
    }
    else
    {
        // Clean up the call.
        _pStdId->UnlockClient();

        // Make sure FreeBuffer doesn't try to free the in buffer.
        pMessage->Buffer = NULL;

        // If the result is server fault, get the exception code from the CMessageCall.
        if (result == RPC_E_SERVERFAULT)
        {
            *status = pCall->GetFault();
        }
        // Everything else is a comm fault.
        else if (result != S_OK)
        {
            *status = result;
            result = RPC_E_FAULT;
        }

        // Inform call object about the failure
        pCall->CallFinished();
        pCall->Release();

        // Since result is almost always mapped to RPC_E_FAULT, display the
        // real error here to assist debugging.
        if (*status != S_OK)
        {
            ComDebOut((DEB_CHANNEL, "ORPC call failed. status = %x\n", *status));

            // Update connection status maintained by standard identity
            if(*status==RPC_E_SERVER_DIED ||
               *status==RPC_E_SERVER_DIED_DNE ||
               *status==RPC_E_DISCONNECTED ||
               *status==(ULONG)MAKE_WIN32(RPC_S_SERVER_UNAVAILABLE))
              _pStdId->SetConnectionStatus(*status);
        }
    }

    // Update connection status if the call succeeded
    if(*status==S_OK && _pStdId->GetConnectionStatus()!=S_OK)
        _pStdId->SetConnectionStatus(S_OK);

    ASSERT_LOCK_NOT_HELD(gComLock);
    gOXIDTbl.ValidateOXID();
    ComDebOut((DEB_CHANNEL, "CRpcChannelBuffer::SendReceive hr:%x\n", result));
    return result;
}

//+-------------------------------------------------------------------------
//
//  Member:     DispatchCall
//
//  Synopsis:   Dispatches the call to the servers apartment.
//
//  History:    26-Feb-98   Johnstra    Created
//              05-06-98    Rickhi      Separated from SwitchAptAndDispatch
//
//--------------------------------------------------------------------------
HRESULT DispatchCall(CMessageCall* pCall)
{
    ComDebOut((DEB_APT, "DispatchCall: call :%x\n", pCall));

    // ThreadDispatch expects a reference on the call object
    pCall->AddRef();

    // In order to prevent an assert in CEventCache::Free, we must
    // indicate that this is a thread-local call.  This prevents
    // ThreadDispatch from setting the call event.  Normally, this
    // event is set to signal a waiting thread.  Because there is
    // no waiting thread to reset the event, CEventCache::Free
    // asserts because the event is set
    BOOL fThreadLocal = pCall->ThreadLocal();
    pCall->SetThreadLocal(TRUE);

    // Dispatch the call on this thread
    ThreadDispatch(pCall);

    // Reset the calls state
    pCall->SetThreadLocal( fThreadLocal );

    // return the result of the call
    ComDebOut((DEB_APT, "DispatchCall: returning:%x\n", pCall->GetResult()));
    return pCall->GetResult();
}


//+-------------------------------------------------------------------------
//
//  Member:     CRpcChannelBuffer::SwitchAptAndDispatchCall
//
//  Synopsis:   Dispatches the call to the servers apartment.  If the caller
//              or callee are in the NA, this function enters/leaves the
//              NTA or leaves/reenters the NA, as appropriate and saves
//              and restores any necessary TLS state.
//
//  History:    26-Feb-98   Johnstra    Created
//
//--------------------------------------------------------------------------
HRESULT CRpcChannelBuffer::SwitchAptAndDispatchCall( CMessageCall** ppCall )
{
    ComDebOut(( DEB_APT, "SwitchAptAndDispatchCall, ppCall:%08X\n", ppCall ));

    CMessageCall*    pCall  = *ppCall;
    HRESULT          result;

    if (pCall->ProcessLocal())
    {
        if( pCall->IsClientSide() )
            pCall->message.reserved2[3] = NULL;

        if (pCall->Neutral())
        {
            // The server is in the NTA.
            Win4Assert(!IsThreadInNTA() && "Thread in NTA");

            result = DispatchCall(pCall);

            Win4Assert(!IsThreadInNTA() && "Thread is still in NTA");
        }
        else if (IsThreadInNTA())
        {
            // Calling out of the NA into either the MTA or an STA.  We leave
            // the NA and then dispatch the call depending on the type of
            // server we are calling and the type of thread in which the client
            // is executing.  Then, when we return from the call, we place
            // ourselves back in the NA.
            //
            BOOL fSTA = IsSTAThread();
            COleTls Tls;
            CObjectContext *pDefaultCtx = fSTA ? Tls->pNativeCtx : g_pMTAEmptyCtx;
            CObjectContext *pSavedCtx = LeaveNTA(pDefaultCtx);
            Win4Assert(!IsThreadInNTA() && "Thread is in NA");

            if (_pOXIDEntry->IsMTAServer())
            {
                // The server is in the MTA.

                // We decide whether a thread switch is required by looking at
                // the client apartments thread type.
                //
                if (fSTA)
                {
                    // The client is on an STA thread, therefore we must do a
                    // thread switch to get to the MTA.
                    //
                    result = SwitchSTA(_pOXIDEntry, ppCall);
                }
                else
                {
                    // The client is on an MTA thread, therefore no thread switch
                    // is required, just switch the apartment type and invoke the
                    // call on this thread.
#if DBG == 1
                    pCall->SetNAToMTAFlag();
#endif
            result = DispatchCall(pCall);
#if DBG == 1
                    pCall->ResetNAToMTAFlag();
#endif
                }
            }
            else
            {
                // The server is in an STA.

                // How we get to the servers STA depends on the client
                // apartments thread type.
                //
                if (fSTA)
                {
                    // The client is on an STA thread.  We must switch
                    // to the servers STA.  Note that the server may or may not
                    // be on this thread (i.e. we may have called from an STA
                    // into the NA and are now calling back into a different object
                    // in the same STA).
                    //
#if DBG == 1
                    pCall->SetNAToSTAFlag();
#endif
                    result = SwitchSTA(_pOXIDEntry, ppCall);
#if DBG == 1
                    pCall->ResetNAToSTAFlag();
#endif
                }
                else
                {
                    // The client is on an MTA thread.  We must switch to the
                    // servers STA.
                    //
                    result = GetToSTA(_pOXIDEntry, pCall);
                }
            }

            // Hop back into the NTA.
            //
            pSavedCtx = EnterNTA(pSavedCtx);
            Win4Assert(pSavedCtx == pDefaultCtx);

            Win4Assert(IsThreadInNTA() && "Thread is not in NTA" );
        }
        else if (IsSTAThread())
        {
            // Calling out of one STA to another STA.
            //
            result = SwitchSTA( _pOXIDEntry, ppCall );
        }
        else
        {
       // Calling out of the MTA into an STA.

       // 128106. It is possible that this call
       // is to an MTA in a dead server process which
       // happened to have the same PID as the
       // current porcess. Fail the call.

       if (_pOXIDEntry->IsMTAServer() && pCall->ProcessLocal() && !_pOXIDEntry->GetServerHwnd())
       {
          ComDebOut((DEB_APT, "Warning: The process that hosted this server died\n"));
          result = RPC_E_SERVER_DIED_DNE;
       }
       else

          result = GetToSTA( _pOXIDEntry,  pCall );
        }
    }
    else
    {
        // For non-local MTA, call ThreadSendReceive directly.
        //

#ifndef _CHICAGO_
        // Upper layer focus management! Only if we are going
        // to an STA on the local machine
        if (_pOXIDEntry->IsOnLocalMachine() &&
            _pOXIDEntry->IsSTAServer() )
        {
            BOOL bASFW = FALSE;
            REFIID riid = *MSG_TO_IIDPTR( &pCall->message );
            if ((&pCall->message)->iMethod==11)
            {
                if (riid == IID_IOleObject)
                {
                    bASFW = TRUE;
                }
            }
            else if ((&pCall->message)->iMethod==7)
            {
                if (riid == IID_IAdviseSink)
                {
                    bASFW = TRUE;
                }
            }
            if (bASFW)
            {
                // The target app is likely to attempt & take focus
                // so give it the permission to do so.
                // Not much we can do if the call fails.
                AllowSetForegroundWindow(_pOXIDEntry->GetPid());
            }
        }
#endif // _CHICAGO_

        result = ThreadSendReceive( pCall );
    }

    ComDebOut(( DEB_APT, "SwitchAptAndDispatchCall: leaving result:%08X\n", result ));
    return result;
}


#if DBG == 1
//+-------------------------------------------------------------------
//
//  Member: CRpcChannelBuffer::AssertValid
//
//  Synopsis:   Validates that the state of the object is consistent.
//
//  History:    25-Jan-94   CraigWi Created.
//
// DCOMWORK - Put in some asserts.
//
//--------------------------------------------------------------------
void CRpcChannelBuffer::AssertValid(BOOL fKnownDisconnected,
                            BOOL fMustBeOnCOMThread)
{
    Win4Assert(state & (proxy_cs | client_cs | server_cs ));

    if (state & (client_cs | proxy_cs))
    {
        ;
    }
    else if (Server())
    {
       if (fMustBeOnCOMThread && IsSTAThread())
           Win4Assert(IsMTAThread()
                      || _pOXIDEntry->GetTid() == GetCurrentThreadId()
                      || IsThreadInNTA());

       // ref count can be 0 in various stages of connection and disconnection
       Win4Assert(_cRefs < 0x7fff && "Channel ref count unreasonably high");

       // the pStdId pointer can not be NULL
       // Win4Assert(IsValidInterface(_pStdId));
    }
}
#endif // DBG == 1

/***************************************************************************/
extern "C"
BOOL _stdcall DllDebugObjectRPCHook( BOOL trace, LPORPC_INIT_ARGS pass_through )
{
    if (!IsWOWThread())
    {
        DoDebuggerHooks = trace;
        DebuggerArg     = pass_through;
        return TRUE;
    }
    else
        return FALSE;
}

/***************************************************************************/
BOOL LocalCall()
{
    // Get the call info from TLS.
    COleTls tls;
    CMessageCall *pCall = (CMessageCall *) tls->pCallInfo;
    Win4Assert( pCall != NULL );
    return pCall->ProcessLocal();
}

/***************************************************************************/
/* This routine returns both comm status and server faults to the runtime
   by raising exceptions.  If FreeThreading is true, ComInvoke will throw
   exceptions to indicate server faults.  These will not be caught and will
   propagate directly to the runtime.  If FreeThreading is false, ComInvoke
   will return the result and fault in the CMessageCall record.

   NOTE:
        This function switches to the 32 bit stack under WIN95.
        An exception has to be caught while switched to the 32 bit stack.
        The exceptions has to be  pass as a value and rethrown again on the
        16 bit stack (see SSInvoke in stkswtch.cxx)
*/

#ifdef _CHICAGO_
LONG
#else
void
#endif
SSAPI(ThreadInvoke)(RPC_MESSAGE *pMessage )
{
    HRESULT          result = S_OK;

    TRACECALL(TRACE_RPC, "ThreadInvoke");
    ComDebOut((DEB_CHANNEL,"ThreadInvoke pMsg:%x\n", pMessage));
    gOXIDTbl.ValidateOXID();
    ASSERT_LOCK_NOT_HELD(gComLock);

    WireThis        *pInb    = (WireThis *) pMessage->Buffer;
    IPID             ipid;
    RPC_STATUS       status;
    unsigned int     transport_type;
    DWORD            authn_level;
    BOOL             fFakeAsync = FALSE;
    CAsyncCall      *pCall  = NULL;
    OXIDEntry       *pOXIDEntry = NULL;
    IPIDEntry       *pIPIDEntry = NULL;


    // Byte swap the header.
    ByteSwapThis( pMessage->DataRepresentation, pInb );

    // Validate several things:
    //            The packet size is larger then the first header size.
    //            No extra flags are set.
    //            The procedure number is greater then 2 (not QI, AddRef, Release).
    if (sizeof(WireThisPart1) > pMessage->BufferLength                ||
        (pInb->c.flags & ~(ORPCF_LOCAL | ORPCF_RESERVED1 |
          ORPCF_RESERVED2 | ORPCF_RESERVED3 | ORPCF_RESERVED4)) != 0 ||
        pMessage->ProcNum < 3)
    {
        RETURN_COMM_STATUS( RPC_E_INVALID_HEADER );
    }

    // Validate the version.
    if (pInb->c.version.MajorVersion != COM_MAJOR_VERSION ||
        pInb->c.version.MinorVersion > COM_MINOR_VERSION)
        RETURN_COMM_STATUS( RPC_E_VERSION_MISMATCH );

    // Get the transport the call arrived on.
    ComDebOut((DEB_CHANNEL,"->I_RpcBindingInqTransportType\n"));
    status = I_RpcBindingInqTransportType(NULL, &transport_type );
    ComDebOut((DEB_CHANNEL,"<-I_RpcBindingInqTransportType(status=0x%x, transport_type=0x%x\n", status, transport_type));
    if (status != RPC_S_OK)
        RETURN_COMM_STATUS( RPC_E_SYS_CALL_FAILED );

    if (pInb->c.flags & ORPCF_LOCAL)
    {
        // Don't accept the local header on remote calls.
        if (transport_type != TRANSPORT_TYPE_LPC)
            RETURN_COMM_STATUS( RPC_E_INVALID_HEADER );
#ifdef _CHICAGO_
        // For Win95 the authentication level will always be none
        authn_level = RPC_C_AUTHN_LEVEL_NONE;
#else // _CHICAGO_
        // For local calls the authentication level will always be encrypt.
        authn_level = RPC_C_AUTHN_LEVEL_PKT_PRIVACY;
#endif // _CHICAGO_
    }
    else if (gDisableDCOM &&
      (transport_type == TRANSPORT_TYPE_CN || transport_type == TRANSPORT_TYPE_DG))
    {
        // Don't accept remote calls if DCOM is disabled.
        RETURN_COMM_STATUS( RPC_E_CALL_REJECTED );
    }

#if DBG==1
    _try
    {
#endif

    // Find the ipid from the RPC messsage.
    ComDebOut((DEB_CHANNEL,"->RpcBindingInqObject(hdl=0x%x)\n", pMessage->Handle));
    status = RpcBindingInqObject( pMessage->Handle, &ipid );
    ComDebOut((DEB_CHANNEL,"<-RpcBindingInqObject(status=0x%x, ipid=%I)\n", status, &ipid));

    if (status == RPC_S_OK)
    {
        // Create a call object
        status = GetCallObject(TRUE /*fAsync */, (CMessageCall **)&pCall);
        if (SUCCEEDED(status))
        {
            status = pCall->InitCallObject(GetCallCat( pInb ),
                                          (RPCOLEMESSAGE *) pMessage,
                                          server_cs,
                                          ipid,
                                          (pInb->c.flags & ORPCF_LOCAL) ? MSHCTX_LOCAL
                                                                        : MSHCTX_DIFFERENTMACHINE,
                                          pInb->c.version,
                                          NULL);

            if (SUCCEEDED(status))
            {
                // Save some fields from the RPC message
                Win4Assert( status == S_OK );
                pCall->_hRpc           = pMessage->Handle;
                pCall->_pRequestBuffer = pMessage->Buffer;

                ASSERT_LOCK_NOT_HELD(gIPIDLock);
                LOCK(gIPIDLock);

                // Find the ipid entry from the ipid.

                result = gIPIDTbl.LookupFromIPIDTables(ipid, &pIPIDEntry, &pOXIDEntry);
                if (FAILED(result))
                {
                    UNLOCK(gIPIDLock);
                    ASSERT_LOCK_NOT_HELD(gIPIDLock);
                    Win4Assert(result == RPC_E_DISCONNECTED ||
                               result == E_NOINTERFACE);
                }
                else
                {
                    if (pOXIDEntry->IsMTAServer() ||
                        pOXIDEntry->IsNTAServer() )
                    {
                        // The call is destined for the MTA or NTA apartment, call
                        // ComInvoke on this thread. This subroutine releases
                        // the lock before it returns.
                        result = ComInvokeWithLockAndIPID( pCall, pIPIDEntry );
                        ASSERT_LOCK_NOT_HELD(gIPIDLock);
                    }
                    else
                    {
                        UNLOCK(gIPIDLock);
                        ASSERT_LOCK_NOT_HELD(gIPIDLock);

                        // For calls to a STA, switch threads and let this thread
                        // return.  The reply will be sent from the STA thread.

                        // Register async
                        Win4Assert(pOXIDEntry->GetTid() != GetCurrentThreadId());
                        status = I_RpcAsyncSetHandle( pMessage, &pCall->_AsyncState );

                        // Wake up the server thread
                        if (status == RPC_S_OK)
                        {
                            fFakeAsync = TRUE;

                            if (pCall->GetCallCategory() == CALLCAT_INPUTSYNC)
                            {
                                // For input sync, use SendMessage.
                                result = pOXIDEntry->SendCallToSTA(pCall);
                            }
                            else
                            {
                                // For sync use PostMessage.
                                result = pOXIDEntry->PostCallToSTA(pCall);
                            }

                            if (result == S_OK)
                            {
                                // we gave away our reference on the call object to
                                // the server thread
                                pCall = NULL;
                            }
                        }
                        else
                        {
                            result = MAKE_WIN32(status);
                        }
                    }

                    // Release the OXID.
                    pOXIDEntry->DecRefCnt();
                }
            }
        }
    }
    else
    {
        result = MAKE_WIN32( status );
    }

#if DBG==1
    }
    _except(ThreadInvokeExceptionFilter(GetExceptionCode(), GetExceptionInformation()))
    {
    }
#endif

    gOXIDTbl.ValidateOXID();
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // Check if the call was implicitly converted to async
    if(fFakeAsync)
    {
        if(pCall)
        {
            // Abort the call
            Win4Assert(FAILED(result));
            I_RpcAsyncAbortCall( &pCall->_AsyncState, result );
            pCall->Release();
        }
    }
    else
    {
        if (pCall)
        {
            // Copy from the call message to RPC's message.
            pMessage->Buffer       = pCall->message.Buffer;
            pMessage->BufferLength = pCall->message.cbBuffer;
            pCall->Release();
            pCall = NULL;
        }

        // For comm and server faults, generate an exception.  Otherwise the buffer
        // is set up correctly.
        if (result != S_OK)
        {
            RETURN_COMM_STATUS(result);
        }
    }

#ifdef _CHICAGO_
    return 0;
#endif //_CHICAGO_
}

#ifdef _CHICAGO_
//+---------------------------------------------------------------------------
//
//  Function:   ThreadInvoke
//
//  Synopsis:   Switches to 32 bit stack and calls ThreadInvoke
//
//----------------------------------------------------------------------------
void ThreadInvoke(RPC_MESSAGE *pMessage)
{
    DWORD dwRet;
    StackDebugOut((DEB_ITRACE, "ThreadInvoke\n"));
    if (SSONSMALLSTACK())
    {
        StackDebugOut((DEB_STCKSWTCH, "SSThreadInvoke: 16->32\n"));
        dwRet = SSCall(4, SSF_BigStack, (LPVOID)SSThreadInvoke, (DWORD)pMessage);
        StackDebugOut((DEB_STCKSWTCH, "SSThreadInvoke 16<-32 done\n"));
    }
    else
    {
        dwRet = SSThreadInvoke(pMessage);
    }
    if (   (dwRet == RPC_E_SERVERFAULT)
        || (   dwRet != RPC_E_SERVERCALL_REJECTED
            && dwRet != RPC_E_SERVERCALL_RETRYLATER
            && dwRet != S_OK))
    {
        RpcRaiseException( dwRet );
    }
}
#endif



/***************************************************************************/
HRESULT SSAPI(ThreadSendReceive( CMessageCall *pCall ))
{
    TRACECALL(TRACE_RPC, "ThreadSendReceive");
    ComDebOut((DEB_CHANNEL, "ThreadSendReceive pCall:%x\n", pCall));

    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT            result;
    RPCOLEMESSAGE     *pMessage = &((CMessageCall *) pCall)->message;
    WireThat          *pOutb;
    BOOL              fFree = FALSE;
    BOOL              fSent = FALSE;
    CAsyncCall        *pAsyncCall;

    // Assert that this method is invoked only on the client side
    Win4Assert(pCall->IsClientSide());

    // Check with call object if it is OK to dispatch the call
    result = pCall->CanDispatch();
    ComDebOut((DEB_CHANNEL, "CanDispatch rc:%x\n", result));

    if(SUCCEEDED(result))
    {
        // Check for fake async calls
        if (pCall->FakeAsync())
        {
            if(SUCCEEDED(result))
            {
                // Register async.
                Win4Assert( !pCall->ClientAsync() );
                pAsyncCall = (CAsyncCall *) pCall;
                result = I_RpcAsyncSetHandle( (RPC_MESSAGE *) &pCall->message,
                                              &pAsyncCall->_AsyncState );
                ComDebOut((DEB_CHANNEL, "I_RpcAsyncSetHandle rc:%x\n", result));

                if (result != RPC_S_OK)
		{
		   fFree = TRUE;
		   result = MAKE_WIN32( result );
		}
                else
                {
                    // Send
                    // AddRef the async call object before calling RPC
                    // This reference is released inside ThreadSignal
                    pAsyncCall->AddRef();
#if DBG==1
                    Win4Assert(pAsyncCall->Release() != 0);
                    pAsyncCall->AddRef();
#endif

                    Win4Assert( pAsyncCall->_eSignalState != pending_ss );
                    pAsyncCall->_eSignalState = pending_ss;
                    result = I_RpcSend( (RPC_MESSAGE *) &pCall->message );
                    ComDebOut((DEB_CHANNEL, "I_RpcSend rc:%x\n", result));

                    if (result != RPC_S_OK)
                    {
                        // Fix up the ref count
                        pAsyncCall->_eSignalState = failed_ss;
                        Win4Assert(!pAsyncCall->IsSignaled());
                        pAsyncCall->Release();
                        result = MAKE_WIN32( result );
                    }
                    else if (IsSTAThread())
                    {
                        ComDebOut((DEB_CHANNEL, "STA Thread FakeAsync\n"));
                        // STA Thread
                        // Inform async call object that the call has
                        // been sent
                        fSent = TRUE;

                        // Enter a modal loop.
                        result = ModalLoop(pCall);
                        ComDebOut((DEB_CHANNEL, "ModalLoop rc:%x\n", result));

                        // Receive
                        result = I_RpcReceive( (RPC_MESSAGE *) &pCall->message, 0 );
                        ComDebOut((DEB_CHANNEL, "I_RpcReceive rc:%x\n", result));
                        Win4Assert( result != RPC_S_ASYNC_CALL_PENDING );

                        // Assert that call completed has been called
                        Win4Assert(pCall->IsCallCompleted());
                    }
                    else
                    {
                        // MTA Thread
                        // Wait for the either the call to complete
                        // or get canceled or timeout to occur

                        Win4Assert(IsMTAThread());
                        ComDebOut((DEB_CHANNEL, "MTA Thread FakeAsync\n"));

                                                // Inform async call object that the call has
                        // been sent
                        fSent = TRUE;

                        result = RPC_S_CALLPENDING;
                        while(result == RPC_S_CALLPENDING)
                        {
                            DWORD dwTimeout = pCall->GetTimeout();
                            DWORD dwReason = WaitForSingleObject(pCall->GetEvent(),
                                                                 dwTimeout);
                            if(dwReason==WAIT_OBJECT_0)
                            {
                                result = S_OK;
                            }
                            else if(dwReason==WAIT_TIMEOUT)
                            {
                                result = RPC_E_CALL_CANCELED;
                                Win4Assert(pCall->GetTimeout() == 0);
                            }
                            else
                            {
                                result = RPC_E_SYS_CALL_FAILED;
                                break;
                            }

                            result = pCall->RslvCancel(dwReason, result, FALSE, NULL);
                        }
                        result = I_RpcReceive( (RPC_MESSAGE *) &pCall->message, 0 );
                        ComDebOut((DEB_CHANNEL, "I_RpcReceive rc:%x\n", result));
                        Win4Assert( result != RPC_S_ASYNC_CALL_PENDING );

                        // Assert that call completed has been called
                        Win4Assert(pCall->IsCallCompleted());
                    }
                }

                // Inform async call object about failure if the call
                // could not be sent
                if(!fSent)
                {
                    pCall->CallCompleted(result);
                }
            }
        }
        else
        {
            // Make a blocking send receive.
            if (SUCCEEDED(result))
            {
                TRACECALL(TRACE_RPC, "I_RpcSendReceive");
                ComDebOut((DEB_CHANNEL,"<-I_RpcSendReceive(pmsg=0x%x)\n",
                           (RPC_MESSAGE *) pMessage));
                result = I_RpcSendReceive( (RPC_MESSAGE *) pMessage );
                ComDebOut((DEB_CHANNEL,"<-I_RpcSendReceive(status=0x%x)\n", result));

                // Inform call object that the call completed
                pCall->CallCompleted(result);
            }
        }
    }
    else
    {
        fFree = TRUE;
    }

    // If the result is small, it is probably a Win32 code.
    if (result != RPC_S_OK)
    {
        if (result == RPC_S_CALL_CANCELLED)
        {
            // The call was canceled, change RPC error to COM error
            result = RPC_E_CALL_CANCELED;
        }
        else
        {
            // Change the error to a win32 code
            result = FIX_WIN32( result );
        }

        if(fFree)
            I_RpcFreeBuffer((RPC_MESSAGE *) pMessage);

        pCall->_pHeader   = NULL;
    }
    else
    {
        // Byte swap the reply header.  Fail the call if the buffer is too
        // small.
        pCall->_pHandle->_fFirstCall = FALSE;
        pCall->_pHeader = pMessage->Buffer;
        pOutb           = (WireThat *) pMessage->Buffer;
        if (pMessage->cbBuffer >= sizeof(WireThatPart1))
        {
            ByteSwapThat( pMessage->dataRepresentation, pOutb);
        }
        else
        {
            I_RpcFreeBuffer( (RPC_MESSAGE *) &pCall->message );
            pCall->_pHeader = NULL;
            result = RPC_E_INVALID_HEADER;
        }
    }

    ComDebOut((DEB_CHANNEL, "ThreadSendReceive pCall:%x hr:%x\n", pCall, result));
    return result;
}

#ifdef _CHICAGO_
//+---------------------------------------------------------------------------
//
//  Function:   ThreadSendReceive
//
//  Synopsis:   Switches to 16 bit stack and calls ThreadSendReceive
//
//----------------------------------------------------------------------------
HRESULT ThreadSendReceive(CMessageCall *pCallInfo)
{
    HRESULT hr;
    if (SSONBIGSTACK())
    {
        StackDebugOut((DEB_STCKSWTCH, "SSThreadSendReceive 32->16\n"));
        hr = SSCall(4, SSF_SmallStack, (LPVOID)SSThreadSendReceive, (DWORD)pCallInfo);
        StackDebugOut((DEB_STCKSWTCH, "SSThreadSendReceive 32->16 done\n"));
    }
    else
    {
        hr = SSThreadSendReceive(pCallInfo);
    }

    return(hr);
}
#endif



//+-------------------------------------------------------------------------
//
//  Class:      CRpcChannelBuffer::CServerCallMgr
//
//  Synopsis:   Server side manager object for async calls
//
//--------------------------------------------------------------------------


//+-------------------------------------------------------------------------------
//
//  Function:   GetChannelCallMgr
//
//  Returns:    S_OK/Failure
//
//  Parameters: pMsg          - the RPC message structure for
//                              handing out to stubs
//              pStub         - the synchronous stub object
//              pServer       - the synchronous server object
//              ppStubBuffer  - out prm for IRpcStubBuffer if. on the obj.
//
//  Synopsis:   Construct an object an get the IRpcStubBuffer interface.
//
//--------------------------------------------------------------------------------
HRESULT GetChannelCallMgr(RPCOLEMESSAGE *pMsg, IUnknown * pStub,
                          IUnknown *pServer, CRpcChannelBuffer::CServerCallMgr **ppStubBuffer)
{
    ComDebOut((DEB_CHANNEL,
               "GetChannelCallMgr [IN] - pMsg:%x, pStub:%x,  pServer:%x, ppStubBuffer:%x\n",
               pMsg, pStub, pServer, ppStubBuffer));

    ASSERT_LOCK_NOT_HELD(gComLock);

    *ppStubBuffer = NULL;

    if (IsWOWProcess() &&
        !(IsEqualGUID(*MSG_TO_IIDPTR(pMsg), IID_IAdviseSink) ||
          IsEqualGUID(*MSG_TO_IIDPTR(pMsg), IID_IAdviseSink2)))
    {
        // don't even try async in WOW.
        return E_FAIL;
    }

    IUnknown *pTest;
    HRESULT hr = pServer->QueryInterface(IID_ICallFactory, (void **)&pTest);
    if (SUCCEEDED(hr))
    {
        pTest->Release();


        // create the object composite
        CRpcChannelBuffer::CServerCallMgr *pObj =
            new CRpcChannelBuffer::CServerCallMgr(pMsg, pStub, pServer, hr);


        if (SUCCEEDED(hr))
        {
            *ppStubBuffer = pObj;
            (*ppStubBuffer)->AddRef();
        }

        // release the reference from the create
        if (pObj)
        {
            pObj->Release();
        }
    }

    ComDebOut((DEB_CHANNEL, "GetChannelCallMgr [OUT]- hr:0x%x\n",hr));
    return hr;
}



//+-------------------------------------------------------------------------------
//
//  Member:     Constructor
//
//  Parameters: pMsg          - the RPC message structure for
//                              handing out to stubs
//              pStub         - the synchronous stub object
//              pServer       - the synchronous server object
//              hr            - success code
//
//  Synopsis:   Create and aggregate all subordinate objects, connect to the
//              stub call object and set up object state.
//
//--------------------------------------------------------------------------------
CRpcChannelBuffer::CServerCallMgr::CServerCallMgr(RPCOLEMESSAGE *pMsg, IUnknown * pStub,
                                                  IUnknown *pServer, HRESULT &hr)
:
_cRefs(1),
_dwState(STATE_WAITINGFORSIGNAL),
_iid(((RPC_SERVER_INTERFACE *) pMsg->reserved2[1])->InterfaceId.SyntaxGUID),
_pUnkStubCallMgr(NULL),
_pUnkServerCallMgr(NULL),
_pSync(NULL),
_pSB(NULL),
_pCall(NULL),
#if DBG==1
_hr(S_OK),
#endif
_pStdID(NULL)
{
    ICallFactory *pCFServer;

    // Get the object server's call factory
    hr = pServer->QueryInterface(IID_ICallFactory, (void **) &pCFServer);
    if (SUCCEEDED(hr))
    {
        // get the async interface's ID
        hr = GetAsyncIIDFromSyncIID(_iid, &_iidAsync);
        if (SUCCEEDED(hr))
        {
            // create the server call manager
            IUnknown *pUnkServerCallMgr;
            hr = pCFServer->CreateCall(_iidAsync, (ISynchronize *) this, IID_IUnknown,
                                       (LPUNKNOWN*) &pUnkServerCallMgr);
            if (SUCCEEDED(hr))
            {
                // get the async interface on the server
                IUnknown *pAsyncInterface;
                hr = pUnkServerCallMgr->QueryInterface(_iidAsync, (void **) &pAsyncInterface);
                if (SUCCEEDED(hr))
                {
                    // get the stub's call factory
                    ICallFactory *pCFStub;
                    hr = pStub->QueryInterface(IID_ICallFactory, (void **) &pCFStub);
                    if (SUCCEEDED(hr))
                    {

                        // create the stub's call manager
                        IUnknown *pUnkStubCallMgr;
                        hr = pCFStub->CreateCall(_iidAsync, NULL, IID_IUnknown,
                                                 (LPUNKNOWN*) &pUnkStubCallMgr);
                        if (SUCCEEDED(hr))
                        {
                            // get the ISychronize interface on the stub
                            ISynchronize *pSync;
                            hr = pUnkStubCallMgr->QueryInterface(IID_ISynchronize, (void **) &pSync);
                            if (SUCCEEDED(hr))
                            {
                                // get the IRpcStubBuffer interface on the stub
                                IRpcStubBuffer *pSB;
                                hr = pUnkStubCallMgr->QueryInterface(IID_IRpcStubBuffer, (void **) &pSB);
                                if (SUCCEEDED(hr))
                                {
                                    // connect the stub to the server object

                                    // ALERT: Connect will expect the v-table for
                                    // the async interface.  It will NOT QI.

                                    hr = pSB->Connect(pAsyncInterface);
                                    if (SUCCEEDED(hr))
                                    {
                                        // everything is ok, so set up the object's
                                        // state

                                        _pUnkStubCallMgr = pUnkStubCallMgr;
                                        _pUnkStubCallMgr->AddRef();

                                        _pUnkServerCallMgr = pUnkServerCallMgr;
                                        _pUnkServerCallMgr->AddRef();


                                        _pSync = pSync; // not AddRef'd because we
                                        _pSB = pSB;     // addref'd the punk


                                        _pCall  = (CMessageCall *) pMsg->reserved1;
                                        _pCall->AddRef();
                                    }
                                    pSB->Release();
                                }
                                pSync->Release();
                            }
                            pUnkStubCallMgr->Release();
                        }
                        pCFStub->Release();
                    }
                    pAsyncInterface->Release();
                }
                pUnkServerCallMgr->Release();
            }
        }
        pCFServer->Release();
    }

}

//+-------------------------------------------------------------------------------
//
//  Member:     Destructor
//
//  Synopsis:   clean up object state
//
//--------------------------------------------------------------------------------

CRpcChannelBuffer::CServerCallMgr::~CServerCallMgr()
{
    if (_pUnkStubCallMgr)
    {
        _pUnkStubCallMgr->Release();
        _pUnkStubCallMgr = 0;
        _pSB = 0;
        _pSync = 0;
    }
    if (_pUnkServerCallMgr)
    {
        _pUnkServerCallMgr->Release();
        _pUnkServerCallMgr = 0;
    }
    if (_pCall)
    {
        _pCall->Release();
    }
    Win4Assert(_pStdID == NULL);
}



//+-------------------------------------------------------------------------------
//
//  Member:     MarkError
//
//  Synopsis:   Atomically mark this call as in an error state and
//              return whether Signal executed or not.
//
//--------------------------------------------------------------------------------

DWORD CRpcChannelBuffer::CServerCallMgr::MarkError(HRESULT hr)
{
    ASSERT_LOCK_NOT_HELD(gComLock);
    LOCK(gComLock);

    DWORD dwState = _dwState;
    BOOL fAbort = FALSE;

    // Initialize
#if DBG==1
    _hr = hr;
#endif

    if (_dwState == STATE_WAITINGFORSIGNAL)
    {
        // Signal has not been started. Mark this call as in
        // the error state and return TRUE to abort the call.
        // If Signal does start it will simply return _hr.
        _dwState = STATE_ERROR;

        // Abort
        fAbort = TRUE;
    }

    UNLOCK(gComLock);
    ASSERT_LOCK_NOT_HELD(gComLock);

    // Abort the call if neccessary
    if(fAbort)
    {
        // Abort the call
        GetCall()->Abort();

        // Delete the context call object
        if(GetCall()->GetServerCtxCall())
            delete GetCall()->GetServerCtxCall();

        // Unlock the server
        CIDObject *pID = _pStdID->GetIDObject();
        if(pID)
            pID->DecrementCallCount();
        _pStdID->UnlockServer();
#if DBG==1
        _pStdID = NULL;
#endif
        // Fixup the refcount. This release would otherwise
        // have been done in Signal
        Release();
    }

    return(dwState);
}


//+-------------------------------------------------------------------------------------
//
// Interface:         IUnknown
//
//--------------------------------------------------------------------------------------


STDMETHODIMP_(ULONG) CRpcChannelBuffer::CServerCallMgr::AddRef()
{
    return (ULONG) InterlockedIncrement((PLONG) &_cRefs);
}

STDMETHODIMP_(ULONG) CRpcChannelBuffer::CServerCallMgr::Release()
{
    ULONG ret = InterlockedDecrement((PLONG) &_cRefs);
    if (ret == 0)
    {
        // protect against reentrancy
        _cRefs = 100;
        delete this;
        return 0;
    }
    return ret;
}


STDMETHODIMP CRpcChannelBuffer::CServerCallMgr::QueryInterface(REFIID riid, LPVOID * ppv)
{

    void *pv = 0;

    if ((riid == IID_IUnknown) ||
        (riid == IID_ISynchronize))
    {
        pv = (ISynchronize *) this;
    }
    else if (riid == IID_IServerSecurity)
    {
        pv = (IServerSecurity *) this;
    }
    else if (riid == IID_ICancelMethodCalls)
    {
        pv = (ICancelMethodCalls *) this;
    }
    else if (riid == IID_IRpcStubBuffer)
    {
        pv = (IRpcStubBuffer *) this;
    }

    if (pv)
    {
        AddRef();
        *ppv = pv;
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }
}


//+-------------------------------------------------------------------------------------
//
// Interface:         ISynchronize
//
// Synopsis:          Most methods are delegated to the stub's ISynchronize. Signal
//                    is hooked for special behavior
//
//--------------------------------------------------------------------------------------

//+-------------------------------------------------------------------------------
//
//  Member:     Wait
//
//  Synopsis:   Delegate to Stub
//
//--------------------------------------------------------------------------------
STDMETHODIMP CRpcChannelBuffer::CServerCallMgr::Wait(DWORD dwFlags, DWORD dwTime)
{
    return _pSync->Wait(0,dwTime);
}


//+-------------------------------------------------------------------------------
//
//  Member:     Signal
//
//  Synopsis:   Check state for errors, setup TLS so context operations work
//              properly during the Finish call, call Signal on the Stub.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CRpcChannelBuffer::CServerCallMgr::Signal()
{
    HRESULT hr;

    // Acquire lock
    LOCK(gComLock);

    if (_dwState == STATE_WAITINGFORSIGNAL)
    {
        _dwState = STATE_SIGNALED;
        hr = S_OK;
    }
    else
        hr = E_UNEXPECTED;

    // Release lock
    UNLOCK(gComLock);

    // Check for the need to call signal on the stub
    if(SUCCEEDED(hr))
    {
        // Setup TLS
        COleTls tls(hr);
        if (SUCCEEDED(hr))
        {
            IUnknown *pContextPrev = tls->pCallContext;
            tls->pCallContext = GetCall()->_pContext;
            tls->pCallContext->AddRef();
            ((CServerSecurity *) (IServerSecurity *) tls->pCallContext)->SetupSecurity();
            CMessageCall *pCallPrev = tls->pCallInfo;
            tls->pCallInfo = GetCall();

            // REVIEW: Deliver CALLTYPE_FINISHLEAVE events
            //         to enter server context. Gopalk

            // Delegate to stub
            hr = _pSync->Signal();
            Win4Assert(SUCCEEDED(_hr) || (_hr == hr));

            // Tear down TLS
            ((CServerSecurity *) (IServerSecurity *) tls->pCallContext)->RestoreSecurity(TRUE);
            tls->pCallContext->Release();
            tls->pCallContext = pContextPrev;
            tls->pCallInfo = pCallPrev;
        }

#if DBG==1
        _hr = hr;
#endif

        // Abort failed calls
        if(FAILED(hr))
            GetCall()->Abort();

        // disconnect stub
        _pSB->Disconnect();
        _pSB = 0;
        _pSync = 0;

        // Delete context call object
        delete GetCall()->GetServerCtxCall();

        // Unlock the server
        CIDObject *pID = _pStdID->GetIDObject();
        if(pID)
            pID->DecrementCallCount();
        _pStdID->UnlockServer();
#if DBG==1
        _pStdID = NULL;
#endif
        // Release this async call manager
        Release();
    }

    return hr;
}


//+-------------------------------------------------------------------------------
//
//  Member:     Reset
//
//  Synopsis:   Delegate to Stub
//
//--------------------------------------------------------------------------------

STDMETHODIMP CRpcChannelBuffer::CServerCallMgr::Reset()
{
    return _pSync->Reset();
}


//+-------------------------------------------------------------------------------------
//
// Interface:         IRpcStubBuffer
//
// Synopsis:          Delegation of IRpcStubBuffer to stub call object
//
//--------------------------------------------------------------------------------------

STDMETHODIMP CRpcChannelBuffer::CServerCallMgr::Connect(IUnknown *pUnkServer)
{
    return _pSB->Connect(pUnkServer);
}

STDMETHODIMP_(void) CRpcChannelBuffer::CServerCallMgr::Disconnect()
{
    _pSB->Disconnect();
}

STDMETHODIMP CRpcChannelBuffer::CServerCallMgr::Invoke(RPCOLEMESSAGE *_prpcmsg,
               IRpcChannelBuffer *_pRpcChannelBuffer)
{
    return _pSB->Invoke(_prpcmsg, _pRpcChannelBuffer);
}

STDMETHODIMP_(IRpcStubBuffer *)  CRpcChannelBuffer::CServerCallMgr::IsIIDSupported(REFIID riid)
{
    return _pSB->IsIIDSupported(riid);
}

STDMETHODIMP_(ULONG) CRpcChannelBuffer::CServerCallMgr::CountRefs()
{
    return _pSB->CountRefs();
}

STDMETHODIMP CRpcChannelBuffer::CServerCallMgr::DebugServerQueryInterface(void **ppv)
{
    return _pSB->DebugServerQueryInterface(ppv);
}
STDMETHODIMP_(void) CRpcChannelBuffer::CServerCallMgr::DebugServerRelease(void *pv)
{
    _pSB->DebugServerRelease(pv);
}


//+-------------------------------------------------------------------------------------
//
// Interface:         IServerSecurity
//
// Synopsis:          Delegation of IServerSecurity to channel call object
//
//--------------------------------------------------------------------------------------

STDMETHODIMP CRpcChannelBuffer::CServerCallMgr::QueryBlanket
(
    DWORD    *pAuthnSvc,
    DWORD    *pAuthzSvc,
    OLECHAR **pServerPrincName,
    DWORD    *pAuthnLevel,
    DWORD    *pImpLevel,
    void    **pPrivs,
    DWORD    *pCapabilities
    )
{
    HRESULT hr;
    IServerSecurity * pSS;
    if (!GetCall())
    {
        return RPC_E_CALL_CANCELED;
    }
    if (SUCCEEDED(hr = GetCall()->_pContext->QueryInterface(IID_IServerSecurity, (void **) &pSS)))
    {
        hr = pSS->QueryBlanket(pAuthnSvc, pAuthzSvc, pServerPrincName,
                               pAuthnLevel, pImpLevel, pPrivs, pCapabilities);
        pSS->Release();
    }

    return hr;
}

STDMETHODIMP CRpcChannelBuffer::CServerCallMgr::ImpersonateClient()
{
    HRESULT hr;
    IServerSecurity * pSS;
    if (!GetCall())
    {
        return RPC_E_CALL_CANCELED;
    }
    if (SUCCEEDED(hr = GetCall()->_pContext->QueryInterface(IID_IServerSecurity, (void **) &pSS)))
    {
        hr = pSS->ImpersonateClient();
        pSS->Release();
    }

    return hr;
}

STDMETHODIMP CRpcChannelBuffer::CServerCallMgr::RevertToSelf()
{
    HRESULT hr;
    IServerSecurity * pSS;
    if (!GetCall())
    {
        return RPC_E_CALL_CANCELED;
    }
    if (SUCCEEDED(hr = GetCall()->_pContext->QueryInterface(IID_IServerSecurity, (void **) &pSS)))
    {
        hr = pSS->RevertToSelf();
        pSS->Release();
    }

    return hr;
}

STDMETHODIMP_(BOOL) CRpcChannelBuffer::CServerCallMgr::IsImpersonating()
{
    HRESULT hr;
    IServerSecurity * pSS;
    if (!GetCall())
    {
        return RPC_E_CALL_CANCELED;
    }
    if (SUCCEEDED(hr = GetCall()->_pContext->QueryInterface(IID_IServerSecurity, (void **) &pSS)))
    {
        BOOL ret = pSS->IsImpersonating();
        pSS->Release();
        return ret;
    }
    else
    {
        return FALSE;
    }

}


//+----------------------------------------------------------------------------
//
//  Member:        CRpcChannelBuffer::CServerCallMgr::Cancel
//
//  Synopsis:      Cancel not implemented for servers
//
//  History:       28-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CRpcChannelBuffer::CServerCallMgr::Cancel(DWORD dwTime)
{
    return E_NOTIMPL;
}

//+----------------------------------------------------------------------------
//
//  Member:        CRpcChannelBuffer::CServerCallMgr::TestCancel
//
//  Synopsis:      Query call to see if it has been cancelled.
//
//  History:       28-Jan-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CRpcChannelBuffer::CServerCallMgr::TestCancel()
{
    ComDebOut((DEB_CHANNEL, "CRpcChannelBuffer::CServerCallMgr::TestCancel IN \n" ));
    HRESULT hr = S_OK;

    LOCK(gComLock);
    if (_dwState != STATE_WAITINGFORSIGNAL)
    {
        hr = RPC_E_CALL_COMPLETE;
    }
    UNLOCK(gComLock);

    if (SUCCEEDED(hr))
    {
        hr = _pCall->TestCancel();
    }

    ComDebOut((DEB_CHANNEL, "CRpcChannelBuffer::CServerCallMgr::TestCancel OUT hr:0x%x\n", hr));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dcomrem\chock.cxx ===
//+-------------------------------------------------------------------
//
//  File:       chock.cxx
//
//  Contents:   Channel hook APIs
//
//  Classes:    CDebugChannelHook
//
//--------------------------------------------------------------------
#include <ole2int.h>
extern "C"
{
#include "orpc_dbg.h"
}
#include <ctxchnl.hxx>
#include <ipidtbl.hxx>
#include <chock.hxx>
#include <stream.hxx>


//+----------------------------------------------------------------
// Macros.

// This macro converts a RIID pointer to a CMessageCall pointer.  It assumes
// that the riid references the iid which is the first field of
// SChannelHookCallInfo in CMessageCall.  Thus a little subtraction yields
// the correct pointer.
inline CMessageCall *RIID_TO_CALL( const IID *pIid )
{
    return (CMessageCall *) (((char *) pIid) - offsetof( CMessageCall, hook ));
}

//+----------------------------------------------------------------
// Definitions.

typedef struct SHookList
{
    struct SHookList *pNext;
    IChannelHook     *pHook;
    UUID              uExtension;
} SHookList;

//+----------------------------------------------------------------
// Global variables.
SHookList          gHookList     = { &gHookList, NULL };
ULONG              gNumExtent    = 0;
LONG               gcChannelHook = -1;
GUID              *gaChannelHook = NULL;


//+-------------------------------------------------------------------
//
//  Function:   CleanupChannelHooks
//
//  Synopsis:   Releases all the hooks in the list.
//
//--------------------------------------------------------------------
void CleanupChannelHooks()
{
    LOCK(gComLock);

    SHookList *pCurr = gHookList.pNext;

    // Release and free each entry.
    while (pCurr != &gHookList)
    {
        pCurr->pHook->Release();
        gHookList.pNext = pCurr->pNext;
        PrivMemFree( pCurr );
        pCurr = gHookList.pNext;
    }

    gNumExtent    = 0;
    gcChannelHook = -1;

    if (gaChannelHook != NULL)
    {
        MIDL_user_free( gaChannelHook );
        gaChannelHook = NULL;
    }

    UNLOCK(gComLock);
}

//+-------------------------------------------------------------------
//
//  Function:   CoRegisterChannelHook
//
//  Synopsis:   Adds a hook object to the list of hook objects.
//
//--------------------------------------------------------------------
WINOLEAPI CoRegisterChannelHook( REFGUID uExtension, IChannelHook *pCaptain )
{
    SHookList *pCurr;
    HRESULT    hr = S_OK;

    // ChannelProcessIntialize calls while holding the lock.
    ASSERT_LOCK_DONTCARE(gComLock);
    LOCK(gComLock);

#if DBG==1
    // See if the extenstion is already on the list.
    pCurr = gHookList.pNext;
    while (pCurr != &gHookList)
    {
        if (pCurr->uExtension == uExtension)
            break;
        pCurr = pCurr->pNext;
    }
    Win4Assert( pCurr == &gHookList );
    Win4Assert( pCaptain != NULL );
#endif

    // Add a node at the head.
    pCurr = (SHookList *) PrivMemAlloc( sizeof(SHookList) );
    if (pCurr != NULL)
    {
        pCaptain->AddRef();
        pCurr->uExtension = uExtension;
        pCurr->pHook      = pCaptain;
        pCurr->pNext      = gHookList.pNext;
        gHookList.pNext   = pCurr;
        gNumExtent       += 1;
    }
    else
        hr = E_OUTOFMEMORY;

    UNLOCK(gComLock);
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   InitHooksIfNecessary
//
//  Synopsis:   Registers debug channel hooks
//
//--------------------------------------------------------------------
void InitHooksIfNecessary()
{
    SHookList *pCurr;
    LONG       i;
    HRESULT    hr;

    // Register the channel hooks.  If some other thread resets cChannelHook,
    // then its ok to stop immediately.
    for (i = 0; i < gcChannelHook; i++)
    {
        IChannelHook *pCaptain = NULL;
        hr = CoCreateInstance( gaChannelHook[i], NULL,
                               CLSCTX_INPROC_SERVER,
                               IID_IChannelHook,
                               (void **) &pCaptain );
        if (FAILED(hr))
            ComDebOut((DEB_CHANNEL, "Creation of default channel hook failed hr:%x\n", hr));
        if (pCaptain != NULL)
        {
            ASSERT_LOCK_NOT_HELD(gComLock);
            LOCK(gComLock);

            // Is this hook already registered?
            pCurr = gHookList.pNext;
            while (pCurr != &gHookList)
            {
                if (pCurr->uExtension == gaChannelHook[i])
                    break;
                pCurr = pCurr->pNext;
            }

            // Register the channel hook if not already registered.
            if (pCurr == &gHookList)
                hr = CoRegisterChannelHook( gaChannelHook[i], pCaptain );

            UNLOCK(gComLock);
            ASSERT_LOCK_NOT_HELD(gComLock);

            // Release the channel hook.
            if (FAILED(hr))
                ComDebOut((DEB_CHANNEL, "Registration of default channel hook failed hr:%x\n", hr));
            pCaptain->Release();
        }
    }

    gcChannelHook = -1;
}

//+-------------------------------------------------------------------
//
//  Function:   ClientGetSize
//
//  Synopsis:   Asks each hook in the list how much data it wishes to
//              place in the next request on this thread.
//
//--------------------------------------------------------------------
ULONG ClientGetSize( ULONG *cNumExtent, CMessageCall *pCall )
{
    SHookList *pCurr = gHookList.pNext;
    ULONG lSize      = SizeOfWireExtentArray;
    ULONG lPiece     = 0;
    *cNumExtent      = 0;

    // Ignore any hooks added to the head of the list.
    ASSERT_LOCK_DONTCARE(gComLock);

    // Ask each hook.
    while (pCurr != &gHookList)
    {
        pCurr->pHook->ClientGetSize( pCurr->uExtension, pCall->hook.iid,
                                     &lPiece );
        if (lPiece != 0)
        {
            lPiece       = ((lPiece + 7) & ~7) + sizeof(WireExtent);
            lSize       += lPiece;
            *cNumExtent += 1;
        }
        pCurr = pCurr->pNext;
    }

    // Round up the number of extents and add size for an array of unique
    // flags.
    *cNumExtent = (*cNumExtent + 1) & ~1;
    lSize      += SizeOfUniqueFlags (*cNumExtent);

    if (*cNumExtent != 0)
        return lSize;
    else
        return 0;
}

//+-------------------------------------------------------------------
//
//  Function:   FillBuffer
//
//  Synopsis:   Asks each hook in the list to place data in the buffer
//              for the next request on this thread.  Returns the final
//              buffer pointer.
//
//--------------------------------------------------------------------
void *FillBuffer( WireExtentArray *pArray, ULONG cMax,
                  ULONG cNumExtent, BOOL fClient, CMessageCall *pCall )
{
    SHookList       *pCurr;
    WireExtent      *pExtent;
    ULONG            lPiece;
    ULONG            cNumFill;
    ULONG            i;

    // Ignore any hooks added to the head of the list.
    ASSERT_LOCK_DONTCARE(gComLock);

    // Figure out where the extents start.
    pCurr      = gHookList.pNext;
    pExtent    = StartOfExtents (pArray, cNumExtent);
    cNumFill   = 0;
    cMax      -= SizeOfWireExtentArrayWithUniqueFlags (cNumExtent);

    // Ask each hook.
    while (pCurr != &gHookList && cMax > 0)
    {
        lPiece = cMax - sizeof(WireExtent);
        if (fClient)
            pCurr->pHook->ClientFillBuffer( pCurr->uExtension, pCall->hook.iid,
                                            &lPiece, pExtent+1 );
        else 
            pCurr->pHook->ServerFillBuffer( pCurr->uExtension, pCall->hook.iid,
                                            &lPiece, pExtent+1, S_OK );
                                            
        Win4Assert( ((lPiece+7)&~7) + sizeof(WireExtent) <= cMax );

        // If the hook put in data, initialize this extent and find the next.
        if (lPiece != 0)
        {
            pExtent->size         = lPiece;
            pExtent->rounded_size = (lPiece+7) & ~7;
            pExtent->id           = pCurr->uExtension;
            cNumFill             += 1;
            cMax                 -= pExtent->rounded_size + sizeof(WireExtent);
            pExtent               = (WireExtent *) ((char *) (pExtent+1) +
                                                    pExtent->rounded_size);

            Win4Assert( cNumFill <= cNumExtent );
        }
        pCurr = pCurr->pNext;
    }


    // If any hooks put in data, fill in the header.
    if (cNumFill != 0)
    {
        pArray->size         = cNumFill;
        pArray->reserved     = 0;
        pArray->unique       = 0x6d727453; // Any non-zero value.
        pArray->rounded_size = (cNumFill+1) & ~1;
        for (i = 0; i < cNumExtent; i++)
            if (i < cNumFill)
                pArray->unique_flag[i] = 0x79614b44; // Any non-zero value.
            else
                pArray->unique_flag[i] = 0;
        return pExtent;
    }

    // Otherwise return the original buffer.
    else
    {
        return pArray;
    }
}

//+-------------------------------------------------------------------
//
//  Function:   FindExtentId
//
//  Synopsis:   Search for the specified extension id in the list of
//              registered extensions.  Return the index of the entry
//              if found
//
//--------------------------------------------------------------------
ULONG FindExtentId( SHookList *pHead, UUID uExtension )
{
    ULONG i = 0;
    while (pHead != &gHookList)
        if (pHead->uExtension == uExtension)
            return i;
        else
        {
            i += 1;
            pHead = pHead->pNext;
        }
    return 0xffffffff;
}

//+-------------------------------------------------------------------
//
//  Function:   VerifyExtent
//
//  Synopsis:   Verifies extent array and extents.
//
//--------------------------------------------------------------------
void *VerifyExtent( SHookList *pHead, WireExtentArray *pArray, ULONG cMax,
                      WireExtent **aExtent, DWORD dwRep )
{
    WireExtent      *pExtent;
    ULONG            i;
    ULONG            j;
    ULONG            cNumExtent;
    WireExtent      *pEnd;

    // Fail if the buffer isn't larger then the extent array header.
    if (cMax < SizeOfWireExtentArray)
        return NULL;

    // Byte swap the array header.
    if ((dwRep & NDR_INT_REP_MASK) != NDR_LOCAL_ENDIAN)
    {
        ByteSwapLong( pArray->size );
        // ByteSwapLong( pArray->reserved );
        ByteSwapLong( pArray->rounded_size );
    }

    // Validate the array header.
    if (cMax < SizeOfWireExtentArrayWithUniqueFlags (pArray->rounded_size) ||
        (pArray->rounded_size & 1) != 0                ||
        pArray->size > pArray->rounded_size            ||
        pArray->reserved != 0)
        return NULL;

    // Count how many unique flags are set.
    cNumExtent = 0;
    for (i = 0; i < pArray->size; i++)
        if (pArray->unique_flag[i])
            cNumExtent += 1;

    // Look up each extent from the packet in the registered list.
    pEnd    = (WireExtent *) ((char *) pArray + cMax);
    pExtent = (WireExtent *) &pArray->unique_flag[pArray->rounded_size];
    for (i = 0; i < cNumExtent; i++)
    {
        // Fail if the next extent header doesn't fit in the buffer.
        if (pExtent + 1 > pEnd)
            return NULL;

        // Byte swap the extent header.
        if ((dwRep & NDR_INT_REP_MASK) != NDR_LOCAL_ENDIAN)
        {
            ByteSwapLong( pExtent->rounded_size );
            ByteSwapLong( pExtent->size );
            ByteSwapLong( pExtent->id.Data1 );
            ByteSwapShort( pExtent->id.Data2 );
            ByteSwapShort( pExtent->id.Data3 );
        }

        // Validate the extent.
        if (pExtent->size > pExtent->rounded_size ||
            (pExtent->rounded_size & 1) != 0      ||
            ((char *) (pExtent+1)) + pExtent->rounded_size > (char *) pEnd)
            return NULL;

        // If the extension is registered, save a pointer to it.
        j = FindExtentId( pHead, pExtent->id );
        if (j != 0xffffffff)
            aExtent[j] = pExtent;

        // Find the next extension.
        pExtent = (WireExtent *) ((char *) (pExtent + 1) +
                  pExtent->rounded_size);
    }
    return pExtent;
}

//+-------------------------------------------------------------------
//
//  Function:   ClientNotify
//
//  Synopsis:   Calls each hook and passes data to those that received
//              data in a reply.
//
//  Notes: pOut is NULL for failed calls or async calls.
//
//--------------------------------------------------------------------
HRESULT ClientNotify( WireThat *pOut, ULONG cMax, void **pStubData,
                      DWORD dwRep, HRESULT hr, CMessageCall *pCall )
{
    SHookList       *pHead  = gHookList.pNext;
    SHookList       *pCurr;
    WireExtent     **aExtent;
    ULONG            cMaxExtent = gNumExtent;
    ULONG            i;

    // Return immediately if there is nothing to do.
    if(pOut)
        *pStubData = &pOut->d.ea;
    if (pHead == &gHookList &&
        (pOut == NULL || pOut->c.unique == FALSE))
        return hr;

	if (gNumExtent == 0)
	{
		Win4Assert(!"Somebody added a channel hook without changing gNumExtent!");
		return RPC_E_INVALID_EXTENSION;
	}

    // Initialize the array of extent pointers.
    aExtent = (WireExtent **) _alloca( cMaxExtent * sizeof(WireExtent *) );
    memset( aExtent, 0, cMaxExtent * sizeof( WireExtent *) );

    // If there are any extents, verify them and sort them.
    if (SUCCEEDED(hr) && pOut != NULL && pOut->c.unique)
    {
        *pStubData = VerifyExtent( pHead, &pOut->d.ea, cMax - sizeof(WireThatPart1),
                                   aExtent, dwRep );
        if (*pStubData == NULL)
            return RPC_E_INVALID_EXTENSION;
    }

    // Notify all the hooks
    for (pCurr = pHead, i = 0; pCurr != &gHookList; pCurr = pCurr->pNext, i++)
        pCurr->pHook->ClientNotify( pCurr->uExtension, pCall->hook.iid,
                             aExtent[i] != NULL ? aExtent[i]->size : 0,
                             aExtent[i] != NULL ? aExtent[i] + 1 : NULL,
                             dwRep, hr );
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   ServerNotify
//
//  Synopsis:   Calls each hook and passes data to those that receive
//              data in a request.
//
//--------------------------------------------------------------------
HRESULT ServerNotify( WireThis *pIn, ULONG cMax, void **pStubData,
                      DWORD dwRep, CMessageCall *pCall )
{
    SHookList       *pHead  = gHookList.pNext;
    SHookList       *pCurr;
    WireExtent     **aExtent;
    ULONG            cMaxExtent = gNumExtent;
    ULONG            i;

    // Return immediately if there is nothing to do.
    *pStubData = &pIn->d.ea;
    if (pHead == &gHookList && pIn->c.unique == FALSE)
        return S_OK;
	
	if (cMaxExtent == 0)
	{
		Win4Assert (!"Somebody added a channel hook to the list without changing gNumExtent!");
		return RPC_E_INVALID_EXTENSION;
	}

    // Initialize the array of extent pointers.
    aExtent = (WireExtent **) _alloca( cMaxExtent * sizeof(WireExtent *) );
    memset( aExtent, 0, cMaxExtent * sizeof( WireExtent *) );

    // If there are any extents, verify them and sort them.
    if (pIn->c.unique)
    {
        *pStubData = VerifyExtent( pHead, &pIn->d.ea, cMax - sizeof(WireThisPart1),
                                   aExtent, dwRep );
        if (*pStubData == NULL)
            return RPC_E_INVALID_EXTENSION;
    }

    // Notify all the hooks
    for (pCurr = pHead, i = 0; pCurr != &gHookList; pCurr = pCurr->pNext, i++)
        pCurr->pHook->ServerNotify( pCurr->uExtension, pCall->hook.iid,
                             aExtent[i] != NULL ? aExtent[i]->size : 0,
                             aExtent[i] != NULL ? aExtent[i] + 1 : NULL,
                             dwRep );

	// Another integrity check on the list?
	Win4Assert((pCurr == &gHookList) && (i == gNumExtent));

    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Function:   ServerGetSize
//
//  Synopsis:   Asks each hook in the list how much data it wishes to
//              place in the next reply on this thread.
//
//--------------------------------------------------------------------
ULONG ServerGetSize( ULONG *cNumExtent, CMessageCall *pCall )
{
    SHookList *pCurr  = gHookList.pNext;
    ULONG      lSize  = SizeOfWireExtentArray;
    ULONG      lPiece = 0;
    *cNumExtent       = 0;

    // Ask each hook.
    while (pCurr != &gHookList)
    {
        pCurr->pHook->ServerGetSize( pCurr->uExtension, pCall->hook.iid,
                                     S_OK, &lPiece );
        if (lPiece != 0)
        {
            lPiece       = ((lPiece + 7) & ~7) + sizeof(WireExtent);
            lSize       += lPiece;
            *cNumExtent += 1;
        }
        pCurr = pCurr->pNext;
    }

    // Round up the number of extents and add size for an array of unique
    // flags.
    *cNumExtent = (*cNumExtent + 1) & ~1;
    lSize      += SizeOfUniqueFlags (*cNumExtent);
    if (*cNumExtent != 0)
        return lSize;
    else
        return 0;
}

//+-------------------------------------------------------------------
//
//  Member:     CDebugChannelHook::ClientGetSize
//
//  Synopsis:   Asks the VC debugger how much data to put in the next
//              request on this thread.  Stores the result in TLS.
//
//--------------------------------------------------------------------
STDMETHODIMP_(void) CDebugChannelHook::ClientGetSize( REFGUID uExtension, REFIID riid,
                                       ULONG *pSize )
{
    COleTls tls;

    Win4Assert( DEBUG_EXTENSION == uExtension );

    if (DoDebuggerHooks)
        tls->cDebugData = DebugORPCClientGetBufferSize( NULL,
                            riid, NULL, NULL, DebuggerArg, DoDebuggerHooks );
    else
        tls->cDebugData = 0;

    *pSize = tls->cDebugData;
}

//+-------------------------------------------------------------------
//
//  Member:     CDebugChannelHook::ClientFillBuffer
//
//  Synopsis:   Asks the VC debugger to place data in the buffer for
//              the next request on this thread.  Uses the size stored
//              in TLS.
//
//--------------------------------------------------------------------
STDMETHODIMP_(void) CDebugChannelHook::ClientFillBuffer( REFGUID uExtension,
                                          REFIID riid,
                                          ULONG *pSize, void *pBuffer )
{
    COleTls       tls;
    CMessageCall *pCall = RIID_TO_CALL( &riid );

    Win4Assert( DEBUG_EXTENSION == uExtension );
    Win4Assert( tls->cDebugData <= *pSize );

    if (tls->cDebugData != 0)
    {
        DebugORPCClientFillBuffer(
            &pCall->message,
            riid,
            NULL,
            NULL,
            pBuffer,
            tls->cDebugData,
            DebuggerArg,
            DoDebuggerHooks );
    }

    *pSize = tls->cDebugData;

    // This permits a smooth foreground transfer when stepping from the
    // client into the server or vice versa during debugging.
    // We cannot do much if the call fails.
    AllowSetForegroundWindow(ASFW_ANY);
}

//+-------------------------------------------------------------------
//
//  Member:     CDebugChannelHook::ClientNotify
//
//  Synopsis:   Passes data to the VC debugger received on the last
//              reply on this thread.
//
//--------------------------------------------------------------------
STDMETHODIMP_(void) CDebugChannelHook::ClientNotify(
                                      REFGUID uExtension, REFIID riid,
                                      ULONG lSize, void *pBuffer,
                                      DWORD dwRep, HRESULT hr )
{
    CMessageCall *pCall = RIID_TO_CALL( &riid );

    Win4Assert( DEBUG_EXTENSION == uExtension );

    if (pBuffer != NULL || DoDebuggerHooks)
    {
        DebugORPCClientNotify(
            pCall == NULL ? NULL : &pCall->message,
            riid,
            NULL,
            NULL,
            hr,
            pBuffer,
            lSize,
            DebuggerArg,
            DoDebuggerHooks );
    }
}

//+-------------------------------------------------------------------
//
//  Member:     CDebugChannelHook::ServerNotify
//
//  Synopsis:   Passes data to the VC debugger receive on the last
//              request on this thread.
//
//--------------------------------------------------------------------
STDMETHODIMP_(void) CDebugChannelHook::ServerNotify(
                                      REFGUID uExtension, REFIID riid,
                                      ULONG lSize, void *pBuffer,
                                      DWORD dwRep )
{
    Win4Assert( DEBUG_EXTENSION == uExtension );

    if (pBuffer != NULL || DoDebuggerHooks)
    {
        IPIDEntry    *pIpid;
        void         *pv = NULL;
        CMessageCall *pCall = RIID_TO_CALL( &riid );

        // Lookup the IPID entry.
        LOCK(gIPIDLock);
        HRESULT hr = gIPIDTbl.LookupFromIPIDTables(pCall->GetIPID(), &pIpid, NULL);
        UNLOCK(gIPIDLock);
        Win4Assert(hr == S_OK && pIpid != NULL);

        // Get the object pointer from the stub because the IPID entry
        // might have a different pointer.
        ((IRpcStubBuffer *) pIpid->pStub)->DebugServerQueryInterface( &pv );

        // Call the debugger.
        DebugORPCServerNotify(
                   &pCall->message,
                   riid,
                   (IRpcChannelBuffer3 *) pIpid->pChnl,
                   pv,
                   NULL,
                   pBuffer,
                   lSize,
                   DebuggerArg,
                   DoDebuggerHooks );

        // Release the object pointer.
        if (pv != NULL)
            ((IRpcStubBuffer *) pIpid->pStub)->DebugServerRelease( pv );
    }
}

//+-------------------------------------------------------------------
//
//  Member:     CDebugChannelHook::ServerGetSize
//
//  Synopsis:   Asks the VC debugger how much data to place in the buffer
//              for the next reply on this thread.  Stores the result
//              in TLS.
//
//--------------------------------------------------------------------
STDMETHODIMP_(void) CDebugChannelHook::ServerGetSize( REFGUID uExtension, REFIID riid,
                                       HRESULT hrFault, ULONG *pSize )
{
    COleTls       tls;
    Win4Assert( DEBUG_EXTENSION == uExtension );

    if (DoDebuggerHooks)
    {
        IPIDEntry    *pIpid;
        void         *pv = NULL;
        CMessageCall *pCall = RIID_TO_CALL( &riid );

        // Lookup the IPID entry.
        LOCK(gIPIDLock);
        HRESULT hr = gIPIDTbl.LookupFromIPIDTables(pCall->GetIPID(), &pIpid, NULL);
        UNLOCK(gIPIDLock);
        Win4Assert(hr == S_OK && pIpid != NULL);

        // Get the object pointer from the stub because the IPID entry
        // might have a different pointer.
        ((IRpcStubBuffer *) pIpid->pStub)->DebugServerQueryInterface( &pv );

        // Ask the debugger how much data it has.
        tls->cDebugData = DebugORPCServerGetBufferSize(
                            &pCall->message,
                            riid,
                            (IRpcChannelBuffer3 *)pIpid->pChnl,
                            pv,
                            NULL,
                            DebuggerArg,
                            DoDebuggerHooks );

        // Release the object pointer.
        if (pv != NULL)
            ((IRpcStubBuffer *) pIpid->pStub)->DebugServerRelease( pv );
    }
    else
        tls->cDebugData = 0;

    *pSize = tls->cDebugData;
}

//+-------------------------------------------------------------------
//
//  Member:     CDebugChannelHook::ServerFillBuffer
//
//  Synopsis:   Asks the VC debugger to place data in the buffer for the
//              next reply on this thread.  Uses the size from TLS.
//
//--------------------------------------------------------------------
STDMETHODIMP_(void) CDebugChannelHook::ServerFillBuffer( REFGUID uExtension, REFIID riid,
                                 ULONG *pSize, void *pBuffer, HRESULT hrFault )
{
    COleTls       tls;

    Win4Assert( DEBUG_EXTENSION == uExtension );
    Win4Assert( tls->cDebugData <= *pSize );

    if (tls->cDebugData != 0)
    {
        IPIDEntry    *pIpid;
        void         *pv = NULL;
        CMessageCall *pCall = RIID_TO_CALL( &riid );

        // Lookup the IPID entry.
        LOCK(gIPIDLock);
        HRESULT hr = gIPIDTbl.LookupFromIPIDTables(pCall->GetIPID(), &pIpid, NULL);
        UNLOCK(gIPIDLock);
        Win4Assert(hr == S_OK && pIpid != NULL);

        // Get the object pointer from the stub because the IPID entry
        // might have a different pointer.
        ((IRpcStubBuffer *) pIpid->pStub)->DebugServerQueryInterface( &pv );

        // Ask the debugger to write its data.
        DebugORPCServerFillBuffer(
                &pCall->message,
                riid,
                (IRpcChannelBuffer3 *)pIpid->pChnl,
                pv,
                NULL,
                pBuffer,
                tls->cDebugData,
                DebuggerArg,
                DoDebuggerHooks );

        // Release the object pointer.
        if (pv != NULL)
            ((IRpcStubBuffer *) pIpid->pStub)->DebugServerRelease( pv );
    }

    *pSize = tls->cDebugData;

    // This permits a smooth foreground transfer when stepping from the
    // client into the server or vice versa during debugging.
    // We cannot do much if the call fails.
    AllowSetForegroundWindow(ASFW_ANY);
}

//+-------------------------------------------------------------------
//
//  Member:     CDebugChannelHook::QueryInterface
//
//  Synopsis:   Queries this object for interfaces
//
//--------------------------------------------------------------------
STDMETHODIMP CDebugChannelHook::QueryInterface( REFIID riid, LPVOID FAR* ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IChannelHook))
    {
        *ppvObj = this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    // This object is not reference counted.
    // AddRef();
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CDebugChannelHook::AddRef
//
//  Synopsis:   Increments object reference count.
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CDebugChannelHook::AddRef( )
{
    return 1;
}

//+-------------------------------------------------------------------
//
//  Member:     CDebugChannelHook::Release
//
//  Synopsis:   Decrements object reference count and deletes if zero.
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CDebugChannelHook::Release( )
{
    return 1;
}


//+-------------------------------------------------------------------
//
//  Member:     CErrorChannelHook::ClientGetSize
//
//  Synopsis:   Does nothing.
//
//--------------------------------------------------------------------
STDMETHODIMP_(void) CErrorChannelHook::ClientGetSize( REFGUID uExtension, REFIID riid,
                                       ULONG *pSize )
{
    Win4Assert( ERROR_EXTENSION == uExtension );

    *pSize = 0;
}

//+-------------------------------------------------------------------
//
//  Member:     CErrorChannelHook::ClientFillBuffer
//
//  Synopsis:   Does nothing.
//
//--------------------------------------------------------------------
STDMETHODIMP_(void) CErrorChannelHook::ClientFillBuffer( REFGUID uExtension,
                                          REFIID riid,
                                          ULONG *pSize, void *pBuffer )
{
    Win4Assert( ERROR_EXTENSION == uExtension );

    *pSize = 0;
}

//+-------------------------------------------------------------------
//
//  Member:     CErrorChannelHook::ClientNotify
//
//  Synopsis:   Unmarshals the COM extended error information.
//
//--------------------------------------------------------------------
STDMETHODIMP_(void) CErrorChannelHook::ClientNotify(
                                      REFGUID uExtension, REFIID riid,
                                      ULONG lSize, void *pBuffer,
                                      DWORD dwRep, HRESULT hr )
{
    COleTls tls;

    Win4Assert( ERROR_EXTENSION == uExtension );


    //Unmarshal the new error object.
    if ((pBuffer != NULL) && (lSize > 0))
    {
        CNdrStream MemStream((unsigned char *)pBuffer, lSize);

        //Release the old error object.
        if(tls->punkError != NULL)
        {
            tls->punkError->Release();
            tls->punkError = NULL;
        }

        CoUnmarshalInterface(&MemStream,
                             IID_IUnknown,
                             (void **) &tls->punkError);
    }
    else if((tls->punkError != NULL) &&
            !IsEqualIID(riid, IID_IRundown) &&
            !IsEqualIID(riid, IID_IRemUnknown) &&
            !IsEqualIID(riid, IID_IRemUnknown2) &&
            !IsEqualIID(riid, IID_ISupportErrorInfo))
    {
            //Release the old error object.
            tls->punkError->Release();
            tls->punkError = NULL;
    }

}

//+-------------------------------------------------------------------
//
//  Member:     CErrorChannelHook::ServerNotify
//
//  Synopsis:   Clears the COM extended error information on an
//              incoming call.
//
//--------------------------------------------------------------------
STDMETHODIMP_(void) CErrorChannelHook::ServerNotify(
                                      REFGUID uExtension, REFIID riid,
                                      ULONG lSize, void *pBuffer,
                                      DWORD dwRep )
{
    COleTls    tls;

    Win4Assert( ERROR_EXTENSION == uExtension );

    //Release the old error object.
    if(tls->punkError != NULL)
    {
        tls->punkError->Release();
        tls->punkError = NULL;
    }

}

//+-------------------------------------------------------------------
//
//  Member:     CErrorChannelHook::ServerGetSize
//
//  Synopsis:   Calculates the size of the marshalled error object.
//
//--------------------------------------------------------------------
STDMETHODIMP_(void) CErrorChannelHook::ServerGetSize( REFGUID uExtension, REFIID riid,
                                       HRESULT hrFault, ULONG *pSize )
{
    HRESULT       hr;
    COleTls       tls;
    CMessageCall *pCall = RIID_TO_CALL( &riid );

    Win4Assert( ERROR_EXTENSION == uExtension );

    tls->cbErrorData = 0;

    //Compute the size of the marshalled error object.
    if(tls->punkError != NULL)
    {
        hr = CoGetMarshalSizeMax( &tls->cbErrorData,
                                  IID_IUnknown,
                                  tls->punkError,
                                  pCall->GetDestCtx(),
                                  NULL,
                                  MSHLFLAGS_NORMAL );
        if(FAILED(hr))
        {
            //Release the error object.
            tls->punkError->Release();
            tls->punkError = NULL;
            tls->cbErrorData = 0;
        }
    }

    *pSize = tls->cbErrorData;
}

//+-------------------------------------------------------------------
//
//  Member:     CErrorChannelHook::ServerFillBuffer
//
//  Synopsis:   Marshals the error object.
//
//--------------------------------------------------------------------
STDMETHODIMP_(void) CErrorChannelHook::ServerFillBuffer( REFGUID uExtension, REFIID riid,
                                 ULONG *pSize, void *pBuffer, HRESULT hrFault )
{
    HRESULT       hr;
    COleTls       tls;
    ULONG         cbSize = 0;
    CMessageCall *pCall  = RIID_TO_CALL( &riid );
    IUnknown     *punkError;
    ULONG         cbErrorData;

    Win4Assert( ERROR_EXTENSION == uExtension );
    Win4Assert( tls->cbErrorData <= *pSize );

    // If the IErrorInfo is a proxy, and we're in an STA then this the 
    // TLS data might go away if we call out from this function.  Thus,
    // back our data up onto the stack and use that version instead of the
    // TLS stuff.  (For consistency's sake, we'll use it everywhere.)
    punkError   = tls->punkError;
    cbErrorData = tls->cbErrorData; 

    if(punkError != NULL)
    {
        //Marshal the error object.
        if(cbErrorData > 0)
        {
            CNdrStream MemStream((unsigned char *)pBuffer, cbErrorData);

            hr = CoMarshalInterface(&MemStream,
                                    IID_IUnknown,
                                    punkError,
                                    pCall->GetDestCtx(),
                                    NULL,
                                    MSHLFLAGS_NORMAL);

            if(FAILED(hr))
            {
                cbErrorData = 0;
            }
        } 

        //Release the error object.
        punkError->Release();

        //This is safe to do.  Any calls relying on this pointer now are
	//now complete and we can go ahead and zero-out this field (so that
	//it doesn't confuse us ever again)
	tls->punkError = NULL;
    }

    *pSize = cbErrorData;
}

//+-------------------------------------------------------------------
//
//  Member:     CErrorChannelHook::QueryInterface
//
//  Synopsis:   Queries this object for interfaces
//
//--------------------------------------------------------------------
STDMETHODIMP CErrorChannelHook::QueryInterface( REFIID riid, LPVOID FAR* ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IChannelHook))
    {
        *ppvObj = this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    // This object is not reference counted.
    // AddRef();
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CErrorChannelHook::AddRef
//
//  Synopsis:   Increments object reference count.
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CErrorChannelHook::AddRef( )
{
    return 1;
}

//+-------------------------------------------------------------------
//
//  Member:     CErrorChannelHook::Release
//
//  Synopsis:   Decrements object reference count and deletes if zero.
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CErrorChannelHook::Release( )
{
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dcomrem\coapi.cxx ===
//+-------------------------------------------------------------------
//
//  File:       coapi.cxx
//
//  Contents:   Public COM remote subsystem APIs
//
//  Classes:    CDestObjectWrapper          - wraps CDestObject for ContextMarshaling
//
//  Functions:  CoGetStandardMarshal       - returns IMarshal for given interface
//              CoGetMarshalSizeMax        - sends size requests one of two ways
//              CoDirectGetMarshalSizeMax  - returns max size buffer needed
//              CoMarshalInterface         - sends marshal requests one of two ways
//              CoDirectMarshalInterface   - marshals an interface
//              CoUnmarshalInterface       - unmarshals an interface
//              CoReleaseMarshalData       - releases data from marshaled interface
//              CoLockObjectExternal       - keep object alive or releases it
//              CoDisconnectObject         - kills sessions held by remote clients
//              CoIsHandlerConnected       - try to determine if handler connected
//
//  History:    23-Nov-92   Rickhi      Created
//              11-Dec-93   CraigWi     Switched to identity object
//              05-Jul-94   BruceMa     Check for end of stream
//              20-Feb-95   Rickhi      Major changes for DCOM
//
//--------------------------------------------------------------------
#include <ole2int.h>
#include <olerem.h>
#include <marshal.hxx>      // CStdMarshal
#include <stdid.hxx>        // CStdIdentity, IDTable APIs
#include <service.hxx>      // SASIZE
#include <crossctx.hxx>     // CStdWrapper
#include <destobj.hxx>          // IDestInfo
#include <resolver.hxx>

// static unmarshaler
IMarshal *gpStdMarshal = NULL;

//+-------------------------------------------------------------------
//
//  Function:   CoGetStdMarshalEx, public
//
//  Synopsis:   Returns an instance of the standard IMarshal aggregated
//              into the specifed object.
//
//  Arguements: [punkOuter] - outer object's controlling IUnknown
//              [dwFlags] - flags (HANDLER | SERVER)
//              [ppUnkInner] - where to return the inner IUnknown
//
//  Algorithm:  lookup or create a CStdIdentity (and CStdMarshal) for
//              the object.
//
//  Notes:      On the client side, the outer IUnknown must be the
//              CStdIdentity object.
//
//  History:    16-Nov-96   Rickhi      Created
//
//--------------------------------------------------------------------
STDAPI CoGetStdMarshalEx(IUnknown *punkOuter, DWORD dwFlags, IUnknown **ppUnkInner)
{
    ComDebOut((DEB_MARSHAL,"CoGetStdMarshalEx pUnkOuter:%x dwFlags:%x ppUnkInner:%x\n",
               punkOuter, dwFlags, ppUnkInner));

    // validate the input parameters
    if ( !IsValidInterface(punkOuter) ||
        (dwFlags != SMEXF_HANDLER && dwFlags != SMEXF_SERVER) ||
         ppUnkInner == NULL )
    {
        return (E_INVALIDARG);
    }

    // init the out parameters
    *ppUnkInner = NULL;

    HRESULT hr = InitChannelIfNecessary();
    if ( FAILED(hr) )
        return (hr);


    CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IUnknown, &punkOuter);

    // determine if the punkOuter is our Identity object. This has
    // to be done for both the client and server side in order to
    // determine if the dwFlags parameter is correct.

    CStdIdentity *pStdId;
    hr = punkOuter->QueryInterface(IID_IStdIdentity, (void **)&pStdId);
    if (SUCCEEDED(hr))
    {
        if (dwFlags == SMEXF_HANDLER)
        {
            // client (handler) requested.
            // pUnkOuter is AggID, return the inner IUnknown
            *ppUnkInner = pStdId->GetInternalUnk();
            (*ppUnkInner)->AddRef();
        }
        else
        {
            // requesting SMEXF_SERVER when the controlling unknown
            // is the client AggID. Not legal (would cause an infinite recursion).
            hr = E_INVALIDARG;
        }

        pStdId->Release();
    }
    else
    {
        if (dwFlags == SMEXF_SERVER)
        {
            // server side.  First, get the real controlling unknown, since
            // the app may have passed in some other interface.
            IUnknown *pUnkRealOuter = NULL;
            hr = punkOuter->QueryInterface(IID_IUnknown, (void **)&pUnkRealOuter);
            if (SUCCEEDED(hr))
            {
                // We put a reference on the StdId so that the ID does not get
                // disconnected when the last external Release occurs.
                hr = GetStdId(pUnkRealOuter, ppUnkInner);
                pUnkRealOuter->Release();
            }
        }
        else
        {
            // requesting SMEXF_HANDLER when the controlling unknown is NOT
            // the AggId.
            hr = E_INVALIDARG;
        }
    }

    ComDebOut((DEB_MARSHAL, "CoGetStdMarshalEx: ppUnkInner:%x hr:%x\n", *ppUnkInner, hr));
    return (hr);
}


//+-------------------------------------------------------------------
//
//  Function:   CoGetStandardMarshal, public
//
//  Synopsis:   Returns an instance of the standard IMarshal for the
//              specifed object.
//
//  Algorithm:  lookup or create a CStdIdentity (and CStdMarshal) for
//              the object.
//
//  History:    23-Nov-92   Rickhi      Created
//              11-Dec-93   CraigWi     Switched to identity object
//              20-Feb-95   Rickhi      Switched to CStdMarshal
//
//--------------------------------------------------------------------
STDAPI CoGetStandardMarshal(REFIID riid, IUnknown *pUnk, DWORD dwDestCtx,
                            void *pvDestCtx, DWORD mshlflags, IMarshal **ppMarshal)
{
    TRACECALL(TRACE_MARSHAL, "CoGetStandardMarshal");
    ComDebOut((DEB_MARSHAL,
        "CoGetStandardMarshal riid:%I pUnk:%x dwDest:%x pvDest:%x flags:%x\n",
        &riid, pUnk, dwDestCtx, pvDestCtx, mshlflags));

    // validate the input parameters
    if (ppMarshal == NULL ||
        FAILED(ValidateMarshalFlags(dwDestCtx, pvDestCtx, mshlflags)))
    {
        return E_INVALIDARG;
    }

    *ppMarshal = NULL;

    HRESULT hr = InitChannelIfNecessary();
    if (FAILED(hr))
        return (hr);

    if (pUnk == NULL)
    {
        // this is the unmarshal side. any instance will do so we return
        // the static one. Calling UnmarshalInterface will return the real
        // proxy.

        hr = GetStaticUnMarshaler(ppMarshal);
    }
    else
    {
        // this is the marshal side. We put a strong reference on the StdId
        // so that the ID does not get disconnected when the last external
        // Release occurs.

        CALLHOOKOBJECT(S_OK,CLSID_NULL,riid,&pUnk);

        DWORD dwFlags = IDLF_CREATE;
        if (mshlflags & MSHLFLAGS_NOPING)
        {
            // requesting NOPING, so set the IDL flags accordingly
            dwFlags |= IDLF_NOPING;
        }

        // Initialize TLS.  We'll need this if this is an FTM object.
        //
        HRESULT hr2;
        COleTls tls(hr2);

        // Create a variable for the supplied flags.  We'll need to modify
        // them if this is an FTM object.
        //
        DWORD dwMrshlFlags = dwFlags;

        // Ok, find out if this object aggregates the FTM.  If it does,
        // we need to switch the thread to the NA to create the StdId.
        //
        CObjectContext* pSavedCtx;
        BOOL fFTM = FALSE;
        IMarshal* pIM = NULL;
        if (SUCCEEDED(pUnk->QueryInterface(IID_IMarshal, (void **)&pIM)))
        {
            IUnknown* pJunk = NULL;
            if (SUCCEEDED(pIM->QueryInterface(IID_IStdFreeMarshal, (void**)&pJunk)))
            {
                // This is an FTM object.  Set the flag indicating so, verify that
                // we have valid TLS info, and switch the thread to the NA.
                fFTM = TRUE;

                dwMrshlFlags |=  IDLF_FTM;

                if (FAILED(hr2))
                    return (hr2);

                // Switch to the default context of NTA
                pSavedCtx = EnterNTA(g_pNTAEmptyCtx);
            }

            // Release the IMarshal interface.
            //
            pIM->Release();
        }

        // Create the StdId object.  We may be in the NA now if the supplied punk
        // is an FTM object and the dwDestCtx is OOP.
        //
        CStdIdentity *pStdId;
        hr = ObtainStdIDFromUnk(pUnk, GetCurrentApartmentId(), GetCurrentContext(),
                                                        dwMrshlFlags, &pStdId);
        *ppMarshal = (IMarshal *)pStdId;

        // If the supplied object aggregates the FTM, make sure we leave in the
        // same apartment we arrived in.
        //
        if (fFTM)
        {
            CObjectContext *pDefaultNTACtx = LeaveNTA(pSavedCtx);
            Win4Assert(g_pNTAEmptyCtx == pDefaultNTACtx);
        }
    }

    ComDebOut((DEB_MARSHAL, "CoGetStandardMarshal: pIM:%x hr:%x\n",
               *ppMarshal, hr));
    return (hr);
}

//+-------------------------------------------------------------------
//
//  Function:   EnsureLegacySupport,    INTERNAL
//
//  synopsis:   Ensures backward compatibility by making the changes
//              needed to support legacy objects that are not context
//              aware
//
//  History:    21-Mar-98   Gopalk      Created
//
//--------------------------------------------------------------------
BOOL EnsureLegacySupport(IUnknown *pUnk, DWORD &dwDestCtx, void *&pvDestCtx)
{
    BOOL fLegacy = FALSE;

    // Check destination context
    if (dwDestCtx == MSHCTX_CROSSCTX || pvDestCtx)
    {
        IMarshal2 *pIM2;
        HRESULT hr = pUnk->QueryInterface(IID_IMarshal2, (void **) &pIM2);
        if (FAILED(hr))
        {
            // Make legacy support changes
            if (dwDestCtx == MSHCTX_CROSSCTX)
                dwDestCtx = MSHCTX_INPROC;

            if (pvDestCtx)
            {
                Win4Assert(dwDestCtx == MSHCTX_DIFFERENTMACHINE);
                pvDestCtx = NULL;
            }
            fLegacy = TRUE;
        }
        else
        {
            pIM2->Release();
        }
    }

    return (fLegacy);
}

//+-------------------------------------------------------------------
//
//  Class:      CDestObjectWrapper, private
//
//  Synopsis:   wraps the CDestObject wrapper to pass to context marshalers
//              carries along an IContextMarshaler they use to call back
//              into us.
//
//  Interfaces: IDestInfo - delegates to receieved CDestObject
//              IContextMarshaler - does the "rest" of CoMarshalInterface
//                                  and CoGetMarshalSizeMax
//
//  History:    01-May-98   SteveSw             Created
//
//--------------------------------------------------------------------
class CDestObjectWrapper : public IDestInfo, IContextMarshaler
{
public:
    //  Constructors and destructors
    CDestObjectWrapper(void* pvDestCtx) : m_cRef(1), m_pIDI(NULL)
    {
        if (pvDestCtx != NULL)
        {
            (void) ((IUnknown*) pvDestCtx)->QueryInterface(IID_IDestInfo, (void**) &m_pIDI);
        }
    }
    ~CDestObjectWrapper()
    {
        if (m_pIDI != NULL)
        {
            m_pIDI->Release();
        }
    }

//  IUnknown interface
public:
    STDMETHOD(QueryInterface)(REFIID riid, void** ppvoid);
    STDMETHOD_(ULONG,AddRef)(void)
    {
        return (InterlockedIncrement(&m_cRef));
    }
    STDMETHOD_(ULONG,Release)(void)
    {
        // these guys are always allocated on the stack
        // so don't delete them here
        return InterlockedDecrement(&m_cRef);
    }

//  IDestInfo interface
public:
    STDMETHOD(GetComVersion)(COMVERSION &cv)
    {
        return (m_pIDI ? m_pIDI->GetComVersion(cv) : E_NOTIMPL);
    }
    STDMETHOD(SetComVersion)(COMVERSION &cv)
    {
        return (m_pIDI ? m_pIDI->SetComVersion(cv) : E_NOTIMPL);
    }
    STDMETHOD(GetDestCtx)(DWORD &dwDestCtx)
    {
        return (m_pIDI ? m_pIDI->GetDestCtx(dwDestCtx) : E_NOTIMPL);
    }
    STDMETHOD(SetDestCtx)(DWORD dwDestCtx)
    {
        return (m_pIDI ? m_pIDI->SetDestCtx(dwDestCtx) : E_NOTIMPL);
    }

//  IContextMarshaler interface
public:
    STDMETHOD(GetMarshalSizeMax) (REFIID riid,
                                  void* pv,
                                  DWORD dwDestContext,
                                  void* pvDestContext,
                                  DWORD mshlflags,
                                  DWORD* pSize);

    STDMETHOD(MarshalInterface) (IStream* pStream,
                                 REFIID riid,
                                 void* pv,
                                 DWORD dwDestContext,
                                 void* pvDestContext,
                                 DWORD mshlflags);

//  Backdoor routines
public:
    STDMETHOD_(void, GetIDestInfo) (void** ppIDI)
    {
        *ppIDI = (void*) m_pIDI;
        if ( *ppIDI != NULL )
        {
            ((IUnknown*) *ppIDI)->AddRef();
        }
    }

//  Members
private:
    LONG            m_cRef;
    IDestInfo*      m_pIDI;
};

//+-------------------------------------------------------------------
//
//  Member:     CDestObjectWrapper::QueryInterface, private
//
//  synopsis:   Standard QI() for CDestObjectWrapper
//
//  History:    01-May-98   SteveSw             Created
//
//--------------------------------------------------------------------
STDMETHODIMP CDestObjectWrapper::QueryInterface(REFIID riid, void** ppvoid)
{
    if ( ppvoid == NULL )
    {
        //  We can't cope with bad arguments here. So we whinge.
        return (E_POINTER);
    }

    if (riid == IID_IDestInfo ||
        riid == IID_IUnknown)
    {
        //  The IUnknown is out of IDestInfo (so people who own this object can convert
        //  between the two by casting, as is done in channelb.cxx)
        *ppvoid = static_cast<IDestInfo*>(this);
    }
    else if (riid == IID_IContextMarshaler)
    {
        //  We implement IContextMarshaler
        *ppvoid = static_cast<IContextMarshaler*>(this);
    }
    else
    {
        //  Yes, we have no bananas.
        *ppvoid = NULL;
        return (E_NOINTERFACE);
    }

    (void) ((IUnknown*) *ppvoid)->AddRef();
    return (S_OK);
}

//+-------------------------------------------------------------------
//
//  Member:     CDestObjectWrapper::GetMarshalSizeMax, private
//
//  synopsis:   returns max size needed to marshal the specified interface.
//
//  History:    01-May-98   SteveSw             Created
//
//--------------------------------------------------------------------
STDMETHODIMP CDestObjectWrapper::GetMarshalSizeMax (REFIID riid,
                                                    void* pv,
                                                    DWORD dwDestCtx,
                                                    void* pvDestObjectWrapper,
                                                    DWORD mshlflags,
                                                    DWORD* pSize)
{
    TRACECALL(TRACE_MARSHAL, "CDestObjectWrapper::GetMarshalSizeMax");
    ComDebOut((DEB_MARSHAL,
              "CDestObjectWrapper::GetMarshalSizeMax: riid:%I pUnk:%x dwDest:%x pvDest:%x flags:%x\n",
               &riid, pv, dwDestCtx, pvDestObjectWrapper, mshlflags));

    HRESULT hr = E_FAIL;
    IUnknown* pUnk = (IUnknown*) pv;
    IMarshal *pIM = NULL;
    void* pvDestCtx;

    *pSize = 0;

    //  Unwrap the pvDestCtx from the wrapper
    ((CDestObjectWrapper*) pvDestObjectWrapper)->GetIDestInfo(&pvDestCtx);

    if ((mshlflags & MSHLFLAGS_NO_IMARSHAL) != MSHLFLAGS_NO_IMARSHAL)
    {
        hr = pUnk->QueryInterface(IID_IMarshal, (void **)&pIM);
    }

    if (SUCCEEDED(hr) && !pIM)
    {
        Win4Assert(!"QI for IMarshal succeeded but returned NULL!");
        hr = E_POINTER;
    }

    if (SUCCEEDED(hr))
    {        
        // Ensure legacy support
        // CODEWORK: we need to get the context based marshal flags
        // for non-legacy custom marshallers

        EnsureLegacySupport(pUnk, dwDestCtx, pvDestCtx);

        // object supports custom marshalling, ask it how much space it needs
        hr = pIM->GetMarshalSizeMax(riid, pv, dwDestCtx,
                                    pvDestCtx, mshlflags, pSize);
        pIM->Release();

        // add in the size of the stuff CoMarshalInterface will write
        *pSize += sizeof(OBJREF);
    }
    else
    {
        hr = MarshalSizeHelper(dwDestCtx, pvDestCtx, mshlflags,
                               GetCurrentContext(), TRUE, pSize);
    }

    if (pvDestCtx != NULL)
    {
        ((IDestInfo*)pvDestCtx)->Release();
    }

    ComDebOut((DEB_MARSHAL, "CDestObjectWrapper::GetMarshalSizeMax: pUnk:%x size:%x hr:%x\n",
                       pv, *pSize, hr));
    return (hr);
}

//+-------------------------------------------------------------------
//
//  Function:   CDestObjectWrapper::MarshalInterface, private
//
//  Synopsis:   marshals the specified interface into the given stream
//
//  History:    01-May-98   SteveSw     Created
//
//--------------------------------------------------------------------
STDMETHODIMP CDestObjectWrapper::MarshalInterface(IStream *pStm,
                                                  REFIID riid,
                                                  void* pv,
                                                  DWORD dwDestCtx,
                                                  void *pDestObjectWrapper,
                                                  DWORD mshlflags)
{
    TRACECALL(TRACE_MARSHAL, "CDestObjectWrapper::MarshalInterface");
    ComDebOut((DEB_MARSHAL,
                       "CDestObjectWrapper::MarshalInterface: pStm:%x riid:%I pUnk:%x dwDest:%x pvDest:%x flags:%x\n",
                       pStm, &riid, pv, dwDestCtx, pDestObjectWrapper, mshlflags));

    HRESULT hr = E_FAIL;
    IMarshal *pIM = NULL;
    IUnknown* pUnk = (IUnknown*) pv;
    void* pvDestCtx;

    //  Unwrap the pvDestCtx from the wrapper
    ((CDestObjectWrapper*) pDestObjectWrapper)->GetIDestInfo(&pvDestCtx);

    // determine whether to do custom or standard marshaling
    if ((mshlflags & MSHLFLAGS_NO_IMARSHAL) != MSHLFLAGS_NO_IMARSHAL)
    {
        hr = ((IUnknown*)pv)->QueryInterface(IID_IMarshal, (void **)&pIM);
    }

    if (SUCCEEDED(hr))
    {
        // object supports custom marshaling, use it. we package the
        // custom data inside an OBJREF.
        Win4Assert(pIM);

        // Ensure legacy support
        EnsureLegacySupport(pUnk, dwDestCtx, pvDestCtx);

        CLSID UnmarshalCLSID;
        DWORD dwSize;

        // get the clsid for unmarshaling
        hr = pIM->GetUnmarshalClass(riid, pUnk, dwDestCtx, pvDestCtx,
                                    mshlflags, &UnmarshalCLSID);

        if ( SUCCEEDED(hr) && !IsEqualCLSID(CLSID_StdMarshal, UnmarshalCLSID) )
        {
            // get the size of data to marshal
            hr = pIM->GetMarshalSizeMax(riid, pv, dwDestCtx,
                                        pvDestCtx, mshlflags, &dwSize);
            if (SUCCEEDED(hr))
            {
                hr = WriteCustomObjrefHeaderToStream(riid, UnmarshalCLSID, dwSize, pStm);
            }
        }
        if (SUCCEEDED(hr))
        {
            // tell the marshaler to write the rest of the data
            hr = pIM->MarshalInterface(pStm, riid, pUnk, dwDestCtx,
                                       pvDestCtx, mshlflags);
        }

        pIM->Release();
    }
    else
    {
		//
        // Decide between wrapper and std marshaling.
		//
		BOOL fUseWrapper = FALSE;

		if (!(mshlflags & MSHLFLAGS_TABLEWEAK))
		{
			if (dwDestCtx == MSHCTX_CROSSCTX)
				fUseWrapper = TRUE;
			else if (dwDestCtx == MSHCTX_INPROC && IsThreadInNTA())
				fUseWrapper = TRUE;				
		}

		if (fUseWrapper)
        {
            hr = WriteCustomObjrefHeaderToStream(riid, CLSID_StdWrapper,
                                                 sizeof(XCtxMarshalData), pStm);
            // Wrapper marshaling
            if (SUCCEEDED(hr))
            {
                hr = WrapperMarshalObject(pStm, riid, pUnk, dwDestCtx, pvDestCtx,
                                          mshlflags);
            }
        }
        else
        {
            // Standard marshaling
            hr = StdMarshalObject(pStm, riid, pUnk, GetCurrentContext(),
                                  dwDestCtx, pvDestCtx, mshlflags);
        }
    }

    if (pvDestCtx != NULL)
    {
        ((IDestInfo*)pvDestCtx)->Release();
    }

    ComDebOut((DEB_MARSHAL,"CDestObjectWrapper::MarshalInterface: pUnk:%x hr:%x\n",pUnk,hr));
    return (hr);
}


//+-------------------------------------------------------------------
//
//  Function:   CoGetMarshalSizeMax, public
//
//  synopsis:   figures max size needed to marshal the specified interface
//                              by delegating to ContextMarshaler or CoDirectGetMarshalSizeMax()
//
//  History:    23-Nov-92   Rickhi      Created
//              11-Dec-93   CraigWi     Switched to static marshaler
//              20-Feb-95   Rickhi      Return correct sizes once again.
//              21-Mar-98   Gopalk      Simplified for context work
//              22-Apr-98   SatishT     Added support for context marshallers
//              01-May-98   SteveSw             Changed support for context marshalers
//
//--------------------------------------------------------------------
STDAPI CoGetMarshalSizeMax(ULONG *pulSize, REFIID riid, IUnknown *pUnk,
                           DWORD dwDestCtx, void *pvDestCtx, DWORD mshlflags)
{
    TRACECALL(TRACE_MARSHAL, "CoGetMarshalSizeMax");
    ComDebOut((DEB_MARSHAL,
              "CoGetMarshalSizeMax: riid:%I pUnk:%x dwDest:%x pvDest:%x flags:%x\n",
               &riid, pUnk, dwDestCtx, pvDestCtx, mshlflags));

    // validate the input parameters
    if (pulSize == NULL || pUnk == NULL ||
        FAILED(ValidateMarshalFlags(dwDestCtx, pvDestCtx, mshlflags)))
    {
        return E_INVALIDARG;
    }

    *pulSize = 0;

    HRESULT hr = InitChannelIfNecessary();
    if (FAILED(hr))
    {
        return (hr);
    }

    CALLHOOKOBJECT(S_OK,CLSID_NULL,riid,&pUnk);

#ifdef _CHICAGO_SCM_
    // On DCOM95 lazy start RPCSS but only if
    // marshalling for a remote client AND EnableDCOM
    // == "Y" in registry.  This allows us to reset
    // gpsaLocalResolver so that a correct result is returned.
    if ((dwDestCtx == MSHCTX_DIFFERENTMACHINE) && (!gDisableDCOM))
    {
        hr = StartRPCSS();
        if (FAILED(hr))
        {
            return (hr);
        }
    }
#endif // _CHICAGO_SCM_

    //  Here we delegate to the context marshaler, if it's there. We
    //  create a wrapper around the destObject that maintains its
    //  interfaces but adds an IContextMarshaler, which the context
    //  marshaler will use to get back into our code. If there's no
    //  context marshaler, we just go ahead and do what the context
    //  marshaler would have done, call back into the wrapper for
    //  the "real" work.

    IContextMarshaler *pICM = NULL;
    hr = (GetCurrentContext())->GetContextMarshaler(&pICM);
    Win4Assert(hr == S_OK);

    CDestObjectWrapper DOW(pvDestCtx);

    if (pICM != NULL)
    {
        hr = pICM->GetMarshalSizeMax(riid, (void*) pUnk, dwDestCtx,
                                     (void*) &DOW, mshlflags, pulSize);
        *pulSize += sizeof(OBJREF);
        ((IUnknown*) pICM)->Release();
    }
    else
    {
        hr = DOW.GetMarshalSizeMax(riid, (void*) pUnk, dwDestCtx,
                                   (void*) &DOW, mshlflags, pulSize);
    }

    ComDebOut((DEB_MARSHAL, "CoGetMarshalSizeMax: pUnk:%x size:%x hr:%x\n",
              pUnk, *pulSize, hr));
    return (hr);
}

//+-------------------------------------------------------------------
//
//  Function:   CoMarshalInterface, public
//
//  Synopsis:   marshals the specified interface into the given stream
//                              using ContextMarshaler or CoDirectMarshalInterface
//
//  History:    23-Nov-92   Rickhi      Created
//              11-Dec-93   CraigWi     Switched to identity object and
//                                      new marshaling format
//              20-Feb-95   Rickhi      switched to newer marshal format
//              21-Mar-98   Gopalk      Added support for wrapper marshalling
//              22-Apr-98   SatishT     Added support for context marshallers
//              01-May-98   SteveSw     Changed support for context marshallers
//
//--------------------------------------------------------------------
STDAPI CoMarshalInterface(IStream *pStm, REFIID riid, IUnknown *pUnk,
                          DWORD dwDestCtx, void *pvDestCtx, DWORD mshlflags)
{
    TRACECALL(TRACE_MARSHAL, "CoMarshalInterface");
    ComDebOut((DEB_MARSHAL,
              "CoMarshalInterface: pStm:%x riid:%I pUnk:%x dwDest:%x pvDest:%x flags:%x\n",
               pStm, &riid, pUnk, dwDestCtx, pvDestCtx, mshlflags));

    // validate the input parameters
    HRESULT hr = ValidateMarshalParams(pStm, pUnk, dwDestCtx, pvDestCtx, mshlflags);
    if (FAILED(hr))
        return hr;

    hr = InitChannelIfNecessary();
    if (FAILED(hr))
    {
        return (hr);
    }

    CALLHOOKOBJECT(S_OK,CLSID_NULL,riid,(IUnknown **)&pUnk);
    CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IStream,(IUnknown **)&pStm);

    //  Here we delegate to the context marshaler, if it's there. We
    //  create a wrapper around the destObject that maintains its
    //  interfaces but adds an IContextMarshaler, which the context
    //  marshaler will use to get back into our code. If there's no
    //  context marshaler, we just go ahead and do what the context
    //  marshaler would have done, call back into the wrapper for
    //  the "real" work.

    IContextMarshaler *pICM = NULL;
    hr = (GetCurrentContext())->GetContextMarshaler(&pICM);
    Win4Assert(hr == S_OK);

    CDestObjectWrapper DOW(pvDestCtx);

    if (pICM != NULL)
    {
        hr = pICM->MarshalInterface(pStm, riid, pUnk, dwDestCtx,
                                   (void*) &DOW, mshlflags);
        ((IUnknown*) pICM)->Release();
    }
    else
    {
        hr = DOW.MarshalInterface(pStm, riid, pUnk, dwDestCtx,
                                  (void*) &DOW, mshlflags);
    }

    ComDebOut((DEB_MARSHAL,"CoMarshalInterface: pUnk:%x hr:%x\n",pUnk,hr));
    return (hr);
}

//+-------------------------------------------------------------------
//
//  Function:   WriteCustomObjrefHeaderToStream
//
//  Synopsis:   Crafts up a header for a custom OBJREF and writes it
//              to a stream.
//
//  History:    24-Apr-97   MattSmit          Created
//
//--------------------------------------------------------------------
HRESULT WriteCustomObjrefHeaderToStream(REFIID riid, REFCLSID rclsid, DWORD dwSize, IStream *pStm)
{
    OBJREF objref;

    objref.signature = OBJREF_SIGNATURE;
    objref.flags     = OBJREF_CUSTOM;
    objref.iid       = riid;
    ORCST(objref).clsid     = rclsid;
    ORCST(objref).size      = dwSize;

    // currently we dont write any extensions into the custom
    // objref. The provision is there so we can do it in the
    // future, for example,  if the unmarshaler does not have the
    // unmarshal class code available we could to provide a callback
    // mechanism by putting the OXID, and saResAddr in there.
    ORCST(objref).cbExtension = 0;

    // write the objref header info into the stream
    ULONG cbToWrite = PtrToUlong( (LPVOID)( (BYTE *)(&ORCST(objref).pData) - (BYTE *)&objref ) );
    return (pStm->Write(&objref, cbToWrite, NULL));
}

//+-------------------------------------------------------------------
//
//  Function:   GetCustomUnmarshaler, private
//
//  Synopsis:   Creates the custom unmarshaler of the given clsid.  Checks
//              for common known clsid's first. Goes through CCI if not
//              one of the known clsids. Called by CoUnmarshalInterface
//              and CoReleaseMarshalData.
//
//  History:    14-Jan-99   Rickhi      Made into common subroutine
//
//--------------------------------------------------------------------
HRESULT GetCustomUnmarshaler(REFCLSID rclsid, IStream *pStm, IMarshal **ppIM)
{
    HRESULT hr;

    if (InlineIsEqualGUID(CLSID_StdWrapper, rclsid))
    {
        hr = GetStaticWrapper(ppIM);
    }
    else if (InlineIsEqualGUID(CLSID_InProcFreeMarshaler, rclsid))
    {
        hr = GetInProcFreeMarshaler(ppIM);
    }
    else if (InlineIsEqualGUID(CLSID_ContextMarshaler, rclsid))
    {
        hr = GetStaticContextUnmarshal(ppIM);
    }
    else if (InlineIsEqualGUID(CLSID_AggStdMarshal, rclsid))
    {
        hr = FindAggStdMarshal(pStm, ppIM);
    }
    else
    {
        DWORD dwFlags = CLSCTX_INPROC | CLSCTX_NO_CODE_DOWNLOAD;
        dwFlags |= (gCapabilities & EOAC_NO_CUSTOM_MARSHAL)
                                  ? CLSCTX_NO_CUSTOM_MARSHAL : 0;

        hr = CoCreateInstance(rclsid, NULL, dwFlags, IID_IMarshal,
                              (void **)ppIM);
    }

    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CoUnmarshalInterface, public
//
//  Synopsis:   Unmarshals a marshaled interface pointer from the stream.
//
//  Notes:      when a controlling unknown is supplied, it is assumed that
//              the HANDLER for the class has done a CreateInstance and wants
//              to aggregate just the proxymanager, ie. we dont want to
//              instantiate a new class handler (the default unmarshalling
//              behaviour).
//
//  History:    23-Nov-92   Rickhi      Created
//              11-Dec-93   CraigWi     Switched to static marshaler and
//                                      new marshaling format
//              20-Feb-95   Rickhi      switched to newer marshal format
//
//--------------------------------------------------------------------
STDAPI CoUnmarshalInterface(IStream *pStm, REFIID riid, void **ppv)
{
    TRACECALL(TRACE_MARSHAL, "CoUnmarshalInterface");
    CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IStream,(IUnknown **)&pStm);
    ComDebOut((DEB_MARSHAL,
              "CoUnmarshalInterface: pStm:%x riid:%I\n", pStm, &riid));

    // validate the input parameters
    if (pStm == NULL || ppv == NULL)
    {
        return (E_INVALIDARG);
    }

    *ppv = NULL;

    HRESULT hr = InitChannelIfNecessary();
    if (FAILED(hr))
        return (hr);

    // read the objref from the stream.
    OBJREF  objref;
    hr = ReadObjRef(pStm, objref);

    if (SUCCEEDED(hr))
    {
        if (objref.flags & OBJREF_CUSTOM)
        {
            // uses custom marshaling, create an instance and ask that guy
            // to do the unmarshaling. special case createinstance for the
            // freethreaded marshaler and aggregated standard marshaler.

            IMarshal *pIM;
            hr = GetCustomUnmarshaler(ORCST(objref).clsid, pStm, &pIM);

            if (SUCCEEDED(hr))
            {
                hr = pIM->UnmarshalInterface(pStm, objref.iid, ppv);
                pIM->Release();
            }
            else
            {
                // seek past the custom marshalers data so we leave the
                // stream at the correct position.

                LARGE_INTEGER libMove;
                libMove.LowPart  = ORCST(objref).size;
                libMove.HighPart = 0;
                pStm->Seek(libMove, STREAM_SEEK_CUR, NULL);
            }
        }
        else
        {
            // uses standard marshaling, call API to find or create the
            // instance of CStdMarshal for the oid inside the objref, and
            // ask that instance to unmarshal the interface. This covers
            // handler unmarshaling also.

            hr = UnmarshalObjRef(objref, ppv);
        }

        // free the objref we read above
        FreeObjRef(objref);

        if (!InlineIsEqualGUID(riid, GUID_NULL) &&
            !InlineIsEqualGUID(riid, objref.iid) && SUCCEEDED(hr) )
        {
            // the interface iid requested was different than the one that
            // was marshaled (and was not GUID_NULL), so go get the requested
            // one and release the marshaled one. GUID_NULL is used by the Ndr
            // unmarshaling engine and means return whatever interface was
            // marshaled.

            IUnknown *pUnk = (IUnknown *)*ppv;

#ifdef WX86OLE
            if ( gcwx86.IsN2XProxy(pUnk) )
            {
                // Tell wx86 thunk layer to thunk as IUnknown
                gcwx86.SetStubInvokeFlag((BOOL)1);
            }
#endif

            hr = pUnk->QueryInterface(riid, ppv);
            pUnk->Release();
        }
    }

    ComDebOut((DEB_MARSHAL, "CoUnmarshalInterface: pUnk:%x hr:%x\n",
                       *ppv, hr));
    return (hr);
}

//+-------------------------------------------------------------------
//
//  Function:   CoReleaseMarshalData, public
//
//  Synopsis:   release the reference created by CoMarshalInterface
//
//  Algorithm:
//
//  History:    23-Nov-92   Rickhi
//              11-Dec-93   CraigWi     Switched to static marshaler and
//                                      new marshaling format
//              20-Feb-95   Rickhi      switched to newer marshal format
//
//--------------------------------------------------------------------
STDAPI CoReleaseMarshalData(IStream *pStm)
{
    TRACECALL(TRACE_MARSHAL, "CoReleaseMarshalData");
    ComDebOut((DEB_MARSHAL, "CoReleaseMarshalData pStm:%x\n", pStm));
    CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IStream,(IUnknown **) &pStm);

    // validate the input parameters
    if (pStm == NULL)
    {
        return (E_INVALIDARG);
    }

    HRESULT hr = InitChannelIfNecessary();
    if (FAILED(hr))
        return (hr);

    // read the objref from the stream.
    OBJREF  objref;
    hr = ReadObjRef(pStm, objref);

    if (SUCCEEDED(hr))
    {
        if (objref.flags & OBJREF_CUSTOM)
        {
            // object uses custom marshaling. create an instance of the
            // unmarshaling code and ask it to release the marshaled data.

            IMarshal *pIM;
            hr = GetCustomUnmarshaler(ORCST(objref).clsid, pStm, &pIM);

            if (SUCCEEDED(hr))
            {
                hr = pIM->ReleaseMarshalData(pStm);
                pIM->Release();
            }
            else
            {
                // seek past the custom marshalers data so we leave the
                // stream at the correct position.

                LARGE_INTEGER libMove;
                libMove.LowPart  = ORCST(objref).size;
                libMove.HighPart = 0;
                pStm->Seek(libMove, STREAM_SEEK_CUR, NULL);
            }
        }
        else
        {
            hr = ReleaseMarshalObjRef(objref);
        }

        // free the objref we read above
        FreeObjRef(objref);
    }

    ComDebOut((DEB_MARSHAL, "CoReleaseMarshalData hr:%x\n", hr));
    return (hr);
}

//+-------------------------------------------------------------------
//
//  Function:   CoDisconnectObject, public
//
//  synopsis:   disconnects all clients of an object by marking their
//              connections as terminted abnormaly.
//
//  History:    04-Oct-93   Rickhi      Created
//              11-Dec-93   CraigWi     Switched to identity object
//
//--------------------------------------------------------------------
STDAPI CoDisconnectObject(IUnknown *pUnk, DWORD dwReserved)
{
    TRACECALL(TRACE_MARSHAL, "CoDisconnectObject");
    ComDebOut((DEB_MARSHAL, "CoDisconnectObject pUnk:%x dwRes:%x\n",
                       pUnk, dwReserved));

    // validate the input parameters
    if (pUnk == NULL || dwReserved != 0)
    {
        return (E_INVALIDARG);
    }

    if (!IsValidInterface(pUnk))
        return (E_INVALIDARG);

    if (!IsApartmentInitialized())
    {
        return (CO_E_NOTINITIALIZED);
    }

    CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IUnknown,&pUnk);

    IMarshal *pIM = NULL;
    HRESULT hr = pUnk->QueryInterface(IID_IMarshal, (void **)&pIM);

    if (FAILED(hr))
    {
        // object does not support IMarshal directly. Find its standard
        // marshaler if there is one, otherwise return an error.

        IUnknown *pServer;
        hr = pUnk->QueryInterface(IID_IUnknown, (void **) &pServer);
        if (SUCCEEDED(hr))
        {
            CIDObject *pID = NULL;
            CObjectContext* pContext = GetCurrentContext();
			
            // Because it so common for folks to call CoDisconnectObject
            // when their dll gets unloaded (think ATL here), we check 
            // for a NULL current context here.   
            if (pContext)
            {
                LOCK(gComLock);
                pID = gPIDTable.Lookup(pServer, pContext);
                UNLOCK(gComLock);
            }
            if ( pID )
            {
                CStdIdentity *pStdID = pID->GetStdID();
                if ( pStdID )
                {
                    pStdID->AddRef();
                    hr = pStdID->DisconnectObject(0);
                    pStdID->Release();
                }
                if ( SUCCEEDED(hr) )
                {
                    CStdWrapper *pWrapper = pID->GetWrapper();
                    if ( pWrapper )
                    {
                        pWrapper->InternalAddRef();
                        hr = pWrapper->DisconnectObject(0);
                        pWrapper->InternalRelease(NULL);
                    }
                }

                // Release the ID object
                pID->Release();
            }

            // Release the server object
            pServer->Release();
        }
        else
        {
            hr = S_OK;
        }
    }
    else
    {
        hr = pIM->DisconnectObject(dwReserved);
        pIM->Release();
    }

    ComDebOut((DEB_MARSHAL,"CoDisconnectObject pIM:%x hr:%x\n", pIM, hr));
    return (hr);
}

//+-------------------------------------------------------------------
//
//  Function:   CoLockObjectExternal, public
//
//  synopsis:   adds/revokes a strong reference count to/from the
//              identity for the given object.
//
//  parameters: [punkObject] - IUnknown of the object
//              [fLock] - lock/unlock the object
//              [fLastUR] - last unlock releases.
//
//  History:    23-Nov-92   Rickhi      Created
//              11-Dec-93   CraigWi     Switched to identity object
//
//--------------------------------------------------------------------
STDAPI  CoLockObjectExternal(IUnknown *pUnk, BOOL fLock, BOOL fLastUR)
{
    TRACECALL(TRACE_MARSHAL, "CoLockObjectExternal");
    ComDebOut((DEB_MARSHAL,
        "CoLockObjectExternal pUnk:%x fLock:%x fLastUR:%x\n", pUnk, fLock, fLastUR));

    if (!IsValidInterface(pUnk))
        return (E_INVALIDARG);

    CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IUnknown,(IUnknown **)&pUnk);

    HRESULT hr = InitChannelIfNecessary();
    if (FAILED(hr))
        return (hr);

    DWORD dwFlags = fLock ? IDLF_CREATE : 0;

    // Initialize TLS.  We'll need this if this is an FTM object.
    //
    HRESULT hr2;
    COleTls tls(hr2);

    // Ok, find out if this object aggregates the FTM.  If it does,
    // we need to switch the thread to the NA to create the StdId.
    //
    CObjectContext* pSavedCtx;
    BOOL fFTM = FALSE;
    IMarshal* pIM = NULL;
    if (SUCCEEDED(pUnk->QueryInterface(IID_IMarshal, (void **)&pIM)))
    {
        IUnknown* pJunk = NULL;
        if ( SUCCEEDED(pIM->QueryInterface(IID_IStdFreeMarshal, (void**)&pJunk)) )
        {
            // This is an FTM object.  Set the flag indicating so, verify that
            // we have valid TLS info, and switch the thread to the NA.
            //
            fFTM = TRUE;

            dwFlags |= IDLF_FTM;

            if (FAILED(hr2))
                return (hr2);

            // Switch to the default context of NTA
            pSavedCtx = EnterNTA(g_pNTAEmptyCtx);
        }

        // Release the IMarshal interface.
        //
        pIM->Release();
    }

    CStdIdentity *pStdID;
    hr = ObtainStdIDFromUnk(pUnk, GetCurrentApartmentId(),
                            GetCurrentContext(),
                            dwFlags,
                            &pStdID);

    // If the supplied object aggregates the FTM, make sure we leave in the
    // same apartment we arrived in.
    //
    if (fFTM)
    {
        CObjectContext *pDefaultNTACtx = LeaveNTA(pSavedCtx);
        Win4Assert(g_pNTAEmptyCtx == pDefaultNTACtx);
    }

    switch (hr)
    {
    case S_OK:
        // REF COUNTING: inc or dec external ref count
        hr = pStdID->LockObjectExternal(fLock, fLastUR);
        pStdID->Release();
        break;

    case CO_E_OBJNOTREG:
        // unlock when not registered; 16bit code returned NOERROR;
        // disconnected handler goes to S_OK case above.
        hr = S_OK;
        break;

    case E_OUTOFMEMORY:
        break;

    default:
        hr = E_UNEXPECTED;
        break;
    }

    ComDebOut((DEB_MARSHAL, "CoLockObjectExternal pStdID:%x hr:%x\n", pStdID, hr));
    return (hr);
}

//+-------------------------------------------------------------------
//
//  Function:   CoIsHandlerConnected, public
//
//  Synopsis:   Returns whether or not handler is connected to remote
//
//  Algorithm:  QueryInterface to IProxyManager. If this is supported,
//              then this is a handler. We ask the handler
//              for its opinion otherwise we simply return TRUE.
//
//  History:    04-Oct-93   Rickhi      Created
//
//  Notes:      The answer of this routine may be wrong by the time
//              the routine returns.  This is correct behavior as
//              this routine is primilary to cleanup state associated
//              with connections.
//
//--------------------------------------------------------------------
STDAPI_(BOOL) CoIsHandlerConnected(LPUNKNOWN pUnk)
{
    // validate input parameters
    if (!IsValidInterface(pUnk))
        return (FALSE);

    // Assume it is connected
    BOOL fResult = TRUE;

    // Handler should support IProxyManager
    IProxyManager *pPM;
    CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IUnknown,(IUnknown **)&pUnk);
    if (SUCCEEDED(pUnk->QueryInterface(IID_IProxyManager, (void **)&pPM)))
    {
        // We have something that thinks its is an Ole handler so we ask
        fResult = pPM->IsConnected();
        pPM->Release();
    }

    return (fResult);
}

//+-------------------------------------------------------------------
//
//  Function:   GetStaticUnMarshaler, private
//
//  Synopsis:   Returns the static instance of the CStdMarshal.
//
//  History:    20-Feb-95   Rickhi      Created.
//
//  Notes:      The standard marshaler must be able to resolve identity, that
//              is two proxies for the same object must never be created in
//              the same apartment. Given that, it makes sense to let the
//              standard guy do the unmarshaling. Since we dont know the
//              identity of the object upfront, and any instance will do, we
//              use a static instance to handle unmarshal.
//
//--------------------------------------------------------------------
INTERNAL GetStaticUnMarshaler(IMarshal **ppIM)
{
    HRESULT hr = S_OK;

    if (gpStdMarshal == NULL)
    {
		IMarshal *pTemp = NULL;
		
        // the global instance has not been created yet, so go make it now.
        hr = CreateIdentityHandler(NULL,
                                   STDID_CLIENT |
                                   STDID_FREETHREADED |
                                   STDID_SYSTEM |
                                   STDID_LOCKEDINMEM,
                                   NULL,
                                   GetCurrentApartmentId(),
                                   IID_IMarshal,
                                   (void **)&pTemp);

		// Only allow one thread to set gpStdMarshal
        if(InterlockedCompareExchangePointer((void **)&gpStdMarshal,pTemp,NULL)!=NULL)
        {
	        ((CStdIdentity *) pTemp)->UnlockAndRelease();
        }
    }
	
    *ppIM = gpStdMarshal;
    if (gpStdMarshal)
    {
        gpStdMarshal->AddRef();
    }
    return (hr);
}

//+-------------------------------------------------------------------
//
//  Function:   GetIIDFromObjRef, private
//
//  Synopsis:   Returns the IID embedded inside a marshaled interface
//              pointer OBJREF. Needed by the x86 thunking code and
//              NDR marshaling engine.
//
//  History:    10-Oct-97   Rickhi      Created
//
//--------------------------------------------------------------------
HRESULT GetIIDFromObjRef(OBJREF &objref, IID **piid)
{
    // check to ensure the objref is at least partially sane
    if ((objref.signature != OBJREF_SIGNATURE) ||
        (objref.flags & OBJREF_RSRVD_MBZ)      ||
        (objref.flags == 0) )
    {
        // the objref signature is bad, or one of the reserved
        // bits in the flags is set, or none of the required bits
        // in the flags is set. the objref cant be interpreted so
        // fail the call.

        Win4Assert(!"Invalid Objref Header");
        return (RPC_E_INVALID_OBJREF);
    }

    // extract the IID
    *piid = &objref.iid;
    return (S_OK);
}


#ifdef WX86OLE
//+-------------------------------------------------------------------
//
//  Function:   CoGetIIDFromMarshaledInterface, public
//
//  Synopsis:   Returns the IID embedded inside a marshaled interface
//              pointer. Needed by the x86 thunking code.
//
//  History:    16-Apr-96   Rickhi      Created
//
//--------------------------------------------------------------------
STDAPI CoGetIIDFromMarshaledInterface(IStream *pStm, IID *piid)
{
    ULARGE_INTEGER ulSeekEnd;
    LARGE_INTEGER lSeekStart, lSeekEnd;
    LISet32(lSeekStart, 0);

    // remember the current position
    HRESULT hr = pStm->Seek(lSeekStart, STREAM_SEEK_CUR, &ulSeekEnd);

    if ( SUCCEEDED(hr) )
    {
        // read the first part of the objref which contains the IID
        OBJREF objref;
        hr = StRead(pStm, &objref, 2*sizeof(ULONG) + sizeof(IID));

        if (SUCCEEDED(hr))
        {
            IID iid;
            IID *piidTemp = &iid;

            // validate the OBJREF and extract the IID
            hr = GetIIDFromObjRef(objref, &piidTemp);

            *piid = *piidTemp;
        }

        // put the seek pointer back to the original location
        lSeekEnd.LowPart = ulSeekEnd.LowPart;
        lSeekEnd.HighPart = (LONG)ulSeekEnd.HighPart;
        HRESULT hr2 = pStm->Seek(lSeekEnd, STREAM_SEEK_SET, NULL);
        hr = (FAILED(hr)) ? hr : hr2;
    }

    return (hr);
}
#endif


//+-------------------------------------------------------------------
//
//  Function:   CoDeactivateObject         public
//
//  Synopsis:   Releases all the references kept on the given object
//              without tearing down the stub manager and wrapper
//
//  History:    30-Mar-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDAPI CoDeactivateObject(IUnknown *pUnk, IUnknown **ppCookie)
{
    ContextDebugOut((DEB_ACTDEACT, "CoDeactivateObject pUnk:%x\n", pUnk));

    // Initialize return value.
    *ppCookie = NULL;

    // Obtain the identity of the server
    IUnknown *pServer;
    HRESULT hr = pUnk->QueryInterface(IID_IUnknown, (void **) &pServer);
    if (SUCCEEDED(hr))
    {
        hr = CO_E_OBJNOTCONNECTED; // assume already disconnected.

        ASSERT_LOCK_NOT_HELD(gComLock);
        LOCK(gComLock);

        // Lookup the IDObject representing the server
        CIDObject *pID = gPIDTable.Lookup(pServer, GetCurrentContext());

        if (pID)
        {
            // deactivate the IDObject, releases the lock
            hr = pID->Deactivate();
            ASSERT_LOCK_NOT_HELD(gComLock);

            if (SUCCEEDED(hr))
            {
                // set the return parameter, caller now owns the
                // IDObject reference.
                *ppCookie = pID;
                pID = NULL;
            }
            else
            {
                pID->Release();
            }
        }
        else
        {
            UNLOCK(gComLock);
            ASSERT_LOCK_NOT_HELD(gComLock);
        }

        pServer->Release();
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    ContextDebugOut((DEB_ACTDEACT,
            "CoDeactivateObject hr:0x%x cookie:%x\n", hr, *ppCookie));
    return(hr);
}

//+-------------------------------------------------------------------
//
//  Function:   CoReactivateObject         public
//
//  Synopsis:   Reconnects the given object to the stub manager and
//              wrapper specified by the IDObject
//
//  History:    30-Mar-98   Gopalk      Created
//
//+-------------------------------------------------------------------
STDAPI CoReactivateObject(IUnknown *pUnk, IUnknown *pCookie)
{
    ContextDebugOut((DEB_ACTDEACT,
            "CoReactivateObject pUnk:%x cookie:%x\n", pUnk, pCookie));
    ASSERT_LOCK_NOT_HELD(gComLock);
    
    // Validate params
    if (pCookie == NULL || pUnk == NULL)
        return E_INVALIDARG;

    // Ensure that the cookie is indeed an IDObject
    CIDObject *pID;
    HRESULT hr = pCookie->QueryInterface(IID_IStdIDObject, (void **) &pID);
    if (SUCCEEDED(hr))
    {
        // Obtain the identity of the server
        IUnknown *pServer;
        hr = pUnk->QueryInterface(IID_IUnknown, (void **) &pServer);
        if (SUCCEEDED(hr))
        {
            hr = pID->Reactivate(pServer);
            pServer->Release();
        }
        else
        {
            hr = E_UNEXPECTED;
        }

        pID->Release();
    }
    else
    {
        hr = E_INVALIDARG;
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_ACTDEACT, "CoReactivateObject hr 0x%x\n", hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Function:   CoAllowSetForegroundWindow  public
//
//  Synopsis:   Grants foreground transfer permissions to the server
//              process of an object from the client process.
//
//  Algorithm:  Queries the pUnk for IForegroundTransfer and calls
//              the AllowForegroundTransfer method on it.
//
//  History:    02-Feb-99   MPrabhu     Created
//
//+-------------------------------------------------------------------

STDAPI CoAllowSetForegroundWindow(IUnknown *pUnk, void* lpvReserved)
{
    HRESULT hr;
    IForegroundTransfer *pFGT = NULL;

    // validate input parameters
    if (!IsValidInterface(pUnk) || (lpvReserved!=NULL))
        return (E_INVALIDARG);

    hr = pUnk->QueryInterface(IID_IForegroundTransfer, (void **)&pFGT);

    if (SUCCEEDED(hr))
    {
        Win4Assert(pFGT);
        hr = pFGT->AllowForegroundTransfer(lpvReserved);
        pFGT->Release();
    }
    else
    {
        hr = (E_NOINTERFACE);
    }

    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   DcomChannelSetHResult  public
//
//  Synopsis:   COM+ services requires that policies registered to
//              receive event notifications on calls to configured
//              classes have access to the actual HRESULT returned by
//              called methods. Because the server's HRESULT cannot be
//              safely fetched from the reply buffer, RPC uses this
//              API to supply us with the HRESULT, which we ship back
//              to the other side using the context extents.
//
//  Algorithm:  If the call is on an object of a configured class,
//              the supplied HRESULT is stored in the context call
//              object in TLS.
//
//  History:    27-Mar-99   Johnstra     Created
//              21-Feb-01   JSimmons     Modifed to accept a NULL first
//                                       parameter - in this case we now
//                                       try to store the hresult in tls.
//
//  Notes:   This function is (as of whistler) defined in objbase.h with
//     the signature below.   RPCRT4 is calling this api as well (since 
//     W2K) but they expect the first parameter to be an RPCOLEMESSAGE*, 
//     hence the cast in the code below.   
//
//+-------------------------------------------------------------------
STDAPI DcomChannelSetHResult(
    LPVOID         pvRpcOleMsg,      
    ULONG         *pReserve,
    HRESULT        appsHR
    )
{
    RPCOLEMESSAGE* pMsg = (RPCOLEMESSAGE*)pvRpcOleMsg;

    if (NULL == pMsg)
    {
        // This is the case where somebody
        // other than RPC is calling us
        return PrivSetServerHRESULTInTLS(pReserve, appsHR);
    }

    // If no call object, punt.
    if (pMsg->reserved1 == NULL)
        return S_OK;

    // If the supplied HRESULT is S_OK, don't do anything.  Only
    // non-S_OK return codes are relevant.
    if (appsHR != S_OK)
        return PrivSetServerHResult(pMsg, pReserve, appsHR);
        
    return S_OK;
}


//+-------------------------------------------------------------------
//
//  Function:   CoInvalidateRemoteMachineBindings
//
//  Synopsis:   API to provide users a way to flush the SCM's remote
//              binding handle cache.    pszMachineName can be "" which
//              means flush the entire cache.    
//
//  Algorithm:  Verify non-NULL arguments, then pass call on to the resolver.
//
//  History:    21-May-00   JSimmons   Created
//
//+-------------------------------------------------------------------
STDAPI CoInvalidateRemoteMachineBindings(
                LPOLESTR pszMachineName
                )
{	
    if (!pszMachineName)
        return E_INVALIDARG;

    // Pass call on to the resolver
    return gResolver.FlushSCMBindings(pszMachineName);
}


//+-------------------------------------------------------------------
//
//  Function:   CoRetireServer  (this api is currently unpublished!)
//
//  Synopsis:   API that when called immediately marks the specified
//              process as no longer eligible for activations.  COM+ 
//              uses this api to support their process recycling feature.
//              SCM will check that we are an administrator, or call will
//              fail.
//
//  Algorithm:  Verify arg is non-NULL, then pass call on to the
//              resolver.
//
//  History:    21-May-00   JSimmons   Created
//
//+-------------------------------------------------------------------
STDAPI CoRetireServer(
                GUID* pguidProcessIdentifier
                )
{
    if (!pguidProcessIdentifier)
        return E_INVALIDARG;
    
    return gResolver.RetireServer(pguidProcessIdentifier);
}

//+-------------------------------------------------------------------
//
//  Function:   CoGetProcessIdentifier  (this api is currently unpublished!)
//
//  Synopsis:   API to retrieve this process's RPCSS-allocated guid identifier.
//
//  Algorithm:  Verify arg is non-NULL, then pass call on to the
//              resolver.
//
//  History:    24-May-00   JSimmons   Created
//
//+-------------------------------------------------------------------
STDAPI CoGetProcessIdentifier(
                GUID* pguidProcessIdentifier
                )
{
    if (!pguidProcessIdentifier)
        return E_INVALIDARG;
    
	*pguidProcessIdentifier = *gResolver.GetRPCSSProcessIdentifier();

    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Function:   CoGetContextToken
//
//  Synopsis:   Gets a context token as fast as possible.
//
//  History:    10-Nov-00   ddriver   Created
//
//+-------------------------------------------------------------------
STDAPI CoGetContextToken(ULONG_PTR* pToken)
{
    if(!pToken) return(E_POINTER);

    // This makes sure TLS is initialized:
    if (!IsApartmentInitialized())
    {
        return (CO_E_NOTINITIALIZED);
    }

    *pToken = (ULONG_PTR)(IObjContext*)(GetCurrentContext());
    ASSERT(*pToken);

    return(S_OK);
}



//+-------------------------------------------------------------------
//
//  Function:   CoGetDefaultContext           public
//
//  Synopsis:   Obtains the default object context for specified
//              apartment. 
//
//  History:    13-Jan-2000 a-sergiv    Created
//              28-Mar-2001 JohnDoty    Modified slightly-- now takes
//                                      an APTTYPE to indicate which
//                                      apartment, supports getting
//                                      specific context.
//
//+-------------------------------------------------------------------
STDAPI CoGetDefaultContext(APTTYPE aptType, REFIID riid, void **ppv)
{
    ContextDebugOut((DEB_POLICYSET, "CoGetDefaultContext\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr;

    // Initialize
    *ppv = NULL;

    // Cannot ask for STA directly-- what STA do you mean?
    if (aptType == APTTYPE_STA)
        return E_INVALIDARG;

    // Initalize channel
    hr = InitChannelIfNecessary();
    if(SUCCEEDED(hr))
    {
        COleTls tls;

        if(aptType == APTTYPE_CURRENT)
        {
            if (tls.IsNULL())
            {
                // No TLS, must be in implicit MTA (if anywhere)
                aptType = APTTYPE_MTA;
            }
            else
            {
                APTKIND aptKind = GetCurrentApartmentKind(tls);
                switch (aptKind)
                {
                case APTKIND_APARTMENTTHREADED: aptType = APTTYPE_STA; break;
                case APTKIND_MULTITHREADED:     aptType = APTTYPE_MTA; break;
                case APTKIND_NEUTRALTHREADED:   aptType = APTTYPE_NA;  break;
                }
            }
        }
        
        CObjectContext *pDefCtx = NULL;
            
        switch(aptType)
        {
        case APTTYPE_MTA:
            pDefCtx = g_pMTAEmptyCtx;
            break;
            
        case APTTYPE_NA:
            pDefCtx = g_pNTAEmptyCtx;
            break;
            
        case APTTYPE_MAINSTA:
            // Get the TLS for the main STA.
            if (gdwMainThreadId)
            {
                SOleTlsData *pMainTls = TLSLookupThreadId(gdwMainThreadId);
                if (pMainTls)
                {
                    pDefCtx = pMainTls->pEmptyCtx;
                }
                //TODO: Assert if NULL?  The main thread should have TLS,
                //      since it's initialized.
            }
            break;

        case APTTYPE_STA:
            // TLS had better be there.. see how we resolve aptType.
            // We cannot get here without having tls.
            Win4Assert(!tls.IsNULL()); 
            pDefCtx = tls->pEmptyCtx;
            break;

        default:
            hr = E_INVALIDARG;
            break;
        }

        if (SUCCEEDED(hr))
        {
            if (pDefCtx)
            {
                hr = pDefCtx->QueryInterface(riid, ppv);
            }
            else
            {
                hr = CO_E_NOTINITIALIZED;
            }
        }
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_POLICYSET, "CoGetObjectContext pv:%x hr:0x%x\n", *ppv, hr));
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dcomrem\context.cxx ===
//+----------------------------------------------------------------------------
//
//  File:       context.cxx
//
//  Contents:   Implementation of COM contexts.
//
//  Classes:    CObjectContext
//              CEnumContextProps
//              CContextPropList
//              CObjectContextFac
//
//  History:    19-Dec-97   Johnstra      Created
//              12-Nov-98   TarunA        Caching of contexts
//
//-----------------------------------------------------------------------------
#include <ole2int.h>
#include <locks.hxx>
#include <hash.hxx>
#include <pstable.hxx>
#include <context.hxx>
#include <aprtmnt.hxx>
#include <actvator.hxx>
#include <crossctx.hxx>

extern DWORD g_cMTAInits;
extern DWORD g_cSTAInits;

ULARGE_INTEGER gNextContextId = { 0 };

//-----------------------------------------------------------------------------
// Static Member Declarations
//-----------------------------------------------------------------------------
// CObjectContext:
CPageAllocator   CObjectContext::s_CXAllocator;         // Object context allocator
BOOL             CObjectContext::s_fInitialized;        // Indicates if initialized
ULONG            CObjectContext::s_cInstances;          // Count of instances

// CContextPropList:
CPageAllocator   CContextPropList::s_NodeAllocator; // List node allocator

// CCtxTable
BOOL                CCtxTable::s_fInitialized;             // Set when the table is initialized
CCtxPropHashTable   CCtxTable::s_CtxPropHashTable;         // Hash table of contexts based on properties
CCtxUUIDHashTable   CCtxTable::s_CtxUUIDHashTable;         // Hash table of contexts based on UUID

SHashChain CCtxTable::s_CtxPropBuckets[NUM_HASH_BUCKETS] = {    // Hash buckets for the property based table
    {&s_CtxPropBuckets[0],  &s_CtxPropBuckets[0]},
    {&s_CtxPropBuckets[1],  &s_CtxPropBuckets[1]},
    {&s_CtxPropBuckets[2],  &s_CtxPropBuckets[2]},
    {&s_CtxPropBuckets[3],  &s_CtxPropBuckets[3]},
    {&s_CtxPropBuckets[4],  &s_CtxPropBuckets[4]},
    {&s_CtxPropBuckets[5],  &s_CtxPropBuckets[5]},
    {&s_CtxPropBuckets[6],  &s_CtxPropBuckets[6]},
    {&s_CtxPropBuckets[7],  &s_CtxPropBuckets[7]},
    {&s_CtxPropBuckets[8],  &s_CtxPropBuckets[8]},
    {&s_CtxPropBuckets[9],  &s_CtxPropBuckets[9]},
    {&s_CtxPropBuckets[10], &s_CtxPropBuckets[10]},
    {&s_CtxPropBuckets[11], &s_CtxPropBuckets[11]},
    {&s_CtxPropBuckets[12], &s_CtxPropBuckets[12]},
    {&s_CtxPropBuckets[13], &s_CtxPropBuckets[13]},
    {&s_CtxPropBuckets[14], &s_CtxPropBuckets[14]},
    {&s_CtxPropBuckets[15], &s_CtxPropBuckets[15]},
    {&s_CtxPropBuckets[16], &s_CtxPropBuckets[16]},
    {&s_CtxPropBuckets[17], &s_CtxPropBuckets[17]},
    {&s_CtxPropBuckets[18], &s_CtxPropBuckets[18]},
    {&s_CtxPropBuckets[19], &s_CtxPropBuckets[19]},
    {&s_CtxPropBuckets[20], &s_CtxPropBuckets[20]},
    {&s_CtxPropBuckets[21], &s_CtxPropBuckets[21]},
    {&s_CtxPropBuckets[22], &s_CtxPropBuckets[22]}
};

SHashChain CCtxTable::s_CtxUUIDBuckets[NUM_HASH_BUCKETS] = { // Hash buckets for the UUID based table
    {&s_CtxUUIDBuckets[0],  &s_CtxUUIDBuckets[0]},
    {&s_CtxUUIDBuckets[1],  &s_CtxUUIDBuckets[1]},
    {&s_CtxUUIDBuckets[2],  &s_CtxUUIDBuckets[2]},
    {&s_CtxUUIDBuckets[3],  &s_CtxUUIDBuckets[3]},
    {&s_CtxUUIDBuckets[4],  &s_CtxUUIDBuckets[4]},
    {&s_CtxUUIDBuckets[5],  &s_CtxUUIDBuckets[5]},
    {&s_CtxUUIDBuckets[6],  &s_CtxUUIDBuckets[6]},
    {&s_CtxUUIDBuckets[7],  &s_CtxUUIDBuckets[7]},
    {&s_CtxUUIDBuckets[8],  &s_CtxUUIDBuckets[8]},
    {&s_CtxUUIDBuckets[9],  &s_CtxUUIDBuckets[9]},
    {&s_CtxUUIDBuckets[10], &s_CtxUUIDBuckets[10]},
    {&s_CtxUUIDBuckets[11], &s_CtxUUIDBuckets[11]},
    {&s_CtxUUIDBuckets[12], &s_CtxUUIDBuckets[12]},
    {&s_CtxUUIDBuckets[13], &s_CtxUUIDBuckets[13]},
    {&s_CtxUUIDBuckets[14], &s_CtxUUIDBuckets[14]},
    {&s_CtxUUIDBuckets[15], &s_CtxUUIDBuckets[15]},
    {&s_CtxUUIDBuckets[16], &s_CtxUUIDBuckets[16]},
    {&s_CtxUUIDBuckets[17], &s_CtxUUIDBuckets[17]},
    {&s_CtxUUIDBuckets[18], &s_CtxUUIDBuckets[18]},
    {&s_CtxUUIDBuckets[19], &s_CtxUUIDBuckets[19]},
    {&s_CtxUUIDBuckets[20], &s_CtxUUIDBuckets[20]},
    {&s_CtxUUIDBuckets[21], &s_CtxUUIDBuckets[21]},
    {&s_CtxUUIDBuckets[22], &s_CtxUUIDBuckets[22]}
};


//-----------------------------------------------------------------------------
// Globals
//-----------------------------------------------------------------------------
#if DBG == 1

DWORD g_cCtxTableLookupSucceeded;           // Number of lookups that succeeded
DWORD g_cCtxTableLookup;                    // Total number of lookups
DWORD g_cCtxTableAdd;                       // Number of Context table additions
DWORD g_cCtxTableRemove;                    // Number of Context table removes
#endif
COleStaticMutexSem gContextLock(TRUE);    // critical section for contexts

//----------------------------------------------------------------------------
// Finalizer bypass regkey check
//----------------------------------------------------------------------------

static DWORD g_dwFinBypassStatus = -1;
static DWORD g_dwGipBypassStatus = -1;

static DWORD GetRegSetting(LPCWSTR pwszValue, DWORD dwDefault, DWORD* pdwOutput)
{
    DWORD dwNewValue = dwDefault;
    HKEY hk;
    LONG lRes;

    lRes = RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\COM3",
        0, KEY_READ, &hk);

    if(lRes == ERROR_SUCCESS)
    {
        DWORD dwType, dwValue;
        DWORD cbValue = sizeof(DWORD);

        lRes = RegQueryValueEx(hk, pwszValue, NULL,
            &dwType, (LPBYTE) &dwValue, &cbValue);

        if(lRes == ERROR_SUCCESS && dwType == REG_DWORD)
            dwNewValue = dwValue;

        RegCloseKey(hk);
    }

    InterlockedCompareExchange(
        (LPLONG) pdwOutput, (LONG) dwNewValue, (LONG) -1);

    return *pdwOutput;
}

BOOL FinalizerBypassEnabled()  // for Finalizers
{
    if(g_dwFinBypassStatus != -1)
        return !!g_dwFinBypassStatus;
    else
        return !!GetRegSetting(L"FinalizerActivityBypass", TRUE, &g_dwFinBypassStatus);
}

BOOL GipBypassEnabled()        // for GIP
{
    if(g_dwGipBypassStatus != -1)
        return !!g_dwGipBypassStatus;
    else
        return !!GetRegSetting(L"GipActivityBypass", FALSE, &g_dwGipBypassStatus);
}

//----------------------------------------------------------------------------
// CEnumContextProps Implementation.
//----------------------------------------------------------------------------

//+--------------------------------------------------------------------------
//
//  Member:     CEnumContextProps::QueryInterface , public
//
//  Synopsis:   Standard IUnknown::QueryInterface implementation.
//
//  History:    19-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP CEnumContextProps::QueryInterface(
    REFIID riid,
    void** ppv
    )
{
    if (IID_IUnknown == riid || IID_IEnumContextProps == riid)
    {
        *ppv = (IEnumContextProps *)this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown*)*ppv)->AddRef();
    return S_OK;
}


//+--------------------------------------------------------------------------
//
//  Member:     CEnumContextProps::AddRef , public
//
//  Synopsis:   Standard IUnknown::AddRef implementation.
//
//  History:    19-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CEnumContextProps::AddRef()
{
    return InterlockedIncrement(&_cRefs);
}


//+--------------------------------------------------------------------------
//
//  Member:     CEnumContextProps::Release , public
//
//  Synopsis:   Standard IUnknown::Release implementation.
//
//  History:    19-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CEnumContextProps::Release()
{
    LONG lRef = InterlockedDecrement(&_cRefs);
    if (lRef == 0)
    {
        delete this;
    }
    return lRef;
}


//+--------------------------------------------------------------------------
//
//  Member:     CEnumContextProps::Next , public
//
//  Synopsis:   Returns the next ContextProp on a ComContext.
//
//  Returns:    S_OK         - if the number of items requested is returned
//              E_INVALIDARG - if the arguments are not valid
//              S_FALSE      - if the number of items requested could not be
//                             provided
//
//  History:    19-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP CEnumContextProps::Next(
    ULONG            celt,
    ContextProperty* pCtxProps,
    ULONG*           pceltFetched
    )
{
    ComDebOut((DEB_OBJECTCONTEXT, "CEnumContextProps::Next celt: %d\n", celt));
    ASSERT_LOCK_NOT_HELD(gContextLock);
    Win4Assert(pCtxProps != NULL);

    //
    // The spec says that if pceltFetched is NULL, then celt must be one.
    // Enforce that here.
    //

    if (pceltFetched == NULL)
    {
        if (celt != 1)
            return E_INVALIDARG;
    }
    else
    {
        *pceltFetched = 0;
    }

    //
    // Allocate an array of IUnknown*s on the stack so we can AddRef all the
    // properties we supply to the caller outside while not holding the
    // lock.
    //

    IUnknown** PunkArr = (IUnknown**) _alloca(sizeof(IUnknown*) * celt);

    //
    // Copy as many of the requested items as possible from the list into the
    // caller supplied array.
    //

    ULONG ItemsCopied = 0;
    ULONG idx = 0;
    LOCK(gContextLock);
    if (_CurrentPosition < _cItems)
    {
        ContextProperty* pDstProp = pCtxProps + ItemsCopied;
        ContextProperty* pSrcProp = &_pList[_CurrentPosition];
        while ((ItemsCopied < celt) && (_CurrentPosition++ < _cItems))
        {
            PunkArr[idx++] = pSrcProp->pUnk;
            CopyMemory(pDstProp++, pSrcProp++, sizeof(ContextProperty));
            ItemsCopied++;
        }
    }
    UNLOCK(gContextLock);

    //
    // Now AddRef all the properties we are returning.
    //

    for (ULONG i = 0; i < ItemsCopied; i++)
        PunkArr[i]->AddRef();

    //
    // Indicate the number of objects we are returning.
    //

    if (pceltFetched != NULL)
        *pceltFetched = ItemsCopied;

    ASSERT_LOCK_NOT_HELD(gContextLock);
    ComDebOut((DEB_OBJECTCONTEXT,
        "CEnumContextProps::Next returning hr:%08X pceltFetched:%d\n",
        (ItemsCopied == celt) ? S_OK : S_FALSE, ItemsCopied));
    return (ItemsCopied == celt) ? S_OK : S_FALSE;
}


//+--------------------------------------------------------------------------
//
//  Member:     CEnumContextProps::Skip , public
//
//  Synopsis:   Skips over the current ContextProp on a ComContext.
//
//  Returns:    S_OK    - if the number of items specified is skipped
//              S_FALSE - otherwise
//
//  History:    19-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP CEnumContextProps::Skip(
    ULONG celt
    )
{
    ComDebOut((DEB_OBJECTCONTEXT, "CEnumContextProps::Skip\n"));
    ASSERT_LOCK_NOT_HELD(gContextLock);

    HRESULT hr = S_OK;
    LOCK(gContextLock);
    _CurrentPosition += celt;
    if (_CurrentPosition > _cItems)
    {
        _CurrentPosition = _cItems;
        hr = S_FALSE;
    }
    UNLOCK(gContextLock);

    ASSERT_LOCK_NOT_HELD(gContextLock);
    ComDebOut((DEB_OBJECTCONTEXT,
               "CEnumContextProps::Skip returning hr:%08X\n", hr));
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Member:     CEnumContextProps::Reset , public
//
//  Synopsis:   Resets the ComContext enumerator to the beginning of the
//              collection of properties.
//
//  History:    19-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP CEnumContextProps::Reset()
{
    ComDebOut((DEB_OBJECTCONTEXT, "CEnumContextProps::Reset\n"));
    ASSERT_LOCK_NOT_HELD(gContextLock);

    LOCK(gContextLock);
    _CurrentPosition = 0;
    UNLOCK(gContextLock);

    ASSERT_LOCK_NOT_HELD(gContextLock);
    return S_OK;
}


//+--------------------------------------------------------------------------
//
//  Member:     CEnumContextProps::Clone , public
//
//  Synopsis:   Returns a pointer to a clone of this context property
//              enumerator.
//
//  History:    19-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP CEnumContextProps::Clone(
    IEnumContextProps** ppEnumCtxProps
    )
{
    ComDebOut((DEB_OBJECTCONTEXT, "CEnumContextProps::Clone\n"));
    ASSERT_LOCK_NOT_HELD(gContextLock);

    LOCK(gContextLock);
    *ppEnumCtxProps = new CEnumContextProps(this);
    UNLOCK(gContextLock);

    ASSERT_LOCK_NOT_HELD(gContextLock);
    ComDebOut((DEB_OBJECTCONTEXT,
        "CEnumContextProps::Clone returning hr:%08X\n",
        (*ppEnumCtxProps != NULL) ? S_OK : E_OUTOFMEMORY));
    return (*ppEnumCtxProps != NULL) ? S_OK : E_OUTOFMEMORY;
}


//+--------------------------------------------------------------------------
//
//  Member:     CEnumContextProps::GetCount , public
//
//  Synopsis:   Returns the number of items in the collection being
//              enumerated.
//
//  History:    19-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP CEnumContextProps::Count(
    PULONG pulCount
    )
{
    ComDebOut((DEB_OBJECTCONTEXT, "CEnumContextProps::Count\n"));
    ASSERT_LOCK_NOT_HELD(gContextLock);
    *pulCount = _cItems;
    return S_OK;
}




//////////////////////////////////////////////////////////////////////////////
//
// CContextPropList Implementation.
//
//////////////////////////////////////////////////////////////////////////////

//+--------------------------------------------------------------------------
//
//  Member:     CContextPropList::CreateCompareBuffer , public
//
//  Synopsis:   Creates a comparison buffer which is used to determine if
//              two contexts are equal.  The buffer contains all of the
//              ContextProperty objects added to this context which are
//              not explicitly marked as DONTCOMPARE.
//
//              This is also where we compute the hash value for this context.
//              Again, only those properties not explicitly marked DONTCOMPARE
//              are included in the calculation.
//
//  History:    29-Nov-98   Johnstra      Created.
//
//----------------------------------------------------------------------------
BOOL CContextPropList::CreateCompareBuffer(void)
{
    if (0 == _cCompareProps)
        return TRUE;

    // Allocate enough space for the buffer.

    _pCompareBuffer = new ContextProperty[_cCompareProps];
    if (!_pCompareBuffer)
        return FALSE;

    // Walk through all the properties, and add those not explicitly marked
    // DONTCOMPARE to the comparison buffer.  Also use those properties
    // not marked DONTCOMPARE to compute the context's hash value.

    ContextProperty *buf = _pCompareBuffer;
    int i = _iFirst;
    do
    {
        if (!(_pProps[_pIndex[i].idx].flags & CPFLAG_DONTCOMPARE))
        {
            // Include this property in the context's hash value.
            _Hash += HashPtr(_pProps[_pIndex[i].idx].pUnk);

            // Add the property to the comparison buffer.
            *buf++ = _pProps[_pIndex[i].idx];
        }

        // Advance to the next property.
        i = _pIndex[i].next;
    } while(i != _iFirst);

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Member:     CContextPropList::Initialize , public
//
//  Synopsis:   Initializes the property list.
//
//  History:    19-Dec-97   Johnstra      Created.
//
//-----------------------------------------------------------------------------
void CContextPropList::Initialize()
{
    ComDebOut((DEB_OBJECTCONTEXT, "CContextPropList::Initialize\n"));
    ASSERT_LOCK_HELD(gContextLock);

    // caller guarantees mutual exclusion to the allocator
    s_NodeAllocator.Initialize(sizeof(ContextProperty), CP_PER_PAGE, NULL);
}


//+----------------------------------------------------------------------------
//
//  Member:     CContextPropList::Initialize , public
//
//  Synopsis:   Cleans up the property list.
//
//  History:    19-Dec-97   Johnstra      Created.
//
//-----------------------------------------------------------------------------
void CContextPropList::Cleanup()
{
    ComDebOut((DEB_OBJECTCONTEXT, "CContextPropList::Cleanup\n"));
    ASSERT_LOCK_HELD(gContextLock);

    s_NodeAllocator.Cleanup();

    ASSERT_LOCK_HELD(gContextLock);
}


//+----------------------------------------------------------------------------
//
//  Member:     CContextPropList::Initialize , private
//
//  Synopsis:   Grows the internal array of ContextProperties when more space
//              is needed.
//
//  History:    30-Nov-98   Johnstra      Created.
//
//-----------------------------------------------------------------------------
BOOL CContextPropList::Grow()
{
    // Allocate a single chunk of memory.

    int cElements = _Max ? (_Max * 2) : CTX_PROPS;
    ULONG cBytes = sizeof(ContextProperty) * cElements +
                   sizeof(SCtxListIndex) * cElements +
                   sizeof(int) * cElements;
    PUCHAR chunk = new UCHAR[cBytes];
    if (!chunk)
        return FALSE;

    // Carve the chunk into the data structures we need.

    ContextProperty *pNewProps = (ContextProperty *) chunk;
    SCtxListIndex   *pNewIndex = (SCtxListIndex *) (pNewProps + cElements);
    int             *pNewSlots = (int *) (pNewIndex + cElements);

    // Initialize the new slot array and the new index array.

    int i;
    for(i = 0; i < _Max; i++)
    {
       pNewIndex[i].idx  = _pIndex[i].idx;
       pNewIndex[i].next = _pIndex[i].next;
       pNewIndex[i].prev = _pIndex[i].prev;
       pNewSlots[i] = _pSlots[i];
    }
    for (i = _Max; i < cElements; i++)
    {
        pNewIndex[i].idx  = i;
        pNewIndex[i].next = i+1;
        pNewIndex[i].prev = i-1;
        pNewSlots[i] = i;
    }
    pNewIndex[0].prev = _Count - 1;
    pNewIndex[_Count-1].next = 0;

    // Update the max number of elements.

    _Max = cElements;

    // If there are properties, copy them old array into the new array and
    // delete the existing chunk of memory.

    if (_Count)
    {
        ContextProperty *pCurProp = pNewProps;
        int i = _iFirst;
        do
        {
            *pCurProp++ = _pProps[_pIndex[i].idx];
            i = _pIndex[i].next;
        } while(i != _iFirst);

        _iFirst  = 0;
        _iLast   = _Count - 1;
        _slotIdx = _Count;

        PUCHAR oldChunk = _chunk;
        delete [] oldChunk;
    }

    // Update member variables.

    _pProps = pNewProps;
    _pIndex = pNewIndex;
    _pSlots = pNewSlots;
    _chunk  = chunk;

    return TRUE;
}

//+--------------------------------------------------------------------------
//
//  Member:     CContextPropList::Add , public
//
//  Synopsis:   Add the property represented by the supplied tuple to the
//              the list.  The supplied pUnk has been AddRef'd by the caller.
//
//  Returns:    TRUE      - if property is added successfully
//              FALSE     - if resources are unavailable
//
//  History:    22-Dec-97   Johnstra      Created.
//              24-Nov-98   JohnStra      Rewrote using flat array
//
//----------------------------------------------------------------------------
BOOL CContextPropList::Add(
    REFGUID   rGUID,
    CPFLAGS   flags,
    IUnknown* pUnk
    )
{
    ComDebOut((DEB_OBJECTCONTEXT,
               "CContextPropList::Add rGUID:%I flags:%08X pUnk:%p\n",
               &rGUID, flags, pUnk));

    ASSERT_LOCK_NOT_HELD(gContextLock);
    LOCK(gContextLock);
    //
    // Don't add a property if it is already in the list.
    //
    ContextProperty* pcp = Get(rGUID);
    if (pcp != NULL)
    {
       UNLOCK(gContextLock);
       return FALSE;
    }

    // Grow our internal data structures if necessary.

    if (_Count >= _Max)
        if (!Grow())
	{
	   UNLOCK(gContextLock);
	   return FALSE;
	}

    // Get the next available slot..

    int slot = PopSlot();

    if (0 == _Count)
    {
        // The list is empty so we have to initialize our first and
        // last pointers.

        _iFirst = slot;
        _iLast = slot;
    }

    // Link in the slot.

    _pIndex[_iFirst].prev = slot;
    _pIndex[_iLast].next  = slot;
    _pIndex[slot].next = _iFirst;
    _pIndex[slot].prev = _iLast;
    _iLast = slot;

    // Fill in the information in the appropriate slot.
    // Note: we need to memset the structure to zero,
    // because on 64 bit platforms there is padding that
    // can cause CContextPropList::operator== to fail
    ContextProperty* pcpProp = _pProps + _pIndex[slot].idx;
    
    memset (pcpProp, 0, sizeof (ContextProperty));
    pcpProp->policyId = rGUID;
    pcpProp->flags    = flags;
    pcpProp->pUnk     = pUnk;

    // Increment the number of properties in the list.

    _Count++;
    if (!(flags & CPFLAG_DONTCOMPARE))
        _cCompareProps++;

    UNLOCK(gContextLock);
    ASSERT_LOCK_NOT_HELD(gContextLock);

    return TRUE;
}


//+--------------------------------------------------------------------------
//
//  Member:     CContextPropList::Remove , public
//
//  Synopsis:   Remove the specified item from the list.
//
//  History:    22-Dec-97   Johnstra      Created.
//              24-Nov-98   JohnStra      Rewritten to use flat array
//
//----------------------------------------------------------------------------
void CContextPropList::Remove(
    REFGUID rGuid
    )
{
    ComDebOut((DEB_OBJECTCONTEXT, "CContextPropList::Remove\n"));
    ASSERT_LOCK_HELD(gContextLock);

    if (0 == _Count)
        return;

    // Scan the list for the specified property.

    BOOL fFound = FALSE;
    int i = _iFirst;
    do
    {
        if (IsEqualGUID(rGuid, _pProps[_pIndex[i].idx].policyId))
        {
            fFound = TRUE;
            break;
        }

        i = _pIndex[i].next;
    } while(i != _iFirst);

    // If we found the specified property, unlink it from the list, push the
    // slot on the available stack, and decrement the count by one.

    if (fFound)
    {
        if (i == _iFirst)
            _iFirst = _pIndex[i].next;

        if (i == _iLast)
            _iLast = _pIndex[i].prev;

        _pIndex[_pIndex[i].next].prev = _pIndex[i].prev;
        _pIndex[_pIndex[i].prev].next = _pIndex[i].next;

        PushSlot(i);

        _Count--;
        if (!(_pProps[_pIndex[i].idx].flags & CPFLAG_DONTCOMPARE))
            _cCompareProps--;
    }
}


//+--------------------------------------------------------------------------
//
//  Member:     CContextPropList::Get , public
//
//  Synopsis:   Get the specified item from the list.
//
//  Returns:    S_OK   - If the specified item is found.
//              E_FAIL - If the item cannot be found.
//
//  History:    22-Dec-97   Johnstra      Created.
//              24-Nov-98   JohnStra      Rewritten to use flat array
//
//----------------------------------------------------------------------------
ContextProperty* CContextPropList::Get(
    REFGUID    rGUID
    )
{
    ComDebOut((DEB_OBJECTCONTEXT,
               "CContextPropList::Get rGUID:%I\n", &rGUID));

    if (0 == _Count)
        return NULL;

    // Scan the list for the specified property.

    ContextProperty *pcp = NULL;
    int i = _iFirst;
    do
    {
        if (IsEqualGUID(rGUID, _pProps[_pIndex[i].idx].policyId))
            pcp = &_pProps[_pIndex[i].idx];

        i = _pIndex[i].next;
    } while(!pcp && i != _iFirst);

    ComDebOut((DEB_OBJECTCONTEXT,
        "CContextPropList::Get returning pcp:%p\n", pcp));
    return pcp;
}




//////////////////////////////////////////////////////////////////////////////
//
// CObjectContext Implementation.
//
//////////////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------
//
//  Method:     CObjectContext::CreatePrototypeContext     public
//
//  Synopsis:   Returns a new context which contains all of the same
//              properties in the current context which are marked
//              CPFLAG_PROPAGATE.
//
// History:     11 Nov 1998  Johnstra    Created
//
//+-------------------------------------------------------------------
HRESULT CObjectContext::CreatePrototypeContext(
    CObjectContext  *pClientContext,
    CObjectContext **pProto
    )
{
    ASSERT_LOCK_NOT_HELD(gContextLock);
    Win4Assert(pClientContext);
    Win4Assert(pProto);

    // The client context must be fozen.

    if (!pClientContext->IsFrozen())
    {
        *pProto = NULL;
        return E_INVALIDARG;
    }

    // Initialize hr to S_OK; and the context we will return to NULL.  If
    // client context has no properties, we don't have to do anything.

    HRESULT hr = S_OK;
    CObjectContext *pContext = NULL;

    // Get the number of properties.

    ULONG cPropsAdded = 0;
    ULONG cProps = pClientContext->GetCount();
    if (cProps)
    {
        // Create a new object context.

        hr = E_OUTOFMEMORY;
        pContext = CreateObjectContext(NULL, 0);
        if (pContext)
        {
            // Get an enumerator for the properties of the client context.

            IEnumContextProps *pEnum = NULL;
            hr = pClientContext->EnumContextProps(&pEnum);
            if (SUCCEEDED(hr))
            {
                // Allocate space for an array of properties on the stack.

                ContextProperty *pProps =
                    (ContextProperty*) _alloca(sizeof(ContextProperty) * cProps);
                if (pProps)
                {
                    // Get all the properties at once from the enumerator.

                    ULONG cReturned;
                    hr = pEnum->Next(cProps, pProps, &cReturned);
                    if (S_OK == hr)
                    {
                        // Add all the properties that are marked
                        // CPFLAG_PROPAGATE to the prototype.

                        while (cProps)
                        {
                            if (pProps->flags & CPFLAG_PROPAGATE)
                            {
                                hr = pContext->SetProperty(pProps->policyId,
                                                           pProps->flags,
                                                           pProps->pUnk);
                                if (FAILED(hr))
                                {
                                    if(pProps->pUnk)
                                    {
                                        pProps->pUnk->Release();
                                    }
                                    break;
                                }
                                ++cPropsAdded;
                            }
                            pProps->pUnk->Release();
                            --cProps;
                            ++pProps;
                        }
                    }
                }

                // Done with the enumerator.  Release it.

                pEnum->Release();
            }

            // If we didn't make it through all of the properties because of an
            // error, or if there were no PROPAGATE properties, release and
            // NULL the prototype.

            if (cProps || !cPropsAdded)
            {
                pContext->InternalRelease();
                pContext = NULL;
            }
        }
    }

    // Give the caller the context.

    *pProto = pContext;

    ASSERT_LOCK_NOT_HELD(gContextLock);
    return hr;
}


//+-------------------------------------------------------------------
//
//   Method:   CObjectContext::CreateUniqueID     static
//
// synopsis:   Creates a unique identifier for an object context.
//
//  History:   24-Nov-98  Johnstra    Created
//
//+-------------------------------------------------------------------
HRESULT CObjectContext::CreateUniqueID(
    ContextID& CtxID)
{
    return CoCreateGuid(&CtxID);
}


CObjectContext* CObjectContext::CreateObjectContext(
    DATAELEMENT *pDE,
    DWORD        dwFlags
    )
{
    ASSERT_LOCK_NOT_HELD(gContextLock);

    CObjectContext *pContext    = NULL;
    CObjectContext *pRelCtx     = NULL;
    GUID            contextId   = GUID_NULL;
    BOOL            fAddToTable = TRUE;

    LOCK(gContextLock);

    if (pDE == NULL)
    {
        fAddToTable = ((dwFlags & CONTEXTFLAGS_STATICCONTEXT) == 0);
        if (SUCCEEDED(CoCreateGuid(&contextId)))
        {
            pContext = new CObjectContext(dwFlags, contextId, NULL);
        }
    }
    else
    {
        // We have been supplied with a DATAELEMENT which contains a marshaled
        // envoy context.  This means we are to either lookup an existing or
        // create a new envoy.

        // First, try to lookup the specified context.  If we find it in this
        // process, we can AddRef it and return it.

        contextId = pDE->dataID;
        pContext = CCtxTable::LookupExistingContext(contextId);

        if (pContext == NULL)
        {
            pContext = new CObjectContext(dwFlags, GUID_NULL, pDE);

            // The above ctor releases the lock in the SetEnvoyData call,
            // thus we need to lookup the context in the table again
            // before adding it, since another thread could have added it
            // in the meantime.

            ASSERT_LOCK_HELD(gContextLock);

            CObjectContext *pCtx = CCtxTable::LookupExistingContext(contextId);
            if (pCtx == NULL)
            {
                if (pContext != NULL)
                {
                    pContext->SetContextId(contextId);
                }
            }
            else
            {
                fAddToTable = FALSE;
                if (pContext != NULL)
                {
                    pRelCtx = pContext;
                }
                pCtx->InternalAddRef();
                pContext = pCtx;
            }
        }
        else
        {
            fAddToTable = FALSE;
            pContext->InternalAddRef();
            PrivMemFree(((DWORD *) pDE)-1);
        }
    }

    // New contexts are always added to the table with the exception of the
    // static unmarshaler context object.

    if (pContext && fAddToTable)
    {
        Win4Assert(NULL == pContext->GetUUIDHashChain()->pPrev &&
                   NULL == pContext->GetUUIDHashChain()->pNext);
        CCtxTable::s_CtxUUIDHashTable.Add(pContext);
    }

    UNLOCK(gContextLock);

    if (pRelCtx)
    {
        // Another thread unmarshaled the same envoy we unmarshaled and added
        // it to the table before we could.  We looked up the one the other
        // thread unmarshaled, so we don't need this one.  We can release it.

        pRelCtx->InternalRelease();
    }

    ASSERT_LOCK_NOT_HELD(gContextLock);
    return pContext;
}


void CleanupCtxTableEntry(SHashChain* pNode)
{
    Win4Assert("!CleanupCtxEntry got called \n");
}


CObjectContext::CObjectContext(
    DWORD        dwFlags,
    REFGUID      contextId,
    DATAELEMENT *pDE
    )
{
    ComDebOut((DEB_OBJECTCONTEXT, "CObjectContext::CObjectContext this:%x\n",this));

    // Initialize the appropriate ref count to 1
    _cRefs   = 1;
    _cInternalRefs  = 1;
    _cUserRefs      = 0;

    _dwFlags        = dwFlags;
    _pifData        = (pDE) ? (InterfaceData *) (((PCHAR) pDE) - sizeof(DWORD)) : NULL;
    _MarshalSizeMax = (pDE) ? pDE->cbSize + sizeof(DATAELEMENT) - sizeof(BYTE) : NULL;
    if(_pifData)
        _pifData->ulCntData = _MarshalSizeMax;
    _pMarshalProp   = NULL;
    _pApartment     = NULL;
    CPolicySet::InitPSCache(&_PSCache);
    _contextId      = contextId;
    ULARGE_INTEGER NewId;
    GetNextContextId(NewId);
    _urtCtxId       = NewId.QuadPart;
    _dwHashOfId     = HashGuid(_contextId);
    _cReleaseThreads = 0;
    _pMtsContext    = NULL;
    _pContextLife   = NULL;

#if DBG==1
    _ValidMarker     = VALID_MARK;
    _propChain.pNext = NULL;
    _propChain.pPrev = NULL;
    _uuidChain.pNext = NULL;
    _uuidChain.pPrev = NULL;
#endif

    if (pDE)
    {
        Win4Assert(GUID_NULL != pDE->dataID);
        SetEnvoyData(pDE);
    }
}


CObjectContext::~CObjectContext()
{
    ComDebOut((DEB_OBJECTCONTEXT, "CObjectContext::~CObjectContext this:%x\n",this));
#if DBG==1
    _ValidMarker = 0;
    _contextId = GUID_NULL;
    _uuidChain.pPrev = NULL;
    _uuidChain.pNext = NULL;
#endif

    // Remove ourselves from the context map.
    ASSERT_LOCK_NOT_HELD(gContextLock);
    Win4Assert(_cRefs & CINDESTRUCTOR);

    _dwFlags &= ~CONTEXTFLAGS_STATICCONTEXT;

    // If _pifData points to an InterfaceData object, we own it, so
    // we need to delete it.
    if (_pifData != NULL)
        PrivMemFree(_pifData);

    // Release the reference to our apartment object.
    if (_pApartment)
        _pApartment->Release();

    // Release our reference to the special marshaling property if
    // we hold one.
    if (_pMarshalProp)
        ((IUnknown*)_pMarshalProp)->Release();

    if (_pMtsContext)
    {
        _pMtsContext->Release();
        _pMtsContext = NULL;
    }

    if (_pContextLife)
    {
        _pContextLife->SetDead();
        _pContextLife->Release();
        _pContextLife = NULL;
    }

    CPolicySet::DestroyPSCache(this);
}


//+-------------------------------------------------------------------
//
//  Method:     CObjectContext::operator new     public
//
//  Synopsis:   new operator of object context
//
// History:     22 Dec 1997  Johnstra    Created
//
//+-------------------------------------------------------------------
void* CObjectContext::operator new(
    size_t size
    )
{
    ComDebOut((DEB_OBJECTCONTEXT,
        "CObjectContext::operator new s_cInstances:%d\n", s_cInstances));
    ASSERT_LOCK_HELD(gContextLock);

    //
    // CObjectContext can be inherited only by those objects with overloaded
    // new and delete operators.
    //

    Win4Assert((size == sizeof(CObjectContext))
                && "CObjectContext improperly inherited");

    //
    // Make sure allocators are initialized.
    //

    if (s_fInitialized == FALSE)
        Initialize();

    //
    // Allocate memory for the object and increment the instance count.
    //

    void* pv = (void*) s_CXAllocator.AllocEntry();
    if (pv != NULL)
        s_cInstances++;

    ASSERT_LOCK_HELD(gContextLock);
    ComDebOut((DEB_OBJECTCONTEXT,
        "CObjectContext::operator new returning pv: %08X\n", pv));
    return pv;
}


//+-------------------------------------------------------------------
//
//  Method:     CObjectContext::operator delete     public
//
//  Synopsis:   delete operator of object context
//
//  History:    22 Dec 1997   Johnstra    Created
//
//+-------------------------------------------------------------------
void CObjectContext::operator delete(
    void *pv
    )
{
    ComDebOut((DEB_OBJECTCONTEXT,
        "CObjectContext::operator delete s_cInstances: %d\n", s_cInstances));

    ASSERT_LOCK_NOT_HELD(gContextLock);
    LOCK(gContextLock);

#if DBG==1
    //
    // Ensure that pv was allocated by the our allocator.
    //

    LONG index = s_CXAllocator.GetEntryIndex((PageEntry *) pv);
    Win4Assert(index != -1 && "pv not allocated by CObjectContext allocator");
#endif

    //
    // Release the pointer
    //

    s_CXAllocator.ReleaseEntry((PageEntry *) pv);
    --s_cInstances;

    //
    // If allocators are initialized and the instance count touches
    // zero, clean up the allocators.
    //

    if (s_fInitialized == FALSE && s_cInstances == 0)
    {
        // Cleanup allocators
        s_CXAllocator.Cleanup();
        CContextPropList::Cleanup();

        // cleanup the context table
        CCtxTable::Cleanup();
    }

    UNLOCK(gContextLock);
    ASSERT_LOCK_NOT_HELD(gContextLock);

    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CObjectContext::Initialize     public
//
//  Synopsis:   Initializes allocators for policy sets
//
//  History:    22 Dec 1997   Johnstra   Created
//
//+-------------------------------------------------------------------
void CObjectContext::Initialize()
{
    ComDebOut((DEB_OBJECTCONTEXT, "CObjectContext::Initialize\n"));
    ASSERT_LOCK_HELD(gContextLock);

    Win4Assert(!s_fInitialized && "CObjectContext already initialized");

    //
    // Initialze the allocators.
    //
    if (s_cInstances == 0)
    {
        // Initialize allocators
        // caller guarantees mutual exclusion
        s_CXAllocator.Initialize(sizeof(CObjectContext), CX_PER_PAGE, NULL);
        CContextPropList::Initialize();

        // Initialize the context table.
        CCtxTable::Initialize();
    }

    //
    // Mark the state as initialized.
    //
    s_fInitialized = TRUE;

    ASSERT_LOCK_HELD(gContextLock);
    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CObjectContext::Cleanup     public
//
//  Synopsis:   Cleanup allocators of contexts and context objects.
//
//  History:    22 Dec 1997   Johnstra    Created
//
//+-------------------------------------------------------------------
void CObjectContext::Cleanup()
{
    ComDebOut((DEB_OBJECTCONTEXT, "CObjectContext::Cleanup\n"));
    ASSERT_LOCK_NOT_HELD(gContextLock);
    LOCK(gContextLock);

    //
    // Cleanup allocators.
    //

    if (s_fInitialized == TRUE)
    {
        if (s_cInstances == 0)
        {
            // Cleanup allocators
            s_CXAllocator.Cleanup();
            CContextPropList::Cleanup();

            // Clean up the context table.
            CCtxTable::Cleanup();
        }

        //
        // Reset state.
        //

        s_fInitialized = FALSE;
    }

    UNLOCK(gContextLock);
    ASSERT_LOCK_NOT_HELD(gContextLock);
    return;
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::QueryInterface , public
//
//  Synopsis:   Standard IUnknown::QueryInterface implementation.
//
//  History:    19-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjectContext::QueryInterface(
    REFIID riid,
    void** ppv
    )
{
    return QIHelper(riid, ppv, FALSE);
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::AddRef , public
//
//  Synopsis:   Standard IUnknown::AddRef implementation.
//
//  History:    19-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CObjectContext::AddRef()
{
    InterlockedIncrement((LONG*)&_cRefs);
    return InterlockedIncrement(&_cUserRefs);
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::Release , public
//
//  Synopsis:   Standard IUnknown::Release implementation.
//
//  History:    19-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CObjectContext::Release()
{
    ULONG cRefs = InterlockedDecrement(&_cUserRefs);
    CommonRelease();
    return cRefs;
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::InternalQueryInterface , public
//
//  History:    16-Dec-98   Johnstra      Created.
//
//----------------------------------------------------------------------------
HRESULT CObjectContext::InternalQueryInterface(
    REFIID   riid,
    void   **ppv
    )
{
    return QIHelper(riid, ppv, TRUE);
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::AddRef , public
//
//  History:    16-Dec-98   Johnstra      Created.
//
//----------------------------------------------------------------------------
ULONG CObjectContext::InternalAddRef()
{
    InterlockedIncrement((LONG*)&_cRefs);
    return InterlockedIncrement(&_cInternalRefs);
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::InternalRelease , public
//
//  History:    16-Dec-98   Johnstra      Created.
//
//----------------------------------------------------------------------------
ULONG CObjectContext::InternalRelease()
{
    ULONG cRefs = InterlockedDecrement(&_cInternalRefs);
    CommonRelease();
    return cRefs;
}


HRESULT CObjectContext::QIHelper(
    REFIID   riid,
    void   **ppv,
    BOOL     fInternal
    )
{
    if (IID_IObjContext == riid || IID_IContext == riid)
    {
        *ppv = (IObjContext *) this;
    }
    else if (IID_IContextCallback == riid)
    {
        *ppv = (IContextCallback *) this;
    }
    else if (IID_IUnknown == riid)
    {
        *ppv = (IUnknown*)(IObjContext*)this;
    }
    else if (IID_IMarshalEnvoy == riid)
    {
        *ppv = (IMarshalEnvoy *) this;
    }
    else if (IID_IMarshal == riid)
    {
        *ppv = (IMarshal *) this;
    }
    else if (IID_IStdObjectContext == riid)
    {
        *ppv = this;
    }
    else if (IID_IComThreadingInfo == riid)
    {
        *ppv = (IComThreadingInfo *) this;
    }
    else if (IID_IAggregator == riid)
    {
        *ppv = (IAggregator *) this;
    }
    else if (IID_IGetContextId == riid)
    {
        *ppv = (IGetContextId *) this;
    }
    else if (_pMtsContext)
    {
        return _pMtsContext->QueryInterface(riid, ppv);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    if (fInternal)
        ((CObjectContext*)*ppv)->InternalAddRef();
    else
        ((IUnknown*)*ppv)->AddRef();

    return S_OK;
}


ULONG CObjectContext::DecideDestruction()
{
    ULONG cRefs;
    BOOL fDelete = FALSE;

    // acquire the same lock that the table uses when it
    // gives out references.
    ASSERT_LOCK_NOT_HELD(gContextLock);
    LOCK(gContextLock);

    cRefs = _cRefs;
    if (cRefs == 0)
    {
        if (GUID_NULL != _contextId)
            CleanupTables();

        _dwFlags |= CONTEXTFLAGS_INDESTRUCTOR;
        _cRefs = CINDESTRUCTOR;

        fDelete = TRUE;
    }

    UNLOCK(gContextLock);
    ASSERT_LOCK_NOT_HELD(gContextLock);

    if (fDelete)
        delete this;

    return cRefs;
}


ULONG CObjectContext::CommonRelease()
{
    ULONG cRefs = InterlockedDecrement((LONG *)&_cRefs);

    if (cRefs == 0)
    {
        if(!(_dwFlags & CONTEXTFLAGS_INDESTRUCTOR))
        {
            cRefs = DecideDestruction();
        }
    }

    return cRefs;
}

void CObjectContext::CleanupTables()
{
    ASSERT_LOCK_HELD(gContextLock);

#if DBG==1
    // In debug builds, ensure that the node is present in the table

    // Obtain Hash value for UUID based hash table
    CObjectContext *pExistingContext = CCtxTable::LookupExistingContext(_contextId);
    Win4Assert( (pExistingContext != NULL || IsStatic()) && "Ctx not in table" );
    Win4Assert( (pExistingContext == this || IsStatic()) && "Wrong Ctx found" );

    // If the context is frozen, obtain Hash value for property
    // based hash table
    if (IsInPropTable() && GetPropertyList()->GetCount())
    {
        pExistingContext = CCtxTable::LookupExistingContext(this);
        Win4Assert(pExistingContext == this || IsStatic());
    }
#endif

    // The static context object is never added to the tables
    // so it should not be removed
    if (!IsStatic())
    {
        CCtxTable::s_CtxUUIDHashTable.Remove(this);

        if (IsInPropTable())
            CCtxTable::s_CtxPropHashTable.Remove(this);
    }

#if DBG == 1
    Win4Assert(NULL == CCtxTable::LookupExistingContext(_contextId));
    _propChain.pNext = NULL;
    _propChain.pPrev = NULL;
    _uuidChain.pNext = NULL;
    _uuidChain.pPrev = NULL;
#endif
    ASSERT_LOCK_HELD(gContextLock);
}


typedef struct tagENVOYDATA
{
    GUID  contextId;
    ULONG ulJunk1;
    ULONG ulJunk2;
} ENVOYDATA;


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::GetEnvoyData , private
//
//  Synopsis:   Returns a pointer to an InterfaceData object that contains
//              the marshaled context.
//
//  History:    27-Jan-98   Johnstra      Created.
//
//----------------------------------------------------------------------------
HRESULT CObjectContext::GetEnvoyData(
    DATAELEMENT**  ppDE
    )
{
    ComDebOut((DEB_OBJECTCONTEXT, "CObjectContext::GetEnvoyData\n"));
    Win4Assert(ppDE != NULL);
    ASSERT_LOCK_NOT_HELD(gContextLock);

    HRESULT hr = E_FAIL;
    *ppDE = NULL;
    if (IsFrozen())
    {
        hr = S_OK;
        if (_pifData == NULL)
        {
            //
            // Get the space requirements of the contexts marshal packet.
            //

            hr = GetEnvoySizeMax(0, &_MarshalSizeMax);
            if (SUCCEEDED(hr))
            {
                //
                // Adjust the space requirements to accommodate the size of
                // a DATAELEMENT structure.
                //

                ULONG cbSize = _MarshalSizeMax - (sizeof(DATAELEMENT) - sizeof(BYTE));

                //
                // Allocate a stream into which the context and all its
                // properties gets marshaled.
                //

                CXmitRpcStream strm(_MarshalSizeMax);

                //
                // Write the header info required by COM into the stream.
                //

                ENVOYDATA EnvoyData;
                EnvoyData.contextId = _contextId;
                EnvoyData.ulJunk1   = cbSize;
                EnvoyData.ulJunk2   = cbSize;
                hr = strm.Write(&EnvoyData, sizeof(ENVOYDATA), NULL);
                if (SUCCEEDED(hr))
                {
                    //
                    // Marshal the context into the stream.
                    //

                    hr = MarshalEnvoy(&strm, 0);
                    if (SUCCEEDED(hr))
                    {
                        LOCK(gContextLock);
                        if (NULL == _pifData)
                        {
                            // We now own the buffer.
                            strm.AssignSerializedInterface(&_pifData);
                            if (_pifData == NULL)
                                hr = E_OUTOFMEMORY;
                        }
                        UNLOCK(gContextLock);
                    }
                }
            }
        }

        //
        // If we successfully created the marshaling buffer, copy the
        // address of the buffer into the supplied pointer.
        //

        if (SUCCEEDED(hr))
        {
            *ppDE = (DATAELEMENT*) _pifData->abData;
        }
    }

    return hr;
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::GetEnvoyData , private
//
//  Synopsis:   Unmarshals an object context from the information stored
//              in the supplied InterfaceData object.  This method should
//              only be called by infrastructure code to unmarshal a
//              previously marshaled context.
//
//              It is assumed that the context will be frozen when
//              unmarshaling completes.
//
//  History:    27-Jan-98   Johnstra      Created.
//
//----------------------------------------------------------------------------
HRESULT CObjectContext::SetEnvoyData(
    DATAELEMENT* pDE
    )
{
    ComDebOut((DEB_OBJECTCONTEXT, "CObjectContext::SetEnvoyData cb:%d\n",
               pDE->cbSize));
    ASSERT_LOCK_HELD(gContextLock);
    Win4Assert(_pifData != NULL);

    //
    // Initialize the contexts state using the information in the supplied
    // buffer.
    //

    CXmitRpcStream strm(_pifData);

    //
    // Read past the header info.
    //

    ENVOYDATA EnvoyData;
    HRESULT hr = strm.Read(&EnvoyData, sizeof(ENVOYDATA), NULL);
    if (SUCCEEDED(hr))
    {
        //
        // Unmarshal the object context from the stream.
        //

        UNLOCK(gContextLock);
        ASSERT_LOCK_NOT_HELD(gContextLock);

        CObjectContext *pCtx = NULL;
        hr = UnmarshalEnvoy(&strm, IID_IObjContext, (void **) &pCtx);

        ASSERT_LOCK_NOT_HELD(gContextLock);
        LOCK(gContextLock);

        if (SUCCEEDED(hr))
        {
#if DBG==1
            Win4Assert(pCtx->IsValid());
            if (pCtx->IsValid())
            {
                pCtx->Release();
            }
#else
            pCtx->Release();
#endif
        }
    }

    ASSERT_LOCK_HELD(gContextLock);
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::GetUnmarshalClass , public
//
//  Synopsis:   Provides caller with the CLSID of the proxy for this class.
//
//  History:    22-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjectContext::GetUnmarshalClass(
    REFIID  riid,
    void*   pv,
    DWORD   dwDestContext,
    void*   pvDestContext,
    DWORD   mshlflags,
    CLSID*  pclsid
    )
{
    ComDebOut((DEB_OBJECTCONTEXT,
     "CObjectContext::GetUnmarshalClass _dwFlags:%08X riid:%I mshlflags:%08X\n",
               _dwFlags, &riid, mshlflags));
    ASSERT_LOCK_NOT_HELD(gContextLock);
    *pclsid = CLSID_ContextMarshaler;
    return S_OK;
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::GetMarshalSizeMax , public
//
//  Synopsis:   Provides caller with number of bytes required to marshal the
//              the context.
//
//  History:    22-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjectContext::GetMarshalSizeMax(
    REFIID  riid,
    void*   pv,
    DWORD   dwDestContext,
    void*   pvDestContext,
    DWORD   mshlflags,
    ULONG*  pcb
    )
{
    ComDebOut((DEB_OBJECTCONTEXT,
      "CObjectContext::GetMarshalSizeMax [IN] this:%08X mshlflags:%08X\n",
               this, mshlflags));
    ASSERT_LOCK_NOT_HELD(gContextLock);
    Win4Assert(pcb != NULL);

    HRESULT hr        = S_OK;
    ULONG   TotalSize = 0;
    ULONG   Count     = 0;

    if (dwDestContext == MSHCTX_INPROC || dwDestContext == MSHCTX_CROSSCTX)
    {
        //
        // This is a cross-context-same-apartment case, we know the size.
        //

        *pcb = sizeof(CONTEXTHEADER) + sizeof(this);
    }
    else
    {
        //
        // If there are properties to marshal, get their size requirements
        // first.
        //

        Count = _properties.GetCount();
        if (Count > 0)
        {
            ULONG PropSize = 0;
            hr = GetPropertiesSizeMax(IID_IUnknown,
                                      pv,
                                      dwDestContext,
                                      pvDestContext,
                                      mshlflags,
                                      Count,
                                      FALSE,
                                      PropSize);
            if (SUCCEEDED(hr))
                TotalSize = PropSize;
        }

        //
        // Add to the total the number of bytes needed by this context.
        //

        TotalSize += sizeof(CONTEXTHEADER);

        //
        // Copy the calculated size into the supplied pointer.
        //

        *pcb = (SUCCEEDED(hr)) ? TotalSize : 0;
    }

    ASSERT_LOCK_NOT_HELD(gContextLock);
    ComDebOut((DEB_OBJECTCONTEXT,
               "CObjectContext::GetMarshalSizeMax [OUT] returning hr:%08X pcb:%d\n",
               hr, *pcb));
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::MarshalInterface , public
//
//  Synopsis:   Marshals the context into the provided stream.
//
//  History:    22-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjectContext::MarshalInterface(
    IStream*  pstm,
    REFIID    riid,
    void*     pv,
    DWORD     dwDestContext,
    void*     pvDestContext,
    DWORD     mshlflags
    )
{
    ComDebOut((DEB_OBJECTCONTEXT,
     "CObjectContext::MarshalInterface _dwFlags:%08X riid:%I mshlflags:%08X\n",
               _dwFlags, &riid, mshlflags));
    ASSERT_LOCK_NOT_HELD(gContextLock);

    ULARGE_INTEGER ulibPosition, ulibPosEnd, ulibInfo;
    LARGE_INTEGER  dlibMove;
    BOOL           fResetSeekPtr       = FALSE;
    ULONG          Count               = _properties.GetCount();
    HRESULT        hr                  = S_OK;
    BOOL           fJustMarshalPointer = FALSE;
    BOOL           fWroteProps         = FALSE;

    //
    // If this is a cross-context-same-apartment scenario, we only need to
    // marshal a pointer into the stream.
    //

    if (dwDestContext == MSHCTX_INPROC || dwDestContext==MSHCTX_CROSSCTX)
    {
        fJustMarshalPointer = TRUE;
    }

    if (fJustMarshalPointer == FALSE && Count > 0)
    {
        //
        // Attempt to allocate on the stack memory into which all the
        // properties can be serialized.
        //

        hr = E_OUTOFMEMORY;
        ContextProperty* pProps =
           (ContextProperty *) _alloca(sizeof(ContextProperty) * Count);

        if (pProps != NULL)
        {
            //
            // We have the necessary memory, so serialize all the
            // properties into the vector.
            //

            _properties.SerializeToVector(pProps);

            //
            // We try to marshal all the properties first, even though
            // we want the context information to precede the property
            // info in the stream.  We do this because one component of
            // the context info we marshal is the number of properties
            // and since all of the properties on the context may not
            // marshal, the value representing the number of properties
            // may change.  So by doing the properties first, we can fixup
            // the count value.  To do this, we seek past where the context
            // info will go in the stream, marshal the property info, then
            // seek back and marshal the context info.
            //

            hr = GetStreamPos(pstm, &ulibPosition);
            if (SUCCEEDED(hr))
            {
                hr = AdvanceStreamPos(pstm, sizeof(CONTEXTHEADER), &ulibInfo);
                if (SUCCEEDED(hr))
                {
                    hr = MarshalProperties(Count,
                                           pProps,
                                           pstm,
                                           IID_IUnknown,
                                           pv,
                                           dwDestContext,
                                           pvDestContext,
                                           mshlflags);
                    fWroteProps = TRUE;
                }
            }
        }
    }

    // Save the current stream pointer and reset the stream to the
    // position where we write the header.
    //
    if (fWroteProps && SUCCEEDED(hr))
    {
        fResetSeekPtr = TRUE;
        hr = GetStreamPos(pstm, &ulibPosEnd);

        if (SUCCEEDED(hr))
        {
            hr = SetStreamPos(pstm, ulibPosition.QuadPart, NULL);
        }
    }

    //
    // If the properties were successfully marshaled (or if there were no
    // properties to marshal or if we are just mashaling a pointer)
    // marshal the context information.
    //

    if (SUCCEEDED(hr))
    {
        CONTEXTHEADER hdr;
        hdr.Version.ThisVersion = OBJCONTEXT_VERSION;
        hdr.Version.MinVersion  = OBJCONTEXT_MINVERSION;
        hdr.CmnHdr.ContextId    = _contextId;
        hdr.CmnHdr.Flags        = (fJustMarshalPointer) ? 0 : CTXMSHLFLAGS_BYVAL;
//      hdr.CmnHdr.Flags        |= CTXMSHLFLAGS_HASMRSHPROP;
        hdr.CmnHdr.Reserved     = 0;
        hdr.CmnHdr.dwNumExtents = 0;
        hdr.CmnHdr.cbExtents    = 0;
        hdr.CmnHdr.MshlFlags    = mshlflags;

        if (fJustMarshalPointer == TRUE)
        {
            // Just marshaling a pointer.  Fill out the rest of the
            // header information and write the pointer into the stream.

            hdr.ByRefHdr.Reserved  = mshlflags;
            hdr.ByRefHdr.ProcessId = GetCurrentProcessId();

            hr = pstm->Write(&hdr, sizeof(CONTEXTHEADER), NULL);
            if (SUCCEEDED(hr))
            {
                hr = pstm->Write(&pv, sizeof(pv), NULL);

                // Bump reference count based on type of marshal.

                if (SUCCEEDED(hr) && (mshlflags != MSHLFLAGS_TABLEWEAK))
                {
                    // In case you're wondering why this is not an
                    // InternalAddRef... RPC releases this ref for
                    // us and they don't know anything about our internal
                    // ref count, so we just take a user reference.
                    ((IUnknown *) pv)->AddRef();
                }
            }
        }
        else
        {
            // Deep copy.  Fill out the rest of the CONTEXTHEADER and write
            // it to the stream.

            hdr.ByValHdr.Count  = Count;
            hdr.ByValHdr.Frozen = !!IsFrozen();

            hr = pstm->Write(&hdr, sizeof(CONTEXTHEADER), NULL);
            if (SUCCEEDED(hr))
            {
                // If we wrote properties into the stream, reset the seek ptr
                // to the end of the last property.

                if (fResetSeekPtr == TRUE)
                {
                    hr = SetStreamPos(pstm, ulibPosEnd.QuadPart, &ulibInfo);
                }
            }
        }
    }

    ASSERT_LOCK_NOT_HELD(gContextLock);
    ComDebOut((DEB_OBJECTCONTEXT,
               "CObjectContext::MarshalInterface returning hr:%08X\n", hr));
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::ReadStreamHdrAndProcessExtents , private
//
//  Synopsis:   Reads the header from the supplied stream.  If we don't
//              understand the stream version, return
//              CO_E_INCOMPATIBLESTREAMVERSION.  Process any extensions
//              in the stream.
//
//  History:    23-Apr-98   Johnstra      Created.
//
//----------------------------------------------------------------------------
HRESULT CObjectContext::ReadStreamHdrAndProcessExtents(
    IStream*       pstm,
    CONTEXTHEADER& hdr
    )
{
    // Read the header.
    //
    HRESULT hr = pstm->Read(&hdr, sizeof(CONTEXTHEADER), NULL);

    if (SUCCEEDED(hr))
    {
        // Verify that we recognize the stream version.
        //
        if (hdr.Version.MinVersion < OBJCONTEXT_MINVERSION)
        {
                hr = CO_E_INCOMPATIBLESTREAMVERSION;
        }
        else
        {
            if (hdr.CmnHdr.dwNumExtents != 0)
            {
                // We don't know about any extensions; skip over them.
                //
                LARGE_INTEGER dlibMove;
                dlibMove.LowPart  = hdr.CmnHdr.cbExtents;
                dlibMove.HighPart = 0;
                hr = pstm->Seek(dlibMove, STREAM_SEEK_CUR, NULL);
            }
        }
    }

    return hr;
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::UnmarshalInterface , public
//
//  Synopsis:   Unmarshals a context from the provided stream.
//
//  History:    22-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjectContext::UnmarshalInterface(
    IStream* pstm,
    REFIID   riid,
    void**   ppv)
{
    ComDebOut((DEB_OBJECTCONTEXT,
               "CObjectContext::UnmarshalInterface _dwFlags:%08X riid:%I\n",
               _dwFlags, &riid));
    ASSERT_LOCK_NOT_HELD(gContextLock);
    Win4Assert(ppv != NULL);

    *ppv = NULL;

    HRESULT         hr          = E_FAIL;
    SHORT           Version     = 0;
    SHORT           MinVersion  = 0;
    DWORD           mshlflags   = 0;
    ULONG           count       = 0;
    CObjectContext *pContext    = NULL;
    BOOL            bNewCtxId   = FALSE;

    // Read the context header and any extensions from the stream.

    CONTEXTHEADER hdr;
    hr = ReadStreamHdrAndProcessExtents(pstm, hdr);
    if (FAILED(hr))
        return hr;

    ContextID ContextId = MarshaledContextId(hdr);

    if (MarshaledByReference(hdr))
    {
        // Do a sanity check on the process ID to ensure that the pointer
        // in the stream is valid in this process.

        if (!MarshaledByThisProcess(hdr))
        {
            Win4Assert(FALSE && "Marshaled ctx ptr not valid in this process!");
            return E_FAIL;
        }

        // This is a cross-context-same-apartment or inproc case.  The
        // stream contains only a pointer to an existing context.  Read
        // the pointer.

        hr = pstm->Read(ppv, sizeof(*ppv), NULL);

        if (SUCCEEDED(hr))
        {
            // What we do with the context at this point depends on how it was
            // marshaled.  There are 3 possibilities:
            // 1) TABLEWEAK:
            //    Multiple clients may unmarshal the context.  Thus we
            //    AddRef each copy we unmarshal.  Because the table does not
            //    hold a reference however, we must make sure the context is
            //    still alive before we attempt to reference it.
            // 2) TABLESTRONG:
            //    Multiple clients may unmarshal the context.  Thus we
            //    AddRef each copy we unmarshal.  Because the table does
            //    hold a reference, we may assume the context is still alive.
            // 3) NORMAL:
            //    Only one client may unmarshal the context.  Thus we do
            //    not AddRef the context before returning it.

            if (MarshaledTableWeak(hdr))
            {
                // TABLEWEAK: we do not know if the interface is still
                // alive.  Look for the interface in our table.  If it
                // is not in the table, fail.

                LOCK(gContextLock);
                pContext = CCtxTable::LookupExistingContext(ContextId);
                if (NULL == pContext)
                    hr = E_FAIL;
                else
                    ((CObjectContext*) *ppv)->InternalAddRef();
                UNLOCK(gContextLock);

            }
            else if (MarshaledTableStrong(hdr))
            {
                // TABLESTRONG: We know the interface is still alive
                // because we AddRef'd it when we marshaled it.  Thus,
                // we can safely AddRef it and hand it out now.

                ((CObjectContext *) *ppv)->InternalAddRef();
            }
        }

        return hr;
    }

    // The common header contains the context id.  If the marshaled context
    // exists in this process, and if the existing context is not an envoy,
    // QI the existing context context for the desired IID instead of
    // unmarshaling a new one.

    LOCK(gContextLock);
    pContext = CCtxTable::LookupExistingContext(ContextId);
    if (pContext)
    {
        // We hold an uncounted ref to the context we found.  Bump the
        // ref count before releasing the lock.

        pContext->InternalAddRef();
        UNLOCK(gContextLock);

        if (pContext->IsEnvoy())
        {
            // The context we found is an envoy, so we want to go ahead
            // and unmarshal, but let's give the new context a
            // new ID so it does not clash with the existing envoy.

            bNewCtxId = TRUE;
        }
        else
        {
            // The marshaled context already lives in this process, so
            // just return a ref to the existing one.

            hr = pContext->QueryInterface(riid, ppv);
        }

        // Release the reference we took before we released the lock.

        pContext->InternalRelease();
        pContext = NULL;

        // If the context we found was not an envoy, return the results
        // of the QI to the caller.

        if (!bNewCtxId)
            return hr;
    }
    else
        UNLOCK(gContextLock);

    // The marshaled context is new to this process.  Unmarshal then add this
    // new context to our table to prevent us from unmarshaling it again in
    // the future.

    ULONG Props = MarshaledPropertyCount(hdr);
    if (SUCCEEDED(hr) && (Props > 0))
    {
        ULONG i = 0;
        do
        {
            // Try to read the property header info from the stream.

            PROPMARSHALHEADER PropHeader;
            hr = pstm->Read(&PropHeader, sizeof(PROPMARSHALHEADER), NULL);

            // Calculate and store the stream pos of the next property.

            ULARGE_INTEGER ulibNextProp;
            if (SUCCEEDED(hr))
            {
                hr = GetStreamPos(pstm, &ulibNextProp);
                if (SUCCEEDED(hr))
                    ulibNextProp.QuadPart += PropHeader.cb;
            }

            if (SUCCEEDED(hr))
            {
                // Unmarshal the property.

                IUnknown* pUnk = NULL;
                hr = CoUnmarshalInterface(pstm, IID_IUnknown, (void**) &pUnk);
                if (SUCCEEDED(hr))
                {
                    // Add the property to this context.

                    hr = SetProperty(PropHeader.policyId, PropHeader.flags, pUnk);

                    // Release our reference to the property.

                    pUnk->Release();

                    if (SUCCEEDED(hr))
                    {
                        // Advance the stream pointer to the next property.

                        hr = SetStreamPos(pstm, ulibNextProp.QuadPart, &ulibNextProp);
                    }
                }
            }
        } while ((++i < Props) && SUCCEEDED(hr));
    }

    // If all is well, check the context table again before returning a
    // reference to ourself.  After releasing the lock above, another thread
    // could have unmarshaled this context.

    if (SUCCEEDED(hr))
    {
        // If the context was marshaled frozen, then we need to freeze
        // this context.  Otherwise, we need to create a new unique ID
        // for this context.

        if (MarshaledFrozen(hdr))
            Freeze();
        else
            bNewCtxId = TRUE;

        // Take the lock and try to find a context in this process with
        // the same ContextId.

        LOCK(gContextLock);
        pContext = CCtxTable::LookupExistingContext(ContextId);
        if (pContext && pContext->IsEnvoy())
        {
            // An envoy for the marshaled context exists in this process.
            // We want to go ahead and unmarshal, but let's give the
            // unmarshaled context a new ID so it does not clash with the
            // existing envoy.

            bNewCtxId = TRUE;
            pContext = NULL;
        }

        if (pContext)
        {
            // LookupExistingContext returned an uncounted reference.  We
            // need to bump the refcount on the context before we release
            // the lock.

            pContext->InternalAddRef();
            UNLOCK(gContextLock);

            // Another thread did unmarshal this context after we released the
            // lock above.  Return a reference to the existing context instead
            // of to ourself.

            hr = pContext->QueryInterface(riid, ppv);

            // Release our reference to the context.

            pContext->InternalRelease();
            pContext = NULL;
        }
        else
        {
            if (bNewCtxId)
            {
                hr = CreateUniqueID(ContextId);
                if (FAILED(hr))
                    return hr;
            }

            if (_dwFlags & CONTEXTFLAGS_STATICCONTEXT)
                _dwFlags &= ~CONTEXTFLAGS_STATICCONTEXT;

            _contextId = ContextId;
            _dwHashOfId = HashGuid(_contextId);

            // We do not add static objects to the tables
            if(!IsStatic())
            {
                // Make sure that the chain is not linked up at the time of
                // addition to the hash tables
//                    Win4Assert(NULL == _propChain.pNext && NULL == _propChain.pPrev);
//                    Win4Assert(NULL == _uuidChain.pNext && NULL == _uuidChain.pPrev);
                CCtxTable::s_CtxUUIDHashTable.Add(this);
            }

            UNLOCK(gContextLock);
            hr = this->QueryInterface(riid, ppv);
            if (FAILED(hr))
            {
                LOCK(gContextLock);
                CCtxTable::s_CtxUUIDHashTable.Remove(this);
                UNLOCK(gContextLock);
            }
        }
    }

    ASSERT_LOCK_NOT_HELD(gContextLock);
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::ReleaseMarshalData , public
//
//  Synopsis:   Releases any data used in marshaling context.
//
//  History:    22-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjectContext::ReleaseMarshalData(
    IStream* pstm
    )
{
    ComDebOut((DEB_OBJECTCONTEXT, "CObjectContext::ReleaseMarshaldata\n"));

    HRESULT hr = E_INVALIDARG;
    Win4Assert(pstm);
    if (!pstm)
        return hr;

    // Read the context header and any extensions from the stream.

    CONTEXTHEADER hdr;
    hr = ReadStreamHdrAndProcessExtents(pstm, hdr);
    if (FAILED(hr))
        return hr;

    if (MarshaledByReference(hdr))
    {
        // If the objref contains a context marshaled by reference, the
        // pointer must be valid in this process's address space.  If it
        // isn't we can't do anything with it.

        if (!MarshaledByThisProcess(hdr))
            return E_INVALIDARG;

        // If the object was marshaled TABLESTRONG or NORMAL, the objref
        // holds a reference to the object which we need to release.

        if (!MarshaledTableWeak(hdr))
        {
            CObjectContext *pCtx = NULL;
            hr = pstm->Read(&pCtx, sizeof(pCtx), NULL);
            if (SUCCEEDED(hr))
            {
                pCtx->InternalRelease();
            }
        }
    }
    else
    {
        // How many properties do we have.
        ULONG Props = MarshaledPropertyCount(hdr);

        // Unmarshal and release all the properties.
        while (Props-- > 0 && SUCCEEDED(hr))
        {
            ULARGE_INTEGER ulibNextProp;
            PROPMARSHALHEADER PropHeader;

            // Read the property header.
            hr = pstm->Read(&PropHeader, sizeof(PROPMARSHALHEADER), NULL);
            if (FAILED(hr))
                break;

            // Get the current stream position.
            hr = GetStreamPos(pstm, &ulibNextProp);
            if (FAILED(hr))
                break;

            // Calculate the location of the next property in the stream.
            ulibNextProp.QuadPart += PropHeader.cb;

            // Unmarshal the property, release it's marshal data, and remove
            // it from the property list.
            IMarshal *pMI = NULL;
            hr = CoReleaseMarshalData(pstm);
            if (SUCCEEDED(hr))
            {
                RemoveProperty(PropHeader.policyId);
            }

            // Advance the stream pointer to the next property.
            hr = SetStreamPos(pstm, ulibNextProp.QuadPart, &ulibNextProp);
        }
    }

    return hr;
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::DisconnectObject , public
//
//  Synopsis:   Disconnects from remote object.
//
//  History:    22-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjectContext::DisconnectObject(
    DWORD dwReserved
    )
{
    ComDebOut((DEB_OBJECTCONTEXT, "CObjectContext::DisconnectObject\n"));
    return S_OK;
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::GetEnvoyUnmarshalClass , public
//
//  Synopsis:   Provides caller with the CLSID of the proxy for this class.
//
//  History:    22-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjectContext::GetEnvoyUnmarshalClass(
    DWORD  dwDestContext,
    CLSID* pclsid
    )
{
    ComDebOut((DEB_OBJECTCONTEXT, "CObjectContext::GetEnvoyUnmarshalClass\n"));
    ASSERT_LOCK_NOT_HELD(gContextLock);

    *pclsid = CLSID_ObjectContext;
    return S_OK;
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::GetEnvoySizeMax , public
//
//  Synopsis:   Provides the maximum size of the the marshaling packet.
//
//  History:    22-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjectContext::GetEnvoySizeMax(
    DWORD  dwDestContext,
    DWORD* pcb
    )
{
    ComDebOut((DEB_OBJECTCONTEXT,
               "CObjectContext::GetEnvoySizeMax _dwFlags:%08X\n", _dwFlags));
    ASSERT_LOCK_NOT_HELD(gContextLock);
    Win4Assert(pcb != NULL);

    ULONG   TotalSize = 0;
    HRESULT hr        = S_OK;
    ULONG   Count     = _properties.GetCount();

    // If the size requirements have already been calculated for this context,
    // do not calculate again.  Just use the previously calculated value.
    //
    if (_pifData)
    {
        *pcb = _MarshalSizeMax;
        return hr;
    }

    if (dwDestContext == MSHCTX_INPROC || dwDestContext == MSHCTX_CROSSCTX)
    {
        //
        // This is an cross-context-same-apartment or inproc case.  Only a
        // pointer to this will be marshaled, so we know the size.
        //

        *pcb = sizeof(CONTEXTHEADER) + sizeof(DATAELEMENT)
            - sizeof(BYTE) + sizeof(this);
        return hr;
    }

    if (Count > 0)
    {
        ULONG PropSize = 0;
        hr = GetPropertiesSizeMax(IID_NULL,
                                  NULL,
                                  dwDestContext,
                                  NULL,
                                  0,
                                  Count,
                                  TRUE,
                                  PropSize);
        if (SUCCEEDED(hr))
            TotalSize = PropSize;
    }

    //
    // Add to the total the number of bytes needed by this context.
    //

    TotalSize += (sizeof(CONTEXTHEADER) + sizeof(DATAELEMENT) - sizeof(BYTE));

    //
    // Copy the calculated size into the supplied pointer.
    //

    Win4Assert(hr==S_OK);
    *pcb = (SUCCEEDED(hr)) ? TotalSize : 0;

    ASSERT_LOCK_NOT_HELD(gContextLock);
    ComDebOut((DEB_OBJECTCONTEXT,
               "CObjectContext::GetEnvoySizeMax returning hr:%08X pcb:%d\n",
               hr, *pcb));
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::MarshalEnvoy , public
//
//  Synopsis:   Write marshaling packet into the provided stream.
//
//  History:    22-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjectContext::MarshalEnvoy(
    IStream* pstm,
    DWORD    dwDestContext
    )
{
    ComDebOut((DEB_OBJECTCONTEXT, "CObjectContext::MarshalEnvoy\n"));
    ASSERT_LOCK_NOT_HELD(gContextLock);

    ULARGE_INTEGER ulibPosition, ulibPosEnd, ulibInfo;
    LARGE_INTEGER  dlibMove;
    BOOL           fResetSeekPtr       = FALSE;
    ULONG          Count               = _properties.GetCount();
    HRESULT        hr                  = S_OK;
    BOOL           fJustMarshalPointer = FALSE;
    BOOL           fWroteProps         = FALSE;

    // If this context has already been envoy marshaled, just write the
    // InterfaceData to the stream.
    //
    if (_pifData)
    {
        return pstm->Write(&_pifData->abData, _pifData->ulCntData, NULL);
    }

    //
    // If this is a cross-context-same-apartment scenario, we only need to
    // marshal a pointer into the stream.
    //

    if (dwDestContext == MSHCTX_INPROC || dwDestContext==MSHCTX_CROSSCTX)
    {
        fJustMarshalPointer = TRUE;
    }

    if (fJustMarshalPointer == FALSE && Count > 0)
    {
        //
        // Attempt to allocate on the stack memory into which all the
        // properties can be serialized.
        //

        hr = E_OUTOFMEMORY;
        ContextProperty* pProps =
           (ContextProperty *) _alloca(sizeof(ContextProperty) * Count);

        if (pProps != NULL)
        {
            //
            // We have the necessary memory, so serialize all the
            // properties into the vector.
            //

            _properties.SerializeToVector(pProps);

            //
            // We try to marshal all the properties first, even though
            // we want the context information to precede the property
            // info in the stream.  We do this because one component of
            // the context info we marshal is the number of properties
            // and since all of the properties on the context may not
            // marshal, the value representing the number of properties
            // may change.  So by doing the properties first, we can fixup
            // the count value.  To do this, we seek past where the context
            // info will go in the stream, marshal the property info, then
            // seek back and marshal the context info.
            //

            hr = GetStreamPos(pstm, &ulibPosition);
            if (SUCCEEDED(hr))
            {
                hr = AdvanceStreamPos(pstm, sizeof(CONTEXTHEADER), &ulibInfo);
                if (SUCCEEDED(hr))
                {
                    hr = MarshalEnvoyProperties(Count,
                                                pProps,
                                                pstm,
                                                dwDestContext);
                    fWroteProps = TRUE;
                }
            }
        }
    }

    // Save the current stream pointer and reset the stream to the
    // position where we write the header.
    //
    if (fWroteProps && SUCCEEDED(hr))
    {
        fResetSeekPtr = TRUE;
        hr = GetStreamPos(pstm, &ulibPosEnd);

        if (SUCCEEDED(hr))
        {
            hr = SetStreamPos(pstm, ulibPosition.QuadPart, NULL);
        }
    }

    //
    // If the properties were successfully marshaled, marshal the context
    // information.
    //

    if (SUCCEEDED(hr))
    {
        CONTEXTHEADER hdr;
        hdr.Version.ThisVersion = OBJCONTEXT_VERSION;
        hdr.Version.MinVersion  = OBJCONTEXT_MINVERSION;
        hdr.CmnHdr.ContextId    = _contextId;
        hdr.CmnHdr.Flags        = (fJustMarshalPointer) ? 0 : CTXMSHLFLAGS_BYVAL;
//      hdr.CmnHdr.Flags        |= CTXMSHLFLAGS_HASMRSHPROP;
        hdr.CmnHdr.Reserved     = 0;
        hdr.CmnHdr.dwNumExtents = 0;
        hdr.CmnHdr.cbExtents    = 0;
        hdr.CmnHdr.MshlFlags    = 0;

        if (fJustMarshalPointer == TRUE)
        {
            // Just marshaling a pointer.  Fill out the rest of the
            // header information and write the pointer into the stream.

            hdr.ByRefHdr.Reserved  = 0;
            hdr.ByRefHdr.ProcessId = GetCurrentProcessId();

            hr = pstm->Write(&hdr, sizeof(CONTEXTHEADER), NULL);
            if (SUCCEEDED(hr))
            {
                void* pv = this;
                hr = pstm->Write(&pv, sizeof(pv), NULL);

                // Because RPC has no knowledge of our internal ref count,
                // we have to take a user reference here so the RPC release
                // works correctly.
                ((IUnknown *) pv)->AddRef();
            }
        }
        else
        {
            hdr.ByValHdr.Count  = Count;
            hdr.ByValHdr.Frozen = !!IsFrozen();

            hr = pstm->Write(&hdr, sizeof(CONTEXTHEADER), NULL);
            if (SUCCEEDED(hr))
            {
                // If we wrote properties into the stream, reset the seek ptr
                // to the end of the last property.

                if (fResetSeekPtr == TRUE)
                    hr = SetStreamPos(pstm, ulibPosEnd.QuadPart, &ulibInfo);
            }
        }
    }

    ASSERT_LOCK_NOT_HELD(gContextLock);
    ComDebOut((DEB_OBJECTCONTEXT,
               "CObjectContext::MarshalEnvoy returning hr:%08X\n", hr));
    return hr;
}


// Helper function for IsPunkInModule (lifted from task.cxx)
inline BOOL IsPathSeparator( WCHAR ch )
{
    return (ch == L'\\' || ch == L'/' || ch == L':');
}

//+--------------------------------------------------------------------------
//
//  Member:     IsPunkInModule , private
//
//  Synopsis:   This function determines if the supplied interface pointer
//              points to an object that is implemented in the supplied
//              module.
//
//  History:    22-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
BOOL IsPunkInModule(
    IUnknown* pUnk,
    LPCWSTR   lpszIn
    )
{
    BOOL retval = FALSE;

    // Get the address of the supplied interface's QI function.
    //
    DWORD* lpVtbl = *(DWORD**)pUnk;
    DWORD_PTR dwQIAddr = *lpVtbl;

    // Try to get the module handle of the named module.  If we can't get this,
    // we know COMSVCS is not even loaded, so we know the given address is not
    // in it.
    //
    HMODULE hSvcs = GetModuleHandleW(lpszIn);
    if (hSvcs)
    {
        // Let's try to query the system for information about the supplied
        // address.
        //
        MEMORY_BASIC_INFORMATION MBI;
        if (VirtualQuery((LPVOID)dwQIAddr, &MBI, sizeof(MBI)))
        {
            // If the address is mapped into an image section, we are still
            // in business.  Otherwise, we know it's not in the COMSVCS dll.
            //
            if (MBI.Type == MEM_IMAGE)
            {
                // Get the path of the image file.
                //
                WCHAR lpModuleName[MAX_PATH];
				*lpModuleName = L'\0';	// PREfix bug: Uninitialized variable

                DWORD nSize = GetModuleFileName((HINSTANCE)MBI.AllocationBase,
                                                lpModuleName, MAX_PATH);
                if (nSize != 0 && nSize < MAX_PATH)
                {
                    // Find the end of the string and determine the string length.
                    //
                    WCHAR* pch = NULL;
                    for (pch=lpModuleName; *pch; pch++);

                    DecLpch(lpModuleName, pch);

                    while (!IsPathSeparator(*pch))
                       DecLpch(lpModuleName, pch);

                    // we're at the last separator.
                    //
                    if (!lstrcmpiW(pch+1, lpszIn))
                        retval = TRUE;
                }
            }
        }
    }

    return retval;
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::UnmarshalEnvoy , public
//
//  Synopsis:   Unmarshal the IObjContext.
//
//  History:    22-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjectContext::UnmarshalEnvoy(
    IStream* pstm,
    REFIID riid,
    void** ppv
    )
{
    ComDebOut((DEB_OBJECTCONTEXT, "CObjectContext::UnmarshalEnvoy riid:%I\n",
               &riid));
    ASSERT_LOCK_NOT_HELD(gContextLock);
    Win4Assert(ppv != NULL);

    // Read the stream header and any extensions.
    //
    CONTEXTHEADER hdr;
    HRESULT hr = ReadStreamHdrAndProcessExtents(pstm, hdr);

    if (SUCCEEDED(hr) && (MarshaledByReference(hdr)))
    {
        Win4Assert(FALSE && "UnmarshalEnvoy by reference?!");
        return E_UNEXPECTED;
    }

    // If everything is still ok, try to reconstitute any properties.
    //
    ULONG Props = MarshaledPropertyCount(hdr);
    if (SUCCEEDED(hr) && (Props > 0))
    {
        HRESULT hrProp = S_OK;
        ULONG i = 0;
        do
        {
            // Try to read the property header info from the stream.
            //
            PROPMARSHALHEADER PropHeader;
            hr = pstm->Read(&PropHeader, sizeof(PROPMARSHALHEADER), NULL);

            // Calculate and store the stream ptr for the next property.
            //
            ULARGE_INTEGER ulibNextProp;
            LARGE_INTEGER  dlibMove;
            if (SUCCEEDED(hr))
            {
                hr = GetStreamPos(pstm, &ulibNextProp);
                if (SUCCEEDED(hr))
                    ulibNextProp.QuadPart += PropHeader.cb;
            }

            if (SUCCEEDED(hr))
            {
                // Create an instance of the proxy, asking for a pointer to its
                // IMarshalEnvoy interface.
                //
                IMarshalEnvoy* pME = NULL;
                hrProp = CoCreateInstance(PropHeader.clsid, NULL, CLSCTX_SERVER,
                                          IID_IMarshalEnvoy, (void**) &pME);
                if (SUCCEEDED(hrProp))
                {
                    // Unmarshal the property.
                    //
                    IUnknown* pUnk = NULL;
                    hrProp = pME->UnmarshalEnvoy(pstm, IID_IUnknown, (void**) &pUnk);
                    if (SUCCEEDED(hrProp))
                    {
                        hr = SetProperty(PropHeader.policyId, PropHeader.flags, pUnk);
                        pUnk->Release();
                    }

                    // Release the IMarshalEnvoy.
                    //
                    pME->Release();
                }

                // Advance stream pointer to beginning of next property.
                //
                if (SUCCEEDED(hr))
                {
                    hr = SetStreamPos(pstm, ulibNextProp.QuadPart, &ulibNextProp);
                }
            }
        } while ((++i < Props) && SUCCEEDED(hr));
    }

    // If all is well, set our frozen-ness state using the value read from the
    // stream and return a pointer to this object.
    //
    if (SUCCEEDED(hr))
    {
        if (MarshaledFrozen(hdr))
            Freeze();
        hr = this->QueryInterface(riid, ppv);
    }

    ASSERT_LOCK_NOT_HELD(gContextLock);
    ComDebOut((DEB_OBJECTCONTEXT,
               "CObjectContext::UnmarshalEnvoy returning hr:%08X\n", hr));
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::GetPropertiesSizeMax , public
//
//  Synopsis:   Gets the number of bytes required to marshal all the
//              properterties on the context.
//
//  History:    22-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
HRESULT CObjectContext::GetPropertiesSizeMax(
    REFIID  riid,
    void*   pv,
    DWORD   dwDestContext,
    void*   pvDestContext,
    DWORD   mshlflags,
    ULONG   cProps,
    BOOL    fEnvoy,
    ULONG&  PropSize
    )
{
    ComDebOut((DEB_OBJECTCONTEXT,
        "CObjectContext::GetPropertiesSizeMax [IN] cProps:%d\n", cProps));

    PropSize = 0;
    ULONG size = 0;

    //
    // Attempt to allocate space on the stack for a vector into which
    // the properties can be serialized.
    //

    HRESULT hr = E_OUTOFMEMORY;
    ContextProperty* pProps =
       (ContextProperty *) _alloca(sizeof(ContextProperty) * cProps);

    if (pProps != NULL)
    {
        //
        // We have the needed memory, so serialize all the properties
        // into a vector and initialize a pointer to the first
        // property.
        //

        _properties.SerializeToVector(pProps);
        ContextProperty* pCurProp = pProps;

        //
        // Now loop through all the properties and accumulate the
        // amount of space needed to marshal them.
        //

        ULONG i = 0;
        hr = S_OK;
        CPFLAGS cpflags = (fEnvoy == TRUE) ? CPFLAG_ENVOY : CPFLAG_EXPOSE;

        do
        {
            if (PropOkToMarshal(pCurProp, cpflags) == TRUE)
            {
                ULONG cb = 0;
                IUnknown* punk = pCurProp->pUnk;
                if (fEnvoy == TRUE)
                {
                    IMarshalEnvoy* pME  = NULL;
                    if (SUCCEEDED(punk->QueryInterface(IID_IMarshalEnvoy,
                                                       (void **) &pME)))
                    {
                        hr = pME->GetEnvoySizeMax(dwDestContext, &cb);
                        pME->Release();
                        size += sizeof(PROPMARSHALHEADER);
                    }
                }
                else
                {
                    hr = CoGetMarshalSizeMax(&cb,
                                             riid,
                                             punk,
                                             dwDestContext,
                                             pvDestContext,
                                             mshlflags);

                    size += sizeof(PROPMARSHALHEADER);
                }

                size += ((cb + 7) & ~7);
            }

            pCurProp++;

        } while ((++i < cProps) && SUCCEEDED(hr));
    }

    if (SUCCEEDED(hr))
        PropSize = size;

    ComDebOut((DEB_OBJECTCONTEXT,
        "CObjectContext::GetPropertiesSizeMax [OUT] PropSize:%08X\n", PropSize));
    return hr;
}


STDMETHODIMP CObjectContext::SetContextMarshaler(IContextMarshaler* pProp)
{
    if (IsFrozen())
    {
        return E_UNEXPECTED;
    }
    else
    {
        if (_pMarshalProp != NULL)
        {
            ((IUnknown*)_pMarshalProp)->Release();
            _pMarshalProp = NULL;
        }

        if (pProp != NULL)
        {
            return ((IUnknown*)pProp)->QueryInterface(IID_IMarshal, (void**) &_pMarshalProp);
        }
        else
        {
            _pMarshalProp = NULL;
            return S_OK;
        }
    }
}


STDMETHODIMP CObjectContext::GetContextMarshaler(IContextMarshaler** ppProp)
{
    if (_pMarshalProp != NULL)
    {
        return ((IUnknown*)_pMarshalProp)->QueryInterface(IID_IContextMarshaler, (void**) ppProp);
    }
    else
    {
        *ppProp = NULL;
        return S_OK;
    }
}


STDMETHODIMP CObjectContext::SetContextFlags(DWORD dwFlags)
{
    if (IsFrozen())
    {
        return E_UNEXPECTED;
    }
    else
    {
        _dwFlags |= dwFlags;
        return S_OK;
    }
}


STDMETHODIMP CObjectContext::ClearContextFlags(DWORD dwFlags)
{
    if (IsFrozen())
    {
        return E_UNEXPECTED;
    }
    else
    {
        _dwFlags &= ~dwFlags;
        return S_OK;
    }
}


STDMETHODIMP CObjectContext::GetContextFlags(DWORD *pdwFlags)
{
    if (NULL == pdwFlags)
    {
        return E_INVALIDARG;
    }
    else
    {
        *pdwFlags = _dwFlags;
        return S_OK;
    }
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::MarshalEnvoyProperties , private
//
//  Synopsis:   This method attempts to marshal each property into the
//              supplied IStream pointer.  If a property cannot be marshaled,
//              it is simply not marshaled into the stream.
//
//  Returns:    S_OK     if successful
//              E_FAIL   if an error occurs
//
//  History:    20-Apr-98   Johnstra      Created.
//
//----------------------------------------------------------------------------
HRESULT CObjectContext::MarshalEnvoyProperties(
    ULONG&            Count,
    ContextProperty*& pProps,
    IStream*          pstm,
    DWORD             dwDestContext
    )
{
    ASSERT_LOCK_NOT_HELD(gContextLock);
    Win4Assert(Count > 0);
    Win4Assert(pProps != NULL);

    HRESULT           hr        = S_OK;
    int               i         = Count;
    ContextProperty*  pCurProp  = pProps;
    PROPMARSHALHEADER PropHeader;
    LARGE_INTEGER     libMove;
    ULARGE_INTEGER    ulibHeaderPos, ulibBegin, ulibEnd;

    do
    {
        // Assume the property could not be marshaled.
        //
        BOOL fAddedProperty = FALSE;

        // Attempt to marshal the property.
        //
        IUnknown* punk = pCurProp->pUnk;
        if (PropOkToMarshal(pCurProp, CPFLAG_ENVOY) == TRUE)
        {
            // QI the property for the IMarshalEnvoy interface.  If the
            // property doesn't support IMarshalEnvoy, we can't marshal it.
            //
            IMarshalEnvoy* pME = NULL;
            if (SUCCEEDED(punk->QueryInterface(IID_IMarshalEnvoy, (void**)&pME)))
            {
                // Get the property's unmarshal CLSID.
                //
                CLSID clsid;
                hr = pME->GetEnvoyUnmarshalClass(dwDestContext, &clsid);
                if (SUCCEEDED(hr))
                {
                    // Get the stream's present seek ptr. This is where we'll
                    // reset to later to write the property header information.
                    //
                    hr = GetStreamPos(pstm, &ulibHeaderPos);
                    if (SUCCEEDED(hr))
                    {
                        // Now advance the seek ptr past where the header
                        // info will go. Note that we save the position
                        // returned - the beginning of the property data.
                        //
                        hr = AdvanceStreamPos(pstm, sizeof(PROPMARSHALHEADER),
                                              &ulibBegin);
                        if (SUCCEEDED(hr))
                        {
                            // Ask the property to marshal its data into the
                            // stream.
                            //
                            hr = pME->MarshalEnvoy(pstm, dwDestContext);
                            if (SUCCEEDED(hr))
                            {
                                // Write a header for the property into the stream.
                                //
                                hr = MarshalPropertyHeader(pstm,
                                                           clsid,
                                                           pCurProp,
                                                           ulibBegin,
                                                           ulibHeaderPos);
                                if (SUCCEEDED(hr))
                                    fAddedProperty = TRUE;
                            }
                        }
                    }
                }

                // Release the marshaling interface pointer.
                pME->Release();
            }
        }

        // If the property could not be marshaled, decrement the count.
        //
        if (fAddedProperty == FALSE)
            --Count;

        // Advance pointer to the next property.
        //
        ++pCurProp;
    } while ((--i > 0) && (SUCCEEDED(hr)));

    ASSERT_LOCK_NOT_HELD(gContextLock);
    ComDebOut((DEB_OBJECTCONTEXT,
               "CObjectContext::MarshalEnvoyProperties returning hr:%08X\n", hr));
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::MarshalProperties , private
//
//  Synopsis:   This method attempts to marshal each property into the
//              supplied IStream pointer.  If a property cannot be marshaled,
//              it is simply not marshaled into the stream.
//
//  Returns:    S_OK     if successful
//              E_FAIL   if an error occurs
//
//  History:    18-Jan-98   Johnstra      Created.
//              20-Apr-98   Johnstra      1) Broke envoy marshaling out into
//                                           separate function.
//                                        2) Use CoMarshalInterface to support
//                                           properties that need to be
//                                           standard marshaled.
//
//----------------------------------------------------------------------------
HRESULT CObjectContext::MarshalProperties(
    ULONG&            Count,
    ContextProperty*& pProps,
    IStream*          pstm,
    REFIID            riid,
    void*             pv,
    DWORD             dwDestContext,
    void*             pvDestContext,
    DWORD             mshlflags
    )
{
    ASSERT_LOCK_NOT_HELD(gContextLock);
    Win4Assert(Count > 0);
    Win4Assert(pProps != NULL);

    HRESULT           hr        = S_OK;
    int               i         = Count;
    ContextProperty*  pCurProp  = pProps;
    LARGE_INTEGER     libMove;
    ULARGE_INTEGER    ulibHeaderPos, ulibBegin, ulibEnd;

    do
    {
        // Assume the property does not get marshaled.
        //
        BOOL fAddedProperty = FALSE;

        // If the property qualifies, marshal it.
        //
        IUnknown* punk = pCurProp->pUnk;
        if (PropOkToMarshal(pCurProp, CPFLAG_EXPOSE) == TRUE)
        {
            // Get the stream's present seek ptr. This is where we'll
            // reset to later to write the property header information.
            //
            hr = GetStreamPos(pstm, &ulibHeaderPos);
            if (SUCCEEDED(hr))
            {
                // Now advance the seek ptr past where the header
                // info will go. Note that we save the position
                // returned - the beginning of the property data.
                //
                hr = AdvanceStreamPos(pstm, sizeof(PROPMARSHALHEADER), &ulibBegin);
                if (SUCCEEDED(hr))
                {
                    // Marshal the property into the stream.
                    //
                    hr = CoMarshalInterface(pstm, riid, punk, dwDestContext,
                                                pvDestContext, mshlflags);
                    if (SUCCEEDED(hr))
                    {
                        // Write a header for the property into the stream.
                        //
                        hr = MarshalPropertyHeader(pstm, CLSID_NULL, pCurProp,
                                                   ulibBegin, ulibHeaderPos);
                        if (SUCCEEDED(hr))
                            fAddedProperty = TRUE;
                    }
                }
            }
        }

        // If the property could not be marshaled, decrement the count.
        //
        if (fAddedProperty == FALSE)
            --Count;

        // Advance pointer to the next property.
        //
        ++pCurProp;
    } while ((--i > 0) && (SUCCEEDED(hr)));

    ASSERT_LOCK_NOT_HELD(gContextLock);
    ComDebOut((DEB_OBJECTCONTEXT,
               "CObjectContext::MarshalProperties returning hr:%08X\n", hr));
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::MarshalPropertyHeader , private
//
//  Synopsis:   This method marshals the per-property information required
//              to reconstitute the property when unmarshaling.  In order
//              to unmarshal, the context needs to know the CLSID of the
//              proxy, the property id, the property flags, and the number
//              of bytes padding between the end of the current property and
//              the beginning of the next one.
//
//  History:    18-Jan-98   Johnstra      Created.
//
//----------------------------------------------------------------------------
HRESULT CObjectContext::MarshalPropertyHeader(
    IStream*&           pstm,
    REFCLSID            clsid,
    ContextProperty*    pProp,
    ULARGE_INTEGER&     ulibBegin,
    ULARGE_INTEGER&     ulibHeaderPos
    )
{
    // Align the stream on the next 8-byte boundary.
    //
    HRESULT hr = (PadStream(pstm)) ? S_OK : E_FAIL;

    if (SUCCEEDED(hr))
    {
        // Get the  stream's seek pointer.  We need this to restore the stream
        // pointer after writing the header.
        //
        ULARGE_INTEGER ulibEnd;
        hr = GetStreamPos(pstm, &ulibEnd);

        if (SUCCEEDED(hr))
        {
            // Move back in the stream to the location where the header is to
            // be written.
            //
            hr = SetStreamPos(pstm, ulibHeaderPos.QuadPart, NULL);

            if (SUCCEEDED(hr))
            {
                // Initialize a header for the property.
                //
                PROPMARSHALHEADER PropHeader;
                PropHeader.clsid    = clsid;
                PropHeader.policyId = pProp->policyId;
                PropHeader.flags    = pProp->flags;
                PropHeader.cb       = (ULONG) ulibEnd.LowPart - ulibBegin.LowPart;

                // Write the header into the stream.
                //
                hr = pstm->Write(&PropHeader, sizeof(PROPMARSHALHEADER), NULL);

                if (SUCCEEDED(hr))
                {
                    // And finally, move the seek ptr back to the end of the property
                    // info.  If this succeeds, we indicate that the property was
                    // successfully marshaled.
                    //
                    hr = SetStreamPos(pstm, ulibEnd.QuadPart, NULL);
                }
            }
        }
    }

    return hr;
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::SetProperty , public
//
//  Synopsis:   Adds the supplied tuple to the internal list of context
//              properties.  If the internal list already contains a property
//              whose elements match those supplied, the call fails.
//
//  Returns:    S_OK          - if property is successfully Set/Added
//              E_INVALIDARG  - if a NULL pUnk is supplied.
//              E_FAIL        - if the object context is frozen or a property
//                              with the supplied GUID is already in the list
//              E_OUTOFMEMORY - if resources are not available
//
//  History:    19-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjectContext::SetProperty(
    REFGUID   rGUID,
    CPFLAGS   flags,
    IUnknown* pUnk
    )
{
    ComDebOut((DEB_OBJECTCONTEXT,
        "CObjectContext::SetProperty GUID:%I flags:0x08X\n", &rGUID, flags));
    ASSERT_LOCK_NOT_HELD(gContextLock);

    //
    // It is expressly forbidden to add a property with a NULL GUID.
    //

    Win4Assert(!(pUnk == NULL));
    if (pUnk == NULL)
        return E_INVALIDARG;

    //
    // If the context is frozen, the specified property is already in
    // the list, or the property isn't valid, return E_FAIL.
    //

    HRESULT hr = E_FAIL;

    if (!IsFrozen())
    {
        //
        // Do validity checks:
        // 1) If the object supports IMarshalEnvoy, CPFLAG_ENVOY must be set.
        //

        hr = S_OK;

#if 0
        // Unfortunately neither this check nor the inverse check
	// works. There are plenty of properties (Partition, Security etc)
	// that call with CPFLAG_ENVOY set, but don't implement
	// IMarshalEnvoy. There is at least one property (TransactionProperty)
	// that calls without CPFLAG_ENVOY set, but implements
	// IMarshalEnvoy. Go Figure. Sajia.
	
	IMarshalEnvoy* pME = NULL;
	if (SUCCEEDED(pUnk->QueryInterface(IID_IMarshalEnvoy,
					   (void **) &pME)))
	{
	   pME->Release();
	   if (CPFLAG_ENVOY != (flags & CPFLAG_ENVOY))
	   {
	      Win4Assert(0 && "Succeeded QI for IID_IMarshalEnvoy but CPFLAG_ENVOY flag not set in SetProperty");
	      hr = E_FAIL;
	   }
	}
#endif
        //
        // If the property passed validity checks, try to add it.
        //

        if (SUCCEEDED(hr))
        {
            // Context may have been frozen by another thread.  Set return
            // value to E_FAIL just in case.

            hr = E_FAIL;

            Win4Assert(!IsFrozen());
            if (!IsFrozen())
            {
	       if (_properties.Add(rGUID, flags, pUnk) == TRUE)
	       {
		  hr = S_OK;
	       }
            }
        }
    }

    //
    // AddRef pUnk if the Add succeeded.
    //

    if (SUCCEEDED(hr))
        pUnk->AddRef();

    ASSERT_LOCK_NOT_HELD(gContextLock);
    ComDebOut((DEB_OBJECTCONTEXT,
        "CObjectContext::SetProperty returning hr: %08X\n", hr));
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::GetProperty , public
//
//  Synopsis:   Returns the context property identified by GUID to the caller.
//
//  Returns:    S_OK
//
//  History:    19-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjectContext::GetProperty(
    REFGUID    rGUID,
    CPFLAGS*   pFlags,
    IUnknown** ppUnk
    )
{
    ComDebOut((DEB_OBJECTCONTEXT,
               "CObjectContext::GetProperty GUID:%I\n", &rGUID));
    ASSERT_LOCK_NOT_HELD(gContextLock);
    Win4Assert(ppUnk != NULL);
    Win4Assert(pFlags != NULL);

    HRESULT hr = S_OK;

    //
    // Initialize returned interface ptr to NULL.
    //

    *ppUnk = NULL;

    //
    // Take the lock if the context is not frozen.
    //

    BOOL fLocked = FALSE;
    if (!IsFrozen())
    {
        LOCK(gContextLock);
        fLocked = TRUE;
    }

    //
    // Try to get the specified property.
    //

    ContextProperty* pProp = _properties.Get(rGUID);

    //
    // Release the lock if we hold it.
    //

    if (fLocked == TRUE)
        UNLOCK(gContextLock);

    //
    // If a property was retrieved, copy the flags and interface ptr
    // into the out params and AddRef the interface ptr.
    //

    if (pProp != NULL)
    {
        *pFlags = pProp->flags;
        *ppUnk = pProp->pUnk;
        (*ppUnk)->AddRef();
    }

    ASSERT_LOCK_NOT_HELD(gContextLock);
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::RemoveProperty , public
//
//  Synopsis:   Removes the specified property from the context.
//
//  Returns:    S_OK    - If the specified property is removed.
//              E_FAIL  - If the context is frozen or if the specified property
//                        is not present on the context.
//
//  History:    19-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjectContext::RemoveProperty(
    REFGUID rGUID
    )
{
    ComDebOut((DEB_OBJECTCONTEXT,
            "CObjectContext::RemoveProperty GUID:%I\n", &rGUID));
    ASSERT_LOCK_NOT_HELD(gContextLock);

    //
    // If the context is not frozen, attempt to remove the specified property
    // from the list, release our reference to the propertys punk, and
    // delete the property.
    //

    HRESULT hr = E_FAIL;
    if (!IsFrozen())
    {
        LOCK(gContextLock);
        if (!IsFrozen())
        {
            _properties.Remove(rGUID);
            hr = S_OK;
        }
        UNLOCK(gContextLock);
    }

    ASSERT_LOCK_NOT_HELD(gContextLock);
    ComDebOut((DEB_OBJECTCONTEXT,
        "CObjectContext::RemoveProperty returning hr:%08X\n", hr));
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::EnumContextProps , public
//
//  Synopsis:   Returns an IEnumContextProps interface pointer to the caller.
//              Creates a snapshot of the internal list of context properties
//              so the enumerator will have a consitent collection to work
//              with.
//
//  Returns:    S_OK           - if the enumerator is successfully created.
//              E_OUTOFMEMORY  - if resources are not available.
//
//  History:    19-Dec-97   Johnstra      Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjectContext::EnumContextProps(
    IEnumContextProps** ppEnumContextProps
    )
{
    ComDebOut((DEB_OBJECTCONTEXT, "CObjectContext::EnumContextProps\n"));
    ASSERT_LOCK_NOT_HELD(gContextLock);
    Win4Assert(ppEnumContextProps != NULL);

    //
    // Initialize the out param to zero.
    //

    *ppEnumContextProps = NULL;

    //
    // Take the lock only if the property is not frozen.
    //

    BOOL fLocked = FALSE;
    if (!IsFrozen())
    {
        LOCK(gContextLock);
        fLocked = TRUE;
    }

    //
    // Create a snapshot of the property list for the enumerator to use.  This
    // is just an immutable vector of ContextProperty objects.
    //

    ContextProperty* pList = NULL;
    CEnumContextProps* pEnumContextProps = NULL;

    ULONG cItems = _properties.GetCount();
    if (cItems != 0)
    {
        pList = new ContextProperty[sizeof(ContextProperty) * cItems];
        if (pList != NULL)
        {
            _properties.SerializeToVector(pList);
            for (ULONG i = 0; i < cItems; i++)
                pList[i].pUnk->AddRef();
        }
        else
            goto exit_point;
    }

    //
    // Create the enumerator object.
    //

    pEnumContextProps = new CEnumContextProps(pList, cItems);
    if (pEnumContextProps && !pEnumContextProps->ListRefsOk())
    {
        delete pEnumContextProps;
        pEnumContextProps = NULL;
    }


exit_point:

    *ppEnumContextProps = pEnumContextProps;

    //
    // Release the lock if took it.
    //

    if (fLocked == TRUE)
        UNLOCK(gContextLock);

    ASSERT_LOCK_NOT_HELD(gContextLock);
    ComDebOut((DEB_OBJECTCONTEXT,
        "CObjectContext::EnumContextProps returning hr: %08X\n",
        (*ppEnumContextProps) ? S_OK : E_OUTOFMEMORY));
    return (*ppEnumContextProps != NULL) ? S_OK : E_OUTOFMEMORY;
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::Freeze , public
//
//  Synopsis:   Freezes the object context.  Once the context is frozen,
//              properties cannot be added/removed.
//
//  Returns:    S_OK
//
//  History:    19-Dec-97   Johnstra      Created.
//
//              27-Jan-98   Johnstra      Call Freeze method on all properties
//                                        that support IPolicyMaker.
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjectContext::Freeze()
{
    ComDebOut((DEB_OBJECTCONTEXT, "CObjectContext::Freeze\n"));
    ASSERT_LOCK_NOT_HELD(gContextLock);

    // If already frozen, return S_OK.

    HRESULT hr = S_OK;
    if (!IsFrozen())
    {
        // Pin down the apartment for the context now

        hr = GetCurrentComApartment(&_pApartment);
        Win4Assert(SUCCEEDED(hr) && _pApartment);

        // Freeze the context and get the number of properties.

        LOCK(gContextLock);
        ULONG cnt = 0;
        if (_properties.CreateCompareBuffer())
        {
            _dwFlags |= CONTEXTFLAGS_FROZEN;
            cnt = _properties.GetCount();
        }
        UNLOCK(gContextLock);

        if (cnt)
        {
            // Try to serialize all the properties into a vector.

            hr = E_OUTOFMEMORY;
            ContextProperty* pList =
               (ContextProperty *) _alloca(sizeof(ContextProperty) * cnt);
            if (pList != NULL)
            {
                hr = S_OK;
                _properties.SerializeToVector(pList);

                // Cycle through the properties.  Call Freeze on any
                // that implement IPolicyMaker.

                for (ULONG i = 0; i < cnt && SUCCEEDED(hr); i++)
                {
                    IUnknown* pUnk = pList[i].pUnk;
                    IPolicyMaker* pPM = NULL;
                    if (SUCCEEDED(pUnk->QueryInterface(IID_IPolicyMaker,
                                                       (void**) &pPM)))
                    {
                        hr = pPM->Freeze((IObjContext *) this);
                        pPM->Release();
                    }
                }
            }

            // Un-freeze if the properties were not successfully frozen

            if (FAILED(hr))
                _dwFlags &= ~CONTEXTFLAGS_FROZEN;
        }
    }

    ASSERT_LOCK_NOT_HELD(gContextLock);
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::DoCallback , public
//
//  Synopsis:   Calls the supplied function.  This method enables a caller
//              with a pointer to an object context to call a function from
//              that context while the caller's code is not necessarily in
//              the context.
//
//  History:    29-Jan-98   Johnstra      Created
//              19-Apr-98   Johnstra      Switches to the context's apt if
//                                        the caller is not in the same apt.
//              30-Jun-98   GopalK        Rewritten
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjectContext::DoCallback(PFNCTXCALLBACK pfnCallback,
                                        void *pParam, REFIID riid,
                                        unsigned int iMethod)
{
    ComDebOut((DEB_OBJECTCONTEXT, "CObjectContext::DoCallback [IN]\n"));

    HRESULT hr = InternalContextCallback(pfnCallback, pParam, riid, iMethod, NULL);

    ComDebOut((DEB_OBJECTCONTEXT, "CObjectContext::DoCallback [OUT] hr=0x%x\n", hr));
    return(hr);
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::ContextCallback    public
//
//  Synopsis:   This is the public version of IObjContext::DoCall. The pParam argument is
//              used to pass structured (but still arbitrary) information that can be used by
//              Context policies.
//
//              Calls the supplied function.  This method enables a caller
//              with a pointer to an object context to call a function from
//              that context while the caller's code is not necessarily in
//              the context.
//
//
//  History:    26-Jun-98   GopalK      Created
//              14-May-99   ScottRob    Split ContextCallback to make InternalContextCallback
//
//----------------------------------------------------------------------------
extern "C" GUID GUID_FinalizerCID;
extern "C" IID  IID_IEnterActivityWithNoLock;

STDMETHODIMP CObjectContext::ContextCallback(PFNCONTEXTCALL pfnCallback,
                                             ComCallData *pParam,
                                             REFIID riid,
                                             int iMethod,
                                             IUnknown *pUnk)
{
  ComDebOut((DEB_OBJECTCONTEXT, "CObjectContext::ContextCallback\n"));

  GUID guidOriginalCID;
  BOOL fNeedToRestore = FALSE;
  HRESULT hr;

  if(FinalizerBypassEnabled() && riid == IID_IEnterActivityWithNoLock)
  {
      fNeedToRestore = TRUE;
      hr = GetCurrentLogicalThreadId(&guidOriginalCID);
      if(SUCCEEDED(hr))
         SetCurrentLogicalThreadId(GUID_FinalizerCID);
      if(FAILED(hr))
         return hr;
  }

  hr = InternalContextCallback((PFNCTXCALLBACK) pfnCallback,(void*) pParam, riid, iMethod, pUnk);

  if(fNeedToRestore)
  {
     HRESULT hr2 = SetCurrentLogicalThreadId(guidOriginalCID);
     if(FAILED(hr2)) hr = hr2;
  }

  ComDebOut((DEB_OBJECTCONTEXT, "CObjectContext::ContextCallback [OUT] hr=0x%x\n", hr));
  return(hr);
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::InternalContextCallback    public
//
//  Synopsis:   Switches to the given context and calls the supplied function.
//              This is an out-of-band mechansim used by the service providers
//              to execute code inside a context while executing potentially
//              outside the context
//
//  History:    26-Jun-98   GopalK      Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjectContext::InternalContextCallback(PFNCTXCALLBACK pfnCallback,
                                             void *pParam,
                                             REFIID riid,
                                             int iMethod,
                                             IUnknown *pUnk)
{
    ComDebOut((DEB_OBJECTCONTEXT, "CObjectContext::InternalContextCallback\n"));

    ASSERT_LOCK_NOT_HELD(gContextLock);

    HRESULT hr = E_INVALIDARG;

    // Ensure that the context has been pinned to an apartment
    if(_pApartment)
    {
        // Initialize channel
        hr = InitChannelIfNecessary();
        if(SUCCEEDED(hr))
        {
            // Check for the need to switch apartments
            if(_pApartment->GetAptId() != GetCurrentApartmentId())
            {
                BOOL fCreate = TRUE;
                CPolicySet *pPS;

                Win4Assert (pfnCallback && "Must have a callback to switch between apartments");

                // Make sure the apartment we're calling into is started, if
                // we have anything to say about it.
                hr = _pApartment->StartServerExternal();
                if (SUCCEEDED(hr))
                {
                    // Obtain the RemUnk proxy
                    IRemUnknownN *pRemUnk = NULL;                
                    hr = _pApartment->GetRemUnk(&pRemUnk);

                    if(SUCCEEDED(hr))
                    {
                        // Obatin SPSNode between current context and server context
                        hr = ObtainPolicySet(GetCurrentContext(), this,
                                             PSFLAG_PROXYSIDE, &fCreate,
                                             &pPS);
                    }
                    
                    // Check for success
                    if(SUCCEEDED(hr))
                    {
                        XAptCallback callbackData;
                        COleTls Tls;
                        
                        // Save SPSNode in Tls
                        CPolicySet *pOldPS = Tls->pPS;
                        Tls->pPS = pPS;
                        
                        // Initialize
                        callbackData.pfnCallback = (PTRMEM) pfnCallback;
                        callbackData.pParam      = (PTRMEM) pParam;
                        callbackData.pServerCtx  = (PTRMEM) this;
                        callbackData.pUnk        = (PTRMEM) pUnk;
                        callbackData.iid         = riid;
                        callbackData.iMethod     = iMethod;
                        
                        // Execute the callback
                        hr = pRemUnk->DoCallback(&callbackData);
                        
                        // Restore TLS state
                        Tls->pPS = pOldPS;
                        
                        // Release SPSNode
                        pPS->Release();
                    }

                    // Release the RemUnk proxy
                    if(pRemUnk)
                        pRemUnk->Release();
                }
            }
            else
            {
                // Execute the callback
                hr = PerformCallback(this, pfnCallback, pParam, riid, iMethod, pUnk);
            }
        }
    }

    ASSERT_LOCK_NOT_HELD(gContextLock);
    ComDebOut((DEB_OBJECTCONTEXT,
               "CObjectContext::InternalContextCallback returning hr:0x%x\n", hr));
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::Reset              , private
//              CObjectContext::GetCount           , private
//              CObjectContext::GetNextProperty    , private
//
//  Synopsis:   These internal functions are used to enumerate over the
//              context's policy set.
//
//  History:    10-Jan-98   Johnstra      Created
//              24-Nov-98   JohnStra      Rewritten to use flat array
//
//----------------------------------------------------------------------------
HRESULT CObjectContext::Reset(
    void **cookie
    )
{
    if (IsFrozen())
        *(int*)cookie = _properties._iFirst;
    else
        *(int*)cookie = -1;
    return (IsFrozen()) ? S_OK : E_FAIL;
}

ULONG CObjectContext::GetCount()
{
    // don't assert FROZEN here because activation code needs to
    // call this before freezing
    return _properties.GetCount();
}

ContextProperty* CObjectContext::GetNextProperty(
    void** cookie
    )
{
    Win4Assert(IsFrozen());

    if (0 == _properties._Count)
    {
        *(int*)cookie = -1;
        return NULL;
    }

    ContextProperty *pcp = NULL;
    int slot = *(int*)cookie;
    if (slot != -1)
    {
        pcp = &_properties._pProps[_properties._pIndex[slot].idx];
        if (slot == _properties._iLast)
            *(int*)cookie = -1;
        else
            *(int*)cookie = _properties._pIndex[slot].next;
    }

    return pcp;
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::GetCurrentApartmentType , public
//
//  Synopsis:   Returns the apartment type in which the callers thread is
//              executing.
//
//  History:    9-Mar-98   Johnstra      Created
//
//----------------------------------------------------------------------------
HRESULT CObjectContext::GetCurrentApartmentType(
    APTTYPE* pAptType
    )
{
    // If the caller passed a NULL output param, return E_INVALIDARG.

    HRESULT hr = E_INVALIDARG;
    if (pAptType != NULL)
    {
        // If an apartment is not initialized for the current thread, return
        // E_FAIL.  Otherwise, map the value returned from
        // GetCurrentApartmentKind onto one of the APTTYPEs.

        hr = E_FAIL;
        if (IsApartmentInitialized())
        {
            hr = S_OK;
            APTKIND aptkind = GetCurrentApartmentKind();

            if (aptkind == APTKIND_APARTMENTTHREADED)
            {
                // This thread is in an STA.  Is it the main STA?

                if (GetCurrentThreadId() == gdwMainThreadId)
                    *pAptType = APTTYPE_MAINSTA;
                else
                    *pAptType = APTTYPE_STA;
            }
            else if (aptkind == APTKIND_NEUTRALTHREADED)
            {
                // This thread is in the NA.

                *pAptType = APTTYPE_NA;
            }
            else
            {
                // This thread is in the MTA

                *pAptType = APTTYPE_MTA;
            }
        }
    }

    return hr;
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::GetCurrentThreadType , public
//
//  Synopsis:   Returns the type of the thread the caller is executing on,
//              one has an associated message loop or not.  Basically
//              identifies whether the thread is associated with an MTA or
//              an STA.
//
//  History:    9-Mar-98   Johnstra      Created
//
//----------------------------------------------------------------------------
HRESULT CObjectContext::GetCurrentThreadType(
    THDTYPE* pThreadType
    )
{
    HRESULT hr;

    if (pThreadType == NULL)
        return E_INVALIDARG;

    hr = E_FAIL;
    if (IsApartmentInitialized())
    {
        hr = S_OK;
        *pThreadType = (IsSTAThread()) ? THDTYPE_PROCESSMESSAGES :
                                         THDTYPE_BLOCKMESSAGES;
    }

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::GetCurrentLogicalThreadId , public
//
//  Synopsis:   Returns the LogicalThreadId associated with this thread.
//
//  History:    7-Jul-99   ScottRob      Created
//
//----------------------------------------------------------------------------
HRESULT CObjectContext::GetCurrentLogicalThreadId(
    GUID* pguid
    )
{
    HRESULT hr = E_INVALIDARG;

    if (IsValidPtrOut(pguid, sizeof(*pguid)))
    {
      GUID *pguidTmp = TLSGetLogicalThread();
      if (pguidTmp != NULL)
      {
              *pguid = *pguidTmp;

              ComDebOut((DEB_OBJECTCONTEXT,
                      "CObjectContext::GetCurrentLogicalThreadId returning hr:S_OK GUID:%I\n", pguid));
              return S_OK;
      }
      hr = E_OUTOFMEMORY;
    }

    ComDebOut((DEB_OBJECTCONTEXT,
               "CObjectContext::GetCurrentLogicalThreadId returning hr:%08X\n", hr));
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::SetCurrentLogicalThreadId , public
//
//  Synopsis:   Forces the LogicalThreadId associated with this thread to a
//              particular value.
//
//  History:    7-Jul-99   ScottRob      Created
//
//----------------------------------------------------------------------------
HRESULT CObjectContext::SetCurrentLogicalThreadId(
    REFGUID rguid
    )
{
    HRESULT hr;
    ComDebOut((DEB_OBJECTCONTEXT,
            "CObjectContext::SetCurrentLogicalThreadId GUID:%I\n", &rguid));

    COleTls tls(hr);

    if (SUCCEEDED(hr)) {
      tls->LogicalThreadId = rguid;
      tls->dwFlags |= OLETLS_UUIDINITIALIZED;
    }

    return hr;
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::CreateIdentity , private
//
//  Synopsis:   Notifies all interested context properties that a new
//              identity object has been created in this context.
//
//  History:    15-Apr-98   JimLyon       Created
//
//----------------------------------------------------------------------------
void CObjectContext::CreateIdentity(
        IComObjIdentity* pID
        )
{
        void* cookie;
        ContextProperty* pProp;
        IPolicyMaker* pPM;
        HRESULT hr;


        Win4Assert(GetCurrentContext() == this);

        Reset(&cookie);
        for (;;)
        {
                pProp = GetNextProperty(&cookie);
                if (pProp == NULL)
                        break;

                if (pProp->flags & CPFLAG_MONITORSTUB)
                {
                        hr = pProp->pUnk->QueryInterface(IID_IPolicyMaker, (void**)&pPM);
                        if (hr == S_OK)
                        {
                                // we don't check return code from CreateStub; he must say S_OK
                                pPM->CreateStub(pID);
                                pPM->Release();
                        }
                }
        }
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::DestroyIdentity , private
//
//  Synopsis:   Notifies all interested context properties that a new
//              identity object is about to be destroyed in this context.
//
//  History:    15-Apr-98   JimLyon       Created
//
//----------------------------------------------------------------------------
void CObjectContext::DestroyIdentity(
        IComObjIdentity* pID
        )
{
        void* cookie;
        ContextProperty* pProp;
        IPolicyMaker* pPM;
        HRESULT hr;

        Win4Assert(GetCurrentContext() == this);

        Reset(&cookie);
        for (;;)
        {
                pProp = GetNextProperty(&cookie);
                if (pProp == NULL)
                        break;

                if (pProp->flags & CPFLAG_MONITORSTUB)
                {
                        hr = pProp->pUnk->QueryInterface(IID_IPolicyMaker, (void**)&pPM);
                        if (hr == S_OK)
                        {
                                // we don't check return code from DestroyStub; he must say S_OK
                                pPM->DestroyStub(pID);
                                pPM->Release();
                        }
                }
        }
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::Aggregate , public
//
//  Synopsis:   This method aggregates the supplied interface into the
//              object context.  It is intended for use by COM Services
//              as a way to expose existing MTS interfaces directly from
//              the object context.
//
//  History:    19-Jun-98   Johnstra      Created
//
//----------------------------------------------------------------------------
HRESULT CObjectContext::Aggregate(
    IUnknown*  pInnerUnk
    )
{
    ASSERT_LOCK_NOT_HELD(gComLock);

    // The supplied interface pointer must not be NULL.

    if (!pInnerUnk)
        return E_INVALIDARG;

    // Take lock and aggregate.

    BOOL fSet = FALSE;
    if (!_pMtsContext)
    {
        LOCK(gComLock);
        if (!_pMtsContext)
        {
            _pMtsContext = pInnerUnk;
            fSet = TRUE;
        }
        UNLOCK(gComLock);
    }

    // If we did aggregate the supplied punk, AddRef it.

    if (fSet)
        _pMtsContext->AddRef();

    return fSet ? S_OK : E_FAIL;
}


//+--------------------------------------------------------------------------
//
//  Function:   CoGetApartmentID
//
//  Synopsis:   Returns the apartment ID of the specified apartment type.
//
//  History:    9-Mar-98   Johnstra      Created
//
//----------------------------------------------------------------------------
STDAPI CoGetApartmentID(
    APTTYPE      dAptType,
    HActivator * pAptID
    )
{
    ComDebOut(( DEB_OBJECTCONTEXT, "CoGetApartmentID [IN]\n" ));
    ASSERT_LOCK_NOT_HELD( gContextLock );

    HRESULT hr;

    // If the supplied out param is NULL or if the supplied APTTYPE
    // is STA, return E_INVALIDARG.

    if (pAptID == NULL || dAptType == APTTYPE_STA)
        return E_INVALIDARG;

    if (dAptType != APTTYPE_CURRENT)
        return E_NOTIMPL;

    // Assume failure
    hr = E_FAIL;
    if (dAptType == APTTYPE_CURRENT)
    {
        // Check if the apartment is initialized
        if(IsApartmentInitialized())
        {
            hr = GetCurrentApartmentToken(*pAptID, (GetCurrentContext() == GetEmptyContext()));
        }
        else
            hr = CO_E_NOTINITIALIZED;
    }

    ASSERT_LOCK_NOT_HELD( gContextLock );
    ComDebOut(( DEB_OBJECTCONTEXT, "CoGetApartmentID [OUT]\n" ));
    return hr;
}


//--------------------------------------------------------------------
//
// Function:    CObjectContextCF_CreateInstance
//
// Params:
//              pUnkOuter - controlling unknown
//              riid      - interface id requested
//              ppv       - location for requested object
//
// Synopsis:    construct object, QI for interface.
//
// History:     22-Dec-97  JohnStra    Created
//
//---------------------------------------------------------------------
HRESULT CObjectContextCF_CreateInstance(
    IUnknown* pUnkOuter,
    REFIID    riid,
    void**    ppv)
{
    ComDebOut((DEB_OBJECTCONTEXT,
        "CObjectContextCF_CreateInstance pUnkOuter:0x%x, riid:%I, ppv:0x%x\n",
        pUnkOuter, &riid, ppv));
    ASSERT_LOCK_NOT_HELD(gContextLock);

    //
    // instantiate a CObjectContext.
    //

    HRESULT hr = E_OUTOFMEMORY;
    CObjectContext *pTemp = CObjectContext::CreateObjectContext(NULL, 0);

    //
    // if an ObjectContext was instantiated, QI for the specified interface,
    // then release the ObjectContext.
    //

    if (NULL != pTemp)
    {
        hr = pTemp->QueryInterface(riid, ppv);
        pTemp->InternalRelease();
    }

    ASSERT_LOCK_NOT_HELD(gContextLock);
    ComDebOut((DEB_OBJECTCONTEXT,
        "CObjectContextCF_CreateInstance returning hr:%08X\n", hr));
    return hr;
}


HRESULT GetStaticContextUnmarshal(IMarshal** ppIM)
{
    HRESULT hr = E_OUTOFMEMORY;
    CObjectContext *pCtx = CObjectContext::CreateObjectContext(NULL, CONTEXTFLAGS_STATICCONTEXT);
    if (pCtx)
    {
        hr = pCtx->QueryInterface(IID_IMarshal, (void **) ppIM);
        pCtx->InternalRelease();
    }
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::NotifyServerException    private
//
//  Synopsis:   Notifies all interested context properties about server exception
//
//  History:    14-Aug-98   GopalK       Created
//
//----------------------------------------------------------------------------
void CObjectContext::NotifyServerException(EXCEPTION_POINTERS *pExceptPtrs)
{
    void *pvCookie;
    ContextProperty *pCtxProp;
    IExceptionNotification *pExceptNotification;
    HRESULT hr;

    // This method can only be called from current context
    Win4Assert(GetCurrentContext() == this);

    // Enumerate properties
    Reset(&pvCookie);
    do
    {
        pCtxProp = GetNextProperty(&pvCookie);
        if(pCtxProp)
        {
            hr = pCtxProp->pUnk->QueryInterface(IID_IExceptionNotification,
                                                (void **) &pExceptNotification);
            if(SUCCEEDED(hr))
            {
                // Notify exception
                pExceptNotification->ServerException(pExceptPtrs);
                pExceptNotification->Release();
            }
        }
    } while(pCtxProp);

	// The above loop will not deliver an exception notification to the
	// aggregated mts-compatibility context prop.  Special case this:
	if (_pMtsContext)
	{
		hr = _pMtsContext->QueryInterface(IID_IExceptionNotification, (void **) &pExceptNotification);
		if (SUCCEEDED(hr))
		{
			pExceptNotification->ServerException(pExceptPtrs);
			pExceptNotification->Release();
		}
	}

    return;
}

//+--------------------------------------------------------------------------
//
//  Member:     CObjectContext::NotifyContextAbandonment    private
//
//  Synopsis:   Notifies all interested context properties about an abandoned context
//
//  History:    14-Aug-98   GopalK       Created
//
//----------------------------------------------------------------------------
void CObjectContext::NotifyContextAbandonment()
{
    void *pvCookie;
    ContextProperty *pCtxProp;
    IAbandonmentNotification *pAbandonNotification;
    HRESULT hr;

    // Enumerate properties
    Reset(&pvCookie);
    do
    {
        pCtxProp = GetNextProperty(&pvCookie);
        if(pCtxProp)
        {
            hr = pCtxProp->pUnk->QueryInterface(IID_IAbandonmentNotification,
                                                (void **) &pAbandonNotification);
            if(SUCCEEDED(hr))
            {
                // Notify abandonment
                pAbandonNotification->Abandoned (this);
                pAbandonNotification->Release();
            }
        }
    } while(pCtxProp);

	// The above loop will not deliver an exception notification to the
	// aggregated mts-compatibility context prop.  Special case this:
	if (_pMtsContext)
	{
		hr = _pMtsContext->QueryInterface(IID_IAbandonmentNotification, (void **) &pAbandonNotification);
		if (SUCCEEDED(hr))
		{
			pAbandonNotification->Abandoned (this);
			pAbandonNotification->Release();
		}
	}

    return;
}

//---------------------------------------------------------------------------
//
//  Method:     CObjectContext::GetLife
//
//  Synopsis:   Returns a the CContextLife object for this context, creating
//              it if it doesn't exist.  The CContextLife object is 
//              essentially a weak reference to the context.
//
//  History:    17-Oct-00   JohnDoty      Created
//
//---------------------------------------------------------------------------
CContextLife *CObjectContext::GetLife()
{
    CContextLife *pCtxLife = _pContextLife;
    if (NULL == pCtxLife)
    {
        // CContextLife begins with 1 reference.
        pCtxLife = new CContextLife;
        if (NULL == pCtxLife)
            return NULL;

        if (InterlockedCompareExchangePointer((void **)&_pContextLife, 
                                              pCtxLife, NULL) != NULL)
        {
            // Somebody beat me.  Oh well.  Release my instance.
            pCtxLife->Release();
            pCtxLife = _pContextLife;
        }
    }

    pCtxLife->AddRef();
    return pCtxLife;
}

#define GetPropListFromHashNode(n)      \
    CObjectContext::HashPropChainToContext((n))->GetPropertyList();

//---------------------------------------------------------------------------
//
//  Method:     CCtxPropHashTable::HashNode
//
//  Synopsis:   Computes the hash value for a given node
//
//  History:    12-Nov-98   TarunA      Created
//
//---------------------------------------------------------------------------
inline DWORD CCtxPropHashTable::HashNode(SHashChain *pNode)
{
    ASSERT_LOCK_HELD(gContextLock);

    // Preconditions: caller must hold context lock.

    CContextPropList* pList = GetPropListFromHashNode(pNode);

    // We can't be looking up contexts with ZERO properties
    // in the property based hash table

    Win4Assert(pList->GetCount() && "Hashing a null property list in context hash table");

    return pList->GetHash();
}

//---------------------------------------------------------------------------
//
//  Method:     CCtxPropHashTable::Compare
//
//  Synopsis:   Compares a node and a key.
//
//  History:    12-Nov-98   TarunA      Created
//              24-Nov-98   JohnStra    Rewritten
//
//---------------------------------------------------------------------------
BOOL CCtxPropHashTable::Compare(
    const void  *pv,
    SHashChain  *pNode,
    DWORD        dwHash
    )
{
    // Preconditions: caller must hold context lock.

    ASSERT_LOCK_HELD(gContextLock);

    CContextPropList *pList1 = GetPropListFromHashNode(pNode);
    CContextPropList *pList2 = ((CObjectContext*)pv)->GetPropertyList();

    // We can't be comparing contexts with ZERO properties in their lists
    // in the property based hash table.

    Win4Assert(pList1->GetCount() && pList2->GetCount() &&
                "Comparing null property lists in context hash table");

    return (*pList1 == *pList2);
}

//---------------------------------------------------------------------------
//
//  Method:     CCtxPropHashTable::Lookup
//
//  Synopsis:   Lookup in a property based hash table.  We want to be as
//              fast as possible here.  This means we only want to compare
//              the property lists if we must.  Before we attempt to do that
//              we make sure the two contexts we are comparing have the same
//              hash value and the same number of properties.
//
//  History:    12-Nov-98   TarunA      Created
//              24-Nov-98   JohnStra    Rewritten for speed and took out
//                                      sort.
//
//---------------------------------------------------------------------------
inline CObjectContext *CCtxPropHashTable::Lookup(
    CObjectContext *pContext
    )
{
    ComDebOut((DEB_OBJECTCONTEXT, "CCtxPropHashTable::Lookup [IN] pContext:%p\n", pContext));

    // Preconditions: caller must hold context lock and context must be frozen.

    ASSERT_LOCK_HELD(gContextLock);
    Win4Assert(pContext->IsFrozen());


    // Get the hash value and the number of properties on the supplied context.

    DWORD dwHash = pContext->GetPropertyList()->GetHash();
    int   iCount = pContext->GetPropertyList()->GetCompareCount();
    ComDebOut((DEB_OBJECTCONTEXT, "   dwHash:%d iCount:%d\n", dwHash, iCount));

    // Must be properties in the list to do a comparison.

    if (0 == pContext->GetPropertyList()->GetCount())
        return NULL;

    // Scan the appropriate hash chain for an entry that has the same hash
    // value and the same number of properties.

    CObjectContext *pKey    = NULL;
    CObjectContext *pCtxOut = NULL;
    ULONG           iHash   = dwHash % NUM_HASH_BUCKETS;
    SHashChain     *pNode   = &CCtxTable::s_CtxPropBuckets[iHash];
    pNode   = pNode->pNext;

    ComDebOut((DEB_OBJECTCONTEXT,
        "   pHead:%p pNode:%p iHash:%d\n",
        &CCtxTable::s_CtxPropBuckets[iHash], pNode, iHash));

    while (pNode != &CCtxTable::s_CtxPropBuckets[iHash])
    {
        pKey = CObjectContext::HashPropChainToContext(pNode);
        ComDebOut((DEB_OBJECTCONTEXT, "   pNode:%p pKey:%p\n", pNode, pKey));

        if (pKey->GetPropertyList()->GetHash() == dwHash &&
            pKey->GetPropertyList()->GetCompareCount() == iCount)
        {
            // We've found a context with the same hash value and the same
            // number of properties.  Let's compare the property buffers.

            if (Compare(pContext, pNode, dwHash))
            {
                // We've found a match.  We're finished.

                pCtxOut = pKey;
                break;
            }
        }

        // Advance to the next node in the hash chain.

        pNode = pNode->pNext;
    }

    // Postconditions: must still hold context lock.

    ASSERT_LOCK_HELD(gContextLock);

    ComDebOut((DEB_OBJECTCONTEXT, "CCtxPropHashTable::Lookup [OUT] pCtxOut:%p\n", pCtxOut));
    return pCtxO