 *ppvRecord = NULL;
    LK_RETCODE lkrc = LK_NO_SUCH_KEY;

    // locate the beginning of the correct bucket chain
    bool fReadLocked = _ReadOrWriteLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    CBucket* const pbkt = _FindBucket(dwSignature, false);
    IRTLASSERT(pbkt != NULL);
    IRTLASSERT(pbkt->IsReadLocked());
    _ReadOrWriteUnlock(fReadLocked);

    // walk down the bucket chain
    for (CNodeClump* pncCurr = &pbkt->m_ncFirst;
         pncCurr != NULL;
         pncCurr = pncCurr->m_pncNext)
    {
        int i;

        FOR_EACH_NODE(i)
        {
            if (pncCurr->IsEmptySlot(i))
            {
                IRTLASSERT(pncCurr->IsEmptyAndInvalid(i));
                IRTLASSERT(0 == _IsNodeCompact(pbkt));
                IRTLASSERT(pncCurr->IsLastClump());
                goto exit;
            }

            if (dwSignature != pncCurr->m_dwKeySigs[i])
                continue;

            const DWORD_PTR pnKey2 = _ExtractKey(pncCurr->m_pvNode[i]);

            if (
#ifdef LKR_EQUALKEYS
                pnKey == pnKey2  ||
#endif// LKR_EQUALKEYS
                _EqualKeys(pnKey,  pnKey2))
            {
                    *ppvRecord = pncCurr->m_pvNode[i];
                    lkrc = LK_SUCCESS;

                    // bump the reference count before handing the record
                    // back to the user.  The user should decrement the
                    // reference count when finished with this record.
                    _AddRefRecord(*ppvRecord, +1);
                    goto exit;
            }
        }
    }

  exit:
    pbkt->ReadUnlock();
    return lkrc;
} // CLKRLinearHashTable::_FindKey



// Thin wrapper for the corresponding method in CLKRLinearHashTable

LK_RETCODE
CLKRHashTable::FindKey(
    const DWORD_PTR pnKey,
    const void** ppvRecord) const
{
    if (!IsUsable())
        return m_lkrcState;
    
    if (ppvRecord == NULL)
        return LK_BAD_RECORD;
    
    LKRHASH_GLOBAL_READ_LOCK();    // usu. no-op
    DWORD     hash_val   = _CalcKeyHash(pnKey);
    SubTable* const pst  = _SubTable(hash_val);
    LK_RETCODE lkrc      = pst->_FindKey(pnKey, hash_val, ppvRecord);
    LKRHASH_GLOBAL_READ_UNLOCK();    // usu. no-op
    return lkrc;
} // CLKRLinearHashTable::FindKey



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_FindRecord
// Synopsis: Sees if the record is contained in the table
// Returns:  Pointer to the record, if it is found.
//           NULL, if the record is not found.
// Returns:  LK_SUCCESS, if record found
//           LK_BAD_RECORD, if pvRecord is invalid
//           LK_NO_SUCH_KEY, if the record was not found in the table
//           LK_UNUSABLE, if hash table not in usable state
// Note:     The record is *not* AddRef'd.
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_FindRecord(
    const void* pvRecord,    // Pointer to the record to find in the table
    DWORD       dwSignature  // hash signature
    ) const
{
    IRTLASSERT(IsUsable()  &&  pvRecord != NULL);

    LK_RETCODE lkrc = LK_NO_SUCH_KEY;

    // locate the beginning of the correct bucket chain
    bool fReadLocked = _ReadOrWriteLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    CBucket* const pbkt = _FindBucket(dwSignature, false);
    IRTLASSERT(pbkt != NULL);
    IRTLASSERT(pbkt->IsReadLocked());
    _ReadOrWriteUnlock(fReadLocked);

    const DWORD_PTR pnKey = _ExtractKey(pvRecord);
    IRTLASSERT(dwSignature == _CalcKeyHash(pnKey));

    // walk down the bucket chain
    for (CNodeClump* pncCurr = &pbkt->m_ncFirst;
         pncCurr != NULL;
         pncCurr = pncCurr->m_pncNext)
    {
        int i;

        FOR_EACH_NODE(i)
        {
            if (pncCurr->IsEmptySlot(i))
            {
                IRTLASSERT(pncCurr->IsEmptyAndInvalid(i));
                IRTLASSERT(0 == _IsNodeCompact(pbkt));
                IRTLASSERT(pncCurr->IsLastClump());
                goto exit;
            }

            if (pncCurr->m_pvNode[i] == pvRecord)
            {
                IRTLASSERT(dwSignature == pncCurr->m_dwKeySigs[i]);
                IRTLASSERT(_EqualKeys(pnKey,
                                      _ExtractKey(pncCurr->m_pvNode[i])));
                lkrc = LK_SUCCESS;

                goto exit;
            }
        }
    }

  exit:
    pbkt->ReadUnlock();
    return lkrc;
} // CLKRLinearHashTable::_FindRecord



// Thin wrapper for the corresponding method in CLKRLinearHashTable

LK_RETCODE
CLKRHashTable::FindRecord(
    const void* pvRecord) const
{
    if (!IsUsable())
        return m_lkrcState;
    
    if (pvRecord == NULL)
        return LK_BAD_RECORD;
    
    LKRHASH_GLOBAL_READ_LOCK();    // usu. no-op
    DWORD     hash_val   = _CalcKeyHash(_ExtractKey(pvRecord));
    SubTable* const pst  = _SubTable(hash_val);
    LK_RETCODE lkrc      = pst->_FindRecord(pvRecord, hash_val);
    LKRHASH_GLOBAL_READ_UNLOCK();    // usu. no-op
    return lkrc;
} // CLKRLinearHashTable::FindRecord



#ifdef LKR_DEPRECATED_ITERATORS

//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::Apply
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKRLinearHashTable::Apply(
    PFnRecordAction pfnAction,
    void*           pvState,
    LK_LOCKTYPE    lkl)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    LK_PREDICATE lkp = LKP_PERFORM;
    if (lkl == LKL_WRITELOCK)
        WriteLock();
    else
        ReadLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    DWORD dw = _Apply(pfnAction, pvState, lkl, lkp);
    if (lkl == LKL_WRITELOCK)
        WriteUnlock();
    else
        ReadUnlock();

    return dw;
} // CLKRLinearHashTable::Apply



//------------------------------------------------------------------------
// Function: CLKRHashTable::Apply
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKRHashTable::Apply(
    PFnRecordAction pfnAction,
    void*           pvState,
    LK_LOCKTYPE    lkl)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    DWORD dw = 0;
    LK_PREDICATE lkp = LKP_PERFORM;

    if (lkl == LKL_WRITELOCK)
        WriteLock();
    else
        ReadLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    if (IsValid())
    {
        for (DWORD i = 0;  i < m_cSubTables;  i++)
        {
            dw += m_palhtDir[i]->_Apply(pfnAction, pvState, lkl, lkp);
            if (lkp == LKP_ABORT  ||  lkp == LKP_PERFORM_STOP
                ||  lkp == LKP_DELETE_STOP)
                break;
        }
    }

    if (lkl == LKL_WRITELOCK)
        WriteUnlock();
    else
        ReadUnlock();

    return dw;
} // CLKRHashTable::Apply



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::ApplyIf
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKRLinearHashTable::ApplyIf(
    PFnRecordPred   pfnPredicate,
    PFnRecordAction pfnAction,
    void*           pvState,
    LK_LOCKTYPE    lkl)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    DWORD dw = 0;
    LK_PREDICATE lkp = LKP_PERFORM;

    if (lkl == LKL_WRITELOCK)
        WriteLock();
    else
        ReadLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    if (IsValid())
    {
        dw = _ApplyIf(pfnPredicate, pfnAction, pvState, lkl, lkp);
    }

    if (lkl == LKL_WRITELOCK)
        WriteUnlock();
    else
        ReadUnlock();
    return dw;
} // CLKRLinearHashTable::ApplyIf



//------------------------------------------------------------------------
// Function: CLKRHashTable::ApplyIf
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKRHashTable::ApplyIf(
    PFnRecordPred   pfnPredicate,
    PFnRecordAction pfnAction,
    void*           pvState,
    LK_LOCKTYPE    lkl)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    DWORD dw = 0;
    LK_PREDICATE lkp = LKP_PERFORM;

    if (lkl == LKL_WRITELOCK)
        WriteLock();
    else
        ReadLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    if (IsValid())
    {
        for (DWORD i = 0;  i < m_cSubTables;  i++)
        {
            dw += m_palhtDir[i]->_ApplyIf(pfnPredicate, pfnAction,
                                          pvState, lkl, lkp);
            if (lkp == LKP_ABORT  ||  lkp == LKP_PERFORM_STOP
                ||  lkp == LKP_DELETE_STOP)
                break;
        }
    }

    if (lkl == LKL_WRITELOCK)
        WriteUnlock();
    else
        ReadUnlock();

    return dw;
} // CLKRHashTable::ApplyIf



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::DeleteIf
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKRLinearHashTable::DeleteIf(
    PFnRecordPred pfnPredicate,
    void*         pvState)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    DWORD dw = 0;
    LK_PREDICATE lkp = LKP_PERFORM;

    WriteLock();
    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());
    if (IsValid())
        dw = _DeleteIf(pfnPredicate, pvState, lkp);
    WriteUnlock();

    return dw;
} // CLKRLinearHashTable::DeleteIf



//------------------------------------------------------------------------
// Function: CLKRHashTable::DeleteIf
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKRHashTable::DeleteIf(
    PFnRecordPred pfnPredicate,
    void*         pvState)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    DWORD dw = 0;
    LK_PREDICATE lkp = LKP_PERFORM;

    WriteLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    if (IsValid())
    {
        for (DWORD i = 0;  i < m_cSubTables;  i++)
        {
            dw += m_palhtDir[i]->_DeleteIf(pfnPredicate, pvState, lkp);
            if (lkp == LKP_ABORT  ||  lkp == LKP_PERFORM_STOP
                ||  lkp == LKP_DELETE_STOP)
                break;
        }
    }

    WriteUnlock();

    return dw;
} // CLKRHashTable::DeleteIf



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_Apply
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKRLinearHashTable::_Apply(
    PFnRecordAction pfnAction,
    void*           pvState,
    LK_LOCKTYPE    lkl,
    LK_PREDICATE&  rlkp)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(lkl == LKL_WRITELOCK  ?  IsWriteLocked()  :  IsReadLocked());
    return _ApplyIf(_PredTrue, pfnAction, pvState, lkl, rlkp);
} // CLKRLinearHashTable::_Apply



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_ApplyIf
// Synopsis:
// Returns:  Number of successful actions
//------------------------------------------------------------------------

DWORD
CLKRLinearHashTable::_ApplyIf(
    PFnRecordPred   pfnPredicate,
    PFnRecordAction pfnAction,
    void*           pvState,
    LK_LOCKTYPE    lkl,
    LK_PREDICATE&  rlkp)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(lkl == LKL_WRITELOCK  ?  IsWriteLocked()  :  IsReadLocked());
    IRTLASSERT(pfnPredicate != NULL  &&  pfnAction != NULL);

    if ((lkl == LKL_WRITELOCK  ?  !IsWriteLocked()  :  !IsReadLocked())
            ||  pfnPredicate == NULL  ||  pfnAction == NULL)
        return 0;

    DWORD cActions = 0;

    for (DWORD iBkt = 0;  iBkt < m_cActiveBuckets;  ++iBkt)
    {
        CBucket* const pbkt = _Bucket(iBkt);
        IRTLASSERT(pbkt != NULL);

        if (lkl == LKL_WRITELOCK)
            pbkt->WriteLock();
        else
            pbkt->ReadLock();

        for (CNodeClump* pncCurr = &pbkt->m_ncFirst, *pncPrev = NULL;
             pncCurr != NULL;
             pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
        {
            int i;

            FOR_EACH_NODE(i)
            {
                if (pncCurr->IsEmptySlot(i))
                {
                    IRTLASSERT(pncCurr->IsEmptyAndInvalid(i));
                    IRTLASSERT(0 == _IsNodeCompact(pbkt));
                    IRTLASSERT(pncCurr->IsLastClump());
                    goto unlock;
                }
                else
                {
                    rlkp = (*pfnPredicate)(pncCurr->m_pvNode[i], pvState);

                    switch (rlkp)
                    {
                    case LKP_ABORT:
                        if (lkl == LKL_WRITELOCK)
                            pbkt->WriteUnlock();
                        else
                            pbkt->ReadUnlock();
                        return cActions;
                        break;

                    case LKP_NO_ACTION:
                        // nothing to do
                        break;

                    case LKP_DELETE:
                    case LKP_DELETE_STOP:
                        if (lkl != LKL_WRITELOCK)
                        {
                            pbkt->ReadUnlock();
                            return cActions;
                        }

                        // fall through

                    case LKP_PERFORM:
                    case LKP_PERFORM_STOP:
                    {
                        LK_ACTION lka;

                        if (rlkp == LKP_DELETE  ||  rlkp == LKP_DELETE_STOP)
                        {
                            IRTLVERIFY(_DeleteNode(pbkt, pncCurr, pncPrev, i));

                            ++cActions;
                            lka = LKA_SUCCEEDED;
                        }
                        else
                        {
                            lka = (*pfnAction)(pncCurr->m_pvNode[i], pvState);

                            switch (lka)
                            {
                            case LKA_ABORT:
                                if (lkl == LKL_WRITELOCK)
                                    pbkt->WriteUnlock();
                                else
                                    pbkt->ReadUnlock();
                                return cActions;
                                
                            case LKA_FAILED:
                                // nothing to do
                                break;
                                
                            case LKA_SUCCEEDED:
                                ++cActions;
                                break;
                                
                            default:
                                IRTLASSERT(FALSE);
                                break;
                            }
                        }

                        if (rlkp == LKP_PERFORM_STOP
                            ||  rlkp == LKP_DELETE_STOP)
                        {
                            if (lkl == LKL_WRITELOCK)
                                pbkt->WriteUnlock();
                            else
                                pbkt->ReadUnlock();
                            return cActions;
                        }

                        break;
                    }

                    default:
                        IRTLASSERT(FALSE);
                        break;
                    }
                }
            }
        }

      unlock:
        if (lkl == LKL_WRITELOCK)
            pbkt->WriteUnlock();
        else
            pbkt->ReadUnlock();
    }

    return cActions;
} // CLKRLinearHashTable::_ApplyIf



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_DeleteIf
// Synopsis: Deletes all records that match the predicate
// Returns:  Count of successful deletions
//------------------------------------------------------------------------

DWORD
CLKRLinearHashTable::_DeleteIf(
    PFnRecordPred  pfnPredicate,
    void*          pvState,
    LK_PREDICATE& rlkp)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(IsWriteLocked());
    IRTLASSERT(pfnPredicate != NULL);

    if (!IsWriteLocked()  ||  pfnPredicate == NULL)
        return 0;

    DWORD cActions = 0;

    for (DWORD iBkt = 0;  iBkt < m_cActiveBuckets;  ++iBkt)
    {
        CBucket* const pbkt = _Bucket(iBkt);
        IRTLASSERT(pbkt != NULL);
        pbkt->WriteLock();

        for (CNodeClump* pncCurr = &pbkt->m_ncFirst, *pncPrev = NULL;
             pncCurr != NULL;
             pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
        {
            int i;

            FOR_EACH_NODE(i)
            {
                if (pncCurr->IsEmptySlot(i))
                {
                    IRTLASSERT(pncCurr->IsEmptyAndInvalid(i));
                    IRTLASSERT(0 == _IsNodeCompact(pbkt));
                    IRTLASSERT(pncCurr->IsLastClump());
                    goto unlock;
                }
                else
                {
                    rlkp = (*pfnPredicate)(pncCurr->m_pvNode[i], pvState);

                    switch (rlkp)
                    {
                    case LKP_ABORT:
                        pbkt->WriteUnlock();
                        return cActions;
                        break;

                    case LKP_NO_ACTION:
                        // nothing to do
                        break;

                    case LKP_PERFORM:
                    case LKP_PERFORM_STOP:
                    case LKP_DELETE:
                    case LKP_DELETE_STOP:
                    {
                        IRTLVERIFY(_DeleteNode(pbkt, pncCurr, pncPrev, i));

                        ++cActions;

                        if (rlkp == LKP_PERFORM_STOP
                            ||  rlkp == LKP_DELETE_STOP)
                        {
                            pbkt->WriteUnlock();
                            return cActions;
                        }

                        break;
                    }

                    default:
                        IRTLASSERT(FALSE);
                        break;
                    }
                }
            }
        }

      unlock:
        pbkt->WriteUnlock();
    }

    return cActions;
} // CLKRLinearHashTable::_DeleteIf

#endif // LKR_DEPRECATED_ITERATORS



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::CheckTable
// Synopsis: Verify that all records are in the right place and can be located.
// Returns:   0 => hash table is consistent
//           >0 => that many misplaced records
//           <0 => otherwise invalid
//------------------------------------------------------------------------

int
CLKRLinearHashTable::CheckTable() const
{
    if (!IsUsable())
        return LK_UNUSABLE;

    bool fReadLocked = _ReadOrWriteLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    if (!IsValid())
    {
        _ReadOrWriteUnlock(fReadLocked);
        return LK_UNUSABLE;
    }

    int       cMisplaced = 0;
    DWORD     cRecords = 0;
    int       retcode = 0;

    // Check every bucket
    for (DWORD i = 0;  i < m_cActiveBuckets;  i++)
    {
        CBucket* const pbkt = _Bucket(i);

        IRTLASSERT(pbkt != NULL);
        retcode += !(pbkt != NULL);

        pbkt->ReadLock();

        IRTLASSERT(0 == _IsNodeCompact(pbkt));

        // Walk the bucket chain
        for (CNodeClump* pncCurr = &pbkt->m_ncFirst, *pncPrev = NULL;
             pncCurr != NULL;
             pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
        {
            int j;

            FOR_EACH_NODE(j)
            {
                if (pncCurr->IsEmptySlot(j))
                {
                    IRTLASSERT(pncCurr->IsLastClump());
                    retcode += !(pncCurr->IsLastClump());

                    for (int k = j;  k != NODE_END;  k += NODE_STEP)
                    {
                        IRTLASSERT(pncCurr->IsEmptyNode(k));
                        retcode += !pncCurr->IsEmptyNode(k);
                        IRTLASSERT(pncCurr->InvalidSignature(k));
                        retcode += !pncCurr->InvalidSignature(k);
                    }
                    break;
                }

                if (!pncCurr->IsEmptySlot(j))
                {
                    ++cRecords;

                    const DWORD_PTR pnKey = _ExtractKey(pncCurr->m_pvNode[j]);

                    DWORD dwSignature = _CalcKeyHash(pnKey);
                    IRTLASSERT(dwSignature != HASH_INVALID_SIGNATURE);
                    retcode += !(dwSignature != HASH_INVALID_SIGNATURE);
                    IRTLASSERT(dwSignature == pncCurr->m_dwKeySigs[j]);
                    retcode += !(dwSignature == pncCurr->m_dwKeySigs[j]);

                    DWORD address = _BucketAddress(dwSignature);
                    IRTLASSERT(address == i);
                    retcode += !(address == i);

                    if (address != i || dwSignature != pncCurr->m_dwKeySigs[j])
                        cMisplaced++;
                }
                else // pncCurr->IsEmptySlot(j)
                {
                    IRTLASSERT(pncCurr->IsEmptyAndInvalid(j));
                    retcode += !pncCurr->IsEmptyAndInvalid(j);
                }
            }
            if (pncPrev != NULL)
            {
                IRTLASSERT(pncPrev->m_pncNext == pncCurr);
                retcode += !(pncPrev->m_pncNext == pncCurr);
            }
        }
        pbkt->ReadUnlock();
    }

    if (cRecords != m_cRecords)
        ++retcode;

    IRTLASSERT(cRecords == m_cRecords);
    retcode += !(cRecords == m_cRecords);

    if (cMisplaced > 0)
        retcode = cMisplaced;

    IRTLASSERT(cMisplaced == 0);
    retcode += !(cMisplaced == 0);

    _ReadOrWriteUnlock(fReadLocked);

    return retcode;
} // CheckTable



//------------------------------------------------------------------------
// Function: CLKRHashTable::CheckTable
// Synopsis: Verify that all records are in the right place and can be located.
// Returns:   0 => hash table is consistent
//           >0 => that many misplaced records
//           <0 => otherwise invalid
//------------------------------------------------------------------------
int
CLKRHashTable::CheckTable() const
{
    if (!IsUsable())
        return LK_UNUSABLE;

    int retcode = 0;

    for (DWORD i = 0;  i < m_cSubTables;  i++)
        retcode += m_palhtDir[i]->CheckTable();

    return retcode;
} // CLKRHashTable::CheckTable



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_Clear
// Synopsis: Remove all data from the table
//------------------------------------------------------------------------

void
CLKRLinearHashTable::_Clear(
    bool fShrinkDirectory)  // Shrink to min size but don't destroy entirely?
{
    if (!IsUsable())
        return;

    IRTLASSERT(IsWriteLocked());

#ifdef _DEBUG
    DWORD cDeleted = 0;
    DWORD cOldRecords = m_cRecords;
#endif // _DEBUG

    for (DWORD iBkt = 0;  iBkt < m_cActiveBuckets;  ++iBkt)
    {
        CBucket* const pbkt = _Bucket(iBkt);
        IRTLASSERT(pbkt != NULL);
        pbkt->WriteLock();

        IRTLASSERT(0 == _IsNodeCompact(pbkt));

        for (CNodeClump* pncCurr = &pbkt->m_ncFirst, *pncPrev = NULL;
             pncCurr != NULL;
             )
        {
            int i;

            FOR_EACH_NODE(i)
            {

                if (pncCurr->IsEmptySlot(i))
                {
                    IRTLASSERT(pncCurr->IsEmptyAndInvalid(i));
                    IRTLASSERT(pncCurr->IsLastClump());
                    break;
                }
                else
                {
                    _AddRefRecord(pncCurr->m_pvNode[i], -1);
                    pncCurr->m_pvNode[i]    = NULL;
                    pncCurr->m_dwKeySigs[i] = HASH_INVALID_SIGNATURE;
                    m_cRecords--;

#ifdef _DEBUG
                    ++cDeleted;
#endif // _DEBUG
                }
            } // for (i ...

            pncPrev = pncCurr;
            pncCurr = pncCurr->m_pncNext;
            pncPrev->m_pncNext = NULL;

            if (pncPrev != &pbkt->m_ncFirst)
                _FreeNodeClump(pncPrev);
        } // for (pncCurr ...

        pbkt->WriteUnlock();
    } // for (iBkt ...

    IRTLASSERT(m_cRecords == 0  &&  cDeleted == cOldRecords);

    // delete all (or all but the first MIN_DIRSIZE) segments
    for (DWORD iSeg = fShrinkDirectory  ?  MIN_DIRSIZE * m_dwSegSize  :  0;
         iSeg < m_cActiveBuckets;
         iSeg += m_dwSegSize)
    {
        _FreeSegment(_Segment(iSeg));
        _Segment(iSeg) = NULL;
    }

    // reduce directory of segments to minimum size
    if (fShrinkDirectory)
    {
        if (m_cDirSegs > MIN_DIRSIZE)
        {
            CDirEntry* paDirSegsNew = _AllocateSegmentDirectory(MIN_DIRSIZE);
            
            if (paDirSegsNew != NULL)
            {
                for (DWORD j = 0;  j < MIN_DIRSIZE;  j++)
                    paDirSegsNew[j] = m_paDirSegs[j];
                for (j = 0;  j < m_cDirSegs;  j++)
                    m_paDirSegs[j].m_pseg = NULL;
                
                _FreeSegmentDirectory(m_paDirSegs);
                
                m_paDirSegs = paDirSegsNew;
                m_cDirSegs  = MIN_DIRSIZE;
            }

            m_nLevel         = m_dwSegBits;
            m_cActiveBuckets = MIN_DIRSIZE * m_dwSegSize;
            m_dwBktAddrMask0 = m_dwSegMask;
            m_dwBktAddrMask1 = (m_dwBktAddrMask0 << 1) | 1;

            for (DWORD tmp = m_cActiveBuckets >> m_dwSegBits;
                 tmp > 1;
                 tmp >>= 1)
            {
                ++m_nLevel;
                m_dwBktAddrMask0 =  m_dwBktAddrMask1;
                m_dwBktAddrMask1 = (m_dwBktAddrMask0 << 1) | 1;
            }
            
            IRTLASSERT(_H1(m_cActiveBuckets) == m_cActiveBuckets);
            m_iExpansionIdx = m_cActiveBuckets & m_dwBktAddrMask0;
        }

#ifdef _DEBUG
        for (DWORD iSeg = 0;  iSeg < m_cActiveBuckets;  iSeg += m_dwSegSize)
        {
            IRTLASSERT(_Segment(iSeg) != NULL);
        }
#endif // _DEBUG
    }

    else // !fShrinkDirectory
    {
        _FreeSegmentDirectory(m_paDirSegs);
        m_paDirSegs = NULL;
        m_cDirSegs = m_nLevel = m_cActiveBuckets = m_iExpansionIdx = 0;
        m_dwBktAddrMask0 = 1;
        m_dwBktAddrMask1 = (m_dwBktAddrMask0 << 1) | 1;
    }
} // CLKRLinearHashTable::_Clear



//------------------------------------------------------------------------
// Function: CLKRHashTable::Clear
// Synopsis: Remove all data from the table
//------------------------------------------------------------------------

void
CLKRHashTable::Clear()
{
    WriteLock();
    for (DWORD i = 0;  i < m_cSubTables;  i++)
        m_palhtDir[i]->_Clear(true);
    WriteUnlock();
} // CLKRHashTable::Clear



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::GetStatistics
// Synopsis: Gather statistics about the table
//------------------------------------------------------------------------

CLKRHashTableStats
CLKRLinearHashTable::GetStatistics() const
{
    CLKRHashTableStats stats;

    if (!IsUsable())
        return stats;

    if (m_paDirSegs != NULL)
    {
        stats.RecordCount   = m_cRecords;
        stats.TableSize     = m_cActiveBuckets;
        stats.SplitFactor   = static_cast<double>(m_iExpansionIdx)
                              / (1 << m_nLevel);
        stats.DirectorySize = m_cDirSegs;
        stats.NodeClumpSize = NODES_PER_CLUMP;
        stats.CBucketSize   = sizeof(CBucket);

#ifdef LOCK_INSTRUMENTATION
        stats.m_alsBucketsAvg.m_nContentions     = 0;
        stats.m_alsBucketsAvg.m_nSleeps          = 0;
        stats.m_alsBucketsAvg.m_nContentionSpins = 0;
        stats.m_alsBucketsAvg.m_nAverageSpins    = 0;
        stats.m_alsBucketsAvg.m_nReadLocks       = 0;
        stats.m_alsBucketsAvg.m_nWriteLocks      = 0;
        stats.m_alsBucketsAvg.m_nItems           = 0;
#endif // LOCK_INSTRUMENTATION

        int empty = 0;
        int totacc = 0;
        int low_count = 0;
        int high_count = 0;
        int max_length = 0;

        for (DWORD i = 0;  i < m_cActiveBuckets;  i++)
        {
            int acc = 0;

            for (CNodeClump* pncCurr = &_Bucket(i)->m_ncFirst;
                 pncCurr != NULL;
                 pncCurr = pncCurr->m_pncNext)
            {
                int j;

                FOR_EACH_NODE(j)
                {
                    if (!pncCurr->IsEmptySlot(j))
                    {
                        acc++;
                        totacc += acc;
                        int iBucketIndex = stats.BucketIndex(acc);
                        ++stats.m_aBucketLenHistogram[iBucketIndex];
                    }
                }
            }

#ifdef LOCK_INSTRUMENTATION
            CLockStatistics ls = _Bucket(i)->LockStats();

            stats.m_alsBucketsAvg.m_nContentions     += ls.m_nContentions;
            stats.m_alsBucketsAvg.m_nSleeps          += ls.m_nSleeps;
            stats.m_alsBucketsAvg.m_nContentionSpins += ls.m_nContentionSpins;
            stats.m_alsBucketsAvg.m_nAverageSpins    += ls.m_nAverageSpins;
            stats.m_alsBucketsAvg.m_nReadLocks       += ls.m_nReadLocks;
            stats.m_alsBucketsAvg.m_nWriteLocks      += ls.m_nWriteLocks;
            stats.m_alsBucketsAvg.m_nItems           ++;
#endif // LOCK_INSTRUMENTATION

            max_length = max(max_length, acc);
            if (acc == 0)
                empty++;

            if (_H0(i) < m_iExpansionIdx)
            {
                low_count += acc;
            }
            else
            {
                high_count += acc;
            }
        }

        stats.LongestChain = max_length;
        stats.EmptySlots   = empty;

        if (m_cActiveBuckets > 0)
        {
            if (m_cRecords > 0)
            {
                double x=static_cast<double>(m_iExpansionIdx) /(1 << m_nLevel);
                double alpha= static_cast<double>(m_cRecords)/m_cActiveBuckets;
                double low_sl = 0.0;
                double high_sl = 0.0;
                
                stats.AvgSearchLength= static_cast<double>(totacc) /m_cRecords;
                stats.ExpSearchLength  = 1 + alpha * 0.25 * (2 + x - x*x);
                
                if (m_iExpansionIdx > 0)
                    low_sl  = static_cast<double>(low_count)
                        / (2.0 * m_iExpansionIdx);
                if (m_cActiveBuckets - 2 * m_iExpansionIdx > 0)
                    high_sl = static_cast<double>(high_count)
                        / (m_cActiveBuckets - 2.0 * m_iExpansionIdx);
                stats.AvgUSearchLength = low_sl * x + high_sl * (1.0 - x);
                stats.ExpUSearchLength = alpha * 0.5 * (2 + x - x*x);
            }

#ifdef LOCK_INSTRUMENTATION
            stats.m_alsBucketsAvg.m_nContentions     /= m_cActiveBuckets;
            stats.m_alsBucketsAvg.m_nSleeps          /= m_cActiveBuckets;
            stats.m_alsBucketsAvg.m_nContentionSpins /= m_cActiveBuckets;
            stats.m_alsBucketsAvg.m_nAverageSpins    /= m_cActiveBuckets;
            stats.m_alsBucketsAvg.m_nReadLocks       /= m_cActiveBuckets;
            stats.m_alsBucketsAvg.m_nWriteLocks      /= m_cActiveBuckets;
#endif // LOCK_INSTRUMENTATION

        }
        else
        {
            stats.AvgSearchLength  = 0.0;
            stats.ExpSearchLength  = 0.0;
            stats.AvgUSearchLength = 0.0;
            stats.ExpUSearchLength = 0.0;
        }
    }

#ifdef LOCK_INSTRUMENTATION
    stats.m_gls     = TableLock::GlobalStatistics();
    CLockStatistics ls = _LockStats();

    stats.m_alsTable.m_nContentions     = ls.m_nContentions;
    stats.m_alsTable.m_nSleeps          = ls.m_nSleeps;
    stats.m_alsTable.m_nContentionSpins = ls.m_nContentionSpins;
    stats.m_alsTable.m_nAverageSpins    = ls.m_nAverageSpins;
    stats.m_alsTable.m_nReadLocks       = ls.m_nReadLocks;
    stats.m_alsTable.m_nWriteLocks      = ls.m_nWriteLocks;
    stats.m_alsTable.m_nItems           = 1;
#endif // LOCK_INSTRUMENTATION

    return stats;
} // CLKRLinearHashTable::GetStatistics



//------------------------------------------------------------------------
// Function: CLKRHashTable::GetStatistics
// Synopsis: Gather statistics about the table
//------------------------------------------------------------------------

CLKRHashTableStats
CLKRHashTable::GetStatistics() const
{
    CLKRHashTableStats hts;

    if (!IsUsable())
        return hts;

    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        CLKRHashTableStats stats = m_palhtDir[i]->GetStatistics();

        hts.RecordCount +=      stats.RecordCount;
        hts.TableSize +=        stats.TableSize;
        hts.DirectorySize +=    stats.DirectorySize;
        hts.LongestChain =      max(hts.LongestChain, stats.LongestChain);
        hts.EmptySlots +=       stats.EmptySlots;
        hts.SplitFactor +=      stats.SplitFactor;
        hts.AvgSearchLength +=  stats.AvgSearchLength;
        hts.ExpSearchLength +=  stats.ExpSearchLength;
        hts.AvgUSearchLength += stats.AvgUSearchLength;
        hts.ExpUSearchLength += stats.ExpUSearchLength;
        hts.NodeClumpSize =     stats.NodeClumpSize;
        hts.CBucketSize =       stats.CBucketSize;

        for (int j = 0;  j < CLKRHashTableStats::MAX_BUCKETS;  ++j)
            hts.m_aBucketLenHistogram[j] += stats.m_aBucketLenHistogram[j];

#ifdef LOCK_INSTRUMENTATION
        hts.m_alsTable.m_nContentions     += stats.m_alsTable.m_nContentions;
        hts.m_alsTable.m_nSleeps          += stats.m_alsTable.m_nSleeps;
        hts.m_alsTable.m_nContentionSpins
            += stats.m_alsTable.m_nContentionSpins;
        hts.m_alsTable.m_nAverageSpins    += stats.m_alsTable.m_nAverageSpins;
        hts.m_alsTable.m_nReadLocks       += stats.m_alsTable.m_nReadLocks;
        hts.m_alsTable.m_nWriteLocks      += stats.m_alsTable.m_nWriteLocks;
        
        hts.m_alsBucketsAvg.m_nContentions
            += stats.m_alsBucketsAvg.m_nContentions;
        hts.m_alsBucketsAvg.m_nSleeps
            += stats.m_alsBucketsAvg.m_nSleeps;
        hts.m_alsBucketsAvg.m_nContentionSpins
            += stats.m_alsBucketsAvg.m_nContentionSpins;
        hts.m_alsBucketsAvg.m_nAverageSpins
            += stats.m_alsBucketsAvg.m_nAverageSpins;
        hts.m_alsBucketsAvg.m_nReadLocks
            += stats.m_alsBucketsAvg.m_nReadLocks;
        hts.m_alsBucketsAvg.m_nWriteLocks
            += stats.m_alsBucketsAvg.m_nWriteLocks;
        hts.m_alsBucketsAvg.m_nItems
            += stats.m_alsBucketsAvg.m_nItems;
        
        hts.m_gls = stats.m_gls;
#endif // LOCK_INSTRUMENTATION
    }

    // Average out the subtables statistics.  (Does this make sense
    // for all of these fields?)
    hts.DirectorySize /=    m_cSubTables;
    hts.SplitFactor /=      m_cSubTables;
    hts.AvgSearchLength /=  m_cSubTables;
    hts.ExpSearchLength /=  m_cSubTables;
    hts.AvgUSearchLength /= m_cSubTables;
    hts.ExpUSearchLength /= m_cSubTables;

#ifdef LOCK_INSTRUMENTATION
    hts.m_alsTable.m_nContentions     /= m_cSubTables;
    hts.m_alsTable.m_nSleeps          /= m_cSubTables;
    hts.m_alsTable.m_nContentionSpins /= m_cSubTables;
    hts.m_alsTable.m_nAverageSpins    /= m_cSubTables;
    hts.m_alsTable.m_nReadLocks       /= m_cSubTables;
    hts.m_alsTable.m_nWriteLocks      /= m_cSubTables;
    hts.m_alsTable.m_nItems            = m_cSubTables;

    hts.m_alsBucketsAvg.m_nContentions     /= m_cSubTables;
    hts.m_alsBucketsAvg.m_nSleeps          /= m_cSubTables;
    hts.m_alsBucketsAvg.m_nContentionSpins /= m_cSubTables;
    hts.m_alsBucketsAvg.m_nAverageSpins    /= m_cSubTables;
    hts.m_alsBucketsAvg.m_nReadLocks       /= m_cSubTables;
    hts.m_alsBucketsAvg.m_nWriteLocks      /= m_cSubTables;
#endif // LOCK_INSTRUMENTATION

    return hts;
} // CLKRHashTable::GetStatistics



//-----------------------------------------------------------------------
// Function: CLKRLinearHashTable::_SetSegVars
// Synopsis: sets the size-specific segment variables
//-----------------------------------------------------------------------

void
CLKRLinearHashTable::_SetSegVars(
    LK_TABLESIZE lkts)
{
    switch (lkts)
    {
    case LK_SMALL_TABLESIZE:
        m_lkts      = LK_SMALL_TABLESIZE;
        m_dwSegBits = CSmallSegment::SEGBITS;
        m_dwSegSize = CSmallSegment::SEGSIZE;
        m_dwSegMask = CSmallSegment::SEGMASK;
        break;
        
    default:
        IRTLASSERT(FALSE);
        // fall-through
        
    case LK_MEDIUM_TABLESIZE:
        m_lkts      = LK_MEDIUM_TABLESIZE;
        m_dwSegBits = CMediumSegment::SEGBITS;
        m_dwSegSize = CMediumSegment::SEGSIZE;
        m_dwSegMask = CMediumSegment::SEGMASK;
        break;
        
    case LK_LARGE_TABLESIZE:
        m_lkts      = LK_LARGE_TABLESIZE;
        m_dwSegBits = CLargeSegment::SEGBITS;
        m_dwSegSize = CLargeSegment::SEGSIZE;
        m_dwSegMask = CLargeSegment::SEGMASK;
        break;
    }

    m_dwBktAddrMask0 = m_dwSegMask;
    m_dwBktAddrMask1 = (m_dwBktAddrMask0 << 1) | 1;
    m_nLevel         = m_dwSegBits;
} // CLKRLinearHashTable::_SetSegVars




#include <stdlib.h>

LONG g_cAllocDirEntry = 0;
LONG g_cAllocNodeClump = 0;
LONG g_cAllocSmallSegment = 0;
LONG g_cAllocMediumSegment = 0;
LONG g_cAllocLargeSegment = 0;

extern "C"
__declspec(dllexport)
bool
GetAllocCounters()
{
return true;
}

// #define LKR_RANDOM_MEMORY_FAILURES 1000  // 1..RAND_MAX (32767)

// Memory allocation wrappers to allow us to simulate allocation
// failures during testing

//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_AllocateSegmentDirectory
// Synopsis: 
//------------------------------------------------------------------------

CLKRLinearHashTable::CDirEntry* const
CLKRLinearHashTable::_AllocateSegmentDirectory(
    size_t n)
{
#ifdef LKR_RANDOM_MEMORY_FAILURES
    if (rand() < LKR_RANDOM_MEMORY_FAILURES)
        return NULL;
#endif
    // InterlockedIncrement(&g_cAllocDirEntry);
    return new CDirEntry [n];
}



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_FreeSegmentDirectory
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::_FreeSegmentDirectory(
    CLKRLinearHashTable::CDirEntry* paDirSegs)
{
    delete [] paDirSegs;
    return true;
}



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_AllocateNodeClump
// Synopsis: 
//------------------------------------------------------------------------

CLKRLinearHashTable::CNodeClump* const
CLKRLinearHashTable::_AllocateNodeClump()
{
#ifdef LKR_RANDOM_MEMORY_FAILURES
    if (rand() < LKR_RANDOM_MEMORY_FAILURES)
        return NULL;
#endif
    // InterlockedIncrement(&g_cAllocNodeClump);
    return new CNodeClump;
}



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_FreeNodeClump
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::_FreeNodeClump(
    CLKRLinearHashTable::CNodeClump* pnc)
{
    delete pnc;
    return true;
}



//-----------------------------------------------------------------------
// Function: CLKRLinearHashTable::_AllocateSegment
// Synopsis: creates a new segment of the approriate size
// Output:   pointer to the new segment; NULL => failure
//-----------------------------------------------------------------------

CLKRLinearHashTable::CSegment* const
CLKRLinearHashTable::_AllocateSegment(
    ) const
{
#ifdef LKR_RANDOM_MEMORY_FAILURES
    if (rand() < LKR_RANDOM_MEMORY_FAILURES)
        return NULL;
#endif
    CSegment* pseg = NULL;

    switch (m_lkts)
    {
    case LK_SMALL_TABLESIZE:
#ifdef LKRHASH_ALLOCATOR_NEW
        IRTLASSERT(CLKRLinearHashTable::CSmallSegment::sm_palloc != NULL);
#endif
        // InterlockedIncrement(&g_cAllocSmallSegment);
        pseg = new CSmallSegment;
        break;
        
    default:
        IRTLASSERT(FALSE);
        // fall-through
        
    case LK_MEDIUM_TABLESIZE:
#ifdef LKRHASH_ALLOCATOR_NEW
        IRTLASSERT(CLKRLinearHashTable::CMediumSegment::sm_palloc != NULL);
#endif
        // InterlockedIncrement(&g_cAllocMediumSegment);
        pseg = new CMediumSegment;
        break;
        
    case LK_LARGE_TABLESIZE:
#ifdef LKRHASH_ALLOCATOR_NEW
        IRTLASSERT(CLKRLinearHashTable::CLargeSegment::sm_palloc != NULL);
#endif
        // InterlockedIncrement(&g_cAllocLargeSegment);
        pseg = new CLargeSegment;
        break;
    }

    IRTLASSERT(pseg != NULL);

    if (pseg != NULL  &&  BucketLock::PerLockSpin() == LOCK_INDIVIDUAL_SPIN)
    {
        for (DWORD i = 0;  i < m_dwSegSize;  ++i)
            pseg->Slot(i).SetSpinCount(m_wBucketLockSpins);
    }

    return pseg;
} // CLKRLinearHashTable::_AllocateSegment



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_FreeSegment
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::_FreeSegment(
    CLKRLinearHashTable::CSegment* pseg) const
{
#ifdef LKR_OLD_SEGMENT
    delete pseg;

#else // !LKR_OLD_SEGMENT
    switch (m_lkts)
    {
    case LK_SMALL_TABLESIZE:
        delete static_cast<CSmallSegment*>(pseg);
        break;
        
    default:
        IRTLASSERT(FALSE);
        // fall-through
        
    case LK_MEDIUM_TABLESIZE:
        delete static_cast<CMediumSegment*>(pseg);
        break;
        
    case LK_LARGE_TABLESIZE:
        delete static_cast<CLargeSegment*>(pseg);
        break;
    }
#endif // !LKR_OLD_SEGMENT

    return true;
}



//------------------------------------------------------------------------
// Function: CLKRHashTable::_AllocateSubTableArray
// Synopsis: 
//------------------------------------------------------------------------

CLKRHashTable::SubTable** const
CLKRHashTable::_AllocateSubTableArray(
    size_t n)
{
#ifdef LKR_RANDOM_MEMORY_FAILURES
    if (rand() < LKR_RANDOM_MEMORY_FAILURES)
        return NULL;
#endif
    return new SubTable* [n];
}



//------------------------------------------------------------------------
// Function: CLKRHashTable::_FreeSubTableArray
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRHashTable::_FreeSubTableArray(
    CLKRHashTable::SubTable** palht)
{
    delete [] palht;
    return true;
}



//------------------------------------------------------------------------
// Function: CLKRHashTable::_AllocateSubTable
// Synopsis: 
//------------------------------------------------------------------------

CLKRHashTable::SubTable* const
CLKRHashTable::_AllocateSubTable(
    LPCSTR          pszName,        // An identifier for debugging
    PFnExtractKey   pfnExtractKey,  // Extract key from record
    PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
    PFnEqualKeys    pfnEqualKeys,   // Compare two keys
    PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
    double          maxload,        // Upperbound on average chain length
    DWORD           initsize,       // Initial size of hash table.
    CLKRHashTable*  phtParent       // Owning table.
    )
{
#ifdef LKR_RANDOM_MEMORY_FAILURES
    if (rand() < LKR_RANDOM_MEMORY_FAILURES)
        return NULL;
#endif
    return new SubTable(pszName, pfnExtractKey, pfnCalcKeyHash,
                        pfnEqualKeys,  pfnAddRefRecord,
                        maxload, initsize, phtParent);
}



//------------------------------------------------------------------------
// Function: CLKRHashTable::_FreeSubTable
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRHashTable::_FreeSubTable(
    CLKRHashTable::SubTable* plht)
{
    delete plht;
    return true;
}




//-----------------------------------------------------------------------
// Function: CLKRLinearHashTable::_Expand
// Synopsis: Expands the table by one bucket. Done by splitting the
//           bucket pointed to by m_iExpansionIdx.
// Output:   LK_SUCCESS, if expansion was successful.
//           LK_ALLOC_FAIL, if expansion failed due to lack of memory.
//-----------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_Expand()
{
    if (m_cActiveBuckets >= MAX_DIRSIZE * m_dwSegSize - 1)
        return LK_ALLOC_FAIL;  // table is not allowed to grow any more

    WriteLock();

    // double segment directory size if necessary
    if (m_cActiveBuckets >= m_cDirSegs * m_dwSegSize)
    {
        IRTLASSERT(m_cDirSegs < MAX_DIRSIZE);
        DWORD cDirSegsNew = (m_cDirSegs == 0) ? MIN_DIRSIZE : m_cDirSegs << 1;
        CDirEntry* paDirSegsNew = _AllocateSegmentDirectory(cDirSegsNew);

        if (paDirSegsNew != NULL)
        {
            for (DWORD j = 0;  j < m_cDirSegs;  j++)
            {
                paDirSegsNew[j] = m_paDirSegs[j];
                m_paDirSegs[j].m_pseg = NULL;
            }

            _FreeSegmentDirectory(m_paDirSegs);
            m_paDirSegs = paDirSegsNew;
            m_cDirSegs  = cDirSegsNew;
        }
        else
        {
            WriteUnlock();
            return LK_ALLOC_FAIL;  // expansion failed
        }
    }

    // locate the new bucket, creating a new segment if necessary
    ++m_cActiveBuckets;

    DWORD     dwOldBkt = m_iExpansionIdx;
    DWORD     dwNewBkt = (1 << m_nLevel) | dwOldBkt;

    IRTLASSERT(dwOldBkt < m_cActiveBuckets);
    IRTLASSERT(dwNewBkt < m_cActiveBuckets);

    IRTLASSERT(_Segment(dwOldBkt) != NULL);
    CSegment* psegNew  = _Segment(dwNewBkt);

    if (psegNew == NULL)
    {
        psegNew = _AllocateSegment();
        if (psegNew == NULL)
        {
            --m_cActiveBuckets;
            WriteUnlock();
            return LK_ALLOC_FAIL;  // expansion failed
        }
        _Segment(dwNewBkt) = psegNew;
    }

    // prepare to relocate records to the new bucket
    CBucket* pbktOld = _Bucket(dwOldBkt);
    CBucket* pbktNew = _Bucket(dwNewBkt);

    // get locks on the two buckets involved
    pbktOld->WriteLock();
    pbktNew->WriteLock();

    // Now work out if we need to allocate any extra CNodeClumps.  We do
    // this up front, before calling _SplitRecordSet, as it's hard to
    // gracefully recover from the depths of that routine should we run
    // out of memory.

    CNodeClump* pncFreeList = NULL;
    LK_RETCODE  lkrc        = LK_SUCCESS;

    // If the old bucket has more than one CNodeClump, there's a chance that
    // we'll need extra CNodeClumps in the new bucket too.  If it doesn't,
    // we definitely won't. One CNodeClump is enough to prime the freelist.
    if (!pbktOld->m_ncFirst.IsLastClump())
    {
        pncFreeList = _AllocateNodeClump();
        if (pncFreeList == NULL)
        {
            lkrc = LK_ALLOC_FAIL;
            --m_cActiveBuckets;
        }
    }

    // adjust expansion pointer, level, and mask
    if (lkrc == LK_SUCCESS)
    {
        if (++m_iExpansionIdx == (1U << m_nLevel))
        {
            ++m_nLevel;
            m_iExpansionIdx = 0;
            m_dwBktAddrMask0 = (m_dwBktAddrMask0 << 1) | 1;
            // m_dwBktAddrMask0 = 00011..111
            IRTLASSERT((m_dwBktAddrMask0 & (m_dwBktAddrMask0+1)) == 0);
            m_dwBktAddrMask1 = (m_dwBktAddrMask0 << 1) | 1;
            IRTLASSERT((m_dwBktAddrMask1 & (m_dwBktAddrMask1+1)) == 0);
        }
    }

    DWORD iExpansionIdx = m_iExpansionIdx;  // save to avoid race conditions
    DWORD dwBktAddrMask = m_dwBktAddrMask0; // ditto

    // Release the table lock before doing the actual relocation
    WriteUnlock();

    if (lkrc == LK_SUCCESS)
    {
        lkrc = _SplitRecordSet(&pbktOld->m_ncFirst, &pbktNew->m_ncFirst,
                               iExpansionIdx, dwBktAddrMask,
                               dwNewBkt, pncFreeList);
    }

    pbktNew->WriteUnlock();
    pbktOld->WriteUnlock();

    return lkrc;
} // CLKRLinearHashTable::_Expand



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_SplitRecordSet
// Synopsis: Split records between the old and new buckets.
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_SplitRecordSet(
    CNodeClump* pncOldTarget,
    CNodeClump* pncNewTarget,
    DWORD       iExpansionIdx,
    DWORD       dwBktAddrMask,
    DWORD       dwNewBkt,
    CNodeClump* pncFreeList     // list of free nodes available for reuse
    )
{
    CNodeClump  ncFirst = *pncOldTarget;    // save head of old target chain
    CNodeClump* pncOldList = &ncFirst;
    CNodeClump* pncTmp;
    int         iOldSlot = NODE_BEGIN;
    int         iNewSlot = NODE_BEGIN;

    // clear target buckets
    pncOldTarget->Clear();
    pncNewTarget->Clear();

    // scan through the old bucket chain and decide where to move each record
    while (pncOldList != NULL)
    {
        int i;

        FOR_EACH_NODE(i)
        {
            // node already empty?
            if (pncOldList->IsEmptySlot(i))
            {
                IRTLASSERT(pncOldList->IsEmptyAndInvalid(i));
                continue;
            }

            // calculate bucket address of this node
            DWORD dwBkt = _H0(pncOldList->m_dwKeySigs[i], dwBktAddrMask);
            if (dwBkt < iExpansionIdx)
                dwBkt = _H1(pncOldList->m_dwKeySigs[i], dwBktAddrMask);

            // record to be moved to the new address?
            if (dwBkt == dwNewBkt)
            {
                // node in new bucket chain full?
                if (iNewSlot == NODE_END)
                {
                    // the calling routine has passed in a FreeList adequate
                    // for all needs
                    IRTLASSERT(pncFreeList != NULL);
                    pncTmp = pncFreeList;
                    pncFreeList = pncFreeList->m_pncNext;
                    pncTmp->Clear();
                    pncNewTarget->m_pncNext = pncTmp;
                    pncNewTarget = pncTmp;
                    iNewSlot = NODE_BEGIN;
                }

                pncNewTarget->m_dwKeySigs[iNewSlot]
                    = pncOldList->m_dwKeySigs[i];
                pncNewTarget->m_pvNode[iNewSlot]
                    = pncOldList->m_pvNode[i];
                iNewSlot += NODE_STEP;
            }

            // no, record stays in its current bucket chain
            else
            {
                // node in old bucket chain full?
                if (iOldSlot == NODE_END)
                {
                    // the calling routine has passed in a FreeList adequate
                    // for all needs
                    IRTLASSERT(pncFreeList != NULL);
                    pncTmp = pncFreeList;
                    pncFreeList = pncFreeList->m_pncNext;
                    pncTmp->Clear();
                    pncOldTarget->m_pncNext = pncTmp;
                    pncOldTarget = pncTmp;
                    iOldSlot = NODE_BEGIN;
                }

                pncOldTarget->m_dwKeySigs[iOldSlot]
                    = pncOldList->m_dwKeySigs[i];
                pncOldTarget->m_pvNode[iOldSlot]
                    = pncOldList->m_pvNode[i];
                iOldSlot += NODE_STEP;
            }

            // clear old slot
            pncOldList->m_dwKeySigs[i] = HASH_INVALID_SIGNATURE;
            pncOldList->m_pvNode[i]    = NULL;
        }

        // keep walking down the original bucket chain
        pncTmp     = pncOldList;
        pncOldList = pncOldList->m_pncNext;

        // ncFirst is a stack variable, not allocated on the heap
        if (pncTmp != &ncFirst)
        {
            pncTmp->m_pncNext = pncFreeList;
            pncFreeList = pncTmp;
        }
    }

    // delete any leftover nodes
    while (pncFreeList != NULL)
    {
        pncTmp = pncFreeList;
        pncFreeList = pncFreeList->m_pncNext;
#ifdef _DEBUG
        pncTmp->m_pncNext = NULL; // or ~CNodeClump will ASSERT
#endif // _DEBUG
        _FreeNodeClump(pncTmp);
    }

#ifdef _DEBUG
    ncFirst.m_pncNext = NULL; // or ~CNodeClump will ASSERT
#endif // _DEBUG

    return LK_SUCCESS;
} // CLKRLinearHashTable::_SplitRecordSet



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_Contract
// Synopsis: Contract the table by deleting the last bucket in the active
//           address space. Return the records to the "buddy" of the
//           deleted bucket.
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_Contract()
{
    WriteLock();

    // update the state variables (expansion ptr, level and mask)
    if (m_iExpansionIdx > 0)
        --m_iExpansionIdx;
    else
    {
        --m_nLevel;
        m_iExpansionIdx = (1 << m_nLevel) - 1;
        IRTLASSERT(m_nLevel > 0  &&  m_iExpansionIdx > 0);
        m_dwBktAddrMask0 >>= 1;
        IRTLASSERT((m_dwBktAddrMask0 & (m_dwBktAddrMask0+1)) == 0); // 00011..111
        m_dwBktAddrMask1 >>= 1;
        IRTLASSERT(m_dwBktAddrMask1 == ((m_dwBktAddrMask0 << 1) | 1));
        IRTLASSERT((m_dwBktAddrMask1 & (m_dwBktAddrMask1+1)) == 0);
    }

    // The last bucket is the one that will be emptied
    CBucket* pbktLast = _Bucket(m_cActiveBuckets - 1);
    pbktLast->WriteLock();

    // Decrement after calculating pbktLast, or _Bucket() will assert.
    --m_cActiveBuckets;

    // Where the nodes from pbktLast will end up
    CBucket* pbktNew = _Bucket(m_iExpansionIdx);
    pbktNew->WriteLock();

    // Now we work out if we need to allocate any extra CNodeClumps.  We do
    // this up front, before calling _MergeRecordSets, as it's hard to
    // gracefully recover from the depths of that routine should we run
    // out of memory.
    
    CNodeClump* pnc;
    int         c = 0;

    // First, count the number of items in the old bucket
    for (pnc = &pbktLast->m_ncFirst;  pnc != NULL;  pnc = pnc->m_pncNext)
    {
        int i;

        FOR_EACH_NODE(i)
        {
            if (!pnc->IsEmptySlot(i))
            {
                IRTLASSERT(!pnc->IsEmptyAndInvalid(i));
                c++;
            }
        }
    }

    // Then, subtract off the number of empty slots in the new bucket
    for (pnc = &pbktNew->m_ncFirst;  pnc != NULL;  pnc = pnc->m_pncNext)
    {
        int i;

        FOR_EACH_NODE(i)
        {
            if (pnc->IsEmptySlot(i))
            {
                IRTLASSERT(pnc->IsEmptyAndInvalid(i));
                c--;
            }
        }
    }

    CNodeClump* pncFreeList = NULL;  // list of nodes available for reuse
    LK_RETCODE  lkrc        = LK_SUCCESS;

    // Do we need to allocate CNodeClumps to accommodate the surplus items?
    if (c > 0)
    {
        pncFreeList = _AllocateNodeClump();
        if (pncFreeList == NULL)
            lkrc = LK_ALLOC_FAIL;
        else if (c > NODES_PER_CLUMP)
        {
            // In the worst case, we need a 2-element freelist for
            // _MergeRecordSets. Two CNodeClumps always suffice since the
            // freelist will be augmented by the CNodeClumps from the old
            // bucket as they are processed.
            pnc = _AllocateNodeClump();
            if (pnc == NULL)
            {
                _FreeNodeClump(pncFreeList);
                lkrc = LK_ALLOC_FAIL;
            }
            else
                pncFreeList->m_pncNext = pnc;
        }
    }

    // Abort if we couldn't allocate enough CNodeClumps
    if (lkrc != LK_SUCCESS)
    {
        // undo the changes to the state variables
        if (++m_iExpansionIdx == (1U << m_nLevel))
        {
            ++m_nLevel;
            m_iExpansionIdx  = 0;
            m_dwBktAddrMask0 = (m_dwBktAddrMask0 << 1) | 1;
            m_dwBktAddrMask1 = (m_dwBktAddrMask0 << 1) | 1;
        }
        ++m_cActiveBuckets;

        // Unlock the buckets and the table
        pbktLast->WriteUnlock();
        pbktNew->WriteUnlock();
        WriteUnlock();

        return lkrc;
    }

    // Copy the chain of records from pbktLast
    CNodeClump ncOldFirst = pbktLast->m_ncFirst;

    // destroy pbktLast
    pbktLast->m_ncFirst.Clear();
    pbktLast->WriteUnlock();

    // remove segment, if empty
    if (_SegIndex(m_cActiveBuckets) == 0)
    {
#ifdef _DEBUG
        // double-check that the supposedly empty segment is really empty
        IRTLASSERT(_Segment(m_cActiveBuckets) != NULL);
        for (DWORD i = 0;  i < m_dwSegSize;  ++i)
        {
            CBucket* pbkt = &_Segment(m_cActiveBuckets)->Slot(i);
            IRTLASSERT(pbkt->IsWriteUnlocked()  &&  pbkt->IsReadUnlocked());
            IRTLASSERT(pbkt->m_ncFirst.IsLastClump());

            int j;

            FOR_EACH_NODE(j)
            {
                IRTLASSERT(pbkt->m_ncFirst.IsEmptyAndInvalid(j));
            }
        }
#endif // _DEBUG
        _FreeSegment(_Segment(m_cActiveBuckets));
        _Segment(m_cActiveBuckets) = NULL;
    }

    // reduce directory of segments if possible
    if (m_cActiveBuckets <= (m_cDirSegs * m_dwSegSize) >> 1
        &&  m_cDirSegs > MIN_DIRSIZE)
    {
        DWORD cDirSegsNew = m_cDirSegs >> 1;
        CDirEntry* paDirSegsNew = _AllocateSegmentDirectory(cDirSegsNew);

        // Memory allocation failure here does not require us to abort; it
        // just means that the directory of segments is larger than we'd like.
        if (paDirSegsNew != NULL)
        {
            for (DWORD j = 0;  j < cDirSegsNew;  j++)
                paDirSegsNew[j] = m_paDirSegs[j];
            for (j = 0;  j < m_cDirSegs;  j++)
                m_paDirSegs[j].m_pseg = NULL;

            _FreeSegmentDirectory(m_paDirSegs);
            m_paDirSegs = paDirSegsNew;
            m_cDirSegs  = cDirSegsNew;
        }
    }

    // release the table lock before doing the reorg
    WriteUnlock();

    lkrc = _MergeRecordSets(pbktNew, &ncOldFirst, pncFreeList);

    pbktNew->WriteUnlock();

#ifdef _DEBUG
    ncOldFirst.m_pncNext = NULL; // or ~CNodeClump will ASSERT
#endif // _DEBUG

    return lkrc;
} // CLKRLinearHashTable::_Contract



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_MergeRecordSets
// Synopsis: Merge two record sets.  Copy the contents of pncOldList
//           into pbktNewTarget.
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_MergeRecordSets(
    CBucket*    pbktNewTarget,
    CNodeClump* pncOldList,
    CNodeClump* pncFreeList
    )
{
    IRTLASSERT(pbktNewTarget != NULL  &&  pncOldList != NULL);

    CNodeClump*   pncTmp = NULL;
    CNodeClump* const pncOldFirst = pncOldList;
    CNodeClump*   pncNewTarget = &pbktNewTarget->m_ncFirst;
    int           iNewSlot;

    // find the first nodeclump in the new target bucket with an empty slot
    while (!pncNewTarget->IsLastClump())
    {
        FOR_EACH_NODE(iNewSlot)
        {
            if (pncNewTarget->IsEmptySlot(iNewSlot))
                break;
        }

        if (iNewSlot == NODE_END)
            pncNewTarget = pncNewTarget->m_pncNext;
        else
            break;
    }

    IRTLASSERT(pncNewTarget != NULL);

    // find the first empty slot in pncNewTarget;
    // if none, iNewSlot == NODE_END
    FOR_EACH_NODE(iNewSlot)
    {
        if (pncNewTarget->IsEmptySlot(iNewSlot))
        {
            break;
        }
    }
    
    while (pncOldList != NULL)
    {
        int i;

        FOR_EACH_NODE(i)
        {
            if (!pncOldList->IsEmptySlot(i))
            {
                // any empty slots left in pncNewTarget?
                if (iNewSlot == NODE_END)
                {
                    // no, so walk down pncNewTarget until we find another
                    // empty slot
                    while (!pncNewTarget->IsLastClump())
                    {
                        pncNewTarget = pncNewTarget->m_pncNext;

                        FOR_EACH_NODE(iNewSlot)
                        {
                            if (pncNewTarget->IsEmptySlot(iNewSlot))
                                goto found_slot;
                        }
                    }

                    // Oops, reached the last nodeclump in pncNewTarget
                    // and it's full.  Get a new nodeclump off the free
                    // list, which is big enough to handle all needs.
                    IRTLASSERT(pncNewTarget != NULL);
                    IRTLASSERT(pncFreeList != NULL);
                    pncTmp = pncFreeList;
                    pncFreeList = pncFreeList->m_pncNext;
                    pncTmp->Clear();
                    pncNewTarget->m_pncNext = pncTmp;
                    pncNewTarget = pncTmp;
                    iNewSlot = NODE_BEGIN;
                }

              found_slot:
                // We have an empty slot in pncNewTarget
                IRTLASSERT(0 <= iNewSlot  &&  iNewSlot < NODES_PER_CLUMP
                       &&  pncNewTarget != NULL
                       &&  pncNewTarget->IsEmptyAndInvalid(iNewSlot));

                // Let's copy the node from pncOldList
                pncNewTarget->m_dwKeySigs[iNewSlot]
                    = pncOldList->m_dwKeySigs[i];
                pncNewTarget->m_pvNode[iNewSlot]
                    = pncOldList->m_pvNode[i];

                // Clear old slot
                pncOldList->m_dwKeySigs[i] = HASH_INVALID_SIGNATURE;
                pncOldList->m_pvNode[i]    = NULL;

                // find the next free slot in pncNewTarget
                while ((iNewSlot += NODE_STEP) != NODE_END)
                {
                    if (pncNewTarget->IsEmptySlot(iNewSlot))
                    {
                        break;
                    }
                }
            }
            else // iNewSlot != NODE_END
            {
                IRTLASSERT(pncOldList->IsEmptyAndInvalid(i));
            }
        }

        // Move into the next nodeclump in pncOldList
        pncTmp = pncOldList;
        pncOldList = pncOldList->m_pncNext;

        // Append to the free list.  Don't put the first node of
        // pncOldList on the free list, as it's a stack variable.
        if (pncTmp != pncOldFirst)
        {
            pncTmp->m_pncNext = pncFreeList;
            pncFreeList = pncTmp;
        }
    }

    // delete any leftover nodes
    while (pncFreeList != NULL)
    {
        pncTmp = pncFreeList;
        pncFreeList = pncFreeList->m_pncNext;
#ifdef _DEBUG
        pncTmp->m_pncNext = NULL; // or ~CNodeClump will ASSERT
#endif // _DEBUG
        _FreeNodeClump(pncTmp);
    }

    return LK_SUCCESS;
} // CLKRLinearHashTable::_MergeRecordSets



#ifdef LKR_DEPRECATED_ITERATORS

//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_InitializeIterator
// Synopsis: Make the iterator point to the first record in the hash table.
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_InitializeIterator(
    CIterator* piter)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(piter != NULL);
    IRTLASSERT(piter->m_lkl == LKL_WRITELOCK
               ?  IsWriteLocked()
               :  IsReadLocked());
    if (piter == NULL  ||  piter->m_plht != NULL)
        return LK_BAD_ITERATOR;

    piter->m_plht = this;
    piter->m_dwBucketAddr = 0;

    CBucket* pbkt = _Bucket(piter->m_dwBucketAddr);
    IRTLASSERT(pbkt != NULL);
    if (piter->m_lkl == LKL_WRITELOCK)
        pbkt->WriteLock();
    else
        pbkt->ReadLock();

    piter->m_pnc = &pbkt->m_ncFirst;
    piter->m_iNode = NODE_BEGIN - NODE_STEP;

    // Let IncrementIterator do the hard work of finding the first
    // slot in use.
    return IncrementIterator(piter);
} // CLKRLinearHashTable::_InitializeIterator



//------------------------------------------------------------------------
// Function: CLKRHashTable::InitializeIterator
// Synopsis: make the iterator point to the first record in the hash table
//------------------------------------------------------------------------

LK_RETCODE
CLKRHashTable::InitializeIterator(
    CIterator* piter)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(piter != NULL  &&  piter->m_pht == NULL);
    if (piter == NULL  ||  piter->m_pht != NULL)
        return LK_BAD_ITERATOR;

    // First, lock all the subtables
    if (piter->m_lkl == LKL_WRITELOCK)
        WriteLock();
    else
        ReadLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());
    if (!IsValid())
        return LK_UNUSABLE;

    piter->m_pht  = this;
    piter->m_ist  = -1;
    piter->m_plht = NULL;

    // Let IncrementIterator do the hard work of finding the first
    // valid node in the subtables.
    return IncrementIterator(piter);
} // CLKRHashTable::InitializeIterator



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::IncrementIterator
// Synopsis: move the iterator on to the next record in the hash table
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::IncrementIterator(
    CIterator* piter)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(piter != NULL);
    IRTLASSERT(piter->m_plht == this);
    IRTLASSERT(piter->m_lkl == LKL_WRITELOCK
               ?  IsWriteLocked()
               :  IsReadLocked());
    IRTLASSERT(piter->m_dwBucketAddr < m_cActiveBuckets);
    IRTLASSERT(piter->m_pnc != NULL);
    IRTLASSERT((0 <= piter->m_iNode  &&  piter->m_iNode < NODES_PER_CLUMP)
               || (NODE_BEGIN - NODE_STEP == piter->m_iNode));

    if (piter == NULL  ||  piter->m_plht != this)
        return LK_BAD_ITERATOR;

    const void* pvRecord = NULL;

    if (piter->m_iNode != NODE_BEGIN - NODE_STEP)
    {
        // Release the reference acquired in the previous call to
        // IncrementIterator
        pvRecord = piter->m_pnc->m_pvNode[piter->m_iNode];
        _AddRefRecord(pvRecord, -1);
    }

    do
    {
        do
        {
            // find the next slot in the nodeclump that's in use
            while ((piter->m_iNode += NODE_STEP) != NODE_END)
            {
                pvRecord = piter->m_pnc->m_pvNode[piter->m_iNode];
                if (pvRecord != NULL)
                {
                    // Add a new reference
                    _AddRefRecord(pvRecord, +1);
                    return LK_SUCCESS;
                }
            }

            // try the next nodeclump in the bucket chain
            piter->m_iNode = NODE_BEGIN - NODE_STEP;
            piter->m_pnc = piter->m_pnc->m_pncNext;
        } while (piter->m_pnc != NULL);

        // Exhausted this bucket chain.  Unlock it.
        CBucket* pbkt = _Bucket(piter->m_dwBucketAddr);
        IRTLASSERT(pbkt != NULL);
        IRTLASSERT(piter->m_lkl == LKL_WRITELOCK
                   ?  pbkt->IsWriteLocked()
                   :  pbkt->IsReadLocked());
        if (piter->m_lkl == LKL_WRITELOCK)
            pbkt->WriteUnlock();
        else
            pbkt->ReadUnlock();

        // Try the next bucket, if there is one
        if (++piter->m_dwBucketAddr < m_cActiveBuckets)
        {
            pbkt = _Bucket(piter->m_dwBucketAddr);
            IRTLASSERT(pbkt != NULL);
            if (piter->m_lkl == LKL_WRITELOCK)
                pbkt->WriteLock();
            else
                pbkt->ReadLock();
            piter->m_pnc = &pbkt->m_ncFirst;
        }
    } while (piter->m_dwBucketAddr < m_cActiveBuckets);

    // We have fallen off the end of the hashtable
    piter->m_iNode = NODE_BEGIN - NODE_STEP;
    piter->m_pnc = NULL;

    return LK_NO_MORE_ELEMENTS;
} // CLKRLinearHashTable::IncrementIterator



//------------------------------------------------------------------------
// Function: CLKRHashTable::IncrementIterator
// Synopsis: move the iterator on to the next record in the hash table
//------------------------------------------------------------------------

LK_RETCODE
CLKRHashTable::IncrementIterator(
    CIterator* piter)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(piter != NULL);
    IRTLASSERT(piter->m_pht == this);
    IRTLASSERT(-1 <= piter->m_ist
               &&  piter->m_ist < static_cast<int>(m_cSubTables));

    if (piter == NULL  ||  piter->m_pht != this)
        return LK_BAD_ITERATOR;

    // Table is already locked
    if (!IsValid())
        return LK_UNUSABLE;

    LK_RETCODE lkrc;
    CLHTIterator* pBaseIter = static_cast<CLHTIterator*>(piter);

    for (;;)
    {
        // Do we have a valid iterator into a subtable?  If not, get one.
        while (piter->m_plht == NULL)
        {
            while (++piter->m_ist < static_cast<int>(m_cSubTables))
            {
                lkrc = m_palhtDir[piter->m_ist]->_InitializeIterator(piter);
                if (lkrc == LK_SUCCESS)
                {
                    IRTLASSERT(m_palhtDir[piter->m_ist] == piter->m_plht);
                    return lkrc;
                }
                else if (lkrc == LK_NO_MORE_ELEMENTS)
                    lkrc = piter->m_plht->_CloseIterator(pBaseIter);

                if (lkrc != LK_SUCCESS)
                    return lkrc;
            }

            // There are no more subtables left.
            return LK_NO_MORE_ELEMENTS;
        }

        // We already have a valid iterator into a subtable.  Increment it.
        lkrc = piter->m_plht->IncrementIterator(pBaseIter);
        if (lkrc == LK_SUCCESS)
            return lkrc;

        // We've exhausted that subtable.  Move on.
        if (lkrc == LK_NO_MORE_ELEMENTS)
            lkrc = piter->m_plht->_CloseIterator(pBaseIter);

        if (lkrc != LK_SUCCESS)
            return lkrc;
    }
} // CLKRHashTable::IncrementIterator



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_CloseIterator
// Synopsis: release the resources held by the iterator
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_CloseIterator(
    CIterator* piter)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(piter != NULL);
    IRTLASSERT(piter->m_plht == this);
    IRTLASSERT(piter->m_lkl == LKL_WRITELOCK
               ?  IsWriteLocked()
               :  IsReadLocked());
    IRTLASSERT(piter->m_dwBucketAddr <= m_cActiveBuckets);
    IRTLASSERT((0 <= piter->m_iNode  &&  piter->m_iNode < NODES_PER_CLUMP)
               || (NODE_BEGIN - NODE_STEP == piter->m_iNode));

    if (piter == NULL  ||  piter->m_plht != this)
        return LK_BAD_ITERATOR;

    // Are we abandoning the iterator before the end of the table?
    // If so, need to unlock the bucket.
    if (piter->m_dwBucketAddr < m_cActiveBuckets)
    {
        CBucket* pbkt = _Bucket(piter->m_dwBucketAddr);
        IRTLASSERT(pbkt != NULL);
        IRTLASSERT(piter->m_lkl == LKL_WRITELOCK
                   ?  pbkt->IsWriteLocked()
                   :  pbkt->IsReadLocked());
        if (0 <= piter->m_iNode  &&  piter->m_iNode < NODES_PER_CLUMP)
        {
            IRTLASSERT(piter->m_pnc != NULL);
            const void* pvRecord = piter->m_pnc->m_pvNode[piter->m_iNode];
            _AddRefRecord(pvRecord, -1);
        }
        if (piter->m_lkl == LKL_WRITELOCK)
            pbkt->WriteUnlock();
        else
            pbkt->ReadUnlock();
    }

    piter->m_plht = NULL;
    piter->m_pnc  = NULL;

    return LK_SUCCESS;
} // CLKRLinearHashTable::_CloseIterator



//------------------------------------------------------------------------
// Function: CLKRHashTable::CloseIterator
// Synopsis: release the resources held by the iterator
//------------------------------------------------------------------------

LK_RETCODE
CLKRHashTable::CloseIterator(
    CIterator* piter)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(piter != NULL);
    IRTLASSERT(piter->m_pht == this);
    IRTLASSERT(-1 <= piter->m_ist
               &&  piter->m_ist <= static_cast<int>(m_cSubTables));

    if (piter == NULL  ||  piter->m_pht != this)
        return LK_BAD_ITERATOR;

    LK_RETCODE lkrc = LK_SUCCESS;

    if (!IsValid())
        lkrc = LK_UNUSABLE;
    else
    {
        // Are we abandoning the iterator before we've reached the end?
        // If so, close the subtable iterator.
        if (piter->m_plht != NULL)
        {
            IRTLASSERT(piter->m_ist < static_cast<int>(m_cSubTables));
            CLHTIterator* pBaseIter = static_cast<CLHTIterator*>(piter);
            piter->m_plht->_CloseIterator(pBaseIter);
        }
    }

    // Unlock all the subtables
    if (piter->m_lkl == LKL_WRITELOCK)
        WriteUnlock();
    else
        ReadUnlock();

    piter->m_plht = NULL;
    piter->m_pht  = NULL;
    piter->m_ist  = -1;

    return lkrc;
} // CLKRHashTable::CloseIterator

#endif // LKR_DEPRECATED_ITERATORS



//------------------------------------------------------------------------
// Function: CLKRHashTable::WriteLock
// Synopsis: Lock all subtables for writing
//------------------------------------------------------------------------

void
CLKRHashTable::WriteLock()
{
    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        m_palhtDir[i]->WriteLock();
        IRTLASSERT(m_palhtDir[i]->IsWriteLocked());
    }
} // CLKRHashTable::WriteLock



//------------------------------------------------------------------------
// Function: CLKRHashTable::ReadLock
// Synopsis: Lock all subtables for reading
//------------------------------------------------------------------------

void
CLKRHashTable::ReadLock() const
{
    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        m_palhtDir[i]->ReadLock();
        IRTLASSERT(m_palhtDir[i]->IsReadLocked());
    }
} // CLKRHashTable::ReadLock



//------------------------------------------------------------------------
// Function: CLKRHashTable::WriteUnlock
// Synopsis: Unlock all subtables
//------------------------------------------------------------------------

void
CLKRHashTable::WriteUnlock() const
{
    // unlock in reverse order: LIFO
    for (DWORD i = m_cSubTables;  i-- > 0;  )
    {
        IRTLASSERT(m_palhtDir[i]->IsWriteLocked());
        m_palhtDir[i]->WriteUnlock();
        IRTLASSERT(m_palhtDir[i]->IsWriteUnlocked());
    }
} // CLKRHashTable::WriteUnlock



//------------------------------------------------------------------------
// Function: CLKRHashTable::ReadUnlock
// Synopsis: Unlock all subtables
//------------------------------------------------------------------------

void
CLKRHashTable::ReadUnlock() const
{
    // unlock in reverse order: LIFO
    for (DWORD i = m_cSubTables;  i-- > 0;  )
    {
        IRTLASSERT(m_palhtDir[i]->IsReadLocked());
        m_palhtDir[i]->ReadUnlock();
        IRTLASSERT(m_palhtDir[i]->IsReadUnlocked());
    }
} // CLKRHashTable::ReadUnlock



//------------------------------------------------------------------------
// Function: CLKRHashTable::IsWriteLocked
// Synopsis: Are all subtables write-locked?
//------------------------------------------------------------------------

bool
CLKRHashTable::IsWriteLocked() const
{
    bool fLocked = (m_cSubTables > 0);
    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        fLocked = fLocked && m_palhtDir[i]->IsWriteLocked();
    }
    return fLocked;
}



//------------------------------------------------------------------------
// Function: CLKRHashTable::IsReadLocked
// Synopsis: Are all subtables read-locked?
//------------------------------------------------------------------------

bool
CLKRHashTable::IsReadLocked() const
{
    bool fLocked = (m_cSubTables > 0);
    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        fLocked = fLocked && m_palhtDir[i]->IsReadLocked();
    }
    return fLocked;
}



//------------------------------------------------------------------------
// Function: CLKRHashTable::IsWriteUnlocked
// Synopsis: Are all subtables write-unlocked?
//------------------------------------------------------------------------

bool
CLKRHashTable::IsWriteUnlocked() const
{
    bool fUnlocked = (m_cSubTables > 0);
    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        fUnlocked = fUnlocked && m_palhtDir[i]->IsWriteUnlocked();
    }
    return fUnlocked;
}



//------------------------------------------------------------------------
// Function: CLKRHashTable::IsReadUnlocked
// Synopsis: Are all subtables read-unlocked?
//------------------------------------------------------------------------

bool
CLKRHashTable::IsReadUnlocked() const
{
    bool fUnlocked = (m_cSubTables > 0);
    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        fUnlocked = fUnlocked && m_palhtDir[i]->IsReadUnlocked();
    }
    return fUnlocked;
}



//------------------------------------------------------------------------
// Function: CLKRHashTable::ConvertSharedToExclusive
// Synopsis: Convert the read lock to a write lock
//------------------------------------------------------------------------

void
CLKRHashTable::ConvertSharedToExclusive() const
{
    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        m_palhtDir[i]->ConvertSharedToExclusive();
        IRTLASSERT(m_palhtDir[i]->IsWriteLocked());
    }
}



//------------------------------------------------------------------------
// Function: CLKRHashTable::ConvertExclusiveToShared
// Synopsis: Convert the write lock to a read lock
//------------------------------------------------------------------------

void
CLKRHashTable::ConvertExclusiveToShared() const
{
    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        m_palhtDir[i]->ConvertExclusiveToShared();
        IRTLASSERT(m_palhtDir[i]->IsReadLocked());
    }
}



//------------------------------------------------------------------------
// Function: CLKRHashTable::Size
// Synopsis: Number of elements in the table
//------------------------------------------------------------------------

DWORD
CLKRHashTable::Size() const
{
    DWORD cSize = 0;

    for (DWORD i = 0;  i < m_cSubTables;  i++)
        cSize += m_palhtDir[i]->Size();

    return cSize;
} // CLKRHashTable::Size



//------------------------------------------------------------------------
// Function: CLKRHashTable::MaxSize
// Synopsis: Maximum possible number of elements in the table
//------------------------------------------------------------------------

DWORD
CLKRHashTable::MaxSize() const
{
    return (m_cSubTables == 0)  ? 0  : m_cSubTables * m_palhtDir[0]->MaxSize();
} // CLKRHashTable::MaxSize



//------------------------------------------------------------------------
// Function: CLKRHashTable::IsValid
// Synopsis: is the table valid?
//------------------------------------------------------------------------

bool
CLKRHashTable::IsValid() const
{
    bool f = (m_lkrcState == LK_SUCCESS     // serious internal failure?
              &&  (m_palhtDir != NULL  &&  m_cSubTables > 0)
              &&  ValidSignature());

    for (DWORD i = 0;  f  &&  i < m_cSubTables;  i++)
        f = f && m_palhtDir[i]->IsValid();

    return f;
} // CLKRHashTable::IsValid



//------------------------------------------------------------------------
// Function: CLKRHashTable::SetBucketLockSpinCount
// Synopsis: 
//------------------------------------------------------------------------

void
CLKRLinearHashTable::SetBucketLockSpinCount(
    WORD wSpins)
{
    m_wBucketLockSpins = wSpins;

    if (BucketLock::PerLockSpin() != LOCK_INDIVIDUAL_SPIN)
        return;
    
    for (DWORD i = 0;  i < m_cDirSegs;  i++)
    {
        CSegment* pseg = m_paDirSegs[i].m_pseg;

        if (pseg != NULL)
        {
            for (DWORD j = 0;  j < m_dwSegSize;  ++j)
            {
                pseg->Slot(j).SetSpinCount(wSpins);
            }
        }
    }
} // CLKRLinearHashTable::SetBucketLockSpinCount



//------------------------------------------------------------------------
// Function: CLKRHashTable::SetBucketLockSpinCount
// Synopsis: 
//------------------------------------------------------------------------

WORD
CLKRLinearHashTable::GetBucketLockSpinCount()
{
    return m_wBucketLockSpins;
} // CLKRLinearHashTable::GetBucketLockSpinCount



//------------------------------------------------------------------------
// Function: CLKRHashTable::SetTableLockSpinCount
// Synopsis: 
//------------------------------------------------------------------------

void
CLKRHashTable::SetTableLockSpinCount(
    WORD wSpins)
{
    for (DWORD i = 0;  i < m_cSubTables;  i++)
        m_palhtDir[i]->SetTableLockSpinCount(wSpins);
} // CLKRHashTable::SetTableLockSpinCount



//------------------------------------------------------------------------
// Function: CLKRHashTable::GetTableLockSpinCount
// Synopsis: 
//------------------------------------------------------------------------

WORD
CLKRHashTable::GetTableLockSpinCount()
{
    return ((m_cSubTables == 0)
            ?  LOCK_DEFAULT_SPINS
            :  m_palhtDir[0]->GetTableLockSpinCount());
} // CLKRHashTable::GetTableLockSpinCount



//------------------------------------------------------------------------
// Function: CLKRHashTable::SetBucketLockSpinCount
// Synopsis: 
//------------------------------------------------------------------------

void
CLKRHashTable::SetBucketLockSpinCount(
    WORD wSpins)
{
    for (DWORD i = 0;  i < m_cSubTables;  i++)
        m_palhtDir[i]->SetBucketLockSpinCount(wSpins);
} // CLKRHashTable::SetBucketLockSpinCount



//------------------------------------------------------------------------
// Function: CLKRHashTable::GetBucketLockSpinCount
// Synopsis: 
//------------------------------------------------------------------------

WORD
CLKRHashTable::GetBucketLockSpinCount()
{
    return ((m_cSubTables == 0)
            ?  LOCK_DEFAULT_SPINS
            :  m_palhtDir[0]->GetBucketLockSpinCount());
} // CLKRHashTable::GetBucketLockSpinCount



#ifdef __LKRHASH_NAMESPACE__
}
#endif // __LKRHASH_NAMESPACE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\lkrhash\lkhash.cpp ===
// =============================================================
// Functions/methods for class CLKLinearHashTable.
//
// Paul Larson, palarson@microsoft.com, March 1996
//   Original implementation
//
// George V. Reilly, georgere@microsoft.com, Dec 1997-Jan 1998
//   Massive cleanup and rewrite.  Templatized.
//
//==============================================================


#include "precomp.hxx"


#define DLL_IMPLEMENTATION
#define IMPLEMENTATION_EXPORT
#include <lkhash.h>

#ifdef __LKHASH_NAMESPACE__
namespace LKHash {
#endif // __LKHASH_NAMESPACE__



#ifdef LKHASH_ALLOCATOR_NEW

# define DECLARE_ALLOCATOR(CLASS)                        \
  CAllocator* CLASS::sm_palloc = NULL;                   \

# define DECLARE_ALLOCATOR_LHTSUBCLASS(CLASS)            \
  CAllocator* CLKLinearHashTable::CLASS::sm_palloc = NULL; \


  // DECLARE_ALLOCATOR(CLKLinearHashTable);
  // DECLARE_ALLOCATOR(CLKHashTable);
  DECLARE_ALLOCATOR_LHTSUBCLASS(CNodeClump);
  DECLARE_ALLOCATOR_LHTSUBCLASS(CSmallSegment);
  DECLARE_ALLOCATOR_LHTSUBCLASS(CMediumSegment);
  DECLARE_ALLOCATOR_LHTSUBCLASS(CLargeSegment);

#endif // LKHASH_ALLOCATOR_NEW



// -------------------------------------------------------------------------
// Initialize per-class allocators
// -------------------------------------------------------------------------

bool
LKHashTableInit()
{
    bool f = true;

    TRACE("LKHashTableInit\n");

#define INIT_ALLOCATOR(CLASS, N)                                \
    LKHASH_ALLOCATOR_INIT(CLASS, N, f);                         \

#define INIT_ALLOCATOR_LHTSUBCLASS(CLASS, N)                    \
    LKHASH_ALLOCATOR_INIT(CLKLinearHashTable::CLASS, N, f);     \


    // INIT_ALLOCATOR(CLKLinearHashTable,        20);
    // INIT_ALLOCATOR(CLKHashTable,               4);
    INIT_ALLOCATOR_LHTSUBCLASS(CNodeClump, 200);
    INIT_ALLOCATOR_LHTSUBCLASS(CSmallSegment,   5);
    INIT_ALLOCATOR_LHTSUBCLASS(CMediumSegment,  5);
    INIT_ALLOCATOR_LHTSUBCLASS(CLargeSegment,   5);

    return f;
}



// -------------------------------------------------------------------------
// Destroy per-class allocators
// -------------------------------------------------------------------------

void
LKHashTableUninit()
{
#define UNINIT_ALLOCATOR(CLASS)                        \
    LKHASH_ALLOCATOR_UNINIT(CLASS);                    \

#define UNINIT_ALLOCATOR_LHTSUBCLASS(CLASS)            \
    LKHASH_ALLOCATOR_UNINIT(CLKLinearHashTable::CLASS);\


    // UNINIT_ALLOCATOR(CLKLinearHashTable);
    // UNINIT_ALLOCATOR(CLKHashTable);
    UNINIT_ALLOCATOR_LHTSUBCLASS(CNodeClump);
    UNINIT_ALLOCATOR_LHTSUBCLASS(CSmallSegment);
    UNINIT_ALLOCATOR_LHTSUBCLASS(CMediumSegment);
    UNINIT_ALLOCATOR_LHTSUBCLASS(CLargeSegment);

    TRACE("LKHashTableUninit done\n");
}



// -------------------------------------------------------------------------
// class static member variables
// -------------------------------------------------------------------------

#ifdef LOCK_INSTRUMENTATION
LONG CLKLinearHashTable::CBucket::sm_cBuckets    = 0;

LONG CLKLinearHashTable::sm_cTables              = 0;
#endif // LOCK_INSTRUMENTATION



// CLKLinearHashTable --------------------------------------------------------
// Constructor for class CLKLinearHashTable.
// -------------------------------------------------------------------------

CLKLinearHashTable::CLKLinearHashTable(
    LPCSTR          pszName,        // An identifier for debugging
    PFnExtractKey   pfnExtractKey,  // Extract key from record
    PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
    PFnEqualKeys    pfnEqualKeys,   // Compare two keys
    PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
    double          maxload,        // Upperbound on the average chain length
    DWORD           initsize,       // Initial size of hash table.
    DWORD         /*num_subtbls*/   // for compatiblity with CLKHashTable
    )
    :
#ifdef LOCK_INSTRUMENTATION
      m_Lock(_LockName()),
#endif // LOCK_INSTRUMENTATION
      m_dwSignature(SIGNATURE),
      m_dwBktAddrMask(0),
      m_iExpansionIdx(0),
      m_paDirSegs(NULL),
      m_lkts(LK_MEDIUM_TABLESIZE),
      m_dwSegBits(0),
      m_dwSegSize(0),
      m_dwSegMask(0),
      m_lkrcState(LK_UNUSABLE),
      m_MaxLoad(LK_DFLT_MAXLOAD),
      m_nLevel(0),
      m_cDirSegs(0),
      m_cRecords(0),
      m_cActiveBuckets(0),
      m_wBucketLockSpins(LOCK_USE_DEFAULT_SPINS),
      m_pfnExtractKey(pfnExtractKey),
      m_pfnCalcKeyHash(pfnCalcKeyHash),
      m_pfnEqualKeys(pfnEqualKeys),
      m_pfnAddRefRecord(pfnAddRefRecord)
{
    strncpy(m_szName, pszName, NAME_SIZE-1);
    m_szName[NAME_SIZE-1] = '\0';

    IRTLASSERT(pfnExtractKey != NULL
               && pfnCalcKeyHash != NULL
               && pfnEqualKeys != NULL);

    // pfnAddRefRecord can be NULL
    if (pfnExtractKey == NULL
            || pfnCalcKeyHash == NULL
            || pfnEqualKeys == NULL)
        return;

    // Choose the size of the segments according to the desired "size" of
    // the table, small, medium, or large.
    if (initsize == LK_SMALL_TABLESIZE)
    {
        _SetSegVars(LK_SMALL_TABLESIZE);
        initsize = CSmallSegment::INITSIZE;
    }
    else if (initsize == LK_MEDIUM_TABLESIZE)
    {
        _SetSegVars(LK_MEDIUM_TABLESIZE);
        initsize = CMediumSegment::INITSIZE;
    }
    else if (initsize == LK_LARGE_TABLESIZE)
    {
        _SetSegVars(LK_LARGE_TABLESIZE);
        initsize = CLargeSegment::INITSIZE;
    }

    // specified an explicit initial size
    else
    {
        // force Small::SEGSIZE <= initsize <= MAX_DIRSIZE * Large::SEGSIZE
        initsize = min(max(initsize, CSmallSegment::SEGSIZE),
                       MAX_DIRSIZE * CLargeSegment::SEGSIZE);

        // Guess a table size
        if (initsize <= CSmallSegment::SEGSIZE)
            _SetSegVars(LK_SMALL_TABLESIZE);
        else if (initsize >= CLargeSegment::SEGSIZE)
            _SetSegVars(LK_LARGE_TABLESIZE);
        else
            _SetSegVars(LK_MEDIUM_TABLESIZE);
    }

    m_cActiveBuckets = initsize;

    // TODO: better sanity check for ridiculous values?
    m_MaxLoad        = (maxload <= 0.0)  ?  LK_DFLT_MAXLOAD  :  maxload;
    m_MaxLoad        = min(m_MaxLoad, 5 * NODES_PER_CLUMP);

    // adjust m_dwBktAddrMask to make it large enough to distribute
    // the buckets across the address space
    for (DWORD tmp = m_cActiveBuckets >> m_dwSegBits;  tmp > 1;  tmp >>= 1)
    {
        ++m_nLevel;
        m_dwBktAddrMask = (m_dwBktAddrMask << 1) | 1;
    }

    IRTLASSERT(_H1(m_cActiveBuckets) == m_cActiveBuckets);
    m_iExpansionIdx = m_cActiveBuckets & m_dwBktAddrMask;

    // create and clear directory of segments
    DWORD dirsize = MIN_DIRSIZE;
    while (dirsize < (m_cActiveBuckets >> m_dwSegBits))
        dirsize <<= 1;

    dirsize = min(dirsize, MAX_DIRSIZE);
    IRTLASSERT(dirsize * m_dwSegSize >= m_cActiveBuckets);

    m_paDirSegs = new CDirEntry [dirsize];

    if (m_paDirSegs != NULL)
    {
        m_cDirSegs = dirsize;
        IRTLASSERT(m_cDirSegs > 0
                   &&  (m_cDirSegs & (m_cDirSegs-1)) == 0);  // == (1 << N)

        // create and initialize only the required segments
        DWORD dwMaxSegs = m_cActiveBuckets >> m_dwSegBits;

        TRACE("m_lkts = %d, m_cActiveBuckets = %lu, m_dwSegSize = %lu, bits = %lu\n"
              "m_cDirSegs = %lu, dwMaxSegs = %lu, segment total size = %lu bytes\n",
              m_lkts, m_cActiveBuckets, m_dwSegSize, m_dwSegBits,
              m_cDirSegs, dwMaxSegs, m_dwSegSize * sizeof(CBucket));

        for (DWORD i = 0;  i < dwMaxSegs;  i++)
        {
            CSegment* pSeg = _NewSeg();
            if (pSeg != NULL)
                m_paDirSegs[i].m_pseg = pSeg;
            else
            {
                // problem: deallocate everything
                delete [] m_paDirSegs;
                m_paDirSegs = NULL;
                m_cDirSegs  = 0;
                return;
            }
        }
    }
    else
    {
        m_cActiveBuckets = 0;
    }

    m_lkrcState = LK_SUCCESS; // so IsValid won't fail
} // CLKLinearHashTable



// CLKHashTable ----------------------------------------------------------
// Constructor for class CLKHashTable.
// ---------------------------------------------------------------------

CLKHashTable::CLKHashTable(
    LPCSTR          pszName,        // An identifier for debugging
    PFnExtractKey   pfnExtractKey,  // Extract key from record
    PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
    PFnEqualKeys    pfnEqualKeys,   // Compare two keys
    PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
    double          maxload,        // Bound on the average chain length
    DWORD           initsize,       // Initial size of hash table.
    DWORD           num_subtbls     // Number of subordinate hash tables.
    )
    : m_dwSignature(SIGNATURE),
      m_cSubTables(0),
      m_palhtDir(NULL),
      m_pfnExtractKey(pfnExtractKey),
      m_pfnCalcKeyHash(pfnCalcKeyHash),
      m_lkrcState(LK_UNUSABLE)
{
    strncpy(m_szName, pszName, NAME_SIZE-1);
    m_szName[NAME_SIZE-1] = '\0';

    IRTLASSERT(pfnExtractKey != NULL
               && pfnCalcKeyHash != NULL
               && pfnEqualKeys != NULL);

    if (pfnExtractKey == NULL
            || pfnCalcKeyHash == NULL
            || pfnEqualKeys == NULL)
        return;

    LK_TABLESIZE lkts = NumSubTables(initsize, num_subtbls);

#ifdef _DEBUG
    int cBuckets = initsize;
    if (initsize == LK_SMALL_TABLESIZE)
        cBuckets = SubTable::CSmallSegment::INITSIZE;
    else if (initsize == LK_MEDIUM_TABLESIZE)
        cBuckets = SubTable::CMediumSegment::INITSIZE;
    else if (initsize == LK_LARGE_TABLESIZE)
        cBuckets = SubTable::CLargeSegment::INITSIZE;

    TRACE("CLKHashTable: %s, %d subtables, initsize = %d, total #buckets = %d\n",
          ((lkts == LK_SMALL_TABLESIZE) ? "small" : 
           (lkts == LK_MEDIUM_TABLESIZE) ? "medium" : "large"),
          num_subtbls, initsize, cBuckets * num_subtbls);
#endif

    m_cSubTables = num_subtbls;
    m_palhtDir   = new SubTable* [m_cSubTables];

    if (m_palhtDir == NULL)
        return;
    else
    {
        for (DWORD i = 0;  i < m_cSubTables;  i++)
            m_palhtDir[i] = NULL;
    }

    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        m_palhtDir[i] = new SubTable(pszName, pfnExtractKey, pfnCalcKeyHash,
                                     pfnEqualKeys,  pfnAddRefRecord,
                                     maxload, initsize);

        // Failed to allocate a subtable.  Destroy everything allocated so far.
        if (m_palhtDir[i] == NULL  ||  !m_palhtDir[i]->IsValid())
        {
            for (DWORD j = i;  j-- > 0;  )
                delete m_palhtDir[j];
            delete [] m_palhtDir;
            m_cSubTables = 0;
            m_palhtDir = NULL;

            return;
        }
    }

    m_lkrcState = LK_SUCCESS; // so IsValid won't fail
} // CLKHashTable



// ~CLKLinearHashTable ------------------------------------------------------
// Destructor for class CLKLinearHashTable
//-------------------------------------------------------------------------

CLKLinearHashTable::~CLKLinearHashTable()
{
    // must acquire all locks before deleting to make sure
    // that no other threads are using the table
    _WriteLock();
    _Clear(false);
    _WriteUnlock();
    m_dwSignature = SIGNATURE_FREE;
} // ~CLKLinearHashTable



// ~CLKHashTable ------------------------------------------------------------
// Destructor for class CLKHashTable
//-------------------------------------------------------------------------
CLKHashTable::~CLKHashTable()
{
    // delete in reverse order, just like delete[].
    for (DWORD i = m_cSubTables;  i-- > 0;  )
        delete m_palhtDir[i];

    delete [] m_palhtDir;
    m_dwSignature = SIGNATURE_FREE;
} // ~CLKHashTable



//------------------------------------------------------------------------
// Function: CLKLinearHashTable::NumSubTables
// Synopsis: 
//------------------------------------------------------------------------

LK_TABLESIZE
CLKLinearHashTable::NumSubTables(
    DWORD& rinitsize,
    DWORD& rnum_subtbls)
{
    LK_TABLESIZE lkts = LK_MEDIUM_TABLESIZE;

    return lkts;
}



//------------------------------------------------------------------------
// Function: CLKHashTable::NumSubTables
// Synopsis: 
//------------------------------------------------------------------------

LK_TABLESIZE
CLKHashTable::NumSubTables(
    DWORD& rinitsize,
    DWORD& rnum_subtbls)
{
    LK_TABLESIZE lkts;
    
    // Establish the table size
    if (rinitsize == LK_SMALL_TABLESIZE
        ||  rinitsize == LK_MEDIUM_TABLESIZE
        ||  rinitsize == LK_LARGE_TABLESIZE)
    {
        lkts = static_cast<LK_TABLESIZE>(rinitsize);
    }
    else
    {
        if (rnum_subtbls != LK_DFLT_NUM_SUBTBLS)
        {
            rinitsize = (rinitsize - 1) / rnum_subtbls + 1;

            if (rinitsize <= SubTable::CSmallSegment::SEGSIZE)
                lkts = LK_SMALL_TABLESIZE;
            else if (rinitsize >= SubTable::CLargeSegment::SEGSIZE)
                lkts = LK_LARGE_TABLESIZE;
            else
                lkts = LK_MEDIUM_TABLESIZE;
        }
        else
        {
            lkts = LK_MEDIUM_TABLESIZE;
        }
    }

    // Choose a suitable number of subtables
    if (rnum_subtbls == LK_DFLT_NUM_SUBTBLS)
    {
        int nCPUs = NumProcessors();
        switch (lkts)
        {
        case LK_SMALL_TABLESIZE:
            rnum_subtbls = min(2, nCPUs);
            break;
        
        case LK_MEDIUM_TABLESIZE:
            rnum_subtbls = 2 * nCPUs;
            break;
        
        case LK_LARGE_TABLESIZE:
            rnum_subtbls = 4 * nCPUs;
            break;
        }
    }

    return lkts;
}



//------------------------------------------------------------------------
// Function: CLKLinearHashTable::_InsertRecord
// Synopsis: Inserts a new record into the hash table. If this causes the
//           average chain length to exceed the upper bound, the table is
//           expanded by one bucket.
// Output:   LK_SUCCESS,    if the record was inserted.
//           LK_KEY_EXISTS, if the record was not inserted (because a record
//               with the same key value already exists in the table, unless
//               fOverwrite==true).
//           LK_ALLOC_FAIL, if failed to allocate the required space
//           LK_UNUSABLE,   if hash table not in usable state
//           LK_BAD_RECORD, if record is bad.
//------------------------------------------------------------------------

LK_RETCODE
CLKLinearHashTable::_InsertRecord(
    const void* pvRecord,   // Pointer to the record to add to table
    DWORD       dwSignature,// hash signature
    bool        fOverwrite  // overwrite record if key already present
    )
{
    IRTLASSERT(IsValid());
    if (!IsValid())
        return LK_UNUSABLE;

    if (pvRecord == NULL)
        return LK_BAD_RECORD;

    // find the beginning of the correct bucket chain
    _WriteLock();
    CBucket* const pbkt = _FindBucket(dwSignature, true);
    IRTLASSERT(pbkt != NULL);
    IRTLASSERT(pbkt->IsWriteLocked());
    _WriteUnlock();

    // check that no record with the same key value exists
    // and save a pointer to the last element on the chain
    LK_RETCODE  lkrc = LK_SUCCESS;
    CNodeClump* pncFree = NULL;
    LONG        iFreePos = -1;
    CNodeClump* pncPrev;
    CNodeClump* pncCurr;
    bool        fUpdate = false;
    const void* pvKey = _ExtractKey(pvRecord);

    // walk down the entire bucket chain, looking for matching hash
    // signatures and keys
    for (pncCurr = &pbkt->m_ncFirst, pncPrev = NULL;
         pncCurr != NULL;
         pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
    {
        for (DWORD i = 0;  i < NODES_PER_CLUMP;  i++)
        {
            if (dwSignature == pncCurr->m_dwKeySigs[i]
                &&  pncCurr->m_pvNode[i] != NULL  // signature could be zero
                &&  _EqualKeys(pvKey,  _ExtractKey(pncCurr->m_pvNode[i])))
            {
                if (fOverwrite)
                {
                    // If we allow overwrites, this is the slot to do it to
                    fUpdate  = true;
                    pncFree  = pncCurr;
                    iFreePos = i;
                    goto insert;
                }
                else
                {
                    // overwrites forbidden: return an error
                    lkrc = LK_KEY_EXISTS;
                    goto exit;
                }
            }

            // keep track of the first free slot in the bucket chain
            if (pncFree == NULL  &&  pncCurr->m_pvNode[i] == NULL)
            {
                IRTLASSERT(pncCurr->m_dwKeySigs[i] == 0);
                pncFree  = pncCurr;
                iFreePos = i;
            }
        }
    }

  insert:
    if (pncFree != NULL)
    {
        pncCurr = pncFree;
        IRTLASSERT(iFreePos >= 0);
    }
    else
    {
        // No free slots.  Attach the new node to the end of the chain
        IRTLASSERT(iFreePos < 0);
        pncCurr = new CNodeClump;

        if (pncCurr == NULL)
        {
            lkrc = LK_ALLOC_FAIL;
            goto exit;
        }

        IRTLASSERT(pncPrev != NULL  &&  pncPrev->m_pncNext == NULL);
        pncPrev->m_pncNext = pncCurr;
        iFreePos = 0;
    }

    // Bump the new record's reference count upwards
    _AddRefRecord(pvRecord, +1);

    if (fUpdate)
    {
        // We're overwriting an existing record.  Adjust the old record's
        // refcount downwards.  (Doing ++new, --old in this order ensures
        // that the refcount won't briefly go to zero if new and old are
        // the same record.)
        IRTLASSERT(pncCurr->m_pvNode[iFreePos] != NULL);
        _AddRefRecord(pncCurr->m_pvNode[iFreePos], -1);
    }
    else
    {
        IRTLASSERT(pncCurr->m_pvNode[iFreePos] == NULL);
        InterlockedIncrement(reinterpret_cast<LONG*>(&m_cRecords));
    }

    pncCurr->m_dwKeySigs[iFreePos] = dwSignature;
    pncCurr->m_pvNode[iFreePos]    = pvRecord;

  exit:
    pbkt->WriteUnlock();

    if (lkrc == LK_SUCCESS)
    {
        // If the average load factor has grown too high, we grow the
        // table one bucket at a time.
        while (m_cRecords > m_MaxLoad * m_cActiveBuckets)
        {
            if ((lkrc = _Expand()) == LK_ALLOC_FAIL)
                break;  // expansion failed
        }
    }

    return lkrc;
} // _InsertRecord



//-------------------------------------------------------------------------
// Function: CLKLinearHashTable::_DeleteKey
// Synopsis: Deletes the record with the given key value from the hash
//           table (if it exists). Holes created by deletions are not filled
//           immediately by moving records around. They will eventually be
//           filled by insertions or reorganizations during expansions or
//           contractions.
// Returns:  LK_SUCCESS, if record found and deleted.
//           LK_NO_SUCH_KEY, if no record with the given key value was found.
//           LK_UNUSABLE, if hash table not in usable state
//-------------------------------------------------------------------------

LK_RETCODE
CLKLinearHashTable::_DeleteKey(
    const void* pvKey,      // Key value of the record, depends on key type
    DWORD       dwSignature
    )
{
    IRTLASSERT(IsValid());
    if (!IsValid())
        return LK_UNUSABLE;

    LK_RETCODE lkrc = LK_NO_SUCH_KEY;

    // locate the beginning of the correct bucket chain
    _WriteLock();
    CBucket* const pbkt = _FindBucket(dwSignature, true);
    IRTLASSERT(pbkt != NULL);
    IRTLASSERT(pbkt->IsWriteLocked());
    _WriteUnlock();

    // scan down the bucket chain, looking for the victim
    for (CNodeClump* pncCurr = &pbkt->m_ncFirst, *pncPrev = NULL;
         pncCurr != NULL;
         pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
    {
        for (DWORD i = 0;  i < NODES_PER_CLUMP;  i++)
        {
            if (dwSignature == pncCurr->m_dwKeySigs[i]
                &&  pncCurr->m_pvNode[i] != NULL  // signature could be zero
                &&  _EqualKeys(pvKey,  _ExtractKey(pncCurr->m_pvNode[i])))
            {
                IRTLVERIFY(_DeleteNode(pbkt, pncCurr, pncPrev, i));
                lkrc = LK_SUCCESS;
                goto exit;
            }
        }
    }

  exit:
    pbkt->WriteUnlock();

    if (lkrc == LK_SUCCESS)
    {
        // contract the table if necessary
        double maxcontract = 1.0 / static_cast<double>(m_MaxLoad);

        for (int contractions = 0;
             m_cRecords < m_MaxLoad * m_cActiveBuckets
                 &&  m_cActiveBuckets > m_dwSegSize * MIN_DIRSIZE
                 &&  contractions < maxcontract;
             ++contractions)
        {
            lkrc = _Contract();
            if (lkrc != LK_SUCCESS)
                break;
        }
    }

    return lkrc;
} // _DeleteKey



//-------------------------------------------------------------------------
// Function: CLKLinearHashTable::_DeleteRecord
// Synopsis: Deletes the specified record from the hash table (if it
//           exists). Holes created by deletions are not filled immediately
//           by moving records around. They will eventually be filled by
//           insertions or reorganizations during expansions or
//           contractions.  This is not the same thing as calling
//           DeleteKey(_ExtractKey(pvRecord)).  If that were called for a
//           record that doesn't exist in the table, it could delete some
//           completely unrelated record that happened to have the key.
// Returns:  LK_SUCCESS, if record found and deleted.
//           LK_NO_SUCH_KEY, if the record is not found in the table.
//           LK_UNUSABLE, if hash table not in usable state.
//-------------------------------------------------------------------------

LK_RETCODE
CLKLinearHashTable::_DeleteRecord(
    const void* pvRecord,   // Pointer to the record to delete from the table
    DWORD       dwSignature
    )
{
    IRTLASSERT(IsValid());
    if (!IsValid())
        return LK_UNUSABLE;

    LK_RETCODE lkrc = LK_NO_SUCH_KEY;

    // locate the beginning of the correct bucket chain
    _WriteLock();
    CBucket* const pbkt = _FindBucket(dwSignature, true);
    IRTLASSERT(pbkt != NULL);
    IRTLASSERT(pbkt->IsWriteLocked());
    _WriteUnlock();

    const void* pvKey = _ExtractKey(pvRecord);
    IRTLASSERT(dwSignature == _CalcKeyHash(pvKey));

    // scan down the bucket chain, looking for the victim
    for (CNodeClump* pncCurr = &pbkt->m_ncFirst, *pncPrev = NULL;
         pncCurr != NULL;
         pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
    {
        for (DWORD i = 0;  i < NODES_PER_CLUMP;  i++)
        {
            if (pncCurr->m_pvNode[i] == pvRecord)
            {
                IRTLASSERT(_EqualKeys(pvKey,
                                      _ExtractKey(pncCurr->m_pvNode[i])));
                IRTLASSERT(dwSignature == pncCurr->m_dwKeySigs[i]);
                IRTLVERIFY(_DeleteNode(pbkt, pncCurr, pncPrev, i));
                lkrc = LK_SUCCESS;
                goto exit;
            }
        }
    }

  exit:
    pbkt->WriteUnlock();

    if (lkrc == LK_SUCCESS)
    {
        // contract the table if necessary
        double maxcontract = 1.0 / static_cast<double>(m_MaxLoad);

        for (int contractions = 0;
             m_cRecords < m_MaxLoad * m_cActiveBuckets
                 &&  m_cActiveBuckets > m_dwSegSize * MIN_DIRSIZE
                 &&  contractions < maxcontract;
             ++contractions)
        {
            lkrc = _Contract();
            if (lkrc != LK_SUCCESS)
                break;
        }
    }

    return lkrc;
} // _DeleteKey



//------------------------------------------------------------------------
// Function: CLKLinearHashTable::_DeleteNode
// Synopsis: Deletes a node; removes the node clump if empty
// Returns:  true if successful
//------------------------------------------------------------------------

bool
CLKLinearHashTable::_DeleteNode(
    CBucket*     pbkt,
    CNodeClump*& rpnc,
    CNodeClump*& rpncPrev,
    DWORD&       riNode)
{
    IRTLASSERT(pbkt != NULL  &&  pbkt->IsWriteLocked());
    IRTLASSERT(rpnc != NULL);
    IRTLASSERT(rpncPrev == NULL  ||  rpncPrev->m_pncNext == rpnc);
    IRTLASSERT(0 <= riNode  &&  riNode < NODES_PER_CLUMP);
    IRTLASSERT(rpnc->m_pvNode[riNode] != NULL);

    if ((pbkt == NULL  ||  !pbkt->IsWriteLocked())
        ||  (rpnc == NULL)
        ||  (rpncPrev != NULL  &&  rpncPrev->m_pncNext != rpnc)
        ||  !(0 <= riNode  ||  riNode < NODES_PER_CLUMP)
        ||  (rpnc->m_pvNode[riNode] == NULL))
        return false;

#ifdef _DEBUG
    // Check that the node clump really does belong to the bucket
    CNodeClump* pnc2 = &pbkt->m_ncFirst;

    while (pnc2 != NULL  &&  pnc2 != rpnc)
         pnc2 = pnc2->m_pncNext;

    IRTLASSERT(pnc2 == rpnc);
#endif // _DEBUG

    // Release the reference to the record
    _AddRefRecord(rpnc->m_pvNode[riNode], -1);

    // Delete the node from the table
    rpnc->m_pvNode[riNode]    = NULL;
    rpnc->m_dwKeySigs[riNode] = 0;

    // Is clump empty now?  Delete it, if possible
    if (rpncPrev != NULL)
    {
        bool fEmpty = true;
        for (DWORD j = 0;  j < NODES_PER_CLUMP;  j++)
        {
            if (rpnc->m_pvNode[j] != NULL)
            {
                fEmpty = false;
                break;
            }
        }

        // if clump is now empty, disconnect and delete it.
        if (fEmpty)
        {
            IRTLASSERT(rpnc != &pbkt->m_ncFirst);
            IRTLASSERT(rpncPrev->m_pncNext == rpnc);
            rpncPrev->m_pncNext = rpnc->m_pncNext;
#ifdef _DEBUG
            rpnc->m_pncNext = NULL; // or dtor will ASSERT
#endif // _DEBUG
            delete rpnc;

            // Reset these to point to the end of the preceding clump so
            // that the calling procedure's loop variables aren't pointing
            // into limbo.
            rpnc   = rpncPrev;
            riNode = NODES_PER_CLUMP;
            if (rpnc == &pbkt->m_ncFirst)
                rpncPrev = NULL;
            else
            {
                for (rpncPrev = &pbkt->m_ncFirst;
                     rpncPrev->m_pncNext != rpnc;
                     rpncPrev = rpncPrev->m_pncNext)
                {}
            }
        }
    }

    IRTLASSERT(rpncPrev == NULL  ||  rpncPrev->m_pncNext == rpnc);

    InterlockedDecrement(reinterpret_cast<LONG*>(&m_cRecords));

    return true;
} // _DeleteNode



//------------------------------------------------------------------------
// Function: CLKLinearHashTable::_FindKey
// Synopsis: Locate the record associated with the given key value.
// Returns:  Pointer to the record, if it is found.
//           NULL, if the record is not found.
// Returns:  LK_SUCCESS, if record found (record is returned in *ppvRecord)
//           LK_BAD_RECORD, if ppvRecord is invalid
//           LK_NO_SUCH_KEY, if no record with the given key value was found.
//           LK_UNUSABLE, if hash table not in usable state
// Note:     the record is AddRef'd.  You must decrement the reference count
//           when you are finished with the record (if you're implementing
//           refcounting semantics).
//------------------------------------------------------------------------

LK_RETCODE
CLKLinearHashTable::_FindKey(
    const void*  pvKey,      // Key value of the record, depends on key type
    DWORD        dwSignature,// hash signature
    const void** ppvRecord   // resultant record
    ) const
{
    IRTLASSERT(IsValid()  &&  ppvRecord != NULL);
    if (!IsValid())
        return LK_UNUSABLE;
    if (ppvRecord == NULL)
        return LK_BAD_RECORD;

    *ppvRecord = NULL;
    LK_RETCODE lkrc = LK_NO_SUCH_KEY;

    // locate the beginning of the correct bucket chain
    _ReadLock();
    CBucket* const pbkt = _FindBucket(dwSignature, false);
    IRTLASSERT(pbkt != NULL);
    IRTLASSERT(pbkt->IsReadLocked());
    _ReadUnlock();

    // walk down the bucket chain
    for (CNodeClump* pncCurr = &pbkt->m_ncFirst;
         pncCurr != NULL;
         pncCurr = pncCurr->m_pncNext)
    {
        for (DWORD i = 0;  i < NODES_PER_CLUMP;  i++)
        {
            if (dwSignature == pncCurr->m_dwKeySigs[i]
                &&  pncCurr->m_pvNode[i] != NULL  // signature could be zero
                &&  _EqualKeys(pvKey,  _ExtractKey(pncCurr->m_pvNode[i])))
            {
                    *ppvRecord = pncCurr->m_pvNode[i];
                    lkrc = LK_SUCCESS;

                    // bump the reference count before handing the record
                    // back to the user.  The user should decrement the
                    // reference count when finished with this record.
                    _AddRefRecord(*ppvRecord, +1);
                    goto exit;
            }
        }
    }

  exit:
    pbkt->ReadUnlock();
    return lkrc;
} // _FindKey



//------------------------------------------------------------------------
// Function: CLKLinearHashTable::_FindRecord
// Synopsis: Sees if the record is contained in the table
// Returns:  Pointer to the record, if it is found.
//           NULL, if the record is not found.
// Returns:  LK_SUCCESS, if record found
//           LK_BAD_RECORD, if pvRecord is invalid
//           LK_NO_SUCH_KEY, if the record was not found in the table
//           LK_UNUSABLE, if hash table not in usable state
// Note:     The record is *not* AddRef'd.
//------------------------------------------------------------------------

LK_RETCODE
CLKLinearHashTable::_FindRecord(
    const void* pvRecord,    // Pointer to the record to find in the table
    DWORD       dwSignature  // hash signature
    ) const
{
    IRTLASSERT(IsValid()  &&  pvRecord != NULL);
    if (!IsValid())
        return LK_UNUSABLE;
    if (pvRecord == NULL)
        return LK_BAD_RECORD;

    LK_RETCODE lkrc = LK_NO_SUCH_KEY;

    // locate the beginning of the correct bucket chain
    _ReadLock();
    CBucket* const pbkt = _FindBucket(dwSignature, false);
    IRTLASSERT(pbkt != NULL);
    IRTLASSERT(pbkt->IsReadLocked());
    _ReadUnlock();

    const void* pvKey = _ExtractKey(pvRecord);
    IRTLASSERT(dwSignature == _CalcKeyHash(pvKey));

    // walk down the bucket chain
    for (CNodeClump* pncCurr = &pbkt->m_ncFirst;
         pncCurr != NULL;
         pncCurr = pncCurr->m_pncNext)
    {
        for (DWORD i = 0;  i < NODES_PER_CLUMP;  i++)
        {
            if (pncCurr->m_pvNode[i] == pvRecord)
            {
                IRTLASSERT(dwSignature == pncCurr->m_dwKeySigs[i]);
                IRTLASSERT(_EqualKeys(pvKey,
                                      _ExtractKey(pncCurr->m_pvNode[i])));
                lkrc = LK_SUCCESS;
                goto exit;
            }
        }
    }

  exit:
    pbkt->ReadUnlock();
    return lkrc;
} // _FindKey



//------------------------------------------------------------------------
// Function: CLKLinearHashTable::Apply
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKLinearHashTable::Apply(
    PFnRecordAction pfnAction,
    void*           pvState,
    LK_LOCKTYPE     lkl)
{
    if (!IsValid())
        return 0;

    LK_PREDICATE lkp = LKP_PERFORM;
    if (lkl == LKL_WRITELOCK)
        _WriteLock();
    else
        _ReadLock();

    DWORD dw = _Apply(pfnAction, pvState, lkl, lkp);
    if (lkl == LKL_WRITELOCK)
        _WriteUnlock();
    else
        _ReadUnlock();

    return dw;
}



//------------------------------------------------------------------------
// Function: CLKHashTable::Apply
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKHashTable::Apply(
    PFnRecordAction pfnAction,
    void*           pvState,
    LK_LOCKTYPE     lkl)
{
    if (!IsValid())
        return 0;

    DWORD dw = 0;
    LK_PREDICATE lkp = LKP_PERFORM;

    if (lkl == LKL_WRITELOCK)
        _WriteLock();
    else
        _ReadLock();
    
    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        dw += m_palhtDir[i]->_Apply(pfnAction, pvState, lkl, lkp);
        if (lkp == LKP_ABORT  ||  lkp == LKP_PERFORM_STOP
                ||  lkp == LKP_DELETE_STOP)
            break;
    }

    if (lkl == LKL_WRITELOCK)
        _WriteUnlock();
    else
        _ReadUnlock();

    return dw;
}



//------------------------------------------------------------------------
// Function: CLKLinearHashTable::ApplyIf
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKLinearHashTable::ApplyIf(
    PFnRecordPred   pfnPredicate,
    PFnRecordAction pfnAction,
    void*           pvState,
    LK_LOCKTYPE     lkl)
{
    if (!IsValid())
        return 0;

    LK_PREDICATE lkp = LKP_PERFORM;
    if (lkl == LKL_WRITELOCK)
        _WriteLock();
    else
        _ReadLock();

    DWORD dw = _ApplyIf(pfnPredicate, pfnAction, pvState, lkl, lkp);
    if (lkl == LKL_WRITELOCK)
        _WriteUnlock();
    else
        _ReadUnlock();
    return dw;
}



//------------------------------------------------------------------------
// Function: CLKHashTable::ApplyIf
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKHashTable::ApplyIf(
    PFnRecordPred   pfnPredicate,
    PFnRecordAction pfnAction,
    void*           pvState,
    LK_LOCKTYPE     lkl)
{
    if (!IsValid())
        return 0;

    DWORD dw = 0;
    LK_PREDICATE lkp = LKP_PERFORM;

    if (lkl == LKL_WRITELOCK)
        _WriteLock();
    else
        _ReadLock();

    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        dw += m_palhtDir[i]->_ApplyIf(pfnPredicate, pfnAction,
                                      pvState, lkl, lkp);
        if (lkp == LKP_ABORT  ||  lkp == LKP_PERFORM_STOP
                ||  lkp == LKP_DELETE_STOP)
            break;
    }

    if (lkl == LKL_WRITELOCK)
        _WriteUnlock();
    else
        _ReadUnlock();

    return dw;
}



//------------------------------------------------------------------------
// Function: CLKLinearHashTable::DeleteIf
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKLinearHashTable::DeleteIf(
    PFnRecordPred pfnPredicate,
    void*         pvState)
{
    if (!IsValid())
        return 0;

    LK_PREDICATE lkp = LKP_PERFORM;
    _WriteLock();
    DWORD dw = _DeleteIf(pfnPredicate, pvState, lkp);
    _WriteUnlock();
    return dw;
}



//------------------------------------------------------------------------
// Function: CLKHashTable::DeleteIf
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKHashTable::DeleteIf(
    PFnRecordPred pfnPredicate,
    void*         pvState)
{
    if (!IsValid())
        return 0;

    DWORD dw = 0;
    LK_PREDICATE lkp = LKP_PERFORM;

    _WriteLock();

    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        dw += m_palhtDir[i]->_DeleteIf(pfnPredicate, pvState, lkp);
        if (lkp == LKP_ABORT  ||  lkp == LKP_PERFORM_STOP
                ||  lkp == LKP_DELETE_STOP)
            break;
    }

    _WriteUnlock();

    return dw;
}



//------------------------------------------------------------------------
// Function: CLKLinearHashTable::_Apply
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKLinearHashTable::_Apply(
    PFnRecordAction pfnAction,
    void*           pvState,
    LK_LOCKTYPE     lkl,
    LK_PREDICATE&   rlkp)
{
    IRTLASSERT(IsValid());
    IRTLASSERT(lkl == LKL_WRITELOCK  ?  _IsWriteLocked()  :  _IsReadLocked());
    return _ApplyIf(_PredTrue, pfnAction, pvState, lkl, rlkp);
}



//------------------------------------------------------------------------
// Function: CLKLinearHashTable::_ApplyIf
// Synopsis:
// Returns:  Number of successful actions
//------------------------------------------------------------------------

DWORD
CLKLinearHashTable::_ApplyIf(
    PFnRecordPred   pfnPredicate,
    PFnRecordAction pfnAction,
    void*           pvState,
    LK_LOCKTYPE     lkl,
    LK_PREDICATE&   rlkp)
{
    IRTLASSERT(IsValid());
    IRTLASSERT(lkl == LKL_WRITELOCK  ?  _IsWriteLocked()  :  _IsReadLocked());
    IRTLASSERT(pfnPredicate != NULL  &&  pfnAction != NULL);

    if ((lkl == LKL_WRITELOCK  ?  !_IsWriteLocked()  :  !_IsReadLocked())
            ||  pfnPredicate == NULL  ||  pfnAction == NULL)
        return 0;

    DWORD cActions = 0;

    for (DWORD iBkt = 0;  iBkt < m_cActiveBuckets;  ++iBkt)
    {
        CBucket* const pbkt = _Bucket(iBkt);
        IRTLASSERT(pbkt != NULL);

        if (lkl == LKL_WRITELOCK)
            pbkt->WriteLock();
        else
            pbkt->ReadLock();

        for (CNodeClump* pncCurr = &pbkt->m_ncFirst, *pncPrev = NULL;
             pncCurr != NULL;
             pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
        {
            for (DWORD i = 0;  i < NODES_PER_CLUMP;  i++)
            {
                if (pncCurr->m_pvNode[i] != NULL)
                {
                    rlkp = (*pfnPredicate)(pncCurr->m_pvNode[i], pvState);

                    switch (rlkp)
                    {
                    case LKP_ABORT:
                        if (lkl == LKL_WRITELOCK)
                            pbkt->WriteUnlock();
                        else
                            pbkt->ReadUnlock();
                        return cActions;
                        break;

                    case LKP_NO_ACTION:
                        // nothing to do
                        break;

                    case LKP_DELETE:
                    case LKP_DELETE_STOP:
                        if (lkl != LKL_WRITELOCK)
                        {
                            pbkt->ReadUnlock();
                            return cActions;
                        }

                        // fall through

                    case LKP_PERFORM:
                    case LKP_PERFORM_STOP:
                    {
                        LK_ACTION lka;

                        if (rlkp == LKP_DELETE  ||  rlkp == LKP_DELETE_STOP)
                        {
                            IRTLVERIFY(_DeleteNode(pbkt, pncCurr, pncPrev, i));
                            ++cActions;
                            lka = LKA_SUCCEEDED;
                        }
                        else
                        {
                            lka = (*pfnAction)(pncCurr->m_pvNode[i], pvState);

                            switch (lka)
                            {
                            case LKA_ABORT:
                                if (lkl == LKL_WRITELOCK)
                                    pbkt->WriteUnlock();
                                else
                                    pbkt->ReadUnlock();
                                return cActions;
                                
                            case LKA_FAILED:
                                // nothing to do
                                break;
                                
                            case LKA_SUCCEEDED:
                                ++cActions;
                                break;
                                
                            default:
                                IRTLASSERT(FALSE);
                                break;
                            }
                        }

                        if (rlkp == LKP_PERFORM_STOP
                            ||  rlkp == LKP_DELETE_STOP)
                        {
                            if (lkl == LKL_WRITELOCK)
                                pbkt->WriteUnlock();
                            else
                                pbkt->ReadUnlock();
                            return cActions;
                        }

                        break;
                    }

                    default:
                        IRTLASSERT(FALSE);
                        break;
                    }
                }
            }
        }

        if (lkl == LKL_WRITELOCK)
            pbkt->WriteUnlock();
        else
            pbkt->ReadUnlock();
    }

    return cActions;
}



//------------------------------------------------------------------------
// Function: CLKLinearHashTable::_DeleteIf
// Synopsis: Deletes all records that match the predicate
// Returns:  Count of successful deletions
//------------------------------------------------------------------------

DWORD
CLKLinearHashTable::_DeleteIf(
    PFnRecordPred pfnPredicate,
    void*         pvState,
    LK_PREDICATE& rlkp)
{
    IRTLASSERT(IsValid());
    IRTLASSERT(_IsWriteLocked());
    IRTLASSERT(pfnPredicate != NULL);

    if (!_IsWriteLocked()  ||  pfnPredicate == NULL)
        return 0;

    DWORD cActions = 0;

    for (DWORD iBkt = 0;  iBkt < m_cActiveBuckets;  ++iBkt)
    {
        CBucket* const pbkt = _Bucket(iBkt);
        IRTLASSERT(pbkt != NULL);
        pbkt->WriteLock();

        for (CNodeClump* pncCurr = &pbkt->m_ncFirst, *pncPrev = NULL;
             pncCurr != NULL;
             pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
        {
            for (DWORD i = 0;  i < NODES_PER_CLUMP;  i++)
            {
                if (pncCurr->m_pvNode[i] != NULL)
                {
                    rlkp = (*pfnPredicate)(pncCurr->m_pvNode[i], pvState);

                    switch (rlkp)
                    {
                    case LKP_ABORT:
                        pbkt->WriteUnlock();
                        return cActions;
                        break;

                    case LKP_NO_ACTION:
                        // nothing to do
                        break;

                    case LKP_PERFORM:
                    case LKP_PERFORM_STOP:
                    case LKP_DELETE:
                    case LKP_DELETE_STOP:
                    {
                        IRTLVERIFY(_DeleteNode(pbkt, pncCurr, pncPrev, i));
                        ++cActions;

                        if (rlkp == LKP_PERFORM_STOP
                            ||  rlkp == LKP_DELETE_STOP)
                        {
                            pbkt->WriteUnlock();
                            return cActions;
                        }

                        break;
                    }

                    default:
                        IRTLASSERT(FALSE);
                        break;
                    }
                }
            }
        }

        pbkt->WriteUnlock();
    }

    return cActions;
}



//------------------------------------------------------------------------
// Function: CLKLinearHashTable::CheckTable
// Synopsis: Verify that all records are in the right place and can be located.
// Returns:   0 => hash table is consistent
//           >0 => that many misplaced records
//           <0 => otherwise invalid
//------------------------------------------------------------------------

int
CLKLinearHashTable::CheckTable() const
{
    IRTLASSERT(IsValid());
    if (!IsValid())
        return LK_UNUSABLE;

    _ReadLock();

    int       cMisplaced = 0;
    DWORD     cRecords = 0;
    int       retcode = 0;

    // Check every bucket
    for (DWORD i = 0;  i < m_cActiveBuckets;  i++)
    {
        CBucket* const pbkt = _Bucket(i);
        IRTLASSERT(pbkt != NULL);
        pbkt->ReadLock();

        // Walk the bucket chain
        for (CNodeClump* pncCurr = &pbkt->m_ncFirst, *pncPrev = NULL;
             pncCurr != NULL;
             pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
        {
            for (DWORD j = 0;  j < NODES_PER_CLUMP;  j++)
            {
                if (pncCurr->m_pvNode[j] != NULL)
                {
                    ++cRecords;

                    const void* pvKey = _ExtractKey(pncCurr->m_pvNode[j]);

                    DWORD dwSignature = _CalcKeyHash(pvKey);
                    IRTLASSERT(dwSignature == pncCurr->m_dwKeySigs[j]);

                    DWORD address = _BucketAddress(dwSignature);
                    IRTLASSERT(address == i);

                    if (address != i || dwSignature != pncCurr->m_dwKeySigs[j])
                        cMisplaced++;
                }
                else
                    IRTLASSERT(pncCurr->m_dwKeySigs[j] == 0);
            }
            if (pncPrev != NULL)
                IRTLASSERT(pncPrev->m_pncNext == pncCurr);
        }
        pbkt->ReadUnlock();
    }

    if (cRecords != m_cRecords)
        retcode = LK_ALLOC_FAIL;
    IRTLASSERT(cRecords == m_cRecords);

    if (cMisplaced > 0)
        retcode = cMisplaced;
    IRTLASSERT(cMisplaced == 0);

    _ReadUnlock();

    return retcode;
} // CheckTable



//------------------------------------------------------------------------
// Function: CLKHashTable::CheckTable
// Synopsis: Verify that all records are in the right place and can be located.
// Returns:   0 => hash table is consistent
//           >0 => that many misplaced records
//           <0 => otherwise invalid
//------------------------------------------------------------------------
int
CLKHashTable::CheckTable() const
{
    int retcode = 0;

    for (DWORD i = 0;  i < m_cSubTables;  i++)
        retcode += m_palhtDir[i]->CheckTable();

    return retcode;
} // CheckTable



//------------------------------------------------------------------------
// Function: CLKLinearHashTable::Print
// Synopsis: Prints the table
//------------------------------------------------------------------------

void
CLKLinearHashTable::Print() const
{
    TRACE("CLKLinearHashTable(%08p)  # Elements %4d; ", this, m_cRecords);
    // TODO: flesh out further
}



//------------------------------------------------------------------------
// Function: CLKHashTable::Print
// Synopsis: Prints the table
//------------------------------------------------------------------------

void
CLKHashTable::Print() const
{
    TRACE("CLKHashTable(%08p)  # Subtables = %4d.\n", this, m_cSubTables);

    for (DWORD i = 0;  i < m_cSubTables;  i++)
        m_palhtDir[i]->Print();

    // TODO: print footer?
}



//------------------------------------------------------------------------
// Function: CLKLinearHashTable::_Clear
// Synopsis: Remove all data from the table
//------------------------------------------------------------------------

void
CLKLinearHashTable::_Clear(
    bool fShrinkDirectory)  // Shrink to min size but don't destroy entirely?
{
    IRTLASSERT(_IsWriteLocked());

#ifdef _DEBUG
    DWORD cDeleted = 0;
    DWORD cOldRecords = m_cRecords;
#endif // _DEBUG

    for (DWORD iBkt = 0;  iBkt < m_cActiveBuckets;  ++iBkt)
    {
        CBucket* const pbkt = _Bucket(iBkt);
        IRTLASSERT(pbkt != NULL);
        pbkt->WriteLock();

        for (CNodeClump* pncCurr = &pbkt->m_ncFirst, *pncPrev = NULL;
             pncCurr != NULL;
             pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
        {
            for (DWORD i = 0;  i < NODES_PER_CLUMP;  i++)
            {
                if (pncCurr->m_pvNode[i] != NULL)
                {
                    IRTLVERIFY(_DeleteNode(pbkt, pncCurr, pncPrev, i));
#ifdef _DEBUG
                    ++cDeleted;
#endif // _DEBUG
                }
            }
        }

#ifdef _DEBUG
        pbkt->m_ncFirst.m_pncNext = NULL; // or ~CNodeClump will ASSERT
#endif // _DEBUG
        pbkt->WriteUnlock();
    }

    IRTLASSERT(m_cRecords == 0  &&  cDeleted == cOldRecords);

    // delete all (or all but the first MIN_DIRSIZE) segments
    for (DWORD iSeg = fShrinkDirectory  ?  MIN_DIRSIZE * m_dwSegSize  :  0;
         iSeg < m_cActiveBuckets;
         iSeg += m_dwSegSize)
    {
        delete _Segment(iSeg);
        _Segment(iSeg) = NULL;
    }

    // reduce directory of segments to minimum size
    if (fShrinkDirectory  &&  m_cDirSegs > MIN_DIRSIZE)
    {
        CDirEntry* paDirSegsNew = new CDirEntry [MIN_DIRSIZE];

        if (paDirSegsNew != NULL)
        {
            for (DWORD j = 0;  j < MIN_DIRSIZE;  j++)
                paDirSegsNew[j] = m_paDirSegs[j];
            for (j = 0;  j < m_cDirSegs;  j++)
                m_paDirSegs[j].m_pseg = NULL;

            delete [] m_paDirSegs;

            m_paDirSegs      = paDirSegsNew;
            m_cDirSegs       = MIN_DIRSIZE;
            m_nLevel         = m_dwSegBits;
            m_cActiveBuckets = m_dwSegSize;
            m_dwBktAddrMask  = m_dwSegMask;
            m_iExpansionIdx  = m_cActiveBuckets & m_dwBktAddrMask;
        }
    }

    if (!fShrinkDirectory)
    {
        delete [] m_paDirSegs;
        m_paDirSegs = NULL;
        m_cDirSegs = m_nLevel = m_cActiveBuckets = m_dwBktAddrMask
            = m_iExpansionIdx = 0;
    }
}



//------------------------------------------------------------------------
// Function: CLKHashTable::Clear
// Synopsis: Remove all data from the table
//------------------------------------------------------------------------

void
CLKHashTable::Clear()
{
    _WriteLock();
    for (DWORD i = 0;  i < m_cSubTables;  i++)
        m_palhtDir[i]->_Clear(true);
    _WriteUnlock();
}



//------------------------------------------------------------------------
// Function: CLKLinearHashTable::GetStatistics
// Synopsis: Gather statistics about the table
//------------------------------------------------------------------------

CLKHashTableStats
CLKLinearHashTable::GetStatistics() const
{
    CLKHashTableStats stats;

    if (m_paDirSegs != NULL)
    {
        stats.RecordCount   = m_cRecords;
        stats.TableSize     = m_cActiveBuckets;
        stats.SplitFactor   = static_cast<double>(m_iExpansionIdx)
                              / (1 << m_nLevel);
        stats.DirectorySize = m_cDirSegs;
        stats.NodeClumpSize = NODES_PER_CLUMP;
        stats.CBucketSize   = sizeof(CBucket);

#ifdef LOCK_INSTRUMENTATION
        stats.m_alsBucketsAvg.m_nContentions     = 0;
        stats.m_alsBucketsAvg.m_nSleeps          = 0;
        stats.m_alsBucketsAvg.m_nContentionSpins = 0;
        stats.m_alsBucketsAvg.m_nAverageSpins    = 0;
        stats.m_alsBucketsAvg.m_nReadLocks       = 0;
        stats.m_alsBucketsAvg.m_nWriteLocks      = 0;
        stats.m_alsBucketsAvg.m_nItems           = 0;
#endif // LOCK_INSTRUMENTATION

        int empty = 0;
        int totacc = 0;
        int low_count = 0;
        int high_count = 0;
        int max_length = 0;

        for (DWORD i = 0;  i < m_cActiveBuckets;  i++)
        {
            int acc = 0;

            for (CNodeClump* pncCurr = &_Bucket(i)->m_ncFirst;
                 pncCurr != NULL;
                 pncCurr = pncCurr->m_pncNext)
            {
                for (DWORD j = 0;  j < NODES_PER_CLUMP;  j++)
                {
                    if (pncCurr->m_pvNode[j] != NULL)
                    {
                        acc++;
                        totacc += acc;
                        int iBucketIndex = stats.BucketIndex(acc);
                        ++stats.m_aBucketLenHistogram[iBucketIndex];
                    }
                }
            }

#ifdef LOCK_INSTRUMENTATION
            CLockStatistics ls = _Bucket(i)->LockStats();

            stats.m_alsBucketsAvg.m_nContentions     += ls.m_nContentions;
            stats.m_alsBucketsAvg.m_nSleeps          += ls.m_nSleeps;
            stats.m_alsBucketsAvg.m_nContentionSpins += ls.m_nContentionSpins;
            stats.m_alsBucketsAvg.m_nAverageSpins    += ls.m_nAverageSpins;
            stats.m_alsBucketsAvg.m_nReadLocks       += ls.m_nReadLocks;
            stats.m_alsBucketsAvg.m_nWriteLocks      += ls.m_nWriteLocks;
            stats.m_alsBucketsAvg.m_nItems           ++;
#endif // LOCK_INSTRUMENTATION

            max_length = max(max_length, acc);
            if (acc == 0)
                empty++;

            if (_H0(i) < m_iExpansionIdx)
            {
                low_count += acc;
            }
            else
            {
                high_count += acc;
            }
        }

        stats.LongestChain = max_length;
        stats.EmptySlots   = empty;

        if (m_cActiveBuckets > 0)
        {
            if (m_cRecords > 0)
            {
                double x=static_cast<double>(m_iExpansionIdx) /(1 << m_nLevel);
                double alpha= static_cast<double>(m_cRecords)/m_cActiveBuckets;
                double low_sl = 0.0;
                double high_sl = 0.0;
                
                stats.AvgSearchLength= static_cast<double>(totacc) /m_cRecords;
                stats.ExpSearchLength  = 1 + alpha * 0.25 * (2 + x - x*x);
                
                if (m_iExpansionIdx > 0)
                    low_sl  = static_cast<double>(low_count)
                        / (2.0 * m_iExpansionIdx);
                if (m_cActiveBuckets - 2 * m_iExpansionIdx > 0)
                    high_sl = static_cast<double>(high_count)
                        / (m_cActiveBuckets - 2.0 * m_iExpansionIdx);
                stats.AvgUSearchLength = low_sl * x + high_sl * (1.0 - x);
                stats.ExpUSearchLength = alpha * 0.5 * (2 + x - x*x);
            }

#ifdef LOCK_INSTRUMENTATION
            stats.m_alsBucketsAvg.m_nContentions     /= m_cActiveBuckets;
            stats.m_alsBucketsAvg.m_nSleeps          /= m_cActiveBuckets;
            stats.m_alsBucketsAvg.m_nContentionSpins /= m_cActiveBuckets;
            stats.m_alsBucketsAvg.m_nAverageSpins    /= m_cActiveBuckets;
            stats.m_alsBucketsAvg.m_nReadLocks       /= m_cActiveBuckets;
            stats.m_alsBucketsAvg.m_nWriteLocks      /= m_cActiveBuckets;
#endif // LOCK_INSTRUMENTATION

        }
        else
        {
            stats.AvgSearchLength  = 0.0;
            stats.ExpSearchLength  = 0.0;
            stats.AvgUSearchLength = 0.0;
            stats.ExpUSearchLength = 0.0;
        }
    }

#ifdef LOCK_INSTRUMENTATION
    stats.m_gls     = TableLock::GlobalStatistics();
    CLockStatistics ls = _LockStats();

    stats.m_alsTable.m_nContentions     = ls.m_nContentions;
    stats.m_alsTable.m_nSleeps          = ls.m_nSleeps;
    stats.m_alsTable.m_nContentionSpins = ls.m_nContentionSpins;
    stats.m_alsTable.m_nAverageSpins    = ls.m_nAverageSpins;
    stats.m_alsTable.m_nReadLocks       = ls.m_nReadLocks;
    stats.m_alsTable.m_nWriteLocks      = ls.m_nWriteLocks;
    stats.m_alsTable.m_nItems           = 1;
#endif // LOCK_INSTRUMENTATION

    return stats;
} // GetStatistics



//------------------------------------------------------------------------
// Function: CLKHashTable::GetStatistics
// Synopsis: Gather statistics about the table
//------------------------------------------------------------------------

CLKHashTableStats
CLKHashTable::GetStatistics() const
{
    CLKHashTableStats hts;

    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        CLKHashTableStats stats = m_palhtDir[i]->GetStatistics();

        hts.RecordCount +=      stats.RecordCount;
        hts.TableSize +=        stats.TableSize;
        hts.DirectorySize +=    stats.DirectorySize;
        hts.LongestChain =      max(hts.LongestChain, stats.LongestChain);
        hts.EmptySlots +=       stats.EmptySlots;
        hts.SplitFactor +=      stats.SplitFactor;
        hts.AvgSearchLength +=  stats.AvgSearchLength;
        hts.ExpSearchLength +=  stats.ExpSearchLength;
        hts.AvgUSearchLength += stats.AvgUSearchLength;
        hts.ExpUSearchLength += stats.ExpUSearchLength;
        hts.NodeClumpSize =     stats.NodeClumpSize;
        hts.CBucketSize =       stats.CBucketSize;

        for (int j = 0;  j < CLKHashTableStats::MAX_BUCKETS;  ++j)
            hts.m_aBucketLenHistogram[j] += stats.m_aBucketLenHistogram[j];

#ifdef LOCK_INSTRUMENTATION
        hts.m_alsTable.m_nContentions     += stats.m_alsTable.m_nContentions;
        hts.m_alsTable.m_nSleeps          += stats.m_alsTable.m_nSleeps;
        hts.m_alsTable.m_nContentionSpins
            += stats.m_alsTable.m_nContentionSpins;
        hts.m_alsTable.m_nAverageSpins    += stats.m_alsTable.m_nAverageSpins;
        hts.m_alsTable.m_nReadLocks       += stats.m_alsTable.m_nReadLocks;
        hts.m_alsTable.m_nWriteLocks      += stats.m_alsTable.m_nWriteLocks;
        
        hts.m_alsBucketsAvg.m_nContentions
            += stats.m_alsBucketsAvg.m_nContentions;
        hts.m_alsBucketsAvg.m_nSleeps
            += stats.m_alsBucketsAvg.m_nSleeps;
        hts.m_alsBucketsAvg.m_nContentionSpins
            += stats.m_alsBucketsAvg.m_nContentionSpins;
        hts.m_alsBucketsAvg.m_nAverageSpins
            += stats.m_alsBucketsAvg.m_nAverageSpins;
        hts.m_alsBucketsAvg.m_nReadLocks
            += stats.m_alsBucketsAvg.m_nReadLocks;
        hts.m_alsBucketsAvg.m_nWriteLocks
            += stats.m_alsBucketsAvg.m_nWriteLocks;
        hts.m_alsBucketsAvg.m_nItems
            += stats.m_alsBucketsAvg.m_nItems;
        
        hts.m_gls = stats.m_gls;
#endif // LOCK_INSTRUMENTATION
    }

    // Average out the subtables statistics.  (Does this make sense
    // for all of these fields?)
    hts.DirectorySize /=    m_cSubTables;
    hts.SplitFactor /=      m_cSubTables;
    hts.AvgSearchLength /=  m_cSubTables;
    hts.ExpSearchLength /=  m_cSubTables;
    hts.AvgUSearchLength /= m_cSubTables;
    hts.ExpUSearchLength /= m_cSubTables;

#ifdef LOCK_INSTRUMENTATION
    hts.m_alsTable.m_nContentions     /= m_cSubTables;
    hts.m_alsTable.m_nSleeps          /= m_cSubTables;
    hts.m_alsTable.m_nContentionSpins /= m_cSubTables;
    hts.m_alsTable.m_nAverageSpins    /= m_cSubTables;
    hts.m_alsTable.m_nReadLocks       /= m_cSubTables;
    hts.m_alsTable.m_nWriteLocks      /= m_cSubTables;
    hts.m_alsTable.m_nItems            = m_cSubTables;

    hts.m_alsBucketsAvg.m_nContentions     /= m_cSubTables;
    hts.m_alsBucketsAvg.m_nSleeps          /= m_cSubTables;
    hts.m_alsBucketsAvg.m_nContentionSpins /= m_cSubTables;
    hts.m_alsBucketsAvg.m_nAverageSpins    /= m_cSubTables;
    hts.m_alsBucketsAvg.m_nReadLocks       /= m_cSubTables;
    hts.m_alsBucketsAvg.m_nWriteLocks      /= m_cSubTables;
#endif // LOCK_INSTRUMENTATION

    return hts;
} // GetStatistics



//-----------------------------------------------------------------------
// Function: CLKLinearHashTable::_SetSegVars
// Synopsis: sets the size-specific segment variables
//-----------------------------------------------------------------------

void
CLKLinearHashTable::_SetSegVars(
    LK_TABLESIZE lkts)
{
    switch (lkts)
    {
    case LK_SMALL_TABLESIZE:
        m_lkts      = LK_SMALL_TABLESIZE;
        m_dwSegBits = CSmallSegment::SEGBITS;
        m_dwSegSize = CSmallSegment::SEGSIZE;
        m_dwSegMask = CSmallSegment::SEGMASK;
        break;
        
    default:
        IRTLASSERT(FALSE);
        // fall-through
        
    case LK_MEDIUM_TABLESIZE:
        m_lkts      = LK_MEDIUM_TABLESIZE;
        m_dwSegBits = CMediumSegment::SEGBITS;
        m_dwSegSize = CMediumSegment::SEGSIZE;
        m_dwSegMask = CMediumSegment::SEGMASK;
        break;
        
    case LK_LARGE_TABLESIZE:
        m_lkts      = LK_LARGE_TABLESIZE;
        m_dwSegBits = CLargeSegment::SEGBITS;
        m_dwSegSize = CLargeSegment::SEGSIZE;
        m_dwSegMask = CLargeSegment::SEGMASK;
        break;
    }

    m_dwBktAddrMask = m_dwSegMask;
    m_nLevel        = m_dwSegBits;
}



//-----------------------------------------------------------------------
// Function: CLKLinearHashTable::_NewSeg
// Synopsis: creates a new segment of the approriate size
// Output:   pointer to the new segment; NULL => failure
//-----------------------------------------------------------------------

CLKLinearHashTable::CSegment*
CLKLinearHashTable::_NewSeg(
    ) const
{
    CSegment* pseg = NULL;

    switch (m_lkts)
    {
    case LK_SMALL_TABLESIZE:
        pseg = new CSmallSegment;
        break;
        
    default:
        IRTLASSERT(FALSE);
        // fall-through
        
    case LK_MEDIUM_TABLESIZE:
        pseg = new CMediumSegment;
        break;
        
    case LK_LARGE_TABLESIZE:
        pseg = new CLargeSegment;
        break;
    }

    IRTLASSERT(pseg != NULL);

    if (pseg != NULL)
    {
        for (DWORD i = 0;  i < m_dwSegSize;  ++i)
            pseg->Slot(i).SetSpinCount(m_wBucketLockSpins);
    }

    return pseg;
}



//-----------------------------------------------------------------------
// Function: CLKLinearHashTable::_FindBucket
// Synopsis: finds and locks the bucket indicated by dwSignature.
// Output:   pointer to the bucket
//-----------------------------------------------------------------------

CLKLinearHashTable::CBucket*
CLKLinearHashTable::_FindBucket(
    DWORD dwSignature,
    bool  fLockForWrite) const
{
    IRTLASSERT(IsValid());
    IRTLASSERT(m_dwBktAddrMask > 0);
    IRTLASSERT((m_dwBktAddrMask & (m_dwBktAddrMask + 1)) == 0); // 00011..111
    IRTLASSERT(m_dwBktAddrMask == (1U << m_nLevel) - 1);
    IRTLASSERT(0 <= m_iExpansionIdx  &&  m_iExpansionIdx <= m_dwBktAddrMask);
    IRTLASSERT(0 < m_dwSegBits  &&  m_dwSegBits < 20
               &&  m_dwSegSize == (1U << m_dwSegBits)
               &&  m_dwSegMask == (m_dwSegSize - 1));
    IRTLASSERT(_IsReadLocked()  ||  _IsWriteLocked());

    const DWORD dwBktAddr = _BucketAddress(dwSignature);
    IRTLASSERT(dwBktAddr < m_cActiveBuckets);

    CBucket* const pbkt = _Bucket(dwBktAddr);
    IRTLASSERT(pbkt != NULL);

    if (fLockForWrite)
        pbkt->WriteLock();
    else
        pbkt->ReadLock();

    return pbkt;

} // _FindBucket



//-----------------------------------------------------------------------
// Function: CLKLinearHashTable::_Expand
// Synopsis: Expands the table by one bucket. Done by splitting the
//           bucket pointed to by m_iExpansionIdx.
// Output:   LK_SUCCESS, if expansion was successful.
//           LK_ALLOC_FAIL, if expansion failed.
//-----------------------------------------------------------------------

LK_RETCODE
CLKLinearHashTable::_Expand()
{
    if (m_cActiveBuckets >= MAX_DIRSIZE * m_dwSegSize)
        return LK_ALLOC_FAIL;  // table is not allowed to grow any more

    _WriteLock();

    // double directory size if necessary
    if (m_cActiveBuckets >= m_cDirSegs * m_dwSegSize)
    {
        IRTLASSERT(m_cDirSegs < MAX_DIRSIZE);
        DWORD cDirSegsNew = m_cDirSegs << 1;
        CDirEntry* paDirSegsNew = new CDirEntry [cDirSegsNew];

        if (paDirSegsNew != NULL)
        {
            for (DWORD j = 0;  j < m_cDirSegs;  j++)
            {
                paDirSegsNew[j] = m_paDirSegs[j];
                m_paDirSegs[j].m_pseg = NULL;
            }

            delete [] m_paDirSegs;
            m_paDirSegs = paDirSegsNew;
            m_cDirSegs = cDirSegsNew;
        }
    }

    // locate the new bucket, creating a new segment if necessary
    DWORD     dwOldBkt = m_iExpansionIdx;
    DWORD     dwNewBkt = (1 << m_nLevel) | dwOldBkt;
    CSegment* psegNew  = _Segment(dwNewBkt);

    if (psegNew == NULL)
    {
        psegNew = _NewSeg();
        if (psegNew == NULL)
        {
            _WriteUnlock();
            return LK_ALLOC_FAIL;  // expansion failed
        }
        _Segment(dwNewBkt) = psegNew;
    }

    // adjust expansion pointer, level, and mask
    if (++m_iExpansionIdx == (1U << m_nLevel))
    {
        ++m_nLevel;
        m_dwBktAddrMask = (m_dwBktAddrMask << 1) | 1;
        m_iExpansionIdx = 0;
        IRTLASSERT((m_dwBktAddrMask & (m_dwBktAddrMask+1)) == 0); // 00011..111
    }
    ++m_cActiveBuckets;

    IRTLASSERT(dwOldBkt < m_cActiveBuckets);
    IRTLASSERT(dwNewBkt < m_cActiveBuckets);

    // prepare to relocate records to the new bucket
    CBucket* pbktOld = _Bucket(dwOldBkt);
    CBucket* pbktNew = _Bucket(dwNewBkt);

    // get locks on the two buckets involved but release
    // the table lock before doing the actual relocation
    pbktOld->WriteLock();
    pbktNew->WriteLock();
    DWORD iExpansionIdx = m_iExpansionIdx;   // save to avoid race conditions
    _WriteUnlock();

    LK_RETCODE lkrc = _SplitRecordSet(&pbktOld->m_ncFirst, &pbktNew->m_ncFirst,
                                      iExpansionIdx, dwNewBkt);

    pbktNew->WriteUnlock();
    pbktOld->WriteUnlock();

    return lkrc;
} // _Expand



//------------------------------------------------------------------------
// Function: CLKLinearHashTable::_SplitRecordSet
// Synopsis: Split records between the old and new buckets.
//------------------------------------------------------------------------

LK_RETCODE
CLKLinearHashTable::_SplitRecordSet(
    CNodeClump* pncOldTarget,
    CNodeClump* pncNewTarget,
    DWORD       iExpansionIdx,
    DWORD       dwNewBkt
    )
{
    LK_RETCODE  lkrc = LK_SUCCESS;
    CNodeClump* pncFreeList = NULL;   // list of free nodes available for reuse
    CNodeClump  ncFirst = *pncOldTarget;    // save head of old target chain
    CNodeClump* pncOldList = &ncFirst;
    CNodeClump* pncTmp;
    LONG        iOldSlot = 0;
    LONG        iNewSlot = 0;

    // clear target buckets
    pncOldTarget->Clear();
    pncNewTarget->Clear();

    // scan through the old bucket chain and decide where to move each record
    while (pncOldList != NULL)
    {
        for (DWORD i = 0;  i < NODES_PER_CLUMP;  i++)
        {
            if (pncOldList->m_pvNode[i] == NULL)
            {
                IRTLASSERT(pncOldList->m_dwKeySigs[i] == 0);
                continue;
            }

            // calculate bucket address of this node
            DWORD dwBkt = _H0(pncOldList->m_dwKeySigs[i]);
            if (dwBkt < iExpansionIdx)
                dwBkt = _H1(pncOldList->m_dwKeySigs[i]);

            // record to be moved to the new address?
            if (dwBkt == dwNewBkt)
            {
                // node in new bucket chain full?
                if (iNewSlot == NODES_PER_CLUMP)
                {
                    pncTmp = pncFreeList;
                    if (pncTmp == NULL)
                    {
                        pncTmp = new CNodeClump;
                        // BUGBUG: better cleanup.  Returning now will leave
                        // table in inconsistent state.  Of course, if we
                        // don't have enough memory for a small object like a
                        // CNodeClump, we've got more serious problems anyway.
                        if (pncTmp == NULL)
                        {
                            m_lkrcState = LK_UNUSABLE;    // IsValid will fail
                            return LK_ALLOC_FAIL;
                        }
                    }
                    else
                    {
                        pncFreeList = pncTmp->m_pncNext;
                        pncTmp->m_pncNext = NULL;
                    }
                    pncNewTarget->m_pncNext = pncTmp;
                    pncNewTarget = pncTmp;
                    iNewSlot = 0;
                }

                pncNewTarget->m_dwKeySigs[iNewSlot]
                    = pncOldList->m_dwKeySigs[i];
                pncNewTarget->m_pvNode[iNewSlot]
                    = pncOldList->m_pvNode[i];
                ++iNewSlot;
            }

            // no, record stays in its current bucket chain
            else
            {
                // node in old bucket chain full?
                if (iOldSlot == NODES_PER_CLUMP)
                {
                    pncTmp = pncFreeList;
                    if (pncTmp == NULL)
                    {
                        pncTmp = new CNodeClump;
                        // BUGBUG: better cleanup.
                        if (pncTmp == NULL)
                        {
                            m_lkrcState = LK_UNUSABLE;    // IsValid will fail
                            return LK_ALLOC_FAIL;
                        }
                    }
                    else
                    {
                        pncFreeList = pncTmp->m_pncNext;
                        pncTmp->Clear();
                    }
                    pncOldTarget->m_pncNext = pncTmp;
                    pncOldTarget = pncTmp;
                    iOldSlot = 0;
                }

                pncOldTarget->m_dwKeySigs[iOldSlot]
                    = pncOldList->m_dwKeySigs[i];
                pncOldTarget->m_pvNode[iOldSlot]
                    = pncOldList->m_pvNode[i];
                ++iOldSlot;
            }

            // clear old slot
            pncOldList->m_dwKeySigs[i] = 0;
            pncOldList->m_pvNode[i] = NULL;
        }

        // keep walking down the original bucket chain
        pncTmp = pncOldList;
        pncOldList = pncOldList->m_pncNext;

        // ncFirst is a stack variable, not allocated on the heap
        if (pncTmp != &ncFirst)
        {
            pncTmp->m_pncNext = pncFreeList;
            pncFreeList = pncTmp;
        }
    }

    // delete any leftover nodes
    while (pncFreeList != NULL)
    {
        pncTmp = pncFreeList;
        pncFreeList = pncFreeList->m_pncNext;
#ifdef _DEBUG
        pncTmp->m_pncNext = NULL; // or ~CNodeClump will ASSERT
#endif // _DEBUG
        delete pncTmp;
    }

#ifdef _DEBUG
    ncFirst.m_pncNext = NULL; // or ~CNodeClump will ASSERT
#endif // _DEBUG

    return lkrc;
} // _SplitRecordSet



//------------------------------------------------------------------------
// Function: CLKLinearHashTable::_Contract
// Synopsis: Contract the table by deleting the last bucket in the active
//           address space. Return the records to the "buddy" of the
//           deleted bucket.
//------------------------------------------------------------------------

LK_RETCODE
CLKLinearHashTable::_Contract()
{
    _WriteLock();

    // update the state variables (expansion ptr, level and mask)
    if (m_iExpansionIdx > 0)
        --m_iExpansionIdx;
    else
    {
        --m_nLevel;
        m_dwBktAddrMask >>= 1;
        m_iExpansionIdx = (1 << m_nLevel) - 1;
        IRTLASSERT(m_nLevel > 0  &&  m_iExpansionIdx > 0);
        IRTLASSERT((m_dwBktAddrMask & (m_dwBktAddrMask+1)) == 0); // 00011..111
    }

    // The last bucket is the one that will be emptied
    CBucket* pbktLast = _Bucket(m_cActiveBuckets - 1);
    pbktLast->WriteLock();

    // Decrement after calculating pbktLast, or _Bucket() will assert.
    --m_cActiveBuckets;

    // Where the nodes from pbktLast will end up
    CBucket* pbktNew = _Bucket(m_iExpansionIdx);
    pbktNew->WriteLock();

    // Copy the chain of records from pbktLast
    CNodeClump ncOldFirst = pbktLast->m_ncFirst;

    // destroy pbktLast
    pbktLast->m_ncFirst.Clear();
    pbktLast->WriteUnlock();

    // remove segment, if empty
    if (_SegIndex(m_cActiveBuckets) == 0)
    {
#ifdef _DEBUG
        // double-check that the supposedly empty segment is really empty
        IRTLASSERT(_Segment(m_cActiveBuckets) != NULL);
        for (DWORD i = 0;  i < m_dwSegSize;  ++i)
        {
            CBucket* pbkt = &_Segment(m_cActiveBuckets)->Slot(i);
            IRTLASSERT(pbkt->IsWriteUnlocked()  &&  pbkt->IsReadUnlocked());
            IRTLASSERT(pbkt->m_ncFirst.m_pncNext == NULL);

            for (DWORD j = 0;  j < NODES_PER_CLUMP;  ++j)
            {
                IRTLASSERT(pbkt->m_ncFirst.m_dwKeySigs[j] == 0
                           &&  pbkt->m_ncFirst.m_pvNode[j] == NULL);
            }
        }
#endif
        delete _Segment(m_cActiveBuckets);
        _Segment(m_cActiveBuckets) = NULL;
    }

    // reduce directory of segments if possible
    if (m_cActiveBuckets <= (m_cDirSegs * m_dwSegSize) >> 1
        &&  m_cDirSegs > MIN_DIRSIZE)
    {
        DWORD cDirSegsNew = m_cDirSegs >> 1;
        CDirEntry* paDirSegsNew = new CDirEntry [cDirSegsNew];

        if (paDirSegsNew != NULL)
        {
            for (DWORD j = 0;  j < cDirSegsNew;  j++)
                paDirSegsNew[j] = m_paDirSegs[j];
            for (j = 0;  j < m_cDirSegs;  j++)
                m_paDirSegs[j].m_pseg = NULL;

            delete [] m_paDirSegs;
            m_paDirSegs = paDirSegsNew;
            m_cDirSegs  = cDirSegsNew;
        }
    }

    // release the table lock before doing the reorg
    _WriteUnlock();

    LK_RETCODE lkrc = _MergeRecordSets(pbktNew, &ncOldFirst);
    pbktNew->WriteUnlock();

#ifdef _DEBUG
    ncOldFirst.m_pncNext = NULL; // or ~CNodeClump will ASSERT
#endif // _DEBUG

    return lkrc;
} // _Contract



//------------------------------------------------------------------------
// Function: CLKLinearHashTable::_MergeRecordSets
// Synopsis: Merge two record sets.  Copy the contents of pncOldList
//           into pbktNewTarget.
//------------------------------------------------------------------------

LK_RETCODE
CLKLinearHashTable::_MergeRecordSets(
    CBucket*    pbktNewTarget,
    CNodeClump* pncOldList
    )
{
    IRTLASSERT(pbktNewTarget != NULL  &&  pncOldList != NULL);

    LK_RETCODE    lkrc = LK_SUCCESS;
    CNodeClump*   pncFreeList = NULL;  // list of nodes available for reuse
    CNodeClump*   pncTmp = NULL;
    CNodeClump* const pncOldFirst = pncOldList;
    CNodeClump*   pncNewTarget = &pbktNewTarget->m_ncFirst;
    DWORD         iNewSlot;

    // find the first nodeclump in the new target bucket with an empty slot
    while (pncNewTarget->m_pncNext != NULL)
    {
        for (iNewSlot = 0;  iNewSlot < NODES_PER_CLUMP;  iNewSlot++)
            if (pncNewTarget->m_pvNode[iNewSlot] == NULL)
                break;

        if (iNewSlot == NODES_PER_CLUMP)
            pncNewTarget = pncNewTarget->m_pncNext;
        else
            break;
    }

    IRTLASSERT(pncNewTarget != NULL);

    // find the first empty slot in pncNewTarget;
    // if none, iNewSlot == NODES_PER_CLUMP
    for (iNewSlot = 0;  iNewSlot < NODES_PER_CLUMP;  iNewSlot++)
    {
        if (pncNewTarget->m_pvNode[iNewSlot] == NULL)
        {
            break;
        }
    }
    
    while (pncOldList != NULL)
    {
        for (DWORD i = 0;  i < NODES_PER_CLUMP;  i++)
        {
            if (pncOldList->m_pvNode[i] != NULL)
            {
                // any empty slots left in pncNewTarget?
                if (iNewSlot == NODES_PER_CLUMP)
                {
                    // no, so walk down pncNewTarget until we find another
                    // emptry slot
                    while (pncNewTarget->m_pncNext != NULL)
                    {
                        pncNewTarget = pncNewTarget->m_pncNext;
                        for (iNewSlot = 0;
                             iNewSlot < NODES_PER_CLUMP;
                             iNewSlot++)
                        {
                            if (pncNewTarget->m_pvNode[iNewSlot] == NULL)
                                goto found_slot;
                        }
                    }

                    // Oops, reached the last nodeclump in pncNewTarget
                    // and it's full.  Get a new nodeclump off the free
                    // list, or allocate one if the free list is empty.
                    IRTLASSERT(pncNewTarget != NULL);
                    pncTmp = pncFreeList;

                    if (pncTmp != NULL)
                    {
                        pncFreeList = pncTmp->m_pncNext;
                        pncTmp->Clear();
                    }
                    else
                    {
                        pncTmp = new CNodeClump;
                        // BUGBUG: better cleanup.  Returning now will leave
                        // table in inconsistent state.  Of course, if we
                        // don't have enough memory for a small object like a
                        // CNodeClump, we've got more serious problems anyway.
                        if (pncTmp == NULL)
                        {
                            m_lkrcState = LK_UNUSABLE;    // IsValid will fail
                            return LK_ALLOC_FAIL;
                        }
                    }

                    pncNewTarget->m_pncNext = pncTmp;
                    pncNewTarget = pncTmp;
                    iNewSlot = 0;
                }

              found_slot:
                // We have an empty slot in pncNewTarget
                IRTLASSERT(0 <= iNewSlot  &&  iNewSlot < NODES_PER_CLUMP
                       &&  pncNewTarget != NULL
                       &&  pncNewTarget->m_pvNode[iNewSlot] == NULL
                       &&  pncNewTarget->m_dwKeySigs[iNewSlot] == 0);

                // Let's copy the node from pncOldList
                pncNewTarget->m_dwKeySigs[iNewSlot]
                    = pncOldList->m_dwKeySigs[i];
                pncNewTarget->m_pvNode[iNewSlot]
                    = pncOldList->m_pvNode[i];

                // Clear old slot
                pncOldList->m_dwKeySigs[i] = 0;
                pncOldList->m_pvNode[i] = NULL;

                // find the next free slot in pncNewTarget
                while (++iNewSlot < NODES_PER_CLUMP)
                {
                    if (pncNewTarget->m_pvNode[iNewSlot] == NULL)
                    {
                        break;
                    }
                }
            }
            else
            {
                IRTLASSERT(pncOldList->m_dwKeySigs[i] == 0);
            }
        }

        // Move into the next nodeclump in pncOldList
        pncTmp = pncOldList;
        pncOldList = pncOldList->m_pncNext;

        // Append to the free list.  Don't put the first node of
        // pncOldList on the free list, as it's a stack variable.
        if (pncTmp != pncOldFirst)
        {
            pncTmp->m_pncNext = pncFreeList;
            pncFreeList = pncTmp;
        }
    }

    // delete any leftover nodes
    while (pncFreeList != NULL)
    {
        pncTmp = pncFreeList;
        pncFreeList = pncFreeList->m_pncNext;
#ifdef _DEBUG
        pncTmp->m_pncNext = NULL; // or ~CNodeClump will ASSERT
#endif // _DEBUG
        delete pncTmp;
    }

    return lkrc;
} // _MergeRecordSets




//------------------------------------------------------------------------
// Function: CLKLinearHashTable::_InitializeIterator
// Synopsis: Make the iterator point to the first record in the hash table.
//------------------------------------------------------------------------

LK_RETCODE
CLKLinearHashTable::_InitializeIterator(
    CIterator* piter)
{
    IRTLASSERT(piter != NULL);
    IRTLASSERT(piter->m_lkl == LKL_WRITELOCK
               ?  _IsWriteLocked()
               :  _IsReadLocked());
    if (piter == NULL  ||  piter->m_plht != NULL)
        return LK_BAD_ITERATOR;

    piter->m_plht = this;
    piter->m_dwBucketAddr = 0;

    CBucket* pbkt = _Bucket(piter->m_dwBucketAddr);
    IRTLASSERT(pbkt != NULL);
    if (piter->m_lkl == LKL_WRITELOCK)
        pbkt->WriteLock();
    else
        pbkt->ReadLock();

    piter->m_pnc = &pbkt->m_ncFirst;
    piter->m_iNode = -1;

    // Let IncrementIterator do the hard work of finding the first
    // slot in use.
    return IncrementIterator(piter);
}



//------------------------------------------------------------------------
// Function: CLKHashTable::InitializeIterator
// Synopsis: make the iterator point to the first record in the hash table
//------------------------------------------------------------------------

LK_RETCODE
CLKHashTable::InitializeIterator(
    CIterator* piter)
{
    IRTLASSERT(piter != NULL  &&  piter->m_pht == NULL);
    if (piter == NULL  ||  piter->m_pht != NULL)
        return LK_BAD_ITERATOR;

    if (!IsValid())
        return LK_UNUSABLE;

    // First, lock all the subtables
    if (piter->m_lkl == LKL_WRITELOCK)
        _WriteLock();
    else
        _ReadLock();

    piter->m_pht  = this;
    piter->m_ist  = -1;
    piter->m_plht = NULL;

    // Let IncrementIterator do the hard work of finding the first
    // valid node in the subtables.
    return IncrementIterator(piter);
}



//------------------------------------------------------------------------
// Function: CLKLinearHashTable::IncrementIterator
// Synopsis: move the iterator on to the next record in the hash table
//------------------------------------------------------------------------

LK_RETCODE
CLKLinearHashTable::IncrementIterator(
    CIterator* piter)
{
    IRTLASSERT(piter != NULL);
    IRTLASSERT(piter->m_plht == this);
    IRTLASSERT(piter->m_lkl == LKL_WRITELOCK
               ?  _IsWriteLocked()
               :  _IsReadLocked());
    IRTLASSERT(piter->m_dwBucketAddr < m_cActiveBuckets);
    IRTLASSERT(piter->m_pnc != NULL);
    IRTLASSERT(-1 <= piter->m_iNode  &&  piter->m_iNode < NODES_PER_CLUMP);

    if (piter == NULL  ||  piter->m_plht != this)
        return LK_BAD_ITERATOR;

    const void* pvRecord = NULL;

    if (piter->m_iNode >= 0)
    {
        // Release the reference acquired in the previous call to
        // IncrementIterator
        pvRecord = piter->m_pnc->m_pvNode[piter->m_iNode];
        _AddRefRecord(pvRecord, -1);
    }

    do
    {
        do
        {
            // find the next slot in the nodeclump that's in use
            while (++piter->m_iNode < NODES_PER_CLUMP)
            {
                pvRecord = piter->m_pnc->m_pvNode[piter->m_iNode];
                if (pvRecord != NULL)
                {
                    // Add a new reference
                    _AddRefRecord(pvRecord, +1);
                    return LK_SUCCESS;
                }
            }

            // try the next nodeclump in the bucket chain
            piter->m_iNode = -1;
            piter->m_pnc = piter->m_pnc->m_pncNext;
        } while (piter->m_pnc != NULL);

        // Exhausted this bucket chain.  Unlock it.
        CBucket* pbkt = _Bucket(piter->m_dwBucketAddr);
        IRTLASSERT(pbkt != NULL);
        IRTLASSERT(piter->m_lkl == LKL_WRITELOCK
                   ?  pbkt->IsWriteLocked()
                   :  pbkt->IsReadLocked());
        if (piter->m_lkl == LKL_WRITELOCK)
            pbkt->WriteUnlock();
        else
            pbkt->ReadUnlock();

        // Try the next bucket, if there is one
        if (++piter->m_dwBucketAddr < m_cActiveBuckets)
        {
            pbkt = _Bucket(piter->m_dwBucketAddr);
            IRTLASSERT(pbkt != NULL);
            if (piter->m_lkl == LKL_WRITELOCK)
                pbkt->WriteLock();
            else
                pbkt->ReadLock();
            piter->m_pnc = &pbkt->m_ncFirst;
        }
    } while (piter->m_dwBucketAddr < m_cActiveBuckets);

    // We have fallen off the end of the hashtable
    piter->m_iNode = -1;
    piter->m_pnc = NULL;

    return LK_NO_MORE_ELEMENTS;
}



//------------------------------------------------------------------------
// Function: CLKHashTable::IncrementIterator
// Synopsis: move the iterator on to the next record in the hash table
//------------------------------------------------------------------------

LK_RETCODE
CLKHashTable::IncrementIterator(
    CIterator* piter)
{
    IRTLASSERT(piter != NULL);
    IRTLASSERT(piter->m_pht == this);
    IRTLASSERT(-1 <= piter->m_ist
           &&  piter->m_ist < static_cast<int>(m_cSubTables));

    if (piter == NULL  ||  piter->m_pht != this)
        return LK_BAD_ITERATOR;

    if (!IsValid())
        return LK_UNUSABLE;

    LK_RETCODE lkrc;
    CLHTIterator* pBaseIter = static_cast<CLHTIterator*>(piter);

    for (;;)
    {
        // Do we have a valid iterator into a subtable?  If not, get one.
        while (piter->m_plht == NULL)
        {
            while (++piter->m_ist < static_cast<int>(m_cSubTables))
            {
                lkrc = m_palhtDir[piter->m_ist]->_InitializeIterator(piter);
                if (lkrc == LK_SUCCESS)
                {
                    IRTLASSERT(m_palhtDir[piter->m_ist] == piter->m_plht);
                    return lkrc;
                }
                else if (lkrc == LK_NO_MORE_ELEMENTS)
                    lkrc = piter->m_plht->_CloseIterator(pBaseIter);

                if (lkrc != LK_SUCCESS)
                    return lkrc;
            }

            // There are no more subtables left.
            return LK_NO_MORE_ELEMENTS;
        }

        // We already have a valid iterator into a subtable.  Increment it.
        lkrc = piter->m_plht->IncrementIterator(pBaseIter);
        if (lkrc == LK_SUCCESS)
            return lkrc;

        // We've exhausted that subtable.  Move on.
        if (lkrc == LK_NO_MORE_ELEMENTS)
            lkrc = piter->m_plht->_CloseIterator(pBaseIter);

        if (lkrc != LK_SUCCESS)
            return lkrc;
    }
}



//------------------------------------------------------------------------
// Function: CLKLinearHashTable::_CloseIterator
// Synopsis: release the resources held by the iterator
//------------------------------------------------------------------------

LK_RETCODE
CLKLinearHashTable::_CloseIterator(
    CIterator* piter)
{
    IRTLASSERT(piter != NULL);
    IRTLASSERT(piter->m_plht == this);
    IRTLASSERT(piter->m_lkl == LKL_WRITELOCK
               ?  _IsWriteLocked()
               :  _IsReadLocked());
    IRTLASSERT(piter->m_dwBucketAddr <= m_cActiveBuckets);
    IRTLASSERT(-1 <= piter->m_iNode  &&  piter->m_iNode < NODES_PER_CLUMP);

    if (piter == NULL  ||  piter->m_plht != this)
        return LK_BAD_ITERATOR;

    // Are we abandoning the iterator before the end of the table?
    // If so, need to unlock the bucket.
    if (piter->m_dwBucketAddr < m_cActiveBuckets)
    {
        CBucket* pbkt = _Bucket(piter->m_dwBucketAddr);
        IRTLASSERT(pbkt != NULL);
        IRTLASSERT(piter->m_lkl == LKL_WRITELOCK
                   ?  pbkt->IsWriteLocked()
                   :  pbkt->IsReadLocked());
        if (0 <= piter->m_iNode  &&  piter->m_iNode < NODES_PER_CLUMP)
        {
            IRTLASSERT(piter->m_pnc != NULL);
            const void* pvRecord = piter->m_pnc->m_pvNode[piter->m_iNode];
            _AddRefRecord(pvRecord, -1);
        }
        if (piter->m_lkl == LKL_WRITELOCK)
            pbkt->WriteUnlock();
        else
            pbkt->ReadUnlock();
    }

    piter->m_plht = NULL;
    piter->m_pnc  = NULL;

    return LK_SUCCESS;
}



//------------------------------------------------------------------------
// Function: CLKHashTable::CloseIterator
// Synopsis: release the resources held by the iterator
//------------------------------------------------------------------------

LK_RETCODE
CLKHashTable::CloseIterator(
    CIterator* piter)
{
    IRTLASSERT(piter != NULL);
    IRTLASSERT(piter->m_pht == this);
    IRTLASSERT(-1 <= piter->m_ist
           &&  piter->m_ist <= static_cast<int>(m_cSubTables));

    if (piter == NULL  ||  piter->m_pht != this)
        return LK_BAD_ITERATOR;

    if (!IsValid())
        return LK_UNUSABLE;

    // Are we abandoning the iterator before we've reached the end?
    // If so, close the subtable iterator.
    if (piter->m_plht != NULL)
    {
        IRTLASSERT(piter->m_ist < static_cast<int>(m_cSubTables));
        CLHTIterator* pBaseIter = static_cast<CLHTIterator*>(piter);
        piter->m_plht->_CloseIterator(pBaseIter);
    }

    // Unlock all the subtables
    if (piter->m_lkl == LKL_WRITELOCK)
        _WriteUnlock();
    else
        _ReadUnlock();

    piter->m_plht = NULL;
    piter->m_pht  = NULL;
    piter->m_ist  = -1;

    return LK_SUCCESS;
}


//------------------------------------------------------------------------
// Function: CLKHashTable::_WriteLock
// Synopsis: Lock all subtables for writing
//------------------------------------------------------------------------

void
CLKHashTable::_WriteLock()
{
    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        m_palhtDir[i]->_WriteLock();
        IRTLASSERT(m_palhtDir[i]->_IsWriteLocked());
    }
}



//------------------------------------------------------------------------
// Function: CLKHashTable::_ReadLock
// Synopsis: Lock all subtables for reading
//------------------------------------------------------------------------

void
CLKHashTable::_ReadLock() const
{
    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        m_palhtDir[i]->_ReadLock();
        IRTLASSERT(m_palhtDir[i]->_IsReadLocked());
    }
}



//------------------------------------------------------------------------
// Function: CLKHashTable::_WriteUnlock
// Synopsis: Unlock all subtables
//------------------------------------------------------------------------

void
CLKHashTable::_WriteUnlock() const
{
    // unlock in reverse order: LIFO
    for (DWORD i = m_cSubTables;  i-- > 0;  )
    {
        IRTLASSERT(m_palhtDir[i]->_IsWriteLocked());
        m_palhtDir[i]->_WriteUnlock();
        IRTLASSERT(m_palhtDir[i]->_IsWriteUnlocked());
    }
}



//------------------------------------------------------------------------
// Function: CLKHashTable::_ReadUnlock
// Synopsis: Unlock all subtables
//------------------------------------------------------------------------

void
CLKHashTable::_ReadUnlock() const
{
    // unlock in reverse order: LIFO
    for (DWORD i = m_cSubTables;  i-- > 0;  )
    {
        IRTLASSERT(m_palhtDir[i]->_IsReadLocked());
        m_palhtDir[i]->_ReadUnlock();
        IRTLASSERT(m_palhtDir[i]->_IsReadUnlocked());
    }
}



//------------------------------------------------------------------------
// Function: CLKHashTable::Size
// Synopsis: Number of elements in the table
//------------------------------------------------------------------------

DWORD
CLKHashTable::Size() const
{
    DWORD cSize = 0;

    for (DWORD i = 0;  i < m_cSubTables;  i++)
        cSize += m_palhtDir[i]->Size();

    return cSize;
}



//------------------------------------------------------------------------
// Function: CLKHashTable::MaxSize
// Synopsis: Maximum possible number of elements in the table
//------------------------------------------------------------------------

DWORD
CLKHashTable::MaxSize() const
{
    return (m_cSubTables == 0)  ? 0  : m_cSubTables * m_palhtDir[0]->MaxSize();
}



//------------------------------------------------------------------------
// Function: CLKHashTable::IsValid
// Synopsis: is the table valid?
//------------------------------------------------------------------------

bool
CLKHashTable::IsValid() const
{
    bool f = (m_lkrcState == LK_SUCCESS     // serious internal failure?
              &&  (m_palhtDir != NULL  &&  m_cSubTables > 0)
              &&  ValidSignature());

    for (DWORD i = 0;  f  &&  i < m_cSubTables;  i++)
        f = f && m_palhtDir[i]->IsValid();

    return f;
}



//------------------------------------------------------------------------
// Function: CLKHashTable::SetBucketLockSpinCount
// Synopsis: 
//------------------------------------------------------------------------

void
CLKLinearHashTable::SetBucketLockSpinCount(
    WORD wSpins)
{
    m_wBucketLockSpins = wSpins;

    for (DWORD i = 0;  i < m_cDirSegs;  i++)
    {
        CSegment* pseg = m_paDirSegs[i].m_pseg;

        if (pseg != NULL)
        {
            for (DWORD j = 0;  j < m_dwSegSize;  ++j)
            {
                pseg->Slot(j).SetSpinCount(wSpins);
            }
        }
    }
}



//------------------------------------------------------------------------
// Function: CLKHashTable::SetBucketLockSpinCount
// Synopsis: 
//------------------------------------------------------------------------

WORD
CLKLinearHashTable::GetBucketLockSpinCount()
{
    CBucket* const pbkt = _Bucket(0);
    IRTLASSERT(pbkt != NULL);
    return pbkt->GetSpinCount();
}



//------------------------------------------------------------------------
// Function: CLKHashTable::SetTableLockSpinCount
// Synopsis: 
//------------------------------------------------------------------------

void
CLKHashTable::SetTableLockSpinCount(
    WORD wSpins)
{
    for (DWORD i = 0;  i < m_cSubTables;  i++)
        m_palhtDir[i]->SetTableLockSpinCount(wSpins);
}



//------------------------------------------------------------------------
// Function: CLKHashTable::GetTableLockSpinCount
// Synopsis: 
//------------------------------------------------------------------------

WORD
CLKHashTable::GetTableLockSpinCount()
{
    return ((m_cSubTables == 0)
            ?  LOCK_DEFAULT_SPINS
            :  m_palhtDir[0]->GetTableLockSpinCount());
}



//------------------------------------------------------------------------
// Function: CLKHashTable::SetBucketLockSpinCount
// Synopsis: 
//------------------------------------------------------------------------

void
CLKHashTable::SetBucketLockSpinCount(
    WORD wSpins)
{
    for (DWORD i = 0;  i < m_cSubTables;  i++)
        m_palhtDir[i]->SetBucketLockSpinCount(wSpins);
}



//------------------------------------------------------------------------
// Function: CLKHashTable::GetBucketLockSpinCount
// Synopsis: 
//------------------------------------------------------------------------

WORD
CLKHashTable::GetBucketLockSpinCount()
{
    return ((m_cSubTables == 0)
            ?  LOCK_DEFAULT_SPINS
            :  m_palhtDir[0]->GetBucketLockSpinCount());
}



#ifdef __LKHASH_NAMESPACE__
}
#endif // __LKHASH_NAMESPACE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\lkrhash\locks.cpp ===
/*++

   Copyright    (c)    1998-2000    Microsoft Corporation

   Module  Name :
       locks.cpp

   Abstract:
       A collection of locks for multithreaded access to data structures

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/


#include "precomp.hxx"

#define DLL_IMPLEMENTATION
#define IMPLEMENTATION_EXPORT
#include <locks.h>
#include "_locks.h"


//------------------------------------------------------------------------
// Not all Win32 platforms support all the functions we want. Set up dummy
// thunks and use GetProcAddress to find their addresses at runtime.

typedef
BOOL
(WINAPI * PFN_SWITCH_TO_THREAD)(
    VOID
    );

static BOOL WINAPI
FakeSwitchToThread(
    VOID)
{
    return FALSE;
}

PFN_SWITCH_TO_THREAD  g_pfnSwitchToThread = NULL;


typedef
BOOL
(WINAPI * PFN_TRY_ENTER_CRITICAL_SECTION)(
    IN OUT LPCRITICAL_SECTION lpCriticalSection
    );

static BOOL WINAPI
FakeTryEnterCriticalSection(
    LPCRITICAL_SECTION /*lpCriticalSection*/)
{
    return FALSE;
}

PFN_TRY_ENTER_CRITICAL_SECTION g_pfnTryEnterCritSec = NULL;


typedef
DWORD
(WINAPI * PFN_SET_CRITICAL_SECTION_SPIN_COUNT)(
    LPCRITICAL_SECTION lpCriticalSection,
    DWORD dwSpinCount
   );

static DWORD WINAPI
FakeSetCriticalSectionSpinCount(
    LPCRITICAL_SECTION /*lpCriticalSection*/,
    DWORD              /*dwSpinCount*/)
{
    // For faked critical sections, the previous spin count is just ZERO!
    return 0;
}

PFN_SET_CRITICAL_SECTION_SPIN_COUNT  g_pfnSetCSSpinCount = NULL;

DWORD g_cProcessors = 0;


class CSimpleLock
{
  public:
    CSimpleLock()
        : m_l(0)
    {}

    void Enter()
    {
        while (Lock_AtomicExchange(const_cast<LONG*>(&m_l), 1) != 0)
            Sleep(0);
    }

    void Leave()
    {
        Lock_AtomicExchange(const_cast<LONG*>(&m_l), 0);
    }

    volatile LONG m_l;
};


BOOL g_fLocksInitialized = FALSE;
CSimpleLock g_lckInit;

BOOL
Locks_Initialize()
{
    if (!g_fLocksInitialized)
    {
        g_lckInit.Enter();
    
        if (!g_fLocksInitialized)
        {
            // load kernel32 and get NT-specific entry points
            HMODULE hKernel32 = GetModuleHandle(TEXT("kernel32.dll"));

            if (hKernel32 != NULL)
            {
                g_pfnSwitchToThread = (PFN_SWITCH_TO_THREAD)
                    GetProcAddress(hKernel32, "SwitchToThread");
                
                g_pfnTryEnterCritSec = (PFN_TRY_ENTER_CRITICAL_SECTION)
                    GetProcAddress(hKernel32, "TryEnterCriticalSection");
                
                g_pfnSetCSSpinCount = (PFN_SET_CRITICAL_SECTION_SPIN_COUNT)
                    GetProcAddress(hKernel32, "SetCriticalSectionSpinCount");
            }
            
            if (g_pfnSwitchToThread == NULL)
                g_pfnSwitchToThread = FakeSwitchToThread;
            
            if (g_pfnTryEnterCritSec == NULL)
                g_pfnTryEnterCritSec = FakeTryEnterCriticalSection;
            
            if (g_pfnSetCSSpinCount == NULL)
                g_pfnSetCSSpinCount = FakeSetCriticalSectionSpinCount;
            
            g_cProcessors = NumProcessors();

            Lock_AtomicExchange((LONG*) &g_fLocksInitialized, TRUE);
        }
        
        g_lckInit.Leave();
    }

    return TRUE;
}


BOOL
Locks_Cleanup()
{
    return TRUE;
}



#ifdef __LOCKS_NAMESPACE__
namespace Locks {
#endif // __LOCKS_NAMESPACE__


#define LOCK_DEFAULT_SPIN_DATA(CLASS)                       \
  WORD   CLASS::sm_wDefaultSpinCount  = LOCK_DEFAULT_SPINS; \
  double CLASS::sm_dblDfltSpinAdjFctr = 0.5


#ifdef LOCK_INSTRUMENTATION

# define LOCK_STATISTICS_DATA(CLASS)            \
LONG        CLASS::sm_cTotalLocks       = 0;    \
LONG        CLASS::sm_cContendedLocks   = 0;    \
LONG        CLASS::sm_nSleeps           = 0;    \
LONGLONG    CLASS::sm_cTotalSpins       = 0;    \
LONG        CLASS::sm_nReadLocks        = 0;    \
LONG        CLASS::sm_nWriteLocks       = 0


# define LOCK_STATISTICS_DUMMY_IMPLEMENTATION(CLASS)            \
CLockStatistics                 CLASS::Statistics() const       \
{return CLockStatistics();}                                     \
CGlobalLockStatistics           CLASS::GlobalStatistics()       \
{return CGlobalLockStatistics();}                               \
void                            CLASS::ResetGlobalStatistics()  \
{}


# define LOCK_STATISTICS_REAL_IMPLEMENTATION(CLASS)             \
                                                                \
/* Per-lock statistics */                                       \
CLockStatistics                                                 \
CLASS::Statistics() const                                       \
{                                                               \
    CLockStatistics ls;                                         \
                                                                \
    ls.m_nContentions     = m_nContentions;                     \
    ls.m_nSleeps          = m_nSleeps;                          \
    ls.m_nContentionSpins = m_nContentionSpins;                 \
    if (m_nContentions > 0)                                     \
        ls.m_nAverageSpins = m_nContentionSpins / m_nContentions;\
    else                                                        \
        ls.m_nAverageSpins = 0;                                 \
    ls.m_nReadLocks       = m_nReadLocks;                       \
    ls.m_nWriteLocks      = m_nWriteLocks;                      \
    strcpy(ls.m_szName, m_szName);                              \
                                                                \
    return ls;                                                  \
}                                                               \
                                                                \
                                                                \
/* Global statistics for CLASS */                               \
CGlobalLockStatistics                                           \
CLASS::GlobalStatistics()                                       \
{                                                               \
    CGlobalLockStatistics gls;                                  \
                                                                \
    gls.m_cTotalLocks      = sm_cTotalLocks;                    \
    gls.m_cContendedLocks  = sm_cContendedLocks;                \
    gls.m_nSleeps          = sm_nSleeps;                        \
    gls.m_cTotalSpins      = sm_cTotalSpins;                    \
    if (sm_cContendedLocks > 0)                                 \
        gls.m_nAverageSpins = static_cast<LONG>(sm_cTotalSpins / \
                                                sm_cContendedLocks);\
    else                                                        \
        gls.m_nAverageSpins = 0;                                \
    gls.m_nReadLocks       = sm_nReadLocks;                     \
    gls.m_nWriteLocks      = sm_nWriteLocks;                    \
                                                                \
    return gls;                                                 \
}                                                               \
                                                                \
                                                                \
/* Reset global statistics for CLASS */                         \
void                                                            \
CLASS::ResetGlobalStatistics()                                  \
{                                                               \
    sm_cTotalLocks       = 0;                                   \
    sm_cContendedLocks   = 0;                                   \
    sm_nSleeps           = 0;                                   \
    sm_cTotalSpins       = 0;                                   \
    sm_nReadLocks        = 0;                                   \
    sm_nWriteLocks       = 0;                                   \
}


// Note: we are not using Interlocked operations for the shared
// statistical counters.  We'll lose perfect accuracy, but we'll
// gain by reduced bus synchronization traffic.
# define LOCK_INSTRUMENTATION_PROLOG()  \
    ++sm_cContendedLocks;               \
    LONG cTotalSpins = 0;               \
    WORD cSleeps = 0

// Don't need InterlockedIncrement or InterlockedExchangeAdd for 
// member variables, as the lock is now locked by this thread.
# define LOCK_INSTRUMENTATION_EPILOG()  \
    ++m_nContentions;                   \
    m_nSleeps += cSleeps;               \
    m_nContentionSpins += cTotalSpins;  \
    sm_nSleeps += cSleeps;              \
    sm_cTotalSpins += cTotalSpins

#else // !LOCK_INSTRUMENTATION
# define LOCK_STATISTICS_DATA(CLASS)
# define LOCK_STATISTICS_DUMMY_IMPLEMENTATION(CLASS)
# define LOCK_STATISTICS_REAL_IMPLEMENTATION(CLASS)
# define LOCK_INSTRUMENTATION_PROLOG()
# define LOCK_INSTRUMENTATION_EPILOG()
#endif // !LOCK_INSTRUMENTATION



//------------------------------------------------------------------------
// Function: RandomBackoffFactor
// Synopsis: A fudge factor to help avoid synchronization problems
//------------------------------------------------------------------------

double
RandomBackoffFactor()
{
    static const double s_aFactors[] = {
        1.020, 0.965,  0.890, 1.065,
        1.025, 1.115,  0.940, 0.995,
        1.050, 1.080,  0.915, 0.980,
        1.010,
    };
    const int nFactors = sizeof(s_aFactors) / sizeof(s_aFactors[0]);

    // Alternatives for nRand include a static counter
    // or the low DWORD of QueryPerformanceCounter().
    DWORD nRand = ::GetCurrentThreadId();

    return s_aFactors[nRand % nFactors];
}


//------------------------------------------------------------------------
// Function: SwitchOrSleep
// Synopsis: If possible, yields the thread with SwitchToThread. If that
//           doesn't work, calls Sleep.
//------------------------------------------------------------------------

void
SwitchOrSleep(
    DWORD dwSleepMSec)
{
#ifdef LOCKS_SWITCH_TO_THREAD
    if (!g_pfnSwitchToThread())
#endif
        Sleep(dwSleepMSec);
}
    



// CSmallSpinLock static member variables

LOCK_DEFAULT_SPIN_DATA(CSmallSpinLock);

#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION

LOCK_STATISTICS_DATA(CSmallSpinLock);
LOCK_STATISTICS_REAL_IMPLEMENTATION(CSmallSpinLock);

#endif // LOCK_SMALL_SPIN_INSTRUMENTATION


//------------------------------------------------------------------------
// Function: CSmallSpinLock::_LockSpin
// Synopsis: Acquire an exclusive lock.  Blocks until acquired.
//------------------------------------------------------------------------

void
CSmallSpinLock::_LockSpin()
{
#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
    LOCK_INSTRUMENTATION_PROLOG();
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION
    
    DWORD dwSleepTime = 0;
    LONG  cBaseSpins  = sm_wDefaultSpinCount;
    LONG  cBaseSpins2 = static_cast<LONG>(cBaseSpins * RandomBackoffFactor());

    // This lock cannot be acquired recursively. Attempting to do so will
    // deadlock this thread forever. Use CSpinLock instead if you need that
    // kind of lock.
    if (m_lTid == _CurrentThreadId())
    {
        IRTLASSERT(
           !"CSmallSpinLock: Illegally attempted to acquire lock recursively");
        DebugBreak();
    }

    while (!_TryLock())
    {
        // Only spin on a multiprocessor machine and then only if
        // spinning is enabled
        if (g_cProcessors > 1  &&  cBaseSpins != LOCK_DONT_SPIN)
        {
            LONG cSpins = cBaseSpins2;
        
            // Check no more than cBaseSpins2 times then yield.
            // It is important not to use the InterlockedExchange in the
            // inner loop in order to minimize system memory bus traffic.
            while (m_lTid != 0)
            { 
                if (--cSpins < 0)
                { 
#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
                    cTotalSpins += cBaseSpins2;
                    ++cSleeps;
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION
                    SwitchOrSleep(dwSleepTime) ;

                    // Backoff algorithm: reduce (or increase) busy wait time
                    cBaseSpins2 = (int) (cBaseSpins2 * sm_dblDfltSpinAdjFctr);
                    // LOCK_MINIMUM_SPINS <= cBaseSpins2 <= LOCK_MAXIMUM_SPINS
                    cBaseSpins2 = min(LOCK_MAXIMUM_SPINS, cBaseSpins2);
                    cBaseSpins2 = max(cBaseSpins2, LOCK_MINIMUM_SPINS);
                    cSpins = cBaseSpins2;

                    // Using Sleep(0) leads to the possibility of priority
                    // inversion.  Sleep(0) only yields the processor if
                    // there's another thread of the same priority that's
                    // ready to run.  If a high-priority thread is trying to
                    // acquire the lock, which is held by a low-priority
                    // thread, then the low-priority thread may never get
                    // scheduled and hence never free the lock.  NT attempts
                    // to avoid priority inversions by temporarily boosting
                    // the priority of low-priority runnable threads, but the
                    // problem can still occur if there's a medium-priority
                    // thread that's always runnable.  If Sleep(1) is used,
                    // then the thread unconditionally yields the CPU.  We
                    // only do this for the second and subsequent even
                    // iterations, since a millisecond is a long time to wait
                    // if the thread can be scheduled in again sooner
                    // (~100,000 instructions).
                    // Avoid priority inversion: 0, 1, 0, 1,...
                    dwSleepTime = !dwSleepTime;
                }
                else
                {
                    Lock_Yield();
                }
            }

            // Lock is now available, but we still need to do the
            // InterlockedExchange to atomically grab it for ourselves.
#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
            cTotalSpins += cBaseSpins2 - cSpins;
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION
        }

        // On a 1P machine, busy waiting is a waste of time
        else
        {
#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
            ++cSleeps;
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION
            SwitchOrSleep(dwSleepTime);

            // Avoid priority inversion: 0, 1, 0, 1,...
            dwSleepTime = !dwSleepTime;
        }

    }

#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
    LOCK_INSTRUMENTATION_EPILOG();
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION
}



// CSpinLock static member variables

LOCK_DEFAULT_SPIN_DATA(CSpinLock);
LOCK_STATISTICS_DATA(CSpinLock);
LOCK_STATISTICS_REAL_IMPLEMENTATION(CSpinLock);


//------------------------------------------------------------------------
// Function: CSpinLock::_LockSpin
// Synopsis: Acquire an exclusive lock.  Blocks until acquired.
//------------------------------------------------------------------------

void
CSpinLock::_LockSpin()
{
    LOCK_INSTRUMENTATION_PROLOG();
    
    DWORD dwSleepTime   = 0;
    bool  fAcquiredLock = false;
    LONG  cBaseSpins    = sm_wDefaultSpinCount;

    cBaseSpins = static_cast<LONG>(cBaseSpins * RandomBackoffFactor());

    while (!fAcquiredLock)
    {
        // Only spin on a multiprocessor machine and then only if
        // spinning is enabled
        if (g_cProcessors > 1  &&  sm_wDefaultSpinCount != LOCK_DONT_SPIN)
        {
            LONG cSpins = cBaseSpins;
        
            // Check no more than cBaseSpins times then yield
            while (m_lTid != 0)
            { 
                if (--cSpins < 0)
                { 
#ifdef LOCK_INSTRUMENTATION
                    cTotalSpins += cBaseSpins;
                    ++cSleeps;
#endif // LOCK_INSTRUMENTATION

                    SwitchOrSleep(dwSleepTime) ;

                    // Backoff algorithm: reduce (or increase) busy wait time
                    cBaseSpins = (int) (cBaseSpins * sm_dblDfltSpinAdjFctr);
                    // LOCK_MINIMUM_SPINS <= cBaseSpins <= LOCK_MAXIMUM_SPINS
                    cBaseSpins = min(LOCK_MAXIMUM_SPINS, cBaseSpins);
                    cBaseSpins = max(cBaseSpins, LOCK_MINIMUM_SPINS);
                    cSpins = cBaseSpins;
            
                    // Avoid priority inversion: 0, 1, 0, 1,...
                    dwSleepTime = !dwSleepTime;
                }
                else
                {
                    Lock_Yield();
                }
            }

            // Lock is now available, but we still need to atomically
            // update m_cOwners and m_nThreadId to grab it for ourselves.
#ifdef LOCK_INSTRUMENTATION
            cTotalSpins += cBaseSpins - cSpins;
#endif // LOCK_INSTRUMENTATION
        }

        // on a 1P machine, busy waiting is a waste of time
        else
        {
#ifdef LOCK_INSTRUMENTATION
            ++cSleeps;
#endif // LOCK_INSTRUMENTATION
            SwitchOrSleep(dwSleepTime);
            
            // Avoid priority inversion: 0, 1, 0, 1,...
            dwSleepTime = !dwSleepTime;
        }

        // Is the lock unowned?
        if (_TryLock())
            fAcquiredLock = true; // got the lock
    }

    IRTLASSERT((m_lTid & OWNER_MASK) > 0
               &&  (m_lTid & THREAD_MASK) == _CurrentThreadId());

    LOCK_INSTRUMENTATION_EPILOG();
}



// CCritSec static member variables

LOCK_DEFAULT_SPIN_DATA(CCritSec);
LOCK_STATISTICS_DATA(CCritSec);
LOCK_STATISTICS_DUMMY_IMPLEMENTATION(CCritSec);

bool
CCritSec::TryWriteLock()
{
    IRTLASSERT(g_pfnTryEnterCritSec != NULL);
    return g_pfnTryEnterCritSec(&m_cs) ? true : false;
}

//------------------------------------------------------------------------
// Function: CCritSec::SetSpinCount
// Synopsis: This function is used to call the appropriate underlying
//           functions to set the spin count for the supplied critical
//           section. The original function is supposed to be exported out
//           of kernel32.dll from NT 4.0 SP3. If the func is not available
//           from the dll, we will use a fake function.
//
// Arguments:
//   lpCriticalSection
//      Points to the critical section object.
//
//   dwSpinCount
//      Supplies the spin count for the critical section object. For UP
//      systems, the spin count is ignored and the critical section spin
//      count is set to 0. For MP systems, if contention occurs, instead of
//      waiting on a semaphore associated with the critical section, the
//      calling thread will spin for spin count iterations before doing the
//      hard wait. If the critical section becomes free during the spin, a
//      wait is avoided.
//
// Returns:
//      The previous spin count for the critical section is returned.
//------------------------------------------------------------------------

DWORD
CCritSec::SetSpinCount(
    LPCRITICAL_SECTION pcs,
    DWORD dwSpinCount)
{
    IRTLASSERT(g_pfnSetCSSpinCount != NULL);
    return g_pfnSetCSSpinCount(pcs, dwSpinCount);
}


// CFakeLock static member variables

LOCK_DEFAULT_SPIN_DATA(CFakeLock);
LOCK_STATISTICS_DATA(CFakeLock);
LOCK_STATISTICS_DUMMY_IMPLEMENTATION(CFakeLock);



// CReaderWriterLock static member variables

LOCK_DEFAULT_SPIN_DATA(CReaderWriterLock);
LOCK_STATISTICS_DATA(CReaderWriterLock);
LOCK_STATISTICS_REAL_IMPLEMENTATION(CReaderWriterLock);


void
CReaderWriterLock::_LockSpin(
    bool fWrite)
{
    LOCK_INSTRUMENTATION_PROLOG();
    
    DWORD dwSleepTime  = 0;
    LONG  cBaseSpins   = static_cast<LONG>(sm_wDefaultSpinCount
                                           * RandomBackoffFactor());
    LONG  cSpins       = cBaseSpins;
    
    for (;;)
    {
        if (g_cProcessors < 2  ||  sm_wDefaultSpinCount == LOCK_DONT_SPIN)
            cSpins = 1; // must loop once to call _TryRWLock

        for (int i = cSpins;  --i >= 0;  )
        {
            bool fLock = fWrite  ?  _TryWriteLock()  :  _TryReadLock();
            if (fLock)
            {
#ifdef LOCK_INSTRUMENTATION
                cTotalSpins += (cSpins - i - 1);
#endif // LOCK_INSTRUMENTATION
                goto locked;
            }
            Lock_Yield();
        }

#ifdef LOCK_INSTRUMENTATION
        cTotalSpins += cBaseSpins;
        ++cSleeps;
#endif // LOCK_INSTRUMENTATION

        SwitchOrSleep(dwSleepTime) ;
        dwSleepTime = !dwSleepTime; // Avoid priority inversion: 0, 1, 0, 1,...
        
        // Backoff algorithm: reduce (or increase) busy wait time
        cBaseSpins = (int) (cBaseSpins * sm_dblDfltSpinAdjFctr);
        // LOCK_MINIMUM_SPINS <= cBaseSpins <= LOCK_MAXIMUM_SPINS
        cBaseSpins = min(LOCK_MAXIMUM_SPINS, cBaseSpins);
        cBaseSpins = max(cBaseSpins, LOCK_MINIMUM_SPINS);
        cSpins = cBaseSpins;
    }

  locked:
    IRTLASSERT(fWrite ? IsWriteLocked() : IsReadLocked());

    LOCK_INSTRUMENTATION_EPILOG();
}



// CReaderWriterLock2 static member variables

LOCK_DEFAULT_SPIN_DATA(CReaderWriterLock2);
LOCK_STATISTICS_DATA(CReaderWriterLock2);
LOCK_STATISTICS_REAL_IMPLEMENTATION(CReaderWriterLock2);


void
CReaderWriterLock2::_WriteLockSpin()
{
    // Add ourselves to the queue of waiting writers
    for (LONG l = m_lRW;  !_CmpExch(l + SL_WRITER_INCR, l);  l = m_lRW)
    {
        Lock_Yield();
    }
    
    _LockSpin(true);
}


void
CReaderWriterLock2::_LockSpin(
    bool fWrite)
{
    LOCK_INSTRUMENTATION_PROLOG();
    
    DWORD dwSleepTime  = 0;
    LONG  cBaseSpins   = static_cast<LONG>(sm_wDefaultSpinCount
                                           * RandomBackoffFactor());
    LONG  cSpins       = cBaseSpins;
    
    for (;;)
    {
        if (g_cProcessors < 2  ||  sm_wDefaultSpinCount == LOCK_DONT_SPIN)
            cSpins = 1; // must loop once to call _TryRWLock

        for (int i = cSpins;  --i >= 0;  )
        {
            bool fLock = fWrite  ?  _TryWriteLock(0)  :  _TryReadLock();

            if (fLock)
            {
#ifdef LOCK_INSTRUMENTATION
                cTotalSpins += (cSpins - i - 1);
#endif // LOCK_INSTRUMENTATION
                goto locked;
            }
            Lock_Yield();
        }

#ifdef LOCK_INSTRUMENTATION
        cTotalSpins += cBaseSpins;
        ++cSleeps;
#endif // LOCK_INSTRUMENTATION

        SwitchOrSleep(dwSleepTime) ;
        dwSleepTime = !dwSleepTime; // Avoid priority inversion: 0, 1, 0, 1,...
        
        // Backoff algorithm: reduce (or increase) busy wait time
        cBaseSpins = (int) (cBaseSpins * sm_dblDfltSpinAdjFctr);
        // LOCK_MINIMUM_SPINS <= cBaseSpins <= LOCK_MAXIMUM_SPINS
        cBaseSpins = min(LOCK_MAXIMUM_SPINS, cBaseSpins);
        cBaseSpins = max(cBaseSpins, LOCK_MINIMUM_SPINS);
        cSpins = cBaseSpins;
    }

  locked:
    IRTLASSERT(fWrite ? IsWriteLocked() : IsReadLocked());

    LOCK_INSTRUMENTATION_EPILOG();
}



// CReaderWriterLock3 static member variables

LOCK_DEFAULT_SPIN_DATA(CReaderWriterLock3);
LOCK_STATISTICS_DATA(CReaderWriterLock3);
LOCK_STATISTICS_REAL_IMPLEMENTATION(CReaderWriterLock3);


void
CReaderWriterLock3::_WriteLockSpin()
{
    // Add ourselves to the queue of waiting writers
    for (LONG l = m_lRW;  !_CmpExch(l + SL_WRITER_INCR, l);  l = m_lRW)
    {
        Lock_Yield();
    }
    
    _LockSpin(true);
}


void
CReaderWriterLock3::_LockSpin(
    bool fWrite)
{
    LOCK_INSTRUMENTATION_PROLOG();
    
    DWORD dwSleepTime  = 0;
    LONG  cBaseSpins   = static_cast<LONG>(sm_wDefaultSpinCount
                                           * RandomBackoffFactor());
    LONG  cSpins       = cBaseSpins;
    
    for (;;)
    {
        if (g_cProcessors < 2  ||  sm_wDefaultSpinCount == LOCK_DONT_SPIN)
            cSpins = 1; // must loop once to call _TryRWLock

        for (int i = cSpins;  --i >= 0;  )
        {
            bool fLock = fWrite  ?  _TryWriteLock(0)  :  _TryReadLock();

            if (fLock)
            {
#ifdef LOCK_INSTRUMENTATION
                cTotalSpins += (cSpins - i - 1);
#endif // LOCK_INSTRUMENTATION
                goto locked;
            }
            Lock_Yield();
        }

#ifdef LOCK_INSTRUMENTATION
        cTotalSpins += cBaseSpins;
        ++cSleeps;
#endif // LOCK_INSTRUMENTATION

        SwitchOrSleep(dwSleepTime) ;
        dwSleepTime = !dwSleepTime; // Avoid priority inversion: 0, 1, 0, 1,...
        
        // Backoff algorithm: reduce (or increase) busy wait time
        cBaseSpins = (int) (cBaseSpins * sm_dblDfltSpinAdjFctr);
        // LOCK_MINIMUM_SPINS <= cBaseSpins <= LOCK_MAXIMUM_SPINS
        cBaseSpins = min(LOCK_MAXIMUM_SPINS, cBaseSpins);
        cBaseSpins = max(cBaseSpins, LOCK_MINIMUM_SPINS);
        cSpins = cBaseSpins;
    }

  locked:
    IRTLASSERT(fWrite ? IsWriteLocked() : IsReadLocked());

    LOCK_INSTRUMENTATION_EPILOG();
}



#ifdef __LOCKS_NAMESPACE__
}
#endif // __LOCKS_NAMESPACE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\nexusobjects\ppnexusclient.cpp ===
#include "precomp.h"
#include <comdef.h>
#include <wininet.h>
#include "KeyCrypto.h"

PassportAlertInterface* g_pAlert    = NULL;

PpNexusClient::PpNexusClient()
{
    LocalConfigurationUpdated();
}


void
PpNexusClient::ReportBadDocument(
    tstring&    strURL,
    IStream*    piStream
    )
{
    HGLOBAL         hStreamMem;
    VOID*           pStream;
    ULARGE_INTEGER  liStreamSize;
    DWORD           dwOutputSize;
    LARGE_INTEGER   liZero = { 0, 0 };
    LPCTSTR         apszErrors[] = { strURL.c_str() };

    piStream->Seek(liZero, STREAM_SEEK_END, &liStreamSize);
    GetHGlobalFromStream(piStream, &hStreamMem);
    pStream = GlobalLock(hStreamMem);

    dwOutputSize = (80 < liStreamSize.LowPart) ? 80 : liStreamSize.LowPart;

    if(g_pAlert != NULL)
        g_pAlert->report(PassportAlertInterface::ERROR_TYPE, 
                         NEXUS_INVALIDDOCUMENT, 
                         1, 
                         apszErrors, 
                         dwOutputSize, 
                         pStream);

    GlobalUnlock(hStreamMem);
}


HRESULT
PpNexusClient::FetchCCD(
    tstring&  strURL,
    IXMLDocument**  ppiXMLDocument
    )
{
    HRESULT                 hr;
    HINTERNET               hNexusSession = NULL, hNexusFile = NULL;
    DWORD                   dwBytesRead;
    DWORD                   dwStatusLen;
    DWORD                   dwStatus;
    tstring                 strAuthHeader;
    tstring                 strFullURL;
    CHAR                    achReadBuf[4096];
    TCHAR                   achAfter[64];
    LARGE_INTEGER           liZero = { 0,0 };
    IStreamPtr              xmlStream;
    IPersistStreamInitPtr   xmlPSI;
	UINT                    uiConnectionTypes[2];
	
    USES_CONVERSION;

    achAfter[0] = 0;

    if(ppiXMLDocument == NULL)
    {
        hr = E_INVALIDARG;        
        goto Cleanup;
    }

    *ppiXMLDocument = NULL;

	// This array will contains connection methods for WinInet in the order 
	// we will attempt them.   I am opting for this method instead of just trying
	// the PRECONFIG option as this will cause no change to existing customers who 
	// have no problems so far.
	uiConnectionTypes[0] = INTERNET_OPEN_TYPE_DIRECT;       //This was the original way of doing things
	uiConnectionTypes[1] = INTERNET_OPEN_TYPE_PRECONFIG;    //This pulls proxy info from the registry

	// Loop through the array...
	for (UINT i = 0; i < sizeof(uiConnectionTypes); i++)
	{
		hNexusSession = InternetOpenA(
	                        "Passport Nexus Client", //BUGBUG  Should we just put in IE4's user agent?
	                        uiConnectionTypes[i],    //Use the connection type
	                        NULL,
	                        NULL,
	                        0);
	    if(hNexusSession == NULL)
	    {
	        hr = GetLastError();
	        lstrcpy(achAfter, TEXT("InternetOpen"));
	        goto Cleanup;
	    }

	    //  Get the document
	    strFullURL = strURL;
	    strFullURL += m_strParam;

	    hNexusFile = InternetOpenUrlA(
	                        hNexusSession,
	                        T2A(const_cast<TCHAR*>(strFullURL.c_str())),
	                        T2A(const_cast<TCHAR*>(m_strAuthHeader.c_str())),
	                        -1,
	                        INTERNET_FLAG_SECURE | INTERNET_FLAG_RELOAD | INTERNET_FLAG_DONT_CACHE,
	                        0);

		// If the file was opened the we hop out of the loop and process it.  If there is
		// and error, we keep looping.  If there is an error on the last run through the loop,
		// it will be handled after the exit of the loop.
	    if (hNexusFile != NULL)
	    	break;
	    	
	}

	// If hNexusFile is NULL when it exits the loop, we process that error.
    if(hNexusFile == NULL)
    {
        hr = GetLastError();
        if(hr == ERROR_INTERNET_SECURITY_CHANNEL_ERROR)
        {
            dwStatusLen = sizeof(HRESULT);
            InternetQueryOption(NULL, INTERNET_OPTION_EXTENDED_ERROR, &hr, &dwStatusLen);
        }

        lstrcpy(achAfter, TEXT("InternetOpenURL"));
        goto Cleanup;
    }
	
    //  Check the status code.
    dwStatusLen = sizeof(DWORD);
    if(!HttpQueryInfoA(hNexusFile,
                       HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER,
                       &dwStatus,
                       &dwStatusLen,
                       NULL))
    {
        hr = GetLastError();
        lstrcpy(achAfter, TEXT("HttpQueryInfo"));
        goto Cleanup;
    }

    if(dwStatus != 200)
    {
        _ultoa(dwStatus, achReadBuf, 10);
        lstrcatA(achReadBuf, " ");

        dwStatusLen = sizeof(achReadBuf) - lstrlenA(achReadBuf);
        HttpQueryInfoA(hNexusFile,
                       HTTP_QUERY_STATUS_TEXT,
                       (LPTSTR)&(achReadBuf[lstrlenA(achReadBuf)]),
                       &dwStatusLen,
                       NULL);

        if(g_pAlert != NULL)
        {
            LPCTSTR apszStrings[] = { strURL.c_str(), A2T(achReadBuf) };

            g_pAlert->report(PassportAlertInterface::ERROR_TYPE,
                             NEXUS_ERRORSTATUS,
                             2,
                             apszStrings,
                             0,
                             NULL
                             );
        }

        lstrcpy(achAfter, TEXT("InternetOpenURL"));
        hr = dwStatus;
        goto Cleanup;
    }

    hr = CreateStreamOnHGlobal(NULL, TRUE, &xmlStream);
    if(hr != S_OK)
    {
        lstrcpy(achAfter, TEXT("CreateStreamOnHGlobal"));
        goto Cleanup;
    }

    while(TRUE)
    {
        if(!InternetReadFile(hNexusFile, achReadBuf, sizeof(achReadBuf), &dwBytesRead))
        {
            hr = GetLastError();
            lstrcpy(achAfter, TEXT("InternetReadFile"));
            goto Cleanup;
        }

        if(dwBytesRead == 0)
            break;

        hr = xmlStream->Write(achReadBuf, dwBytesRead, NULL);
        if(hr != S_OK)
        {
            lstrcpy(achAfter, TEXT("IStream::Write"));
            goto Cleanup;
        }
    }

    hr = xmlStream->Seek(liZero, STREAM_SEEK_SET, NULL);
    if(hr != S_OK)
    {
        lstrcpy(achAfter, TEXT("IStream::Seek"));
        goto Cleanup;
    }

    //
    //  Now create an XML object and initialize it using the stream.
    //

    hr = CoCreateInstance(__uuidof(XMLDocument), NULL, CLSCTX_ALL, IID_IPersistStreamInit, (void**)&xmlPSI);
    if(hr != S_OK)
    {
        lstrcpy(achAfter, TEXT("CoCreateInstance"));
        goto Cleanup;
    }

    hr = xmlPSI->Load((IStream*)xmlStream);
    if(hr != S_OK)
    {
        ReportBadDocument(strFullURL, xmlStream);
        lstrcpy(achAfter, TEXT("IPersistStreamInit::Load"));
        goto Cleanup;
    }

    hr = xmlPSI->QueryInterface(__uuidof(IXMLDocument), (void**)ppiXMLDocument);
    lstrcpy(achAfter, TEXT("QueryInterface(IID_IXMLDocument)"));

Cleanup:

    //
    //  Catch-all event for a fetch failure.
    //

    if(hr != S_OK && g_pAlert != NULL)
    {
        TCHAR   achErrBuf[1024];
        LPCTSTR apszStrings[] = { strURL.c_str(), achErrBuf };
        LPVOID  lpMsgBuf;

        FormatMessage( 
            FORMAT_MESSAGE_ALLOCATE_BUFFER |
            FORMAT_MESSAGE_FROM_SYSTEM | 
            FORMAT_MESSAGE_IGNORE_INSERTS |
            FORMAT_MESSAGE_FROM_HMODULE |
            FORMAT_MESSAGE_MAX_WIDTH_MASK,
            GetModuleHandle(TEXT("wininet.dll")),
            hr,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            (LPTSTR) &lpMsgBuf,
            0,
            NULL 
        );

        lstrcpy(achErrBuf, TEXT("0x"));
        _ultot(hr, &(achErrBuf[2]), 16);
        if(lpMsgBuf != NULL && *(LPTSTR)lpMsgBuf != TEXT('\0'))
        {
            lstrcat(achErrBuf, TEXT(" ("));
            lstrcat(achErrBuf, (LPTSTR)lpMsgBuf);
            lstrcat(achErrBuf, TEXT(") "));
        }

        if(achAfter[0])
        {
            lstrcat(achErrBuf, TEXT(" after a call to "));
            lstrcat(achErrBuf, achAfter);
            lstrcat(achErrBuf, TEXT("."));            
        }


        g_pAlert->report(PassportAlertInterface::ERROR_TYPE,
                         NEXUS_FETCHFAILED,
                         2,
                         apszStrings,
                         0,
                         NULL
                         );

        LocalFree(lpMsgBuf);
    }
    else if(g_pAlert != NULL)
    {
        // Emit success event.

        g_pAlert->report(PassportAlertInterface::INFORMATION_TYPE,
                         NEXUS_FETCHSUCCEEDED,
                         strURL.c_str());
    }

    if(hNexusFile != NULL)
        InternetCloseHandle(hNexusFile);
    if(hNexusSession != NULL)
        InternetCloseHandle(hNexusSession);

    return hr;
}

void
PpNexusClient::LocalConfigurationUpdated()
{
    LONG            lResult;
    TCHAR           achBuf[128];
    DWORD           dwBufLen;
    DWORD           dwSiteId;
    tstring         strCreds;
    tstring         strBase64Creds;
    CRegKey         NexusRegKey;
    CRegKey         PassportRegKey;
    LPTSTR          pszBase64CredBuf;
    CKeyCrypto      kc;

    USES_CONVERSION;

    lResult = PassportRegKey.Open(HKEY_LOCAL_MACHINE,
                                  TEXT("Software\\Microsoft\\Passport"),
                                  KEY_READ);
    if(lResult != ERROR_SUCCESS)
        goto Cleanup;

    lResult = PassportRegKey.QueryDWORDValue(TEXT("SiteId"),
                                        dwSiteId);
    if(lResult != ERROR_SUCCESS)
        goto Cleanup;

    _ultot(dwSiteId, achBuf, 10);
    m_strParam = TEXT("?id=");
    m_strParam += achBuf;

    lResult = NexusRegKey.Open(HKEY_LOCAL_MACHINE,
                     TEXT("Software\\Microsoft\\Passport\\Nexus"),
                     KEY_READ);
    if(lResult != ERROR_SUCCESS)
        goto Cleanup;

    dwBufLen = sizeof(achBuf);
    lResult = NexusRegKey.QueryStringValue(TEXT("CCDUsername"),
                                     achBuf,
                                     &dwBufLen);
    if(lResult != ERROR_SUCCESS)
        goto Cleanup;

    strCreds += achBuf;
    strCreds += TEXT(":");

    dwBufLen = sizeof(achBuf);
    lResult = RegQueryValueEx(NexusRegKey, TEXT("CCDPassword"), NULL,
               NULL, (LPBYTE)achBuf, &dwBufLen);
    if(lResult != ERROR_SUCCESS)
        goto Cleanup;

    DATA_BLOB     iBlob;
    DATA_BLOB     oBlob;
    iBlob.cbData = dwBufLen;
    iBlob.pbData = (PBYTE)achBuf;
    ZeroMemory(&oBlob, sizeof(oBlob));
    if (kc.decryptKey(&iBlob, &oBlob) != S_OK)
    {
        if(g_pAlert != NULL)
            g_pAlert->report(PassportAlertInterface::ERROR_TYPE,
                             PM_CANT_DECRYPT_CONFIG);

        goto Cleanup;
    }

    strCreds += A2T((LPSTR)(oBlob.pbData));

    pszBase64CredBuf = (LPTSTR)alloca(strCreds.size() * 2 * sizeof(TCHAR));

    Base64Encode((LPBYTE)(T2A(const_cast<TCHAR*>(strCreds.c_str()))), strCreds.length(), pszBase64CredBuf);

    m_strAuthHeader =  TEXT("Authorization: Basic ");
    m_strAuthHeader += pszBase64CredBuf;

Cleanup:

    if(lResult != ERROR_SUCCESS)
    {
        //BUGBUG  Throw an exception and an NT Event here.
    }

    if (oBlob.pbData)
      ::LocalFree(oBlob.pbData);
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\nexusobjects\ppnexusclient.h ===
#ifndef __PPNEXUSCLIENT_H
#define __PPNEXUSCLIENT_H

#include <msxml.h>
#include "tstring"

#include "nexus.h"

class PpNexusClient : public IConfigurationUpdate
{
public:
    PpNexusClient();

    HRESULT FetchCCD(tstring& strURL, IXMLDocument** ppiXMLDocument);

    void LocalConfigurationUpdated(void);

private:

    void ReportBadDocument(tstring& strURL, IStream* piStream);

    tstring m_strAuthHeader;
    tstring m_strParam;
};

#endif // __PPNEXUSCLIENT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\nexusobjects\precomp.cpp ===
#include "precomp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\nexusobjects\ppshadowdocument.h ===
#ifndef __PPSHADOWDOCUMENT_H
#define __PPSHADOWDOCUMENT_H

#include <msxml.h>

#include "tstring"

using namespace std;

class PpShadowDocument
{
public:

    PpShadowDocument();
    PpShadowDocument(tstring& strURL);
    PpShadowDocument(tstring& strURL, tstring& strLocalFile);

    void SetURL(tstring& strURL);
    void SetLocalFile(tstring& strLocalFile);

    HRESULT GetDocument(IXMLDocument** ppiXMLDocument, BOOL bForceFetch = TRUE);

private:

    BOOL IsValidCCD(IXMLDocument* piXMLDocument);
    BOOL NoPersist(IXMLDocument* piXMLDocument);

    HRESULT SaveDocument(IXMLDocument* piXMLDocument);
    HRESULT LoadDocument(IXMLDocument** ppiXMLDocument);

    tstring m_strURL;
    tstring m_strLocalFile;
    bool    m_bFailing;
};

#endif // __PPSHADOWDOCUMENT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\nexusobjects\ppnotificationthread.cpp ===
#include "precomp.h"

PassportLockedInteger PpNotificationThread::m_NextHandle;

//
//  Constructor
//

PpNotificationThread::PpNotificationThread()
{
    LocalConfigurationUpdated();

    AddLocalConfigClient(dynamic_cast<IConfigurationUpdate*>(this), NULL);
}

//
//  Destructor
//


PpNotificationThread::~PpNotificationThread()
{
}

//
//  Add a CCD client to the notification list.
//

HRESULT
PpNotificationThread::AddCCDClient(
    tstring& strCCDName,
    ICCDUpdate* piUpdate,
    HANDLE* phClientHandle)
{
    HRESULT hr;
    NOTIFICATION_CLIENT clientInfo;

    clientInfo.dwNotificationType = NOTIF_CCD;
    clientInfo.NotificationInterface.piCCDUpdate = piUpdate;
    clientInfo.strCCDName = strCCDName;
    clientInfo.hClientHandle = (HANDLE)(LONG_PTR)(++m_NextHandle);

    {
        PassportGuard<PassportLock> guard(m_ClientListLock);
        m_ClientList.push_back(clientInfo);
    }

    if(phClientHandle != NULL)
    {
        *phClientHandle = clientInfo.hClientHandle;
    }

    hr = S_OK;

    return hr;
}

//
//  Add a configuration client to the notification list
//

HRESULT
PpNotificationThread::AddLocalConfigClient(
    IConfigurationUpdate* piUpdate,
    HANDLE* phClientHandle)
{
    HRESULT hr;
    NOTIFICATION_CLIENT clientInfo;

    clientInfo.dwNotificationType = NOTIF_CONFIG;
    clientInfo.NotificationInterface.piConfigUpdate = piUpdate;
    clientInfo.hClientHandle = (HANDLE)(LONG_PTR)(++m_NextHandle);

    {
        PassportGuard<PassportLock> guard(m_ClientListLock);
        m_ClientList.push_back(clientInfo);
    }

    if(phClientHandle != NULL)
    {
        *phClientHandle = clientInfo.hClientHandle;
    }

    hr = S_OK;

    return hr;
}

//
//  Remove a client (either type) from the notification list.
//

HRESULT
PpNotificationThread::RemoveClient(
    HANDLE hClientHandle)
{
    HRESULT hr;
    PassportGuard<PassportLock> guard(m_ClientListLock);    

    for(CLIENT_LIST::iterator it = m_ClientList.begin(); it != m_ClientList.end(); it++)
    {
        if((*it).hClientHandle == hClientHandle)
        {
            m_ClientList.erase(it);
            hr = S_OK;
            goto Cleanup;
        }
    }

    hr = E_FAIL;

Cleanup:

    return hr;
}

//
//  Do a manual refresh of a CCD.
//

HRESULT
PpNotificationThread::GetCCD(
    tstring&        strCCDName,
    IXMLDocument**  ppiXMLDocument,
    BOOL            bForceFetch)
{
    HRESULT                 hr;
    PpShadowDocument*       pShadowDoc;
    CCD_INFO                ccdInfo;
    
    {
        PassportGuard<PassportLock> guard(m_CCDInfoLock);

        //  Get the CCD Information for the requested CCD
        if(!GetCCDInfo(strCCDName, ccdInfo))
        {
            hr = E_INVALIDARG;
            pShadowDoc = NULL;
            goto Cleanup;
        }

        //  Create a new shadow document for the CCD
        if(ccdInfo.strCCDLocalFile.empty())
            pShadowDoc = new PpShadowDocument(ccdInfo.strCCDURL);
        else
            pShadowDoc = new PpShadowDocument(ccdInfo.strCCDURL, ccdInfo.strCCDLocalFile);
    }

    if(!pShadowDoc)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    //  Do the update.
    hr = pShadowDoc->GetDocument(ppiXMLDocument, bForceFetch);

    //BUGBUG  This is weird because currently other clients of this CCD will NOT get
    //        notified.  I don't want to loop through the notification list here for
    //        two reasons:
    //
    //        1.  The caller might be in the notification list and I don't to notify
    //            unnecessarily.
    //        2.  Don't want to put the overhead of notifying all clients on the 
    //            caller's thread.
    //
    //        The ideal solution would be to wake up our dedicated thread and have it
    //        do the notification.  I haven't been able to find a way to signal a
    //        waitable time though.

Cleanup:

    if(pShadowDoc != NULL)
        delete pShadowDoc;

    return hr;
}

void
PpNotificationThread::run(void)
{
    HANDLE*         pHandleArray    = NULL;
    LONG            lResult;
    PassportEvent   RegChangeEvent(FALSE,FALSE);
    DWORD           dwCurCCDInfo;
    DWORD           dwCurArrayLen;
    DWORD           dwWaitResult;
    DWORD           dwError;
    CCD_INFO_LIST::iterator it;
    CRegKey         PassportKey;
    BOOL            bKeyOpened;
    HRESULT         hr;

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    _ASSERT(hr != S_FALSE);

    lResult = PassportKey.Open(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Passport"), KEY_NOTIFY);
    bKeyOpened = (lResult == ERROR_SUCCESS);

    m_StartupThread.Set();

    while(TRUE)
    {
        if(bKeyOpened)
        {
            lResult = RegNotifyChangeKeyValue((HKEY)PassportKey, TRUE, 
                                              REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_CHANGE_LAST_SET,
                                              (HANDLE)RegChangeEvent, 
                                              TRUE);
            if(lResult != ERROR_SUCCESS)
                dwError = GetLastError();
        }

        {
            PassportGuard<PassportLock> guard(m_CCDInfoLock);

            dwCurArrayLen = m_aciCCDInfoList.size() + 2;

            pHandleArray = new HANDLE[dwCurArrayLen];
            if(pHandleArray == NULL)
            {
                //  BUGBUG  Throw a low-memory alert here?
                continue;
            }

            pHandleArray[0] = (HANDLE)m_ShutdownThread; //  Handle 0 always contains the thread shutdown signal. 
            pHandleArray[1] = (HANDLE)RegChangeEvent; //  Handle 1 always contains the registry change event.

            for(it = m_aciCCDInfoList.begin(), dwCurCCDInfo = 0; it != m_aciCCDInfoList.end(); it++, dwCurCCDInfo++)
            {
                pHandleArray[dwCurCCDInfo + 2] = (*it).hCCDTimer;
            }
        }

        dwWaitResult = WaitForMultipleObjects(dwCurArrayLen,
                                              pHandleArray,
                                              FALSE,
                                              INFINITE);
        switch(dwWaitResult)
        {
        case WAIT_FAILED:

            dwError = GetLastError();

            break;

        //  Thread shutdown has been signalled.  Exit this thread.
        case WAIT_OBJECT_0:
            goto Cleanup;

        //  Registry change has been signalled.  Notify all local config clients.
        case WAIT_OBJECT_0 + 1:

            {
                PassportGuard<PassportLock> guard(m_ClientListLock);

                for(CLIENT_LIST::iterator it = m_ClientList.begin(); it != m_ClientList.end(); it++)
                {
                    if((*it).dwNotificationType == NOTIF_CONFIG)
                    {
                        (*it).NotificationInterface.piConfigUpdate->LocalConfigurationUpdated();
                    }                        
                }
            }

            break;

        //  One of the CCD timers has been signalled.  Read the CCD and notify all CCD clients.
        default:

            {
                m_CCDInfoLock.acquire();
                CCD_INFO_LIST   aciTempCCDInfoList(m_aciCCDInfoList);
                m_CCDInfoLock.release();
                
                IXMLDocumentPtr     xmlDoc;
                PpShadowDocument    ShadowDoc;
                DWORD               dwInfoIndex = dwWaitResult - WAIT_OBJECT_0 - 2;
                
                m_aciCCDInfoList[dwInfoIndex].SetTimer();

                 //  Fetch the CCD
                ShadowDoc.SetURL(aciTempCCDInfoList[dwInfoIndex].strCCDURL);
                if(!aciTempCCDInfoList[dwInfoIndex].strCCDLocalFile.empty())
                    ShadowDoc.SetLocalFile(aciTempCCDInfoList[dwInfoIndex].strCCDLocalFile);
            
                if(ShadowDoc.GetDocument(&xmlDoc) == S_OK)
                {
                    PassportGuard<PassportLock> guard(m_ClientListLock);

                    LPCTSTR pszUpdatedName = aciTempCCDInfoList[dwInfoIndex].strCCDName.c_str();

                    //  Loop through client list and call any clients registered for the CCD that
                    //  changed.
                    for(CLIENT_LIST::iterator it = m_ClientList.begin(); it != m_ClientList.end(); it++)
                    {
                        if(lstrcmpi(pszUpdatedName, (*it).strCCDName.c_str()) == 0)
                        {
                            (*it).NotificationInterface.piCCDUpdate->CCDUpdated(
                                        pszUpdatedName, 
                                        (IXMLDocument*)xmlDoc);
                        }                        
                    }
                }
            }

            break;
    
        }

        delete [] pHandleArray;
    }

Cleanup:

    if(pHandleArray != NULL)
        delete [] pHandleArray;

    CoUninitialize();
}

//
//  Update our configuration.  This is called from the constructor, and
//  from the notification thread whenever the registry changes.
//

void
PpNotificationThread::LocalConfigurationUpdated()
{
    CRegKey NexusRegKey;
    LONG    lResult;
    DWORD   dwIndex;
    DWORD   dwNameLen;
    DWORD   dwDefaultRefreshInterval;
    TCHAR   achNameBuf[64];

    lResult = NexusRegKey.Open(HKEY_LOCAL_MACHINE, 
                               TEXT("Software\\Microsoft\\Passport\\Nexus"),
                               KEY_READ);
    if(lResult != ERROR_SUCCESS)
    {
        //BUGBUG  This is a required reg key, throw an event.
        return;
    }

    //  Get the default refresh interval.
    lResult = NexusRegKey.QueryDWORDValue(TEXT("CCDRefreshInterval"), dwDefaultRefreshInterval);
    if(lResult != ERROR_SUCCESS)
    {
        //BUGBUG  This is a required reg value, throw an event.
        return;
    }

    //
    //  Lock down the list.
    //

    {
        PassportGuard<PassportLock> guard(m_CCDInfoLock);

        //
        //  Loop through existing list and remove any items whose corresponding keys 
        //  have been removed.
        //

        CCD_INFO_LIST::iterator it;
        for(it = m_aciCCDInfoList.begin(); it != m_aciCCDInfoList.end(); )
        {
            CRegKey CCDRegKey;

            lResult = CCDRegKey.Open((HKEY)NexusRegKey, (*it).strCCDName.c_str(), KEY_READ);
            if(lResult != ERROR_SUCCESS)
            {
                it = m_aciCCDInfoList.erase(it);
            }
            else
                it++;
        }

        //
        //  Loop through each subkey and add/update the CCD info therein.
        //

        dwIndex = 0;
        dwNameLen = sizeof(achNameBuf);

        while(RegEnumKeyEx((HKEY)NexusRegKey, dwIndex,achNameBuf, &dwNameLen, NULL, NULL, NULL, NULL ) == ERROR_SUCCESS)
        {
            CRegKey CCDRegKey;

            lResult = CCDRegKey.Open((HKEY)NexusRegKey, achNameBuf, KEY_READ);
            if(lResult == ERROR_SUCCESS)
            {
                ReadCCDInfo(tstring(achNameBuf), dwDefaultRefreshInterval, CCDRegKey);
            }

            dwIndex++;
            dwNameLen = sizeof(achNameBuf);
        }
    }
}

//
//  This method starts the thread and then wait for the thread to get going.
//

bool
PpNotificationThread::start(void)
{
    m_StartupThread.Reset();

    bool bReturn = PassportThread::start();

    //
    //  Now wait for the thread to start.
    //

    WaitForSingleObject((HANDLE)m_StartupThread, INFINITE);

    return bReturn;
}

//
//  This method just signals the shutdown event causing the thread to terminate immediately.
//

void
PpNotificationThread::stop(void)
{
    m_ShutdownThread.Set();
}

//
//  Private method for reading the CCD info for a single CCD subkey from
//  the registry.
//

BOOL
PpNotificationThread::ReadCCDInfo(
    tstring&    strCCDName,
    DWORD       dwDefaultRefreshInterval,
    CRegKey&    CCDRegKey
    )
{
    BOOL                    bReturn = TRUE;
    LONG                    lResult;
    DWORD                   dwBufLen;
    CCD_INFO_LIST::iterator it;
    LPTSTR                  pszRemoteFile;
    LPTSTR                  pszLocalFile;
    DWORD                   dwCCDRefreshInterval;

    //
    //  Read in the remote path to the CCD.
    //  CCDRemoteFile is the only required value.  If it's not there, return FALSE.
    //

    lResult = CCDRegKey.QueryStringValue(TEXT("CCDRemoteFile"), NULL, &dwBufLen);
    if(lResult == ERROR_SUCCESS)
    {
        pszRemoteFile = (LPTSTR)alloca(dwBufLen * sizeof(TCHAR));

        CCDRegKey.QueryStringValue(TEXT("CCDRemoteFile"), pszRemoteFile, &dwBufLen);
        while(*pszRemoteFile && _istspace(*pszRemoteFile)) pszRemoteFile++;
    }
    else
    {
        bReturn = FALSE;
        goto Cleanup;
    }

    //
    //  Read in the refresh interval for this CCD.
    //

    lResult = CCDRegKey.QueryDWORDValue(TEXT("CCDRefreshInterval"), dwCCDRefreshInterval);
    if(lResult != ERROR_SUCCESS)
        dwCCDRefreshInterval = 0xFFFFFFFF;

    //
    //  Read in local (backup) path for the CCD.  This is an optional value.
    //

    lResult = CCDRegKey.QueryStringValue(TEXT("CCDLocalFile"), NULL, &dwBufLen);
    if(lResult == ERROR_SUCCESS)
    {
        pszLocalFile = (LPTSTR)alloca(dwBufLen * sizeof(TCHAR));

        CCDRegKey.QueryStringValue(TEXT("CCDLocalFile"), pszLocalFile, &dwBufLen);
        while(*pszLocalFile && _istspace(*pszLocalFile)) pszLocalFile++;
    }
    else
    {
        pszLocalFile = (LPTSTR)alloca(sizeof(TCHAR));
        *pszLocalFile = 0;
    }

    //
    //  If this CCD is already in the list, then update it.
    //

    for(it = m_aciCCDInfoList.begin(); it != m_aciCCDInfoList.end(); it++)
    {
        if(lstrcmp((*it).strCCDName.c_str(), strCCDName.c_str()) == 0)
        {
            //  Check to see if the information has changed.
            if(lstrcmpi(pszRemoteFile, (*it).strCCDURL.c_str()) != 0 ||
               lstrcmpi(pszLocalFile,  (*it).strCCDLocalFile.c_str()) != 0 ||
               dwCCDRefreshInterval != (*it).dwCCDRefreshInterval ||
               dwDefaultRefreshInterval != (*it).dwDefaultRefreshInterval
              )
            {
                DWORD   dwOldRefreshInterval = ((*it).dwCCDRefreshInterval == 0xFFFFFFFF ? 
                                                (*it).dwDefaultRefreshInterval : 
                                                (*it).dwCCDRefreshInterval);
                DWORD   dwNewRefreshInterval = (dwCCDRefreshInterval == 0xFFFFFFFF ? 
                                                dwDefaultRefreshInterval : 
                                                dwCCDRefreshInterval);

                (*it).strCCDURL                 = pszRemoteFile;
                (*it).strCCDLocalFile           = pszLocalFile;
                (*it).dwCCDRefreshInterval      = dwCCDRefreshInterval;
                (*it).dwDefaultRefreshInterval  = dwDefaultRefreshInterval;

                if(dwOldRefreshInterval != dwNewRefreshInterval)
                    (*it).SetTimer();
            }

            break;
        }
    }

    //
    //  This is a new CCD, add it to the list.
    //

    if(it == m_aciCCDInfoList.end())
    {
        CCD_INFO ccdInfo;

        ccdInfo.strCCDName                  = strCCDName;
        ccdInfo.strCCDURL                   = pszRemoteFile;
        ccdInfo.strCCDLocalFile             = pszLocalFile;
        ccdInfo.dwCCDRefreshInterval        = dwCCDRefreshInterval;
        ccdInfo.dwDefaultRefreshInterval    = dwDefaultRefreshInterval;

        ccdInfo.SetTimer();

        m_aciCCDInfoList.push_back(ccdInfo);
    }

    bReturn = TRUE;

Cleanup:

    return bReturn;
}

//
//  Private method for retrieving a CCD_INFO structure given the CCD name.
//

BOOL
PpNotificationThread::GetCCDInfo(
    tstring&    strCCDName,
    CCD_INFO&   ccdInfo
    )
{
    CCD_INFO_LIST::iterator     it;

    for(it = m_aciCCDInfoList.begin(); it != m_aciCCDInfoList.end(); it++)
    {
        if(lstrcmpi((*it).strCCDName.c_str(), strCCDName.c_str()) == 0)
        {
            ccdInfo = (*it);
            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\nexusobjects\precomp.h ===
#ifndef __PRECOMP_H
#define __PRECOMP_H

#pragma warning ( disable : 4242 )

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#include <assert.h>
#include <comdef.h>

#ifdef MEM_DBG
  #define _CRTDBG_MAP_ALLOC
  #include <crtdbg.h>
#endif

#include "digest.h"
#include "passporttypes.h"

#include "PassportEvent.hpp"
#include "PassportGuard.hpp"
#include "PpNexusClient.h"
#include "PpNotificationThread.h"
#include "PpShadowDocument.h"
#include "PMAlertsDefs.h"
#include "PassportAlertInterface.h"
#include "pmalerts.h"

extern PassportAlertInterface* g_pAlert;

#endif // __PRECOMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\nexusobjects\ppshadowdocument.cpp ===
#include "precomp.h"

PpShadowDocument::PpShadowDocument()
{
}

PpShadowDocument::PpShadowDocument(
    tstring& strURL) : m_strURL(strURL)
{
}

PpShadowDocument::PpShadowDocument(
    tstring& strURL, 
    tstring& strLocalFile) : m_strURL(strURL), m_strLocalFile(strLocalFile)
{
}

void
PpShadowDocument::SetURL(
    tstring& strURL)
{
    m_strURL = strURL;
}

void
PpShadowDocument::SetLocalFile(
    tstring& strLocalFile)
{
    m_strLocalFile = strLocalFile;
}

HRESULT
PpShadowDocument::GetDocument(
    IXMLDocument**  ppiXMLDocument,
    BOOL            bForceFetch
    )
{
    HRESULT                 hr;
    PpNexusClient           nexusClient;
    IPersistStreamInitPtr   xmlStream;
    IXMLDocumentPtr         xmlDoc;

    if(ppiXMLDocument == NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppiXMLDocument = NULL;

    if(bForceFetch)
    {
        //  Fetch the XML document

        if(!m_strURL.empty())
            hr = nexusClient.FetchCCD(m_strURL, ppiXMLDocument);
        else
        {
            tstring strMsg;
            if(!m_strLocalFile.empty())
            {
                strMsg = TEXT("for ");
                strMsg += m_strLocalFile;
            }

            g_pAlert->report(PassportAlertInterface::ERROR_TYPE,
                             NEXUS_EMPTYREMOTENAME,
                             strMsg.c_str()
                             );
            hr = S_FALSE;
        }

        if(m_strLocalFile.empty())
        {
            tstring strMsg;
            if(!m_strURL.empty())
            {
                strMsg = TEXT("for ");
                strMsg += m_strURL;
            }

            g_pAlert->report(PassportAlertInterface::INFORMATION_TYPE,
                             NEXUS_EMPTYLOCALNAME,
                             strMsg.c_str()
                             );
            goto Cleanup;
        }

        //  If FetchCCD failed and a local file is configured, read from the file.
        //  If FetchCCD succeeded and a local file is configured, write to the file.

        if(hr == S_OK)
        {
            if(!NoPersist(*ppiXMLDocument))
                SaveDocument(*ppiXMLDocument);
            else
            {
                g_pAlert->report(PassportAlertInterface::INFORMATION_TYPE,
                                 NEXUS_NOTPERSISTING,
                                 m_strURL.c_str());
            }
        }
        else
        {
            // use new hr variable, not to eat the global one
            HRESULT hr1 = LoadDocument(ppiXMLDocument);

            if(hr1 != S_OK)
                g_pAlert->report(PassportAlertInterface::ERROR_TYPE,
                                 NEXUS_LOADFAILED,
                                 m_strLocalFile.c_str());
            else
                g_pAlert->report(PassportAlertInterface::INFORMATION_TYPE,
                                 NEXUS_USINGLOCAL,
                                 m_strLocalFile.c_str());
        }
    }
    else
    {
        if(!m_strLocalFile.empty())
        {
            hr = LoadDocument(ppiXMLDocument);
            if(hr == S_OK)
			{
				//  If the file is still valid, then return.
				if(IsValidCCD(*ppiXMLDocument))
                {
                    g_pAlert->report(PassportAlertInterface::INFORMATION_TYPE,
                                     NEXUS_USINGLOCAL,
                                     m_strLocalFile.c_str());
					goto Cleanup;
                }
			}
            else
            {
                g_pAlert->report(PassportAlertInterface::ERROR_TYPE,
                                 NEXUS_LOADFAILED,
                                 m_strLocalFile.c_str());
            }
        }
        else
        {
            tstring strMsg;
            if(!m_strURL.empty())
            {
                strMsg = TEXT("for ");
                strMsg += m_strURL;
            }

            g_pAlert->report(PassportAlertInterface::INFORMATION_TYPE,
                             NEXUS_EMPTYLOCALNAME,
                             strMsg.c_str()
                             );
        }

        //  At this point, we're in one of two states:
        //  1.  *ppiXMLDocument is NULL
        //  2.  *ppiXMLDocument is not NULL, but points to a document that is old

        //  Fetch the XML document, if successful release the document loaded from
        //  disk (if any).

        if(!m_strURL.empty())
            hr = nexusClient.FetchCCD(m_strURL, &xmlDoc);
        else
        {
            tstring strMsg;
            if(!m_strLocalFile.empty())
            {
                strMsg = TEXT("for ");
                strMsg += m_strLocalFile;
            }

            g_pAlert->report(PassportAlertInterface::ERROR_TYPE,
                             NEXUS_EMPTYREMOTENAME,
                             strMsg.c_str()
                             );
            hr = S_FALSE;
        }

        if(hr == S_OK)
        {
            if(*ppiXMLDocument) (*ppiXMLDocument)->Release();
            xmlDoc->QueryInterface(IID_IXMLDocument, (void**)ppiXMLDocument);

            //  If FetchCCD succeeded and a local file is configured, write to the file.
            if(!m_strLocalFile.empty())
            {
                if(!NoPersist(*ppiXMLDocument))
                    SaveDocument(*ppiXMLDocument);
                else
                {
                    g_pAlert->report(PassportAlertInterface::INFORMATION_TYPE,
                                     NEXUS_NOTPERSISTING,
                                     m_strURL.c_str());
                }
            }
            else
            {
                tstring strMsg;
                if(!m_strURL.empty())
                {
                    strMsg = TEXT("for ");
                    strMsg += m_strURL;
                }

                g_pAlert->report(PassportAlertInterface::INFORMATION_TYPE,
                                 NEXUS_EMPTYLOCALNAME,
                                 strMsg.c_str()
                                 );
            }
        }
        else if(*ppiXMLDocument)
        {

         // TODO: the logic is not so clear, on 3.0 timeframe, rewrite this whole func
         
            g_pAlert->report(PassportAlertInterface::INFORMATION_TYPE,
                             NEXUS_USINGLOCAL,
                             m_strLocalFile.c_str());
            hr = S_OK;
        }
        else
        {
            //  If we get here it means that the fetch from the nexus failed
            //  and the load from disk failed.  It is sufficient here to simply
            //  fall through because hr will already contain an error code
            //  which should indicate to the caller that no document is 
            //  available.
        }
    }

Cleanup:

    return hr;
}


BOOL
PpShadowDocument::IsValidCCD(
    IXMLDocument* piXMLDocument
    )
{
    BOOL            bReturn;
    HRESULT         hr;
    IXMLElementPtr  piRootElement;
    SYSTEMTIME      sysTime;
    DOUBLE          dblTime;
    VARIANT         vAttrValue;
    VARIANT         vAttrDate;

    hr = piXMLDocument->get_root(&piRootElement);
    if(hr != S_OK)
    {
        bReturn = FALSE;
        goto Cleanup;
    }

    VariantInit(&vAttrValue);
    hr = piRootElement->getAttribute(L"ValidUntil", &vAttrValue);
    if(hr != S_OK)
    {
        bReturn = FALSE;
        goto Cleanup;
    }

    VariantInit(&vAttrDate);
    hr = VariantChangeType(&vAttrDate, &vAttrValue, 0, VT_DATE);
    if(hr != S_OK)
    {
        bReturn = FALSE;
        goto Cleanup;
    }

    GetSystemTime(&sysTime);
    SystemTimeToVariantTime(&sysTime, &dblTime);

    bReturn = ((long)V_DATE(&vAttrDate) >= (long)dblTime);

Cleanup:

    VariantClear(&vAttrValue);
    VariantClear(&vAttrDate);

    return bReturn;
}


BOOL
PpShadowDocument::NoPersist(
    IXMLDocument* piXMLDocument
    )
{
    BOOL            bReturn;
    HRESULT         hr;
    IXMLElementPtr  piRootElement;
    VARIANT         vAttrValue;

    hr = piXMLDocument->get_root(&piRootElement);
    if(hr != S_OK)
    {
        bReturn = FALSE;
        goto Cleanup;
    }

    VariantInit(&vAttrValue);
    hr = piRootElement->getAttribute(L"NoPersist", &vAttrValue);
    if(hr != S_OK)
    {
        bReturn = FALSE;
        goto Cleanup;
    }

    bReturn = (lstrcmpiW(L"true", V_BSTR(&vAttrValue)) == 0);

Cleanup:

    VariantClear(&vAttrValue);

    return bReturn;
}


HRESULT
PpShadowDocument::SaveDocument(
    IXMLDocument* piXMLDoc
    )
{
    HRESULT                 hr;
    HANDLE                  hFile = INVALID_HANDLE_VALUE;
    ULARGE_INTEGER          uliSize;
    LARGE_INTEGER           liZero = {0,0};
    IStreamPtr              piStream;
    IPersistStreamInitPtr   piPSI;
    LPBYTE                  lpBuf = NULL;
    DWORD                   dwCurBlock;
    DWORD                   dwBytesWritten;

    hr = CreateStreamOnHGlobal(NULL, TRUE, &piStream);
    if(hr != S_OK)
        goto Cleanup;

    hr = piXMLDoc->QueryInterface(IID_IPersistStreamInit, (void**)&piPSI);
    if(hr != S_OK)
        goto Cleanup;

    piPSI->Save(piStream, TRUE);

    piStream->Seek(liZero, STREAM_SEEK_CUR, &uliSize);
    piStream->Seek(liZero, STREAM_SEEK_SET, NULL);

    if(uliSize.HighPart != 0)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    lpBuf = new BYTE[uliSize.LowPart];
    if(lpBuf == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hFile = CreateFile(
        m_strLocalFile.c_str(),
        GENERIC_WRITE,
        0,
        NULL,
        CREATE_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL);
    if(hFile == INVALID_HANDLE_VALUE)
    {
        hr = GetLastError();
        goto Cleanup;
    }

    for(dwCurBlock = 0; dwCurBlock < uliSize.HighPart; dwCurBlock++)
    {
        hr = piStream->Read(lpBuf, 0xFFFFFFFF, NULL);
        if(!WriteFile(hFile, lpBuf, 0xFFFFFFFF, NULL, NULL))
        {
            hr = GetLastError();
            goto Cleanup;
        }
    }

    hr = piStream->Read(lpBuf, uliSize.LowPart, NULL);
    if(hr != S_OK)
        goto Cleanup;

    if(!WriteFile(hFile, lpBuf, uliSize.LowPart, &dwBytesWritten, NULL))
    {
        hr = GetLastError();
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:

    if(hr != S_OK)
    {
        TCHAR   achErrBuf[1024];
        LPCTSTR apszStrings[] = { m_strLocalFile.c_str(), achErrBuf };
        LPVOID  lpMsgBuf;

        FormatMessage( 
            FORMAT_MESSAGE_ALLOCATE_BUFFER |
            FORMAT_MESSAGE_FROM_SYSTEM | 
            FORMAT_MESSAGE_IGNORE_INSERTS |
            FORMAT_MESSAGE_FROM_HMODULE |
            FORMAT_MESSAGE_MAX_WIDTH_MASK,
            GetModuleHandle(TEXT("wininet.dll")),
            hr,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            (LPTSTR) &lpMsgBuf,
            0,
            NULL 
        );

        lstrcpy(achErrBuf, TEXT("0x"));
        _ultot(hr, &(achErrBuf[2]), 16);
        if(lpMsgBuf != NULL && *(LPTSTR)lpMsgBuf != TEXT('\0'))
        {
            lstrcat(achErrBuf, TEXT(" ("));
            lstrcat(achErrBuf, (LPTSTR)lpMsgBuf);
            lstrcat(achErrBuf, TEXT(") "));
        }

        lstrcat(achErrBuf, TEXT(" when trying to save the fetched file to disk."));

        g_pAlert->report(PassportAlertInterface::ERROR_TYPE,
                         NEXUS_LOCALSAVEFAILED,
                         2,
                         apszStrings,
                         0,
                         NULL
                         );

        LocalFree(lpMsgBuf);

        hr = E_FAIL;
    }

    if(lpBuf != NULL)
        delete [] lpBuf;

    if(hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);

    return hr;
}


HRESULT
PpShadowDocument::LoadDocument(
    IXMLDocument** ppiXMLDocument
    )
{
    HRESULT                 hr;
    HANDLE                  hFile = INVALID_HANDLE_VALUE;
    DWORD                   dwFileSizeLow;
    DWORD                   dwBytesRead;
    LPBYTE                  lpBuf = NULL;
    IStreamPtr              piStream;
    IPersistStreamInitPtr   piPSI;
    LARGE_INTEGER           liZero = {0,0};

    hFile = CreateFile(
        m_strLocalFile.c_str(),
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL);
    if(hFile == INVALID_HANDLE_VALUE)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    dwFileSizeLow = GetFileSize(hFile, NULL);
    if(dwFileSizeLow == 0xFFFFFFFF)
    {
        hr = GetLastError();
        goto Cleanup;
    }

    lpBuf = new BYTE[dwFileSizeLow];
    if(lpBuf == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = CreateStreamOnHGlobal(NULL, TRUE, &piStream);
    if(hr != S_OK)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if(ReadFile(hFile, lpBuf, dwFileSizeLow, &dwBytesRead, NULL) == 0)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = piStream->Write(lpBuf, dwFileSizeLow, NULL);

    hr = piStream->Seek(liZero, STREAM_SEEK_SET, NULL);

    //
    //  Now create an XML object and initialize it using the stream.
    //

    hr = CoCreateInstance(__uuidof(XMLDocument), NULL, CLSCTX_ALL, IID_IPersistStreamInit, (void**)&piPSI);
    if(hr != S_OK)
        goto Cleanup;

    hr = piPSI->Load((IStream*)piStream);
    if(hr != S_OK)
        goto Cleanup;

    hr = piPSI->QueryInterface(__uuidof(IXMLDocument), (void**)ppiXMLDocument);

Cleanup:

    if(lpBuf != NULL)
        delete [] lpBuf;

    if(hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);

    return hr;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\nexusobjects\ppnotificationthread.h ===
#ifndef __PPNOTIFICATIONTHREAD_H
#define __PPNOTIFICATIONTHREAD_H

#include <windows.h>
#include <winbase.h>
#include <atlbase.h>
#include <msxml.h>
#include "tstring"
#include <vector>

using namespace std;

#include "PassportThread.hpp"
#include "PassportLock.hpp"
#include "PassportEvent.hpp"
#include "PassportLockedInteger.hpp"
#include "nexus.h"

// Notification types used in structure below
#define NOTIF_CONFIG 1
#define NOTIF_CCD    2

typedef struct
{
    DWORD dwNotificationType;
    union
    {
        IConfigurationUpdate*   piConfigUpdate;
        ICCDUpdate*             piCCDUpdate;
    } NotificationInterface;
    tstring strCCDName; // Will be empty for config notif types
    HANDLE hClientHandle;
}
NOTIFICATION_CLIENT;

typedef vector<NOTIFICATION_CLIENT> CLIENT_LIST;

class CCD_INFO
{
public:
    tstring strCCDName;
    tstring strCCDURL;
    tstring strCCDLocalFile;
    DWORD   dwCCDRefreshInterval;
    DWORD   dwDefaultRefreshInterval;
    HANDLE  hCCDTimer;

    CCD_INFO()
    {
        strCCDName              = TEXT("");
        strCCDURL               = TEXT("");
        strCCDLocalFile         = TEXT("");
        dwCCDRefreshInterval    = 0;
        dwDefaultRefreshInterval= 0;
        hCCDTimer               = CreateWaitableTimer(NULL, TRUE, NULL);
    };

    CCD_INFO(const CCD_INFO& ci)
    {
        strCCDName              = ci.strCCDName;
        strCCDURL               = ci.strCCDURL;
        strCCDLocalFile         = ci.strCCDLocalFile;
        dwCCDRefreshInterval    = ci.dwCCDRefreshInterval;
        dwDefaultRefreshInterval= ci.dwDefaultRefreshInterval;
        
        HANDLE hProcess = GetCurrentProcess();
        DuplicateHandle(hProcess, 
                        ci.hCCDTimer, 
                        hProcess, 
                        &hCCDTimer, 0, FALSE, DUPLICATE_SAME_ACCESS);
    };

    ~CCD_INFO()
    {
        CloseHandle(hCCDTimer);
    }

    const CCD_INFO&
    operator = (const CCD_INFO& ci)
    {
        strCCDName              = ci.strCCDName;
        strCCDURL               = ci.strCCDURL;
        strCCDLocalFile         = ci.strCCDLocalFile;
        dwCCDRefreshInterval    = ci.dwCCDRefreshInterval;
        dwDefaultRefreshInterval= ci.dwDefaultRefreshInterval;
        
        CloseHandle(hCCDTimer);

        HANDLE hProcess = GetCurrentProcess();
        DuplicateHandle(hProcess, 
                        ci.hCCDTimer, 
                        hProcess, 
                        &hCCDTimer, 0, FALSE, DUPLICATE_SAME_ACCESS);

        return ci;
    }

    BOOL SetTimer(DWORD dwOneTimeRefreshInterval = 0xFFFFFFFF)
    {
        //  Reset the timer.
        LARGE_INTEGER   liDueTime;
        DWORD           dwError;
        DWORD           dwRefreshInterval = (dwOneTimeRefreshInterval != 0xFFFFFFFF ? 
                                                dwOneTimeRefreshInterval :
                                                (dwCCDRefreshInterval != 0xFFFFFFFF ? 
                                                 dwCCDRefreshInterval : 
                                                 dwDefaultRefreshInterval
                                                )
                                            );

        liDueTime.QuadPart = -((LONGLONG)(dwRefreshInterval) * 10000000);

        if(!SetWaitableTimer(hCCDTimer, &liDueTime, 0, NULL, NULL, FALSE))
        {
            dwError = GetLastError();
            return FALSE;
        }

        return TRUE;
    }
};

typedef vector<CCD_INFO> CCD_INFO_LIST;

class PpNotificationThread : public PassportThread, public IConfigurationUpdate
{
public:

    PpNotificationThread();
    ~PpNotificationThread();
    
    HRESULT AddCCDClient(tstring& strCCDName, ICCDUpdate* piUpdate, HANDLE* phClientHandle);
    HRESULT AddLocalConfigClient(IConfigurationUpdate* piUpdate, HANDLE* phClientHandle);
    HRESULT RemoveClient(HANDLE hClientHandle);
    HRESULT GetCCD(tstring& strCCDName, IXMLDocument** ppiStream, BOOL bForceFetch = TRUE);

    void run(void);

    void LocalConfigurationUpdated(void);

    void stop(void);

    bool start(void);

private:
	static PassportLockedInteger m_NextHandle;

    //  Private methods.
    BOOL    GetCCDInfo(tstring& strCCDName, CCD_INFO& ccdInfo);
    BOOL    ReadCCDInfo(tstring& strCCDName, DWORD dwDefaultRefreshInterval, CRegKey& CCDRegKey);

    //  Private data
    CLIENT_LIST             m_ClientList;
    PassportLock            m_ClientListLock;

    CCD_INFO_LIST           m_aciCCDInfoList;
    PassportLock            m_CCDInfoLock;
    PassportEvent           m_StartupThread;
    PassportEvent           m_ShutdownThread;
};

#endif // __PPNOTIFICATIONTHREAD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\perflibrary\dllregister.h ===
// DllRegister.h: interface for the DllRegister class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_DLLREGISTER_H__76C48EB6_3EB3_11D2_9F35_00C04F8E7AED__INCLUDED_)
#define AFX_DLLREGISTER_H__76C48EB6_3EB3_11D2_9F35_00C04F8E7AED__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class DllRegister  
{
public:
	DllRegister();
	virtual ~DllRegister();

};

#endif // !defined(AFX_DLLREGISTER_H__76C48EB6_3EB3_11D2_9F35_00C04F8E7AED__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\perflibrary\dllregister.cpp ===
#include "PassportPerf.h"
#include "PassportPerfDefs.h" 

#include <loadperf.h>

//-------------------------------------------------------------
//
// DllUnregisterServer
//
//-------------------------------------------------------------
STDAPI DllUnregisterServer(void)
{
	TCHAR	lpszBuffer[1024];
	DWORD	dwAllocBufferLength=1024;
	LONG	result = 0;
	// BUGBUG the counter ini file must be in the same directory as
	// the dll

	// note: this "unlodctr " MUST be added to the buffer first,
	// else UnloadPerfCounterTextStrings() fails.  WHY? Literally,
	// UnloadPerfCounterTextStrings first parameter is the Command 
	// Line of the unlodctr.exe application -- eeech!
	wsprintf(&lpszBuffer[0],_T("unlodctr %s"),_T(PASSPORT_PERF_INI_FILE));
	__try {
		result = UnloadPerfCounterTextStrings(lpszBuffer,FALSE);
    } 
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
		;
    }

	if (result != ERROR_SUCCESS)
	{
		return (E_UNEXPECTED);
	}

	wsprintf(&lpszBuffer[0],_T("SYSTEM\\CurrentControlSet\\Services\\%s\\Performance"), _T(PASSPORT_NAME)); 
	LONG regError = RegDeleteKey(HKEY_LOCAL_MACHINE,lpszBuffer);
	if (regError != ERROR_SUCCESS)
	{
		return (E_UNEXPECTED);
	}

	wsprintf(&lpszBuffer[0],_T("SYSTEM\\CurrentControlSet\\Services\\%s"), _T(PASSPORT_NAME)); 
	regError = RegDeleteKey(HKEY_LOCAL_MACHINE,lpszBuffer);
	if (regError != ERROR_SUCCESS)
	{
		return (E_UNEXPECTED);
	}

	return (S_OK);
}


//-------------------------------------------------------------
//
// DllRegisterServer
//
//-------------------------------------------------------------
STDAPI DllRegisterServer(void)
{
	DWORD	dwAllocBufferLength=1024;
	TCHAR	lpszBuffer[1024];
	HKEY	hkResult1; 					// address of handle of open key 
	HKEY	hkResult2; 					// address of handle of open key 
	HKEY	hkResult3; 					// address of handle of open key 
	DWORD	ulOptions=0;
	REGSAM	samDesired=KEY_ALL_ACCESS;
	DWORD	Reserved=0;
	DWORD	dwTypesSupported=7;	
	DWORD	dwCatagoryCount=1;	
	LONG	result = 0;

	(void) DllUnregisterServer();


	// Get DLL File Location
	if(!GetCurrentDirectory(dwAllocBufferLength,&lpszBuffer[0]))
		goto Error;
	
	_tcscat(lpszBuffer,_T("\\"));
	_tcscat(lpszBuffer,_T(PASSPORT_PERF_DLL));

	// Event Logging Registry Settings

	if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		_T("SYSTEM\\CurrentControlSet\\Services"),
		ulOptions,samDesired,&hkResult1)!=ERROR_SUCCESS)
		goto Error;
	
	if (RegCreateKey(hkResult1,_T(PASSPORT_NAME)
		,&hkResult2)!=ERROR_SUCCESS)
	{
		RegCloseKey(hkResult1);
		goto Error;
	}

	if (RegCreateKey(hkResult2,_T("Performance"),&hkResult3)!=ERROR_SUCCESS)
	{
		RegCloseKey(hkResult1);
		RegCloseKey(hkResult2);
		goto Error;
	}

	if (RegSetValueEx(hkResult3,_T("Library"),
		Reserved,REG_EXPAND_SZ,
		(UCHAR*)lpszBuffer,_tcslen(lpszBuffer)* sizeof(TCHAR))!=ERROR_SUCCESS)
	{
		RegCloseKey(hkResult1);
		RegCloseKey(hkResult2);
		RegCloseKey(hkResult3);
		goto Error;
	}

	if (RegSetValueEx(hkResult3, _T("Open"),Reserved,
		REG_SZ,(UCHAR*)PASSPORT_PERF_OPEN,
		_tcslen(PASSPORT_PERF_OPEN)* sizeof(TCHAR))!=ERROR_SUCCESS)
	{
		RegCloseKey(hkResult1);
		RegCloseKey(hkResult2);
		RegCloseKey(hkResult3);
		goto Error;
	}

	if (RegSetValueEx(hkResult3,_T("Collect"),Reserved,
		REG_SZ,(UCHAR*)PASSPORT_PERF_COLLECT,
		(_tcslen(PASSPORT_PERF_COLLECT)* sizeof(TCHAR)))!=ERROR_SUCCESS)
	{
		RegCloseKey(hkResult1);
		RegCloseKey(hkResult2);
		RegCloseKey(hkResult3);
		goto Error;
	}

	if (RegSetValueEx(hkResult3,_T("Close"),Reserved,
		REG_SZ,(CONST BYTE *)PASSPORT_PERF_CLOSE,
		(_tcslen(PASSPORT_PERF_CLOSE)* sizeof(TCHAR)))!=ERROR_SUCCESS)
	{
		RegCloseKey(hkResult1);
		RegCloseKey(hkResult2);
		RegCloseKey(hkResult3);
		goto Error;
	}

	if (RegCloseKey(hkResult1)!=ERROR_SUCCESS)
		goto Error;

	if (RegCloseKey(hkResult2)!=ERROR_SUCCESS)
		goto Error;

	if (RegCloseKey(hkResult3)!=ERROR_SUCCESS)
		goto Error;

	// BUGBUG the counter ini file must be in the same directory as
	// the dll

	// note: this "lodctr " MUST be added to the buffer first,
	// else LoadPerfCounterTextStrings() fails.  WHY? Literally,
	// LoadPerfCounterTextStrings first parameter is the Command 
	// Line of the lodctr.exe application -- eeech!
	_tcscpy(&lpszBuffer[0], _T("lodctr "));
	_tcscat(lpszBuffer,_T(PASSPORT_PERF_INI_FILE));
	_tcscat(lpszBuffer,_T(".ini"));
	__try {
		result = LoadPerfCounterTextStrings(lpszBuffer,FALSE);
    } 
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
		;
    }

	if (result != ERROR_SUCCESS)
	{
		goto Error;
	}

	return(S_OK);

Error:
	return(E_UNEXPECTED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\perflibrary\passportperfinterface.cpp ===
// PassportPerfInterface.cpp: implementation of the PassportPerfInterface class.
//
//////////////////////////////////////////////////////////////////////

#define _PassportExport_
#include "PassportExport.h"

#include "PassportPerfInterface.h"
#include "PassportPerfMon.h"

//-------------------------------------------------------------
//
// CreatePassportPerfObject
//
//-------------------------------------------------------------
PassportPerfInterface *  CreatePassportPerformanceObject ( PassportPerfInterface::OBJECT_TYPE type )
{
	switch (type)
	{
	case PassportPerfInterface::PERFMON_TYPE:
		return ( PassportPerfInterface * ) new PassportPerfMon();
	default:
		return NULL;
	}
}

//-------------------------------------------------------------
//
// DeletePassportPerformanceObject
//
//-------------------------------------------------------------
void DeletePassportPerformanceObject ( PassportPerfInterface ** ppObject )
{
	if (ppObject && *ppObject)
	{
		delete *ppObject;
		*ppObject = NULL;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\perflibrary\passportperf.h ===
/*++

    Copyright (c) 1998 Microsoft Corporation

    Module Name:

        PassportPerf.h

    Abstract:

		Perormance Objects Definition

    Author:

		Christopher Bergh (cbergh) 10-Sept-1988

    Revision History:

		- added multi-object support 1-Oct-98
--*/

#if !defined(PASSPORTPERF_H)
#define PASSPORTPERF_H

#include <windows.h>
#include <winperf.h>
#include <string.h>
#include <tchar.h>
#include "PerfSharedMemory.h"

//
//  Function Prototypes//
//      these are used to insure that the data collection functions
//      accessed by Perflib will have the correct calling format.//
PM_OPEN_PROC		OpenPassportPerformanceData;
PM_COLLECT_PROC		CollectPassportPerformanceData;
PM_CLOSE_PROC		ClosePassportPerformanceData;

//
// defs
//
#define PASSPORT_PERF_KEY		"SYSTEM\\CurrentControlSet\\Services\\" 
const TCHAR PASSPORT_PERF_OPEN[] = _T("OpenPassportPerformanceData");
const TCHAR PASSPORT_PERF_COLLECT[] = _T("CollectPassportPerformanceData");
const TCHAR PASSPORT_PERF_CLOSE[] = _T("ClosePassportPerformanceData");

// these two should be the same as in PassportPerfInterface's
// MAX_INSTANCE_NAME and MAX_COUNTERS
#define MAX_INSTANCE_NAME_LENGTH 32
#define MAX_NUMBER_COUNTERS		128

typedef CHAR INSTANCENAME[MAX_INSTANCE_NAME_LENGTH];
struct INSTANCE_DATA
{
	BOOL						active;
	INSTANCENAME				szInstanceName;
};

typedef struct _PassportDefaultCounterType 
{
	DWORD	dwIndex;
	DWORD	dwDefaultType;
} PassportDefaultCounterType;

#define PASSPORT_NAME_SIZE		512
#define MAX_PASSPORT_OBJECTS	10

typedef struct _PassportObjectData
{
	TCHAR		szPassportName[PASSPORT_NAME_SIZE];
	const TCHAR	*lpcszPassportPerfBlock;
	TCHAR		szPassportPerfDll[PASSPORT_NAME_SIZE];
	TCHAR		szPassportPerfIniFile[PASSPORT_NAME_SIZE];
	BOOL		active;
	DWORD		dwNumDefaultCounterTypes;
	PassportDefaultCounterType	defaultCounterTypes[MAX_NUMBER_COUNTERS];
	PerfSharedMemory *PSM;
} PassportObjectData;


#define DWORD_MULTIPLE(x) (((x+sizeof(DWORD)-1)/sizeof(DWORD))*sizeof(DWORD))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\perflibrary\passportperfinterface.h ===
/*++

    Copyright (c) 1998 Microsoft Corporation

    Module Name:

        PassportPerfInterface.h

    Abstract:

		Performance Monitor Class Definition

    Author:

		Christopher Bergh (cbergh) 10-Sept-1988

    Revision History:

		- added Instance support 1-Oct-98
--*/

#if !defined (PASSPORTPERFINTERFACE_H)
#define PASSPORTPERFINTERFACE_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <windows.h>

class PassportPerfInterface 
{
public:
	inline PassportPerfInterface() {};
	inline virtual ~PassportPerfInterface () {};

	enum OBJECT_TYPE
	{
		PERFMON_TYPE	= 100,		// use Perfmon counter,
		SNMP_TYPE		= 101		// use SNMP Traps,
	};
	
	// -------------------------------------------------------------------
	/* Divide delta by delta time.  Display suffix: "/sec" */
		// PERF_COUNTER_COUNTER = 1000,
	/* Indicates the data is a counter  which should not be	*/
	/* time averaged on display (such as an error counter on a serial line)	*/
	/* Display as is.  No Display Suffix.*/
		// PERF_COUNTER_RAWCOUNT = 1001,
	/* A timer which, when divided by an average base, produces a time */
	/* in seconds which is the average time of some operation.  This */
	/* timer times total operations, and  the base is the number of opera- */
	/* tions.  Display Suffix: "sec" */
		// PERF_AVERAGE_TIMER 	= 1002,
	/*  This counter is used to display the difference from one sample */
	/*  to the next. The counter value is a constantly increasing number */
	/*  and the value displayed is the difference between the current */
	/*  value and the previous value. Negative numbers are not allowed	*/
	/*  which shouldn't be a problem as long as the counter value is */
	/*  increasing or unchanged. */
		// PERF_COUNTER_DELTA = 1003,
	/* unknown type	*/
		// PERF_COUNTER_UNDEFINED = 1004


	enum COUNTER_SAMPLING_TYPE
	{
		COUNTER_COUNTER = 1000,
		COUNTER_RAWCOUNT = 1001,
		AVERAGE_TIMER 	= 1002,
		COUNTER_DELTA = 1003,
		COUNTER_UNDEFINED = 1004
	};

	enum { MAX_COUNTERS = 128, MAX_INSTANCES = 64, MAX_INSTANCE_NAME = 32 };

	// object initialization
	virtual BOOL init ( LPCTSTR lpcPerfObjectName ) = 0;
	
	// get set counter type
	virtual BOOL setCounterType ( 
				const DWORD &dwType, 
				const PassportPerfInterface::COUNTER_SAMPLING_TYPE &counterSampleType) = 0; 
	virtual PassportPerfInterface::COUNTER_SAMPLING_TYPE getCounterType ( 
				const DWORD &dwType ) const = 0;

	// adding/subtracting an instance to this object 
	virtual BOOL addInstance ( LPCSTR lpszInstanceName ) = 0;
	virtual BOOL deleteInstance ( LPCSTR lpszInstanceName ) = 0;
	virtual BOOL instanceExists ( LPCSTR lpszInstanceName ) = 0;
	virtual BOOL hasInstances ( void ) = 0;
	virtual DWORD numInstances ( void ) = 0;

	// counters:  note if hasInstances() is TRUE, then you must 
	// give the instance name
	virtual BOOL incrementCounter ( 
				const DWORD &dwType, 
				LPCSTR lpszInstanceName = NULL ) = 0;
	virtual BOOL decrementCounter ( 
				const DWORD &dwType, 
				LPCSTR lpszInstanceName = NULL ) = 0;
	virtual BOOL setCounter ( 
				const DWORD &dwType, 
				const DWORD &dwValue, 
				LPCSTR lpszInstanceName = NULL )  = 0;
	virtual BOOL getCounterValue ( 
				DWORD &dwValue,
				const DWORD &dwType, 
				LPCSTR lpszInstanceName = NULL ) = 0;


};

// create and returns a pointer to the relevant implementation,
// NULL if none exists (FYI- extern "C" to stop name mangling)
extern "C" PassportPerfInterface * CreatePassportPerformanceObject( PassportPerfInterface::OBJECT_TYPE type );

// deletes object and sets pObject = NULL
extern "C" void DeletePassportPerformanceObject ( PassportPerfInterface ** ppObject );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\perflibrary\passportperf.cpp ===
#define _PassportExport_
#include "PassportExport.h"

#include <string.h>
#include <tchar.h>

#include "PassportPerf.h"
#include "PassportPerfObjects.h" 

#include "PerfSharedMemory.h"
#include "PerfUtils.h"

#include <loadperf.h>

#include <crtdbg.h>

DWORD   dwOpenCount = 0;			// count of "Open" threads
BOOL    bInitOK = FALSE;			// true = DLL initialized OK


//-------------------------------------------------------------
//
// OpenPassportPerformanceData
//
// Arguments:    
//		Pointer to object ID of each device to be opened (VGA)
//
// Return Value:    always ERROR_SUCCESS
//
//-------------------------------------------------------------
DWORD APIENTRY OpenPassportPerformanceData(LPWSTR lpDeviceNames)
{
	TCHAR	lpszBuffer[500];
	LONG	status;
	HKEY	hKeyDriverPerf;
	DWORD	dwFirstCounter = 0, dwFirstHelp = 0, 
			dwLastCounter = 0, dwLastHelp  = 0, 
			dwNumCounters = 0,
			size = 0, type = 0, i;

	// here we need to find out the number of counters (remeber,
	// this code not support counter instances) from the registry
	if (dwOpenCount == 0)
	{
		for (i = 0; i < NUM_PERFMON_OBJECTS; i++)
		{
			_ASSERT(g_PObject[i]);
			g_PObject[i]->PSM = new PerfSharedMemory();
			if (g_PObject[i]->PSM == NULL)
			{
				g_PObject[i]->active = FALSE;
				continue;
			}
			
			// get counter and help index base values from registry
			//      Open key to registry entry
			//      read First Counter and First Help values
			
			wsprintf(&lpszBuffer[0], 
				_T("SYSTEM\\CurrentControlSet\\Services\\%s\\Performance"), 
				g_PObject[i]->szPassportName);
			
			status = RegOpenKeyEx (
				HKEY_LOCAL_MACHINE,
				lpszBuffer,
				0L,            
				KEY_READ,            
				&hKeyDriverPerf);
			if (status != ERROR_SUCCESS) 
			{
				g_PObject[i]->active = FALSE;
				continue;
			}
			
			size = sizeof (DWORD);        
			status = RegQueryValueExA(
				hKeyDriverPerf,                     
				(const char *) ("First Counter"),
				0L,                    
				&type,
				(LPBYTE)&dwFirstCounter,                    
				&size);
			if (status != ERROR_SUCCESS) 
			{
				g_PObject[i]->active = FALSE;
				continue;
			}
			
			status = RegQueryValueExA(
				hKeyDriverPerf,                     
				(const char *) ("First Help"),
				0L,                    
				&type,
				(LPBYTE)&dwFirstHelp,            
				&size);
			if (status != ERROR_SUCCESS) 
			{
				g_PObject[i]->active = FALSE;
				continue;
			}
			
			status = RegQueryValueExA(
				hKeyDriverPerf,                     
				(const char *) ("Last Counter"),
				0L,                    
				&type,
				(LPBYTE)&dwLastCounter,                    
				&size);
			if (status != ERROR_SUCCESS) 
			{
				g_PObject[i]->active = FALSE;
				continue;
			}
			
			status = RegQueryValueExA(
				hKeyDriverPerf,                     
				(const char *) ("Last Help"),
				0L,                    
				&type,
				(LPBYTE)&dwLastHelp,            
				&size);
			if (status != ERROR_SUCCESS) 
			{
				g_PObject[i]->active = FALSE;
				continue;
			}
			
			dwNumCounters = (dwLastCounter - dwFirstCounter) / 2;
			
			RegCloseKey(hKeyDriverPerf);
			
			if (!g_PObject[i]->PSM->initialize(
				dwNumCounters, 
				dwFirstCounter, 
				dwFirstHelp))
			{
				g_PObject[i]->active = FALSE;
				continue;
			} 
				
			for (DWORD j = 0; j < g_PObject[i]->dwNumDefaultCounterTypes; j++)
			{
				g_PObject[i]->PSM->setDefaultCounterType(
					g_PObject[i]->defaultCounterTypes[j].dwIndex,
					g_PObject[i]->defaultCounterTypes[j].dwDefaultType);
			}

			(void)g_PObject[i]->PSM->OpenSharedMemory(
					g_PObject[i]->lpcszPassportPerfBlock, FALSE);
			
			g_PObject[i]->active = TRUE;
		}
		
	}
	dwOpenCount++;

	return ERROR_SUCCESS;
}

//
// rotate amoung objects and skip uninstalled objects
//
void ObjectRotate(DWORD *pi)
{
	if (NUM_PERFMON_OBJECTS == 1) 
	{
		return;
	}
	
	if (NUM_PERFMON_OBJECTS == 2) 
	{
		if (g_PObject[!(*pi)]->active) 
		{
			*pi = !(*pi);
		}
		return;
	}
	
	DWORD oldI = *pi;
	
	DWORD dwMod = NUM_PERFMON_OBJECTS; 
	
    do 
	{
        *pi = (*pi + 1) % dwMod;
   	} 
	while ((*pi != oldI) && (!g_PObject[*pi]->active));
	
	return;
}


//-------------------------------------------------------------
//
// CollectPassportPerformanceData
//
// Arguments:
//		IN       LPWSTR   lpValueName
//			  pointer to a wide character string passed by registry.
//		IN OUT   LPVOID   *lppData
//         IN: pointer to the address of the buffer to receive the completed 
//            PerfDataBlock and subordinate structures. This routine will
//            append its data to the buffer starting at the point referenced
//            by *lppData.
//         OUT: points to the first byte after the data structure added by this
//            routine. This routine updated the value at lppdata after appending
//            its data.   
//		IN OUT   LPDWORD  lpcbTotalBytes
//         IN: the address of the DWORD that tells the size in bytes of the 
//            buffer referenced by the lppData argument
//         OUT: the number of bytes added by this routine is written to the 
//            DWORD pointed to by this argument   
//      IN OUT   LPDWORD  NumObjectTypes
//         IN: the address of the DWORD to receive the number of objects added 
//            by this routine 
//         OUT: the number of objects added by this routine is written to the 
//            DWORD pointed to by this argument
//
// Return Value:
//      ERROR_MORE_DATA if buffer passed is too small to hold data
//         any error conditions encountered are reported to the event log if
//         event logging is enabled.
//      ERROR_SUCCESS  if success or any other error. Errors, however are
//         also reported to the event log.
//
//-------------------------------------------------------------
DWORD APIENTRY CollectPassportPerformanceData(
											  IN		LPWSTR	lpValueName,
											  IN OUT	LPVOID	*lppData,
											  IN OUT	LPDWORD lpcbTotalBytes,
											  IN OUT	LPDWORD lpNumObjectTypes)
{

	//DebugBreak();
	DWORD rv = ERROR_SUCCESS,
		  dwQueryType = 0;
	static DWORD i = 0;

	if (dwOpenCount  <= 0 || !g_PObject[i] || !g_PObject[i]->active)
	{
		*lpcbTotalBytes = (DWORD) 0;
		*lpNumObjectTypes = (DWORD) 0;
		ObjectRotate(&i);
		return ERROR_SUCCESS; // yes, this is a successful exit
	}
	
	_ASSERT(g_PObject[i]->PSM);

	if (!g_PObject[i]->PSM->checkQuery(lpValueName))
	{
		*lpcbTotalBytes = (DWORD) 0;
		*lpNumObjectTypes = (DWORD) 0;
		ObjectRotate(&i);
		return ERROR_SUCCESS;
	}
	
	(void)g_PObject[i]->PSM->OpenSharedMemory(
		g_PObject[i]->lpcszPassportPerfBlock, FALSE);

	if (*lpcbTotalBytes < g_PObject[i]->PSM->spaceNeeded())
	{
		*lpcbTotalBytes = (DWORD) 0;
		*lpNumObjectTypes = (DWORD) 0;
		ObjectRotate(&i);
		return ERROR_MORE_DATA;
	}

	if (!g_PObject[i]->PSM->writeData(lppData, lpcbTotalBytes))
	{
		*lpcbTotalBytes = (DWORD) 0;
		*lpNumObjectTypes = (DWORD) 0;
		ObjectRotate(&i);
		return ERROR_SUCCESS;
	}

	*lpNumObjectTypes = 1;

	ObjectRotate(&i);
	return ERROR_SUCCESS;
}



//-------------------------------------------------------------
//
// ClosePassportPerformanceData
//
//-------------------------------------------------------------
DWORD APIENTRY ClosePassportPerformanceData()
{
	dwOpenCount--;
	if (dwOpenCount <= 0)
	{
		for (DWORD i = 0; i < NUM_PERFMON_OBJECTS; i++)
		{
			_ASSERT(g_PObject[i]);
			_ASSERT(g_PObject[i]->PSM);
			if (g_PObject[i]->active)
				g_PObject[i]->PSM->CloseSharedMemory();
			delete g_PObject[i]->PSM;
			g_PObject[i]->PSM = NULL;
		}
	}
 	return ERROR_SUCCESS;
}


//-------------------------------------------------------------
//
// DllUnregisterServer
//
//-------------------------------------------------------------
STDAPI DllUnregisterServer(void)
{
	TCHAR	lpszBuffer[1024];
	DWORD	dwAllocBufferLength=1024;
	LONG	result = 0;
	// BUGBUG the counter ini file must be in the same directory as
	// the dll

	// note: this "unlodctr " MUST be added to the buffer first,
	// else UnloadPerfCounterTextStrings() fails.  WHY? Literally,
	// UnloadPerfCounterTextStrings first parameter is the Command 
	// Line of the unlodctr.exe application -- eeech!
	for (DWORD i = 0; i < NUM_PERFMON_OBJECTS; i++)
	{
		_ASSERT(g_PObject[i]);
		
		wsprintf(&lpszBuffer[0],_T("unlodctr %s"),g_PObject[i]->szPassportPerfIniFile);
		__try {
			result = UnloadPerfCounterTextStrings(lpszBuffer,FALSE);
		} 
		__except( EXCEPTION_EXECUTE_HANDLER )
		{
			;
		}
		
		if (result != ERROR_SUCCESS)
		{
			return (E_UNEXPECTED);
		}
		
		wsprintf(&lpszBuffer[0],_T("SYSTEM\\CurrentControlSet\\Services\\%s\\Performance"), 
			g_PObject[i]->szPassportName); 
		LONG regError = RegDeleteKey(HKEY_LOCAL_MACHINE,lpszBuffer);
		if (regError != ERROR_SUCCESS)
		{
			return (E_UNEXPECTED);
		}
		
		wsprintf(&lpszBuffer[0],_T("SYSTEM\\CurrentControlSet\\Services\\%s"), 
			g_PObject[i]->szPassportName); 
		regError = RegDeleteKey(HKEY_LOCAL_MACHINE,lpszBuffer);
		if (regError != ERROR_SUCCESS)
		{
			return (E_UNEXPECTED);
		}
	}
	return (S_OK);
}


//-------------------------------------------------------------
//
// DllRegisterServer
//
//-------------------------------------------------------------
STDAPI DllRegisterServer(void)
{
	DWORD	dwAllocBufferLength=1024;
	TCHAR	lpszBuffer[1024];
	HKEY	hkResult1; 					// address of handle of open key 
	HKEY	hkResult2; 					// address of handle of open key 
	HKEY	hkResult3; 					// address of handle of open key 
	DWORD	ulOptions=0;
	REGSAM	samDesired=KEY_ALL_ACCESS;
	DWORD	Reserved=0;
	DWORD	dwTypesSupported=7;	
	DWORD	dwCatagoryCount=1;	
	LONG	result = 0;

	(void) DllUnregisterServer();


	for (DWORD i = 0; i < NUM_PERFMON_OBJECTS; i++)
	{
		_ASSERT(g_PObject[i]);
		
		// Get DLL File Location
		if(!GetCurrentDirectory(dwAllocBufferLength,&lpszBuffer[0]))
			goto Error;
		
		_tcscat(lpszBuffer,_T("\\"));
		_tcscat(lpszBuffer,g_PObject[i]->szPassportPerfDll);
		
		// perfmon Registry Settings
		
		if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
			_T("SYSTEM\\CurrentControlSet\\Services"),
			ulOptions,samDesired,&hkResult1)!=ERROR_SUCCESS)
			goto Error;
		
		if (RegCreateKey(hkResult1,g_PObject[i]->szPassportName,
			&hkResult2)!=ERROR_SUCCESS)
		{
			RegCloseKey(hkResult1);
			goto Error;
		}
		
		if (RegCreateKey(hkResult2,_T("Performance"),&hkResult3)!=ERROR_SUCCESS)
		{
			RegCloseKey(hkResult1);
			RegCloseKey(hkResult2);
			goto Error;
		}
		
		if (RegSetValueEx(hkResult3,_T("Library"),
			Reserved,REG_EXPAND_SZ,
			(UCHAR*)lpszBuffer,_tcslen(lpszBuffer)* sizeof(TCHAR))!=ERROR_SUCCESS)
		{
			RegCloseKey(hkResult1);
			RegCloseKey(hkResult2);
			RegCloseKey(hkResult3);
			goto Error;
		}
		
		if (RegSetValueEx(hkResult3, _T("Open"),Reserved,
			REG_SZ,(UCHAR*)PASSPORT_PERF_OPEN,
			_tcslen(PASSPORT_PERF_OPEN)* sizeof(TCHAR))!=ERROR_SUCCESS)
		{
			RegCloseKey(hkResult1);
			RegCloseKey(hkResult2);
			RegCloseKey(hkResult3);
			goto Error;
		}
		
		if (RegSetValueEx(hkResult3,_T("Collect"),Reserved,
			REG_SZ,(UCHAR*)PASSPORT_PERF_COLLECT,
			(_tcslen(PASSPORT_PERF_COLLECT)* sizeof(TCHAR)))!=ERROR_SUCCESS)
		{
			RegCloseKey(hkResult1);
			RegCloseKey(hkResult2);
			RegCloseKey(hkResult3);
			goto Error;
		}
		
		if (RegSetValueEx(hkResult3,_T("Close"),Reserved,
			REG_SZ,(CONST BYTE *)PASSPORT_PERF_CLOSE,
			(_tcslen(PASSPORT_PERF_CLOSE)* sizeof(TCHAR)))!=ERROR_SUCCESS)
		{
			RegCloseKey(hkResult1);
			RegCloseKey(hkResult2);
			RegCloseKey(hkResult3);
			goto Error;
		}
		
		if (RegCloseKey(hkResult1)!=ERROR_SUCCESS)
			goto Error;
		
		if (RegCloseKey(hkResult2)!=ERROR_SUCCESS)
			goto Error;
		
		if (RegCloseKey(hkResult3)!=ERROR_SUCCESS)
			goto Error;
		
		// BUGBUG the counter ini file must be in the same directory as
		// the dll
		
		// note: this "lodctr " MUST be added to the buffer first,
		// else LoadPerfCounterTextStrings() fails.  WHY? Literally,
		// LoadPerfCounterTextStrings first parameter is the Command 
		// Line of the lodctr.exe application -- eeech!
		_tcscpy(&lpszBuffer[0], _T("lodctr "));
		_tcscat(lpszBuffer,g_PObject[i]->szPassportPerfIniFile);
		_tcscat(lpszBuffer,_T(".ini"));
		__try {
			result = LoadPerfCounterTextStrings(lpszBuffer,FALSE);
		} 
		__except( EXCEPTION_EXECUTE_HANDLER )
		{
			;
		}
		
		if (result != ERROR_SUCCESS)
		{
			goto Error;
		}
	}
	
	return(S_OK);

Error:
	return(E_UNEXPECTED);
}



//-------------------------------------------------------------
//
//
//
//-------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\perflibrary\passportperfmon.cpp ===
// PassportPerfMon.cpp: implementation of the PassportPerfMon class.
//
//////////////////////////////////////////////////////////////////////

#define _PassportExport_
#include "PassportExport.h"

#include "PassportPerfMon.h"
#include "PassportPerf.h"

#include <crtdbg.h>

//-------------------------------------------------------------
//
// PassportPerfMon const
//
//-------------------------------------------------------------
PassportPerfMon::PassportPerfMon( ) : PassportSharedMemory()
{
	isInited = FALSE;
	dwNumInstances = 0;
}

//-------------------------------------------------------------
//
// ~PassportPerfMon
//
//-------------------------------------------------------------
PassportPerfMon::~PassportPerfMon()
{
	CloseSharedMemory();
}

//-------------------------------------------------------------
//
// init
//
//-------------------------------------------------------------
BOOL PassportPerfMon::init( LPCTSTR lpcPerfObjectName )
{

	if (isInited)
	{
		return FALSE;
	}
	
	_ASSERT( lpcPerfObjectName );

	InitializeCriticalSection(&mInitLock);
	EnterCriticalSection(&mInitLock);

	// File mapped memory layout
	// 1. MAX_COUNTERS of DWORD for the counter types
	// 2. if dwNumInstances == 0, then
	//	  (a) MAX_COUNTERS of DWORDS of the counter data
	//    else (dwNumInstances > 0)
	//	  (b) MAX_COUNTERS of INSTANCE_DATA structures each followed
	//        immediately by MAX_COUNTERS of DWORDS of the counter data
	DWORD dwSize = (
			(MAX_COUNTERS * sizeof(DWORD))		// for counter type
		  + (MAX_INSTANCES * 
			(sizeof(INSTANCE_DATA) + (MAX_COUNTERS * sizeof(DWORD))))
			); 
	
	if (!CreateSharedMemory(0, dwSize, lpcPerfObjectName, TRUE))
	{
		// raise information alert
		if (!OpenSharedMemory (lpcPerfObjectName, TRUE ))
		{
			LeaveCriticalSection(&mInitLock);
			return FALSE;
		}
	}

	// zero new memory
	memset((void *)m_pbShMem, 0, dwSize);

	// setup counter types to default, note that the counters
	// start at index 1 in SHM
	PPERF_COUNTER_BLOCK pCounterBlock = (PPERF_COUNTER_BLOCK)m_pbShMem;
	_ASSERT(pCounterBlock);
	DWORD dw = WaitForSingleObject(m_hMutex,INFINITE);
	if (dw == WAIT_OBJECT_0)
	{
		for (DWORD i = 0; i < MAX_COUNTERS; i++)
		{
			PDWORD pdwCounter = ((PDWORD) pCounterBlock) + i;
			_ASSERT(pdwCounter);
			*pdwCounter = PERF_TYPE_ZERO;
		}
		ReleaseMutex(m_hMutex);
		isInited = TRUE;
	}
	else
	{
		ReleaseMutex(m_hMutex);
		isInited = FALSE;
	}

	LeaveCriticalSection(&mInitLock);
	return isInited;
}

//-------------------------------------------------------------
//
// incrementCounter
//
//-------------------------------------------------------------
BOOL PassportPerfMon::incrementCounter ( const DWORD &dwType, LPCSTR lpszInstanceName  )
{
	if (!isInited)
	{
		return FALSE;
	}
	
	_ASSERT( (dwType >= 0) && (dwType < MAX_COUNTERS));
	_ASSERT(m_pbShMem);
	
	DWORD dwIndex = ((dwType == 0) ? 0 : (DWORD)(dwType/2));
	
	BYTE* pb = (BYTE*)m_pbShMem;
	_ASSERT(pb);
	pb += MAX_COUNTERS * sizeof(DWORD);
	
	// if lpszInstanceName == NULL, select the first datablock after
	// the first INSTANCE_DATA, else iterate until we find the
	// right instance name
	// TBD insert thread locking
	for (DWORD i = 0; i < MAX_INSTANCES; i++)
	{
		INSTANCE_DATA * pInst = (INSTANCE_DATA *)pb;
		_ASSERT(pInst);
		pb += sizeof(INSTANCE_DATA);
		if (lpszInstanceName == NULL
			|| (pInst->active && strcmp(pInst->szInstanceName, lpszInstanceName) == 0)	)
		{
			
			PPERF_COUNTER_BLOCK pCounterBlock = (PPERF_COUNTER_BLOCK)pb;
			_ASSERT(pCounterBlock);
			PDWORD pdwCounter = ((PDWORD) pCounterBlock) + dwIndex;
			_ASSERT(pdwCounter);

			DWORD dw = WaitForSingleObject(m_hMutex,INFINITE);
			if (dw == WAIT_OBJECT_0)
			{
				(*pdwCounter)++;
				ReleaseMutex(m_hMutex);
				return TRUE;
			}
			else
			{
				ReleaseMutex(m_hMutex);
				return FALSE;
			}

		}
		pb += (MAX_COUNTERS * sizeof(DWORD)); 
	}
	return FALSE;
}


//-------------------------------------------------------------
//
// decrementCounter
//
//-------------------------------------------------------------
BOOL PassportPerfMon::decrementCounter ( const DWORD &dwType, LPCSTR lpszInstanceName )
{
	if (!isInited)
	{
		return FALSE;
	}

	_ASSERT( (dwType >= 0) && (dwType < MAX_COUNTERS));	
	_ASSERT(m_pbShMem);

	DWORD dwIndex = ((dwType == 0) ? 0 : (DWORD)(dwType/2));

	BYTE* pb = (BYTE*)m_pbShMem;
	_ASSERT(pb);
	pb += MAX_COUNTERS * sizeof(DWORD);
	
	// if lpszInstanceName == NULL, select the first datablock after
	// the first INSTANCE_DATA, else iterate until we find the
	// right instance name
	// TBD insert thread locking
	for (DWORD i = 0; i < MAX_INSTANCES; i++)
	{
		INSTANCE_DATA * pInst = (INSTANCE_DATA *)pb;
		_ASSERT(pInst);
		pb += sizeof(INSTANCE_DATA);
		if (lpszInstanceName == NULL
			|| (pInst->active && strcmp(pInst->szInstanceName, lpszInstanceName) == 0)	)
		{
			PPERF_COUNTER_BLOCK pCounterBlock = (PPERF_COUNTER_BLOCK)pb;
			_ASSERT(pCounterBlock);
			PDWORD pdwCounter = ((PDWORD) pCounterBlock) + dwIndex;
			_ASSERT(pdwCounter);

			DWORD dw = WaitForSingleObject(m_hMutex,INFINITE);
			if (dw == WAIT_OBJECT_0)
			{
				(*pdwCounter)--;
				ReleaseMutex(m_hMutex);
				return TRUE;
			}
			else
			{
				ReleaseMutex(m_hMutex);
				return FALSE;
			}

		}
		pb += (MAX_COUNTERS * sizeof(DWORD));
	}
	return FALSE;
}


//-------------------------------------------------------------
//
// setCounter
//
//-------------------------------------------------------------
BOOL PassportPerfMon::setCounter ( const DWORD &dwType,
										 const DWORD &dwValue, 
										 LPCSTR lpszInstanceName )
{
	if (!isInited)
	{
		return FALSE;
	}

	_ASSERT( (dwType >= 0) && (dwType < MAX_COUNTERS));	
	_ASSERT(m_pbShMem);

	DWORD dwIndex = ((dwType == 0) ? 0 : (DWORD)(dwType/2));

	BYTE* pb = (BYTE*)m_pbShMem;
	_ASSERT(pb);
	pb += MAX_COUNTERS * sizeof(DWORD);
	
	// if lpszInstanceName == NULL, select the first datablock after
	// the first INSTANCE_DATA, else iterate until we find the
	// right instance name
	// TBD insert thread locking
	for (DWORD i = 0; i < MAX_INSTANCES; i++)
	{
		INSTANCE_DATA * pInst = (INSTANCE_DATA *)pb;
		_ASSERT(pInst);
		pb += sizeof(INSTANCE_DATA);
		if (lpszInstanceName == NULL
			|| (pInst->active && strcmp(pInst->szInstanceName, lpszInstanceName) == 0)	)
		{
			
			PPERF_COUNTER_BLOCK pCounterBlock = (PPERF_COUNTER_BLOCK)pb;
			_ASSERT(pCounterBlock);
			PDWORD pdwCounter = ((PDWORD) pCounterBlock) + dwIndex;
			_ASSERT(pdwCounter);

			DWORD dw = WaitForSingleObject(m_hMutex,INFINITE);
			if (dw == WAIT_OBJECT_0)
			{
				(*pdwCounter) = dwValue;
				ReleaseMutex(m_hMutex);
				return TRUE;
			}
			else
			{
				ReleaseMutex(m_hMutex);
				return FALSE;
			}
		}
		pb += (MAX_COUNTERS * sizeof(DWORD));
	}
	return FALSE;
}


//-------------------------------------------------------------
//
// 	getCounterValue
//
//-------------------------------------------------------------
BOOL PassportPerfMon::getCounterValue ( DWORD &dwValue, 
									   const DWORD &dwType, LPCSTR lpszInstanceName )
{
	if (!isInited)
	{
		dwValue = 0;
		return FALSE;
	}

	_ASSERT( (dwType >= 0) && (dwType < MAX_COUNTERS));	
	_ASSERT(m_pbShMem);

	DWORD dwIndex = ((dwType == 0) ? 0 : (DWORD)(dwType/2));

	BYTE* pb = (BYTE*)m_pbShMem;
	_ASSERT(pb);
	pb += MAX_COUNTERS * sizeof(DWORD);
	
	// if lpszInstanceName == NULL, select the first datablock after
	// the first INSTANCE_DATA, else iterate until we find the
	// right instance name
	// TBD insert thread locking
	for (DWORD i = 0; i < MAX_INSTANCES; i++)
	{
		INSTANCE_DATA * pInst = (INSTANCE_DATA *)pb;
		_ASSERT(pInst);
		pb += sizeof(INSTANCE_DATA);
		if (lpszInstanceName == NULL
			|| (pInst->active && strcmp(pInst->szInstanceName, lpszInstanceName) == 0)	)
		{
			PPERF_COUNTER_BLOCK pCounterBlock = (PPERF_COUNTER_BLOCK)pb;
			_ASSERT(pCounterBlock);
			PDWORD pdwCounter = ((PDWORD) pCounterBlock) + dwIndex;
			_ASSERT(pdwCounter);

			DWORD dw = WaitForSingleObject(m_hMutex,INFINITE);
			if (dw == WAIT_OBJECT_0)
			{
				dwValue = (*pdwCounter);
				ReleaseMutex(m_hMutex);
				return TRUE;
			}
			else
			{
				ReleaseMutex(m_hMutex);
				return FALSE;
			}

		}
		pb += (MAX_COUNTERS * sizeof(DWORD));
	}
	return TRUE;
}

//-------------------------------------------------------------
//
// setCounterType	
//
//-------------------------------------------------------------
BOOL PassportPerfMon::setCounterType ( const DWORD &dwType, 
				const PassportPerfInterface::COUNTER_SAMPLING_TYPE &counterSampleType)
{
	if (!isInited)
	{
		return FALSE;
	}

	_ASSERT( (dwType >= 0) && (dwType < MAX_COUNTERS));	
	_ASSERT(m_pbShMem);
	
	DWORD dwIndex = ((dwType == 0) ? 0 : (DWORD)(dwType/2));
	DWORD dwPerfType = 0;
	
	switch ( counterSampleType )
	{
	case (PassportPerfInterface::COUNTER_COUNTER):
		dwPerfType = PERF_COUNTER_COUNTER;
		break;
	case (PassportPerfInterface::AVERAGE_TIMER):
		dwPerfType = PERF_AVERAGE_TIMER;
		break;
	case (PassportPerfInterface::COUNTER_DELTA):
		dwPerfType = PERF_COUNTER_DELTA;
		break;
	case (PassportPerfInterface::COUNTER_RAWCOUNT):
	case (PassportPerfInterface::COUNTER_UNDEFINED):
	default:
		dwPerfType = PERF_COUNTER_RAWCOUNT;
		break;
	}

	PPERF_COUNTER_BLOCK pCounterBlock = (PPERF_COUNTER_BLOCK)m_pbShMem;
	_ASSERT(pCounterBlock);
	PDWORD pdwCounter = ((PDWORD) pCounterBlock) + (dwIndex-1);
	_ASSERT(pdwCounter);

	DWORD dw = WaitForSingleObject(m_hMutex,INFINITE);
	if (dw == WAIT_OBJECT_0)
	{
		(*pdwCounter) = dwPerfType;
		ReleaseMutex(m_hMutex);
		return TRUE;
	}
	else
	{
		ReleaseMutex(m_hMutex);
		return FALSE;
	}
		
	return FALSE;	
}

//-------------------------------------------------------------
//
// getCounterType	
//
//-------------------------------------------------------------
PassportPerfInterface::COUNTER_SAMPLING_TYPE PassportPerfMon::getCounterType(
				const DWORD &dwType ) const
{
	if (!isInited)
	{
		return PassportPerfInterface::COUNTER_UNDEFINED;
	}

	_ASSERT( (dwType >= 0) && (dwType < MAX_COUNTERS));	
	_ASSERT(m_pbShMem);
	
	DWORD dwIndex = ((dwType == 0) ? 0 : (DWORD)(dwType/2));
	DWORD dwPerfType = 0;

	PPERF_COUNTER_BLOCK pCounterBlock = (PPERF_COUNTER_BLOCK)m_pbShMem;
	PDWORD pdwCounter = ((PDWORD) pCounterBlock) + (dwIndex-1);
	_ASSERT(pdwCounter);

	DWORD dw = WaitForSingleObject(m_hMutex,INFINITE);
	if (dw == WAIT_OBJECT_0)
	{
		dwPerfType = (*pdwCounter);
		ReleaseMutex(m_hMutex);
	}
	else
	{
		ReleaseMutex(m_hMutex);
	}

	switch ( dwPerfType )
	{
	case (PERF_COUNTER_COUNTER):
		return PassportPerfInterface::COUNTER_COUNTER;
	case (PERF_AVERAGE_TIMER):
		return PassportPerfInterface::AVERAGE_TIMER;
	case (PERF_COUNTER_DELTA):
		return PassportPerfInterface::COUNTER_DELTA;
	case (PERF_COUNTER_RAWCOUNT):
		return PassportPerfInterface::COUNTER_RAWCOUNT;
	default:
		return PassportPerfInterface::COUNTER_UNDEFINED;
	}

}

//-------------------------------------------------------------
//
// addInstance	
//
//-------------------------------------------------------------
BOOL PassportPerfMon::addInstance( LPCSTR lpszInstanceName )
{
	if (!isInited || lpszInstanceName == NULL)
	{
		return FALSE;
	}

	_ASSERT(m_pbShMem);
	BYTE* pb = (BYTE*)m_pbShMem;
	_ASSERT(pb);

	pb += MAX_COUNTERS * sizeof(DWORD);

	
	DWORD dw = WaitForSingleObject(m_hMutex,INFINITE);
	if (dw == WAIT_OBJECT_0)
	{
		// find if the instance already exists, if so fail
		for (DWORD i = 0; i < MAX_INSTANCES; i++)
		{
			INSTANCE_DATA * pInst = (INSTANCE_DATA *)pb;
			_ASSERT(pInst);
			if (pInst->active)
			{
				if (strcmp(pInst->szInstanceName, lpszInstanceName) == 0)
				{
					ReleaseMutex(m_hMutex);
					return FALSE;
				}
			}
			pb += sizeof(INSTANCE_DATA);
		}
		
		// insert the instance in the first available slot
		pb = (BYTE*)m_pbShMem;
		_ASSERT(pb);
		pb += MAX_COUNTERS * sizeof(DWORD);	
		for (i = 0; i < MAX_INSTANCES; i++)
		{
			INSTANCE_DATA * pInst = (INSTANCE_DATA *)pb;
			_ASSERT(pInst);
			if (!pInst->active)
			{
				memset((void *)pInst->szInstanceName,'\n',sizeof(INSTANCENAME));
				if (strcpy(pInst->szInstanceName, lpszInstanceName) == NULL)
				{
					ReleaseMutex(m_hMutex);
					return FALSE;
				}
				else
				{
					pInst->active = TRUE;
					InterlockedIncrement(&dwNumInstances);
					pb += sizeof(INSTANCE_DATA);
					memset(pb,0,(MAX_COUNTERS * sizeof(DWORD)));
					ReleaseMutex(m_hMutex);
					return TRUE;
				}
			}
			pb += sizeof(INSTANCE_DATA) + (MAX_COUNTERS * sizeof(DWORD));
		}
		
		// didn't find it, fail
		ReleaseMutex(m_hMutex);
		return FALSE;
	}
	else
	{
		ReleaseMutex(m_hMutex);
		return FALSE;
	}



}


//-------------------------------------------------------------
//
// deleteInstance	
//
//-------------------------------------------------------------
BOOL PassportPerfMon::deleteInstance( LPCSTR lpszInstanceName )
{
	if (!isInited || lpszInstanceName == NULL)
	{
		return FALSE;
	}

	_ASSERT(m_pbShMem);
	BYTE* pb = (BYTE*)m_pbShMem;
	_ASSERT(pb);

	pb += MAX_COUNTERS * sizeof(DWORD);
	
	DWORD dw = WaitForSingleObject(m_hMutex,INFINITE);
	if (dw == WAIT_OBJECT_0)
	{
		// find if the instance already exists, if so set it inactive
		for (DWORD i = 0; i < MAX_INSTANCES; i++)
		{
			INSTANCE_DATA * pInst = (INSTANCE_DATA *)pb;
			_ASSERT(pInst);
			if (pInst->active && strcmp(pInst->szInstanceName, lpszInstanceName) == 0)
			{
				pInst->active = FALSE;
				InterlockedDecrement(&dwNumInstances);
				// zero the data
				pb += sizeof(INSTANCE_DATA);
				memset(pb,0,(MAX_COUNTERS * sizeof(DWORD)));
				ReleaseMutex(m_hMutex);
				return TRUE;
			}
			pb += sizeof(INSTANCE_DATA)+(MAX_COUNTERS * sizeof(DWORD));
		}
		
		// didn't find it, fail
		ReleaseMutex(m_hMutex);
		return FALSE;
	}
	else
	{
		ReleaseMutex(m_hMutex);
		return FALSE;
	}
}


//-------------------------------------------------------------
//
// hasInstances	
//
//-------------------------------------------------------------
BOOL PassportPerfMon::hasInstances( void ) 
{
	DWORD dwNum = (DWORD)InterlockedExchangeAdd(&dwNumInstances,0);
	if (dwNum > 0)
		return TRUE;
	else
		return FALSE;
}

//-------------------------------------------------------------
//
// 	numInstances
//
//-------------------------------------------------------------
DWORD PassportPerfMon::numInstances( void ) 
{
	DWORD rv = (DWORD)InterlockedExchangeAdd(&dwNumInstances,0);
	return rv;
}


//-------------------------------------------------------------
//
// instanceExists
//
//-------------------------------------------------------------
BOOL PassportPerfMon::instanceExists ( LPCSTR lpszInstanceName )
{
	
	if (!isInited || lpszInstanceName == NULL)
	{
		return FALSE;
	}

	_ASSERT(m_pbShMem);
	BYTE* pb = (BYTE*)m_pbShMem;
	_ASSERT(pb);

	DWORD dw = WaitForSingleObject(m_hMutex,INFINITE);
	if (dw == WAIT_OBJECT_0)
	{
		pb += MAX_COUNTERS * sizeof(DWORD);
		for (DWORD i = 0; i < MAX_INSTANCES; i++)
		{
			INSTANCE_DATA * pInst = (INSTANCE_DATA *)pb;
			_ASSERT(pInst);
			if (pInst->active && strcmp(pInst->szInstanceName, lpszInstanceName) == 0)
			{
				ReleaseMutex(m_hMutex);
				return TRUE;
			}
			pb += sizeof(INSTANCE_DATA) + (MAX_COUNTERS * sizeof(DWORD));
		}
		
		// didn't find it, fail
		ReleaseMutex(m_hMutex);
		return FALSE;
	}
	else
	{
		ReleaseMutex(m_hMutex);
		return FALSE;
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\perflibrary\passportsharedmemory.cpp ===
#define _PassportExport_
#include "PassportExport.h"

#include "PassportSharedMemory.h"
#include <malloc.h>
#include <tchar.h>

#define PMUTEX_STRING _T("PASSPORTMUTEX")

//-------------------------------------------------------------
//
// PassportSharedMemory
//
//-------------------------------------------------------------
PassportSharedMemory::PassportSharedMemory()
{
	m_hShMem = 0;
	m_pbShMem = 0;
	m_bInited = 0;
	m_hMutex = 0;
	m_bUseMutex = FALSE;
}

//-------------------------------------------------------------
//
// ~PassportSharedMemory
//
//-------------------------------------------------------------
PassportSharedMemory::~PassportSharedMemory()
{
	CloseSharedMemory();
}


//-------------------------------------------------------------
//
// CreateSharedMemory
//
//-------------------------------------------------------------
BOOL PassportSharedMemory::CreateSharedMemory ( 
					const DWORD &dwMaximumSizeHigh, 
					const DWORD &dwMaximunSizeLow,
					LPCTSTR lpcName,
					BOOL	useMutex)
{

    BOOL fReturn  = FALSE;
	SID_IDENTIFIER_AUTHORITY siaWorld = SECURITY_WORLD_SID_AUTHORITY;

    // local param need to be freed before exit
	PSECURITY_DESCRIPTOR lpSD = NULL;
	SID *lpSID = NULL;
	LPSECURITY_ATTRIBUTES lpSA = NULL;

    // local param do not need to free
	TCHAR *pStr = NULL;

	if (!lpcName)
        goto exit;

	if (m_pbShMem != NULL && m_hShMem != NULL && m_bInited)
    {
        fReturn = TRUE;
        goto exit;
    }

	m_bUseMutex = useMutex;
	
	lpSD = malloc(1024);
	if (!lpSD)
        goto exit;

	if (!AllocateAndInitializeSid(	&siaWorld,				// Security, world authoity for ownership
									1,						// 1 relative sub-authority
									SECURITY_WORLD_RID,		// sub-authority, all users, world
									0, 0, 0, 0, 0, 0, 0,	// unused sub-authority types
									(void**)&lpSID))		// ** to security ID struct
	{
        goto exit;
	}

	InitializeSecurityDescriptor(lpSD, SECURITY_DESCRIPTOR_REVISION);

	SetSecurityDescriptorDacl(lpSD, TRUE, NULL, FALSE);		// allow access to DACL
	SetSecurityDescriptorGroup(lpSD, lpSID, FALSE);			// set owner group to lpSID
	SetSecurityDescriptorOwner(lpSD, NULL, FALSE);			// set owner to nobody
	SetSecurityDescriptorSacl(lpSD, FALSE, NULL, FALSE);	// disable system ACL access

	lpSA = new SECURITY_ATTRIBUTES;
    if( !lpSA )
        goto exit;

	lpSA->nLength = sizeof(SECURITY_ATTRIBUTES);
	lpSA->lpSecurityDescriptor = lpSD;
	lpSA->bInheritHandle = TRUE;

	m_hShMem = CreateFileMapping((INVALID_HANDLE_VALUE),                      
						lpSA,
						PAGE_READWRITE,                      
						dwMaximumSizeHigh,
						dwMaximunSizeLow,                      
						lpcName);
	
	if( !m_hShMem )
        goto exit;

	m_pbShMem = (BYTE*) MapViewOfFile( m_hShMem, 
		FILE_MAP_ALL_ACCESS, 
		0, 0, 0 );

	if( ! m_pbShMem )
		goto exit;

	if (useMutex)
	{
		pStr = (TCHAR *) _alloca ((_tcslen(lpcName) + _tcslen(PMUTEX_STRING) + 1) * sizeof(TCHAR));

		_tcscpy (pStr, lpcName);
		_tcscat (pStr, PMUTEX_STRING);
		m_hMutex = CreateMutex(lpSA,FALSE,pStr);
		
		if( !m_hMutex )
            goto exit;
	}
	
    // we are here because we are fully initialized :-)
	m_bInited = TRUE;
    fReturn = TRUE;

exit:
    // cleanup locally allocated heap
    if( lpSA ) 
        delete lpSA;

    if( lpSD )
		free(lpSD);

    if( lpSID )
        FreeSid(lpSID);

    // if we are not fully initialized, cleanup them
    if( !m_bInited )
	    CloseSharedMemory();

	return fReturn;
}	



//-------------------------------------------------------------
//
// OpenSharedMemory
//
//-------------------------------------------------------------
BOOL PassportSharedMemory::OpenSharedMemory( LPCTSTR lpcName, BOOL useMutex )
{
	
	if (!lpcName)
		return FALSE;

	if (m_pbShMem != NULL && m_hShMem != NULL && m_bInited)
		return TRUE;

	m_bUseMutex = useMutex;

	m_hShMem = OpenFileMapping( FILE_MAP_READ, FALSE, lpcName );
	if( ! m_hShMem )
	{
		return FALSE;
	}

	m_pbShMem = (BYTE*) MapViewOfFile( m_hShMem, FILE_MAP_READ, 0, 0, 0 );
	if( ! m_pbShMem )
	{
		CloseHandle( m_hShMem );
		m_hShMem = 0;
		return FALSE;
	}

	if (useMutex)
	{
		TCHAR *pStr = (TCHAR *) _alloca ((_tcslen(lpcName) + _tcslen(PMUTEX_STRING) + 1) * sizeof(TCHAR));
		_tcscpy (pStr, lpcName);
		_tcscat (pStr,PMUTEX_STRING);
		m_hMutex = OpenMutex(SYNCHRONIZE ,FALSE, pStr);
		if( !m_hMutex )
		{
			CloseSharedMemory();
			return FALSE;
		}
	}

	m_bInited = TRUE;
	return TRUE;
}

//-------------------------------------------------------------
//
// CloseSharedMemory
//
//-------------------------------------------------------------
void PassportSharedMemory::CloseSharedMemory( void )
{
	if( m_pbShMem )
	{
		UnmapViewOfFile( (void*) m_pbShMem );
		m_pbShMem = 0;
	}
	
	if( m_hShMem )
	{
		CloseHandle( m_hShMem );
		m_hShMem = 0;
	}

	if( m_hMutex )
	{
		ReleaseMutex(m_hMutex);
		m_hMutex = 0;;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\perflibrary\passportsharedmemory.h ===
/*++

    Copyright (c) 1998 Microsoft Corporation

    Module Name:

        PassportSharedMemory.h

    Abstract:

		Shared Memory class

    Author:

		Christopher Bergh (cbergh) 10-Sept-1988

    Revision History:

--*/
#if !defined(PASSPORTSHAREDMEMORY_H)
#define PASSPORTSHAREDMEMORY_H

#include <windows.h>

class PassportExport PassportSharedMemory
{
public:
	PassportSharedMemory();
	virtual ~PassportSharedMemory();

	BOOL CreateSharedMemory ( 
					const DWORD &dwMaximumSizeHigh, 
					const DWORD &dwMaximunSizeLow,
					LPCTSTR lpcName,
					BOOL	useMutex = TRUE);

	BOOL OpenSharedMemory( LPCTSTR lpcName,
					BOOL	useMutex = TRUE);
	
	void CloseSharedMemory( void );

protected:
	
	// handle and pointer for the shared memory
	HANDLE						m_hShMem;
	PBYTE						m_pbShMem;
	BOOL						m_bInited;
	HANDLE						m_hMutex;
	BOOL						m_bUseMutex;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\perflibrary\perfsharedmemory.cpp ===
#define _PassportExport_
#include "PassportExport.h"

#include "PerfSharedMemory.h"
#include "PerfUtils.h"
#include "PassportPerf.h"
#include "PassportPerfInterface.h"


#include <crtdbg.h>

//-------------------------------------------------------------
//
// PerfSharedMemory
//
//-------------------------------------------------------------
PerfSharedMemory::PerfSharedMemory() : PassportSharedMemory()
{
    m_dwNumCounters = 0;
}


//-------------------------------------------------------------
//
// PerfSharedMemory
//
//-------------------------------------------------------------

PerfSharedMemory::~PerfSharedMemory()
{

}


//-------------------------------------------------------------
//
// initialize
//
//-------------------------------------------------------------
BOOL PerfSharedMemory::initialize(
                        const DWORD &dwNumCounters,
                        const DWORD &dwFirstCounter,
                        const DWORD &dwFirstHelp)
{
    
    if ( dwNumCounters <= 0 || dwNumCounters >= PassportPerfInterface::MAX_COUNTERS)
        return FALSE;

    m_dwNumCounters = dwNumCounters;


    // 2. initialize the PERF_OBJECT_TYPE
    m_Object.NumInstances = PassportPerfInterface::MAX_INSTANCES;
    m_Object.TotalByteLength = 0;
    m_Object.DefinitionLength = sizeof(PERF_OBJECT_TYPE)
                                + (dwNumCounters * sizeof(PERF_COUNTER_DEFINITION));
    m_Object.HeaderLength = sizeof(PERF_OBJECT_TYPE);
    m_Object.ObjectNameTitleIndex = dwFirstCounter;
    m_Object.ObjectNameTitle = 0;
    m_Object.ObjectHelpTitleIndex = dwFirstHelp;
    m_Object.ObjectHelpTitle = 0;
    m_Object.DetailLevel = PERF_DETAIL_NOVICE;
    m_Object.NumCounters = dwNumCounters;
    m_Object.DefaultCounter = 0;
    m_Object.CodePage = 0;

    // 3. initialize each counter
    for (DWORD i = 0; i < dwNumCounters; i++)
    {
      m_Counter[i].ByteLength = sizeof(PERF_COUNTER_DEFINITION);
      m_Counter[i].CounterNameTitleIndex = dwFirstCounter + ((i+1) * 2);
      m_Counter[i].CounterNameTitle = 0;
      m_Counter[i].CounterHelpTitleIndex = dwFirstHelp + ((i+1) * 2);
      m_Counter[i].CounterHelpTitle = 0;
      m_Counter[i].DefaultScale = 0;
      m_Counter[i].DetailLevel = PERF_DETAIL_NOVICE;
      m_Counter[i].CounterType = PERF_COUNTER_RAWCOUNT; // PERF_COUNTER_COUNTER;
      m_Counter[i].CounterSize = sizeof(DWORD);
      m_Counter[i].CounterOffset = sizeof(PERF_COUNTER_BLOCK) + (i * sizeof(DWORD));
    }

    return TRUE;
}



//-------------------------------------------------------------
//
// setDefaultCounterType
//
//-------------------------------------------------------------
VOID PerfSharedMemory::setDefaultCounterType (
                     const DWORD dwIndex,
                     const DWORD dwType )
{
    _ASSERT( (dwIndex >= 0) && (dwIndex < PassportPerfInterface::MAX_COUNTERS));

    // indexes start at one in SHM, but in this object they start at 0
    DWORD dwRealIndex = ((dwIndex == 0) ? 0 : (DWORD)(dwIndex/2)-1);
    m_Counter[dwRealIndex].CounterType = dwType;
    return;
}


//-------------------------------------------------------------
//
// checkQuery
//
//-------------------------------------------------------------
BOOL PerfSharedMemory::checkQuery ( const LPWSTR lpValueName )
{
    DWORD dwQueryType = 0;

    dwQueryType = GetQueryType (lpValueName);   
    if (dwQueryType == QUERY_FOREIGN)
    {
        // this routine does not service requests for data from
        // Non-NT computers     
        return FALSE;   
    }

    if (dwQueryType == QUERY_ITEMS)
    {
        if ( !(IsNumberInUnicodeList (m_Object.ObjectNameTitleIndex, lpValueName)))
        {
            
            // request received for data object not provided by this routine
            return FALSE;
        }   
    }
    
    return TRUE;
}


//-------------------------------------------------------------
//
// spaceNeeded
//
//-------------------------------------------------------------
ULONG PerfSharedMemory::spaceNeeded ( void )
{
    DWORD dwTotalInstanceLength = 0;
    m_Object.NumInstances = 0;

    // --------------------------------
    //  count the instances
    if (m_pbShMem != NULL)
    {
        BYTE* pShm = (BYTE *)m_pbShMem;
        if (pShm != NULL)
        {   
            pShm += PassportPerfInterface::MAX_COUNTERS * sizeof(DWORD);
            
            if (!m_bUseMutex
                || WaitForSingleObject(m_hMutex,INFINITE) == WAIT_OBJECT_0)
            {
                for (DWORD i = 0; i < PassportPerfInterface::MAX_INSTANCES; i++)
                {
                    INSTANCE_DATA * pInst = (INSTANCE_DATA *)pShm;
                    _ASSERT(pInst);
                    if (pInst->active)
                    {
                        m_Object.NumInstances++;
                        dwTotalInstanceLength += (strlen(pInst->szInstanceName)+1) * sizeof(WCHAR);
                    }
                    pShm += sizeof(INSTANCE_DATA) +
                        (PassportPerfInterface::MAX_COUNTERS * sizeof(DWORD));
                }
                if (m_bUseMutex)
                    ReleaseMutex(m_hMutex);
            }
            else
            {
                ReleaseMutex(m_hMutex);
                return FALSE;
            }
            
        }
    }
    
    // --------------------------------
    //  calculate the ByteLength in the Object structure
    if (m_Object.NumInstances == 0)
    {
        m_Object.NumInstances = PERF_NO_INSTANCES;
        m_Object.TotalByteLength = sizeof(PERF_OBJECT_TYPE)
                                + (m_dwNumCounters * sizeof(PERF_COUNTER_DEFINITION))
                                + sizeof(PERF_COUNTER_BLOCK)
                                + (m_dwNumCounters * sizeof(DWORD));
    }
    else
    {
        m_Object.TotalByteLength = sizeof(PERF_OBJECT_TYPE)
                                + (m_dwNumCounters * sizeof(PERF_COUNTER_DEFINITION))
                                + (m_Object.NumInstances *
                                                (sizeof(PERF_INSTANCE_DEFINITION) +
                                                 // note: INSTANCENAME is next in the SHM
                                                 sizeof(PERF_COUNTER_BLOCK) +
                                                 (m_dwNumCounters * sizeof(DWORD)) ))
                                + dwTotalInstanceLength;

    }

    //  align on 8 bytes boundary ...
    if (m_Object.TotalByteLength & 7)
    {
        m_Object.TotalByteLength += 8;
        m_Object.TotalByteLength &= ~7;
    }

    return m_Object.TotalByteLength;
}

//-------------------------------------------------------------
//
// writeData
//
//-------------------------------------------------------------
BOOL PerfSharedMemory::writeData (
                                  LPVOID    *lppData,
                                  LPDWORD lpcbTotalBytes )
{
    BYTE*               pb = NULL;
    DWORD               dwBytes = 0;
    
    // --------------------------------
    // 1. find the active number of instances
    //    (may have been done already)
    if (m_Object.TotalByteLength == 0)
        spaceNeeded();
    
    pb = (BYTE*) *lppData;
    
    // --------------------------------
    // 2. copy the Object structure
    CopyMemory( pb, &m_Object, sizeof(PERF_OBJECT_TYPE) );
    pb += sizeof(PERF_OBJECT_TYPE);
    dwBytes += sizeof(PERF_OBJECT_TYPE);
    
    if (!m_bUseMutex
        || WaitForSingleObject(m_hMutex,INFINITE) == WAIT_OBJECT_0)
    {
        // --------------------------------
        // 3. read the counter types from SHM
        if ( m_pbShMem != NULL )
        {
            DWORD dwPerfType = 0;
            BYTE * pShm = (BYTE*)m_pbShMem;
            _ASSERT(pShm);
            
            for (DWORD j = 0; j < m_dwNumCounters; j++)
            {
                PDWORD pdwCounter = ((PDWORD) pShm) + j;
                _ASSERT(pdwCounter);
                // only reset the counter if it has a defined value
                // or if it has changed
                if (*pdwCounter != PERF_TYPE_ZERO
                    && m_Counter[j].CounterType != *pdwCounter)
                    m_Counter[j].CounterType = (*pdwCounter);
            }
            
        }
        // --------------------------------
        // 4. copy the counters
        for (DWORD i = 0; i < m_dwNumCounters; i++)
        {
            CopyMemory( pb, &(m_Counter[i]),sizeof(PERF_COUNTER_DEFINITION));
            pb += sizeof(PERF_COUNTER_DEFINITION);
            dwBytes += sizeof(PERF_COUNTER_DEFINITION);
        }
        
        // --------------------------------
        // 5. if SHM if null, then just dump out all
        //    zeroes for the counters
        if ( m_pbShMem == NULL )
        {
            // copy the number of counters in the counter block
            PERF_COUNTER_BLOCK counterBlock;
            counterBlock.ByteLength = sizeof(PERF_COUNTER_BLOCK) +
                (m_dwNumCounters * sizeof(DWORD));
            CopyMemory( pb, &counterBlock, sizeof(PERF_COUNTER_BLOCK));
            pb += sizeof(PERF_COUNTER_BLOCK);
            dwBytes += sizeof(PERF_COUNTER_BLOCK);
            for (DWORD j = 1; j <= m_dwNumCounters; j++)
            {
                DWORD val = 0;
                CopyMemory( pb, &val, sizeof(DWORD));
                pb += sizeof(DWORD);
                dwBytes += sizeof(DWORD);
            }
        }
        // --------------------------------
        // 6. if object has no instances, then read just the first
        //    section of data,
        else if (m_Object.NumInstances == PERF_NO_INSTANCES)
        {
            _ASSERT(m_pbShMem);
            BYTE * pShm = (BYTE*)m_pbShMem;
            _ASSERT(pShm);
            pShm += (PassportPerfInterface::MAX_COUNTERS * sizeof(DWORD));
            pShm += sizeof(INSTANCE_DATA);
            _ASSERT(pShm);
            // copy the number of counters in the counter block
            PERF_COUNTER_BLOCK counterBlock;
            counterBlock.ByteLength = sizeof(PERF_COUNTER_BLOCK) +
                (m_dwNumCounters * sizeof(DWORD));
            CopyMemory( pb, &counterBlock, sizeof(PERF_COUNTER_BLOCK));
            pb += sizeof(PERF_COUNTER_BLOCK);
            dwBytes += sizeof(PERF_COUNTER_BLOCK);
            
            PPERF_COUNTER_BLOCK pCounterBlock = (PPERF_COUNTER_BLOCK)pShm;
            _ASSERT(pCounterBlock);
            
            for (DWORD j = 1; j <= m_dwNumCounters; j++)
            {
                PDWORD pdwCounter = ((PDWORD) pCounterBlock) + j;
                _ASSERT(pdwCounter);
                DWORD val = *pdwCounter;
                CopyMemory( pb, &val, sizeof(DWORD));
                pb += sizeof(DWORD);
                dwBytes += sizeof(DWORD);
            }
            
        }
        // --------------------------------
        // 7. get and write all instance data
        else
        {
            _ASSERT(m_pbShMem);
            BYTE * pShm = (BYTE*)m_pbShMem;
            _ASSERT(pShm);
            pShm += (PassportPerfInterface::MAX_COUNTERS * sizeof(DWORD));
            DWORD dwInstanceIndex = 0;
            
            for (i = 0; i < (DWORD)m_Object.NumInstances; i++)
            {
                PERF_INSTANCE_DEFINITION instDef;
                PERF_COUNTER_BLOCK perfCounterBlock;
                BOOL gotInstance = FALSE;
                INSTANCE_DATA * pInst = NULL;
                WCHAR   wszName[MAX_PATH];
                
                // 7a. get the instance name from the next active instance
                //     in SHM
                for (DWORD i = dwInstanceIndex;
                i < PassportPerfInterface::MAX_INSTANCES && !gotInstance;
                i++)
                {
                    pInst = (INSTANCE_DATA *)pShm;
                    _ASSERT(pInst);
                    pShm += sizeof(INSTANCE_DATA);
                    if (pInst->active)
                    {
                        dwInstanceIndex = i + 1;
                        gotInstance = TRUE;
                        
                    }
                    else
                    {
                        pShm += (PassportPerfInterface::MAX_COUNTERS * sizeof(DWORD));
                    }
                }
                
                if (!gotInstance || pInst == NULL)
                    return FALSE;
                
                // 7b. create the instace Definition and
                //     copy it (also get the instance name)
                instDef.ParentObjectTitleIndex = 0;//m_Object.ObjectNameTitleIndex + 2*i;
                instDef.ParentObjectInstance = 0; // ????
                instDef.UniqueID = PERF_NO_UNIQUE_ID;
                instDef.NameOffset = sizeof(PERF_INSTANCE_DEFINITION);
                //  Build UNICODE instance name
                if (!MultiByteToWideChar( CP_ACP,
                    MB_PRECOMPOSED,
                    pInst->szInstanceName,
                    strlen(pInst->szInstanceName)+1,
                    wszName,
                    MAX_PATH))
                {
                    wszName[0] = 0;
                }
                instDef.NameLength = (lstrlenW( wszName ) + 1) * sizeof(WCHAR);
                instDef.ByteLength = sizeof(PERF_INSTANCE_DEFINITION)
                    + instDef.NameLength;
                CopyMemory( pb, &instDef, sizeof(PERF_INSTANCE_DEFINITION) );
                pb += sizeof(PERF_INSTANCE_DEFINITION);
                dwBytes += sizeof(PERF_INSTANCE_DEFINITION);
                
                // 7c. copy the instance name
                CopyMemory(pb, wszName, instDef.NameLength);
                pb += instDef.NameLength;
                dwBytes += instDef.NameLength;
                
                // 7d. copy the counterblock
                perfCounterBlock.ByteLength = sizeof(PERF_COUNTER_BLOCK)
                    + (m_dwNumCounters * sizeof(DWORD));
                CopyMemory( pb, &perfCounterBlock, sizeof(PERF_COUNTER_BLOCK));
                pb += sizeof(PERF_COUNTER_BLOCK);
                dwBytes += sizeof(PERF_COUNTER_BLOCK);
                
                // 7e. copy the DWORDs themselves
                PPERF_COUNTER_BLOCK pCounterBlock = (PPERF_COUNTER_BLOCK)pShm;
                DWORD val = 0;
                for (DWORD j = 1; j <= m_dwNumCounters; j++)
                {
                    if (m_pbShMem != NULL)
                    {
                        PDWORD pdwCounter = ((PDWORD) pCounterBlock) + j;
                        val = *pdwCounter;
                    }
                    CopyMemory( pb, &val, sizeof(DWORD));
                    pb += sizeof(DWORD);
                    dwBytes += sizeof(DWORD);
                }
                pShm += (PassportPerfInterface::MAX_COUNTERS * sizeof(DWORD));
            } // end for ( i = ...)
        } // end else (instances exist)
        
        if (m_bUseMutex)
            ReleaseMutex(m_hMutex);
    }
    else
    {
        ReleaseMutex(m_hMutex);
        return FALSE;
    }
    
    //
    //  8 byte alignment
    while (dwBytes%8 != 0)
    {
        (dwBytes)++;
        pb++;
    }

    *lppData = (void*) pb;//++pb;
    *lpcbTotalBytes = dwBytes;
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\perflibrary\passportperfmon.h ===
/*++

    Copyright (c) 1998 Microsoft Corporation

    Module Name:

        PassportPerfMon.h

    Abstract:

		Performance Monitor Class Implementation

    Author:

		Christopher Bergh (cbergh) 10-Sept-1988

    Revision History:

		- added Instance support 1-Oct-98
--*/

#if !defined(PASSPORTPERFMON_H)
#define PASSPORTPERFMON_H

#include <windows.h>
#include "PassportSharedMemory.h"
#include "PassportPerfInterface.h"

class PassportPerfMon : public PassportPerfInterface, public PassportSharedMemory  
{
public:
	PassportPerfMon();
	~PassportPerfMon ();

	BOOL init ( LPCTSTR lpcPerfObjectName );

	// get set counter type
	BOOL setCounterType ( const DWORD &dwType, 
				const PassportPerfInterface::COUNTER_SAMPLING_TYPE &counterSampleType); 
	PassportPerfInterface::COUNTER_SAMPLING_TYPE getCounterType( 
				const DWORD &dwType  ) const;

	// adding/subtracting an instance to this object 
	BOOL addInstance ( LPCSTR lpszInstanceName );
	BOOL deleteInstance ( LPCSTR lpszInstanceName );
	BOOL instanceExists ( LPCSTR lpszInstanceName );
	BOOL hasInstances ( void );
	DWORD numInstances ( void );

	// counters:  note if hasInstances() is TRUE, then you must 
	// give the instance name
	BOOL incrementCounter ( const DWORD &dwType, LPCSTR lpszInstanceName = NULL );
	BOOL decrementCounter ( const DWORD &dwType, LPCSTR lpszInstanceName = NULL );
	BOOL setCounter ( 
				const DWORD &dwType, 
				const DWORD &dwValue, 
				LPCSTR lpszInstanceName = NULL );
	BOOL getCounterValue ( 
				DWORD &dwValue,
				const DWORD &dwType,
				LPCSTR lpszInstanceName = NULL );

private:
	BOOL isInited;
	LONG dwNumInstances;
	CRITICAL_SECTION mInitLock;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\perflibrary\perfutils.h ===
/*++

    Copyright (c) 1998 Microsoft Corporation

    Module Name:

        PerfUtils.h

    Abstract:

		Perfmon utils

    Author:

		Christopher Bergh (cbergh) 10-Sept-1988

    Revision History:

--*/

#if !defined(AFX_PERFUTILS_H__968D9AF5_3EBF_11D2_9F35_00C04F8E7AED__INCLUDED_)
#define AFX_PERFUTILS_H__968D9AF5_3EBF_11D2_9F35_00C04F8E7AED__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4

// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3


#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)

BOOL IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
);

DWORD GetQueryType (IN LPWSTR lpValue);

#define DWORD_MULTIPLE(x) (((x+sizeof(DWORD)-1)/sizeof(DWORD))*sizeof(DWORD))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\perflibrary\perfsharedmemory.h ===
/*++

    Copyright (c) 1998 Microsoft Corporation

    Module Name:

        PerfSharedMemory.h

    Abstract:

		Class to hold per-object perfmon specific functions

    Author:

		Christopher Bergh (cbergh) 10-Sept-1988

    Revision History:

--*/

#if !defined(AFX_PERFSHAREDMEMORY_H)
#define AFX_PERFSHAREDMEMORY_H

#include "PassportSharedMemory.h"
#include "WinPerf.h"
#include "PassportPerfInterface.h"

class PassportExport PerfSharedMemory : public PassportSharedMemory  
{
public:
	PerfSharedMemory();
	virtual ~PerfSharedMemory();

	BOOL initialize( const DWORD &dwNumCounters, 
					 const DWORD &dwFirstCounter, 
					 const DWORD &dwFirstHelp);

    VOID setDefaultCounterType (
					 const DWORD dwIndex,
					 const DWORD dwType );

	BOOL checkQuery ( const LPWSTR lpValueName );

	ULONG spaceNeeded ( void );

	BOOL writeData ( LPVOID	*lppData,
					 LPDWORD lpNumObjectTypes );

private:
	DWORD						m_dwNumCounters;
	PERF_OBJECT_TYPE			m_Object;	
	PERF_COUNTER_DEFINITION		m_Counter[PassportPerfInterface::MAX_COUNTERS];	// array of counter defintions

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\perflibrary\pmcounters\msppcntr.h ===
//
//  testcounters.h
//
//  Offset definition file for exensible counter objects and counters
//
//  These "relative" offsets must start at 0 and be multiples of 2 (i.e.
//  even numbers). In the Open Procedure, they will be added to the 
//  "First Counter" and "First Help" values fo the device they belong to, 
//  in order to determine the  absolute location of the counter and 
//  object names and corresponding help text in the registry.
//
//  this file is used by the extensible counter DLL code as well as the 
//  counter name and help text definition file (.INI) file that is used
//  by LODCTR to load the names into the registry.
//
#define PMCOUNTERS_PERF_OBJ			0

#define PM_REQUESTS_SEC             2
#define PM_REQUESTS_TOTAL           4
#define PM_AUTHSUCCESS_SEC          6
#define PM_AUTHSUCCESS_TOTAL        8
#define PM_AUTHFAILURE_SEC          10
#define PM_AUTHFAILURE_TOTAL        12
#define PM_FORCEDSIGNIN_SEC         14
#define PM_FORCEDSIGNIN_TOTAL       16
#define PM_PROFILEUPDATES_SEC       18
#define PM_PROFILEUPDATES_TOTAL     20
#define PM_INVALIDREQUESTS_SEC      22
#define PM_INVALIDREQUESTS_TOTAL    24
#define PM_PROFILECOMMITS_SEC       26
#define PM_PROFILECOMMITS_TOTAL     28
#define PM_VALIDPROFILEREQ_SEC      30
#define PM_VALIDPROFILEREQ_TOTAL    32
#define PM_NEWCOOKIES_SEC           34
#define PM_NEWCOOKIES_TOTAL         36
#define PM_VALIDREQUESTS_SEC        38
#define PM_VALIDREQUESTS_TOTAL      40
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\perflibrary\perfutils.cpp ===
#include <windows.h>
#include <string.h>
#include <winperf.h>
#include "PerfUtils.h"


WCHAR GLOBAL_STRING[] = L"Global";
WCHAR FOREIGN_STRING[] = L"Foreign";
WCHAR COSTLY_STRING[] = L"Costly";


//-------------------------------------------------------------
//
//	helper functions pinched from MSDN 
//
//-------------------------------------------------------------
 BOOL IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
)
{
    DWORD   dwThisNumber;
    WCHAR   *pwcThisChar;
    BOOL    bValidNumber;
    BOOL    bNewItem;
    WCHAR   wcDelimiter;    // could be an argument to be more flexible

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not founde

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;
    wcDelimiter = (WCHAR)' ';
    bValidNumber = FALSE;
    bNewItem = TRUE;
    
    while (TRUE) {
        switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
            case DIGIT:
                // if this is the first digit after a delimiter, then 
                // set flags to start computing the new number
                if (bNewItem) {
                    bNewItem = FALSE;
                    bValidNumber = TRUE;
                }
                if (bValidNumber) {
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - (WCHAR)'0');
                }
                break;
            
            case DELIMITER:
                // a delimter is either the delimiter character or the 
                // end of the string ('\0') if when the delimiter has been
                // reached a valid number was found, then compare it to the
                // number from the argument list. if this is the end of the
                // string and no match was found, then return.
                //
                if (bValidNumber) {
                    if (dwThisNumber == dwNumber) return TRUE;
                    bValidNumber = FALSE;
                }
                if (*pwcThisChar == 0) {
                    return FALSE;
                } else {
                    bNewItem = TRUE;
                    dwThisNumber = 0;
                }
                break;

            case INVALID:
                // if an invalid character was encountered, ignore all
                // characters up to the next delimiter and then start fresh.
                // the invalid number is not compared.
                bValidNumber = FALSE;
                break;

            default:
                break;

        }
        pwcThisChar++;
    }
    return FALSE;
}   // IsNumberInUnicodeList

DWORD GetQueryType (IN LPWSTR lpValue)
/*++

GetQueryType

    returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL
        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string

    QUERY_FOREIGN
        if lpValue == pointer to "Foriegn" string

    QUERY_COSTLY
        if lpValue == pointer to "Costly" string

    otherwise:

    QUERY_ITEMS

--*/
{
    WCHAR   *pwcArgChar, *pwcTypeChar;
    BOOL    bFound;

    if (lpValue == 0) {
        return QUERY_GLOBAL;
    } else if (*lpValue == 0) {
        return QUERY_GLOBAL;
    }

    // check for "Global" request

    pwcArgChar = lpValue;
    pwcTypeChar = GLOBAL_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string
    
    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_GLOBAL;

    // check for "Foreign" request
    
    pwcArgChar = lpValue;
    pwcTypeChar = FOREIGN_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string
    
    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_FOREIGN;

    // check for "Costly" request
    
    pwcArgChar = lpValue;
    pwcTypeChar = COSTLY_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string
    
    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_COSTLY;

    // if not Global and not Foreign and not Costly, 
    // then it must be an item list
    
    return QUERY_ITEMS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\schema\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	schema.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\perflibrary\pmcounters\passportperfobjects.h ===
/*++

    Copyright (c) 1998 Microsoft Corporation

    Module Name:

        PassportPerfObjects.h

    Abstract:

		Perormace Objects Definition

    Author:

		Christopher Bergh (cbergh) 10-Sept-1988

    Revision History:

		- added multi-object support 1-Oct-98
		- added default counter types 22-Oct-98
--*/
#if !defined(PASSPORTPERFOBJECTS_H)
#define PASSPORTPERFOBJECTS_H

#include "PassportPerfDefs.h"

#include "msppcntr.h"


// -------------------------------------------------------------------
// counter types
// 1. PERF_COUNTER_COUNTER = 1000:
    /* Divide delta by delta time.  Display suffix: "/sec" */
// 2. PERF_COUNTER_RAWCOUNT = 1001:        
    /* Indicates the data is a counter  which should not be */
    /* time averaged on display (such as an error counter on a serial line) */
    /* Display as is.  No Display Suffix.*/
// 3. PERF_AVERAGE_TIMER   = 1002:        
    /* A timer which, when divided by an average base, produces a time */
    /* in seconds which is the average time of some operation.  This */
    /* timer times total operations, and  the base is the number of opera- */
    /* tions.  Display Suffix: "sec" */
// 4. PERF_COUNTER_DELTA = 1003,        
    /*  This counter is used to display the difference from one sample */
    /*  to the next. The counter value is a constantly increasing number */
    /*  and the value displayed is the difference between the current */
    /*  value and the previous value. Negative numbers are not allowed  */
    /*  which shouldn't be a problem as long as the counter value is */
    /*  increasing or unchanged. */
//
// Note: PERF_COUNTER_RAWCOUNT is the default counter type
//     To add another counter type increment the number of counters and
//     add the counter type according to the pattern:
//      {
//          { <countername1>, <Counter Type> },
//          { <countername2}, <Counter Type> }
//      }
// -------------------------------------------------------------------

// create objects
PassportObjectData PMCountersObject = {	
	TEXT("msppcntr"),		// object name
	PASSPORT_PERF_BLOCK,		// const string, name of MemoryMapped File
	TEXT("msppcntr.dll"),	// dll name
	TEXT("msppcntr"),		// ini file name
	FALSE,						// must be FALSE
	20, 							// number of default counter types
	{ 							// default counter types
	{PM_REQUESTS_SEC,PERF_COUNTER_COUNTER}, 
	{PM_REQUESTS_TOTAL,PERF_COUNTER_RAWCOUNT}, 
	{PM_AUTHSUCCESS_SEC,PERF_COUNTER_COUNTER}, 
	{PM_AUTHSUCCESS_TOTAL,PERF_COUNTER_RAWCOUNT}, 
	{PM_AUTHFAILURE_SEC,PERF_COUNTER_COUNTER}, 
	{PM_AUTHFAILURE_TOTAL,PERF_COUNTER_RAWCOUNT}, 
	{PM_FORCEDSIGNIN_SEC,PERF_COUNTER_COUNTER}, 
	{PM_FORCEDSIGNIN_TOTAL,PERF_COUNTER_RAWCOUNT}, 
	{PM_PROFILEUPDATES_SEC,PERF_COUNTER_COUNTER}, 
	{PM_PROFILEUPDATES_TOTAL,PERF_COUNTER_RAWCOUNT}, 
	{PM_INVALIDREQUESTS_SEC,PERF_COUNTER_COUNTER}, 
	{PM_INVALIDREQUESTS_TOTAL,PERF_COUNTER_RAWCOUNT},
	{PM_PROFILECOMMITS_SEC,PERF_COUNTER_COUNTER},
	{PM_PROFILECOMMITS_TOTAL,PERF_COUNTER_RAWCOUNT},
	{PM_VALIDPROFILEREQ_SEC,PERF_COUNTER_COUNTER},
	{PM_VALIDPROFILEREQ_TOTAL,PERF_COUNTER_RAWCOUNT},
	{PM_NEWCOOKIES_SEC,PERF_COUNTER_COUNTER},
	{PM_NEWCOOKIES_TOTAL,PERF_COUNTER_RAWCOUNT},
	{PM_VALIDREQUESTS_SEC,PERF_COUNTER_COUNTER}, 
	{PM_VALIDREQUESTS_TOTAL,PERF_COUNTER_RAWCOUNT}
	},			
	NULL,						// must be null
};


// add objects to global object array
PassportObjectData *g_PObject[] = {
	&PMCountersObject
};

#define NUM_PERFMON_OBJECTS (sizeof(g_PObject) / sizeof(g_PObject[0]))


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\perflibrary\pmcounters\passportperfdefs.h ===
/*++

    Copyright (c) 1998 Microsoft Corporation

    Module Name:

        PassportPerfDefs.h

    Abstract:

		Shared Memory segment name definitions

    Author:

		Christopher Bergh (cbergh) 10-Sept-1988

    Revision History:

		- added multi-object support 1-Oct-98
--*/
#if !defined(PASSPORTPERFDEFS_H)
#define PASSPORTPERFDEFS_H


const TCHAR PASSPORT_PERF_BLOCK[] = _T("PMCountersFileBlock");
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\schema\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__70EC6ECF_9549_11D2_95DE_00C04F8E7A70__INCLUDED_)
#define AFX_STDAFX_H__70EC6ECF_9549_11D2_95DE_00C04F8E7A70__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#include <tchar.h>
#include <comdef.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__70EC6ECF_9549_11D2_95DE_00C04F8E7A70__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\tools\passportassert.hpp ===
#ifndef PASSPORTASSERT_HPP
#define PASSPORTASSERT_HPP

#include <stdlib.h>
#include <iostream>
using namespace std;

inline void PassportAssert(bool assertion)
{
	if (!assertion)
	{
		cout << "ASSERT FALIED" << endl;
		abort();
	}
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\schema\authnsecureschema.cpp ===
// Init functions for auth and secure ticket schemas
#include "stdafx.h"
#include "ProfileSchema.h"
#include <winsock2.h>

CProfileSchema* InitAuthSchema()
{
  UINT numEntries = 13; // MemberId, last refresh, last login, savePwd, flags
  LPTSTR names[] = { _TEXT("memberIdLow"),_TEXT("memberIdHigh"),_TEXT("lastRefresh"),
             _TEXT("lastLogin"),_TEXT("currentTime"),_TEXT("savedPwd"),_TEXT("flags"),
             _TEXT("SchemaVersion"),_TEXT("Mask"),_TEXT("DA-Skew"),_TEXT("SecurityLevel"),
             _TEXT("KidConsent"),_TEXT("PinTime")};

  short sizes[] = { sizeof(u_long)*8, sizeof(u_long)*8, sizeof(u_long)*8,
            sizeof(u_long)*8, sizeof(u_long)*8, 8, sizeof(u_long)*8,
            sizeof(u_short)*8, sizeof(u_short)*8, sizeof(u_long)*8, sizeof(u_long)*8,
            sizeof(u_long)*8, sizeof(u_long)*8
  };
  CProfileSchema::AttrType types[] = {
    CProfileSchema::tLong, CProfileSchema::tLong,
    CProfileSchema::tLong, CProfileSchema::tLong,
    CProfileSchema::tLong, CProfileSchema::tChar,
    CProfileSchema::tLong, CProfileSchema::tWord,
    CProfileSchema::tWord, CProfileSchema::tLong,
    CProfileSchema::tLong, CProfileSchema::tLong,
    CProfileSchema::tLong
  };

  CProfileSchema *cp = new CProfileSchema();
  if (cp)
    cp->ReadFromArray(numEntries, names, types, sizes);

  cp->m_maskPos = 8;
  return cp;
}

CProfileSchema* InitSecureSchema()
{
//  UINT numEntries = 6; // MemberIdLow, MemberIdHigh, password, version, time flags
  LPTSTR names[] = { _TEXT("memberIdLow"),_TEXT("memberIdHigh"),_TEXT("password"),
                     _TEXT("version"), _TEXT("time"), _TEXT("flags") };
  short sizes[] = { sizeof(u_long)*8, sizeof(u_long)*8, -1,
                  sizeof(u_long)*8, sizeof(u_long)*8, sizeof(u_long)*8 };
  CProfileSchema::AttrType types[] = {
    CProfileSchema::tLong, CProfileSchema::tLong, CProfileSchema::tText,
   CProfileSchema::tLong, CProfileSchema::tLong, CProfileSchema::tLong, };

  CProfileSchema *cp = new CProfileSchema();
  if (cp)
    cp->ReadFromArray(sizeof(names)/sizeof(LPTSTR),
                      names,
                      types,
                      sizes);
  return cp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\schema\ticketschema.cpp ===
/*++

  Copyright (c) 2001 Microsoft Corporation
  
    Module Name:
    
      ticketSchema.cpp
      
    Abstract:
        
      Implementation of ticket schema lookup
          
    Usage:
            
    Author:
              
      Wei Jiang(weijiang) 15-Jan-2001
                
    Revision History:
      15-Jan-2001 weijiang         Created.
                      
--*/

#include "stdafx.h"
#include "ticketschema.h"
#include "BstrDebug.h"
#include <winsock2.h> // u_short, u_long, ntohs, ntohl
#include <crtdbg.h>
#include <pmerrorcodes.h>
#include <time.h>
// #include <pmalerts.h>

#define PASSPORTLOG(i,x)  ;

CTicketSchema::CTicketSchema()
: m_isOk(FALSE), m_szReason(L"Uninitialized"),
  m_numAtts(0), m_attsDef(NULL), m_version(0)
{
}

CTicketSchema::~CTicketSchema()
{
  if (m_attsDef != NULL)
    delete[] m_attsDef;
}

BOOL CTicketSchema::ReadSchema(MSXML::IXMLElementPtr &root)
{
   BOOL bResult = FALSE;
   LPTSTR r=NULL; // The current error, if it happens
   int cAtts = 0;
   MSXML::IXMLElementCollectionPtr atts;
   MSXML::IXMLElementPtr pElt;
   VARIANT iAtts;

   // Type identifiers
 
   try
   {    
      // Ok, now iterate over attributes
      atts = root->children;
      cAtts = atts->length;
    
      if (cAtts <= 0)
      {
         r = _T("No attributes in TicketSchema file.");
         _com_issue_error(E_FAIL);
      }
    
      if (m_attsDef)
         delete[] m_attsDef;
    
      m_attsDef = new TicketFieldDef[cAtts];

      // get name and version info
      m_name = root->getAttribute(ATTRNAME_NAME);
      _bstr_t aVersion = root->getAttribute(ATTRNAME_VERSION);

      if(aVersion.length() != 0)
         m_version = (short)_wtol(aVersion);
      else
         m_version = 0; // invalid
    
      VariantInit(&iAtts);
      iAtts.vt = VT_I4;

      for (iAtts.lVal = 0; iAtts.lVal < cAtts; iAtts.lVal++)
      {
         pElt = atts->item(iAtts);
         m_attsDef[iAtts.lVal].name = pElt->getAttribute(ATTRNAME_NAME);
         _bstr_t aType = pElt->getAttribute(ATTRNAME_TYPE);
         _bstr_t aFlags = pElt->getAttribute(ATTRNAME_FLAGS);

         // find out the type information
         m_attsDef[iAtts.lVal].type = tInvalid;
         if(aType.length() != 0)
         {
            for(int i = 0; i < (sizeof(TicketTypeNameMap) / sizeof(CTicketTypeNameMap)); ++i)
            {
               if(_wcsicmp(aType, TicketTypeNameMap[i].name) == 0)
               {
                  m_attsDef[iAtts.lVal].type = TicketTypeNameMap[i].type;
                  break;
               }
            }
         }

         // flags      
         if(aFlags.length() != 0)
            m_attsDef[iAtts.lVal].flags = _wtol(aFlags);
         else
            m_attsDef[iAtts.lVal].flags = 0;
      }

      m_numAtts = iAtts.lVal;
      bResult = m_isOk = TRUE;
    
   }
   catch (_com_error &e)
   {
      CHAR ach[256];

      // TODO -- put tracing code in to ease the debug
      WideCharToMultiByte(CP_ACP, 0, e.ErrorMessage(), -1, ach, sizeof(ach), NULL, NULL);
      PASSPORTLOG(DOMAINMAP_DBGNUM, "Passport:  CTicketSchema::Read threw this exception: \""<<ach<<"\".\n");
      
      WideCharToMultiByte(CP_ACP, 0, r, -1, ach, sizeof(ach), NULL, NULL);
      PASSPORTLOG(DOMAINMAP_DBGNUM, "Passport:  CTicketSchema::Read...r = \""<<ach<<"\".\n");
      
      bResult = m_isOk = FALSE;
   }
    
   return bResult;
}


HRESULT CTicketSchema::parseTicket(LPCSTR raw, UINT size, CTicketPropertyBag& bag)
{
   DWORD          cParsed = 0;
   HRESULT        hr = S_OK;
   LPBYTE         dataToParse = (LPBYTE)raw;
   UINT           cDataToParse = size;

#if 0 // avoid changing to much to the code, not to deal with the 1.3x ticket format in schema parser
   // get those 1.3X items
   CTicket_13X    ticket13X;

   // parse the 1.3X ticket first
   BOOL bParsed = ticket13X.parse(dataToParse, cDataToParse, &cParsed);

   if (!bParsed)  return E_INVALIDARG;

   {
      long  curTime;

      time(&curTime);
      // If the current time is "too" negative, bail (5 mins)
      if ((unsigned long)(curTime+300) < ticket13X.currentTime())
      {
          /*
           if (g_pAlert)
           {
               DWORD dwTimes[2] = { curTime, ntohl(*(u_long*) (lpBase+spot)) };
               g_pAlert->report(PassportAlertInterface::ERROR_TYPE, PM_TIMESTAMP_BAD,
                            0, NULL, sizeof(DWORD) << 1, (LPVOID)dwTimes);
           }
           */
           hr = E_FAIL; // need an error code for ... PM_TIMESTAMP_BAD;
           return hr;
      }
   }

   dataToParse += cParsed;
   cDataToParse -= cParsed;
   // put 1.3x fields into the bag
   // TODO -- later
#endif // 1.3X stuff

   // then the schema version #
   if(cDataToParse > 2)  // enough  for version
   {
      unsigned short * p = (unsigned short *)(dataToParse);
#if 0       // we purposely not to compare version, since live prop may create a time gap there between mspp, and parnter site.
      if (ntohs(*p) != m_version)
         return S_FALSE; // Todo -- new error code for version mismatch
#endif

      if (m_version < VALID_SCHEMA_VERSION_MIN || m_version > VALID_SCHEMA_VERSION_MAX)
         return S_FALSE;   // not able to process with this version of ppm
         
      dataToParse += 2;
      cDataToParse -= 2;
   }
   
   // then the maskK
   CTicketFieldMasks maskF;
   hr = maskF.Parse(dataToParse, cDataToParse, &cParsed);

   if(hr != S_OK)
      return hr;

   // pointer advances
   dataToParse += cParsed;
   cDataToParse -= cParsed;
   
   USHORT*     pIndexes = maskF.GetIndexes();
   DWORD       type = 0;
   DWORD       flags = 0;
   DWORD       fSize = 0;
   variant_t   value;

   USHORT   index = MASK_INDEX_INVALID;
   // then the data
   // get items that enabled by the schema
   while((index = *pIndexes) != MASK_INDEX_INVALID && cDataToParse > 0)
   {
      TicketProperty prop;
      // if index is out of schema range
      if (index >= m_numAtts) break;

      // fill-in the offset of the property
      prop.offset = dataToParse - (LPBYTE)raw; 

      // type 
      type = m_attsDef[index].type;

      fSize = TicketTypeSizes[type];
      switch (type)
      {
      case tText:
        {
            u_short slen = ntohs(*(u_short*)(dataToParse));
            value.vt = VT_BSTR;
            if (slen == 0)
            {
                value.bstrVal = ALLOC_AND_GIVEAWAY_BSTR_LEN(L"", 0);
            }
            else
            {
                int wlen = MultiByteToWideChar(CP_UTF8, 0,
                                            (LPCSTR)dataToParse+sizeof(u_short),
                                            slen, NULL, 0);
                value.bstrVal = ALLOC_AND_GIVEAWAY_BSTR_LEN(NULL, wlen);
                MultiByteToWideChar(CP_UTF8, 0,
                                    (LPCSTR)dataToParse+sizeof(u_short),
                                    slen, value.bstrVal, wlen);
                value.bstrVal[wlen] = L'\0';
            }

            dataToParse += slen + sizeof(u_short);
            cDataToParse -= slen + sizeof(u_short);
         }
         break;
         
      case tChar:
         _ASSERTE(0);  // NEED MORE THOUGHT -- IF unicode makes more sense
/*         
         {
            int wlen = MultiByteToWideChar(CP_UTF8, 0,
                                            raw+m_pos[index],
                                            m_schema->GetByteSize(index), NULL, 0);
            pVal->vt = VT_BSTR;
            pVal->bstrVal = ALLOC_AND_GIVEAWAY_BSTR_LEN(NULL, wlen);
            MultiByteToWideChar(CP_UTF8, 0,
                                raw+m_pos[index],
                                m_schema->GetByteSize(index), pVal->bstrVal, wlen);
            pVal->bstrVal[wlen] = L'\0';
         }
*/
         break;
      case tByte:
         value.vt = VT_I2;
         value.iVal = *(BYTE*)(dataToParse);
         break;
      case tWord:
         value.vt = VT_I2;
         value.iVal = ntohs(*(u_short*) (dataToParse));
         break;
      case tLong:
         value.vt = VT_I4;
         value.lVal = ntohl(*(u_long*) (dataToParse));
         break;
      case tDate:
         value.vt = VT_DATE;
         VarDateFromI4(ntohl(*(u_long*) (dataToParse)), &(value.date));
         break;
      default:
         return PP_E_BAD_DATA_FORMAT;
      }

      // now with name, flags, value, type, we can put it into property bag
      // name, flags, value
      prop.flags = m_attsDef[index].flags;
      prop.type = type;
      prop.value.Attach(value.Detach());
      bag.PutProperty(m_attsDef[index].name, prop);


      // for text data, the pointer was already adjusted
      if (fSize  != SIZE_TEXT)
      {
         dataToParse += fSize;
         cDataToParse -= fSize;
      }   

      ++pIndexes;
   }
   
   return S_OK;
}

//
//
// Ticket property bag
//
CTicketPropertyBag::CTicketPropertyBag()
{

}

CTicketPropertyBag::~CTicketPropertyBag()
{
}

HRESULT CTicketPropertyBag::GetProperty(LPCWSTR  name, TicketProperty& prop)
{
   HRESULT  hr = S_OK;

   if(!name || (!*name))
      return E_INVALIDARG;
   
   TicketPropertyMap::iterator i;

   i = m_props.find(name);

   if(i!= m_props.end())
      prop = i->second;
   else
      hr = S_FALSE;
    

   return hr;
}

HRESULT CTicketPropertyBag::PutProperty(LPCWSTR  name, const TicketProperty& prop)
{
   HRESULT  hr = S_OK;

   if(!name || (!*name))
      return E_INVALIDARG;
   try{
      m_props[name] = prop;
   }
   catch (...)
   {
      hr = E_OUTOFMEMORY;
   }
   return hr;
}

#if 0 // was meant to replace existing code that parses the 1.3x ticket -- to avoid too much change, not to use it for now.

// 
// deal with 1.3X ticket format
//
BOOL CTicket_13X::parse(
    LPBYTE      raw,
    DWORD       dwByteLen,
    DWORD*      pdwBytesParsed
    )
{
    LPSTR lpBase;
    UINT  byteLen, spot=0;
    long  curTime;

    if(pdwBytesParsed)
      *pdwBytesParsed = 0;

   m_valid = false;
    if (!raw)
    {
        goto Cleanup;
    }  

    // format:
    //  four bytes network long - low memberId bytes
    //  four bytes network long - high memberId bytes
    //  four bytes network long - time of last refresh
    //  four bytes network long - time of last password entry
    //  four bytes network long - time of ticket generation
    //  one byte - is this a saved password (Y/N)
    //  four bytes network long - flags

    lpBase = (LPSTR) raw;
    byteLen = dwByteLen;
    spot=0;

    if (byteLen < sizeof(u_long)*5 + sizeof(char)) 
    { 
        m_valid = FALSE;
        goto Cleanup;
    }

    m_mIdLow  = ntohl(*(u_long*)lpBase);
    spot += sizeof(u_long);

    m_mIdHigh = ntohl(*(u_long*)(lpBase + spot));
    spot += sizeof(u_long);

    m_ticketTime     = ntohl(*(u_long*) (lpBase+spot));
    spot += sizeof(u_long);

    m_lastSignInTime = ntohl(*(u_long*) (lpBase+spot));
    spot += sizeof(u_long);

    time(&curTime);
    // If the current time is "too" negative, bail (5 mins)
    m_curTime = ntohl(*(u_long*) (lpBase+spot));
    spot += sizeof(u_long);

    m_savedPwd = (*(char*)(lpBase+spot)) == 'Y' ? TRUE : FALSE;
    spot += sizeof(char);

    m_flags = ntohl(*(u_long*) (lpBase+spot));
    spot += sizeof(u_long);

    m_valid = TRUE;
    *pdwBytesParsed = spot;

Cleanup:

    return m_valid;
}

ULONG CTicket_13X::ticketTime()
{
    return m_ticketTime;
}

ULONG CTicket_13X::currentTime()
{
    return m_curTime;
}

ULONG CTicket_13X::signInTime()
{
    return m_lastSignInTime;
}

ULONG CTicket_13X::flags()
{
    return m_flags;
}

ULONG CTicket_13X::memberIdHigh()
{
    return m_mIdHigh;
}

ULONG CTicket_13X::memberIdLow()
{
    return m_mIdLow;
}

BOOL CTicket_13X::hasSavedPassword()
{
   return m_savedPwd;
}

BOOL CTicket_13X::isValid()
{
   return m_valid;
}

#endif // if 0 ...
//
//
// class CTicketFieldMasks
//
inline HRESULT CTicketFieldMasks::Parse(PBYTE masks, ULONG size, ULONG* pcParsed) throw()
{
   _ASSERT(pcParsed && masks);
   // 16 bits as a unit of masks

   *pcParsed = 0;
   if (!masks || size < 2) return E_INVALIDARG;
   // validate the masks
   u_short* p = (u_short*)masks;
   ULONG    totalMasks = 15;
   u_short  mask;
   *pcParsed += 2;

   // find out size
   while(MORE_MASKUNIT(ntohs(*p++))) //the folling short is mask unit
   {
      totalMasks += 15;
      // insufficient data in buffer
      if (*pcParsed + 2 > size)  return E_INVALIDARG;

      *pcParsed += 2;
   }

   if(m_fieldIndexes) delete[] m_fieldIndexes;
   m_fieldIndexes = new unsigned short[totalMasks];  // max number of mask bits
   for ( unsigned int i = 0; i < totalMasks; ++i)
   {
      m_fieldIndexes[i] = MASK_INDEX_INVALID;
   }

   p = (u_short*)masks;
   unsigned short      index = 0;
   totalMasks = 0; 
   // fill in the mask
   do
   {
      mask = ntohs(*p++);
	  //// find the bits
      if (mask & 0x7fff)   // any 1s
      {
         unsigned short j = 0x0001;
         while( j != 0x8000 )
         {
            if(j & mask)
               m_fieldIndexes[totalMasks++] = index;
            ++index;
            j <<= 1;
         }
      }
      else
         index += 15;
   } while(MORE_MASKUNIT(mask)); //the folling short is mask unit


   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\tools\passporterrortostring.hpp ===
#ifndef PASSPORTERRORTOSTRING_HPP
#define PASSPORTERRORTOSTRING_HPP

#include <windows.h>
#include <winbase.h>
#include <string>

#include "PassportToString.hpp"


// translates a GetLastError() code to a string.

inline std::string PassportErrorToString(DWORD systemErrorCode)
{

	char* buffer = NULL;
	

	DWORD bytes = FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER |
								FORMAT_MESSAGE_FROM_SYSTEM |     
								FORMAT_MESSAGE_IGNORE_INSERTS
								,    
								NULL,
								systemErrorCode,
								MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
								(char*) &buffer,
								0,
								NULL );

	std::string retValue = "Error = " + PassportToString(systemErrorCode);
	if (buffer != NULL)
	{
		retValue += " Msg = ";
		retValue += buffer;
		LocalFree(buffer);
		return retValue;
	}
	else
		retValue += " Msg = <unable to translate message>";

	return retValue;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\tools\passportevent.hpp ===
#ifndef __PASSPORTEVENT_HPP
#define __PASSPORTEVENT_HPP

class PassportEvent
{
public:

    PassportEvent(BOOL bManualReset = TRUE, BOOL bInitialState = FALSE)
    {
        m_hEvent = CreateEvent(NULL, bManualReset, bInitialState, NULL);
    }

    ~PassportEvent()
    {
        CloseHandle(m_hEvent);
    }

    BOOL Pulse()    {return PulseEvent(m_hEvent);}
    BOOL Set()      {return SetEvent(m_hEvent);}
    BOOL Reset()    {return ResetEvent(m_hEvent);}

    operator HANDLE() {return m_hEvent;}

private:

    HANDLE m_hEvent;
};

#endif // __PASSPORTEVENT_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\schema\profileschema.cpp ===
/*++

  Copyright (c) 1998 Microsoft Corporation

    Module Name:

      ProfileSchema.cpp

    Abstract:

      Implementation of profile schema lookup

    Usage:

    Author:

      Max Metral (mmetral) 15-Dec-1998

    Revision History:

      15-Dec-1998 mmetral

        Created.

--*/

#include "stdafx.h"
#include "ProfileSchema.h"
#include "BstrDebug.h"
#include <winsock2.h> // u_short, u_long, ntohs, ntohl

#define PASSPORTLOG(i,x)  ;

CProfileSchema::CProfileSchema()
: m_isOk(FALSE), m_szReason(L"Uninitialized"),
  m_numAtts(0), m_atts(NULL), m_sizes(NULL), m_refs(0),
  m_readOnly(NULL), m_indexes("ProfileSchema",LK_DFLT_MAXLOAD,LK_SMALL_TABLESIZE,0),
  m_maskPos(-1)
{
}

CProfileSchema::~CProfileSchema()
{
  if (m_atts != NULL)
    delete[] m_atts;
  if (m_sizes != NULL)
    delete[] m_sizes;
  if (m_readOnly != NULL)
    delete[] m_readOnly;

  if (m_indexes.Size() > 0)
    {
      LK_RETCODE lkrc;
      const RAWBSTR2INT& htConst = m_indexes;
      RAWBSTR2INT::CConstIterator itconst;
      for (lkrc = htConst.InitializeIterator(&itconst) ;
       lkrc == LK_SUCCESS ;
       lkrc = htConst.IncrementIterator(&itconst))
    {
      FREE_BSTR(itconst.Key());
    }
      htConst.CloseIterator(&itconst);
      m_indexes.Clear();
    }
}

BOOL CProfileSchema::Read(MSXML::IXMLElementPtr &root)
{
  BOOL bResult = FALSE;
  LPTSTR r=NULL; // The current error, if it happens
  int cAtts = 0, i;
  MSXML::IXMLElementCollectionPtr atts;
  MSXML::IXMLElementPtr pElt;
  VARIANT iAtts;

  // Type identifiers
  _bstr_t btText(L"text"), btChar(L"char"), btByte(L"byte");
  _bstr_t btWord(L"word"), btLong(L"long"), btDate(L"date");;
  _bstr_t name(L"name"), type(L"type"), size(L"size"), acc(L"access");

  try
  {
    // Ok, now iterate over attributes
    atts = root->children;
    cAtts = atts->length;

    if (cAtts <= 0)
    {
      r = _T("No attributes in ProfileSchema file.");
      _com_issue_error(E_FAIL);
    }

    if (m_atts)
      delete[] m_atts;
    if (m_sizes)
      delete[] m_sizes;
    if (m_readOnly)
      delete[] m_readOnly;
    if (m_indexes.Size() == 0)
      {
    LK_RETCODE lkrc;
    const RAWBSTR2INT& htConst = m_indexes;
    RAWBSTR2INT::CConstIterator itconst;
    for (lkrc = htConst.InitializeIterator(&itconst) ;
         lkrc == LK_SUCCESS ;
         lkrc = htConst.IncrementIterator(&itconst))
      {
        FREE_BSTR(itconst.Key());
      }
    htConst.CloseIterator(&itconst);
    m_indexes.Clear();
      }

    m_atts = new AttrType[cAtts];
    m_sizes = new short[cAtts];
    m_readOnly = new BYTE[cAtts];
    m_numAtts = cAtts;

    VariantInit(&iAtts);
    iAtts.vt = VT_I4;

    for (iAtts.lVal = 0; iAtts.lVal < cAtts; iAtts.lVal++)
    {
      i = iAtts.lVal;
      m_readOnly[i] = 0;

      pElt = atts->item(iAtts);
      _bstr_t aType = pElt->getAttribute(type);
      _bstr_t aName = pElt->getAttribute(name);
      _bstr_t aAccess = pElt->getAttribute(acc);

      if (aAccess.length() > 0 && !_wcsicmp(aAccess, L"ro"))
    {
      m_readOnly[i] = 1;
    }

    //  [DARRENAN]  Don't add empty names to the list.  This is so we can deprecate the use
    //  of certain attributes w/o removing their position in the schema.  First example
    //  of this is inetaccess.
    if(aName.length() != 0)
    {
        BSTR aNameCopy = ALLOC_BSTR(aName);
        if (!aNameCopy)
            _com_issue_error(E_OUTOFMEMORY);

        RAWBSTR2INT::ValueType *pMapVal = new RAWBSTR2INT::ValueType(aNameCopy, i);
        if (!pMapVal || LK_SUCCESS != m_indexes.InsertRecord(pMapVal))
            _com_issue_error(E_FAIL);
    }

      if (aType == btText)
      {
        m_atts[i] = tText;
        m_sizes[i]= -1;
      }
      else if (aType == btChar)
      {
        m_atts[i] = tChar;
        m_sizes[i]= _wtoi(_bstr_t(pElt->getAttribute(size)))*8;
      }
      else if (aType == btByte)
      {
        m_atts[i] = tByte;
        m_sizes[i]= 8;
      }
      else if (aType == btWord)
      {
        m_atts[i] = tWord;
        m_sizes[i]= 16;
      }
      else if (aType == btLong)
      {
        m_atts[i] = tLong;
        m_sizes[i] = 32;
      }
      else if (aType == btDate)
      {
        m_atts[i] = tDate;
        m_sizes[i] = 32;
      }
      else
        _com_issue_error(E_FAIL);
    }
    bResult = TRUE;

    }

    catch (_com_error &e)
    {
      CHAR ach[256];

      WideCharToMultiByte(CP_ACP, 0, (LPCWSTR) e.ErrorMessage(), -1, ach, sizeof(ach), NULL, NULL);
      PASSPORTLOG(DOMAINMAP_DBGNUM, "Passport:  CProfileSchema::Read threw this exception: \""<<ach<<"\".\n");

      WideCharToMultiByte(CP_ACP, 0, (LPCWSTR) r, -1, ach, sizeof(ach), NULL, NULL);
      PASSPORTLOG(DOMAINMAP_DBGNUM, "Passport:  CProfileSchema::Read...r = \""<<ach<<"\".\n");

      bResult = m_isOk = FALSE;
    }

    return bResult;
}

BOOL CProfileSchema::ReadFromArray(UINT numAttributes, LPTSTR names[], AttrType types[], short sizes[], BYTE readOnly[])
{
  if (m_atts)
    delete[] m_atts;
  if (m_sizes)
    delete[] m_sizes;
  if (m_readOnly)
    delete[] m_readOnly;
  if (m_indexes.Size() == 0)
    {
      LK_RETCODE lkrc;
      const RAWBSTR2INT& htConst = m_indexes;
      RAWBSTR2INT::CConstIterator itconst;
      for (lkrc = htConst.InitializeIterator(&itconst) ;
       lkrc == LK_SUCCESS ;
       lkrc = htConst.IncrementIterator(&itconst))
      {
        FREE_BSTR(itconst.Key());
      }
      htConst.CloseIterator(&itconst);
      m_indexes.Clear();
    }

  m_numAtts = numAttributes;
  m_atts = new AttrType[m_numAtts];
  m_sizes = new short[m_numAtts];
  m_readOnly = new BYTE[m_numAtts];

  if (!m_atts || !m_sizes || !m_readOnly) return FALSE;

  for (UINT i = 0; i < m_numAtts; i++)
    {
      BSTR copy = ALLOC_BSTR((LPCWSTR) names[i]);
      if (!copy)
    return FALSE;
      RAWBSTR2INT::ValueType *pMapVal = new RAWBSTR2INT::ValueType(copy, i);
      if (!pMapVal || m_indexes.InsertRecord(pMapVal) != LK_SUCCESS)
    return FALSE;
      m_atts[i] = types[i];
      // BUGBUG we shouldn't copy directly if it's a type we KNOW the size of
      // should be a switch here
      m_sizes[i] = sizes[i];
      if (readOnly)
    m_readOnly[i] = readOnly[i];
      else
    m_readOnly[i] = 0;
    }
  m_isOk = true;

  return TRUE;
}

int CProfileSchema::GetBitSize(UINT index) const
{
  if (index > m_numAtts)
    return 0;

  return m_sizes[index];
}

int CProfileSchema::GetByteSize(UINT index) const
{
  if (index > m_numAtts)
    return 0;

  if (m_sizes[index] != -1)
    return m_sizes[index]/8;
  else
    return -1;
}

CProfileSchema::AttrType CProfileSchema::GetType(UINT index) const
{
  if (index > m_numAtts)
    return AttrType::tInvalid;
  return m_atts[index];
}

BOOL CProfileSchema::IsReadOnly(UINT index) const
{
  if (index > m_numAtts)
    return TRUE;
  return m_readOnly[index] != 0;
}

int CProfileSchema::GetIndexByName(BSTR name) const
{
    const RAWBSTR2INT& htConst = m_indexes;
    const RAWBSTR2INT::ValueType *pOut = NULL;

    if (LK_SUCCESS == m_indexes.FindKeyBstr(name, &pOut) && pOut != NULL)
    {
        int o = pOut->m_v;
        m_indexes.AddRefRecord(pOut, -1);
        return o;
    }
    else
        return -1;
}

BSTR CProfileSchema::GetNameByIndex(int index) const
{
  LK_RETCODE lkrc;
  const RAWBSTR2INT& htConst = m_indexes;
  RAWBSTR2INT::CConstIterator it;

  for (lkrc = htConst.InitializeIterator(&it) ;
       lkrc == LK_SUCCESS ;
       lkrc = htConst.IncrementIterator(&it))
    {
      if (it.Record()->m_v == index)
    {
      BSTR r = it.Key();
      htConst.CloseIterator(&it);
      return r;
    }
    }
  htConst.CloseIterator(&it);
  return NULL;
}

/**
 * Given my schema, and a void* array of elements, build the profile blob
 * the number of element passed in is specified in cEles parameter
 * the elements should be continuous
 */
BSTR CProfileSchema::packProfile(void *elements[], DWORD cEles)
{
  UINT i;
  int bitSize=0, spot=0;
  int *sz;
  BSTR ret;
  LPSTR raw;
  u_short mask;

  // full schema case
  if (cEles == FULL_SCHEMA)
     cEles = m_numAtts;

  if (!m_isOk || m_numAtts == 0 || cEles == 0 || cEles > m_numAtts)
  {
      sz = NULL;
      ret = NULL;
      goto Cleanup;
  }

  sz = new int[m_numAtts];

  // First find the size we need
  for (i = 0; i < cEles; i++)
  {
    if (m_maskPos >= 0 && i == m_maskPos)
    {
        if (tWord != m_atts[i])
        {
            ret = NULL;         // wrong type
            goto Cleanup;
        }
        mask = *(u_short*)elements[i];
    }
    if (m_maskPos >= 0 && ((int) i) > m_maskPos)
    {
        if ((i-m_maskPos) > 15)
        {
            ret = NULL;         // need more mask.
            goto Cleanup;
        }
        if (!(mask & (1<<(i-m_maskPos-1))))
            continue;       // the field is to be skipped.
    }

    if ((sz[i] = m_sizes[i]) == -1)
    {
      if (elements[i])
         sz[i] = strlen((LPSTR)elements[i])*8;
      else
         sz[i] = 0;
      if (sz[i] > 0xffff) // string too big
      {
        ret = NULL;
        goto Cleanup;
      }

      bitSize += sizeof(u_short)*8;
    }
    bitSize += sz[i];
  }

  ret = ALLOC_BSTR_BYTE_LEN(NULL,bitSize/8);
  raw = (LPSTR) ret;

  // Now fill it
  for (i = 0; i < cEles; i++)
  {
    if (m_maskPos >= 0 && ((int) i) > m_maskPos)
    {
        if (!(mask & (1<<(i-m_maskPos-1))))
            continue;       // the field is to be skipped.
    }
    switch (m_atts[i])
    {
    case tText:
      *(u_short*)(raw+spot) = htons(sz[i]/8); // Set the string size
      spot += sizeof(u_short);
    case tChar:
      if (elements[i])
      {
         memcpy(raw+spot, elements[i], sz[i]/8);
      }
      spot += sz[i]/8;
      break;

    case tByte:
      *(BYTE*)(raw+spot) = *(BYTE*)elements[i];
      spot ++;
      break;

    case tWord:
      *(u_short*)(raw+spot) = htons(*(u_short*)elements[i]);
      spot += sizeof(u_short);
      break;

    case tLong:
    case tDate:
      *(u_long*)(raw+spot) = htonl(*(u_long*)elements[i]);
      spot += sizeof(u_long);
      break;

    }
  }

Cleanup:

  if(sz)
    delete[] sz;

  if(ret)
  {
    GIVEAWAY_BSTR(ret);
  }

  return ret;
}

HRESULT CProfileSchema::parseProfile(LPSTR raw, UINT size, UINT *positions, UINT *bitFlagPositions, DWORD* pdwAttris)
{
    // Read the raw blob according to the schema, and output the positions of
    // each element
    UINT i, spot = 0, curBits = 0, thisSize;

    // they have to be good memory
    if (IsBadWritePtr(positions, m_numAtts * sizeof(UINT))) return E_INVALIDARG;
    if (IsBadWritePtr(bitFlagPositions, m_numAtts * sizeof(UINT))) return E_INVALIDARG;
    if (!pdwAttris) return E_INVALIDARG;

    // initialize the arrays
    for (i = 0; i < m_numAtts; i++)
    {
      *(positions + i) = INVALID_POS;   // position of -1 is not defined
      *(bitFlagPositions + i) = 0;     // bit flag position of 0, is to start from begining
    }

    // number of attributes - init 0
    *pdwAttris = 0;

    for (i = 0; i < m_numAtts && spot < size; i++)
    {
        //
        //  increment attrib cnt moved at the end. Added a check
        //  that the new attrib size fits in the buf len
        //
        positions[i] = spot;
        thisSize = GetByteSize(i);

        if (thisSize && curBits)
        {
            // Make sure the padding lines up on a boundary
            if ((curBits + m_sizes[i])%8)
            {
                // Something wrong, can't align on non-byte boundaries
                return E_INVALIDARG;
            }
            spot += ((curBits+m_sizes[i])/8);
        }

        UINT iRemain = size - spot; // # of byte left to parse
        
        if (thisSize == 0xFFFFFFFF) // String
        {
            if(iRemain < sizeof(u_short)) return E_INVALIDARG;

            iRemain -= sizeof(u_short);
            u_short sz = ntohs(*(u_short*)(raw+spot));

            if(iRemain < sz)  return E_INVALIDARG;
            spot += sizeof(u_short)+sz;
        }
        else if (thisSize != 0)
        {
            if(iRemain < thisSize)  return E_INVALIDARG;
            spot += thisSize;  // Simple, just a fixed length
        }
        else // Bit field
        {
            curBits += m_sizes[i];
            // If this is a pad, this field is irrelevant anyway,
            // otherwise, it's one bit long
            bitFlagPositions[i] = curBits;
            while (curBits >= 8)
            {
                spot ++;
                curBits -= 8;
            }
        }
        if (spot <= size)
            (*pdwAttris)++;
    }

    if (i == 0)
        return S_FALSE;
    else
        return S_OK;
}

CProfileSchema* CProfileSchema::AddRef()
{
  InterlockedIncrement(&m_refs);
  return this;
}

void CProfileSchema::Release()
{
  InterlockedDecrement(&m_refs);
  if (m_refs == 0)
    delete this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\tools\passportexport.h ===
// PassportExport.h: 
//
//////////////////////////////////////////////////////////////////////

#if !defined(PASSPORTEXPORT_H)
#define PASSPORTEXPORT_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#if !defined(_PassportExport_)
#define PassportExport __declspec(dllimport)
#else
#define PassportExport __declspec(dllexport)
#endif

#endif // !defined(PASSPORTEXPORT_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\tools\passportdefaultconstructor.hpp ===
#ifndef PASSPORTDEFAULTCONSTRUCTOR_HPP
#define PASSPORTDEFAULTCONSTRUCTOR_HPP

template < class T >
class PassportDefaultConstructor
{
public:
	T* newObject()
	{
		return (new T());
	}
};



#endif // !PASSPORTDEFAULTCONSTRUCTOR_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\tools\passportlock.cpp ===
#include "PassportLock.hpp"

PassportLock::PassportLock(DWORD dwSpinCount)
{
	InitializeCriticalSectionAndSpinCount(&mLock, 4000);
}

void PassportLock::acquire()
{
	EnterCriticalSection(&mLock);
}

void PassportLock::release()
{
	LeaveCriticalSection(&mLock);
}

PassportLock::~PassportLock()
{
	DeleteCriticalSection(&mLock);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\tools\passportguard.hpp ===
#ifndef PASSPORTGUARD_HPP
#define PASSPORTGUARD_HPP

template <class Lock>
class PassportGuard
{
public:
	PassportGuard(Lock& lock)
		:mLock(lock)
	{
		mLock.acquire();
	}

	~PassportGuard()
	{
		mLock.release();
	}
private:
	Lock& mLock;
};

#endif //!PASSPORTGUARD_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\tools\passportlock.h ===
class PassportLock
{
public:
	PassportLock();

	public acquire();

	public release();

	~PassportLock();
private:
	CRITICAL_SECTION mLock;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\tools\passportlock.hpp ===
#ifndef PASSPORTLOCK_HPP
#define PASSPORTLOCK_HPP

#include <windows.h>
#include <winbase.h>

class PassportLock
{
public:
	PassportLock(DWORD dwSpinCount = 4000);

	void acquire();

	void release();

	~PassportLock();
private:
	CRITICAL_SECTION mLock;
};

#endif // !PASSPORTLOCK_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\tools\passportfile.hpp ===
//---------------------------------------------------------------------------------------
//
//   @doc
// 
//   @module passportfile.hpp | Passport smart class to wrap FILE*
//    
//   Author: stevefu
//   
//   Date: 05/28/2000 
//
//  Copyright <cp> 1999-2000 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------------------

#ifndef PASSPORTFILE_HPP
#define PASSPORTFILE_HPP

#pragma once

#include <stdio.h>
#include <tchar.h>

class PassportFile
{
private:
	FILE* m_hFile;

public:
	PassportFile() : m_hFile(NULL) { }

	~PassportFile() 
	{ 
	 	if ( m_hFile != NULL) fclose(m_hFile); 
	}

	BOOL Open( const TCHAR* filename, const TCHAR* mode)
	{
		m_hFile = _tfopen(filename, mode);
		return ( NULL != m_hFile );
	}

	void Close()
	{	
		ATLASSERT(m_hFile != NULL);
		fclose(m_hFile);
	}

	// return length,   -1 if error or eof
	int ReadLine(TCHAR* string, int n)
	{
		ATLASSERT(m_hFile != NULL);
		int len = -1;
		if ( _fgetts(string, n, m_hFile) )
		{
			len = _tcslen(string);
			// trim the new line
			if ( len > 0 && string[len-1] == TEXT('\n') )
			{
				string[len-1] = TEXT('\0');
				len--;
			}
		}
		return len;
	}
	
	inline operator FILE*() { return m_hFile; }
	
};

#endif // PASSPORTFILE_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\tools\passportsemaphore.cpp ===
#include "PassportSemaphore.hpp"

PassportSemaphore::PassportSemaphore(long max, long count)
{
	mSemaphore = CreateSemaphore(NULL, count, max, NULL);
}

void PassportSemaphore::acquire()
{
	WaitForSingleObject(mSemaphore, INFINITE);
}

void PassportSemaphore::release()
{
	ReleaseSemaphore(mSemaphore, 1, NULL);
}

PassportSemaphore::~PassportSemaphore()
{
	CloseHandle(mSemaphore);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\tools\passportobjectpool.cpp ===
#include <algorithm>

#include "PassportObjectPool.hpp"
#include "PassportSystem.hpp"
#include "PassportGuard.hpp"
//#include "PassportAssert.hpp"


template <class PoolT, class ObjectConstructor >
int PassportObjectPool<PoolT, ObjectConstructor>::smDefaultMinObjects = 1;

template <class PoolT, class ObjectConstructor >
int PassportObjectPool<PoolT, ObjectConstructor>::smDefaultMaxObjects = -1; // no max 

template <class PoolT, class ObjectConstructor >
long PassportObjectPool<PoolT, ObjectConstructor>::smDefaultMaxSecondsInActive = 300; // 5 minutes 

/**
* Constructor 
* 
* @param  constructor  the object that constructs objects
* @param  minObjects the minimum number of objects in the pool. 
*         Negative is assumed to be zero
* @param  maxObjects  the maximum objects in the pool.
*         Negative is assumed to unlimited number of objects
*         If maxObjects is less then minObjects then the maximum
*         number of objects will be equal to minObjects
* @param  maxSecondsInActive  the maximum number of seconds that
*         an object that is not checked out is kept around.
*         Negative value assumes that objects once created will
*         never be released. (note: the number of objects will
*         never fall below minObjects even if they are not being used)
*/
template <class PoolT, class ObjectConstructor >
PassportObjectPool<PoolT, ObjectConstructor>::
PassportObjectPool(int minObjects,
				   int maxObjects,
				   int maxSecondsInActive)
				   :mMinObjects(minObjects),
				   mMaxObjects(maxObjects), mMaxSecondsInActive(maxSecondsInActive),
				   mLastInActivityCheck(PassportSystem::currentTimeInMillis()),
				   mObjectConstructor(*new ObjectConstructor()),
				   mOwnObjectConstructor(true)
{
	growPoolToMinimum();
}

/**
* Constructor with object constructor
* 
* @param  objectConstructor is an instance of a class that has
*         a newObject object member function that returns a pointer to
*         an object of type PoolT
* @param  minObjects the minimum number of objects in the pool. 
*         Negative is assumed to be zero
* @param  maxObjects  the maximum objects in the pool.
*         Negative is assumed to unlimited number of objects
*         If maxObjects is less then minObjects then the maximum
*         number of objects will be equal to minObjects
* @param  maxSecondsInActive  the maximum number of seconds that
*         an object that is not checked out is kept around.
*         Negative value assumes that objects once created will
*         never be released. (note: the number of objects will
*         never fall below minObjects even if they are not being used)
*/
template <class PoolT, class ObjectConstructor >
PassportObjectPool<PoolT, ObjectConstructor>::
PassportObjectPool(ObjectConstructor& objectConstructor,
				   int minObjects,
				   int maxObjects,
				   int maxSecondsInActive)
				   :mMinObjects(minObjects),
				   mMaxObjects(maxObjects), mMaxSecondsInActive(maxSecondsInActive),
				   mLastInActivityCheck(PassportSystem::currentTimeInMillis()),
				   mObjectConstructor(objectConstructor),
				   mOwnObjectConstructor(false)
{
	growPoolToMinimum();
}

/**
* Gets the min objects in the pool
*/
template <class PoolT, class ObjectConstructor >
int PassportObjectPool<PoolT, ObjectConstructor>::getMinObjects()
{
	PassportGuard<PassportWaitableLock> guard(mLock);
	return mMinObjects;
}

/**
* Sets the min objects in the pool
* @param  minObjects the minimum number of objects in the pool. 
*         Negative is assumed to be zero. The minimum is greater
*         then the current maximum then the current maximum is 
*         increased.
*/
template <class PoolT, class ObjectConstructor >
void PassportObjectPool<PoolT, ObjectConstructor>::setMinObjects(int value)
{
	PassportGuard<PassportWaitableLock> guard(mLock);
	if (value < 0)
		mMinObjects = 0;
	else
		mMinObjects = value;
	
	if (mMinObjects > getMaxObjects())
		setMaxObjects(mMinObjects);
	
	growPoolToMinimum();
}

/**
* Gets the max objects in the pool. Negative means
* there is no maximum.
*/
template <class PoolT, class ObjectConstructor >
int PassportObjectPool<PoolT, ObjectConstructor>::getMaxObjects()
{
	PassportGuard<PassportWaitableLock> guard(mLock);
	return mMaxObjects;
}

/**
* Sets the max objects in the pool. Note because some objects
* may be checked out this may not take effect immediately
* @param  maxObjects  the maximum objects in the pool.
*         Negative is assumed to unlimited number of objects
*         If maxObjects is less then minObjects then the maximum
*         number of objects will be equal to minObjects
*/
template <class PoolT, class ObjectConstructor >
void PassportObjectPool<PoolT, ObjectConstructor>::setMaxObjects(int value)
{
	PassportGuard<PassportWaitableLock> guard(mLock);
	if ((value >= 0) && (value < mMinObjects))
		mMaxObjects = mMinObjects;
	else
		mMaxObjects = value;
	
	shrinkPoolToMaximum();
}

/**
* Gets the maximum no activity time for the pool. Negtive
* means there is no maximum.
*/
template <class PoolT, class ObjectConstructor >
int PassportObjectPool<PoolT, ObjectConstructor>::getMaxSecondsInActive()
{
	PassportGuard<PassportWaitableLock> guard(mLock);
	return mMaxSecondsInActive;
}

/**
* Sets the maximum no activity time for the pool.
* @param  maxSecondsInActive  the maximum number of seconds that
*         an object that is not checked out is kept around.
*         Negative value assumes that objects once created will
*         never be released. (note: the number of objects will
*         never fall below minObjects even if they are not being used)
*/
template <class PoolT, class ObjectConstructor >
void PassportObjectPool<PoolT, ObjectConstructor>::setMaxSecondsInActive(int value)
{
	PassportGuard<PassportWaitableLock> guard(mLock);
	mMaxSecondsInActive = value;
}

/**
*  The object number of objects this pool is managing
*/
template <class PoolT, class ObjectConstructor >
int PassportObjectPool<PoolT, ObjectConstructor>::totalObjects()
{
	PassportGuard<PassportWaitableLock> guard(mLock);
	return mAllObjects.size();
}

/**
* The total number of objects available to be checked 
* out
*/
template <class PoolT, class ObjectConstructor >
int PassportObjectPool<PoolT, ObjectConstructor>::availableObjects()
{
	PassportGuard<PassportWaitableLock> guard(mLock);
	return mPooledObjects.size();
}

/**
* checks the object out of the pool
*/
template <class PoolT, class ObjectConstructor >
PoolT* PassportObjectPool<PoolT, ObjectConstructor>::checkout()
{
	PassportGuard<PassportWaitableLock> guard(mLock);
	if ((availableObjects() == 0) && 
		(roomToGrow()))
		growPool();
	
	while (availableObjects() == 0)
	{
		mLock.wait();
	}
	
	return getObjectFromTop();
}

/**
* checks the object back into the pool. The 
* object must be one that was retrieved using
* checkout.and has not yet been checked in.
* returns throws an assert if the object in being returned
* was not generated by the pool or if the object
* has already been checked in. 
*/
template <class PoolT, class ObjectConstructor >
void PassportObjectPool<PoolT, ObjectConstructor>::checkin(PoolT* object)
{
	PassportGuard<PassportWaitableLock> guard(mLock);
	// ------------------------
	// return the object
	returnObjectToTop(object);
	
	// ------------------------------------
	// we have to do this becauase the max
	// pool size could have changed.
	shrinkPoolToMaximum();
	
	// ----------------------
	// remove all old objects
	removeInActiveObjects();
	
	// ----------------------
	// notify anyone that is
	// waiting that an object
	// has been returned.
	mLock.notify();
}

/**
* This functions call the modify
* functions on the modifier for
* every function in the pool.
* NOTE: that the objects in the pool
* are responsible for locking themselves
* because this method could get call while
* another thread is using a checked out 
* pooled object.
*/
/*template <class PoolT, class ObjectConstructor >
void PassportObjectPool<PoolT, ObjectConstructor>::modifyPooledObjects(PassportModifier<PoolT>& modifier)
{
PassportGuard<PassportWaitableLock> guard(mLock);
for (int i = 0 ; i < totalObjects() ; i++ )
{
modifier.modify(mAllObjects[i]);
}
}
*/

/*
* NOTE: all objects better be returned before this is called
*/
template <class PoolT, class ObjectConstructor >
PassportObjectPool<PoolT, ObjectConstructor>::~PassportObjectPool()
{
	//PassportAssert(totalObjects() == availableObjects());
	while (totalObjects() != 0)
	{
		removeOldestObject();
	}
	if (mOwnObjectConstructor)
		delete &mObjectConstructor;
}

template <class PoolT, class ObjectConstructor >
bool PassportObjectPool<PoolT, ObjectConstructor>::roomToGrow()
{
	PassportGuard<PassportWaitableLock> guard(mLock);
	return ((getMaxObjects() < 0) ||
		(getMaxObjects() > totalObjects()));
}

template <class PoolT, class ObjectConstructor >
PoolT* PassportObjectPool<PoolT, ObjectConstructor>::getObjectFromTop()
{
	PassportGuard<PassportWaitableLock> guard(mLock);
	
	// ---------------------------
	// remove it internal list
	mInActiveTimes.pop_back();
	
	// -------------------------
	// get the top object
	PoolT* obj = mPooledObjects.back();
	mPooledObjects.pop_back();
	return obj;
}

template <class PoolT, class ObjectConstructor >
bool PassportObjectPool<PoolT, ObjectConstructor>::contains(const std::list<PoolT*>& vec, PoolT* obj)
{
	return (std::find(vec.begin(),vec.end(), obj) != vec.end());
}

template <class PoolT, class ObjectConstructor >
bool PassportObjectPool<PoolT, ObjectConstructor>::contains(const std::deque<PoolT*>& vec, PoolT* obj)
{
	return (std::find(vec.begin(),vec.end(), obj) != vec.end());
}

template <class PoolT, class ObjectConstructor >
void PassportObjectPool<PoolT, ObjectConstructor>::returnObjectToTop(PoolT* obj)
{
	PassportGuard<PassportWaitableLock> guard(mLock);
	
	// ----------------------------
	// check if this object was 
	// generated by the pool.
	//PassportAssert(contains(mAllObjects, obj));
	
	// --------------------------------
	// check if this object has already
	// been returned.
	//PassportAssert(!contains(mPooledObjects,obj));
	
	// -----------------------------
	// add it to pooled objects list
	mPooledObjects.push_back(obj);
	
	// ----------------------
	// set the inactive time
	mInActiveTimes.push_back(PassportSystem::currentTimeInMillis());
	
}

template <class PoolT, class ObjectConstructor >
void PassportObjectPool<PoolT, ObjectConstructor>::growPoolToMinimum()
{
	PassportGuard<PassportWaitableLock> guard(mLock);
	
	// --------------------
	// grow the pool until
	// it is big enough
	while (totalObjects() < getMinObjects())
		growPool();
}

template <class PoolT, class ObjectConstructor >
void PassportObjectPool<PoolT, ObjectConstructor>::growPool()
{
	PassportGuard<PassportWaitableLock> guard(mLock);
	
	/* fix
	if (smDebug)
		cout << "Growing Pool to " << (totalObjects()+1) << " objects" << endl; 
	*/
	// ---------------------------
	// construct a new object
	PoolT* obj = mObjectConstructor.newObject();
	
	// -------------------------------
	// add it to the vector of objects
	mPooledObjects.push_back(obj);
	
	// ---------------------------------------
	// add a field to store the objects
	// last use time
	mInActiveTimes.push_back(PassportSystem::currentTimeInMillis());
	
	// ---------------------------
	// add the object to the list
	// of all objects.
	mAllObjects.push_back(obj);
}

template <class PoolT, class ObjectConstructor >
void PassportObjectPool<PoolT, ObjectConstructor>::shrinkPoolToMaximum()
{
	PassportGuard<PassportWaitableLock> guard(mLock);
	
	while ((getMaxObjects() >= 0) && 
		(getMaxObjects() < totalObjects()) &&
		(availableObjects() > 0))
	{
		/* fix
		if (smDebug)
			cout << "Removing object because the maximum number of " << 
			"objects allowed has decresed" << endl;
		*/
		removeOldestObject();
	}
}

template <class PoolT, class ObjectConstructor >
void PassportObjectPool<PoolT, ObjectConstructor>::removeInActiveObjects()
{
	PassportGuard<PassportWaitableLock> guard(mLock);
	
	// ---------------------------------
	// negative maxSecondsInActive indicates
	// to never in activate objects. We also
	// only check for in active objects
	// every once in a while. finally
	// we should not remove any objects
	// if we are already at the minimum
	long now = PassportSystem::currentTimeInMillis();
	
	if ((mMaxSecondsInActive < 0) ||
		(mLastInActivityCheck + 1000*mMaxSecondsInActive/2 > now) ||
		(totalObjects() == getMinObjects()))
		return;
    
	mLastInActivityCheck = now;
	
	/* fix
	if (smDebug)
		cout << "Checking for inactive objects" << endl;
	*/

	// -------------------------------------------------------
	// since the inactive times list goes from most
	// least often used to most often used we can stop looking
	// as soon as we find an object that has not expired.
	
	
	while ((totalObjects() > getMinObjects()) &&
		(oldestObjectExpired()))
	{
		/* fix
		if (smDebug)
			cout << "Removing object because it has expired. Shrinking pool to " << 
			        totalObjects() - 1 << " objects" << endl;
					*/
		removeOldestObject();
	}
	
}

template <class PoolT, class ObjectConstructor >
bool PassportObjectPool<PoolT, ObjectConstructor>::oldestObjectExpired()
{
	PassportGuard<PassportWaitableLock> guard(mLock);
	return (mLastInActivityCheck - mInActiveTimes[0] > 1000*mMaxSecondsInActive);
}

template <class PoolT, class ObjectConstructor >
void PassportObjectPool<PoolT, ObjectConstructor>::removeOldestObject()
{
	PassportGuard<PassportWaitableLock> guard(mLock);
	
	//-----------------------------
	// get the object to be removed
	PoolT* obj = mPooledObjects.front();
	
	// --------------------------------------
	// remove it from the list of all objects
	removeElement(mAllObjects, obj);
	
	// ------------------------------------
	// remove it from the vector of objects
	mPooledObjects.pop_front();
	
	// ------------------------
	// remove the inactive time
	mInActiveTimes.pop_front();
	
	// ------------------
	// delete the object.
	delete obj;
}

template <class PoolT, class ObjectConstructor >
void PassportObjectPool<PoolT, ObjectConstructor>::removeElement(std::list<PoolT*>& vec, PoolT* obj)
{
	std::list<PoolT*>::iterator i = std::find(vec.begin(), vec.end(), obj);
	//PassportAssert(i != vec.end());
	vec.erase(i);
}

template <class PoolT, class ObjectConstructor >
bool PassportObjectPool<PoolT, ObjectConstructor>::smDebug = true;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\tools\passportlockedinteger.hpp ===
#ifndef PASSPORTLOCKEDINTERGER_HPP
#define PASSPORTLOCKEDINTERGER_HPP

#include <windows.h>
#include <winbase.h>

// a thread safe integer class..
class PassportLockedInteger
{
public:
    PassportLockedInteger(LONG l = 0)
    {
        m_Long = l;
    }

    // returns the new value of the integer.
    LONG operator++()
    {
        return InterlockedIncrement(&m_Long);
    }

    // returns the new value of the integer.
    LONG operator--()
    {
        return InterlockedDecrement(&m_Long);
    }

    // returns the new value of the integer.
    LONG operator+=(LONG value)
    {
        return InterlockedExchangeAdd( &m_Long , value ) + value;
    }

    // returns the new value of the integer.
    LONG operator-=(LONG value)
    {
        return InterlockedExchangeAdd( &m_Long , -value ) - value;
    }

    // returns the current value of the integer.
    LONG value()
    {
        return m_Long;
    }
private:
    LONG m_Long;
};


// smart wrapper class for PassportLockedInteger
class CPassportLockedIntegerWrapper
{
public:
    // Constructor automatically does increment
    CPassportLockedIntegerWrapper(PassportLockedInteger *pLock)
    {
        m_pLock = pLock;
        if (m_pLock)
        {
            m_Value = ++(*m_pLock);
        }
        else
        {
            m_Value = 0;
        }
    }

    // Destructor automatically decrements
    ~CPassportLockedIntegerWrapper()
    {
        if (m_pLock)
        {
            --(*m_pLock);
        }
    }
    // returns the current value of the integer.
    LONG value()
    {
        return m_Value;
    }

private:
    PassportLockedInteger *m_pLock;
    LONG m_Value;       
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\tools\passportstats.hpp ===
#ifndef PASSPORTSTATS_HPP
#define PASSPORTSTATS_HPP

#include "PassportLock.hpp"
#include "PassportGuard.hpp"

template <class dataType, class averType>
class PassportStats
{
public:

	PassportStats()
		:m_Points(0),
		 m_Sum(0)
	{
		//empty
	}

	// adds a sample point and returns the running
	// average
	averType addSample(dataType value)
	{
		PassportGuard < PassportLock > guard(m_Lock);
		m_Points++;
		m_Sum += value;
		return ((averType)m_Sum)/((averType)m_Points);
	}

private:
	PassportLock m_Lock;
	DWORD m_Points;
	dataType m_Sum;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\tools\passportobjectpool.hpp ===
#ifndef PASSPORTOBJECTPOOL_HPP
#define PASSPORTOBJECTPOOL_HPP

/**
* A class representing a pool of objects. Objects
* can be checked out and returned to the
* the pool. If there are no objects available
* when a client tries to check one out. The client
* will block until one is returned. The pool can 
* be configured to always
* have a minimum number of objects, to have
* a maximum number of objects, and to remove objects
* that have been inactive. Client are required
* to supply an Object Constructot that is used by the 
* pool to construct new objects on demand. Client
* can also modify all the existing objects in the
* pool be supplying a Modifier object.
*
* @author Jesse Hull
*/
#include <list>
#include <deque>

#include "PassportDefaultConstructor.hpp"
#include "PassportWaitableLock.hpp"

template<class PoolT, class ObjectConstructor = PassportDefaultConstructor<PoolT> >
class PassportObjectPool
{
public:
	static int smDefaultMinObjects;
	static int smDefaultMaxObjects; 
	static long smDefaultMaxSecondsInActive; 
	
	/**
	* Constructor 
	* 
	* @param  minObjects the minimum number of objects in the pool. 
	*         Negative is assumed to be zero
	* @param  maxObjects  the maximum objects in the pool.
	*         Negative is assumed to unlimited number of objects
	*         If maxObjects is less then minObjects then the maximum
	*         number of objects will be equal to minObjects
	* @param  maxSecondsInActive  the maximum number of seconds that
	*         an object that is not checked out is kept around.
	*         Negative value assumes that objects once created will
	*         never be released. (note: the number of objects will
	*         never fall below minObjects even if they are not being used)
	*/
    PassportObjectPool(int minObjects = smDefaultMinObjects,
		int maxObjects = smDefaultMaxObjects,
		int maxSecondsInActive = smDefaultMaxSecondsInActive);
	
		/**
		* Constructor with object constructor
		* 
		* @param  objectConstructor is an instance of a class that has
		*         a newObject object member function that returns a pointer to
		*         an object of type PoolT
		* @param  minObjects the minimum number of objects in the pool. 
		*         Negative is assumed to be zero
		* @param  maxObjects  the maximum objects in the pool.
		*         Negative is assumed to unlimited number of objects
		*         If maxObjects is less then minObjects then the maximum
		*         number of objects will be equal to minObjects
		* @param  maxSecondsInActive  the maximum number of seconds that
		*         an object that is not checked out is kept around.
		*         Negative value assumes that objects once created will
		*         never be released. (note: the number of objects will
		*         never fall below minObjects even if they are not being used)
	*/
    PassportObjectPool(ObjectConstructor& objectConstructor,
		int minObjects = smDefaultMinObjects,
		int maxObjects = smDefaultMaxObjects,
		int maxSecondsInActive = smDefaultMaxSecondsInActive);
	
		/**
		* Gets the min objects in the pool
	*/
	int getMinObjects();
	
	/**
	* Sets the min objects in the pool
	* @param  minObjects the minimum number of objects in the pool. 
	*         Negative is assumed to be zero. The minimum is greater
	*         then the current maximum then the current maximum is 
	*         increased.
	*/
	void setMinObjects(int value);
	
	/**
	* Gets the max objects in the pool. Negative means
	* there is no maximum.
	*/
	int getMaxObjects();
	
	
	/**
	* Sets the max objects in the pool. Note because some objects
	* may be checked out this may not take effect immediately
	* @param  maxObjects  the maximum objects in the pool.
	*         Negative is assumed to unlimited number of objects
	*         If maxObjects is less then minObjects then the maximum
	*         number of objects will be equal to minObjects
	*/
	void setMaxObjects(int value);
	
	/**
	* Gets the maximum no activity time for the pool. Negtive
	* means there is no maximum.
	*/
	int getMaxSecondsInActive();
	
	/**
	* Sets the maximum no activity time for the pool.
	* @param  maxSecondsInActive  the maximum number of seconds that
	*         an object that is not checked out is kept around.
	*         Negative value assumes that objects once created will
	*         never be released. (note: the number of objects will
	*         never fall below minObjects even if they are not being used)
	*/
	void setMaxSecondsInActive(int value);
	
	/**
	*  The object number of objects this pool is managing
	*/
	int totalObjects();
	
	/**
	* The total number of objects available to be checked 
	* out
	*/
	int availableObjects();
	
	/**
	* checks the object out of the pool
	*/
	PoolT* checkout();
	
	/**
	* checks the object back into the pool. The 
	* object must be one that was retrieved using
	* checkout.and has not yet been checked in.
	* returns throws an assert if the object in being returned
	* was not generated by the pool or if the object
	* has already been checked in. 
	*/
	void checkin(PoolT* object);
	
	/**
	* This functions calls the modify
	* functions on the modifier for
	* every function in the pool.
	* NOTE: that the objects in the pool
	* are responsible for locking themselves
	* because this method could get call while
	* another thread is using a checked out 
	* pooled object.
	*/
	//template <class modifier>
	//void modifyPooledObjects()
	
	/*
	* NOTE: all objects better be returned before this is called
	*/
	~PassportObjectPool();
	
private:
	
	bool roomToGrow();
	PoolT* getObjectFromTop();
	
	bool contains(const std::list< PoolT* > & vec, PoolT* obj);
	bool contains(const std::deque<PoolT*>& vec, PoolT* obj);
	
	void returnObjectToTop(PoolT* obj);
	void growPoolToMinimum();
	void growPool();
	void shrinkPoolToMaximum();
	void removeInActiveObjects();
	bool oldestObjectExpired();
	virtual void removeOldestObject();
	
	void removeElement(std::list<PoolT*>& vec, PoolT* obj);
	
private:
    // --------------------
    // whether to print
    // debugging stuff to stdout
    static bool smDebug;
	
    // -------------------------
    // min number of objects to
    // have at all times
    int mMinObjects;
	
    // ---------------------------
    // maximum number of objects
    // negative indicates no max
    int mMaxObjects; // no maximum
	
    // --------------------------------------------
    // time to keep in active objects around before
    // removing them
    int mMaxSecondsInActive; // 5 minutes
	
    // ----------------------------------
    // the last time we checked for
    // in active objects
    long mLastInActivityCheck;
	
    // ---------------------------------------
    // the vector of all objects being managed
    // by the pool.
	std::list<PoolT*> mAllObjects;
	
    // --------------------------------------
    // the vector of pooled objects currently
    // not out
	std::deque<PoolT*> mPooledObjects;
	
    // ------------------------------------
    // a vector of the last time each object 
    // was used.
	std::deque<long> mInActiveTimes;
	
	// -----------------------------------
	// the object constructor for the pool
	ObjectConstructor& mObjectConstructor;
	
	// -------------------------------------
	// whether we own the object constructor
	bool mOwnObjectConstructor;
	
	// -------------------
	// lock to guard data
	PassportWaitableLock mLock;
};

#include "PassportObjectPool.cpp"

#endif // !PASSPORTOBJECTPOOL_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\tools\passportsystem.hpp ===
#ifndef PASSPORTSYSTEM_HPP
#define PASSPORTSYSTEM_HPP

#include <windows.h>

class PassportSystem
{
public:
	static long currentTimeInMillis()
	{
		return GetTickCount(); // BUG!! WILL OVERFLOW IN ~50 days
	}
};

#endif // !PASSPORTSYSTEM_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\tools\passportsemaphore.hpp ===
#ifndef PASSPORTSEMAPHORE_HPP
#define PASSPORTSEMAPHORE_HPP

#include <windows.h>
#include <winbase.h>

class PassportSemaphore
{
public:
	// ---------------------
	// creates a semaphore 
	// with a maximum value
	// of max and initializes
	// the count to count.
	PassportSemaphore(long max, long count);

	// --------------------------------------
	// decrements the count of the semaphore
	// or blocks if the count is zero.
	void acquire();

	// -------------------------
	// increments the count of
	// the semaphore.
	void release();

	~PassportSemaphore();
private:
	HANDLE mSemaphore;
};

#endif // !PASSPORTSEMAPHORE_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\tools\passportthread.cpp ===
#include <process.h>

#include "PassportThread.hpp"
#include "PassportAssert.hpp"


static DWORD WINAPI threadRunner(void* lpvThreadParam)
{
    ((PassportThread*) lpvThreadParam)->run();
    return 0; // is this right/okay??
}


bool PassportThread::start()
{
//  mHandle = (HANDLE) _beginthreadex(NULL, 0, &threadRunner, (void*) this,
//                               0, &mThreadID);
    mHandle = CreateThread(NULL,
                           0,
                           threadRunner,
                           (void*)this,
                           0,
                           &mThreadID);
    if (mHandle == NULL)
        return false;
    else
        return true;
}


PassportThread::PassportThread()
:mThreadID(0), mHandle(NULL)
{
    //empty
}


DWORD PassportThread::threadID()
{
    return mThreadID;
}


PassportThread::~PassportThread()
{
    if (mHandle)
        CloseHandle(mHandle);
}

bool PassportThread::join(PassportThread* threads[], int size)
{
    HANDLE* handles = new HANDLE[size];

    for (int i = 0 ; i < size ; i++)
    {
        PassportAssert(threads[i] != NULL);
        handles[i] = threads[i]->mHandle;
    }

    bool success = (WaitForMultipleObjects(size, handles, TRUE, INFINITE) != WAIT_FAILED);
    delete[] handles;
    return success;
}


void PassportThread::sleep(long milliseconds)
{
    Sleep(milliseconds);
}


DWORD PassportThread::currentThreadID()
{
    return GetCurrentThreadId();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\tools\passportwaitablelock.cpp ===
#include "PassportWaitableLock.hpp"

PassportWaitableLock::PassportWaitableLock()
:mSemaphore(1, 0)
{
	//empty
}

void PassportWaitableLock::acquire()
{
	mLock.acquire();
}

void PassportWaitableLock::release()
{
	mLock.release();
}

void PassportWaitableLock::wait()
{
	mLock.release();
	mSemaphore.acquire();
	mLock.acquire();
}

void PassportWaitableLock::notify()
{
	mSemaphore.release();
}

PassportWaitableLock::~PassportWaitableLock()
{
	//empty
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\tools\passportwaitablelock.hpp ===
#ifndef PASSPORTWAITABLELOCK_HPP
#define PASSPORTWAITABLELOCK_HPP

#include "PassportLock.hpp"
#include "PassportSemaphore.hpp"

class PassportWaitableLock
{
public:
	PassportWaitableLock();

	void acquire();

	void release();

	// --------------------------------
	// acquire must be called
	// before calling this function
	// It will then release the lock
	// and wait for notify to be called
	void wait();

	// ----------------------------
	// acquire must be called
	// before calling this function
	// it will cause at most one
	// waiting thread to wake up.
	void notify();

	~PassportWaitableLock();
private:
	PassportLock mLock;
	PassportSemaphore mSemaphore;
};

#endif // !PASSPORTWAITABLELOCK_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\tools\passporttimer.cpp ===
#include "PassportAssert.hpp"
#include "PassportTimer.hpp"

void PassportTimer::setToNow(PassportTime& t)
{
#ifdef SOLARIS
  gettimeofday(&t, NULL);
#elif defined(WIN32)
  bool worked = (QueryPerformanceCounter(&t) != 0);
  PassportAssert(worked);
#else
  gettimeofday(&t);
#endif
}

double PassportTimer::difference(PassportTime& t1, 
   			      PassportTime& t2)
{
#ifndef WIN32
  double sec = double(t1.tv_sec - t2.tv_sec);
  double usec = double(t1.tv_usec - t2.tv_usec);

  usec /= double(1000000.0);

  return sec + usec;
#else

  // ------------------------
  // calculate the difference
  LONGLONG diff = t1.QuadPart - t2.QuadPart;

  // -----------------------
  // get the number of ticks
  // per second.
  PassportTime freq;
  bool worked = (QueryPerformanceFrequency(&freq) != 0);
  PassportAssert(worked);

  // -----------------------
  // return the difference
  // in seconds
  return (double(diff) / double(freq.QuadPart));
#endif
}
  
PassportTimer::PassportTimer ( ) 
  :mRunning(false), mCumulativeTime(double(0.0))
{
  //empty
}

void PassportTimer::start ( )
{
  if (mRunning)
    return;
  
  mRunning = true;
  setToNow(mStartTime);
};

double PassportTimer::elapsedTime()
{
  if (mRunning)
    {
      PassportTime now;
      setToNow(now);
      return difference(now, mStartTime) + 
	mCumulativeTime;
    }
  else
    return mCumulativeTime;
}

void PassportTimer::stop ( )
{
  if (!mRunning)
    return;

  mRunning = false;
  PassportTime now;
  setToNow(now);
  mCumulativeTime += difference(now, mStartTime);
};

void PassportTimer::reset ( )
{
  stop();
  mCumulativeTime = double(0.0);
};

void PassportTimer_deletor(void *obj)
{ delete (PassportTimer *) obj;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\tools\passporttostring.hpp ===
#ifndef PASSPORTTOSTRING_HPP
#define PASSPORTTOSTRING_HPP

#include <strstrea.h>

template <class T>
std::string PassportToString(const T & t)
{
		strstream out; 
		out << t << ends;
		std::string retValue = out.str(); 
		out.rdbuf()->freeze(0); 
		return retValue;
}

#endif // !PASSPORTTOSTRING_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\tools\passporttimer.hpp ===
//==================================================================
//Class: PassportTimer
//
// Author:              Jesse Hull
//
// Description:		
//         a class timer class with the same interface 
// as the roguewave timer(RWTimer) except that it measures 
// wall time where the RW timer measures CPU time
//
// Usage:		like a stop watch
//-------------------------------------------------------------------

#ifndef PASSPORTTIMER_HPP
#define PASSPORTTIMER_HPP

#ifdef WIN32
#include <windows.h>
#include <WINBASE.H>
#else
#include <sys/time.h>
#include <unistd.h>
#endif

#ifndef WIN32
typedef struct timeval PassportTime;
#else
typedef LARGE_INTEGER PassportTime;
#endif

class PassportTimer
{
public:
  
  // creates a stop watch (does not start it)
  PassportTimer ( );

  // starts the stop watch
  void start();

  // stops the stop watch
  void stop ();

  // stops and resets the stop watch
  void reset();

  // returns the total time the stop
  // watch has been running in seconds
  double elapsedTime();  

protected:

  void setToNow(PassportTime& t);
  double difference(PassportTime& t1, 
		   PassportTime& t2);

  bool mRunning;
  double mCumulativeTime;
  PassportTime mStartTime;
};

#endif //!PassportTimer
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\tools\passportthread.hpp ===
#ifndef PASSPORTTHREAD_HPP
#define PASSPORTTHREAD_HPP

#include <windows.h>
#include <winbase.h>

class PassportThread
{
public:
    PassportThread();

    // --------------------
    // the new thread will
    // execute this function
    virtual void run() = 0;

    // ---------------------
    // start a new thread and
    // that thread calls run
    bool start();

    virtual DWORD threadID();

    virtual ~PassportThread();

    // ---------------------------------------
    // waits for all the given threads to stop.
    // NOTE: the current maximum number of
    // threads that can be joined is 64.
    static bool join(PassportThread* threads[], int size);

    // ---------------------------
    // cause the current thread
    // to sleep for the specified
    // number of milliseconds
    static void sleep(long milliseconds);

    // --------------------------------
    // returns the id of the current
    // thread
    static DWORD currentThreadID();

private:
    DWORD mThreadID;
    HANDLE mHandle;
};

#endif // !PASSPORTTHREAD_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\tools\pooltest.cpp ===
#include <iostream>
using namespace std;

#include "PassportObjectPool.hpp"
#include "PassportThread.hpp"

class SampleConstructor
{
public:
    
	static int count;
	
    int* newObject()
    {
        return new int(count++);
    }
};

int SampleConstructor::count = 0;

class tester : public PassportThread
{
private:
    int mSleepTime;
    PassportObjectPool<int, SampleConstructor>& mPool;
	
public:
    tester(int sleepTime, PassportObjectPool<int, SampleConstructor>& pool)
		:mSleepTime(sleepTime), mPool(pool)
    {
		//empty
    }
	
	void run()
    {
		if (mSleepTime >= 0)
		{
			while (true)
			{
				cout << "Sleeper getting from pool in " << threadID() << endl;
				int* I = mPool.checkout();
				cout << "Got " << *I << " from pool. Sleeping in " << threadID() << endl;
				PassportThread::sleep(mSleepTime*1000);
				cout << "returning " << *I << " to pool in " << threadID() << endl;
				mPool.checkin(I);
				cout << "returned. Going to sleep in " << threadID() << endl;
				PassportThread::sleep(mSleepTime*1000);
			}
		}
		else
		{
			while (true)
			{
				cout << "waiter getting from pool in " << threadID() << endl;
				int* I = mPool.checkout();
				cout << "Got " << *I << " from pool. waiting in " << threadID() << endl;
				char c;
				cin >> c;
				cout << "returning " << *I << " to pool. in " << threadID() << endl;
				mPool.checkin(I);
				cout << "returned. Going to wait in " << threadID() << endl;
				cin >> c;
			}
		}
        
    }                
};


int main(int argc, char* argv[])
{
	int sleepers = 5;
	int sleepTime = 10; // secs

	PassportObjectPool<int, SampleConstructor> pool(1, 6, 30);

	for (int i = 0; i < sleepers ; i++)
	{
		tester* t = new tester(sleepTime, pool);
		t->start();
	}
	
	tester test2(-1, pool);

	test2.run();

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\tools\mttest\passportmttester.cpp ===
#include "PassportMTTester.hpp"
#include "PassportTimer.hpp"
#include "PassportThread.hpp"
#include "PassportAssert.hpp"

class TestThread : public PassportThread
{
public:
	TestThread(PassportTestable& testable, int iterations)
		:mTestable(testable), mIterations(iterations), mSuccess(true)
	{
		// empty
	}
	
	virtual void run()
	{
		for( int i = 0; i < mIterations ; i++ )
		{
			mTimer.start();
			bool success = mTestable.runTest();
			mTimer.stop();
			if (!success)
			{
				mSuccess = false;
				break;
			}
		}
	}

	double totalTime()
	{
		return mTimer.elapsedTime();
	}

	bool success()
	{
		return mSuccess;
	}

private:
	PassportTestable& mTestable;
	int mIterations;
	bool mSuccess;
	PassportTimer mTimer;
};

// --------------------------------------------------------------------
// creates given number of threads and calls the runTest method on
// testable object iterations number of time in each thread. 
// Calculates throughput and latency
PassportMTTester::PassportMTTester(PassportTestable& testable, int threads, int iterations)
:mDoingCopy(false), mTestable(testable), mThreads(threads), mIterations(iterations),
	mLatency(0), mThroughput(0), mRan(false), mSuccess(true)
{
	//empty
}

// --------------------------------------------------------------------
// creates given number of threads and calls the runTest method on
// testable object iterations number of times. Calculates throughput and 
// latency. Difference is each thread uses a copy of the testable
// object.
PassportMTTester::PassportMTTester(PassportTestableCopy& testable, int threads, int iterations)
:mDoingCopy(true), mTestable(testable), mThreads(threads), mIterations(iterations),
	mLatency(0), mThroughput(0), mRan(false), mSuccess(true)
{
	//empty
}

bool PassportMTTester::runMTTest()
{

	mRan = true;
	PassportThread** threads = new PassportThread*[mThreads];
	PassportTestableCopy** testers = new PassportTestableCopy*[mThreads];

	for (int i = 0 ; i < mThreads ; i++ )
	{
		if (!mDoingCopy)
		{
			threads[i] = new TestThread(mTestable, mIterations);
			testers[i] = NULL;
		}
		else
		{
			testers[i] = ((PassportTestableCopy&) mTestable).copy();
			PassportAssert(testers[i] != NULL);
			threads[i] = new TestThread(*(testers[i]), mIterations);
		}
	}

	PassportTimer timer;
	timer.start();
	for (i = 0; i < mThreads ; i++)
		threads[i]->start();

	if (!PassportThread::join(threads, mThreads))
	{
		mSuccess = false;
	}
	timer.stop();

	if (mSuccess)
	{
		mThroughput = ((double) (mIterations*mThreads)) / timer.elapsedTime();

		double time = 0.0;
		for ( i = 0 ; i <mThreads ; i++ )
		{
			TestThread& thread = *((TestThread*) threads[i]);
			if (thread.success())
				time += thread.totalTime();
			else
			{
				mSuccess = false;
			}
		}
	
		if (mSuccess)
			mLatency = time / ((double) mIterations*mThreads);
	}

	for ( i =  0 ; i <mThreads ; i++ )
	{
		delete testers[i];
		delete threads[i];
	}
	delete[] testers;
	delete[] threads;

	return mSuccess;
}
	
	
void PassportMTTester::dumpResults(ostream& out)
{
	if (!mRan)
	{
		cout << "Test not run yet" << endl;
		return;
	}

	if (!mSuccess)
	{
		cout << "TEST FAILED" << endl;
		return;
	}

	out << "Threads    = " << mThreads << endl;
	out << "Iterations = " << mIterations << endl;
	out << "Latency    = " << mLatency << endl;
	out << "Throughput = " << mThroughput << endl;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\tools\mttest\passporttestablecopy.hpp ===
#ifndef PASSPORTTESTABLECOPY_HPP
#define PASSPORTTESTABLECOPY_HPP

class PassportTestableCopy : public PassportTestable
{ 
public:
	virtual PassportTestableCopy* copy() = 0;
};

#endif // !PASSPORTTESTABLECOPY_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\tools\mttest\test.cpp ===
#include <iostream>
using namespace std;

#include <windows.h>

#include "PassportMTTester.hpp"
#include "PassportThread.hpp"

class Testable : public PassportTestable
{
public:
	Testable(int sleepTime)
		:mSleepTime(sleepTime)
	{
		//empty
	}

	virtual bool runTest()
	{
		//cout << "thread " << PassportThread::currentThreadID() << " sleeping" << endl;
		Sleep(1000*mSleepTime);
		//cout << "thread " << PassportThread::currentThreadID() << " done sleeping" << endl;
		return true;
	}

private:
	int mSleepTime;
};

int main(int argc, char** argv)
{
	int threads = 10;
	int sleepTime = 10;
	int iterations = 10;

	Testable test(sleepTime);
	PassportMTTester tester(test, threads, iterations);
	tester.runMTTest();
	tester.dumpResults(cout);

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\tools\mttest\passportmttester.hpp ===
#ifndef PASSPORTMTTESTER_HPP
#define PASSPORTMTTESTER_HPP

#include <iostream>
using namespace std;

#include "PassportTestable.hpp"
#include "PassportTestableCopy.hpp"

class PassportMTTester
{
public:

	// --------------------------------------------------------------------
	// creates given number of threads and calls the runTest method on
	// testable object iterations number of time in each thread. 
	// Calculates throughput and latency
	PassportMTTester(PassportTestable& testable, int threads, int iterations);

	// --------------------------------------------------------------------
	// creates given number of threads and calls the runTest method on
	// testable object iterations number of times. Calculates throughput and 
	// latency. Difference is each thread uses a copy of the testable
	// object.
	PassportMTTester(PassportTestableCopy& testable, int threads, int iterations);

	virtual bool runMTTest();

	virtual void dumpResults(ostream& out);

private:

	const bool mDoingCopy;
	PassportTestable& mTestable;
	int mThreads;
	int mIterations;
	double mThroughput;
	double mLatency;
	bool mRan;
	bool mSuccess;
};

#endif // !PASSPORTMTTESTER_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\tools\mttest\passporttestable.hpp ===
#ifndef PASSPORTTESTABLE_HPP
#define PASSPORTTESTABLE_HPP

class PassportTestable
{
public:
	virtual bool runTest() = 0;
	
	virtual ~PassportTestable()
	{
		//empty
	}
};

#endif // !PASSPORTTESTABLE_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\utilities\birthdatefunctions.cpp ===
//-----------------------------------------------------------------------------
//
//  @doc
//
//  @module BirthdateFunctions.cpp | Implementation of birthdate functions.
//
//  Author: Darren Anderson
//
//  Date:   5/10/00
//
//-----------------------------------------------------------------------------

#include "stdafx.h"
#include "BirthdateFunctions.h"

//-----------------------------------------------------------------------------
//
//  @func  Determine if the given birthdate represents an under 13 age
//         relative to the current date/time on the machine.
//
//-----------------------------------------------------------------------------
bool
IsUnder13(
    DATE dtBirthdate  // @parm  The birthdate to check.
    )
{
    return IsUnder(dtBirthdate, 13);
}


//-----------------------------------------------------------------------------
//
//  @func  Determine if the given birthdate represents an under 18 age
//         relative to the current date/time on the machine.
//
//-----------------------------------------------------------------------------
bool 
IsUnder18(
    DATE dtBirthdate  // @parm  The birthdate to check.
    )
{
    return IsUnder(dtBirthdate, 18);
}


//-----------------------------------------------------------------------------
//
//  @func  Determine if the given birthdate represents an under 13 age
//         relative to the current date/time on the machine.
//
//-----------------------------------------------------------------------------
bool IsUnder(
    DATE    dtBirthdate, // @parm  The birthdate to check.
    USHORT  ulAge // @parm  Age in years to check for.
    )
{
    bool        bIsUnder = false;
    SYSTEMTIME  stBirthdate;
    SYSTEMTIME  stNow;

    // Convert birthdate to system time.
    if(!VariantTimeToSystemTime(dtBirthdate, &stBirthdate))
    {
        goto Cleanup;
    }

    // Get current time.
    GetSystemTime(&stNow);

    // Compare years.
    if(stNow.wYear - stBirthdate.wYear > ulAge)
        goto Cleanup;
    if(stNow.wYear - stBirthdate.wYear < ulAge)
    {
        bIsUnder = true;
        goto Cleanup;
    }

    // Years are equal, compare months.
    if(stNow.wMonth > stBirthdate.wMonth)
        goto Cleanup;
    if(stNow.wMonth < stBirthdate.wMonth)
    {
        bIsUnder = true;
        goto Cleanup;
    }

    // Months are equal, compare days.
    bIsUnder = (stNow.wDay < stBirthdate.wDay);

Cleanup:

    return bIsUnder;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\utilities\brwsrinfo.cpp ===
//-----------------------------------------------------------------------------
//
//  @doc
//
//  @module brwsrinfo.cpp | implementation of browser info specific to
//                          Passport network
//
//  Author: stevefu, mostly copied from Darren's code
//
//  Date:   05/05/2000
//
//  Copyright <cp> 1999-2000 Microsoft Corporation.  All Rights Reserved.
//
//-----------------------------------------------------------------------------

#include "stdafx.h"
#include <pputils.h>

CBrowserInfo::CBrowserInfo(LPCSTR szUserAgent) 
: m_nBrowserIndex(BROWSER_UNKNOWN), 
  m_nBrowserMajorVersion(0),
  m_nBrowserMinorVersion(0),
  m_bIsBrowserHigh(FALSE),
  m_bIsWebTVBased(FALSE)
{
    if(szUserAgent != NULL)
        Initialize(szUserAgent);
}

CBrowserInfo::~CBrowserInfo()
{
}

BOOL CBrowserInfo::IfUserAgentHasStr(LPCSTR str)
{
   _ASSERT(str && str[0]);

   if(!str || str[0] == 0) 
      return FALSE;
   else
      return (m_strUserAgent.Find(str) != -1);
}


BOOL CBrowserInfo::Initialize(LPCSTR szUserAgent)
{
    LPSTR szStart;
    LPSTR szFinish = NULL;

    // keep it for later use
    m_strUserAgent = szUserAgent;

    if((szStart = strstr(szUserAgent, "AvantGo")) != NULL)
    {
        m_nBrowserIndex = BROWSER_AVANTGO;
        // FUTURE: this is to try out the AvantGo browser, version details can be found out later
        return TRUE;
    }
    else if((szStart = strstr(szUserAgent, "MSIE ")) != NULL)
    {
        LPSTR szNewStart;
        if((szNewStart = strstr(szUserAgent, "WebTV/")) != NULL) 
        {
            m_bIsWebTVBased = true;

            if((szStart = strstr(szUserAgent, "Rogers/")) != NULL)
            {
                // Mozilla/3.0 Rogers/1.0 WebTV/1.4 (Compatible; MSIE 2.0)
                m_nBrowserIndex = BROWSER_ROGERS;
                szStart += 7;
            }
            else if((szStart = strstr(szUserAgent, "MSTV/")) != NULL)
            {
                // Mozilla/4.0 MSTV/1.1 WebTV/2.5 (Compatible; MSIE 4.0)
                m_nBrowserIndex = BROWSER_MSTV;
                szStart += 5;
            }
            else
            {
                m_nBrowserIndex = BROWSER_WEBTV;
                szStart = szNewStart + 6;
            }
            szFinish = strchr(szStart, ' ');
            m_bIsBrowserHigh = FALSE;
        }
        else
        {
            if(strstr(szUserAgent, "Windows CE;") != NULL)
               m_nBrowserIndex = BROWSER_IE_WINCE;
            else               
               m_nBrowserIndex = BROWSER_IE;

            szStart += 5;
            szFinish = strchr(szStart, ';');
        }
    }
    else if((szStart = strstr(szUserAgent, "Mozilla/")) != NULL)
    {
        szStart += 8;
        szFinish = strchr(szStart, ' ');

        // mme phone
        if(strstr(szStart, "MMEF30") != NULL && strstr(szStart, "CellPhone;") != NULL)
           m_nBrowserIndex = BROWSER_MMEPHONE;
        else
           m_nBrowserIndex = BROWSER_NETSCAPE;
    }
    else if((szStart = strstr(szUserAgent, "Passport Client")) != NULL)
    {
        szStart = strchr(szStart, '(');
        szStart++;
        szFinish = strchr(szStart, ')');
        m_nBrowserIndex = BROWSER_PASSPORT_CLIENT;
        m_bIsBrowserHigh = TRUE;
    }
    else if((szStart = strstr(szUserAgent, "UP.Browser")) != NULL)   // phone.com
    {
        szStart += 11;
        m_nBrowserIndex = BROWSER_UP;
        m_bIsBrowserHigh = FALSE;
        szFinish = strchr(szStart, '-');
    }
    else if((szStart = strstr(szUserAgent, "DoCoMo")) != NULL
      #ifdef   _DEBUG
      // iMode emulator uses this ua
      || (szStart = strstr(szUserAgent, "Microsoft URL Control - ")) != NULL
      #endif
      ) // iMode phone
    {
        szStart += 7;
        m_nBrowserIndex = BROWSER_DoCoMo;
        m_bIsBrowserHigh = FALSE;
        szFinish = strchr(szStart, '/');
    }
    else
    {
        m_nBrowserIndex = 0;
    }

    // Get the version string
    if(szFinish)
    {
        int nLength = (int) (szFinish - szStart);
        CStringA strNew(szStart, nLength);
        m_strBrowserVersion = strNew;
        m_nBrowserMajorVersion = atoi(m_strBrowserVersion);
    }
    
    // Pick up minor version
    if (!m_strBrowserVersion.IsEmpty())
    {
        LPSTR szMinorVer = strchr(m_strBrowserVersion, '.');
        if (szMinorVer)
        {
            m_nBrowserMinorVersion = atoi(szMinorVer + 1);
        }
    }
    switch (m_nBrowserIndex)
    {
        case BROWSER_IE:
            if (m_nBrowserMajorVersion >= 4)
            {
                m_bIsBrowserHigh = TRUE;
            }
            break;
        case BROWSER_NETSCAPE:
            if (m_nBrowserMajorVersion >= 3)
            {
                m_bIsBrowserHigh = TRUE;
            }
            break;
    }
    return TRUE;
}

unsigned int CBrowserInfo::GetBrowserNameIndex(void)
{
    return m_nBrowserIndex;
}

unsigned int CBrowserInfo::GetBrowserMajorVersion(void)
{
    return m_nBrowserMajorVersion;
}

unsigned int CBrowserInfo::GetBrowserMinorVersion(void)
{
    return m_nBrowserMinorVersion;
}

LPCSTR CBrowserInfo::GetBrowserVersionString()
{
    return m_strBrowserVersion;
}

BOOL CBrowserInfo::IsHighBrowser(void) 
{
    return m_bIsBrowserHigh;
}

BOOL CBrowserInfo::IsWebTVBased(void) 
{
    return m_bIsWebTVBased;
}

/*
function GetNav4MinorVersionString()
{
    var userAgent = Request.ServerVariables("HTTP_USER_AGENT").Item;
    var minorVersion = "-1";
    var returnedMinorVersion = "-1";
    var versionEnd;
    var nameIndex;

    nameIndex = userAgent.indexOf("Mozilla/4.");
    if (nameIndex != -1)
    {
        var versionEnd = userAgent.indexOf(" ", nameIndex + 10);
        if( versionEnd != -1 )
        {
            minorVersion = userAgent.substring(nameIndex + 10, versionEnd);
            returnedMinorVersion = minorVersion.substr(0, 1);
        }
    }

    return (returnedMinorVersion);
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\utilities\puidutils.cpp ===
//-----------------------------------------------------------------------------
//
// PUIDUtils.cpp
//
// Functions for dealing with the PUID data type.
//
// Author: Jeff Steinbok
//
// 02/01/01       jeffstei    Initial Version
//
// Copyright <cp> 2000-2001 Microsoft Corporation.  All Rights Reserved.
//
//-----------------------------------------------------------------------------

#include "stdafx.h"
#include <windows.h>
#include "PUIDUtils.h"

//
// Converts a PUID into a string. 
//
// See PUIDUtils.h for more information.
//
HRESULT PUID2String(LARGE_INTEGER* in_pPUID, CStringW& out_cszwPUIDStr)
{
	HRESULT hr = S_OK;

	WCHAR   buf[50];

	// Copy the PUID into the new string.
	wsprintfW(buf, L"%08X%08X", in_pPUID->HighPart, in_pPUID->LowPart);

	out_cszwPUIDStr = buf;
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\utilities\errorsupport.cpp ===
// ErrorSupport.cpp: implementation of the CErrorSupport class.
#include "stdafx.h"
#include "ErrorSupport.h"



WORD IntCategoryFromMessageID(DWORD x)	{return (WORD)(((x) & 0x0000F000) >> 12);}




// ---------------------------------------------------------------------------------
//
//
// ---------------------------------------------------------------------------------
CErrorSupport::CErrorSupport(CLSID clsidMyCLSID, LPCTSTR szEventSource)

{
    TCHAR *szTmp;

    ProgIDFromCLSID(clsidMyCLSID, (unsigned short **) &szTmp);
    m_bstrErrorSource = szTmp;

    CoTaskMemFree(szTmp);

	_tcscpy(m_szEventSource, szEventSource);

}
// ---------------------------------------------------------------------------------
//
//
// ---------------------------------------------------------------------------------
CErrorSupport::CErrorSupport(LPCTSTR szErrorSource, LPCTSTR szEventSource)
{
    m_bstrErrorSource = szErrorSource;
	_tcscpy(m_szEventSource, szEventSource);
}



// ---------------------------------------------------------------------------------
//
//
// ---------------------------------------------------------------------------------
void CErrorSupport::Log(HRESULT	hr,
						  LPCTSTR	szLineNum, 
						  LPCTSTR	szMethodName, 
						  WORD		wCategory,
						  WORD		wMsgType,
						  DWORD		dwMsgID,
						  LPCTSTR	szFormat, ...)
{
	va_list vl;
	DWORD cStrings;
	LPCTSTR *prgStrings;
	CAtlArray<LPTSTR> rgStrings;
	
	va_start(vl, szFormat);

	// Build up the string list
	//
	if (szFormat != NULL)
	{
		InternalBuildStringList(hr, szLineNum, szMethodName, szFormat, &vl, &rgStrings);

		cStrings 	= rgStrings.GetCount();
		prgStrings 	= (LPCTSTR *)&rgStrings[0];
	}
	else
	{
		cStrings	= 0;
		prgStrings	= NULL;
	}


	// Call the LogEvent function
	//
	InternalLogEvent(wCategory, dwMsgID, wMsgType, cStrings, prgStrings);

}


// ---------------------------------------------------------------------------------
//
//
// ---------------------------------------------------------------------------------
HRESULT CErrorSupport::InternalLogEvent(WORD wCategory, DWORD dwMsgID, WORD wMsgType, DWORD cStrings, LPCTSTR *rgStrings)
{
    BOOL 	nRetVal;
	HRESULT	hr;
    HANDLE 	hEventSource = NULL;
 
	// Register the event source
	if ((hEventSource = RegisterEventSource(NULL, m_szEventSource)) == NULL)
    {
    	hr = HRESULT_FROM_WIN32(GetLastError());
		goto exit;
	}

	// Log the event
	nRetVal = ReportEvent(hEventSource, 
				 		  wMsgType, 
						  wCategory, 
						  dwMsgID, 
						  NULL, 
						  (WORD) cStrings, 
						  0, 
						  rgStrings, 
						  NULL);

	if (!nRetVal)
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto exit;
	}

	hr = S_OK;

exit:
    if (hEventSource != NULL)
	    DeregisterEventSource(hEventSource);

   return hr;
}




// ---------------------------------------------------------------------------------
//
//
// ---------------------------------------------------------------------------------
HRESULT CErrorSupport::InternalFormatOneString(TCHAR cFmt, va_list *pvl, BSTR *pbstr)
{
	USES_CONVERSION;
	DWORD	dwMisc;
	int		iMisc;
	LPTSTR	pszMisc;
	HRESULT	hr;
	VARIANT	var;
	TCHAR	szSmallBuff[100];
	LPVOID 	lpMsgBuf = NULL;
	const DWORD MAX_ARG = 256;

	__try
	{
		switch (cFmt)
		{
			case 'i':
	            iMisc = va_arg(*pvl, int);
	            _stprintf(szSmallBuff, _T("%d"), iMisc);
		        *pbstr = SysAllocString(T2W(szSmallBuff));
				break;
				
	        case 'h':
	        case 'x':
	            iMisc = va_arg(*pvl, int);
	            _stprintf(szSmallBuff, _T("0x%x"), iMisc);          
	            *pbstr = SysAllocString(T2W(szSmallBuff));
	            break;

	        case 'e':
	            iMisc = va_arg(*pvl, int);
	            dwMisc = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
	                           NULL,
	                           (HRESULT_FACILITY(iMisc) == FACILITY_WIN32) ? HRESULT_CODE(iMisc) : iMisc,
	                           MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
	                           (LPTSTR) &lpMsgBuf,
	                           MAX_ARG,
	                           NULL);
	            if (dwMisc)
	            {
					LPTSTR	psz;

	            	if ((psz = (LPTSTR)alloca((dwMisc + 100) * sizeof(TCHAR))) == NULL)
	            	{
	            		hr = E_OUTOFMEMORY;
	            		goto exit;
	            	}
	                _stprintf(psz, _T("Error (0x%x): %s"), iMisc, lpMsgBuf);

	                *pbstr = SysAllocString(T2W(psz));
				}
	            else
	                _stprintf(szSmallBuff, _T("Returned error: 0x%x"), iMisc);

	            break;

	       case 'c':
	            V_VT(&var) 	= VT_CY;
	            V_CY(&var)	= va_arg(*pvl, CURRENCY);
	            hr = VariantChangeType(&var, &var, NULL, VT_BSTR);
	            if (FAILED(hr))
	            	*pbstr = SysAllocString(_T("??.??"));

				*pbstr = V_BSTR(&var);
	            break; 

	        case 's':
	            pszMisc = va_arg(*pvl, TCHAR *);
	            *pbstr = SysAllocString(T2W(pszMisc));
	            break;        

	        default:
	        	_ASSERTE(FALSE);
	        	*pbstr = SysAllocString(L"<Invalid format character>");
	            break;        
	    }

		hr = S_OK;
exit:;
	}
	__except (EXCEPTION_EXECUTE_HANDLER) 
	{
#if _DEBUG
		OutputDebugString(_T("An exception occured in FormatOneString().  The arguments passed to LogEventMulti() or AddErrorEx() were incorrect.\n"));
		_ASSERTE(FALSE);
		*pbstr = SysAllocString(L"<ERROR>");
#endif // _DEBUG
	}
	
	if (lpMsgBuf != NULL)
		LocalFree(lpMsgBuf);

	return hr;
}


// ---------------------------------------------------------------------------------
//
//
// ---------------------------------------------------------------------------------
HRESULT CErrorSupport::InternalBuildStringList(HRESULT hrResult, LPCTSTR szLineNum, LPCTSTR szMethodName, LPCTSTR pszFmt, va_list *pvl, CAtlArray<LPTSTR> *prgStrings)
{
	HRESULT	hr;
	BSTR	bstr;
	LPTSTR	psz;
	int		i;

	if (pszFmt != NULL)
	{
		for (i = 0; pszFmt[i] != NULL; i++)
		{
			hr = InternalFormatOneString(pszFmt[i], pvl, &bstr);
			if (FAILED(hr))
				goto exit;

			psz = new TCHAR[SysStringLen(bstr)+1];
			_tcscpy(psz, W2T(bstr));

			prgStrings->Add(psz);

			SysFreeString(bstr);
		}


		TCHAR szLastString[512];
	    _stprintf(szLastString, _T("\r\n\r\n\r\n%s, method/function:%s  [%s] \r\n(HRESULT=0x%x)"), m_bstrErrorSource, 
		         szMethodName, szLineNum, hrResult);
		psz = new TCHAR[_tcslen(szLastString)];
		_tcscpy(psz, szLastString);
		prgStrings->Add(psz);

	}
	else
	{
		_ASSERTE(FALSE);
	}

	hr = S_OK;
exit:
#if _DEBUG
	if (FAILED(hr))
	{
		TCHAR	szMsg[200];
		_stprintf(szMsg, _T("BuildStringList() was unable to process the va_list for LogEventMulti() or AddErrorEx().  Error 0x%x\n"), hr);
		OutputDebugString(szMsg);
	}
#endif _DEBUG
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\utilities\ppstr.cpp ===
//-----------------------------------------------------------------------------
//
//  @doc
//
//  @module ppstr.cpp | implementation of Passport common string utilities
//
//  Author: stevefu
//
//  Date:   05/02/2000
//
//  Copyright <cp> 1999-2000 Microsoft Corporation.  All Rights Reserved.
//
//-----------------------------------------------------------------------------

#include "stdafx.h"
#include <pputils.h>

//-----------------------------------------------------------------------------
//  @func  
//   convert MBCS string to UNICODE, optionally do HTML numeric decoding
//   expects pszIn in the correct codepage and/or in HTML numeric decoding. 
//  @rdesc 
//    wOut returns the converted string. "" if error during conversion.
//-----------------------------------------------------------------------------
void Mbcs2Unicode(LPCSTR  pszIn,     //@parm the cstring to be converted
                  unsigned codepage, //@parm codepage pszIn is on
                  BOOL bNEC,         //@parm do HTML numeric decoding or not
                  CStringW& wOut     //@parm return the W string 
                  )
{
    // codepage 0 == CP_ACP, a perfectly valid code page
    // ATLASSERT(codepage > 0);
    wchar_t* p = NULL;   

    wOut = L"";

	if (NULL == pszIn)
		return;

    int ret;    
    int maxlen;    
    maxlen = strlen(pszIn); // We deal with DBCS only. 
    if ( maxlen == 0 ) goto cleanup;

    p = (wchar_t*)_alloca( sizeof(wchar_t) * (maxlen+4));
    ATLASSERT( p != NULL );
    ret = MultiByteToWideChar(codepage,       
                                  MB_PRECOMPOSED, 
                                  pszIn,          
                                  -1,             
                                  p,           
                                  maxlen + 1); 
    ATLASSERT( ret != 0 );
	if ( ret == 0 ) goto cleanup;

	wOut = p;
    if ( !bNEC ) goto cleanup;

    FixUpHtmlDecimalCharacters(wOut);  

cleanup:    
    return ;
}

//-----------------------------------------------------------------------------
//  @func
//  convert UNICODE string to MBCS string, optionally do HTML numeric encoding
//  for characters that can NOT be mapped into the given codepage.
//  If you want everything in HTML numeric encoding, use Western codepage 1252.
//
//  @rdesc 
//    aOut returns the converted string. "" if error during conversion.
//-----------------------------------------------------------------------------
void Unicode2Mbcs(LPCWSTR pwszIn,    //@parm the W string to be converted
             	  unsigned codepage, //@parm the codepage used for the conversion
                  BOOL bNEC,         //@parm if TRUE, characters that don't fit into
                                     //      the given codepage will be NEC'ed
                  CStringA& aOut     //@parm return the A string 
                      )
{
    // codepage 0 == CP_ACP, a perfectly valid code page
    // ATLASSERT(codepage > 0);
	char* p = NULL;
  
	aOut = "";

	if (NULL == pwszIn)
		return;

    int  ret;  
    if ( ! bNEC )
    {
        int  maxlen;        
        maxlen = wcslen(pwszIn) * 2; // We deal with DBCS only. 
        if ( maxlen == 0 ) goto cleanup;

        char* p = (char*)_alloca( sizeof(char) * (maxlen+4));
        ATLASSERT( p != NULL );

        ret = WideCharToMultiByte(codepage,
                              0,              
                              pwszIn,         
                              -1,             
                              p,
                              maxlen,
                              NULL,
                              NULL);
        ATLASSERT( ret != 0 );
		if ( ret == 0 ) goto cleanup;

		aOut = p;
		goto cleanup;
    }
    else // do it the slow way: convert one char at a time. If can't convert, do
         // HTML numeric encoding
    {
        int  i;
        char     strbuff[20]; // buffer for one single MBCS character or NEC
        aOut.Preallocate(wcslen(pwszIn) * 3); //estimate: reduce re-allocate
        
        for( i = 0; pwszIn[i] != L'\0'; i++ )
        {
			BOOL bDefault = FALSE;
            ret = WideCharToMultiByte(codepage,
                                      0,              
                                      &pwszIn[i],         
                                      1,             
                                      strbuff,
                                      20,
                                      NULL,
                                      &bDefault);
            if ( 0 != ret && !bDefault )
            {
				strbuff[ret] = '\0';
                aOut += strbuff;
            }
            else
            {
                ATLASSERT(pwszIn[i] > 0);
                ltoa(pwszIn[i], strbuff, 10);
                aOut += "&#";
                aOut += strbuff;
                aOut += ";" ;
            }
        }
    }

cleanup:
	return;
}


//*----------------------------------------------------------------------------
// @func
//     convert HTML numeric encoding blocks (&#1234; etc) within a W string 
//     to UNICODE  characters.
//*----------------------------------------------------------------------------
void FixUpHtmlDecimalCharacters(
                   CStringW& str  //@parm in/out. the string to be converted
                   )
{
    CStringW tmp = "";
    wchar_t* pstr = str.LockBuffer();

    int i;
    int len = str.GetLength();
    tmp.Preallocate(len+4); // avoid re-allocation
    for( i = 0; i < len; i++) 
    {
        if ( pstr[i] == L'&' && pstr[i+1] == L'#' )
        {
            int ndx = str.Find(L';', i+1);
            if ( ndx != -1 && ndx > i+2)
            {
                pstr[ndx] = L'\0';
                long wch = _wtoi(&pstr[i+2]);             
                if (wch > 0 && wch < static_cast<long>(USHRT_MAX)) 
                {
                    tmp += static_cast<wchar_t>(wch);
                }
                i = ndx; 
                continue;
            }
        }    
    
        //default case: append it
        tmp += str[i];
    }

    str = tmp;
}

//*----------------------------------------------------------------------------
// @func 
//   escaping special characters. supported characters are: ", <, > .  
//   this is used only for HTML escaping, not for URL escaping.  
//*----------------------------------------------------------------------------
void HtmlEscapeString(
           CStringW& str,               //@parm in/out. the string to be escaped
           LPCWSTR escch /*= L"\"<>"*/  //@parm in. the escape characters to check
                                        // for: 
           )
{
    ATLASSERT( escch != NULL );
    CStringW strEsc(escch);

    if (strEsc.Find(L'"') != -1)
    {
        str.Replace(L"\"", L"&quot;");
    }
    if (strEsc.Find(L'<') != -1)
    {
        str.Replace(L"<", L"&lt;");
    }
    if (strEsc.Find(L'>') != -1)
    {
        str.Replace(L">", L"&gt;");
    }
    return;
}

//*----------------------------------------------------------------------------
// @func 
//   escaping special characters. supported characters are: ", <, > .  
//   this is used only for HTML escaping, not for URL escaping.  
//*----------------------------------------------------------------------------
void HtmlEscapeString(
           CStringA& str,               //@parm in/out. the string to be escaped
           LPCSTR escch /*= L"\"<>"*/  //@parm in. the escape characters to check
                                        // for: 
           )
{
    ATLASSERT( escch != NULL );

    if (strchr(escch, '"'))
    {
        str.Replace("\"", "&quot;");
    }
    if (strchr(escch, '<'))
    {
        str.Replace("<", "&lt;");
    }
    if (strchr(escch, '>'))
    {
        str.Replace(">", "&gt;");
    }
    return;
}

//*----------------------------------------------------------------------------
// @func 
//   URL escaping unsafe characters specified under the URI RFC document
//*----------------------------------------------------------------------------
void UrlEscapeString(
             CStringW& wStr    //@parm in/out, string to be converted
             )
{
	int      len;
	int      i;
	wchar_t  ch;
	wchar_t  cbuff[10];
	CStringW wOutstr = L"";
	
	len = wStr.GetLength();
	if ( len == 0 ) return;
	wOutstr.Preallocate(len*3); // avoid re-allocate

	for ( i = 0; i < len; i++ )
	{
		ch = wStr[i];		
		if ( AtlIsUnsafeUrlChar((char)ch) )
		{
			//output the percent, followed by the hex value of the character
			wOutstr += L'%';
			swprintf(cbuff, L"%.2X", ch);
			wOutstr += cbuff;
		}
		else //safe character
		{
			wOutstr += ch;
		}
	}
	
	wStr = wOutstr;
	return;
}


//*----------------------------------------------------------------------------
// @func 
//   URL escaping unsafe characters specified under the URI RFC document
//*----------------------------------------------------------------------------
CStringA UrlEscapeStr(
             const CStringA& oStr    //@parm in/out, string to be converted
             )
{
	int			iLen;
	int			iIndex;
	char		ch;
	char		cbuff[10];
	CStringA	oStrOut = "";
	
	iLen = oStr.GetLength();
	if (iLen == 0) { return oStr; }

	oStrOut.Preallocate(iLen * 3); // avoid re-allocate

	for (iIndex = 0; iIndex < iLen; iIndex++)
	{
		ch = oStr[iIndex];		
		if ( AtlIsUnsafeUrlChar(ch) )
		{
			//output the percent, followed by the hex value of the character
			oStrOut += '%';
			sprintf(cbuff, "%.2X", ch);
			oStrOut += cbuff;
		}
		else //safe character
		{
			oStrOut += ch;
		}
	}
	
	return oStrOut;
}


//*----------------------------------------------------------------------------
// @func 
//   URL escaping unsafe characters specified under the URI RFC document
//*----------------------------------------------------------------------------
void UrlEscapeString(
             CStringA& oStr    //@parm in/out, string to be converted
             )
{
	int			iLen;
	int			iIndex;
	char		ch;
	char		cbuff[10];
	CStringA	oStrOut = "";
	
	iLen = oStr.GetLength();
	if (iLen == 0) { return; }

	oStrOut.Preallocate(iLen * 3); // avoid re-allocate

	for (iIndex = 0; iIndex < iLen; iIndex++)
	{
		ch = oStr[iIndex];		
		if ( AtlIsUnsafeUrlChar(ch) )
		{
			//output the percent, followed by the hex value of the character
			oStrOut += '%';
			sprintf(cbuff, "%.2X", ch);
			oStrOut += cbuff;
		}
		else //safe character
		{
			oStrOut += ch;
		}
	}
	
	oStr = oStrOut;
	return;
}


//*----------------------------------------------------------------------------
// @func 
//   URL un-escaping unsafe characters specified under the URI RFC document
//*----------------------------------------------------------------------------
void UrlUnescapeString(
		CStringW& wStr    //@parm in/out, string to be converted
		)
{
	wchar_t* psrc; 
	wchar_t* pdest;
	unsigned nValue;

	psrc = pdest = wStr.GetBuffer();
	while( *psrc != '\0' )
	{
		if (*psrc == L'%' && *(psrc+1) != '\0' && *(psrc+2) != '\0')
		{
			//currently assuming 2 hex values after '%'
			//as per the RFC 2396 document
			nValue = 16*AtlHexValue((char)*(psrc+1));
			nValue+= AtlHexValue((char)*(psrc+2));
			*pdest = (wchar_t) nValue;
			psrc += 3;
		}
		else if ( *psrc == L'+' ) // special treatment for space
		{
			*pdest = L' ';
			psrc++;
		}
		else //non-escape character
		{
			*pdest = *psrc;
			psrc++;
		}
		pdest++;
	}
	*pdest = L'\0';
	wStr.ReleaseBuffer();
	
	return;
}

//*----------------------------------------------------------------------------
// @func 
//   URL un-escaping unsafe characters specified under the URI RFC document
//*----------------------------------------------------------------------------
void UrlUnescapeString(
		CStringA& aStr    //@parm in/out, string to be converted
		)
{
	char* psrc; 
	char* pdest;
	unsigned nValue;

	psrc = pdest = aStr.GetBuffer();
	while( *psrc != '\0' )
	{
		if (*psrc == '%' && *(psrc+1) != '\0' && *(psrc+2) != '\0')
		{
			//currently assuming 2 hex values after '%'
			//as per the RFC 2396 document
			nValue = 16*AtlHexValue((char)*(psrc+1));
			nValue+= AtlHexValue((char)*(psrc+2));
			*pdest = (char) nValue;
			psrc += 3;
		}
		else if ( *psrc == '+' ) // special treatment for space
		{
			*pdest = ' ';
			psrc++;
		}
		else //non-escape character
		{
			*pdest = *psrc;
			psrc++;
		}
		pdest++;
	}
	*pdest = '\0';
	aStr.ReleaseBuffer();
	
	return;
}

//*----------------------------------------------------------------------------
// @func 
//   copy BSTR contents to a string object and also free up the BSTR src
//*----------------------------------------------------------------------------
void BSTRMove(BSTR& src,         //@parm in/out source string
              CStringW& dest     //@parm out, dest string object
              )
{
	dest = src;
	::SysFreeString(src);
	src = NULL;
}


//*----------------------------------------------------------------------------
// @func 
//   copy BSTR contents to a string object and also free up the BSTR src
//*----------------------------------------------------------------------------
void BSTRMove(BSTR& src,         //@parm in/out source string
              CStringA& dest     //@parm out, dest string object
              )
{
	wchar_t*  p;
	char      c;

	dest = "";
	for ( p = src; *p != L'\0'; p++ )
	{
		c = (char) ( (*p) & 0xff ); // ignore high bits
		dest += c;
	}
	::SysFreeString(src);
	src = NULL;
}


//*----------------------------------------------------------------------------
// @func 
//   convert a WCHAR character into a hex number
//*----------------------------------------------------------------------------
long HexToNum(wchar_t c)
{
    return ((c >= L'0' && c <= L'9') ? (c - L'0') : ((c >= 'A' && c <= 'F') ? (c - L'A' + 10) : -1));
}

//*----------------------------------------------------------------------------
// @func 
//   convert a wide char hex string to its numeric equivalent
//*----------------------------------------------------------------------------
long FromHex(LPCWSTR pszHexString)
{
    long    lResult = 0;
    long    lCurrent;
    LPWSTR  pszCurrent;
    
    for(pszCurrent = const_cast<LPWSTR>(pszHexString); *pszCurrent; pszCurrent++)
    {
        if((lCurrent = HexToNum(towupper(*pszCurrent))) == -1)
            break;  // illegal character, we're done

        lResult = (lResult << 4) + lCurrent;
    }

    return lResult;
}



void EncodeXMLString(CStringA& str)
{
    /*
    Any occurrence of & must be replaced by &amp;
    Any occurrence of < must be replaced by &lt;
    Any occurrence of > must be replaced by &gt;
    Any occurrence of " (double quote) must be replaced by &quot; 
    */
    str.Replace("&", "&amp;");
    str.Replace("<", "&lt;");
    str.Replace(">", "&gt;");
    str.Replace("\"", "&quot;");
}

void EncodeXMLString(CStringW& str)
{
    /*
    Any occurrence of & must be replaced by &amp;
    Any occurrence of < must be replaced by &lt;
    Any occurrence of > must be replaced by &gt;
    Any occurrence of " (double quote) must be replaced by &quot; 
    */
    str.Replace(L"&", L"&amp;");
    str.Replace(L"<", L"&lt;");
    str.Replace(L">", L"&gt;");
    str.Replace(L"\"", L"&quot;");
}

void EncodeWMLString(CStringA& str)
{
    /*
    on top of XML, change $ --> $$
    */

    EncodeXMLString(str);
    str.Replace("$", "$$");
}

void EncodeWMLString(CStringW& str)
{
    /*
    on top of XML, change $ --> $$
    */

    EncodeXMLString(str);
    str.Replace(L"$", L"$$");
}

void EncodeHDMLString(CStringA & str)
{
    /*
    on top of XML, change $ --> $$
    */

    EncodeXMLString(str);
    str.Replace("$", "&dol;");
}

void EncodeHDMLString(CStringW & str)
{
    /*
    on top of XML, change $ --> $$
    */

    EncodeXMLString(str);
    str.Replace(L"$", L"&dol;");
}

void ToHexStr(CStringA& outputToAppend, LPCWSTR instr) throw()
{
   char temp[6];
   while(*instr)
   {
      sprintf(temp, "%04x", *instr);
      outputToAppend += temp;
      ++instr;
   }
}

void ToHexStr(CStringA& outputToAppend, unsigned short in) throw()
{
   WCHAR temp[10];
   wsprintf(temp, L"%-hu", in);
   ToHexStr(outputToAppend, temp);
}

void ToHexStr(CStringA& outputToAppend, unsigned long in) throw()
{
   WCHAR temp[10];
   wsprintf(temp, L"%-lu", in);
   ToHexStr(outputToAppend, temp);
}


void ToHexStr(CStringA& outputToAppend, PBYTE pData, ULONG len) throw()
{
#define TOHEX(a) ((a)>=10 ? 'a'+(a)-10 : '0'+(a))
   _ASSERT(pData);
   _ASSERT(len != 0);
   
   UINT v;
   char temp[2];
   temp[2] = 0;
   for(ULONG i = 0; i < len; ++i, ++pData)
   {
        v = *pData >> 4;
        temp[0] = TOHEX( v );
        v = *pData & 0x0f;
        temp[1] = TOHEX( v );
        outputToAppend += temp;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\utilities\ppurl.cpp ===
// PPUrl.cpp: implementation of the CPPUrl class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "PPUrl.h"
#include "passportexception.h"
#include "pputils.h"
#include "pphandlerbase.h"

#define LONG_DIGITS     10

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CPPUrl::CPPUrl(LPCSTR pszUrl)
{
    m_pszQuestion = NULL;
    Set(pszUrl);
}

BOOL CPPUrl::GetQParamQuick(LPCSTR qsStart, LPCSTR name, UINT nameStrLen, LPCSTR& qpStart, LPCSTR& qpEnd)
{
   _ASSERT(nameStrLen >= 2); // = sign is required
   _ASSERT(name[nameStrLen - 1] == '=');   // high perf
   _ASSERT(name[nameStrLen] != '?');   // high perf
   _ASSERT(name[nameStrLen] != '&');   // high perf
   _ASSERT(strlen(name) == nameStrLen); // high perf

   if (!qsStart) return FALSE;
   
   LPCSTR p = qsStart;

   while(p = strstr(p, name))
   {
      if (p == qsStart || *(p - 1) == '&')
      {
         qpStart = p + nameStrLen;
         break;
      }

      p += nameStrLen;
   }
   
   if (qpStart)
   {
      qpEnd = (LPSTR)strchr(qpStart, '&');
      return TRUE;
   }
   return FALSE;
}

BOOL CPPUrl::GetQParamQuick(LPCSTR qsStart, LPCSTR name, UINT nameStrLen, INT& value)
{
   LPCSTR qpS = NULL;
   LPCSTR qpE = NULL;

   if(GetQParamQuick(qsStart, name, nameStrLen, qpS, qpE))
   {
      char qpEChar;
      if (qpE != NULL)
      {
         qpEChar = *(LPSTR)qpE;
         *(LPSTR)qpE = 0;
      }

      value = atoi(qpS);

      if (qpE != NULL)
         *(LPSTR)qpE  = qpEChar;
         
      return TRUE;
   }
   return FALSE;
}
 

void CPPUrl::Set(LPCSTR pszUrl)
{
    if (NULL != pszUrl)
    {
        CPPQueryString::Set(pszUrl);
        m_pszQuestion = strchr(m_pszBegin, '?');
    }
}

void CPPUrl::Set(LPCWSTR pwszUrl)
{
    if (NULL != pwszUrl)
    {
        CPPQueryString::Set(pwszUrl);
        m_pszQuestion = strchr(m_pszBegin, '?');
    }
}

void CPPUrl::Reinit()
{
    if (NULL == m_psz)
    {
        CPPQueryString::Reinit();
        m_pszQuestion = strchr(m_pszBegin, '?');
    }
}

void CPPQueryString::Set(LPCSTR lpsz)
{
    if (NULL != lpsz)
    {
        long len = lstrlenA(lpsz);
        if (len > (signed) (ATL_URL_MAX_URL_LENGTH-1))
        {
            throw CPassportException(__FILE__";url length exceeded max",
                                     __LINE__,
                                     E_FAIL,
                                     len, 
                                     ATL_URL_MAX_URL_LENGTH);
        }

        UnlockData();

        m_pszBegin = m_psz = LockData();
        lstrcpynA(m_psz, lpsz, ATL_URL_MAX_URL_LENGTH); 
        m_psz += len; 
    }
}

void CPPQueryString::Set(LPCWSTR lpwsz)
{
    if (NULL != lpwsz)
    {
        long len = lstrlenW(lpwsz);
        long lIndex = len;
        if (len > (signed) (ATL_URL_MAX_URL_LENGTH-1))
        {
            throw CPassportException(__FILE__";url length exceeded max",
                                     __LINE__,
                                     E_FAIL,
                                     len, 
                                     ATL_URL_MAX_URL_LENGTH);
        }

        UnlockData();       // balanced the last LockBuffer;

        m_pszBegin = m_psz = LockData();
        for (;lIndex>0;lIndex--)
        {
            *m_psz++ = (char) *lpwsz++;     // lpcwstr must be true ASCII) !!
        }
        *m_psz = 0;
    }
}

void CPPQueryString::Reinit()
{
    if (NULL == m_psz)
    {
        m_pszBegin = m_psz = LockData();
        m_psz += lstrlenA(m_psz); 
    }
}

void CPPQueryString::Uninit(bool bUnlock)
{
    if (bUnlock)
    {
        UnlockData();
    }
    else
    {
        // to deal with anomalies of CString class that doesn't respect preallocate
        // during operator=, we need to remain locked when casting to CString *
        if (!m_bLockedCString)
            LockData();
    }

    if (NULL != m_psz)
    {
        m_pszBegin = m_psz = NULL;
    }
}

#define TOHEX(a) ((a)>=10 ? 'a'+(a)-10 : '0'+(a))

void CPPQueryString::DoParamAdd(LPCWSTR pwszParamValue, bool fEncoding)
{
    long lleng = lstrlenW(pwszParamValue);
    long lStartStrLen = (long) (m_psz - m_pszBegin);

    if (lleng == 0)
    { 
        return; 
    }

    if (lStartStrLen >= (signed) (ATL_URL_MAX_URL_LENGTH-lleng-1))
    {
         throw CPassportException(  __FILE__";url length exceeded max",
                                    __LINE__,
                                    E_FAIL,
                                    lleng, 
                                    ATL_URL_MAX_URL_LENGTH);
    }
    
    if (!fEncoding)
    {
        while (*pwszParamValue)
        {
            *m_psz++ = (char) *pwszParamValue;  // we know this cast is safe for non-unicode wchar
            pwszParamValue++;
        }
    }
    else
    {
        long        lIndex = 0;
        char        ch;
        long        lEncodedLen = lleng;  // assume no encoding happens
        UINT        uiValue;

        while (lIndex < lleng)
        {
            ch = (char)pwszParamValue[lIndex];  // we know this cast is safe for non-unicode wchar      
            if ( AtlIsUnsafeUrlChar(ch) )
            {
                if (ch == ' ')
                {
                    *m_psz++ = '+';
                }
                else
                {
                    // size of encoding increased by two
                    lEncodedLen +=2;
                    // check to see if we are still within the limit
                    if (lStartStrLen + lEncodedLen >= (signed) (ATL_URL_MAX_URL_LENGTH - 1))
                    {
                        throw CPassportException(   __FILE__";url length exceeded max",
                                                    __LINE__,
                                                    E_FAIL,
                                                    lEncodedLen, 
                                                    ATL_URL_MAX_URL_LENGTH);
                    }
                    //output the percent, followed by the hex value of the character
                    *m_psz++ = '%';
                    uiValue = ch >> 4;
                    *m_psz++ = TOHEX(uiValue);
                    uiValue = ch & 0x0f;
                    *m_psz++ = TOHEX(uiValue);
                }
            }
            else //safe character
            {
                *m_psz++ = ch;
            }
            ++lIndex;
        }
    }
    *m_psz = 0;
}


void CPPQueryString::DoParamAdd(LPCSTR pszParamValue, bool fEncoding)
{
    long lleng = lstrlenA(pszParamValue);
    long lStartStrLen = (long) (m_psz - m_pszBegin);

    if (lleng == 0)
    { 
        return; 
    }

    if (lStartStrLen >= (signed) (ATL_URL_MAX_URL_LENGTH-lleng-1))
    {
        throw CPassportException(__FILE__";url length exceeded max",
                                 __LINE__,
                                 E_FAIL,
                                 lleng, 
                                 ATL_URL_MAX_URL_LENGTH);
    }
    
    if (!fEncoding)
    {
        lstrcpynA(m_psz, pszParamValue, lleng+1);
        m_psz += lleng;
    }
    else
    {
        long        lIndex = 0;
        char        ch;
        long        lEncodedLen = lleng;  // assume no encoding happens
        UINT        uiValue;

        while (lIndex < lleng)
        {
            ch = pszParamValue[lIndex];        
            if ( AtlIsUnsafeUrlChar(ch) )
            {
                if (ch == ' ')
                {
                    *m_psz++ = '+';
                }
                else
                {
                    // size of encoding increased by two
                    lEncodedLen +=2;
                    // check to see if we are still within the limit
                    if (lStartStrLen + lEncodedLen >= (signed) (ATL_URL_MAX_URL_LENGTH - 1))
                    {
                        throw CPassportException(   __FILE__";url length exceeded max",
                                                    __LINE__,
                                                    E_FAIL,
                                                    lEncodedLen, 
                                                    ATL_URL_MAX_URL_LENGTH);
                    }
                    //output the percent, followed by the hex value of the character
                    *m_psz++ = '%';
                    uiValue = ch >> 4;
                    *m_psz++ = TOHEX(uiValue);
                    uiValue = ch & 0x0f;
                    *m_psz++ = TOHEX(uiValue);
                }
            }
            else //safe character
            {
                *m_psz++ = ch;
            }
            ++lIndex;
        }
    }
    *m_psz = 0;
}


void CPPQueryString::AddQueryParam(LPCSTR pszParamName, LPCWSTR pwszParamValue, bool bTrueUnicode, bool fEncoding)
{
    Reinit();
    if (NULL == pszParamName)
    {
        ATLASSERT(FALSE);
        //*** assert/exception.
    }

    long lleng = lstrlenA(pszParamName);
    // 3 for '?' or '&', '=' and NULL
    if ((m_psz-m_pszBegin) >= (signed) (ATL_URL_MAX_URL_LENGTH-lleng-3))
    {
         throw CPassportException(  __FILE__";url length exceeded max",
                                    __LINE__,
                                    E_FAIL,
                                    lleng, 
                                    ATL_URL_MAX_URL_LENGTH);
    }
    if (m_psz > m_pszBegin && '?' != *(m_psz-1) && '&' != *(m_psz-1))
    {
        *m_psz++ = '&';
        *m_psz = 0;
    }

    lstrcpynA(m_psz, pszParamName, lleng+1);
    m_psz += lleng;
    *m_psz++ = '=';
    *m_psz = 0;

    if (NULL != pwszParamValue)
    {
        if (!bTrueUnicode)
        {
            DoParamAdd(pwszParamValue, fEncoding);
        }
        else
        {
            CStringA cszA;
            ::Unicode2Mbcs(pwszParamValue, 1252 /*ANSI codepage*/,  true, cszA);
            DoParamAdd(cszA, fEncoding);
        }
    }
}

void CPPQueryString::AddQueryParam(LPCSTR pszParamName, LPCSTR pszParamValue, bool fEncoding)
{
    Reinit();
    if (NULL == pszParamName)
    {
        //*** assert/exception.
    }
    long lleng = lstrlenA(pszParamName);
    // 3 for '?' or '&', '=' and NULL
    if ((m_psz-m_pszBegin) >= (signed) (ATL_URL_MAX_URL_LENGTH-lleng-3))
    {
         throw CPassportException(  __FILE__";url length exceeded max",
                                    __LINE__,
                                    E_FAIL,
                                    lleng, 
                                    ATL_URL_MAX_URL_LENGTH);
    }
    if (m_psz > m_pszBegin && '?' != *(m_psz-1) && '&' != *(m_psz-1))
    {
        *m_psz++ = '&';
        *m_psz = 0;
    }

    lstrcpynA(m_psz, pszParamName, lleng+1);
    m_psz += lleng;
    *m_psz++ = '=';
    *m_psz = 0;

    if (NULL != pszParamValue)
    {
        DoParamAdd(pszParamValue, fEncoding);
    }
}

bool CPPQueryString::StripQueryParam(LPCSTR pszParamName)
{
    ATLASSERT(pszParamName);
    Reinit();
    bool fIncremented;

    if (m_pszBegin == m_psz)
    {
        // No string, so everything is already stripped
        return false;
    }

    long lleng = lstrlenA(pszParamName);
    char *pszIndex = m_pszBegin;
    while (*pszIndex)
    {
        // Is this the beginning of a new parameter?
        if ((*pszIndex == '?') || (*pszIndex == '&') || (pszIndex == m_pszBegin))
        {
            // move past '?' or '&'
            if ((*pszIndex == '?') || (*pszIndex == '&'))
            {
                fIncremented = true;
                ++pszIndex;
            }
            else
            {
                fIncremented = false;
            }
            
            // is this the param we are looking for?
            if (strnicmp(pszIndex, pszParamName, lleng) == 0)
            {
                // make sure it is an exact match
                if (pszIndex[lleng] == '=')
                {
                    // find the end of the param value
                    char *pszEnd = pszIndex + lleng + 1;
                    while ((*pszEnd != '&') && *pszEnd)
                    {
                        ++pszEnd;
                    }
                    // Was this the last param
                    if (!*pszEnd)
                    {
                        // if previously incremented, back up one
                        if (fIncremented)
                        {
                            --pszIndex;
                        }
                    }
                    else
                    {
                        // need to move params on end
                        ++pszEnd; // move past '&'
                        while (*pszEnd)
                        {
                            *pszIndex = *pszEnd;
                            ++pszIndex;
                            ++pszEnd;
                        }
                    }

                    // null terminate and exit
                    *pszIndex = '\0';
                    m_psz = pszIndex;
                    return true;
                }
            }

            // if this was not incremented, make sure it gets incremented
            if (!fIncremented)
            {
                ++pszIndex;
            }
        }
        else
        {
            ++pszIndex;
        }
    }

    return false;
}

void CPPUrl::AddQueryParam(LPCSTR pszParamName, long lValue)
{
    Reinit();
    char szLong[LONG_DIGITS + 1];
    ltoa(lValue, szLong, 10);
    AddQueryParam(pszParamName, szLong, false);
}

void CPPUrl::AddQueryParam(LPCSTR pszParamName, LPCSTR pszParamValue, bool fEncoding)
{
    Reinit();
    if (!m_pszQuestion)
    {
        // 2 for '?', and NULL
        if ((m_psz-m_pszBegin) >= (signed) (ATL_URL_MAX_URL_LENGTH-2))
        {
            throw CPassportException(__FILE__";url too long",__LINE__,E_FAIL);
        }
        m_pszQuestion = m_psz;
        *m_psz++ = '?';
        *m_psz = 0;
    }
    CPPQueryString::AddQueryParam(pszParamName, pszParamValue, fEncoding);
}

void CPPUrl::AddQueryParam(LPCSTR pszParamName, LPCWSTR pwszParamValue, bool bTrueUnicode, bool fEncoding)
{
    Reinit();
    if (!m_pszQuestion)
    {
        // 2 for '?', and NULL
        if ((m_psz-m_pszBegin) >= (signed) (ATL_URL_MAX_URL_LENGTH-2))
        {
            throw CPassportException(__FILE__";url too long",__LINE__,E_FAIL);
        }
        m_pszQuestion = m_psz;
        *m_psz++ = '?';
        *m_psz = 0;
    }
    CPPQueryString::AddQueryParam(pszParamName, pwszParamValue, bTrueUnicode, fEncoding);
}

void CPPUrl::AppendQueryString(LPCSTR pszQueryString)
{
    if (NULL == pszQueryString)
        return;
    
    Reinit();
    long lLeng = lstrlenA(pszQueryString);
    if (!m_pszQuestion)
        lLeng++;

    if ((m_psz-m_pszBegin) >= (signed) (ATL_URL_MAX_URL_LENGTH-1-lLeng))
    {
        ATLASSERT(FALSE);
        throw CPassportException(__FILE__";url too long",__LINE__,E_FAIL);
    }
    if (!m_pszQuestion)
    {
        m_pszQuestion = m_psz;
        *m_psz++ = '?';
        lLeng--;
    }

    lstrcpyA(m_psz, pszQueryString);
    m_psz += lLeng;
}

//pszQueryString doesn't contain leading '?' or '&'
void CPPUrl::InsertBQueryString(LPCSTR pszQueryString)
{
    Reinit();
    if (!m_pszQuestion)
    {
        AppendQueryString(pszQueryString);
    }
    else
    {
        long lLeng = lstrlenA(pszQueryString);
        if ((m_psz-m_pszBegin) >= (signed) (ATL_URL_MAX_URL_LENGTH-1-lLeng-1))
        {
            ATLASSERT(FALSE);
            throw CPassportException(__FILE__";url too long",__LINE__,E_FAIL);
        }
        memmove(m_pszQuestion+1+lLeng+1, m_pszQuestion+1, m_psz-m_pszQuestion-1);
        memmove(m_pszQuestion+1, pszQueryString, lLeng);
        *(m_pszQuestion+1+lLeng) = '&';
        m_psz += lLeng+1;
        *m_psz = '\0';
    }
}

void CPPUrl::MakeSecure()
{
    Reinit();

    if (0 == _strnicmp(m_pszBegin, "http:", 5))     // at least it's a http protocol url
    {
        // make sure there is room for one more char
        if ((m_psz-m_pszBegin) >= (signed) (ATL_URL_MAX_URL_LENGTH-1))
        {
            ATLASSERT(FALSE);
            throw CPassportException(__FILE__";url too long",__LINE__,E_FAIL);
        }
        memmove(m_pszBegin+5, m_pszBegin+4, m_psz-m_pszBegin-4);
        m_pszBegin[4] = 's';
        *(++m_psz) = 0;
        if (m_pszQuestion)
        {
            m_pszQuestion++;
        }
    }
}
void CPPUrl::MakeNonSecure()
{
    Reinit();

    if (0 == _strnicmp(m_pszBegin, "https:", 6))        // at least it's a http protocol url
    {
        memmove(m_pszBegin+4, m_pszBegin+5, m_psz-m_pszBegin-5);
        *(--m_psz) = 0;
        if (m_pszQuestion)
        {
            m_pszQuestion--;
        }
    }
}

void CPPUrl::ReplaceQueryParam(LPCSTR pszParamName, LPCSTR pszParamValue)
{
    if (!pszParamName)
    {
        //todo -- badbad
    }
    Reinit();
    long nlen = lstrlenA(pszParamName);

    char *psz = StrStrA(m_pszBegin, pszParamName);
    while (psz != NULL && (psz==m_pszBegin || (*(psz-1) != '?' && *(psz-1) != '&') ||
            (*(psz+nlen) != '=' && *(psz+nlen) != '&'))) // not a query parameter
    {
        psz = strstr(psz+nlen, pszParamName);
    }
    if (NULL == psz)
        AddQueryParam(pszParamName, pszParamValue);
    else
    {
        //todo*** figure out the old value length
        psz += lstrlenA(pszParamName);
        long nold = 0;
        if (pszParamValue)
            nlen = lstrlenA(pszParamValue);
        else
            nlen = 0;

        if (*psz != '=')
        {
            ATLASSERT(*psz == '&');
            memmove(psz+1+nlen, psz, lstrlenA(psz));
            *psz = '=';
            if (nlen)
                memcpy(psz+1, pszParamValue, nlen);
        }
        else
        {
            char *pszNext = StrStrA(psz, "&");
            if (NULL == pszNext)
                nold = lstrlenA(psz+1);
            else
                nold = (long) (pszNext-psz-1);
            memmove(psz+1+nlen, psz+1+nold, lstrlenA(psz+1+nold));
            if (nlen)
                memcpy(psz+1, pszParamValue, nlen);
        }
    }
}

void CPPUrl::MakeFullUrl(LPCSTR pszUrlPath, bool bSecure)
{
    Reinit();
    CPassportHandlerBase* p = CPassportHandlerBase::GetPPHandler();
    ATLASSERT( p != NULL && "this method is limited to a handler.");

    CStringA cszA;
    if (bSecure)
    {
        lstrcpyA(m_pszBegin, "https://");
        m_psz = m_pszBegin + 8;
    }
    else
    {
        lstrcpyA(m_pszBegin, "http://");
        m_psz = m_pszBegin + 7;
    }

    p->GetAServerVariable("SERVER_NAME", cszA);
    lstrcpyA(m_psz, cszA);
    m_psz += cszA.GetLength();
    
    *(m_psz++) = '/';
    *m_psz = '\0';
    
    long len = lstrlenA(pszUrlPath);
    if (len)
    {
        if ((m_psz-m_pszBegin) >= (signed) (ATL_URL_MAX_URL_LENGTH-1-len))
        {
            ATLASSERT(FALSE);
            throw CPassportException(__FILE__";url too long",__LINE__,E_FAIL);
        }
        lstrcpyA(m_psz, pszUrlPath);
        m_pszQuestion = strchr(m_psz, '?');
        m_psz += len;
    }
    else
    {
        m_pszQuestion = NULL;
    }
}

void CPPUrl::ReplacePath(LPCSTR pszUrlPath)
{
    Reinit();
    m_psz = StrStrA(m_pszBegin, "://");
    if (NULL == m_psz)
    {
        ATLASSERT(FALSE);       // not good -- it was not a url to begin with
        throw CPassportException(__FILE__, __LINE__, E_INVALIDARG, 0, 0, 0);
    }
    m_psz += 3;

    m_psz = StrStrA(m_psz, "/");
    if (NULL == m_psz)
    {
        // url contained host name only.  Append first path separator, and then
        // new path.
        m_psz = m_pszBegin + lstrlenA(m_pszBegin);
        *(m_psz++) = '/';        
    }
    else
    {
        m_psz++;
    }

    long len = lstrlenA(pszUrlPath);
    if ((m_psz-m_pszBegin) >= (signed) (ATL_URL_MAX_URL_LENGTH-1-len))
    {
        ATLASSERT(FALSE);
        throw CPassportException(__FILE__";url too long",__LINE__,E_FAIL);
    }
    lstrcpyA(m_psz, pszUrlPath);
    m_psz += len;
    m_pszQuestion = strchr(m_pszBegin, '?');
}


CPPUrl & CPPUrl::operator += (LPCSTR pcszAppend)
{
    Reinit();

    long lLeng = lstrlenA(pcszAppend);
    if ((m_psz-m_pszBegin) >= (signed) (ATL_URL_MAX_URL_LENGTH-lLeng))
    {
        ATLASSERT(FALSE);
        throw CPassportException(__FILE__";url too long",__LINE__,E_FAIL);
    }
    lstrcpynA(m_psz, pcszAppend, lLeng+1);
    m_psz += lLeng;
    m_pszQuestion = strchr(m_pszBegin, '?');
    return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\utilities\regutils.cpp ===
//-----------------------------------------------------------------------------
//
// RegUtils.cpp
//
//
// Helper functions for dealing with the registry.
//
// Author: Jeff Steinbok
//
// 02/01/01       jeffstei    Initial Version
//
// Copyright <cp> 2000-2001 Microsoft Corporation.  All Rights Reserved.
//
//-----------------------------------------------------------------------------

#include "stdafx.h"
#include <windows.h>
#include "regUtils.h"


//
// CopyKeyHierarchy(...)
//
LONG CopyKeyHierarchy (HKEY in_hKeySrc, LPTSTR in_lpszSubKeySrc, HKEY in_hKeyDest, LPTSTR in_lpszSubKeyDest)
{
	LONG retVal;

	DWORD dwNumSubKeys;
	DWORD dwMaxSubKeyLen;
	DWORD dwNumValues;
	DWORD dwMaxValueNameLen;
	DWORD dwMaxValueLen;

	HKEY  hKey;
	HKEY  hNewKey;

	retVal = RegOpenKey(in_hKeySrc,in_lpszSubKeySrc, &hKey);
	if (retVal)
		return retVal;
	
	// Get information about the key
	retVal = RegQueryInfoKey(hKey, 
				    NULL,
					NULL,
					NULL,
					&dwNumSubKeys,
					&dwMaxSubKeyLen,
					NULL,
					&dwNumValues,
					&dwMaxValueNameLen,
					&dwMaxValueLen,
					NULL,
					NULL);
	if (retVal)
		return retVal;

	LPTSTR lpszKeyName = new TCHAR[++dwMaxSubKeyLen];
	LPTSTR lpszValueName = new TCHAR[++dwMaxValueNameLen];
	LPBYTE lpbValue = new BYTE [dwMaxValueLen];
	
	DWORD dwKeyLen;
	DWORD dwValueNameLen;
	DWORD dwValueType;
	DWORD dwValueLen;
	

	// Perhaps use the EX one
	retVal = RegCreateKey(in_hKeyDest, in_lpszSubKeyDest, &hNewKey);
	if (retVal)
		return retVal;

	DWORD dCounter;

	// Iterate through the values, copy them
	for (dCounter = 0; dCounter < dwNumValues; dCounter++)
	{
		dwValueLen = dwMaxValueLen;
		dwValueNameLen = dwMaxValueNameLen;
		retVal = RegEnumValue(hKey, dCounter, lpszValueName, &dwValueNameLen, NULL, &dwValueType, lpbValue, &dwValueLen);
		if (retVal)
			return retVal;

		retVal = RegSetValueEx(hNewKey, lpszValueName, NULL, dwValueType, lpbValue, dwValueLen);
		if (retVal)
			return retVal;
	}

	// Iterate over each subkey.  Call recursively on each
	for (dCounter = 0; dCounter < dwNumSubKeys; dCounter++)
	{
		dwKeyLen = dwMaxSubKeyLen; 
		retVal = RegEnumKeyEx(hKey, dCounter, lpszKeyName, &dwKeyLen, NULL, NULL, NULL, NULL);
		if (retVal)
			return retVal;
		
		retVal = CopyKeyHierarchy(hKey, lpszKeyName, hNewKey, lpszKeyName);
		if (retVal)
			return retVal;
	}
	
	// Cleanup
	retVal = RegCloseKey(hKey);
	if (retVal)
		return retVal;

	retVal = RegCloseKey(hNewKey);
	if (retVal)
		return retVal;

	delete lpszKeyName;
	delete lpszValueName;
	delete lpbValue;

	return retVal;
}

//
// DeleteKeyHierarchy(...)
//
LONG DeleteKeyHierarchy (HKEY in_hKey, LPTSTR in_lpszSubKey)
{
	LONG retVal;

	DWORD dwNumSubKeys;
	DWORD dwMaxSubKeyLen;

	HKEY  hKey;

	retVal = RegOpenKey(in_hKey,in_lpszSubKey, &hKey);
	if (retVal)
		return retVal;

	// Get info about the key
	retVal = RegQueryInfoKey(hKey, 
				    NULL,
					NULL,
					NULL,
					&dwNumSubKeys,
					&dwMaxSubKeyLen,
					NULL,
					NULL,
					NULL,
					NULL,
					NULL,
					NULL);
	if (retVal)
		return retVal;


	LPTSTR lpszKeyName = new TCHAR[++dwMaxSubKeyLen];
	DWORD dwKeyLen;

	// Iterate over the keys, calling recursively on each.
	for (DWORD dCounter = 0; dCounter < dwNumSubKeys; dCounter++)
	{
		dwKeyLen = dwMaxSubKeyLen; 
		// Note, we alwasy ask for "0" as when we delete the 0th, the 1st becomes 0th and so on.
		retVal = RegEnumKeyEx(hKey, 0, lpszKeyName, &dwKeyLen, NULL, NULL, NULL, NULL);
		if (retVal)
			return retVal;
		
		retVal = DeleteKeyHierarchy(hKey, lpszKeyName);
		if (retVal)
			return retVal;
	}

	// Now that children are gone, delete ourselves
	retVal = RegDeleteKey(hKey, NULL);
	if (retVal)
		return retVal;

	
	// Cleanup
	retVal = RegCloseKey(hKey);
	if (retVal)
		return retVal;
	delete lpszKeyName;

	return retVal;
}

//
// RenameKey(...)
//
LONG RenameKey (HKEY in_hKeySrc, LPTSTR in_lpszSubKeySrc, HKEY in_hKeyDest, LPTSTR in_lpszSubKeyDest)
{
	LONG retVal;

	retVal = CopyKeyHierarchy (in_hKeySrc, in_lpszSubKeySrc, in_hKeyDest, in_lpszSubKeyDest);
	if (retVal)
		return retVal;

	retVal = DeleteKeyHierarchy (in_hKeySrc, in_lpszSubKeySrc);
	if (retVal)
		return retVal;

	return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\utilities\ppini.cpp ===
//-----------------------------------------------------------------------------
//
//  @doc
//
//  @module ppini.cpp | Passport ini file parsing
//
//  Author: stevefu
//
//  Date:   05/27/2000
//
//  Copyright <cp> 1999-2000 Microsoft Corporation.  All Rights Reserved.
//
//-----------------------------------------------------------------------------

#include "stdafx.h"
#include <tchar.h>
#include "pputils.h"
#include "passportfile.hpp"

const int MAX_INI_LINE_LEN=2048;

// INI parsing state enum
enum INI_PARSE_STATE {
	INI_PARSE_NORMAL = 0,
	INI_PARSE_FOUND_SEC,	
	INI_PARSE_LINE_CNT,
    INI_PARSE_NEXTSEC,
};

//--------------------------------------------------------------------------
//	@func GetPrivateProfilePairs | parse a particular INI section and 
//   return the key/value pairs in an array. 
//   you could load multiple sections at once by combining the seciton
//   names in the format of "section1|section2|...\0".  
//  @rdesc return FALSE if section not found.
//--------------------------------------------------------------------------
BOOL GetPrivateProfilePairs(
  			LPCTSTR lpFileName,      //@parm initialization file name
  			LPCTSTR lpSectionName,   //@parm section name. you can specify
  			                         // multiple sections by separating them
  			                         // with "|": section1|section2|...\0
  			CAtlArray<IniSettingPair>& nvarray //@parm return value array 
            )
{

	BOOL bRtn = TRUE;
	PassportFile fConfigIni;  // smart class. close itself
	unsigned uState = INI_PARSE_NORMAL;
	BOOL     bFoundSection = FALSE;
	TCHAR    linebuff[MAX_INI_LINE_LEN];
	CString  strLine;
	CString  strSection;
	int      len, i;

	if ( !fConfigIni.Open(lpFileName, TEXT("r")) ) 
	{
		bRtn = FALSE;
		goto done;
	}	

	nvarray.RemoveAll();	
	strLine.Preallocate(MAX_INI_LINE_LEN);
	strSection.Preallocate(MAX_INI_LINE_LEN);
	
	// construct a list of section names in format of "[section1][section2]..."
	strSection = CString("[") + lpSectionName + TEXT("]") ;
	strSection.Replace( TEXT("|"), TEXT("][") );

	uState = INI_PARSE_NORMAL;
    do
	{
		// skip to the needed section
		while ( uState == INI_PARSE_NEXTSEC ||
               (len = fConfigIni.ReadLine(linebuff, MAX_INI_LINE_LEN)) >= 0 )
		{
            // trim tailing space
            for ( i = len-1; i >= 0 
                  && linebuff[i] == TEXT(' '); i--) linebuff[i] = TEXT('\0');			
			// see if we have a matched section name
            if ( linebuff[0] == TEXT('[') && -1 != strSection.Find(linebuff) )
			{
				uState = INI_PARSE_FOUND_SEC;
				break;
			}
            else
            {
                uState = INI_PARSE_NORMAL;
            }
		}		
		if ( uState != INI_PARSE_FOUND_SEC )
		{
			bRtn = bFoundSection;
			goto done;
		}
		else
		{
			bFoundSection = TRUE;
		}
		
		// now parse this section
		strLine = "";
        uState = INI_PARSE_NORMAL;
		while ( (len = fConfigIni.ReadLine(linebuff, MAX_INI_LINE_LEN)) >= 0 )
		{
            // next section begins
            if ( linebuff[0] == TEXT('[') ) 
            {  
                uState = INI_PARSE_NEXTSEC;
                break;    
            }

            // comment line
			if ( linebuff[0] == TEXT(';') ) continue; 
			
            // previous line continuation
            if ( uState == INI_PARSE_LINE_CNT )
			{
				strLine += linebuff;
			}

            // next line continuation
			if ( linebuff[len-1] == TEXT('\\') )
			{
				uState = INI_PARSE_LINE_CNT;
				linebuff[len-1] = TEXT('\0');
				continue;
			}

			// got a valid line
			uState = INI_PARSE_NORMAL;
			strLine += linebuff;
			strLine.TrimLeft();
			strLine.TrimRight();
			if ( ( i = strLine.Find(TEXT('=')) ) != -1 )
			{
				IniSettingPair nvset;
				nvset.strIniKey  = strLine.Left(i);
				nvset.strIniKey.TrimLeft();
				nvset.strIniKey.TrimRight();
				nvset.strIniValue = strLine.Mid(i+1);
				nvset.strIniValue.TrimLeft();
				nvset.strIniValue.TrimRight();
				nvarray.Add(nvset);
			}
			strLine = "";
		}
	}
	while ( len > 0 ) ;
	
done:
	return bRtn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\utilities\pptrace.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    pptrace.cxx

Abstract:

    Debugging functions for Passport DLL

Author:

    Danpo Zhang (danpoz) 2-May-2000

Environment:

    Win32(s) user-mode DLL

Revision History:

--*/

#include <stdafx.h>
#include <tchar.h>
#include <ole2.h>
#include <wmistr.h>
#include <evntrace.h>
#include <pptrace.h>

GUID TransactionGuid = 
    {0xce5b1020, 0x8ea9, 0x11d0, 0xa4, 0xec, 0x00, 0xa0, 0xc9, 0x06, 0x29, 0x10};

TRACE_GUID_REGISTRATION TraceGuidReg[] =
{
    { (LPGUID)&TransactionGuid,
      NULL
    }
};

typedef struct _USER_MOF_EVENT {
    EVENT_TRACE_HEADER    Header;
    MOF_FIELD             mofData;
} USER_MOF_EVENT, *PUSER_MOF_EVENT;


TRACEHANDLE LoggerHandle;
TRACEHANDLE RegistrationHandle;

namespace PPTraceStatus {
	bool TraceOnFlag = false;
	UCHAR EnableLevel = 0;
	ULONG EnableFlags = 0;
}

// TRACEHANDLE is typedefed as ULONG64
ULONG64 GetTraceHandle()
    {
    return LoggerHandle;
    }

// TRACEHANDLE is typedefed as ULONG64
void SetTraceHandle(ULONG64 TraceHandle)
    {
    LoggerHandle = TraceHandle;
    }

// unicode version
ULONG TraceString(UCHAR Level, IN LPCWSTR wszBuf) 
{
	ULONG status;
//	WCHAR   strMofData[MAXSTR];
    PMOF_FIELD          mofField;
    USER_MOF_EVENT      UserMofEvent;

    RtlZeroMemory(&UserMofEvent, sizeof(UserMofEvent));

 	UserMofEvent.Header.Class.Type = EVENT_TRACE_TYPE_INFO;
 	UserMofEvent.Header.Class.Level = Level;

    UserMofEvent.Header.Size  = sizeof(UserMofEvent);
    UserMofEvent.Header.Flags = WNODE_FLAG_TRACED_GUID;
    UserMofEvent.Header.Guid  = TransactionGuid;
    UserMofEvent.Header.Flags |= WNODE_FLAG_USE_MOF_PTR;

//  wcscpy(strMofData, wszBuf);
	mofField          = (PMOF_FIELD) & UserMofEvent.mofData;
//	mofField->DataPtr = (ULONGLONG) (strMofData);
	mofField->DataPtr = (ULONGLONG) (wszBuf);
	mofField->Length  = sizeof(WCHAR) * (wcslen(wszBuf) + 1);

	status = TraceEvent(LoggerHandle, (PEVENT_TRACE_HEADER) & UserMofEvent);

	return status;
}

// ansi version
ULONG TraceString(UCHAR Level, IN LPCSTR szBuf) 
{
	ULONG status;
    PMOF_FIELD          mofField;
    USER_MOF_EVENT      UserMofEvent;

    RtlZeroMemory(&UserMofEvent, sizeof(UserMofEvent));

 	UserMofEvent.Header.Class.Type = EVENT_TRACE_TYPE_INFO;
 	UserMofEvent.Header.Class.Level = Level;

    UserMofEvent.Header.Size  = sizeof(UserMofEvent);
    UserMofEvent.Header.Flags = WNODE_FLAG_TRACED_GUID;
    UserMofEvent.Header.Guid  = TransactionGuid;
    UserMofEvent.Header.Flags |= WNODE_FLAG_USE_MOF_PTR;

	mofField          = (PMOF_FIELD) & UserMofEvent.mofData;
	mofField->DataPtr = (ULONGLONG) (szBuf);
	mofField->Length  = sizeof(CHAR) * (strlen(szBuf) + 1);

	status = TraceEvent(LoggerHandle, (PEVENT_TRACE_HEADER) & UserMofEvent);

	return status;
}

ULONG
ControlCallback(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID Context,
    IN OUT ULONG *InOutBufferSize,
    IN OUT PVOID Buffer
    )
{
    ULONG Status;
    ULONG RetSize;

    Status = ERROR_SUCCESS;

    switch (RequestCode)
    {
        case WMI_ENABLE_EVENTS:
        {
            RetSize = 0;
            LoggerHandle = GetTraceLoggerHandle( Buffer );
            PPTraceStatus::EnableLevel = GetTraceEnableLevel(LoggerHandle);
            PPTraceStatus::EnableFlags = GetTraceEnableFlags(LoggerHandle);
//            _tprintf(_T("Logging enabled to 0x%016I64x(%d,%d,%d) for %s\n"),
//                    LoggerHandle, RequestCode, EnableLevel, EnableFlags, (LPSTR)Context);
            PPTraceStatus::TraceOnFlag = true;
            break;
        }
        case WMI_DISABLE_EVENTS:
        {
            PPTraceStatus::TraceOnFlag = false;
            RetSize = 0;
            LoggerHandle = 0;
//            _tprintf(_T("\nLogging Disabled\n"));
            break;
        }
        default:
        {
            RetSize = 0;
            Status = ERROR_INVALID_PARAMETER;
            break;
        }

    }

    *InOutBufferSize = RetSize;
    return(Status);
}

ULONG PPInitTrace(LPGUID pControlGuid)
{
    ULONG Status;
    PPTraceStatus::TraceOnFlag = false;

    Status = RegisterTraceGuids(
                (WMIDPREQUEST)ControlCallback,
                NULL,     // Optional RequestContext
                (LPGUID)pControlGuid,
                1,
                TraceGuidReg,
				NULL,                 // Optional WMI - MOFImagePath
				NULL,                 // Optional WMI - MOFResourceName
                &RegistrationHandle);

    if (Status != ERROR_SUCCESS) {
        _tprintf(_T("Trace registration failed\n"));
    }
    else {
        _tprintf(_T("Trace registered successfully\n"));
    }

    return(Status);
}

ULONG PPEndTrace()
{
    return (UnregisterTraceGuids(RegistrationHandle));
}



VOID
TracePrint(
    UCHAR  Level,
	LPCSTR szFileAndLine,
    LPCSTR ParameterList OPTIONAL,
    ...
)
{
	//  no data generated for the following two cases
    if (!PPTraceStatus::TraceOnFlag || Level > PPTraceStatus::EnableLevel)
		return;

    CHAR buf[MAXSTR];
	int len = 0;
    
    if (ARGUMENT_PRESENT(ParameterList)) {
            va_list parms;
            va_start(parms, ParameterList);
            len = _vsnprintf(buf, MAXSTR-1, (CHAR*)ParameterList, parms);
 			if (len < 0) len = MAXSTR - 1;
            va_end(parms);
    }

	if (len < (MAXSTR - 1))
	{
		CHAR* pStr = strrchr(szFileAndLine, '\\');
		if (pStr)
		{
			pStr++;
			_snprintf(buf+len, MAXSTR-len-1, "@%s", pStr);
		}
	}
    
    TraceString(Level, buf);
}

CTraceFuncVoid::CTraceFuncVoid(UCHAR Level, LPCSTR szFileAndLine, LPCSTR szFuncName, LPCSTR ParameterList, ...) : m_Level(Level)
	{
		//  no data generated for the following two cases
		if (!PPTraceStatus::TraceOnFlag || m_Level > PPTraceStatus::EnableLevel)
			return;

		strncpy(m_szFuncName, szFuncName, MAXNAME-1);

		CHAR buf[MAXSTR];
    
		int len = _snprintf(buf, MAXSTR-1, "+%s(", m_szFuncName);
		int count = 0;
		if (ARGUMENT_PRESENT(ParameterList)) {
				va_list parms;
				va_start(parms, ParameterList);
				count = _vsnprintf(buf+len, MAXSTR-len-1, (CHAR*)ParameterList, parms);
				len = (count > 0) ? len + count : MAXSTR - 1;
				va_end(parms);
		}
		if (len < (MAXSTR - 1))
		{
			CHAR* pStr = strrchr(szFileAndLine, '\\');
			if (pStr)
			{
				pStr++; //remove '\'
				_snprintf(buf+len, MAXSTR-len-1, ")@%s", pStr);
			}
		}

		TraceString(m_Level, buf); 
	};

CTraceFuncVoid::~CTraceFuncVoid()
	{
		//  no data generated for the following two cases
		if (!PPTraceStatus::TraceOnFlag || m_Level > PPTraceStatus::EnableLevel)
			return;
		
		std::ostringstream ost;
		ost << "-" << m_szFuncName << "()";  
		TraceString(m_Level, ost.str().c_str()); 
	};

//////////////////////////////////////////////////////////////////////
// CFunctTrace Class
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

/*
CTraceFunc::CTraceFunc(UCHAR Level, LPCSTR szFile, DWORD dwLine, LPCSTR szFuncName, HRESULT & hr, LPCSTR ParameterList OPTIONAL, ...): m_Level(Level), m_hr(hr)
{
	//  no data generated for the following two cases
    if (!PPTraceStatus::TraceOnFlag || m_Level > PPTraceStatus::EnableLevel)
		return;

    strncpy(m_szFuncName, szFuncName, MAXNAME-1);

    CHAR buf[MAXSTR];
    
	int len = _snprintf(buf, MAXSTR-1, "%s_%d:+%s(", szFile, dwLine, m_szFuncName);
	int count = 0;
    if (ARGUMENT_PRESENT(ParameterList)) {
            va_list parms;
            va_start(parms, ParameterList);
            count = _vsnprintf(buf+len, MAXSTR-len-1, (CHAR*)ParameterList, parms);
			len = (count > 0) ? len + count : MAXSTR - 1;
            va_end(parms);
    }
	if (len < (MAXSTR - 1))
		sprintf(buf+len, ")");

	TraceString(m_Level, buf); 
}

CTraceFunc::~CTraceFunc()
{
	//  no data generated for the following two cases
    if (!TraceOnFlag || m_Level > EnableLevel)
		return;

    CHAR buf[MAXSTR];
	_snprintf(buf, MAXSTR-1, "-%s(hr=%X)", m_szFuncName, m_hr); 
	TraceString(m_Level, buf); 
}
*/
// old tracing stuff
printit(UINT level,LPCSTR str)
{
    printf(str);
    return 0;
}

VOID
PPInitTrace(LPWSTR wszAppName)
{
    //WPP_INIT_TRACING(wszAppName);
//    WPP_INIT_TRACING_EX(wszAppName, (WMLPRINTFUNC)printit);
	return;
}

VOID
PPFuncEnter(
    DWORD Category,
    LPCSTR Function,
    LPCSTR ParameterList OPTIONAL,
    ...
)
{
#if 0
    char buf[MAXSTR];
	int len = _snprintf(buf, MAXSTR-1, "+%s(", Function);
	int count = 0;
    if (ARGUMENT_PRESENT(ParameterList)) {

            va_list parms;
            va_start(parms, ParameterList);
            count = _vsnprintf(buf+len, MAXSTR-len-1, (CHAR*)ParameterList, parms);
			len = (count > 0) ? len + count : MAXSTR - 1;
            va_end(parms);
    }
	if (len < (MAXSTR - 1))
		sprintf(buf+len, ")");

    //printf(buf);
    //printf("\n");
//    DoTraceMessage(1, "%s",  LOGASTR(buf) );
    TraceString( 0 , buf );
#endif
}

VOID
PPFuncLeave(
    IN DWORD Category,
    IN TRACE_FUNCTION_RETURN_TYPE ReturnType,
    IN DWORD_PTR Variable,
    IN LPCSTR Function,
    IN LPCSTR ParameterList,
    ...
    )
{

    LPSTR format;
    BOOL noVar;
    DWORD lastError;

    char buf[MAXSTR];
    LPSTR bufptr;

    bufptr = buf;
    *bufptr = '\0';
    bufptr += sprintf(bufptr, "-%s(", Function);

    lastError = GetLastError();

    noVar = FALSE;
    switch (ReturnType) {
        case None:
            format = "return: VOID";
            noVar = TRUE;
            break;

        case Bool:
            Variable = (DWORD_PTR)(Variable ? "TRUE" : "FALSE");
            //
            // fall through (so that it prints the string)
            //

        case String:
                format = "return: %s";
                break;

        case WString:
                format = "return: %S";
                break;

        case Int:
                format = "return: %d";
                break;

        case Dword:
                format = "return: %u";
                break;

        case HResult:
                format = "return: %X";
                break;

        case Pointer:
                if (Variable == 0) {
                    format = "return: NULL";
                    noVar = TRUE;
                } else {
                    format = "return: %#x";
                }
                break;

            default:
                break;
    }

    if( !noVar )
    {
        bufptr += sprintf(bufptr, format, Variable);
    }
    else
    {
        bufptr += sprintf(bufptr, format);
    }

    if (ARGUMENT_PRESENT(ParameterList)) {

            va_list parms;

            va_start(parms, ParameterList);

            bufptr += vsprintf(bufptr, (char*)ParameterList, parms);
            va_end(parms);
    }
    sprintf(bufptr, ")");


    //
    // refresh the last error, in case it was nuked
    //
    SetLastError(lastError);

//    DoTraceMessage(1, "%s",  LOGASTR(buf) );
    TraceString( 0 , buf );

}

VOID
PPTrace(
    DWORD  Category,
    DWORD  Level,
    LPCSTR ParameterList OPTIONAL,
    ...
)
{
#if 0
    char buf[MAXSTR];
    
    if (ARGUMENT_PRESENT(ParameterList)) {
            va_list parms;
            va_start(parms, ParameterList);
            _vsnprintf(buf, MAXSTR-1, (char*)ParameterList, parms);
            va_end(parms);
    }
    
//    DoTraceMessage( 1 /*Category|Level*/ , "%s",  LOGASTR(buf) );
    TraceString( 0 , buf );
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\utilities\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	pputils.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\utilities\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__2D93832A_D6E0_4D64_8855_9434DA399837__INCLUDED_)
#define AFX_STDAFX_H__2D93832A_D6E0_4D64_8855_9434DA399837__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <atlbase.h>
#include <atlstr.h>
#include <atlutil.h>
#include <atlisapi.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__2D93832A_D6E0_4D64_8855_9434DA399837__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\utilities\urlfunctions.cpp ===
//-----------------------------------------------------------------------------
//
//  @doc
//
//  @module UrlFunctions.cpp | Generic functions for constructing URLs.
//
//  Author: Darren Anderson
//
//  Date:   5/17/00
//
//-----------------------------------------------------------------------------

#include "stdafx.h"
#include "ppurl.h"
#include "UrlFunctions.h"
#include "BaseHandlerHelper.h"

void
RootUrl(
    bool        bSecure,
    CPPUrl&     rootUrl
    )
{
    CStringA cszUrl;

    cszUrl = "http";

    if(bSecure)
        cszUrl += "s";

	cszUrl += "://";

    CStringA cszServer;
    GetAServerVariable("SERVER_NAME", cszServer);

    cszUrl += cszServer;

    rootUrl.Set(cszUrl);
}


// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\atlpool.h ===
#ifndef __ATLPOOL_H_
#define __ATLPOOL_H_

#include <atlbase.h>
#include <atlcom.h>
#include "PassportObjectPool.hpp"

//Base is the user's class that derives from CComObjectRoot and whatever
//interfaces the user wants to support on the object

template <class Base>
class CComObjectPooled : public Base
{
public:
	typedef Base _BaseClass;

    CComObjectPooled(void* = NULL) : m_Pool(NULL)
	{
		_Module.Lock();
	}
	// Set refcount to 1 to protect destruction
	~CComObjectPooled()
	{
		m_dwRef = 1L;
		FinalRelease();
#ifdef _ATL_DEBUG_INTERFACES
		_Module.DeleteNonAddRefThunk(_GetRawUnknown());
#endif
		_Module.Unlock();
	}
	//If InternalAddRef or InternalRelease is undefined then your class
	//doesn't derive from CComObjectRoot
	STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
	STDMETHOD_(ULONG, Release)()
	{
		ULONG l = InternalRelease();
		if (l == 0 && m_Pool)
			m_Pool->checkin(this);
		return l;
	}
	//if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{return _InternalQueryInterface(iid, ppvObject);}
	template <class Q>
	HRESULT STDMETHODCALLTYPE QueryInterface(Q** pp)
	{
		return QueryInterface(__uuidof(Q), (void**)pp);
	}

    void SetPool(PassportObjectPool< CComObjectPooled<Base> >* pPool)
    {
        m_Pool = pPool;
    }

private:

    void*       m_Releaser;

    PassportObjectPool< CComObjectPooled<Base> > *m_Pool;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\birthdatefunctions.h ===
//-----------------------------------------------------------------------------
//
//  @doc
//
//  @module BirthdateFunctions.h |  Birthdate specific functions.
//
//  Author: Darren Anderson
//
//  Date:   4/26/00
//
//  Copyright <cp> 1999-2000 Microsoft Corporation.  All Rights Reserved.
//
//-----------------------------------------------------------------------------
#pragma once


bool IsUnder13(DATE dtBirthdate);
bool IsUnder18(DATE dtBirthdate);
bool IsUnder(DATE dtBirthdate, USHORT ulAge);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\utilities\_tracewpp.h ===
//1c1b4ffa Generated File. Do not edit.
// File created by WPP compiler version 0.01-Sat Apr  1 17:27:32 2000
// on 06/22/2000 at 17:38:45 UTC
//   
//   Source files: pptrace.cpp.

enum WPP_FILES {WPP_FILE_pptrace_cpp,};

//
// Unless disabled, WPP selects one of the source
// files as a "guid store". That file will have definitions
// of trace and control arrays
//
#if defined(PPTRACE_CPP)
#define WPP_DEFINE_ARRAYS
#endif
 
#if !defined(WPP_ARRAYSIZE)
#  define WPP_ARRAYSIZE(_array_) ( sizeof(_array_) / sizeof( (_array_)[0] ) )
#endif

//
// if your project contains multiple directories and you want to share
// the same control guids. #define WPP_CONTROL_GUID_ARRAY YourSharedControlGuidsArrayName
//

#if !defined(WPP_CONTROL_GUID_ARRAY)
#  define WPP_CONTROL_GUID_ARRAY Utilities_wpp_ControlGuids
#else
#  define WPP_DECLARE_CONTROL_GUIDS
#  define Utilities_wpp_ControlGuids WPP_CONTROL_GUID_ARRAY
#endif

//
// Define default flavors of the trace macro
//

#if defined(WMLUM_H) 
extern WML_DATA WmlData;
#  define WPP_TRACE_MESSAGE(_lh,_fl,_guid,_id,_msg,_arg) (*WmlData.Trace)(_id,&_guid,_lh,_arg)
#  define WPP_DECLARE_CONTROL_GUIDS
#  define WML_CONTROL_GUID_REG WML_REG_STRUCT
#elif defined(WMLKM_H)
#  define WPP_TRACE_MESSAGE(_lh,_fl,_guid,_id,_msg,_arg) WmlTrace(_id,&_guid,_lh,_arg)
#  define WPP_DECLARE_CONTROL_GUIDS
#else
#  define WPP_PTRLEN
#  define WPP_USE_WmiTraceMessage
#  if defined(WPP_KERNEL_MODE)
#     define WPP_WMI_TRACE_MESSAGE WmiTraceMessage
#  else
#     define WPP_WMI_TRACE_MESSAGE TraceMessage
#  endif
#  define WPP_TRACE_MESSAGE(_lh,_fl,_guid,_id,_msg,_arg) WPP_WMI_TRACE_MESSAGE(_lh,_fl,&(_guid),_id,_arg)
#endif

#if defined(WPP_ARRAY_DEFINITIONS_ONLY)
#  define WPP_DEFINE_TRACE_GUIDS
#  define WPP_DEFINE_CONTROL_GUIDS
#else
#  define WPP_LOCAL_DEFINITIONS
#endif

#if defined(WPP_DEFINE_ARRAYS)
#  define WPP_DEFINE_TRACE_GUIDS
#  define WPP_DEFINE_CONTROL_GUIDS
#endif

#if !defined(WPP_TRACE_OPTIONS)
#  if defined(WPP_USE_WmiTraceMessage)
#    define WPP_TRACE_OPTIONS (TRACE_MESSAGE_SEQUENCE|TRACE_MESSAGE_GUID|TRACE_MESSAGE_TIMESTAMP|TRACE_MESSAGE_SYSTEMINFO)
#  else
#    define WPP_TRACE_OPTIONS 0
#  endif
#endif

#define NOARGS // Yep. No args, alright.

#if defined(WPP_LOCAL_DEFINITIONS)

#if !defined(WPP_DEFINE_GRP_ID) && !defined(WPP_CTRL_FLAGS) && !defined(WPP_CTRL_GUID_NO)
#  define WPP_DEFINE_GRP_ID(_a,_b) ( ((_a) << 16) | ( _b) )
#  define WPP_CTRL_FLAGS(_id)      (1 << ((_id) & 0xFFFF) )
#  define WPP_CTRL_GUID_NO(_id)    ((_id) >> 16)
#endif // WPP_DEFINE_GRP_ID

#if defined(DEFINE_GROUP_IDS)
#  define GRP_ID_1	WPP_DEFINE_GRP_ID(0,0) // pptrace_cpp79 pptrace_cpp179
#  define GRP_ID_1 /*Category|Level*/	WPP_DEFINE_GRP_ID(0,1) // pptrace_cpp206
#endif

#if !defined(WPP_DEFINE_MSG_ID)
#  define WPP_DEFINE_MSG_ID(_a,_b)   ( ((_a) << 16) | ( _b) )
#  define WPP_MSG_NO(_id)            ((_id) & 0xFFFF)
#  define WPP_TRACE_GUID_NO(_id)     ((_id) >> 16)
#endif // WPP_DEFINE_MSG_ID

#if !defined(WPP_TRACE_GUID)
#define WPP_TRACE_GUID(_ArrayPrefix_,_Id_) (_ArrayPrefix_ ## TraceGuids[ WPP_TRACE_GUID_NO(_Id_) ] )
#endif

#if !defined(WPP_LOGGER_HANDLE)
#define WPP_LOGGER_HANDLE(_ArrayPrefix_,_Id_) (_ArrayPrefix_ ## ControlGuids[ WPP_CTRL_GUID_NO(_Id_) ].LoggerHandle )
#define WPP_ENABLED(_ArrayPrefix_,_Id_) \
	(_ArrayPrefix_ ## ControlGuids[ WPP_CTRL_GUID_NO(_Id_) ].EnableFlags & WPP_CTRL_FLAGS(_Id_) )
#endif

#define LOGARSTR(_Value_)	WPP_LOGASTR( _Value_ )
#define LOGASTR(_Value_)	WPP_LOGASTR( _Value_ )
 
#  define MSG_ID_pptrace_cpp179	WPP_DEFINE_MSG_ID(0,11)
#  define MSG_ID_pptrace_cpp206	WPP_DEFINE_MSG_ID(0,12)
#  define MSG_ID_pptrace_cpp79	WPP_DEFINE_MSG_ID(0,10)
 
extern GUID                         Utilities_wpp_TraceGuids[]; 
#define Utilities_wpp_TraceGuids_len    1      // I don't think we need this [BUGBUG]


#if defined(WPP_KERNEL_MODE) && !defined(WMLKM_H)
#  undef WPP_DEFINE_CONTROL_GUIDS
#  undef WPP_DECLARE_CONTROL_GUIDS
#endif

#if defined(WPP_DECLARE_CONTROL_GUIDS)
extern WML_CONTROL_GUID_REG         WPP_CONTROL_GUID_ARRAY[]; 
#endif

#endif // defined(WPP_LOCAL_DEFINITIONS)

#ifdef WPP_DEFINE_TRACE_GUIDS
#if 1
GUID Utilities_wpp_TraceGuids[] = {
 // 0a029043-f647-449d-8850-d413b9053365 pptrace.cpp
 {0x0a029043,0xf647,0x449d,{0x88,0x50,0xd4,0x13,0xb9,0x05,0x33,0x65}}, // pptrace.cpp
};
#endif
#endif // WPP_DEFINE_TRACE_GUIDS

#if defined(WMLUM_H)
# define WPP_INIT_TRACING_EX(AppName, PrintFunc) \
    do { \
        DWORD status; \
	LOADWML(status, WmlData); \
	if (status == ERROR_SUCCESS) { \
		status = (*WmlData.Initialize)( \
			   AppName, \
			   PrintFunc, \
                           &WmlData.WmiRegHandle, \
			   L"Default", &WPP_CONTROL_GUID_ARRAY[0], 0); \
	} \
    } while(0)
# define WPP_INIT_TRACING(AppName) WPP_INIT_TRACING_EX(AppName, NULL)
#endif

#ifdef WPP_DEFINE_CONTROL_GUIDS
  #if defined(WMLUM_H) 
     WML_DATA WmlData;
  #endif

# if !defined(WMLKM_H)
    WML_CONTROL_GUID_REG WPP_CONTROL_GUID_ARRAY[1];
# else
WML_CONTROL_GUID_REG WPP_CONTROL_GUID_ARRAY[] = {
 {// 79cb5074-2492-438b-bc33-8c4547963f66 
   {0x79cb5074,0x2492,0x438b,{0xbc,0x33,0x8c,0x45,0x47,0x96,0x3f,0x66}}}, // 
};
#endif
#endif // WPP_DEFINE_CONTROL_GUIDS

#if defined(WPP_LOCAL_DEFINITIONS)

#if !defined(WPP_DEFAULT_GROUP_ID)
  #define WPP_DEFAULT_GROUP_ID WPP_DEFINE_GRP_ID(0,0)
#endif

#if !defined(DoTraceMessage)
#define DoTraceMessage(GRP, MSG, ARG) WPP_LOG(Utilities_wpp_, GRP, MSG_ID_ ## WPP_AUTO_ID, MSG, ARG -0)
#endif
#if !defined(SimpleTraceMessage)
#define SimpleTraceMessage(MSG, ARG) WPP_LOG(Utilities_wpp_, WPP_DEFAULT_GROUP_ID, MSG_ID_ ## WPP_AUTO_ID, MSG, ARG -0)
#endif
#if !defined(SimpleTracemessageEx)
#define SimpleTracemessageEx(GRP, MSG, ARG) WPP_LOG(Utilities_wpp_, GRP, MSG_ID_ ## WPP_AUTO_ID, MSG, ARG -0)
#endif
#if 0 // Real check is done in elif
#elif defined(PPTRACE_CPP) // pptrace.cpp
#	define WPP_THIS_FILE pptrace_cpp
#endif 

#define WPP_EVAL(_value_) _value_
#define MSG_ID_WPP_AUTO_ID WPP_EVAL(MSG_ID_) ## WPP_EVAL(WPP_THIS_FILE) ## WPP_EVAL(__LINE__)

//
// WPP_CHECKED_ZERO will be expanded to 0, if 
// expression _value has the same size as the type _Type,
// or to division by 0, if the sizes are different
//
// This is poor man compile time argument checking. So don't be surprised
// if a compiler will tell you suddenly that you have a division by 0
// in line such and such
//

#define WPP_CHECKED_ZERO(_Value, _Type) \
    (0 * (1/(int)!(sizeof(_Type) - sizeof(_Value) )))

#define WPP_CHECKED_SIZEOF(_Value, _Type) \
    (sizeof(_Value) + WPP_CHECKED_ZERO( _Value, _Type) )

#if !defined(WPP_PRINTF_STYLE)

#if defined(WPP_PTRLEN)
#  define WPP_LOGPAIR(_Size, _Addr) (_Addr),(_Size),
#else
#  define WPP_LOGPAIR(_Size, _Addr) (_Size),(_Addr),
#endif

# define WPP_LOGTYPEVAL(_Type, _Value) \
    WPP_LOGPAIR(WPP_CHECKED_SIZEOF(_Value, _Type), &(_Value))

# define WPP_LOGASTR(_value) \
    WPP_LOGPAIR( strlen(_value) + WPP_CHECKED_SIZEOF((_value)[0],CHAR), _value )

# define WPP_LOGWSTR(_value) \
    WPP_LOGPAIR( wcslen(_value) * sizeof(WCHAR) + WPP_CHECKED_SIZEOF((_value)[0],WCHAR), _value)

# define WPP_LOGCSTR(_x) \
    WPP_LOGPAIR( sizeof((_x).Length) + WPP_CHECKED_ZERO(_x,STRING), &(_x).Length ) \
    WPP_LOGPAIR( (_x).Length, (_x).Buffer )

# define WPP_LOGUSTR(_x)                                                            \
    WPP_LOGPAIR( WPP_CHECKED_SIZEOF((_x).Length, short)                        \
                    + WPP_CHECKED_ZERO((_x),UNICODE_STRING), &(_x).Length)  \
    WPP_LOGPAIR( (_x).Length, (_x).Buffer )

#  if !defined(WPP_LOG)
#  define WPP_LOG(_ArrayPrefix_, _Group_, _Id_, _Msg_, _Args_) \
       if (!WPP_ENABLED(_ArrayPrefix_, _Group_)) {;} else \
           WPP_TRACE_MESSAGE(WPP_LOGGER_HANDLE(_ArrayPrefix_, _Group_), \
                             WPP_TRACE_OPTIONS, \
                             WPP_TRACE_GUID(_ArrayPrefix_,_Id_), \
                             WPP_MSG_NO(_Id_), _Msg_, _Args_)
#  endif

#else

// no printf style so far

#endif // defined(WPP_PRINTF_STYLE)


#endif // defined(WPP_LOCAL_DEFINITIONS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\binhex.h ===
// BinHex.h: interface for the CBinHex class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_BINHEX_H__1B7F2A63_8878_11D2_B4C8_00C04F9914AB__INCLUDED_)
#define AFX_BINHEX_H__1B7F2A63_8878_11D2_B4C8_00C04F9914AB__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <wtypes.h>
#include <oleauto.h>

#define BBAD (BYTE)-1

class CBinHex  
{
public:

  CBinHex();

  // Prepend makes this a non-generic binhex, but oh well.
  // If it's 0, nothing is prepended
  static HRESULT ToBase64(LPVOID pv, UINT cbSize, char prepend, char ivecnpad[9], BSTR* pbstr); 
  static HRESULT ToBase64ASCII(LPVOID pv, UINT cbSize, char prepend, char ivecnpad[9], BSTR* pbstr); 
  
  HRESULT FromBase64(LPSTR lpStr, UINT cbSize, BSTR* pblob); 
  HRESULT FromWideBase64(BSTR bstr, BSTR* pblob); 
  
  HRESULT PartFromBase64(LPSTR lpStr, BYTE* output, ULONG *numOutBytes);
  HRESULT PartFromWideBase64(LPWSTR bStr, BYTE* output, ULONG *numOutBytes);

protected:
  BYTE m_decodeArray[256];
};

#endif // !defined(AFX_BINHEX_H__1B7F2A63_8878_11D2_B4C8_00C04F9914AB__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\basehandlerhelper.h ===
//-----------------------------------------------------------------------------
//
//  @doc
//
//  @module BaseHandlerHelper.h |  Helper functions for dealing with base
//                                 handler methods.
//
//  Author: Darren Anderson
//
//  Date:   5/16/00
//
//  Copyright <cp> 1999-2000 Microsoft Corporation.  All Rights Reserved.
//
//-----------------------------------------------------------------------------
#pragma once

#include "pphandlerbase.h"

inline void AddGlobalCarryThru(CPPUrl &url)
{
    CPassportHandlerBase* pHandler = CPassportHandlerBase::GetPPHandler();
    return pHandler->AddGlobalCarryThru(url);
}

HRESULT GetGlobalObj(REFGUID objid, REFIID riid, void**pobj);
void GetWParam(LPCSTR szParamName,
               CStringW& cszValue,
               unsigned flag = CPassportHandlerBase::CI_FLAG_DEFAULT);
void GetWFormVar(LPCSTR szParamName,
                 CStringW& cszValue,
                 unsigned flag = CPassportHandlerBase::CI_FLAG_DEFAULT);
long GetParamLong(LPCSTR szParamName);
void GetWCookie(LPCSTR szParamName, 
                CStringW& cszValue,
                unsigned flag = CPassportHandlerBase::CI_FLAG_DEFAULT);
void GetWServerVariable(LPCSTR szParamName, 
                        CStringW& cszValue,
                        unsigned flag = CPassportHandlerBase::CI_FLAG_DEFAULT);
void GetAServerVariable(
    LPCSTR szParamName, 
    CStringA& cszOut, 
    unsigned flag = CPassportHandlerBase::CI_FLAG_DEFAULT);

void GetWItem(LPCSTR szParamName, 
              CStringW& cszValue,
              unsigned flag = CPassportHandlerBase::CI_FLAG_DEFAULT);
void Mbcs2Unicode(LPCSTR  pszIn, BOOL bNEC, CStringW& cszOut);
void Unicode2Mbcs(LPCWSTR pwszIn, BOOL bNEC, CStringA& cszOut);
HRESULT GetDomainAttribute(
                    const BSTR      bstrAttrName,         //@parm the attribute name
                           LPCWSTR pwszDomain,
                           CComBSTR& cbstrValue);
HRESULT GetPartnerAttribute(ULONG ulSiteId, 
                            LPCWSTR pwszAttribute, 
                            CStringW& cszValue);
HRESULT GetPartnerAttribute(ULONG ulSiteId, 
                            LPCWSTR pwszAttribute, 
                            CComBSTR& cszValue);
CPassportLocale* GetRequestLocale();
void GetConfigString(LPCWSTR szItem, CStringW& cszValue);
void GetConfigNumber(LPCWSTR szItem, long& lValue);
void SetCookie(LPCSTR  szCookieName,
               LPCSTR  szCookieValue,
               LPCSTR  szCookieExpiration = NULL,
               LPCSTR  szCookieDomain = NULL,
               LPCSTR  szCookiePath = NULL,
               bool    bSecure = false
               );
void SetCookie(LPCSTR  szCookieName,
               LPCWSTR szCookieValue,
               LPCSTR  szCookieExpiration = NULL,
               LPCSTR  szCookieDomain = NULL,
               LPCSTR  szCookiePath = NULL,
               bool    bSecure = false
               );

// @func	bool | IsHttpsOn | Check if the connection is over SSL
// @rdesc	Return the following values:
// @flag	true	| the connection is over SSL
// @flag	false	| the connection is NOT over SSL
bool IsHttpsOn(void);

inline const PPMGRVer & GetPPMgrVersion()
{
    CPassportHandlerBase* pHandler = CPassportHandlerBase::GetPPHandler();
    return pHandler->GetPPMgrVersion();
}

inline  ULONG ProfileElesToReturn(long browserIndex, long id)
    {
         ULONG ret = (ULONG)-1;

         if(browserIndex == CBrowserInfo::BROWSER_DoCoMo
            || browserIndex == CBrowserInfo::BROWSER_MMEPHONE
            || browserIndex == CBrowserInfo::BROWSER_UP)
         {
             if( id != 0)
             // determine how profile cookie should be generated
             {
               // if needmembername is defined for the partner, (none 0)
               // create profile cookie with membernameonly
               // if needmembername is undefined, or 0, then no profile
               CComBSTR needMemberName;
               HRESULT hr = GetPartnerAttribute(id,
                                     k_cvPartnerAttrNeedsMembername.bstrVal,
                                     needMemberName);

               if(hr == S_OK && needMemberName != NULL && _wtoi(needMemberName) != 0)
                  ret = 1;
               else
                  ret = 0;
             }
             else
               ret = 0;
         }

         return ret;
    }
    


// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\blendedheap.hpp ===
#ifndef _BLENDED_HEAP_HPP_
#define _BLENDED_HEAP_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Rockall.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   A blended heap.                                                */
    /*                                                                  */
    /*   A blended heap tries to provide good performance and           */
    /*   thoughtfull memory layout for a modest cost in terms of        */
    /*   additional memory usage.                                       */
    /*                                                                  */
    /********************************************************************/

class ROCKALL_LINKAGE BLENDED_HEAP : public ROCKALL
    {
   public:
        //
        //   Public functions.
        //
        BLENDED_HEAP
			( 
			int						  MaxFreeSpace = 1048576,
			bool					  Recycle = false,
			bool					  SingleImage = false,
			bool					  ThreadSafe = true 
			);

        ~BLENDED_HEAP( void );

	private:
        //
        //   Disabled operations.
 		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
		//
        BLENDED_HEAP( const BLENDED_HEAP & Copy );

        void operator=( const BLENDED_HEAP & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\bstrdebug.h ===
#ifndef _BSTRDEBUG_H
#define _BSTRDEBUG_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// BSTR debugging.  
// GIVEAWAY is used when someone else will free it
// TAKEOVER is used when you get one you should be freeing

/*
#ifdef MEM_DBG

#define FANDL __FILE__,__LINE__

#define ALLOC_BSTR(x)                         g_allocs.track(SysAllocString(x),FANDL)
#define ALLOC_BSTR_LEN(x,y)                   g_allocs.track(SysAllocStringLen(x,y),FANDL)
#define ALLOC_BSTR_BYTE_LEN(x,y)              g_allocs.track(SysAllocStringByteLen(x,y),FANDL)
#define ALLOC_AND_GIVEAWAY_BSTR(x)            SysAllocString(x)
#define ALLOC_AND_GIVEAWAY_BSTR_LEN(x,y)      SysAllocStringLen(x,y)
#define ALLOC_AND_GIVEAWAY_BSTR_BYTE_LEN(x,y) SysAllocStringByteLen(x,y)
#define GIVEAWAY_BSTR(x)                      g_allocs.release(x,FANDL)
#define TAKEOVER_BSTR(x)                      g_allocs.track(x,FANDL)
#define FREE_BSTR(x)                          { g_allocs.release(x,FANDL); SysFreeString(x);}

#else
*/
#define ALLOC_BSTR(x)                         SysAllocString(x)
#define ALLOC_BSTR_LEN(x,y)                   SysAllocStringLen(x,y)
#define ALLOC_BSTR_BYTE_LEN(x,y)              SysAllocStringByteLen(x,y)
#define ALLOC_AND_GIVEAWAY_BSTR(x)            SysAllocString(x)
#define ALLOC_AND_GIVEAWAY_BSTR_LEN(x,y)      SysAllocStringLen(x,y)
#define ALLOC_AND_GIVEAWAY_BSTR_BYTE_LEN(x,y) SysAllocStringByteLen(x,y)
#define GIVEAWAY_BSTR(x)             
#define TAKEOVER_BSTR(x)
#define FREE_BSTR(x)                          SysFreeString(x)

//#endif

#include "BstrHash.h"

#pragma warning(disable:4786)

class bstrAllocInfo
{
 public:
  bstrAllocInfo(LPSTR f, int i, ULONG n) : file(f), line(i), num(n) {};
  LPSTR file;
  int   line;
  ULONG num; // Which allocation number is this...
};

typedef CGenericHash<long,bstrAllocInfo*> BSTRLEAKMAP;

class CBstrDebug  
{
 public:
  CBstrDebug();
  virtual ~CBstrDebug();

  // Usage: track(SysAllocString(L"newbstr"), __FILE__, __LINE__)
  // If it leaks, the message will be displayed (as file and line#)
  // For more reasonable performance, the message must be a static,
  // i.e. we don't free it.
  BSTR track(BSTR mem, LPSTR message, int line);
  void release(BSTR mem, LPSTR message, int line);

 protected:
  BSTRLEAKMAP m_allocs;
  ULONG       m_numAllocs;
};

/*
#ifdef MEM_DBG
  extern CBstrDebug g_allocs;
  extern ULONG      g_breakOnBstrAlloc;
#endif
*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\bstrhash.h ===
// Helper funcs for string maps

#ifndef _BSTRHASH_INC
#define _BSTRHASH_INC

#pragma warning( disable : 4786 )

#include <map>
using namespace std;

#include "lkrhash.h"

template <class _Key, class _Val>
class CLKWrap
{
 public:
#ifdef MEM_DBG
  char m_id[8];
#endif
  _Key m_k;
  _Val m_v;
  mutable LONG m_cRefs;
  
  CLKWrap(_Key k, _Val v, char* id = "CLKWrap") : m_k(k), m_v(v), m_cRefs(0) 
    {
#ifdef MEM_DBG
      memcpy(m_id, id, 8);
#endif
    }
  ~CLKWrap()
    {
    }
};

template <class _Val>
class CRawCIBstrHash
  : public CTypedHashTable<CRawCIBstrHash<_Val>, const CLKWrap<BSTR,_Val>, BSTR>
{
 public:
  typedef CLKWrap<BSTR,_Val> ValueType;

  CRawCIBstrHash(LPCSTR name) :
    CTypedHashTable<CRawCIBstrHash, const CLKWrap<BSTR,_Val>, BSTR>(name)
    {}

  CRawCIBstrHash(LPCSTR name, double maxload, DWORD initsize, DWORD num_subtbls) :
    CTypedHashTable<CRawCIBstrHash, const CLKWrap<BSTR,_Val>, BSTR>(name,maxload,initsize,num_subtbls)
    {}

  static BSTR ExtractKey(const CLKWrap<BSTR,_Val> *pEntry)
    { return pEntry->m_k; }
  static DWORD CalcKeyHash(BSTR pstrKey)
    { return HashStringNoCase(pstrKey); }
  static bool EqualKeys(BSTR x, BSTR y)
    {
      if (x == NULL)
	{
	  return (y==NULL ? TRUE : FALSE);
	}
      if (!y) return FALSE;

      return (_wcsicmp(x,y) == 0); 
    }
  
    static void AddRefRecord(const CLKWrap<BSTR,_Val>* pTest, int nIncr)
    {
        IRTLTRACE(_TEXT("AddRef(%p, %s) %d, cRefs == %d\n"),
                  pTest, pTest->m_k, nIncr, pTest->m_cRefs);

        if (nIncr == +1)
        {
            // or, perhaps, pIFoo->AddRef() (watch out for marshalling)
            // or ++pTest->m_cRefs (single-threaded only)
            InterlockedIncrement(&pTest->m_cRefs);
        }
        else if (nIncr == -1)
        {
            // or, perhaps, pIFoo->Release() or --pTest->m_cRefs;
            LONG l = InterlockedDecrement(&pTest->m_cRefs);

            // For some hashtables, it may also make sense to add the following
            if (l == 0) delete pTest;
            // but that would typically only apply when InsertRecord was
            // used thus
            //      lkrc = ht.InsertRecord(new CTest(foo, bar));
        }
        else
            IRTLASSERT(0);
    }

};

// For normal built in types as keys
template <class _Key,class _Val>
class CGenericHash
  : public CTypedHashTable<CGenericHash<_Key,_Val>, const CLKWrap<_Key,_Val>, _Key>
{
 public:
  typedef CLKWrap<_Key,_Val> ValueType;
  
  CGenericHash(LPCSTR name) :
    CTypedHashTable<CGenericHash, const ValueType, _Key>(name)
    {}
  
  CGenericHash(LPCSTR name, double maxload, DWORD initsize, DWORD num_subtbls) :
    CTypedHashTable<CGenericHash, const ValueType, _Key>(name,maxload,initsize,num_subtbls)
    {}
 
  static _Key ExtractKey(const CLKWrap<_Key,_Val> *pEntry)
    { return pEntry->m_k; }
  static DWORD CalcKeyHash(_Key psKey)
    { return Hash(psKey); }
  static bool EqualKeys(_Key x, _Key y)
    { return (x==y); }

    static void AddRefRecord(const CLKWrap<_Key,_Val>* pTest, int nIncr)
    {
        IRTLTRACE(_TEXT("AddRef(%p, %s) %d, cRefs == %d\n"),
                  pTest, pTest->m_k, nIncr, pTest->m_cRefs);

        if (nIncr == +1)
        {
            // or, perhaps, pIFoo->AddRef() (watch out for marshalling)
            // or ++pTest->m_cRefs (single-threaded only)
            InterlockedIncrement(&pTest->m_cRefs);
        }
        else if (nIncr == -1)
        {
            // or, perhaps, pIFoo->Release() or --pTest->m_cRefs;
            LONG l = InterlockedDecrement(&pTest->m_cRefs);

            // For some hashtables, it may also make sense to add the following
            if (l == 0) delete pTest;
            // but that would typically only apply when InsertRecord was
            // used thus
            //      lkrc = ht.InsertRecord(new CTest(foo, bar));
        }
        else
            IRTLASSERT(0);
    }
};

#include <map>
using namespace std;

class RawBstrLT
{
 public:
  bool operator()(const BSTR& x, const BSTR& y) const
  {
    return (_wcsicmp(x,y) < 0);
  }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\cprofileconsent.h ===
#pragma once


/************************************************************************

    Copyright (c) 2001 Microsoft Corporation

    File Name: CProfileConsent.h  -- Definition of CProfileConsent.cpp

    Abstract: Access Profile Consent data stored in DB.

    Revision History:

        2001/1/27 lifenwu	Created.

***************************************************************************/

#include "cuserprofileex.h"

class CProfileConsent
{
public:

	CProfileConsent();
	CProfileConsent(PROFILE_CATEGORY t);

	~CProfileConsent();

	HRESULT InitFromDB(LARGE_INTEGER PUID, CStringW cswCredName); 
	HRESULT InitFromString(LPCSTR sz);

	void ResetConsent();

	// Persist to DB or String
	HRESULT Persist(LARGE_INTEGER PUID, CStringW cswCredName);
	HRESULT Persist(CStringA& szConsent);

	//
	// get/set operations for a particuar field number
	//
	BOOL GetConsent(ULONG ulFieldNum);
	HRESULT SetConsent(ULONG ulFieldNum, BOOL bConsent);
	
	void SetCategoryType(PROFILE_CATEGORY t) { m_type = t; }

	//
	// You don't have to worry about consent memory allocation.
	// It rellocates each time when the field number requested is not in range.
	// However, you can help to make it more efficient, by pre-allocating
	// enough space, as you know the maximum number of fields.
	//
	// You use this to help allocate memory only when you don't initialize
	// from DB. (bFromFlag = FALSE).  I pretty much know the size when initializing
	// from DB.
	//
	HRESULT PreAllocConsent(int iMaxNumFields);

	void SetDBAdminPUID(LARGE_INTEGER p) { m_biDBAdminPUID = p; }


private:

	unsigned char Bin2Hex(unsigned char c);

	unsigned char *m_bytes;
	int m_iSize;
	PROFILE_CATEGORY m_type;

	LARGE_INTEGER m_biDBAdminPUID;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\cocryptnobinhex.h ===
// CoCrypt.h: interface for the CCoCrypt class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_COCRYPTNOBINHEX_H__41651BFB_A5C8_11D2_95DF_00C04F8E7A70__INCLUDED_)
#define AFX_COCRYPTNOBINHEX_H__41651BFB_A5C8_11D2_95DF_00C04F8E7A70__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "nt\des.h"
#include "nt\tripldes.h"
#include "nt\modes.h"

class CCoCryptNoBinhex
{
public:
  CCoCryptNoBinhex();
  virtual ~CCoCryptNoBinhex();
  
  bool Decrypt32(const long lVectLen, const long lPaddingLen, const BYTE * byPadding, const BYTE *rawData, UINT dataSize, BSTR *pUnencrypted);
  bool Encrypt32(const long lVectLen, const long lPaddingLen, const BYTE * byPadding, const LPSTR rawData, UINT dataSize, BYTE *pEncrypted, UINT cbOut);

  
  bool setKeyMaterial(const char *newVal);        // length of newVal must be 24 bytes
  bool setKeyMaterial(long cb, const BYTE *newVal);
  static const long s_kKeyLen;

protected:

  DES3TABLE ks;

};

#endif // !defined(AFX_COCRYPT_H__41651BFB_A5C8_11D2_95DF_00C04F8E7A70__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\cprofile.h ===
//-----------------------------------------------------------------------------
//
//  @doc
//
//  @module CProfile.h |  Declaration of the CProfile class.
//
//  Author: Darren Anderson
//
//  Date:   4/26/00
//
//  Copyright <cp> 1999-2000 Microsoft Corporation.  All Rights Reserved.
//
//-----------------------------------------------------------------------------
#pragma once

#include "ppstorage.h"

//-----------------------------------------------------------------------------
//
//  @class CProfile | This class abstracts out a number of common profile
//                    operations.
//
//-----------------------------------------------------------------------------
class CUserProfileBase;
class CProfile
{
public:
   static const UINT AllMembers = (UINT)(-1);
      
// @access Protected members
protected:

    // @cmember <md CProfile::m_bInitialized> is true if this instance has been 
    //          initialized with a profile string.
    bool m_bInitialized;

    // @cmember <md CProfile::m_piProfile> is used to perform ticket operations.
    CComPtr<IPassportProfile> m_piProfile;

    // @cmember Pointer to global handler base.
    CPassportHandlerBase* m_pHandler;

    // @cmember Helper function to create <md CProfile::m_piProfile>.
    void CreateProfileObject(void);

    // @cmember Create a test mode (i.e. site id 1) cookie.
    static void MakeTest(LPCWSTR    szMemberName, 
                         ULONG      ulIdLow, 
                         ULONG      ulIdHigh, 
                         ULONG      ulProfileVersion, 
                         USHORT     nKeyVersion,
                         CStringW&  cszProfileCookie,
                         UINT       cEle
                         );

    // @cmember Create a limited consent cookie.
    static HRESULT MakeLimited(
                            LPCWSTR     szMemberName,
                            ULONG       ulIdlow,
                            ULONG       ulIdHigh,
                            ULONG       ulProfileVersion,
                            PASSPORT_PROFILE_BDAYPRECISION nBDayPrecision,
                            DATE        dtCookieBirthdate,
                            ULONG       ulFlags,
                            ULONG       ulSiteId,
                            USHORT      nKeyVersion,
                            bool        bSecure,
                            CStringW&   cszProfileCookie,
                            UINT        cEle
                            );
    // @cmember Create a limited consent cookie.
    static HRESULT MakeLimited(
                            LPCWSTR     szMemberName,
                            ULONG       ulIdlow,
                            ULONG       ulIdHigh,
                            ULONG       ulProfileVersion,
                            PASSPORT_PROFILE_BDAYPRECISION nBDayPrecision,
                            DATE        dtCookieBirthdate,
                            ULONG       ulFlags,
                            ULONG       ulSiteId,
                            USHORT      nKeyVersion,
                            CStringW&   cszProfileCookie,
                            UINT        cEle
                            );

// @access Public members
public:

    //
    //  Note, two-phase construction.  Constructor followed
    //  by PutProfile.
    //

    // @cmember Constructor.
    CProfile();

    // @cmember Destructor.
    ~CProfile();

    // @cmember Initialize this instance with a profile cookie string.
    void PutProfile(LPCWSTR szProfile);

    // @cmember Has this instance been initialized?
    bool IsInitialized(void);

    // @cmember Does this instance contain a valid profile?
    bool IsValid(void);

    //
    //  Multiple Get's for different types.
    //

    // @cmember Get string-type attribute.
    void Get(PASSPORT_PROFILE_ITEM item, CStringW& cszValue);

    // @cmember Get string-type attribute, but return as BSTR.
    void Get(PASSPORT_PROFILE_ITEM item, CComBSTR& cszValue);

    // @cmember Get a ULONG-type attribute.
    void Get(PASSPORT_PROFILE_ITEM item, ULONG& ulValue);

    // @cmember Get a DATE-type attribute.
    void Get(PASSPORT_PROFILE_ITEM item, DATE&  dtValue);

    // @cmember Get a USHORT-type attribute.
    void Get(PASSPORT_PROFILE_ITEM item, USHORT& usValue);

    //
    //  Membername/domain methods.
    //

    // @cmember  Retrieve the domain portion of the current user's name.
    HRESULT DomainFromMemberName(CStringW& cszDomain);

    // @cmember  Retrieve the alias portion of the current user's name.
    HRESULT AliasFromMemberName(CStringW& cszAlias);

    // @cmember  Retrieve the display version of the current user's naem.
    HRESULT FullDisplayMemberName(CStringW& cszMemberName);

    //
    //  Profile cookie manipulation functions.
    //


	//todo change this later -- make sure to implement kids consent correct!!
    static HRESULT Make(
						CUserProfileBase * cdbCoreProfile,
                        LPCWSTR            szMemberName,
                        ULONG              nSiteId,
                        USHORT             nKeyVersion,
                        KPP                nKPP,
                        LPCWSTR            szKPPVC,
                        bool               bMD5Silent,
                        CStringW&          cszProfileCookie,
                        ULONG          &ulKidsFlags,
                        UINT           cEle
                        );
    // @cmember  Create a profile cookie string using the parameters passed in.
    static HRESULT Make(
						CPPCoreProfileStorage&  profile,
                        LPCWSTR            szMemberName,
                        ULONG              nSiteId,
                        USHORT             nKeyVersion,
                        KPP                nKPP,
                        LPCWSTR            szKPPVC,
                        bool               bSecure,
                        bool               bMD5Silent,
                        CStringW&          cszProfileCookie,
                        ULONG          &ulKidsFlags,
                        UINT          cEle
                        );

    HRESULT MD5Make(ULONG       nSiteId,
                    USHORT      nKeyVersion,
                    UINT        cEle,
                    CStringW&   cszProfileCookie
                    );

    // @cmember Create a copy of the current profile cookie using the
    //          information passed in.
    HRESULT Copy(ULONG          nSiteId,
                 USHORT         nKeyVersion,
                 KPP            nKPP,
                 LPCWSTR        szKPPVC,
                 bool           bSecure,
                 bool           bNewReg,
                 CStringW&      cszProfileCookie,
                 ULONG          &ulKidsFlags,
                 UINT           cEles,
                 bool           bMD5Silent = false,   // TODO: should remove default
                 LPCWSTR        szMemberName = NULL);

    // @cmember Add the cookie specified to the response.
    static HRESULT Set(LPCWSTR szProfileCookie, 
                       bool bPersist);

    // @cmember Expire the current profile cookie.
    static HRESULT Expire(void);

};

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\consent.h ===
//-----------------------------------------------------------------------------
//
//  @doc
//
//  @module consent.h | Functions for retrieving information from the
//                      kids passport consent database.
//
//  Author: Darren Anderson
//
//  Date:   5/1/2000
//
//  Copyright <cp> 1999-2000 Microsoft Corporation.  All Rights Reserved.
//
//  History:
//        6/27/2000    t-ycphen    Split DoParentConsent() to mimic
//                                 the ASP procedure
//-----------------------------------------------------------------------------
#pragma once

#include "ppurl.h"

typedef enum 
{ 
    NEED_PARENT = 1, 
    NEED_CONSENT = 2 
} 
CONSENT_TYPE, *PCONSENT_TYPE;


void MakeKPPVC(
    ULONG           ulKidIdHigh,
    ULONG           ulKidIdLow,
    ULONG           ulParentIdHigh,
    ULONG           ulParentIdLow,
    ULONG           ulSiteId,
    LPCWSTR         szMemberName,
    CStringW&       strwKPPVC
    );

HRESULT CrackKPPVC(
    LPCWSTR         szKPPVC,
    ULONG           ulSiteId,
    ULONG           &ulKidIdHigh,
    ULONG           &ulKidIdLow,
    ULONG           &ulParentIdHigh,
    ULONG           &ulParentIdLow,
    ULONG           &ulChildAccountStatus,
    CStringW        &szMemberName
    );

HRESULT MakeConsentUrl(
    ULONG           ulSiteId,
    ULONG           ulMemberIdHigh, 
    ULONG           ulMemberIdLow, 
    LPCWSTR         szMemberName,
    CONSENT_TYPE    type,
    CPPUrl          &ppReturnUrl
    );


HRESULT DoParentConsent(
    ULONG           ulSiteId,
    ULONG           ulMemberIdHigh, 
    ULONG           ulMemberIdLow, 
    LPCWSTR         szMemberName,
    CONSENT_TYPE    type,
    bool            fDoRedirect = true
    );


HRESULT DBGetConsentForSite(
    ULONG           ulMemberIdHigh,
    ULONG           ulMemberIdLow,
    ULONG           ulSiteId,
    PULONG          pulConsent
    );


HRESULT ValidateParentWithKppvc(
    ULONG           ulMemberIdHigh, 
    ULONG           ulMemberIdLow, 
    LPCWSTR         szMemberName, 
    LPCWSTR         szKPPVC, 
    ULONG           ulSiteId
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\cocrypt.h ===
// CoCrypt.h: interface for the CCoCrypt class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_COCRYPT_H__41651BFB_A5C8_11D2_95DF_00C04F8E7A70__INCLUDED_)
#define AFX_COCRYPT_H__41651BFB_A5C8_11D2_95DF_00C04F8E7A70__INCLUDED_

const BYTE g_kMK[] = 
{
    0x38, 0x12, 0x87, 0x12, 0x00, 0xA1, 0xE9, 0x44,
    0x45, 0x92, 0x55, 0x08, 0x23, 0x55, 0x99, 0x04,
    0x14, 0x66, 0x29, 0x91, 0x06, 0xB8, 0x33, 0x0F
};


#include "BinHex.h"	// Added by ClassView
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef UNIX
#include <des.h>
#else
#include "nt\des.h"
#include "nt\tripldes.h"
#include "nt\modes.h"
#endif

class CCoCrypt  
{
public:
  static int getKeyVersion(BSTR encrypted);
  static int getKeyVersion(BYTE *encrypted);
  CCoCrypt();
  virtual ~CCoCrypt();
  
  BOOL Decrypt(LPWSTR rawData, UINT dataSize, BSTR *pUnencrypted);
  void Encrypt(int keyVersion, LPSTR rawData, UINT dataSize, BSTR *pEncrypted);
  void CryptMemberID(BOOL encrypt, long &memberId, long &domainId, long puidScope);

  void EncryptKey(int nKeyVer, BSTR bstrIn, BYTE *pEncrypted, UINT &cbOut);  
  BOOL DecryptKey(BYTE *rawData, UINT dataSize, BSTR *pDecrypted);

  void setKeyMaterial(BSTR newVal);
  unsigned char *getKeyMaterial(DWORD *pdwLen);
  void setWideMaterial(BSTR kvalue);
  BSTR getWideMaterial();

protected:
  void encryptDynamic(char ivec[9], int sz, int keyVersion, LPSTR rawData, 
                        UINT dataSize, BSTR *pEncrypted);
  void encrypt2048(char ivec[9], int sz, int keyVersion, LPSTR rawData, 
                        UINT dataSize, BSTR *pEncrypted, BOOL bEncode = TRUE);
  BOOL decryptDynamic(LPWSTR rawData, UINT dataSize, BSTR *pUnencrypted);
  BOOL decrypt2048(LPWSTR rawData, UINT dataSize, BSTR *pUnencrypted, BOOL bEncoded = TRUE);

  static CBinHex m_binhex;

  BOOL m_ok;

  unsigned char m_nextIvec[8];
  short         m_ivecCtr;
  unsigned char m_keyMaterial[24];
  _bstr_t       m_bstrWideMaterial;

#ifdef UNIX

  des_key_schedule ks1, ks2, ks3;

#else

  DES3TABLE ks;

#endif

};

#endif // !defined(AFX_COCRYPT_H__41651BFB_A5C8_11D2_95DF_00C04F8E7A70__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\clist.h ===
/*--------------------------------------------------------------------------
        
    Copyright (C) 1997 Microsoft Corporation
    All rights reserved.

	File:		utils.hxx

	Abstract:	Various C++ class lib

    Authors:	Antony Halim

    History:	9/17/97 
				
  --------------------------------------------------------------------------*/
#if !defined(__CLIST_H__)
#define __CLIST_H__


//////////////////////////////////////////////////////////////////////////////
//
//	External enumerator for CList, for multi-thread read access
//
//////////////////////////////////////////////////////////////////////////////


template <class CData>
class CListEnum
{
private:
	struct LIST_NODE {
		CData		*pData;
		LIST_ENTRY	List;
	};

	PLIST_ENTRY		m_pListHead;
	PLIST_ENTRY		m_pCurrentData;
	DWORD			m_dwCount;

public:

	VOID Init(PLIST_ENTRY pListHead, DWORD dwCount) 
	{
		m_pListHead = pListHead;
		m_pCurrentData = pListHead;
		m_dwCount = dwCount;
	}

	CData *RemoveCurrent()
	{
		CData *pData;
		LIST_NODE *pTreeNode;

		if (IsEnd())
			return NULL;
		
		RemoveEntryList(m_pCurrentData);
		pTreeNode = (LIST_NODE *)CONTAINING_RECORD(m_pCurrentData, LIST_NODE, List);
		pData = pTreeNode->pData;
		Prev(); 
		delete pTreeNode;
		//ASSERT(m_dwCount >= 1);
		m_dwCount--;
		return pData;
	}


	//
	// iterator methods are included as part of the CList api
	//
	VOID First()
	{
		m_pCurrentData = m_pListHead->Flink;
	}

	VOID Next()
	{
		m_pCurrentData = m_pCurrentData->Flink;
	}

	VOID Prev()
	{
		m_pCurrentData = m_pCurrentData->Blink;
	}

	BOOL IsEnd()
	{
		if (m_pCurrentData == m_pListHead)
			return TRUE;
		else
			return FALSE;
	}

	BOOL IsNotEnd()
	{
		return !IsEnd();
	}

	CData *GetCurrent()
	{
		LIST_NODE *pTreeNode;
		if (IsEnd())
			return NULL;
		pTreeNode = (LIST_NODE *)CONTAINING_RECORD(m_pCurrentData, LIST_NODE, List);
		return pTreeNode->pData;
	}

	BOOL IsEmpty()
	{
		if (m_dwCount == 0L) {
			//ASSERT(IsListEmpty(m_pListHead));
			return TRUE;
		}
		else {
			return FALSE;
		}
	}
};

//////////////////////////////////////////////////////////////////////////////
//
//	Link List template class
//  For a link list of of CData object pointer.
//
//////////////////////////////////////////////////////////////////////////////

template <class CData>
class CList
{
private:

	struct LIST_NODE {
		CData		*pData;
		LIST_ENTRY	List;
	};

public:
	CList() :
		m_dwCount(0)
	{
		InitializeListHead(&m_List);
		m_pCurrentData = &m_List;
	}

	~CList()
	{
		Cleanup();
	}

	DWORD Count() 
	{
		return m_dwCount;
	}

	BOOL AddTail(CData *pData)
	{
		LIST_NODE *pTreeNode = new LIST_NODE;
		if (!pTreeNode) {
			//ASSERT(0);
			return FALSE;
		}

		pTreeNode->pData = pData;
		InsertTailList(&m_List, &pTreeNode->List);
		m_dwCount++;
		return TRUE;
	}

	BOOL AddBeforeCurrent(CData *pData)
	{
		LIST_NODE *pTreeNode = new LIST_NODE;
		if (!pTreeNode) {
			//ASSERT(0);
			return FALSE;
		}

		pTreeNode->pData = pData;

		pTreeNode->List.Flink = m_pCurrentData;
		pTreeNode->List.Blink = m_pCurrentData->Blink;
		m_pCurrentData->Blink = &pTreeNode->List;
		m_pCurrentData->Blink->Flink = &pTreeNode->List;

		m_dwCount++;
		return TRUE;
	}

	CList<CData> *DupList(CList<CData> *pList)
	{
		CList<CData> *pDupList;
		CData *pData;
		BOOL fStatus = TRUE;

		pDupList = new CList<CData>;
		if (!pDupList)
			return NULL;
		
		for (pList->First(); pList->IsNotEnd(); pList->Next()) {
			pData = pList->GetCurrent();
			if (pDupList->AddTail(pData)) {
				fStatus = FALSE;
				break;
			}
		}

		if (fStatus) {
			return pDupList;
		}
		else {
			delete pDupList;
			return NULL;
		}
	}

	BOOL AddHead(CData *pData)
	{
		LIST_NODE *pTreeNode = new LIST_NODE;
		if (!pTreeNode) {
			//ASSERT(0);
			return FALSE;
		}

		pTreeNode->pData = pData;
		InsertHeadList(&m_List, &pTreeNode->List);
		m_dwCount++;
		return TRUE;
	}

	// cleanup list without deleting the data pointer
	VOID Cleanup()
	{
		LIST_NODE *pTreeNode;
		PLIST_ENTRY pEntry;

		while (!IsListEmpty(&m_List)) {
			pEntry = RemoveHeadList(&m_List);
			pTreeNode = (LIST_NODE *)CONTAINING_RECORD(pEntry, LIST_NODE, List);
			delete pTreeNode;
		}
		m_dwCount = 0;
	}

	// cleanup list and the data pointers
	VOID CleanupAll()
	{
		CData *pData;
		LIST_NODE *pTreeNode;
		PLIST_ENTRY pEntry;

		while (!IsListEmpty(&m_List)) {
			pEntry = RemoveHeadList(&m_List);
			pTreeNode = (LIST_NODE *)CONTAINING_RECORD(pEntry, LIST_NODE, List);
			pData = pTreeNode->pData;
			// delete the data pointer as well
			delete pData;
			delete pTreeNode;
		}
		m_dwCount = 0;
	}

	//
	// iterator methods are included as part of the CList api
	//

	VOID First()
	{
		m_pCurrentData = m_List.Flink;
	}

	VOID Next()
	{
		m_pCurrentData = m_pCurrentData->Flink;
	}

	VOID Prev()
	{
		m_pCurrentData = m_pCurrentData->Blink;
	}

	BOOL IsEnd()
	{
		if (m_pCurrentData == &m_List)
			return TRUE;
		else
			return FALSE;
	}

	BOOL IsNotEnd()
	{
		if (m_pCurrentData == &m_List)
			return FALSE;
		else
			return TRUE;
	}

	CData *GetCurrent()
	{
		LIST_NODE *pTreeNode;
		if (IsEnd())
			return NULL;
		pTreeNode = (LIST_NODE *)CONTAINING_RECORD(m_pCurrentData, LIST_NODE, List);
		return pTreeNode->pData;
	}

	CData *RemoveCurrent()
	{
		CData *pData;
		LIST_NODE *pTreeNode;

		if (IsEnd())
			return NULL;
		
		RemoveEntryList(m_pCurrentData);
		pTreeNode = (LIST_NODE *)CONTAINING_RECORD(m_pCurrentData, LIST_NODE, List);
		pData = pTreeNode->pData;
		Prev(); 
		delete pTreeNode;
		//ASSERT(m_dwCount >= 1);
		m_dwCount--;
		return pData;
	}

	//
	// end of iterator methods
	//

	// remove the first list node, and return its data pointer
	CData *RemoveFirst()
	{
		CData *pData;
		LIST_NODE *pTreeNode;
		PLIST_ENTRY pEntry;

		if (IsListEmpty(&m_List)) {
			return NULL;
		}
		else {
			pEntry = RemoveHeadList(&m_List);
			pTreeNode = (LIST_NODE *)CONTAINING_RECORD(pEntry, LIST_NODE, List);
			pData = pTreeNode->pData;
			delete pTreeNode;
			//ASSERT(m_dwCount >= 1);
			m_dwCount--;
			return pData;
		}
	}


	BOOL IsEmpty()
	{
		if (m_dwCount == 0L) {
			//ASSERT(IsListEmpty(&m_List));
			return TRUE;
		}
		else {
			return FALSE;
		}
	}

	// remove list node whose data pointer is equal to pRemData
	BOOL Remove(CData *pRemData)
	{
		PLIST_ENTRY pCurrent;
		LIST_NODE *pTreeNode;

		for (pCurrent = m_List.Flink; pCurrent != &m_List; pCurrent = pCurrent->Flink) {
			pTreeNode = (LIST_NODE *)CONTAINING_RECORD(pCurrent, LIST_NODE, List);
			if (pTreeNode->pData == pRemData) {
				RemoveEntryList(pCurrent);
				delete pTreeNode;
				//ASSERT(m_dwCount >= 1);
				m_dwCount--;
				return TRUE;
			}
		}
		return FALSE;
	}

	CListEnum<CData> *GetEnumerator()
	{
		CListEnum<CData> *pListEnum;

		pListEnum = new(CListEnum<CData>);
		if (!pListEnum)
			return NULL;

		pListEnum->Init(&m_List, m_dwCount);
		return pListEnum;
	}

	VOID InitEnumerator(CListEnum<CData> *pListEnum)
	{
		pListEnum->Init(&m_List, m_dwCount);
	}

private:

	LIST_ENTRY		m_List;
	PLIST_ENTRY		m_pCurrentData;
	LONG			m_dwCount;
};




#endif // __CLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\csite.h ===
#pragma once


/************************************************************************

    Copyright (c) 2001 Microsoft Corporation

    File Name: CSite.h  -- Definition of CSite.cpp

    Abstract: Site objects that manages partner site settings through XML and DB.
	          Site interface to manage SiteXXX.xml.

    Revision History:

        2001/1/24 lifenwu	Created.

***************************************************************************/

#include "PSANexus.h" //sd_uncommented
#include "atlcoll.h"
#include "atltime.h"


//
//  XML Item Node type
//

typedef enum siteItemNodeType
{
	stnt_Device = 1, 
    stnt_Item,
    stnt_ExtItem,
    stnt_CBScriptVar,
    stnt_Invalid
} SITE_ITEM_NODE_TYPE;


//
// Each XML node owns a set of attributes
// 
class CSiteAttribute
{
public:
    virtual ~CSiteAttribute();

	// 
	// Random Access to an attribute
	//
	BOOL AttributeGet(CString szName, CString *pszValue);

	BOOL AttributeGet(POSITION pos, CString *pszName, CString *pszValue)
	{
		if (pos == NULL) return FALSE;
		m_mapFields.GetAt(pos, *pszName, pszValue);
		return TRUE;
	}

	//
    // enumeration through
	//
    POSITION AttributeGetStartPosition()
	{
		return m_mapFields.GetStartPosition();
	}

	BOOL AttributeGetNext(POSITION& pos, CString *pszName, CString *pszValue)
	{
		CString *csValue;

		if (pos == NULL) return FALSE;
		m_mapFields.GetNextAssoc(pos, *pszName, csValue);
		*pszValue = *csValue;
		return TRUE;
	}
	    
    ULONG AttributeGetCount()
	{
		return m_mapFields.GetCount();
	}
   

	//
	// Add/Update/Delete operation
	//
	BOOL AttributeAdd(CString szName, CString szValue);
    BOOL AttributeUpdate(CString szName, CString szValue);
    BOOL AttributeDelete(CString szName);

	//
	// Initialization routines
	//
	HRESULT InitAttributes(IXMLDOMNode *pNode);


protected:
	
	typedef CAtlMap<CString, CString *,   CStringElementTraits<CString>  > ATTRIBUTE_MAP;
	ATTRIBUTE_MAP m_mapFields;

private:

};


//
// CSite Item represents a leaf XML node, 
// such <Item>Birthdate</Item> or <ExtItem> or <CBScriptVar>
//
class CSiteItem : public CSiteAttribute
{
public:

    ~CSiteItem() { };

	//
	// Get/Set Item value and its type
	//
    LPCTSTR GetItem() { return m_szItem; }
    void SetItem(LPCTSTR szItem) { m_szItem = szItem; }
    SITE_ITEM_NODE_TYPE GetType() { return m_enumType; 	}
    void SetType(SITE_ITEM_NODE_TYPE t) { m_enumType = t; }

	//
	// Initialization routines
	// $$Todo$$ Add DB init
	//
	HRESULT InitFromXML(IXMLDOMNode *pNode);

protected:

    CString	m_szItem;
    SITE_ITEM_NODE_TYPE m_enumType;
};



//
// Represents an XML containder node such as <Section>, <Device>, <Locale>
// Internally, a CAtlArray maintains the container.
// The ordering of the elements are implicitly stored in the array
//
template<class T>
class CSiteContainer : public CSiteAttribute
{
public:

    ~CSiteContainer() 
	{
		// Deep clean up array
		for (ULONG ulIndex = 0; ulIndex < m_array.GetCount(); ulIndex++)
		{
			T * pT = m_array[ulIndex];
			if (pT != NULL)
			{	
				delete pT;
				pT = 0; //sd_added
			}
		}

		m_array.RemoveAll();
	}

	//
	// Access to container array
	//
    T *GetItem(unsigned long ulItemIdx) { return m_array[ulItemIdx]; }
    size_t AddItem(T *t) { return m_array.Add(t); }
    ULONG GetCount() { return m_array.GetCount(); }

	//
	// Initializations
	//
	HRESULT InitFromXML(IXMLDOMNode *pNode)
	{
		HRESULT hr = E_FAIL;
		CComPtr<IXMLDOMNode> pItem = NULL;
		CComPtr<IXMLDOMNodeList> pList = NULL;
		long i, lNumChildren;
		CComBSTR bstr;
		CComVariant var;

		hr = InitAttributes(pNode);

		hr = pNode->get_childNodes(&pList);
		if (FAILED(hr)) 
		{
			goto exit;
		}

		hr = pList->get_length(&lNumChildren);

		for (i=0; i < lNumChildren; i++)
		{
			pItem = NULL;
			hr = pList->get_item(i, &pItem);
			T *pT = new T;
			if (pT == NULL)
			{
				hr = E_OUTOFMEMORY;
				goto exit;
			}

			hr = pT->InitFromXML(pItem);

			if (FAILED(hr)) 
			{
				if (pT != NULL) delete pT;
			}
			else
			{
				AddItem(pT);
			}
		}

		hr = S_OK;
	exit:
		return hr;
	}
	
protected:

	typedef CAtlArray<T *>  SITEITEM_ARRAY;
    SITEITEM_ARRAY  m_array;
};


//
// Container objects class
//
typedef CSiteContainer<CSiteItem> CSiteSection;
typedef CSiteContainer<CSiteItem> CSiteLocale;


//
//  Device has been referred as Style (mainly indicates HTML, WML, CDML, Wizard, etc
//
class CSiteDevice : public CSiteContainer<CSiteSection>
{
public:
	CSiteDevice() { }
	CSiteDevice(CString szDeviceName) {	m_szName = szDeviceName; }
	
	void SetDeviceName(CString sz) { m_szName = sz; }

	// Persist as XML blob in DB
	//
	HRESULT Pesist(LONG lSiteID);

	HRESULT InitFromDB(LONG lSiteID);
	HRESULT InitFromStream(ISequentialStream *pStream);

private:
	CString m_szName;
	COleDateTime m_dtSRFChangedTime;
};

//
// Main entry object to a partner site settings data
//
//sd_added, 08/March/2001, use this type to pass the site info to be stored in DB
//to CSite obj.
typedef CPSANexusFlexRegInsert::tagInputParameters SITEMETRICS_STRUCT;

class CSite : public CSiteAttribute
{
public:
    
	CSite() { m_lSiteID = -1;};
	CSite(LONG lSiteID) { m_lSiteID = lSiteID; }
    ~CSite() { };

    // Initialize from DB, Read Only, to be used during Runtime
	HRESULT InitSiteAttributes();
	HRESULT	InitSiteDevices(int iTargetType);
	HRESULT InitDevice(CString szwStyle, int iTargetType);

    // Initialize from XML -- an XML for a site customization ; used by preprocessing
    HRESULT Init(IXMLDOMDocument *pXMLDoc); 
	HRESULT	InitFromDB(int iTargetType);

    // Persist to DB through XML only
	// never persist from object memory
    HRESULT Persist(SITEMETRICS_STRUCT *pSiteMetrics);
	HRESULT GetDateTime(COleDateTime *pDateTime);

    CSiteContainer<CSiteDevice>* GetDeviceContainer() { return &m_Devices; }
    CSiteContainer<CSiteLocale>* GetLocaleContainer() { return &m_Locales; }
   
	LONG GetSiteID() { return m_lSiteID; }
	void SetSiteID(LONG l) { m_lSiteID = l; }
	CSiteDevice * GetDevice(CString cszDevice);

private:
	typedef CAtlMap< CString, LONG, CStringElementTraits<CString> >  SITEDEVICE_MAP;
 
    CSiteContainer<CSiteDevice> m_Devices;
	SITEDEVICE_MAP m_DeviceMap;
    CSiteContainer<CSiteLocale> m_Locales;
    LONG m_lSiteID;
	COleDateTime m_oledtDateUpdated;
};


class CSitesAll : public CSiteContainer<CSite>
{
public:
	
protected:

private:
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\csecureticket.h ===
//-----------------------------------------------------------------------------
//
//  @doc
//
//  @module CSecureTicket.h | Declaration of the CSecureTicket class.
//
//  Author: Darren Anderson
//
//  Date:   5/2/2000
//
//  Copyright <cp> 1999-2000 Microsoft Corporation.  All Rights Reserved.
//
//-----------------------------------------------------------------------------
#pragma once

class CProfileSchema;

//-----------------------------------------------------------------------------
//
//  @class CSecureTicket | This class abstracts out a number of common
//                         secure ticket operations.
//
//-----------------------------------------------------------------------------

class CSecureTicket
{
// @access  Protected members.
protected:

    // @cmember Has this instance been initialized?
    bool m_bInitialized;

    // @cmember Holds the raw ticket cookie passed in via
    // <mf CSecureTicket::PutTicket>.
    CComBSTR m_cbstrRaw;
    //  holds the unencrypted ticket
    CComBSTR m_cbstrUnencrypted;
    //  passport siteid
    LONG    m_lPassportSiteId;

    // @cmember Base handler.
    CPassportHandlerBase* m_pHandler;
    //  interface to encrypt/decrypt funcs
    CComPtr<ILoginServer> m_piLoginServer;
    CComPtr<INetworkServerCrypt> m_piNetworkServerCrypt;

    //  gets the unencrypted ticket
    void    GetUnencryptedTicket();

    //  encrypt back
    void    EncryptUnencryptedTicket();

    //  schema for the secure ticket
    CAutoPtr<CProfileSchema>    m_piProfileSchema;
    //  field positions
    CAutoVectorPtr<UINT>    m_rgPositions;
    CAutoVectorPtr<UINT>    m_rgBitPositions;

    //  enum for field position index
    enum {k_MemberIdLow = 0,  k_MemberIdHigh, k_Pwd,
         k_Version, k_Time, k_Flags};

    //  ticket version
    static const long k_lCurrentVersion = 1;

// @access  Public members.
public:

    // @cmember  Default constructor.
    CSecureTicket();

    // @cmember  Default destructor.
    ~CSecureTicket();

    // @cmember Initialize this object using the existing MSPSec cookie.
    void PutSecureTicket(LPCWSTR szSecureTicketCookie);

    // @member Get the secure ticket cookie.
    void GetSecureTicket(CStringW& cszSecureTicket);

    // @cmember Has this object been initialized yet?
    bool IsInitialized(void);

    // @cmember Does this object contain a valid secure ticket?
    bool IsValid(void);

    // @cmember Create a secure ticket cookie string using only information
    //          passed in.
    static void Make(ULONG      ulMemberIdLow,
                     ULONG      ulMemberIdHigh,
                     LPCWSTR    szPassword,
                     ULONG      ulDomainSiteId,
                     USHORT     nKeyVersion,
                     CStringW&  cszSecureTicketCookie
                     );

    //
    //  @cmember Create a secure ticket with the new schema
    //  Note that this is not a static member. The caller can still change
    //  the ticket if necessary.
    //  Also key version and domain ID params are gone. These are always
    //  the same for the DA.
    //
    void Make2(ULONG      ulMemberIdLow,
              ULONG       ulMemberIdHigh,
              LPCWSTR     szPassword,
              LONG        lTicketTime = 0,
              LONG        lFlags = 0,
              LONG        lVersion = k_lCurrentVersion
              );

    // @cmember Check the member id high/low and password passed in against
    //          the current secure ticket.
    bool CheckPassword(ULONG     ulMemberIdLow,
                       ULONG          ulMemberIdHigh,
                       LPCWSTR      cwszPassword
                       );

    // @cmember Check the member id high/low passed in against the current
    //          secure ticket.
    bool CheckMemberId(ULONG     ulMemberIdLow,
                       ULONG     ulMemberIdHigh
                       );

    // @cmember Check the member id high/low as well as ticket time passed in against the current
    // secure ticket.
    bool CheckTicketIntegrity(ULONG     ulMemberIdLow,
                              ULONG     ulMemberIdHigh,
                              time_t    SignInTime
                       );

    // @cmember Set the secure cookie.
    static HRESULT Set(LPCWSTR          szSecureTicketCookie,
                       bool             bPersist);

    // @cmember Expire the secure cookie.
    static HRESULT Expire(void);

    //  get secure ticket flags
    LONG   GetFlags();

    //  set secure ticket flags
    void SetFlags(LONG lFlags);

    //  get/set ticket time
    time_t  GetTicketTime();
    void    SetTicketTime(time_t);
	
	// get PUID
    DWORD GetPUIDLow();
    LONG GetPUIDHigh();

    //  known secure ticket flags
    static const LONG   g_fPinEntered = 1;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\cuserprofile.h ===
#pragma once

// names of all known profile fields ....
#define PROF_MEMBERNAME                 "SignInName"
#define PROF_DOMAIN			            "Domain"
#define PROF_EMAIL                      "Email"
#define PROF_PASSWORD                   "Password"
#define PROF_SECRETQ                    "SecretQuestion"
#define PROF_SECRETA                    "SecretAnswer"
#define PROF_BIRTHDATE                  "Birthdate"
#define PROF_COUNTRY                    "Country"
#define PROF_REGION                     "Region"
#define PROF_POSTALCODE                 "PostalCode"
#define PROF_SPACER                     "Spacer"
#define PROF_GENDER                     "Gender"
#define PROF_LANGUAGE                   "LanguagePreference"
#define PROF_ACCESSIBILITY              "Accessibility"
#define PROF_EMAIL_SHARE                "Email_1"
#define PROF_NICKNAME                   "NickName"
#define PROF_FIRSTNAME                  "FirstName"
#define PROF_LASTNAME                   "LastName"
#define PROF_TIMEZONE                   "TimeZone"
#define PROF_OCCUPATION                 "Occupation"
#define PROF_EMAIL_SPAM                 "NA_1"
#define PROF_CONGRAT                    "NA_2"
#define PROF_SVC                        "svc"
#define PROF_SAVEPASSWORD               "SavePassword"
#define PROF_ALLOWEMAILINPROFILE        "AllowEmailinProfile"
#define PROF_ALLOWPASSPORTNETWORKEMAIL  "AllowPassportNetworkEmail"
#define PROF_WALLET                     "Wallet"
#define PROF_DIRECTORY                  "Directory"
#define PROF_GENERAL                    "General"

//  ALL available fields in bit mask
#define PROFILE_BIT_BIRTHDATE           0x0000000000000001
#define PROFILE_BIT_GENDER              0x0000000000000002
#define PROFILE_BIT_LANGUAGE            0x0000000000000004
#define PROFILE_BIT_ACCESSABILITY       0x0000000000000008
#define PROFILE_BIT_EMAIL               0x0000000000000010
#define PROFILE_BIT_CONGRAT             0x0000000000000020
#define PROFILE_BIT_EMAIL_SHARE         0x0000000000000040
#define PROFILE_BIT_EMAIL_SPAM          0x0000000000000080
#define PROFILE_BIT_NICKNAME            0x0000000000000100
#define PROFILE_BIT_MEMBERNAME          0x0000000000000200
#define PROFILE_BIT_PASSWORD            0x0000000000000400
#define PROFILE_BIT_SECRETQ             0x0000000000000800
#define PROFILE_BIT_SECRETA             0x0000000000001000
#define PROFILE_BIT_COUNTRY             0x0000000000002000
#define PROFILE_BIT_REGION              0x0000000000004000
#define PROFILE_BIT_POSTALCODE          0x0000000000008000
#define PROFILE_BIT_FIRSTNAME           0x0000000000010000
#define PROFILE_BIT_LASTNAME            0x0000000000020000
#define PROFILE_BIT_TIMEZONE            0x0000000000040000
#define PROFILE_BIT_OCCUPATION          0x0000000000080000
#define PROFILE_BIT_SPACER              0x0000000000100000
// TODO:
//      I am not sure of the bit masks (positions) of the following 4 fields.
//      Please modify them if necessary.
#define PROFILE_BIT_SVC                         0x0000000000200000
#define PROFILE_BIT_SAVEPASSWORD                0x0000000000400000
#define PROFILE_BIT_ALLOWEMAILINPROFILE         0x0000000000800000
#define PROFILE_BIT_ALLOWPASSPORTNETWORKEMAIL   0x0000000001000000
#define PROFILE_BIT_DOMAIN                      0x0000000002000000

//
// customizaeble validation paramers
//
class CValidationParams
{
public:
    CValidationParams(LONG  lMinPwd = 8,
                      LONG  lMaxPwd = 16,
                      LONG  lMinMemberName = 1,
                      LONG  lMaxMemberName = 64,
                      LONG  lEmailLeft = 32,
                      LONG  lEmailRight = 32,
                      LONG  lMaxNickname = 30) :
    // default values ....
    m_lMinPwd(lMinPwd), m_lMaxPwd(lMaxPwd),
    m_lMinMemberName(lMinMemberName), m_lMaxMemberName(lMaxMemberName),
    m_lEmailLeft(lEmailLeft), m_lEmailRight(lEmailRight),
    m_lMaxNickname(lMaxNickname)
    {
    }
    // this is how to change'em
    VOID SetNewValues(LONG  lMinPwd = 8,
                      LONG  lMaxPwd = 16,
                      LONG  lMinMemberName = 1,
                      LONG  lMaxMemberName = 64,
                      LONG  lEmailLeft = 32,
                      LONG  lEmailRight = 32,
                      LONG  lMaxNickname = 30)
    {
        m_lMinPwd = lMinPwd, m_lMaxPwd=lMaxPwd,
        m_lMinMemberName = lMinMemberName, m_lMaxMemberName = lMaxMemberName,
        m_lEmailLeft = lEmailLeft, m_lEmailRight = lEmailRight;
        m_lMaxNickname = lMaxNickname;
    }
    void GetPwdParams(LONG& lmin, LONG& lmax) {
        lmin = m_lMinPwd, lmax = m_lMaxPwd;
    }
    void GetMemberNameParams(LONG& lmin, LONG& lmax){
        lmin = m_lMinMemberName, lmax = m_lMaxMemberName;
    }
    void GetEmailParams(LONG& lmailL, LONG& lmailR ){
        lmailL = m_lEmailLeft, lmailR = m_lEmailRight;
    }
    void GetNicknameParams(LONG& lmax){
        lmax = m_lMaxNickname;
    }
private:
    LONG    m_lMinPwd;
    LONG    m_lMaxPwd;
    LONG    m_lMinMemberName;
    LONG    m_lMaxMemberName;
    LONG    m_lEmailLeft;
    LONG    m_lEmailRight;
    LONG    m_lMaxNickname;
};

//
//  field description ...
//
typedef struct
{
    LPCSTR      pcszFieldName;
    BOOL        fIsRequired;
    BOOL        bInvalid;
} FIELD_STATE, *PFIELD_STATE;
typedef CAtlArray<PFIELD_STATE> FIELD_ARRAY;

typedef struct
{
    LPCSTR      pcszUIFIELDID;
    BOOL        bState;
    LPCSTR      pcszUIDepends;
} UIFIELD_STATE, *PUIFIELD_STATE;
typedef CAtlArray<PUIFIELD_STATE> UIFIELD_ARRAY;

//
//  user profile interface. An abstract class ...
//
class CUserProfile
{
public:
    //  this need to be defined for the autoptr ....
    //  all other functions are pure virtual
    virtual ~CUserProfile(){};

    //  get field by index ....
    //  index corresponds to the bit position in the bit mask ....
    virtual PCSTR GetFieldNameByIndex(ULONG ind) = 0;

    // validate profile
    virtual BOOL   Validate() = 0;

    // regProfile <-> database
    virtual HRESULT InitFromDB( CStringW wszMemberName, 
                                FIELD_ARRAY& fields) = 0;
    virtual HRESULT Persist(CStringW *wszMemberName = NULL) = 0;
    virtual HRESULT DeleteMember(CStringW &wszMemberName) = 0;

    //
    //  field initialization options
    //
    virtual HRESULT AddField(LPCSTR name, PCWSTR    value) = 0;
    virtual HRESULT AddField(ULONG  findex, PCWSTR  value) = 0;
    virtual HRESULT UpdateField(LPCSTR  name, PCWSTR    value) = 0;
    virtual HRESULT UpdateField(ULONG   findex, PCWSTR  value) = 0;

    // regProfile <-> XML format
    virtual HRESULT InitFromXML(IXMLDOMDocument *pXMLDoc,
                                FIELD_ARRAY    &Fields) = 0;

    virtual HRESULT SaveToXML(CStringA &szProfileXML) = 0;

    //
    //  html form init
    //  process the fields in the Fields array
    //
    virtual HRESULT InitFromHTMLForm(CHttpRequest&         request,
                                     FIELD_ARRAY&         Fields) = 0;

    //  html query string init
    virtual HRESULT InitFromQueryString(CHttpRequest&         request,
                                        FIELD_ARRAY&         Fields) = 0;

    //
    //  get value, errcode or help text for field name ....
    //
    virtual HRESULT GetFieldValue(LPCSTR fname, CStringW& strVal) = 0;
    virtual HRESULT GetFieldValue(ULONG findex, CStringW& strVal) = 0;
    virtual HRESULT GetFieldError(LPCSTR fname) = 0;
    virtual HRESULT GetFieldError(ULONG fIndex) = 0;
    virtual HRESULT FieldHasError(LPCSTR fname) = 0;
    virtual HRESULT FieldHasError(ULONG fIndex) = 0;
    virtual void    SetFieldError(LPCSTR fname) = 0;
    virtual void    RemoveProfileKey(LPCSTR fname) = 0;
    virtual void    GetFieldHelpText(LPCSTR fname, CStringW& strHelp) = 0;
    virtual BOOL    IsField(LPCSTR fname) = 0;


    //
    //  enum methods
    //
    virtual HRESULT StartEnumFields(POSITION& pos) = 0;
    virtual HRESULT GetNextField(POSITION& p, CStringW& fn, CStringW& fv) = 0;
    virtual HRESULT StartEnumErrors(POSITION& pos) = 0;
    virtual HRESULT GetNextError(POSITION& p, CStringW& fn, HRESULT& fhr) = 0;

    //
    //  validation functions
    //
    virtual HRESULT ValidateMember(CStringW &value) = 0;
    virtual HRESULT ValidateEmail(CStringW  &value) = 0;
    virtual HRESULT ValidateLocation(CStringW &country, 
                                     CStringW &region, 
                                     CStringW &pcode) = 0;
    virtual HRESULT ValidatePassword(CStringW &pwd, CStringW &mbrname) = 0;
    virtual HRESULT ValidateNickname(CStringW &value) = 0;


    //  regional info for validation
    virtual void SetProfileRegionalInfo(
                    LCID lc, IDictionaryEx *piDict = NULL) = 0;

    //  set namespace
    virtual void SetProfileNamespace(PCWSTR cszNameSpace) = 0;

	//  get namespace
    virtual HRESULT GetProfileNamespace(CStringW& strNameSpace) = 0;

    //  flags to be determined ...
    virtual  void SetProfileFlags(ULONG fFlags) = 0;
    virtual  ULONG GetProfileFlags() = 0;
    virtual  ULONG GetProfileMiscFlags() = 0;
    virtual  ULONG GetProfileVersion() = 0;

    virtual void SetInsertFlags(ULONG fFlags) = 0;

    //  passport cookies for login and member services ....
    // t&p stuff ....
    virtual HRESULT GenSecureTicket(CStringA* pSec) = 0;
    virtual HRESULT GenAuthTicket(CStringA* pAuth)  = 0;
    virtual HRESULT GenProfileCookie(CStringA* pProf) = 0;

    // customizable validation
    virtual VOID    SetValidationParams(CValidationParams&) = 0;

    // debug method
    virtual void Dump(CStringA& dump) = 0;
    virtual CPPCoreProfileStorage& GetRow() = 0;

	virtual HRESULT SetDictionaryObject(IDictionaryEx *ppiDict)=0;

};

//
//  wrapper for the abstract class. Use it to get
//  CUserProfile* interface
//
class CUserProfileWrapper : public CAutoPtr<CUserProfile>
{
public:
    CUserProfileWrapper();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\cuserprofileex.h ===
#pragma once

#include "profilefieldsconsts.h"
#include "profilefieldinfo.h"
#include "csite.h"

class CUserProfile2;


//
// customizaeble validation paramers
//
class CValidationParams
{
public:
    CValidationParams(LONG  lMinPwd = 6,
                      LONG  lMaxPwd = 16,
                      LONG  lMinMemberName = 1,
                      LONG  lMaxMemberName = 64,
                      LONG  lEmailLeft = 32,
                      LONG  lEmailRight = 32,
                      LONG  lMaxNickname = 30) :
    // default values ....
    m_lMinPwd(lMinPwd), m_lMaxPwd(lMaxPwd),
    m_lMinMemberName(lMinMemberName), m_lMaxMemberName(lMaxMemberName),
    m_lEmailLeft(lEmailLeft), m_lEmailRight(lEmailRight),
    m_lMaxNickname(lMaxNickname)
    {
    }
    // this is how to change'em
    VOID SetNewValues(LONG  lMinPwd = 8,
                      LONG  lMaxPwd = 16,
                      LONG  lMinMemberName = 1,
                      LONG  lMaxMemberName = 64,
                      LONG  lEmailLeft = 32,
                      LONG  lEmailRight = 32,
                      LONG  lMaxNickname = 30)
    {
        m_lMinPwd = lMinPwd, m_lMaxPwd=lMaxPwd,
        m_lMinMemberName = lMinMemberName, m_lMaxMemberName = lMaxMemberName,
        m_lEmailLeft = lEmailLeft, m_lEmailRight = lEmailRight;
        m_lMaxNickname = lMaxNickname;
    }
    void GetPwdParams(LONG& lmin, LONG& lmax) {
        lmin = m_lMinPwd, lmax = m_lMaxPwd;
    }
    void GetMemberNameParams(LONG& lmin, LONG& lmax){
        lmin = m_lMinMemberName, lmax = m_lMaxMemberName;
    }
    void GetEmailParams(LONG& lmailL, LONG& lmailR ){
        lmailL = m_lEmailLeft, lmailR = m_lEmailRight;
    }
    void GetNicknameParams(LONG& lmax){
        lmax = m_lMaxNickname;
    }
private:
    LONG    m_lMinPwd;
    LONG    m_lMaxPwd;
    LONG    m_lMinMemberName;
    LONG    m_lMaxMemberName;
    LONG    m_lEmailLeft;
    LONG    m_lEmailRight;
    LONG    m_lMaxNickname;
};


extern CProfileFieldInfo *g_pFieldInfo;

//
//  field description ...
//
class CProfileFieldState
{
public:
	CProfileFieldState(CStringA szName) 
	{
		m_bIsRequired = FALSE;
		m_lSectionID = -1;
		m_lValidationID = 0;

		m_pTag = g_pFieldInfo->GetFieldInfoByName(szName);
		if (m_pTag == NULL) 
		{	
			m_szFieldName = szName;
			m_bIsExternal = TRUE;
		}
		else
		{
			m_bIsExternal = FALSE;
			m_lValidationID = -1; // internal validation
		}
	}


	VARENUM GetSyntax()
	{
		if (m_bIsExternal) return VT_BSTR;
		return m_pTag->lSyntax;
	}

	LONG GetFieldID()
	{
		if (m_bIsExternal) return -1;
		return m_pTag->lFieldID;
	}

	LPCSTR GetFieldName()
	{
		if (!m_bIsExternal) return m_pTag->szField;
		return m_szFieldName;
	}

	BOOL GetIsRequired() { return m_bIsRequired; }
	void SetIsRequired(BOOL b) { m_bIsRequired = b; }

	BOOL GetIsExternal() { return m_bIsExternal; }

	LONG GetSectionID() { return m_lSectionID; }
	void SetSectionID(LONG l) { m_lSectionID = l; }
	
	LONG GetValidation() { return m_lValidationID; }
	void SetValidation(LONG l) 
	{ 
		if (GetIsExternal()) m_lValidationID = l; 
	}

	HRESULT GetHRMissing() 
	{ 
		if (GetIsExternal()) E_INVALIDARG;

		if (m_pTag)
			return m_pTag->hrMissing;
		else
			return S_OK;
	}

private:
	PCPROF_FIELD m_pTag;	// This variable is stored for performance reason
							// If a tag is passport supported, m_pTag points
							// to g_FieldInfo, which provides Syntax, FieldID,
							// and missing HR.

	CStringA    m_szFieldName;	// Store name of a non passport attribute.
								// GetFieldName points to m_pTag->cszField
								// instead of making another copy
    BOOL        m_bIsRequired;
    BOOL        m_bIsExternal;
	LONG		m_lSectionID;	// SectionID = -1 && bIsExternal indicates our internal "external item"

	// validation routine index
	// 0 = no validation
	// -1 = internal validation for passport supported fields
	// > 0 specify a validation routine for external items
	// For internal items, the object that owns the field
	// knows how to validate a particular field ID
	LONG		m_lValidationID;
	

};

typedef CAutoPtr<CProfileFieldState> CFieldStatePtr;



//
//  represent a field into profile. Should be initialized from
//  schema file in XML format ....
//
class   CProfileField
{
public:
    // get the field from the form ....
    CProfileField(CProfileFieldState *pField,
                  BOOL fIsRequired = FALSE,
				  BOOL fIsDirty = TRUE
				  ) :
                    m_dwErr(S_OK),
                    m_pTag(pField),
                    //  by default the field is set. Mark it not set if
                    //  necessary
                    m_fIsSet(TRUE),
					m_bIsDirty(fIsDirty)
    {
		pField->SetIsRequired(fIsRequired);
		m_lFieldID = pField->GetFieldID();
        // should probably throw an exception if pField is NULL .....
    }

	// virtual d-tor
    virtual ~CProfileField(){
    }


    // and from XML ....
    // and from Cookie ....

    //  get the value ....
    //  specific for field types
    //  make that class abstract ...
    virtual void GetStringValue(CStringW& Val) = 0;
    virtual void SetStringValue(LPCWSTR Val) = 0;
    HRESULT GetErrorCode()
    {
        return  m_dwErr;
    }
    //
    //  external validation setting errcodes ...
    //
    void SetErrorCode(HRESULT hr)
    {
        m_dwErr = hr;
    }

	//
	// Wrappers on CProfileFieldState when m_pTag is been invalidated
	// When no FieldState is provided
	//
	VARENUM GetSyntax()
	{
		if (m_pTag) return m_pTag->GetSyntax();

		PCPROF_FIELD ppf = g_pFieldInfo->GetFieldInfoByID(m_lFieldID);
		if (!ppf) return VT_BSTR;
		return ppf->lSyntax;
	}

	LONG GetFieldID()
	{
		return m_lFieldID;
	}

	LPCSTR GetFieldName()
	{
		if (m_pTag) return m_pTag->GetFieldName();

		PCPROF_FIELD ppf = g_pFieldInfo->GetFieldInfoByID(m_lFieldID);
		if (!ppf) return NULL;
		return ppf->szField;
	}

	BOOL GetIsRequired() 
	{ 
		if (m_pTag) return m_pTag->GetIsRequired();
		return FALSE;
	}

	BOOL GetIsExternal() 
	{ 
		if (m_pTag == NULL) return FALSE;
		return m_pTag->GetIsExternal();
	}

	LONG GetSectionID()
	{ 
		if (m_pTag == NULL) return -1;
		return m_pTag->GetSectionID(); 
	}

	BOOL SetSectionID(LONG l) 
	{ 
		if (m_pTag == NULL) return FALSE;
		m_pTag->SetSectionID(l); 
	}
	
	LONG GetValidation() 
	{ 
		if (m_pTag == NULL) return -1;  // internal validation
		return m_pTag->GetValidation();
	}

	BOOL SetValidation(LONG l) 
	{ 
		if (m_pTag == NULL) return FALSE;
		// overwrite validation when when it is external
		if (m_pTag->GetIsExternal()) 
		{
			m_pTag->SetValidation(l); 
			return TRUE;
		}
		else return FALSE;
	}

	HRESULT GetHRMissing() 
	{ 
		if (m_pTag->GetIsExternal()) return PP_E_EXTERNALFIELD_BLANK;
		return m_pTag->GetHRMissing();	
	}


    // set up the item
    virtual HRESULT SetDBItem(CComVariant& v) = 0;

	//
	// Generate field that does not need runtime FieldState
	// This is used only for passport supported attributes
	//
	//void InvalidateFieldState() 
	//{ 
	//	m_pTag = NULL; 
	//}

	BOOL GetIsDirty() { return m_bIsDirty; }
	void SetIsDirty(BOOL b) { m_bIsDirty = b; }


protected:
    HRESULT     m_dwErr;
	BOOL        m_fIsSet;
	LONG		m_lFieldID;		// used when m_pTag is not valid
								// used for simple attribute that does not need
								// runtime FieldState, the FieldID
								// gives us access to g_FieldInfo

    CProfileFieldState *m_pTag;

	//
	// Used for persistence optimization
	//
	BOOL	m_bIsDirty;


};

typedef CAutoPtr<CProfileField> CProfFieldPtr;




//
//  This interface manages a list of profile fields.
//  Alternatively, field state list can be managed to
//  restrict the list of fields presented.
//
class CProfileFieldCollectionBase
{
public:

	virtual ~CProfileFieldCollectionBase(){};

	// A field is passport supported within the range that this object manages
	virtual BOOL IsFieldSupported(LPCSTR szName) = 0;

	// FieldName <- -> FieldID	; only for passport supported attributes
	virtual LPCSTR GetFieldNameByID(ULONG lFieldID) = 0;
	virtual LONG GetIDByFieldName(LPCSTR szName) = 0;

	// Retrive a field
	virtual CProfileField*   GetField(LPCSTR szName) = 0;
	virtual CProfileFieldState*   GetFieldState(LPCSTR szName) = 0;
	virtual HRESULT   GetFieldStateCount(LONG& lCount) =0;

	virtual HRESULT   GetFieldValue(LPCSTR szName, CStringW& cswValue) = 0;
	virtual HRESULT   GetFieldValue(LPCSTR szName, LONG& lValue) = 0;
	virtual HRESULT   GetFieldValue(LPCSTR szName, CComBSTR& bstrValue) = 0;
	virtual HRESULT   GetFieldError(LPCSTR szName) = 0;
	
	virtual HRESULT   SetFieldError(LPCSTR szName, HRESULT h) =0;
	virtual HRESULT   GetFieldErrorCount(LONG& lCount) =0;
  
	// Validation
	virtual LONG   Validate() = 0;
	virtual HRESULT   Validate(CProfileField *ppf) = 0;
	virtual LONG ValidateSection(LONG lSectionNum)=0;

	// Field management
	virtual HRESULT UpdateField(LPCSTR  cszName, LPCWSTR cszValue)=0;
	virtual HRESULT UpdateField(LPCSTR  cszName, LONG lValue)=0;
    virtual HRESULT AddField(LPCSTR cszName, PCWSTR    value)=0;
	virtual HRESULT DeleteField(LPCSTR cszName)=0;

	// DB initialization
    virtual HRESULT InitFromDB(LARGE_INTEGER PUID, CStringW cswCredName)=0;
	virtual HRESULT Persist(LARGE_INTEGER& PUID, CStringW& cswCredName, BOOL bInsert)=0;

	// Web initialization
	virtual HRESULT InitFromHTMLForm(CHttpRequest& request)=0;
	virtual HRESULT InitFromQueryString(CHttpRequest& request)=0; 
	virtual HRESULT InitFromXML(IXMLDOMDocument *pXMLDoc)=0;


	// Save all fields in XML format and append to szProfileXML	
	virtual HRESULT SaveToXML(CStringA &szProfileXML) = 0;
	//
	// Manage FieldStates.  
	// It stores a list of fields requirements.
	// Used when only a subset of fields belonging to the category are needed
	//
	virtual HRESULT InitFieldStates()=0;
	//virtual HRESULT AddFieldState(LONG lFieldID, bool bRequired = true)=0;
	virtual HRESULT AddFieldState(LPCSTR szName, bool bRequired = true, bool bExternal = false)=0;
	//virtual HRESULT DeleteFieldState(LONG lFieldID)=0;
	virtual HRESULT DeleteFieldState(LPCSTR szsName)=0;
	virtual HRESULT DeleteFieldStates()=0;

	virtual	HRESULT StartEnumFields(POSITION &pos)=0;
	virtual	HRESULT GetNextField(POSITION& pos, CStringA& fname, CStringW& fvalue)=0;
	virtual	HRESULT StartEnumErrors(POSITION& pos)=0;
	virtual	HRESULT GetNextError(POSITION& pos, CStringA& fname, HRESULT& fhr)=0;


};


// In DB, 
//  set @si_ProfileCategory = 1
//  set @si_SystemCategory = 2
//  set @si_ProfileConsentCategory = 3
//(never change)  defined in DB
typedef enum _tagProfileCategory
{
	PROFCAT_INVALID = -1,
	PROFCAT_FIRST=0,
	PROFCAT_CREDENTIAL = PROFCAT_FIRST,		// 0
	PROFCAT_PROFILE,						// 1	
	PROFCAT_SYSTEM,							// 2	
	PROFCAT_PROFILECONSENT,					// 3    
	PROFCAT_CREDENTIALCONSENT,				// 4 
	PROFCAT_SYSTEMCONSENT,					// 5
	PROFCAT_VOLATILE,						// 6
	PROFCAT_LAST,
	
} PROFILE_CATEGORY;

#define PROFCAT_NUM 3

typedef enum _tagCredentialType
{
	PROFCRED_INVALID = -1,
	PROFCRED_FIRST=0,
	PROFCRED_EMAIL = PROFCAT_FIRST,		// email, password
	PROFCRED_EMAILSQA,					// email, password, secret question, secret answer
	PROFCRED_MOBILE,					// phone, pin
//	PROFCRED_EMAIL3SQA,					// email, password, SQ1, SA1, SQ2, SA2, SQ3, SA3
	PROFCRED_3SQAPIN,					// SQ1, SA1, SQ2, SA2, SQ3, SA3, PIN, SA1_Verify, SA2_Verify, SA3_Verify
	PROFCRED_LAST,
} PROFILE_CREDENTIALTYPE;


//
//  user profile interface. An abstract class ...
//
class CUserProfileBase : public CProfileFieldCollectionBase
{
public:
    //  this need to be defined for the autoptr ....
    //  all other functions are pure virtual
    virtual ~CUserProfileBase(){};

	//*******************************************************************
	// CProfileFieldCollectionBase interface to access to fields
	//
		// A field is passport supported within the range that this object manages
	virtual BOOL IsFieldSupported(LPCSTR szName) = 0;

	// FieldName <- -> FieldID	; only for passport supported attributes
	virtual LPCSTR GetFieldNameByID(ULONG lFieldID) = 0;
	virtual LONG GetIDByFieldName(LPCSTR szName) = 0;

	// Retrive a field
	virtual CProfileField*   GetField(LPCSTR szName) = 0;
	virtual CProfileFieldState*   GetFieldState(LPCSTR szName) = 0;
	virtual HRESULT   GetFieldStateCount(LONG& lCount) =0;

	virtual HRESULT   GetFieldValue(LPCSTR szName, CStringW& cswValue) = 0;
	virtual HRESULT   GetFieldValue(LPCSTR szName, LONG& lValue) = 0;
	virtual HRESULT   GetFieldValue(LPCSTR szName, CComBSTR& bstrValue) = 0;
	virtual HRESULT   GetFieldError(LPCSTR szName) = 0;
	
	virtual HRESULT   SetFieldError(LPCSTR szName, HRESULT h) =0;
	virtual HRESULT   GetFieldErrorCount(LONG& lCount) =0;
  
	// Validation
	virtual LONG   Validate() = 0;
	virtual HRESULT   Validate(CProfileField *ppf) = 0;

	// Field management
	virtual HRESULT UpdateField(LPCSTR  cszName, LPCWSTR cszValue)=0;
	virtual HRESULT UpdateField(LPCSTR  cszName, LONG lValue)=0;
    virtual HRESULT AddField(LPCSTR cszName, PCWSTR    value)=0;
	virtual HRESULT DeleteField(LPCSTR cszName)=0;

	// DB initialization
    virtual HRESULT InitFromDB(LARGE_INTEGER PUID, CStringW cswCredName)=0;
	virtual HRESULT Persist(LARGE_INTEGER& PUID, CStringW& cswCredName, BOOL bInsert)=0;

	// Web initialization
	virtual HRESULT InitFromHTMLForm(CHttpRequest& request)=0;
	virtual HRESULT InitFromQueryString(CHttpRequest& request)=0; 
	virtual HRESULT InitFromXML(IXMLDOMDocument *pXMLDoc)=0;


	// Save all fields in XML format and append to szProfileXML	
	virtual HRESULT SaveToXML(CStringA &szProfileXML) = 0;
	//
	// Manage FieldStates.  
	// It stores a list of fields requirements.
	// Used when only a subset of fields belonging to the category are needed
	//
	virtual HRESULT InitFieldStates(LONG lSiteID, CStringA cszDevice, CSite* in_pCSite = NULL, BOOL bIsService = FALSE)=0;
	//virtual HRESULT AddFieldState(LONG lFieldID, bool bRequired = true)=0;
	virtual HRESULT AddFieldState(LPCSTR szName, bool bRequired = true, bool bExternal = false)=0;
	//virtual HRESULT DeleteFieldState(LONG lFieldID)=0;
	virtual HRESULT DeleteFieldState(LPCSTR szsName)=0;
	virtual HRESULT DeleteFieldStates()=0;

	virtual	HRESULT StartEnumFields(POSITION &pos)=0;
	virtual	HRESULT GetNextField(POSITION& pos, CStringA& fname, CStringW& fvalue)=0;
	virtual	HRESULT StartEnumErrors(POSITION& pos)=0;
	virtual	HRESULT GetNextError(POSITION& pos, CStringA& fname, HRESULT& fhr)=0;

	//
	//
	//
	//**********************************************************************

	// Set Dictionary, Locale or Regional Information for Validation purpose
	virtual void SetDictionaryObject(IDictionaryEx *ppiDict)=0;
	virtual IDictionaryEx* GetDictionaryObject()=0;

	virtual void SetLCID(LCID lc)=0;
	virtual LCID GetLCID()=0;
#if 0
	// Maintain fields version
	virtual void SetVersion(LONG l)=0;
	virtual LONG GetVersion()=0;
#endif
	virtual PROFILE_CATEGORY GetCategory(LPCSTR szFieldName)=0;


	// debug method
    virtual void Dump(PROFILE_CATEGORY cat, CStringA& dump) = 0;
#if 0
	//  get/set namespace
	virtual HRESULT GetProfileNamespace(CStringW& strNameSpace) = 0;
    virtual void SetProfileNamespace(PCWSTR cszNameSpace) = 0;
#endif
	// get/set credential type
	virtual void SetCredentialType(PROFILE_CREDENTIALTYPE t) = 0;
	virtual PROFILE_CREDENTIALTYPE GetCredentialType() =0;
	virtual HRESULT GetCredentialFieldName(CStringA& cszCredential) =0;
	virtual HRESULT GetCredResponseFieldName(CStringA& cszCredResponse) =0;
//	virtual BOOL Credential2PUID(LPCWSTR szMemberName, LARGE_INTEGER& PUID)=0;

	// consent
	virtual HRESULT GetConsent(LPCSTR cszFieldName, BOOL& bHasConsent)=0;
	virtual HRESULT SetConsent(LPCSTR cszFieldName, BOOL bHasConsent)=0;

	// get a list of External fields for generating ticket/cookie
	virtual HRESULT GetExternalProfileFields(CAtlArray<CStringA *>& pArray)=0;

	//$$ Should move to global caching later
	// Initialize Global Meta Info
//	virtual HRESULT InitGlobalMetaDataInfo()=0;

	// Enumeration: to control which category to enumerate
	virtual void SetEnumerationCategory(PROFILE_CATEGORY cat) =0;

	// Backward Compatibility
	virtual HRESULT GetSystemFlag_backward(LONG& lFlags) = 0;
	virtual HRESULT GetDirectoryFlag_backward(LONG& lFlags) = 0;
	virtual HRESULT GetSystemMiscFlag_backward(LONG& lFlags) = 0;
	
	// Retrieve error for last calling GetFieldValue
	virtual LPCWSTR   GetStringFieldValue(LPCSTR szName) = 0;
	virtual DATE	  GetDateFieldValue(LPCSTR szName) = 0;
	virtual LONG	  GetLongFieldValue(LPCSTR szName) = 0;
	virtual HRESULT	  GetLastFieldError() = 0;

	// Fine Tune category action control
	virtual LONG GetTaskMask() = 0;
	virtual void SetTaskMask(LONG l) = 0;

	// PUID access
	virtual LARGE_INTEGER GetPUID() = 0;
	virtual void GetPUID(LONG& lHigh, LONG& lLow)=0;
	virtual void SetPUID(LARGE_INTEGER l) = 0;
	virtual void SetPUID(LONG lHigh, LONG lLow) = 0;

	// DB flags access
	virtual void SetDBIsActive(BOOL b) = 0;
	virtual void SetDBIsManaged(BOOL b) = 0;
	virtual void SetDBIsOverwrite(BOOL b) = 0;
	virtual void SetDBIsCaseSensitive(BOOL b) = 0;
	virtual void SetDBAdminPUID(LARGE_INTEGER PUID)=0;

	virtual BOOL GetDBIsActive() = 0;
	virtual BOOL GetDBIsManaged() = 0;
	virtual BOOL GetDBIsOverwrite() = 0;
	virtual BOOL GetDBIsCaseSensitive() = 0;
	virtual LARGE_INTEGER GetDBAdminPUID()=0;

	// Wizard Section Processing
	virtual LONG GetSectionCount()=0;
	virtual HRESULT GetDeviceAttribute(CStringA szName, CStringW& wszValue)=0;

	// Set ProfileFieldInfo  -- replacing InitGlobalMetaData
	// init per app instead of per request
	virtual void SetProfileFieldInfo(CProfileFieldInfo *p) = 0;

	// Check whether a field is a volatile passport field
	virtual BOOL IsFieldPassportVolatile(LPCSTR szName) = 0;

	// Delete Member
	virtual HRESULT DeleteMember(LARGE_INTEGER PUID, CStringW &wszMemberName) = 0;

	// in order to make sure Persist does MemberName conversion
	virtual HRESULT GetDisplayMemberName(CStringW& cswMemberName) = 0;
	virtual HRESULT GetInternalName(BOOL bEASI, LPCWSTR m_cswNameSpace, CStringW& cswName) = 0;

	// IsEASI for managed domain member exclusion validation
	virtual BOOL GetIsEASI() = 0;
	virtual void SetIsEASI(BOOL b) = 0;
};


//
// Global validation function
//
BOOL VL_IsDropDownMissing(CProfileField *pField);

//
//  wrapper for the abstract class. Use it to get
//  CUserProfile* interface
//
class CUserProfileWrapper2 : public CAutoPtr<CUserProfileBase>
{
public:
    CUserProfileWrapper2();
};


#define	PROFILE_TASK_PROFILE					0x00000001
#define PROFILE_TASK_SYSTEM						0x00000002
#define PROFILE_TASK_PROFILECONSENT				0x00000004
#define PROFILE_TASK_SYSTEMCONSENT				0x00000008
#define PROFILE_TASK_CREDENTIALCONSENT			0x00000010

#define PROFILE_TASK_CREDENTIAL_ANY(l)			( l >= 10000 )

#define PROFILE_TASK_CREDENTIAL_NEW				0x00010000
#define PROFILE_TASK_CREDENTIAL_ADD_ADDITIONAL	0x00020000
#define PROFILE_TASK_CREDENTIAL_UPDATE			0x00040000
#define PROFILE_TASK_CREDENTIAL_RENAME			0x00080000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\cticket.h ===
//-----------------------------------------------------------------------------
//
//  @doc
//
//  @module CTicket.h | Declaration of the CTicket class.
//
//  Author: Darren Anderson
//
//  Date:   5/2/2000
//
//  Copyright <cp> 1999-2000 Microsoft Corporation.  All Rights Reserved.
//
//-----------------------------------------------------------------------------
#pragma once

//-----------------------------------------------------------------------------
//
//  @class CTicket | This class abstracts out a number of common ticket
//                   operations.
//
//-----------------------------------------------------------------------------

class CTicket
{
// @access  Protected members.
protected:

    // @cmember Has this instance been initialized?
    bool                m_bInitialized;

    // @cmember Ticket object used for satisfying most method calls.
    CComPtr<IPassportTicket2> m_piTicket;

    // @cmember Base handler object.
    CPassportHandlerBase* m_pHandler;

    // @cmember Create a new IPassportTicket object and save it in
    //          <md CTicket::m_piTicket>.
    void CreateTicketObject(void);

// @access  Public members.
public:

    //
    //  Note, two-phase construction.  Constructor followed
    //  by PutTicket.
    //

    // @cmember  Default constructor.
    CTicket();

    // @cmember  Default destructor.
    ~CTicket();

    //
    //  Pass in profile cookie.
    //

    // @cmember  Initialize this object with a ticket cookie string.
    void PutTicket(LPCWSTR szProfile);

    //
    //  Ticket object initialized and profile valid?
    //

    // @cmember  Has this instance been initialized?
    bool IsInitialized(void);

    // @cmember  Does this instance contain a valid ticket?
    bool IsValid(void);

    //
    //  Ticket accessor methods.
    //

    // @cmember  Determines if the current user is authenticated based on the
    // time window and force signin parameters passed in.
    bool IsAuthenticated(ULONG ulTimeWindow,
                         bool bForceSignin
                         );

    // @cmember  Return any network error stored within the ticket.
    ULONG GetError(void);

    // @cmember  Return the time that this ticket was created.
    LONG  TicketTime(void);

    // @cmember  Return the time that the user last typed their password.
    LONG  SignInTime(void);

    // @cmember  Return the time that the user last typed their PIN.
    LONG  PinTime(void);

    // @cmember  Return arbitrary property
    HRESULT GetPropertyValue(PWSTR pcszProperty, VARIANT *pvResult);

    // @cmember  Return the high portion of the user's member id.
    ULONG MemberIdHigh(void);

    // @cmember  Return the low portion of the user's member id.
    ULONG MemberIdLow(void);

    // @cmember  Did the user select 'Save My Password'?
    bool HasSavedPassword(void);

    //
    //  Ticket cookie manipulation functions.
    //

    // @cmember Create a 2.0 ticket cookie string
    //  using only information passed in.
    static void Make2(ULONG      ulMemberIdLow,
                      ULONG      ulMemberIdHigh,
                      LONG       lSignInTime,
                      LONG       lTicketTime,
                      bool       bSavePassword,
                      ULONG      ulError,
                      ULONG      ulSiteId,
                      USHORT     nKeyVersion,
                      LONG       nSkew,
                      ULONG      ulSecureLevel,
                      LONG       PassportFlags,
                      LONG       pinTime,
                      CStringW&  cszTicketCookie
                     );

    // @cmember Create a ticket cookie string using some information passed in,
    // as well as the internal ticket object.
    HRESULT Copy2(ULONG          ulSiteId,
                  USHORT         nKeyVersion,
                  LONG           nSkew,
                  ULONG          ulError,
                  ULONG          ulSecureLevel,
                  LONG           PassportFlags,
                  CStringW&      cszTicketCookie
                 );

    //  versions for 2.0. of Make and secure. Substitute security level
    //  for bSecure
    // @cmember Create a ticket cookie string using only information passed in.
    static void Make(ULONG      ulMemberIdLow,
                     ULONG      ulMemberIdHigh,
                     LONG       lSignInTime,
                     LONG       lTicketTime,
                     bool       bSavePassword,
                     ULONG      ulError,
                     ULONG      ulSiteId,
                     USHORT     nKeyVersion,
                     LONG       nSkew,
                     bool       bSecure,
                     CStringW&  cszTicketCookie
                     );

    // @cmember Create a ticket cookie string using some information passed in,
    // as well as the internal ticket object.
    HRESULT Copy(ULONG          ulSiteId,
                 USHORT         nKeyVersion,
                 LONG           nSkew,
                 ULONG          ulError,
                 bool           bSecure,
                 CStringW&      cszTicketCookie
                 );

    // @cmember Place the ticket cookie string into a Set-Cookie header in
    // the current response.
    static HRESULT Set(LPCWSTR szTicketCookie,
                       bool bPersist);

    // @cmember Place a ticket cookie expiration string into a Set-Cookie
    // header in the current response.
    static HRESULT Expire();

};

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\debugheap.hpp ===
#ifndef _DEBUG_HEAP_HPP_
#define _DEBUG_HEAP_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Rockall.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   The debug memory allocator.                                    */
    /*                                                                  */
    /*   The debug memory allocator checks all the memory allocation    */
    /*   calls to make sure they are reasonable.  If not then it        */
    /*   raises an execption at the point it detects a problem.         */
    /*                                                                  */
    /********************************************************************/

class ROCKALL_LINKAGE DEBUG_HEAP : public ROCKALL
    {
		//
		//   Private type definitions.
		//
		//   A debug heap places a collection of guard words
		//   before and after each allocation.  It checks
		//   these guard words everytime the allocation is
		//   examined or modified.
		//
		typedef struct
			{
			int						  Size;
			int						  StartGuard;
			}
		DEBUG_HEADER;

		typedef struct
			{
			char					  MidGuard[ sizeof(int) ];
			int						  EndGuard[1];
			}
		DEBUG_TRAILER;

		typedef struct
			{
			DEBUG_HEADER			  DebugHeader;
			DEBUG_TRAILER			  DebugTrailer;
			}
		DEBUG_GUARD;

    public:
        //
        //   Public functions.
		//
		//   A heaps public interface consists of a number
		//   of groups of related APIs.
        //
        DEBUG_HEAP
			( 
			int						  MaxFreeSpace = 0,
			bool					  Recycle = false,
			bool					  SingleImage = false,
			bool					  ThreadSafe = true 
			);

		//
		//   Manipulate allocations.
		//
		//   The first group of functions manipulate 
		//   single or small arrays of allocations. 
		//
		virtual bool Delete
			( 
			void					  *Address,
			int						  Size = NoSize 
			);

		virtual bool Details
			( 
			void					  *Address,
			int						  *Space = NULL 
			);

		virtual bool MultipleDelete
			( 
			int						  Actual,
			void					  *Array[],
			int						  Size = NoSize
			);

		virtual bool MultipleNew
			( 
			int						  *Actual,
			void					  *Array[],
			int						  Requested,
			int						  Size,
			int						  *Space = NULL,
			bool					  Zero = false
			);

		virtual void *New
			( 
			int						  Size,
			int						  *Space = NULL,
			bool					  Zero = false
			);

		virtual void *Resize
			( 
			void					  *Address,
			int						  NewSize,
			int						  Move = 1,
			int						  *Space = NULL,
			bool					  NoDelete = false,
			bool					  Zero = false
			);

		virtual bool Verify
			( 
			void					  *Address = NULL,
			int						  *Space = NULL 
			);

		//
		//   Manipulate the heap.
		//
		//   The second group of functions act upon a heap
		//   as a whole.
		//
		virtual void DeleteAll( bool Recycle = true );

		virtual void HeapLeaks( void );

		virtual void Truncate( int MaxFreeSpace = 0 );

		virtual bool Walk
			(
			bool					  *Active,
			void					  **Address,
			int						  *Space
			);

		//
		//   Low level heap interface.
		//
		//   The third group of functions are called by the
		//   heap to aquire or release large blocks of memory.
		//   These functions can be overloaded to enable the
		//   heap work in constrained environments.
		//
		virtual void *NewArea( int AlignMask,int Size );

        virtual ~DEBUG_HEAP( void );

	private:
		//
		//   Private functions.
		//
		//   A debug heap verifies each allocation using a 
		//   collection of private functions.
		//
		DEBUG_HEADER *ComputeHeaderAddress( void *Address )
			{
			register int HeaderSize = sizeof(DEBUG_HEADER);

			return ((DEBUG_HEADER*) (((char*) Address) - HeaderSize)); 
			}

		void *ComputeDataAddress( DEBUG_HEADER *Header )
			{ return ((void*) & Header[1]); }

		void ResetGuardWords( DEBUG_HEADER *Header,int TotalSize );

		void SetGuardWords( DEBUG_HEADER *Header,int Size,int TotalSize );

		void TestGuardWords( DEBUG_HEADER *Header,int TotalSize );

		void UnmodifiedGuardWords( DEBUG_HEADER *Header,int TotalSize );

		void UpdateGuardWords( DEBUG_HEADER *Header,int Size,int TotalSize );

        //
        //   Disabled operations.
		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        DEBUG_HEAP( const DEBUG_HEAP & Copy );

        void operator=( const DEBUG_HEAP & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\dbgutil.h ===
// dbgutil.h -  Debug Functions and Macros

/*
	The main macros are:

	ASSERT - display error if parameter evalulates to FALSE.
		e.g. ASSERT(x == y);

	ERROR_OUT - always print this error.  Messagebox is optional.
		e.g. ERROR_OUT(("Unable to FooBar!  Err=%d", dwErr));

	WARNING_OUT - warning message, not an error (App must call InitDebugModule)
		e.g. WARNING_OUT(("FooBar is not available. Using %s", szAlt));

	TRACE_OUT - debug message (App must call InitDebugModule)
		e.g. TRACE_OUT(("dwFoo=%d, dwBar=%d", dwFoo, dwBar));

	DBGMSG - debug message for a specific zone
		e.g. DBGMSG(ghZoneFoo, ZONE_BAR, ("Setting dwFoo=%d", dwFoo));


Important Functions:
	VOID DbgInit(HDBGZONE * phDbgZone, PTCHAR * psz, UINT cZone);
	VOID DbgDeInit(HDBGZONE * phDbgZone);
	VOID WINAPI DbgPrintf(PCSTR pszPrefix, PCSTR pszFormat, va_list ap);
	PSTR WINAPI DbgZPrintf(HDBGZONE hZone, UINT iZone, PSTR pszFormat,...);

	Note: The strings in these functions, in particular the module and
	zone names, are always ANSI strings, even in Unicode components.  The
	input strings to DBGINIT should not be wrapped in TEXT macros.


 *	When		Who					What
 *	--------	------------------	---------------------------------------
 *	2.26.98		Yoram Yaacovi		Adapted from NetMeeting and modified (generalized)
 *  7.17.98     scottcot            Added PDBGDATA::fRunningAsService support
*/
 
#ifndef _DBGUTIL_H_
#define _DBGUTIL_H_

#include <mspputil.h>
#include <stock.h>

#ifdef __cplusplus
extern "C" {
#endif
#include <pshpack8.h> /* Assume 8 byte packing throughout */

// deal with including "debug.h" before and after
#ifdef DEBUGMSG
#undef DEBUGMSG
#endif
#define _DEBUG_H

// MFC also defines this - use our version
#ifdef ASSERT
#undef ASSERT
#endif

#ifdef DEBUG
#ifndef DEBUG_UTIL
#define DEBUG_UTIL
#endif
#endif /* DEBUG */

// Special NetMeeting Debug definitions
#ifdef DEBUG_UTIL


//////////////////////////////////////
// Special Mutex Macros
#define ACQMUTEX(hMutex, msec)													\
	while (WaitForSingleObject(hMutex, msec) == WAIT_TIMEOUT)		\
	{																			\
		ERROR_OUT(("Thread 0x%x waits on mutex\n", GetCurrentThreadId()));		\
	}																			\
		
#define RELMUTEX(hMutex)	ReleaseMutex(hMutex)

//////////////////////////////////////
//Debug Zones

#define MAXNUM_OF_MODULES			64
#define MAXSIZE_OF_MODULENAME		32
#define MAXNUM_OF_ZONES				16
#define MAXSIZE_OF_ZONENAME			32

#define ZONEINFO_SIGN				0x12490000


// Zone information for a module
typedef struct _ZoneInfo
{
	ULONG	ulSignature;
	ULONG	ulRefCnt;
	ULONG	ulZoneMask; //the zone mask
	BOOL	bInUse;
	CHAR	pszModule[MAXSIZE_OF_MODULENAME];	//name against which the zones are registered
	CHAR	szZoneNames[MAXNUM_OF_ZONES][MAXSIZE_OF_ZONENAME]; //names of the zones
	CHAR	szFile[MAX_PATH];	                // output file, specific to this module
}ZONEINFO,*PZONEINFO;

// DBGZONEPARAM replaced by ZONEINFO
#define DBGZONEINFO ZONEINFO
#define PDBGZONEINFO PZONEINFO
	
typedef PVOID HDBGZONE;

// size of the memory mapped file
#define CBMMFDBG (sizeof(ZONEINFO) * MAXNUM_OF_MODULES + sizeof(DBGDATA))

// General information at end of memory-mapped file (after all zone data)
typedef struct _DbgData {
	BOOL  fOutputDebugString;  // OutputDebugString is enabled
	BOOL  fWinOutput;          // Window Output is enabled
	HWND  hwndCtrl;            // Window that handles output
	UINT  msgDisplay;          // Message to post to hwndCtrl
	BOOL  fFileOutput;         // File Output is enabled
	CHAR  szFile[MAX_PATH];    // File name for output
	BOOL  fShowTime;           // Dump Time (TickCount) with each message
	BOOL  fShowThreadId;       // Dump ThreadId with each message
	BOOL  fShowModule;         // Dump Module:Zone with each message
	BOOL  fAssertBreak;        // Break in AssertProc
    BOOL  fRunningAsService;   // running as a service? service-friendly message boxes then
} DBGDATA;
typedef DBGDATA * PDBGDATA;


extern BOOL      WINAPI     DbgRegisterCtl(HWND hwnd, UINT uDisplayMsg);
extern BOOL      WINAPI     DbgDeregisterCtl(HWND hwnd);
extern BOOL      WINAPI     DbgSetLoggingOptions(HWND hwnd, UINT uOptions);
extern void      WINAPI     DbgFlushFileLog();
extern BOOL      WINAPI     DbgGetAllZoneParams(PDBGZONEINFO *plpZoneParam, UINT * puCnt);
extern BOOL      WINAPI     DbgFreeZoneParams(PDBGZONEINFO pZoneParam);

extern HDBGZONE  WINAPI     DbgCreateZone(LPSTR pszName);
extern VOID      WINAPI     DbgDeleteZone(LPSTR pszName, HDBGZONE hDbgZone);
extern BOOL      WINAPI     DbgSetZone(HDBGZONE hDbgZone,PDBGZONEINFO pZoneParam);
extern PDBGDATA  WINAPI     GetPDbg(void);
extern VOID      WINAPI     DbgSetZoneFileName(HDBGZONE hDbgZone, LPCSTR pszFile);

extern PZONEINFO PROJINTERNAL FindZoneForModule(LPCSTR pszModule);
extern PZONEINFO PROJINTERNAL AllocZoneForModule(LPCSTR pszModule);
extern PZONEINFO PROJINTERNAL MapDebugZoneArea(void);
extern VOID      PROJINTERNAL UnMapDebugZoneArea(void);

extern VOID      PROJINTERNAL InitDbgZone(void);
extern VOID      PROJINTERNAL DeInitDbgZone(void);
extern VOID      PROJINTERNAL SetDbgFlags(void);
extern VOID      PROJINTERNAL SetDbgRunAsService(BOOL fRunningAsService);

// Special reserved strings
#define SZ_DBG_MAPPED_ZONE TEXT("_DebugZoneMap")
#define SZ_DBG_FILE_MUTEX  TEXT("_DbgFileMutex")
#define SZ_DBG_ZONE_MUTEX  TEXT("_DbgZoneMutex")


#define GETZONEMASK(z)  ((z) ? (((PZONEINFO)(z))->ulZoneMask) : 0 )
#define IS_ZONE_ENABLED(z, f) ((((PZONEINFO)(z))->ulZoneMask) & (f))

// Macro to check if zone is enabled:  h = ghZone,  i = zone index
#define F_ZONE_ENABLED(h, i)  ((NULL != h) && IS_ZONE_ENABLED(h, (1 << i)))


// Standard Zones
#define ZONE_WARNING           0
#define ZONE_TRACE             1
#define ZONE_FUNCTION          2

#define ZONE_WARNING_FLAG   0x01
#define ZONE_TRACE_FLAG     0x02
#define ZONE_FUNCTION_FLAG  0x04


////////////////////////////////////////////
// Functions
VOID PROJINTERNAL AssertProc(PCSTR pszAssert, PCSTR pszFile, UINT uLine);
VOID WINAPI     DbgPrintf(PCSTR pszPrefix, PCSTR pszFormat, va_list ap);
PSTR WINAPI     DbgZPrintf(HDBGZONE hZone, UINT iZone, PSTR pszFormat,...);
PSTR WINAPI     DbgZVPrintf(HDBGZONE hZone, UINT iZone, PSTR pszFormat, va_list ap);

VOID PROJINTERNAL DbgInitEx(HDBGZONE * phDbgZone, PCHAR * psz, UINT cZone, long ulZoneDefault);
VOID PROJINTERNAL DbgDeInit(HDBGZONE * phDbgZone);

INLINE VOID DbgInit(HDBGZONE * phDbgZone, PCHAR * psz, UINT cZones)
{
	DbgInitEx(phDbgZone, psz, cZones, 0);
}

PSTR PszPrintf(PCSTR pszFormat,...);

#endif /* DEBUG_UTIL */


////////////////////////////////////////////
// Main Macros
#ifdef DEBUG
#define DBGINIT(phZone, psz)    DbgInit(phZone, psz, (sizeof(psz)/sizeof(PCHAR))-1)
#define DBGDEINIT(phZone)       DbgDeInit(phZone)
#define SETDBGRUNASSERVICE(f)   SetDbgRunAsService(f)

#define ASSERT(exp)     ((!(exp)) ? AssertProc((PCSTR)#exp,__FILE__,__LINE__) : 0)

#define SET_DEBUG_METHOD_NAME(name) const TCHAR *__szMethod = name;
#define DEBUG_METHOD_NAME   __szMethod

PSTR WINAPI DbgZPrintError(PCSTR pszFile, UINT uLine, PSTR pszMsg);
VOID WINAPI DbgZPrintWarning(PSTR pszFormat,...);
VOID WINAPI DbgZPrintTrace(PSTR pszFormat,...);
VOID WINAPI DbgZPrintFunction(PSTR pszFormat,...);
VOID WINAPI RetailPrintfTrace(LPCSTR lpszFormat, ...);

#define ERROR_OUT(s)	LocalFree(DbgZPrintError(__FILE__, __LINE__, PszPrintf s))
#define WARNING_OUT(s)	DbgZPrintWarning s
#define TRACE_OUT(s)	DbgZPrintTrace s
//	RETAILMSG: Prints a message to the debug output
//	NOTE: available in all builds, depends on the registry flag
#define RETAILMSG(x)	RetailPrintfTrace x

// DebugBreak based on a registry entry
#define DEBUGTRAP		DebugTrapFn()

#define DBGMSG(z, i, s)                                             \
   {                                                                \
      if ((NULL != z) && (((PZONEINFO)(z))->ulZoneMask & (1<<i)) )  \
      {                                                             \
         LocalFree(DbgZPrintf(z, i, PszPrintf s));                  \
      }                                                             \
   }
// e.g. DBGMSG(ghZone, ZONE_FOO, ("bar=%d", dwBar))

#else
#define DBGINIT(phZone, psz)
#define DBGDEINIT(phZone)
#define SETDBGRUNASSERVICE(f)
#define ASSERT(exp)

#define SET_DEBUG_METHOD_NAME(name)
#define DEBUG_METHOD_NAME   NULL

#define ERROR_OUT(s)
#define WARNING_OUT(s)
#define TRACE_OUT(s)

#ifndef DBGMSG
#define DBGMSG(z, f, s)
#endif

#endif /* DEBUG */


#include <poppack.h> /* End byte packing */

#ifdef __cplusplus
}
#endif

#endif /* _DBGUTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\dbgmacro.h ===
/*
 -  DBGMACRO.H
 -
 *	Annotations and Virtual Communities
 *	Macros for tracing functions
 *
 *	Revision History:
 *
 *	When		Who					What
 *	--------	------------------	---------------------------------------
 *	3.8.98		Ahalim				Created
 *
 */

#ifndef __DBGMACRO_H_
#define __DBGMACRO_H_

#define TRACE(x)	 TRACE_OUT((x))

#ifdef DEBUG

#define SET_DEBUG_FUNCTION_NAME(x) \
    char *__pszFunctionName = x

#define DEBUG_FUNCTION_NAME       __pszFunctionName

#define ENTER(x)	\
	SET_DEBUG_FUNCTION_NAME(x); \
	DbgZPrintFunction("%s() entered", DEBUG_FUNCTION_NAME)

#define LEAVE()	\
	DbgZPrintFunction("%s() exited", DEBUG_FUNCTION_NAME)

#define VERIFY(f)	ASSERT(f)

#else // RETAIL


#define VERIFY(f)	((void)(f))

#define SET_DEBUG_FUNCTION_NAME(x)
#define DEBUG_FUNCTION_NAME

#define ENTER(x)
#define LEAVE()

#endif // DEBUG/RETAIL

#endif	// __DBGMACRO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\domainfunctions.h ===
// DomainFunctions.h

#ifndef __DomainFunctionsH__
#define __DomainFunctionsH__

enum DA_DOMAINID
{
    DADOMAINID_NONE = 0,
    DADOMAINID_HOTMAIL = 1,
    DADOMAINID_MSN = 2,
    DADOMAINID_PASSPORT = 3
};

//todo -- deprecate this.  use the one that takes wchar*
bool DoesDomainExist(const char *szCheckDomain);
// Check the domain if it is supported by the local database
bool DoesDomainExist(LPCWSTR pwszCheckDomain, int *pDAID=NULL);

HRESULT GetLocalDomainId(ULONG& ulDomainId);
void GetLocalDomainName(CComBSTR & pbstrDomainName);
HRESULT GetLocalDomainName(BSTR* pbstrDomainName);

// Get the name of a given domain Id
void GetDomainName(ULONG ulDomainId, CComBSTR &bstrDomain);
// A thin wrapper of the previous function
HRESULT GetDomainName(ULONG ulDomainId, BSTR* pbstrDA);

// Get the DA domain Id
void PassportDADomainId(ULONG &ulPPDADomainId);
// Get the DA domain name
void PassportDADomain(CComBSTR &bstrPPDADomain, bool bRaw = true);

// Check the domain in partner.xml
bool DoesDomainExist_PartnerXML(const BSTR &bstrDomain);

// Allow name change? (bOldName indicates this is old name or new name)
bool DomainAllowNameChange(CStringW& szSignInName, bool bOldName);

bool IsDomainManaged(const CStringW& szwDomainName);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\defaultheap.hpp ===
#ifndef _DEFAULT_HEAP_HPP_
#define _DEFAULT_HEAP_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#ifdef _DEBUG
#include "DebugHeap.hpp"
typedef DEBUG_HEAP DEFAULT_HEAP;
#else
#include "FastHeap.hpp"
typedef FAST_HEAP DEFAULT_HEAP;
#endif

    /********************************************************************/
    /*                                                                  */
    /*   Default heap.                                                  */
    /*                                                                  */
    /*   The default heap is available for everyone as soon as the      */
    /*   memory allocator DLL has loaded.                               */
    /*                                                                  */
    /********************************************************************/

extern ROCKALL_LINKAGE DEFAULT_HEAP DefaultHeap;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\disp.h ===
/*++

    Copyright (c) 1998 Microsoft Corporation

    Module Name:

        Disp.h

    Abstract:

        Definitions for lightweight IDispatch implementation.

    Author:

        Darren L. Anderson (darrenan) 25-Jun-1998

    Revision History:

        25-Jun-1998 darrenan

            Created.
--*/

#ifndef _DISP_H
#define _DISP_H

typedef HRESULT (STDMETHODCALLTYPE* DISPFUNC)(WORD, DISPPARAMS*, VARIANT*, void*);

typedef struct _DISPMETHOD
{
    WCHAR*      wszName;
    DISPFUNC    pfn;
}
DISPMETHOD;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\emailsigninfunctions.h ===
// EmailSignInFunctions.h

#ifndef __EmailSignInFunctionsH__
#define __EmailSignInFunctionsH__

HRESULT ConvertSignInForEmail(IPDBAgent *pIPDBAgent, char *szDomain, char **ppszSignInName);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\emailstr.h ===
// Emailstr.h

#ifndef __EmailstrH__
#define __EmailstrH__

bool IsEMail(LPCWSTR pwszName);

// a@b.com -> a%b.com (stored internally)
void EMail2Name(CStringW & cwszName);
// A thin wrapper of the previous function
void EMail2Name(LPCWSTR pszwSrc, CStringW &szwDest);
// A thin wrapper of the previous function
void EMail2Name(LPCWSTR pszwSrc, CComBSTR &bstrDest);

// a%b.com <- a@b.com (stored internally)
void Name2EMail(CStringW & cwszName);
// A thin wrapper of the previous function
void Name2EMail(LPCWSTR pszwSrc, CStringW &szwDest);
// A thin wrapper of the previous function
void Name2EMail(LPCWSTR pszwSrc, CComBSTR &bstrDest);

// a%b.com@passport.com -> a@passport.com
// a@passport.com       -> a@passport.com
void Name2AltName(LPCWSTR pwszName, CStringW & cwszAltname);
// a%b.com@passport.com -> a@b.com
// a@passport.com       -> a@passport.com
void InternalName2Name(LPCWSTR pwszName, CStringW & cwszName);

void EMail2Domain(LPCWSTR pwszName, CStringW & cwszDomain);

void EMail2Login(LPCWSTR pwszName, CStringW & cwszLogin);

// a@passport.com -> FALSE
// a@b.com	      -> TRUE
BOOL IsEASI(LPCWSTR pwszName);

// a@passport.com -> a@passport.com
// a@b.com	      -> a%b.com@passport.com
void Name2InternalName(LPCWSTR pwszName, CStringW& cwszName);

void Reduce2MSN(LPCWSTR pwszName, CStringW & cszwName);
// A thin wrapper of the previous function
void Reduce2MSN(LPCWSTR pwszName, CComBSTR & bstrName);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\errorsupport.h ===
// ErrorSupport.h: interface/implementation for the CErrorSupport class.

#if !defined(AFX_ERRORSUPPORT_H__A7238E58_0795_11D2_A95C_0000F87584FA__INCLUDED_)
#define AFX_ERRORSUPPORT_H__A7238E58_0795_11D2_A95C_0000F87584FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


#ifndef FILENAME_AND_LINE
// Macros that allow the file name and line number to be passed in as a string.
#define LineNumberAsString(x)	_T(#x)
#define LineNumber(x)			LineNumberAsString(x)
#define FILENAME_AND_LINE		_T(" File ") _T(__FILE__) _T(" Line ") LineNumber(__LINE__)
#endif

class CErrorSupport  
{
public:

    CErrorSupport(LPCTSTR szErrorSource, LPCTSTR szEventSource);
	CErrorSupport(CLSID clsidMyCLSID, LPCTSTR szEventSource);

	virtual ~CErrorSupport() {};

	// szFormat is a string of format specifiers. 
	// Legal format specifiers are as below:
	// i -- long
	// h,x -- hex
	// e -- win32 error code
	// c -- currency
	// s -- TSTR
	void Log( HRESULT	hr,
				LPCTSTR	szLineNum, 
				LPCTSTR	szMethodName, 
				WORD	wCategory,
				WORD	wMsgType,
				DWORD	dwMsgID,
				LPCTSTR	szFormat, ...);

protected:

        CComBSTR m_bstrErrorSource;
        TCHAR  m_szEventSource[128];

 private:
	HRESULT	InternalBuildStringList(HRESULT		hr,
										LPCTSTR		szLineNum, 
										LPCTSTR		szMethodName, 
										LPCTSTR		pszFmt, 
										va_list		*pvl,
										CAtlArray<LPTSTR>		*prgStrings);

	HRESULT InternalFormatOneString(TCHAR cFmt, va_list *pvl, BSTR *pbstr);

	HRESULT InternalLogEvent(WORD dwCategory, DWORD dwMsgID, WORD wMsgType, DWORD cStrings, LPCTSTR *rgStrings);

};




#endif // !defined(AFX_ERRORSUPPORT_H__A7238E58_0795_11D2_A95C_0000F87584FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\exclusionfuncs.h ===
/* @doc
 *
 * @module ExclusionFuncs.h |
 *
 * Header file for ExclusionFuncs.cpp
 *
 * Author: Ying-ping Chen (t-ypchen)
 */
#pragma once

// @func	bool | IsUserExcluded | Check if the user is excluded
// @rdesc	Return the following values:
// @flag	true	| the user is EXCLUDED
// @flag	false	| the user is not excluded
bool IsUserExcluded(LPCWSTR pwszNameComplete);		// @parm	[in]	the complete username (e.g., aaa%bbb.org@ccc.com)

// @func	bool | RecordLoginFailure | Record a login failure of the user
// @rdesc	Return the following values:
// @flag	true	| the user is EXCLUDED (after too many failures)
// @flag	false	| the user is not excluded (after this failure)
bool RecordLoginFailure(LPCWSTR pwszNameComplete);	// @parm	[in]	the complete username (e.g., aaa%bbb.org@ccc.com)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\digest.h ===
/*++

    Copyright (c) 1998 Microsoft Corporation

    Module Name:

        CDigestAuth.h

    Abstract:

        This class performs digest authentication MD5 calculations.

    Author:

        Darren L. Anderson (darrenan) 5-Aug-1998

    Revision History:

        5-Aug-1998 darrenan

            Created.

--*/

#ifndef __DIGESTAUTH_H
#define __DIGESTAUTH_H

#include <windows.h>

#define DIGESTBUF_LEN  33

enum DIGEST_AUTH_NAMES
{
    DIGEST_AUTH_USERNAME=0,
    DIGEST_AUTH_REALM,
    DIGEST_AUTH_NONCE,
    DIGEST_AUTH_URI,
    DIGEST_AUTH_RESPONSE,
    DIGEST_AUTH_DIGEST,
    DIGEST_AUTH_ALGORITHM,
    DIGEST_AUTH_OPAQUE,
    DIGEST_AUTH_CNONCE,
    DIGEST_AUTH_QOP,
    DIGEST_AUTH_NC,
    DIGEST_AUTH_LAST
};

#ifdef __cplusplus
extern "C" {
#endif

VOID WINAPI
ToHex(
    LPBYTE pSrc,
    UINT   cSrc,
    LPSTR  pDst
    );
    
HRESULT WINAPI
DigestFromCreds(
    IN  LPCSTR  pszAlgorithm,
    IN  LPCSTR  pszUsername,
    IN  LPCSTR  pszRealm,
    IN  LPCSTR  pszPassword,
    IN  LPCSTR  pszNonce,
    IN  LPCSTR  pszNonceCount,
    IN  LPCSTR  pszCNonce,
    IN  LPCSTR  pszQOP,
    IN  LPCSTR  pszMethod,
    IN  LPCSTR  pszURI,
    IN  LPCSTR  pszEntityDigest,
    OUT LPSTR   pszSessionKey,
    OUT LPSTR   pszResult
    );

HRESULT WINAPI
DigestFromKey(
    IN  LPCSTR  pszAlgorithm,
    IN  LPCSTR  pszSessionKey,
    IN  LPCSTR  pszNonce,
    IN  LPCSTR  pszNonceCount,
    IN  LPCSTR  pszCNonce,
    IN  LPCSTR  pszQOP,
    IN  LPCSTR  pszMethod,
    IN  LPCSTR  pszURI,
    IN  LPCSTR  pszEntityDigest,
    OUT LPSTR   pszResult
    );


// Base64EncodeA and Base64EncodeW is provided for backward
// compatibility with the existing code only. 
HRESULT WINAPI
Base64EncodeA(               
    const LPBYTE    pSrc,
    ULONG           ulSrcSize,
    LPSTR           pszDst
    );

HRESULT WINAPI
Base64EncodeW(               
    const LPBYTE    pSrc,
    ULONG           ulSrcSize,
    LPWSTR          pszDst
    );

/*
HRESULT WINAPI
Base64DecodeA(
    LPCSTR      pszSrc,
    ULONG       ulSrcSize,
    LPBYTE      pDst
    );

HRESULT WINAPI
Base64DecodeW(
    LPCWSTR     pszSrc,
    ULONG       ulSrcSize,
    LPBYTE      pDst
    );
*/

/////////////////////////////////////////////////////////////////////////////////////

typedef unsigned char Byte;
typedef long SInt32;
typedef unsigned long UInt32;
typedef unsigned char Boolean;

void WINAPI 
Base64_DecodeBytes(                         // base-64 encode a series of blocks
                const char *pSource,        // the source (can be the same as the destination)
                char *pTerminate,           // the source termination characters
                Byte *rDest,                // the destination (can be the same as the source)
                SInt32 *rDestSize);         // the number of dest bytes

void WINAPI
UU_DecodeBytes(                             // uu decode a series of blocks
                const char *pSource,        // the source (can be the same as the destination)
                char *pTerminate,           // the source termination characters
                Byte *rDest,                // the destination (can be the same as the source)
                SInt32 *rSize);             // the number of source bytes

void WINAPI
MSUU_DecodeBytes(                           // ms uu decode a series of blocks
                const char *pSource,        // the source (can be the same as the destination)
                char *pTerminate,           // the source termination characters
                Byte *rDest,                // the destination (can be the same as the source)
                SInt32 *rSize);             // the number of source bytes

void WINAPI
SixBit_DecodeBytes(                         // six bit decode a series of blocks
                const char *pSource,        // the source (can be the same as the destination)
                char *pTerminate,           // the source termination characters
                const Byte *pFromTable,     // conversion table
                Byte *rDest,                // the destination (can be the same as the source)
                SInt32 *rSize);             // the number of source bytes

void WINAPI
Base64_DecodeStream(                        // base-64 decode a stream of bytes
                Byte *pRemainder,           // the remainder from a previous encode (returns any new remainder)
                SInt32 *pRemainderSize,     // the size of the remainder (returns new new remainder size)
                const char *pSource,        // the source
                SInt32 pSourceSize,         // the source size
                Boolean pTerminate,         // meaningless (for Base64_EncodeStream() compatibility)
                Byte *rDest,                // the destination
                SInt32 *rDestSize);         // returns the destination size

void WINAPI
UU_DecodeStream(                            // uu decode a stream of bytes
                Byte *pRemainder,           // the remainder from a previous encode (returns any new remainder)
                SInt32 *pRemainderSize,     // the size of the remainder (returns new new remainder size)
                const char *pSource,        // the source
                SInt32 pSourceSize,         // the source size
                Boolean pTerminate,         // meaningless (for Base64_EncodeStream() compatibility)
                Byte *rDest,                // the destination
                SInt32 *rDestSize);         // returns the destination size

void WINAPI
MSUU_DecodeStream(                          // ms uu decode a stream of bytes
                Byte *pRemainder,           // the remainder from a previous encode (returns any new remainder)
                SInt32 *pRemainderSize,     // the size of the remainder (returns new new remainder size)
                const char *pSource,        // the source
                SInt32 pSourceSize,         // the source size
                Boolean pTerminate,         // meaningless (for Base64_EncodeStream() compatibility)
                Byte *rDest,                // the destination
                SInt32 *rDestSize);         // returns the destination size

void WINAPI
SixBit_DecodeStream(                        // six bit decode a stream of bytes
                Byte *pRemainder,           // the remainder from a previous encode (returns any new remainder)
                SInt32 *pRemainderSize,     // the size of the remainder (returns new new remainder size)
                const char *pSource,        // the source
                SInt32 pSourceSize,         // the source size
                Boolean pTerminate,         // meaningless (for Base64_EncodeStream() compatibility)
                const Byte *pFromTable,     // conversion table
                Byte *rDest,                // the destination
                SInt32 *rDestSize);         // returns the destination size

void WINAPI
Base64_EncodeStream(                        // base-64 encode a stream of bytes
                Byte *pRemainder,           // the remainder from a previous encode (returns any new remainder)
                SInt32 *pRemainderSize,     // the size of the remainder (returns new new remainder size)
                const Byte *pSource,        // the source
                SInt32 pSourceSize,         // the source size
                Boolean pTerminate,         // terminate the stream
                char *rDest,                // the destination
                SInt32 *rDestSize);         // the destination size

void WINAPI
UU_EncodeStream(                            // uu encode a stream of bytes
                Byte *pRemainder,           // the remainder from a previous encode (returns any new remainder)
                SInt32 *pRemainderSize,     // the size of the remainder (returns new new remainder size)
                const Byte *pSource,        // the source
                SInt32 pSourceSize,         // the source size
                Boolean pTerminate,         // terminate the stream
                char *rDest,                // the destination
                SInt32 *rDestSize);         // the destination size

void WINAPI
MSUU_EncodeStream(                          // ms uu encode a stream of bytes
                Byte *pRemainder,           // the remainder from a previous encode (returns any new remainder)
                SInt32 *pRemainderSize,     // the size of the remainder (returns new new remainder size)
                const Byte *pSource,        // the source
                SInt32 pSourceSize,         // the source size
                Boolean pTerminate,         // terminate the stream
                char *rDest,                // the destination
                SInt32 *rDestSize);         // the destination size

void WINAPI
SixBit_EncodeStream(                        // six bit encode a stream of bytes
                Byte *pRemainder,           // the remainder from a previous encode (returns any new remainder)
                SInt32 *pRemainderSize,     // the size of the remainder (returns new new remainder size)
                const Byte *pSource,        // the source
                SInt32 pSourceSize,         // the source size
                Boolean pTerminate,         // terminate the stream
                const char *pToTable,       // conversion table
                char *rDest,                // the destination
                SInt32 *rDestSize);         // the destination size


void WINAPI
Base64_EncodeBytes(                         // base-64 encode a series of whole blocks
                const Byte *pSource,        // the source (can be the same as the destination)
                SInt32 pSourceSize,         // the number of source bytes
                char *rDest,                // the destination (can be the same as the source)
                SInt32 *rDesteSize);        // returns the dest size

void WINAPI
UU_EncodeBytes(                             // uu encode a series of whole blocks
                const Byte *pSource,        // the source (can be the same as the destination)
                SInt32 pSourceSize,         // the number of source bytes
                char *rDest,                // the destination (can be the same as the source)
                SInt32 *rDesteSize);        // returns the dest size

void WINAPI
MSUU_EncodeBytes(                           // ms uu encode a series of whole blocks
                const Byte *pSource,        // the source (can be the same as the destination)
                SInt32 pSourceSize,         // the number of source bytes
                char *rDest,                // the destination (can be the same as the source)
                SInt32 *rDesteSize);        // returns the dest size

void WINAPI
SixBit_EncodeBytes(                         // six bit encode a series of whole blocks
                const Byte *pSource,        // the source (can be the same as the destination)
                SInt32 pSourceSize,         // the number of source bytes
                const char *pToTable,       // conversion table
                char *rDest,                // the destination (can be the same as the source)
                SInt32 *rDesteSize);        // returns the dest size

extern const char cToBase64[66];
extern const Byte cFromBase64[257];
extern const char cToUU[66];
extern const Byte cFromUU[257];
extern const char cToMSUU[66];
extern const Byte cFromMSUU[257];

/////////////////////////////////////////////////////////////////////////////////////

HRESULT WINAPI 
GenerateNonce(BYTE *pSrcStr, 
              long lSrcSize, 
              BYTE *pDestStr, 
              long *plDestSize);


HRESULT WINAPI 
CheckNonce(BYTE* pNonce,
           long lSrcSize,
           long lTimeoutWindow = 300, // default to 5 minutes
           long lCurTime = 0);



#if defined(UNICODE) || defined(_UNICODE)
#define Base64Encode Base64EncodeW
//#define Base64Decode Base64DecodeW
#else
#define Base64Encode Base64EncodeA
//#define Base64Decode Base64DecodeA
#endif

BOOL
ParseAuthorizationHeader(
    LPSTR pszHeader, 
    LPSTR pValueTable[DIGEST_AUTH_LAST]
    );

#ifdef __cplusplus
}
#endif

#endif // __DIGESTAUTH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\globalobjects.h ===
/* @doc
 *
 * @module GlobalObjects.h |
 *
 * Header file for GlobalObjects.cpp
 *
 * Author: Ying-ping Chen (t-ypchen)
 */
#pragma once

#include "ComMD5.h"

// @func	void | GetGlobalLoginServer | Get the Passport LoginServer
// @rdesc	None
void GetGlobalLoginServer(ILoginServer **ppLoginServer);						// @parm	[out]	the LoginServer

// @func	void | GetGlobalExclusionList | Get the Passport ExclusionList
// @rdesc	None
//void GetGlobalExclusionList(IExclusionList **ppExclusionList);					// @parm	[out]	the ExclusionList

// @func	void | GetGlobalNetConfig | Get the Passport NetConfig
// @rdesc	None
void GetGlobalNetConfig(INetworkConfiguration **ppNetConfig);					// @parm	[out]	the NetConfig

// @func	void | GetGlobalPassportManager | Get the Passport Manager
// @rdesc	None
void GetGlobalPassportManager(IPassportManager **ppPassportManager);			// @parm	[out]	the PassportManager

// @func	void | GetGlobalNetworkServerCrypt | Get the NetworkServer Crypt
// @rdesc	None
void GetGlobalNetworkServerCrypt(INetworkServerCrypt **ppNetworkServerCrypt);	// @parm	[out]	the NetworkServerCrypt

// @func	void | GetGlobalPassportCrypt | Get the Passport Crypt
// @rdesc	None
void GetGlobalPassportCrypt(IPassportCrypt **ppPassportCrypt);					// @parm	[out]	the PassportCrypt

// @func	void | GetGlobalCoMD5 | Get the CoMD5
// @rdesc	None
void GetGlobalCoMD5(IMD5 **ppCoMD5);											// @parm	[out]	the CoMD5


HRESULT GetGlobalFieldInfo(IProfileFieldInfoCom **ppCoFieldInfoObj, LONG **ppFieldInfo);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\iishelper.hpp ===
/**************************************************************************
 * Copyright  1998-1999  Microsoft Corporation.  All Rights Reserved.
 *
 *    File Name: I I S H E L P E R . H P P
 *
 *    Purpose: class definition of CIISResponse
 *
 *    Creator:  
 *         (dd/mm/yy)
 *    Date: 13/4/1999
 *
 *    HISTORY:
 *     Modified By:
 *     Modified Date:
 *     Reason:
 *
 *************************************************************************/

#if !defined(_IISRESP_HPP_)
#define _IISRESP_HPP_


#define CZ_CGI_ALL_HTTP         "ALL_HTTP"
#define CZ_CGI_CONTENT_TYPE    "CONTENT_TYPE"
#define CZ_CGI_CONTENT_LENGTH  "CONTENT_LENGTH"
#define CZ_CGI_SOAPMethodName  "soapmethodname:"
#define CZ_CGI_SOAPAction      "soapaction:"
#define CZ_CGI_PATH_INFO       "PATH_INFO"


/**************************************************************************
 *  Include files
 *
 *************************************************************************/



/**************************************************************************
 *  Class Name: CIISResponse
 *
 *
 *************************************************************************/
class CIISHelper
{

// static methods
public:
   static BOOL SendResponse(EXTENSION_CONTROL_BLOCK* pECB, DWORD dwStatus, LPCSTR pStatus, DWORD dwStatusSize, LPCSTR pHeader, DWORD dwHeaderSize, LPCSTR pBody, DWORD dwBodySize, BOOL bReqDone, BOOL fConnectionClosed);
   static BOOL SendResponse(EXTENSION_CONTROL_BLOCK* pECB, DWORD dwStatus, BOOL bReqDone = TRUE);
   static HRESULT  GetECBServerVariable(IN EXTENSION_CONTROL_BLOCK * pECB, LPCSTR name, LPVOID* ppBuf, LPDWORD pLen) throw();
   static HRESULT  GetECBBodyData(IN EXTENSION_CONTROL_BLOCK * pECB, PBYTE buf, DWORD len, DWORD* copied);

   

// static methods
private:
   static BOOL FillOutHeaderInfo(DWORD dwStatus, LPSTR szStatus, LPSTR szHeader, LPSTR szMessage);
   

// static attributes
// private:
//   static HMODULE s_hModules;   // MSMQ FormatName RequestQueue
   
};

#endif // !defined(_IISRESP_HPP_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\fastheap.hpp ===
#ifndef _FAST_HEAP_HPP_
#define _FAST_HEAP_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Rockall.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   A fast heap.                                                   */
    /*                                                                  */
    /*   A fast heap tries to provide very good performance even        */
    /*   if that comes at a significant cost in terms of additional     */
    /*   memory usage.                                                  */
    /*                                                                  */
    /********************************************************************/

class ROCKALL_LINKAGE FAST_HEAP : public ROCKALL
    {
   public:
        //
        //   Public functions.
        //
        FAST_HEAP
			( 
			int						  MaxFreeSpace = 4194304,
			bool					  Recycle = true,
			bool					  SingleImage = false,
			bool					  ThreadSafe = true 
			);

        ~FAST_HEAP( void );

	private:
        //
        //   Disabled operations.
 		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        FAST_HEAP( const FAST_HEAP & Copy );

        void operator=( const FAST_HEAP & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\htmlfilt.h ===
#ifndef __FILTER_H__
#define __FILTER_H__

// Based on the filtering type (All or Table) tags in the given body will 
// be filtered. What the filter does with the tags will depend on the 
// next set of flags. The Disable/Remove Option will determine if the tags
// are removed or diabled by replacing the '<' with and &lt. The last flag
// controls whether or not embedded links like http:// are activated. If 
// a link is detected and not put into an <A> tag.
#define FILTERTAGS_FILTERALL        0x00000001
#define FILTERTAGS_FILTERTABLE      0x00000002

#define FILTERTAGS_ENABLELINKS      0x00000100


//+------------------------------------------------------------------------
//
//  Member:     HTML_FilterTags
//
//  Synopsis:   This function is used to filter HTML tags from a block of
//              text. Based on the flags the filtering routine can be used
//              to filter tags out, disable them, and can do a few other
//              types of filtering.
//
//  Arguments:  szContent   - This is the block of text that should be
//                            filtered. The filtering is done in place.
//                            Therefore depending on the flags, the block
//                            may grow and there must be enough space in
//                            the buffer for the expansion.
//              dwMaxLen    - This is the size of the buffer, and any
//                            can not exceeed these limits.
//              iFilterHow  - This controls what filtering process is 
//                            applied to the data.
//				pszNewBuffer- This will hold the adress of the dynamic
//							  buffer if there was a need to allocate one 
//				dwNewBufferSize - if not 0 and the initial string is not
//								large enough to hold the result, a new
//								buffer of that size will be allocated
//
//
//  Returns:    HRESULT
//
//              S_OK    - means that the data was successfully filtered and
//                        enough space existed to perform all required
//                        modifications to the data.
//
//  Notes:      The grsValidTags table is used to determine which tags
//              and attributes are allowed.
//
//-------------------------------------------------------------------------
HRESULT PROJINTERNAL HTML_FilterTagsA(const CHAR *szSrcContent, CHAR *szDestContent, DWORD *pdwMaxLen, int fFilterHow, CHAR** pszNewBuffer = NULL, DWORD dwNewBufferSize = 0);
HRESULT PROJINTERNAL HTML_FilterTagsW(const WCHAR *szSrcContent, WCHAR *szDestContent, DWORD *pdwMaxLen, int fFilterHow, WCHAR** pszNewBuffer = NULL, DWORD dwNewBufferSize = 0);

#ifdef UNICODE
#define HTML_FilterTags HTML_FilterTagsW
#else
#define HTML_FilterTags HTML_FilterTagsA
#endif

#endif  // __FILTER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\irtlmisc.h ===
/*++

   Copyright    (c)    1998-2000    Microsoft Corporation

   Module  Name :
       irtlmisc.h

   Abstract:
       Declares miscellaneous functions and classes in IisRtl.DLL

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/


#ifndef __IRTLMISC_H__
#define __IRTLMISC_H__

#include <windows.h>

//--------------------------------------------------------------------
// These declarations are needed to export the template classes from
// IisRtl.DLL and import them into other modules.

#ifndef IRTL_DLLEXP
# ifdef DLL_IMPLEMENTATION
#  define IRTL_DLLEXP __declspec(dllexport)
#  ifdef IMPLEMENTATION_EXPORT
#   define IRTL_EXPIMP
#  else
#   undef  IRTL_EXPIMP
#  endif 
# else // !DLL_IMPLEMENTATION
#  define IRTL_DLLEXP __declspec(dllimport)
#  define IRTL_EXPIMP extern
# endif // !DLL_IMPLEMENTATION 
#endif // !IRTL_DLLEXP



//--------------------------------------------------------------------
// Miscellaneous functions

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus


// how many CPUs on this machine?
inline int NumProcessors()
{
    static int s_nCPUs = 0;
    
    if (s_nCPUs == 0)
    {
        SYSTEM_INFO si;
        GetSystemInfo(&si);
        s_nCPUs = si.dwNumberOfProcessors;
    }
    return s_nCPUs;
}


// Type of processor, 386, 486, etc
inline int ProcessorType()
{
    static int s_nProcessorType = 0;
    
    if (s_nProcessorType == 0)
    {
        SYSTEM_INFO si;
        GetSystemInfo(&si);
        s_nProcessorType = si.dwProcessorType;
    }
    return s_nProcessorType;
}


#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __IRTLMISC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\hubapi.h ===
/*++

    Copyright (c) 1998 Microsoft Corporation

    Module Name:

        PassProvider.h

    Abstract:

        Header file for Provider implementations

    Author:

        Max Metral (mmetral) 12-Aug-1998

    Revision History:

        12-Aug-1998 mmetral

            Created.
     
--*/

#ifndef _HUBAPI_H_
#define _HUBAPI_H_

#include "PassportTypes.h"

/**
 * We use fixed size structure members here for efficiency.
 * If you don't want to write your own "AsciiToUniCpyN", here's an example
 * w/no error checking or null appending
 *
 * AsciiToUniCpyN(WCHAR* dest, CHAR* src, DWORD n)
 * {
 *   while ((n-- > 0) && (*(dest++)=(WCHAR) *(src++)))
 *    ;
 * }
 */

typedef struct _UserEntry
{
  CHAR   achMemberName[MAX_MEMBERNAME_LEN];
  CHAR   achContactEmail[MAX_CONTACTEMAIL_LEN];
  CHAR   achPassword[MAX_PASSWORD_LEN];
  char   achCountry [2];  // ISO
  CHAR   achPostalCode[MAX_POSTALCODE_LEN];
  DATE   dtBirthdate;
  GENDER Gender;
  CHAR   achMemberID[MAX_MEMBERID_LEN];
  CHAR   achAlias[MAX_ALIAS_LEN];
  ULONG  ulLanguagePreference;
  CHAR   achMSNGUID[MAX_MSNGUID_LEN];
  ULONG  ulProfileVersion;
  ULONG  ulFlags;
  BYTE*  pProviderInfo; // Pointer for provider's use
} 
UserEntry;

/**
 * Here are the function prototypes for providers.
 *
 * The function prototypes YOU (the provider implementor) must implement
 * are here too.  If you are an implementor, define _PROVIDER_IMPLEMENTATION_,
 * and the exports will be handled correctly
 */
#ifdef _PROVIDER_IMPLEMENTATION_
#define PROVEXPORT __declspec(dllexport)
#else
#define PROVEXPORT __declspec(dllimport)
#endif

#ifdef __cplusplus
extern "C" {
#endif
/**
 * Initializes provider.  Returns either:
 *  S_OK - Initialization succeeded, the hub should begin processing requests 
 *  E_FAIL - Initialization failed, the hub should generate the appropriate
 *           diagnostic events and abort startup 
 */
PROVEXPORT HRESULT WINAPI Init();

/**
 * Gets a member entry.
 *
 * pachRequestingDN
 *
 * The hub passes in the "distinguished name" of the requesting party.
 * In most cases this corresponds to the subject dn from the X.509
 * certificate used in the connection to the hub.  This can be useful for
 * filling in the pDomainReserved portion of the UserEntry.
 *
 * pachMemberName
 *
 * The Passport Id (including domain name) of the user to be retrieved.
 * For example, max@hotmail.com.
 *
 * pExistingEntry
 *
 * The hub passes in the existing cached UserEntry record (if any) for
 * examination by the provider.  The definition of the UserEntry
 * structure follows this function declaration.  pExistingEntry can be
 * NULL.
 *
 * ppNewEntry
 *
 * The provider should return the UserEntry to be used in authenticating
 * the user.  If the same, the provider should return pExistingEntry
 * here.  If there is no valid entry for the user, the Get function
 * should use the E_NO_USER return code.
 *
 * ppachDomainReserved
 *
 * The provider can pass back a value to be used for the pDomainReserved field
 * of the returned profile.  The caller does NO management of this memory.  The
 * likely solution is to place all possible values in the structure stored in 
 * pProviderInfo, and free them on Release.  This field is broken out to allow
 * different values to be delivered to different brokers without causing locking
 * problems.
 *
 * Returns:
 *  S_OK - A valid user entry was placed in ppNewEntry 
 *  E_NO_USER - There is no valid user entry for the user named by bstrMemberName 
 *  Other E_* code - A system failure has occurred, and should be logged accordingly 
 *
 */
PROVEXPORT HRESULT WINAPI Get(LPSTR pachRequestingDN, LPSTR pachMemberName,
			      ULONG* pulSchemaVersionRequest, 
			      ULONG* pulSchemaVersionResponse,
			      LPSTR* pachSchemaDefinition,
                              UserEntry *pExistingEntry, UserEntry **ppNewEntry,
                              LPSTR *ppachDomainReserved);

/**
 * Checks to see whether a member exists.  This can be implemented as a call
 * to Get, but to allow maximum performance, we push that decision down to the
 * individual provider.
 *
 * in parameters (dn and memberName) are same as Get
 *
 * Returns:
 *  S_OK - A valid user entry was placed in ppNewEntry 
 *  E_NO_USER - There is no valid user entry for the user named by bstrMemberName 
 *  Other E_* code - A system failure has occurred, and should be logged accordingly 
 *
 */
PROVEXPORT HRESULT WINAPI MemberExists(LPSTR pwchRequestingDN, LPSTR pachMemberName);

/**
 * Release gives the provider an opportunity to clean up UserEntry-s.
 */
PROVEXPORT void WINAPI Release(UserEntry *pUserEntry);

/**
 * This code number is arbitrary.  Should probably be more carefully 
 * chosen at some point.
 */
#define E_NO_USER   0x80ff0001
#define E_NO_SCHEMA 0x80ff0002

/**
 * INVALID_SCHEMA is used to terminate the list of desired schemas.
 */
#define INVALID_SCHEMA 0xffffffff
/**
 * ANY_SCHEMA is used as a wild card in the list of desired schemas
 */
#define ANY_SCHEMA     0x00000000

typedef HRESULT (CALLBACK* LPPROVINIT)();
typedef HRESULT 
   (CALLBACK* LPPROVGET)(LPSTR,LPSTR,ULONG*,ULONG*,LPSTR*,UserEntry*,UserEntry**,LPSTR*);
typedef HRESULT (CALLBACK* LPPROVMEXIST)(LPSTR,LPSTR);
typedef void (CALLBACK* LPPROVRELEASE)(UserEntry*);

#ifdef __cplusplus
} /* Extern C */
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\irtldbg.h ===
/*++

   Copyright    (c)    1998-2000    Microsoft Corporation

   Module  Name :
       irtldbg.h

   Abstract:
       Some simple debugging macros that look and behave a lot like their
       namesakes in MFC.  These macros should work in both C and C++ and do
       something useful with almost any Win32 compiler.

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/

#ifndef __IRTLDBG_H__
#define __IRTLDBG_H__

#ifndef __IRTLMISC_H__
# include <irtlmisc.h>
#endif

/* Ensure that MessageBoxes can popup */
# define RUNNING_AS_SERVICE 1

#include <tchar.h>

// Compile-time (not run-time) assertion. Code will not compile if
// expr is false. Note: there is no non-debug version of this; we
// want this for all builds. The compiler optimizes the code away.
template <bool> struct static_checker;
template <> struct static_checker<true> {};
#define STATIC_ASSERT(expr) static_checker<expr>()

# ifndef _AFX
  /* Assure compatiblity with MFC */

# ifdef LKRDEBUG
#  ifndef USE_DEBUG_CRTS
    /* IIS (and NT) do not ship msvcrtD.dll, per the VC license,
     * so we can't use the assertion code from <crtdbg.h>.  Use similar
     * macros from <pudebug.h> instead. */
#   include <pudebug.h>
#   define IRTLASSERT(f) DBG_ASSERT(f)
#  elif defined(_MSC_VER)  &&  (_MSC_VER >= 1000)
    /* Use the new debugging tools in Visual C++ 4.x */
#   include <crtdbg.h>
    /* _ASSERTE will give a more meaningful message, but the string takes
     * space.  Use _ASSERT if this is an issue. */
#   define IRTLASSERT(f) _ASSERTE(f)
#  else
#   include <assert.h>
#   define IRTLASSERT(f) assert(f)
#  endif

#  define IRTLVERIFY(f)               IRTLASSERT(f)
#  define DEBUG_ONLY(f)               (f)
#  define IRTLTRACE                   IrtlTrace
#  define IRTLTRACE0(psz)             IrtlTrace(_T("%s"), _T(psz))
#  define IRTLTRACE1(psz, p1)         IrtlTrace(_T(psz), p1)
#  define IRTLTRACE2(psz, p1, p2)     IrtlTrace(_T(psz), p1, p2)
#  define IRTLTRACE3(psz, p1, p2, p3) IrtlTrace(_T(psz), p1, p2, p3)
#  define ASSERT_VALID(pObj)  \
     do {IRTLASSERT((pObj) != NULL); (pObj)->AssertValid();} while (0)
#  define DUMP(pObj)  \
     do {IRTLASSERT((pObj) != NULL); (pObj)->Dump();} while (0)

# else /* !LKRDEBUG */

  /* These macros should all compile away to nothing */
#  define IRTLASSERT(f)           ((void)0)
#  define IRTLVERIFY(f)           ((void)(f))
#  define DEBUG_ONLY(f)           ((void)0)
#  define IRTLTRACE               1 ? (void)0 : IrtlTrace
#  define IRTLTRACE0(psz)
#  define IRTLTRACE1(psz, p1)
#  define IRTLTRACE2(psz, p1, p2)
#  define IRTLTRACE3(psz, p1, p2, p3)
#  define ASSERT_VALID(pObj)      ((void)0)
#  define DUMP(pObj)              ((void)0)

# endif /* !LKRDEBUG */


# define ASSERT_POINTER(p, type) \
    IRTLASSERT(((p) != NULL)  &&  IsValidAddress((p), sizeof(type), FALSE))

# define ASSERT_NULL_OR_POINTER(p, type) \
    IRTLASSERT(((p) == NULL)  ||  IsValidAddress((p), sizeof(type), FALSE))

#define ASSERT_STRING(s) \
    IRTLASSERT(((s) != NULL)  &&  IsValidString((s), -1))

#define ASSERT_NULL_OR_STRING(s) \
    IRTLASSERT(((s) == NULL)  ||  IsValidString((s), -1))


/* Declarations for non-Windows apps */

# ifndef _WINDEF_
typedef void*           LPVOID;
typedef const void*     LPCVOID;
typedef unsigned int    UINT;
typedef int             BOOL;
typedef const char*     LPCTSTR;
# endif /* _WINDEF_ */

# ifndef TRUE
#  define FALSE  0
#  define TRUE   1
# endif


# ifdef __cplusplus
extern "C" {

/* Low-level sanity checks for memory blocks */
IRTL_DLLEXP BOOL IsValidAddress(LPCVOID pv, UINT nBytes, BOOL fReadWrite = TRUE);
IRTL_DLLEXP BOOL IsValidString(LPCTSTR ptsz, int nLength = -1);

}

# else /* !__cplusplus */

/* Low-level sanity checks for memory blocks */
IRTL_DLLEXP BOOL IsValidAddress(LPCVOID pv, UINT nBytes, BOOL fReadWrite);
IRTL_DLLEXP BOOL IsValidString(LPCTSTR ptsz, int nLength);

# endif /* !__cplusplus */

#endif /* !_AFX */


/* Writes trace messages to debug stream */
extern
#ifdef __cplusplus
"C"
#endif /* !__cplusplus */
IRTL_DLLEXP
void __cdecl
IrtlTrace(
    LPCTSTR pszFormat,
    ...);


#ifdef _DEBUG
# define IRTL_DEBUG_INIT()            IrtlDebugInit()
# define IRTL_DEBUG_TERM()            IrtlDebugTerm()
#else /* !_DEBUG */
# define IRTL_DEBUG_INIT()            ((void)0)
# define IRTL_DEBUG_TERM()            ((void)0)
#endif /* !_DEBUG */


#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/* should be called from main(), WinMain(), or DllMain() */
IRTL_DLLEXP void
IrtlDebugInit();

IRTL_DLLEXP void
IrtlDebugTerm();

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* __IRTLDBG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\hashfn.h ===
/*++

   Copyright    (c)    1998-2000    Microsoft Corporation

   Module  Name :
       hashfn.h

   Abstract:
       Declares and defines a collection of overloaded hash functions.
       It is strongly suggested that you use these functions with LKRHash.

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/

#ifndef __HASHFN_H__
#define __HASHFN_H__


#ifdef __HASHFN_NAMESPACE__
namespace HashFn {
#endif // __HASHFN_NAMESPACE__

// Produce a scrambled, randomish number in the range 0 to RANDOM_PRIME-1.
// Applying this to the results of the other hash functions is likely to
// produce a much better distribution, especially for the identity hash
// functions such as Hash(char c), where records will tend to cluster at
// the low end of the hashtable otherwise.  LKRHash applies this internally
// to all hash signatures for exactly this reason.

inline DWORD
HashScramble(DWORD dwHash)
{
    // Here are 10 primes slightly greater than 10^9
    //  1000000007, 1000000009, 1000000021, 1000000033, 1000000087,
    //  1000000093, 1000000097, 1000000103, 1000000123, 1000000181.

    // default value for "scrambling constant"
    const DWORD RANDOM_CONSTANT = 314159269UL;
    // large prime number, also used for scrambling
    const DWORD RANDOM_PRIME =   1000000007UL;

    return (RANDOM_CONSTANT * dwHash) % RANDOM_PRIME ;
}


// Faster scrambling function suggested by Eric Jacobsen

inline DWORD
RandomizeBits(DWORD dw)
{
	return (((dw * 1103515245 + 12345) >> 16)
            | ((dw * 69069 + 1) & 0xffff0000));
}


// Small prime number used as a multiplier in the supplied hash functions
const DWORD HASH_MULTIPLIER = 101;

#undef HASH_SHIFT_MULTIPLY

#ifdef HASH_SHIFT_MULTIPLY
# define HASH_MULTIPLY(dw)   (((dw) << 5) - (dw))
#else
# define HASH_MULTIPLY(dw)   ((dw) * HASH_MULTIPLIER)
#endif

// Fast, simple hash function that tends to give a good distribution.
// Apply HashScramble to the result if you're using this for something
// other than LKRHash.

inline DWORD
HashString(
    const char* psz,
    DWORD       dwHash = 0)
{
    // force compiler to use unsigned arithmetic
    const unsigned char* upsz = (const unsigned char*) psz;

    for (  ;  *upsz;  ++upsz)
        dwHash = HASH_MULTIPLY(dwHash)  +  *upsz;

    return dwHash;
}


// Unicode version of above

inline DWORD
HashString(
    const wchar_t* pwsz,
    DWORD          dwHash = 0)
{
    for (  ;  *pwsz;  ++pwsz)
        dwHash = HASH_MULTIPLY(dwHash)  +  *pwsz;

    return dwHash;
}


// Quick-'n'-dirty case-insensitive string hash function.
// Make sure that you follow up with _stricmp or _mbsicmp.  You should
// also cache the length of strings and check those first.  Caching
// an uppercase version of a string can help too.
// Again, apply HashScramble to the result if using with something other
// than LKRHash.
// Note: this is not really adequate for MBCS strings.

inline DWORD
HashStringNoCase(
    const char* psz,
    DWORD       dwHash = 0)
{
    const unsigned char* upsz = (const unsigned char*) psz;

    for (  ;  *upsz;  ++upsz)
        dwHash = HASH_MULTIPLY(dwHash)
                     +  (*upsz & 0xDF);  // strip off lowercase bit

    return dwHash;
}


// Unicode version of above

inline DWORD
HashStringNoCase(
    const wchar_t* pwsz,
    DWORD          dwHash = 0)
{
    for (  ;  *pwsz;  ++pwsz)
        dwHash = HASH_MULTIPLY(dwHash)  +  (*pwsz & 0xFFDF);

    return dwHash;
}


// HashBlob returns the hash of a blob of arbitrary binary data.
// 
// Warning: HashBlob is generally not the right way to hash a class object.
// Consider:
//     class CFoo {
//     public:
//         char   m_ch;
//         double m_d;
//         char*  m_psz;
//     };
// 
//     inline DWORD Hash(const CFoo& rFoo)
//     { return HashBlob(&rFoo, sizeof(CFoo)); }
//
// This is the wrong way to hash a CFoo for two reasons: (a) there will be
// a 7-byte gap between m_ch and m_d imposed by the alignment restrictions
// of doubles, which will be filled with random data (usually non-zero for
// stack variables), and (b) it hashes the address (rather than the
// contents) of the string m_psz.  Similarly,
// 
//     bool operator==(const CFoo& rFoo1, const CFoo& rFoo2)
//     { return memcmp(&rFoo1, &rFoo2, sizeof(CFoo)) == 0; }
//
// does the wrong thing.  Much better to do this:
//
//     DWORD Hash(const CFoo& rFoo)
//     {
//         return HashString(rFoo.m_psz,
//                           HASH_MULTIPLIER * Hash(rFoo.m_ch)
//                               +  Hash(rFoo.m_d));
//     }
//
// Again, apply HashScramble if using with something other than LKRHash.

inline DWORD
HashBlob(
    const void* pv,
    size_t      cb,
    DWORD       dwHash = 0)
{
    LPBYTE pb = static_cast<LPBYTE>(const_cast<void*>(pv));

    while (cb-- > 0)
        dwHash = HASH_MULTIPLY(dwHash)  +  *pb++;

    return dwHash;
}



//
// Overloaded hash functions for all the major builtin types.
// Again, apply HashScramble to result if using with something other than
// LKRHash.
//

inline DWORD Hash(const char* psz)
{ return HashString(psz); }

inline DWORD Hash(const unsigned char* pusz)
{ return HashString(reinterpret_cast<const char*>(pusz)); }

inline DWORD Hash(const signed char* pssz)
{ return HashString(reinterpret_cast<const char*>(pssz)); }

inline DWORD Hash(const wchar_t* pwsz)
{ return HashString(pwsz); }

inline DWORD
Hash(
    const GUID* pguid,
    DWORD       dwHash = 0)
{
    DWORD* pdw = reinterpret_cast<DWORD*>(const_cast<GUID*>(pguid));
    
    dwHash = HASH_MULTIPLY(dwHash)  +  *pdw++;
    dwHash = HASH_MULTIPLY(dwHash)  +  *pdw++;
    dwHash = HASH_MULTIPLY(dwHash)  +  *pdw++;
    dwHash = HASH_MULTIPLY(dwHash)  +  *pdw;

    return dwHash;
}

// Identity hash functions: scalar values map to themselves
inline DWORD Hash(char c)
{ return c; }

inline DWORD Hash(unsigned char uc)
{ return uc; }

inline DWORD Hash(signed char sc)
{ return sc; }

inline DWORD Hash(short sh)
{ return sh; }

inline DWORD Hash(unsigned short ush)
{ return ush; }

inline DWORD Hash(int i)
{ return i; }

inline DWORD Hash(unsigned int u)
{ return u; }

inline DWORD Hash(long l)
{ return l; }

inline DWORD Hash(unsigned long ul)
{ return ul; }

inline DWORD Hash(float f)
{
    // be careful of rounding errors when computing keys
    union {
        float f;
        DWORD dw;
    } u;
    u.f = f;
    return u.dw;
}

inline DWORD Hash(double dbl)
{
    // be careful of rounding errors when computing keys
    union {
        double dbl;
        DWORD  dw[2];
    } u;
    u.dbl = dbl;
    return u.dw[0] * HASH_MULTIPLIER  +  u.dw[1];
}

#ifdef __HASHFN_NAMESPACE__
}
#endif // __HASHFN_NAMESPACE__

#endif // __HASHFN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\keymanager.h ===
// KeyManager.h: interface for the CKeyManager class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_KEYMANAGER_H__0AC10C43_D0D5_11D2_95E5_00C04F8E7A70__INCLUDED_)
#define AFX_KEYMANAGER_H__0AC10C43_D0D5_11D2_95E5_00C04F8E7A70__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef UNIX
#include <des.h>
// BUGBUG needs some headers to get MAC Address on unix
#else
#include "nt\des.h"
#include "nt\tripldes.h"
#include "nt\modes.h"
#include <nb30.h>
#endif

class CKeyManager  
{
 public:
  CKeyManager();
  virtual ~CKeyManager();

  HRESULT encryptKey(BYTE input[24], BYTE output[32]);
  HRESULT decryptKey(BYTE input[32], BYTE output[24]);

  BOOL isOk() { return m_ok; }

 protected:
  void LogBlob(LPBYTE pbBlob, DWORD dwBlobLen, LPCSTR pszCaption);
  void makeDESKey(LPBYTE pbKey);
  BOOL m_ok;
  BOOL m_dwLoggingEnabled;

#ifdef UNIX

  des_key_schedule ks1, ks2, ks3;

#else

  DES3TABLE m_ks;

#endif
};

#endif // !defined(AFX_KEYMANAGER_H__0AC10C43_D0D5_11D2_95E5_00C04F8E7A70__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\keycrypto.h ===
// KeyManager.h: interface for the CKeyManagerHash class.
//
//////////////////////////////////////////////////////////////////////
#if !defined(_KEYCRYPTO_H)
#define _KEYCRYPTO_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "Wincrypt.h"

/*
  typedef BYTE RAWKEY[24];
  typedef BYTE ENCKEY[56];
*/


class CKeyCrypto  
{
 public:
// ==
// NOTE: 
// when change the following strings, the ENCKEY_SIZE may be affected
//
  const static UINT  RAWKEY_SIZE = 24;

  CKeyCrypto();
  virtual ~CKeyCrypto(){};

  HRESULT encryptKey(DATA_BLOB* input, DATA_BLOB* output);
  HRESULT decryptKey(DATA_BLOB* input, DATA_BLOB* output);
  BOOL IsFromThis(PBYTE pData, ULONG cb);
  
 protected:
  DATA_BLOB    m_EntropyBlob;
};

#endif // !defined(_KEYCRYPTO_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\kppvc.h ===
//-----------------------------------------------------------------------------
//
//  @doc
//
//  @module kppvc.h     Functions for retrieving information from the
//                      kids passport consent database.
//
//  Author: Darren Anderson
//
//  Date:   5/5/2000
//
//  Copyright <cp> 1999-2000 Microsoft Corporation.  All Rights Reserved.
//
//-----------------------------------------------------------------------------
#pragma once
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\keymanagerhash.h ===
// KeyManager.h: interface for the CKeyManagerHash class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(_KEYMANAGERHASH_H)
#define _KEYMANAGERHASH_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef UNIX
#include <des.h>
// BUGBUG needs some headers to get MAC Address on unix
#else
#include "nt\des.h"
#include "nt\tripldes.h"
#include "nt\modes.h"
#include <nb30.h>
#endif

class CKeyManagerHash  
{
 public:
  CKeyManagerHash();
  virtual ~CKeyManagerHash();

  typedef BYTE RAWKEY[24];
  typedef BYTE ENCKEY[56];

  HRESULT encryptKey(RAWKEY input, ENCKEY output);
  HRESULT decryptKey(ENCKEY input, RAWKEY output);

  BOOL isOk() { return m_ok; }

 protected:
  void LogBlob(LPBYTE pbBlob, DWORD dwBlobLen, LPCSTR pszCaption);
  void makeDESKey(LPBYTE pbKey, ULONG nKey);
  HRESULT LoadKeysFromWMI();

  BOOL m_ok;
  BOOL m_dwLoggingEnabled;

#ifdef UNIX

  des_key_schedule ks1, ks2, ks3;

#else

  unsigned long m_nKeys;
  unsigned long m_nEncryptKey;
  DES3TABLE*    m_pks;

#endif
};

#endif // !defined(AFX_KEYMANAGER_H__0AC10C43_D0D5_11D2_95E5_00C04F8E7A70__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\listmacr.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    listmacr.h

Abstract:

    This module defines the macros that manipulates list
    structures defined in winnt.h.  Code is copied from the
    internal NT project.

Author:

    Johnson Apacible (JohnsonA)     30-Sept-1994

Revision History:

--*/

#ifndef _LISTMACR_
#define _LISTMACR_

//
//  Doubly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures.
//

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

//
//
//  PSINGLE_LIST_ENTRY
//  PopEntryList(
//      PSINGLE_LIST_ENTRY ListHead
//      );
//

#define PopEntryList(ListHead) \
    (ListHead)->Next;\
    {\
        PSINGLE_LIST_ENTRY FirstEntry;\
        FirstEntry = (ListHead)->Next;\
        if (FirstEntry != NULL) {     \
            (ListHead)->Next = FirstEntry->Next;\
        }                             \
    }

//
//  VOID
//  PushEntryList(
//      PSINGLE_LIST_ENTRY ListHead,
//      PSINGLE_LIST_ENTRY Entry
//      );
//

#define PushEntryList(ListHead,Entry) \
    (Entry)->Next = (ListHead)->Next; \
    (ListHead)->Next = (Entry)

#endif // ndef _LISTMACR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\locks.h ===
/*++

   Copyright    (c)    1998-2000    Microsoft Corporation

   Module  Name :
       locks.h

   Abstract:
       A collection of locks for multithreaded access to data structures

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/

#ifndef __LOCKS_H__
#define __LOCKS_H__

//--------------------------------------------------------------------
// File: locks.h
//
// A collection of different implementations of read/write locks that all
// share the same interface.  This allows different locks to be plugged
// into C++ templates as parameters.
//
// The implementations are:
//      CSmallSpinLock      lightweight critical section
//      CSpinLock           variant of CSmallSpinLock
//      CFakeLock           do-nothing class; useful as a template parameter
//      CCritSec            Win32 CRITICAL_SECTION
//   Multi-Reader/Single-Writer locks:
//      CReaderWriterLock   MRSW lock from Neel Jain
//      CReaderWriterLock2  smaller implementation of CReaderWriterLock
//      CReaderWriterLock3  CReaderWriterLock2 with recursive WriteLock
//
// CAutoReadLock<Lock> and CAutoWriteLock<Lock> can used as
// exception-safe wrappers.
//
// TODO:
// * Add a timeout feature to Try{Read,Write}Lock
// * Add some way of tracking all the owners of a multi-reader lock
//--------------------------------------------------------------------



#ifndef __IRTLDBG_H__
# include <irtldbg.h>
#endif

#ifdef __LOCKS_NAMESPACE__
namespace Locks {
#endif // __LOCKS_NAMESPACE__


enum LOCK_LOCKTYPE {
    LOCK_SMALLSPINLOCK = 1,
    LOCK_SPINLOCK,
    LOCK_FAKELOCK,
    LOCK_CRITSEC,
    LOCK_READERWRITERLOCK,
    LOCK_READERWRITERLOCK2,
    LOCK_READERWRITERLOCK3,
};


// Forward declarations
class IRTL_DLLEXP CSmallSpinLock;
class IRTL_DLLEXP CSpinLock;
class IRTL_DLLEXP CFakeLock;
class IRTL_DLLEXP CCritSec;
class IRTL_DLLEXP CReaderWriterLock;
class IRTL_DLLEXP CReaderWriterLock2;
class IRTL_DLLEXP CReaderWriterLock3;



#if defined(_MSC_VER)  &&  (_MSC_VER >= 1200)
// __forceinline keyword new to VC6
# define LOCK_FORCEINLINE __forceinline
#else
# define LOCK_FORCEINLINE inline
#endif

#ifdef _M_IX86
// The compiler will warn that the assembly language versions of the
// Lock_Atomic* functions don't return a value. Actually, they do: in EAX.
# pragma warning(disable: 4035)
#endif

// Workarounds for certain useful interlocked operations that are not
// available on Windows 95. Note: the CMPXCHG and XADD instructions were
// introduced in the 80486. If you still need to run on a 386 (unlikely in
// 2000), you'll need to use something else.

LOCK_FORCEINLINE
LONG
Lock_AtomicIncrement(
    IN OUT PLONG plAddend)
{
#ifdef _M_IX86
    __asm
    {
             mov        ecx,    plAddend
             mov        eax,    1
        lock xadd       [ecx],  eax
             inc        eax                 // correct result
    }
#else
    return InterlockedIncrement(plAddend);
#endif
}

LOCK_FORCEINLINE
LONG
Lock_AtomicDecrement(
    IN OUT PLONG plAddend)
{
#ifdef _M_IX86
    __asm
    {
             mov        ecx,    plAddend
             mov        eax,    -1
        lock xadd       [ecx],  eax
             dec        eax                 // correct result
    }
#else
    return InterlockedDecrement(plAddend);
#endif
}

LOCK_FORCEINLINE
LONG
Lock_AtomicExchange(
    IN OUT PLONG plAddr,
    IN LONG      lNew)
{
#ifdef _M_IX86
    __asm
    {
             mov        ecx,    plAddr
             mov        edx,    lNew
             mov        eax,    [ecx]
    LAEloop:
        lock cmpxchg    [ecx],  edx
             jnz        LAEloop
    }
#else
    return InterlockedExchange(plAddr, lNew);
#endif
}

LOCK_FORCEINLINE
LONG
Lock_AtomicCompareExchange(
    IN OUT PLONG plAddr,
    IN LONG      lNew,
    IN LONG      lCurrent)
{
#ifdef _M_IX86
    __asm
    {
             mov        ecx,    plAddr
             mov        edx,    lNew
             mov        eax,    lCurrent
        lock cmpxchg    [ecx],  edx
    }
#else
    return InterlockedCompareExchange(plAddr, lNew, lCurrent);
#endif
}

LOCK_FORCEINLINE
LONG
Lock_AtomicExchangeAdd(
    IN OUT LPLONG plAddr,
    IN LONG       lValue)
{
#ifdef _M_IX86
    __asm
    {
             mov        ecx,    plAddr
             mov        eax,    lValue
        lock xadd       [ecx],  eax
    }
#else
    return InterlockedExchangeAdd(plAddr, lValue);
#endif
}



#ifdef _M_IX86
# pragma warning(default: 4035)
// Makes tight loops a little more cache friendly and reduces power
// consumption. Needed on Willamette processors.
# define Lock_Yield()    _asm { rep nop }
#else
# define Lock_Yield()    ((void) 0)
#endif



//--------------------------------------------------------------------
// Spin count values.
enum LOCK_SPINS {
    LOCK_MAXIMUM_SPINS =      10000,    // maximum allowable spin count
    LOCK_DEFAULT_SPINS =       4000,    // default spin count
    LOCK_MINIMUM_SPINS =        100,    // minimum allowable spin count
    LOCK_USE_DEFAULT_SPINS = 0xFFFF,    // use class default spin count
    LOCK_DONT_SPIN =              0,    // don't spin at all
};


// Boilerplate code for the per-class default spincount and spinfactor

#define LOCK_DEFAULT_SPIN_IMPLEMENTATION()                                  \
protected:                                                                  \
    /* per-class variables */                                               \
    static   WORD   sm_wDefaultSpinCount;   /* global default spin count */   \
    static   double sm_dblDfltSpinAdjFctr;  /* global spin adjustment factor*/\
                                                                            \
public:                                                                     \
    /* Set the default spin count for all locks */                          \
    static void SetDefaultSpinCount(WORD wSpins)                            \
    {                                                                       \
        IRTLASSERT((wSpins == LOCK_DONT_SPIN)                               \
                   || (wSpins == LOCK_USE_DEFAULT_SPINS)                    \
                   || (LOCK_MINIMUM_SPINS <= wSpins                         \
                       &&  wSpins <= LOCK_MAXIMUM_SPINS));                  \
                                                                            \
        if ((LOCK_MINIMUM_SPINS <= wSpins  &&  wSpins <= LOCK_MAXIMUM_SPINS)\
                || (wSpins == LOCK_DONT_SPIN))                              \
            sm_wDefaultSpinCount = wSpins;                                  \
        else if (wSpins == LOCK_USE_DEFAULT_SPINS)                          \
            sm_wDefaultSpinCount = LOCK_DEFAULT_SPINS;                      \
    }                                                                       \
                                                                            \
    /* Return the default spin count for all locks */                       \
    static WORD GetDefaultSpinCount()                                       \
    {                                                                       \
        return sm_wDefaultSpinCount;                                        \
    }                                                                       \
                                                                            \
    /* Set the adjustment factor for the spincount, used in each iteration */\
    /* of countdown-and-sleep by the backoff algorithm. */                  \
    static void SetDefaultSpinAdjustmentFactor(double dblAdjFactor)         \
    {                                                                       \
        IRTLASSERT(0.1 <= dblAdjFactor  &&  dblAdjFactor <= 10.0);          \
        if (0.1 <= dblAdjFactor  &&  dblAdjFactor <= 10.0)                  \
            sm_dblDfltSpinAdjFctr = dblAdjFactor;                           \
    }                                                                       \
                                                                            \
    /* Return the default spin count for all locks */                       \
    static double GetDefaultSpinAdjustmentFactor()                          \
    {                                                                       \
        return sm_dblDfltSpinAdjFctr;                                       \
    }                                                                       \



//--------------------------------------------------------------------
// Various Lock Traits

// Is the lock a simple mutex or a multi-reader/single-writer lock?
enum LOCK_RW_MUTEX {
    LOCK_MUTEX = 1,         // mutexes allow only one thread to hold the lock
    LOCK_MRSW,              // multi-reader, single-writer
};


// Can the lock be recursively acquired?
enum LOCK_RECURSION {
    LOCK_RECURSIVE = 1,     // Write and Read locks can be recursively acquired
    LOCK_READ_RECURSIVE,    // Read locks can be reacquired, but not Write
    LOCK_NON_RECURSIVE,     // Will deadlock if attempt to acquire recursively
};


// Does the lock Sleep in a loop or block on a kernel synch object handle?
// May (or may not) spin first before sleeping/blocking.
enum LOCK_WAIT_TYPE {
    LOCK_WAIT_SLEEP = 1,    // Calls Sleep() in a loop
    LOCK_WAIT_HANDLE,       // Blocks on a kernel mutex, semaphore, or event
};


// When the lock is taken, how are the waiters dequeued?
enum LOCK_QUEUE_TYPE {
    LOCK_QUEUE_FIFO = 1,    // First in, first out.  Fair.
    LOCK_QUEUE_LIFO,        // Unfair but CPU cache friendly
    LOCK_QUEUE_KERNEL,      // Determined by vagaries of scheduler
};


// Can the lock's spincount be set on a per-lock basis, or is it only
// possible to modify the default spincount for all the locks in this class?
enum LOCK_PERLOCK_SPIN {
    LOCK_NO_SPIN = 1,       // The locks do not spin at all
    LOCK_CLASS_SPIN,        // Can set class-wide spincount, not individual
    LOCK_INDIVIDUAL_SPIN,   // Can set a spincount on an individual lock
};


//--------------------------------------------------------------------
// CLockBase: bundle the above attributes

template < LOCK_LOCKTYPE     locktype,
           LOCK_RW_MUTEX     mutextype,
           LOCK_RECURSION    recursiontype,
           LOCK_WAIT_TYPE    waittype,
           LOCK_QUEUE_TYPE   queuetype,
           LOCK_PERLOCK_SPIN spintype
         >
class CLockBase
{
public:
    static LOCK_LOCKTYPE     LockType()     {return locktype;}
    static LOCK_RW_MUTEX     MutexType()    {return mutextype;}
    static LOCK_RECURSION    Recursion()    {return recursiontype;}
    static LOCK_WAIT_TYPE    WaitType()     {return waittype;}
    static LOCK_QUEUE_TYPE   QueueType()    {return queuetype;}
    static LOCK_PERLOCK_SPIN PerLockSpin()  {return spintype;}
};



// Lock instrumentation causes all sorts of interesting statistics about
// lock contention, etc., to be gathered, but makes locks considerably fatter
// and somewhat slower.  Turned off by default.

// #define LOCK_INSTRUMENTATION 1

#ifdef LOCK_INSTRUMENTATION

// We generally don't want to instrument CSmallSpinLock in addition
// to CSpinLock1, as it makes a CSpinLock1 huge.

// #define LOCK_SMALL_SPIN_INSTRUMENTATION 1

//--------------------------------------------------------------------
// CLockStatistics: statistics for an individual lock

class IRTL_DLLEXP CLockStatistics
{
public:
    enum {
        L_NAMELEN = 8,
    };
    
    double   m_nContentions;     // #times this lock was already locked
    double   m_nSleeps;          // Total #Sleep()s needed
    double   m_nContentionSpins; // Total iterations this lock spun
    double   m_nAverageSpins;    // Average spins each contention needed
    double   m_nReadLocks;       // Number of times lock acquired for reading
    double   m_nWriteLocks;      // Number of times lock acquired for writing
    char     m_szName[L_NAMELEN];// Name of this lock

    CLockStatistics()
        : m_nContentions(0),
          m_nSleeps(0),
          m_nContentionSpins(0),
          m_nAverageSpins(0),
          m_nReadLocks(0),
          m_nWriteLocks(0)
    {
        m_szName[0] = '\0';
    }
};



//--------------------------------------------------------------------
// CGlobalLockStatistics: statistics for all the known locks

class IRTL_DLLEXP CGlobalLockStatistics
{
public:
    LONG     m_cTotalLocks;     // Total number of locks created
    LONG     m_cContendedLocks; // Total number of contended locks
    LONG     m_nSleeps;         // Total #Sleep()s needed by all locks
    LONGLONG m_cTotalSpins;     // Total iterations all locks spun
    double   m_nAverageSpins;   // Average spins needed for each contended lock
    LONG     m_nReadLocks;      // Total ReadLocks
    LONG     m_nWriteLocks;     // Total WriteLocks

    CGlobalLockStatistics()
        : m_cTotalLocks(0),
          m_cContendedLocks(0),
          m_nSleeps(0),
          m_cTotalSpins(0),
          m_nAverageSpins(0),
          m_nReadLocks(0),
          m_nWriteLocks(0)
    {}
};

# define LOCK_INSTRUMENTATION_DECL() \
private:                                                                    \
    volatile LONG   m_nContentionSpins; /* #iterations this lock spun */    \
    volatile WORD   m_nContentions;     /* #times lock was already locked */\
    volatile WORD   m_nSleeps;          /* #Sleep()s needed */              \
    volatile WORD   m_nReadLocks;       /* #ReadLocks */                    \
    volatile WORD   m_nWriteLocks;      /* #WriteLocks */                   \
    char            m_szName[CLockStatistics::L_NAMELEN]; /* Name of lock */\
                                                                            \
    static   LONG   sm_cTotalLocks;     /* Total number of locks created */ \
    static   LONG   sm_cContendedLocks; /* Total number of contended locks */\
    static   LONG   sm_nSleeps;         /* Total #Sleep()s by all locks */  \
    static LONGLONG sm_cTotalSpins;     /* Total iterations all locks spun */\
    static   LONG   sm_nReadLocks;      /* Total ReadLocks */               \
    static   LONG   sm_nWriteLocks;     /* Total WriteLocks */              \
                                                                            \
public:                                                                     \
    const char* Name() const        {return m_szName;}                      \
                                                                            \
    CLockStatistics                 Statistics() const;                     \
    static CGlobalLockStatistics    GlobalStatistics();                     \
    static void                     ResetGlobalStatistics();                \
private:                                                                    \


// Add this to constructors

# define LOCK_INSTRUMENTATION_INIT(pszName)         \
    m_nContentionSpins = 0;                         \
    m_nContentions = 0;                             \
    m_nSleeps = 0;                                  \
    m_nReadLocks = 0;                               \
    m_nWriteLocks = 0;                              \
    ++sm_cTotalLocks;                               \
    if (pszName == NULL)                            \
        m_szName[0] = '\0';                         \
    else                                            \
        strncpy(m_szName, pszName, sizeof(m_szName))

// Note: we are not using Interlocked operations for the shared
// statistical counters.  We'll lose perfect accuracy, but we'll
// gain by reduced bus synchronization traffic.

# define LOCK_READLOCK_INSTRUMENTATION()    \
      { ++m_nReadLocks;                     \
        ++sm_nReadLocks; }

# define LOCK_WRITELOCK_INSTRUMENTATION()   \
      { ++m_nWriteLocks;                    \
        ++sm_nWriteLocks; }

#else // !LOCK_INSTRUMENTATION

# define LOCK_INSTRUMENTATION_DECL()
# define LOCK_READLOCK_INSTRUMENTATION()    ((void) 0)
# define LOCK_WRITELOCK_INSTRUMENTATION()   ((void) 0)

#endif // !LOCK_INSTRUMENTATION



//--------------------------------------------------------------------
// CAutoReadLock<Lock> and CAutoWriteLock<Lock> provide exception-safe
// acquisition and release of the other locks defined below

template <class _Lock>
class IRTL_DLLEXP CAutoReadLock
{
private:
    bool    m_fLocked;
    _Lock&  m_Lock;

public:
    CAutoReadLock(
        _Lock& rLock,
        bool   fLockNow = true)
        : m_fLocked(false), m_Lock(rLock)
    {
        if (fLockNow)
            Lock();
    }
    ~CAutoReadLock()
    {
        Unlock();
    }
    
    void Lock()
    {
        // disallow recursive acquisition of the lock through this wrapper
        if (!m_fLocked)
        {
            m_fLocked = true;
            m_Lock.ReadLock();
        }
    }
    
    void Unlock()
    {
        if (m_fLocked)
        {
            m_Lock.ReadUnlock();
            m_fLocked = false;
        }
    }
};



template <class _Lock>
class IRTL_DLLEXP CAutoWriteLock
{
private:
    bool    m_fLocked;
    _Lock&  m_Lock;

public:
    CAutoWriteLock(
        _Lock& rLock,
        bool   fLockNow = true)
        : m_fLocked(false), m_Lock(rLock)
    {
        if (fLockNow)
            Lock();
    }

    ~CAutoWriteLock()
    {
        Unlock();
    }
    
    void Lock()
    {
        // disallow recursive acquisition of the lock through this wrapper
        if (!m_fLocked)
        {
            m_fLocked = true;
            m_Lock.WriteLock();
        }
    }
    
    void Unlock()
    {
        if (m_fLocked)
        {
            m_fLocked = false;
            m_Lock.WriteUnlock();
        }
    }
};




//--------------------------------------------------------------------
// A spinlock is a sort of lightweight critical section.  Its main
// advantage over a true Win32 CRITICAL_SECTION is that it occupies 4 bytes
// instead of 24 (+ another 32 bytes for the RTL_CRITICAL_SECTION_DEBUG data),
// which is important when we have many thousands of locks
// and we're trying to be L1 cache-conscious.  A CRITICAL_SECTION also
// contains a HANDLE to a semaphore, although this is not initialized until
// the first time that the CRITICAL_SECTION blocks.
//
// On a multiprocessor machine, a spinlock tries to acquire the lock.  If
// it fails, it sits in a tight loop, testing the lock and decrementing a
// counter.  If the counter reaches zero, it does a Sleep(0), yielding the
// processor to another thread.  When control returns to the thread, the
// lock is probably free.  If not, the loop starts again and it is
// terminated only when the lock is acquired.  The theory is that it is
// less costly to spin in a busy loop for a short time rather than
// immediately yielding the processor, forcing an expensive context switch
// that requires the old thread's state (registers, etc) be saved, the new
// thread's state be reloaded, and the L1 and L2 caches be left full of
// stale data.
//
// You can tune the spin count (global only: per-lock spin counts are 
// disabled) and the backoff algorithm (the factor by which the spin
// count is multiplied after each Sleep).
//
// On a 1P machine, the loop is pointless---this thread has control,
// hence no other thread can possibly release the lock while this thread
// is looping---so the processor is yielded immediately.
//
// The kernel uses spinlocks internally and spinlocks were also added to
// CRITICAL_SECTIONs in NT 4.0 sp3.  In the CRITICAL_SECTION implementation,
// however, the counter counts down only once and waits on a semaphore
// thereafter (i.e., the same blocking behavior that it exhibits without
// the spinlock).
//
// A disadvantage of a user-level spinlock such as this is that if the
// thread that owns the spinlock blocks for any reason (or is preempted by
// the scheduler), all the other threads will continue to spin on the
// spinlock, wasting CPU, until the owning thread completes its wait and
// releases the lock.  (The kernel spinlocks, however, are smart enough to
// switch to another runnable thread instead of wasting time spinning.)
// The backoff algorithm decreases the spin count on each iteration in an
// attempt to minimize this effect.  The best policy---and this is true for
// all locks---is to hold the lock for as short as time as possible.
//
// Note: unlike a CRITICAL_SECTION, a CSmallSpinLock cannot be recursively
// acquired; i.e., if you acquire a spinlock and then attempt to acquire it
// again *on the same thread* (perhaps from a different function), the
// thread will hang forever.  Use CSpinLock instead, which is safe though a
// little slower than a CSmallSpinLock.  If you own all the code
// that is bracketed by Lock() and Unlock() (e.g., no callbacks or passing
// back of locked data structures to callers) and know for certain that it
// will not attempt to reacquire the lock, you can use CSmallSpinLock.
//
// See also http://muralik/work/performance/spinlocks.htm and John Vert's
// MSDN article, "Writing Scalable Applications for Windows NT".
//
// The original implementation is due to PALarson.

class IRTL_DLLEXP CSmallSpinLock :
    public CLockBase<LOCK_SMALLSPINLOCK, LOCK_MUTEX,
                       LOCK_NON_RECURSIVE, LOCK_WAIT_SLEEP, LOCK_QUEUE_KERNEL,
                       LOCK_CLASS_SPIN
                      >
{
private:
    volatile LONG m_lTid;              // The lock state variable

#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
    LOCK_INSTRUMENTATION_DECL();
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION

    LOCK_FORCEINLINE static LONG _CurrentThreadId()
    {
        DWORD dwTid = ::GetCurrentThreadId();
        return (LONG) (dwTid);
    }

private:
    // Does all the spinning (and instrumentation) if the lock is contended.
    void _LockSpin();

    LOCK_FORCEINLINE bool _TryLock()
    {
        if (m_lTid == 0)
        {
            LONG l = _CurrentThreadId();

            return (Lock_AtomicCompareExchange(const_cast<LONG*>(&m_lTid), l,0)
                    == 0);
        }
        else
            return false;
    }

public:

#ifndef LOCK_SMALL_SPIN_INSTRUMENTATION

    CSmallSpinLock()
        : m_lTid(0)
    {}

#else // LOCK_SMALL_SPIN_INSTRUMENTATION

    CSmallSpinLock(
        const char* pszName)
        : m_lTid(0)
    {
        LOCK_INSTRUMENTATION_INIT(pszName);
    }

#endif // LOCK_SMALL_SPIN_INSTRUMENTATION

#ifdef _DEBUG
    ~CSmallSpinLock()
    {
        IRTLASSERT(m_lTid == 0);
    }
#endif // _DEBUG

    // Acquire an exclusive lock for writing.  Blocks until acquired.
    inline void WriteLock()
    {
#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
        LOCK_WRITELOCK_INSTRUMENTATION();
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION

        // Optimize for the common case by helping the processor's branch
        // prediction algorithm.
        if (_TryLock())
            return;

        _LockSpin();
    }

    // Acquire a (possibly shared) lock for reading.  Blocks until acquired.
    inline void ReadLock()
    {
#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
        LOCK_READLOCK_INSTRUMENTATION();
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION

        if (_TryLock())
            return;

        _LockSpin();
    }

    // Try to acquire an exclusive lock for writing.  Returns true
    // if successful.  Non-blocking.
    inline bool TryWriteLock()
    {
        bool fAcquired = _TryLock();

#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
        if (fAcquired)
            LOCK_WRITELOCK_INSTRUMENTATION();
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION

        return fAcquired;
    }

    // Try to acquire a (possibly shared) lock for reading.  Returns true
    // if successful.  Non-blocking.
    inline bool TryReadLock()
    {
        bool fAcquired = _TryLock();

#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
        if (fAcquired)
            LOCK_READLOCK_INSTRUMENTATION();
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION

        return fAcquired;
    }

    // Unlock the lock after a successful call to {,Try}WriteLock().
    // Assumes caller owned the lock.
    inline void WriteUnlock()
    {
        Lock_AtomicExchange(const_cast<LONG*>(&m_lTid), 0);
    }

    // Unlock the lock after a successful call to {,Try}ReadLock().
    // Assumes caller owned the lock.
    inline void ReadUnlock()
    {
        WriteUnlock();
    }

    // Is the lock already locked for writing by this thread?
    bool IsWriteLocked() const
    {
        return (m_lTid == _CurrentThreadId());
    }
    
    // Is the lock already locked for reading?
    bool IsReadLocked() const
    {
        return IsWriteLocked();
    }
    
    // Is the lock unlocked for writing?
    bool IsWriteUnlocked() const
    {
        return (m_lTid == 0);
    }
    
    // Is the lock unlocked for reading?
    bool IsReadUnlocked() const
    {
        return IsWriteUnlocked();
    }
    
    // Convert a reader lock to a writer lock
    void ConvertSharedToExclusive()
    {
        // no-op
    }

    // Convert a writer lock to a reader lock
    void ConvertExclusiveToShared()
    {
        // no-op
    }

    // Set the spin count for this lock.
    // Returns true if successfully set the per-lock spincount, false otherwise
    bool SetSpinCount(WORD wSpins)
    {
        IRTLASSERT((wSpins == LOCK_DONT_SPIN)
                   || (wSpins == LOCK_USE_DEFAULT_SPINS)
                   || (LOCK_MINIMUM_SPINS <= wSpins
                       &&  wSpins <= LOCK_MAXIMUM_SPINS));

        return false;
    }

    // Return the spin count for this lock.
    WORD GetSpinCount() const
    {
        return sm_wDefaultSpinCount;
    }
    
    LOCK_DEFAULT_SPIN_IMPLEMENTATION();

    static const char*   ClassName()  {return "CSmallSpinLock";}
}; // CSmallSpinLock




//--------------------------------------------------------------------
// CSpinLock is a spinlock that doesn't deadlock if recursively acquired.
// This version occupies only 4 bytes.  Uses 28 bits for the thread id.

class IRTL_DLLEXP CSpinLock :
    public CLockBase<LOCK_SPINLOCK, LOCK_MUTEX,
                       LOCK_RECURSIVE, LOCK_WAIT_SLEEP, LOCK_QUEUE_KERNEL,
                       LOCK_CLASS_SPIN
                      >
{
private:
    // a union for convenience
    volatile LONG m_lTid;

    enum {
        THREAD_SHIFT = 0,
        THREAD_BITS  = 28,
        OWNER_SHIFT  = THREAD_BITS,
        OWNER_BITS   = 4,
        THREAD_MASK  = ((1 << THREAD_BITS) - 1) << THREAD_SHIFT,
        OWNER_INCR   = 1 << THREAD_BITS,
        OWNER_MASK   = ((1 << OWNER_BITS) - 1) << OWNER_SHIFT,
    };

    LOCK_INSTRUMENTATION_DECL();

private:
    // Get the current thread ID.  Assumes that it can fit into 28 bits,
    // which is fairly safe as NT recycles thread IDs and failing to fit into
    // 28 bits would mean that more than 268,435,456 threads were currently
    // active.  This is improbable in the extreme as NT runs out of
    // resources if there are more than a few thousands threads in
    // existence and the overhead of context swapping becomes unbearable.
    LOCK_FORCEINLINE static LONG _CurrentThreadId()
    {
        DWORD dwTid = ::GetCurrentThreadId();
        // Thread ID 0 is used by the System Process (Process ID 0).
        // We use a thread-id of zero to indicate that the lock is unowned.
        // NT uses +ve thread ids, Win9x uses -ve ids
        IRTLASSERT(dwTid != 0
                   && ((dwTid <= THREAD_MASK) || (dwTid > ~THREAD_MASK)));
        return (LONG) (dwTid & THREAD_MASK);
    }

    // Attempt to acquire the lock without blocking
    LOCK_FORCEINLINE bool _TryLock()
    {
        if (m_lTid == 0)
        {
            LONG l = _CurrentThreadId() | OWNER_INCR;

            return (Lock_AtomicCompareExchange(const_cast<LONG*>(&m_lTid), l,0)
                    == 0);
        }
        else
            return false;
    }


    // Acquire the lock, recursively if need be
    void _Lock()
    {
        // Do we own the lock already?  Just bump the count.
        if ((m_lTid & THREAD_MASK) == _CurrentThreadId())
        {
            // owner count isn't maxed out?
            IRTLASSERT((m_lTid & OWNER_MASK) != OWNER_MASK);

            Lock_AtomicExchangeAdd(const_cast<LONG*>(&m_lTid), OWNER_INCR);
        }

        // Some other thread owns the lock.  We'll have to spin :-(.
        else
            _LockSpin();

        IRTLASSERT((m_lTid & OWNER_MASK) > 0
                   &&  (m_lTid & THREAD_MASK) == _CurrentThreadId());
    }


    // Release the lock
    LOCK_FORCEINLINE void _Unlock()
    {
        IRTLASSERT((m_lTid & OWNER_MASK) > 0
                   &&  (m_lTid & THREAD_MASK) == _CurrentThreadId());

        LONG l = m_lTid - OWNER_INCR; 

        // Last owner?  Release completely, if so
        if ((l & OWNER_MASK) == 0)
            l = 0;

        Lock_AtomicExchange(const_cast<LONG*>(&m_lTid), l);
    }


    // Return true if the lock is owned by this thread
    bool _IsLocked() const
    {
        bool fLocked = ((m_lTid & THREAD_MASK) == _CurrentThreadId());

        IRTLASSERT(!fLocked || ((m_lTid & OWNER_MASK) > 0
                               && (m_lTid & THREAD_MASK)==_CurrentThreadId()));

        return fLocked;
    }


    // Does all the spinning (and instrumentation) if the lock is contended.
    void _LockSpin();

public:

#ifndef LOCK_INSTRUMENTATION

    CSpinLock()
        : m_lTid(0)
    {}

#else // LOCK_INSTRUMENTATION

    CSpinLock(
        const char* pszName)
        : m_lTid(0)
    {
        LOCK_INSTRUMENTATION_INIT(pszName);
    }

#endif // LOCK_INSTRUMENTATION

#ifdef _DEBUG
    ~CSpinLock()
    {
        IRTLASSERT(m_lTid == 0);
    }
#endif // _DEBUG

    // Acquire an exclusive lock for writing.  Blocks until acquired.
    inline void WriteLock()
    {
        LOCK_WRITELOCK_INSTRUMENTATION();

        // Is the lock unowned?
        if (_TryLock())
            return; // got the lock
        
        _Lock();
    }
    

    // Acquire a (possibly shared) lock for reading.  Blocks until acquired.
    inline void ReadLock()
    {
        LOCK_READLOCK_INSTRUMENTATION();

        // Is the lock unowned?
        if (_TryLock())
            return; // got the lock
        
        _Lock();
    }

    // See the description under CReaderWriterLock3::ReadOrWriteLock
    inline bool ReadOrWriteLock()
    {
        ReadLock();
        return true;
    } 

    // Try to acquire an exclusive lock for writing.  Returns true
    // if successful.  Non-blocking.
    inline bool TryWriteLock()
    {
        bool fAcquired = _TryLock();

        if (fAcquired)
            LOCK_WRITELOCK_INSTRUMENTATION();

        return fAcquired;
    }

    // Try to acquire a (possibly shared) lock for reading.  Returns true
    // if successful.  Non-blocking.
    inline bool TryReadLock()
    {
        bool fAcquired = _TryLock();

        if (fAcquired)
            LOCK_READLOCK_INSTRUMENTATION();

        return fAcquired;
    }

    // Unlock the lock after a successful call to {,Try}WriteLock().
    inline void WriteUnlock()
    {
        _Unlock();
    }

    // Unlock the lock after a successful call to {,Try}ReadLock().
    inline void ReadUnlock()
    {
        _Unlock();
    }

    // Unlock the lock after a call to ReadOrWriteLock().
    inline void ReadOrWriteUnlock(bool)
    {
        ReadUnlock();
    } 

    // Is the lock already locked for writing?
    bool IsWriteLocked() const
    {
        return _IsLocked();
    }
    
    // Is the lock already locked for reading?
    bool IsReadLocked() const
    {
        return _IsLocked();
    }
    
    // Is the lock unlocked for writing?
    bool IsWriteUnlocked() const
    {
        return !IsWriteLocked();
    }
    
    // Is the lock unlocked for reading?
    bool IsReadUnlocked() const
    {
        return !IsReadLocked();
    }
    
    // Convert a reader lock to a writer lock
    void ConvertSharedToExclusive()
    {
        // no-op
    }

    // Convert a writer lock to a reader lock
    void ConvertExclusiveToShared()
    {
        // no-op
    }
    
    // Set the spin count for this lock.
    bool SetSpinCount(WORD dwSpins)     {return false;}

    // Return the spin count for this lock.
    WORD GetSpinCount() const
    {
        return sm_wDefaultSpinCount;
    }
    
    LOCK_DEFAULT_SPIN_IMPLEMENTATION();

    static const char*   ClassName()    {return "CSpinLock";}
}; // CSpinLock




//--------------------------------------------------------------------
// A dummy class, primarily useful as a template parameter

class IRTL_DLLEXP CFakeLock :
    public CLockBase<LOCK_FAKELOCK, LOCK_MUTEX,
                       LOCK_RECURSIVE, LOCK_WAIT_SLEEP, LOCK_QUEUE_FIFO,
                       LOCK_NO_SPIN
                      >
{
private:
    LOCK_INSTRUMENTATION_DECL();

public:
    CFakeLock()                     {} 
#ifdef LOCK_INSTRUMENTATION
    CFakeLock(const char*)          {}
#endif // LOCK_INSTRUMENTATION
    ~CFakeLock()                    {} 
    void WriteLock()                {} 
    void ReadLock()                 {} 
    bool ReadOrWriteLock()          {return true;} 
    bool TryWriteLock()             {return true;} 
    bool TryReadLock()              {return true;} 
    void WriteUnlock()              {}
    void ReadUnlock()               {}
    void ReadOrWriteUnlock(bool)    {}
    bool IsWriteLocked() const      {return true;} 
    bool IsReadLocked() const       {return IsWriteLocked();}
    bool IsWriteUnlocked() const    {return true;}
    bool IsReadUnlocked() const     {return true;}
    void ConvertSharedToExclusive() {}
    void ConvertExclusiveToShared() {}
    bool SetSpinCount(WORD dwSpins) {return false;}
    WORD GetSpinCount() const       {return LOCK_DONT_SPIN;}

    LOCK_DEFAULT_SPIN_IMPLEMENTATION();

    static const char*   ClassName()  {return "CFakeLock";}
}; // CFakeLock




//--------------------------------------------------------------------
// A Win32 CRITICAL_SECTION

class IRTL_DLLEXP CCritSec :
    public CLockBase<LOCK_CRITSEC, LOCK_MUTEX,
                       LOCK_RECURSIVE, LOCK_WAIT_HANDLE, LOCK_QUEUE_KERNEL,
                       LOCK_INDIVIDUAL_SPIN
                      >
{
private:
    CRITICAL_SECTION m_cs;

    LOCK_INSTRUMENTATION_DECL();

public:
    CCritSec()
    {
        InitializeCriticalSection(&m_cs);
        SetSpinCount(sm_wDefaultSpinCount);
    }
#ifdef LOCK_INSTRUMENTATION
    CCritSec(const char*)
    {
        InitializeCriticalSection(&m_cs);
        SetSpinCount(sm_wDefaultSpinCount);
    }
#endif // LOCK_INSTRUMENTATION
    ~CCritSec()         { DeleteCriticalSection(&m_cs); }

    void WriteLock()    { EnterCriticalSection(&m_cs); }
    void ReadLock()     { WriteLock(); }
    bool ReadOrWriteLock() { ReadLock(); return true; } 
    bool TryWriteLock();
    bool TryReadLock()  { return TryWriteLock(); }
    void WriteUnlock()  { LeaveCriticalSection(&m_cs); }
    void ReadUnlock()   { WriteUnlock(); }
    void ReadOrWriteUnlock(bool) { ReadUnlock(); } 

    bool IsWriteLocked() const      {return true;}  // TODO: fix this
    bool IsReadLocked() const       {return IsWriteLocked();}
    bool IsWriteUnlocked() const    {return true;}  // TODO: fix this
    bool IsReadUnlocked() const     {return true;}  // TODO: fix this

    // Convert a reader lock to a writer lock
    void ConvertSharedToExclusive()
    {
        // no-op
    }

    // Convert a writer lock to a reader lock
    void ConvertExclusiveToShared()
    {
        // no-op
    }
    
    // Wrapper for ::SetCriticalSectionSpinCount which was introduced
    // in NT 4.0 sp3 and hence is not available on all platforms
    static DWORD SetSpinCount(LPCRITICAL_SECTION pcs,
                              DWORD dwSpinCount=LOCK_DEFAULT_SPINS);

    bool SetSpinCount(WORD wSpins)
    {SetSpinCount(&m_cs, wSpins); return true;}
    
    WORD GetSpinCount() const       { return sm_wDefaultSpinCount; }    // TODO

    LOCK_DEFAULT_SPIN_IMPLEMENTATION();

    static const char*   ClassName()  {return "CCritSec";}
}; // CCritSec




//--------------------------------------------------------------------
// CReaderWriterlock is a multi-reader, single-writer spinlock due to NJain,
// which in turn is derived from an exclusive spinlock by DmitryR.
// Gives priority to writers.  Cannot be acquired recursively.
// No error checking. Use CReaderWriterLock3.

class IRTL_DLLEXP CReaderWriterLock :
    public CLockBase<LOCK_READERWRITERLOCK, LOCK_MRSW,
                       LOCK_READ_RECURSIVE, LOCK_WAIT_SLEEP, LOCK_QUEUE_KERNEL,
                       LOCK_CLASS_SPIN
                      >
{
private:
    volatile  LONG  m_nState;   // > 0 => that many readers
    volatile  LONG  m_cWaiting; // number of would-be writers

    LOCK_INSTRUMENTATION_DECL();

private:
    enum {
        SL_FREE = 0,
        SL_EXCLUSIVE = -1,
    };

    void _LockSpin(bool fWrite);
    void _WriteLockSpin() { _LockSpin(true); }
    void _ReadLockSpin()  { _LockSpin(false); }

    // _CmpExch is equivalent to
    //      LONG lTemp = m_lRW;
    //      if (lTemp == lCurrent)  m_lRW = lNew;
    //      return lCurrent == lTemp;
    // except it's one atomic instruction.  Using this gives us the basis of
    // a protocol because the update only succeeds when we knew exactly what
    // used to be in m_lRW.  If some other thread slips in and modifies m_lRW
    // before we do, the update will fail.  In other words, it's transactional.
    LOCK_FORCEINLINE bool _CmpExch(LONG lNew, LONG lCurrent)
    {
        return lCurrent == Lock_AtomicCompareExchange(
                                 const_cast<LONG*>(&m_nState), lNew, lCurrent);
    }

    LOCK_FORCEINLINE bool _TryWriteLock()
    {
        return (m_nState == SL_FREE  &&  _CmpExch(SL_EXCLUSIVE, SL_FREE));
    }

    LOCK_FORCEINLINE bool _TryReadLock()
    {
        LONG nCurrState = m_nState;
                
        // Give writers priority
        return (nCurrState != SL_EXCLUSIVE  &&  m_cWaiting == 0
                &&  _CmpExch(nCurrState + 1, nCurrState));
    }

public:
    CReaderWriterLock()
        : m_nState(SL_FREE),
          m_cWaiting(0)
    {
    }

#ifdef LOCK_INSTRUMENTATION
    CReaderWriterLock(
        const char* pszName)
        : m_nState(SL_FREE),
          m_cWaiting(0)
    {
        LOCK_INSTRUMENTATION_INIT(pszName);
    }
#endif // LOCK_INSTRUMENTATION

#ifdef _DEBUG
    ~CReaderWriterLock()
    {
        IRTLASSERT(m_nState == SL_FREE  &&  m_cWaiting == 0);
    }
#endif // _DEBUG

    inline void WriteLock()
    {
        LOCK_WRITELOCK_INSTRUMENTATION();

        // Add ourselves to the queue of waiting writers
        Lock_AtomicIncrement(const_cast<LONG*>(&m_cWaiting));
        
        if (_TryWriteLock())
            return;

        _WriteLockSpin();
    } 

    inline void ReadLock()
    {
        LOCK_READLOCK_INSTRUMENTATION();

        if (_TryReadLock())
            return;
        
        _ReadLockSpin();
    } 

    inline bool TryWriteLock()
    {
        // Add ourselves to the queue of waiting writers
        Lock_AtomicIncrement(const_cast<LONG*>(&m_cWaiting));

        if (_TryWriteLock())
        {
            LOCK_WRITELOCK_INSTRUMENTATION();
            return true;
        }

        Lock_AtomicDecrement(const_cast<LONG*>(&m_cWaiting));
        return false;    
    }

    inline bool TryReadLock()
    {
        if (_TryReadLock())
        {
            LOCK_READLOCK_INSTRUMENTATION();
            return true;
        }

        return false;
    }

    inline void WriteUnlock()
    {
        Lock_AtomicExchange(const_cast<LONG*>(&m_nState), SL_FREE);
        Lock_AtomicDecrement(const_cast<LONG*>(&m_cWaiting));
    }

    inline void ReadUnlock()
    {
        Lock_AtomicDecrement(const_cast<LONG*>(&m_nState));
    }

    bool IsWriteLocked() const      {return m_nState == SL_EXCLUSIVE;}
    bool IsReadLocked() const       {return m_nState > SL_FREE;}
    bool IsWriteUnlocked() const    {return m_nState != SL_EXCLUSIVE;}
    bool IsReadUnlocked() const     {return m_nState <= SL_FREE;}

    void ConvertSharedToExclusive()
    {
        IRTLASSERT(IsReadLocked());
        Lock_AtomicIncrement(const_cast<LONG*>(&m_cWaiting));

        // single reader?
        if (m_nState == SL_FREE + 1  &&  _CmpExch(SL_EXCLUSIVE, SL_FREE + 1))
            return;

        // release the reader lock and spin
        Lock_AtomicDecrement(const_cast<LONG*>(&m_nState));
        _WriteLockSpin();

        IRTLASSERT(IsWriteLocked());
    }

    void ConvertExclusiveToShared()
    {
        IRTLASSERT(IsWriteLocked());
        Lock_AtomicExchange(const_cast<LONG*>(&m_nState), SL_FREE + 1);
        Lock_AtomicDecrement(const_cast<LONG*>(&m_cWaiting));
        IRTLASSERT(IsReadLocked());
    }

    bool SetSpinCount(WORD wSpins)      {return false;}
    WORD GetSpinCount() const           {return sm_wDefaultSpinCount;}

    LOCK_DEFAULT_SPIN_IMPLEMENTATION();

    static const char*   ClassName()    {return "CReaderWriterLock";}
}; // CReaderWriterLock



//--------------------------------------------------------------------
// CReaderWriterlock2 is a multi-reader, single-writer spinlock due to NJain,
// which in turn is derived from an exclusive spinlock by DmitryR.
// Gives priority to writers.  Cannot be acquired recursively.
// No error checking. The difference between this and CReaderWriterLock is
// that all the state is packed into a single LONG, instead of two LONGs.

class IRTL_DLLEXP CReaderWriterLock2 :
    public CLockBase<LOCK_READERWRITERLOCK2, LOCK_MRSW,
                       LOCK_READ_RECURSIVE, LOCK_WAIT_SLEEP, LOCK_QUEUE_KERNEL,
                       LOCK_CLASS_SPIN
                      >
{
private:
    volatile LONG m_lRW;

    // LoWord is state. ==0 => free; >0 => readers; ==0xFFFF => 1 writer.
    // HiWord is count of writers, W.
    //      If LoWord==0xFFFF => W-1 waiters, 1 writer;
    //      otherwise W waiters.
    enum {
        SL_FREE =         0x00000000,
        SL_STATE_MASK =   0x0000FFFF,
        SL_STATE_SHIFT =           0,
        SL_WAITING_MASK = 0xFFFF0000,   // waiting writers
        SL_WAITING_SHIFT =        16,
        SL_READER_INCR =  0x00000001,
        SL_READER_MASK =  0x00007FFF,
        SL_EXCLUSIVE =    0x0000FFFF,   // one writer
        SL_WRITER_INCR =  0x00010000,
        SL_ONE_WRITER =   SL_EXCLUSIVE | SL_WRITER_INCR,
        SL_ONE_READER =  (SL_FREE + 1),
        SL_WRITERS_MASK = ~SL_READER_MASK,
    };

    LOCK_INSTRUMENTATION_DECL();

private:
    void _LockSpin(bool fWrite);
    void _WriteLockSpin();
    void _ReadLockSpin()  { _LockSpin(false); }

    
    // _CmpExch is equivalent to
    //      LONG lTemp = m_lRW;
    //      if (lTemp == lCurrent)  m_lRW = lNew;
    //      return lCurrent == lTemp;
    // except it's one atomic instruction.  Using this gives us the basis of
    // a protocol because the update only succeeds when we knew exactly what
    // used to be in m_lRW.  If some other thread slips in and modifies m_lRW
    // before we do, the update will fail.  In other words, it's transactional.
    LOCK_FORCEINLINE bool _CmpExch(LONG lNew, LONG lCurrent)
    {
        return lCurrent ==Lock_AtomicCompareExchange(const_cast<LONG*>(&m_lRW),
                                                     lNew, lCurrent);
    }

    LOCK_FORCEINLINE bool _TryWriteLock(
        LONG nIncr)
    {
        LONG l = m_lRW;
        // Grab exclusive access to the lock if it's free.  Works even
        // if there are other writers queued up.
        return ((l & SL_STATE_MASK) == SL_FREE
                &&  _CmpExch((l + nIncr) | SL_EXCLUSIVE, l));
    }

    LOCK_FORCEINLINE bool _TryReadLock()
    {
        LONG l = m_lRW;
                
        // Give writers priority
        return ((l & SL_WRITERS_MASK) == 0
                &&  _CmpExch(l + SL_READER_INCR, l));
    }

public:
    CReaderWriterLock2()
        : m_lRW(SL_FREE)
    {}

#ifdef LOCK_INSTRUMENTATION
    CReaderWriterLock2(
        const char* pszName)
        : m_lRW(SL_FREE)
    {
        LOCK_INSTRUMENTATION_INIT(pszName);
    }
#endif // LOCK_INSTRUMENTATION

#ifdef _DEBUG
    ~CReaderWriterLock2()
    {
        IRTLASSERT(m_lRW == SL_FREE);
    }
#endif // _DEBUG

    inline void WriteLock()
    {
        LOCK_WRITELOCK_INSTRUMENTATION();

        // Optimize for the common case
        if (_TryWriteLock(SL_WRITER_INCR))
            return;
        
        _WriteLockSpin();
    } 

    inline void ReadLock()
    {
        LOCK_READLOCK_INSTRUMENTATION();

        // Optimize for the common case
        if (_TryReadLock())
            return;
        
        _ReadLockSpin();
    } 

    inline bool TryWriteLock()
    {
        if (_TryWriteLock(SL_WRITER_INCR))
        {
            LOCK_WRITELOCK_INSTRUMENTATION();
            return true;
        }

        return false;
    }

    inline bool TryReadLock()
    {
        if (_TryReadLock())
        {
            LOCK_READLOCK_INSTRUMENTATION();
            return true;
        }

        return false;
    }

    inline void WriteUnlock()
    {
        IRTLASSERT(IsWriteLocked());
        for (LONG l = m_lRW;
                    // decrement waiter count, clear loword to SL_FREE
             !_CmpExch((l - SL_WRITER_INCR) & ~SL_STATE_MASK, l);
             l = m_lRW)
        {
            IRTLASSERT(IsWriteLocked());
            Lock_Yield();
        }
    }

    inline void ReadUnlock()
    {
        IRTLASSERT(IsReadLocked());
        for (LONG l = m_lRW;  !_CmpExch(l - SL_READER_INCR, l);  l = m_lRW)
        {
            IRTLASSERT(IsReadLocked());
            Lock_Yield();
        }
    }

    bool IsWriteLocked() const
    {return (m_lRW & SL_STATE_MASK) == SL_EXCLUSIVE;}

    bool IsReadLocked() const
    {return (m_lRW & SL_READER_MASK) >= SL_READER_INCR ;}

    bool IsWriteUnlocked() const
    {return !IsWriteLocked();}

    bool IsReadUnlocked() const
    {return !IsReadLocked();}

    void ConvertSharedToExclusive()
    {
        IRTLASSERT(IsReadLocked());

        // single reader?
        if (m_lRW != SL_ONE_READER  ||  !_CmpExch(SL_ONE_WRITER,SL_ONE_READER))
        {
            // no, multiple readers
            ReadUnlock();
            _WriteLockSpin();
        }

        IRTLASSERT(IsWriteLocked());
    }

    void ConvertExclusiveToShared()
    {
        IRTLASSERT(IsWriteLocked());
        for (LONG l = m_lRW;
             !_CmpExch(((l-SL_WRITER_INCR) & SL_WAITING_MASK) | SL_READER_INCR,
                         l);
            l = m_lRW)
        {
            IRTLASSERT(IsWriteLocked());
            Lock_Yield();
        }

        IRTLASSERT(IsReadLocked());
    }

    bool SetSpinCount(WORD wSpins)      {return false;}
    WORD GetSpinCount() const           {return sm_wDefaultSpinCount;}

    LOCK_DEFAULT_SPIN_IMPLEMENTATION();

    static const char*   ClassName()    {return "CReaderWriterLock2";}
}; // CReaderWriterLock2



//--------------------------------------------------------------------
// CReaderWriterLock3 is a multi-reader, single-writer spinlock due
// to NJain, which in turn is derived from an exclusive spinlock by DmitryR.
// Gives priority to writers.  Cannot be acquired recursively.
// No error checking. Much like CReaderWriterLock2, except that the WriteLock
// can be acquired recursively.

class IRTL_DLLEXP CReaderWriterLock3 :
    public CLockBase<LOCK_READERWRITERLOCK3, LOCK_MRSW,
                       LOCK_RECURSIVE, LOCK_WAIT_SLEEP, LOCK_QUEUE_KERNEL,
                       LOCK_CLASS_SPIN
                      >
{
private:
    volatile LONG m_lRW;    // Reader-Writer state
    volatile LONG m_lTid;   // Owning Thread ID + recursion count

    // m_lRW:
    //  LoWord is state. =0 => free; >0 => readers; ==0xFFFF => 1 writer
    //  HiWord is count of writers. If LoWord==0xFFFF => N-1 waiters, 1 writer;
    //      otherwise N waiters.
    // m_lTid:
    //  If readers, then 0; if a write lock, then thread id + recursion count

    enum {
        // m_lRW
        SL_FREE =         0x00000000,
        SL_STATE_MASK =   0x0000FFFF,
        SL_STATE_SHIFT =           0,
        SL_WAITING_MASK = 0xFFFF0000,   // waiting writers
        SL_WAITING_SHIFT =        16,
        SL_READER_INCR =  0x00000001,
        SL_READER_MASK =  0x00007FFF,
        SL_EXCLUSIVE =    0x0000FFFF,   // one writer
        SL_WRITER_INCR =  0x00010000,
        SL_ONE_WRITER =   SL_EXCLUSIVE | SL_WRITER_INCR,
        SL_ONE_READER =  (SL_FREE + 1),
        SL_WRITERS_MASK = ~SL_READER_MASK,

        // m_lTid
        SL_THREAD_SHIFT = 0,
        SL_THREAD_BITS  = 28,
        SL_OWNER_SHIFT  = SL_THREAD_BITS,
        SL_OWNER_BITS   = 4,
        SL_THREAD_MASK  = ((1 << SL_THREAD_BITS) - 1) << SL_THREAD_SHIFT,
        SL_OWNER_INCR   = 1 << SL_THREAD_BITS,
        SL_OWNER_MASK   = ((1 << SL_OWNER_BITS) - 1) << SL_OWNER_SHIFT,
    };

    LOCK_INSTRUMENTATION_DECL();

private:
    void _LockSpin(bool fWrite);
    void _WriteLockSpin();
    void _ReadLockSpin()  { _LockSpin(false); }

    
    // _CmpExch is equivalent to
    //      LONG lTemp = m_lRW;
    //      if (lTemp == lCurrent)  m_lRW = lNew;
    //      return lCurrent == lTemp;
    // except it's one atomic instruction.  Using this gives us the basis of
    // a protocol because the update only succeeds when we knew exactly what
    // used to be in m_lRW.  If some other thread slips in and modifies m_lRW
    // before we do, the update will fail.  In other words, it's transactional.
    LOCK_FORCEINLINE bool _CmpExch(LONG lNew, LONG lCurrent)
    {
        return lCurrent==Lock_AtomicCompareExchange(const_cast<LONG*>(&m_lRW),
                                                    lNew, lCurrent);
    }

    // Get the current thread ID.  Assumes that it can fit into 28 bits,
    // which is fairly safe as NT recycles thread IDs and failing to fit into
    // 28 bits would mean that more than 268,435,456 threads were currently
    // active.  This is improbable in the extreme as NT runs out of
    // resources if there are more than a few thousands threads in
    // existence and the overhead of context swapping becomes unbearable.
    inline static LONG _CurrentThreadId()
    {
        DWORD dwTid = ::GetCurrentThreadId();
        // Thread ID 0 is used by the System Process (Process ID 0).
        // We use a thread-id of zero to indicate lock is unowned.
        // NT uses +ve thread ids, Win9x uses -ve ids
        IRTLASSERT(dwTid != 0
                  && ((dwTid <= SL_THREAD_MASK) || (dwTid > ~SL_THREAD_MASK)));
        return (LONG) (dwTid & SL_THREAD_MASK);
    }

    LOCK_FORCEINLINE bool _TryWriteLock(
        LONG nIncr)
    {
        // The common case: the writelock has no owner
        if (m_lTid == 0)
        {
            // IRTLASSERT((m_lRW & SL_STATE_MASK) != SL_EXCLUSIVE);
            LONG l = m_lRW;
            // Grab exclusive access to the lock if it's free.  Works even
            // if there are other writers queued up.
            if ((l & SL_STATE_MASK) == SL_FREE
                &&  _CmpExch((l + nIncr) | SL_EXCLUSIVE, l))
            {
                l = Lock_AtomicExchange(const_cast<LONG*>(&m_lTid), 
                                        _CurrentThreadId() | SL_OWNER_INCR);
                IRTLASSERT(l == 0);
                return true;
            }
        }

        return _TryWriteLock2();
    }

    // split into a separate function to make _TryWriteLock more inlineable
    bool _TryWriteLock2()
    {
        if ((m_lTid & SL_THREAD_MASK) == _CurrentThreadId())
        {
            IRTLASSERT((m_lRW & SL_STATE_MASK) == SL_EXCLUSIVE);
            IRTLASSERT((m_lTid & SL_OWNER_MASK) != SL_OWNER_MASK);

            Lock_AtomicExchangeAdd(const_cast<LONG*>(&m_lTid), SL_OWNER_INCR);
            return true;
        }

        return false;
    }

    LOCK_FORCEINLINE bool _TryReadLock()
    {
        LONG l = m_lRW;
                
        // Give writers priority
        bool f = ((l & SL_WRITERS_MASK) == 0
                  &&  _CmpExch(l + SL_READER_INCR, l));
        IRTLASSERT(!f  ||  m_lTid == 0);
        return f;
    }

public:
    CReaderWriterLock3()
        : m_lRW(SL_FREE),
          m_lTid(0)
    {}

#ifdef LOCK_INSTRUMENTATION
    CReaderWriterLock3(
        const char* pszName)
        : m_lRW(SL_FREE),
          m_lTid(0)
    {
        LOCK_INSTRUMENTATION_INIT(pszName);
    }
#endif // LOCK_INSTRUMENTATION

#ifdef _DEBUG
    ~CReaderWriterLock3()
    {
        IRTLASSERT(m_lRW == SL_FREE  &&  m_lTid == 0);
    }
#endif // _DEBUG

    inline void WriteLock()
    {
        LOCK_WRITELOCK_INSTRUMENTATION();

        // Optimize for the common case
        if (_TryWriteLock(SL_WRITER_INCR))
            return;
        
        _WriteLockSpin();
    } 

    inline void ReadLock()
    {
        LOCK_READLOCK_INSTRUMENTATION();

        // Optimize for the common case
        if (_TryReadLock())
            return;
        
        _ReadLockSpin();
    } 

    // If already locked, recursively acquires another lock of the same
    // kind (read or write). Otherwise, just acquires a read lock.
    // Needed for cases like this.
    //      pTable->WriteLock();
    //      if (!pTable->FindKey(&SomeKey))
    //          InsertRecord(&Whatever);
    //      pTable->WriteUnlock();
    // where FindKey looks like
    //  Table::FindKey(pKey) {
    //      ReadOrWriteLock();
    //      // find pKey if present in table
    //      ReadOrWriteUnlock();
    //  }
    // and InsertRecord looks like
    //  Table::InsertRecord(pRecord) {
    //      WriteLock();
    //      // insert pRecord into table
    //      WriteUnlock();
    //  }
    // If FindKey called ReadLock while the thread already had done a
    // WriteLock, the thread would deadlock.
    
    inline bool ReadOrWriteLock()
    {
        if (IsWriteLocked())
        {
            WriteLock();
            return false;
        }
        else
        {
            ReadLock();
            return true;
        }
    } 

    inline bool TryWriteLock()
    {
        if (_TryWriteLock(SL_WRITER_INCR))
        {
            LOCK_WRITELOCK_INSTRUMENTATION();
            return true;
        }

        return false;
    }

    inline bool TryReadLock()
    {
        if (_TryReadLock())
        {
            LOCK_READLOCK_INSTRUMENTATION();
            return true;
        }

        return false;
    }

    inline void WriteUnlock()
    {
        IRTLASSERT(IsWriteLocked());
        LONG lNew = m_lTid - SL_OWNER_INCR; 

        // Last owner?  Release completely, if so
        if ((lNew & SL_OWNER_MASK) == 0)
        {
            Lock_AtomicExchange(const_cast<LONG*>(&m_lTid), 0);
            for (LONG l = m_lRW;
                    // decrement waiter count, clear loword to SL_FREE
                 !_CmpExch((l - SL_WRITER_INCR) & ~SL_STATE_MASK, l);
                 l = m_lRW)
            {
                Lock_Yield();
            }
        }
        else
            Lock_AtomicExchange(const_cast<LONG*>(&m_lTid), lNew);
    }

    inline void ReadUnlock()
    {
        IRTLASSERT(IsReadLocked());
        for (LONG l = m_lRW;  !_CmpExch(l - SL_READER_INCR, l);  l = m_lRW)
        {
            IRTLASSERT(IsReadLocked());
            Lock_Yield();
        }
    }

    inline void ReadOrWriteUnlock(bool fIsReadLocked)
    {
        if (fIsReadLocked)
            ReadUnlock();
        else
            WriteUnlock();
    } 

    // Does current thread hold a write lock?
    bool IsWriteLocked() const
    {
        // bool fLocked = ((m_lTid & SL_THREAD_MASK) == _CurrentThreadId());
        bool fLocked = !((m_lTid ^ GetCurrentThreadId()) & SL_THREAD_MASK);
        IRTLASSERT(!fLocked  || (((m_lRW & SL_STATE_MASK) == SL_EXCLUSIVE)
                                 &&  ((m_lTid & SL_OWNER_MASK) > 0)));
        return fLocked;
    }

    bool IsReadLocked() const
    {return (m_lRW & SL_READER_MASK) >= SL_READER_INCR ;}

    bool IsWriteUnlocked() const
    {return !IsWriteLocked();}

    bool IsReadUnlocked() const
    {return !IsReadLocked();}

    // Note: if there's more than one reader, then there's a window where
    // another thread can acquire and release a writelock before this routine
    // returns.
    void ConvertSharedToExclusive()
    {
        IRTLASSERT(IsReadLocked());

        // single reader?
        if (m_lRW == SL_ONE_READER  &&  _CmpExch(SL_ONE_WRITER, SL_ONE_READER))
        {
            Lock_AtomicExchange(const_cast<LONG*>(&m_lTid), 
                                _CurrentThreadId() | SL_OWNER_INCR);
        }
        else
        {
            // no, multiple readers
            ReadUnlock();
            _WriteLockSpin();
        }

        IRTLASSERT(IsWriteLocked());
    }

    // There is no such window when converting from a writelock to a readlock
    void ConvertExclusiveToShared()
    {
        IRTLASSERT(IsWriteLocked());

        // assume writelock is not held recursively
        IRTLASSERT((m_lTid & SL_OWNER_MASK) == SL_OWNER_INCR);
        Lock_AtomicExchange(const_cast<LONG*>(&m_lTid), 0);

        for (LONG l = m_lRW;
             !_CmpExch(((l-SL_WRITER_INCR) & SL_WAITING_MASK) | SL_READER_INCR,
                        l);
             l = m_lRW)
        {
            Lock_Yield();
        }

        IRTLASSERT(IsReadLocked());
    }

    bool SetSpinCount(WORD wSpins)      {return false;}
    WORD GetSpinCount() const           {return sm_wDefaultSpinCount;}

    LOCK_DEFAULT_SPIN_IMPLEMENTATION();

    static const char*   ClassName()    {return "CReaderWriterLock3";}
}; // CReaderWriterLock3


#ifdef __LOCKS_NAMESPACE__
}
#endif // __LOCKS_NAMESPACE__

#endif // __LOCKS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\lkhash.h ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
       lkhash.h

   Abstract:
       Declares hash tables

   Author:
       Paul Larson, palarson@microsoft.com, July 1997
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/


#ifndef __LKHASH_H__
#define __LKHASH_H__

//=====================================================================
//  The class CLKLinearHashTable defined in this file provides dynamic hash
//  tables, i.e. tables that grow and shrink dynamically with
//  the number of records in the table.
//  The basic method used is linear hashing, as explained in:
//
//    P.-A. Larson, Dynamic Hash Tables, Comm. of the ACM, 31, 4 (1988)
//
//  This version has the following characteristics:
//  - It is thread-safe and uses spin locks for synchronization.
//  - It was designed to support very high rates of concurrent
//    operations (inserts/deletes/lookups).  It achieves this by
//    (a) partitioning a CLKHashTable into a collection of CLKLinearHashTables
//        to reduce contention on the global table lock.
//    (b) minimizing the hold time on a table lock, preferring to lock
//        down a bucket chain instead.
//  - The design is L1 cache-conscious.  See CNodeClump.
//  - It is designed for sets varying in size from a dozen
//    elements to a several million elements.
//
//  Main classes:
//    CLKLinearHashTable: thread-safe linear hash table
//    CLKHashTable:       collection of CLKLinearHashTables
//    CTypedHashTable:    typesafe wrapper for CLKHashTable
//
//
//  Paul Larson, palarson@microsoft.com, July 1997
//   Original implementation with input from Murali R. Krishnan,
//   muralik@microsoft.com.
//
//  George V. Reilly, georgere@microsoft.com, Dec 1997-Jan 1998
//   Massive cleanup and rewrite.  Added templates.
//=====================================================================


// 1) Linear Hashing
// ------------------
//
// Linear hash tables grow and shrink dynamically with the number of
// records in the table.  The growth or shrinkage is smooth: logically,
// one bucket at a time but physically in larger increments
// (64 buckets).  An insertion (deletion) may cause an expansion
// (contraction) of the table.  This causes relocation of a small number
// of records (at most one bucket worth).  All operations (insert,
// delete, lookup) take constant expected time, regardless of the
// current size or the growth of the table.
//
// 2) LK extensions to Linear hash table
// --------------------------------------
//
// Larson-Krishnan extensions to Linear hash tables for multiprocessor
// scalability and improved cache performance.
//
// Traditional implementations of linear hash tables use one global lock
// to prevent interference between concurrent operations
// (insert/delete/lookup) on the table.  The single lock easily becomes
// the bottleneck in SMP scenarios when multiple threads are used.
//
// Traditionally, a (hash) bucket is implemented as a chain of
// single-item nodes.  Every operation results in chasing down a chain
// looking for an item. However, pointer chasing is very slow on modern
// systems because almost every jump results in a cache miss. L2 (or L3)
// cache misses are very expensive in missed CPU cycles and the cost is
// increasing (going to 100s of cycles in the future).
//
// LK extensions offer
//    1) Partitioning (by hashing) of records among multiple subtables.
//       Each subtable has locks but there is no global lock.  Each
//       subtable receives a much lower rate of operations, resulting in
//       fewer conflicts.
//
//    2) Improve cache locality by grouping keys and their hash values
//       into contigous chunks that fit exactly into one (or a few)
//       cache lines.
//
// Specifically the implementation that exists here achieves this using
// following techniques.
//
// Class CLKHashTable is the top-level data structure that dynamically
// creates m_cSubTables linear hash tables. The CLKLinearHashTables act as
// the subtables to which items and accesses are fanned out. A good
// hash function multiplexes requests uniformly to various subtables,
// thus minimizing traffic to any single subtable. The implemenation
// uses a home-grown version of bounded spinlocks, that is, a thread
// does not spin on a lock indefinitely, instead yielding after a
// predetermined number of loops.
//
// Each CLKLinearHashTable consists of a CDirEntry pointing to segments
// each holding m_dwSegSize CBuckets. Each CBucket in turn consists of a
// chain of CNodeClumps.  Each CNodeClump contains a group of
// NODES_PER_CLUMP hash values (aka hash keys or signatures) and
// pointers to the associated data items.  Keeping the signatures
// together increases the cache locality in scans for lookup.
//
// Traditionally, people store a link-list element right inside the
// object that is hashed and use this link-list for the chaining of data
// blocks.  However, keeping just the pointers to the data object and
// not chaining through them limits the need for bringing in the data
// object to the cache.  We need to access the data object only if the
// hash values match. This limits the cache-thrashing behaviour
// exhibited by conventional implementations.  It has the additional
// benefit that the objects themselves do not need to be modified
// in order to be collected in the hash table (i.e., it's non-invasive).


//--------------------------------------------------------------------
// TODO
// * Debugging support for iisprobe and inetdbg?
// * Use auto_ptrs.
// * Provide ReplaceRecord and DeleteRecord methods on iterators.
// * Sloppy iterators
// * Provide implementations of the STL collection classes, map, set,
//   multimap, and multiset.
// * Make exception safe.
//--------------------------------------------------------------------


#include <irtldbg.h>
#include <locks.h>
#include <hashfn.h>
#include <limits.h>



#ifdef __LKHASH_NAMESPACE__
namespace LKHash {
#endif // __LKHASH_NAMESPACE__

enum LK_TABLESIZE {
    LK_SMALL_TABLESIZE=  1,     // < 200 elements
    LK_MEDIUM_TABLESIZE= 2,     // 200...10,000 elements
    LK_LARGE_TABLESIZE=  3,     // 10,000+ elements
};

// Default values for the hashtable constructors
enum {
    LK_DFLT_MAXLOAD=     4, // Default upperbound on average chain length.
    LK_DFLT_INITSIZE=LK_MEDIUM_TABLESIZE, // Default initial size of hash table
    LK_DFLT_NUM_SUBTBLS= 0, // Use a heuristic to choose #subtables
};

// build fix hack
enum {
    DFLT_LK_MAXLOAD=     LK_DFLT_MAXLOAD,
    DFLT_LK_INITSIZE=    LK_DFLT_INITSIZE,
    DFLT_LK_NUM_SUBTBLS= LK_DFLT_NUM_SUBTBLS,
};

//--------------------------------------------------------------------
// forward declarations

class IRTL_DLLEXP CLKLinearHashTable;

class IRTL_DLLEXP CLKHashTable;

template <class _Der, class _Rcd, class _Ky, class _HT, class _Iter>
class CTypedHashTable;


//--------------------------------------------------------------------
// Possible return codes from public member functions of
// CLKLinearHashTable, CLKHashTable, and CTypedHashTable

enum LK_RETCODE {
    // severe errors < 0
    LK_UNUSABLE = -99,  // Table corrupted: all bets are off
    LK_ALLOC_FAIL,      // ran out of memory
    LK_BAD_ITERATOR,    // invalid iterator; e.g., points to another table
    LK_BAD_RECORD,      // invalid record; e.g., NULL for InsertRecord

    LK_SUCCESS = 0,     // everything's okay
    LK_KEY_EXISTS,      // key already present for InsertRecord(no-overwrite)
    LK_NO_SUCH_KEY,     // key not found
    LK_NO_MORE_ELEMENTS,// iterator exhausted
};

#define LK_SUCCEEDED(lkrc)  ((lkrc) >= LK_SUCCESS)


//--------------------------------------------------------------------
// Return codes from PFnRecordPred.

enum LK_PREDICATE {
    LKP_ABORT = 1,           // Stop walking the table immediately
    LKP_NO_ACTION = 2,       // No action, just keep walking
    LKP_PERFORM = 3,         // Perform action and continue walking
    LKP_PERFORM_STOP = 4,    // Perform action, then stop
    LKP_DELETE = 5,          // Delete record and keep walking
    LKP_DELETE_STOP = 6,     // Delete record, then stop
};


//--------------------------------------------------------------------
// Return codes from PFnRecordAction.

enum LK_ACTION {
    LKA_ABORT = 1,          // Stop walking the table immediately
    LKA_FAILED = 2,         // Action failed; continue walking the table
    LKA_SUCCEEDED = 3,      // Action succeeded; continue walking the table
};


//--------------------------------------------------------------------
// Parameter to Apply and ApplyIf.

enum LK_LOCKTYPE {
    LKL_READLOCK = 1,       // Lock the table for reading (for constness)
    LKL_WRITELOCK = 2,      // Lock the table for writing
};



//--------------------------------------------------------------------
// Global table lock code.  This is only used to measure how much of a
// slowdown having a global lock on the CLKHashTable causes.  It is never
// used in production code.


// #define LKHASH_GLOBAL_LOCK CCritSec

#ifdef LKHASH_GLOBAL_LOCK

# define LKHASH_GLOBAL_LOCK_DECLARATIONS()         \
    typedef LKHASH_GLOBAL_LOCK GlobalLock;  \
    mutable GlobalLock m_lkGlobal;

# define LKHASH_GLOBAL_READ_LOCK()     m_lkGlobal.ReadLock()
# define LKHASH_GLOBAL_WRITE_LOCK()    m_lkGlobal.WriteLock()
# define LKHASH_GLOBAL_READ_UNLOCK()   m_lkGlobal.ReadUnlock()
# define LKHASH_GLOBAL_WRITE_UNLOCK()  m_lkGlobal.WriteUnlock()

#else // !LKHASH_GLOBAL_LOCK

# define LKHASH_GLOBAL_LOCK_DECLARATIONS()

// These ones will be optimized away by the compiler
# define LKHASH_GLOBAL_READ_LOCK()     ((void)0)
# define LKHASH_GLOBAL_WRITE_LOCK()    ((void)0)
# define LKHASH_GLOBAL_READ_UNLOCK()   ((void)0)
# define LKHASH_GLOBAL_WRITE_UNLOCK()  ((void)0)

#endif // !LKHASH_GLOBAL_LOCK



//--------------------------------------------------------------------
// Statistical information returned by GetStatistics
//--------------------------------------------------------------------

#ifdef LOCK_INSTRUMENTATION

class IRTL_DLLEXP CAveragedLockStats : public CLockStatistics
{
public:
    int m_nItems;

    CAveragedLockStats()
        : m_nItems(1)
    {}
};

#endif // LOCK_INSTRUMENTATION



class IRTL_DLLEXP CLKHashTableStats
{
public:
    int      RecordCount;           // number of records in the table
    int      TableSize;             // table size in number of slots
    int      DirectorySize;         // number of entries in directory
    int      LongestChain;          // longest hash chain in the table
    int      EmptySlots;            // number of unused hash slots
    double   SplitFactor;           // fraction of buckets split
    double   AvgSearchLength;       // average length of a successful search
    double   ExpSearchLength;       // theoretically expected length
    double   AvgUSearchLength;      // average length of an unsuccessful search
    double   ExpUSearchLength;      // theoretically expected length
    int      NodeClumpSize;         // number of slots in a node clump
    int      CBucketSize;           // sizeof(CBucket)

#ifdef LOCK_INSTRUMENTATION
    CAveragedLockStats      m_alsTable;  // stats for table lock
    CAveragedLockStats      m_alsBucketsAvg; // avg of stats for bucket locks
    CGlobalLockStatistics   m_gls;      // global statistics for all locks
#endif // LOCK_INSTRUMENTATION

    enum {
        MAX_BUCKETS = 40,
    };

    // histogram of bucket lengths
    LONG    m_aBucketLenHistogram[MAX_BUCKETS];

    CLKHashTableStats()
        : RecordCount(0),
          TableSize(0),
          DirectorySize(0),
          LongestChain(0),
          EmptySlots(0),
          SplitFactor(0.0),
          AvgSearchLength(0.0),
          ExpSearchLength(0.0),
          AvgUSearchLength(0.0),
          ExpUSearchLength(0.0),
          NodeClumpSize(1),
          CBucketSize(0)
    {
        for (int i = MAX_BUCKETS;  --i >= 0;  )
            m_aBucketLenHistogram[i] = 0;
    }

    static const LONG*
    BucketSizes()
    {
        static const LONG  s_aBucketSizes[MAX_BUCKETS] = {
             0,    1,    2,    3,    4,    5,    6,    7,      8,        9,
            10,   11,   12,   13,   14,   15,   16,   17,     18,       19,
            20,   21,   22,   23,   24,   25,   30,   40,     50,       60,
            70,   80,   90,  100,  200,  500, 1000,10000, 100000, LONG_MAX,
        };

        return s_aBucketSizes;
    }

    static LONG
    BucketSize(
        LONG nBucketIndex)
    {
        IRTLASSERT(0 <= nBucketIndex  &&  nBucketIndex < MAX_BUCKETS);
        return BucketSizes()[nBucketIndex];
    }

    static LONG
    BucketIndex(
        LONG nBucketLength)
    {
        const LONG* palBucketSizes = BucketSizes();
        LONG i = 0;
        while (palBucketSizes[i] < nBucketLength)
            ++i;
        if (i == MAX_BUCKETS  ||  palBucketSizes[i] > nBucketLength)
            --i;
        IRTLASSERT(0 <= i  &&  i < MAX_BUCKETS);
        return i;
    }
};



//--------------------------------------------------------------------
// CLKLinearHashTable deals with void* records.  These typedefs
// provide prototypes for functions that manipulate instances of
// those records.  CTypedHashTable and CStringTestHashTable (below) show a
// way to encapsulate these in typesafe wrappers.
//--------------------------------------------------------------------

// Given a record, return its key.  Assumes that the key is embedded in
// the record, or at least somehow derivable from the record.  For
// completely unrelated keys & values, a wrapper class should use
// something like STL's pair<key, value> template to aggregate them
// into a record.
typedef const void* (*PFnExtractKey)  (const void* pvRecord);

// Given a key, return its hash signature.  The hashing functions in
// hashfn.h (or something that builds upon them) are suggested.
typedef DWORD       (*PFnCalcKeyHash) (const void* pvKey);

// Compare two keys for equality; e.g., _stricmp, memcmp, operator==
typedef bool        (*PFnEqualKeys)   (const void* pvKey1, const void* pvKey2);

// Increment the reference count of a record before returning it from
// FindKey.  It's necessary to do it in FindKey itself while the bucket
// is still locked, rather than one of the wrappers, to avoid race
// conditions.  Similarly, the reference count is incremented in
// InsertRecord and decremented in DeleteKey.  Finally, if an old record
// is overwritten in InsertRecord, its reference count is decremented.
//
// It's up to you to decrement the reference count when you're finished
// with it after retrieving it via FindKey and to determine the
// semantics of what this means.  The hashtable itself has no notion of
// reference counts; this is merely to help with the lifetime management
// of the record objects.
typedef void        (*PFnAddRefRecord)(const void* pvRecord, int nIncr);

// ApplyIf() and DeleteIf(): Does the record match the predicate?
typedef LK_PREDICATE (*PFnRecordPred) (const void* pvRecord, void* pvState);

// Apply() et al: Perform action on record.
typedef LK_ACTION   (*PFnRecordAction)(const void* pvRecord, void* pvState);



//--------------------------------------------------------------------
// Custom memory allocators
//--------------------------------------------------------------------


// #define LKHASH_ACACHE 1
// #define LKHASH_MANODEL 1
// #define LKHASH_MADEL 1

// #define LKHASH_MEM_DEFAULT_ALIGN 32

#ifndef LKHASH_MEM_DEFAULT_ALIGN
# define LKHASH_MEM_DEFAULT_ALIGN 8
#endif

#if defined(LKHASH_ACACHE)

# include <acache.hxx>

  typedef ALLOC_CACHE_HANDLER  CAllocator;
# define LKHASH_ALLOCATOR_NEW(C, N)                             \
    const ALLOC_CACHE_CONFIGURATION acc = { 1, N, sizeof(C) };  \
    C::sm_palloc = new ALLOC_CACHE_HANDLER("IISRTL:" #C, &acc);

#elif defined(LKHASH_MANODEL)

# include <manodel.hxx>
  typedef MEMORY_ALLOC_NO_DELETE  CAllocator;
# define LKHASH_ALLOCATOR_NEW(C, N)                             \
    C::sm_palloc = new MEMORY_ALLOC_NO_DELETE(sizeof(C),        \
                                              LKHASH_MEM_DEFAULT_ALIGN);

#elif defined(LKHASH_MADEL)

# include <madel.hxx>
  typedef MEMORY_ALLOC_DELETE  CAllocator;
# define LKHASH_ALLOCATOR_NEW(C, N)                             \
    C::sm_palloc = new MEMORY_ALLOC_DELETE(sizeof(C),           \
                                           LKHASH_MEM_DEFAULT_ALIGN, N);

#else // no custom allocator

# undef LKHASH_ALLOCATOR_NEW

#endif // no custom allocator



// Used to initialize and destroy custom allocators
bool LKHashTableInit();
void LKHashTableUninit();


#ifdef LKHASH_ALLOCATOR_NEW

// placed inline in the declaration of class C
# define LKHASH_ALLOCATOR_DEFINITIONS(C)                        \
    protected:                                                  \
        static CAllocator* sm_palloc;                           \
        friend bool LKHashTableInit();                          \
        friend void LKHashTableUninit();                        \
    public:                                                     \
        static void*  operator new(size_t s)                    \
        {                                                       \
          IRTLASSERT(s == sizeof(C));                           \
          IRTLASSERT(sm_palloc != NULL);                        \
          return sm_palloc->Alloc();                            \
        }                                                       \
        static void   operator delete(void* pv)                 \
        {                                                       \
          IRTLASSERT(pv != NULL);                               \
          if (sm_palloc != NULL)                                \
              sm_palloc->Free(pv);                              \
        }


// used in LKHashTableInit()
# define LKHASH_ALLOCATOR_INIT(C, N, f)                         \
    {                                                           \
        if (f)                                                  \
        {                                                       \
            IRTLASSERT(C::sm_palloc == NULL);                   \
            LKHASH_ALLOCATOR_NEW(C, N);                         \
            f = (C::sm_palloc != NULL);                         \
        }                                                       \
    }


// used in LKHashTableUninit()
# define LKHASH_ALLOCATOR_UNINIT(C)                             \
    {                                                           \
        if (C::sm_palloc != NULL)                               \
        {                                                       \
            delete C::sm_palloc;                                \
            C::sm_palloc = NULL;                                \
        }                                                       \
    }


#else // !LKHASH_ALLOCATOR_NEW

# define LKHASH_ALLOCATOR_DEFINITIONS(C)
# define LKHASH_ALLOCATOR_INIT(C, N, f)
# define LKHASH_ALLOCATOR_UNINIT(C)

#endif // !LKHASH_ALLOCATOR_NEW



//--------------------------------------------------------------------
// CLKLinearHashTable
//
// A thread-safe linear hash table.
//--------------------------------------------------------------------

class IRTL_DLLEXP CLKLinearHashTable
{
public:
    typedef CSpinLock TableLock;
    typedef CSpinLock BucketLock;

    class CIterator;
    friend class CLKLinearHashTable::CIterator;

private:
    friend class CLKHashTable;

#ifdef LKHASH_ALLOCATOR_NEW
    friend bool LKHashTableInit();
    friend void LKHashTableUninit();
#endif // LKHASH_ALLOCATOR_NEW

#ifdef LKHASH_INSTRUMENTATION
    // TODO
#endif // LKHASH_INSTRUMENTATION


    // Class for nodes on a bucket chain.  Instead of a node containing
    // one (signature, record-pointer, next-tuple-pointer) tuple, it
    // contains _N_ such tuples.  (N-1 next-tuple-pointers are omitted.)
    // This improves locality of reference greatly; i.e., it's L1
    // cache-friendly.  It also reduces memory fragmentation and memory
    // allocator overhead.  It does complicate the chain traversal code
    // slightly, admittedly.
    //
    // This theory is beautiful.  In practice, however, CNodeClumps
    // are *not* perfectly aligned on 32-byte boundaries by the memory
    // allocators.  Experimental results indicate that we get a 2-3%
    // speed improvement by using 32-byte-aligned blocks, but this must
    // be considered against the average of 16 bytes wasted per block.

    class CNodeClump
    {
    public:
        // Record slots per chunk - set so a chunk matches (one or
        // two) cache lines.  2 ==> 28 bytes, 6 ==> 60 bytes
        // Note: the default max load factor is 4.0, which implies that
        // there will seldom be more than one node clump in a chain.
        enum {
            BUCKET_BYTE_SIZE = 64,
            BUCKET_OVERHEAD  = sizeof(BucketLock) + sizeof(CNodeClump*),
            NODE_SIZE        = sizeof(const void*) + sizeof(DWORD),
            NODES_PER_CLUMP  = (BUCKET_BYTE_SIZE - BUCKET_OVERHEAD) / NODE_SIZE
        };

        DWORD  m_dwKeySigs[NODES_PER_CLUMP]; // hash values computed from keys
        CNodeClump* m_pncNext;               // next node clump on the chain
        const void* m_pvNode[NODES_PER_CLUMP];// pointers to records

        CNodeClump()
        {
            Clear();
        }

        void Clear()
        { memset(this, 0, sizeof(*this)); }

#ifdef LKRDEBUG
        // Don't want overhead of calls to dtor in retail build
        ~CNodeClump()
        {
            IRTLASSERT(m_pncNext == NULL);  // no dangling pointers
            for (DWORD i = 0;  i < NODES_PER_CLUMP;  ++i)
                IRTLASSERT(m_dwKeySigs[i] == 0  &&  m_pvNode[i] == NULL);
        }
#endif // LKRDEBUG

        LKHASH_ALLOCATOR_DEFINITIONS(CNodeClump);
    };


    // Class for bucket chains of the hash table.  Note that the first
    // nodeclump is actually included in the bucket and not dynamically
    // allocated, which increases space requirements slightly but does
    // improve performance.
    class CBucket
    {
        mutable BucketLock m_Lock;       // lock protecting this bucket

#ifdef LOCK_INSTRUMENTATION
        static LONG sm_cBuckets;

        static const char*
        _LockName()
        {
            LONG l = ++sm_cBuckets;
            // possible race condition but we don't care, as this is never
            // used in production code
            static char s_szName[CLockStatistics::L_NAMELEN];
            wsprintf(s_szName, "B%06x", 0xFFFFFF & l);
            return s_szName;
        }
#endif // LOCK_INSTRUMENTATION

    public:
        CNodeClump    m_ncFirst;    // first CNodeClump of this bucket

#if defined(LOCK_INSTRUMENTATION) || defined(LKRDEBUG)
        CBucket()
#ifdef LOCK_INSTRUMENTATION
            : m_Lock(_LockName())
#endif // LOCK_INSTRUMENTATION
        {
#ifdef LKRDEBUG
            LOCK_LOCKTYPE lt = BucketLock::LockType();
            if (lt == LOCK_SPINLOCK  ||  lt == LOCK_FAKELOCK)
                IRTLASSERT(sizeof(*this) <= 64);
#endif LKRDEBUG
        }
#endif // LOCK_INSTRUMENTATION || LKRDEBUG

        void  WriteLock()           { m_Lock.WriteLock(); }
        void  ReadLock() const      { m_Lock.ReadLock(); }
        void  WriteUnlock() const   { m_Lock.WriteUnlock();   }
        void  ReadUnlock() const    { m_Lock.ReadUnlock();   }
        bool  IsWriteLocked() const { return m_Lock.IsWriteLocked(); }
        bool  IsReadLocked() const  { return m_Lock.IsReadLocked(); }
        bool  IsWriteUnlocked() const { return m_Lock.IsWriteUnlocked(); }
        bool  IsReadUnlocked() const  { return m_Lock.IsReadUnlocked(); }
        void  SetSpinCount(WORD wSpins) { m_Lock.SetSpinCount(wSpins); }
        WORD  GetSpinCount() const  { return m_Lock.GetSpinCount(); }
#ifdef LOCK_INSTRUMENTATION
        CLockStatistics LockStats() const {return m_Lock.Statistics();}
#endif // LOCK_INSTRUMENTATION
    };


    // The hash table space is divided into fixed-size segments (arrays of
    // CBuckets) and physically grows/shrinks one segment at a time.

    // We provide small, medium, and large segments to better tune the
    // overall memory requirements of the hash table according to the
    // expected usage of an instance.

    class CSegment
    {
    public:
        virtual ~CSegment() {}; // link fails if this is pure virtual
        virtual DWORD Bits() const = 0;
        virtual DWORD Size() const = 0;
        virtual DWORD Mask() const = 0;
        virtual DWORD InitSize() const = 0;
        virtual CBucket& Slot(DWORD i) = 0;
    };


    // Small-sized segments contain 2^3 = 8 buckets => ~0.5Kb
    class CSmallSegment : public CSegment
    {
    public:
        // Maximum table size equals MAX_DIRSIZE * SEGSIZE buckets.
        enum {
            SEGBITS  =            3,// number of bits extracted from a hash
                                    // address for offset within a segment
            SEGSIZE  = (1<<SEGBITS),// segment size
            SEGMASK  = (SEGSIZE-1), // mask used for extracting offset bit
            INITSIZE = 1 * SEGSIZE, // #segments to allocate initially
        };

    private:
        CBucket m_bktSlots[SEGSIZE];

    public:
        virtual ~CSmallSegment()        {}
        virtual DWORD Bits() const      { return SEGBITS; }
        virtual DWORD Size() const      { return SEGSIZE; }
        virtual DWORD Mask() const      { return SEGMASK; }
        virtual DWORD InitSize() const  { return INITSIZE;}
        virtual CBucket& Slot(DWORD i)
        { IRTLASSERT(i < SEGSIZE); return m_bktSlots[i]; }

#ifdef LKRDEBUG
        CSmallSegment()
        {
            // IRTLASSERT(((ULONG_PTR) this & (LKHASH_MEM_DEFAULT_ALIGN-1)) == 0);
            IRTLASSERT(sizeof(*this) == SEGSIZE * sizeof(CBucket) + sizeof(void*));
        }
#endif // LKRDEBUG

        LKHASH_ALLOCATOR_DEFINITIONS(CSmallSegment);
    };


    // Medium-sized segments contain 2^6 = 64 buckets => ~4Kb
    class CMediumSegment : public CSegment
    {
    public:
        enum {
            SEGBITS  =            6,
            SEGSIZE  = (1<<SEGBITS),
            SEGMASK  = (SEGSIZE-1),
            INITSIZE = 2 * SEGSIZE,
        };

    private:
        CBucket m_bktSlots[SEGSIZE];

    public:
        virtual ~CMediumSegment()       {}
        virtual DWORD Bits() const      { return SEGBITS; }
        virtual DWORD Size() const      { return SEGSIZE; }
        virtual DWORD Mask() const      { return SEGMASK; }
        virtual DWORD InitSize() const  { return INITSIZE;}
        virtual CBucket& Slot(DWORD i)
        { IRTLASSERT(i < SEGSIZE); return m_bktSlots[i]; }

#ifdef LKRDEBUG
        CMediumSegment()
        {
            // IRTLASSERT(((ULONG_PTR) this & (LKHASH_MEM_DEFAULT_ALIGN-1)) == 0);
            IRTLASSERT(sizeof(*this) == SEGSIZE * sizeof(CBucket) + sizeof(void*));
        }
#endif // LKRDEBUG

        LKHASH_ALLOCATOR_DEFINITIONS(CMediumSegment);
    };

    // Large-sized segments contain 2^9 = 512 buckets => ~32Kb
    class CLargeSegment : public CSegment
    {
    public:
        enum {
            SEGBITS  =            9,
            SEGSIZE  = (1<<SEGBITS),
            SEGMASK  = (SEGSIZE-1),
            INITSIZE = 4 * SEGSIZE,
        };

    private:
        CBucket m_bktSlots[SEGSIZE];

    public:
        virtual ~CLargeSegment()        {}
        virtual DWORD Bits() const      { return SEGBITS; }
        virtual DWORD Size() const      { return SEGSIZE; }
        virtual DWORD Mask() const      { return SEGMASK; }
        virtual DWORD InitSize() const  { return INITSIZE;}
        virtual CBucket& Slot(DWORD i)
        { IRTLASSERT(i < SEGSIZE); return m_bktSlots[i]; }


#ifdef LKRDEBUG
        CLargeSegment()
        {
            // IRTLASSERT(((ULONG_PTR) this & (LKHASH_MEM_DEFAULT_ALIGN-1)) == 0);
            IRTLASSERT(sizeof(*this) == SEGSIZE * sizeof(CBucket) + sizeof(void*));
        }
#endif // LKRDEBUG

        LKHASH_ALLOCATOR_DEFINITIONS(CLargeSegment);
    };


    // A directory keeps track of the segments comprising the hash table.
    // The directory is just a variable-sized array of pointers to
    // segments (CDirEntrys).
    class CDirEntry
    {
    public:
        // MIN_DIRSIZE and MAX_DIRSIZE can be changed independently
        // of anything else.  Should be powers of two.
        enum {
            MIN_DIRSIZE =  (1<<3),   // minimum directory size
            MAX_DIRSIZE = (1<<16),   // maximum directory size
        };

        CSegment* m_pseg;

        CDirEntry()
            : m_pseg(NULL)
        {}

        ~CDirEntry()
        { delete m_pseg; }
    };

public:

    // aliases for convenience
    enum {
        NODES_PER_CLUMP = CNodeClump::NODES_PER_CLUMP,
        MIN_DIRSIZE     = CDirEntry::MIN_DIRSIZE,
        MAX_DIRSIZE     = CDirEntry::MAX_DIRSIZE,
        NAME_SIZE       = 16,
    };


private:

    // Miscellaneous helper functions

    // Convert a hash signature to a bucket address
    DWORD        _BucketAddress(DWORD dwSignature) const
    {
        DWORD dwBktAddr = _H0(dwSignature);
        // Has this bucket been split already?
        if (dwBktAddr < m_iExpansionIdx)
            dwBktAddr = _H1(dwSignature);
        IRTLASSERT(dwBktAddr < m_cActiveBuckets);
        IRTLASSERT(dwBktAddr < (m_cDirSegs << m_dwSegBits));
        return dwBktAddr;
    }

    // See the Linear Hashing paper
    DWORD        _H0(DWORD dwSignature) const
    { return dwSignature & m_dwBktAddrMask; }

    // See the Linear Hashing paper.  Preserves one bit more than _H0.
    DWORD        _H1(DWORD dwSignature) const
    { return dwSignature & ((m_dwBktAddrMask << 1) | 1); }

    // In which segment within the directory does the bucketaddress lie?
    // (Return type must be lvalue so that it can be assigned to.)
    CSegment*&   _Segment(DWORD dwBucketAddr) const
    {
        const DWORD iSeg = dwBucketAddr >> m_dwSegBits;
        IRTLASSERT(m_paDirSegs != NULL  &&  iSeg < m_cDirSegs);
        return m_paDirSegs[iSeg].m_pseg;
    }

    // Offset within the segment of the bucketaddress
    DWORD        _SegIndex(DWORD dwBucketAddr) const
    { return (dwBucketAddr & m_dwSegMask); }

    // Convert a bucketaddress to a CBucket*
    CBucket*     _Bucket(DWORD dwBucketAddr) const
    {
        IRTLASSERT(dwBucketAddr < m_cActiveBuckets);
        CSegment* const pseg = _Segment(dwBucketAddr);
        IRTLASSERT(pseg != NULL);
        return &(pseg->Slot(_SegIndex(dwBucketAddr)));
    }

    // Extract the key from a record
    const void*  _ExtractKey(const void* pvRecord) const
    {
        IRTLASSERT(pvRecord != NULL);
        IRTLASSERT(m_pfnExtractKey != NULL);
        return (pvRecord != NULL) ? (*m_pfnExtractKey)(pvRecord) : NULL;
    }

    // Hash a key
    DWORD        _CalcKeyHash(const void* pvKey) const
    {
        // Note pvKey==0 is acceptable, as the real key type could be an int
        IRTLASSERT(m_pfnCalcKeyHash != NULL);
        DWORD dwHash = (*m_pfnCalcKeyHash)(pvKey);
        // We forcibly scramble the result to help ensure a better distribution
        return HashScramble(dwHash);
    }

    // Compare two keys for equality
    bool         _EqualKeys(const void* pvKey1, const void* pvKey2) const
    {
        IRTLASSERT(m_pfnEqualKeys != NULL);
        return (*m_pfnEqualKeys)(pvKey1, pvKey2);
    }

    // AddRef or Release a record.
    void         _AddRefRecord(const void* pvRecord, int nIncr) const
    {
        IRTLASSERT(pvRecord != NULL  &&  (nIncr == -1  ||  nIncr == +1));
        if (m_pfnAddRefRecord != NULL  &&  pvRecord != NULL)
            (*m_pfnAddRefRecord)(pvRecord, nIncr);
    }

    // We won't expose the locking mechanism.  If a wrapper class needs to
    // expose a global lock (not recommended), it can provide its own lock.

    // Lock the table (exclusively) for writing
    void         _WriteLock()
    { m_Lock.WriteLock(); }

    // Lock the table (possibly shared) for reading
    void         _ReadLock() const
    { m_Lock.ReadLock(); }

    // Unlock the table for writing
    void         _WriteUnlock() const
    { m_Lock.WriteUnlock(); }

    // Unlock the table for reading
    void         _ReadUnlock() const
    { m_Lock.ReadUnlock(); }

    // Is the table already locked for writing?
    bool _IsWriteLocked() const
    { return m_Lock.IsWriteLocked(); }

    // Is the table already locked for reading?
    bool _IsReadLocked() const
    { return m_Lock.IsReadLocked(); }

    // Is the table unlocked for writing?
    bool _IsWriteUnlocked() const
    { return m_Lock.IsWriteUnlocked(); }

    // Is the table unlocked for reading?
    bool _IsReadUnlocked() const
    { return m_Lock.IsReadUnlocked(); }

    // Set the spin count on the table lock
    void _SetSpinCount(WORD wSpins)
    { m_Lock.SetSpinCount(wSpins); }

    // Get the spin count on the table lock
    WORD _GetSpinCount() const
    { return m_Lock.GetSpinCount(); }

#ifdef LOCK_INSTRUMENTATION
    static LONG sm_cTables;

    static const char*
    _LockName()
    {
        LONG l = ++sm_cTables;
        // possible race condition but we don't care, as this is never
        // used in production code
        static char s_szName[CLockStatistics::L_NAMELEN];
        wsprintf(s_szName, "LH%05x", 0xFFFFF & l);
        return s_szName;
    }

    // Statistics for the table lock
    CLockStatistics _LockStats() const
    { return m_Lock.Statistics(); }
#endif // LOCK_INSTRUMENTATION

private:

    // Fields are ordered so as to minimize number of cache lines touched

    DWORD         m_dwSignature;    // debugging: id & corruption check
    mutable TableLock m_Lock;       // Lock on entire linear hash table
    DWORD         m_dwBktAddrMask;  // mask used for address calculation
    DWORD         m_iExpansionIdx;  // address of next bucket to be expanded
    CDirEntry*    m_paDirSegs;      // directory of table segments

    // State variables
    LK_TABLESIZE  m_lkts;           // "size" of table: small, medium, or large
    DWORD         m_dwSegBits;      // C{Small,Medium,Large}Segment::SEGBITS
    DWORD         m_dwSegSize;      // C{Small,Medium,Large}Segment::SEGSIZE
    DWORD         m_dwSegMask;      // C{Small,Medium,Large}Segment::SEGMASK
    LK_RETCODE    m_lkrcState;      // Internal state of table
    double        m_MaxLoad;        // max load factor (average chain length)
    DWORD         m_nLevel;         // number of table doublings performed
    DWORD         m_cDirSegs;       // segment directory size: varies between
                                    // MIN_DIRSIZE and MAX_DIRSIZE
    DWORD         m_cRecords;       // number of records in the table
    DWORD         m_cActiveBuckets; // number of buckets in use (table size)
    WORD          m_wBucketLockSpins;// default spin count for bucket locks

    // type-specific function pointers
    PFnExtractKey   m_pfnExtractKey;    // Extract key from record
    PFnCalcKeyHash  m_pfnCalcKeyHash;   // Calculate hash signature of key
    PFnEqualKeys    m_pfnEqualKeys;     // Compare two keys
    PFnAddRefRecord m_pfnAddRefRecord;  // AddRef a record

    CHAR          m_szName[NAME_SIZE];  // an identifier for debugging

    // Non-trivial implementation functions
    LK_RETCODE   _InsertRecord(const void* pvRecord, DWORD dwSignature,
                               bool fOverwrite);
    LK_RETCODE   _DeleteKey(const void* pvKey, DWORD dwSignature);
    LK_RETCODE   _DeleteRecord(const void* pvRecord, DWORD dwSignature);
    bool         _DeleteNode(CBucket* pbkt, CNodeClump*& rpnc,
                             CNodeClump*& rpncPrev, DWORD& riNode);
    LK_RETCODE   _FindKey(const void* pvKey, DWORD dwSignature,
                          const void** ppvRecord) const;
    LK_RETCODE   _FindRecord(const void* pvRecord, DWORD dwSignature) const;

    // Predicate functions
    static LK_PREDICATE _PredTrue(const void* /*pvRecord*/, void* /*pvState*/)
    { return LKP_PERFORM; }

    DWORD        _Apply(PFnRecordAction pfnAction, void* pvState,
                        LK_LOCKTYPE lkl, LK_PREDICATE& rlkp);
    DWORD        _ApplyIf(PFnRecordPred   pfnPredicate,
                          PFnRecordAction pfnAction, void* pvState,
                          LK_LOCKTYPE lkl, LK_PREDICATE& rlkp);
    DWORD        _DeleteIf(PFnRecordPred pfnPredicate, void* pvState,
                           LK_PREDICATE& rlkp);
    void         _Clear(bool fShrinkDirectory);


    void         _SetSegVars(LK_TABLESIZE lkts);
    CSegment*    _NewSeg() const;
    CBucket*     _FindBucket(DWORD dwSignature, bool fLockForWrite) const;
    LK_RETCODE   _Expand();
    LK_RETCODE   _Contract();
    LK_RETCODE   _SplitRecordSet(CNodeClump* pncOldTarget,
                                 CNodeClump* pncNewTarget,
                                 DWORD       iExpansionIdx,
                                 DWORD       dwNewBkt);
    LK_RETCODE   _MergeRecordSets(CBucket*    pbktNewTarget,
                                  CNodeClump* pncOldList);

    // Private copy ctor and op= to prevent compiler synthesizing them.
    // Must provide a (bad) implementation because we export instantiations.
    // TODO: implement these properly; they could be useful.
    CLKLinearHashTable(const CLKLinearHashTable&)
#ifdef LOCK_INSTRUMENTATION
        : m_Lock(NULL)
#endif // LOCK_INSTRUMENTATION
    {*(BYTE*)NULL;}

    CLKLinearHashTable& operator=(const CLKLinearHashTable&)
    {return *(CLKLinearHashTable*)NULL;}

public:
    CLKLinearHashTable(
        LPCSTR   pszName,               // An identifier for debugging
        PFnExtractKey   pfnExtractKey,  // Extract key from record
        PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
        PFnEqualKeys    pfnEqualKeys,   // Compare two keys
        PFnAddRefRecord pfnAddRefRecord=NULL,   // AddRef in FindKey, etc
        double   maxload=LK_DFLT_MAXLOAD, // Upperbound on average chain length
        DWORD    initsize=LK_DFLT_INITSIZE, // Initial size of hash table.
        DWORD    num_subtbls=LK_DFLT_NUM_SUBTBLS  // for signature compatiblity
                                                  // with CLKHashTable
        );

    ~CLKLinearHashTable();

    static const char* ClassName()           {return "CLKLinearHashTable";}
    int                NumSubTables() const  {return 1;}

    static LK_TABLESIZE NumSubTables(DWORD& rinitsize, DWORD& rnum_subtbls);

    // Insert a new record into hash table.
    // Returns LK_SUCCESS if all OK, LK_KEY_EXISTS if same key already
    // exists (unless fOverwrite), LK_ALLOC_FAIL if out of space,
    // or LK_BAD_RECORD for a bad record.
    LK_RETCODE     InsertRecord(const void* pvRecord, bool fOverwrite=false)
    { return _InsertRecord(pvRecord, _CalcKeyHash(_ExtractKey(pvRecord)),
                           fOverwrite);
    }

    // Delete record with the given key.
    // Returns LK_SUCCESS if all OK, or LK_NO_SUCH_KEY if not found
    LK_RETCODE     DeleteKey(const void* pvKey)
    { return _DeleteKey(pvKey, _CalcKeyHash(pvKey)); }

    // Delete a record from the table, if present.
    // Returns LK_SUCCESS if all OK, or LK_NO_SUCH_KEY if not found
    LK_RETCODE     DeleteRecord(const void* pvRecord)
    { return _DeleteRecord(pvRecord, _CalcKeyHash(_ExtractKey(pvRecord))); }

    // Find record with given key.
    // Returns:  LK_SUCCESS, if record found (record is returned in *ppvRecord)
    //           LK_BAD_RECORD, if ppvRecord is invalid
    //           LK_NO_SUCH_KEY, if no record with given key value was found
    //           LK_UNUSABLE, if hash table not in usable state
    // Note: the record is AddRef'd.  You must decrement the reference
    // count when you are finished with the record (if you're implementing
    // refcounting semantics).
    LK_RETCODE     FindKey(const void* pvKey,
                           const void** ppvRecord) const
    { return _FindKey(pvKey, _CalcKeyHash(pvKey), ppvRecord); }

    // Sees if the record is contained in the table
    // Returns:  LK_SUCCESS, if record found
    //           LK_BAD_RECORD, if pvRecord is invalid
    //           LK_NO_SUCH_KEY, if record is not in the table
    //           LK_UNUSABLE, if hash table not in usable state
    // Note: the record is *not* AddRef'd.
    LK_RETCODE     FindRecord(const void* pvRecord) const
    { return _FindRecord(pvRecord, _CalcKeyHash(_ExtractKey(pvRecord))); }

    // Walk the hash table, applying pfnAction to all records.
    // Locks the whole table for the duration with either a (possibly
    // shared) readlock or a writelock, according to lkl.
    // Loop is aborted if pfnAction returns LKA_ABORT.
    // Returns the number of successful applications.
    DWORD          Apply(PFnRecordAction pfnAction,
                         void*           pvState=NULL,
                         LK_LOCKTYPE     lkl=LKL_READLOCK);

    // Walk the hash table, applying pfnAction to any records that match
    // pfnPredicate.  Locks the whole table for the duration with either
    // a (possibly shared) readlock or a writelock, according to lkl.
    // Loop is aborted if pfnAction returns LKA_ABORT.
    // Returns the number of successful applications.
    DWORD          ApplyIf(PFnRecordPred   pfnPredicate,
                           PFnRecordAction pfnAction,
                           void*           pvState=NULL,
                           LK_LOCKTYPE     lkl=LKL_READLOCK);

    // Delete any records that match pfnPredicate.
    // Locks the table for the duration with a writelock.
    // Returns the number of deletions.
    //
    // Do *not* walk the hash table by hand with an iterator and call
    // DeleteKey.  The iterator will end up pointing to garbage.
    DWORD          DeleteIf(PFnRecordPred pfnPredicate,
                            void*         pvState=NULL);

    // Check table for consistency.  Returns 0 if okay, or the number of
    // errors otherwise.
    int            CheckTable() const;

    // Prints the table (to where??)
    void           Print() const;

    // Remove all data from the table
    void           Clear()
    {
        _WriteLock();
        _Clear(true);
        _WriteUnlock();
    }

    // Number of elements in the table
    DWORD          Size() const
    { return m_cRecords; }

    // Maximum possible number of elements in the table
    DWORD          MaxSize() const
    { return static_cast<DWORD>(m_MaxLoad * MAX_DIRSIZE * m_dwSegSize); }

    // Get hash table statistics
    CLKHashTableStats GetStatistics() const;

    // Is the hash table consistent and correct?
    bool           IsValid() const
    {
        return (m_lkrcState == LK_SUCCESS     // serious internal failure?
                &&  m_paDirSegs != NULL
                &&  (MIN_DIRSIZE & (MIN_DIRSIZE-1)) == 0  // == (1 << N)
                &&  (MAX_DIRSIZE & (MAX_DIRSIZE-1)) == 0
                &&  MAX_DIRSIZE > MIN_DIRSIZE
                &&  MIN_DIRSIZE <= m_cDirSegs  &&  m_cDirSegs <= MAX_DIRSIZE
                &&  (m_cDirSegs & (m_cDirSegs-1)) == 0
                &&  m_pfnExtractKey != NULL
                &&  m_pfnCalcKeyHash != NULL
                &&  m_pfnEqualKeys != NULL
                &&  m_cActiveBuckets > 0
                &&  ValidSignature()
                );
    }

    void        SetTableLockSpinCount(WORD wSpins)
    { _SetSpinCount(wSpins); }

    WORD        GetTableLockSpinCount()
    { return _GetSpinCount(); }

    void        SetBucketLockSpinCount(WORD wSpins);
    WORD        GetBucketLockSpinCount();

    enum {
        SIGNATURE =      (('L') | ('K' << 8) | ('L' << 16) | ('H' << 24)),
        SIGNATURE_FREE = (('L') | ('K' << 8) | ('L' << 16) | ('x' << 24)),
    };

    bool
    ValidSignature() const
    { return m_dwSignature == SIGNATURE;}

    // LKHASH_ALLOCATOR_DEFINITIONS(CLKLinearHashTable);

public:

    // Iterators can be used to walk the table.  To ensure a consistent
    // view of the data, the iterator locks the whole table.  This can
    // have a negative effect upon performance, because no other thread
    // can do anything with the table.  Use with care.
    //
    // You should not use an iterator to walk the table, calling DeleteKey,
    // as the iterator will end up pointing to garbage.
    //
    // Use Apply, ApplyIf, or DeleteIf instead of iterators to safely
    // walk the tree.
    //
    // Note that iterators acquire a reference to the record pointed to
    // and release that reference as soon as the iterator is incremented.
    // In other words, this code is safe:
    //     lkrc = ht.IncrementIterator(&iter);
    //     // assume lkrc == LK_SUCCESS for the sake of this example
    //     CMyHashTable::Record* pRec = iter.Record();
    //     Foo(pRec);  // uses pRec but doesn't hang on to it
    //     lkrc = ht.IncrementIterator(&iter);
    //
    // But this code is not because pRec is used out of the scope of the
    // iterator that provided it:
    //     lkrc = ht.IncrementIterator(&iter);
    //     CMyHashTable::Record* pRec = iter.Record();
    //     // BUGBUG: Should call ht.AddRefRecord(pRec, +1) here
    //     lkrc = ht.IncrementIterator(&iter);
    //     Foo(pRec);
    //
    // If record has no reference-counting semantics, then you can ignore
    // the above remarks about scope.


    class CIterator
    {
    protected:
        friend class CLKLinearHashTable;

        CLKLinearHashTable*   m_plht;         // which linear hash table?
        DWORD               m_dwBucketAddr; // bucket index
        CNodeClump*         m_pnc;          // a CNodeClump in bucket
        int                 m_iNode;        // offset within m_pnc
        LK_LOCKTYPE         m_lkl;          // readlock or writelock?

    private:
        // Private copy ctor and op= to prevent compiler synthesizing them.
        // Must provide (bad) implementation because we export instantiations.
        CIterator(const CIterator&)             {*(BYTE*)NULL;}
        CIterator& operator=(const CIterator&)  {return *(CIterator*)NULL;}

    public:
        CIterator(
            LK_LOCKTYPE lkl=LKL_WRITELOCK)
            : m_plht(NULL),
              m_dwBucketAddr(0),
              m_pnc(NULL),
              m_iNode(-1),
              m_lkl(lkl)
        {}

        // Return the record associated with this iterator
        const void* Record() const
        {
            IRTLASSERT(IsValid());

            return ((m_pnc != NULL
                        &&  m_iNode >= 0  &&  m_iNode < CLKLinearHashTable::NODES_PER_CLUMP)
                    ?  m_pnc->m_pvNode[m_iNode]
                    :  NULL);
        }

        // Return the key associated with this iterator
        const void* Key() const
        {
            IRTLASSERT(m_plht != NULL);
            const void* pRec = Record();
            return ((pRec != NULL  &&  m_plht != NULL)
                    ?  m_plht->_ExtractKey(pRec)
                    :  NULL);
        }

        bool IsValid() const
        {
            return ((m_plht != NULL)
                    &&  (m_pnc != NULL)
                    &&  (0 <= m_iNode  &&  m_iNode < CLKLinearHashTable::NODES_PER_CLUMP)
                    &&  (m_pnc->m_pvNode[m_iNode] != NULL));
        }

        // Delete the record that the iterator points to.  Does an implicit
        // IncrementIterator after deletion.
        LK_RETCODE     DeleteRecord();

        // Change the record that the iterator points to.  The new record
        // must have the same key as the old one.
        LK_RETCODE     ChangeRecord(const void* pNewRec);
    };

    // Const iterators for readonly access.  You must use these with
    // const CLKLinearHashTables.
    class CConstIterator : public CIterator
    {
    private:
        // Private, unimplemented copy ctor and op= to prevent
        // compiler synthesizing them.
        CConstIterator(const CConstIterator&);
        CConstIterator& operator=(const CConstIterator&);

    public:
        CConstIterator()
            : CIterator(LKL_READLOCK)
        {}
    };

private:
    // The public APIs lock the table.  The private ones, which are used
    // directly by CLKHashTable, don't.
    LK_RETCODE     _InitializeIterator(CIterator* piter);
    LK_RETCODE     _CloseIterator(CIterator* piter);

public:
    // Initialize the iterator to point to the first item in the hash table
    // Returns LK_SUCCESS, LK_NO_MORE_ELEMENTS, or LK_BAD_ITERATOR.
    LK_RETCODE     InitializeIterator(CIterator* piter)
    {
        IRTLASSERT(piter != NULL  &&  piter->m_plht == NULL);
        if (piter == NULL  ||  piter->m_plht != NULL)
            return LK_BAD_ITERATOR;

        if (piter->m_lkl == LKL_WRITELOCK)
            _WriteLock();
        else
            _ReadLock();

        return _InitializeIterator(piter);
    }

    // The const iterator version
    LK_RETCODE     InitializeIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_plht == NULL);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_plht != NULL
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        _ReadLock();
        return const_cast<CLKLinearHashTable*>(this)
                    ->_InitializeIterator(static_cast<CIterator*>(piter));
    }

    // Move the iterator on to the next item in the table.
    // Returns LK_SUCCESS, LK_NO_MORE_ELEMENTS, or LK_BAD_ITERATOR.
    LK_RETCODE     IncrementIterator(CIterator* piter);

    LK_RETCODE     IncrementIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_plht == this);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_plht != this
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        return const_cast<CLKLinearHashTable*>(this)
                    ->IncrementIterator(static_cast<CIterator*>(piter));
    }

    // Close the iterator.
    LK_RETCODE     CloseIterator(CIterator* piter)
    {
        IRTLASSERT(piter != NULL  &&  piter->m_plht == this);
        if (piter == NULL  ||  piter->m_plht != this)
            return LK_BAD_ITERATOR;
        _CloseIterator(piter);

        if (piter->m_lkl == LKL_WRITELOCK)
            _WriteUnlock();
        else
            _ReadUnlock();

        return LK_SUCCESS;
    };

    // Close the CConstIterator
    LK_RETCODE     CloseIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_plht == this);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_plht != this
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        const_cast<CLKLinearHashTable*>(this)
             ->_CloseIterator(static_cast<CIterator*>(piter));

        _ReadUnlock();
        return LK_SUCCESS;
    };
};



//--------------------------------------------------------------------
// CLKHashTable
//
// To improve concurrency, a hash table is divided into a number of
// (independent) subtables. Each subtable is a linear hash table. The
// number of subtables is defined when the table is created and remains
// fixed thereafter. Records are assigned to subtables based on their
// hashed key.
//
// For small or low-contention hashtables, you can bypass this
// thin wrapper and use CLKLinearHashTable directly.  The methods are
// documented in the declarations for CLKHashTable (above).
//--------------------------------------------------------------------

class IRTL_DLLEXP CLKHashTable
{
private:
    typedef CLKLinearHashTable SubTable;

public:
    typedef SubTable::TableLock  TableLock;
    typedef SubTable::BucketLock BucketLock;

    class CIterator;
    friend class CLKHashTable::CIterator;

private:
    enum {
        NAME_SIZE = SubTable::NAME_SIZE,
    };
    
    // Hash table parameters
    DWORD          m_dwSignature;   // debugging: id & corruption check
    DWORD          m_cSubTables;    // number of subtables
    SubTable**     m_palhtDir;      // array of subtables

    // type-specific function pointers
    PFnExtractKey  m_pfnExtractKey;
    PFnCalcKeyHash m_pfnCalcKeyHash;
    LK_RETCODE     m_lkrcState;     // Internal state of table

    CHAR          m_szName[NAME_SIZE];  // an identifier for debugging

    LKHASH_GLOBAL_LOCK_DECLARATIONS();

    // Private copy ctor and op= to prevent compiler synthesizing them.
    // Must provide a (bad) implementation because we export instantiations.
    // TODO: implement these properly; they could be useful.
    CLKHashTable(const CLKHashTable&)             {*(BYTE*)NULL;}
    CLKHashTable& operator=(const CLKHashTable&)  {return *(CLKHashTable*)NULL;}


    // Extract the key from the record
    const void*  _ExtractKey(const void* pvRecord) const
    {
        IRTLASSERT(pvRecord != NULL);
        IRTLASSERT(m_pfnExtractKey != NULL);
        return (*m_pfnExtractKey)(pvRecord);
    }

    // Hash the key
    DWORD        _CalcKeyHash(const void* pvKey) const
    {
        // Note pvKey==0 is acceptable, as the real key type could be an int
        IRTLASSERT(m_pfnCalcKeyHash != NULL);
        DWORD dwHash = (*m_pfnCalcKeyHash)(pvKey);
        // We forcibly scramble the result to help ensure a better distribution
        return HashScramble(dwHash);
    }

    // Use the key's hash signature to multiplex into a subtable
    SubTable*    _SubTable(DWORD dwSignature) const
    {
        IRTLASSERT(m_lkrcState == LK_SUCCESS
                   && m_palhtDir != NULL  &&  m_cSubTables > 0);
        if (m_lkrcState == LK_SUCCESS)
        {
            const DWORD PRIME = 1048583UL;  // used to scramble the hash sig
            DWORD       index = (dwSignature % PRIME) % m_cSubTables;
            return m_palhtDir[index];
        }
        else
            return NULL;
    }

    void         _WriteLock();
    void         _ReadLock() const;
    void         _WriteUnlock() const;
    void         _ReadUnlock() const;

public:
    CLKHashTable(
        LPCSTR   pszName,               // An identifier for debugging
        PFnExtractKey   pfnExtractKey,  // Extract key from record
        PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
        PFnEqualKeys    pfnEqualKeys,   // Compare two keys
        PFnAddRefRecord pfnAddRefRecord=NULL,   // AddRef in FindKey, etc
        double    maxload=LK_DFLT_MAXLOAD,      // bound on avg chain length
        DWORD     initsize=LK_DFLT_INITSIZE,    // Initial size of hash table.
        DWORD     num_subtbls=LK_DFLT_NUM_SUBTBLS  // #subordinate hash tables.
        );

    ~CLKHashTable();

    static const char* ClassName()           {return "CLKHashTable";}
    int                NumSubTables() const  {return m_cSubTables;}

    static LK_TABLESIZE NumSubTables(DWORD& rinitsize, DWORD& rnum_subtbls);

    // Thin wrappers for the corresponding methods in CLKLinearHashTable
    LK_RETCODE     InsertRecord(const void* pvRecord, bool fOverwrite=false)
    {
        LKHASH_GLOBAL_WRITE_LOCK();    // usu. no-op
        DWORD     hash_val  = _CalcKeyHash(_ExtractKey(pvRecord));
        SubTable* const pst = _SubTable(hash_val);
        LK_RETCODE lk       = (pst != NULL
                               ?  pst->_InsertRecord(pvRecord, hash_val,
                                                     fOverwrite)
                               :  LK_UNUSABLE);
        LKHASH_GLOBAL_WRITE_UNLOCK();    // usu. no-op
        return lk;
    }

    LK_RETCODE     DeleteKey(const void* pvKey)
    {
        LKHASH_GLOBAL_WRITE_LOCK();    // usu. no-op
        DWORD     hash_val  = _CalcKeyHash(pvKey);
        SubTable* const pst = _SubTable(hash_val);
        LK_RETCODE lk       = (pst != NULL
                               ?  pst->_DeleteKey(pvKey, hash_val)
                               :  LK_UNUSABLE);
        LKHASH_GLOBAL_WRITE_UNLOCK();    // usu. no-op
        return lk;
    }

    LK_RETCODE     DeleteRecord(const void* pvRecord)
    {
        LKHASH_GLOBAL_WRITE_LOCK();    // usu. no-op
        DWORD     hash_val  = _CalcKeyHash(_ExtractKey(pvRecord));
        SubTable* const pst = _SubTable(hash_val);
        LK_RETCODE lk       = (pst != NULL
                               ?  pst->_DeleteRecord(pvRecord, hash_val)
                               :  LK_UNUSABLE);
        LKHASH_GLOBAL_WRITE_UNLOCK();    // usu. no-op
        return lk;
    }

    LK_RETCODE     FindKey(const void* pvKey,
                           const void** ppvRecord) const
    {
        LKHASH_GLOBAL_READ_LOCK();    // usu. no-op
        DWORD     hash_val   = _CalcKeyHash(pvKey);
        SubTable* const pst  = _SubTable(hash_val);
        LK_RETCODE lkrc      = (pst != NULL
                                ?  pst->_FindKey(pvKey, hash_val, ppvRecord)
                                :  LK_UNUSABLE);
        LKHASH_GLOBAL_READ_UNLOCK();    // usu. no-op
        return lkrc;
    }

    LK_RETCODE     FindRecord(const void* pvRecord) const
    {
        LKHASH_GLOBAL_READ_LOCK();    // usu. no-op
        DWORD     hash_val   = _CalcKeyHash(_ExtractKey(pvRecord));
        SubTable* const pst  = _SubTable(hash_val);
        LK_RETCODE lkrc      = (pst != NULL
                                ?  pst->_FindRecord(pvRecord, hash_val)
                                :  LK_UNUSABLE);
        LKHASH_GLOBAL_READ_UNLOCK();    // usu. no-op
        return lkrc;
    }

    DWORD          Apply(PFnRecordAction pfnAction,
                         void*           pvState=NULL,
                         LK_LOCKTYPE     lkl=LKL_READLOCK);
    DWORD          ApplyIf(PFnRecordPred   pfnPredicate,
                           PFnRecordAction pfnAction,
                           void*           pvState=NULL,
                           LK_LOCKTYPE     lkl=LKL_READLOCK);
    DWORD          DeleteIf(PFnRecordPred pfnPredicate,
                            void*         pvState=NULL);
    void           Clear();

    int            CheckTable() const;
    void           Print() const;
    DWORD          Size() const;
    DWORD          MaxSize() const;
    CLKHashTableStats GetStatistics() const;
    bool           IsValid() const;

    void           SetTableLockSpinCount(WORD wSpins);
    WORD           GetTableLockSpinCount();
    void           SetBucketLockSpinCount(WORD wSpins);
    WORD           GetBucketLockSpinCount();

    enum {
        SIGNATURE =      (('L') | ('K' << 8) | ('H' << 16) | ('T' << 24)),
        SIGNATURE_FREE = (('L') | ('K' << 8) | ('H' << 16) | ('x' << 24)),
    };

    bool
    ValidSignature() const
    { return m_dwSignature == SIGNATURE;}

    // LKHASH_ALLOCATOR_DEFINITIONS(CLKHashTable);

public:
    typedef SubTable::CIterator CLHTIterator;

    class CIterator : public CLHTIterator
    {
    protected:
        friend class CLKHashTable;

        CLKHashTable*     m_pht;  // which hash table?
        int             m_ist;  // which subtable

    private:
        // Private copy ctor and op= to prevent compiler synthesizing them.
        // Must provide (bad) implementation because we export instantiations.
        CIterator(const CIterator&)             {*(BYTE*)NULL;}
        CIterator& operator=(const CIterator&)  {return *(CIterator*)NULL;}

    public:
        CIterator(
            LK_LOCKTYPE lkl=LKL_WRITELOCK)
            : CLHTIterator(lkl),
              m_pht(NULL),
              m_ist(-1)
        {}

        const void* Record() const
        {
            IRTLASSERT(IsValid());

            // This is a hack to work around a compiler bug.  Calling
            // CLHTIterator::Record calls this function recursively until
            // the stack overflows.
            const CLHTIterator* pBase = static_cast<const CLHTIterator*>(this);
            return pBase->Record();
        }

        const void* Key() const
        {
            IRTLASSERT(IsValid());
            const CLHTIterator* pBase = static_cast<const CLHTIterator*>(this);
            return pBase->Key();
        }

        bool IsValid() const
        {
            const CLHTIterator* pBase = static_cast<const CLHTIterator*>(this);
            return (m_pht != NULL  &&  m_ist >= 0  &&  pBase->IsValid());
        }
    };

    // Const iterators for readonly access
    class CConstIterator : public CIterator
    {
    private:
        // Private, unimplemented copy ctor and op= to prevent
        // compiler synthesizing them.
        CConstIterator(const CConstIterator&);
        CConstIterator& operator=(const CConstIterator&);

    public:
        CConstIterator()
            : CIterator(LKL_READLOCK)
        {}
    };


public:
    LK_RETCODE     InitializeIterator(CIterator* piter);
    LK_RETCODE     IncrementIterator(CIterator* piter);
    LK_RETCODE     CloseIterator(CIterator* piter);

    LK_RETCODE     InitializeIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_pht == NULL);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_pht != NULL
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        return const_cast<CLKHashTable*>(this)
                ->InitializeIterator(static_cast<CIterator*>(piter));
    }

    LK_RETCODE     IncrementIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_pht == this);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_pht != this
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        return const_cast<CLKHashTable*>(this)
                ->IncrementIterator(static_cast<CIterator*>(piter));
    }

    LK_RETCODE     CloseIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_pht == this);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_pht != this
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        return const_cast<CLKHashTable*>(this)
                ->CloseIterator(static_cast<CIterator*>(piter));
    }
};



//--------------------------------------------------------------------
// A typesafe wrapper for CLKHashTable (or CLKLinearHashTable).
//
// * _Derived must derive from CTypedHashTable and provide certain member
//   functions.  It's needed for various downcasting operations.  See
//   CStringTestHashTable and CNumberTestHashTable below.
// * _Record is the type of the record.  C{Linear}HashTable will store
//   pointers to _Record.
// * _Key is the type of the key.  _Key is used directly; i.e., it is
//   not assumed to be a pointer type.  C{Linear}HashTable assumes that
//   the key is stored in the associated record.  See the comments
//   at the declaration of PFnExtractKey for more details.
//
// (optional parameters):
// * _BaseHashTable is the base hash table: CLKHashTable or CLKLinearHashTable
// * _BaseIterator is the iterator type, _BaseHashTable::CIterator
//
// CTypedHashTable could derive directly from CLKLinearHashTable, if you
// don't need the extra overhead of CLKHashTable (which is quite low).
//
// You may need to add the following line to your code to disable
// warning messages about truncating extremly long identifiers.
//   #pragma warning (disable : 4786)
//--------------------------------------------------------------------

template < class _Derived, class _Record, class _Key,
           class _BaseHashTable=CLKHashTable,
           class _BaseIterator=_BaseHashTable::CIterator
         >
class CTypedHashTable : public _BaseHashTable
{
public:
    // convenient aliases
    typedef _Derived        Derived;
    typedef _Record         Record;
    typedef _Key            Key;
    typedef _BaseHashTable  BaseHashTable;
    typedef CTypedHashTable<_Derived, _Record, _Key,
                                 _BaseHashTable, _BaseIterator>
                            HashTable;
    typedef _BaseIterator   BaseIterator;

    // ApplyIf() and DeleteIf(): Does the record match the predicate?
    // Note: takes a Record*, not a const Record*.  You can modify the
    // record in Pred() or Action(), if you like, but if you do, you
    // should use LKL_WRITELOCK to lock the table.
    typedef LK_PREDICATE (*PFnRecordPred) (Record* pRec, void* pvState);

    // Apply() et al: Perform action on record.
    typedef LK_ACTION   (*PFnRecordAction)(Record* pRec, void* pvState);

private:

    // Wrappers for the typesafe methods exposed by the derived class

    static const void*
    _ExtractKey(const void* pvRecord)
    {
        const _Record* pRec = static_cast<const _Record*>(pvRecord);
        _Key           key  = static_cast<_Key>(_Derived::ExtractKey(pRec));
        return reinterpret_cast<const void*>(key);
    }

    static DWORD
    _CalcKeyHash(const void* pvKey)
    {
        _Key key = reinterpret_cast<_Key>(const_cast<void*>(pvKey));
        return _Derived::CalcKeyHash(key);
    }

    static bool
    _EqualKeys(const void* pvKey1, const void* pvKey2)
    {
        _Key key1 = reinterpret_cast<_Key>(const_cast<void*>(pvKey1));
        _Key key2 = reinterpret_cast<_Key>(const_cast<void*>(pvKey2));
        return _Derived::EqualKeys(key1, key2);
    }

    // Hmm? what's a good way of bypassing this and passing NULL
    // for pfnAddRefRecord to the C{Linear}HashTable ctor if the user
    // doesn't want this functionality?  Perhaps a template bool param?
    static void
    _AddRefRecord(const void* pvRecord, int nIncr)
    {
        _Record* pRec = static_cast<_Record*>(const_cast<void*>(pvRecord));
        _Derived::AddRefRecord(pRec, nIncr);
    }


    // Typesafe wrappers for Apply, ApplyIf, and DeleteIf.

    class CState
    {
    public:
        PFnRecordPred   m_pfnPred;
        PFnRecordAction m_pfnAction;
        void*           m_pvState;

        CState(
            PFnRecordPred   pfnPred,
            PFnRecordAction pfnAction,
            void*           pvState)
            : m_pfnPred(pfnPred), m_pfnAction(pfnAction), m_pvState(pvState)
        {}
    };

    static LK_PREDICATE
    _Pred(const void* pvRecord, void* pvState)
    {
        _Record* pRec = static_cast<_Record*>(const_cast<void*>(pvRecord));
        CState*  pState = static_cast<CState*>(pvState);

        return (*pState->m_pfnPred)(pRec, pState->m_pvState);
    }

    static LK_ACTION
    _Action(const void* pvRecord, void* pvState)
    {
        _Record* pRec = static_cast<_Record*>(const_cast<void*>(pvRecord));
        CState*  pState = static_cast<CState*>(pvState);

        return (*pState->m_pfnAction)(pRec, pState->m_pvState);
    }

public:
    CTypedHashTable(
        LPCSTR pszName,                       // An identifier for debugging
        double maxload=LK_DFLT_MAXLOAD,       // Upperbound on avg chain length
        DWORD  initsize=LK_DFLT_INITSIZE,     // Initial size of hash table.
        DWORD  num_subtbls=LK_DFLT_NUM_SUBTBLS// #subordinate hash tables.
        )
        : _BaseHashTable(pszName, _ExtractKey, _CalcKeyHash, _EqualKeys,
                            _AddRefRecord, maxload, initsize, num_subtbls)
    {}

    LK_RETCODE   InsertRecord(const _Record* pRec, bool fOverwrite=false)
    { return _BaseHashTable::InsertRecord(pRec, fOverwrite); }

    LK_RETCODE   DeleteKey(const _Key key)
    { return _BaseHashTable::DeleteKey(reinterpret_cast<const void*>(key));}

    LK_RETCODE   DeleteRecord(const _Record* pRec)
    { return _BaseHashTable::DeleteRecord(pRec);}

    // Note: returns a _Record**, not a const Record**.  Note that you
    // can use a const type for the template parameter to ensure constness.
    LK_RETCODE   FindKey(const _Key key, _Record** ppRec) const
    {
        if (ppRec == NULL)
            return LK_BAD_RECORD;
        *ppRec = NULL;
        const void* pvRec = NULL;
        LK_RETCODE lkrc =
           _BaseHashTable::FindKey(reinterpret_cast<const void*>(key), &pvRec);
        *ppRec = static_cast<_Record*>(const_cast<void*>(pvRec));
        return lkrc;
    }

    LK_RETCODE   FindRecord(const _Record* pRec) const
    { return _BaseHashTable::FindRecord(pRec);}


    // Other C{Linear}HashTable methods can be exposed without change
    // TODO: Print?


    // Typesafe wrappers for Apply et al

    DWORD        Apply(PFnRecordAction pfnAction,
                       void*           pvState=NULL,
                       LK_LOCKTYPE     lkl=LKL_READLOCK)
    {
        IRTLASSERT(pfnAction != NULL);
        if (pfnAction == NULL)
            return 0;

        CState   state(NULL, pfnAction, pvState);
        return   _BaseHashTable::Apply(_Action, &state, lkl);
    }

    DWORD        ApplyIf(PFnRecordPred   pfnPredicate,
                         PFnRecordAction pfnAction,
                         void*           pvState=NULL,
                         LK_LOCKTYPE     lkl=LKL_READLOCK)
    {
        IRTLASSERT(pfnPredicate != NULL  &&  pfnAction != NULL);
        if (pfnPredicate == NULL  ||  pfnAction == NULL)
            return 0;

        CState   state(pfnPredicate, pfnAction, pvState);
        return   _BaseHashTable::ApplyIf(_Pred, _Action, &state, lkl);
    }

    DWORD        DeleteIf(PFnRecordPred pfnPredicate, void* pvState=NULL)
    {
        IRTLASSERT(pfnPredicate != NULL);
        if (pfnPredicate == NULL)
            return 0;

        CState   state(pfnPredicate, NULL, pvState);
        return   _BaseHashTable::DeleteIf(_Pred, &state);
    }


    // Typesafe wrappers for iterators


    class CIterator : public _BaseIterator
    {
    private:
        // Private, unimplemented copy ctor and op= to prevent
        // compiler synthesizing them.
        CIterator(const CIterator&);
        CIterator& operator=(const CIterator&);

    public:
        CIterator(
            LK_LOCKTYPE lkl=LKL_WRITELOCK)
            : _BaseIterator(lkl)
        {}

        _Record*  Record() const
        {
            const _BaseIterator* pBase = static_cast<const _BaseIterator*>(this);
            return reinterpret_cast<_Record*>(const_cast<void*>(
                        pBase->Record()));
        }

        _Key      Key() const
        {
            const _BaseIterator* pBase = static_cast<const _BaseIterator*>(this);
            return reinterpret_cast<_Key>(const_cast<void*>(pBase->Key()));
        }
    };

    // readonly iterator
    class CConstIterator : public CIterator
    {
    private:
        // Private, unimplemented copy ctor and op= to prevent
        // compiler synthesizing them.
        CConstIterator(const CConstIterator&);
        CConstIterator& operator=(const CConstIterator&);

    public:
        CConstIterator()
            : CIterator(LKL_READLOCK)
        {}

        const _Record*  Record() const
        {
            return CIterator::Record();
        }

        const _Key      Key() const
        {
            return CIterator::Key();
        }
    };


public:
    LK_RETCODE     InitializeIterator(CIterator* piter)
    {
        return _BaseHashTable::InitializeIterator(piter);
    }

    LK_RETCODE     IncrementIterator(CIterator* piter)
    {
        return _BaseHashTable::IncrementIterator(piter);
    }

    LK_RETCODE     CloseIterator(CIterator* piter)
    {
        return _BaseHashTable::CloseIterator(piter);
    }

    LK_RETCODE     InitializeIterator(CConstIterator* piter) const
    {
        return const_cast<HashTable*>(this)
                ->InitializeIterator(static_cast<CIterator*>(piter));
    }

    LK_RETCODE     IncrementIterator(CConstIterator* piter) const
    {
        return const_cast<HashTable*>(this)
                ->IncrementIterator(static_cast<CIterator*>(piter));
    }

    LK_RETCODE     CloseIterator(CConstIterator* piter) const
    {
        return const_cast<HashTable*>(this)
                ->CloseIterator(static_cast<CIterator*>(piter));
    }
};



#ifdef __LKHASH_NAMESPACE__
}
#endif // __LKHASH_NAMESPACE__



#ifdef SAMPLE_LKHASH_TESTCLASS

#include <hashfn.h>

//--------------------------------------------------------------------
// An example of how to create a wrapper for CLKHashTable
//--------------------------------------------------------------------

// some random class

class CTest
{
public:
    enum {BUFFSIZE=20};

    int   m_n;                  // This will also be a key
    char  m_sz[BUFFSIZE];       // This will be the primary key
    bool  m_fWhatever;
    mutable LONG  m_cRefs;      // Reference count for lifetime management.
                                // Must be mutable to use 'const CTest*' in
                                // hashtables

    CTest(int n, const char* psz, bool f)
        : m_n(n), m_fWhatever(f), m_cRefs(0)
    {
        strncpy(m_sz, psz, BUFFSIZE-1);
        m_sz[BUFFSIZE-1] = '\0';
    }

    ~CTest()
    {
        IRTLASSERT(m_cRefs == 0);
    }
};



// A typed hash table of CTests, keyed on the string field.  Case-insensitive.

class CStringTestHashTable
    : public CTypedHashTable<CStringTestHashTable, const CTest, const char*>
{
public:
    CStringTestHashTable()
        : CTypedHashTable<CStringTestHashTable, const CTest,
                          const char*>("string")
    {}
    
    static const char*
    ExtractKey(const CTest* pTest)
    {
        return pTest->m_sz;
    }

    static DWORD
    CalcKeyHash(const char* pszKey)
    {
        return HashStringNoCase(pszKey);
    }

    static bool
    EqualKeys(const char* pszKey1, const char* pszKey2)
    {
        return _stricmp(pszKey1, pszKey2) == 0;
    }

    static void
    AddRefRecord(const CTest* pTest, int nIncr)
    {
        if (nIncr == +1)
        {
            // or, perhaps, pIFoo->AddRef() (watch out for marshalling)
            // or ++pTest->m_cRefs (single-threaded only)
            InterlockedIncrement(&pTest->m_cRefs);
        }
        else if (nIncr == -1)
        {
            // or, perhaps, pIFoo->Release() or --pTest->m_cRefs;
            LONG l = InterlockedDecrement(&pTest->m_cRefs);

            // For some hashtables, it may also make sense to add the following
            //      if (l == 0) delete pTest;
            // but that would typically only apply when InsertRecord was
            // used thus
            //      lkrc = ht.InsertRecord(new CTest(foo, bar));
        }
        else
            IRTLASSERT(0);

        TRACE("AddRef(%p, %s) %d, cRefs == %d\n",
              pTest, pTest->m_sz, nIncr, pTest->m_cRefs);
    }
};


// Another typed hash table of CTests.  This one is keyed on the numeric field.

class CNumberTestHashTable
    : public CTypedHashTable<CNumberTestHashTable, const CTest, int>
{
public:
    CNumberTestHashTable()
        : CTypedHashTable<CNumberTestHashTable, const CTest, int>("number") {}
    static int   ExtractKey(const CTest* pTest)        {return pTest->m_n;}
    static DWORD CalcKeyHash(int nKey)                 {return Hash(nKey);}
    static bool  EqualKeys(int nKey1, int nKey2)       {return nKey1 == nKey2;}
    static void  AddRefRecord(const CTest* pTest, int nIncr) {/* do nothing*/}
};


// A class to exercise ApplyIf()

class CApplyIfTest
{
public:
    static LK_PREDICATE
    Predicate(const CTest* pTest, void* pvState)
    {
        CApplyIfTest* pThis = static_cast<CApplyIfTest*>(pvState);
        ++pThis->m_cPreds;
        TRACE("CApplyIfTest::Predicate(%p (%s, %d), %p)\n",
              pTest, pTest->m_sz, pTest->m_n, pThis);
        return (pTest->m_n % 10 == 7)  ?  LKP_PERFORM  :   LKP_NO_ACTION;
    }

    static LK_ACTION
    Action(const CTest* pTest, void* pvState)
    {
        CApplyIfTest* pThis = static_cast<CApplyIfTest*>(pvState);
        ++pThis->m_cActions;
        LK_ACTION lka = (pTest->m_n > 30)  ?  LKA_SUCCEEDED  :  LKA_FAILED;

        TRACE("CApplyIfTest::Action(%p (%s, %d), %p) %s\n",
              pTest, pTest->m_sz, pTest->m_n, pThis,
              lka == LKA_SUCCEEDED ? "succeeded" : "failed");

        if (lka == LKA_SUCCEEDED)
            ++pThis->m_cSuccesses;
        else if (lka == LKA_FAILED)
            ++pThis->m_cFailures;

        return lka;
    }

    int m_cPreds;
    int m_cActions;
    int m_cSuccesses;
    int m_cFailures;

    CApplyIfTest()
        : m_cPreds(0), m_cActions(0), m_cSuccesses(0), m_cFailures(0)
    {}
};


// The Predicate and Action functions can be static member functions,
// but don't have to be

LK_PREDICATE
DeleteIfGt10(
    const CTest* pTest,
    void* pvState)
{
    TRACE("DeleteIfGt10(%p, %s, %p) = %d\n",
          pTest, pTest->m_sz, pvState, pTest->m_n);
    return (pTest->m_n > 10)  ?  LKP_PERFORM  :   LKP_NO_ACTION;
}


#include <stdio.h>
#include <string.h>

void Test(
    bool fVerbose)
{
    // Some objects for the hash tables
    CTest tl(5,  "Larson",   true);
    CTest tk(17, "Krishnan", false);
    CTest tr(37, "Reilly",   true);

    // A string-keyed hash table
    CStringTestHashTable stht;

    IRTLVERIFY(LK_SUCCESS == stht.InsertRecord(&tl));
    IRTLVERIFY(LK_SUCCESS == stht.InsertRecord(&tk));
    IRTLVERIFY(LK_SUCCESS == stht.InsertRecord(&tr));

    TRACE("Check the overwrite feature of InsertRecord\n");
    IRTLVERIFY(LK_KEY_EXISTS == stht.InsertRecord(&tr, false));
    IRTLASSERT(tr.m_cRefs == 1);
    IRTLVERIFY(LK_SUCCESS == stht.InsertRecord(&tr, true));
    IRTLASSERT(tr.m_cRefs == 1);    // 1+1-1 == 1

    TRACE("Check that the keys are really present in the table and that "
          "the refcounting works\n");
    const CTest* pTest = NULL;
    IRTLVERIFY(LK_SUCCESS == stht.FindKey(tl.m_sz, &pTest)  &&  pTest == &tl);
    IRTLASSERT(tl.m_cRefs == 2);
    IRTLVERIFY(LK_SUCCESS == stht.FindKey(tk.m_sz, &pTest)  &&  pTest == &tk);
    IRTLASSERT(tk.m_cRefs == 2);
    IRTLVERIFY(LK_SUCCESS == stht.FindKey(tr.m_sz, &pTest)  &&  pTest == &tr);
    IRTLASSERT(tr.m_cRefs == 2);
    IRTLVERIFY(LK_SUCCESS == stht.FindRecord(&tr));
    IRTLASSERT(tr.m_cRefs == 2);    // FindRecord does not addref

    TRACE("Look for a key under an alternate spelling (case-insensitive)\n");
    IRTLVERIFY(LK_SUCCESS == stht.FindKey("rEiLlY", &pTest)  &&  pTest == &tr);
    IRTLASSERT(tr.m_cRefs == 3);

    TRACE("Release the references added by FindKey\n");
    stht.AddRefRecord(&tl, -1);
    tk.m_cRefs--;
    tr.m_cRefs = 1;

    TRACE("Now build the numeric hash table\n");
    CNumberTestHashTable ntht;

    IRTLVERIFY(LK_SUCCESS == ntht.InsertRecord(&tl));
    IRTLVERIFY(LK_SUCCESS == ntht.InsertRecord(&tk));
    IRTLVERIFY(LK_SUCCESS == ntht.InsertRecord(&tr));

    TRACE("Test ApplyIf()\n");
    CApplyIfTest ait;

    IRTLVERIFY(1 == ntht.ApplyIf(ait.Predicate, ait.Action, &ait));
    IRTLASSERT(3 == ait.m_cPreds  &&  2 == ait.m_cActions
               &&  1 == ait.m_cSuccesses  &&  1 == ait.m_cFailures);

    TRACE("Test DeleteIf()\n");
    IRTLASSERT(3 == ntht.Size());
    ntht.DeleteIf(DeleteIfGt10, NULL);
    IRTLASSERT(1 == ntht.Size());

    TRACE("Check that the keys that were supposed to be deleted "
          "really are gone\n");
    IRTLASSERT(tl.m_n <= 10);
    IRTLVERIFY(LK_SUCCESS == ntht.FindKey(tl.m_n, &pTest)  &&  pTest == &tl);
    IRTLASSERT(tk.m_n >  10);
    IRTLVERIFY(LK_NO_SUCH_KEY == ntht.FindKey(tk.m_n, &pTest)
               &&  pTest == NULL);
    IRTLASSERT(tr.m_n >  10);
    IRTLVERIFY(LK_NO_SUCH_KEY == ntht.FindKey(tr.m_n, &pTest)
               &&  pTest == NULL);

    IRTLVERIFY(LK_SUCCESS == ntht.DeleteRecord(&tl));
    IRTLASSERT(0 == ntht.Size());

    TRACE("Check Iterators\n");
    DWORD  cRec = 0;
    CStringTestHashTable::CIterator iter;
    LK_RETCODE lkrc = stht.InitializeIterator(&iter);

    while (lkrc == LK_SUCCESS)
    {
        ++cRec;
        CStringTestHashTable::Key     pszKey = iter.Key();
        CStringTestHashTable::Record* pRec   = iter.Record();

        IRTLASSERT(pRec == &tl  ||  pRec == &tk  ||  pRec == &tr);
        if (fVerbose)
            printf("Record(%p) contains \"%s\"\n", pRec, pszKey);
        lkrc = stht.IncrementIterator(&iter);
    }

    IRTLASSERT(lkrc == LK_NO_MORE_ELEMENTS);

    lkrc = stht.CloseIterator(&iter);
    IRTLASSERT(lkrc == LK_SUCCESS);
    IRTLASSERT(cRec == stht.Size());

    TRACE("Check const iterators\n");
    const CStringTestHashTable& sthtConst = stht;
    CStringTestHashTable::CConstIterator iterConst;
    cRec = 0;

    lkrc = sthtConst.InitializeIterator(&iterConst);

    while (lkrc == LK_SUCCESS)
    {
        ++cRec;
        const CStringTestHashTable::Key     pszKey = iterConst.Key();
        const CStringTestHashTable::Record* pRec   = iterConst.Record();

        IRTLASSERT(pRec == &tl  ||  pRec == &tk  ||  pRec == &tr);
        if (fVerbose)
            printf("Const Record(%p) contains \"%s\"\n", pRec, pszKey);
        lkrc = sthtConst.IncrementIterator(&iterConst);
    }

    IRTLASSERT(lkrc == LK_NO_MORE_ELEMENTS);

    lkrc = sthtConst.CloseIterator(&iterConst);
    IRTLASSERT(lkrc == LK_SUCCESS);
    IRTLASSERT(cRec == sthtConst.Size());

#if 1
    TRACE("Check Clear\n");
    stht.Clear();
    IRTLASSERT(0 == stht.Size());
#else
    TRACE("Check DeleteKey\n");
    IRTLVERIFY(LK_SUCCESS == stht.DeleteKey(tl.m_sz));
    IRTLVERIFY(LK_SUCCESS == stht.DeleteKey(tk.m_sz));
    IRTLVERIFY(LK_SUCCESS == stht.DeleteKey(tr.m_sz));
#endif

    TRACE("Test done\n");
    // ~CTest will check for m_cRefs==0
}

#endif // SAMPLE_LKHASH_TESTCLASS

#endif // __LKHASH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\lstentry.h ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module  Name :
       lstentry.h

   Abstract:
       Declares CListEntry and other singly- and doubly-linked lists

   Author:
       George V. Reilly      (GeorgeRe)     02-Mar-1999

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/

#ifndef __LSTENTRY_H__
#define __LSTENTRY_H__

#ifndef __LOCKS_H__
# include <locks.h>
#endif // !__LOCKS_H__


//--------------------------------------------------------------------
// CSingleListEntry: a node in a singly-linked list.  Usually embedded
// within larger structures.
//--------------------------------------------------------------------

class CSingleListEntry
{
public:
    CSingleListEntry* Next;  // forward link
};



//--------------------------------------------------------------------
// A non-threadsafe singly linked list
//--------------------------------------------------------------------

class IRTL_DLLEXP CSingleList
{
protected:
    CSingleListEntry m_sleHead; // external head node

public:
    CSingleList()
    {
        m_sleHead.Next = NULL;
    }

    ~CSingleList()
    {
        IRTLASSERT(IsEmpty());
    }

    bool
    IsEmpty() const
    {
        return m_sleHead.Next == NULL;
    }

    CSingleListEntry* const
    Pop()
    {
        CSingleListEntry* psle = m_sleHead.Next;

        if (psle != NULL)
            m_sleHead.Next = psle->Next;

        return psle;
    }

    void
    Push(
        CSingleListEntry* const psle)
    {
        psle->Next     = m_sleHead.Next;
        m_sleHead.Next = psle;
    }
};


//--------------------------------------------------------------------
// A threadsafe singly linked list
//--------------------------------------------------------------------

class IRTL_DLLEXP CLockedSingleList
{
protected:
    CSpinLock   m_lock;
    CSingleList m_list;

public:

#ifdef LOCK_INSTRUMENTATION
    CLockedSingleList()
        : m_lock(NULL)
    {}
#endif // LOCK_INSTRUMENTATION

    void
    Lock()
    {
        m_lock.WriteLock();
    }

    void
    Unlock()
    {
        m_lock.WriteUnlock();
    }

    bool
    IsLocked() const
    {
        return m_lock.IsWriteLocked();
    }
    
    bool
    IsUnlocked() const
    {
        return m_lock.IsWriteUnlocked();
    }
    
    bool
    IsEmpty() const
    {
        return m_list.IsEmpty();
    }

    CSingleListEntry* const
    Pop()
    {
        Lock();
        CSingleListEntry* const psle = m_list.Pop();
        Unlock();

        return psle;
    }

    void
    Push(
        CSingleListEntry* const psle)
    {
        Lock();
        m_list.Push(psle);
        Unlock();
    }
};



//--------------------------------------------------------------------
// CListEntry: a node in a circular doubly-linked list.  Usually embedded
// within larger structures.
//--------------------------------------------------------------------

class CListEntry
{
public:
    CListEntry* Flink;  // forward link
    CListEntry* Blink;  // backward link
};


//--------------------------------------------------------------------
// A non-threadsafe circular doubly linked list
//--------------------------------------------------------------------

class IRTL_DLLEXP CDoubleList
{
protected:
    CListEntry  m_leHead; // external head node

public:
    CDoubleList()
    {
        m_leHead.Flink = m_leHead.Blink = &m_leHead;
    }

    ~CDoubleList()
    {
        IRTLASSERT(m_leHead.Flink != NULL  &&  m_leHead.Blink != NULL);
        IRTLASSERT(IsEmpty());
    }

    bool
    IsEmpty() const
    {
        return m_leHead.Flink == &m_leHead;
    }

    void
    InsertHead(
        CListEntry* const ple)
    {
        ple->Blink        = &m_leHead;
        ple->Flink        = m_leHead.Flink;
        ple->Flink->Blink = ple;
        m_leHead.Flink    = ple;
    }

    void
    InsertTail(
        CListEntry* const ple)
    {
        ple->Flink        = &m_leHead;
        ple->Blink        = m_leHead.Blink;
        ple->Blink->Flink = ple;
        m_leHead.Blink    = ple;
    }

    const CListEntry* const
    HeadNode() const
    {
        return &m_leHead;
    }

    CListEntry* const
    First() const
    {
        return m_leHead.Flink;
    }

    CListEntry* const
    RemoveHead()
    {
        CListEntry* ple = First();
        RemoveEntry(ple);
        return ple;
    }

    CListEntry* const
    Last() const
    {
        return m_leHead.Blink;
    }

    CListEntry* const
    RemoveTail()
    {
        CListEntry* ple = Last();
        RemoveEntry(ple);
        return ple;
    }

    static void
    RemoveEntry(
        CListEntry* const ple)
    {
        CListEntry* const pleOldBlink = ple->Blink;
        IRTLASSERT(pleOldBlink != NULL);
        CListEntry* const pleOldFlink = ple->Flink;
        IRTLASSERT(pleOldFlink != NULL);

        pleOldBlink->Flink = pleOldFlink;
        pleOldFlink->Blink = pleOldBlink;
    }
};


//--------------------------------------------------------------------
// A threadsafe circular doubly linked list
//--------------------------------------------------------------------

class IRTL_DLLEXP CLockedDoubleList
{
protected:
    CSpinLock   m_lock;
    CDoubleList m_list;

public:

#ifdef LOCK_INSTRUMENTATION
    CLockedDoubleList()
        : m_lock(NULL)
    {}
#endif // LOCK_INSTRUMENTATION
    
    void
    Lock()
    {
        m_lock.WriteLock();
    }

    void
    Unlock()
    {
        m_lock.WriteUnlock();
    }

    bool
    IsLocked() const
    {
        return m_lock.IsWriteLocked();
    }
    
    bool
    IsUnlocked() const
    {
        return m_lock.IsWriteUnlocked();
    }
    
    bool
    IsEmpty() const
    {
        return m_list.IsEmpty();
    }

    void
    InsertHead(
        CListEntry* const ple)
    {
        Lock();
        m_list.InsertHead(ple);
        Unlock();
    }

    void
    InsertTail(
        CListEntry* const ple)
    {
        Lock();
        m_list.InsertTail(ple);
        Unlock();
    }

    // not threadsafe
    const CListEntry* const
    HeadNode() const
    {
        return m_list.HeadNode();
    }

    // not threadsafe
    CListEntry* const
    First()
    {
        return m_list.First();
    }

    CListEntry* const
    RemoveHead()
    {
        Lock();
        CListEntry* const ple = m_list.RemoveHead();
        Unlock();
        return ple;
    }

    // not threadsafe
    CListEntry* const
    Last()
    {
        return m_list.Last();
    }

    CListEntry* const
    RemoveTail()
    {
        Lock();
        CListEntry* const ple = m_list.RemoveTail();
        Unlock();
        return ple;
    }

    void
    RemoveEntry(
        CListEntry* const ple)
    {
        Lock();
        m_list.RemoveEntry(ple);
        Unlock();
    }
};


#ifndef CONTAINING_RECORD
//
// Calculate the address of the base of the structure given its type, and an
// address of a field within the structure.
//

#define CONTAINING_RECORD(address, type, field) \
            ((type *)((PCHAR)(address) - (ULONG_PTR)(&((type *)0)->field)))

#endif // !CONTAINING_RECORD


#endif // __LSTENTRY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\msppheap.h ===
#ifndef __MSPPHEAP_H
#define __MSPPHEAP_H

#include "Rockall.hpp"

#ifdef __cplusplus
extern "C" {
#endif

void * WINAPI MSPP_New(int s, int* Space = NULL, bool Zero = false);
void WINAPI MSPP_Delete(void *p, int Size = NoSize);

#ifdef __cplusplus
}
#endif

#if defined(_USE_MSPPHEAP)
inline void* __cdecl operator new( size_t sz ) { return MSPP_New(sz); }
extern void  __cdecl operator delete (void * pInstance ) { MSPP_Delete(pInstance); }
#endif

#endif // __MSPPHEAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\lkrhash.h ===
/*++

   Copyright    (c) 1998-2000    Microsoft Corporation

   Module  Name :
       LKRhash.h

   Abstract:
       Declares LKRhash: a fast, scalable, cache- and MP-friendly hash table

   Author:
       Paul (Per-Ake) Larson, palarson@microsoft.com, July 1997
       Murali R. Krishnan    (MuraliK)
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:
       10/01/1998 - Change name from LKhash to LKRhash

--*/


#undef LKR_OLD_SEGMENT
#define LKR_SIGS_NODES
#define LKR_TEST_SIGNATURE
#undef LKR_COUNTDOWN
#define LKR_EQUALKEYS
#define LKR_DEPRECATED_ITERATORS
#define LKR_BITSCRAMBLE_SUBTABLE_INDEX
#define LKR_SUBTABLE_BITMASK
#define LKR_SUBTABLE_MASK


#ifndef __LKRHASH_H__
#define __LKRHASH_H__

//=====================================================================
//  The class CLKRLinearHashTable defined in this file provides dynamic hash
//  tables, i.e. tables that grow and shrink dynamically with
//  the number of records in the table.
//  The basic method used is linear hashing, as explained in:
//
//    P.-A. Larson, Dynamic Hash Tables, Comm. of the ACM, 31, 4 (1988)
//
//  This version has the following characteristics:
//  - It is thread-safe and uses spin locks for synchronization.
//  - It was designed to support very high rates of concurrent
//    operations (inserts/deletes/lookups).  It achieves this by
//    (a) partitioning a CLKRHashTable into a collection of
//        CLKRLinearHashTables to reduce contention on the global table lock.
//    (b) minimizing the hold time on a table lock, preferring to lock
//        down a bucket chain instead.
//  - The design is L1 cache-conscious.  See CNodeClump.
//  - It is designed for sets varying in size from a dozen
//    elements to several million.
//
//  Main classes:
//    CLKRLinearHashTable: thread-safe linear hash table
//    CLKRHashTable:       collection of CLKRLinearHashTables
//    CTypedHashTable:     typesafe wrapper for CLKRHashTable
//
//
//  Paul Larson, palarson@microsoft.com, July 1997
//   Original implementation with input from Murali R. Krishnan,
//   muralik@microsoft.com.
//
//  George V. Reilly, georgere@microsoft.com, Dec 1997-Jan 1998
//   Massive cleanup and rewrite.  Added templates.
//=====================================================================


// 1) Linear Hashing
// ------------------
//
// Linear hash tables grow and shrink dynamically with the number of
// records in the table.  The growth or shrinkage is smooth: logically,
// one bucket at a time but physically in larger increments
// (64 buckets).  An insertion (deletion) may cause an expansion
// (contraction) of the table.  This causes relocation of a small number
// of records (at most one bucket worth).  All operations (insert,
// delete, lookup) take constant expected time, regardless of the
// current size or the growth of the table.
//
// 2) LKR extensions to Linear hash table
// --------------------------------------
//
// Larson-Krishnan-Reilly extensions to Linear hash tables for multiprocessor
// scalability and improved cache performance.
//
// Traditional implementations of linear hash tables use one global lock
// to prevent interference between concurrent operations
// (insert/delete/lookup) on the table.  The single lock easily becomes
// the bottleneck in SMP scenarios when multiple threads are used.
//
// Traditionally, a (hash) bucket is implemented as a chain of
// single-item nodes.  Every operation results in chasing down a chain
// looking for an item. However, pointer chasing is very slow on modern
// systems because almost every jump results in a cache miss. L2 (or L3)
// cache misses are very expensive in missed CPU cycles and the cost is
// increasing (going to 100s of cycles in the future).
//
// LKR extensions offer
//    1) Partitioning (by hashing) of records among multiple subtables.
//       Each subtable has locks but there is no global lock.  Each
//       subtable receives a much lower rate of operations, resulting in
//       fewer conflicts.
//
//    2) Improved cache locality by grouping keys and their hash values
//       into contigous chunks that fit exactly into one (or a few)
//       cache lines.
//
// Specifically the implementation that exists here achieves this using
// the following techniques.
//
// Class CLKRHashTable is the top-level data structure that dynamically
// creates m_cSubTables linear hash tables. The CLKRLinearHashTables act as
// the subtables to which items and accesses are fanned out. A good
// hash function multiplexes requests uniformly to various subtables,
// thus minimizing traffic to any single subtable. The implemenation
// uses a home-grown version of bounded spinlocks, that is, a thread
// does not spin on a lock indefinitely, instead yielding after a
// predetermined number of loops.
//
// Each CLKRLinearHashTable consists of a CDirEntry pointing to segments
// each holding m_dwSegSize CBuckets. Each CBucket in turn consists of a
// chain of CNodeClumps.  Each CNodeClump contains a group of
// NODES_PER_CLUMP hash values (aka hash keys or signatures) and
// pointers to the associated data items.  Keeping the signatures
// together increases the cache locality in scans for lookup.
//
// Traditionally, people store a link-list element right inside the
// object that is hashed and use this link-list for the chaining of data
// blocks.  However, keeping just the pointers to the data object and
// not chaining through them limits the need for bringing in the data
// object to the cache.  We need to access the data object only if the
// hash values match. This limits the cache-thrashing behaviour
// exhibited by conventional implementations.  It has the additional
// benefit that the objects themselves do not need to be modified
// in order to be collected in the hash table (i.e., it's non-invasive).


//--------------------------------------------------------------------
// TODO
// * Debugging support for iisprobe?
// * Use auto_ptrs.
// * Provide ReplaceRecord and DeleteRecord methods on iterators.
// * Sloppy iterators
// * Provide implementations of the STL collection classes, map, set,
//   multimap, and multiset.
// * Make exception safe.
//--------------------------------------------------------------------


#include <irtldbg.h>
#include <lstentry.h>
#include <hashfn.h>
#include <limits.h>



#ifdef __LKRHASH_NAMESPACE__
namespace LKRHash {
#endif // __LKRHASH_NAMESPACE__

enum LK_TABLESIZE {
    LK_SMALL_TABLESIZE=  1,     // < 200 elements
    LK_MEDIUM_TABLESIZE= 2,     // 200...10,000 elements
    LK_LARGE_TABLESIZE=  3,     // 10,000+ elements
};

// Default values for the hashtable constructors
enum {
#ifndef _WIN64
    LK_DFLT_MAXLOAD=     6, // Default upperbound on average chain length.
#else // _WIN64
    LK_DFLT_MAXLOAD=     4, // 64-byte nodes => NODES_PER_CLUMP = 4
#endif // _WIN64
    LK_DFLT_INITSIZE=LK_MEDIUM_TABLESIZE, // Default initial size of hash table
    LK_DFLT_NUM_SUBTBLS= 0, // Use a heuristic to choose #subtables
};

// build fix hack
// enum {
//     DFLT_LK_MAXLOAD=     LK_DFLT_MAXLOAD,
//     DFLT_LK_INITSIZE=    LK_DFLT_INITSIZE,
//     DFLT_LK_NUM_SUBTBLS= LK_DFLT_NUM_SUBTBLS,
// };

//--------------------------------------------------------------------
// forward declarations

class IRTL_DLLEXP CLKRLinearHashTable;

class IRTL_DLLEXP CLKRHashTable;

template <class _Der, class _Rcd, class _Ky, class _HT
#ifdef LKR_DEPRECATED_ITERATORS
          , class _Iter
#endif // LKR_DEPRECATED_ITERATORS
          >
class CTypedHashTable;


//--------------------------------------------------------------------
// Possible return codes from public member functions of
// CLKRLinearHashTable, CLKRHashTable, and CTypedHashTable

enum LK_RETCODE {
    // severe errors < 0
    LK_UNUSABLE = -99,  // Table corrupted: all bets are off
    LK_ALLOC_FAIL,      // ran out of memory
    LK_BAD_ITERATOR,    // invalid iterator; e.g., points to another table
    LK_BAD_RECORD,      // invalid record; e.g., NULL for InsertRecord
    LK_BAD_PARAMETERS,  // invalid parameters; e.g., NULL fnptrs to ctor
    LK_NOT_INITIALIZED, // LKRHashTableInit was not called

    LK_SUCCESS = 0,     // everything's okay
    LK_KEY_EXISTS,      // key already present for InsertRecord(no-overwrite)
    LK_NO_SUCH_KEY,     // key not found
    LK_NO_MORE_ELEMENTS,// iterator exhausted
};

#define LK_SUCCEEDED(lkrc)  ((lkrc) >= LK_SUCCESS)


#ifdef LKR_DEPRECATED_ITERATORS

//--------------------------------------------------------------------
// Return codes from PFnRecordPred.

enum LK_PREDICATE {
    LKP_ABORT = 1,           // Stop walking the table immediately
    LKP_NO_ACTION = 2,       // No action, just keep walking
    LKP_PERFORM = 3,         // Perform action and continue walking
    LKP_PERFORM_STOP = 4,    // Perform action, then stop
    LKP_DELETE = 5,          // Delete record and keep walking
    LKP_DELETE_STOP = 6,     // Delete record, then stop
};


//--------------------------------------------------------------------
// Return codes from PFnRecordAction.

enum LK_ACTION {
    LKA_ABORT = 1,          // Stop walking the table immediately
    LKA_FAILED = 2,         // Action failed; continue walking the table
    LKA_SUCCEEDED = 3,      // Action succeeded; continue walking the table
};


//--------------------------------------------------------------------
// Parameter to Apply and ApplyIf.

enum LK_LOCKTYPE {
    LKL_READLOCK = 1,       // Lock the table for reading (for constness)
    LKL_WRITELOCK = 2,      // Lock the table for writing
};

#endif // LKR_DEPRECATED_ITERATORS



//--------------------------------------------------------------------
// Global table lock code.  This is only used to measure how much a
// slowdown having a global lock on the CLKRHashTable causes.  It is *never*
// used in production code.


// #define LKRHASH_GLOBAL_LOCK CCritSec

#ifdef LKRHASH_GLOBAL_LOCK

# define LKRHASH_GLOBAL_LOCK_DECLARATIONS()         \
    typedef LKRHASH_GLOBAL_LOCK GlobalLock;  \
    mutable GlobalLock m_lkGlobal;

# define LKRHASH_GLOBAL_READ_LOCK()     m_lkGlobal.ReadLock()
# define LKRHASH_GLOBAL_WRITE_LOCK()    m_lkGlobal.WriteLock()
# define LKRHASH_GLOBAL_READ_UNLOCK()   m_lkGlobal.ReadUnlock()
# define LKRHASH_GLOBAL_WRITE_UNLOCK()  m_lkGlobal.WriteUnlock()

#else // !LKRHASH_GLOBAL_LOCK

# define LKRHASH_GLOBAL_LOCK_DECLARATIONS()

// These ones will be optimized away by the compiler
# define LKRHASH_GLOBAL_READ_LOCK()     ((void)0)
# define LKRHASH_GLOBAL_WRITE_LOCK()    ((void)0)
# define LKRHASH_GLOBAL_READ_UNLOCK()   ((void)0)
# define LKRHASH_GLOBAL_WRITE_UNLOCK()  ((void)0)

#endif // !LKRHASH_GLOBAL_LOCK



//--------------------------------------------------------------------
// Statistical information returned by GetStatistics
//--------------------------------------------------------------------

#ifdef LOCK_INSTRUMENTATION

class IRTL_DLLEXP CAveragedLockStats : public CLockStatistics
{
public:
    int m_nItems;

    CAveragedLockStats()
        : m_nItems(1)
    {}
};

#endif // LOCK_INSTRUMENTATION



class IRTL_DLLEXP CLKRHashTableStats
{
public:
    int      RecordCount;           // number of records in the table
    int      TableSize;             // table size in number of slots
    int      DirectorySize;         // number of entries in directory
    int      LongestChain;          // longest hash chain in the table
    int      EmptySlots;            // number of unused hash slots
    double   SplitFactor;           // fraction of buckets split
    double   AvgSearchLength;       // average length of a successful search
    double   ExpSearchLength;       // theoretically expected length
    double   AvgUSearchLength;      // average length of an unsuccessful search
    double   ExpUSearchLength;      // theoretically expected length
    int      NodeClumpSize;         // number of slots in a node clump
    int      CBucketSize;           // sizeof(CBucket)

#ifdef LOCK_INSTRUMENTATION
    CAveragedLockStats      m_alsTable;  // stats for table lock
    CAveragedLockStats      m_alsBucketsAvg; // avg of stats for bucket locks
    CGlobalLockStatistics   m_gls;      // global statistics for all locks
#endif // LOCK_INSTRUMENTATION

    enum {
        MAX_BUCKETS = 40,
    };

    // histogram of bucket lengths
    LONG    m_aBucketLenHistogram[MAX_BUCKETS];

    CLKRHashTableStats()
        : RecordCount(0),
          TableSize(0),
          DirectorySize(0),
          LongestChain(0),
          EmptySlots(0),
          SplitFactor(0.0),
          AvgSearchLength(0.0),
          ExpSearchLength(0.0),
          AvgUSearchLength(0.0),
          ExpUSearchLength(0.0),
          NodeClumpSize(1),
          CBucketSize(0)
    {
        for (int i = MAX_BUCKETS;  --i >= 0;  )
            m_aBucketLenHistogram[i] = 0;
    }

    static const LONG*
    BucketSizes()
    {
        static const LONG  s_aBucketSizes[MAX_BUCKETS] = {
                   1,    2,    3,    4,    5,    6,    7,      8,        9,
            10,   11,   12,   13,   14,   15,   16,   17,     18,       19,
            20,   21,   22,   23,   24,   25,   30,   40,     50,       60,
            70,   80,   90,  100,  200,  500, 1000,10000, 100000, LONG_MAX,
        };

        return s_aBucketSizes;
    }

    static LONG
    BucketSize(
        LONG nBucketIndex)
    {
        IRTLASSERT(0 <= nBucketIndex  &&  nBucketIndex < MAX_BUCKETS);
        return BucketSizes()[nBucketIndex];
    }

    static LONG
    BucketIndex(
        LONG nBucketLength)
    {
        const LONG* palBucketSizes = BucketSizes();
        LONG i = 0;
        while (palBucketSizes[i] < nBucketLength)
            ++i;
        if (i == MAX_BUCKETS  ||  palBucketSizes[i] > nBucketLength)
            --i;
        IRTLASSERT(0 <= i  &&  i < MAX_BUCKETS);
        return i;
    }
};



// Use types defined in recent versions of the Platform SDK.
#ifndef _W64
typedef DWORD DWORD_PTR;   // integral type big enough to hold a pointer
#endif

//--------------------------------------------------------------------
// CLKRLinearHashTable deals with void* records.  These typedefs
// provide prototypes for functions that manipulate instances of
// those records.  CTypedHashTable and CStringTestHashTable (below) show a
// way to encapsulate these in typesafe wrappers.
//--------------------------------------------------------------------

// Given a record, return its key.  Assumes that the key is embedded in
// the record, or at least somehow derivable from the record.  For
// completely unrelated keys & values, a wrapper class should use
// something like STL's pair<key,value> template to aggregate them
// into a record.
typedef const DWORD_PTR (WINAPI *PFnExtractKey)  (const void* pvRecord);

// Given a key, return its hash signature.  The hashing functions in
// hashfn.h (or something that builds upon them) are suggested.
typedef DWORD       (WINAPI *PFnCalcKeyHash) (const DWORD_PTR pnKey);

// Compare two keys for equality; e.g., _stricmp, memcmp, operator==
typedef bool        (WINAPI *PFnEqualKeys)   (const DWORD_PTR pnKey1,
                                              const DWORD_PTR pnKey2);

// Increment the reference count of a record before returning it from
// FindKey.  It's necessary to do it in FindKey itself while the bucket
// is still locked, rather than one of the wrappers, to avoid race
// conditions.  Similarly, the reference count is incremented in
// InsertRecord and decremented in DeleteKey.  Finally, if an old record
// is overwritten in InsertRecord, its reference count is decremented.
//
// It's up to you to decrement the reference count when you're finished
// with it after retrieving it via FindKey and to determine the
// semantics of what this means.  The hashtable itself has no notion of
// reference counts; this is merely to help with the lifetime management
// of the record objects.
typedef void        (WINAPI *PFnAddRefRecord)(const void* pvRecord, int nIncr);

#ifdef LKR_DEPRECATED_ITERATORS
// ApplyIf() and DeleteIf(): Does the record match the predicate?
typedef LK_PREDICATE (WINAPI *PFnRecordPred) (const void* pvRecord,
                                              void* pvState);

// Apply() et al: Perform action on record.
typedef LK_ACTION   (WINAPI *PFnRecordAction)(const void* pvRecord,
                                              void* pvState);
#endif // LKR_DEPRECATED_ITERATORS



//--------------------------------------------------------------------
// Custom memory allocators
//--------------------------------------------------------------------


#ifndef LKR_NO_ALLOCATORS
// # define LKRHASH_ACACHE 1
// # define LKRHASH_MANODEL 1
// # define LKRHASH_MADEL 1
// # define LKRHASH_ROCKALL_FAST 1

// # define LKRHASH_MEM_DEFAULT_ALIGN 32
#endif // !LKR_NO_ALLOCATORS

#ifndef LKRHASH_MEM_DEFAULT_ALIGN
# define LKRHASH_MEM_DEFAULT_ALIGN 8
#endif // !LKRHASH_MEM_DEFAULT_ALIGN

#if defined(LKRHASH_ACACHE)

# include <acache.hxx>
  typedef ALLOC_CACHE_HANDLER  CLKRhashAllocator;
# define LKRHASH_ALLOCATOR_NEW(C, N)                            \
    const ALLOC_CACHE_CONFIGURATION acc = { 1, N, sizeof(C) };  \
    C::sm_palloc = new ALLOC_CACHE_HANDLER("IISRTL:" #C, &acc);

#elif defined(LKRHASH_MANODEL)

# include <manodel.hxx>
  typedef MEMORY_ALLOC_NO_DELETE  CLKRhashAllocator;
# define LKRHASH_ALLOCATOR_NEW(C, N)                            \
    C::sm_palloc = new MEMORY_ALLOC_NO_DELETE(sizeof(C),        \
                                              LKRHASH_MEM_DEFAULT_ALIGN);

#elif defined(LKRHASH_MADEL)

# include <madel.hxx>
  typedef MEMORY_ALLOC_DELETE  CLKRhashAllocator;
# define LKRHASH_ALLOCATOR_NEW(C, N)                            \
    C::sm_palloc = new MEMORY_ALLOC_DELETE(sizeof(C),           \
                                           LKRHASH_MEM_DEFAULT_ALIGN, N);

#elif defined(LKRHASH_ROCKALL_FAST)

# include <FastHeap.hpp>

class FastHeap : public FAST_HEAP
{
public:
    FastHeap(
        SIZE_T cb)
        : m_cb(cb)
    {}

    LPVOID Alloc()
    { return New(m_cb, NULL, false); }

    BOOL   Free(LPVOID pvMem)
    { return Delete(pvMem); }

    SIZE_T m_cb;
};

  typedef FastHeap  CLKRhashAllocator;
# define LKRHASH_ALLOCATOR_NEW(C, N)                            \
    C::sm_palloc = new FastHeap(sizeof(C));

#else // no custom allocator

# undef LKRHASH_ALLOCATOR_NEW

#endif // no custom allocator



// Used to initialize and destroy custom allocators
bool LKRHashTableInit();
void LKRHashTableUninit();


#ifdef LKRHASH_ALLOCATOR_NEW

// placed inline in the declaration of class C
# define LKRHASH_ALLOCATOR_DEFINITIONS(C)                       \
    protected:                                                  \
        static CLKRhashAllocator* sm_palloc;                    \
        friend bool LKRHashTableInit();                         \
        friend void LKRHashTableUninit();                       \
    public:                                                     \
        static void*  operator new(size_t s)                    \
        {                                                       \
          IRTLASSERT(s == sizeof(C));                           \
          IRTLASSERT(sm_palloc != NULL);                        \
          return sm_palloc->Alloc();                            \
        }                                                       \
        static void   operator delete(void* pv)                 \
        {                                                       \
          IRTLASSERT(pv != NULL);                               \
          IRTLASSERT(sm_palloc != NULL);                        \
          sm_palloc->Free(pv);                                  \
        }


// used in LKRHashTableInit()
# define LKRHASH_ALLOCATOR_INIT(C, N, f)                        \
    {                                                           \
        if (f)                                                  \
        {                                                       \
            IRTLASSERT(C::sm_palloc == NULL);                   \
            LKRHASH_ALLOCATOR_NEW(C, N);                        \
            f = (C::sm_palloc != NULL);                         \
        }                                                       \
    }


// used in LKRHashTableUninit()
# define LKRHASH_ALLOCATOR_UNINIT(C)                            \
    {                                                           \
        if (C::sm_palloc != NULL)                               \
        {                                                       \
            delete C::sm_palloc;                                \
            C::sm_palloc = NULL;                                \
        }                                                       \
    }


#else // !LKRHASH_ALLOCATOR_NEW

# define LKRHASH_ALLOCATOR_DEFINITIONS(C)
# define LKRHASH_ALLOCATOR_INIT(C, N, f)
# define LKRHASH_ALLOCATOR_UNINIT(C)

#endif // !LKRHASH_ALLOCATOR_NEW



//--------------------------------------------------------------------
// CLKRLinearHashTable
//
// A thread-safe linear hash table.
//--------------------------------------------------------------------

class IRTL_DLLEXP CLKRLinearHashTable
{
public:
    // typedef CSmallSpinLock   TableLock;
    // typedef CFakeLock        TableLock;
    // typedef CSpinLock        TableLock;
    // typedef CSpinLock2       TableLock;
    // typedef CSpinLock3       TableLock;
    // typedef CShareLock       TableLock;
    // typedef CReaderWriterLock  TableLock;
    // typedef CReaderWriterLock2 TableLock;
    typedef CReaderWriterLock3 TableLock;

    // typedef CSmallSpinLock   BucketLock;
    // typedef CFakeLock        BucketLock;
    // typedef CSpinLock        BucketLock;
    // typedef CSpinLock2       BucketLock;
    // typedef CSpinLock3       BucketLock;
    // typedef CShareLock       BucketLock;
    // typedef CReaderWriterLock  BucketLock;
    // typedef CReaderWriterLock2 BucketLock;
    typedef CReaderWriterLock3 BucketLock;

#ifdef LKR_DEPRECATED_ITERATORS
    class CIterator;
    friend class CLKRLinearHashTable::CIterator;
#endif // LKR_DEPRECATED_ITERATORS

private:
    class CNodeClump;
    friend class CLKRLinearHashTable::CNodeClump;

    friend class CLKRHashTable;

#ifdef LKRHASH_ALLOCATOR_NEW
    friend bool LKRHashTableInit();
    friend void LKRHashTableUninit();
#endif // LKRHASH_ALLOCATOR_NEW

#ifdef LKRHASH_INSTRUMENTATION
    // TODO
#endif // LKRHASH_INSTRUMENTATION

#define HASH_RANDOMIZE_BITS

#ifdef HASH_RANDOMIZE_BITS
    enum {
        // No number in 0..2^31-1 maps to this number after it has been
        // scrambled by RandomizeBits
        HASH_INVALID_SIGNATURE = 31678523,
    };
#else // !HASH_RANDOMIZE_BITS
    enum {
        // Given M = A % B, A and B unsigned 32-bit integers greater than zero,
        // there are no values of A or B which yield M = 2^32-1.  Why?  Because
        // M must be less than B.
        HASH_INVALID_SIGNATURE = ULONG_MAX,
    };
#endif // !HASH_RANDOMIZE_BITS


    // Class for nodes on a bucket chain.  Instead of a node containing
    // one (signature, record-pointer, next-tuple-pointer) tuple, it
    // contains _N_ such tuples.  (N-1 next-tuple-pointers are omitted.)
    // This improves locality of reference greatly; i.e., it's L1
    // cache-friendly.  It also reduces memory fragmentation and memory
    // allocator overhead.  It does complicate the chain traversal code
    // slightly, admittedly.
    //
    // This theory is beautiful.  In practice, however, CNodeClumps
    // are *not* perfectly aligned on 32-byte boundaries by the memory
    // allocators.  Experimental results indicate that we get a 2-3%
    // speed improvement by using 32-byte-aligned blocks, but this must
    // be considered against the average of 16 bytes wasted per block.

    class CNodeClump
    {
    public:
        // Record slots per chunk - set so a chunk matches (one or
        // two) cache lines.  3 ==> 32 bytes, 7 ==> 64 bytes
        // Note: the default max load factor is 4.0, which implies that
        // there will seldom be more than one node clump in a chain.
        enum {
            BUCKET_BYTE_SIZE = 64,
            BUCKET_OVERHEAD  = sizeof(BucketLock) + sizeof(CNodeClump*),
            NODE_SIZE        = sizeof(const void*) + sizeof(DWORD),
            NODES_PER_CLUMP  = (BUCKET_BYTE_SIZE - BUCKET_OVERHEAD) / NODE_SIZE
        };

#ifdef LKR_SIGS_NODES
        DWORD  m_dwKeySigs[NODES_PER_CLUMP]; // hash values computed from keys
        CNodeClump* m_pncNext;               // next node clump on the chain
        const void* m_pvNode[NODES_PER_CLUMP];// pointers to records
#else // !LKR_SIGS_NODES
        const void* m_pvNode[NODES_PER_CLUMP];// pointers to records
        CNodeClump* m_pncNext;               // next node clump on the chain
        DWORD  m_dwKeySigs[NODES_PER_CLUMP]; // hash values computed from keys
#endif // !LKR_SIGS_NODES

        CNodeClump()
        {
            Clear();
        }

        void
        Clear()
        { 
            m_pncNext = NULL;  // no dangling pointers
            for (int i = NODES_PER_CLUMP;  --i >= 0; )
            {
                m_dwKeySigs[i] = HASH_INVALID_SIGNATURE;
                m_pvNode[i] = NULL;
            }
        }

        bool
        InvalidSignature(
            DWORD i) const
        {
            IRTLASSERT(0 <= i  &&  i < NODES_PER_CLUMP);
            return (m_dwKeySigs[i] == HASH_INVALID_SIGNATURE);
        }

        bool
        IsEmptyNode(
            DWORD i) const
        {
            IRTLASSERT(0 <= i  &&  i < NODES_PER_CLUMP);
            return (m_pvNode[i] == NULL);
        }

        bool
        IsEmptyAndInvalid(
            DWORD i) const
        {
            return IsEmptyNode(i) && InvalidSignature(i);
        }

        bool
        IsEmptySlot(
            DWORD i) const
        {
#ifdef LKR_TEST_SIGNATURE
            return InvalidSignature(i);
#else // !LKR_TEST_SIGNATURE
            return IsEmptyNode(i);
#endif // !LKR_TEST_SIGNATURE
        }

        bool
        IsLastClump() const
        {
            return (m_pncNext == NULL);
        }

#ifdef _DEBUG
        // Don't want overhead of calls to dtor in retail build
        ~CNodeClump()
        {
            IRTLASSERT(IsLastClump());  // no dangling pointers
            for (int i = NODES_PER_CLUMP;  --i >= 0;  )
                IRTLASSERT(InvalidSignature(i)  &&  IsEmptyNode(i));
        }
#endif // _DEBUG

        LKRHASH_ALLOCATOR_DEFINITIONS(CNodeClump);
    };


    // Class for bucket chains of the hash table.  Note that the first
    // nodeclump is actually included in the bucket and not dynamically
    // allocated, which increases space requirements slightly but does
    // improve performance.
    class CBucket
    {
    private:
        mutable BucketLock m_Lock;       // lock protecting this bucket

#ifdef LOCK_INSTRUMENTATION
        static LONG sm_cBuckets;

        static const char*
        _LockName()
        {
            LONG l = ++sm_cBuckets;
            // possible race condition but we don't care, as this is never
            // used in production code
            static char s_szName[CLockStatistics::L_NAMELEN];
            wsprintf(s_szName, "B%06x", 0xFFFFFF & l);
            return s_szName;
        }
#endif // LOCK_INSTRUMENTATION

    public:
        CNodeClump    m_ncFirst;    // first CNodeClump of this bucket

#if defined(LOCK_INSTRUMENTATION) || defined(_DEBUG)
        CBucket()
#ifdef LOCK_INSTRUMENTATION
            : m_Lock(_LockName())
#endif // LOCK_INSTRUMENTATION
        {
#ifdef _DEBUG
            LOCK_LOCKTYPE lt = BucketLock::LockType();
            if (lt == LOCK_SPINLOCK  ||  lt == LOCK_FAKELOCK)
                IRTLASSERT(sizeof(*this) <= 64);
#endif _DEBUG
        }
#endif // LOCK_INSTRUMENTATION || _DEBUG

        void  WriteLock()           { m_Lock.WriteLock(); }
        void  ReadLock() const      { m_Lock.ReadLock(); }
        void  WriteUnlock() const   { m_Lock.WriteUnlock();   }
        void  ReadUnlock() const    { m_Lock.ReadUnlock();   }
        bool  IsWriteLocked() const { return m_Lock.IsWriteLocked(); }
        bool  IsReadLocked() const  { return m_Lock.IsReadLocked(); }
        bool  IsWriteUnlocked() const { return m_Lock.IsWriteUnlocked(); }
        bool  IsReadUnlocked() const  { return m_Lock.IsReadUnlocked(); }
        void  SetSpinCount(WORD wSpins) { m_Lock.SetSpinCount(wSpins); }
        WORD  GetSpinCount() const  { return m_Lock.GetSpinCount(); }
#ifdef LOCK_INSTRUMENTATION
        CLockStatistics LockStats() const {return m_Lock.Statistics();}
#endif // LOCK_INSTRUMENTATION
    };


    // The hash table space is divided into fixed-size segments (arrays of
    // CBuckets) and physically grows/shrinks one segment at a time.

    // We provide small, medium, and large segments to better tune the
    // overall memory requirements of the hash table according to the
    // expected usage of an instance.

    class CSegment
    {
    public:
#ifdef LKR_OLD_SEGMENT
        virtual ~CSegment() {}; // link fails if this is pure virtual
        virtual DWORD Bits() const = 0;
        virtual DWORD Size() const = 0;
        virtual DWORD Mask() const = 0;
        virtual DWORD InitSize() const = 0;
        virtual CBucket& Slot(DWORD i) = 0;
#else // !LKR_OLD_SEGMENT
        CBucket m_bktSlots;

        CBucket& Slot(DWORD i)
        { return static_cast<CBucket*>(&m_bktSlots)[i]; }
#endif // !LKR_OLD_SEGMENT
    };


    // Small-sized segments contain 2^3 = 8 buckets => ~0.5Kb
    class CSmallSegment : public CSegment
    {
    public:
        // Maximum table size equals MAX_DIRSIZE * SEGSIZE buckets.
        enum {
            SEGBITS  =            3,// number of bits extracted from a hash
                                    // address for offset within a segment
            SEGSIZE  = (1<<SEGBITS),// segment size
            SEGMASK  = (SEGSIZE-1), // mask used for extracting offset bit
            INITSIZE = 1 * SEGSIZE, // #segments to allocate initially
        };

#ifdef LKR_OLD_SEGMENT
    private:
        CBucket m_bktSlots[SEGSIZE];

    public:
        virtual ~CSmallSegment()        {}
        virtual DWORD Bits() const      { return SEGBITS; }
        virtual DWORD Size() const      { return SEGSIZE; }
        virtual DWORD Mask() const      { return SEGMASK; }
        virtual DWORD InitSize() const  { return INITSIZE;}
        virtual CBucket& Slot(DWORD i)
        { IRTLASSERT(i < SEGSIZE); return m_bktSlots[i]; }

#else // !LKR_OLD_SEGMENT
    private:
        CBucket m_bktSlots2[SEGSIZE-1];
    public:
        DWORD Bits() const      { return SEGBITS; }
        DWORD Size() const      { return SEGSIZE; }
        DWORD Mask() const      { return SEGMASK; }
        DWORD InitSize() const  { return INITSIZE;}
#endif // !LKR_OLD_SEGMENT

#ifdef _DEBUG
        CSmallSegment()
        {
            IRTLASSERT(((DWORD_PTR)this & (LKRHASH_MEM_DEFAULT_ALIGN-1)) == 0);
#ifdef LKR_OLD_SEGMENT
            IRTLASSERT(sizeof(*this) == SEGSIZE * sizeof(CBucket)
                                        + sizeof(void*));
#else  // !LKR_OLD_SEGMENT
            IRTLASSERT(sizeof(*this) == SEGSIZE * sizeof(CBucket));
#endif // !LKR_OLD_SEGMENT
        }
#endif // _DEBUG

        LKRHASH_ALLOCATOR_DEFINITIONS(CSmallSegment);
    };


    // Medium-sized segments contain 2^6 = 64 buckets => ~4Kb
    class CMediumSegment : public CSegment
    {
    public:
        enum {
            SEGBITS  =            6,
            SEGSIZE  = (1<<SEGBITS),
            SEGMASK  = (SEGSIZE-1),
            INITSIZE = 2 * SEGSIZE,
        };

#ifdef LKR_OLD_SEGMENT
    private:
        CBucket m_bktSlots[SEGSIZE];

    public:
        virtual ~CMediumSegment()       {}
        virtual DWORD Bits() const      { return SEGBITS; }
        virtual DWORD Size() const      { return SEGSIZE; }
        virtual DWORD Mask() const      { return SEGMASK; }
        virtual DWORD InitSize() const  { return INITSIZE;}
        virtual CBucket& Slot(DWORD i)
        { IRTLASSERT(i < SEGSIZE); return m_bktSlots[i]; }

#else // !LKR_OLD_SEGMENT
    private:
        CBucket m_bktSlots2[SEGSIZE-1];
    public:
        DWORD Bits() const      { return SEGBITS; }
        DWORD Size() const      { return SEGSIZE; }
        DWORD Mask() const      { return SEGMASK; }
        DWORD InitSize() const  { return INITSIZE;}
#endif // !LKR_OLD_SEGMENT

#ifdef _DEBUG
        CMediumSegment()
        {
            IRTLASSERT(((DWORD_PTR)this & (LKRHASH_MEM_DEFAULT_ALIGN-1)) == 0);
#ifdef LKR_OLD_SEGMENT
            IRTLASSERT(sizeof(*this) == SEGSIZE * sizeof(CBucket)
                                        + sizeof(void*));
#else  // !LKR_OLD_SEGMENT
            IRTLASSERT(sizeof(*this) == SEGSIZE * sizeof(CBucket));
#endif // !LKR_OLD_SEGMENT
        }
#endif // _DEBUG

        LKRHASH_ALLOCATOR_DEFINITIONS(CMediumSegment);
    };

    // Large-sized segments contain 2^9 = 512 buckets => ~32Kb
    class CLargeSegment : public CSegment
    {
    public:
        enum {
            SEGBITS  =            9,
            SEGSIZE  = (1<<SEGBITS),
            SEGMASK  = (SEGSIZE-1),
            INITSIZE = 4 * SEGSIZE,
        };

#ifdef LKR_OLD_SEGMENT
    private:
        CBucket m_bktSlots[SEGSIZE];

    public:
        virtual ~CLargeSegment()        {}
        virtual DWORD Bits() const      { return SEGBITS; }
        virtual DWORD Size() const      { return SEGSIZE; }
        virtual DWORD Mask() const      { return SEGMASK; }
        virtual DWORD InitSize() const  { return INITSIZE;}
        virtual CBucket& Slot(DWORD i)
        { IRTLASSERT(i < SEGSIZE); return m_bktSlots[i]; }

#else // !LKR_OLD_SEGMENT
    private:
        CBucket m_bktSlots2[SEGSIZE-1];
    public:
        DWORD Bits() const      { return SEGBITS; }
        DWORD Size() const      { return SEGSIZE; }
        DWORD Mask() const      { return SEGMASK; }
        DWORD InitSize() const  { return INITSIZE;}
#endif // !LKR_OLD_SEGMENT

#ifdef _DEBUG
        CLargeSegment()
        {
            IRTLASSERT(((DWORD_PTR)this & (LKRHASH_MEM_DEFAULT_ALIGN-1)) == 0);
#ifdef LKR_OLD_SEGMENT
            IRTLASSERT(sizeof(*this) == SEGSIZE * sizeof(CBucket)
                                        + sizeof(void*));
#else  // !LKR_OLD_SEGMENT
            IRTLASSERT(sizeof(*this) == SEGSIZE * sizeof(CBucket));
#endif // !LKR_OLD_SEGMENT
        }
#endif // _DEBUG

        LKRHASH_ALLOCATOR_DEFINITIONS(CLargeSegment);
    };


    // A directory keeps track of the segments comprising the hash table.
    // The directory is just a variable-sized array of pointers to
    // segments (CDirEntrys).
    class CDirEntry
    {
    public:
        // MIN_DIRSIZE and MAX_DIRSIZE can be changed independently
        // of anything else.  Should be powers of two.
        enum {
            MIN_DIRSIZE =  (1<<3),   // minimum directory size
            MAX_DIRSIZE = (1<<20),   // maximum directory size
        };

        CSegment* m_pseg;

        CDirEntry()
            : m_pseg(NULL)
        {}

        ~CDirEntry()
        { delete m_pseg; }
    };

public:

    // aliases for convenience
    enum {
        NODES_PER_CLUMP = CNodeClump::NODES_PER_CLUMP,
        MIN_DIRSIZE     = CDirEntry::MIN_DIRSIZE,
        MAX_DIRSIZE     = CDirEntry::MAX_DIRSIZE,
        NAME_SIZE       = 16,
    };


private:

    // Miscellaneous helper functions

    // Convert a hash signature to a bucket address
    inline DWORD _BucketAddress(DWORD dwSignature) const
    {
        DWORD dwBktAddr = _H0(dwSignature);
        // Has this bucket been split already?
        if (dwBktAddr < m_iExpansionIdx)
            dwBktAddr = _H1(dwSignature);
        IRTLASSERT(dwBktAddr < m_cActiveBuckets);
        IRTLASSERT(dwBktAddr < (m_cDirSegs << m_dwSegBits));
        return dwBktAddr;
    }

    // See the Linear Hashing paper
    static DWORD _H0(DWORD dwSignature, DWORD dwBktAddrMask)
    { return dwSignature & dwBktAddrMask; }

    DWORD        _H0(DWORD dwSignature) const
    { return _H0(dwSignature, m_dwBktAddrMask0); }

    // See the Linear Hashing paper.  Preserves one bit more than _H0.
    static DWORD _H1(DWORD dwSignature, DWORD dwBktAddrMask)
    { return dwSignature & ((dwBktAddrMask << 1) | 1); }

    DWORD        _H1(DWORD dwSignature) const
    { return _H0(dwSignature, m_dwBktAddrMask1); }

    // In which segment within the directory does the bucketaddress lie?
    // (Return type must be lvalue so that it can be assigned to.)
    CSegment*&   _Segment(DWORD dwBucketAddr) const
    {
        const DWORD iSeg = dwBucketAddr >> m_dwSegBits;
        IRTLASSERT(m_paDirSegs != NULL  &&  iSeg < m_cDirSegs);
        return m_paDirSegs[iSeg].m_pseg;
    }

    // Offset within the segment of the bucketaddress
    DWORD        _SegIndex(DWORD dwBucketAddr) const
    { return (dwBucketAddr & m_dwSegMask); }

    // Convert a bucketaddress to a CBucket*
    inline CBucket* _Bucket(DWORD dwBucketAddr) const
    {
        IRTLASSERT(dwBucketAddr < m_cActiveBuckets);
        CSegment* const pseg = _Segment(dwBucketAddr);
        IRTLASSERT(pseg != NULL);
        return &(pseg->Slot(_SegIndex(dwBucketAddr)));
    }

    // Extract the key from a record
    const DWORD_PTR  _ExtractKey(const void* pvRecord) const
    {
        IRTLASSERT(pvRecord != NULL);
        IRTLASSERT(m_pfnExtractKey != NULL);
        return (*m_pfnExtractKey)(pvRecord);
    }

    // Hash the key
    DWORD        _CalcKeyHash(const DWORD_PTR pnKey) const
    {
        // Note pnKey==0 is acceptable, as the real key type could be an int
        IRTLASSERT(m_pfnCalcKeyHash != NULL);
        DWORD dwHash = (*m_pfnCalcKeyHash)(pnKey);
        // We forcibly scramble the result to help ensure a better distribution
#ifdef HASH_RANDOMIZE_BITS
        dwHash = RandomizeBits(dwHash);
#else // !HASH_RANDOMIZE_BITS
        dwHash = HashScramble(dwHash);
#endif // !HASH_RANDOMIZE_BITS
        IRTLASSERT(dwHash != HASH_INVALID_SIGNATURE);
        return dwHash;
    }

    // Compare two keys for equality
    bool       _EqualKeys(const DWORD_PTR pnKey1, const DWORD_PTR pnKey2) const
    {
        IRTLASSERT(m_pfnEqualKeys != NULL);
        return (*m_pfnEqualKeys)(pnKey1, pnKey2);
    }

    // AddRef or Release a record.
    void         _AddRefRecord(const void* pvRecord, int nIncr) const
    {
        IRTLASSERT(pvRecord != NULL  &&  (nIncr == -1  ||  nIncr == +1));
        IRTLASSERT(m_pfnAddRefRecord != NULL);
        (*m_pfnAddRefRecord)(pvRecord, nIncr);
    }

    // Find a bucket, given its signature.
    CBucket*     _FindBucket(DWORD dwSignature, bool fLockForWrite) const;

    // Used by _FindKey so that the thread won't deadlock if the user has
    // already explicitly called table->WriteLock().
    bool _ReadOrWriteLock() const
    { return m_Lock.ReadOrWriteLock(); }

    void _ReadOrWriteUnlock(bool fReadLocked) const
    { m_Lock.ReadOrWriteUnlock(fReadLocked); }

    // Memory allocation wrappers to allow us to simulate allocation
    // failures during testing
    static CDirEntry* const
    _AllocateSegmentDirectory(
        size_t n);

    static bool
    _FreeSegmentDirectory(
        CDirEntry* paDirSegs);

    static CNodeClump* const
    _AllocateNodeClump();

    static bool
    _FreeNodeClump(
        CNodeClump* pnc);

    CSegment* const
    _AllocateSegment() const;

    bool
    _FreeSegment(
        CSegment* pseg) const;

#ifdef LOCK_INSTRUMENTATION
    static LONG sm_cTables;

    static const char*
    _LockName()
    {
        LONG l = ++sm_cTables;
        // possible race condition but we don't care, as this is never
        // used in production code
        static char s_szName[CLockStatistics::L_NAMELEN];
        wsprintf(s_szName, "LH%05x", 0xFFFFF & l);
        return s_szName;
    }

    // Statistics for the table lock
    CLockStatistics _LockStats() const
    { return m_Lock.Statistics(); }
#endif // LOCK_INSTRUMENTATION

private:

    // Fields are ordered so as to minimize number of cache lines touched

    DWORD         m_dwSignature;    // debugging: id & corruption check
    CHAR          m_szName[NAME_SIZE];  // an identifier for debugging
    mutable LK_RETCODE m_lkrcState; // Internal state of table
    mutable TableLock m_Lock;       // Lock on entire linear hash table

    // type-specific function pointers
    PFnExtractKey   m_pfnExtractKey;    // Extract key from record
    PFnCalcKeyHash  m_pfnCalcKeyHash;   // Calculate hash signature of key
    PFnEqualKeys    m_pfnEqualKeys;     // Compare two keys
    PFnAddRefRecord m_pfnAddRefRecord;  // AddRef a record

    LK_TABLESIZE  m_lkts;           // "size" of table: small, medium, or large
    DWORD         m_dwSegBits;      // C{Small,Medium,Large}Segment::SEGBITS
    DWORD         m_dwSegSize;      // C{Small,Medium,Large}Segment::SEGSIZE
    DWORD         m_dwSegMask;      // C{Small,Medium,Large}Segment::SEGMASK
    double        m_MaxLoad;        // max load factor (average chain length)

    DWORD         m_dwBktAddrMask0; // mask used for address calculation
    DWORD         m_dwBktAddrMask1; // used in _H1 calculation
    DWORD         m_iExpansionIdx;  // address of next bucket to be expanded
    CDirEntry*    m_paDirSegs;      // directory of table segments
    DWORD         m_nLevel;         // number of table doublings performed
    DWORD         m_cDirSegs;       // segment directory size: varies between
                                    // MIN_DIRSIZE and MAX_DIRSIZE
    DWORD         m_cRecords;       // number of records in the table
    DWORD         m_cActiveBuckets; // number of buckets in use (table size)

    WORD          m_wBucketLockSpins;// default spin count for bucket locks

    const BYTE    m_nTableLockType; // for debugging: LOCK_SPINLOCK, etc
    const BYTE    m_nBucketLockType;// for debugging: LOCK_SPINLOCK, etc
    const CLKRHashTable* const m_phtParent;// Owning table. NULL => standalone

#ifndef LKR_NO_GLOBAL_LIST
    static CLockedDoubleList sm_llGlobalList;// All active CLKRLinearHashTables
    CListEntry    m_leGlobalList;
#endif // !LKR_NO_GLOBAL_LIST

    void        _InsertThisIntoGlobalList()
    {
#ifndef LKR_NO_GLOBAL_LIST
        // Only add standalone CLKRLinearHashTables to global list.
        // CLKRHashTables have their own global list.
        if (m_phtParent == NULL)
            sm_llGlobalList.InsertHead(&m_leGlobalList);
#endif // !LKR_NO_GLOBAL_LIST
    }

    void        _RemoveThisFromGlobalList()
    {
#ifndef LKR_NO_GLOBAL_LIST
        if (m_phtParent == NULL)
            sm_llGlobalList.RemoveEntry(&m_leGlobalList);
#endif // !LKR_NO_GLOBAL_LIST
    }

    // Non-trivial implementation functions
    LK_RETCODE   _InsertRecord(const void* pvRecord, DWORD dwSignature,
                               bool fOverwrite);
    LK_RETCODE   _DeleteKey(const DWORD_PTR pnKey, DWORD dwSignature);
    LK_RETCODE   _DeleteRecord(const void* pvRecord, DWORD dwSignature);
    bool         _DeleteNode(CBucket* pbkt, CNodeClump*& rpnc,
                             CNodeClump*& rpncPrev, int& riNode);
    LK_RETCODE   _FindKey(const DWORD_PTR pnKey, DWORD dwSignature,
                          const void** ppvRecord) const;
    LK_RETCODE   _FindRecord(const void* pvRecord, DWORD dwSignature) const;

    // returns count of errors in compacted state => 0 is good
    int          _IsNodeCompact(CBucket* const pbkt) const;


#ifdef LKR_DEPRECATED_ITERATORS
    // Predicate functions
    static LK_PREDICATE WINAPI
    _PredTrue(const void* /*pvRecord*/, void* /*pvState*/)
    { return LKP_PERFORM; }

    DWORD        _Apply(PFnRecordAction pfnAction, void* pvState,
                        LK_LOCKTYPE lkl, LK_PREDICATE& rlkp);
    DWORD        _ApplyIf(PFnRecordPred   pfnPredicate,
                          PFnRecordAction pfnAction, void* pvState,
                          LK_LOCKTYPE lkl, LK_PREDICATE& rlkp);
    DWORD        _DeleteIf(PFnRecordPred pfnPredicate, void* pvState,
                           LK_PREDICATE& rlkp);
#endif // LKR_DEPRECATED_ITERATORS

    void         _Clear(bool fShrinkDirectory);
    void         _SetSegVars(LK_TABLESIZE lkts);
    LK_RETCODE   _Expand();
    LK_RETCODE   _Contract();
    LK_RETCODE   _SplitRecordSet(CNodeClump* pncOldTarget,
                                 CNodeClump* pncNewTarget,
                                 DWORD       iExpansionIdx,
                                 DWORD       dwBktAddrMask,
                                 DWORD       dwNewBkt,
                                 CNodeClump* pncFreeList);
    LK_RETCODE   _MergeRecordSets(CBucket*    pbktNewTarget,
                                  CNodeClump* pncOldList,
                                  CNodeClump* pncFreeList);

    // Private copy ctor and op= to prevent compiler synthesizing them.
    // Must provide a (bad) implementation because we export instantiations.
    // TODO: implement these properly; they could be useful.
    CLKRLinearHashTable(const CLKRLinearHashTable&)
        : m_dwSignature(SIGNATURE_FREE)
#ifdef LOCK_INSTRUMENTATION
        , m_Lock(NULL)
#endif // LOCK_INSTRUMENTATION
        , m_nTableLockType(0),
          m_nBucketLockType(0),
          m_phtParent(NULL)
    {*(BYTE*)NULL;}

    CLKRLinearHashTable& operator=(const CLKRLinearHashTable&)
    {return *(CLKRLinearHashTable*)NULL;}

private:
    // This ctor is used by CLKRHashTable
    CLKRLinearHashTable(
        LPCSTR          pszName,        // An identifier for debugging
        PFnExtractKey   pfnExtractKey,  // Extract key from record
        PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
        PFnEqualKeys    pfnEqualKeys,   // Compare two keys
        PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
        double          maxload,        // Upperbound on average chain length
        DWORD           initsize,       // Initial size of hash table.
        CLKRHashTable*  phtParent       // Owning table.
        );

    LK_RETCODE
    _Initialize(
        PFnExtractKey   pfnExtractKey,
        PFnCalcKeyHash  pfnCalcKeyHash,
        PFnEqualKeys    pfnEqualKeys,
        PFnAddRefRecord pfnAddRefRecord,
        LPCSTR          pszName,
        double          maxload,
        DWORD           initsize);

public:
    CLKRLinearHashTable(
        LPCSTR          pszName,        // An identifier for debugging
        PFnExtractKey   pfnExtractKey,  // Extract key from record
        PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
        PFnEqualKeys    pfnEqualKeys,   // Compare two keys
        PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
        double   maxload=LK_DFLT_MAXLOAD,// Upperbound on average chain length
        DWORD    initsize=LK_DFLT_INITSIZE, // Initial size of hash table.
        DWORD    num_subtbls=LK_DFLT_NUM_SUBTBLS  // for signature compatiblity
                                                  // with CLKRHashTable
        );

    ~CLKRLinearHashTable();

    static const char* ClassName()           {return "CLKRLinearHashTable";}
    int                NumSubTables() const  {return 1;}

    static LK_TABLESIZE NumSubTables(DWORD& rinitsize, DWORD& rnum_subtbls);

    // Insert a new record into hash table.
    // Returns LK_SUCCESS if all OK, LK_KEY_EXISTS if same key already
    // exists (unless fOverwrite), LK_ALLOC_FAIL if out of space,
    // or LK_BAD_RECORD for a bad record.
    LK_RETCODE     InsertRecord(const void* pvRecord, bool fOverwrite=false)
    {
        if (!IsUsable())
            return m_lkrcState;

        if (pvRecord == NULL)
            return LK_BAD_RECORD;
        
        return _InsertRecord(pvRecord, _CalcKeyHash(_ExtractKey(pvRecord)),
                             fOverwrite);
    }

    // Delete record with the given key.
    // Returns LK_SUCCESS if all OK, or LK_NO_SUCH_KEY if not found
    LK_RETCODE     DeleteKey(const DWORD_PTR pnKey)
    {
        if (!IsUsable())
            return m_lkrcState;
        
        return _DeleteKey(pnKey, _CalcKeyHash(pnKey));
    }

    // Delete a record from the table, if present.
    // Returns LK_SUCCESS if all OK, or LK_NO_SUCH_KEY if not found
    LK_RETCODE     DeleteRecord(const void* pvRecord)
    {
        if (!IsUsable())
            return m_lkrcState;

        if (pvRecord == NULL)
            return LK_BAD_RECORD;
        
        return _DeleteRecord(pvRecord, _CalcKeyHash(_ExtractKey(pvRecord)));
    }

    // Find record with given key.
    // Returns:  LK_SUCCESS, if record found (record is returned in *ppvRecord)
    //           LK_BAD_RECORD, if ppvRecord is invalid
    //           LK_NO_SUCH_KEY, if no record with given key value was found
    //           LK_UNUSABLE, if hash table not in usable state
    // Note: the record is AddRef'd.  You must decrement the reference
    // count when you are finished with the record (if you're implementing
    // refcounting semantics).
    LK_RETCODE     FindKey(const DWORD_PTR pnKey,
                           const void** ppvRecord) const
    {
        if (!IsUsable())
            return m_lkrcState;
        
        if (ppvRecord == NULL)
            return LK_BAD_RECORD;
        
        return _FindKey(pnKey, _CalcKeyHash(pnKey), ppvRecord);
    }

    // Sees if the record is contained in the table
    // Returns:  LK_SUCCESS, if record found
    //           LK_BAD_RECORD, if pvRecord is invalid
    //           LK_NO_SUCH_KEY, if record is not in the table
    //           LK_UNUSABLE, if hash table not in usable state
    // Note: the record is *not* AddRef'd.
    LK_RETCODE     FindRecord(const void* pvRecord) const
    {
        if (!IsUsable())
            return m_lkrcState;

        if (pvRecord == NULL)
            return LK_BAD_RECORD;
        
        return _FindRecord(pvRecord, _CalcKeyHash(_ExtractKey(pvRecord)));
    }

#ifdef LKR_DEPRECATED_ITERATORS
    // Walk the hash table, applying pfnAction to all records.
    // Locks the whole table for the duration with either a (possibly
    // shared) readlock or a writelock, according to lkl.
    // Loop is aborted if pfnAction returns LKA_ABORT.
    // Returns the number of successful applications.
    DWORD          Apply(PFnRecordAction pfnAction,
                         void*           pvState=NULL,
                         LK_LOCKTYPE     lkl=LKL_READLOCK);

    // Walk the hash table, applying pfnAction to any records that match
    // pfnPredicate.  Locks the whole table for the duration with either
    // a (possibly shared) readlock or a writelock, according to lkl.
    // Loop is aborted if pfnAction returns LKA_ABORT.
    // Returns the number of successful applications.
    DWORD          ApplyIf(PFnRecordPred   pfnPredicate,
                           PFnRecordAction pfnAction,
                           void*           pvState=NULL,
                           LK_LOCKTYPE     lkl=LKL_READLOCK);

    // Delete any records that match pfnPredicate.
    // Locks the table for the duration with a writelock.
    // Returns the number of deletions.
    //
    // Do *not* walk the hash table by hand with an iterator and call
    // DeleteKey.  The iterator will end up pointing to garbage.
    DWORD          DeleteIf(PFnRecordPred pfnPredicate,
                            void*         pvState=NULL);
#endif // LKR_DEPRECATED_ITERATORS

    // Check table for consistency.  Returns 0 if okay, or the number of
    // errors otherwise.
    int            CheckTable() const;

    // Remove all data from the table
    void           Clear()
    {
        WriteLock();
        _Clear(true);
        WriteUnlock();
    }

    // Number of elements in the table
    DWORD          Size() const
    { return m_cRecords; }

    // Maximum possible number of elements in the table
    DWORD          MaxSize() const
    { return static_cast<DWORD>(m_MaxLoad * MAX_DIRSIZE * m_dwSegSize); }

    // Get hash table statistics
    CLKRHashTableStats GetStatistics() const;

    // Is the hash table usable?
    bool           IsUsable() const
    { return (m_lkrcState == LK_SUCCESS); }
    
    // Is the hash table consistent and correct?
    bool           IsValid() const
    {
        bool f = (m_lkrcState == LK_SUCCESS     // serious internal failure?
                  &&  m_paDirSegs != NULL
                  &&  (MIN_DIRSIZE & (MIN_DIRSIZE-1)) == 0  // == (1 << N)
                  &&  (MAX_DIRSIZE & (MAX_DIRSIZE-1)) == 0
                  &&  MAX_DIRSIZE > MIN_DIRSIZE
                  &&  MIN_DIRSIZE <= m_cDirSegs  &&  m_cDirSegs <= MAX_DIRSIZE
                  &&  (m_cDirSegs & (m_cDirSegs-1)) == 0
                  &&  m_pfnExtractKey != NULL
                  &&  m_pfnCalcKeyHash != NULL
                  &&  m_pfnEqualKeys != NULL
                  &&  m_cActiveBuckets > 0
                  &&  ValidSignature()
                  );
        if (!f)
            m_lkrcState = LK_UNUSABLE;
        return f;
    }

    // Set the spin count on the table lock
    void        SetTableLockSpinCount(WORD wSpins)
    { m_Lock.SetSpinCount(wSpins); }

    // Get the spin count on the table lock
    WORD        GetTableLockSpinCount()
    { return m_Lock.GetSpinCount(); }

    // Set/Get the spin count on the bucket locks
    void        SetBucketLockSpinCount(WORD wSpins);
    WORD        GetBucketLockSpinCount();

    enum {
        SIGNATURE =      (('L') | ('K' << 8) | ('L' << 16) | ('H' << 24)),
        SIGNATURE_FREE = (('L') | ('K' << 8) | ('L' << 16) | ('x' << 24)),
    };

    bool
    ValidSignature() const
    { return m_dwSignature == SIGNATURE;}


    // Lock manipulators

    // Lock the table (exclusively) for writing
    void        WriteLock()
    { m_Lock.WriteLock(); }

    // Lock the table (possibly shared) for reading
    void        ReadLock() const
    { m_Lock.ReadLock(); }

    // Unlock the table for writing
    void        WriteUnlock() const
    { m_Lock.WriteUnlock(); }

    // Unlock the table for reading
    void        ReadUnlock() const
    { m_Lock.ReadUnlock(); }

    // Is the table already locked for writing?
    bool        IsWriteLocked() const
    { return m_Lock.IsWriteLocked(); }

    // Is the table already locked for reading?
    bool        IsReadLocked() const
    { return m_Lock.IsReadLocked(); }

    // Is the table unlocked for writing?
    bool        IsWriteUnlocked() const
    { return m_Lock.IsWriteUnlocked(); }

    // Is the table unlocked for reading?
    bool        IsReadUnlocked() const
    { return m_Lock.IsReadUnlocked(); }

    // Convert the read lock to a write lock
    void  ConvertSharedToExclusive() const
    { m_Lock.ConvertSharedToExclusive(); }

    // Convert the write lock to a read lock
    void  ConvertExclusiveToShared() const
    { m_Lock.ConvertExclusiveToShared(); }

    // LKRHASH_ALLOCATOR_DEFINITIONS(CLKRLinearHashTable);

public:

#ifdef LKR_DEPRECATED_ITERATORS
    // Iterators can be used to walk the table.  To ensure a consistent
    // view of the data, the iterator locks the whole table.  This can
    // have a negative effect upon performance, because no other thread
    // can do anything with the table.  Use with care.
    //
    // You should not use an iterator to walk the table, calling DeleteKey,
    // as the iterator will end up pointing to garbage.
    //
    // Use Apply, ApplyIf, or DeleteIf instead of iterators to safely
    // walk the tree.
    //
    // Note that iterators acquire a reference to the record pointed to
    // and release that reference as soon as the iterator is incremented.
    // In other words, this code is safe:
    //     lkrc = ht.IncrementIterator(&iter);
    //     // assume lkrc == LK_SUCCESS for the sake of this example
    //     CMyHashTable::Record* pRec = iter.Record();
    //     Foo(pRec);  // uses pRec but doesn't hang on to it
    //     lkrc = ht.IncrementIterator(&iter);
    //
    // But this code is not safe because pRec is used out of the scope of the
    // iterator that provided it:
    //     lkrc = ht.IncrementIterator(&iter);
    //     CMyHashTable::Record* pRec = iter.Record();
    //     // Broken code: Should have called ht.AddRefRecord(pRec, +1) here
    //     lkrc = ht.IncrementIterator(&iter);
    //     Foo(pRec);   // Unsafe: because no longer have a valid reference
    //
    // If record has no reference-counting semantics, then you can ignore
    // the above remarks about scope.


    class CIterator
    {
    protected:
        friend class CLKRLinearHashTable;

        CLKRLinearHashTable* m_plht;        // which linear hash table?
        DWORD               m_dwBucketAddr; // bucket index
        CNodeClump*         m_pnc;          // a CNodeClump in bucket
        int                 m_iNode;        // offset within m_pnc
        LK_LOCKTYPE         m_lkl;          // readlock or writelock?

    private:
        // Private copy ctor and op= to prevent compiler synthesizing them.
        // Must provide (bad) implementation because we export instantiations.
        CIterator(const CIterator&)             {*(BYTE*)NULL;}
        CIterator& operator=(const CIterator&)  {return *(CIterator*)NULL;}

    public:
        CIterator(
            LK_LOCKTYPE lkl=LKL_WRITELOCK)
            : m_plht(NULL),
              m_dwBucketAddr(0),
              m_pnc(NULL),
              m_iNode(-1),
              m_lkl(lkl)
        {}

        // Return the record associated with this iterator
        const void* Record() const
        {
            IRTLASSERT(IsValid());

            return ((m_pnc != NULL
                        &&  m_iNode >= 0
                        &&  m_iNode < CLKRLinearHashTable::NODES_PER_CLUMP)
                    ?  m_pnc->m_pvNode[m_iNode]
                    :  NULL);
        }

        // Return the key associated with this iterator
        const DWORD_PTR Key() const
        {
            IRTLASSERT(m_plht != NULL);
            const void* pRec = Record();
            return ((pRec != NULL  &&  m_plht != NULL)
                    ?  m_plht->_ExtractKey(pRec)
                    :  NULL);
        }

        bool IsValid() const
        {
            return ((m_plht != NULL)
                    &&  (m_pnc != NULL)
                    &&  (0 <= m_iNode
                         &&  m_iNode < CLKRLinearHashTable::NODES_PER_CLUMP)
                    &&  (!m_pnc->IsEmptyNode(m_iNode)));
        }

        // Delete the record that the iterator points to.  Does an implicit
        // IncrementIterator after deletion.
        LK_RETCODE     DeleteRecord();

        // Change the record that the iterator points to.  The new record
        // must have the same key as the old one.
        LK_RETCODE     ChangeRecord(const void* pNewRec);
    };

    // Const iterators for readonly access.  You must use these with
    // const CLKRLinearHashTables.
    class CConstIterator : public CIterator
    {
    private:
        // Private, unimplemented copy ctor and op= to prevent
        // compiler synthesizing them.
        CConstIterator(const CConstIterator&);
        CConstIterator& operator=(const CConstIterator&);

    public:
        CConstIterator()
            : CIterator(LKL_READLOCK)
        {}
    };

private:
    // The public APIs lock the table.  The private ones, which are used
    // directly by CLKRHashTable, don't.
    LK_RETCODE     _InitializeIterator(CIterator* piter);
    LK_RETCODE     _CloseIterator(CIterator* piter);

public:
    // Initialize the iterator to point to the first item in the hash table
    // Returns LK_SUCCESS, LK_NO_MORE_ELEMENTS, or LK_BAD_ITERATOR.
    LK_RETCODE     InitializeIterator(CIterator* piter)
    {
        IRTLASSERT(piter != NULL  &&  piter->m_plht == NULL);
        if (piter == NULL  ||  piter->m_plht != NULL)
            return LK_BAD_ITERATOR;

        if (piter->m_lkl == LKL_WRITELOCK)
            WriteLock();
        else
            ReadLock();

        return _InitializeIterator(piter);
    }

    // The const iterator version
    LK_RETCODE     InitializeIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_plht == NULL);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_plht != NULL
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        ReadLock();
        return const_cast<CLKRLinearHashTable*>(this)
                    ->_InitializeIterator(static_cast<CIterator*>(piter));
    }

    // Move the iterator on to the next item in the table.
    // Returns LK_SUCCESS, LK_NO_MORE_ELEMENTS, or LK_BAD_ITERATOR.
    LK_RETCODE     IncrementIterator(CIterator* piter);

    LK_RETCODE     IncrementIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_plht == this);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_plht != this
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        return const_cast<CLKRLinearHashTable*>(this)
                    ->IncrementIterator(static_cast<CIterator*>(piter));
    }

    // Close the iterator.
    LK_RETCODE     CloseIterator(CIterator* piter)
    {
        IRTLASSERT(piter != NULL  &&  piter->m_plht == this);
        if (piter == NULL  ||  piter->m_plht != this)
            return LK_BAD_ITERATOR;
        _CloseIterator(piter);

        if (piter->m_lkl == LKL_WRITELOCK)
            WriteUnlock();
        else
            ReadUnlock();

        return LK_SUCCESS;
    };

    // Close the CConstIterator
    LK_RETCODE     CloseIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_plht == this);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_plht != this
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        const_cast<CLKRLinearHashTable*>(this)
             ->_CloseIterator(static_cast<CIterator*>(piter));

        ReadUnlock();
        return LK_SUCCESS;
    };
#endif // LKR_DEPRECATED_ITERATORS
};



//--------------------------------------------------------------------
// CLKRHashTable
//
// To improve concurrency, a hash table is divided into a number of
// (independent) subtables. Each subtable is a linear hash table. The
// number of subtables is defined when the table is created and remains
// fixed thereafter. Records are assigned to subtables based on their
// hashed key.
//
// For small or low-contention hashtables, you can bypass this
// thin wrapper and use CLKRLinearHashTable directly.  The methods are
// documented in the declarations for CLKRHashTable (above).
//--------------------------------------------------------------------

class IRTL_DLLEXP CLKRHashTable
{
private:
    typedef CLKRLinearHashTable SubTable;

public:
    typedef SubTable::TableLock  TableLock;
    typedef SubTable::BucketLock BucketLock;

#ifdef LKR_DEPRECATED_ITERATORS
    class CIterator;
    friend class CLKRHashTable::CIterator;
#endif // LKR_DEPRECATED_ITERATORS

    // aliases for convenience
    enum {
        NAME_SIZE = SubTable::NAME_SIZE,
        HASH_INVALID_SIGNATURE = SubTable::HASH_INVALID_SIGNATURE,
        NODES_PER_CLUMP = SubTable::NODES_PER_CLUMP,
    };

private:
    // Hash table parameters
    DWORD          m_dwSignature;   // debugging: id & corruption check
    CHAR           m_szName[NAME_SIZE]; // an identifier for debugging
    DWORD          m_cSubTables;    // number of subtables
    SubTable**     m_palhtDir;      // array of subtables

    // type-specific function pointers
    PFnExtractKey  m_pfnExtractKey;
    PFnCalcKeyHash m_pfnCalcKeyHash;
    mutable LK_RETCODE m_lkrcState;     // Internal state of table
#ifdef LKR_SUBTABLE_MASK
    int            m_nSubTableMask;
#endif // LKR_SUBTABLE_MASK

#ifndef LKR_NO_GLOBAL_LIST
    static CLockedDoubleList sm_llGlobalList; // All active CLKRHashTables
    CListEntry     m_leGlobalList;
#endif // !LKR_NO_GLOBAL_LIST

    void
    _InsertThisIntoGlobalList()
    {
#ifndef LKR_NO_GLOBAL_LIST
        sm_llGlobalList.InsertHead(&m_leGlobalList);
#endif // !LKR_NO_GLOBAL_LIST
    }

    void
    _RemoveThisFromGlobalList()
    {
#ifndef LKR_NO_GLOBAL_LIST
        sm_llGlobalList.RemoveEntry(&m_leGlobalList);
#endif // !LKR_NO_GLOBAL_LIST
    }

    LKRHASH_GLOBAL_LOCK_DECLARATIONS();

    // Private copy ctor and op= to prevent compiler synthesizing them.
    // Must provide a (bad) implementation because we export instantiations.
    // TODO: implement these properly; they could be useful.
    CLKRHashTable(const CLKRHashTable&)             {*(BYTE*)NULL;}
    CLKRHashTable& operator=(const CLKRHashTable&)  {return *(CLKRHashTable*)NULL;}


    // Extract the key from the record
    const DWORD_PTR  _ExtractKey(const void* pvRecord) const
    {
        IRTLASSERT(pvRecord != NULL);
        IRTLASSERT(m_pfnExtractKey != NULL);
        return (*m_pfnExtractKey)(pvRecord);
    }

    // Hash the key
    DWORD        _CalcKeyHash(const DWORD_PTR pnKey) const
    {
        // Note pnKey==0 is acceptable, as the real key type could be an int
        IRTLASSERT(m_pfnCalcKeyHash != NULL);
        DWORD dwHash = (*m_pfnCalcKeyHash)(pnKey);
        // We forcibly scramble the result to help ensure a better distribution
#ifdef HASH_RANDOMIZE_BITS
        dwHash = RandomizeBits(dwHash);
#else // !HASH_RANDOMIZE_BITS
        dwHash = HashScramble(dwHash);
#endif // !HASH_RANDOMIZE_BITS
        IRTLASSERT(dwHash != HASH_INVALID_SIGNATURE);
        return dwHash;
    }

    // Use the key's hash signature to multiplex into a subtable
    SubTable*    _SubTable(DWORD dwSignature) const;

    // Memory allocation wrappers to allow us to simulate allocation
    // failures during testing
    static SubTable** const
    _AllocateSubTableArray(
        size_t n);

    static bool
    _FreeSubTableArray(
        SubTable** palht);

    static SubTable* const
    _AllocateSubTable(
        LPCSTR          pszName,        // An identifier for debugging
        PFnExtractKey   pfnExtractKey,  // Extract key from record
        PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
        PFnEqualKeys    pfnEqualKeys,   // Compare two keys
        PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
        double          maxload,        // Upperbound on average chain length
        DWORD           initsize,       // Initial size of hash table.
        CLKRHashTable*  phtParent       // Owning table.
    );

    static bool
    _FreeSubTable(
        SubTable* plht);

public:
    CLKRHashTable(
        LPCSTR   pszName,               // An identifier for debugging
        PFnExtractKey   pfnExtractKey,  // Extract key from record
        PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
        PFnEqualKeys    pfnEqualKeys,   // Compare two keys
        PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
        double    maxload=LK_DFLT_MAXLOAD,      // bound on avg chain length
        DWORD     initsize=LK_DFLT_INITSIZE,    // Initial size of hash table.
        DWORD     num_subtbls=LK_DFLT_NUM_SUBTBLS  // #subordinate hash tables.
        );

    ~CLKRHashTable();

    static const char* ClassName()           {return "CLKRHashTable";}
    int                NumSubTables() const  {return m_cSubTables;}

    static LK_TABLESIZE NumSubTables(DWORD& rinitsize, DWORD& rnum_subtbls);


    // Thin wrappers for the corresponding methods in CLKRLinearHashTable
    LK_RETCODE     InsertRecord(const void* pvRecord, bool fOverwrite=false);
    LK_RETCODE     DeleteKey(const DWORD_PTR pnKey);
    LK_RETCODE     DeleteRecord(const void* pvRecord);
    LK_RETCODE     FindKey(const DWORD_PTR pnKey,
                           const void** ppvRecord) const;
    LK_RETCODE     FindRecord(const void* pvRecord) const;

#ifdef LKR_DEPRECATED_ITERATORS
    DWORD          Apply(PFnRecordAction pfnAction,
                         void*           pvState=NULL,
                         LK_LOCKTYPE     lkl=LKL_READLOCK);
    DWORD          ApplyIf(PFnRecordPred   pfnPredicate,
                           PFnRecordAction pfnAction,
                           void*           pvState=NULL,
                           LK_LOCKTYPE     lkl=LKL_READLOCK);
    DWORD          DeleteIf(PFnRecordPred pfnPredicate,
                            void*         pvState=NULL);
#endif // LKR_DEPRECATED_ITERATORS

    void           Clear();
    int            CheckTable() const;
    DWORD          Size() const;
    DWORD          MaxSize() const;
    CLKRHashTableStats GetStatistics() const;
    bool           IsValid() const;

    void           SetTableLockSpinCount(WORD wSpins);
    WORD           GetTableLockSpinCount();
    void           SetBucketLockSpinCount(WORD wSpins);
    WORD           GetBucketLockSpinCount();

    enum {
        SIGNATURE =      (('L') | ('K' << 8) | ('H' << 16) | ('T' << 24)),
        SIGNATURE_FREE = (('L') | ('K' << 8) | ('H' << 16) | ('x' << 24)),
    };

    bool
    ValidSignature() const
    { return m_dwSignature == SIGNATURE;}

    // Is the hash table usable?
    bool           IsUsable() const
    { return (m_lkrcState == LK_SUCCESS); }
    
    void        WriteLock();
    void        ReadLock() const;
    void        WriteUnlock() const;
    void        ReadUnlock() const;
    bool        IsWriteLocked() const;
    bool        IsReadLocked() const;
    bool        IsWriteUnlocked() const;
    bool        IsReadUnlocked() const;
    void        ConvertSharedToExclusive() const;
    void        ConvertExclusiveToShared() const;


    // LKRHASH_ALLOCATOR_DEFINITIONS(CLKRHashTable);

public:

#ifdef LKR_DEPRECATED_ITERATORS
    typedef SubTable::CIterator CLHTIterator;

    class CIterator : public CLHTIterator
    {
    protected:
        friend class CLKRHashTable;

        CLKRHashTable*  m_pht;  // which hash table?
        int             m_ist;  // which subtable

    private:
        // Private copy ctor and op= to prevent compiler synthesizing them.
        // Must provide (bad) implementation because we export instantiations.
        CIterator(const CIterator&)             {*(BYTE*)NULL;}
        CIterator& operator=(const CIterator&)  {return *(CIterator*)NULL;}

    public:
        CIterator(
            LK_LOCKTYPE lkl=LKL_WRITELOCK)
            : CLHTIterator(lkl),
              m_pht(NULL),
              m_ist(-1)
        {}

        const void* Record() const
        {
            IRTLASSERT(IsValid());

            // This is a hack to work around a compiler bug.  Calling
            // CLHTIterator::Record calls this function recursively until
            // the stack overflows.
            const CLHTIterator* pBase = static_cast<const CLHTIterator*>(this);
            return pBase->Record();
        }

        const DWORD_PTR Key() const
        {
            IRTLASSERT(IsValid());
            const CLHTIterator* pBase = static_cast<const CLHTIterator*>(this);
            return pBase->Key();
        }

        bool IsValid() const
        {
            const CLHTIterator* pBase = static_cast<const CLHTIterator*>(this);
            return (m_pht != NULL  &&  m_ist >= 0  &&  pBase->IsValid());
        }
    };

    // Const iterators for readonly access
    class CConstIterator : public CIterator
    {
    private:
        // Private, unimplemented copy ctor and op= to prevent
        // compiler synthesizing them.
        CConstIterator(const CConstIterator&);
        CConstIterator& operator=(const CConstIterator&);

    public:
        CConstIterator()
            : CIterator(LKL_READLOCK)
        {}
    };


public:
    LK_RETCODE     InitializeIterator(CIterator* piter);
    LK_RETCODE     IncrementIterator(CIterator* piter);
    LK_RETCODE     CloseIterator(CIterator* piter);

    LK_RETCODE     InitializeIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_pht == NULL);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_pht != NULL
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        return const_cast<CLKRHashTable*>(this)
                ->InitializeIterator(static_cast<CIterator*>(piter));
    }

    LK_RETCODE     IncrementIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_pht == this);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_pht != this
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        return const_cast<CLKRHashTable*>(this)
                ->IncrementIterator(static_cast<CIterator*>(piter));
    }

    LK_RETCODE     CloseIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_pht == this);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_pht != this
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        return const_cast<CLKRHashTable*>(this)
                ->CloseIterator(static_cast<CIterator*>(piter));
    }
#endif // LKR_DEPRECATED_ITERATORS
};



//--------------------------------------------------------------------
// A typesafe wrapper for CLKRHashTable (or CLKRLinearHashTable).
//
// * _Derived must derive from CTypedHashTable and provide certain member
//   functions.  It's needed for various downcasting operations.  See
//   CStringTestHashTable and CNumberTestHashTable below.
// * _Record is the type of the record.  C{Linear}HashTable will store
//   pointers to _Record.
// * _Key is the type of the key.  _Key is used directly; i.e., it is
//   not assumed to be a pointer type.  C{Linear}HashTable assumes that
//   the key is stored in the associated record.  See the comments
//   at the declaration of PFnExtractKey for more details.
//
// (optional parameters):
// * _BaseHashTable is the base hash table: CLKRHashTable or
///   CLKRLinearHashTable
// * _BaseIterator is the iterator type, _BaseHashTable::CIterator
//
// CTypedHashTable could derive directly from CLKRLinearHashTable, if you
// don't need the extra overhead of CLKRHashTable (which is quite low).
//
// You may need to add the following line to your code to disable
// warning messages about truncating extremly long identifiers.
//   #pragma warning (disable : 4786)
//--------------------------------------------------------------------

#define LKRHASH_HACKY_CAST(T, pv)  ((T) (UINT_PTR) (pv))

template < class _Derived, class _Record, class _Key,
           class _BaseHashTable=CLKRHashTable
#ifdef LKR_DEPRECATED_ITERATORS
         , class _BaseIterator=_BaseHashTable::CIterator
#endif // LKR_DEPRECATED_ITERATORS
         >
class CTypedHashTable : public _BaseHashTable
{
public:
    // convenient aliases
    typedef _Derived        Derived;
    typedef _Record         Record;
    typedef _Key            Key;
    typedef _BaseHashTable  BaseHashTable;
    typedef CTypedHashTable<_Derived, _Record, _Key, _BaseHashTable
#ifdef LKR_DEPRECATED_ITERATORS
                            , _BaseIterator
#endif // LKR_DEPRECATED_ITERATORS
                            > HashTable;
#ifdef LKR_DEPRECATED_ITERATORS
    typedef _BaseIterator   BaseIterator;
#endif // LKR_DEPRECATED_ITERATORS

#ifdef LKR_DEPRECATED_ITERATORS
    // ApplyIf() and DeleteIf(): Does the record match the predicate?
    // Note: takes a Record*, not a const Record*.  You can modify the
    // record in Pred() or Action(), if you like, but if you do, you
    // should use LKL_WRITELOCK to lock the table.
    typedef LK_PREDICATE (WINAPI *PFnRecordPred) (Record* pRec, void* pvState);

    // Apply() et al: Perform action on record.
    typedef LK_ACTION   (WINAPI *PFnRecordAction)(Record* pRec, void* pvState);
#endif // LKR_DEPRECATED_ITERATORS

private:

    // Wrappers for the typesafe methods exposed by the derived class

    static const DWORD_PTR WINAPI
    _ExtractKey(const void* pvRecord)
    {
        const _Record* pRec = static_cast<const _Record*>(pvRecord);
        _Key           key  = static_cast<_Key>(_Derived::ExtractKey(pRec));
        return (DWORD_PTR) key;
    }

    static DWORD WINAPI
    _CalcKeyHash(const DWORD_PTR pnKey)
    {
        _Key key = LKRHASH_HACKY_CAST(_Key, pnKey);
        return _Derived::CalcKeyHash(key);
    }

    static bool WINAPI
    _EqualKeys(const DWORD_PTR pnKey1, const DWORD_PTR pnKey2)
    {
        _Key key1 = LKRHASH_HACKY_CAST(_Key, pnKey1);
        _Key key2 = LKRHASH_HACKY_CAST(_Key, pnKey2);
        return _Derived::EqualKeys(key1, key2);
    }

    static void WINAPI
    _AddRefRecord(const void* pvRecord, int nIncr)
    {
        _Record* pRec = static_cast<_Record*>(const_cast<void*>(pvRecord));
        _Derived::AddRefRecord(pRec, nIncr);
    }


#ifdef LKR_DEPRECATED_ITERATORS
    // Typesafe wrappers for Apply, ApplyIf, and DeleteIf.

    class CState
    {
    public:
        PFnRecordPred   m_pfnPred;
        PFnRecordAction m_pfnAction;
        void*           m_pvState;

        CState(
            PFnRecordPred   pfnPred,
            PFnRecordAction pfnAction,
            void*           pvState)
            : m_pfnPred(pfnPred), m_pfnAction(pfnAction), m_pvState(pvState)
        {}
    };

    static LK_PREDICATE WINAPI
    _Pred(const void* pvRecord, void* pvState)
    {
        _Record* pRec = static_cast<_Record*>(const_cast<void*>(pvRecord));
        CState*  pState = static_cast<CState*>(pvState);

        return (*pState->m_pfnPred)(pRec, pState->m_pvState);
    }

    static LK_ACTION WINAPI
    _Action(const void* pvRecord, void* pvState)
    {
        _Record* pRec = static_cast<_Record*>(const_cast<void*>(pvRecord));
        CState*  pState = static_cast<CState*>(pvState);

        return (*pState->m_pfnAction)(pRec, pState->m_pvState);
    }
#endif // LKR_DEPRECATED_ITERATORS

public:
    CTypedHashTable(
        LPCSTR pszName,                       // An identifier for debugging
        double maxload=LK_DFLT_MAXLOAD,       // Upperbound on avg chain length
        DWORD  initsize=LK_DFLT_INITSIZE,     // Initial size of hash table.
        DWORD  num_subtbls=LK_DFLT_NUM_SUBTBLS// #subordinate hash tables.
        )
        : _BaseHashTable(pszName, _ExtractKey, _CalcKeyHash, _EqualKeys,
                            _AddRefRecord, maxload, initsize, num_subtbls)
    {}

    LK_RETCODE   InsertRecord(const _Record* pRec, bool fOverwrite=false)
    { return _BaseHashTable::InsertRecord(pRec, fOverwrite); }

    LK_RETCODE   DeleteKey(const _Key key)
    {
        const void* pvKey = UlongToPtr(key);
        DWORD_PTR   pnKey = reinterpret_cast<DWORD_PTR>(pvKey);
        return _BaseHashTable::DeleteKey(pnKey);
    }
    //{ return _BaseHashTable::DeleteKey(reinterpret_cast<const DWORD_PTR>(key));}

    LK_RETCODE   DeleteRecord(const _Record* pRec)
    { return _BaseHashTable::DeleteRecord(pRec);}

    // Note: returns a _Record**, not a const Record**.  Note that you
    // can use a const type for the template parameter to ensure constness.
    LK_RETCODE   FindKey(const _Key key, _Record** ppRec) const
    {
        if (ppRec == NULL)
            return LK_BAD_RECORD;
        *ppRec = NULL;
        const void* pvRec = NULL;

        const void* pvKey = UlongToPtr(key);

        DWORD_PTR pnKey = reinterpret_cast<DWORD_PTR>(pvKey);
        LK_RETCODE lkrc = _BaseHashTable::FindKey(pnKey, &pvRec);
        *ppRec = static_cast<_Record*>(const_cast<void*>(pvRec));
        return lkrc;
    }

    // Note: returns a _Record**, not a const Record**.  Note that you
    // can use a const type for the template parameter to ensure constness.
    LK_RETCODE   FindKeyBstr(const _Key key, _Record** ppRec) const
    {
        if (ppRec == NULL)
            return LK_BAD_RECORD;
        *ppRec = NULL;
        const void* pvRec = NULL;

        const void* pvKey = key;

        DWORD_PTR pnKey = reinterpret_cast<DWORD_PTR>(pvKey);
        LK_RETCODE lkrc = _BaseHashTable::FindKey(pnKey, &pvRec);
        *ppRec = static_cast<_Record*>(const_cast<void*>(pvRec));
        return lkrc;
    }

    LK_RETCODE   FindRecord(const _Record* pRec) const
    { return _BaseHashTable::FindRecord(pRec);}


    // Other C{Linear}HashTable methods can be exposed without change


#ifdef LKR_DEPRECATED_ITERATORS
    // Typesafe wrappers for Apply et al

    DWORD        Apply(PFnRecordAction pfnAction,
                       void*           pvState=NULL,
                       LK_LOCKTYPE     lkl=LKL_READLOCK)
    {
        IRTLASSERT(pfnAction != NULL);
        if (pfnAction == NULL)
            return 0;

        CState   state(NULL, pfnAction, pvState);
        return   _BaseHashTable::Apply(_Action, &state, lkl);
    }

    DWORD        ApplyIf(PFnRecordPred   pfnPredicate,
                         PFnRecordAction pfnAction,
                         void*           pvState=NULL,
                         LK_LOCKTYPE     lkl=LKL_READLOCK)
    {
        IRTLASSERT(pfnPredicate != NULL  &&  pfnAction != NULL);
        if (pfnPredicate == NULL  ||  pfnAction == NULL)
            return 0;

        CState   state(pfnPredicate, pfnAction, pvState);
        return   _BaseHashTable::ApplyIf(_Pred, _Action, &state, lkl);
    }

    DWORD        DeleteIf(PFnRecordPred pfnPredicate, void* pvState=NULL)
    {
        IRTLASSERT(pfnPredicate != NULL);
        if (pfnPredicate == NULL)
            return 0;

        CState   state(pfnPredicate, NULL, pvState);
        return   _BaseHashTable::DeleteIf(_Pred, &state);
    }


    // Typesafe wrappers for iterators


    class CIterator : public _BaseIterator
    {
    private:
        // Private, unimplemented copy ctor and op= to prevent
        // compiler synthesizing them.
        CIterator(const CIterator&);
        CIterator& operator=(const CIterator&);

    public:
        CIterator(
            LK_LOCKTYPE lkl=LKL_WRITELOCK)
            : _BaseIterator(lkl)
        {}

        _Record*  Record() const
        {
            const _BaseIterator* pBase = static_cast<const _BaseIterator*>(this);
            return reinterpret_cast<_Record*>(const_cast<void*>(
                        pBase->Record()));
        }

        _Key      Key() const
        {
            const _BaseIterator* pBase = static_cast<const _BaseIterator*>(this);
            return reinterpret_cast<_Key>(reinterpret_cast<void*>(pBase->Key()));
        }
    };

    // readonly iterator
    class CConstIterator : public CIterator
    {
    private:
        // Private, unimplemented copy ctor and op= to prevent
        // compiler synthesizing them.
        CConstIterator(const CConstIterator&);
        CConstIterator& operator=(const CConstIterator&);

    public:
        CConstIterator()
            : CIterator(LKL_READLOCK)
        {}

        const _Record*  Record() const
        {
            return CIterator::Record();
        }

        const _Key      Key() const
        {
            return CIterator::Key();
        }
    };


public:
    LK_RETCODE     InitializeIterator(CIterator* piter)
    {
        return _BaseHashTable::InitializeIterator(piter);
    }

    LK_RETCODE     IncrementIterator(CIterator* piter)
    {
        return _BaseHashTable::IncrementIterator(piter);
    }

    LK_RETCODE     CloseIterator(CIterator* piter)
    {
        return _BaseHashTable::CloseIterator(piter);
    }

    LK_RETCODE     InitializeIterator(CConstIterator* piter) const
    {
        return const_cast<HashTable*>(this)
                ->InitializeIterator(static_cast<CIterator*>(piter));
    }

    LK_RETCODE     IncrementIterator(CConstIterator* piter) const
    {
        return const_cast<HashTable*>(this)
                ->IncrementIterator(static_cast<CIterator*>(piter));
    }

    LK_RETCODE     CloseIterator(CConstIterator* piter) const
    {
        return const_cast<HashTable*>(this)
                ->CloseIterator(static_cast<CIterator*>(piter));
    }
#endif // LKR_DEPRECATED_ITERATORS

};



#ifdef __LKRHASH_NAMESPACE__
}
#endif // __LKRHASH_NAMESPACE__


#endif // __LKRHASH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\loginfuncs.h ===
#pragma once
class CUserProfileBase;
//-----------------------------------------------------------------------------
//
//  @doc
//
//  @module loginfuncs.h | Generic login functions.
//
//  Author: Darren Anderson
//
//  Date:   10/10/00
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//
//  @func   This function creates, and sets, the MSPAuth, MSPProf, MSPSec and 
//          MSPDom cookies in the DA domain.  It also creates the MSPAuth and 
//          MSPProf cookies for the partner, and appends them to the return 
//          URL.
//
//          If the bSkipRedirect parameter is false, this function will then
//          throw a CPassportRedirect exception which will end the current
//          request and redirect back to the partner.
//
//          If the bSkipRedirect parameter is true, the final return URL
//          including t=, p= and did= parameters will be returned in the 
//          <p cFullReturnURL> parameter.
//
//          The <p cdbCoreProfile> parameter should already have the user's
//          profile loaded in it.
//
//-----------------------------------------------------------------------------
HRESULT DoPhysical(
    ULONG                   ulSiteID,           // @parm Partner's site id.
    USHORT                  nKeyVersion,        // @parm Partner's key version.
    KPP                     kpp,                // @parm KPP mode.
    LPCWSTR                 szKPPVC,            // @parm KPPVC
    long                    lTimeSkew,          // @parm Time Skew
    LPCSTR                  szReturnURL,        // @parm Return URL
    LPCWSTR                 szMemberName,       // @parm Member Name
    LPCWSTR                 szDomain,           // @parm Member's Domain
    long                    lSkew,              // @parm Session length, 
                                                // MD5Auth only, all others 
                                                // should pass in zero.
    bool                    bSavePassword,
    CPPCoreProfileStorage&  cdbCoreProfile,     // @parm User's core profile	
    bool                    bSkipRedirect,      // @parm If true, no redirect.
    bool                    bSkipPartner,       // @parm If true, DA cookies
                                                // only.
    CPPUrl&                 cFullReturnURL      // Complete return URL
                                                // returned here (only if
                                                // <p bSkipRedirect> is
                                                // true.
    );


void WriteFormAutoPostStart(CHttpResponse *pHttpResponse, LPCSTR szReturnPostUrl);

void WriteFormAutoPostEnd(CHttpResponse *pHttpResponse);

void WriteFormInput(CHttpResponse *pHttpResponse, LPCSTR szName, LPCWSTR szValue);

void WriteFormInput(CHttpResponse *pHttpResponse, LPCSTR szName, LPCSTR szValue);

void WriteFormInput(CHttpResponse *pHttpResponse, LPCSTR szName, long lValue);

void WriteSupplementalPostData(
    CHttpResponse *pHttpResponse,
    CPPUrl  &strReturnUrl,
    LPCWSTR szwMemberName,
    ULONG   ulMemberIdHigh,
    ULONG   ulMemberIdLow,
    ULONG   ulProfileVersion,
    ULONG   ulBdayPrecision,
    DATE    dtBirthdate,
    LPCWSTR szwCountry,
    LPCWSTR szwPostalCode,
    ULONG   ulRegion,
    ULONG   ulLangPref,
    LPCWSTR szwGender,
    LPCWSTR szwPreferredEmail,
    LPCWSTR szwNickname,
    ULONG   ulAccessibility,
    ULONG   ulFlags,
    ULONG   ulWallet,
    ULONG   ulDirectory,
    LPCWSTR szwFirstName,
    LPCWSTR szwLastName,
    LPCWSTR szwOccupation,
    LPCWSTR szwTimeZone,
    long    lSignInTime,
    long    lTicketTime,
    bool    fSavePassword,
    ULONG   ulError,
    long    lSkew,
    bool    fDoPostPassThru = false
    );

void WriteSupplementalPostData(
    CHttpResponse *pHttpResponse,
    CUserProfileBase * cdbCoreProfile,
    CPPUrl  &strReturnUrl,
    LPCWSTR szwMemberName,
    ULONG   ulMemberIdHigh,
    ULONG   ulMemberIdLow,
    long    lSignInTime,
    long    lTicketTime,
    bool    fSavePassword,
    ULONG   ulError,
    long    lSkew,
    bool    fDoPostPassThru = false
    );

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\mspputil.h ===
/*
 -  UTIL.H
 -
 *	Utility library
 *
 */

#ifndef _UTIL_H_
#define _UTIL_H_

#define PROJINTERNAL __stdcall

#endif  // _UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\nexus.h ===
#ifndef __NEXUS_H
#define __NEXUS_H

#include <msxml.h>

#if defined(UNICODE) || defined(_UNICODE)
#define CCDUpdated CCDUpdatedW
#else
#define CCDUpdated CCDUpdatedA
#endif

class ICCDUpdate
{
public:
    virtual void CCDUpdatedA(LPCSTR  pszCCDName, IXMLDocument* piXMLDocument) = 0;
    virtual void CCDUpdatedW(LPCWSTR pszCCDName, IXMLDocument* piXMLDocument) = 0;
};

class IConfigurationUpdate
{
public:
    virtual void LocalConfigurationUpdated(void) = 0;
};


#ifdef __cplusplus
extern "C" {
#endif

HANDLE WINAPI
RegisterCCDUpdateNotification(
    LPCTSTR     pszCCDName,
    ICCDUpdate* piCCDUpdate
    );

BOOL WINAPI
UnregisterCCDUpdateNotification(
    HANDLE  hNotificationHandle
    );

HANDLE WINAPI
RegisterConfigChangeNotification(
    IConfigurationUpdate*   piConfigUpdate
    );

BOOL WINAPI
UnregisterConfigChangeNotification(
    HANDLE  hNotificationHandle
    );

BOOL WINAPI
GetCCD(
    LPCTSTR         pszCCDName,
    IXMLDocument**  ppiStream,
    BOOL            bForceFetch
    );


#ifdef __cplusplus
}
#endif

#endif // __NEXUS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\passportredirect.h ===
// PassportRedirect.h: interface for the CPassportRedirect class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PASSPORTREDIRECT_H__A2A35B12_5D1F_43C0_BC03_05189E612CA9__INCLUDED_)
#define AFX_PASSPORTREDIRECT_H__A2A35B12_5D1F_43C0_BC03_05189E612CA9__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "ppurl.h"

class CPassportRedirect  
{
public:
    CPassportRedirect(LPCSTR pszUrl, ULONG ulFlags, HRESULT hr = 0)
            : m_curlRedirect(pszUrl), m_lFlags(ulFlags), m_hr(hr) {};
    virtual ~CPassportRedirect() {};
	CPPUrl & GetUrl() { return m_curlRedirect; }
	ULONG GetFlags() { return m_lFlags; }
    HRESULT GetHr() { return m_hr; }
protected: 
	CPPUrl m_curlRedirect;
	ULONG m_lFlags;
    HRESULT m_hr;
private:
	CPassportRedirect(CPassportRedirect &) {};
};

#endif // !defined(AFX_PASSPORTREDIRECT_H__A2A35B12_5D1F_43C0_BC03_05189E612CA9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\passportcookiefunctions.h ===
//-----------------------------------------------------------------------------
//
//  @doc
//
//  @module PassportCookieFunctions.h |  Passport specific cookie
//                                       routines.
//
//  Author: Darren Anderson
//
//  Date:   5/19/00
//
//  Copyright <cp> 1999-2000 Microsoft Corporation.  All Rights Reserved.
//
//-----------------------------------------------------------------------------
#pragma once

class CTicket;
class CProfile;
class CPassportHandlerBase;

void SetIdInVisitedSitesCookie(ULONG ulSiteId);
void SetBrowserTestCookie(void);
bool ReadBrowserTestCookie(CPassportHandlerBase *pHandler=NULL);
void SetLastDBWriteCookie();
long ReadLastDBWriteCookie();

// @func	void | GetProfileFromCookie | Get the profile from cookie
// @rdesc	None
void GetProfileFromCookie(CProfile &theProfile);	// @parm	[out]	the profile contained in the cookie

// @func	void | GetTicketFromCookie | Get the ticket from cookie
// @rdesc	None
void GetTicketFromCookie(CTicket &theTicket);		// @parm	[out]	the ticket contained in the cookie

BOOL GetHackCookie(ATL::CHttpRequest* req, LPCSTR name, CStringA& cookie);        // HACK CODE -- to deal with the UP emulator's cooke problem
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\passporttypes.h ===
/*++

    Copyright (c) 1998 Microsoft Corporation

    Module Name:

        PassportTypes.h

    Abstract:

        Header file for brokers and hubs
--*/
#ifndef _PASSPORT_TYPES_H
#define _PASSPORT_TYPES_H

// Max user entry length
#define MAX_MEMBER_PROFILE_LEN      1024

// Field Lengths
#define MAX_MEMBERNAME_LEN   128
#define MAX_CONTACTEMAIL_LEN 128
#define MAX_PASSWORD_LEN     128
#define MAX_POSTALCODE_LEN   64
#define MAX_MEMBERID_LEN     32
#define MAX_MSNGUID_LEN      32
#define MAX_ALIAS_LEN        48
#define MAX_SESSIONKEY_LEN   36 
#define MAX_PROFILEBLOB_LEN  596   // this will be changing as Profile Schema changes...
                                   // we probably should be doing things like this.... 
#define MAX_CACHEKEY_LEN     145

#define PPM_TIMEWINDOW_MIN   20
#define PPM_TIMEWINDOW_MAX   (31 * 24 * 60 * 60 )	// 31 days timewindow

// Gender can be 'M', 'F', or 'U'
typedef char GENDER;

#define MALE 'M'
#define FEMALE 'F'
#define UNSPECIFIED 'U'

// Network Errors
#ifndef NETWORK_ERRORS_DEFINED
#define NETWORK_ERRORS_DEFINED

#define BAD_REQUEST  1
#define OFFLINE      2
#define TIMEOUT      3
#define LOCKED       4
#define NO_PROFILE   5
#define DISASTER     6
#define INVALID_KEY  7

#endif

#define SECURE_FLAG L' '

// Language codes
// English 
#define LANG_EN 0x0409
// German 
#define LANG_DE 0x0407
// Japanese 
#define LANG_JA 0x0411
// Korean 
#define LANG_KO 0x0412
// Traditional Chinese 
#define LANG_TW 0x0404
// Simplified Chinese 
#define LANG_CN 0x804
// French 
#define LANG_FR 0x40c
// Spanish 
#define LANG_ES 0xc0a
// Brazilian 
#define LANG_BR 0x416
// Italian 
#define LANG_IT 0x410
// Dutch 
#define LANG_NL 0x413
// Swedish 
#define LANG_SV 0x41d
// Danish 
#define LANG_DA 0x406
// Finnish 
#define LANG_FI 0x40b
// Hungarian 
#define LANG_HU 0x40e
// Norwegian 
#define LANG_NO 0x414
// Greek 
#define LANG_EL 0x408
// Polish 
#define LANG_PL 0x415
// Russian 
#define LANG_RU 0x419
// Czech 
#define LANG_CZ 0x405
// Portuguese 
#define LANG_PT 0x816
// Turkish 
#define LANG_TR 0x41f
// Slovak 
#define LANG_SK 0x41b
// Slovenian 
#define LANG_SL 0x424
// Arabic 
#define LANG_AR 0x401
// Hebrew 
#define LANG_HE 0x40d

//
//  HRESULTs specific to passport interfaces.
//

#define PP_E_INVALID_MEMBERNAME     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1001)
#define PP_E_INVALID_DOMAIN         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1002)
#define PP_E_ATTRIBUTE_UNDEFINED    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1003)
#define PP_E_SYSTEM_UNAVAILABLE     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1004)
#define PP_E_DOMAIN_MAP_UNAVAILABLE MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1005)
#define PP_E_NO_LOCALFILE           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1006)
#define PP_E_CCD_INVALID            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1007)
#define PP_E_SITE_NOT_EXISTS        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1008)
#define PP_E_NOT_INITIALIZEDED      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1009)
#define PP_E_TYPE_NOT_SUPPORTED     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x100a)

#include "PMErrorCodes.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\partnermanager.h ===
// PartnerManager.h: interface for the CPartnerManager class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PARTNERMANAGER_H__B4189152_B982_11D2_B67D_7C33F3000000__INCLUDED_)
#define AFX_PARTNERMANAGER_H__B4189152_B982_11D2_B67D_7C33F3000000__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CPartnerManager  
{
public:
	CPartnerManager();
	virtual ~CPartnerManager();

};

#endif // !defined(AFX_PARTNERMANAGER_H__B4189152_B982_11D2_B67D_7C33F3000000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\passportexception.h ===
// PassportException.h: interface for the CPassportException class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PASSPORTEXCEPTION_H__7C1CDC20_EF2E_4E6A_B17E_030EAB7A6759__INCLUDED_)
#define AFX_PASSPORTEXCEPTION_H__7C1CDC20_EF2E_4E6A_B17E_030EAB7A6759__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <atlisapi.h>
#include "nsconst.h"
#include "pputils.h"


// The way to use CPassportException
//
//      throw CPassportException(__FILE__, __LINE__, hr, long1, long2, long3)
//
//  1.  don't ever pass anything other than __FILE__, __LINE__ as the first two
//      argument.
//  2.  You may pass some description through compilatime time string
//      concatenation as __FILE__";description".   Make sure ";" is the first
//      character after __FILE__.   
//      A separate description argument is explicit avoided so that
//          a) CPassportException doesn't have to alloc another copy of string.
//          b) or have to worry about freeing things.
//          c) to keep CPassportException very small in size.
//
//
class CPassportException  
{
public:
	CPassportException(LPCSTR szFilename, long lLine, HRESULT hr, 
					long lLong1=0, long lLong2=0, long lLong3=0)
        :	m_szFilename(szFilename), m_lLine(lLine), m_hr(hr), m_lStatus1(lLong1), 
			m_lStatus2(lLong2), m_lStatus3(lLong3),
        	m_pcszQS(NULL), m_pcszPath(NULL)
			{}
    virtual ~CPassportException() {};
	inline LPCSTR GetFilename() { return m_szFilename; }
	inline long GetFilelineno() { return m_lLine; }
	inline HRESULT GetHr() { return m_hr; }
	inline long GetStatus1() { return m_lStatus1; }
	inline long GetStatus2() { return m_lStatus2; }
	inline long GetStatus3() { return m_lStatus3; }
	inline LPCSTR GetQueryString() { return m_pcszQS; }
	inline LPCSTR GetPath() { return m_pcszPath; }
private:
    LPCSTR m_szFilename;
    long m_lLine;
    HRESULT m_hr;
    long m_lStatus1;
    long m_lStatus2;
    long m_lStatus3;
	LPCSTR m_pcszQS;
	LPCSTR m_pcszPath;

public:    
	// @mfunc create a cookie that store the error info in this exception object
	//        along with other info in the passed-in request object. 
	void SaveState(CHttpRequest* req)
	{
		// construct a full URL from req, and store it in cookie 
		m_pcszPath = req->GetPathInfo();
		m_pcszQS = req->GetQueryString();
	}
	void MakeCookie(CHttpRequest* req, //@parm request object
	                CCookie& errinfo   //@parm out, the result cookie 
	                )
	{
        char buff[50]; // max len for _ltoa is 32
		CStringW wTmp;
		CStringA aOut;

		// store exception info into cookie
       	wTmp = m_szFilename;
		::UrlEscapeString(wTmp);
		aOut = wTmp; // ASCII conversion		
		errinfo.AddValue(k_szErrCAttrFilename, aOut);
		_ltoa( m_lLine, buff, 10 );
		errinfo.AddValue(k_szErrCAttrLine, buff);
		_ltoa( m_hr, buff, 16 );
		errinfo.AddValue(k_szErrCAttrHr, buff);
		_ltoa( m_lStatus1, buff, 16 );
		errinfo.AddValue(k_szErrCAttrStatus1, buff);
		_ltoa( m_lStatus2, buff, 16 );
		errinfo.AddValue(k_szErrCAttrStatus2, buff);
		_ltoa( m_lStatus3, buff, 16 );
		errinfo.AddValue(k_szErrCAttrStatus3, buff);

		// construct a full URL from req, and store it in cookie 
		wTmp = req->GetPathInfo();
		LPCSTR qs = req->GetQueryString();
		if ( qs && qs[0] > ' ' ) wTmp = wTmp + L"?" + qs;		
		::UrlEscapeString(wTmp);
		aOut = wTmp; // ASCII conversion
		errinfo.AddValue(k_szErrCAttrTheURL, aOut);
	}
    
};

#endif // !defined(AFX_PASSPORTEXCEPTION_H__7C1CDC20_EF2E_4E6A_B17E_030EAB7A6759__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\paneconst.h ===
PPCONST char*   k_szPPPRegister                  ="reg";
PPCONST char*   k_szPPPRegEASI                   ="ppRegEASI";
PPCONST char*   k_szPPPRegEASIErr                ="ppRegEASIErr";
PPCONST char*   k_szPPPRegEASIcookie             ="ppRegEASIcookie";
PPCONST char*   k_szPPPRegEASIcookieErr          ="ppRegEASIcookieErr";
PPCONST char*   k_szPPPRegHM                     ="ppRegHM";
PPCONST char*   k_szPPPRegHMErr                  ="ppRegHMErr";
PPCONST char*   k_szPPPRegHMAltNames             ="ppRegHMAltNames";
PPCONST char*   k_szPPPRegHMAltNamesErr          ="ppRegHMAltNamesErr";
PPCONST char*   k_szPPPRegCongrats               ="ppRegCongrats";
PPCONST char*   k_szPPPExpLoggedIn               ="ppExpLoggedIn";
PPCONST char*   k_szPPPExpCantBeParent           ="ppExpCantBeParent";
PPCONST char*   k_szPPPExpParentNotLoggedIn      ="ppExpParentNotLoggedIn";
PPCONST char*   k_szPPPExpUnknownSerErr          ="ppExpUnknownSerErr";
PPCONST char*   k_szPPPSecKeyReg                 ="ppSecKeyReg";
PPCONST char*   k_szPPPSecKeyRegErr              ="ppSecKeyRegErr";
PPCONST char*   k_szPPPSecKeyRetype              ="ppSecKeyRetype";
PPCONST char*   k_szPPPSecKeyRetypeErr           ="ppSecKeyRetypeErr";
PPCONST char*   k_szPPPExistingMember            ="ppExistingMember";
PPCONST char*   k_szPPPLogin                     ="ppLogin";
PPCONST char*   k_szPPPLockedOut                 ="ppLockedOut";
PPCONST char*   k_szPPPAcctLocked                ="ppAcctLocked";
PPCONST char*   k_szPPPTooManyRequests           ="ppTooManyReqs";
PPCONST char*   k_szPPPCookiesDisabled           ="ppCookiesDisabled";
PPCONST char*   k_szPPPInvalidSiteID             ="ppInvalidSiteID";
PPCONST char*   k_szPPPNeedBirthdate             ="ppNeedBirthdate";
PPCONST char*   k_szPPPSwitchUser                ="ppSwitchUser";
PPCONST char*   k_szPPPErrMemberNotExist         ="ppErrMemberNotExist";
PPCONST char*   k_szPPPLogout                    ="ppLogout";
PPCONST char*   k_szPPPDelegatedAdmin            ="ppDelegatedAdmin";
PPCONST char*   k_szPPPNeedCred                  ="ppNeedCred";
PPCONST char*   k_szPPPNeedMembername            ="ppNeedMembername";
PPCONST char*   k_szPPPNeedPswd                  ="ppNeedPswd";
PPCONST char*   k_szPPPNeedDomain                ="ppNeedDomain";
PPCONST char*   k_szPPPBadPswd                   ="ppBadPswd";
PPCONST char*   k_szPPPBadChar                   ="ppBadChar";
PPCONST char*   k_szPPPBadMembername             ="ppBadMembername";
PPCONST char*   k_szPPPHMMSNLogin                ="ppHMMSNLogin";
PPCONST char*   k_szPPPChkSpell                  ="ppChkSpell";
PPCONST char*   k_szPPPAddPhone                  ="ppAddPhone";
PPCONST char*   k_szPPPAddPhoneErr               ="ppAddPhoneErr";
PPCONST char*   k_szPPPAddPhoneSucc              ="ppAddPhoneSucc";
PPCONST char*   k_szPPPSecKeySignin              ="ppSecKeySignin";
PPCONST char*   k_szPPPSecInvalidSiteID          ="ppSecInvalidSiteID";
PPCONST char*   k_szPPPSecKeySigninErr           ="ppSecKeySigninErr";
PPCONST char*   k_szPPPSecKeyReset               ="ppSecKeyReset";
PPCONST char*   k_szPPPSecKeyResetErr            ="ppSecKeyResetErr";
PPCONST char*   k_szPPPSecKeyResetLockout        ="ppSecKeyResetLockout";
PPCONST char*   k_szPPPPswdReset1                ="ppPswdReset1";
PPCONST char*   k_szPPPPswdReset1Err             ="ppPswdReset1Err";
PPCONST char*   k_szPPPPswdReset2                ="ppPswdReset2";
PPCONST char*   k_szPPPPswdReset2Err             ="ppPswdReset2Err";
PPCONST char*   k_szPPPPswdResetLockout          ="ppPswdResetLockout";
PPCONST char*   k_szPPPPswdResetSucc             ="ppPswdResetSucc";
PPCONST char*   k_szPPPEmailPswdReset            ="ppEmailPswdReset";
PPCONST char*   k_szPPPEmailPswdResetSent        ="ppEmailPswdResetSent";
PPCONST char*   k_szPPPEmailPswdResetNotSent     ="ppEmailPswdResetNotSent";
PPCONST char*   k_szPPPEmailPswdReset2           ="ppEmailPswdReset2";
PPCONST char*   k_szPPPEmailPswdResetNotPoss     ="ppEmailPswdResetNotPoss";
PPCONST char*   k_szPPPEmailPswdResetCancl       ="ppEmailPswdResetCancl";
PPCONST char*   k_szPPPChangeSQ                  ="ppChangeSQ";
PPCONST char*   k_szPPPChangeSQErr               ="ppChangeSQErr";
PPCONST char*   k_szPPPChangeSQSucc              ="ppChangeSQSucc";
PPCONST char*   k_szPPPChangePW                  ="ppChangePW";
PPCONST char*   k_szPPPChangePWErr               ="ppChangePWErr";
PPCONST char*   k_szPPPChangePWSucc              ="ppChangePWSucc";
PPCONST char*   k_szPPPChangeEmail               ="ppChangeEmail";
PPCONST char*   k_szPPPChangeEmailErr            ="ppChangeEmailErr";
PPCONST char*   k_szPPPChangeEmailSucc           ="ppChangeEmailSucc";
PPCONST char*   k_szPPPForceChangeEmail          ="ppForceChangeEmail";
PPCONST char*   k_szPPPForceChangeEmailErr       ="ppForceChangeEmailErr";
PPCONST char*   k_szPPPChangePhone               ="ppChangePhone";
PPCONST char*   k_szPPPChangePhoneErr            ="ppChangePhoneErr";
PPCONST char*   k_szPPPChangePhoneSucc           ="ppChangePhoneSucc";
PPCONST char*   k_szPPPEditProf                  ="ppEditProf";
PPCONST char*   k_szPPPEditProfErr               ="ppEditProfErr";
PPCONST char*   k_szPPPEditProfHM                ="ppEditProfHM";
PPCONST char*   k_szPPPEditProfErrHM             ="ppEditProfErrHM";
PPCONST char*   k_szPPPEditProfSucc              ="ppEditProfSucc";
PPCONST char*   k_szPPPExpNotLoggedInEditProf    ="ppExpNotLoggedInEditProf";
PPCONST char*   k_szPPPMemServHome               ="ppMemServHome";
PPCONST char*   k_szPPPContactUs                 ="ppContactUs";
PPCONST char*   k_szPPPContactUsSucc             ="ppContactUsSucc";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\nsconst.h ===
//-----------------------------------------------------------------------------
//
//  @doc
//
//  @module nsconst.h | global constants used in Passport network
//
//  Author: Darren Anderson
//          Steve Fu
//
//  Date:   7/24/2000
//
//  Copyright <cp> 1999-2000 Microsoft Corporation.  All Rights Reserved.
//
//-----------------------------------------------------------------------------

#pragma once

#include <atlbase.h>
/* use external linkage to avoid mulitple instances */
#define PPCONST __declspec(selectany) extern const 

#include "paneconst.h"

//
//  Magic numbers.
//

PPCONST ULONG  k_nMaxMemberNameLength   = 129;
PPCONST ULONG  k_nMaxDomainLength       = 64;
PPCONST ULONG  k_nMaxAliasLength        = 64;
PPCONST USHORT k_nDefaultKeyVersion     = 0xFFFF;
PPCONST ULONG  k_nMaxCredsAge           = 2400;
PPCONST ULONG  k_nMD5AuthTimeWindow     = 600;

//
//  Names used to lookup profile items in the profile object.
//

PPCONST CComVariant  k_cvItemNameMemberName(L"membername");
PPCONST CComVariant  k_cvItemNameInternalMemberName(L"internalmembername");
PPCONST CComVariant  k_cvItemNameMemberIdLow(L"memberidlow");
PPCONST CComVariant  k_cvItemNameMemberIdHigh(L"memberidhigh");
PPCONST CComVariant  k_cvItemNameProfileVersion(L"profileversion");
PPCONST CComVariant  k_cvItemNameCountry(L"country");
PPCONST CComVariant  k_cvItemNamePostalCode(L"postalcode");
PPCONST CComVariant  k_cvItemNameRegion(L"region");
PPCONST CComVariant  k_cvItemNameLangPref(L"lang_preference");
PPCONST CComVariant  k_cvItemNameBirthdate(L"birthdate");
PPCONST CComVariant  k_cvItemNameBDayPrecision(L"bday_precision");
PPCONST CComVariant  k_cvItemNameGender(L"gender");
PPCONST CComVariant  k_cvItemNameEmail(L"preferredemail");
PPCONST CComVariant  k_cvItemNameNickname(L"nickname");
PPCONST CComVariant  k_cvItemNameAccessibility(L"accessibility");
PPCONST CComVariant  k_cvItemNameWallet(L"wallet");
PPCONST CComVariant  k_cvItemNameDirectory(L"directory");
PPCONST CComVariant  k_cvItemNameFlags(L"flags");

//
//  Names used to lookup profile items in the database object.
//

PPCONST CComVariant  k_cvDBItemNameMemberIdLow(L"member_id_low");
PPCONST CComVariant  k_cvDBItemNameMemberIdHigh(L"member_id_high");
PPCONST CComVariant  k_cvDBItemNameProfileVersion(L"profile_version");
PPCONST CComVariant  k_cvDBItemNameCountry(L"iso_3166_country_code");
PPCONST CComVariant  k_cvDBItemNamePostalCode(L"postal_code");
PPCONST CComVariant  k_cvDBItemNameRegion(L"region_geoid");
PPCONST CComVariant  k_cvDBItemNameLangPref(L"language_preference_lcid");
PPCONST CComVariant  k_cvDBItemNameBirthdate(L"birthdate");
PPCONST CComVariant  k_cvDBItemNameBDayPrecision(L"birthdate_precision");
PPCONST CComVariant  k_cvDBItemNameGender(L"gender");
PPCONST CComVariant  k_cvDBItemNameEmail(L"contact_email_complete");
PPCONST CComVariant  k_cvDBItemNameNickname(L"nickname");
PPCONST CComVariant  k_cvDBItemNameAccessibility(L"accessibility");
PPCONST CComVariant  k_cvDBItemNameWallet(L"wallet_version");
PPCONST CComVariant  k_cvDBItemNameDirectory(L"directory_version");
PPCONST CComVariant  k_cvDBItemNameFlags(L"flags");
PPCONST CComVariant  k_cvDBItemNameMiscFlags(L"misc_flags");

//
//  Domain attribute names.
//

PPCONST CComVariant  k_cvDefault(L"default");
PPCONST CComVariant  k_cvDomainAttrPassportHome(L"PassportHome");
PPCONST CComVariant  k_cvDomainAttrKidsPassport(L"KidsPassport");
PPCONST CComVariant  k_cvDomainAttrLogout(L"Logout");
PPCONST CComVariant  k_cvDomainAttrAuth(L"Auth");
PPCONST CComVariant  k_cvDomainAttrAuthSecure(L"AuthSecure");
PPCONST CComVariant  k_cvDomainAttrReAuth(L"Reauth");
PPCONST CComVariant  k_cvDomainAttrPost(L"Post");
PPCONST CComVariant  k_cvDomainAttrPostUpdate(L"PostUpdate");
PPCONST CComVariant  k_cvDomainAttrPIC(L"PassportInformationCenter");
PPCONST CComVariant  k_cvDomainAttrRegistration(L"Registration");
PPCONST CComVariant  k_cvDomainAttrDefaultReturn(L"DefaultReturn");
PPCONST CComVariant  k_cvDomainAttrTermsOfUse(L"TermsOfUse");
PPCONST CComVariant  k_cvDomainAttrPrivacyPolicy(L"PrivacyPolicy");
PPCONST CComVariant  k_cvDomainAttrCustomerService(L"CustomerService");
PPCONST CComVariant  k_cvDomainAttrPassportImages(L"PassportImages");
PPCONST CComVariant  k_cvDomainAttrSiteDirectory(L"SiteDirectory");
PPCONST CComVariant  k_cvDomainAttrHelp(L"Help");
PPCONST CComVariant  k_cvDomainAttrMPP(L"MPP");
PPCONST CComVariant  k_cvDomainAttrPasswordOptions(L"PasswordOptions");
PPCONST CComVariant  k_cvDomainAttrPasswordReset(L"PasswordReset");
PPCONST CComVariant  k_cvDomainAttrChangePassword(L"ChangePassword");
PPCONST CComVariant  k_cvDomainAttrChangeSecretQ(L"ChangeSecretQ");
PPCONST CComVariant  k_cvDomainAttrChangeMemName(L"ChangeMemName");
PPCONST CComVariant  k_cvDomainAttrManageConsent(L"ManageConsent");
PPCONST CComVariant	 k_cvDomainAttrEmailPwdReset(L"EmailPwdReset");
PPCONST CComVariant	 k_cvDomainAttrEmailValidating(L"EmailValidating");
PPCONST CComVariant  k_cvDomainAttrChangeLanguage(L"ChangeLanguage");
PPCONST CComVariant  k_cvDomainAttrMobilePin(L"MobilePin");
PPCONST CComVariant  k_cvDomainAttrNoSecretQ(L"NoSecretQ");
PPCONST CComVariant  k_cvDomainAttrEditProfile(L"EditProfile");
PPCONST CComVariant  k_cvDomainAttrContactUs(L"CustomerService");
PPCONST CComVariant  k_cvDomainAttrRevalidateEmailURL(L"RevalidateEmailURL");
PPCONST CComVariant  k_cvDomainAttrXMLLogin(L"XMLLogin");
PPCONST CComVariant  k_cvDomainAttrXMLRegistration(L"XMLRegistration");
PPCONST CComVariant  k_cvDomainAttrXMLProfileRequest(L"XMLProfileRequest");
PPCONST CComVariant  k_cvDomainAttrWallet(L"Wallet");
PPCONST CComVariant  k_cvDomainAttrWalletRoot(L"WalletRoot");
PPCONST CComVariant  k_cvDomainAttrWirelessReg(L"WirelessRegistration");
PPCONST CComVariant  k_cvDomainAttrPinPost(L"PinPost");
PPCONST CComVariant  k_cvDomainAttrPinReg(L"PinReg");
PPCONST CComVariant  k_cvDomainAttrCSSEform(L"CSSEform");
PPCONST CComVariant  k_cvDomainAttrSupplementalAuthUrl(L"SupplementalAuthUrl");
PPCONST CComVariant  k_cvDomainAttrMail(L"Mail");	
PPCONST CComVariant  k_cvDomainHotmailError(L"ErrorLogin");

//
//  Partner attribute names.
//

PPCONST CComVariant  k_cvDefaultReturnUrl(L"DefaultReturnUrl");
PPCONST CComVariant  k_cvPartnerAttrName(L"Name");
PPCONST CComVariant  k_cvPartnerAttrCompanyID(L"CompanyID");
PPCONST CComVariant  k_cvPartnerAttrExpireCookieUrl(L"ExpireCookieURL");
PPCONST CComVariant  k_cvPartnerAttrCobrandCSSUrl(L"CoBrandCSSURL");
PPCONST CComVariant  k_cvPartnerAttrLogoutUrl(L"LogoutURL");
PPCONST CComVariant  k_cvPartnerAttrCoBrandUrl(L"CoBrandURL");
PPCONST CComVariant  k_cvPartnerAttrCoBrandImageUrl(L"CoBrandImageURL");
PPCONST CComVariant  k_cvPartnerAttrCoBrandLogoHREF(L"CoBrandLogoHREF");
PPCONST CComVariant  k_cvPartnerAttrAllowProtectedUpdates(L"AllowProtectedUpdates");
PPCONST CComVariant  k_cvPartnerAttrConsentID(L"ConsentID");
PPCONST CComVariant  k_cvPartnerAttrPrivacyPolicyUrl(L"PrivacyPolicyURL");
PPCONST CComVariant  k_cvPartnerAttrAccountDataUrl(L"AccountDataURL");
PPCONST CComVariant  k_cvPartnerAttrAccountRemovalUrl(L"AccountRemovalURL");
PPCONST CComVariant  k_cvPartnerAttrAllowInlineSignin(L"AllowInlineSignin");
PPCONST CComVariant  k_cvPartnerAttrSupplementalAuthPostType(L"SupplementalAuthPostType");
PPCONST CComVariant  k_cvPartnerAttrSupplementalAuthPostUrl(L"SupplementalAuthPostUrl");
PPCONST CComVariant  k_cvPartnerAttrNeedsMembername(L"NeedsMembername");
PPCONST CComVariant  k_cvPartnerAttrDisableMemberServices(L"DisableMemberServices");
PPCONST CComVariant  k_cvPartnerAttrDisableTermsOfUse(L"DisableTermsOfUse");
PPCONST CComVariant  k_cvPartnerAttrDisablePrivacyPolicy(L"DisablePrivacyPolicy");
PPCONST CComVariant  k_cvPartnerAttrDisableCopyright(L"DisableCopyright");
PPCONST CComVariant  k_cvPartnerAttrDisableHelpText(L"DisableHelpText");
PPCONST CComVariant  k_cvPartnerAttrNameSpaceOwner(L"NameSpaceOwner");

//
//  Stock profile values
//

PPCONST CComVariant  k_cvEmpty(L"");
PPCONST CComVariant  k_cvCustomer(L"Customer!");
PPCONST CComVariant  k_cvNoCountry(L"  ");
PPCONST CComVariant  k_cvCountryUS(L"US");
PPCONST CComVariant  k_cvPostalCodeRedmond(L"98052");
PPCONST CComVariant  k_cvRegionWashington(35841);
PPCONST CComVariant  k_cvLangPrefEnglishUS(1033);
PPCONST CComVariant  k_cvZeroBirthdate(static_cast<double>(0.0));
PPCONST CComVariant  k_cvProfileValueGenderU(L"U");
PPCONST CComVariant  k_cvProfileValueGenderM(L"M");
PPCONST CComVariant  k_cvTestModeEmail(L"PassportTestMode@hotmail.com");
PPCONST CComVariant  k_cvTestModeNickname(L"ILoveMyPassport");

//
//  Other PPCONSTants
//

PPCONST CComVariant  k_cvFalse(false);

//
//  Misc flags
//

PPCONST ULONG  k_ulMiscFlagWantPassportMail   = 0x00000001;
PPCONST ULONG  k_ulMiscFlagShareEmail         = 0x00000002;

//
//  Flags
//

PPCONST ULONG  k_ulFlagsEmailValidated        = 0x00000001;
PPCONST ULONG  k_ulFlagsHotmailAcctActivated  = 0x00000002;
PPCONST ULONG  k_ulFlagsHotmailPwdRecovered   = 0x00000004;
PPCONST ULONG  k_ulFlagsWalletUploadAllowed   = 0x00000008;
PPCONST ULONG  k_ulFlagsHotmailAcctBlocked    = 0x00000010;
PPCONST ULONG  k_ulFlagsConsentStatusNone     = 0x00000000;
PPCONST ULONG  k_ulFlagsConsentStatusLimited  = 0x00000020;
PPCONST ULONG  k_ulFlagsConsentStatusFull     = 0x00000040;
PPCONST ULONG  k_ulFlagsConsentStatus         = 0x00000060; // two bits
PPCONST ULONG  k_ulFlagsAccountTypeKid        = 0x00000080;
PPCONST ULONG  k_ulFlagsAccountTypeParent     = 0x00000100;
PPCONST ULONG  k_ulFlagsAccountType           = 0x00000180; // two bits
PPCONST ULONG  k_ulFlagsEmailPassport         = 0x00000200;
PPCONST ULONG  k_ulFlagsEmailPassportValid    = 0x00000400;
PPCONST ULONG  k_ulFlagsHasMsniaAccount       = 0x00000800;
PPCONST ULONG  k_ulFlagsHasMobileAccount      = 0x00001000;
PPCONST ULONG  k_ulFlagsSecuredTransportedTicket      = 0x00002000;
PPCONST ULONG  k_ulFlagsConsentCookieNeeded   = 0x80000000;
PPCONST ULONG  k_ulFlagsConsentCookieMask     = (k_ulFlagsConsentStatus | k_ulFlagsAccountType);

//
//  Cookie values.
//

PPCONST char* k_szPPAuthCookieName              = "MSPAuth";
PPCONST char* k_szPPProfileCookieName           = "MSPProf";
PPCONST char* k_szPPSecureCookieName            = "MSPSec";
PPCONST char* k_szPPVisitedCookieName           = "MSPVis";
PPCONST char* k_szPPRequestCookieName           = "MSPRequ";
PPCONST char* k_szPPLastDBWriteCookieName       = "MSPLDBW";
PPCONST char* k_szBrowserTestCookieName         = "BrowserTest";
PPCONST char* k_szBrowserTestCookieValue        = "Success?";
PPCONST char* k_szPassportCookiePastDate        = "Thu, 30 Oct 1980 16:00:00 GMT";
PPCONST char* k_szPassportCookieExpiration      = "Wed, 30 Dec 2037 16:00:00 GMT";
PPCONST char* k_szSecurePath                    = "/ppsecure";
PPCONST char* k_szPPPasswordPassingCookie       = "MSPRdr";
PPCONST char* k_szPPClientCookieName            = "MSPClient";
PPCONST char* k_szPPDomainCookieName            = "MSPDom";
PPCONST char* k_szPPPMailCookieName             = "pmail";
PPCONST char* k_szJSStateSecureCookieName       = "MSPSSta";
PPCONST char* k_szPPSecAuthCookieName           = "MSPSecAuth";
PPCONST char* k_szPPPrefillCookieName           = "MSPPre";
PPCONST char* k_szPPSharedComputerCookieName    = "MSPShared";

//
//  Configuration value names.
//

PPCONST wchar_t*  k_szPPDomain          = L"PassportDomain";
PPCONST wchar_t*  k_szPPAuthDomain      = L"AuthDomain";
PPCONST wchar_t*  k_szPPVirtualRoot     = L"PassportVirtualRoot";
PPCONST wchar_t*  k_szPPSiteId          = L"PassportSiteId";
PPCONST wchar_t*  k_szPPFromEmailAddress = L"FromEmailAddress";
PPCONST wchar_t*  k_szPPDomainId        = L"DomainId";
PPCONST wchar_t*  k_szKidsSiteId        = L"KidsSiteId";
PPCONST wchar_t*  k_szPPDomains         = L"Domains";
PPCONST wchar_t*  k_szPPDocRoot         = L"DocRoot";
PPCONST wchar_t*  k_szPPAppRoot         = L"AppRoot";
PPCONST wchar_t*  k_szBadLoginLockTime  = L"BadLoginLockTime";
PPCONST wchar_t*  k_szDigestNonceTimeout= L"DigestNonceTimeout";
PPCONST wchar_t*  k_szSupplementalAuthNonceTimeout = L"SupplementalAuthNonceTimeout";
PPCONST wchar_t*  k_szXmlProfReqTimeout = L"XMLProfileRequestTimout";
PPCONST wchar_t*  k_szNexusVersion      = L"NexusVersion";
PPCONST wchar_t*  k_szNumHeadersToAdd   = L"NumHeadersToAdd";
PPCONST wchar_t*  k_szHeaderNum         = L"HeaderNum";
// mobile to enable test with emulators
PPCONST wchar_t*  k_szMobileNoHTTPs      = L"MobileNoHTTPs";
PPCONST wchar_t*  k_szMobileNoCookiePersist      = L"MobileNoCookiePersist";
PPCONST wchar_t*  k_szMobileCookieDomainFromServer      = L"MobileCookieDomainFromServer";
//

//
//  Network error flags (f= values)
//

PPCONST wchar_t*  k_szBadRequest    = L"1";
PPCONST wchar_t*  k_szOffline       = L"2";
PPCONST wchar_t*  k_szTimeout       = L"3";
PPCONST wchar_t*  k_szLocked        = L"4";
PPCONST wchar_t*  k_szNoProfile     = L"5";
PPCONST wchar_t*  k_szDisaster      = L"6";
PPCONST wchar_t*  k_szInvalidKey    = L"7";
PPCONST wchar_t*  k_szBadPartnerInfo = L"8";
PPCONST wchar_t*  k_szUnhandledError = L"9";
PPCONST wchar_t*  k_szIllegalKppUse = L"10";

//
//  support for passing CPassportExceptioninfo
//  within cookie
//

PPCONST char* k_szErrPage           = "err.srf";
PPCONST char* k_szErrCode           = "code";
PPCONST char* k_szErrCookieName     = "pperr";
PPCONST char* k_szErrCAttrFilename  = "efn";
PPCONST char* k_szErrCAttrLine      = "eln";
PPCONST char* k_szErrCAttrHr        = "ehr";
PPCONST char* k_szErrCAttrStatus1   = "es1";
PPCONST char* k_szErrCAttrStatus2   = "es2";
PPCONST char* k_szErrCAttrStatus3   = "es3";
PPCONST char* k_szErrCAttrTheURL    = "eul";

//
//  MD5 Login mode
//

PPCONST char*   k_szMD5ModeAuth     = "auth";
PPCONST char*   k_szMD5ModeExst     = "exst";
PPCONST char*   k_szMD5ModeExst2    = "exst2";

//
//  XML node name and attribute name
//

PPCONST CComVariant k_cvXMLNodeClientInfo(L"//ClientInfo");
PPCONST CComVariant k_cvXMLNodeSignInName(L"//SignInName");
PPCONST CComVariant k_cvXMLNodeDomain(L"//Domain");
PPCONST CComVariant k_cvXMLNodePassword(L"//Password");
PPCONST CComVariant k_cvXMLNodeSavePassword(L"//SavePassword");
PPCONST CComVariant k_cvXMLNodeCountry(L"//Country");
PPCONST CComVariant k_cvXMLNodeRegion(L"//Region");
PPCONST CComVariant k_cvXMLNodePostalCode(L"//PostalCode");
PPCONST CComVariant k_cvXMLNodeEmail(L"//Email");
PPCONST CComVariant k_cvXMLNodeFirstName(L"//FirstName");
PPCONST CComVariant k_cvXMLNodeLastName(L"//LastName");
PPCONST CComVariant k_cvXMLNodeOccupation(L"//Occupation");
PPCONST CComVariant k_cvXMLNodeTimeZone(L"//TimeZone");
PPCONST CComVariant k_cvXMLNodeOldPassword(L"//OldPassword");
PPCONST CComVariant k_cvXMLNodeNewPassword(L"//NewPassword");
PPCONST CComVariant k_cvXMLNodeSecretQAnswer(L"//SecretQAnswer");
PPCONST CComVariant k_cvXMLNodeCreditCardInfo(L"//CreditCardInfo");
PPCONST CComVariant k_cvXMLNodeBirthDate(L"//Birthdate");
PPCONST CComVariant k_cvXMLNodeAccountIsValidated(L"//AccountIsValidated");
PPCONST CComVariant k_cvXMLNodeSVC(L"//SVC");	
PPCONST CComVariant k_cvXMLNodePCR(L"//ParentCreatingKidsAccount");
PPCONST CComVariant k_cvXMLNodeAllowEmailInProfile(L"//AllowEmailInProfile");

PPCONST CComVariant k_cvXMLNodeAttrID(L"ID");
PPCONST CComVariant k_cvXMLNodeAttrClientInfoVersion(L"version");

//
//  XML root tags of requests and responses
//

PPCONST wchar_t*    k_szLoginRequestRootTag     =   L"LoginRequest";
PPCONST wchar_t*    k_szProfileRequestRootTag   =   L"ProfileRequest";
PPCONST wchar_t*    k_szSignupRequestRootTag    =   L"SignupRequest";
PPCONST wchar_t*    k_szLoginResponseRootTag    =   L"LoginResponse";
PPCONST wchar_t*    k_szProfileResponseRootTag  =   L"ProfileResponse";
PPCONST wchar_t*    k_szSignupResponseRootTag   =   L"SignupResponse";
PPCONST wchar_t*    k_szChangePWResponseRootTag =   L"ChangePasswordResponse";
PPCONST wchar_t*    k_szChangePWRequestRootTag  =   L"ChangePasswordRequest";
PPCONST wchar_t*    k_szResetPWResponseRootTag  =   L"ResetPasswordResponse";
PPCONST wchar_t*    k_szResetPWRequest1RootTag  =   L"ResetPasswordRequest1";
PPCONST wchar_t*    k_szResetPWRequest2RootTag  =   L"ResetPasswordRequest2";

//
//  XML redirect and referral
//

PPCONST wchar_t*    k_szXMLRedirect =   L"Redirect";
PPCONST wchar_t*    k_szXMLReferral =   L"Referral";
PPCONST wchar_t*    k_szXMLAltName	=   L"Alternative";

//
//  Misc constants
//

PPCONST wchar_t*    k_szTrue    =   L"true";
PPCONST wchar_t*    k_szFalse   =   L"false";

//
// PP_SERVICE constants. Passed to Partners CB file as PP_SERVICE="value"
// Tells the partner what service their cobranding is being rendered in.
//

PPCONST char*   k_szPPSRegistration             =   "registration";
PPCONST char*   k_szPPSLogin                    =   "login";
PPCONST char*   k_szPPSLogout                   =   "logout";
PPCONST char*   k_szPPSMemberServices           =   "memberservices";

//
// PP_PAGE constants. Passed to Partners CB file as PP_PAGE="value"
// Tells the partner what page their cobranding is being rendered on.
//

PPCONST char*   k_szPPPRegisterError             =   "regerr";
PPCONST char*   k_szPPPRegisterEditProfile       =   "editprof";
PPCONST char*   k_szPPPExpNotLoggedInEditProfile =   "expnotloggedineditprof";
PPCONST char*   k_szPPPCongrats                  =   "congrats";
PPCONST char*   k_szPPPExpAlreadyLoggedIn        =   "exploggedin";
PPCONST char*   k_szPPPExpUnknownServerError     =   "expunknownsererr";

//
// Passport1.4 (tweener) string constants
//
PPCONST wchar_t* k_szPassport_Prot14 =  L"Passport1.4";
PPCONST char* k_szPassport_Prot14_A = "Passport1.4";

//
//  secure signin levels
//
PPCONST USHORT k_iSeclevelAny                =   0;
PPCONST USHORT k_iSeclevelSecureChannel      =   10;
PPCONST USHORT k_iSeclevelStrongCreds        =   100;
PPCONST USHORT k_iSeclevelStrongestAvaileble =   0xFF;

PPCONST USHORT k_iPPSignInOptionPrefill = 1;       // - Prefill
PPCONST USHORT k_iPPSignInOptionSavePassword = 2;  // - Save passpord/Auto signin
PPCONST USHORT k_iPPSignInOptionShared = 3;        // - Public/shared computer
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\pmerrorcodes.h ===
#ifndef __ERRORCODES_H_
#define __ERRORCODES_H_


#define PP_E_NOT_CONFIGURED     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0200)
#define PP_E_NOT_CONFIGUREDSTR  L"PassportManager misconfigured"

#define PP_E_NO_SUCH_ATTRIBUTE MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0201)
#define PP_E_NO_SUCH_ATTRIBUTESTR L"Profile.Attribute: No such attribute."
#define PP_E_NSA_BADMID           L"Profile.Update: Schema has bad memberId fields, cannot update."
#define PP_E_BAD_DATA_FORMAT    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0202)
#define PP_E_BAD_DATA_FORMATSTR L"Invalid profile data format"
#define PP_E_BDF_TOSTRCVT          L"Profile.ByIndex: Couldn't convert value to string."
#define PP_E_BDF_TOBYTECVT         L"Profile.ByIndex: Couldn't convert value to byte."
#define PP_E_BDF_TOSHORTCVT        L"Profile.ByIndex: Couldn't convert value to short."
#define PP_E_BDF_TOINTCVT          L"Profile.ByIndex: Couldn't convert value to integer."
#define PP_E_BDF_STRTOLG           L"Profile.ByIndex: Data too large."
#define PP_E_BDF_NONULL            L"Profile.ByIndex: Can't set null value."
#define PP_E_BDF_CANTSET           L"Can't set that profile field"

#define PP_E_READONLY_ATTRIBUTE MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0203)
#define PP_E_READONLY_ATTRIBUTESTR L"Profile.ByIndex: That attribute is read only."

#define PP_E_INVALID_TICKET     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0204)
#define PP_E_INVALID_TICKETSTR  L"Passport: cannot ask for properties of invalid auth ticket"
#define PP_E_IT_FOR_HASFLAGSTR  L"Can't call HasFlag: no valid Passport user"
#define PP_E_IT_FOR_COMMITSTR   L"PassportManager.Commit can't be used w/o a valid member."

#define PP_E_INVALID_TIMEWINDOW MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0205)
#define PP_E_INVALID_TIMEWINDOWSTR L"TimeWindow invalid.  Must be between 100 and 1000000"

#define PP_E_LOGOUTURL_NOTDEFINED MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0206)
#define PP_E_LOGOUTURL_NOTDEFINEDSTR L"Logout URL is not defined. Check partner.xml file."

#define PP_E_GETFLAGS_OBSOLETESTR L"HasFlags is now obsolete, please use the Error property."

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\pperr.h ===
#pragma once
//-----------------------------------------------------------------------------
//
//  File:   pperr.h
//
//  Passport error code definitions.
//
//-----------------------------------------------------------------------------
#include <winerror.h>
// General errors

#define     PP_E_COMFAIL                                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1000)
#define     PP_E_ERRORCODE                              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1001)
#define     PP_E_TOOMANYREQUESTS                        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1002)
#define     PP_E_SVC_NOT_CONFIGURED                     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1003)
#define     PP_E_NEEDSBIRTHDATE                         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1004)
#define     PP_E_MD5SILENTNOCONSENT                     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1005)
#define     PP_E_MD5SILENTNEEDPARENT                    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1006)
#define     PP_E_PROFILENOTEXIST                        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1007)
#define     PP_E_TICKETEXPIRED                          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1008)
#define     PP_E_TICKETNOTEXIST                         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1009)
#define     PP_E_SECTICKETNOTEXIST                      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x100A)
#define     PP_E_SECTICKETNOTMATCH                      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x100B)
#define     PP_E_FORCESIGNIN                            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x100C)
#define     PP_E_KPPVCMISSING                           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x100D)
#define     PP_E_KPPVCINVALID                           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x100E)
#define     PP_E_KPPNONKIDSITE                          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x100F)
#define     PP_E_EXCLUDED                               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1010)
#define     PP_E_MEMBER_LOCKED                          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1011)
#define     PP_E_BAD_PASSWORD                           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1012)
#define     PP_E_KIDNPP                                 MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1014)
#define     PP_E_KIDSPASSPORTURL                        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1015)
#define     PP_E_NOT_OVER_SSL                           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1016)
#define     PP_E_INVALIDKPP                             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1017)
#define     PP_E_INVALIDSITEID                          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1018)
#define     PP_E_INVALIDMEMBERNAME                      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1019)
#define     PP_E_INVALIDRETURNURL                       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x101A)
#define     PP_E_INVALIDKEYVERSION                      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x101B)
#define     PP_E_INVALIDREQUEST                         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x101C)
#define     PP_E_INVALIDPARAMS                          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x101D)
#define     PP_E_NOCREDENTIALS                          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x101E)
#define     PP_E_NOAUTH                                 MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x101F)
#define     PP_E_NO_SL                                  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1020)
#define     PP_E_NO_ALIAS_NO_PASSWORD                   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1021)
#define     PP_E_NO_ALIAS                               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1022)
#define     PP_E_NO_PASSWORD                            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1023)
#define     PP_E_NO_DOMAIN                              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1024)
#define     PP_E_NO_CHALLENGE                           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1025)
#define     PP_E_INVALIDMODE                            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1026)
#define     PP_E_USER_BAD_LOGIN                         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1027)
#define     PP_E_SAME_USER_BAD_LOGIN                    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1028)
#define     PP_E_DIFFERENT_USER                         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1029)
#define     PP_E_WRONG_CREDENTIALS                      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x102A)
#define     PP_E_WRONG_MODE                             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x102B)
#define     PP_E_BROWSERINCAPABLE                       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x102C)
#define     PP_E_BROWSERCOOKIEDISABLED                  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x102D)
#define     PP_E_CRED_INPUT_TOO_LONG                    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x102E)
#define     PP_E_NOT_EMAIL_INPUT                        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x102F)
#define     PP_E_MISSING_CREDS                          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1030)
#define     PP_E_MISSING_MEMBERNAME                     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1031)
#define     PP_E_MISSING_PASSWORD                       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1032)
#define     PP_E_MISSING_DOMAIN                         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1033)
#define     PP_E_INVALID_MEMBERNAME                     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1034)
#define     PP_E_WRONG_DA_DOMAIN                        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1035)
#define     PP_E_NONE_AUTH_MODE                         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1036)
#define     PP_E_INVALID_CARD                           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1037)
#define     PP_E_LOCATION_WRONG                         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1038)
#define     PP_E_SECRET_ANS_WRONG                       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1039)
#define     PP_E_KID_HAS_NO_CONSENT                     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x103A)
#define     PP_E_NO_COUNTRY                             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x103B)
#define     PP_E_NO_REGION                              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x103C)
#define     PP_E_NO_POSTALCODE                          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x103D)
#define     PP_E_NO_SECRET_ANSWER                       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x103E)
#define     PP_E_NO_CREDIT_CARD                         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x103F)
#define     PP_E_NEED_STRONG_CREDENTIALS                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1040)
#define     PP_E_BAD_PIN                                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1041)
#define     PP_E_EMAIL_TAKEN                            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1042)
#define     PP_E_BAD_PINSA                              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1043)
#define     PP_E_MISSING_PIN                            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1044)
#define     PP_E_MISSING_PINSA                          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1045)
#define     PP_E_PIN_MISMATCH                           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1046)
#define     PP_E_PIN_INVALID                            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1047)
#define     PP_E_PIN_BLANK                              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1048)
#define     PP_E_PIN_TOO_SHORT                          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1049)
#define     PP_E_PIN_TOO_LONG                           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1050)
#define     PP_E_PIN_CONTAINS_MEMBERNAME                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1051)
#define     PP_E_FORCE_RENAME                           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1052)
#define     PP_E_MISSING_PHONENUM                       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1053)
#define     PP_E_MISSING_PHONEPIN                       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1054)
#define     PP_E_PPM_NOTCAPABLE                         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1055)

// Errors from ValidateFunctions.cpp

#define     PP_E_NAME_BLANK                             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1100)
#define     PP_E_NAME_TOO_SHORT                         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1101)
#define     PP_E_NAME_TOO_LONG                          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1102)
#define     PP_E_NAME_INVALID                           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1103)
#define     PP_E_PASSWORD_BLANK                         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1104)
#define     PP_E_PASSWORD_TOO_SHORT                     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1105)
#define     PP_E_PASSWORD_TOO_LONG                      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1106)
#define     PP_E_PASSWORD_CONTAINS_MEMBERNAME           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1107)
#define     PP_E_PASSWORD_INVALID                       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1108)
#define     PP_E_PASSWORD_MISMATCH                      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1109)
#define     PP_E_EMAIL_BLANK                            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x110A)
#define     PP_E_EMAIL_INVALID                          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x110B)
#define     PP_E_EMAIL_RIGHT_TOO_LONG                   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x110C)
#define     PP_E_EMAIL_INCOMPLETE                       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x110D)
#define     PP_E_EMAIL_INVALID_CHARS                    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x110E)
#define     PP_E_BIRTHDATE_NOTENTERED                   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x110F)
#define     PP_E_BIRTHYEAR_INVALID_CHARS                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1110)
#define     PP_E_BIRTHYEAR_NOT_4DIGIT                   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1111)
#define     PP_E_BIRTHYEAR_TOO_LOW                      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1112)
#define     PP_E_BIRTHYEAR_MISSING                      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1113)
#define     PP_E_BIRTHMONTH_MISSING                     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1114)
#define     PP_E_BIRTHMONTH_INVALID                     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1115)
#define     PP_E_BIRTHDAY_MISSING                       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1116)
#define     PP_E_BIRTHDAY_INVALID                       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1117)
#define     PP_E_BADDAYFORMONTH                         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1118)
#define     PP_E_BIRTHDATE_UNDER18                      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1119)
#define     PP_E_BIRTHDATE_IN_FUTURE                    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x111A)
#define     PP_E_PARENT_UNDER13                         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x111B)
#define     PP_E_SECRETQA_NOQUESTION                    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x111C)
#define     PP_E_SECRETQA_NOANSWER                      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x111D)
#define     PP_E_SQ_INVALID                             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x111E)
#define     PP_E_SA_INVALID                             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x111F)
#define     PP_E_SA_TOOSHORT                            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1120)
#define     PP_E_SA_TOOLONG                             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1121)
#define     PP_E_SQ_TOOSHORT                            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1122)
#define     PP_E_SQ_TOOLONG                             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1123)
#define     PP_E_LOCATION_INVALID_REGION                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1124)
#define     PP_E_LOCATION_INVALID_POSTALCODE            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1125)
#define     PP_E_LOCATION_INVALID_POSTALCODECHARS       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1126)
#define     PP_E_LOCATION_INVALID_COUNTRY               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1127)
#define     PP_E_GENDER_BLANK                           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1128)
#define     PP_E_GENDER_INVALID                         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1129)
#define     PP_E_LANGUAGE_BLANK                         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x112A)
#define     PP_E_TIMEZONE_BLANK                         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x112B)
#define     PP_E_OCCUPATION_BLANK                       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x112C)
#define     PP_E_SVC_BLANK                              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x112D)
#define     PP_E_SAVEPASSWORD_BLANK                     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x112E)
#define     PP_E_ACCESSIBILITY_BLANK                    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x112F)
#define     PP_E_ALLOWEMAILINPROFILE_BLANK              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1130)
#define     PP_E_ALLOWPASSPORTNETWORKEMAIL_BLANK        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1131)

#define     PP_E_MEMBER_EXIST                           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1132)
#define     PP_E_EMAIL_MEMBER_EXIST                     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1133)
#define     PP_E_EMAIL_MANAGED                          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1134)

#define     PP_E_SECRETQA_DUPLICATE_Q                   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1135)

#define     PP_E_FIRSTNAME_BLANK                        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1136)
#define     PP_E_LASTNAME_BLANK                         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1137)
#define     PP_E_NICKNAME_BLANK                         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1138)
#define     PP_E_EMAIL_RESERVED                         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1139)
#define     PP_E_DOMAIN_INVALID                         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x113A)

#define     PP_E_SECRETQA_DUPLICATE_A                   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x113B)
#define     PP_E_SECRETQA_NOMATCH                       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x113C)

#define     PP_E_EXTERNALFIELD_BLANK                    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x113D)

#define     PP_E_PARENT_INVALID                         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x113E)

#define		PP_E_INVALID_PHONENUMBER					MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x113F)
#define		PP_E_PHONENUMBER_EXIST						MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1140)

// Database Errors

#define     PP_E_DB_STRINGTOOLONG                       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1200)
#define     PP_E_DB_STRINGTOOSHORT                      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1201)
#define     PP_E_DB_INVALIDPASSWORD                     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1202)
#define     PP_E_DB_INVALIDEMAIL                        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1203)
#define     PP_E_DB_INVALIDMEMBERNAME                   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1204)
#define     PP_E_DB_MISSINGPARAMETERS                   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1205)
#define     PP_E_DB_FORBIDDENWORD                       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1206)
#define     PP_E_DB_INVALIDDOMAINNAME                   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1207)
#define     PP_E_DB_CRITICALERROR                       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1208)
#define     PP_E_DB_ERROR                               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1209)
#define     PP_E_DB_MEMBEREXISTS                        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x120A)
#define     PP_E_DB_MEMBERDOESNOTEXIST                  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x120B)
#define     PP_E_DB_NODATA                              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x120C)
#define     PP_E_DB_DUPLICATEFRIENDLYNAME               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x120D)
#define     PP_E_DB_ADDRESSDOESNOTEXIST                 MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x120E)
#define     PP_E_DB_CARDDOESNOTEXIST                    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x120F)
#define     PP_E_DB_ADDRESSREFERENCEDBYCARD             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1210)
#define     PP_E_DB_KIDSSITENOTLISTED                   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1211)
#define     PP_E_DB_SITEALREADYREQUESTED                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1212)
#define     PP_E_DB_CONNECTIONTIMEOUT                   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1213)
#define     PP_E_DB_NOCONNECTIONAVAILABLE               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1224)

// XML interface errors

#define     PP_E_XML_PARSE_ERROR                        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1300)
#define     PP_E_XML_NO_CLIENTINFO                      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1301)
#define     PP_E_XML_UNKNOWN_CLIENTVERSION              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1302)
#define     PP_E_XML_NAME_AND_PASSWORD_BLANK            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1303)
#define     PP_E_XML_DOMAIN_BLANK                       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1304)
#define     PP_E_XML_INCOMPLETE_MEMBERNAME              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1305)
#define     PP_E_XML_NO_SUCH_NODE                       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1306)
#define     PP_E_XML_NO_TEXT                            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1307)
#define     PP_E_XML_INVALID_ROOTTAG                    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1308)
#define     PP_E_XML_USER_ALREADY_LOGGEDIN              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1309)
#define     PP_E_XML_KEYVERSION_NOT_A_NUMBER            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x130A)
#define     PP_E_XML_NO_USER_LOGGED_IN                  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x130B)
#define     PP_E_XML_NO_SUCH_ATTRIBUTE                  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x130C)

// Global Init object errors

#define     PP_E_GLOBALINIT_BASE                        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1400)
#define     PP_E_GLOBALINIT_MISSING_PCONTROL_SERVICE    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1400)
#define     PP_E_GLOBALINIT_NOAGENT                     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1401)
#define     PP_E_GLOBALINIT_DOMAINGET_BINDFAILED        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1402)
#define     PP_E_GLOBALINIT_MISSING_STRINGTABLE_SERVICE MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1403)
#define     PP_E_GLOBALINIT_DOMAINGET_EXECUTEFAILED     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1404)
#define     PP_E_GLOBALINIT_MISSING_DOMAINID_CONFIG     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1405)
#define     PP_E_GLOBALINIT_INVALID_DOMAIN_INDEX        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1406)
#define     PP_E_GLOBALINIT_BUFFER_TOO_SMALL            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1407)
#define     PP_E_GLOBALINIT_MISSING_MANAGER_SERVICE     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1408)
#define     PP_E_GLOBALINIT_ADDSTRING_FAILED            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1409)
#define     PP_E_GLOBALINIT_DOMAINGET_GETROWEXFAILED    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x140A)
#define     PP_E_GLOBALINIT_DOMAINGET_GETITEMFAILED     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x140B)
#define     PP_E_GLOBALINIT_ADDNUMBER_FAILED            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x140C)


// Digest Errors
#define     PP_E_DIGEST_PARSE_AUTH_HEADER               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1500)
#define     PP_E_DIGEST_OPAQUE_MISSMATCH                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1501)
#define     PP_E_DIGEST_ALGORITHM_MISSMATCH             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1502)
#define     PP_E_DIGEST_REALMS_MISSMATCH                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1503)
#define     PP_E_DIGEST_URL_MISSMATCH                   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1504)
#define     PP_E_DIGEST_USERNAME_MISSING                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1505)
#define     PP_E_DIGEST_CNONCE_MISSING                  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1506)
#define     PP_E_DIGEST_NONCE_COUNT_MISSING             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1507)
#define     PP_E_DIGEST_NONCE_MISSING                   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1508)
#define     PP_E_DIGEST_UNSUPPORTED_KPP_MODE            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1509)
#define     PP_E_DIGEST_NONCE_MISSMATCH                 MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x150A)
#define     PP_E_DIGEST_RESPONSE_TIMEOUT                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x150B)
#define     PP_E_DIGEST_RESPONSE_MISSING                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x150C)


// MD5 Silent Errors
#define     PP_E_MD5SILENT_SITEID_IS_ONE                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1600)
#define     PP_E_MD5SILENT_INVALID_T                    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1601)
#define     PP_E_MD5SILENT_INVALID_P                    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1602)
#define     PP_E_MD5SILENT_INVALID_KPP                  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1603)

// Inline Signin Errors
#define     PP_E_INLINESIGNIN_NOT_ALLOWED_FOR_SITE      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1700)
#define     PP_E_INLINESIGNIN_SSL_REQUIRED_FOR_POST     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1701)


// NetPartnerInfo (NSO) Errors
#define     PP_E_NETPARTNERINFO_UNINITIALZED            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1800)
#define     PP_E_NETPARTNERINFO_SITEID_NOT_FOUND        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1801)
#define     PP_E_NETPARTNERINFO_DECRYPT_FAILED          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1802)
#define     PP_E_NETPARTNERINFO_KEYSIZE_MISMATCH        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1803)
#define     PP_E_NETPARTNERINFO_CREATEFILE              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1804)
#define     PP_E_NETPARTNERINFO_WRITEFILE               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1805)
#define     PP_E_NETPARTNERINFO_READFILE                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1806)

// Com object errors
#define     PP_E_HASHSTRING_ADDRECORD_FAILED            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1900)
#define     PP_E_MD5_HASH_FAILED                        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1901)

// Globalization errors
#define     PP_E_GLOBALIZATION_INVALID_COUNTRY_ID       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A00)
#define     PP_E_GLOBALIZATION_INVALID_REGION_ID        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A01)
#define     PP_E_GLOBALIZATION_INVALID_POSTAL_ID        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A02)
#define     PP_E_GLOBALIZATION_INVALID_GEO_ID           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A03)
#define     PP_E_GLOBALIZATION_INVALID_TIMEZONE_ID      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A04)
#define     PP_E_GLOBALIZATION_INVALID_REGION           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A05)
#define     PP_E_GLOBALIZATION_INVALID_TIMEZONE         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A06)
#define     PP_E_GLOBALIZATION_INVALID_INDEX            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A07)
#define     PP_E_GLOBALIZATION_INVALID_DATA             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A08)
#define     PP_E_GLOBALIZATION_INVALID_DATA_TYPE        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A09)
#define     PP_E_GLOBALIZATION_OBJ_IS_NULL              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A0A)
#define     PP_E_GLOBALIZATION_PTR_IS_NULL              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A0B)
#define     PP_E_GLOBALIZATION_STREAM_IS_NULL           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A0C)
#define     PP_E_GLOBALIZATION_BSTR_EXPECTED            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A0D)
#define     PP_E_GLOBALIZATION_SEMICOLON_NOT_FOUND      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A0E)
#define     PP_E_GLOBALIZATION_COMMA_NOT_FOUND          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A0F)
#define     PP_E_GLOBALIZATION_ALREADY_LOADED           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A10)
#define     PP_E_GLOBALIZATION_LCIDINFO_NOT_LOADED      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A11)
#define     PP_E_GLOBALIZATION_LCIDINFO_NOT_PREPARED    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A12)
#define     PP_E_GLOBALIZATION_REGION_LOAD_FAILED       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A13)
#define     PP_E_GLOBALIZATION_TIMEZONE_LOAD_FAILED     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A14)
#define     PP_E_GLOBALIZATION_LOOKUP_OBJ_FAILED        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A15)
#define     PP_E_GLOBALIZATION_LOADVALUES_FAILED        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A16)
#define     PP_E_GLOBALIZATION_GETLOCALINFO_FAILED      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A17)
#define     PP_E_GLOBALIZATION_STRING_RETURNED          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A18)
#define     PP_E_GLOBALIZATION_W2A_FAILED               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A19)
#define     PP_E_GLOBALIZATION_A2W_FAILED               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A1A)
#define     PP_E_GLOBALIZATION_INSTREAM_FAILED          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A1B)
#define     PP_E_GLOBALIZATION_GET_LCIDINFODIR_FAILED   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A1C)
#define     PP_E_GLOBALIZATION_STRING_TOO_LONG          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A1D)
#define     PP_E_GLOBALIZATION_IDTABLE_NOT_INIT         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A1E)

// DelegatedAdmin Errors
#define     PP_E_DELEGADMIN_INVALID_ADMIN_ELE           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1B00)
#define     PP_E_DELEGADMIN_INVALID_ADMIN_TICKET        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1B01)
#define     PP_E_DELEGADMIN_DOMAIN_ALREADY_MANAGED      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1B02)
#define     PP_E_DELEGADMIN_DOMAIN_NOT_MANAGED          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1B03)
#define     PP_E_DELEGADMIN_DOMAIN_NOT_PARTNERS         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1B04)
#define     PP_E_DELEGADMIN_INVALID_NS_ADMIN            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1B05)
#define     PP_E_DELEGADMIN_INVALID_PARTNER_ADMIN       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1B06)
#define     PP_E_DELEGADMIN_ERROR_LOADING_XMLRQ         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1B07)
#define     PP_E_DELEGADMIN_INVALID_AUTH_ELE            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1B08)
#define     PP_E_DELEGADMIN_INVALID_DOMAIN              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1B09)
#define     PP_E_DELEGADMIN_INVALID_ACTION              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1B0a)
#define     PP_E_DELEGADMIN_INVALID_CLIENTVERSION       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1B0b)
#define     PP_E_DELEGADMIN_NOTALLOWED                  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1B0c)
#define     PP_E_DELEGADMIN_INVALID_USER                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1B0d)
#define     PP_E_DELEGADMIN_INVALID_USER_ELE            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1B0e)
#define     PP_E_DELEGADMIN_INVALID_PARAM               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1B0f)
#define     PP_E_DELEGADMIN_NOT_NAMESPACE_PARTNER       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1B10)

// Update Server Errors
#define     PP_E_UPDATE_UPDATES_NOT_ALLOWED             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1C00)


// Profile Server Errors
#define     PP_E_PROFILE_REG_LOGIN_FAILED               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1D00)


#define     PP_E_EMAILRESPONSE_INTERNALERROR			MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1D01)		// unexpected error (status should be of VT_INT) return from EmailResponse object
#define	    PP_E_EMAIL_NOT_FOUND						MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1D02)	
#define		PP_E_LCID_NOT_FOUND							MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1D03)
#define		PP_E_EMAILRESPONSE_CHECKSECRET				MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1D04)

// PST Support Object Errors
#define	    PP_E_PSTUTIL_INVALID_EMAIL_STATUS			MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1E00)
#define	    PP_E_PSTUTIL_INVALID_ADMIN					MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1E01)
#define	    PP_E_PSTUTIL_INVALID_CRED_TYPE				MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1E02)


// map db error to application error defined above
HRESULT     DBError(HRESULT hr); 
// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\passporturlfunctions.h ===
//-----------------------------------------------------------------------------
//
//  @doc
//
//  @module PassportUrlFunctions.h |  Passport specific URL construction
//                                    routines.
//
//  Author: Darren Anderson
//
//  Date:   5/17/00
//
//  Copyright <cp> 1999-2000 Microsoft Corporation.  All Rights Reserved.
//
//-----------------------------------------------------------------------------
#pragma once

void
MakeUrl(
    bool        bSecure,
    LPCSTR      szTarget,
    CPPUrl&     url
    );

void
MakeRefreshUrl(
    ULONG   ulSiteId,
    LPCSTR  szReturnUrl,
    ULONG   ulTimeWindow,
    bool    bForceSignin,
    USHORT  nKeyVersion,
    LPCSTR  szCobranding,
    ULONG   ulCobrandId,
    time_t  tCurrent,
    LONG    lTimeSkew,
    LPCWSTR szAlias,
    LPCWSTR szDomain,
    //bool    bSavePassword,
    USHORT  usSignInOption,
    LPCSTR  szErrorCode,
    ULONG   ulSecure,
    CPPUrl& url
    );

void
MakeSilentUrl(
    ULONG   ulSiteId,
    LPCSTR  szReturnUrl,
    ULONG   ulTimeWindow,
    bool    bForceSignin,
    USHORT  nKeyVersion,
    LPCSTR  szCobranding,
    ULONG   ulCobrandId,
    time_t  tCurrent,
    LONG    lTimeSkew,
    ULONG   ulSecure,
    CPPUrl& url
    );

void
MakeLogoutUrl(
    ULONG   ulSiteId,
    LPCSTR  szReturnUrl,
    ULONG   ulTimeWindow,
    bool    bForceSignin,
    USHORT  nKeyVersion,
    LPCSTR  szCobranding,
    ULONG   ulCobrandId,
    time_t  tCurrent,
    LONG    lTimeSkew,
    LPCWSTR szAlias,
    LPCWSTR szDomain,
    //bool    bSavePassword,
    USHORT  usSignInOption,
    LPCWSTR szMode,
    ULONG   ulSecure,
    CPPUrl& url
    );

void
MakeRegistrationUrl(
    ULONG   ulSiteId,
    LPCSTR  szReturnUrl,
    USHORT  nKeyVersion,
    ULONG   ulCobrandId,
    LPCSTR  szCobranding,
    time_t  tCurrent,
    LPCWSTR szNameSpace,
    LPCWSTR szOtherQ,
    ULONG   ulSecure,
    CPPUrl& url
    );

void
MakePostUrl(
    LPCWSTR szDADomain,
    const BSTR szPostAttr,
    ULONG   ulSiteId,
    LPCSTR szReturnUrl,
    ULONG   ulTimeWindow,
    bool    bForceSignin,
    USHORT  nKeyVersion,
    LPCSTR szCobranding,
    ULONG   ulCobrandId,
    LONG    lTimeSkew,
    LPCWSTR szAlias,
    LPCWSTR szDomain,
    bool    bPersistedCredentials,
    ULONG   ulSecure,
    CPPUrl& url
    );

void
MakeSecureUrl(
    ULONG   ulSiteId,
    LPCSTR  szReturnUrl,
    ULONG   ulTimeWindow,
    bool    bForceSignin,
    USHORT  nKeyVersion,
    LPCSTR  szCoBranding,
    ULONG   ulCobrandId,
    LONG    lTimeSkew,
    ULONG   ulSecure,
    CPPUrl& url
    );

void
MakeFullReturnUrl(
    LPCSTR      szUrl,
    LPCWSTR     szTicket,
    LPCWSTR     szProfile,
    LPCWSTR     szFlags,
    CPPUrl&     fullUrl
    );

void MakeFullReturnURL(CPPUrl &curlReturnURL, LPCWSTR pwszTicket, LPCWSTR pwszProfile);
// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\pperrmap.h ===
#if !defined(__PPERRMAP_H__)
#define __PPERRMAP_H__

#pragma once
//-----------------------------------------------------------------------------
//
//  File:   pperrmap.h
//
//  Passport error code definitions.
//
//-----------------------------------------------------------------------------
#include <pperr.h>
#include <pperrres.h>

struct  PPERR_MAP
{
    HRESULT                 hr;
    DWORD                   dwResourceID;
    LPCWSTR                 cwzXMLCode; 
}; 

static PPERR_MAP sgProfileErrMap[] =
{
    {   PP_E_NAME_BLANK,
        IDS_E_NAME_BLANK, 
        L"f2a"
    },

    {   PP_E_INVALID_PHONENUMBER,
//      IDS_E_NAME_TOO_SHORT,
		IDS_E_INVALID_PHONENUMBER,
        L"f3c"
    }, 


    {   PP_E_NAME_TOO_LONG,
        IDS_E_NAME_TOO_LONG,
        L"f3d"
    },

	{   PP_E_NAME_INVALID,
	    IDS_E_NAME_INVALID,
        L"f3"
    },

	{   PP_E_MEMBER_EXIST,
	    IDS_E_NAME_EXIST,
        L"f3"
    },

    
    {   PP_E_PASSWORD_BLANK,
        IDS_E_PASSWORD_BLANK,
        L"f2b"
    },

	{   PP_E_PASSWORD_TOO_SHORT,
	    IDS_E_PASSWORD_TOO_SHORT,
        L"f5"
    },

    {   PP_E_PASSWORD_TOO_LONG,
        IDS_E_PASSWORD_TOO_LONG,
	    L"f5c"
    },

    {   PP_E_PASSWORD_CONTAINS_MEMBERNAME,
        IDS_E_PASSWORD_CONTAINS_MEMBERNAME,
        L"f5a"
    },

	{   PP_E_PASSWORD_INVALID,
	    IDS_E_PASSWORD_INVALID,
        L"f5b"
    },

	{   PP_E_PASSWORD_MISMATCH,
	    IDS_E_PASSWORD_MISMATCH,
        L""
    },

    {   PP_E_SECRETQA_NOQUESTION,
        IDS_E_SECRETQA,
        L"f2c"
    },

	{   PP_E_SECRETQA_NOANSWER,
        IDS_E_SECRETQA,
        L"f2c"
    },

	{   PP_E_SECRETQA_NOMATCH,
        IDS_E_SECRETQA_NOMATCH,
        L"f2c"
    },

    {   PP_E_SECRETQA_DUPLICATE_Q,
        IDS_E_SECRETQA_DUPLICATE_Q,
        L"f2c"
    },

    {   PP_E_SECRETQA_DUPLICATE_A,  
        IDS_E_SECRETQA_DUPLICATE_A,
        L""
    },  
 
    {   PP_E_PIN_BLANK,
        IDS_E_PIN_BLANK,
        L""
    },

	{   PP_E_PIN_TOO_SHORT,
	    IDS_E_PIN_TOO_SHORT,
        L""
    },

    {   PP_E_PIN_TOO_LONG,
        IDS_E_PIN_TOO_LONG,
	    L""
    },

    {   PP_E_PIN_CONTAINS_MEMBERNAME,
        IDS_E_PIN_CONTAINS_MEMBERNAME,
        L""
    },

	{   PP_E_PIN_INVALID,
	    IDS_E_PIN_INVALID,
        L""
    },

	{   PP_E_PIN_MISMATCH,
	    IDS_E_PIN_MISMATCH,
        L""
    },

    {   PP_E_LOCATION_INVALID_COUNTRY,
        IDS_E_LOCATION_INVALID_COUNTRY,
        L"f7b"
    },

    {   PP_E_LOCATION_INVALID_REGION,
        IDS_E_LOCATION_INVALID_REGION,
        L"f7a"
    },

    {   PP_E_LOCATION_INVALID_POSTALCODECHARS,
        IDS_E_LOCATION_INVALID_POSTALCODECHARS,
        L"f7d"
    },

    {   PP_E_LOCATION_INVALID_POSTALCODE,
        IDS_E_LOCATION_INVALID_POSTALCODE,
	    L"f7c"
    },


    {   PP_E_EMAIL_BLANK,
        IDS_E_EMAIL_BLANK,
        L"f7f"
    },

    {   PP_E_EMAIL_INVALID,
        IDS_E_EMAIL_INVALID,
        L"f7g"
    },

    {   PP_E_EMAIL_RIGHT_TOO_LONG,
        IDS_E_EMAIL_RIGHT_TOO_LONG,
        L"f7g"
    },

    {   PP_E_EMAIL_INVALID_CHARS,
        IDS_E_EMAIL_INVALID_CHARS,
        L"f7h"
    },

    {   PP_E_EMAIL_INCOMPLETE,
        IDS_E_EMAIL_INCOMPLETE,
        L"f7g"
    },

    {   PP_E_EMAIL_MEMBER_EXIST,
        IDS_E_EMAIL_MEMBER_EXIST,
        L"f7"
    },

    {   PP_E_EMAIL_MANAGED,
        IDS_E_EMAIL_MANAGED,
        L"f7h"
    },

	{   PP_E_GENDER_BLANK,
	    IDS_E_GENDER,
        L"f8"
    },

	{   PP_E_GENDER_INVALID,
	    IDS_E_GENDER,
        L"f8"
    },

    {   PP_E_BIRTHDATE_NOTENTERED,
        IDS_E_BIRTHDATE,
        L"f9"
    },  

    {   PP_E_BIRTHYEAR_INVALID_CHARS,              
        IDS_E_BIRTHDATE,
        L"f9"
    },  

    {   PP_E_BIRTHYEAR_NOT_4DIGIT,     
        IDS_E_BIRTHDATE,
        L"f9"
    },  

    {   PP_E_BIRTHYEAR_TOO_LOW,
        IDS_E_BIRTHDATE,
        L"f9"
    },  

    {   PP_E_BIRTHYEAR_MISSING,  
        IDS_E_BIRTHDATE,
        L"f9"
    },  

    {   PP_E_BIRTHMONTH_MISSING,
        IDS_E_BIRTHDATE,
        L"f9"
    },  

    {   PP_E_BIRTHMONTH_INVALID, 
        IDS_E_BIRTHDATE,
        L"f9"
    },  

    {   PP_E_BIRTHDAY_MISSING,      
        IDS_E_BIRTHDATE,
        L"f9"
    },  

    {   PP_E_BIRTHDAY_INVALID,             
        IDS_E_BIRTHDATE,
        L"f9"
    },  

    {   PP_E_BIRTHDATE_IN_FUTURE,  
        IDS_E_BIRTHDATE,
        L"f9"
    },  

    {   PP_E_FIRSTNAME_BLANK,  
        IDS_E_FIRSTNAME_BLANK,  
        L"fb1"
    },  

    {   PP_E_LASTNAME_BLANK,  
        IDS_E_LASTNAME_BLANK,  
        L"fb2"
    },  

    {   PP_E_NICKNAME_BLANK,  
        IDS_E_NICKNAME_BLANK,  
        L"fb3"
    },  

    {   PP_E_OCCUPATION_BLANK,
        IDS_E_OCCUPATION_BLANK,
        L"fb3"
    },  

    {   PP_E_TIMEZONE_BLANK,
        IDS_E_TIMEZONE_BLANK,		
        L"fb3"
    },  

	{   PP_E_EXTERNALFIELD_BLANK,
        IDS_E_REQUIREDEXTERNAL_BLANK,		
        L""
    },  

	{	PP_E_INVALID_PHONENUMBER,
		IDS_E_INVALID_PHONENUMBER,
		L""
	},
	{
		PP_E_PHONENUMBER_EXIST,
		IDS_E_PHONENUMBER_EXIST,
		L""
	},

	{
		PP_E_MISSING_PHONENUM,
		IDS_E_MISSING_PHONENUM,
		L""
	}


};     


struct  PPHELP_MAP
{
    PCSTR                   szField;
    DWORD                   dwResourceID;
}; 

static PPHELP_MAP sgProfileHelpMap[] =
{
    {   "Email",
        IDS_H_EMAIL 
    },

    {   "EmailAsName",
        IDS_H_EMAIL_AS_NAME 
    },

    {   "Password",
        IDS_H_PASSWORD
    }, 

    {   "SecretQuestion",
        IDS_H_SQA
    },

    {   "SignInName",
        IDS_H_NAME
    },
};

LPCWSTR ProfileHR2XMLCode(HRESULT hr);

ULONG ProfileHR2ResID(HRESULT hr);

ULONG ProfileField2HelpResID(LPSTR szField);

#endif //#if !defined(__PPERRMAP_H__)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\ppmgrver.h ===
//-----------------------------------------------------------------------------
//
//  @doc
//
//  @module ppmgrver.h
//
//  Author: mikeguo
//
//  Date:   2/22/2001
//
//  Copyright <cp> 1999-2001 Microsoft Corporation.  All Rights Reserved.
//
//  header file to contain ppmgr version structure.
//
//-----------------------------------------------------------------------------

#pragma once
class PPMGRVer
{
public:
    PPMGRVer() { MajorVersion = 0; }
    ULONG MajorVersion;
/* FUTURE: following aren't needed in 2.0    
    ULONG Minor1; 
    ULONG Minor2; 
    ULONG Minor3; 
*/    
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\posixheap.hpp ===
#ifndef _POSIX_HEAP_HPP_
#define _POSIX_HEAP_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "DefaultHeap.hpp"
 
    /********************************************************************/
    /*                                                                  */
    /*   The standard posix interface.                                  */
    /*                                                                  */
    /*   The Posix interface allows Rockall to be linked into Unix      */
    /*   applications with a minimal amount of fuss.  Although the      */
    /*   function names are not identical to the posix names (so as     */
    /*   to avoid name clashes) functionally they are close enough      */
    /*    to be simple replacements.                                    */
    /*                                                                  */
    /********************************************************************/

inline void *Calloc( int Size )
	{ return DefaultHeap.New( Size,NULL,true ); }

inline bool Free( void *Address,int Size = NoSize )
	{ return DefaultHeap.Delete( Address,Size ); }

inline void *Malloc( int Size )
	{ return DefaultHeap.New( Size ); }

inline void *Realloc( void *Address,int NewSize )
	{ return DefaultHeap.Resize( Address,NewSize ); }
#ifdef POSIX_EXTENSIONS

    /********************************************************************/
    /*                                                                  */
    /*   Extensions to the posix interface.                             */
    /*                                                                  */
    /*   The Posix interface is fairly restricted and only gives        */
    /*   access to a small portion of Rockall.  The functions that      */
    /*   follow expose additional Rockall functionality.                */
    /*                                                                  */
    /********************************************************************/

inline void DeleteAll( bool Recycle = true )
	{ DefaultHeap.DeleteAll( Recycle ); }

inline bool MultipleFree
		( 
		int				Actual,
		void			*Array[],
		int				Size = NoSize
		)
	{ return DefaultHeap.MultipleDelete( Actual,Array,Size ); }

inline bool MultipleMalloc
		( 
		int				*Actual,
		void			*Array[],
		int				Requested,
		int				Size
		)
	{ return DefaultHeap.MultipleNew( Actual,Array,Requested,Size ); }
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\pperrres.h ===
#define IDS_E_NAME_BLANK                                    1
#define IDS_E_NAME_TOO_SHORT                                2
#define IDS_E_NAME_TOO_LONG                                 3
#define IDS_E_NAME_INVALID                                  4
#define	IDS_E_NAME_EXIST                                    5
#define IDS_E_PASSWORD_BLANK                                6
#define IDS_E_PASSWORD_TOO_SHORT                            7
#define IDS_E_PASSWORD_TOO_LONG                             8
#define IDS_E_PASSWORD_CONTAINS_MEMBERNAME                  9
#define IDS_E_PASSWORD_INVALID                              10
#define IDS_E_PASSWORD_MISMATCH                             11
#define IDS_E_SECRETQA                                      12
#define IDS_E_SECRETQA_DUPLICATE_Q                          13
#define IDS_E_SECRETQA_DUPLICATE_A                          14
#define IDS_E_SECRETQA_NOMATCH                              15
#define IDS_E_LOCATION_INVALID_COUNTRY                      16
#define IDS_E_LOCATION_INVALID_REGION                       17
#define IDS_E_LOCATION_INVALID_POSTALCODECHARS              18
#define IDS_E_LOCATION_INVALID_POSTALCODE                   19
#define IDS_E_EMAIL_BLANK                                   20
#define IDS_E_EMAIL_INVALID                                 21
#define IDS_E_EMAIL_RIGHT_TOO_LONG                          22
#define IDS_E_EMAIL_INVALID_CHARS                           23
#define IDS_E_EMAIL_INCOMPLETE                              24
#define	IDS_E_EMAIL_MEMBER_EXIST                            25
#define	IDS_E_EMAIL_MANAGED                                 26
#define IDS_E_GENDER                                        27
#define IDS_E_BIRTHDATE                                     28
#define IDS_E_NICKNAME_BLANK                                29
#define IDS_E_FIRSTNAME_BLANK                               30
#define IDS_E_LASTNAME_BLANK                                31
#define IDS_E_OCCUPATION_BLANK						        32
#define	IDS_E_TIMEZONE_BLANK				                33
#define IDS_E_REQUIREDEXTERNAL_BLANK						34
#define IDS_E_INVALID_PHONENUMBER							35
#define IDS_E_PHONENUMBER_EXIST								36
#define IDS_E_MISSING_PHONENUM								37	
    
#define IDS_H_EMAIL                                         50
#define IDS_H_EMAIL_AS_NAME                                 51
#define IDS_H_NAME                                          52
#define IDS_H_PASSWORD                                      53
#define IDS_H_SQA                                           54
#define IDS_H_FLNAME                                        55

#define IDS_E_PIN_BLANK										76
#define IDS_E_PIN_TOO_SHORT									77
#define IDS_E_PIN_TOO_LONG 									78	
#define IDS_E_PIN_CONTAINS_MEMBERNAME						79
#define IDS_E_PIN_INVALID  									70
#define IDS_E_PIN_MISMATCH 									81
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\ppstorage.h ===
// PPStorage.h: interface for the CPPStorage class.
//
//////////////////////////////////////////////////////////////////////
#if !defined(AFX_PPSTORAGE_H__C9A5FAC1_64E7_4574_92B1_F870EB8DB633__INCLUDED_)
#define AFX_PPSTORAGE_H__C9A5FAC1_64E7_4574_92B1_F870EB8DB633__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "ssocore.h"

// this enum is used to manually specify which database to go to (read or
// write).  The default is OBEYCOOKIE which means decide which db to go
// to based on contents of MSPLDBW cookie.
typedef enum 
{
    OBEYCOOKIE = 0, // go to read or write db depending on MSPLDBW cookie
    FROMREAD,       // go to read db
    FROMWRITE       // go to write db
}
PPDBTARGET;

class CPPStorage  
{
public:
    CPPStorage() { };
    virtual ~CPPStorage() {};
    static void GetAgent(IPControl *pobjStorage, IPDBAgentEx **ppIPDBAgent);
    static void BindTo(IPDBAgentEx *pIPDBAgent, long lProcedure, PPDBTARGET target = OBEYCOOKIE);

    static HRESULT SetItemWChar(IPDBAgentEx *pIPDBAgent, long lColumn, LPCWSTR pwszValue);
    static HRESULT SetItemDate(IPDBAgentEx *pIPDBAgent, long lColumn, DATE ddate);
    static HRESULT SetItemLong(IPDBAgentEx *pIPDBAgent, long lColumn, long lLong);

    static HRESULT GetItemBstr(IPRow *pIPRow, long lColumn, BSTR *pBstr); 
    static HRESULT GetItemObject(IPRow *pIPRow, long lColumn, REFIID riid, LPVOID *ppvoid);
    static HRESULT GetItemDate(IPRow *pIPRow, long lColumn, DATE *pDate);
    static HRESULT GetItemLong(IPRow *pIPRow, long lColumn, long *pLong);

    static HRESULT Go(IPDBAgentEx *pIPDBAgent, bool bWrite=false) ;

    static HRESULT GetRow(IPDBAgentEx *pIPDBAgent, IPRow **ppIPRow);
    static HRESULT GetRowSet(IPDBAgentEx *pIPDBAgent, IPRowset **ppIRowset);

protected:
    static HRESULT Error(HRESULT hr);
};

class CPPSingleRowStorage : public CPPStorage
{
public:
    CPPSingleRowStorage() { m_lProcedure = 0;};
    virtual ~CPPSingleRowStorage() {};

    void BindTo(long lProcedure, PPDBTARGET target = OBEYCOOKIE);
    HRESULT SetItemWChar(long lColumn, LPCWSTR pwszValue);
    HRESULT SetItemDate(long lColumn, DATE ddate);
    HRESULT SetItemLong(long lColumn, long lLong);

    void GetItemBstr(long lColumn, CComBSTR &bstrRet);
    DATE GetItemDate(long lColumn);
    long GetItemLong(long lColumn);
	void GetItemAsObject(long lColumn, REFIID riid, LPVOID *ppvoid);

    HRESULT Go(bool bWrite=false) ;

    IPDBAgentEx *GetDBAgent();    // ref-counted, owner must release it: use CComPtr
                                // get rid of it after Darren get rid of the use of it.

protected:
    virtual void ReuseObject();
    CComPtr<IPDBAgentEx> m_pIPDBAgent;
    CComPtr<IPRow> m_pIPRow;
	long m_lProcedure;
};

class CPPCoreProfileStorage : public CPPSingleRowStorage
{
public:
    CPPCoreProfileStorage() { };
    virtual ~CPPCoreProfileStorage() {};

	BSTR GetPassword();
    bool ComparePassword(LPCWSTR lpwszPassword);

    HRESULT GetCoreProfile(LPCWSTR lpwszMemberName, PPDBTARGET target = OBEYCOOKIE);

protected:
    void ReuseObject();
    CComPtr<IPData> m_pIPData;
};

#endif // !defined(AFX_PPSTORAGE_H__C9A5FAC1_64E7_4574_92B1_F870EB8DB633__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\ppstring.h ===
#if !defined(CPPStringW_INCLUDE)
#define CPPStringW_INCLUDE

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CPPStringW: public CStringW
{
public:
	CPPStringW() {};
	~CPPStringW() {};
	void TrimBlanks()
	{
        TrimLeft();
        TrimRight();
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\pphandlerbase.h ===
//---------------------------------------------------------------------------------------
//
//   @doc
// 
//   @module pphandlerbase.h 
//    
//   Author: stevefu
//   
//   Date: 04/28/2000 
//
//  Copyright <cp> 1999-2000 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------------------

#if !defined(PPHANDLERBASE_H_INCLUDED__)
#define PPHANDLERBASE_H_INCLUDED__

#pragma once

#if (!defined(_UNICODE) || !defined(UNICODE) ) 
#error Passport Handler must be built with _UNICODE and UNICODE defined.
#endif // built w/ UNICODE only, all CString are assumed as CStringW

#include "pputils.h"
#include "ppurl.h"
#include "passportexception.h"
#include "ppmgrver.h"

class CPassportLocale;
class CBrowserInfo;
class CPassportCommonUIInfo;

//-----------------------------------------------------------------------------
//
//  @class CPassportHandlerBase | non-template interface class.
//  If your codes are being used within a Passport ISAPI Handler, you can 
//  get access to the current active handler by calling 
//  CPassportHandlerBase::GetPPHandler().  That saves you from passing 
//  a global pointer everywhere in your codes.
//  Note there are some caveats:
//    1. This works on per-thread scope. If you write an async handler,
//       you will have some glitch.
//    2. If you have a handler include chain (in a single processing thread), 
//       only the top level handler is returned by CPassportHandlerBase::GetPPHandler().
//    3. This method does not work with multiple handler DLLs. In other word,
//       child ( sub or include )handlers in a different DLL can NOT get to the 
//       top level handler.
//
//	If you have a CPassportHandlerBase object/pointer you can also use 
//  GetTopHandler to get access to the first handler within a request.
//  This does NOT limit to single thread request and works across multiple
//  request handler DLL.
//
//  Parent and child handlers can also communicate with each other by calling 
//	AddPerRequestObj, GetPerRequestObj, RemovePerRequestObj.  Note you must 
//  remove all objects before the destrutor of top handler to avoid memory leak.
//
//-----------------------------------------------------------------------------
class CPassportHandlerBase 
{
public:
    // @cmember static function to retrieve per-thread handler object
    inline static CPassportHandlerBase* GetPPHandler()
	{
		ATLASSERT(m_TlsIndex.x > 0 );
		CPassportHandlerBase* h = (CPassportHandlerBase*)TlsGetValue(m_TlsIndex.x);
		if ( GetLastError() != 0 ) return NULL;
		else return h;
	}

	// Numeric constants to control parameter translation, can be ORed.
	// UNICODE conversion is always performed.
    enum INPUT_CONVERSION_FLAG 
    {
	    CI_HTML_NUMERIC_DECODE     = 0x1,
		CI_ESCAPE_SCRIPT_INJECTION = 0x2,
		CI_URL_UNESCAPE            = 0x4,
		CI_FLAG_DEFAULT = CI_HTML_NUMERIC_DECODE   
    };
    enum OUTPUT_CONVERSION_FLAG
    {
    	CO_HTML_NUMERIC_ENCODE     = 0x1,
		CO_ESCAPE_SCRIPT_INJECTION = 0x2,
		CO_URL_ESCAPE              = 0x4,
		CO_FLAG_DEFAULT = CO_HTML_NUMERIC_ENCODE | CO_ESCAPE_SCRIPT_INJECTION   
    };

	//  @cmember retrieve the top level handler object
	virtual CPassportHandlerBase* GetTopHandler() = 0;	
	virtual BOOL IsTopHandler() = 0;


	enum 
	{
		OBJID_TOPHANDLER = 0,     // reserve ID 0 to support GetTopHandler
        OBJID_BASEID_END = 100,   // custom ID should be after this one
        OBJID_LOGIN_REQUEST = 101 // login request object.
	};

	// @cmember support per-request object sharing		
	virtual BOOL AddPerRequestObj(unsigned id, void* pObj) = 0;
	virtual BOOL RemovePerRequestObj(unsigned id ) = 0;
	virtual void* GetPerRequestObj(unsigned id ) = 0;

    // @cmember retrieve global object
    virtual HRESULT GetGlobalObj(REFGUID objid,	REFIID riid, void**pobj) = 0;

    // @cmember retrieve and convert parameter from query string
    virtual void GetWParam(LPCSTR szParamName, CStringW& wOut, unsigned flag = CI_FLAG_DEFAULT) = 0;
    // @cmember retrieve and convert parameter from query string and/or form variable
    virtual void GetWFormVar(LPCSTR szParamName, CStringW& wOut, unsigned flag = CI_FLAG_DEFAULT) = 0;
    // @cmember retrieve and convert cookie
    virtual void GetWCookie(LPCSTR szParamName, CStringW& wOut, unsigned flag = CI_FLAG_DEFAULT) = 0;
    // @cmember retrieve and convert cookie
    virtual void GetACookie(LPCSTR szParamName, CStringA& wOut, unsigned flag = CI_FLAG_DEFAULT) = 0;
    // @cmember retrieve and convert server variable
    virtual void GetWServerVariable(LPCSTR szParamName, CStringW& wOut, unsigned flag = 0) = 0;    
    virtual void GetAServerVariable(LPCSTR szParamName, CStringA& aOut, unsigned flag = 0) = 0;    
    // @cmember retrieve and convert a request item from query string, form, cookies
    //          or server variables.
    virtual void GetWItem(LPCSTR szItem, CStringW& wOut, unsigned flag = CI_FLAG_DEFAULT) = 0;

    // @cmember retrieve and convert parameter from query string.
    // note the contents of parameter must be in ASCII only, not MBCS.
	virtual void GetAParam(LPCSTR szParamName, CStringA& aOut, unsigned flag = CI_FLAG_DEFAULT) = 0;
    // @cmember retrieve and convert item    
    // note the contents of retrieved item must be in ASCII only, not MBCS.
	virtual void GetAItem( LPCSTR szItemName, CStringA& aOut, unsigned flag = CI_FLAG_DEFAULT) = 0;
    // @cmember retrieve a long parameter
    virtual long GetParamLong(LPCSTR szParamName) = 0;
    // @cmember retrieve a long item
    virtual long GetItemLong(LPCSTR szItemName) = 0;
    
    // @cemeber return browser info object
    virtual CBrowserInfo* GetBrowserInfo() = 0; 
	// @cmember retrieve the full locale object
	virtual CPassportLocale* GetRequestLocale() = 0 ;
	// @cmember retrieve the ui info object
	virtual CPassportCommonUIInfo* GetCommonUIInfo() = 0 ;
	// @cmember retrieve the http request object
	virtual CHttpRequest* GetHttpRequest() = 0 ;
	// @cmember retrieve the http response object
    virtual CHttpResponse* GetHttpResponse() = 0;

	// @cmember MBCS/Unicode helper using codepage for the active request	
	virtual void Mbcs2Unicode(LPCSTR  pszIn, BOOL bNEC, CStringW& wOut) = 0;
	// @cmember Unicode/MBCS helper using codepage for the active request
	virtual void Unicode2Mbcs(LPCWSTR pwszIn, BOOL bNEC, CStringA& aOut) = 0;

    // @cmember add a cookie to the current response
    virtual void SetCookie(LPCSTR   szName, 
                           LPCSTR   szValue,
                           LPCSTR   szExpiration= NULL,
                           LPCSTR  szCookieDomain = NULL,
                           LPCSTR  szCookiePath = NULL,
                           bool    bSecure = false
                           ) = 0;

    // @cmember add a cookie to the current response
    virtual void SetCookie(LPCSTR   szName, 
                           LPCWSTR  szValue,
                           LPCSTR   szExpiration= NULL,
                           LPCSTR  szCookieDomain = NULL,
                           LPCSTR  szCookiePath = NULL,
                           bool    bSecure = false
                           ) = 0;

    // @cmember add a cookie to the current response
    virtual void SetCookie(CCookie& cookie) = 0;

	// @cmember get domain attribute from PassportManager
	virtual HRESULT GetDomainAttribute(
                    const BSTR      bstrAttrName,         //@parm the attribute name
            			               LPCWSTR pwszDomain,
                        			   CComBSTR& cbstrValue) = 0;

 	// @cmember sets PP_SERVICE parameter for cobranding
    virtual void SetPPService(LPCSTR strService) = 0;

 	// @cmember sets PP_PAGE parameter for cobranding
 	virtual void SetPPPage(LPCSTR strPage) = 0;

 	virtual long GetPassportID() = 0;
#pragma warning( disable: 4172 )
    virtual const PPMGRVer & GetPPMgrVersion() { ATLASSERT(false); return PPMGRVer(); };
#pragma warning( default: 4172 )
 	virtual void AddGlobalCarryThru(CPPUrl &url) { ATLASSERT(false); }

protected:
    // @cmember <md m_TlsIndex> is used for Tls purpose. Note this is global to 
    // the whole DLL.
	static struct CTlsIndex
	{
		DWORD x;
		CTlsIndex() { x = TlsAlloc(); }
		~CTlsIndex() { if ( x ) TlsFree(x); }
	} m_TlsIndex;
	
};


//-----------------------------------------------------------------------------
//  Static member init.
//  Note constructor is called before DllMain() with runtime
//  static/global init so that we don't have to force re-write 
//  DllMain for every single handler DLL
//-----------------------------------------------------------------------------
__declspec(selectany) 
struct CPassportHandlerBase::CTlsIndex CPassportHandlerBase::m_TlsIndex;


#endif //PPHANDLERBASE_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\pptrace.h ===
/**************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name:

    pptrace.h 

Abstract:

    Event tracing header file

Author:

    Naiyi Jiang

Revision History:

***************************************************************/

#pragma once

#pragma warning(disable:4786)
#include <sstream> // use ostringstream
//using namespace std;

#define MAXSTR 4096
#define MAXNAME 512

#define ARGUMENT_PRESENT(ArgPtr) ( (CHAR*)(ArgPtr) != (CHAR*)(NULL) )

// Macros that allow the file name and line number to be passed in as a string.
#ifndef FILE_AND_LINE
#define LineNumAsString(x)	#x
#define LineNum(x)			LineNumAsString(x)
#define FILE_AND_LINE		__FILE__"_"LineNum(__LINE__)
#endif

// Use these macros in your components
#define PPTracePrint		if (PPTraceStatus::TraceOnFlag) TracePrint
#define PPTraceFunc			CTraceFunc
#define PPTraceFuncV		CTraceFuncVoid

// Use these macros to supply level and szFileAndName argument
// Additional levels (upto 255) can be defined
#define PPTRACE_ERR		0, FILE_AND_LINE
#define PPTRACE_RAW		1, FILE_AND_LINE
#define PPTRACE_FUNC	2, FILE_AND_LINE
#define PPTRACE_VERB	3, FILE_AND_LINE

// Use PPInitTrace/PPEndTrace at the entry/exit points of a component
ULONG PPInitTrace(LPGUID pControlGuid);
ULONG PPEndTrace();


namespace PPTraceStatus {
	extern bool TraceOnFlag;
	extern UCHAR EnableLevel;
	extern ULONG EnableFlags;
}

//
// Don't use the following functions and class names directly
// Use them via above macros
//
VOID TracePrint(UCHAR Level, LPCSTR szFileAndLine, LPCSTR ParameterList OPTIONAL, ...);
ULONG TraceString(UCHAR Level, IN LPCSTR szBuf); 
ULONG TraceString(UCHAR Level, IN LPCWSTR wszBuf); 
ULONG64 GetTraceHandle();
void SetTraceHandle(ULONG64 TraceHandle);

// Template class to trace functions with a reference type T argument
template <class T> class CTraceFunc  
{
public:
	CTraceFunc(UCHAR Level, LPCSTR szFileAndLine, T & ret, LPCSTR szFuncName, LPCSTR ParameterList = NULL, ...) : m_Level(Level), m_ret(ret)
	{
		//  no data generated for the following two cases
		if (!PPTraceStatus::TraceOnFlag || m_Level > PPTraceStatus::EnableLevel)
			return;

		strncpy(m_szFuncName, szFuncName, MAXNAME-1);

		CHAR buf[MAXSTR];
    
		int len = _snprintf(buf, MAXSTR-1, "+%s(", m_szFuncName);
		int count = 0;
		if (ARGUMENT_PRESENT(ParameterList)) {
				va_list parms;
				va_start(parms, ParameterList);
				count = _vsnprintf(buf+len, MAXSTR-len-1, (CHAR*)ParameterList, parms);
				len = (count > 0) ? len + count : MAXSTR - 1;
				va_end(parms);
		}
		if (len < (MAXSTR - 1))
		{
			CHAR* pStr = strrchr(szFileAndLine, '\\');
			if (pStr)
			{
				pStr++; //remove '\'
				_snprintf(buf+len, MAXSTR-len-1, ")@%s", pStr);
			}
		}

		TraceString(m_Level, buf); 
	};

	virtual ~CTraceFunc()
	{
		//  no data generated for the following two cases
		if (!PPTraceStatus::TraceOnFlag || m_Level > PPTraceStatus::EnableLevel)
			return;
		
		std::ostringstream ost;
		ost << "-" << m_szFuncName << "=" << m_ret;  
		TraceString(m_Level, ost.str().c_str()); 
	};

private:
	UCHAR m_Level;
	T m_ret;
	CHAR m_szFuncName[MAXNAME];
};

// class to trace void type function
class CTraceFuncVoid  
{
public:
	CTraceFuncVoid(UCHAR Level, LPCSTR szFileAndLine, LPCSTR szFuncName, LPCSTR ParameterList = NULL, ...);
	virtual ~CTraceFuncVoid();

private:
	UCHAR m_Level;
	CHAR m_szFuncName[MAXNAME];
};

//
// old tracing stuff to be removed?
//
// the default (all) flag with each trace level
//#define TRACE_FLOW_ALL  0xFFFFFFFF
//#define TRACE_WARN_ALL  0xFFFFFFFF
//#define TRACE_ERR_ALL   0xFFFFFFFF
#define TRACE_FLOW_ALL  0
#define TRACE_WARN_ALL  0
#define TRACE_ERR_ALL   0

// category flag (define your own!)
#define TRACE_TAG_REG   0x00000001
#define TRACE_TAG_foo1  0x00000002
#define TRACE_TAG_foo2  0x00000004

// level
#define TRACE_INFO      0x10000000
#define TRACE_WARN      0x20000000
#define TRACE_ERR       0x40000000


typedef enum {
    None,
    Bool,
    Int,
    Dword,
    HResult,
    String,
    WString,
    Pointer
} TRACE_FUNCTION_RETURN_TYPE;


VOID
PPInitTrace(LPWSTR wszAppName);


VOID
PPFuncEnter(
    DWORD Category,
    LPCSTR Function,
    LPCSTR ParameterList OPTIONAL,
    ...
    );

VOID
PPFuncLeave(
    IN DWORD Category,
    IN TRACE_FUNCTION_RETURN_TYPE ReturnType,
    IN DWORD_PTR Variable,
    IN LPCSTR Function,
    IN LPCSTR ParameterList OPTIONAL,
    ...
    );

VOID
PPTrace(
    DWORD Category,
    DWORD Level,
    LPCSTR ParameterList OPTIONAL,
    ...
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\profilefieldsconsts.h ===
// names of supported credential fields ....
#define CRED_MEMBERNAME                 "SignInName"
#define CRED_DOMAIN						"Domain"
#define CRED_PASSWORD                   "Password"
#define CRED_CONFIRMPASSWORD            "ConfirmedPassword"
#define CRED_SECRETQ                    "SecretQuestion"
#define CRED_SECRETA                    "SecretAnswer"

#define	CRED_MOBILEPHONE				"MobilePhone"
#define CRED_MOBILEPIN					"MobilePin"
#define CRED_CONFIRMMOBILEPIN			"ConfirmedMobilePin"

#define	CRED_SA_PIN						"SecurePIN"
#define CRED_SA_CONFIRMPIN			    "ConfirmSecurePIN"
#define CRED_SA_SECRETQ1					"SecretQ1"
#define CRED_SA_SECRETQ2					"SecretQ2"
#define CRED_SA_SECRETQ3					"SecretQ3"
#define CRED_SA_SECRETA1					"SecretA1"
#define CRED_SA_SECRETA2					"SecretA2"
#define CRED_SA_SECRETA3					"SecretA3"
#define CRED_SA_SECRETA1_VERIFY			"SecretA1Verify"
#define CRED_SA_SECRETA2_VERIFY			"SecretA2Verify"
#define CRED_SA_SECRETA3_VERIFY			"SecretA3Verify"
#define CRED_SA_HIDDEN_FLAG			    "HiddenFlag"



// names of supported profile fields ....

#define PROF_EMAIL                      "Email"
#define PROF_BIRTHDATE                  "Birthdate"
#define PROF_COUNTRY                    "Country"
#define PROF_REGION                     "Region"
#define PROF_POSTALCODE                 "PostalCode"
#define PROF_GENDER                     "Gender"
#define PROF_LANGUAGE                   "PrefLanguage"
#define PROF_ACCESSIBILITY              "Accessibility"
#define PROF_NICKNAME                   "NickName"
#define PROF_FIRSTNAME                  "FirstName"
#define PROF_LASTNAME                   "LastName"
#define PROF_TIMEZONE                   "TimeZone"
#define PROF_OCCUPATION                 "Occupation"

//
//These profile fields below are not persisted in DB.
//They are viewed as (non-persist) external items.
//The difference between these fields and partner customized external items
//is their SectionID=-1 
#define PROF_VOLATILE_SAVEPASSWORD		"SavePassword"


// names of system fields ...
#define SYSTEM_WALLET                     "Wallet"
#define SYSTEM_DIR1_HMMPP                 "Dir1_HM_MPP"
#define SYSTEM_DIR2_HMDIRSEARCH           "Dir2_HM_DirSearch"
#define SYSTEM_DIR3_HMWHITEPAGE           "Dir3_HM_WhitePage"
#define SYSTEM_DIR4_PPMPP                 "Dir4_PP_MPP"

#define SYSTEM_BIRTHDATE_PRECISION		  "BirthdatePrecision"
#define SYSTEM_PROFILEVERSION             "ProfileVersion"

#define SYSTEM_FLAG1					  "Flag1_PreferredEmailVerified"
#define SYSTEM_FLAG2					  "Flag2_HMActivated"
#define SYSTEM_FLAG3					  "Flag3_HMPwdRecovered"
#define SYSTEM_FLAG4					  "Flag4_WalletUpload"
#define SYSTEM_FLAG5					  "Flag5_HMMemberBlocked"
#define SYSTEM_FLAG6_7					  "Flag6_7_AffiliateConsent"
#define SYSTEM_FLAG8_9					  "Flag8_9_AccountType"
#define SYSTEM_FLAG10					  "Flag10_EASI"
#define SYSTEM_FLAG11					  "Flag11_PPEmailVerified"
#define SYSTEM_FLAG12					  "Flag12_MSNIA"
#define SYSTEM_FLAG13					  "Flag13_MSNMOBILE"
//#define SYSTEM_FLAG31					  "Flag31_NOTUSED"
#define SYSTEM_FLAG32					  "Flag32_KidConsentCookie"

// misc bit 2 is a bit 1 (EMAIL) in profileconsent field (under profileconsent) category
#define SYSTEM_MISC1_PPMARKETING		  "Misc1_PP_Marketing"


#define SYSTEM_DOMAINADMIN					"DomainAdministrator"

   
  
//  -1, 'ProfileConsent'
   



//
// Starting point for a field cateogry
// Never change these numbers without consulting NexusDB
//
#define FIELD_INVALID			0x0000
#define CREDENTIAL_FIRST_TAG	0x0001
#define PROFILE_FIRST_TAG		0x10000
#define SYSTEM_FIRST_TAG		0x20000
#define	CONSENT_FIRST_TAG		0x30000
#define NEXT_CATEGORY_FIRST_TAG	0x40000
#define CREDENTIAL_LAST_TAG		(PROFILE_FIRST_TAG-1)
#define PROFILE_LAST_TAG		(SYSTEM_FIRST_TAG-1)
// Suwat is putting some system flags that runtime shouldn't load
// These flags would be at the high end of the system ID's
// Ignore those
#define SYSTEM_LAST_TAG			(CONSENT_FIRST_TAG-1 - 0x300)
#define CONSENT_LAST_TAG		(NEXT_CATEGORY_FIRST_TAG -1)


// email sq credential
#define FIELD_CRED_MEMBERNAME		0x0001
#define FIELD_CRED_PASSWORD			0x0002
#define FIELD_CRED_SECRETQ			0x0003
#define FIELD_CRED_SECRETA			0x0004
#define FIELD_CRED_CONFIRMPASSWORD	0x0005
// secure token pin 3qa credential
#define FIELD_CRED_SA_SECRETQ1		0x0006
#define FIELD_CRED_SA_SECRETQ2		0x0007
#define FIELD_CRED_SA_SECRETQ3		0x0008
#define FIELD_CRED_SA_SECRETA1		0x0009
#define FIELD_CRED_SA_SECRETA2		0x000A
#define FIELD_CRED_SA_SECRETA3		0x000B
#define FIELD_CRED_SA_PIN			0x000C
#define FIELD_CRED_SA_CONFIRMPIN	0x000D
#define FIELD_CRED_SA_SECRETA1_VERIFY	0x000E
#define FIELD_CRED_SA_SECRETA2_VERIFY	0x000F
#define FIELD_CRED_SA_SECRETA3_VERIFY	0x0010
#define FIELD_CRED_SA_HIDDEN_FLAG	0x0011
//mobile pin credential
#define FIELD_CRED_MOBILEPHONE		0x0012
#define FIELD_CRED_MOBILEPIN		0x0013
#define FIELD_CRED_CONFIRMMOBILEPIN	0x0014

//
// cred flags needed for barry's delegated admin
// These are not real fields at all.  Don't use them to call into CUserProfile
#define FIELD_CRED_DBFLAG_ACTIVE	0xFFFD
#define FIELD_CRED_DBFLAG_MANAGED	0xFFFE




// consent
#define FIELD_CONSENT_PROFILE		CONSENT_FIRST_TAG
#define FIELD_CONSENT_CREDENTIAL	CONSENT_FIRST_TAG + 1
#define FIELD_CONSENT_SYSTEM		CONSENT_FIRST_TAG + 2



// Use for Site 3, device=web, in order to get traditional passport core fields.
#define DEFAULT_DEVICESTYLE_WEB		"web"
#define DEFAULT_DEVICESTYLE_WIZ		"wiz"


//
//
//
#define QRY_PAGE		"pppage"
#define QRY_PPDIRECTION	"ppdir"
#define QRY_RST			"rst"
#define QRY_PPERR		"pperr"
//#define FORM_IS_SPECIAL_PASSWORD_PAGE		"HiddenSpecialPasswordPage"

#define QRY_VALUE_PPDIRECTION_NEXT	"next"
#define QRY_VALUE_PPDIRECTION_PREV	"prev"
#define QRY_VALUE_PPERROR_MEMBEREXIST "1"
//#define FORM_VALUE_IS_SPECIAL_PASSWORD_PAGE		"1"

#define DEVICE_ATTRIBUTE_WIZARDAFTER	"WizardPageAfter"
#define DEVICE_ATTRIBUTE_WIZARDBEFORE	"WizardPageBefore"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\ppurl.h ===
// PPUrl.h: interface for the CPPUrl class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PPURL_H__7AF434BC_E9A3_4288_9B3F_F7BA9FD68B4E__INCLUDED_)
#define AFX_PPURL_H__7AF434BC_E9A3_4288_9B3F_F7BA9FD68B4E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CPPQueryString: protected CStringA
{
public:
    CPPQueryString() 
    { 
        Preallocate(ATL_URL_MAX_URL_LENGTH); 
        m_psz=NULL; 
        m_pszBegin=NULL;
        m_bLockedCString = false;
    };
    virtual ~CPPQueryString() { Uninit(true); };

    void AddQueryParam(LPCSTR pszParamName, LPCSTR pszParamValue, bool fEncoding=false);
    void AddQueryParam(LPCSTR pszParamName, LPCWSTR pwszParamValue, bool bTrueUnicode, bool fEncoding=false);
    void Set(LPCSTR lpsz); 
    void Set(LPCWSTR lpwsz); 
    bool StripQueryParam(LPCSTR pszParamName);
    operator CStringA * () { Uninit(false); return (CStringA *) this; }
    operator LPCSTR () { return m_pszBegin; }
    inline bool IsEmpty()
    {
        return (m_psz - m_pszBegin) > 0 ? false : true;
    }

protected:
    //char m_szUrl[ATL_URL_MAX_URL_LENGTH];
    char *m_psz;
    char *m_pszBegin;
    void DoParamAdd(LPCSTR pszParamValue, bool fEncoding);
    void DoParamAdd(LPCWSTR pwszParamValue, bool fEncoding);
    void Reinit();
    void Uninit(bool bUnlock);
    char *LockData()
    {
        if (m_bLockedCString)
        {
            UnlockBuffer();     // balanced the last LockBuffer;
            return LockBuffer();
        }
        m_bLockedCString = true;
        return LockBuffer();
    };
    void UnlockData()
    {
        if (m_bLockedCString)
        {
            m_bLockedCString = false;
            UnlockBuffer();     // balanced the last LockBuffer;
        }
    }
    bool m_bLockedCString;
private:
    CPPQueryString & operator= (const CPPQueryString cp) { return *this; };
};

class CPPUrl : protected CPPQueryString
{
public:
    CPPUrl(CPPUrl &cp) { Set((LPCSTR)cp); } ;       // prevent copy operations, as in = assignment.
    CPPUrl(LPCSTR pszUrl=NULL);
    virtual ~CPPUrl() {};

    static BOOL GetQParamQuick(LPCSTR qsStart, LPCSTR name, UINT nameStrLen, LPCSTR& qpStart, LPCSTR& qpEnd);
    inline BOOL GetQParamQuick(LPCSTR name, UINT nameStrLen, LPCSTR& qpStart, LPCSTR& qpEnd) const
    {
        return GetQParamQuick(GetQString(), name, nameStrLen, qpStart, qpEnd);
    };
    
    static BOOL GetQParamQuick(LPCSTR qsStart, LPCSTR name, UINT nameStrLen, INT& value);
    inline BOOL GetQParamQuick(LPCSTR name, UINT nameStrLen, INT& value) const
    {
        return GetQParamQuick(GetQString(), name, nameStrLen, value);
    };

    LPCSTR GetQString() const { return m_pszQuestion ? m_pszQuestion + 1 : NULL;};
    ULONG GetLength() 
    { 
        Reinit();
        return (ULONG)(m_psz - m_pszBegin);
    };
    void Set(LPCSTR lpsz); 
    void Set(LPCWSTR lpwsz); 
    void AddQueryParam(LPCSTR pszParamName, long lValue);
    void AddQueryParam(LPCSTR pszParamName, LPCSTR pszParamValue, bool fEncoding=false);
    void AddQueryParam(LPCSTR pszParamName, LPCWSTR pwszParamValue, bool bTrueUnicode, bool fEncoding=false);
    void ReplaceQueryParam(LPCSTR pszParamName, LPCSTR pszParamValue);

	inline  bool StripQueryParam(LPCSTR pszParamName)
	{
		return CPPQueryString::StripQueryParam(pszParamName);
	}
    void InsertBQueryString(LPCSTR pszQueryString);
    void AppendQueryString(LPCSTR pszQueryString);
    void MakeSecure();
    void MakeNonSecure();
    operator CStringA * () { Uninit(false); return ((CStringA *) this); }
    operator LPCSTR () { Reinit(); return m_pszBegin; }
    bool IsSecure()
    {
        return (0 == _strnicmp((LPCSTR) *this, "https:", 6));
    }
    inline bool IsEmpty()
    {
        return CPPQueryString::IsEmpty();
    }
    inline BOOL UrlEncode(LPSTR szBuf, PULONG pulBufLen)
    {
        return AtlEscapeUrlA((LPCSTR) *this,
                             szBuf, 
                             pulBufLen, 
                             *pulBufLen, 
                             ATL_URL_ESCAPE);
    }
    void MakeFullUrl(LPCSTR pszUrlPath, bool bSecure);
    void ReplacePath(LPCSTR pszUrlPath);
    CPPUrl & operator += (LPCSTR pcszAppend);

private:
    CPPUrl & operator= (const CPPUrl cp) { return *this; };
    char *m_pszQuestion;
    void Reinit();
};

#endif // !defined(AFX_PPURL_H__7AF434BC_E9A3_4288_9B3F_F7BA9FD68B4E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\pputils.h ===
//---------------------------------------------------------------------------------------
//
//   @doc
// 
//   @module pputils.h | Passport utilities. 
//    
//   Author: stevefu
//   
//   Date: 05/01/2000 
//
//---------------------------------------------------------------------------------------

#if !defined(PPUTILITIES_H__INCLUDED_)
#define PPUTILITIES_H__INCLUDED_

#pragma once

#include "nsconst.h"

// Useful macros
#define PPF_BOOL(b)		(((b) == false) ? (k_szFalse) : (k_szTrue))
#define PPF_CHAR(p)		((((LPCSTR )(p)) == NULL) ? ("<NULL>") : ((LPCSTR )(p)))
#define PPF_WCHAR(p)	((((LPCWSTR )(p)) == NULL) ? (L"<NULL>") : ((LPCWSTR )(p)))

////////////////////////////////////////////////////////////////////////////////////////
// String utilities
void Mbcs2Unicode(LPCSTR  pszIn, unsigned codepage, BOOL bNEC, CStringW& wOut);
void Unicode2Mbcs(LPCWSTR pwszIn, unsigned codepage, BOOL bNEC, CStringA& wOut);
void FixUpHtmlDecimalCharacters(CStringW& str);
void HtmlEscapeString(CStringW& str, LPCWSTR escch = L"\"<>" );
void HtmlEscapeString(CStringA& str,  LPCSTR escch = "\"<>");

void UrlEscapeString(CStringW& wStr );
void UrlEscapeString(CStringA& oStr);
CStringA UrlEscapeStr(const CStringA& oStr);
void UrlUnescapeString(CStringW& wStr );
void UrlUnescapeString(CStringA& aStr);
void BSTRMove(BSTR& src, CStringW& dest);
void BSTRMove(BSTR& src, CStringA& dest);
long HexToNum(wchar_t c);
long FromHex(LPCWSTR pszHexString);

void EncodeXMLString(CStringW& str );
void EncodeXMLString(CStringA& str);

void EncodeWMLString(CStringW& str );
void EncodeWMLString(CStringA& str);

void EncodeHDMLString(CStringW& str );
void EncodeHDMLString(CStringA& str);

void ToHexStr(CStringA& outputToAppend, LPCWSTR instr) throw();
void ToHexStr(CStringA& outputToAppend, unsigned short in) throw();
void ToHexStr(CStringA& outputToAppend, unsigned long in) throw();
void ToHexStr(CStringA& outputToAppend, PBYTE pData, ULONG len) throw();

////////////////////////////////////////////////////////////////////////////////////////
// ini file processing
typedef struct tag_ConfigIniPair
{
	CString strIniKey;
	CString strIniValue;
} IniSettingPair;

BOOL GetPrivateProfilePairs(
  			LPCTSTR lpFileName,          
  			LPCTSTR lpSectionName,      
  			ATL::CAtlArray<IniSettingPair>& r 
            );	


////////////////////////////////////////////////////////////////////////////////////////
//  Browser info 
// 
class CBrowserInfo
{
protected:
    BOOL         m_bIsBrowserHigh;
    BOOL         m_bIsWebTVBased;
    unsigned int m_nBrowserIndex;
    unsigned int m_nBrowserMajorVersion;
    unsigned int m_nBrowserMinorVersion;
    CStringA     m_strBrowserVersion;
    CStringA     m_strUserAgent;

public:
    CBrowserInfo(LPCSTR pszUserAgentStr = NULL);
    ~CBrowserInfo();

    BOOL Initialize(LPCSTR pszUserAgent);

    enum BROWSER_NAME_ID
    {
        BROWSER_UNKNOWN=0,
        BROWSER_IE=1,            
        BROWSER_NETSCAPE=2,
        BROWSER_PASSPORT_CLIENT=3,
        BROWSER_UP=4,
        BROWSER_DoCoMo=5,
        BROWSER_WEBTV=6,
        BROWSER_ROGERS=7,
        BROWSER_MSTV=8,
        BROWSER_MMEPHONE = 9,
        BROWSER_IE_WINCE = 10,
        BROWSER_AVANTGO
    };

    unsigned int GetBrowserNameIndex();
    unsigned int GetBrowserMajorVersion();
    unsigned int GetBrowserMinorVersion();
    LPCSTR   GetBrowserVersionString();
    BOOL     IsHighBrowser();
    BOOL     IsWebTVBased();

    BOOL     IfUserAgentHasStr(LPCSTR str);
}; 



////////////////////////////////////////////////////////////////////////////////////////
// URL helper:  ATLSvr CUrl. 
// It does not provide an easy way to set name-value pair on query string. Anyone feel strong 
// about needing one?
//

// 
// Time helper, birthdate helper: ATLSvr CTime, CTimeSpan
//

//
// cookie helper: ATLSvr CCookie
//

#endif //PPUTILITIES_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\pptypes.h ===
//-----------------------------------------------------------------------------
//
//  @doc
//
//  @module PpTypes.h |  Passport specific type definitions.
//
//  Author: Darren Anderson
//
//  Date:   4/26/00
//
//  Copyright <cp> 1999-2000 Microsoft Corporation.  All Rights Reserved.
//
//-----------------------------------------------------------------------------
#pragma once

// @enum  PASSPORT_PROFILE_ITEM | Indices to passport profile items in the
//                                profile cookie.
typedef enum
{
    PROFILE_ITEM_INTERNALMEMBERNAME = 0,    // @emem Index of the membername attribute.
    PROFILE_ITEM_MEMBERIDLOW,       // @emem Index of the member id low 
                                    //       attribute.
    PROFILE_ITEM_MEMBERIDHIGH,      // @emem Index of the member id high
                                    //       attribute.
    PROFILE_ITEM_PROFILEVERSION,    // @emem Index of the profile version
                                    //       attribute.
    PROFILE_ITEM_COUNTRY,           // @emem Index of the country attribute.
    PROFILE_ITEM_POSTALCODE,        // @emem Index of the postal code 
                                    //       attribute.
    PROFILE_ITEM_REGION,            // @emem Index of the region attribute.
    PROFILE_ITEM_CITY,              // @emem Index of the city attribute.
    PROFILE_ITEM_LANGPREFERENCE,    // @emem Index of the language preference
                                    //       attribute.
    PROFILE_ITEM_BDAYPRECISION,     // @emem Index of the birthday precision
                                    //       attribute.
    PROFILE_ITEM_BIRTHDATE,         // @emem Index of the birthdate attribute.
    PROFILE_ITEM_GENDER,            // @emem Index of the gender attribute.
    PROFILE_ITEM_PREFERREDEMAIL,    // @emem Index of the email attribute.
    PROFILE_ITEM_NICKNAME,          // @emem Index of the nickname attribute.
    PROFILE_ITEM_ACCESSIBILITY,     // @emem Index of the accessibility 
                                    //       attribute.
    PROFILE_ITEM_WALLET,            // @emem Index of the wallet attribute.
    PROFILE_ITEM_DIRECTORY,         // @emem Index of the directory attribute.
    PROFILE_ITEM_NULL,              // @emem Index of deprecated attribute.
    PROFILE_ITEM_FLAGS,              // @emem Index of the flags attribute.
    PROFILE_ITEM_FIRSTNAME,         // @emem Index of the firstname attribute.
    PROFILE_ITEM_LASTNAME,          // @emem Index of the lastname attribute.
    PROFILE_ITEM_TIMEZONE,          // @emem Index of the timezone attribute.
    PROFILE_ITEM_OCCUPATION        // @emem Index of the occupation attribute.
}
PASSPORT_PROFILE_ITEM;

// @enum  PASSPORT_PROFILE_BDAYPRECISION|Valid values for birthdate precision.
typedef enum
{
    PRECISION_NOBIRTHDATE = 0,  // @emem  No birthdate specified for this user.
    PRECISION_YEARONLY = 1,     // @emem  User entered birthyear only (deprecated).
    PRECISION_NORMAL = 2,       // @emem  User has full birthdate.
    PRECISION_UNDER18 = 3,      // @emem  User is under 18, but we don't know their
                                //         birthdate (deprecated).
    PRECISION_UNDER13 = 4,      // @emem  User is under 13.  This value is never
                                //        stored in the database.
    PRECISION_13TO18 = 5        // @emem  User is at least 13 and under 18.  This
                                //        value is never stored in the database.
}
PASSPORT_PROFILE_BDAYPRECISION;

// @enum  KPP | Valid KPP values.
typedef enum
{
    KPP_NO_CONSENT_REQUIRED = 0,    // @emem Site does not require consent.
    KPP_CHECK_CONSENT_ONLY = 1,     // @emem Site needs consent status of user, but
                                    //       does not require consent.
    KPP_CHECK_CONSENT_W_UI = 2,     // @emem Site does not want to see this user 
                                    //       again until the user has been granted
                                    //       consent.
    KPP_CHECK_BIRTHDATE = 3,        // @emem Site requires the user's birthdate to be
                                    //       specified.  Used for legacy accounts
                                    //       with birthday precision 3 (under 18, no
                                    //       birthdate specified).
    KPP_CHECK_PARENT = 4,           // @emem Site requires authentication of the parent
                                    //       and
                                    //       issuance of a KPPVC.
    KPP_DA_NO_CONSENT = 10,         // @emem Not passed on query string.  This is
                                    //       passed into profile functions when 
                                    //       we're dealing with domain authority
                                    //       cookies and don't want to do any of the
                                    //       consent logic.
}
KPP;

// @enum LOGIN_ERRORS | Valid login errors.
typedef enum
{
    ERROR_NONE = 0, //  @emem   No error.
    ERROR_E1 = 1,   //  @emem   Empty sign in.
    ERROR_E2,       //  @emem   Missing login name.
    ERROR_E3,       //  @emem   Missing password.
    ERROR_E4,       //  @emem   Missing domain.
    ERROR_E5A,      //  @emem   Password incorrect for member name.
    ERROR_E5B,      //  @emem   No account of this name.
    ERROR_E5D,      //  @emem   User typed a member name containing invalid
                    //          characters.
    ERROR_E5E,      //  @emem   User typed incomplete membern name.
    ERROR_E6,       //  @emem
    ERROR_EX
}
LOGIN_ERRORS;

// @enum LOGIN_REQUEST_TYPE | Different types of login requests.
typedef enum 
{ 
    LOGIN_REQUEST_NORMAL = 0,
    LOGIN_REQUEST_SILENT,
    LOGIN_REQUEST_MD5SILENT, 
    LOGIN_REQUEST_MD5AUTH,
    LOGIN_REQUEST_MD5SILENT_EXST2,
    LOGIN_REQUEST_POST,
    LOGIN_REQUEST_COOKIE_COPY,
    LOGIN_REQUEST_NEEDBIRTHDATE,
    LOGIN_REQUEST_XML,
    PROFILE_REQUEST_XML,
    LOGIN_REQUEST_DIGEST,
    LOGIN_REQUEST_TWEENER,
    LOGIN_REQUEST_INLINE,
    LOGIN_REQUEST_PINPOST,
    LOGIN_REQUEST_PINRESETPOST,
    LOGIN_REQUEST_MOBILEPOST,
    LOGIN_REQUEST_INLINE_MD5
} LOGIN_REQUEST_TYPE;


// @enum PARTNER_SEND_DATA_TYPE | Different ways to post data back to partners.
typedef enum 
{ 
    PARTNER_SEND_DATA_COOKIES = 0,  // normal t/p cookies on query string
    PARTNER_SEND_DATA_SSLPOST = 1   // post data over ssl
} PARTNER_SEND_DATA_TYPE;


// @enum PARTNER_INLINESIGNIN_UI_TYPE | Different ui for inline signin interface.
typedef enum 
{ 
    PARTNER_INLINESIGNIN_LOW_BROWSER = -1,          // Nav 4.0x - no ui
    PARTNER_INLINESIGNIN_ALREADY_LOGGED_IN = 0,     // Logged in dialog
    PARTNER_INLINESIGNIN_UI_STANDARD = 1,           // normal dialog
    PARTNER_INLINESIGNIN_UI_HORIZONTAL = 2,         // horizontal dialog
    PARTNER_INLINESIGNIN_UI_COMPACT = 3,            // compact dialog
    PARTNER_INLINESIGNIN_SUPPLEMENTAL_AUTH = 100    // supplemental auth
} PARTNER_INLINESIGNIN_UI_TYPE;

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\ptstl.h ===
#ifndef __PPT_ALLOCATOR_
#define __PPT_ALLOCATOR_

#include <memory>


/**************************************************************************
 *  Template name: heap_allocator
 *
 *  Purpose: Allocator class to handle STL allocations
 *
 */
template<class _Ty>
class PtHeap_allocator : public std::allocator<_Ty>
{
public:
   PtHeap_allocator()
   {
      __hHeap = GetProcessHeap();
   };
   pointer allocate(size_type _N, const void *)
        {return (pointer) _Charalloc(_N * sizeof(_Ty)); }

   char* _Charalloc(size_type _N)
        {return (char*) HeapAlloc(__hHeap, 0, _N); }

   void deallocate(void* _P, size_type)
        {HeapFree(__hHeap, 0, _P); }
private:
   HANDLE   __hHeap;
};




// Defines strings that use the above allocator to that the DMI heap stuff is used.
#include <string>
#include <queue>

typedef std::basic_string<CHAR, std::char_traits<CHAR>, PtHeap_allocator<CHAR> > PtStlString;
typedef std::basic_string<WCHAR, std::char_traits<WCHAR>, PtHeap_allocator<WCHAR> > PtStlWstring;
#if   0// uses new allocator
template<class Key, class T, class Pred = less<Key> > 
class PtStlMap : public std::map<Key, T, Pred, PtHeap_allocator<T> >{};
template<class T> 
class PtStlQueue : public std::queue<T, deque<T, PtHeap_allocator<T> > > {};
#else
template<class Key, class T, class Pred = less<Key> > 
class PtStlMap : public std::map<Key, T, Pred, std::allocator<T> >{};
template<class T> 
class PtStlQueue : public std::queue<T, deque<T, std::allocator<T> > > {};
#endif
#endif // __PPT_ALLOCATOR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\profileserv.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Fri Apr 09 14:03:13 1999
 */
/* Compiler settings for ProfileServ.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __ProfileServ_h__
#define __ProfileServ_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IPRegistrar_FWD_DEFINED__
#define __IPRegistrar_FWD_DEFINED__
typedef interface IPRegistrar IPRegistrar;
#endif 	/* __IPRegistrar_FWD_DEFINED__ */


#ifndef __IRegistryServices_FWD_DEFINED__
#define __IRegistryServices_FWD_DEFINED__
typedef interface IRegistryServices IRegistryServices;
#endif 	/* __IRegistryServices_FWD_DEFINED__ */


#ifndef __PRegistrar_FWD_DEFINED__
#define __PRegistrar_FWD_DEFINED__

#ifdef __cplusplus
typedef class PRegistrar PRegistrar;
#else
typedef struct PRegistrar PRegistrar;
#endif /* __cplusplus */

#endif 	/* __PRegistrar_FWD_DEFINED__ */


#ifndef __RegistryServices_FWD_DEFINED__
#define __RegistryServices_FWD_DEFINED__

#ifdef __cplusplus
typedef class RegistryServices RegistryServices;
#else
typedef struct RegistryServices RegistryServices;
#endif /* __cplusplus */

#endif 	/* __RegistryServices_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IPRegistrar_INTERFACE_DEFINED__
#define __IPRegistrar_INTERFACE_DEFINED__

/* interface IPRegistrar */
/* [unique][oleautomation][dual][object][helpstring][uuid] */ 


EXTERN_C const IID IID_IPRegistrar;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("725D4CE9-6DEB-11D2-863A-00C04FBBECDE")
    IPRegistrar : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CancelAccount( 
            /* [in] */ BSTR member_name,
            /* [in] */ unsigned long reason_code,
            /* [retval][out] */ int __RPC_FAR *result) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CheckName( 
            /* [in] */ BSTR member_name,
            /* [optional][in] */ BSTR first_name,
            /* [optional][in] */ BSTR last_name,
            /* [in] */ unsigned long generates_alternative_names,
            /* [out] */ VARIANT __RPC_FAR *alternative_names,
            /* [retval][out] */ int __RPC_FAR *result) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateAccount( 
            /* [in] */ BSTR member_name,
            /* [in] */ unsigned long domain_ID,
            /* [in] */ BSTR password,
            /* [in] */ BSTR hint_question,
            /* [in] */ BSTR hint_answer,
            /* [optional][in] */ BSTR country,
            /* [optional][in] */ BSTR postal_code,
            /* [optional][in] */ unsigned long region,
            /* [optional][in] */ unsigned long city,
            /* [optional][in] */ unsigned long language_ID,
            /* [optional][in] */ BSTR gender,
            /* [optional][in] */ unsigned long has_full_birth_date,
            /* [optional][in] */ DATE birth_date,
            /* [optional][in] */ BSTR nickname,
            /* [optional][in] */ BSTR contact_email,
            /* [optional][in] */ unsigned long has_accessibility,
            /* [optional][in] */ unsigned long referring_site_ID,
            /* [optional][in] */ unsigned long has_password_reminder,
            /* [optional][in] */ BSTR inserter,
            /* [out] */ VARIANT __RPC_FAR *member_ID_low,
            /* [retval][out] */ int __RPC_FAR *result) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPRegistrarVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPRegistrar __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPRegistrar __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPRegistrar __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IPRegistrar __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IPRegistrar __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IPRegistrar __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IPRegistrar __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CancelAccount )( 
            IPRegistrar __RPC_FAR * This,
            /* [in] */ BSTR member_name,
            /* [in] */ unsigned long reason_code,
            /* [retval][out] */ int __RPC_FAR *result);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CheckName )( 
            IPRegistrar __RPC_FAR * This,
            /* [in] */ BSTR member_name,
            /* [optional][in] */ BSTR first_name,
            /* [optional][in] */ BSTR last_name,
            /* [in] */ unsigned long generates_alternative_names,
            /* [out] */ VARIANT __RPC_FAR *alternative_names,
            /* [retval][out] */ int __RPC_FAR *result);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateAccount )( 
            IPRegistrar __RPC_FAR * This,
            /* [in] */ BSTR member_name,
            /* [in] */ unsigned long domain_ID,
            /* [in] */ BSTR password,
            /* [in] */ BSTR hint_question,
            /* [in] */ BSTR hint_answer,
            /* [optional][in] */ BSTR country,
            /* [optional][in] */ BSTR postal_code,
            /* [optional][in] */ unsigned long region,
            /* [optional][in] */ unsigned long city,
            /* [optional][in] */ unsigned long language_ID,
            /* [optional][in] */ BSTR gender,
            /* [optional][in] */ unsigned long has_full_birth_date,
            /* [optional][in] */ DATE birth_date,
            /* [optional][in] */ BSTR nickname,
            /* [optional][in] */ BSTR contact_email,
            /* [optional][in] */ unsigned long has_accessibility,
            /* [optional][in] */ unsigned long referring_site_ID,
            /* [optional][in] */ unsigned long has_password_reminder,
            /* [optional][in] */ BSTR inserter,
            /* [out] */ VARIANT __RPC_FAR *member_ID_low,
            /* [retval][out] */ int __RPC_FAR *result);
        
        END_INTERFACE
    } IPRegistrarVtbl;

    interface IPRegistrar
    {
        CONST_VTBL struct IPRegistrarVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPRegistrar_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPRegistrar_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPRegistrar_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPRegistrar_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPRegistrar_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPRegistrar_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPRegistrar_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPRegistrar_CancelAccount(This,member_name,reason_code,result)	\
    (This)->lpVtbl -> CancelAccount(This,member_name,reason_code,result)

#define IPRegistrar_CheckName(This,member_name,first_name,last_name,generates_alternative_names,alternative_names,result)	\
    (This)->lpVtbl -> CheckName(This,member_name,first_name,last_name,generates_alternative_names,alternative_names,result)

#define IPRegistrar_CreateAccount(This,member_name,domain_ID,password,hint_question,hint_answer,country,postal_code,region,city,language_ID,gender,has_full_birth_date,birth_date,nickname,contact_email,has_accessibility,referring_site_ID,has_password_reminder,inserter,member_ID_low,result)	\
    (This)->lpVtbl -> CreateAccount(This,member_name,domain_ID,password,hint_question,hint_answer,country,postal_code,region,city,language_ID,gender,has_full_birth_date,birth_date,nickname,contact_email,has_accessibility,referring_site_ID,has_password_reminder,inserter,member_ID_low,result)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPRegistrar_CancelAccount_Proxy( 
    IPRegistrar __RPC_FAR * This,
    /* [in] */ BSTR member_name,
    /* [in] */ unsigned long reason_code,
    /* [retval][out] */ int __RPC_FAR *result);


void __RPC_STUB IPRegistrar_CancelAccount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPRegistrar_CheckName_Proxy( 
    IPRegistrar __RPC_FAR * This,
    /* [in] */ BSTR member_name,
    /* [optional][in] */ BSTR first_name,
    /* [optional][in] */ BSTR last_name,
    /* [in] */ unsigned long generates_alternative_names,
    /* [out] */ VARIANT __RPC_FAR *alternative_names,
    /* [retval][out] */ int __RPC_FAR *result);


void __RPC_STUB IPRegistrar_CheckName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPRegistrar_CreateAccount_Proxy( 
    IPRegistrar __RPC_FAR * This,
    /* [in] */ BSTR member_name,
    /* [in] */ unsigned long domain_ID,
    /* [in] */ BSTR password,
    /* [in] */ BSTR hint_question,
    /* [in] */ BSTR hint_answer,
    /* [optional][in] */ BSTR country,
    /* [optional][in] */ BSTR postal_code,
    /* [optional][in] */ unsigned long region,
    /* [optional][in] */ unsigned long city,
    /* [optional][in] */ unsigned long language_ID,
    /* [optional][in] */ BSTR gender,
    /* [optional][in] */ unsigned long has_full_birth_date,
    /* [optional][in] */ DATE birth_date,
    /* [optional][in] */ BSTR nickname,
    /* [optional][in] */ BSTR contact_email,
    /* [optional][in] */ unsigned long has_accessibility,
    /* [optional][in] */ unsigned long referring_site_ID,
    /* [optional][in] */ unsigned long has_password_reminder,
    /* [optional][in] */ BSTR inserter,
    /* [out] */ VARIANT __RPC_FAR *member_ID_low,
    /* [retval][out] */ int __RPC_FAR *result);


void __RPC_STUB IPRegistrar_CreateAccount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPRegistrar_INTERFACE_DEFINED__ */


#ifndef __IRegistryServices_INTERFACE_DEFINED__
#define __IRegistryServices_INTERFACE_DEFINED__

/* interface IRegistryServices */
/* [unique][dual][object][helpstring][uuid] */ 


EXTERN_C const IID IID_IRegistryServices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3B89FEF1-7270-11D2-863A-00C04FBBECDE")
    IRegistryServices : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetAccount( 
            /* [in] */ BSTR member_name,
            /* [out] */ VARIANT __RPC_FAR *domain_ID,
            /* [out] */ VARIANT __RPC_FAR *member_ID_low,
            /* [out] */ VARIANT __RPC_FAR *password,
            /* [out] */ VARIANT __RPC_FAR *country,
            /* [out] */ VARIANT __RPC_FAR *postal_code,
            /* [out] */ VARIANT __RPC_FAR *region,
            /* [out] */ VARIANT __RPC_FAR *city,
            /* [out] */ VARIANT __RPC_FAR *language_ID,
            /* [out] */ VARIANT __RPC_FAR *gender,
            /* [out] */ VARIANT __RPC_FAR *has_full_birth_date,
            /* [out] */ VARIANT __RPC_FAR *birth_date,
            /* [out] */ VARIANT __RPC_FAR *nickname,
            /* [out] */ VARIANT __RPC_FAR *contact_email,
            /* [out] */ VARIANT __RPC_FAR *has_accessibility,
            /* [out] */ VARIANT __RPC_FAR *has_wallet,
            /* [out] */ VARIANT __RPC_FAR *has_directory,
            /* [out] */ VARIANT __RPC_FAR *has_MSN_IA,
            /* [out] */ VARIANT __RPC_FAR *has_password_reminder,
            /* [out] */ VARIANT __RPC_FAR *password_change_date,
            /* [out] */ VARIANT __RPC_FAR *password_last_reminder_date,
            /* [out] */ VARIANT __RPC_FAR *flags,
            /* [out] */ VARIANT __RPC_FAR *profile_version,
            /* [retval][out] */ int __RPC_FAR *result) = 0;
        
        virtual /* [helpstring][id] */ HRESULT __stdcall GetCities( 
            /* [in] */ unsigned long language_ID,
            /* [out] */ VARIANT __RPC_FAR *cities,
            /* [retval][out] */ int __RPC_FAR *result) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetCountries( 
            /* [in] */ unsigned long language_ID,
            /* [out] */ VARIANT __RPC_FAR *countries,
            /* [retval][out] */ int __RPC_FAR *result) = 0;
        
        virtual /* [helpstring][id] */ HRESULT __stdcall GetDomains( 
            /* [out] */ VARIANT __RPC_FAR *domains,
            /* [retval][out] */ int __RPC_FAR *result) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetHint( 
            /* [in] */ BSTR member_name,
            /* [out] */ VARIANT __RPC_FAR *hint_question,
            /* [out] */ VARIANT __RPC_FAR *hint_answer,
            /* [retval][out] */ int __RPC_FAR *result) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetHintQuestions( 
            /* [in] */ unsigned long language_ID,
            /* [out] */ VARIANT __RPC_FAR *hint_questions,
            /* [retval][out] */ int __RPC_FAR *result) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetLanguages( 
            /* [optional][in] */ VARIANT __RPC_FAR *language_ID,
            /* [out] */ VARIANT __RPC_FAR *languages,
            /* [retval][out] */ int __RPC_FAR *result) = 0;
        
        virtual /* [helpstring][id] */ HRESULT __stdcall GetReferringSites( 
            /* [out] */ VARIANT __RPC_FAR *referring_sites,
            /* [retval][out] */ int __RPC_FAR *result) = 0;
        
        virtual /* [helpstring][id] */ HRESULT __stdcall GetRegions( 
            /* [in] */ unsigned long language_ID,
            /* [out] */ VARIANT __RPC_FAR *regions,
            /* [retval][out] */ int __RPC_FAR *result) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE UpdateAccount( 
            /* [in] */ BSTR member_name,
            /* [in] */ BSTR country,
            /* [in] */ BSTR postal_code,
            /* [in] */ unsigned long region,
            /* [in] */ unsigned long city,
            /* [in] */ unsigned long language_ID,
            /* [in] */ BSTR gender,
            /* [in] */ unsigned long has_full_birth_date,
            /* [in] */ DATE birth_date,
            /* [in] */ BSTR nickname,
            /* [in] */ BSTR contact_email,
            /* [in] */ unsigned long has_accessibility,
            /* [in] */ unsigned long has_wallet,
            /* [in] */ unsigned long has_directory,
            /* [in] */ unsigned long has_MSN_IA,
            /* [in] */ unsigned long has_password_reminder,
            /* [in] */ unsigned long flags,
            /* [optional][in] */ BSTR updater,
            /* [retval][out] */ int __RPC_FAR *result) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE UpdateHint( 
            /* [in] */ BSTR member_name,
            /* [in] */ BSTR hint_question,
            /* [in] */ BSTR hint_answer,
            /* [retval][out] */ int __RPC_FAR *result) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE UpdatePassword( 
            /* [in] */ BSTR member_name,
            /* [in] */ BSTR new_password,
            /* [retval][out] */ int __RPC_FAR *result) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRegistryServicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRegistryServices __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRegistryServices __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRegistryServices __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IRegistryServices __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IRegistryServices __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IRegistryServices __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IRegistryServices __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAccount )( 
            IRegistryServices __RPC_FAR * This,
            /* [in] */ BSTR member_name,
            /* [out] */ VARIANT __RPC_FAR *domain_ID,
            /* [out] */ VARIANT __RPC_FAR *member_ID_low,
            /* [out] */ VARIANT __RPC_FAR *password,
            /* [out] */ VARIANT __RPC_FAR *country,
            /* [out] */ VARIANT __RPC_FAR *postal_code,
            /* [out] */ VARIANT __RPC_FAR *region,
            /* [out] */ VARIANT __RPC_FAR *city,
            /* [out] */ VARIANT __RPC_FAR *language_ID,
            /* [out] */ VARIANT __RPC_FAR *gender,
            /* [out] */ VARIANT __RPC_FAR *has_full_birth_date,
            /* [out] */ VARIANT __RPC_FAR *birth_date,
            /* [out] */ VARIANT __RPC_FAR *nickname,
            /* [out] */ VARIANT __RPC_FAR *contact_email,
            /* [out] */ VARIANT __RPC_FAR *has_accessibility,
            /* [out] */ VARIANT __RPC_FAR *has_wallet,
            /* [out] */ VARIANT __RPC_FAR *has_directory,
            /* [out] */ VARIANT __RPC_FAR *has_MSN_IA,
            /* [out] */ VARIANT __RPC_FAR *has_password_reminder,
            /* [out] */ VARIANT __RPC_FAR *password_change_date,
            /* [out] */ VARIANT __RPC_FAR *password_last_reminder_date,
            /* [out] */ VARIANT __RPC_FAR *flags,
            /* [out] */ VARIANT __RPC_FAR *profile_version,
            /* [retval][out] */ int __RPC_FAR *result);
        
        /* [helpstring][id] */ HRESULT ( __stdcall __RPC_FAR *GetCities )( 
            IRegistryServices __RPC_FAR * This,
            /* [in] */ unsigned long language_ID,
            /* [out] */ VARIANT __RPC_FAR *cities,
            /* [retval][out] */ int __RPC_FAR *result);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCountries )( 
            IRegistryServices __RPC_FAR * This,
            /* [in] */ unsigned long language_ID,
            /* [out] */ VARIANT __RPC_FAR *countries,
            /* [retval][out] */ int __RPC_FAR *result);
        
        /* [helpstring][id] */ HRESULT ( __stdcall __RPC_FAR *GetDomains )( 
            IRegistryServices __RPC_FAR * This,
            /* [out] */ VARIANT __RPC_FAR *domains,
            /* [retval][out] */ int __RPC_FAR *result);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetHint )( 
            IRegistryServices __RPC_FAR * This,
            /* [in] */ BSTR member_name,
            /* [out] */ VARIANT __RPC_FAR *hint_question,
            /* [out] */ VARIANT __RPC_FAR *hint_answer,
            /* [retval][out] */ int __RPC_FAR *result);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetHintQuestions )( 
            IRegistryServices __RPC_FAR * This,
            /* [in] */ unsigned long language_ID,
            /* [out] */ VARIANT __RPC_FAR *hint_questions,
            /* [retval][out] */ int __RPC_FAR *result);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLanguages )( 
            IRegistryServices __RPC_FAR * This,
            /* [optional][in] */ VARIANT __RPC_FAR *language_ID,
            /* [out] */ VARIANT __RPC_FAR *languages,
            /* [retval][out] */ int __RPC_FAR *result);
        
        /* [helpstring][id] */ HRESULT ( __stdcall __RPC_FAR *GetReferringSites )( 
            IRegistryServices __RPC_FAR * This,
            /* [out] */ VARIANT __RPC_FAR *referring_sites,
            /* [retval][out] */ int __RPC_FAR *result);
        
        /* [helpstring][id] */ HRESULT ( __stdcall __RPC_FAR *GetRegions )( 
            IRegistryServices __RPC_FAR * This,
            /* [in] */ unsigned long language_ID,
            /* [out] */ VARIANT __RPC_FAR *regions,
            /* [retval][out] */ int __RPC_FAR *result);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdateAccount )( 
            IRegistryServices __RPC_FAR * This,
            /* [in] */ BSTR member_name,
            /* [in] */ BSTR country,
            /* [in] */ BSTR postal_code,
            /* [in] */ unsigned long region,
            /* [in] */ unsigned long city,
            /* [in] */ unsigned long language_ID,
            /* [in] */ BSTR gender,
            /* [in] */ unsigned long has_full_birth_date,
            /* [in] */ DATE birth_date,
            /* [in] */ BSTR nickname,
            /* [in] */ BSTR contact_email,
            /* [in] */ unsigned long has_accessibility,
            /* [in] */ unsigned long has_wallet,
            /* [in] */ unsigned long has_directory,
            /* [in] */ unsigned long has_MSN_IA,
            /* [in] */ unsigned long has_password_reminder,
            /* [in] */ unsigned long flags,
            /* [optional][in] */ BSTR updater,
            /* [retval][out] */ int __RPC_FAR *result);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdateHint )( 
            IRegistryServices __RPC_FAR * This,
            /* [in] */ BSTR member_name,
            /* [in] */ BSTR hint_question,
            /* [in] */ BSTR hint_answer,
            /* [retval][out] */ int __RPC_FAR *result);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdatePassword )( 
            IRegistryServices __RPC_FAR * This,
            /* [in] */ BSTR member_name,
            /* [in] */ BSTR new_password,
            /* [retval][out] */ int __RPC_FAR *result);
        
        END_INTERFACE
    } IRegistryServicesVtbl;

    interface IRegistryServices
    {
        CONST_VTBL struct IRegistryServicesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRegistryServices_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRegistryServices_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRegistryServices_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRegistryServices_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRegistryServices_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IRegistryServices_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IRegistryServices_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IRegistryServices_GetAccount(This,member_name,domain_ID,member_ID_low,password,country,postal_code,region,city,language_ID,gender,has_full_birth_date,birth_date,nickname,contact_email,has_accessibility,has_wallet,has_directory,has_MSN_IA,has_password_reminder,password_change_date,password_last_reminder_date,flags,profile_version,result)	\
    (This)->lpVtbl -> GetAccount(This,member_name,domain_ID,member_ID_low,password,country,postal_code,region,city,language_ID,gender,has_full_birth_date,birth_date,nickname,contact_email,has_accessibility,has_wallet,has_directory,has_MSN_IA,has_password_reminder,password_change_date,password_last_reminder_date,flags,profile_version,result)

#define IRegistryServices_GetCities(This,language_ID,cities,result)	\
    (This)->lpVtbl -> GetCities(This,language_ID,cities,result)

#define IRegistryServices_GetCountries(This,language_ID,countries,result)	\
    (This)->lpVtbl -> GetCountries(This,language_ID,countries,result)

#define IRegistryServices_GetDomains(This,domains,result)	\
    (This)->lpVtbl -> GetDomains(This,domains,result)

#define IRegistryServices_GetHint(This,member_name,hint_question,hint_answer,result)	\
    (This)->lpVtbl -> GetHint(This,member_name,hint_question,hint_answer,result)

#define IRegistryServices_GetHintQuestions(This,language_ID,hint_questions,result)	\
    (This)->lpVtbl -> GetHintQuestions(This,language_ID,hint_questions,result)

#define IRegistryServices_GetLanguages(This,language_ID,languages,result)	\
    (This)->lpVtbl -> GetLanguages(This,language_ID,languages,result)

#define IRegistryServices_GetReferringSites(This,referring_sites,result)	\
    (This)->lpVtbl -> GetReferringSites(This,referring_sites,result)

#define IRegistryServices_GetRegions(This,language_ID,regions,result)	\
    (This)->lpVtbl -> GetRegions(This,language_ID,regions,result)

#define IRegistryServices_UpdateAccount(This,member_name,country,postal_code,region,city,language_ID,gender,has_full_birth_date,birth_date,nickname,contact_email,has_accessibility,has_wallet,has_directory,has_MSN_IA,has_password_reminder,flags,updater,result)	\
    (This)->lpVtbl -> UpdateAccount(This,member_name,country,postal_code,region,city,language_ID,gender,has_full_birth_date,birth_date,nickname,contact_email,has_accessibility,has_wallet,has_directory,has_MSN_IA,has_password_reminder,flags,updater,result)

#define IRegistryServices_UpdateHint(This,member_name,hint_question,hint_answer,result)	\
    (This)->lpVtbl -> UpdateHint(This,member_name,hint_question,hint_answer,result)

#define IRegistryServices_UpdatePassword(This,member_name,new_password,result)	\
    (This)->lpVtbl -> UpdatePassword(This,member_name,new_password,result)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRegistryServices_GetAccount_Proxy( 
    IRegistryServices __RPC_FAR * This,
    /* [in] */ BSTR member_name,
    /* [out] */ VARIANT __RPC_FAR *domain_ID,
    /* [out] */ VARIANT __RPC_FAR *member_ID_low,
    /* [out] */ VARIANT __RPC_FAR *password,
    /* [out] */ VARIANT __RPC_FAR *country,
    /* [out] */ VARIANT __RPC_FAR *postal_code,
    /* [out] */ VARIANT __RPC_FAR *region,
    /* [out] */ VARIANT __RPC_FAR *city,
    /* [out] */ VARIANT __RPC_FAR *language_ID,
    /* [out] */ VARIANT __RPC_FAR *gender,
    /* [out] */ VARIANT __RPC_FAR *has_full_birth_date,
    /* [out] */ VARIANT __RPC_FAR *birth_date,
    /* [out] */ VARIANT __RPC_FAR *nickname,
    /* [out] */ VARIANT __RPC_FAR *contact_email,
    /* [out] */ VARIANT __RPC_FAR *has_accessibility,
    /* [out] */ VARIANT __RPC_FAR *has_wallet,
    /* [out] */ VARIANT __RPC_FAR *has_directory,
    /* [out] */ VARIANT __RPC_FAR *has_MSN_IA,
    /* [out] */ VARIANT __RPC_FAR *has_password_reminder,
    /* [out] */ VARIANT __RPC_FAR *password_change_date,
    /* [out] */ VARIANT __RPC_FAR *password_last_reminder_date,
    /* [out] */ VARIANT __RPC_FAR *flags,
    /* [out] */ VARIANT __RPC_FAR *profile_version,
    /* [retval][out] */ int __RPC_FAR *result);


void __RPC_STUB IRegistryServices_GetAccount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT __stdcall IRegistryServices_GetCities_Proxy( 
    IRegistryServices __RPC_FAR * This,
    /* [in] */ unsigned long language_ID,
    /* [out] */ VARIANT __RPC_FAR *cities,
    /* [retval][out] */ int __RPC_FAR *result);


void __RPC_STUB IRegistryServices_GetCities_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRegistryServices_GetCountries_Proxy( 
    IRegistryServices __RPC_FAR * This,
    /* [in] */ unsigned long language_ID,
    /* [out] */ VARIANT __RPC_FAR *countries,
    /* [retval][out] */ int __RPC_FAR *result);


void __RPC_STUB IRegistryServices_GetCountries_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT __stdcall IRegistryServices_GetDomains_Proxy( 
    IRegistryServices __RPC_FAR * This,
    /* [out] */ VARIANT __RPC_FAR *domains,
    /* [retval][out] */ int __RPC_FAR *result);


void __RPC_STUB IRegistryServices_GetDomains_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRegistryServices_GetHint_Proxy( 
    IRegistryServices __RPC_FAR * This,
    /* [in] */ BSTR member_name,
    /* [out] */ VARIANT __RPC_FAR *hint_question,
    /* [out] */ VARIANT __RPC_FAR *hint_answer,
    /* [retval][out] */ int __RPC_FAR *result);


void __RPC_STUB IRegistryServices_GetHint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRegistryServices_GetHintQuestions_Proxy( 
    IRegistryServices __RPC_FAR * This,
    /* [in] */ unsigned long language_ID,
    /* [out] */ VARIANT __RPC_FAR *hint_questions,
    /* [retval][out] */ int __RPC_FAR *result);


void __RPC_STUB IRegistryServices_GetHintQuestions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRegistryServices_GetLanguages_Proxy( 
    IRegistryServices __RPC_FAR * This,
    /* [optional][in] */ VARIANT __RPC_FAR *language_ID,
    /* [out] */ VARIANT __RPC_FAR *languages,
    /* [retval][out] */ int __RPC_FAR *result);


void __RPC_STUB IRegistryServices_GetLanguages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT __stdcall IRegistryServices_GetReferringSites_Proxy( 
    IRegistryServices __RPC_FAR * This,
    /* [out] */ VARIANT __RPC_FAR *referring_sites,
    /* [retval][out] */ int __RPC_FAR *result);


void __RPC_STUB IRegistryServices_GetReferringSites_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT __stdcall IRegistryServices_GetRegions_Proxy( 
    IRegistryServices __RPC_FAR * This,
    /* [in] */ unsigned long language_ID,
    /* [out] */ VARIANT __RPC_FAR *regions,
    /* [retval][out] */ int __RPC_FAR *result);


void __RPC_STUB IRegistryServices_GetRegions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRegistryServices_UpdateAccount_Proxy( 
    IRegistryServices __RPC_FAR * This,
    /* [in] */ BSTR member_name,
    /* [in] */ BSTR country,
    /* [in] */ BSTR postal_code,
    /* [in] */ unsigned long region,
    /* [in] */ unsigned long city,
    /* [in] */ unsigned long language_ID,
    /* [in] */ BSTR gender,
    /* [in] */ unsigned long has_full_birth_date,
    /* [in] */ DATE birth_date,
    /* [in] */ BSTR nickname,
    /* [in] */ BSTR contact_email,
    /* [in] */ unsigned long has_accessibility,
    /* [in] */ unsigned long has_wallet,
    /* [in] */ unsigned long has_directory,
    /* [in] */ unsigned long has_MSN_IA,
    /* [in] */ unsigned long has_password_reminder,
    /* [in] */ unsigned long flags,
    /* [optional][in] */ BSTR updater,
    /* [retval][out] */ int __RPC_FAR *result);


void __RPC_STUB IRegistryServices_UpdateAccount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRegistryServices_UpdateHint_Proxy( 
    IRegistryServices __RPC_FAR * This,
    /* [in] */ BSTR member_name,
    /* [in] */ BSTR hint_question,
    /* [in] */ BSTR hint_answer,
    /* [retval][out] */ int __RPC_FAR *result);


void __RPC_STUB IRegistryServices_UpdateHint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRegistryServices_UpdatePassword_Proxy( 
    IRegistryServices __RPC_FAR * This,
    /* [in] */ BSTR member_name,
    /* [in] */ BSTR new_password,
    /* [retval][out] */ int __RPC_FAR *result);


void __RPC_STUB IRegistryServices_UpdatePassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRegistryServices_INTERFACE_DEFINED__ */



#ifndef __PROFILESERVLib_LIBRARY_DEFINED__
#define __PROFILESERVLib_LIBRARY_DEFINED__

/* library PROFILESERVLib */
/* [version][helpstring][uuid] */ 


EXTERN_C const IID LIBID_PROFILESERVLib;

EXTERN_C const CLSID CLSID_PRegistrar;

#ifdef __cplusplus

class DECLSPEC_UUID("725D4CEA-6DEB-11D2-863A-00C04FBBECDE")
PRegistrar;
#endif

EXTERN_C const CLSID CLSID_RegistryServices;

#ifdef __cplusplus

class DECLSPEC_UUID("3B89FEF2-7270-11D2-863A-00C04FBBECDE")
RegistryServices;
#endif
#endif /* __PROFILESERVLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\profileschema.h ===
#ifndef _PROFILE_SCHEMA_H
#define _PROFILE_SCHEMA_H

#include "BstrHash.h"

#ifndef __no_msxml_dll_import__
#include "xmltlh.h"
//#import <msxml.dll> rename_namespace("MSXML")
//#import "msxml.dll"
//#define MSXML
#endif

typedef CRawCIBstrHash<int> RAWBSTR2INT;

#define	INVALID_POS	(UINT)(-1)
#define	FULL_SCHEMA (DWORD)(-1)

class CProfileSchema
{
 public:
  // Read the raw blob according to the schema, and output the positions of
  // each element.  Output array size MUST be >= Count()
  HRESULT parseProfile(LPSTR raw, UINT size, UINT* positions, UINT* bitFlagPositions, DWORD* pdwAttrs);

  // parck profile ..., when cEles == -1, assuming full schema
  BSTR packProfile(void *elements[], DWORD cEles/* = FULL_SCHEMA */);
  BSTR packMaskProfile(void *elements[], int maskElemPosition);

  enum AttrType {
    tText=0,
    tChar,
    tByte,
    tWord,
    tLong,
    tDate,
    tInvalid
  };

  CProfileSchema();
  ~CProfileSchema();

  BOOL    isOk() const { return m_isOk; }
  _bstr_t getErrorInfo() const { return m_szReason; }
  
  long GetAgeSeconds() const;

#ifndef __no_msxml_dll_import__
  BOOL Read(MSXML::IXMLElementPtr &root);
#endif  
  BOOL ReadFromArray(UINT numAttributes, LPTSTR names[], AttrType types[], short sizes[], BYTE readOnly[] = NULL);
  int         m_maskPos;

  // Number of attributes
  int     Count() const { return m_numAtts; }

  // Find the index by name
  int     GetIndexByName(BSTR name) const;
  BSTR    GetNameByIndex(int index) const;

  // Get the type of an attribute
  AttrType GetType(UINT index) const;

  // Can I write to this attribute?
  BOOL    IsReadOnly(UINT index) const;

  // Get the inherent size of an attribute
  // Returns -1 if the type is length prefixed
  int     GetBitSize(UINT index) const;
  int     GetByteSize(UINT index) const;

  CProfileSchema* AddRef();
  void Release();

 protected:
  long      m_refs;

  BOOL      m_isOk;
  _bstr_t   m_szReason;

  // Valid until this time
  SYSTEMTIME m_validUntil;

  // Array of attribute types
  UINT        m_numAtts;
  AttrType    *m_atts;
  short       *m_sizes;
  BYTE        *m_readOnly;
  RAWBSTR2INT  m_indexes;
};

// Init functions for fixed schemas
CProfileSchema* InitAuthSchema();
CProfileSchema* InitSecureSchema();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\puidutils.h ===
//-----------------------------------------------------------------------------
//
// PUIDUtils.h
//
// Functions for dealing with the PUID data type.
//
// Author: Jeff Steinbok
//
// 02/01/01       jeffstei    Initial Version
//
// Copyright <cp> 2000-2001 Microsoft Corporation.  All Rights Reserved.
//
//-----------------------------------------------------------------------------


#ifndef _PUIDUTILS_H
#define _PUIDUTILS_H

//
// Converts a PUID into a string.
//
// The format is as follows:
//     PUID:      HIGH               LOW
//                 |                  |
//                 \/                 \/
//             0x[hhhhhhhh]       0x[llllllll]
//                   \                /
//     STR:          "hhhhhhhhllllllll"
//
HRESULT PUID2String(LARGE_INTEGER* in_pPUID, CStringW& out_cszwPUIDStr);

#endif //_PUIDUTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\shadowdocument.h ===
// ShadowDocument.h: interface for the CShadowDocument class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SHADOWDOCUMENT_H__70EC6ED7_9549_11D2_95DE_00C04F8E7A70__INCLUDED_)
#define AFX_SHADOWDOCUMENT_H__70EC6ED7_9549_11D2_95DE_00C04F8E7A70__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CShadowDocument  
{
public:
	LPWSTR getLocalFilename();
	BOOL Update();

	~CShadowDocument();
	CShadowDocument(BOOL encrypted,
                  LPSTR server, LPSTR doc,
                  LPTSTR localFilename);

protected:
	_bstr_t m_localFilename;
	_bstr_t m_doc;
	_bstr_t m_server;
	BOOL m_encrypted;
};

#endif // !defined(AFX_SHADOWDOCUMENT_H__70EC6ED7_9549_11D2_95DE_00C04F8E7A70__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\rwlock.h ===
// this lock only works for a single write, and multiple read, concurrent
// multiple exclusive lock isn't a supported scenario
//
// (1) ClaimExclusiveLock() and ClaimShareLock() is mutually exclusive because
// the reverse order of increments and checking
// 
// (2) As soon as Exclusive is set, all new Share lock will be blocked
// 
//

#ifndef _CReadWriteLock_H_
#define _CReadWriteLock_H_

class CReadWriteLock
{
    long lExclusive;
    long lTotalUsers;
    long lReadInQueue;
	HANDLE hWriteReadyEvent, hReadReadyEvent;

public:
    CReadWriteLock()
    {
    	hWriteReadyEvent = CreateEvent(NULL, TRUE, FALSE, NULL); 
        hReadReadyEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    };

    ~CReadWriteLock()
    {
        CloseHandle(hWriteReadyEvent);
        CloseHandle(hReadReadyEvent);
    }

    bool IsInit()
    {
        return NULL != hWriteReadyEvent && NULL != hReadReadyEvent;
    }

    bool CReadWriteLock::ClaimExclusiveLock()
    {
        ResetEvent(hWriteReadyEvent);
        ResetEvent(hReadReadyEvent);
        InterlockedIncrement( &lExclusive );
        InterlockedIncrement( &lTotalUsers );
        if (lTotalUsers > 1)
        {
            if (lReadInQueue > 0)   // in case no body is in the read queue
            {
                // wait until all the reads to finish
                if (WAIT_OBJECT_0 != WaitForSingleObject(hWriteReadyEvent, INFINITE))
                    return false;
            }
        }
        return true;
    }

    void CReadWriteLock::ReleaseExclusiveLock( )
    {
        InterlockedDecrement( &lTotalUsers );
        InterlockedDecrement( &lExclusive );
        SetEvent(hReadReadyEvent);
    }

    bool CReadWriteLock::ClaimShareLock( )
    {
        InterlockedIncrement( &lTotalUsers );
        if (CReadWriteLock::lExclusive > 0)
        {
            if (WAIT_OBJECT_0 != WaitForSingleObject(hReadReadyEvent, INFINITE))
                return false;
        }
        InterlockedIncrement ( &lReadInQueue );
        return true;
    }


    void CReadWriteLock::ReleaseShareLock( )
    {
        if (0 == InterlockedDecrement ( &lReadInQueue ))
        {
            if (CReadWriteLock::lExclusive > 0)
                SetEvent(hWriteReadyEvent);
        }
        InterlockedDecrement( &lTotalUsers );
    }
};

//
// this class extends CReadWriteLock to allow multiple write threads
//      -- additional overhead of entering/leaving critical section 
//
class CReadWriteLockEx : public CReadWriteLock
{
public:
    bool ClaimExclusiveLock()
    {
        // Request ownership of the critical section.
        EnterCriticalSection(&CriticalSection); 
        return CReadWriteLock::ClaimExclusiveLock();
    };

    void ReleaseExclusiveLock( )
    {
        CReadWriteLock::ReleaseExclusiveLock();
        // Release ownership of the critical section.
        LeaveCriticalSection(&CriticalSection);
    };

public:
    // constructor and desctructor
    CReadWriteLockEx()
    {
       // Initialize the critical section.
       InitializeCriticalSection(&CriticalSection); 
    };
    
    virtual ~CReadWriteLockEx()
    {
       // Release resources used by the critical section object.
       DeleteCriticalSection(&CriticalSection);
    };

protected:
   // data members
   CRITICAL_SECTION CriticalSection;
   
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\srxutil.h ===
//-----------------------------------------------------------------------------
//
//  @doc
//
//  @module SRXUtil.h | SRX to SRF preprocessing utilities.
//
//  Author: Darren Anderson
//
//  Date:   6/23/2000
//
//  Copyright <cp> 1999-2000 Microsoft Corporation.  All Rights Reserved.
//
//-----------------------------------------------------------------------------

#define ToString(x) #x
#define QuotedReplacement(x) ToString(##x)

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\smallheap.hpp ===
#ifndef _SMALL_HEAP_HPP_
#define _SMALL_HEAP_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Rockall.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   A small heap.                                                  */
    /*                                                                  */
    /*   A small heap tries to significantly reduce memory usage        */
    /*   even if that comes at a significant cost in terms of           */
    /*   performance.                                                   */
    /*                                                                  */
    /********************************************************************/

class ROCKALL_LINKAGE SMALL_HEAP : public ROCKALL
    {
   public:
        //
        //   Public functions.
        //
        SMALL_HEAP
			( 
			int						  MaxFreeSpace = 0,
			bool					  Recycle = false,
			bool					  SingleImage = false,
			bool					  ThreadSafe = true 
			);

        ~SMALL_HEAP( void );

	private:
        //
        //   Disabled operations.
 		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        SMALL_HEAP( const SMALL_HEAP & Copy );

        void operator=( const SMALL_HEAP & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\regutils.h ===
//-----------------------------------------------------------------------------
//
// RegUtils.h
//
// Helper functions for dealing with the registry.
//
// Author: Jeff Steinbok
//
// 02/01/01       jeffstei    Initial Version
//
// Copyright <cp> 2000-2001 Microsoft Corporation.  All Rights Reserved.
//
//-----------------------------------------------------------------------------

#ifndef _REG_UTILS_H
#define _REG_UTILS_H

//
// CopyKeyHierarchy(...)
//
// Copies a hierarchy of the registry to another location
//
// Params:
//   HKEY in_hKeySrc	        Handler to the parent key, this can be 
//								simpley HKEY_CLASSES_ROOT
//   LPTSTR in_lpszSubKeySrc    Subkey string.  This can be NULL if the prev
//								param points to the actual key.
//	 HKEY in_hKeyDest			Destination key.
//	 LPTSTR in_lpszSubKeyDest	Destination subkey.
//
// Returns:
//	 0  = Success
//   !0 = Failure:  See error codes in winerror.h   
//
// Examples:
//	  CopyKeyHierarchy(HKEY_CLASSES_ROOT, L"Passport.Manager", HKEY_CLASSES_ROOT, L"PPMCopy")
//	  CopyKeyHierarchy(key, NULL, HKEY_CLASSES_ROOT, L"PPMCopy")
//
LONG CopyKeyHierarchy (HKEY in_hKeySrc, LPTSTR in_lpszSubKeySrc, HKEY in_hKeyDest, LPTSTR in_lpszSubKeyDest);

//
// DeleteKeyHierarchy(...)
//
// Deletes a hierarchy of the registry 
//
// Params:
//   HKEY in_hKey   	        Handler to the parent key, this can be 
//								simpley HKEY_CLASSES_ROOT
//   LPTSTR in_lpszSubKey       Subkey string.  This can be NULL if the prev
//								param points to the actual key.
//
// Returns:
//	 0  = Success
//   !0 = Failure:  See error codes in winerror.h   
//
// Examples:
//	  DeleteKeyHierarchy(HKEY_CLASSES_ROOT, L"Passport.Manager")
//	  DeleteKeyHierarchy(key, NULL)
//
LONG DeleteKeyHierarchy (HKEY in_hKey, LPTSTR in_lpszSubKey);

//
// RenameKey(...)
//
// Renames a registry key
//
// Params:
//   HKEY in_hKeySrc	        Handler to the parent key, this can be 
//								simpley HKEY_CLASSES_ROOT
//   LPTSTR in_lpszSubKeySrc    Subkey string.  This can be NULL if the prev
//								param points to the actual key.
//	 HKEY in_hKeyDest			Destination key.
//	 LPTSTR in_lpszSubKeyDest	Destination subkey.
//
// Returns:
//	 0  = Success
//   !0 = Failure:  See error codes in winerror.h   
//
// Examples:
//	  RenameKey(HKEY_CLASSES_ROOT, L"Passport.Manager", HKEY_CLASSES_ROOT, L"PPMCopy")
//	  RenameKey(key, NULL, HKEY_CLASSES_ROOT, L"PPMCopy")
//
LONG RenameKey (HKEY in_hKeySrc, LPTSTR in_lpszSubKeySrc, HKEY in_hKeyDest, LPTSTR in_lpszSubKeyDest);

#endif _REG_UTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\urlfunctions.h ===
//-----------------------------------------------------------------------------
//
//  @doc
//
//  @module UrlFunctions.h |  Generic URL construction routines.
//
//  Author: Darren Anderson
//
//  Date:   5/17/00
//
//  Copyright <cp> 1999-2000 Microsoft Corporation.  All Rights Reserved.
//
//-----------------------------------------------------------------------------
#pragma once

void
RootUrl(
    bool        bSecure,
    CPPUrl&     rootUrl
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\rockall.hpp ===
#ifndef _ROCKALL_HPP_
#define _ROCKALL_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include <stddef.h>

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation constants.                                   */
    /*                                                                  */
    /*   The memory allocation constants are denote special situations  */
    /*   where optimizations are possible or failures have cccured.     */
    /*                                                                  */
    /********************************************************************/

const int AllocationFailure			  = 0;
const int GuardValue				  = 0xDeadBeef;
const int NoSize					  = -1;

    /********************************************************************/
    /*                                                                  */
    /*   Class forward references.                                      */
    /*                                                                  */
    /*   We need to refer to the following classes before they are      */
    /*   fully specified so here we list them as forward references.    */
    /*                                                                  */
    /********************************************************************/

class CACHE;
class FIND;
class HEAP;
class NEW_PAGE;

    /********************************************************************/
    /*                                                                  */
    /*   Linkage to the DLL.                                            */
    /*                                                                  */
    /*   We need to compile the class specification slightly            */
    /*   differently if we are creating the heap DLL.                   */
    /*                                                                  */
    /********************************************************************/

#ifdef COMPILING_ROCKALL_DLL
#define ROCKALL_LINKAGE __declspec(dllexport)
#else
#define ROCKALL_LINKAGE __declspec(dllimport)
#endif

    /********************************************************************/
    /*                                                                  */
    /*   The memory allocation interface.                               */
    /*                                                                  */
    /*   The memory allocator can be configured in a wide variety       */
    /*   of ways to closely match the needs of specific programs.       */
    /*   The interface outlined here can be overloaded to support       */
    /*   whatever customization is necessary.                           */
    /*                                                                  */
    /********************************************************************/

class ROCKALL_LINKAGE ROCKALL
    {
    public:
		//
		//   Public types.
		//
		//   A heap is constructed of a collection of 
		//   fixed sized buckets each with an associated
		//   cache.  The details of these buckets are
		//   supplied to the heap using the following
		//   structure.
		//
		typedef struct
			{
			int						  AllocationSize;
			int						  CacheSize;
			int						  ChunkSize;
			int						  PageSize;
			}
		CACHE_DETAILS;

		//
		//   Public data.
		//
		//   The internals linkages in a heap are built
		//   dynamically during the execution of a heaps
		//   constructor.  The member that follow relate
		//   to key internal classes.
		//
		CACHE						  **Array;
		CACHE						  *Caches;
		FIND						  *Find;
		HEAP						  *Heap;
		NEW_PAGE					  *NewPage;

		//
		//   A heap constructor is required to preserve 
		//   a small amount of information for the heap
		//   destructor.
		//
		bool						  GlobalDelete;
		int							  GuardWord;
		int							  NumberOfCaches;
		int							  TotalSize;

        //
        //   Public functions.
		//
		//   A heaps public interface consists of a number
		//   of groups of related APIs.
        //
		ROCKALL( void );

        ROCKALL
			(
			CACHE_DETAILS			  *Caches1,
			CACHE_DETAILS			  *Caches2,
			int						  FindCacheSize,
			int						  FindCacheThreshold,
			int						  FindSize,
			int						  MaxFreeSpace,
			int						  *NewPageSizes,
			bool					  Recycle,
			bool					  SingleImage,
			int						  Stride1,
			int						  Stride2,
			bool					  ThreadSafe 
			);

		//
		//   Manipulate allocations.
		//
		//   The first group of functions manipulate 
		//   single or small arrays of allocations. 
		//
		virtual bool Delete
			( 
			void					  *Address,
			int						  Size = NoSize 
			);

		virtual bool Details
			( 
			void					  *Address,
			int						  *Space = NULL 
			);

		virtual bool KnownArea( void *Address );

		virtual bool MultipleDelete
			( 
			int						  Actual,
			void					  *Array[],
			int						  Size = NoSize
			);

		virtual bool MultipleNew
			( 
			int						  *Actual,
			void					  *Array[],
			int						  Requested,
			int						  Size,
			int						  *Space = NULL,
			bool					  Zero = false
			);

		virtual void *New
			( 
			int						  Size,
			int						  *Space = NULL,
			bool					  Zero = false
			);

		virtual void *Resize
			( 
			void					  *Address,
			int						  NewSize,
			int						  Move = -64,
			int						  *Space = NULL,
			bool					  NoDelete = false,
			bool					  Zero = false
			);

		virtual bool Verify
			( 
			void					  *Address = NULL,
			int						  *Space = NULL 
			);

		//
		//   Manipulate the heap.
		//
		//   The second group of functions act upon a heap
		//   as a whole.
		//
		virtual void DeleteAll( bool Recycle = true );

		virtual void LockAll( void );

		virtual void Truncate( int MaxFreeSpace = 0 );

		virtual void UnlockAll( void );

		virtual bool Walk
			(
			bool					  *Active,
			void					  **Address,
			int						  *Space
			);

		//
		//   Low level heap interface.
		//
		//   The third group of functions are called by the
		//   heap to aquire or release large blocks of memory.
		//   These functions can be overloaded to enable the
		//   heap work in constrained environments.
		//
		virtual void DeleteArea( void *Memory,int Size );

		virtual int NaturalSize( void );

		virtual void *NewArea( int AlignMask,int Size );

        virtual ~ROCKALL( void );

		//
		//   Public inline functions.
		//
		inline bool Available( void )
			{ return (GuardWord == GuardValue); }

		inline bool Failure( void )
			{ return (GuardWord != GuardValue); }

	private:
		//
		//   Private functions.
		//
		//   A heap needs to compute the size of certain
		//   user supplied structures.  This task is 
		//   performed by the following function.
		//
		int ComputeSize( char *Array,int Stride );

        //
        //   Disabled operations.
		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        ROCKALL( const ROCKALL & Copy );

        void operator=( const ROCKALL & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\soaphelper.h ===
//-----------------------------------------------------------------------------
//
// SOAPHelper.h
//
// Helper functions for SOAP
//
// This implementation aims to be SOAP 1.1 compliant.  The spec can be
// found here:
//		http://msdn.microsoft.com/xml/general/soapspec.asp
//
// Author: Wei Jiang
//
// 10/12/00       weijiang    created
// 01/10/01       weijiang    update for SOAP 1.1, code clean up
// 01/23/01       jeffstei    Rename and add GetSOAPMethod(...)
//
// Copyright <cp> 2000-2001 Microsoft Corporation.  All Rights Reserved.
//
//-----------------------------------------------------------------------------

#if !defined(_SOAPHELPER_H_)
#define _SOAPHELPER_H_

#pragma once

#ifndef  Assert
#define  Assert   ATLASSERT
#endif

// SOAP content type
#define CZ_SOAP_CONTENTTYPE  "text/xml; charset=\"utf-8\""
#define CZ_SOAP_CONTENTTYPEBASIC "text/xml"


#define  ERR_XML_FORMAT    "Incorrect xml data"
#define  ERR_SOAP_ENVELOPE "Incorrect SOAP envelope, or SOAP envelope is missing "
#define  ERR_SOAP_BODY     "Incorrect SOAP body, or SOAP body is missing"
#define  ERR_SOAP_METHOD   "Incorrect method, or SOAP method is missing"
#define  ERR_SOAP_PARAM    "Incorrect parameter: "


#define  SOAP_FAULT        "Fault"
#define  SOAP_FAULT_CODE   "faultcode"
#define  SOAP_FAULT_STRING "faultstring"
#define  SOAP_FAULT_DETAIL "detail"

#define  SOAP_ENV_URI      "http://schemas.xmlsoap.org/soap/envelope/"
#define  SOAP_ENC_URI      "http://schemas.xmlsoap.org/soap/encoding/" 
#define  SOAP_ENV_NS       "SOAP-ENV"
#define  SOAP_ENV_NAME     "Envelope"
#define  SOAP_ENV_BODY     "Body"

#define  SOAP_ENV_NAME_TAG SOAP_ENV_NS ":" SOAP_ENV_NAME
#define  SOAP_ENV_BODY_TAG SOAP_ENV_NS ":" SOAP_ENV_BODY

#define  XML_V10           "<?xml version=\"1.0\"?>"

/*
  xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"
  SOAP-ENV:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/
*/
#define     SOAP_NS_URI    "xmlns:" SOAP_ENV_NS "=\'" SOAP_ENV_URI "\'\n" \
                           SOAP_ENV_NS ":encodingStyle=\'" SOAP_ENC_URI "\'"

// change string to unicode
#define  W(n)              __WIDECHAR__(n)
#define  __WIDECHAR__(n)   L ## n

// open & close tag string macros
#define  OPENTAG_NS(nm,ns) "<" ## nm ## " " ## ns ">"
#define  OPENTAG(t)        "<" ## t ## ">"
#define  CLOSETAG(t)       "</" ## t ## ">"

/*
<?xml version="1.0"?>\r\n
<SOAP:Envelope xmlns:SOAP="http://schemas.xmlsoap.org/soap/envelope/" SOAP:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/">\r\n
<SOAP:Body>
*/
#define SOAPEnvelope_Body_Open  XML_V10 OPENTAG_NS(SOAP_ENV_NAME_TAG, SOAP_NS_URI) OPENTAG(SOAP_ENV_BODY_TAG)

/*
</SOAP:Body>
</SOAP:Envelope>
*/
#define SOAPEnvelope_Body_Close CLOSETAG(SOAP_ENV_BODY_TAG) CLOSETAG(SOAP_ENV_NAME_TAG) 


class SOAPHelper;

#define  MAX_PARAM_LENGTH  64
#define  MAX_PARAM_COUNT   64

///////////////////////////////////////////////////////////////////////////////////
//
// CLASS ParamMap
//
// Class to contain a mapping of parameters read from a SOAP Request and written
// to a response.
//
///////////////////////////////////////////////////////////////////////////////////
class ParamMap
{
private:
   friend class SOAPHelper;
   struct Param
   {
      WCHAR    name[MAX_PARAM_LENGTH + 1];
      VARIANT  value;
   };

public:
   UINT  Size()   { return cnt;};
   BOOL  Get(UINT index, LPCWSTR* pName, VARIANT** pVal)
   {
      if ( index >= cnt ) return FALSE;

      *pName = params[index].name;
      *pVal  = &params[index].value;

      return TRUE;
   };
   
   VARIANT* Find(LPCWSTR name)
   {
      for(UINT i = 0; i < cnt; ++i)
      {
         if(wcsncmp(params[i].name, name, MAX_PARAM_LENGTH) == 0)
            return &params[i].value;
            
      };

      return NULL;
   };

public:   
   // note: parameter pVar will be skin level copied, NOT VariantCopied ...
   // note: parameter pVar will be set to VT_EMPTY after this call
   HRESULT  AddParam(LPCWSTR name, VARIANT* pVar)
   {
      Assert(name);
      Assert(pVar);
      
      if(cnt >= MAX_PARAM_COUNT) return S_FALSE;

      wcsncpy(params[cnt].name, name, MAX_PARAM_LENGTH);
      params[cnt].value = *pVar;
      ++cnt;

      VariantInit(pVar);

      return S_OK;
   };

public:
   ParamMap() : cnt(0)   {   };
   virtual ~ParamMap()
   {
      for (UINT i = 0; i < cnt; ++i)
      {
         VariantClear(&params[i].value);
      }
   };
   
private:
   Param  params[MAX_PARAM_COUNT];
   UINT    cnt;
};
///////////////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////////////
//
// CLASS SOAPHelper
//
// Class of static methods and definitions to help in processing
// SOAP requests and responses
//
///////////////////////////////////////////////////////////////////////////////////
class SOAPHelper
{
public:

   //
   // GetParameters(...)
   //
   // retrieve the parameters from a given ECB
   //the method name, content type are checked
   //
   static HRESULT GetParameters(IN EXTENSION_CONTROL_BLOCK* pECB,
                                IN  LPCWSTR pcwszMethodName,
                                OUT ParamMap& mapParams, 
                                OUT VARIANT_BOOL& bParsedOK, 
                                OUT CStringW& strParseErr);

   // 
   // GenerateResponse(...)
   //
   // generate soap response package with given paramters
   // content type is returned from this call
   //
   static HRESULT GenerateResponse(
                                IN  LPCWSTR pcwszMethodName,
                                IN  ParamMap& mapParams, 
                                OUT CHeapPtr<char>& body,
                                OUT CStringA& contentType);
   

   //
   // GenerateFaultSOAPEnvelope (...)
   //
   // generate soap fault package with the passed in parameters.
   //
   static HRESULT GenerateFaultSOAPEnvelope(IN  DWORD dwFaultCode,
   											IN  LPCSTR pcszFaultString,
   											IN  LPCSTR pcszFaultActor,
                                            IN  LPCSTR pcszDetail, 
                                            OUT CStringA& faultEnvelope);

   //
   // GetFaultSOAPEnvelopeDetail(...)
   //
   // get error details from a soap fault package
   //
   static HRESULT GetFaultSOAPEnvelopeDetail(IN  BSTR faultEnvelope, 
                                             OUT CStringW& faultCode, 
                                             OUT CStringW& faultString,
                                             OUT CStringW& faultDetail);

   // 
   // GenerateSOAPEnvelope(...)
   //
   static HRESULT GenerateSOAPEnvelope(ParamMap& mapParams,
                                    LPCWSTR pcwszMethodName,
                                    BSTR* envelope);

   //
   // ParseSOAPEnvelope(...)
   //
   static HRESULT ParseSOAPEnvelope(ParamMap& mapParams,
                                    LPCWSTR pcwszMethodName,
                                    BSTR bstrSoapEnvelope, 
                                    VARIANT_BOOL* pbParsedOK, 
                                    BSTR* pbstrErrorMsg);
   //
   // GetSOAPMethod(...)
   // 
   // Returns the full SOAP method name.
   //
   static HRESULT GetSOAPMethod(EXTENSION_CONTROL_BLOCK* pECB, 
   								LPCSTR path, 
   								CStringW& out_cszMethod);

   //
   // GetShortSOAPMethod(...)
   //
   // Returns the abbreviated method name, all in lowercase.  The abbreviated name consists
   // of everything in the full name (see above function) after the "#"
   //
   static HRESULT GetShortSOAPMethod(EXTENSION_CONTROL_BLOCK* pECB, 
   									 LPCSTR path, 
   									 CStringW& out_cszMethod);

   //
   // CheckSOAPMethod(...)
   //
   // Checks to determine presence of the passed in method.  
   // pRet will contain TRUE of the method exists, and FALSE otherwize.
   //
   static HRESULT CheckSOAPMethod(EXTENSION_CONTROL_BLOCK* pECB, 
   								  LPCSTR pcszMethod, 
   								  LPCSTR pcszPath, 
   								  BOOL* pRet); 

   // SOAP Fault codes.  Taken from SOAP 1.1 specification.  
   // The numbers associated are arbitrary (i think).  Either way
   // they're never shown to the user
   static const UINT SOAP_FAULT_NONE = 0;			// This is NOT a SOAP code, but we needed an "unset" value.
   static const UINT SOAP_FAULT_VERSIONMISMATCH = 100;
   static const UINT SOAP_FAULT_MUSTUNDERSTAND = 200;
   static const UINT SOAP_FAULT_CLIENT = 300;
   static const UINT SOAP_FAULT_SERVER = 400;
   
};
///////////////////////////////////////////////////////////////////////////////////

#endif //!defined(_SOAPHELPER_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\ticketschema.h ===
#ifndef _TICKET_SCHEMA_H
#define _TICKET_SCHEMA_H

#include "xstring"
#include "BstrHash.h"

#include "xmltlh.h"
//#import "msxml.dll" rename_namespace("MSXML")
//#import "msxml.dll"
//#define MSXML

// this schema object can only handles schema version within the following range
#define  VALID_SCHEMA_VERSION_MIN	1
#define  VALID_SCHEMA_VERSION_MAX	0x1ff

class CRefCountObj
{
public:
   ULONG AddRef()
   {
      InterlockedIncrement(&m_refs);
      return m_refs;
   };
   ULONG Release()
   {
      InterlockedDecrement(&m_refs);
      if (m_refs == 0)
      {
         delete this;
         return 0;
      }
      else
         return m_refs;
   };
protected:
   CRefCountObj(): m_refs(0){};
   virtual ~CRefCountObj(){};

   long    m_refs;
};

// the value types supported in the schema
enum TicketValueType {
    tNull = 0, 
    tText,
    tChar,
    tByte,
    tWord,
    tLong,
    tDate,
    tInvalid
  };

#define	SIZE_TEXT		(DWORD)(-1)

// the size array of the types defines in TicketValueType
const DWORD TicketTypeSizes[] =
{
	0, 
    SIZE_TEXT,
    1,	
    1, 
    sizeof(short),
    sizeof(long),
    sizeof(long),
    0
};

// attribute names in schema definition in partner.xml
#define	ATTRNAME_VERSION	L"version"
#define	ATTRNAME_NAME	L"name"
#define	ATTRNAME_TYPE	L"type"
#define	ATTRNAME_SIZE	L"size"
#define	ATTRNAME_FLAGS	L"flags"


// type name value map
struct CTicketTypeNameMap {
   LPCWSTR  name;
   DWORD    type;
};

const CTicketTypeNameMap TicketTypeNameMap[] = { 
	{L"text" , tText},
	{L"char" , tChar},
	{L"byte" , tByte},
	{L"word" , tWord},
	{L"text" , tLong},
	{L"long" , tLong},
	{L"date" , tDate},
	{L"long" , tLong},
};
	
struct TicketFieldDef
{
   _bstr_t  name;
   DWORD    type;
   DWORD    flags;
};

#define  INVALID_OFFSET (DWORD)(-1)

struct   TicketProperty
{
   TicketProperty():flags(0), offset(INVALID_OFFSET) {}; 
   _variant_t  value;
   DWORD       type;       // type of the property, a value of TicketValueType
   DWORD       flags;      // the flags defined in schema
   DWORD       offset;     // the offset of the property in raw buf
};

class CTicketSchema;
class C_Ticket_13X;

class wstringLT
{
 public:
  bool operator()(const std::wstring& x, const std::wstring& y) const
  {
    return (_wcsicmp(x.c_str(),y.c_str()) < 0);
  }
};

typedef std::map<std::wstring,TicketProperty, wstringLT> TicketPropertyMap;

class CTicketPropertyBag
{
friend class CTicketSchema;
friend class C_Ticket_13X;
public:
   CTicketPropertyBag();
   virtual ~CTicketPropertyBag();

   HRESULT GetProperty(LPCWSTR  name, TicketProperty& prop);
   
protected:     
   // this bag is read only to external
   HRESULT PutProperty(LPCWSTR  name, const TicketProperty& prop);

protected:
   TicketPropertyMap  m_props;
};

class CTicketSchema : public CRefCountObj
{
 public:
  // Read the raw blob according to the schema, and output the positions of
  // each element.  Output array size MUST be >= Count()
  HRESULT parseTicket(LPCSTR raw, UINT size, CTicketPropertyBag& bag);


  CTicketSchema();
  virtual ~CTicketSchema();

  BOOL    isValid() const { return m_isOk; }
  _bstr_t getErrorInfo() const { return m_szReason; }
  
  BOOL ReadSchema(MSXML::IXMLElementPtr &root);

protected:

  BOOL      m_isOk;
  _bstr_t   m_szReason;

  // Valid until this time
  SYSTEMTIME m_validUntil;

  // verion #
  USHORT    m_version;

  // name
  _bstr_t   m_name;

  // Array of attribute types
  UINT            m_numAtts;
  TicketFieldDef* m_attsDef;
};

#if 0 // was meant to replace existing code that parses the 1.3x ticket -- to avoid too much change, not to use it for now.
//
// the class deals with 1.3X ticket data part
//
class CTicket_13X 
{
public:
   CTicket_13X(){};
   virtual ~CTicket_13X(){};

   BOOL parse(LPBYTE raw, DWORD dwByteLen, DWORD* pdwDataParsed);
   ULONG memberIdHigh();
   ULONG memberIdLow();
   ULONG flags();
   ULONG signInTime();
   ULONG ticketTime();
   ULONG currentTime();
   BOOL hasSavedPassword();
   BOOL isValid();
   
protected:
   BOOL    m_valid;
   BOOL    m_savedPwd;
   int     m_mIdLow;
   int     m_mIdHigh;
   long    m_flags;
   time_t  m_ticketTime;
   time_t  m_lastSignInTime;
   time_t  m_curTime;

private:

};
#endif   // if 0 ... 

#define  MORE_MASKUNIT(n)           (((n) & 0x8000) != 0)
#define  MASK_INDEX_INVALID        (USHORT)(-1)

class CTicketFieldMasks
{
public:
   CTicketFieldMasks(): m_fieldIndexes(NULL){};
   virtual ~CTicketFieldMasks(){delete[] m_fieldIndexes;};
   HRESULT     Parse(LPBYTE mask, ULONG size, ULONG* pcParsed);
   unsigned short* GetIndexes(){ return m_fieldIndexes;};

protected:
   unsigned short*   m_fieldIndexes;
};

#endif	// _TICKET_SCHEMA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\stock.h ===
/*
 * stock.h - Stock header file.
 *
 * Taken from URL code by ChrisPi 9-11-95
 *
 */

#ifndef _STOCK_H_
#define _STOCK_H_

/* Constants
 ************/

#define FOREVER                  for (;;)

#define INVALID_SEEK_POSITION    (0xffffffff)

#define EMPTY_STRING             ""

#ifdef DEBUG
#define NULL_STRING              "(null)"
#endif

#define SLASH_SLASH              "\\\\"

#define ASTERISK                 '*'
#define BACKSLASH                '/'
#define COLON                    ':'
#define COMMA                    ','
#define EQUAL                    '='
#define PERIOD                   '.'
#define POUND                    '#'
#define QMARK                    '?'
#define QUOTE                    '\''
#define QUOTES                   '"'
#define SLASH                    '\\'
#define SPACE                    ' '
#define TAB                      '\t'

/* linkage */

#ifdef __cplusplus
#define INLINE                   inline
#else
#define INLINE                   __inline
#endif

/* limits */

#define WORD_MAX                 USHRT_MAX
#define DWORD_MAX                ULONG_MAX

/* file system constants */

#define MAX_PATH_LEN             MAX_PATH
#define MAX_NAME_LEN             MAX_PATH
#define MAX_FOLDER_DEPTH         (MAX_PATH / 2)
#define DRIVE_ROOT_PATH_LEN      (4)

/* ui constants */

#define MAX_MSG_LEN              MAX_PATH_LEN

/* invalid thread ID */

#define INVALID_THREAD_ID        (0xffffffff)

/* no context-sensitive help available */

#define NO_HELP                  ((DWORD)-1)

/* Win32 HRESULTs */

#define E_FILE_NOT_FOUND         MAKE_SCODE(SEVERITY_ERROR, FACILITY_WIN32, ERROR_FILE_NOT_FOUND)
#define E_PATH_NOT_FOUND         MAKE_SCODE(SEVERITY_ERROR, FACILITY_WIN32, ERROR_PATH_NOT_FOUND)

/* file-related flag combinations */

#define ALL_FILE_ACCESS_FLAGS          (GENERIC_READ |\
                                        GENERIC_WRITE)

#define ALL_FILE_SHARING_FLAGS         (FILE_SHARE_READ |\
                                        FILE_SHARE_WRITE)

#define ALL_FILE_ATTRIBUTES            (FILE_ATTRIBUTE_READONLY |\
                                        FILE_ATTRIBUTE_HIDDEN |\
                                        FILE_ATTRIBUTE_SYSTEM |\
                                        FILE_ATTRIBUTE_DIRECTORY |\
                                        FILE_ATTRIBUTE_ARCHIVE |\
                                        FILE_ATTRIBUTE_NORMAL |\
                                        FILE_ATTRIBUTE_TEMPORARY |\
                                        FILE_ATTRIBUTE_ATOMIC_WRITE |\
                                        FILE_ATTRIBUTE_XACTION_WRITE)

#define ALL_FILE_FLAGS                 (FILE_FLAG_WRITE_THROUGH |\
                                        FILE_FLAG_OVERLAPPED |\
                                        FILE_FLAG_NO_BUFFERING |\
                                        FILE_FLAG_RANDOM_ACCESS |\
                                        FILE_FLAG_SEQUENTIAL_SCAN |\
                                        FILE_FLAG_DELETE_ON_CLOSE |\
                                        FILE_FLAG_BACKUP_SEMANTICS |\
                                        FILE_FLAG_POSIX_SEMANTICS)

#define ALL_FILE_ATTRIBUTES_AND_FLAGS  (ALL_FILE_ATTRIBUTES |\
                                        ALL_FILE_FLAGS)


/* Macros
 *********/

#ifndef DECLARE_STANDARD_TYPES

/*
 * For a type "FOO", define the standard derived types PFOO, CFOO, and PCFOO.
 */

#define DECLARE_STANDARD_TYPES(type)      typedef type *P##type; \
                                          typedef const type C##type; \
                                          typedef const type *PC##type;

#endif

/* character manipulation */

#define IS_SLASH(ch)                      ((ch) == SLASH || (ch) == BACKSLASH)

/* bit flag manipulation */

#define SET_FLAG(dwAllFlags, dwFlag)      ((dwAllFlags) |= (dwFlag))

/* ChrisPi: DCL also defines this - override their definition */
#ifdef CLEAR_FLAG
#undef CLEAR_FLAG
#endif /* CLEAR_FLAG */

#define CLEAR_FLAG(dwAllFlags, dwFlag)    ((dwAllFlags) &= (~dwFlag))

#define IS_FLAG_SET(dwAllFlags, dwFlag)   ((BOOL)((dwAllFlags) & (dwFlag)))
#define IS_FLAG_CLEAR(dwAllFlags, dwFlag) (! (IS_FLAG_SET(dwAllFlags, dwFlag)))

/* array element count */

#define ARRAY_ELEMENTS(rg)                (sizeof(rg) / sizeof((rg)[0]))
#define CCHMAX(rg)                        ARRAY_ELEMENTS(rg)

/* string safety */

#define CHECK_STRING(psz)                 ((psz) ? (psz) : NULL_STRING)

/* file attribute manipulation */

#define IS_ATTR_DIR(attr)                 (IS_FLAG_SET((attr), FILE_ATTRIBUTE_DIRECTORY))
#define IS_ATTR_VOLUME(attr)              (IS_FLAG_SET((attr), FILE_ATTRIBUTE_VOLUME))

/* stuff a point value packed in an LPARAM into a POINT */

#define LPARAM_TO_POINT(lparam, pt)       ((pt).x = (short)LOWORD(lparam), \
                                           (pt).y = (short)HIWORD(lparam))


/* Types
 ********/

typedef const void *PCVOID;
typedef const INT CINT;
typedef const INT *PCINT;
typedef const UINT CUINT;
typedef const UINT *PCUINT;
typedef const LONG CULONG;
typedef const LONG *PCULONG;
typedef const BYTE CBYTE;
typedef const BYTE *PCBYTE;
typedef const WORD CWORD;
typedef const WORD *PCWORD;
typedef const DWORD CDWORD;
typedef const DWORD *PCDWORD;
typedef const CRITICAL_SECTION CCRITICAL_SECTION;
typedef const CRITICAL_SECTION *PCCRITICAL_SECTION;
typedef const FILETIME CFILETIME;
typedef const FILETIME *PCFILETIME;
typedef const BITMAPINFO CBITMAPINFO;
typedef const BITMAPINFO *PCBITMAPINFO;
typedef const POINT CPOINT;
typedef const POINT *PCPOINT;
typedef const POINTL CPOINTL;
typedef const POINTL *PCPOINTL;
typedef const SECURITY_ATTRIBUTES CSECURITY_ATTRIBUTES;
typedef const SECURITY_ATTRIBUTES *PCSECURITY_ATTRIBUTES;
typedef const WIN32_FIND_DATA CWIN32_FIND_DATA;
typedef const WIN32_FIND_DATA *PCWIN32_FIND_DATA;

DECLARE_STANDARD_TYPES(HGLOBAL);
DECLARE_STANDARD_TYPES(HICON);
DECLARE_STANDARD_TYPES(HMENU);
DECLARE_STANDARD_TYPES(HWND);
DECLARE_STANDARD_TYPES(NMHDR);


#ifndef _COMPARISONRESULT_DEFINED_

/* comparison result */

typedef enum _comparisonresult
{
   CR_FIRST_SMALLER = -1,
   CR_EQUAL = 0,
   CR_FIRST_LARGER = +1
}
COMPARISONRESULT;
DECLARE_STANDARD_TYPES(COMPARISONRESULT);

#define _COMPARISONRESULT_DEFINED_

#endif

#endif /* _STOCK_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\webtv.h ===
#pragma once
//-----------------------------------------------------------------------------
//
//  File: WebTV.h
//
//  Author: jhorton
//
//  Date: Wednesday, February 14, 2001
//
//  Description: 
//
//-----------------------------------------------------------------------------

void RedirectToWebTVTrick(LPCSTR szCobrandImageUrl,
                          LPCSTR szMemberName,
                          LPCSTR szPPService);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\windowsheap.hpp ===
#ifndef WINDOWS_HEAP_HPP 
#define WINDOWS_HEAP_HPP 1                         
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Windows.h"

#include "WindowsHeap.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   The shadow interface.                                          */
    /*                                                                  */
    /*   The shadow interface closely resembles the NT heap interface   */
    /*   and so enables the easy porting of applications.               */
    /*                                                                  */
    /********************************************************************/

extern "C" HANDLE WindowsHeapCreate
	( 
	DWORD						  Flags,
	DWORD						  InitialSize,
	DWORD						  MaximumSize 
	);

extern "C" LPVOID WindowsHeapAlloc
	( 
	HANDLE						  Heap,
	DWORD						  Flags,
	DWORD						  Size 
	);

extern "C" UINT WindowsHeapCompact
	( 
	HANDLE						  Heap,
	DWORD						  Flags 
	);

extern "C" BOOL WindowsHeapFree
	( 
	HANDLE						  Heap,
	DWORD						  Flags,
	LPVOID						  Memory 
	);

extern "C" BOOL WindowsHeapLock
	( 
	HANDLE						  Heap 
	);

extern "C" LPVOID WindowsHeapReAlloc
	( 
	HANDLE						  Heap,
	DWORD						  Flags,
	LPVOID						  Memory,
	DWORD						  Size 
	);

extern "C" VOID WindowsHeapReset
	(
	HANDLE						  Heap 
	);

extern "C" DWORD WindowsHeapSize
	( 
	HANDLE						  Heap,
	DWORD						  Flags,
	LPVOID						  Memory 
	);

extern "C" BOOL WindowsHeapUnlock
	(
	HANDLE						  Heap 
	);

extern "C" BOOL WindowsHeapValidate
	( 
	HANDLE						  Heap,
	DWORD						  Flags,
	LPVOID						  Memory 
	);

extern "C" BOOL WindowsHeapWalk
	( 
	HANDLE						  Heap,
	LPPROCESS_HEAP_ENTRY		  Walk 
	);

extern "C" BOOL WindowsHeapDestroy
	(
	HANDLE						  Heap 
	);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\validatefunctions.h ===
//-----------------------------------------------------------------------------
//
//  @doc
//
//  @module ValidateFunctions.h | Function declarations for validation
//
//  Author: Christopher Ambler (cambler)
//
//  01 May 00   - Created           - cambler
//
//  Copyright <cp> 1999-2000 Microsoft Corporation.  All Rights Reserved.
//
//-----------------------------------------------------------------------------
#pragma once

#define VALIDPHONECHAR "0123456789";
// VL_SignInName
const long VALIDATENAME_PPREG = 1;
const long VALIDATENAME_LOGIN = 2;

const long VALIDATEPASSWORD_PASSPORT = 1;
const long VALIDATEPASSWORD_MSN      = 2;

//
//  Validation routines
//

// Validate email address
HRESULT VL_EmailAddress(
    CStringW &szEmail, 
    BOOL bOptional, 
    long nLeftMax, 
    long nRightMax);

// Validate a birthdate is under nYears Old
bool VL_IsUnder(
    DATE Birthdate,
    long nYearsOld);

// Validate location
HRESULT VL_Location(
    CStringW &szCountryCode, 
    CStringW &szRegionGEOID, 
    CStringW &szPostalCode, 
    long &lReturnFlags,
    long lLCID,
    IDictionaryEx* pIDict = NULL);

// Validate nickname
HRESULT VL_NickName(
    CStringW &szName, 
    long nMaxLen);

// Validate occupation
bool VL_Occupation(
    CStringW &szOccupation);

// Validate password
HRESULT VL_Password(
    CStringW &szPassword,
    CStringW &szConfirm,
    CStringW &szMembername,
    long nMinLen, 
    long nMaxLen,
    long nRuleset = VALIDATEPASSWORD_PASSPORT);

// Validate PIN
HRESULT VL_PIN(
    CStringW &in_PIN,          // @parm Password to validated
    CStringW &in_ConfirmPIN,   // @parm Confirmation password
    CStringW &in_membername);      // @parm Membername

// Validate Birthdate
HRESULT VL_ProfileBirthdate(
    long            nDay,
    long            nMonth,
    CStringW        szYear,
    long            flags,
    COleDateTime*   ptBirthdate);

// Validate Birthdate
HRESULT VL_ProfileBirthdate(
    long            nDay,
    long            nMonth,
    long            nYear,
    long            flags,
    COleDateTime*   ptBirthdate);

// Validate secret question and answer
HRESULT VL_ProfileSecretQA(
    CStringW &szSecretQ,
    CStringW &szSecretA);

// Validate secret question and answer more thoroughly
HRESULT VL_SecretQandA(
    CStringW &szNewSQ, 
    CStringW &szNewSA, 
    CStringW &szMName, 
    CStringW &szCurrPW, 
    long nMinLen, 
    long nMaxLen);

// Validate sign-in name
HRESULT VL_SignInName(
    CStringW &Name, 
    long nMinLen, 
    long nMaxLen,
    long nRuleset = VALIDATENAME_PPREG);

// Validate domain - blocked, managed, etc.
HRESULT VL_ManagedDomain(
    CStringW &szSignInName,
    bool     bSignin = TRUE);

// Validate timezone
bool VL_TimeZone(
    CStringW &szTimeZone);

// Validate a string has no invalid chars in it
bool VL_ValidString(
    CStringW &szSource, 
    CStringW &szChars);
//validate phone number, the first param is the phone number to be validated
// the second param is a string that contains all characters that is valid
bool VL_PhoneNumber(CStringW &szSource, CStringW &szChars);  

long IsSiteIdValid(
    ULONG   ulID,
    BSTR szRU);

bool IsUSTerritory(LPCWSTR szCountryCode);

class CProfile;
class CTicket;

// Check whether the user is a signed-in user or not.
// If ppProfile or ppTicket is not NULL, the profile or ticket generated
// during the checking process will be returned to the caller.
// REMEMBER: the caller must delete the object it gets.
bool AlreadyLoggedIn(CProfile & cProfiles);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\xmlmiscutils.h ===
/* @doc
 *
 * @module XMLMiscUtils.h |
 *
 * Header file for XMLMiscUtils.cpp
 *
 * Author: Ying-ping Chen (t-ypchen)
 */
#pragma once

// @func	void | XMLSetContentType | Set the content type
// @rdesc	None
void XMLSetContentType
	(	CHttpResponse	&httpResponse	// @parm	[in]	the outgoing response
	);

// @func	void | GetXMLContentFromPostData | Get the XML content from the post data of a request
// @syntax	void GetXMLContentFromPostData(CHttpRequest &httpRequest, CStringA &cszXML);
// @syntax	void GetXMLContentFromPostData(CHttpRequest &httpRequest, CStringW &cwszXML);
// @rdesc	None
void GetXMLContentFromPostData
	(	CHttpRequest	&httpRequest,	// @parm	[in]	the incoming request
		CStringA		&cszXML			// @parm	[out]	the XML content contained in the request
	);

// Get the XML content from the post data of a request
// (a thin wrapper of the previous function)
void GetXMLContentFromPostData
	(	CHttpRequest	&httpRequest,
		CStringW		&cwszXML		// @parm	[out]	the XML content contained in the request
	);

// @func	HRESULT | CheckRootTag | Check the root tag of the given XML document is correct or not
// @rdesc	Return the following values:
// @flag	S_OK					| successful
// @flag	PP_E_XML_PARSE_ERROR	| can't parse the XML
// @flag	PP_E_INVALIDREQUEST		| the root tag is incorrect
HRESULT CheckRootTag
	(	IXMLDOMDocument *pXMLDoc,	// @parm	[in]	the XML document
		LPCWSTR pwszRootTag			// @parm	[in]	the correct root tag
	);

// @func	HRESULT | CheckClientVersion | Check the client version if it is valid
// @rdesc	Return the following values:
// @flag	S_OK							| successful
// @flag	PP_E_XML_NO_CLIENTINFO			| no "ClientInfo" node in the XML document
// @flag	PP_E_XML_UNKNOWN_CLIENTVERSION	| unknown client version
HRESULT CheckClientVersion
	(	IXMLDOMDocument *pXMLDoc,	// @parm	[in]	the XML document
		double &dVersion			// @parm	[out]	the client version (if S_OK)
	);

// @func	HRESULT | CheckSignInNameAndDomain | Validate signinname, password, and domain, directly from the XML post
// @rdesc	Return the following values:
// @flag	S_OK								| successful
// @flag	PP_E_XML_DOMAIN_BLANK				| no domain
// @flag	PP_E_XML_DOMAIN_BLANK_EX			| no domain (RAID 7628)
// @flag	PP_E_XML_NAME_AND_PASSWORD_BLANK	| no member name and no password
// @flag	PP_E_NAME_BLANK						| no member name
// @flag	PP_E_PASSWORD_BLANK					| no password
// @flag	PP_E_INVALIDPARAMS					| some parameter(s) too long
HRESULT CheckSignInNameAndDomain
	(	double			dClientVersion,			// @parm	[in]	the client version
		IXMLDOMDocument	*pXMLDoc,				// @parm	[in]	the XML document
		CStringW		&cwszSignInName,		// @parm	[out]	the member name
		CStringW		&cwszDomain,			// @parm	[out]	the domain
		CStringW		&cwszPassword,			// @parm	[out]	the password of the user
		CStringW		&cwszSignInNameComplete	// @parm	[out]	the complete member name
	);

// @func	HRESULT | CheckIDRU | Check the id & ru
// @rdesc	Return the following values:
// @flag	S_OK					| successful
// @flag	PP_E_INVALIDSITEID		| id is invalid
// @flag	PP_E_INVALIDRETURNURL	| id is valid but ru is not
HRESULT CheckIDRU
		(	long	&lSiteId,		// @parm	[out]	id
			CPPUrl	&curlRu,		// @parm	[out]	ru
			bool	&bReturnToSite	// @parm	[out]	can the id & ru be used to return?
		);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\xmldocutils.h ===
/* @doc
 *
 * @module XMLDocUtils.h |
 *
 * Header file for XMLDocUtils.cpp
 *
 * Author: Ying-ping Chen (t-ypchen)
 */
#pragma once

// @func	void | CreateXMLDocument | Create a new XML document
// @rdesc	None
void CreateXMLDocument
	(	IXMLDOMDocument **ppXMLDoc	// @parm [out]	the created XML document
	); 

// @func	void | XMLAddAttributeToElement | Add an attribute to an element
// @syntax	void XMLAddAttributeToElement(IXMLDOMDocument *pContextDoc, IXMLDOMElement *pElement, const BSTR bstrAttrName, const CComVariant	&varAttrValue);
// @syntax	void XMLAddAttributeToElement(IXMLDOMDocument *pContextDoc, IXMLDOMElement *pElement, const LPCWSTR pwszAttrName, const LPCWSTR pwszAttrValue);
// @rdesc	None
void XMLAddAttributeToElement
	(	IXMLDOMDocument		*pContextDoc,	// @parm	[in]	the XML context for creating the new attribute
		IXMLDOMElement		*pElement,		// @parm	[in]	the XML element
		const BSTR			bstrAttrName,	// @parm	[in]	the name of the attribute
		const CComVariant	&varAttrValue	// @parm	[in]	the value of the attribute
	);

// Add an attribute to an element (a thin wrapper of the previous function)
void XMLAddAttributeToElement
	(	IXMLDOMDocument	*pContextDoc,
		IXMLDOMElement	*pElement,
		const LPCWSTR	pwszAttrName,	// @parm	[in]	the name of the attribute
		const LPCWSTR	pwszAttrValue	// @parm	[in]	the value of the attribute
	);

// @func	void | XMLAddTextToElement | Add a text node to an element
// @syntax	void XMLAddTextToElement(IXMLDOMElement *pElement, const BSTR bstrText);
// @syntax	void XMLAddTextToElement(IXMLDOMElement *pElement, const LPCWSTR pwszText);
// @rdesc	None
void XMLAddTextToElement
	(	IXMLDOMElement	*pElement,	// @parm	[in]	the XML element
		const BSTR		bstrText	// @parm	[in]	the text of the text node
	);

// Add a text node to an element (a thin wrapper of the previous function)
void XMLAddTextToElement
	(	IXMLDOMElement	*pElement,
		const LPCWSTR	pwszText	// @parm	[in]	the text of the text node
	);

// @func	void | XMLAddElementToNode |
//				Add an element to a node,
//				add an element to a node with a text node, or
//				add an element to a node with an attribute.
// @syntax	void XMLAddElementToNode(IXMLDOMDocument *pContextDoc, IXMLDOMNode *pParentNode, const BSTR bstrTagName, IXMLDOMElement **ppElement, IXMLDOMNode **ppNode = NULL);
// @syntax	void XMLAddElementToNode(IXMLDOMDocument *pContextDoc, IXMLDOMNode *pParentNode, const LPCWSTR pwszTagName, IXMLDOMElement **ppElement, IXMLDOMNode **ppNode = NULL);
// @syntax	void XMLAddElementToNode(IXMLDOMDocument *pContextDoc, IXMLDOMNode *pParentNode, const BSTR bstrTagName, const BSTR bstrText, IXMLDOMElement **ppElement, IXMLDOMNode **ppNode = NULL);
// @syntax	void XMLAddElementToNode(IXMLDOMDocument *pContextDoc, IXMLDOMNode *pParentNode, const LPCWSTR pwszTagName, const LPCWSTR pwszText, IXMLDOMElement **ppElement, IXMLDOMNode **ppNode = NULL);
// @syntax	void XMLAddElementToNode(IXMLDOMDocument *pContextDoc, IXMLDOMNode *pParentNode, const BSTR bstrTagName, const BSTR	bstrAttrName, const CComVariant &varAttrValue, IXMLDOMElement **ppElement, IXMLDOMNode **ppNode = NULL);
// @syntax	void XMLAddElementToNode(IXMLDOMDocument *pContextDoc, IXMLDOMNode *pParentNode, const LPCWSTR pwszTagName, const LPCWSTR pwszAttrName, const LPCWSTR pwszAttrValue, IXMLDOMElement **ppElement, IXMLDOMNode **ppNode = NULL);
// @rdesc	None
void XMLAddElementToNode
	(	IXMLDOMDocument	*pContextDoc,	// @parm	[in]	the XML context for creating the new element
		IXMLDOMNode		*pParentNode,	// @parm	[in]	the parent node
		const BSTR		bstrTagName,	// @parm	[in]	the tag of the new element
		IXMLDOMElement	**ppElement,	// @parm	[out]	the created element
		IXMLDOMNode		**ppNode = NULL	// @parmopt	[out]	(Optional) the XML node interface to the created element
	);

// Add an element to a node (a thin wrapper of the previous function)
void XMLAddElementToNode
	(	IXMLDOMDocument	*pContextDoc,
		IXMLDOMNode		*pParentNode,
		const LPCWSTR	pwszTagName,	// @parm	[in]	the tag of the new element
		IXMLDOMElement	**ppElement,
		IXMLDOMNode		**ppNode = NULL
	);

// Add an element to a node with a text node
// [in]		pContextDoc		- the XML context for creating the new element
// [in]		pParentNode		- the parent node
// [in]		bstrTagName		- the tag of the new node
// [in]		bstrText		- the text of the text node
// [out]	ppElement		- the pointer to the pointer to the created element
// [out]	ppNode			- (Optional) the pointer to the pointer to the XML
//							  node interface to the created element
void XMLAddElementToNode
	(	IXMLDOMDocument	*pContextDoc,
		IXMLDOMNode		*pParentNode,
		const BSTR		bstrTagName,
		const BSTR		bstrText,	// @parm	[in]	the text of the text node
		IXMLDOMElement	**ppElement,
		IXMLDOMNode		**ppNode = NULL
	);

// Add an element to a node with a text node
// (a thin wrapper of the previous function)
void XMLAddElementToNode
	(	IXMLDOMDocument	*pContextDoc,
		IXMLDOMNode		*pParentNode,
		const LPCWSTR	pwszTagName,
		const LPCWSTR	pwszText,	// @parm	[in]	the text of the text node
		IXMLDOMElement	**ppElement,
		IXMLDOMNode		**ppNode = NULL
	);

// Add an element to a node with an attribute
// [in]		pContextDoc		- the XML context for creating the new element
// [in]		pParentNode		- the parent node
// [in]		bstrTagName		- the tag of the new element
// [in]		bstrAttrName	- the name of the attribute of the new element
// [in]		varAttrValue	- the value of the attribute of the new element
// [out]	ppElement		- the pointer to the pointer to the created element
// [out]	ppNode			- (Optional) the pointer to the pointer to the XML
//							  node interface to the created element
void XMLAddElementToNode
	(	IXMLDOMDocument		*pContextDoc,
		IXMLDOMNode			*pParentNode,
		const BSTR			bstrTagName,
		const BSTR			bstrAttrName,	// @parm	[in]	the name of the attribute of the new element
		const CComVariant	&varAttrValue,	// @parm	[in]	the value of the attribute of the new element
		IXMLDOMElement		**ppElement,
		IXMLDOMNode			**ppNode = NULL
	);

// Add an element to a node with an attribute
// (a thin wrapper of the previous function)
void XMLAddElementToNode
	(	IXMLDOMDocument	*pContextDoc,
		IXMLDOMNode		*pParentNode,
		const LPCWSTR	pwszTagName,
		const LPCWSTR	pwszAttrName,	// @parm	[in]	the name of the attribute of the new element
		const LPCWSTR	pwszAttrValue,	// @parm	[in]	the value of the attribute of the new element
		IXMLDOMElement	**ppElement,
		IXMLDOMNode		**ppNode = NULL
	);

// @func	HRESULT | ParseXML | Parse an XML document
// @syntax	HRESULT ParseXML(const BSTR bstrXML, IXMLDOMDocument **ppXMLDoc);
// @syntax	HRESULT ParseXML(const LPCSTR pwszXML, IXMLDOMDocument **ppXMLDoc);
// @syntax	HRESULT ParseXML(const LPCSTR pszXML, IXMLDOMDocument **ppXMLDoc);
// @rdesc	Return the following values:
// @flag	S_OK		| successful
// @flag	Otherwise	| parse error
HRESULT ParseXML
	(	const BSTR		bstrXML,	// @parm	[in]	the XML content
		IXMLDOMDocument	**ppXMLDoc	// @parm	[out]	the XML document object
	);

// Parse an XML document
// (a thin wrapper of the previous function)
HRESULT ParseXML
	(	const LPCWSTR	pwszXML,	// @parm	[in]	the XML content
		IXMLDOMDocument	**ppXMLDoc
	);

// Parse an XML document
// (a thin wrapper of the previous function)
HRESULT ParseXML
	(	const LPCSTR	pszXML,		// @parm	[in]	the XML content
		IXMLDOMDocument	**ppXMLDoc
	);

// @func	void | XMLToString | Output an XML document to a string object
// @syntax	void XMLToString(IXMLDOMNode *pXMLRootNode, CStringW &cwszDoc);
// @syntax	void XMLToString(IXMLDOMNode *pXMLRootNode, CStringA &cszDoc);
// @rdesc	None
void XMLToString
	(	IXMLDOMNode *pXMLRootNode,	// @parm	[in]	the root node of the XML document to be output
		CStringW &cwszDoc			// @parm	[out]	the string object holding the XML document
	);

// Output an XML document to a string object
// (a thin wrapper of the previous function)
void XMLToString
	(	IXMLDOMNode *pXMLRootNode,
		CStringA &cszDoc			// @parm	[out]	the string object holding the XML document
	);

// @func	HRESULT | XMLLoadNodeText | Load the text of a node
// @syntax	HRESULT XMLLoadNodeText(IXMLDOMDocument *pXMLDoc, const LPCWSTR &pwszNodeName, CComBSTR &bstrNodeText);
// @syntax	HRESULT XMLLoadNodeText(IXMLDOMDocument *pXMLDoc, const LPCWSTR &pwszNodeName, CStringW &cwszNodeText);
// @syntax	HRESULT XMLLoadNodeText(IXMLDOMDocument *pXMLDoc, const LPCSTR &pszNodeName, CComBSTR &bstrNodeText);
// @syntax	HRESULT XMLLoadNodeText(IXMLDOMDocument *pXMLDoc, const LPCSTR &pszNodeName, CStringW &cwszNodeText);
// @rdesc	Return the following values:
// @flag	S_OK					| successful
// @flag	PP_E_XML_NO_SUCH_NODE	| the specified node is not found
// @flag	PP_E_XML_NO_TEXT		| the specified node has no text
HRESULT XMLLoadNodeText
		(	IXMLDOMDocument	*pXMLDoc,		// @parm	[in]	the XML document
			const LPCWSTR	&pwszNodeName,	// @parm	[in]	the name of the node
			CComBSTR		&bstrNodeText	// @parm	[out]	the text of the node (if S_OK)
		);

// Load the text of a node (a thin wrapper of the previous function)
HRESULT XMLLoadNodeText
		(	IXMLDOMDocument	*pXMLDoc,
			const LPCWSTR	&pwszNodeName,
			CStringW		&cwszNodeText	// @parm	[out]	the text of the node (if S_OK)
		);

// Load the text of a node (a thin wrapper of the previous function)
HRESULT XMLLoadNodeText
		(	IXMLDOMDocument	*pXMLDoc,
			const LPCSTR	&pszNodeName,	// @parm	[in]	the name of the node
			CComBSTR		&bstrNodeText
		);

// Load the text of a node (a thin wrapper of the previous function)
HRESULT XMLLoadNodeText
		(	IXMLDOMDocument	*pXMLDoc,
			const LPCSTR	&pszNodeName,
			CStringW		&cwszNodeText
		);

// @func	HRESULT | XMLLoadAttribute | Load the attribute
// @syntax	HRESULT XMLLoadAttribute(IXMLDOMDocument *pXMLDoc, const LPCWSTR &pwszNodeName, const LPCWSTR &pwszAttrName, CComBSTR &bstrAttrValue);
// @rdesc	Return the following values:
// @flag	S_OK						| successful
// @flag	PP_E_XML_NO_SUCH_NODE		| the specified node is not found
// @flag	PP_E_XML_NO_SUCH_ATTRIBUTE	| the specified attribute not found
HRESULT XMLLoadAttribute
	(	IXMLDOMDocument *pXMLDoc,			// @parm	[in]	the XML document
		const LPCWSTR	&pwszNodeName,		// @parm	[in]	the name of the node
		const LPCWSTR	&pwszAttrName,		// @parm	[in]	the name of the attribute 
		CComBSTR		&bstrAttrValue		// @parm	[out]	the value of the attribute (if S_OK)
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\xmlstrs.h ===
#ifndef __XMLSTRS_H
#define __XMLSTRS_H

//
//  Partner.xml strings.
//

#define XML_STR_SECURESIGNOUTGIF    "SecureSignoutGIF"
#define XML_STR_SECURESIGNINGIF     "SecureSigninGIF"
#define XML_STR_SIGNOUTGIF          "SignoutGIF"
#define XML_STR_SIGNINGIF           "SigninGIF"

//
//  Networksserver.xml strings.
//

#define XML_STR_ROOTURL             "RootURL"
#define XML_STR_DEFAULTRETURNURL    "DefaultReturnURL"

#endif // __XMLSTRS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\xmlresponse.h ===
/* @doc
 *
 * @module XMLResponse.h |
 *
 * Header file for XMLResponse.cpp
 *
 * Author: Ying-ping Chen (t-ypchen)
 */
#pragma once

// @class	CXMLResponse | XML response class for the XML client interface
class CXMLResponse {
// @access	Public Members
public:

	enum eResponseType {
		RESPONSE_UNDEFINED = 0,
		RESPONSE_SUCCESS,
		RESPONSE_FAIL,
		RESPONSE_TOTAL_NUM
	};

	// @cmember	Constructor
	CXMLResponse
		(	LPCWSTR pwszNewTag,
			eResponseType rtNewType = RESPONSE_UNDEFINED
		);

	// @cmember	Destructor
	~CXMLResponse();

	// @cmember	Get the response tag
	LPCWSTR GetResponseTag(void);
	// @cmember Set the response tag
	void SetResponseTag(LPCWSTR pwszNewTag);

	// @cmember Get the response type
	CXMLResponse::eResponseType GetType(void);
	// @cmember Set the response type
	void SetType(eResponseType rtNewType);

	// @cmember Convert the internal XML document to a string object
	void ToString(CStringW &cwszDoc);
	// @cmember Convert the internal XML document to a string object
	void ToString(CStringA &cszDoc);

	// @cmember	Add an element to a specific node
	void AddElement
		(	const LPCWSTR	pwszTag,
			IXMLDOMNode		*pParentNode = NULL,
			IXMLDOMElement	**ppChildElement = NULL,
			IXMLDOMNode		**ppChildNode = NULL
		);
	// @cmember	Add an element to a specific node with a text node
	void AddElement
		(	const LPCWSTR	pwszTag,
			const LPCWSTR	pwszText,
			IXMLDOMNode		*pParentNode = NULL,
			IXMLDOMElement	**ppChildElement = NULL,
			IXMLDOMNode		**ppChildNode = NULL
		);
	// @cmember	Add an element to a specific node with an attribute
	void AddElement
		(	const LPCWSTR	pwszTag,
			const LPCWSTR	pwszAttrName,
			const LPCWSTR	pwszAttrValue,
			IXMLDOMNode		*pParentNode = NULL,
			IXMLDOMElement	**ppChildElement = NULL,
			IXMLDOMNode		**ppChildNode = NULL
		);

	// @cmember	Add an error code to the response object
	void AddErrorCode
		(	const LPCWSTR	pwszErrorCode,
			IXMLDOMElement	**ppChildElement = NULL,
			IXMLDOMNode		**ppChildNode = NULL
		);

// @access	Protected Members
protected:
	// @cmember	The XML document
	CComPtr<IXMLDOMDocument>	m_pXMLDoc;
	// @cmember The root node (interface)
	CComQIPtr<IXMLDOMNode>		m_pXMLNode_Root;
	// @cmember	The first-level node (interface)
	CComQIPtr<IXMLDOMNode>		m_pXMLNode_L1;
	// @cmember The first-level element (interface)
	CComPtr<IXMLDOMElement>		m_pXMLElement_L1;

	// @cmember	The root tag of this response object
	CStringW					m_cwszResponseTag;
	// @cmember	The type of this response object
	eResponseType				m_rtType;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\nt\des.h ===
#ifndef __DES_H__
#define __DES_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _destable {
    unsigned long   keytab[16][2];
} DESTable;

#define DES_TABLESIZE   (sizeof(DESTable))
#define DES_BLOCKLEN    (8)
#define DES_KEYSIZE     (8)

typedef struct _desxtable {
    unsigned char inWhitening[8];
    unsigned char outWhitening[8];
    DESTable desTable;
} DESXTable;

#define DESX_TABLESIZE  (sizeof(DESXTable))
#define DESX_BLOCKLEN   (8)
#define DESX_KEYSIZE    (24)

/* In deskey.c:

     Fill in the DESTable struct with the decrypt and encrypt
     key expansions.

     Assumes that the second parameter points to DES_BLOCKLEN
     bytes of key.

*/

void RSA32API deskey(DESTable *,unsigned char *);

/* In desport.c:

     Encrypt or decrypt with the key in DESTable

*/

void RSA32API des(BYTE *pbOut, BYTE *pbIn, void *key, int op);

//
// set the parity on the DES key to be odd
// NOTE : must be called before deskey
// key must be cbKey number of bytes
//
void RSA32API desparityonkey(BYTE *pbKey, DWORD cbKey);

//
// reduce the DES key to a 40 bit key
// NOTE : must be called before deskey
// key must be 8 bytes
//
void RSA32API desreducekey(BYTE *key);

// Expand 40 bit DES key to 64 and check weakness
// same as desreducekey except expands instead of weakening keys
void RSA32API deskeyexpand(BYTE *pbKey, BYTE *pbExpanded_key);


void
RSA32API
desexpand128to192(
    BYTE *pbKey,        // input 128bit or 192bit buffer
    BYTE *pbExpandedKey // output buffer (must be 192bit wide if pbKey == pbExpandedKey
    );

// DES-X routines

// initialize desX key struct.  key size is 24 bytes
void RSA32API desxkey(DESXTable *k, BYTE *key);

void RSA32API desx(BYTE *pbOut, BYTE *pbIn, void *keyin, int op);


extern int Asmversion;  /* 1 if we're linked with an asm version, 0 if C */

#ifdef __cplusplus
}
#endif

#endif // __DES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\xmltlh.h ===
// Created by Microsoft (R) C/C++ Compiler Version 13.00.9076.3 (8cb5a81c).
//
// e:\nt\ds\security\passport\common\schema\obj\ia64\msxml.tlh
//
// C++ source equivalent of Win32 type library msxml.dll
// compiler-generated file created 04/17/01 at 14:47:29 - DO NOT EDIT!

#pragma once
#pragma pack(push, 8)

#include <comdef.h>

namespace MSXML {

//
// Forward references and typedefs
//

struct __declspec(uuid("d63e0ce2-a0a2-11d0-9c02-00c04fc99c8e"))
/* LIBID */ __MSXML;
struct __declspec(uuid("65725580-9b5d-11d0-9bfe-00c04fc99c8e"))
/* dual interface */ IXMLElementCollection;
struct __declspec(uuid("f52e2b61-18a1-11d1-b105-00805f49916b"))
/* dual interface */ IXMLDocument;
struct __declspec(uuid("3f7f31ac-e15f-11d0-9c25-00c04fc99c8e"))
/* dual interface */ IXMLElement;
struct __declspec(uuid("2b8de2fe-8d2d-11d1-b2fc-00c04fd915a9"))
/* interface */ IXMLDocument2;
struct __declspec(uuid("2b8de2ff-8d2d-11d1-b2fc-00c04fd915a9"))
/* dual interface */ IXMLElement2;
struct __declspec(uuid("d4d4a0fc-3b73-11d1-b2b4-00c04fb92596"))
/* dual interface */ IXMLAttribute;
struct __declspec(uuid("948c5ad3-c58d-11d0-9c0b-00c04fc99c8e"))
/* interface */ IXMLError;
struct _xml_error;
struct __declspec(uuid("3efaa410-272f-11d2-836f-0000f87a7782"))
/* dual interface */ IDOMImplementation;
struct __declspec(uuid("3efaa411-272f-11d2-836f-0000f87a7782"))
/* dual interface */ IDOMNode;
typedef enum tagDOMNodeType DOMNodeType;
enum tagDOMNodeType;
struct __declspec(uuid("3efaa416-272f-11d2-836f-0000f87a7782"))
/* dual interface */ IDOMNodeList;
struct __declspec(uuid("3efaa418-272f-11d2-836f-0000f87a7782"))
/* dual interface */ IDOMNamedNodeMap;
struct __declspec(uuid("3efaa414-272f-11d2-836f-0000f87a7782"))
/* dual interface */ IDOMDocument;
struct __declspec(uuid("3efaa421-272f-11d2-836f-0000f87a7782"))
/* dual interface */ IDOMDocumentType;
struct __declspec(uuid("3efaa41c-272f-11d2-836f-0000f87a7782"))
/* dual interface */ IDOMElement;
struct __declspec(uuid("3efaa41b-272f-11d2-836f-0000f87a7782"))
/* dual interface */ IDOMAttribute;
struct __declspec(uuid("3efaa413-272f-11d2-836f-0000f87a7782"))
/* dual interface */ IDOMDocumentFragment;
struct __declspec(uuid("9cafc72d-272e-11d2-836f-0000f87a7782"))
/* dual interface */ IDOMText;
struct __declspec(uuid("3efaa41a-272f-11d2-836f-0000f87a7782"))
/* dual interface */ IDOMCharacterData;
struct __declspec(uuid("3efaa41e-272f-11d2-836f-0000f87a7782"))
/* dual interface */ IDOMComment;
struct __declspec(uuid("3efaa420-272f-11d2-836f-0000f87a7782"))
/* dual interface */ IDOMCDATASection;
struct __declspec(uuid("3efaa41f-272f-11d2-836f-0000f87a7782"))
/* dual interface */ IDOMProcessingInstruction;
struct __declspec(uuid("3efaa424-272f-11d2-836f-0000f87a7782"))
/* dual interface */ IDOMEntityReference;
struct __declspec(uuid("3efaa422-272f-11d2-836f-0000f87a7782"))
/* dual interface */ IDOMNotation;
struct __declspec(uuid("3efaa423-272f-11d2-836f-0000f87a7782"))
/* dual interface */ IDOMEntity;
struct __declspec(uuid("3efaa412-272f-11d2-836f-0000f87a7782"))
/* dual interface */ IXMLDOMNode;
struct __declspec(uuid("3efaa417-272f-11d2-836f-0000f87a7782"))
/* dual interface */ IXMLDOMNodeList;
struct __declspec(uuid("3efaa415-272f-11d2-836f-0000f87a7782"))
/* dual interface */ IXMLDOMDocument;
struct __declspec(uuid("3efaa426-272f-11d2-836f-0000f87a7782"))
/* dual interface */ IDOMParseError;
struct __declspec(uuid("3efaa419-272f-11d2-836f-0000f87a7782"))
/* dual interface */ IXMLDOMNamedNodeMap;
struct __declspec(uuid("3efaa425-272f-11d2-836f-0000f87a7782"))
/* dual interface */ IXTLRuntime;
struct __declspec(uuid("3efaa427-272f-11d2-836f-0000f87a7782"))
/* dispinterface */ XMLDOMDocumentEvents;
struct /* coclass */ DOMDocument;
struct __declspec(uuid("ed8c108d-4349-11d2-91a4-00c04f7969e8"))
/* dual interface */ IXMLHttpRequest;
struct /* coclass */ XMLHTTPRequest;
struct __declspec(uuid("310afa62-0575-11d2-9ca9-0060b0ec3d39"))
/* dual interface */ IXMLDSOControl;
struct /* coclass */ XMLDSOControl;
typedef enum tagXMLEMEM_TYPE XMLELEM_TYPE;
enum tagXMLEMEM_TYPE;
struct /* coclass */ XMLDocument;

//
// Smart pointer typedef declarations
//

_COM_SMARTPTR_TYPEDEF(IXMLElementCollection, __uuidof(IXMLElementCollection));
_COM_SMARTPTR_TYPEDEF(IXMLDocument, __uuidof(IXMLDocument));
_COM_SMARTPTR_TYPEDEF(IXMLElement, __uuidof(IXMLElement));
_COM_SMARTPTR_TYPEDEF(IXMLDocument2, __uuidof(IXMLDocument2));
_COM_SMARTPTR_TYPEDEF(IXMLElement2, __uuidof(IXMLElement2));
_COM_SMARTPTR_TYPEDEF(IXMLAttribute, __uuidof(IXMLAttribute));
_COM_SMARTPTR_TYPEDEF(IXMLError, __uuidof(IXMLError));
_COM_SMARTPTR_TYPEDEF(IDOMImplementation, __uuidof(IDOMImplementation));
_COM_SMARTPTR_TYPEDEF(IDOMNode, __uuidof(IDOMNode));
_COM_SMARTPTR_TYPEDEF(IDOMNodeList, __uuidof(IDOMNodeList));
_COM_SMARTPTR_TYPEDEF(IDOMNamedNodeMap, __uuidof(IDOMNamedNodeMap));
_COM_SMARTPTR_TYPEDEF(IDOMDocument, __uuidof(IDOMDocument));
_COM_SMARTPTR_TYPEDEF(IDOMDocumentType, __uuidof(IDOMDocumentType));
_COM_SMARTPTR_TYPEDEF(IDOMElement, __uuidof(IDOMElement));
_COM_SMARTPTR_TYPEDEF(IDOMAttribute, __uuidof(IDOMAttribute));
_COM_SMARTPTR_TYPEDEF(IDOMDocumentFragment, __uuidof(IDOMDocumentFragment));
_COM_SMARTPTR_TYPEDEF(IDOMCharacterData, __uuidof(IDOMCharacterData));
_COM_SMARTPTR_TYPEDEF(IDOMText, __uuidof(IDOMText));
_COM_SMARTPTR_TYPEDEF(IDOMComment, __uuidof(IDOMComment));
_COM_SMARTPTR_TYPEDEF(IDOMCDATASection, __uuidof(IDOMCDATASection));
_COM_SMARTPTR_TYPEDEF(IDOMProcessingInstruction, __uuidof(IDOMProcessingInstruction));
_COM_SMARTPTR_TYPEDEF(IDOMEntityReference, __uuidof(IDOMEntityReference));
_COM_SMARTPTR_TYPEDEF(IDOMNotation, __uuidof(IDOMNotation));
_COM_SMARTPTR_TYPEDEF(IDOMEntity, __uuidof(IDOMEntity));
_COM_SMARTPTR_TYPEDEF(IXMLDOMNode, __uuidof(IXMLDOMNode));
_COM_SMARTPTR_TYPEDEF(IXMLDOMNodeList, __uuidof(IXMLDOMNodeList));
_COM_SMARTPTR_TYPEDEF(IXMLDOMDocument, __uuidof(IXMLDOMDocument));
_COM_SMARTPTR_TYPEDEF(IDOMParseError, __uuidof(IDOMParseError));
_COM_SMARTPTR_TYPEDEF(IXMLDOMNamedNodeMap, __uuidof(IXMLDOMNamedNodeMap));
_COM_SMARTPTR_TYPEDEF(IXTLRuntime, __uuidof(IXTLRuntime));
_COM_SMARTPTR_TYPEDEF(XMLDOMDocumentEvents, __uuidof(XMLDOMDocumentEvents));
_COM_SMARTPTR_TYPEDEF(IXMLHttpRequest, __uuidof(IXMLHttpRequest));
_COM_SMARTPTR_TYPEDEF(IXMLDSOControl, __uuidof(IXMLDSOControl));

//
// Type library items
//

struct __declspec(uuid("65725580-9b5d-11d0-9bfe-00c04fc99c8e"))
IXMLElementCollection : IDispatch
{
    //
    // Property data
    //

    __declspec(property(get=Getlength,put=Putlength))
    long length;
    __declspec(property(get=Get_newEnum))
    IUnknownPtr _newEnum;

    //
    // Wrapper methods for error-handling
    //

    void Putlength (
        long p );
    long Getlength ( );
    IUnknownPtr Get_newEnum ( );
    IDispatchPtr item (
        const _variant_t & var1 = vtMissing,
        const _variant_t & var2 = vtMissing );

    //
    // Raw methods provided by interface
    //

      virtual HRESULT __stdcall put_length (
        /*[in]*/ long p ) = 0;
      virtual HRESULT __stdcall get_length (
        /*[out,retval]*/ long * p ) = 0;
      virtual HRESULT __stdcall get__newEnum (
        /*[out,retval]*/ IUnknown * * ppUnk ) = 0;
      virtual HRESULT __stdcall raw_item (
        /*[in]*/ VARIANT var1,
        /*[in]*/ VARIANT var2,
        /*[out,retval]*/ IDispatch * * ppDisp ) = 0;
};

struct __declspec(uuid("f52e2b61-18a1-11d1-b105-00805f49916b"))
IXMLDocument : IDispatch
{
    //
    // Property data
    //

    __declspec(property(get=Getroot))
    IXMLElementPtr root;
    __declspec(property(get=GetfileSize))
    _bstr_t fileSize;
    __declspec(property(get=GetfileModifiedDate))
    _bstr_t fileModifiedDate;
    __declspec(property(get=GetfileUpdatedDate))
    _bstr_t fileUpdatedDate;
    __declspec(property(get=GetURL,put=PutURL))
    _bstr_t URL;
    __declspec(property(get=GetmimeType))
    _bstr_t mimeType;
    __declspec(property(get=GetreadyState))
    long readyState;
    __declspec(property(get=Getcharset,put=Putcharset))
    _bstr_t charset;
    __declspec(property(get=Getversion))
    _bstr_t version;
    __declspec(property(get=Getdoctype))
    _bstr_t doctype;
    __declspec(property(get=GetdtdURL))
    _bstr_t dtdURL;

    //
    // Wrapper methods for error-handling
    //

    IXMLElementPtr Getroot ( );
    _bstr_t GetfileSize ( );
    _bstr_t GetfileModifiedDate ( );
    _bstr_t GetfileUpdatedDate ( );
    _bstr_t GetURL ( );
    void PutURL (
        _bstr_t p );
    _bstr_t GetmimeType ( );
    long GetreadyState ( );
    _bstr_t Getcharset ( );
    void Putcharset (
        _bstr_t p );
    _bstr_t Getversion ( );
    _bstr_t Getdoctype ( );
    _bstr_t GetdtdURL ( );
    IXMLElementPtr createElement (
        const _variant_t & vType,
        const _variant_t & var1 = vtMissing );

    //
    // Raw methods provided by interface
    //

      virtual HRESULT __stdcall get_root (
        /*[out,retval]*/ struct IXMLElement * * p ) = 0;
      virtual HRESULT __stdcall get_fileSize (
        /*[out,retval]*/ BSTR * p ) = 0;
      virtual HRESULT __stdcall get_fileModifiedDate (
        /*[out,retval]*/ BSTR * p ) = 0;
      virtual HRESULT __stdcall get_fileUpdatedDate (
        /*[out,retval]*/ BSTR * p ) = 0;
      virtual HRESULT __stdcall get_URL (
        /*[out,retval]*/ BSTR * p ) = 0;
      virtual HRESULT __stdcall put_URL (
        /*[in]*/ BSTR p ) = 0;
      virtual HRESULT __stdcall get_mimeType (
        /*[out,retval]*/ BSTR * p ) = 0;
      virtual HRESULT __stdcall get_readyState (
        /*[out,retval]*/ long * pl ) = 0;
      virtual HRESULT __stdcall get_charset (
        /*[out,retval]*/ BSTR * p ) = 0;
      virtual HRESULT __stdcall put_charset (
        /*[in]*/ BSTR p ) = 0;
      virtual HRESULT __stdcall get_version (
        /*[out,retval]*/ BSTR * p ) = 0;
      virtual HRESULT __stdcall get_doctype (
        /*[out,retval]*/ BSTR * p ) = 0;
      virtual HRESULT __stdcall get_dtdURL (
        /*[out,retval]*/ BSTR * p ) = 0;
      virtual HRESULT __stdcall raw_createElement (
        /*[in]*/ VARIANT vType,
        /*[in]*/ VARIANT var1,
        /*[out,retval]*/ struct IXMLElement * * ppElem ) = 0;
};

struct __declspec(uuid("3f7f31ac-e15f-11d0-9c25-00c04fc99c8e"))
IXMLElement : IDispatch
{
    //
    // Property data
    //

    __declspec(property(get=GettagName,put=PuttagName))
    _bstr_t tagName;
    __declspec(property(get=Getparent))
    IXMLElementPtr parent;
    __declspec(property(get=Getchildren))
    IXMLElementCollectionPtr children;
    __declspec(property(get=Gettype))
    long type;
    __declspec(property(get=Gettext,put=Puttext))
    _bstr_t text;

    //
    // Wrapper methods for error-handling
    //

    _bstr_t GettagName ( );
    void PuttagName (
        _bstr_t p );
    IXMLElementPtr Getparent ( );
    HRESULT setAttribute (
        _bstr_t strPropertyName,
        const _variant_t & PropertyValue );
    _variant_t getAttribute (
        _bstr_t strPropertyName );
    HRESULT removeAttribute (
        _bstr_t strPropertyName );
    IXMLElementCollectionPtr Getchildren ( );
    long Gettype ( );
    _bstr_t Gettext ( );
    void Puttext (
        _bstr_t p );
    HRESULT addChild (
        struct IXMLElement * pChildElem,
        long lIndex,
        long lReserved );
    HRESULT removeChild (
        struct IXMLElement * pChildElem );

    //
    // Raw methods provided by interface
    //

      virtual HRESULT __stdcall get_tagName (
        /*[out,retval]*/ BSTR * p ) = 0;
      virtual HRESULT __stdcall put_tagName (
        /*[in]*/ BSTR p ) = 0;
      virtual HRESULT __stdcall get_parent (
        /*[out,retval]*/ struct IXMLElement * * ppParent ) = 0;
      virtual HRESULT __stdcall raw_setAttribute (
        /*[in]*/ BSTR strPropertyName,
        /*[in]*/ VARIANT PropertyValue ) = 0;
      virtual HRESULT __stdcall raw_getAttribute (
        /*[in]*/ BSTR strPropertyName,
        /*[out,retval]*/ VARIANT * PropertyValue ) = 0;
      virtual HRESULT __stdcall raw_removeAttribute (
        /*[in]*/ BSTR strPropertyName ) = 0;
      virtual HRESULT __stdcall get_children (
        /*[out,retval]*/ struct IXMLElementCollection * * pp ) = 0;
      virtual HRESULT __stdcall get_type (
        /*[out,retval]*/ long * plType ) = 0;
      virtual HRESULT __stdcall get_text (
        /*[out,retval]*/ BSTR * p ) = 0;
      virtual HRESULT __stdcall put_text (
        /*[in]*/ BSTR p ) = 0;
      virtual HRESULT __stdcall raw_addChild (
        /*[in]*/ struct IXMLElement * pChildElem,
        long lIndex,
        long lReserved ) = 0;
      virtual HRESULT __stdcall raw_removeChild (
        /*[in]*/ struct IXMLElement * pChildElem ) = 0;
};

struct __declspec(uuid("2b8de2fe-8d2d-11d1-b2fc-00c04fd915a9"))
IXMLDocument2 : IDispatch
{
    //
    // Property data
    //

    __declspec(property(get=Getroot))
    IXMLElement2Ptr root;
    __declspec(property(get=GetfileSize))
    _bstr_t fileSize;
    __declspec(property(get=GetfileModifiedDate))
    _bstr_t fileModifiedDate;
    __declspec(property(get=GetfileUpdatedDate))
    _bstr_t fileUpdatedDate;
    __declspec(property(get=GetURL,put=PutURL))
    _bstr_t URL;
    __declspec(property(get=GetmimeType))
    _bstr_t mimeType;
    __declspec(property(get=GetreadyState))
    long readyState;
    __declspec(property(get=Getcharset,put=Putcharset))
    _bstr_t charset;
    __declspec(property(get=Getversion))
    _bstr_t version;
    __declspec(property(get=Getdoctype))
    _bstr_t doctype;
    __declspec(property(get=GetdtdURL))
    _bstr_t dtdURL;
    __declspec(property(get=Getasync,put=Putasync))
    VARIANT_BOOL async;

    //
    // Wrapper methods for error-handling
    //

    IXMLElement2Ptr Getroot ( );
    _bstr_t GetfileSize ( );
    _bstr_t GetfileModifiedDate ( );
    _bstr_t GetfileUpdatedDate ( );
    _bstr_t GetURL ( );
    void PutURL (
        _bstr_t p );
    _bstr_t GetmimeType ( );
    long GetreadyState ( );
    _bstr_t Getcharset ( );
    void Putcharset (
        _bstr_t p );
    _bstr_t Getversion ( );
    _bstr_t Getdoctype ( );
    _bstr_t GetdtdURL ( );
    IXMLElement2Ptr createElement (
        const _variant_t & vType,
        const _variant_t & var1 = vtMissing );
    VARIANT_BOOL Getasync ( );
    void Putasync (
        VARIANT_BOOL pf );

    //
    // Raw methods provided by interface
    //

      virtual HRESULT __stdcall get_root (
        /*[out,retval]*/ struct IXMLElement2 * * p ) = 0;
      virtual HRESULT __stdcall get_fileSize (
        /*[out,retval]*/ BSTR * p ) = 0;
      virtual HRESULT __stdcall get_fileModifiedDate (
        /*[out,retval]*/ BSTR * p ) = 0;
      virtual HRESULT __stdcall get_fileUpdatedDate (
        /*[out,retval]*/ BSTR * p ) = 0;
      virtual HRESULT __stdcall get_URL (
        /*[out,retval]*/ BSTR * p ) = 0;
      virtual HRESULT __stdcall put_URL (
        /*[in]*/ BSTR p ) = 0;
      virtual HRESULT __stdcall get_mimeType (
        /*[out,retval]*/ BSTR * p ) = 0;
      virtual HRESULT __stdcall get_readyState (
        /*[out,retval]*/ long * pl ) = 0;
      virtual HRESULT __stdcall get_charset (
        /*[out,retval]*/ BSTR * p ) = 0;
      virtual HRESULT __stdcall put_charset (
        /*[in]*/ BSTR p ) = 0;
      virtual HRESULT __stdcall get_version (
        /*[out,retval]*/ BSTR * p ) = 0;
      virtual HRESULT __stdcall get_doctype (
        /*[out,retval]*/ BSTR * p ) = 0;
      virtual HRESULT __stdcall get_dtdURL (
        /*[out,retval]*/ BSTR * p ) = 0;
      virtual HRESULT __stdcall raw_createElement (
        /*[in]*/ VARIANT vType,
        /*[in]*/ VARIANT var1,
        /*[out,retval]*/ struct IXMLElement2 * * ppElem ) = 0;
      virtual HRESULT __stdcall get_async (
        /*[out,retval]*/ VARIANT_BOOL * pf ) = 0;
      virtual HRESULT __stdcall put_async (
        /*[in]*/ VARIANT_BOOL pf ) = 0;
};

struct __declspec(uuid("2b8de2ff-8d2d-11d1-b2fc-00c04fd915a9"))
IXMLElement2 : IDispatch
{
    //
    // Property data
    //

    __declspec(property(get=GettagName,put=PuttagName))
    _bstr_t tagName;
    __declspec(property(get=Getparent))
    IXMLElement2Ptr parent;
    __declspec(property(get=Getchildren))
    IXMLElementCollectionPtr children;
    __declspec(property(get=Gettype))
    long type;
    __declspec(property(get=Gettext,put=Puttext))
    _bstr_t text;
    __declspec(property(get=Getattributes))
    IXMLElementCollectionPtr attributes;

    //
    // Wrapper methods for error-handling
    //

    _bstr_t GettagName ( );
    void PuttagName (
        _bstr_t p );
    IXMLElement2Ptr Getparent ( );
    HRESULT setAttribute (
        _bstr_t strPropertyName,
        const _variant_t & PropertyValue );
    _variant_t getAttribute (
        _bstr_t strPropertyName );
    HRESULT removeAttribute (
        _bstr_t strPropertyName );
    IXMLElementCollectionPtr Getchildren ( );
    long Gettype ( );
    _bstr_t Gettext ( );
    void Puttext (
        _bstr_t p );
    HRESULT addChild (
        struct IXMLElement2 * pChildElem,
        long lIndex,
        long lReserved );
    HRESULT removeChild (
        struct IXMLElement2 * pChildElem );
    IXMLElementCollectionPtr Getattributes ( );

    //
    // Raw methods provided by interface
    //

      virtual HRESULT __stdcall get_tagName (
        /*[out,retval]*/ BSTR * p ) = 0;
      virtual HRESULT __stdcall put_tagName (
        /*[in]*/ BSTR p ) = 0;
      virtual HRESULT __stdcall get_parent (
        /*[out,retval]*/ struct IXMLElement2 * * ppParent ) = 0;
      virtual HRESULT __stdcall raw_setAttribute (
        /*[in]*/ BSTR strPropertyName,
        /*[in]*/ VARIANT PropertyValue ) = 0;
      virtual HRESULT __stdcall raw_getAttribute (
        /*[in]*/ BSTR strPropertyName,
        /*[out,retval]*/ VARIANT * PropertyValue ) = 0;
      virtual HRESULT __stdcall raw_removeAttribute (
        /*[in]*/ BSTR strPropertyName ) = 0;
      virtual HRESULT __stdcall get_children (
        /*[out,retval]*/ struct IXMLElementCollection * * pp ) = 0;
      virtual HRESULT __stdcall get_type (
        /*[out,retval]*/ long * plType ) = 0;
      virtual HRESULT __stdcall get_text (
        /*[out,retval]*/ BSTR * p ) = 0;
      virtual HRESULT __stdcall put_text (
        /*[in]*/ BSTR p ) = 0;
      virtual HRESULT __stdcall raw_addChild (
        /*[in]*/ struct IXMLElement2 * pChildElem,
        long lIndex,
        long lReserved ) = 0;
      virtual HRESULT __stdcall raw_removeChild (
        /*[in]*/ struct IXMLElement2 * pChildElem ) = 0;
      virtual HRESULT __stdcall get_attributes (
        /*[out,retval]*/ struct IXMLElementCollection * * pp ) = 0;
};

struct __declspec(uuid("d4d4a0fc-3b73-11d1-b2b4-00c04fb92596"))
IXMLAttribute : IDispatch
{
    //
    // Property data
    //

    __declspec(property(get=Getname))
    _bstr_t name;
    __declspec(property(get=Getvalue))
    _bstr_t value;

    //
    // Wrapper methods for error-handling
    //

    _bstr_t Getname ( );
    _bstr_t Getvalue ( );

    //
    // Raw methods provided by interface
    //

      virtual HRESULT __stdcall get_name (
        /*[out,retval]*/ BSTR * n ) = 0;
      virtual HRESULT __stdcall get_value (
        /*[out,retval]*/ BSTR * v ) = 0;
};

struct __declspec(uuid("948c5ad3-c58d-11d0-9c0b-00c04fc99c8e"))
IXMLError : IUnknown
{
    //
    // Wrapper methods for error-handling
    //

    HRESULT GetErrorInfo (
        struct _xml_error * pErrorReturn );

    //
    // Raw methods provided by interface
    //

      virtual HRESULT __stdcall raw_GetErrorInfo (
        struct _xml_error * pErrorReturn ) = 0;
};

struct _xml_error
{
    unsigned int _nLine;
    BSTR _pchBuf;
    unsigned int _cchBuf;
    unsigned int _ich;
    BSTR _pszFound;
    BSTR _pszExpected;
    unsigned long _reserved1;
    unsigned long _reserved2;
};

struct __declspec(uuid("3efaa410-272f-11d2-836f-0000f87a7782"))
IDOMImplementation : IDispatch
{
    //
    // Wrapper methods for error-handling
    //

    VARIANT_BOOL hasFeature (
        _bstr_t feature,
        _bstr_t version );

    //
    // Raw methods provided by interface
    //

      virtual HRESULT __stdcall raw_hasFeature (
        /*[in]*/ BSTR feature,
        /*[in]*/ BSTR version,
        /*[out,retval]*/ VARIANT_BOOL * hasFeature ) = 0;
};

struct __declspec(uuid("3efaa411-272f-11d2-836f-0000f87a7782"))
IDOMNode : IDispatch
{
    //
    // Property data
    //

    __declspec(property(get=GetnodeName))
    _bstr_t nodeName;
    __declspec(property(get=GetnodeValue,put=PutnodeValue))
    _variant_t nodeValue;
    __declspec(property(get=GetnodeType))
    DOMNodeType nodeType;
    __declspec(property(get=GetparentNode))
    IDOMNodePtr parentNode;
    __declspec(property(get=GetchildNodes))
    IDOMNodeListPtr childNodes;
    __declspec(property(get=GetfirstChild))
    IDOMNodePtr firstChild;
    __declspec(property(get=GetlastChild))
    IDOMNodePtr lastChild;
    __declspec(property(get=GetpreviousSibling))
    IDOMNodePtr previousSibling;
    __declspec(property(get=GetnextSibling))
    IDOMNodePtr nextSibling;
    __declspec(property(get=Getattributes))
    IDOMNamedNodeMapPtr attributes;
    __declspec(property(get=GetownerDocument))
    IDOMDocumentPtr ownerDocument;

    //
    // Wrapper methods for error-handling
    //

    _bstr_t GetnodeName ( );
    _variant_t GetnodeValue ( );
    void PutnodeValue (
        const _variant_t & value );
    DOMNodeType GetnodeType ( );
    IDOMNodePtr GetparentNode ( );
    IDOMNodeListPtr GetchildNodes ( );
    IDOMNodePtr GetfirstChild ( );
    IDOMNodePtr GetlastChild ( );
    IDOMNodePtr GetpreviousSibling ( );
    IDOMNodePtr GetnextSibling ( );
    IDOMNamedNodeMapPtr Getattributes ( );
    IDOMNodePtr insertBefore (
        struct IDOMNode * newChild,
        const _variant_t & refChild );
    IDOMNodePtr replaceChild (
        struct IDOMNode * newChild,
        struct IDOMNode * oldChild );
    IDOMNodePtr removeChild (
        struct IDOMNode * childNode );
    IDOMNodePtr appendChild (
        struct IDOMNode * newChild );
    VARIANT_BOOL hasChildNodes ( );
    IDOMDocumentPtr GetownerDocument ( );
    IDOMNodePtr cloneNode (
        VARIANT_BOOL deep );

    //
    // Raw methods provided by interface
    //

      virtual HRESULT __stdcall get_nodeName (
        /*[out,retval]*/ BSTR * name ) = 0;
      virtual HRESULT __stdcall get_nodeValue (
        /*[out,retval]*/ VARIANT * value ) = 0;
      virtual HRESULT __stdcall put_nodeValue (
        /*[in]*/ VARIANT value ) = 0;
      virtual HRESULT __stdcall get_nodeType (
        /*[out,retval]*/ DOMNodeType * type ) = 0;
      virtual HRESULT __stdcall get_parentNode (
        /*[out,retval]*/ struct IDOMNode * * parent ) = 0;
      virtual HRESULT __stdcall get_childNodes (
        /*[out,retval]*/ struct IDOMNodeList * * childList ) = 0;
      virtual HRESULT __stdcall get_firstChild (
        /*[out,retval]*/ struct IDOMNode * * firstChild ) = 0;
      virtual HRESULT __stdcall get_lastChild (
        /*[out,retval]*/ struct IDOMNode * * lastChild ) = 0;
      virtual HRESULT __stdcall get_previousSibling (
        /*[out,retval]*/ struct IDOMNode * * previousSibling ) = 0;
      virtual HRESULT __stdcall get_nextSibling (
        /*[out,retval]*/ struct IDOMNode * * nextSibling ) = 0;
      virtual HRESULT __stdcall get_attributes (
        /*[out,retval]*/ struct IDOMNamedNodeMap * * atrributeMap ) = 0;
      virtual HRESULT __stdcall raw_insertBefore (
        /*[in]*/ struct IDOMNode * newChild,
        /*[in]*/ VARIANT refChild,
        /*[out,retval]*/ struct IDOMNode * * outNewChild ) = 0;
      virtual HRESULT __stdcall raw_replaceChild (
        /*[in]*/ struct IDOMNode * newChild,
        /*[in]*/ struct IDOMNode * oldChild,
        /*[out,retval]*/ struct IDOMNode * * outOldChild ) = 0;
      virtual HRESULT __stdcall raw_removeChild (
        /*[in]*/ struct IDOMNode * childNode,
        /*[out,retval]*/ struct IDOMNode * * oldChild ) = 0;
      virtual HRESULT __stdcall raw_appendChild (
        /*[in]*/ struct IDOMNode * newChild,
        /*[out,retval]*/ struct IDOMNode * * outNewChild ) = 0;
      virtual HRESULT __stdcall raw_hasChildNodes (
        /*[out,retval]*/ VARIANT_BOOL * hasChild ) = 0;
      virtual HRESULT __stdcall get_ownerDocument (
        /*[out,retval]*/ struct IDOMDocument * * DOMDocument ) = 0;
      virtual HRESULT __stdcall raw_cloneNode (
        /*[in]*/ VARIANT_BOOL deep,
        /*[out,retval]*/ struct IDOMNode * * cloneRoot ) = 0;
};

enum tagDOMNodeType
{
    NODE_INVALID = 0,
    NODE_ELEMENT = 1,
    NODE_ATTRIBUTE = 2,
    NODE_TEXT = 3,
    NODE_CDATA_SECTION = 4,
    NODE_ENTITY_REFERENCE = 5,
    NODE_ENTITY = 6,
    NODE_PROCESSING_INSTRUCTION = 7,
    NODE_COMMENT = 8,
    NODE_DOCUMENT = 9,
    NODE_DOCUMENT_TYPE = 10,
    NODE_DOCUMENT_FRAGMENT = 11,
    NODE_NOTATION = 12
};

struct __declspec(uuid("3efaa416-272f-11d2-836f-0000f87a7782"))
IDOMNodeList : IDispatch
{
    //
    // Property data
    //

    __declspec(property(get=Getitem))
    IDOMNodePtr item[];
    __declspec(property(get=Getlength))
    long length;

    //
    // Wrapper methods for error-handling
    //

    IDOMNodePtr Getitem (
        long index );
    long Getlength ( );

    //
    // Raw methods provided by interface
    //

      virtual HRESULT __stdcall get_item (
        /*[in]*/ long index,
        /*[out,retval]*/ struct IDOMNode * * listItem ) = 0;
      virtual HRESULT __stdcall get_length (
        /*[out,retval]*/ long * listLength ) = 0;
};

struct __declspec(uuid("3efaa418-272f-11d2-836f-0000f87a7782"))
IDOMNamedNodeMap : IDispatch
{
    //
    // Property data
    //

    __declspec(property(get=Getitem))
    IDOMNodePtr item[];
    __declspec(property(get=Getlength))
    long length;

    //
    // Wrapper methods for error-handling
    //

    IDOMNodePtr getNamedItem (
        _bstr_t name );
    IDOMNodePtr setNamedItem (
        struct IDOMNode * newItem );
    IDOMNodePtr removeNamedItem (
        _bstr_t name );
    IDOMNodePtr Getitem (
        long index );
    long Getlength ( );

    //
    // Raw methods provided by interface
    //

      virtual HRESULT __stdcall raw_getNamedItem (
        /*[in]*/ BSTR name,
        /*[out,retval]*/ struct IDOMNode * * namedItem ) = 0;
      virtual HRESULT __stdcall raw_setNamedItem (
        /*[in]*/ struct IDOMNode * newItem,
        /*[out,retval]*/ struct IDOMNode * * nameItem ) = 0;
      virtual HRESULT __stdcall raw_removeNamedItem (
        /*[in]*/ BSTR name,
        /*[out,retval]*/ struct IDOMNode * * namedItem ) = 0;
      virtual HRESULT __stdcall get_item (
        /*[in]*/ long index,
        /*[out,retval]*/ struct IDOMNode * * listItem ) = 0;
      virtual HRESULT __stdcall get_length (
        /*[out,retval]*/ long * listLength ) = 0;
};

struct __declspec(uuid("3efaa414-272f-11d2-836f-0000f87a7782"))
IDOMDocument : IDOMNode
{
    //
    // Property data
    //

    __declspec(property(get=Getdoctype))
    IDOMDocumentTypePtr doctype;
    __declspec(property(get=Getimplementation))
    IDOMImplementationPtr implementation;
    __declspec(property(get=GetdocumentElement,put=PutRefdocumentElement))
    IDOMElementPtr documentElement;

    //
    // Wrapper methods for error-handling
    //

    IDOMDocumentTypePtr Getdoctype ( );
    IDOMImplementationPtr Getimplementation ( );
    IDOMElementPtr GetdocumentElement ( );
    void PutRefdocumentElement (
        struct IDOMElement * DOMElement );
    IDOMElementPtr createElement (
        _bstr_t tagName );
    IDOMDocumentFragmentPtr createDocumentFragment ( );
    IDOMTextPtr createTextNode (
        _bstr_t data );
    IDOMCommentPtr createComment (
        _bstr_t data );
    IDOMCDATASectionPtr createCDATASection (
        _bstr_t data );
    IDOMProcessingInstructionPtr createProcessingInstruction (
        _bstr_t target,
        _bstr_t data );
    IDOMAttributePtr createAttribute (
        _bstr_t name );
    IDOMEntityReferencePtr createEntityReference (
        _bstr_t name );
    IDOMNodeListPtr getElementsByTagName (
        _bstr_t tagName );

    //
    // Raw methods provided by interface
    //

      virtual HRESULT __stdcall get_doctype (
        /*[out,retval]*/ struct IDOMDocumentType * * documentType ) = 0;
      virtual HRESULT __stdcall get_implementation (
        /*[out,retval]*/ struct IDOMImplementation * * impl ) = 0;
      virtual HRESULT __stdcall get_documentElement (
        /*[out,retval]*/ struct IDOMElement * * DOMElement ) = 0;
      virtual HRESULT __stdcall putref_documentElement (
        /*[in]*/ struct IDOMElement * DOMElement ) = 0;
      virtual HRESULT __stdcall raw_createElement (
        /*[in]*/ BSTR tagName,
        /*[out,retval]*/ struct IDOMElement * * element ) = 0;
      virtual HRESULT __stdcall raw_createDocumentFragment (
        /*[out,retval]*/ struct IDOMDocumentFragment * * docFrag ) = 0;
      virtual HRESULT __stdcall raw_createTextNode (
        /*[in]*/ BSTR data,
        /*[out,retval]*/ struct IDOMText * * text ) = 0;
      virtual HRESULT __stdcall raw_createComment (
        /*[in]*/ BSTR data,
        /*[out,retval]*/ struct IDOMComment * * comment ) = 0;
      virtual HRESULT __stdcall raw_createCDATASection (
        /*[in]*/ BSTR data,
        /*[out,retval]*/ struct IDOMCDATASection * * cdata ) = 0;
      virtual HRESULT __stdcall raw_createProcessingInstruction (
        /*[in]*/ BSTR target,
        /*[in]*/ BSTR data,
        /*[out,retval]*/ struct IDOMProcessingInstruction * * pi ) = 0;
      virtual HRESULT __stdcall raw_createAttribute (
        /*[in]*/ BSTR name,
        /*[out,retval]*/ struct IDOMAttribute * * attribute ) = 0;
      virtual HRESULT __stdcall raw_createEntityReference (
        /*[in]*/ BSTR name,
        /*[out,retval]*/ struct IDOMEntityReference * * entityRef ) = 0;
      virtual HRESULT __stdcall raw_getElementsByTagName (
        /*[in]*/ BSTR tagName,
        /*[out,retval]*/ struct IDOMNodeList * * resultList ) = 0;
};

struct __declspec(uuid("3efaa421-272f-11d2-836f-0000f87a7782"))
IDOMDocumentType : IDOMNode
{
    //
    // Property data
    //

    __declspec(property(get=Getname))
    _bstr_t name;
    __declspec(property(get=Getentities))
    IDOMNamedNodeMapPtr entities;
    __declspec(property(get=Getnotations))
    IDOMNamedNodeMapPtr notations;

    //
    // Wrapper methods for error-handling
    //

    _bstr_t Getname ( );
    IDOMNamedNodeMapPtr Getentities ( );
    IDOMNamedNodeMapPtr Getnotations ( );

    //
    // Raw methods provided by interface
    //

      virtual HRESULT __stdcall get_name (
        /*[out,retval]*/ BSTR * rootName ) = 0;
      virtual HRESULT __stdcall get_entities (
        /*[out,retval]*/ struct IDOMNamedNodeMap * * entityMap ) = 0;
      virtual HRESULT __stdcall get_notations (
        /*[out,retval]*/ struct IDOMNamedNodeMap * * notationMap ) = 0;
};

struct __declspec(uuid("3efaa41c-272f-11d2-836f-0000f87a7782"))
IDOMElement : IDOMNode
{
    //
    // Property data
    //

    __declspec(property(get=GettagName))
    _bstr_t tagName;

    //
    // Wrapper methods for error-handling
    //

    _bstr_t GettagName ( );
    _variant_t getAttribute (
        _bstr_t name );
    HRESULT setAttribute (
        _bstr_t name,
        const _variant_t & value );
    HRESULT removeAttribute (
        _bstr_t name );
    IDOMAttributePtr getAttributeNode (
        _bstr_t name );
    IDOMAttributePtr setAttributeNode (
        struct IDOMAttribute * DOMAttribute );
    IDOMAttributePtr removeAttributeNode (
        struct IDOMAttribute * DOMAttribute );
    IDOMNodeListPtr getElementsByTagName (
        _bstr_t tagName );
    HRESULT normalize ( );

    //
    // Raw methods provided by interface
    //

      virtual HRESULT __stdcall get_tagName (
        /*[out,retval]*/ BSTR * tagName ) = 0;
      virtual HRESULT __stdcall raw_getAttribute (
        /*[in]*/ BSTR name,
        /*[out,retval]*/ VARIANT * value ) = 0;
      virtual HRESULT __stdcall raw_setAttribute (
        /*[in]*/ BSTR name,
        /*[in]*/ VARIANT value ) = 0;
      virtual HRESULT __stdcall raw_removeAttribute (
        /*[in]*/ BSTR name ) = 0;
      virtual HRESULT __stdcall raw_getAttributeNode (
        /*[in]*/ BSTR name,
        /*[out,retval]*/ struct IDOMAttribute * * attributeNode ) = 0;
      virtual HRESULT __stdcall raw_setAttributeNode (
        /*[in]*/ struct IDOMAttribute * DOMAttribute,
        /*[out,retval]*/ struct IDOMAttribute * * attributeNode ) = 0;
      virtual HRESULT __stdcall raw_removeAttributeNode (
        /*[in]*/ struct IDOMAttribute * DOMAttribute,
        /*[out,retval]*/ struct IDOMAttribute * * attributeNode ) = 0;
      virtual HRESULT __stdcall raw_getElementsByTagName (
        /*[in]*/ BSTR tagName,
        /*[out,retval]*/ struct IDOMNodeList * * resultList ) = 0;
      virtual HRESULT __stdcall raw_normalize ( ) = 0;
};

struct __declspec(uuid("3efaa41b-272f-11d2-836f-0000f87a7782"))
IDOMAttribute : IDOMNode
{
    //
    // Property data
    //

    __declspec(property(get=Getvalue,put=Putvalue))
    _variant_t value;
    __declspec(property(get=Getname))
    _bstr_t name;
    __declspec(property(get=Getspecified))
    VARIANT_BOOL specified;

    //
    // Wrapper methods for error-handling
    //

    _bstr_t Getname ( );
    VARIANT_BOOL Getspecified ( );
    _variant_t Getvalue ( );
    void Putvalue (
        const _variant_t & attributeValue );

    //
    // Raw methods provided by interface
    //

      virtual HRESULT __stdcall get_name (
        /*[out,retval]*/ BSTR * attributeName ) = 0;
      virtual HRESULT __stdcall get_specified (
        /*[out,retval]*/ VARIANT_BOOL * isSpecified ) = 0;
      virtual HRESULT __stdcall get_value (
        /*[out,retval]*/ VARIANT * attributeValue ) = 0;
      virtual HRESULT __stdcall put_value (
        /*[in]*/ VARIANT attributeValue ) = 0;
};

struct __declspec(uuid("3efaa413-272f-11d2-836f-0000f87a7782"))
IDOMDocumentFragment : IDOMNode
{};

struct __declspec(uuid("3efaa41a-272f-11d2-836f-0000f87a7782"))
IDOMCharacterData : IDOMNode
{
    //
    // Property data
    //

    __declspec(property(get=Getdata,put=Putdata))
    _bstr_t data;
    __declspec(property(get=Getlength))
    long length;

    //
    // Wrapper methods for error-handling
    //

    _bstr_t Getdata ( );
    void Putdata (
        _bstr_t data );
    long Getlength ( );
    _bstr_t substringData (
        long offset,
        long count );
    HRESULT appendData (
        _bstr_t data );
    HRESULT insertData (
        long offset,
        _bstr_t data );
    HRESULT deleteData (
        long offset,
        long count );
    HRESULT replaceData (
        long offset,
        long count,
        _bstr_t data );

    //
    // Raw methods provided by interface
    //

      virtual HRESULT __stdcall get_data (
        /*[out,retval]*/ BSTR * data ) = 0;
      virtual HRESULT __stdcall put_data (
        /*[in]*/ BSTR data ) = 0;
      virtual HRESULT __stdcall get_length (
        /*[out,retval]*/ long * dataLength ) = 0;
      virtual HRESULT __stdcall raw_substringData (
        /*[in]*/ long offset,
        /*[in]*/ long count,
        /*[out,retval]*/ BSTR * data ) = 0;
      virtual HRESULT __stdcall raw_appendData (
        /*[in]*/ BSTR data ) = 0;
      virtual HRESULT __stdcall raw_insertData (
        /*[in]*/ long offset,
        /*[in]*/ BSTR data ) = 0;
      virtual HRESULT __stdcall raw_deleteData (
        /*[in]*/ long offset,
        /*[in]*/ long count ) = 0;
      virtual HRESULT __stdcall raw_replaceData (
        /*[in]*/ long offset,
        /*[in]*/ long count,
        /*[in]*/ BSTR data ) = 0;
};

struct __declspec(uuid("9cafc72d-272e-11d2-836f-0000f87a7782"))
IDOMText : IDOMCharacterData
{
    //
    // Wrapper methods for error-handling
    //

    IDOMTextPtr splitText (
        long offset );

    //
    // Raw methods provided by interface
    //

      virtual HRESULT __stdcall raw_splitText (
        /*[in]*/ long offset,
        /*[out,retval]*/ struct IDOMText * * rightHandTextNode ) = 0;
};

struct __declspec(uuid("3efaa41e-272f-11d2-836f-0000f87a7782"))
IDOMComment : IDOMCharacterData
{};

struct __declspec(uuid("3efaa420-272f-11d2-836f-0000f87a7782"))
IDOMCDATASection : IDOMText
{};

struct __declspec(uuid("3efaa41f-272f-11d2-836f-0000f87a7782"))
IDOMProcessingInstruction : IDOMNode
{
    //
    // Property data
    //

    __declspec(property(get=Getdata,put=Putdata))
    _bstr_t data;
    __declspec(property(get=Gettarget))
    _bstr_t target;

    //
    // Wrapper methods for error-handling
    //

    _bstr_t Gettarget ( );
    _bstr_t Getdata ( );
    void Putdata (
        _bstr_t value );

    //
    // Raw methods provided by interface
    //

      virtual HRESULT __stdcall get_target (
        /*[out,retval]*/ BSTR * name ) = 0;
      virtual HRESULT __stdcall get_data (
        /*[out,retval]*/ BSTR * value ) = 0;
      virtual HRESULT __stdcall put_data (
        /*[in]*/ BSTR value ) = 0;
};

struct __declspec(uuid("3efaa424-272f-11d2-836f-0000f87a7782"))
IDOMEntityReference : IDOMNode
{};

struct __declspec(uuid("3efaa422-272f-11d2-836f-0000f87a7782"))
IDOMNotation : IDOMNode
{
    //
    // Property data
    //

    __declspec(property(get=GetpublicId))
    _variant_t publicId;
    __declspec(property(get=GetsystemId))
    _variant_t systemId;

    //
    // Wrapper methods for error-handling
    //

    _variant_t GetpublicId ( );
    _variant_t GetsystemId ( );

    //
    // Raw methods provided by interface
    //

      virtual HRESULT __stdcall get_publicId (
        /*[out,retval]*/ VARIANT * publicId ) = 0;
      virtual HRESULT __stdcall get_systemId (
        /*[out,retval]*/ VARIANT * systemId ) = 0;
};

struct __declspec(uuid("3efaa423-272f-11d2-836f-0000f87a7782"))
IDOMEntity : IDOMNode
{
    //
    // Property data
    //

    __declspec(property(get=GetpublicId))
    _variant_t publicId;
    __declspec(property(get=GetsystemId))
    _variant_t systemId;
    __declspec(property(get=GetnotationName))
    _bstr_t notationName;

    //
    // Wrapper methods for error-handling
    //

    _variant_t GetpublicId ( );
    _variant_t GetsystemId ( );
    _bstr_t GetnotationName ( );

    //
    // Raw methods provided by interface
    //

      virtual HRESULT __stdcall get_publicId (
        /*[out,retval]*/ VARIANT * publicId ) = 0;
      virtual HRESULT __stdcall get_systemId (
        /*[out,retval]*/ VARIANT * systemId ) = 0;
      virtual HRESULT __stdcall get_notationName (
        /*[out,retval]*/ BSTR * name ) = 0;
};

struct __declspec(uuid("3efaa412-272f-11d2-836f-0000f87a7782"))
IXMLDOMNode : IDOMNode
{
    //
    // Property data
    //

    __declspec(property(get=Gettext,put=Puttext))
    _bstr_t text;
    __declspec(property(get=GetnodeStringType))
    _bstr_t nodeStringType;
    __declspec(property(get=Getspecified))
    VARIANT_BOOL specified;
    __declspec(property(get=Getdefinition))
    IXMLDOMNodePtr definition;
    __declspec(property(get=GetnodeTypedValue,put=PutnodeTypedValue))
    _variant_t nodeTypedValue;
    __declspec(property(get=Getxml))
    _bstr_t xml;
    __declspec(property(get=Getparsed))
    VARIANT_BOOL parsed;
    __declspec(property(get=GetnameSpace))
    _bstr_t nameSpace;
    __declspec(property(get=Getprefix))
    _bstr_t prefix;
    __declspec(property(get=GetbaseName))
    _bstr_t baseName;

    //
    // Wrapper methods for error-handling
    //

    _bstr_t GetnodeStringType ( );
    _bstr_t Gettext ( );
    void Puttext (
        _bstr_t text );
    VARIANT_BOOL Getspecified ( );
    IXMLDOMNodePtr Getdefinition ( );
    _variant_t GetnodeTypedValue ( );
    void PutnodeTypedValue (
        const _variant_t & typedValue );
    _variant_t GetdataType ( );
    void PutdataType (
        _bstr_t dataTypeName );
    _bstr_t Getxml ( );
    _bstr_t transformNode (
        struct IXMLDOMNode * stylesheet );
    IXMLDOMNodeListPtr selectNodes (
        _bstr_t queryString );
    IXMLDOMNodePtr selectSingleNode (
        _bstr_t queryString );
    VARIANT_BOOL Getparsed ( );
    _bstr_t GetnameSpace ( );
    _bstr_t Getprefix ( );
    _bstr_t GetbaseName ( );

    //
    // Raw methods provided by interface
    //

      virtual HRESULT __stdcall get_nodeStringType (
        /*[out,retval]*/ BSTR * nodeType ) = 0;
      virtual HRESULT __stdcall get_text (
        /*[out,retval]*/ BSTR * text ) = 0;
      virtual HRESULT __stdcall put_text (
        /*[in]*/ BSTR text ) = 0;
      virtual HRESULT __stdcall get_specified (
        /*[out,retval]*/ VARIANT_BOOL * isSpecified ) = 0;
      virtual HRESULT __stdcall get_definition (
        /*[out,retval]*/ struct IXMLDOMNode * * definitionNode ) = 0;
      virtual HRESULT __stdcall get_nodeTypedValue (
        /*[out,retval]*/ VARIANT * typedValue ) = 0;
      virtual HRESULT __stdcall put_nodeTypedValue (
        /*[in]*/ VARIANT typedValue ) = 0;
      virtual HRESULT __stdcall get_dataType (
        /*[out,retval]*/ VARIANT * dataTypeName ) = 0;
      virtual HRESULT __stdcall put_dataType (
        /*[in]*/ BSTR dataTypeName ) = 0;
      virtual HRESULT __stdcall get_xml (
        /*[out,retval]*/ BSTR * xmlString ) = 0;
      virtual HRESULT __stdcall raw_transformNode (
        /*[in]*/ struct IXMLDOMNode * stylesheet,
        /*[out,retval]*/ BSTR * xmlString ) = 0;
      virtual HRESULT __stdcall raw_selectNodes (
        /*[in]*/ BSTR queryString,
        /*[out,retval]*/ struct IXMLDOMNodeList * * resultList ) = 0;
      virtual HRESULT __stdcall raw_selectSingleNode (
        /*[in]*/ BSTR queryString,
        /*[out,retval]*/ struct IXMLDOMNode * * resultNode ) = 0;
      virtual HRESULT __stdcall get_parsed (
        /*[out,retval]*/ VARIANT_BOOL * isParsed ) = 0;
      virtual HRESULT __stdcall get_nameSpace (
        /*[out,retval]*/ BSTR * namespaceURI ) = 0;
      virtual HRESULT __stdcall get_prefix (
        /*[out,retval]*/ BSTR * prefixString ) = 0;
      virtual HRESULT __stdcall get_baseName (
        /*[out,retval]*/ BSTR * nameString ) = 0;
};

struct __declspec(uuid("3efaa417-272f-11d2-836f-0000f87a7782"))
IXMLDOMNodeList : IDOMNodeList
{
    //
    // Property data
    //

    __declspec(property(get=Get_newEnum))
    IUnknownPtr _newEnum;

    //
    // Wrapper methods for error-handling
    //

    IXMLDOMNodePtr nextNode ( );
    HRESULT reset ( );
    IUnknownPtr Get_newEnum ( );

    //
    // Raw methods provided by interface
    //

      virtual HRESULT __stdcall raw_nextNode (
        /*[out,retval]*/ struct IXMLDOMNode * * nextItem ) = 0;
      virtual HRESULT __stdcall raw_reset ( ) = 0;
      virtual HRESULT __stdcall get__newEnum (
        /*[out,retval]*/ IUnknown * * ppUnk ) = 0;
};

struct __declspec(uuid("3efaa415-272f-11d2-836f-0000f87a7782"))
IXMLDOMDocument : IDOMDocument
{
    //
    // Property data
    //

    __declspec(property(get=GetparseError))
    IDOMParseErrorPtr parseError;
    __declspec(property(get=GetURL))
    _bstr_t URL;
    __declspec(property(get=Getasync,put=Putasync))
    VARIANT_BOOL async;
    __declspec(property(get=GetvalidateOnParse,put=PutvalidateOnParse))
    VARIANT_BOOL validateOnParse;
    __declspec(property(put=Putonreadystatechange))
    _variant_t onreadystatechange;
    __declspec(property(put=Putondataavailable))
    _variant_t ondataavailable;
    __declspec(property(get=Getxml))
    _bstr_t xml;
    __declspec(property(get=GetreadyState))
    long readyState;
    __declspec(property(get=Getparsed))
    VARIANT_BOOL parsed;

    //
    // Wrapper methods for error-handling
    //

    IXMLDOMNodePtr createNode (
        const _variant_t & type,
        _bstr_t name,
        _bstr_t namespaceURI );
    IXMLDOMNodePtr nodeFromID (
        _bstr_t idString );
    VARIANT_BOOL load (
        _bstr_t URL );
    long GetreadyState ( );
    IDOMParseErrorPtr GetparseError ( );
    _bstr_t GetURL ( );
    VARIANT_BOOL Getasync ( );
    void Putasync (
        VARIANT_BOOL isAsync );
    HRESULT abort ( );
    VARIANT_BOOL loadXML (
        _bstr_t xmlString );
    VARIANT_BOOL GetvalidateOnParse ( );
    void PutvalidateOnParse (
        VARIANT_BOOL isValidating );
    void Putonreadystatechange (
        const _variant_t & _arg1 );
    void Putondataavailable (
        const _variant_t & _arg1 );
    _bstr_t Getxml ( );
    _bstr_t transformNode (
        struct IXMLDOMNode * stylesheet );
    IXMLDOMNodeListPtr selectNodes (
        _bstr_t queryString );
    IXMLDOMNodePtr selectSingleNode (
        _bstr_t queryString );
    VARIANT_BOOL Getparsed ( );

    //
    // Raw methods provided by interface
    //

      virtual HRESULT __stdcall raw_createNode (
        /*[in]*/ VARIANT type,
        /*[in]*/ BSTR name,
        /*[in]*/ BSTR namespaceURI,
        /*[out,retval]*/ struct IXMLDOMNode * * node ) = 0;
      virtual HRESULT __stdcall raw_nodeFromID (
        /*[in]*/ BSTR idString,
        /*[out,retval]*/ struct IXMLDOMNode * * node ) = 0;
      virtual HRESULT __stdcall raw_load (
        /*[in]*/ BSTR URL,
        /*[out,retval]*/ VARIANT_BOOL * isSuccessful ) = 0;
      virtual HRESULT __stdcall get_readyState (
        /*[out,retval]*/ long * value ) = 0;
      virtual HRESULT __stdcall get_parseError (
        /*[out,retval]*/ struct IDOMParseError * * errorObj ) = 0;
      virtual HRESULT __stdcall get_URL (
        /*[out,retval]*/ BSTR * urlString ) = 0;
      virtual HRESULT __stdcall get_async (
        /*[out,retval]*/ VARIANT_BOOL * isAsync ) = 0;
      virtual HRESULT __stdcall put_async (
        /*[in]*/ VARIANT_BOOL isAsync ) = 0;
      virtual HRESULT __stdcall raw_abort ( ) = 0;
      virtual HRESULT __stdcall raw_loadXML (
        /*[in]*/ BSTR xmlString,
        /*[out,retval]*/ VARIANT_BOOL * isSuccessful ) = 0;
      virtual HRESULT __stdcall get_validateOnParse (
        /*[out,retval]*/ VARIANT_BOOL * isValidating ) = 0;
      virtual HRESULT __stdcall put_validateOnParse (
        /*[in]*/ VARIANT_BOOL isValidating ) = 0;
      virtual HRESULT __stdcall put_onreadystatechange (
        /*[in]*/ VARIANT _arg1 ) = 0;
      virtual HRESULT __stdcall put_ondataavailable (
        /*[in]*/ VARIANT _arg1 ) = 0;
      virtual HRESULT __stdcall get_xml (
        /*[out,retval]*/ BSTR * xmlString ) = 0;
      virtual HRESULT __stdcall raw_transformNode (
        /*[in]*/ struct IXMLDOMNode * stylesheet,
        /*[out,retval]*/ BSTR * transformedXML ) = 0;
      virtual HRESULT __stdcall raw_selectNodes (
        /*[in]*/ BSTR queryString,
        /*[out,retval]*/ struct IXMLDOMNodeList * * resultList ) = 0;
      virtual HRESULT __stdcall raw_selectSingleNode (
        /*[in]*/ BSTR queryString,
        /*[out,retval]*/ struct IXMLDOMNode * * resultNode ) = 0;
      virtual HRESULT __stdcall get_parsed (
        /*[out,retval]*/ VARIANT_BOOL * isParsed ) = 0;
};

struct __declspec(uuid("3efaa426-272f-11d2-836f-0000f87a7782"))
IDOMParseError : IDispatch
{
    //
    // Property data
    //

    __declspec(property(get=GeterrorCode))
    long errorCode;
    __declspec(property(get=GetURL))
    _bstr_t URL;
    __declspec(property(get=Getreason))
    _bstr_t reason;
    __declspec(property(get=GetsrcText))
    _bstr_t srcText;
    __declspec(property(get=Getline))
    long line;
    __declspec(property(get=Getlinepos))
    long linepos;
    __declspec(property(get=Getfilepos))
    long filepos;

    //
    // Wrapper methods for error-handling
    //

    long GeterrorCode ( );
    _bstr_t GetURL ( );
    _bstr_t Getreason ( );
    _bstr_t GetsrcText ( );
    long Getline ( );
    long Getlinepos ( );
    long Getfilepos ( );

    //
    // Raw methods provided by interface
    //

      virtual HRESULT __stdcall get_errorCode (
        /*[out,retval]*/ long * errorCode ) = 0;
      virtual HRESULT __stdcall get_URL (
        /*[out,retval]*/ BSTR * urlString ) = 0;
      virtual HRESULT __stdcall get_reason (
        /*[out,retval]*/ BSTR * reasonString ) = 0;
      virtual HRESULT __stdcall get_srcText (
        /*[out,retval]*/ BSTR * sourceString ) = 0;
      virtual HRESULT __stdcall get_line (
        /*[out,retval]*/ long * lineNumber ) = 0;
      virtual HRESULT __stdcall get_linepos (
        /*[out,retval]*/ long * linePosition ) = 0;
      virtual HRESULT __stdcall get_filepos (
        /*[out,retval]*/ long * filePosition ) = 0;
};

struct __declspec(uuid("3efaa419-272f-11d2-836f-0000f87a7782"))
IXMLDOMNamedNodeMap : IDOMNamedNodeMap
{
    //
    // Property data
    //

    __declspec(property(get=Get_newEnum))
    IUnknownPtr _newEnum;

    //
    // Wrapper methods for error-handling
    //

    IXMLDOMNodePtr getQualifiedItem (
        _bstr_t baseName,
        _bstr_t namespaceURI );
    IXMLDOMNodePtr removeQualifiedItem (
        _bstr_t baseName,
        _bstr_t namespaceURI );
    IXMLDOMNodePtr nextNode ( );
    HRESULT reset ( );
    IUnknownPtr Get_newEnum ( );

    //
    // Raw methods provided by interface
    //

      virtual HRESULT __stdcall raw_getQualifiedItem (
        /*[in]*/ BSTR baseName,
        /*[in]*/ BSTR namespaceURI,
        /*[out,retval]*/ struct IXMLDOMNode * * qualifiedItem ) = 0;
      virtual HRESULT __stdcall raw_removeQualifiedItem (
        /*[in]*/ BSTR baseName,
        /*[in]*/ BSTR namespaceURI,
        /*[out,retval]*/ struct IXMLDOMNode * * qualifiedItem ) = 0;
      virtual HRESULT __stdcall raw_nextNode (
        /*[out,retval]*/ struct IXMLDOMNode * * nextItem ) = 0;
      virtual HRESULT __stdcall raw_reset ( ) = 0;
      virtual HRESULT __stdcall get__newEnum (
        /*[out,retval]*/ IUnknown * * ppUnk ) = 0;
};

struct __declspec(uuid("3efaa425-272f-11d2-836f-0000f87a7782"))
IXTLRuntime : IXMLDOMNode
{
    //
    // Wrapper methods for error-handling
    //

    long uniqueID (
        struct IDOMNode * pNode );
    long depth (
        struct IDOMNode * pNode );
    long childNumber (
        struct IDOMNode * pNode );
    long ancestorChildNumber (
        _bstr_t bstrNodeName,
        struct IDOMNode * pNode );
    long absoluteChildNumber (
        struct IDOMNode * pNode );
    _bstr_t formatIndex (
        long lIndex,
        _bstr_t bstrFormat );
    _bstr_t formatNumber (
        double dblNumber,
        _bstr_t bstrFormat );
    _bstr_t formatDate (
        const _variant_t & varDate,
        _bstr_t bstrFormat,
        const _variant_t & varDestLocale = vtMissing );
    _bstr_t formatTime (
        const _variant_t & varTime,
        _bstr_t bstrFormat,
        const _variant_t & varDestLocale = vtMissing );

    //
    // Raw methods provided by interface
    //

      virtual HRESULT __stdcall raw_uniqueID (
        /*[in]*/ struct IDOMNode * pNode,
        /*[out,retval]*/ long * pID ) = 0;
      virtual HRESULT __stdcall raw_depth (
        /*[in]*/ struct IDOMNode * pNode,
        /*[out,retval]*/ long * pDepth ) = 0;
      virtual HRESULT __stdcall raw_childNumber (
        /*[in]*/ struct IDOMNode * pNode,
        /*[out,retval]*/ long * pNumber ) = 0;
      virtual HRESULT __stdcall raw_ancestorChildNumber (
        /*[in]*/ BSTR bstrNodeName,
        /*[in]*/ struct IDOMNode * pNode,
        /*[out,retval]*/ long * pNumber ) = 0;
      virtual HRESULT __stdcall raw_absoluteChildNumber (
        /*[in]*/ struct IDOMNode * pNode,
        /*[out,retval]*/ long * pNumber ) = 0;
      virtual HRESULT __stdcall raw_formatIndex (
        /*[in]*/ long lIndex,
        /*[in]*/ BSTR bstrFormat,
        /*[out,retval]*/ BSTR * pbstrFormattedString ) = 0;
      virtual HRESULT __stdcall raw_formatNumber (
        /*[in]*/ double dblNumber,
        /*[in]*/ BSTR bstrFormat,
        /*[out,retval]*/ BSTR * pbstrFormattedString ) = 0;
      virtual HRESULT __stdcall raw_formatDate (
        /*[in]*/ VARIANT varDate,
        /*[in]*/ BSTR bstrFormat,
        /*[in]*/ VARIANT varDestLocale,
        /*[out,retval]*/ BSTR * pbstrFormattedString ) = 0;
      virtual HRESULT __stdcall raw_formatTime (
        /*[in]*/ VARIANT varTime,
        /*[in]*/ BSTR bstrFormat,
        /*[in]*/ VARIANT varDestLocale,
        /*[out,retval]*/ BSTR * pbstrFormattedString ) = 0;
};

struct __declspec(uuid("3efaa427-272f-11d2-836f-0000f87a7782"))
XMLDOMDocumentEvents : IDispatch
{
    //
    // Wrapper methods for error-handling
    //

    // Methods:
    HRESULT ondataavailable ( );
    HRESULT onreadystatechange ( );
};

struct __declspec(uuid("3efaa428-272f-11d2-836f-0000f87a7782"))
DOMDocument;
    // [ default ] interface IXMLDOMDocument
    // [ default, source ] dispinterface XMLDOMDocumentEvents

struct __declspec(uuid("ed8c108d-4349-11d2-91a4-00c04f7969e8"))
IXMLHttpRequest : IDispatch
{
    //
    // Property data
    //

    __declspec(property(get=GetRequestBody,put=PutRequestBody))
    _variant_t RequestBody;
    __declspec(property(get=GetStatus))
    long Status;
    __declspec(property(get=GetStatusText))
    _bstr_t StatusText;
    __declspec(property(get=GetResponseXML))
    IDispatchPtr ResponseXML;
    __declspec(property(get=GetResponseBody))
    _variant_t ResponseBody;

    //
    // Wrapper methods for error-handling
    //

    HRESULT Open (
        _bstr_t bstrMethod,
        _bstr_t bstrUrl,
        const _variant_t & bstrUser = vtMissing,
        const _variant_t & bstrPassword = vtMissing );
    HRESULT SetHeader (
        _bstr_t bstrHeader,
        _bstr_t bstrValue );
    _bstr_t GetHeader (
        _bstr_t bstrHeader );
    HRESULT Send ( );
    void PutRequestBody (
        const _variant_t & pvarVal );
    _variant_t GetRequestBody ( );
    long GetStatus ( );
    _bstr_t GetStatusText ( );
    IDispatchPtr GetResponseXML ( );
    _variant_t GetResponseBody ( );

    //
    // Raw methods provided by interface
    //

      virtual HRESULT __stdcall raw_Open (
        /*[in]*/ BSTR bstrMethod,
        /*[in]*/ BSTR bstrUrl,
        /*[in]*/ VARIANT bstrUser = vtMissing,
        /*[in]*/ VARIANT bstrPassword = vtMissing ) = 0;
      virtual HRESULT __stdcall raw_SetHeader (
        /*[in]*/ BSTR bstrHeader,
        /*[in]*/ BSTR bstrValue ) = 0;
      virtual HRESULT __stdcall raw_GetHeader (
        /*[in]*/ BSTR bstrHeader,
        /*[out,retval]*/ BSTR * pbstrValue ) = 0;
      virtual HRESULT __stdcall raw_Send ( ) = 0;
      virtual HRESULT __stdcall put_RequestBody (
        /*[in]*/ VARIANT pvarVal ) = 0;
      virtual HRESULT __stdcall get_RequestBody (
        /*[out,retval]*/ VARIANT * pvarVal ) = 0;
      virtual HRESULT __stdcall get_Status (
        /*[out,retval]*/ long * plVal ) = 0;
      virtual HRESULT __stdcall get_StatusText (
        /*[out,retval]*/ BSTR * pbstrVal ) = 0;
      virtual HRESULT __stdcall get_ResponseXML (
        /*[out,retval]*/ IDispatch * * ppXmlDom ) = 0;
      virtual HRESULT __stdcall get_ResponseBody (
        /*[out,retval]*/ VARIANT * pvarVal ) = 0;
};

struct __declspec(uuid("ed8c108e-4349-11d2-91a4-00c04f7969e8"))
XMLHTTPRequest;
    // [ default ] interface IXMLHttpRequest

struct __declspec(uuid("310afa62-0575-11d2-9ca9-0060b0ec3d39"))
IXMLDSOControl : IDispatch
{
    //
    // Property data
    //

    __declspec(property(get=GetXMLDocument,put=PutXMLDocument))
    IXMLDOMDocumentPtr XMLDocument;
    __declspec(property(get=GetJavaDSOCompatible,put=PutJavaDSOCompatible))
    long JavaDSOCompatible;
    __declspec(property(get=GetFilterSchema,put=PutFilterSchema))
    _bstr_t FilterSchema;
    __declspec(property(get=GetreadyState))
    long readyState;

    //
    // Wrapper methods for error-handling
    //

    IXMLDOMDocumentPtr GetXMLDocument ( );
    void PutXMLDocument (
        struct IXMLDOMDocument * ppDoc );
    long GetJavaDSOCompatible ( );
    void PutJavaDSOCompatible (
        long fJavaDSOCompatible );
    _bstr_t GetFilterSchema ( );
    void PutFilterSchema (
        _bstr_t pFilterSchemaUrl );
    long GetreadyState ( );

    //
    // Raw methods provided by interface
    //

      virtual HRESULT __stdcall get_XMLDocument (
        /*[out,retval]*/ struct IXMLDOMDocument * * ppDoc ) = 0;
      virtual HRESULT __stdcall put_XMLDocument (
        /*[in]*/ struct IXMLDOMDocument * ppDoc ) = 0;
      virtual HRESULT __stdcall get_JavaDSOCompatible (
        /*[out,retval]*/ long * fJavaDSOCompatible ) = 0;
      virtual HRESULT __stdcall put_JavaDSOCompatible (
        /*[in]*/ long fJavaDSOCompatible ) = 0;
      virtual HRESULT __stdcall get_FilterSchema (
        /*[out,retval]*/ BSTR * pFilterSchemaUrl ) = 0;
      virtual HRESULT __stdcall put_FilterSchema (
        /*[in]*/ BSTR pFilterSchemaUrl ) = 0;
      virtual HRESULT __stdcall get_readyState (
        /*[out,retval]*/ long * state ) = 0;
};

struct __declspec(uuid("550dda30-0541-11d2-9ca9-0060b0ec3d39"))
XMLDSOControl;
    // [ default ] interface IXMLDSOControl

enum tagXMLEMEM_TYPE
{
    XMLELEMTYPE_ELEMENT = 0,
    XMLELEMTYPE_TEXT = 1,
    XMLELEMTYPE_COMMENT = 2,
    XMLELEMTYPE_DOCUMENT = 3,
    XMLELEMTYPE_DTD = 4,
    XMLELEMTYPE_PI = 5,
    XMLELEMTYPE_OTHER = 6
};

struct __declspec(uuid("cfc399af-d876-11d0-9c10-00c04fc99c8e"))
XMLDocument;
    // [ default ] interface IXMLDocument2

//
// Wrapper method implementations
//

#include "xmltli.h"

} // namespace MSXML

#pragma pack(pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\xmltli.h ===
// Created by Microsoft (R) C/C++ Compiler Version 13.00.9076.3 (8cb5a81c).
//
// e:\nt\ds\security\passport\common\schema\obj\ia64\msxml.tli
//
// Wrapper implementations for Win32 type library msxml.dll
// compiler-generated file created 04/17/01 at 14:47:29 - DO NOT EDIT!

#pragma once

//
// interface IXMLElementCollection wrapper method implementations
//

inline void IXMLElementCollection::Putlength ( long p ) {
    HRESULT _hr = put_length(p);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long IXMLElementCollection::Getlength ( ) {
    long _result = 0;
    HRESULT _hr = get_length(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline IUnknownPtr IXMLElementCollection::Get_newEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__newEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

inline IDispatchPtr IXMLElementCollection::item ( const _variant_t & var1, const _variant_t & var2 ) {
    IDispatch * _result = 0;
    HRESULT _hr = raw_item(var1, var2, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDispatchPtr(_result, false);
}

//
// interface IXMLDocument wrapper method implementations
//

inline IXMLElementPtr IXMLDocument::Getroot ( ) {
    struct IXMLElement * _result = 0;
    HRESULT _hr = get_root(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IXMLElementPtr(_result, false);
}

inline _bstr_t IXMLDocument::GetfileSize ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_fileSize(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t IXMLDocument::GetfileModifiedDate ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_fileModifiedDate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t IXMLDocument::GetfileUpdatedDate ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_fileUpdatedDate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t IXMLDocument::GetURL ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_URL(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void IXMLDocument::PutURL ( _bstr_t p ) {
    HRESULT _hr = put_URL(p);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline _bstr_t IXMLDocument::GetmimeType ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_mimeType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline long IXMLDocument::GetreadyState ( ) {
    long _result = 0;
    HRESULT _hr = get_readyState(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _bstr_t IXMLDocument::Getcharset ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_charset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void IXMLDocument::Putcharset ( _bstr_t p ) {
    HRESULT _hr = put_charset(p);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline _bstr_t IXMLDocument::Getversion ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_version(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t IXMLDocument::Getdoctype ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_doctype(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t IXMLDocument::GetdtdURL ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_dtdURL(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline IXMLElementPtr IXMLDocument::createElement ( const _variant_t & vType, const _variant_t & var1 ) {
    struct IXMLElement * _result = 0;
    HRESULT _hr = raw_createElement(vType, var1, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IXMLElementPtr(_result, false);
}

//
// interface IXMLElement wrapper method implementations
//

inline _bstr_t IXMLElement::GettagName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_tagName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void IXMLElement::PuttagName ( _bstr_t p ) {
    HRESULT _hr = put_tagName(p);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline IXMLElementPtr IXMLElement::Getparent ( ) {
    struct IXMLElement * _result = 0;
    HRESULT _hr = get_parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IXMLElementPtr(_result, false);
}

inline HRESULT IXMLElement::setAttribute ( _bstr_t strPropertyName, const _variant_t & PropertyValue ) {
    HRESULT _hr = raw_setAttribute(strPropertyName, PropertyValue);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline _variant_t IXMLElement::getAttribute ( _bstr_t strPropertyName ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_getAttribute(strPropertyName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline HRESULT IXMLElement::removeAttribute ( _bstr_t strPropertyName ) {
    HRESULT _hr = raw_removeAttribute(strPropertyName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline IXMLElementCollectionPtr IXMLElement::Getchildren ( ) {
    struct IXMLElementCollection * _result = 0;
    HRESULT _hr = get_children(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IXMLElementCollectionPtr(_result, false);
}

inline long IXMLElement::Gettype ( ) {
    long _result = 0;
    HRESULT _hr = get_type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _bstr_t IXMLElement::Gettext ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_text(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void IXMLElement::Puttext ( _bstr_t p ) {
    HRESULT _hr = put_text(p);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline HRESULT IXMLElement::addChild ( struct IXMLElement * pChildElem, long lIndex, long lReserved ) {
    HRESULT _hr = raw_addChild(pChildElem, lIndex, lReserved);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IXMLElement::removeChild ( struct IXMLElement * pChildElem ) {
    HRESULT _hr = raw_removeChild(pChildElem);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IXMLDocument2 wrapper method implementations
//

inline IXMLElement2Ptr IXMLDocument2::Getroot ( ) {
    struct IXMLElement2 * _result = 0;
    HRESULT _hr = get_root(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IXMLElement2Ptr(_result, false);
}

inline _bstr_t IXMLDocument2::GetfileSize ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_fileSize(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t IXMLDocument2::GetfileModifiedDate ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_fileModifiedDate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t IXMLDocument2::GetfileUpdatedDate ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_fileUpdatedDate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t IXMLDocument2::GetURL ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_URL(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void IXMLDocument2::PutURL ( _bstr_t p ) {
    HRESULT _hr = put_URL(p);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline _bstr_t IXMLDocument2::GetmimeType ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_mimeType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline long IXMLDocument2::GetreadyState ( ) {
    long _result = 0;
    HRESULT _hr = get_readyState(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _bstr_t IXMLDocument2::Getcharset ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_charset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void IXMLDocument2::Putcharset ( _bstr_t p ) {
    HRESULT _hr = put_charset(p);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline _bstr_t IXMLDocument2::Getversion ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_version(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t IXMLDocument2::Getdoctype ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_doctype(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t IXMLDocument2::GetdtdURL ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_dtdURL(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline IXMLElement2Ptr IXMLDocument2::createElement ( const _variant_t & vType, const _variant_t & var1 ) {
    struct IXMLElement2 * _result = 0;
    HRESULT _hr = raw_createElement(vType, var1, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IXMLElement2Ptr(_result, false);
}

inline VARIANT_BOOL IXMLDocument2::Getasync ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_async(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void IXMLDocument2::Putasync ( VARIANT_BOOL pf ) {
    HRESULT _hr = put_async(pf);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IXMLElement2 wrapper method implementations
//

inline _bstr_t IXMLElement2::GettagName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_tagName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void IXMLElement2::PuttagName ( _bstr_t p ) {
    HRESULT _hr = put_tagName(p);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline IXMLElement2Ptr IXMLElement2::Getparent ( ) {
    struct IXMLElement2 * _result = 0;
    HRESULT _hr = get_parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IXMLElement2Ptr(_result, false);
}

inline HRESULT IXMLElement2::setAttribute ( _bstr_t strPropertyName, const _variant_t & PropertyValue ) {
    HRESULT _hr = raw_setAttribute(strPropertyName, PropertyValue);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline _variant_t IXMLElement2::getAttribute ( _bstr_t strPropertyName ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_getAttribute(strPropertyName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline HRESULT IXMLElement2::removeAttribute ( _bstr_t strPropertyName ) {
    HRESULT _hr = raw_removeAttribute(strPropertyName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline IXMLElementCollectionPtr IXMLElement2::Getchildren ( ) {
    struct IXMLElementCollection * _result = 0;
    HRESULT _hr = get_children(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IXMLElementCollectionPtr(_result, false);
}

inline long IXMLElement2::Gettype ( ) {
    long _result = 0;
    HRESULT _hr = get_type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _bstr_t IXMLElement2::Gettext ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_text(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void IXMLElement2::Puttext ( _bstr_t p ) {
    HRESULT _hr = put_text(p);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline HRESULT IXMLElement2::addChild ( struct IXMLElement2 * pChildElem, long lIndex, long lReserved ) {
    HRESULT _hr = raw_addChild(pChildElem, lIndex, lReserved);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IXMLElement2::removeChild ( struct IXMLElement2 * pChildElem ) {
    HRESULT _hr = raw_removeChild(pChildElem);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline IXMLElementCollectionPtr IXMLElement2::Getattributes ( ) {
    struct IXMLElementCollection * _result = 0;
    HRESULT _hr = get_attributes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IXMLElementCollectionPtr(_result, false);
}

//
// interface IXMLAttribute wrapper method implementations
//

inline _bstr_t IXMLAttribute::Getname ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t IXMLAttribute::Getvalue ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_value(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface IXMLError wrapper method implementations
//

inline HRESULT IXMLError::GetErrorInfo ( struct _xml_error * pErrorReturn ) {
    HRESULT _hr = raw_GetErrorInfo(pErrorReturn);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IDOMImplementation wrapper method implementations
//

inline VARIANT_BOOL IDOMImplementation::hasFeature ( _bstr_t feature, _bstr_t version ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_hasFeature(feature, version, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IDOMNode wrapper method implementations
//

inline _bstr_t IDOMNode::GetnodeName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_nodeName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _variant_t IDOMNode::GetnodeValue ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_nodeValue(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline void IDOMNode::PutnodeValue ( const _variant_t & value ) {
    HRESULT _hr = put_nodeValue(value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline DOMNodeType IDOMNode::GetnodeType ( ) {
    DOMNodeType _result;
    HRESULT _hr = get_nodeType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline IDOMNodePtr IDOMNode::GetparentNode ( ) {
    struct IDOMNode * _result = 0;
    HRESULT _hr = get_parentNode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDOMNodePtr(_result, false);
}

inline IDOMNodeListPtr IDOMNode::GetchildNodes ( ) {
    struct IDOMNodeList * _result = 0;
    HRESULT _hr = get_childNodes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDOMNodeListPtr(_result, false);
}

inline IDOMNodePtr IDOMNode::GetfirstChild ( ) {
    struct IDOMNode * _result = 0;
    HRESULT _hr = get_firstChild(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDOMNodePtr(_result, false);
}

inline IDOMNodePtr IDOMNode::GetlastChild ( ) {
    struct IDOMNode * _result = 0;
    HRESULT _hr = get_lastChild(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDOMNodePtr(_result, false);
}

inline IDOMNodePtr IDOMNode::GetpreviousSibling ( ) {
    struct IDOMNode * _result = 0;
    HRESULT _hr = get_previousSibling(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDOMNodePtr(_result, false);
}

inline IDOMNodePtr IDOMNode::GetnextSibling ( ) {
    struct IDOMNode * _result = 0;
    HRESULT _hr = get_nextSibling(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDOMNodePtr(_result, false);
}

inline IDOMNamedNodeMapPtr IDOMNode::Getattributes ( ) {
    struct IDOMNamedNodeMap * _result = 0;
    HRESULT _hr = get_attributes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDOMNamedNodeMapPtr(_result, false);
}

inline IDOMNodePtr IDOMNode::insertBefore ( struct IDOMNode * newChild, const _variant_t & refChild ) {
    struct IDOMNode * _result = 0;
    HRESULT _hr = raw_insertBefore(newChild, refChild, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDOMNodePtr(_result, false);
}

inline IDOMNodePtr IDOMNode::replaceChild ( struct IDOMNode * newChild, struct IDOMNode * oldChild ) {
    struct IDOMNode * _result = 0;
    HRESULT _hr = raw_replaceChild(newChild, oldChild, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDOMNodePtr(_result, false);
}

inline IDOMNodePtr IDOMNode::removeChild ( struct IDOMNode * childNode ) {
    struct IDOMNode * _result = 0;
    HRESULT _hr = raw_removeChild(childNode, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDOMNodePtr(_result, false);
}

inline IDOMNodePtr IDOMNode::appendChild ( struct IDOMNode * newChild ) {
    struct IDOMNode * _result = 0;
    HRESULT _hr = raw_appendChild(newChild, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDOMNodePtr(_result, false);
}

inline VARIANT_BOOL IDOMNode::hasChildNodes ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_hasChildNodes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline IDOMDocumentPtr IDOMNode::GetownerDocument ( ) {
    struct IDOMDocument * _result = 0;
    HRESULT _hr = get_ownerDocument(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDOMDocumentPtr(_result, false);
}

inline IDOMNodePtr IDOMNode::cloneNode ( VARIANT_BOOL deep ) {
    struct IDOMNode * _result = 0;
    HRESULT _hr = raw_cloneNode(deep, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDOMNodePtr(_result, false);
}

//
// interface IDOMNodeList wrapper method implementations
//

inline IDOMNodePtr IDOMNodeList::Getitem ( long index ) {
    struct IDOMNode * _result = 0;
    HRESULT _hr = get_item(index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDOMNodePtr(_result, false);
}

inline long IDOMNodeList::Getlength ( ) {
    long _result = 0;
    HRESULT _hr = get_length(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IDOMNamedNodeMap wrapper method implementations
//

inline IDOMNodePtr IDOMNamedNodeMap::getNamedItem ( _bstr_t name ) {
    struct IDOMNode * _result = 0;
    HRESULT _hr = raw_getNamedItem(name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDOMNodePtr(_result, false);
}

inline IDOMNodePtr IDOMNamedNodeMap::setNamedItem ( struct IDOMNode * newItem ) {
    struct IDOMNode * _result = 0;
    HRESULT _hr = raw_setNamedItem(newItem, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDOMNodePtr(_result, false);
}

inline IDOMNodePtr IDOMNamedNodeMap::removeNamedItem ( _bstr_t name ) {
    struct IDOMNode * _result = 0;
    HRESULT _hr = raw_removeNamedItem(name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDOMNodePtr(_result, false);
}

inline IDOMNodePtr IDOMNamedNodeMap::Getitem ( long index ) {
    struct IDOMNode * _result = 0;
    HRESULT _hr = get_item(index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDOMNodePtr(_result, false);
}

inline long IDOMNamedNodeMap::Getlength ( ) {
    long _result = 0;
    HRESULT _hr = get_length(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IDOMDocument wrapper method implementations
//

inline IDOMDocumentTypePtr IDOMDocument::Getdoctype ( ) {
    struct IDOMDocumentType * _result = 0;
    HRESULT _hr = get_doctype(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDOMDocumentTypePtr(_result, false);
}

inline IDOMImplementationPtr IDOMDocument::Getimplementation ( ) {
    struct IDOMImplementation * _result = 0;
    HRESULT _hr = get_implementation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDOMImplementationPtr(_result, false);
}

inline IDOMElementPtr IDOMDocument::GetdocumentElement ( ) {
    struct IDOMElement * _result = 0;
    HRESULT _hr = get_documentElement(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDOMElementPtr(_result, false);
}

inline void IDOMDocument::PutRefdocumentElement ( struct IDOMElement * DOMElement ) {
    HRESULT _hr = putref_documentElement(DOMElement);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline IDOMElementPtr IDOMDocument::createElement ( _bstr_t tagName ) {
    struct IDOMElement * _result = 0;
    HRESULT _hr = raw_createElement(tagName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDOMElementPtr(_result, false);
}

inline IDOMDocumentFragmentPtr IDOMDocument::createDocumentFragment ( ) {
    struct IDOMDocumentFragment * _result = 0;
    HRESULT _hr = raw_createDocumentFragment(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDOMDocumentFragmentPtr(_result, false);
}

inline IDOMTextPtr IDOMDocument::createTextNode ( _bstr_t data ) {
    struct IDOMText * _result = 0;
    HRESULT _hr = raw_createTextNode(data, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDOMTextPtr(_result, false);
}

inline IDOMCommentPtr IDOMDocument::createComment ( _bstr_t data ) {
    struct IDOMComment * _result = 0;
    HRESULT _hr = raw_createComment(data, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDOMCommentPtr(_result, false);
}

inline IDOMCDATASectionPtr IDOMDocument::createCDATASection ( _bstr_t data ) {
    struct IDOMCDATASection * _result = 0;
    HRESULT _hr = raw_createCDATASection(data, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDOMCDATASectionPtr(_result, false);
}

inline IDOMProcessingInstructionPtr IDOMDocument::createProcessingInstruction ( _bstr_t target, _bstr_t data ) {
    struct IDOMProcessingInstruction * _result = 0;
    HRESULT _hr = raw_createProcessingInstruction(target, data, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDOMProcessingInstructionPtr(_result, false);
}

inline IDOMAttributePtr IDOMDocument::createAttribute ( _bstr_t name ) {
    struct IDOMAttribute * _result = 0;
    HRESULT _hr = raw_createAttribute(name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDOMAttributePtr(_result, false);
}

inline IDOMEntityReferencePtr IDOMDocument::createEntityReference ( _bstr_t name ) {
    struct IDOMEntityReference * _result = 0;
    HRESULT _hr = raw_createEntityReference(name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDOMEntityReferencePtr(_result, false);
}

inline IDOMNodeListPtr IDOMDocument::getElementsByTagName ( _bstr_t tagName ) {
    struct IDOMNodeList * _result = 0;
    HRESULT _hr = raw_getElementsByTagName(tagName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDOMNodeListPtr(_result, false);
}

//
// interface IDOMDocumentType wrapper method implementations
//

inline _bstr_t IDOMDocumentType::Getname ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline IDOMNamedNodeMapPtr IDOMDocumentType::Getentities ( ) {
    struct IDOMNamedNodeMap * _result = 0;
    HRESULT _hr = get_entities(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDOMNamedNodeMapPtr(_result, false);
}

inline IDOMNamedNodeMapPtr IDOMDocumentType::Getnotations ( ) {
    struct IDOMNamedNodeMap * _result = 0;
    HRESULT _hr = get_notations(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDOMNamedNodeMapPtr(_result, false);
}

//
// interface IDOMElement wrapper method implementations
//

inline _bstr_t IDOMElement::GettagName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_tagName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _variant_t IDOMElement::getAttribute ( _bstr_t name ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_getAttribute(name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline HRESULT IDOMElement::setAttribute ( _bstr_t name, const _variant_t & value ) {
    HRESULT _hr = raw_setAttribute(name, value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IDOMElement::removeAttribute ( _bstr_t name ) {
    HRESULT _hr = raw_removeAttribute(name);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline IDOMAttributePtr IDOMElement::getAttributeNode ( _bstr_t name ) {
    struct IDOMAttribute * _result = 0;
    HRESULT _hr = raw_getAttributeNode(name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDOMAttributePtr(_result, false);
}

inline IDOMAttributePtr IDOMElement::setAttributeNode ( struct IDOMAttribute * DOMAttribute ) {
    struct IDOMAttribute * _result = 0;
    HRESULT _hr = raw_setAttributeNode(DOMAttribute, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDOMAttributePtr(_result, false);
}

inline IDOMAttributePtr IDOMElement::removeAttributeNode ( struct IDOMAttribute * DOMAttribute ) {
    struct IDOMAttribute * _result = 0;
    HRESULT _hr = raw_removeAttributeNode(DOMAttribute, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDOMAttributePtr(_result, false);
}

inline IDOMNodeListPtr IDOMElement::getElementsByTagName ( _bstr_t tagName ) {
    struct IDOMNodeList * _result = 0;
    HRESULT _hr = raw_getElementsByTagName(tagName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDOMNodeListPtr(_result, false);
}

inline HRESULT IDOMElement::normalize ( ) {
    HRESULT _hr = raw_normalize();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IDOMAttribute wrapper method implementations
//

inline _bstr_t IDOMAttribute::Getname ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline VARIANT_BOOL IDOMAttribute::Getspecified ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_specified(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _variant_t IDOMAttribute::Getvalue ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_value(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline void IDOMAttribute::Putvalue ( const _variant_t & attributeValue ) {
    HRESULT _hr = put_value(attributeValue);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IDOMCharacterData wrapper method implementations
//

inline _bstr_t IDOMCharacterData::Getdata ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_data(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void IDOMCharacterData::Putdata ( _bstr_t data ) {
    HRESULT _hr = put_data(data);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long IDOMCharacterData::Getlength ( ) {
    long _result = 0;
    HRESULT _hr = get_length(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _bstr_t IDOMCharacterData::substringData ( long offset, long count ) {
    BSTR _result = 0;
    HRESULT _hr = raw_substringData(offset, count, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline HRESULT IDOMCharacterData::appendData ( _bstr_t data ) {
    HRESULT _hr = raw_appendData(data);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IDOMCharacterData::insertData ( long offset, _bstr_t data ) {
    HRESULT _hr = raw_insertData(offset, data);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IDOMCharacterData::deleteData ( long offset, long count ) {
    HRESULT _hr = raw_deleteData(offset, count);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IDOMCharacterData::replaceData ( long offset, long count, _bstr_t data ) {
    HRESULT _hr = raw_replaceData(offset, count, data);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IDOMText wrapper method implementations
//

inline IDOMTextPtr IDOMText::splitText ( long offset ) {
    struct IDOMText * _result = 0;
    HRESULT _hr = raw_splitText(offset, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDOMTextPtr(_result, false);
}

//
// interface IDOMProcessingInstruction wrapper method implementations
//

inline _bstr_t IDOMProcessingInstruction::Gettarget ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_target(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t IDOMProcessingInstruction::Getdata ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_data(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void IDOMProcessingInstruction::Putdata ( _bstr_t value ) {
    HRESULT _hr = put_data(value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IDOMNotation wrapper method implementations
//

inline _variant_t IDOMNotation::GetpublicId ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_publicId(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline _variant_t IDOMNotation::GetsystemId ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_systemId(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

//
// interface IDOMEntity wrapper method implementations
//

inline _variant_t IDOMEntity::GetpublicId ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_publicId(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline _variant_t IDOMEntity::GetsystemId ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_systemId(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline _bstr_t IDOMEntity::GetnotationName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_notationName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface IXMLDOMNode wrapper method implementations
//

inline _bstr_t IXMLDOMNode::GetnodeStringType ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_nodeStringType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t IXMLDOMNode::Gettext ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_text(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void IXMLDOMNode::Puttext ( _bstr_t text ) {
    HRESULT _hr = put_text(text);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline VARIANT_BOOL IXMLDOMNode::Getspecified ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_specified(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline IXMLDOMNodePtr IXMLDOMNode::Getdefinition ( ) {
    struct IXMLDOMNode * _result = 0;
    HRESULT _hr = get_definition(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IXMLDOMNodePtr(_result, false);
}

inline _variant_t IXMLDOMNode::GetnodeTypedValue ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_nodeTypedValue(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline void IXMLDOMNode::PutnodeTypedValue ( const _variant_t & typedValue ) {
    HRESULT _hr = put_nodeTypedValue(typedValue);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline _variant_t IXMLDOMNode::GetdataType ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_dataType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline void IXMLDOMNode::PutdataType ( _bstr_t dataTypeName ) {
    HRESULT _hr = put_dataType(dataTypeName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline _bstr_t IXMLDOMNode::Getxml ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_xml(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t IXMLDOMNode::transformNode ( struct IXMLDOMNode * stylesheet ) {
    BSTR _result = 0;
    HRESULT _hr = raw_transformNode(stylesheet, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline IXMLDOMNodeListPtr IXMLDOMNode::selectNodes ( _bstr_t queryString ) {
    struct IXMLDOMNodeList * _result = 0;
    HRESULT _hr = raw_selectNodes(queryString, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IXMLDOMNodeListPtr(_result, false);
}

inline IXMLDOMNodePtr IXMLDOMNode::selectSingleNode ( _bstr_t queryString ) {
    struct IXMLDOMNode * _result = 0;
    HRESULT _hr = raw_selectSingleNode(queryString, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IXMLDOMNodePtr(_result, false);
}

inline VARIANT_BOOL IXMLDOMNode::Getparsed ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_parsed(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _bstr_t IXMLDOMNode::GetnameSpace ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_nameSpace(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t IXMLDOMNode::Getprefix ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_prefix(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t IXMLDOMNode::GetbaseName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_baseName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface IXMLDOMNodeList wrapper method implementations
//

inline IXMLDOMNodePtr IXMLDOMNodeList::nextNode ( ) {
    struct IXMLDOMNode * _result = 0;
    HRESULT _hr = raw_nextNode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IXMLDOMNodePtr(_result, false);
}

inline HRESULT IXMLDOMNodeList::reset ( ) {
    HRESULT _hr = raw_reset();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline IUnknownPtr IXMLDOMNodeList::Get_newEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__newEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

//
// interface IXMLDOMDocument wrapper method implementations
//

inline IXMLDOMNodePtr IXMLDOMDocument::createNode ( const _variant_t & type, _bstr_t name, _bstr_t namespaceURI ) {
    struct IXMLDOMNode * _result = 0;
    HRESULT _hr = raw_createNode(type, name, namespaceURI, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IXMLDOMNodePtr(_result, false);
}

inline IXMLDOMNodePtr IXMLDOMDocument::nodeFromID ( _bstr_t idString ) {
    struct IXMLDOMNode * _result = 0;
    HRESULT _hr = raw_nodeFromID(idString, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IXMLDOMNodePtr(_result, false);
}

inline VARIANT_BOOL IXMLDOMDocument::load ( _bstr_t URL ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_load(URL, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long IXMLDOMDocument::GetreadyState ( ) {
    long _result = 0;
    HRESULT _hr = get_readyState(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline IDOMParseErrorPtr IXMLDOMDocument::GetparseError ( ) {
    struct IDOMParseError * _result = 0;
    HRESULT _hr = get_parseError(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDOMParseErrorPtr(_result, false);
}

inline _bstr_t IXMLDOMDocument::GetURL ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_URL(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline VARIANT_BOOL IXMLDOMDocument::Getasync ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_async(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void IXMLDOMDocument::Putasync ( VARIANT_BOOL isAsync ) {
    HRESULT _hr = put_async(isAsync);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline HRESULT IXMLDOMDocument::abort ( ) {
    HRESULT _hr = raw_abort();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline VARIANT_BOOL IXMLDOMDocument::loadXML ( _bstr_t xmlString ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_loadXML(xmlString, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL IXMLDOMDocument::GetvalidateOnParse ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_validateOnParse(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void IXMLDOMDocument::PutvalidateOnParse ( VARIANT_BOOL isValidating ) {
    HRESULT _hr = put_validateOnParse(isValidating);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline void IXMLDOMDocument::Putonreadystatechange ( const _variant_t & _arg1 ) {
    HRESULT _hr = put_onreadystatechange(_arg1);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline void IXMLDOMDocument::Putondataavailable ( const _variant_t & _arg1 ) {
    HRESULT _hr = put_ondataavailable(_arg1);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline _bstr_t IXMLDOMDocument::Getxml ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_xml(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t IXMLDOMDocument::transformNode ( struct IXMLDOMNode * stylesheet ) {
    BSTR _result = 0;
    HRESULT _hr = raw_transformNode(stylesheet, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline IXMLDOMNodeListPtr IXMLDOMDocument::selectNodes ( _bstr_t queryString ) {
    struct IXMLDOMNodeList * _result = 0;
    HRESULT _hr = raw_selectNodes(queryString, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IXMLDOMNodeListPtr(_result, false);
}

inline IXMLDOMNodePtr IXMLDOMDocument::selectSingleNode ( _bstr_t queryString ) {
    struct IXMLDOMNode * _result = 0;
    HRESULT _hr = raw_selectSingleNode(queryString, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IXMLDOMNodePtr(_result, false);
}

inline VARIANT_BOOL IXMLDOMDocument::Getparsed ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_parsed(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IDOMParseError wrapper method implementations
//

inline long IDOMParseError::GeterrorCode ( ) {
    long _result = 0;
    HRESULT _hr = get_errorCode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _bstr_t IDOMParseError::GetURL ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_URL(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t IDOMParseError::Getreason ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_reason(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t IDOMParseError::GetsrcText ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_srcText(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline long IDOMParseError::Getline ( ) {
    long _result = 0;
    HRESULT _hr = get_line(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long IDOMParseError::Getlinepos ( ) {
    long _result = 0;
    HRESULT _hr = get_linepos(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long IDOMParseError::Getfilepos ( ) {
    long _result = 0;
    HRESULT _hr = get_filepos(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IXMLDOMNamedNodeMap wrapper method implementations
//

inline IXMLDOMNodePtr IXMLDOMNamedNodeMap::getQualifiedItem ( _bstr_t baseName, _bstr_t namespaceURI ) {
    struct IXMLDOMNode * _result = 0;
    HRESULT _hr = raw_getQualifiedItem(baseName, namespaceURI, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IXMLDOMNodePtr(_result, false);
}

inline IXMLDOMNodePtr IXMLDOMNamedNodeMap::removeQualifiedItem ( _bstr_t baseName, _bstr_t namespaceURI ) {
    struct IXMLDOMNode * _result = 0;
    HRESULT _hr = raw_removeQualifiedItem(baseName, namespaceURI, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IXMLDOMNodePtr(_result, false);
}

inline IXMLDOMNodePtr IXMLDOMNamedNodeMap::nextNode ( ) {
    struct IXMLDOMNode * _result = 0;
    HRESULT _hr = raw_nextNode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IXMLDOMNodePtr(_result, false);
}

inline HRESULT IXMLDOMNamedNodeMap::reset ( ) {
    HRESULT _hr = raw_reset();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline IUnknownPtr IXMLDOMNamedNodeMap::Get_newEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__newEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

//
// interface IXTLRuntime wrapper method implementations
//

inline long IXTLRuntime::uniqueID ( struct IDOMNode * pNode ) {
    long _result = 0;
    HRESULT _hr = raw_uniqueID(pNode, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long IXTLRuntime::depth ( struct IDOMNode * pNode ) {
    long _result = 0;
    HRESULT _hr = raw_depth(pNode, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long IXTLRuntime::childNumber ( struct IDOMNode * pNode ) {
    long _result = 0;
    HRESULT _hr = raw_childNumber(pNode, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long IXTLRuntime::ancestorChildNumber ( _bstr_t bstrNodeName, struct IDOMNode * pNode ) {
    long _result = 0;
    HRESULT _hr = raw_ancestorChildNumber(bstrNodeName, pNode, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long IXTLRuntime::absoluteChildNumber ( struct IDOMNode * pNode ) {
    long _result = 0;
    HRESULT _hr = raw_absoluteChildNumber(pNode, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _bstr_t IXTLRuntime::formatIndex ( long lIndex, _bstr_t bstrFormat ) {
    BSTR _result = 0;
    HRESULT _hr = raw_formatIndex(lIndex, bstrFormat, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t IXTLRuntime::formatNumber ( double dblNumber, _bstr_t bstrFormat ) {
    BSTR _result = 0;
    HRESULT _hr = raw_formatNumber(dblNumber, bstrFormat, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t IXTLRuntime::formatDate ( const _variant_t & varDate, _bstr_t bstrFormat, const _variant_t & varDestLocale ) {
    BSTR _result = 0;
    HRESULT _hr = raw_formatDate(varDate, bstrFormat, varDestLocale, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t IXTLRuntime::formatTime ( const _variant_t & varTime, _bstr_t bstrFormat, const _variant_t & varDestLocale ) {
    BSTR _result = 0;
    HRESULT _hr = raw_formatTime(varTime, bstrFormat, varDestLocale, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// dispinterface XMLDOMDocumentEvents wrapper method implementations
//

inline HRESULT XMLDOMDocumentEvents::ondataavailable ( ) {
    HRESULT _result = 0;
    _com_dispatch_method(this, 0x2a2, DISPATCH_METHOD, VT_ERROR, (void*)&_result, NULL);
    return _result;
}

inline HRESULT XMLDOMDocumentEvents::onreadystatechange ( ) {
    HRESULT _result = 0;
    _com_dispatch_method(this, DISPID_READYSTATECHANGE, DISPATCH_METHOD, VT_ERROR, (void*)&_result, NULL);
    return _result;
}

//
// interface IXMLHttpRequest wrapper method implementations
//

inline HRESULT IXMLHttpRequest::Open ( _bstr_t bstrMethod, _bstr_t bstrUrl, const _variant_t & bstrUser, const _variant_t & bstrPassword ) {
    HRESULT _hr = raw_Open(bstrMethod, bstrUrl, bstrUser, bstrPassword);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IXMLHttpRequest::SetHeader ( _bstr_t bstrHeader, _bstr_t bstrValue ) {
    HRESULT _hr = raw_SetHeader(bstrHeader, bstrValue);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline _bstr_t IXMLHttpRequest::GetHeader ( _bstr_t bstrHeader ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetHeader(bstrHeader, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline HRESULT IXMLHttpRequest::Send ( ) {
    HRESULT _hr = raw_Send();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline void IXMLHttpRequest::PutRequestBody ( const _variant_t & pvarVal ) {
    HRESULT _hr = put_RequestBody(pvarVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline _variant_t IXMLHttpRequest::GetRequestBody ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_RequestBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline long IXMLHttpRequest::GetStatus ( ) {
    long _result = 0;
    HRESULT _hr = get_Status(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _bstr_t IXMLHttpRequest::GetStatusText ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_StatusText(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline IDispatchPtr IXMLHttpRequest::GetResponseXML ( ) {
    IDispatch * _result = 0;
    HRESULT _hr = get_ResponseXML(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDispatchPtr(_result, false);
}

inline _variant_t IXMLHttpRequest::GetResponseBody ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_ResponseBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

//
// interface IXMLDSOControl wrapper method implementations
//

inline IXMLDOMDocumentPtr IXMLDSOControl::GetXMLDocument ( ) {
    struct IXMLDOMDocument * _result = 0;
    HRESULT _hr = get_XMLDocument(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IXMLDOMDocumentPtr(_result, false);
}

inline void IXMLDSOControl::PutXMLDocument ( struct IXMLDOMDocument * ppDoc ) {
    HRESULT _hr = put_XMLDocument(ppDoc);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long IXMLDSOControl::GetJavaDSOCompatible ( ) {
    long _result = 0;
    HRESULT _hr = get_JavaDSOCompatible(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void IXMLDSOControl::PutJavaDSOCompatible ( long fJavaDSOCompatible ) {
    HRESULT _hr = put_JavaDSOCompatible(fJavaDSOCompatible);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline _bstr_t IXMLDSOControl::GetFilterSchema ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_FilterSchema(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void IXMLDSOControl::PutFilterSchema ( _bstr_t pFilterSchemaUrl ) {
    HRESULT _hr = put_FilterSchema(pFilterSchemaUrl);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long IXMLDSOControl::GetreadyState ( ) {
    long _result = 0;
    HRESULT _hr = get_readyState(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\nt\modes.h ===
#ifndef __MODES_H__
#define __MODES_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

/* modes.h

    Defines the generic routines used to do chaining modes with a
    block cipher.
*/


#ifdef __cplusplus
extern "C" {
#endif

// constants for operations
#define ENCRYPT     1
#define DECRYPT     0

/* CBC()
 *
 * Performs a XOR on the plaintext with the previous ciphertext
 *
 * Parameters:
 *
 *      output      Input buffer    -- MUST be RC2_BLOCKLEN
 *      input       Output buffer   -- MUST be RC2_BLOCKLEN
 *      keyTable
 *      op      ENCRYPT, or DECRYPT
 *      feedback    feedback register
 *
 */
void
RSA32API
CBC(
         void   RSA32API Cipher(BYTE *, BYTE *, void *, int),
         DWORD  dwBlockLen,
         BYTE   *output,
         BYTE   *input,
         void   *keyTable,
         int    op,
         BYTE   *feedback
         );


/* CFB (cipher feedback)
 *
 *
 * Parameters:
 *
 *
 *      output      Input buffer    -- MUST be RC2_BLOCKLEN
 *      input       Output buffer   -- MUST be RC2_BLOCKLEN
 *      keyTable
 *      op      ENCRYPT, or DECRYPT
 *      feedback    feedback register
 *
 */
void
RSA32API
CFB(
         void   RSA32API Cipher(BYTE *, BYTE *, void *, int),
         DWORD  dwBlockLen,
         BYTE   *output,
         BYTE   *input,
         void   *keyTable,
         int    op,
         BYTE   *feedback
         );


#ifdef __cplusplus
}
#endif

#endif // __MODES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\vc6\msdaguid.h ===
//--------------------------------------------------------------------
// Microsoft OLE DB Implementation 
// (C) Copyright 1994 - 1997 By Microsoft Corporation.
//
// @doc
//
// @module MSDAGUID.H | Microsoft Data Access GUID defintions
//--------------------------------------------------------------------

#ifndef MSDAGUID
#define MSDAGUID

#undef OLEDBDECLSPEC
#if _MSC_VER >= 1100
#define OLEDBDECLSPEC __declspec(selectany)
#else
#define OLEDBDECLSPEC 
#endif //_MSC_VER

#ifdef DBINITCONSTANTS
EXTERN_C const OLEDBDECLSPEC GUID CLSID_OLEDB_ENUMERATOR = {0xc8b522d0L,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
EXTERN_C const OLEDBDECLSPEC GUID CLSID_EXTENDEDERRORINFO = {0xc8b522cfL,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
EXTERN_C const OLEDBDECLSPEC GUID CLSID_MSDAVTM = {0x0c733a8eL,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
EXTERN_C const OLEDBDECLSPEC GUID CLSID_OLEDB_CONVERSIONLIBRARY= {0xc8b522d1L,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
EXTERN_C const OLEDBDECLSPEC GUID CLSID_OLEDB_ROWPOSITIONLIBRARY= {0x2048eee6l,0x7fa2,0x11d0,{0x9e,0x6a,0x00,0xa0,0xc9,0x13,0x8c,0x29}};
#else
EXTERN_C const GUID CLSID_OLEDB_ENUMERATOR;
EXTERN_C const GUID CLSID_EXTENDEDERRORINFO;
EXTERN_C const GUID CLSID_MSDAVTM;
EXTERN_C const GUID CLSID_OLEDB_CONVERSIONLIBRARY;
EXTERN_C const GUID CLSID_OLEDB_ROWPOSITIONLIBRARY;
#endif

#endif // MSDAGUID
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\vc6\msdasql.h ===
//--------------------------------------------------------------------
// Microsoft OLE DB Provider for ODBC data 
// (C) Copyright 1994 - 1997 By Microsoft Corporation.
//
// @doc
//
// @module MSDASQL.H | Provider Specific definitions
//
//--------------------------------------------------------------------

#ifndef  _MSDASQL_H_
#define  _MSDASQL_H_

#undef OLEDBDECLSPEC
#if _MSC_VER >= 1100
#define OLEDBDECLSPEC __declspec(selectany)
#else
#define OLEDBDECLSPEC 
#endif //_MSC_VER

// Provider Class Id
#ifdef DBINITCONSTANTS
// IID_ISQLRequestDiagFields {228972F0-B5FF-11d0-8A80-00C04FD611CD}
extern const GUID OLEDBDECLSPEC IID_ISQLRequestDiagFields = { 0x228972f0, 0xb5ff, 0x11d0, { 0x8a, 0x80, 0x0, 0xc0, 0x4f, 0xd6, 0x11, 0xcd } };
// IID_ISQLGetDiagField {228972F1-B5FF-11d0-8A80-00C04FD611CD}
extern const GUID OLEDBDECLSPEC IID_ISQLGetDiagField = { 0x228972f1, 0xb5ff, 0x11d0, { 0x8a, 0x80, 0x0, 0xc0, 0x4f, 0xd6, 0x11, 0xcd } };
// @msg IID_IRowsetChangeExtInfo | {0c733a8f-2a1c-11ce-ade5-00aa0044773d}
extern const GUID OLEDBDECLSPEC IID_IRowsetChangeExtInfo    = {0x0C733A8FL,0x2A1C,0x11CE,{0xAD,0xE5,0x00,0xAA,0x00,0x44,0x77,0x3D}};
extern const GUID CLSID_MSDASQL               = {0xC8B522CBL,0x5CF3,0x11CE,{0xAD,0xE5,0x00,0xAA,0x00,0x44,0x77,0x3D}};
extern const GUID CLSID_MSDASQL_ENUMERATOR    = {0xC8B522CDL,0x5CF3,0x11CE,{0xAD,0xE5,0x00,0xAA,0x00,0x44,0x77,0x3D}};
#else // !DBINITCONSTANTS
extern const GUID IID_ISQLRequestDiagFields;
extern const GUID IID_ISQLGetDiagField;
extern const GUID IID_IRowsetChangeExtInfo;
extern const GUID CLSID_MSDASQL;
extern const GUID CLSID_MSDASQL_ENUMERATOR;
#endif // DBINITCONSTANTS

//----------------------------------------------------------------------------
// MSDASQL specific properties
#ifdef DBINITCONSTANTS
extern const GUID OLEDBDECLSPEC DBPROPSET_PROVIDERDATASOURCEINFO	= {0x497c60e0,0x7123,0x11cf,{0xb1,0x71,0x0,0xaa,0x0,0x57,0x59,0x9e}};
extern const GUID OLEDBDECLSPEC DBPROPSET_PROVIDERROWSET  		= {0x497c60e1,0x7123,0x11cf,{0xb1,0x71,0x0,0xaa,0x0,0x57,0x59,0x9e}};
extern const GUID OLEDBDECLSPEC DBPROPSET_PROVIDERDBINIT  		= {0x497c60e2,0x7123,0x11cf,{0xb1,0x71,0x0,0xaa,0x0,0x57,0x59,0x9e}};
extern const GUID OLEDBDECLSPEC DBPROPSET_PROVIDERSTMTATTR  		= {0x497c60e3,0x7123,0x11cf,{0xb1,0x71,0x0,0xaa,0x0,0x57,0x59,0x9e}};
extern const GUID OLEDBDECLSPEC DBPROPSET_PROVIDERCONNATTR  		= {0x497c60e4,0x7123,0x11cf,{0xb1,0x71,0x0,0xaa,0x0,0x57,0x59,0x9e}};
#else // !DBINITCONSTANTS
extern const GUID DBPROPSET_PROVIDERDATASOURCEINFO;
extern const GUID DBPROPSET_PROVIDERROWSET;
extern const GUID DBPROPSET_PROVIDERDBINIT;
extern const GUID DBPROPSET_PROVIDERSTMTATTR;
extern const GUID DBPROPSET_PROVIDERCONNATTR;
#endif // DBINITCONSTANTS

// PropIds under DBPROPSET_PROVIDERROWSET 
#define KAGPROP_QUERYBASEDUPDATES			2
#define KAGPROP_MARSHALLABLE				3
#define KAGPROP_POSITIONONNEWROW			4
#define	KAGPROP_IRowsetChangeExtInfo		5
#define KAGPROP_CURSOR						6
#define KAGPROP_CONCURRENCY					7
#define KAGPROP_BLOBSONFOCURSOR				8
#define KAGPROP_INCLUDENONEXACT				9
#define KAGPROP_FORCESSFIREHOSEMODE			10
#define KAGPROP_FORCENOPARAMETERREBIND		11
#define KAGPROP_FORCENOPREPARE				12
#define KAGPROP_FORCENOREEXECUTE			13

// PropIds under DPBROPSET_PROVIDERDATASOURCEINFO
#define KAGPROP_ACCESSIBLEPROCEDURES		2
#define KAGPROP_ACCESSIBLETABLES			3
#define KAGPROP_ODBCSQLOPTIEF				4
#define KAGPROP_OJCAPABILITY				5
#define KAGPROP_PROCEDURES					6
#define KAGPROP_DRIVERNAME					7
#define KAGPROP_DRIVERVER					8
#define KAGPROP_DRIVERODBCVER				9
#define KAGPROP_LIKEESCAPECLAUSE			10
#define KAGPROP_SPECIALCHARACTERS			11
#define KAGPROP_MAXCOLUMNSINGROUPBY			12
#define KAGPROP_MAXCOLUMNSININDEX			13
#define KAGPROP_MAXCOLUMNSINORDERBY			14
#define KAGPROP_MAXCOLUMNSINSELECT			15
#define KAGPROP_MAXCOLUMNSINTABLE			16
#define KAGPROP_NUMERICFUNCTIONS			17
#define KAGPROP_ODBCSQLCONFORMANCE			18
#define KAGPROP_OUTERJOINS					19
#define KAGPROP_STRINGFUNCTIONS				20
#define KAGPROP_SYSTEMFUNCTIONS				21
#define KAGPROP_TIMEDATEFUNCTIONS			22
#define KAGPROP_FILEUSAGE					23
#define KAGPROP_ACTIVESTATEMENTS			24

// PropIds under DBPROPSET_PROVIDERDBINIT 
#define KAGPROP_AUTH_TRUSTEDCONNECTION		2
#define KAGPROP_AUTH_SERVERINTEGRATED		3


// Bitmask values for KAGPROP_CONCURRENCY
#define KAGPROPVAL_CONCUR_ROWVER			0x00000001
#define KAGPROPVAL_CONCUR_VALUES			0x00000002
#define KAGPROPVAL_CONCUR_LOCK				0x00000004
#define KAGPROPVAL_CONCUR_READ_ONLY			0x00000008


/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.00.15 */
/* at Tue Sep 24 13:38:00 1996
 */
/* Compiler settings for rstcei.idl:
    Os, W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __rstcei_h__
#define __rstcei_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IRowsetChangeExtInfo_FWD_DEFINED__
#define __IRowsetChangeExtInfo_FWD_DEFINED__
typedef interface IRowsetChangeExtInfo IRowsetChangeExtInfo;
#endif 	/* __IRowsetChangeExtInfo_FWD_DEFINED__ */

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IRowsetChangeExtInfo_INTERFACE_DEFINED__
#define __IRowsetChangeExtInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRowsetChangeExtInfo
 * at Tue Sep 24 13:38:00 1996
 * using MIDL 3.00.15
 ****************************************/
/* [unique][uuid][object][local] */ 



EXTERN_C const IID IID_IRowsetChangeExtInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRowsetChangeExtInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetOriginalRow( 
            /* [in] */ HCHAPTER hReserved,
            /* [in] */ HROW hRow,
            /* [out] */ HROW __RPC_FAR *phRowOriginal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPendingColumns( 
            /* [in] */ HCHAPTER hReserved,
            /* [in] */ HROW hRow,
            /* [in] */ ULONG cColumnOrdinals,
            /* [size_is][in] */ const ULONG __RPC_FAR rgiOrdinals[  ],
            /* [size_is][out] */ DBPENDINGSTATUS __RPC_FAR rgColumnStatus[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRowsetChangeExtInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRowsetChangeExtInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRowsetChangeExtInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRowsetChangeExtInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOriginalRow )( 
            IRowsetChangeExtInfo __RPC_FAR * This,
            /* [in] */ HCHAPTER hReserved,
            /* [in] */ HROW hRow,
            /* [out] */ HROW __RPC_FAR *phRowOriginal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPendingColumns )( 
            IRowsetChangeExtInfo __RPC_FAR * This,
            /* [in] */ HCHAPTER hReserved,
            /* [in] */ HROW hRow,
            /* [in] */ ULONG cColumnOrdinals,
            /* [size_is][in] */ const ULONG __RPC_FAR rgiOrdinals[  ],
            /* [size_is][out] */ DBPENDINGSTATUS __RPC_FAR rgColumnStatus[  ]);
        
        END_INTERFACE
    } IRowsetChangeExtInfoVtbl;

    interface IRowsetChangeExtInfo
    {
        CONST_VTBL struct IRowsetChangeExtInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRowsetChangeExtInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRowsetChangeExtInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRowsetChangeExtInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRowsetChangeExtInfo_GetOriginalRow(This,hReserved,hRow,phRowOriginal)	\
    (This)->lpVtbl -> GetOriginalRow(This,hReserved,hRow,phRowOriginal)

#define IRowsetChangeExtInfo_GetPendingColumns(This,hReserved,hRow,cColumnOrdinals,rgiOrdinals,rgColumnStatus)	\
    (This)->lpVtbl -> GetPendingColumns(This,hReserved,hRow,cColumnOrdinals,rgiOrdinals,rgColumnStatus)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRowsetChangeExtInfo_GetOriginalRow_Proxy( 
    IRowsetChangeExtInfo __RPC_FAR * This,
    /* [in] */ HCHAPTER hReserved,
    /* [in] */ HROW hRow,
    /* [out] */ HROW __RPC_FAR *phRowOriginal);


void __RPC_STUB IRowsetChangeExtInfo_GetOriginalRow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRowsetChangeExtInfo_GetPendingColumns_Proxy( 
    IRowsetChangeExtInfo __RPC_FAR * This,
    /* [in] */ HCHAPTER hReserved,
    /* [in] */ HROW hRow,
    /* [in] */ ULONG cColumnOrdinals,
    /* [size_is][in] */ const ULONG __RPC_FAR rgiOrdinals[  ],
    /* [size_is][out] */ DBPENDINGSTATUS __RPC_FAR rgColumnStatus[  ]);


void __RPC_STUB IRowsetChangeExtInfo_GetPendingColumns_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRowsetChangeExtInfo_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.00.44 */
/* at Sun May 11 15:03:47 1997
 */
/* Compiler settings for KAGDIAG.IDL:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __KAGDIAG_H__
#define __KAGDIAG_H__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ISQLRequestDiagFields_FWD_DEFINED__
#define __ISQLRequestDiagFields_FWD_DEFINED__
typedef interface ISQLRequestDiagFields ISQLRequestDiagFields;
#endif 	/* __ISQLRequestDiagFields_FWD_DEFINED__ */


#ifndef __ISQLGetDiagField_FWD_DEFINED__
#define __ISQLGetDiagField_FWD_DEFINED__
typedef interface ISQLGetDiagField ISQLGetDiagField;
#endif 	/* __ISQLGetDiagField_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Sun May 11 15:03:47 1997
 * using MIDL 3.00.44
 ****************************************/
/* [local] */ 



enum KAGREQDIAGFLAGSENUM
    {	KAGREQDIAGFLAGS_HEADER	= 0x1,
	KAGREQDIAGFLAGS_RECORD	= 0x2
    };
// the structure passed in in IRequestDiagFields::RequestDiagFields
typedef struct  tagKAGREQDIAG
    {
    ULONG ulDiagFlags;
    VARTYPE vt;
    SHORT sDiagField;
    }	KAGREQDIAG;

// the structure passed in in IGetDiagField::GetDiagField
typedef struct  tagKAGGETDIAG
    {
    ULONG ulSize;
    VARIANTARG vDiagInfo;
    SHORT sDiagField;
    }	KAGGETDIAG;



extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

#ifndef __ISQLRequestDiagFields_INTERFACE_DEFINED__
#define __ISQLRequestDiagFields_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISQLRequestDiagFields
 * at Sun May 11 15:03:47 1997
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid] */ 



EXTERN_C const IID IID_ISQLRequestDiagFields;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ISQLRequestDiagFields : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RequestDiagFields( 
            /* [in] */ ULONG cDiagFields,
            /* [size_is][in] */ KAGREQDIAG __RPC_FAR rgDiagFields[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISQLRequestDiagFieldsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISQLRequestDiagFields __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISQLRequestDiagFields __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISQLRequestDiagFields __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RequestDiagFields )( 
            ISQLRequestDiagFields __RPC_FAR * This,
            /* [in] */ ULONG cDiagFields,
            /* [size_is][in] */ KAGREQDIAG __RPC_FAR rgDiagFields[  ]);
        
        END_INTERFACE
    } ISQLRequestDiagFieldsVtbl;

    interface ISQLRequestDiagFields
    {
        CONST_VTBL struct ISQLRequestDiagFieldsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISQLRequestDiagFields_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISQLRequestDiagFields_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISQLRequestDiagFields_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISQLRequestDiagFields_RequestDiagFields(This,cDiagFields,rgDiagFields)	\
    (This)->lpVtbl -> RequestDiagFields(This,cDiagFields,rgDiagFields)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISQLRequestDiagFields_RequestDiagFields_Proxy( 
    ISQLRequestDiagFields __RPC_FAR * This,
    /* [in] */ ULONG cDiagFields,
    /* [size_is][in] */ KAGREQDIAG __RPC_FAR rgDiagFields[  ]);


void __RPC_STUB ISQLRequestDiagFields_RequestDiagFields_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISQLRequestDiagFields_INTERFACE_DEFINED__ */


#ifndef __ISQLGetDiagField_INTERFACE_DEFINED__
#define __ISQLGetDiagField_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISQLGetDiagField
 * at Sun May 11 15:03:47 1997
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid] */ 



EXTERN_C const IID IID_ISQLGetDiagField;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ISQLGetDiagField : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDiagField( 
            /* [unique][out][in] */ KAGGETDIAG __RPC_FAR *pDiagInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISQLGetDiagFieldVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISQLGetDiagField __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISQLGetDiagField __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISQLGetDiagField __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDiagField )( 
            ISQLGetDiagField __RPC_FAR * This,
            /* [unique][out][in] */ KAGGETDIAG __RPC_FAR *pDiagInfo);
        
        END_INTERFACE
    } ISQLGetDiagFieldVtbl;

    interface ISQLGetDiagField
    {
        CONST_VTBL struct ISQLGetDiagFieldVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISQLGetDiagField_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISQLGetDiagField_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISQLGetDiagField_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISQLGetDiagField_GetDiagField(This,pDiagInfo)	\
    (This)->lpVtbl -> GetDiagField(This,pDiagInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISQLGetDiagField_GetDiagField_Proxy( 
    ISQLGetDiagField __RPC_FAR * This,
    /* [unique][out][in] */ KAGGETDIAG __RPC_FAR *pDiagInfo);


void __RPC_STUB ISQLGetDiagField_GetDiagField_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISQLGetDiagField_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif

#endif
//----
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\nt\tripldes.h ===
#ifndef __TRIPLDES_H__
#define __TRIPLDES_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _DES3TABLE {
    DESTable    keytab1;
    DESTable    keytab2;
    DESTable    keytab3;
} DES3TABLE, *PDES3TABLE;

#define DES3_TABLESIZE  sizeof(DES3TABLE)
#define DES2_KEYSIZE    16
#define DES3_KEYSIZE    24

//   tripledes2key:
//
//   Fill in the DES3Table structs with the decrypt and encrypt
//   key expansions.
//
//   Assumes that the second parameter points to 2 * DES_BLOCKLEN
//   bytes of key.
//
//

void RSA32API tripledes2key(PDES3TABLE pDES3Table, BYTE *pbKey);

//   tripledes3key:
//
//   Fill in the DES3Table structs with the decrypt and encrypt
//   key expansions.
//
//   Assumes that the second parameter points to 3 * DES_BLOCKLEN
//   bytes of key.
//
//

void RSA32API tripledes3key(PDES3TABLE pDES3Table, BYTE *pbKey);

//
//   Encrypt or decrypt with the key in pKey (DES3Table)
//

void RSA32API tripledes(BYTE *pbOut, BYTE *pbIn, void *pKey, int op);

extern int Asmversion;  /* 1 if we're linked with an asm version, 0 if C */

#ifdef __cplusplus
}
#endif

#endif // __TRIPLDES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\wml\wmlkm.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    wmlkm.h

Abstract:

    Kernel mode definitions for an easy wmi tracing.

Author:

    gorn

Revision History:

Comments:

    Needs to be moved to wmilib\inc when DCR is approved

--*/
#ifndef WMLKM_H
#define WMLKM_H 1

#pragma warning(disable: 4201) // error C4201: nonstandard extension used : nameless struct/union
#include <wmistr.h>
#include <evntrace.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _WML_CONTROL_GUID_REG {
    GUID        Guid;
    union {
        struct {
            ULONG EnableFlags;
            ULONG EnableLevel;
        };
        UINT64 EnableFlags64;
    };
    TRACEHANDLE LoggerHandle;
} WML_CONTROL_GUID_REG, *PWML_CONTROL_GUID_REG;

typedef struct _WML_TINY_INFO {
    PWML_CONTROL_GUID_REG    ControlGuids;
    ULONG                    GuidCount;
    PDEVICE_OBJECT           LowerDeviceObject;
    PUNICODE_STRING          DriverRegPath;
} WML_TINY_INFO, *PWML_TINY_INFO;


NTSTATUS
WmlTinySystemControl(
    IN OUT PWML_TINY_INFO WmiLibInfo,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

ULONG
WmlTrace(
    IN ULONG Type,
    IN LPCGUID TraceGuid,
    IN TRACEHANDLE LoggerHandle,
    ... // Pairs: Length, Address
    );

#ifdef __cplusplus
};
#endif

#endif // WMLKM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\vc6\msdasc.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Thu Jun 11 15:52:14 1998
 */
/* Compiler settings for Source\MSDASC.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __MSDASC_h__
#define __MSDASC_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IService_FWD_DEFINED__
#define __IService_FWD_DEFINED__
typedef interface IService IService;
#endif 	/* __IService_FWD_DEFINED__ */


#ifndef __IDBPromptInitialize_FWD_DEFINED__
#define __IDBPromptInitialize_FWD_DEFINED__
typedef interface IDBPromptInitialize IDBPromptInitialize;
#endif 	/* __IDBPromptInitialize_FWD_DEFINED__ */


#ifndef __IDataInitialize_FWD_DEFINED__
#define __IDataInitialize_FWD_DEFINED__
typedef interface IDataInitialize IDataInitialize;
#endif 	/* __IDataInitialize_FWD_DEFINED__ */


#ifndef __IDataSourceLocator_FWD_DEFINED__
#define __IDataSourceLocator_FWD_DEFINED__
typedef interface IDataSourceLocator IDataSourceLocator;
#endif 	/* __IDataSourceLocator_FWD_DEFINED__ */


#ifndef __DataLinks_FWD_DEFINED__
#define __DataLinks_FWD_DEFINED__

#ifdef __cplusplus
typedef class DataLinks DataLinks;
#else
typedef struct DataLinks DataLinks;
#endif /* __cplusplus */

#endif 	/* __DataLinks_FWD_DEFINED__ */


#ifndef __MSDAINITIALIZE_FWD_DEFINED__
#define __MSDAINITIALIZE_FWD_DEFINED__

#ifdef __cplusplus
typedef class MSDAINITIALIZE MSDAINITIALIZE;
#else
typedef struct MSDAINITIALIZE MSDAINITIALIZE;
#endif /* __cplusplus */

#endif 	/* __MSDAINITIALIZE_FWD_DEFINED__ */


#ifndef __PDPO_FWD_DEFINED__
#define __PDPO_FWD_DEFINED__

#ifdef __cplusplus
typedef class PDPO PDPO;
#else
typedef struct PDPO PDPO;
#endif /* __cplusplus */

#endif 	/* __PDPO_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "oledb.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IService_INTERFACE_DEFINED__
#define __IService_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IService
 * at Thu Jun 11 15:52:14 1998
 * using MIDL 3.01.75
 ****************************************/
/* [object][unique][helpstring][uuid] */ 



EXTERN_C const IID IID_IService;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("06210E88-01F5-11D1-B512-0080C781C384")
    IService : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE InvokeService( 
            /* [in] */ IUnknown __RPC_FAR *pUnkInner) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IServiceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IService __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IService __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IService __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InvokeService )( 
            IService __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pUnkInner);
        
        END_INTERFACE
    } IServiceVtbl;

    interface IService
    {
        CONST_VTBL struct IServiceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IService_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IService_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IService_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IService_InvokeService(This,pUnkInner)	\
    (This)->lpVtbl -> InvokeService(This,pUnkInner)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [local] */ HRESULT STDMETHODCALLTYPE IService_InvokeService_Proxy( 
    IService __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pUnkInner);


void __RPC_STUB IService_InvokeService_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IService_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_MSDASC_0149
 * at Thu Jun 11 15:52:14 1998
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 


typedef DWORD DBPROMPTOPTIONS;

typedef 
enum tagDBPROMPTOPTIONSENUM
    {	DBPROMPTOPTIONS_NONE	= 0,
	DBPROMPTOPTIONS_WIZARDSHEET	= 0x1,
	DBPROMPTOPTIONS_PROPERTYSHEET	= 0x2,
	DBPROMPTOPTIONS_BROWSEONLY	= 0x8,
	DBPROMPTOPTIONS_DISABLE_PROVIDER_SELECTION	= 0x10
    }	DBPROMPTOPTIONSENUM;



extern RPC_IF_HANDLE __MIDL_itf_MSDASC_0149_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_MSDASC_0149_v0_0_s_ifspec;

#ifndef __IDBPromptInitialize_INTERFACE_DEFINED__
#define __IDBPromptInitialize_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDBPromptInitialize
 * at Thu Jun 11 15:52:14 1998
 * using MIDL 3.01.75
 ****************************************/
/* [restricted][local][unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IDBPromptInitialize;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("2206CCB0-19C1-11D1-89E0-00C04FD7A829")
    IDBPromptInitialize : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE PromptDataSource( 
            /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ HWND hWndParent,
            /* [in] */ DBPROMPTOPTIONS dwPromptOptions,
            /* [in] */ ULONG cSourceTypeFilter,
            /* [size_is][in] */ DBSOURCETYPE __RPC_FAR *rgSourceTypeFilter,
            /* [in] */ LPCOLESTR pwszszzProviderFilter,
            /* [in] */ REFIID riid,
            /* [iid_is][out][in] */ IUnknown __RPC_FAR *__RPC_FAR *ppDataSource) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE PromptFileName( 
            /* [in] */ HWND hWndParent,
            /* [in] */ DBPROMPTOPTIONS dwPromptOptions,
            /* [in] */ LPCOLESTR pwszInitialDirectory,
            /* [in] */ LPCOLESTR pwszInitialFile,
            /* [out] */ LPOLESTR __RPC_FAR *ppwszSelectedFile) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDBPromptInitializeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDBPromptInitialize __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDBPromptInitialize __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDBPromptInitialize __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PromptDataSource )( 
            IDBPromptInitialize __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ HWND hWndParent,
            /* [in] */ DBPROMPTOPTIONS dwPromptOptions,
            /* [in] */ ULONG cSourceTypeFilter,
            /* [size_is][in] */ DBSOURCETYPE __RPC_FAR *rgSourceTypeFilter,
            /* [in] */ LPCOLESTR pwszszzProviderFilter,
            /* [in] */ REFIID riid,
            /* [iid_is][out][in] */ IUnknown __RPC_FAR *__RPC_FAR *ppDataSource);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PromptFileName )( 
            IDBPromptInitialize __RPC_FAR * This,
            /* [in] */ HWND hWndParent,
            /* [in] */ DBPROMPTOPTIONS dwPromptOptions,
            /* [in] */ LPCOLESTR pwszInitialDirectory,
            /* [in] */ LPCOLESTR pwszInitialFile,
            /* [out] */ LPOLESTR __RPC_FAR *ppwszSelectedFile);
        
        END_INTERFACE
    } IDBPromptInitializeVtbl;

    interface IDBPromptInitialize
    {
        CONST_VTBL struct IDBPromptInitializeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDBPromptInitialize_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDBPromptInitialize_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDBPromptInitialize_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDBPromptInitialize_PromptDataSource(This,pUnkOuter,hWndParent,dwPromptOptions,cSourceTypeFilter,rgSourceTypeFilter,pwszszzProviderFilter,riid,ppDataSource)	\
    (This)->lpVtbl -> PromptDataSource(This,pUnkOuter,hWndParent,dwPromptOptions,cSourceTypeFilter,rgSourceTypeFilter,pwszszzProviderFilter,riid,ppDataSource)

#define IDBPromptInitialize_PromptFileName(This,hWndParent,dwPromptOptions,pwszInitialDirectory,pwszInitialFile,ppwszSelectedFile)	\
    (This)->lpVtbl -> PromptFileName(This,hWndParent,dwPromptOptions,pwszInitialDirectory,pwszInitialFile,ppwszSelectedFile)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDBPromptInitialize_PromptDataSource_Proxy( 
    IDBPromptInitialize __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
    /* [in] */ HWND hWndParent,
    /* [in] */ DBPROMPTOPTIONS dwPromptOptions,
    /* [in] */ ULONG cSourceTypeFilter,
    /* [size_is][in] */ DBSOURCETYPE __RPC_FAR *rgSourceTypeFilter,
    /* [in] */ LPCOLESTR pwszszzProviderFilter,
    /* [in] */ REFIID riid,
    /* [iid_is][out][in] */ IUnknown __RPC_FAR *__RPC_FAR *ppDataSource);


void __RPC_STUB IDBPromptInitialize_PromptDataSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDBPromptInitialize_PromptFileName_Proxy( 
    IDBPromptInitialize __RPC_FAR * This,
    /* [in] */ HWND hWndParent,
    /* [in] */ DBPROMPTOPTIONS dwPromptOptions,
    /* [in] */ LPCOLESTR pwszInitialDirectory,
    /* [in] */ LPCOLESTR pwszInitialFile,
    /* [out] */ LPOLESTR __RPC_FAR *ppwszSelectedFile);


void __RPC_STUB IDBPromptInitialize_PromptFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDBPromptInitialize_INTERFACE_DEFINED__ */


#ifndef __IDataInitialize_INTERFACE_DEFINED__
#define __IDataInitialize_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDataInitialize
 * at Thu Jun 11 15:52:14 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IDataInitialize;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("2206CCB1-19C1-11D1-89E0-00C04FD7A829")
    IDataInitialize : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDataSource( 
            /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ DWORD dwClsCtx,
            /* [unique][in] */ LPCOLESTR pwszInitializationString,
            /* [in] */ REFIID riid,
            /* [iid_is][out][in] */ IUnknown __RPC_FAR *__RPC_FAR *ppDataSource) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetInitializationString( 
            /* [in] */ IUnknown __RPC_FAR *pDataSource,
            /* [in] */ boolean fIncludePassword,
            /* [out] */ LPOLESTR __RPC_FAR *ppwszInitString) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateDBInstance( 
            /* [in] */ REFCLSID clsidProvider,
            /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ DWORD dwClsCtx,
            /* [unique][in] */ LPOLESTR pwszReserved,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppDataSource) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateDBInstanceEx( 
            /* [in] */ REFCLSID clsidProvider,
            /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ DWORD dwClsCtx,
            /* [unique][in] */ LPOLESTR pwszReserved,
            /* [unique][in] */ COSERVERINFO __RPC_FAR *pServerInfo,
            /* [in] */ ULONG cmq,
            /* [size_is][out][in] */ MULTI_QI __RPC_FAR *rgmqResults) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE LoadStringFromStorage( 
            /* [unique][in] */ LPCOLESTR pwszFileName,
            /* [out] */ LPOLESTR __RPC_FAR *ppwszInitializationString) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE WriteStringToStorage( 
            /* [unique][in] */ LPCOLESTR pwszFileName,
            /* [unique][in] */ LPCOLESTR pwszInitializationString,
            /* [in] */ DWORD dwCreationDisposition) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDataInitializeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDataInitialize __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDataInitialize __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDataInitialize __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDataSource )( 
            IDataInitialize __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ DWORD dwClsCtx,
            /* [unique][in] */ LPCOLESTR pwszInitializationString,
            /* [in] */ REFIID riid,
            /* [iid_is][out][in] */ IUnknown __RPC_FAR *__RPC_FAR *ppDataSource);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInitializationString )( 
            IDataInitialize __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pDataSource,
            /* [in] */ boolean fIncludePassword,
            /* [out] */ LPOLESTR __RPC_FAR *ppwszInitString);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateDBInstance )( 
            IDataInitialize __RPC_FAR * This,
            /* [in] */ REFCLSID clsidProvider,
            /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ DWORD dwClsCtx,
            /* [unique][in] */ LPOLESTR pwszReserved,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppDataSource);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateDBInstanceEx )( 
            IDataInitialize __RPC_FAR * This,
            /* [in] */ REFCLSID clsidProvider,
            /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ DWORD dwClsCtx,
            /* [unique][in] */ LPOLESTR pwszReserved,
            /* [unique][in] */ COSERVERINFO __RPC_FAR *pServerInfo,
            /* [in] */ ULONG cmq,
            /* [size_is][out][in] */ MULTI_QI __RPC_FAR *rgmqResults);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadStringFromStorage )( 
            IDataInitialize __RPC_FAR * This,
            /* [unique][in] */ LPCOLESTR pwszFileName,
            /* [out] */ LPOLESTR __RPC_FAR *ppwszInitializationString);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WriteStringToStorage )( 
            IDataInitialize __RPC_FAR * This,
            /* [unique][in] */ LPCOLESTR pwszFileName,
            /* [unique][in] */ LPCOLESTR pwszInitializationString,
            /* [in] */ DWORD dwCreationDisposition);
        
        END_INTERFACE
    } IDataInitializeVtbl;

    interface IDataInitialize
    {
        CONST_VTBL struct IDataInitializeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDataInitialize_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDataInitialize_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDataInitialize_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDataInitialize_GetDataSource(This,pUnkOuter,dwClsCtx,pwszInitializationString,riid,ppDataSource)	\
    (This)->lpVtbl -> GetDataSource(This,pUnkOuter,dwClsCtx,pwszInitializationString,riid,ppDataSource)

#define IDataInitialize_GetInitializationString(This,pDataSource,fIncludePassword,ppwszInitString)	\
    (This)->lpVtbl -> GetInitializationString(This,pDataSource,fIncludePassword,ppwszInitString)

#define IDataInitialize_CreateDBInstance(This,clsidProvider,pUnkOuter,dwClsCtx,pwszReserved,riid,ppDataSource)	\
    (This)->lpVtbl -> CreateDBInstance(This,clsidProvider,pUnkOuter,dwClsCtx,pwszReserved,riid,ppDataSource)

#define IDataInitialize_CreateDBInstanceEx(This,clsidProvider,pUnkOuter,dwClsCtx,pwszReserved,pServerInfo,cmq,rgmqResults)	\
    (This)->lpVtbl -> CreateDBInstanceEx(This,clsidProvider,pUnkOuter,dwClsCtx,pwszReserved,pServerInfo,cmq,rgmqResults)

#define IDataInitialize_LoadStringFromStorage(This,pwszFileName,ppwszInitializationString)	\
    (This)->lpVtbl -> LoadStringFromStorage(This,pwszFileName,ppwszInitializationString)

#define IDataInitialize_WriteStringToStorage(This,pwszFileName,pwszInitializationString,dwCreationDisposition)	\
    (This)->lpVtbl -> WriteStringToStorage(This,pwszFileName,pwszInitializationString,dwCreationDisposition)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDataInitialize_GetDataSource_Proxy( 
    IDataInitialize __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
    /* [in] */ DWORD dwClsCtx,
    /* [unique][in] */ LPCOLESTR pwszInitializationString,
    /* [in] */ REFIID riid,
    /* [iid_is][out][in] */ IUnknown __RPC_FAR *__RPC_FAR *ppDataSource);


void __RPC_STUB IDataInitialize_GetDataSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDataInitialize_GetInitializationString_Proxy( 
    IDataInitialize __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pDataSource,
    /* [in] */ boolean fIncludePassword,
    /* [out] */ LPOLESTR __RPC_FAR *ppwszInitString);


void __RPC_STUB IDataInitialize_GetInitializationString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDataInitialize_CreateDBInstance_Proxy( 
    IDataInitialize __RPC_FAR * This,
    /* [in] */ REFCLSID clsidProvider,
    /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
    /* [in] */ DWORD dwClsCtx,
    /* [unique][in] */ LPOLESTR pwszReserved,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppDataSource);


void __RPC_STUB IDataInitialize_CreateDBInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDataInitialize_CreateDBInstanceEx_Proxy( 
    IDataInitialize __RPC_FAR * This,
    /* [in] */ REFCLSID clsidProvider,
    /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
    /* [in] */ DWORD dwClsCtx,
    /* [unique][in] */ LPOLESTR pwszReserved,
    /* [unique][in] */ COSERVERINFO __RPC_FAR *pServerInfo,
    /* [in] */ ULONG cmq,
    /* [size_is][out][in] */ MULTI_QI __RPC_FAR *rgmqResults);


void __RPC_STUB IDataInitialize_CreateDBInstanceEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDataInitialize_LoadStringFromStorage_Proxy( 
    IDataInitialize __RPC_FAR * This,
    /* [unique][in] */ LPCOLESTR pwszFileName,
    /* [out] */ LPOLESTR __RPC_FAR *ppwszInitializationString);


void __RPC_STUB IDataInitialize_LoadStringFromStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDataInitialize_WriteStringToStorage_Proxy( 
    IDataInitialize __RPC_FAR * This,
    /* [unique][in] */ LPCOLESTR pwszFileName,
    /* [unique][in] */ LPCOLESTR pwszInitializationString,
    /* [in] */ DWORD dwCreationDisposition);


void __RPC_STUB IDataInitialize_WriteStringToStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDataInitialize_INTERFACE_DEFINED__ */



#ifndef __MSDASC_LIBRARY_DEFINED__
#define __MSDASC_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: MSDASC
 * at Thu Jun 11 15:52:14 1998
 * using MIDL 3.01.75
 ****************************************/
/* [helpstring][version][uuid] */ 



EXTERN_C const IID LIBID_MSDASC;

#ifndef __IDataSourceLocator_INTERFACE_DEFINED__
#define __IDataSourceLocator_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDataSourceLocator
 * at Thu Jun 11 15:52:14 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_IDataSourceLocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("2206CCB2-19C1-11D1-89E0-00C04FD7A829")
    IDataSourceLocator : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_hWnd( 
            /* [retval][out] */ LONG __RPC_FAR *phwndParent) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_hWnd( 
            /* [in] */ LONG hwndParent) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE PromptNew( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppADOConnection) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE PromptEdit( 
            /* [out][in] */ IDispatch __RPC_FAR *__RPC_FAR *ppADOConnection,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbSuccess) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDataSourceLocatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDataSourceLocator __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDataSourceLocator __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDataSourceLocator __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDataSourceLocator __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDataSourceLocator __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDataSourceLocator __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDataSourceLocator __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_hWnd )( 
            IDataSourceLocator __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *phwndParent);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_hWnd )( 
            IDataSourceLocator __RPC_FAR * This,
            /* [in] */ LONG hwndParent);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PromptNew )( 
            IDataSourceLocator __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppADOConnection);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PromptEdit )( 
            IDataSourceLocator __RPC_FAR * This,
            /* [out][in] */ IDispatch __RPC_FAR *__RPC_FAR *ppADOConnection,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbSuccess);
        
        END_INTERFACE
    } IDataSourceLocatorVtbl;

    interface IDataSourceLocator
    {
        CONST_VTBL struct IDataSourceLocatorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDataSourceLocator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDataSourceLocator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDataSourceLocator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDataSourceLocator_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDataSourceLocator_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDataSourceLocator_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDataSourceLocator_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDataSourceLocator_get_hWnd(This,phwndParent)	\
    (This)->lpVtbl -> get_hWnd(This,phwndParent)

#define IDataSourceLocator_put_hWnd(This,hwndParent)	\
    (This)->lpVtbl -> put_hWnd(This,hwndParent)

#define IDataSourceLocator_PromptNew(This,ppADOConnection)	\
    (This)->lpVtbl -> PromptNew(This,ppADOConnection)

#define IDataSourceLocator_PromptEdit(This,ppADOConnection,pbSuccess)	\
    (This)->lpVtbl -> PromptEdit(This,ppADOConnection,pbSuccess)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDataSourceLocator_get_hWnd_Proxy( 
    IDataSourceLocator __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *phwndParent);


void __RPC_STUB IDataSourceLocator_get_hWnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IDataSourceLocator_put_hWnd_Proxy( 
    IDataSourceLocator __RPC_FAR * This,
    /* [in] */ LONG hwndParent);


void __RPC_STUB IDataSourceLocator_put_hWnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDataSourceLocator_PromptNew_Proxy( 
    IDataSourceLocator __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppADOConnection);


void __RPC_STUB IDataSourceLocator_PromptNew_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDataSourceLocator_PromptEdit_Proxy( 
    IDataSourceLocator __RPC_FAR * This,
    /* [out][in] */ IDispatch __RPC_FAR *__RPC_FAR *ppADOConnection,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbSuccess);


void __RPC_STUB IDataSourceLocator_PromptEdit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDataSourceLocator_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_DataLinks;

class DECLSPEC_UUID("2206CDB2-19C1-11D1-89E0-00C04FD7A829")
DataLinks;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_MSDAINITIALIZE;

class DECLSPEC_UUID("2206CDB0-19C1-11D1-89E0-00C04FD7A829")
MSDAINITIALIZE;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_PDPO;

class DECLSPEC_UUID("CCB4EC60-B9DC-11D1-AC80-00A0C9034873")
PDPO;
#endif
#endif /* __MSDASC_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\wml\wmlmacro.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    wmlmacro.h

Abstract:

    This file defines macro for an easy wmi tracing.

Author:

    gorn

Revision History:

--*/
#ifndef WMLMACRO_H
#define WMLMACRO_H 1

typedef struct {char x[418957];} WMILIBTYPE_STRING;

#undef  WMILIB_TYPEDEF
#define WMILIB_TYPEDEF(_TypeName, _EquivType, _FmtStr, _Func, _MofStr, _InitType) \
    typedef _EquivType WMILIBTYPE_ ## _TypeName ;
#include "wmltypes.inc"

typedef union _WMLLOCALSTRUCT {
    UCHAR    uchar;
    USHORT   ushort;
    ULONG    uint;
    WCHAR    wchar;
    LONGLONG longlong;
} WMLLOCALSTRUCT;

#define WMLLOCAL WMLLOCALSTRUCT _wmllocal


#define WMILIB_CHECKED_ZERO(_Value, _Type) \
    (0 * (1/(int)!(sizeof(_Type) - sizeof(_Value) )))

#define WMILIB_CHECKED_SIZEOF(_Value, _Type) \
    (sizeof(_Value) + WMILIB_CHECKED_ZERO( _Value, _Type) )

#define WMILIB_LOGPAIR(_a, _b) (_a),(_b),

#define WMILIB_LOGARGVALTYPE(_value, _type) \
            WMILIB_LOGPAIR(WMILIB_CHECKED_SIZEOF(_value, _type), &(_value) )

#define LOG(_TypeName, _Value)                         \
    WMILIB_LOGARGVALTYPE( _Value, WMILIBTYPE_ ## _TypeName)

#define LOGASTR(_value) \
    WMILIB_LOGPAIR( strlen(_value) + WMILIB_CHECKED_ZERO((_value)[0],CHAR), _value )

#define LOGWSTR(_value) \
    WMILIB_LOGPAIR( wcslen(_value) * sizeof(WCHAR) + WMILIB_CHECKED_ZERO((_value)[0],WCHAR), _value)

#define LOGCSTR(_x) \
    WMILIB_LOGPAIR( sizeof((_x).Length) + WMILIB_CHECKED_ZERO(_x,STRING), &(_x).Length ) \
    WMILIB_LOGPAIR( (_x).Length, (_x).Buffer )

#define LOGUSTR(_x)                                                            \
    WMILIB_LOGPAIR( sizeof((_x).Length)                                        \
                    + WMILIB_CHECKED_ZERO((_x),UNICODE_STRING), &(_x).Length)  \
    WMILIB_LOGPAIR( (_x).Length, (_x).Buffer )

#define LOGCHARARR(_count, _x)                                 \
    WMILIB_LOGARGVALTYPE( _wmllocal.ushort , USHORT )          \
    WMILIB_LOGPAIR( (_wmllocal.ushort = _count * sizeof(CHAR)) \
                    + WMILIB_CHECKED_ZERO((_x)[0], CHAR), _x ) 

#define LOGWCHARARR(_count, _x)                                 \
    WMILIB_LOGARGVALTYPE( _wmllocal.ushort , USHORT )           \
    WMILIB_LOGPAIR( (_wmllocal.ushort = _count * sizeof(WCHAR)) \
                    + WMILIB_CHECKED_ZERO((_x)[0], WCHAR), _x ) 

#define LOGTIME(_Value)    LOG(TIMENT,  _Value)
#define LOGPTR(_Value)     LOG(PTR,     _Value)
#define LOGHANDLE(_Value)  LOG(HANDLE,  _Value)
#define LOGSTATUS(_Value)  LOG(XINT,    _Value)
#define LOGBYTE(_Value)    LOG(UBYTE,   _Value)
#define LOGULONG(_Value)   LOG(UINT,    _Value)
#define LOGULONGLONG(_Value)   LOG(ULONGLONG,    _Value)
#define LOGXLONG(_Value)   LOG(XINT,    _Value)
#define LOGXSHORT(_Value)  LOG(XSHORT,  _Value)
#define LOGUSHORT(_Value)  LOG(USHORT,  _Value)
#define LOGUCHAR(_Value)   LOG(UCHAR,   _Value)
#define LOGUBYTE(_Value)   LOG(UCHAR,   _Value)
#define LOGIRQL(_Value)    LOG(UCHAR,   _Value)
#define LOGBOOL(_Value)    LOG(BOOL,    _Value)
#define LOGBOOLEAN(_Value) LOG(BOOLEAN, _Value)
#define LOGARSTR(_Value)   LOGASTR(_Value)
#define LOGPNPMN(_Value)   LOG(UCHAR,   _Value)
#define LOGIOCTL(_Value)   LOG(ULONG,   _Value)
#define LOGGUID(_Val)      LOG(GUID, _Val)
#define LOGSLONG(_Val)     LOG(SINT, _Val)
#define LOGTIMEDELTA(_Val) LOG(TIMEDELTA, _Val)
#define LOGWAITTIME(_Val)  LOG(WAITTIME, _Val)

// These better be defined elsewhere
//#define WML_FLAGS(_Val)  ( (ULONG) (_Val) )
//#define WML_STREAM(_Val) ( (ULONG) ((_Val) >> 32) )

#define WML_CONTROL(_prefix, _flags) \
            ( _prefix ## ControlGuids[ WML_STREAM(_flags) ] )
            
#define WML_TRACEGUID(_prefix, _id) \
            ( _prefix ## TraceGuids[ WML_GUID(_id) ] )
            
#define WML_ENABLED(_prefix, _flags) \
            ( WML_CONTROL(_prefix, _flags).EnableFlags & WML_FLAGS(_flags) )
            
#define WML_LOG(_prefix, _flags, _id, _arg) \
    do { \
        if ( WML_ENABLED(_prefix, _flags) ) { \
            WmlTrace( WML_ID(_id), \
                     &WML_TRACEGUID(_prefix, _id) , \
                      WML_CONTROL(_prefix, _flags).LoggerHandle, _arg); \
        } \
    } while (0)            


#endif // WMLMACRO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\wml\wmltypes.inc ===
//#define WMILIB_TYPEDEF(_TypeName, _EquivType, _FmtStr, _Func, _MofStr, _InitType)

#define WMILIB_SIMPLE_TYPE(_TypeName, _EquivType, _FmtStr, _MofStr) \
   WMILIB_TYPEDEF(_TypeName, _EquivType, _FmtStr, FormatSimple, _MofStr, WMILIB_ALIGNEDCOPY)
   
#define WMILIB_COMPLX_TYPE(_TypeName, _EquivType, _Func, _MofStr) \
   WMILIB_TYPEDEF(_TypeName, _EquivType, 0, _Func, _MofStr, WMILIB_ALIGNEDCOPY)

#define WMILIB_STRING_TYPE(_TypeName, _EquivType, _Func, _MofStr) \
   WMILIB_TYPEDEF(_TypeName, _EquivType, 0, _Func, _MofStr, WMILIB_ASIS)

WMILIB_SIMPLE_TYPE(UBYTE, char, "u",          ItemByte)
WMILIB_SIMPLE_TYPE(SBYTE, char, "d",          ItemSByte)
WMILIB_SIMPLE_TYPE(XBYTE, char, "X",          ItemXByte)
WMILIB_SIMPLE_TYPE(OBYTE, char, "02o",        ItemOByte)
WMILIB_COMPLX_TYPE(BBYTE, char, FormatBinary, ItemXByte)

WMILIB_SIMPLE_TYPE(USHORT, short, "u",          ItemUShort)
WMILIB_SIMPLE_TYPE(SSHORT, short, "d",          ItemShort)
WMILIB_SIMPLE_TYPE(XSHORT, short, "X",          ItemXShort)
WMILIB_SIMPLE_TYPE(OSHORT, short, "o",          ItemOShort)
WMILIB_COMPLX_TYPE(BSHORT, short, FormatBinary, ItemXShort)

WMILIB_SIMPLE_TYPE(UINT, int, "u",          ItemULong)
WMILIB_SIMPLE_TYPE(SINT, int, "s",          ItemLong)
WMILIB_SIMPLE_TYPE(XINT, int, "X",          ItemULongX)
WMILIB_SIMPLE_TYPE(OINT, int, "o",          ItemULong)
WMILIB_COMPLX_TYPE(BINT, int, FormatBinary, ItemULong)

WMILIB_SIMPLE_TYPE(HANDLE, HANDLE, "x",     ItemULong)

WMILIB_SIMPLE_TYPE(ULONGLONG, _int64, "u", ItemULongLong)
WMILIB_SIMPLE_TYPE(SLONGLONG, _int64, "s", ItemLongLong)
WMILIB_SIMPLE_TYPE(XLONGLONG, _int64, "X", ItemULongLongX)
WMILIB_SIMPLE_TYPE(OLONGLONG, _int64, "o", ItemULongLong)

WMILIB_SIMPLE_TYPE(PTR,        void*, "x", ItemXPointer)

WMILIB_SIMPLE_TYPE(BOOLEAN, char, "u", ItemListByte (FALSE,TRUE) )

WMILIB_SIMPLE_TYPE(UCHAR, CHAR,  "c", ItemUChar)
WMILIB_SIMPLE_TYPE(ACHAR, CHAR,  "c", ItemChar)
WMILIB_SIMPLE_TYPE(WCHAR, WCHAR, "c", ItemShortSign)

WMILIB_STRING_TYPE(ASTR, WMILIBTYPE_STRING, FormatMisc, ItemString)
WMILIB_STRING_TYPE(WSTR, WMILIBTYPE_STRING, FormatMisc, ItemWString)
WMILIB_STRING_TYPE(USTR, WMILIBTYPE_STRING, FormatMisc, ItemPString)

WMILIB_COMPLX_TYPE(DATE,     LARGE_INTEGER, FormatMisc, ItemDate)
WMILIB_COMPLX_TYPE(TIMENT,   LARGE_INTEGER, FormatMisc, ItemTime)
WMILIB_COMPLX_TYPE(DATETIME, LARGE_INTEGER, FormatMisc, ItemDateTime)
WMILIB_COMPLX_TYPE(MILLISEC, LARGE_INTEGER, FormatMisc, ItemMillisec)
WMILIB_COMPLX_TYPE(TIMEDELTA,LARGE_INTEGER, FormatMisc, ItemTimeDelta)
WMILIB_COMPLX_TYPE(WAITTIME, LARGE_INTEGER, FormatMisc, ItemWaitTime)
WMILIB_COMPLX_TYPE(ALETTER,  CHAR,          FormatMisc, ItemLetter)
WMILIB_COMPLX_TYPE(WLETTER,  WCHAR,         FormatMisc, ItemWLetter)
WMILIB_COMPLX_TYPE(GUID,     GUID,          FormatMisc, ItemGuid)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\passportmanager\admin.cpp ===
// Admin.cpp : Implementation of CAdmin
#include "stdafx.h"
#include "Passport.h"
#include "Admin.h"
#include "keycrypto.h"
#include <time.h>

#define TOHEX(n) ((n >= 10) ? (('A' - 10) + n) : ('0' + n))

/////////////////////////////////////////////////////////////////////////////
// CAdmin

STDMETHODIMP CAdmin::InterfaceSupportsErrorInfo(REFIID riid)
{
  static const IID* arr[] = 
  {
    &IID_IPassportAdmin,
  };
  for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
    {
      if (InlineIsEqualGUID(*arr[i],riid))
	return S_OK;
    }
  return S_FALSE;
}


STDMETHODIMP CAdmin::get_IsValid(VARIANT_BOOL *pVal)
{
  *pVal =  g_config->isValid() ? VARIANT_TRUE : VARIANT_FALSE;
  return S_OK;
}

STDMETHODIMP CAdmin::get_ErrorDescription(BSTR *pVal)
{
  if (g_config->isValid())
    *pVal = SysAllocString(L"Passport Object OK");
  else
    *pVal = SysAllocString(g_config->getFailureString());
  return S_OK;
}

STDMETHODIMP CAdmin::addKey(BSTR keyMaterial, int version, long expires, VARIANT_BOOL *ok)
{
  HRESULT hr = S_OK;
  *ok = VARIANT_FALSE;

  // Must be the appropriate length
  if (SysStringLen(keyMaterial) != 24)
  {
    AtlReportError(CLSID_Admin, 
      L"Key must be 24 characters", IID_IPassportAdmin, E_FAIL);
    return E_FAIL;
  }

  // Must be the appropriate length
  if (version >= 16)
  {
    AtlReportError(CLSID_Admin, 
      L"Key version must be <16", IID_IPassportAdmin, E_FAIL);
    return E_FAIL;
  }

  BYTE      original[CKeyCrypto::RAWKEY_SIZE];
  DATA_BLOB iBlob;
  iBlob.cbData = sizeof(original);
  iBlob.pbData = &(original[0]);

  for (int i = 0; i < CKeyCrypto::RAWKEY_SIZE; i++)
    original[i] = static_cast<BYTE>(keyMaterial[i] & 0xFF);

  // Try to encrypt it
  CKeyCrypto   kc;
  DATA_BLOB    oBlob;
  ZeroMemory(&oBlob, sizeof(oBlob));

  if (kc.encryptKey(&iBlob, &oBlob) != S_OK)
  {
    AtlReportError(CLSID_Admin, 
      L"Failed to encrypt key, couldn't find valid network card?", IID_IPassportAdmin, E_FAIL);
    return E_FAIL;
  }

  // Now add it to registry
  LONG   lResult;
  LPSTR szKeyData = "SOFTWARE\\Microsoft\\Passport\\KeyData";
  LPSTR szKeyTimes= "SOFTWARE\\Microsoft\\Passport\\KeyTimes";
  HKEY   hkDataKey = NULL, hkTimeKey = NULL;
  char  szKeyNum[2];

  szKeyNum[0] = TOHEX(version);
  szKeyNum[1] = '\0';

  lResult = RegOpenKeyExA(HKEY_LOCAL_MACHINE, szKeyData, 0,
			 KEY_WRITE, &hkDataKey);
  if(lResult != ERROR_SUCCESS)
    {
      AtlReportError(CLSID_Admin, 
        L"Couldn't find KeyData key in registry.  Reinstall Passport.", IID_IPassportAdmin, E_FAIL);
      hr = E_FAIL;
      goto Cleanup;
    }
  lResult = RegOpenKeyExA(HKEY_LOCAL_MACHINE, szKeyTimes, 0,
    KEY_WRITE, &hkTimeKey);
  if(lResult != ERROR_SUCCESS)
    {
      AtlReportError(CLSID_Admin, 
        L"Couldn't find KeyTimes key in registry.  Reinstall Passport.", IID_IPassportAdmin, E_FAIL);
      hr = E_FAIL;
      goto Cleanup;
    }

  lResult = RegSetValueExA(hkDataKey, szKeyNum, 0,
      REG_BINARY, oBlob.pbData, oBlob.cbData);
  if(lResult != ERROR_SUCCESS)
    {
      AtlReportError(CLSID_Admin, 
        L"Couldn't write KeyData key to registry.", IID_IPassportAdmin, E_FAIL);
      hr = E_FAIL;
      goto Cleanup;
    }

  if (expires != 0)
  {
    DWORD dwTime = expires;
    lResult = RegSetValueExA(hkTimeKey, szKeyNum, 0,
      REG_DWORD, (LPBYTE) &dwTime, sizeof(DWORD));
    if(lResult != ERROR_SUCCESS)
      {
        AtlReportError(CLSID_Admin, 
          L"Couldn't write KeyTime value to registry.", IID_IPassportAdmin, E_FAIL);
        hr = E_FAIL;
        goto Cleanup;
      }
  }
  else
  {
    RegDeleteValueA(hkTimeKey, szKeyNum);
  }

  *ok = VARIANT_TRUE;
Cleanup:
  if (hkDataKey)
    RegCloseKey(hkDataKey);
  if (hkTimeKey)
    RegCloseKey(hkTimeKey);

  if(oBlob.pbData)
    LocalFree(oBlob.pbData);

  if (*ok == VARIANT_TRUE)
    {
      if (g_pAlert)
	g_pAlert->report(PassportAlertInterface::INFORMATION_TYPE,
			 PM_NEWKEY_INSTALLED);

    }

  return hr;
}

STDMETHODIMP CAdmin::addKeyEx(BSTR keyMaterial, int version, long expires, VARIANT vSiteName, VARIANT_BOOL *ok)
{
  HRESULT       hr = S_OK;
  LPSTR         szSiteName;
  LONG          lResult;
  HKEY          hkDataKey = NULL, hkTimeKey = NULL;
  HKEY          hkSites = NULL, hkPassport = NULL;
  char          szKeyNum[2];

  BYTE         original[CKeyCrypto::RAWKEY_SIZE];
  DATA_BLOB    iBlob;
  DATA_BLOB    oBlob;
  CKeyCrypto   kc;
  
  int i;

  *ok = VARIANT_FALSE;
  
  USES_CONVERSION;

  // Must be the appropriate length
  if (SysStringLen(keyMaterial) != 24)
  {
    AtlReportError(CLSID_Admin, 
      L"Key must be 24 characters", IID_IPassportAdminEx, E_FAIL);
    return E_FAIL;
  }

  // Must be the appropriate length
  if (version >= 16)
  {
    AtlReportError(CLSID_Admin, 
      L"Key version must be <16", IID_IPassportAdminEx, E_FAIL);
    return E_FAIL;
  }

  if(vSiteName.vt == VT_ERROR && vSiteName.scode == DISP_E_PARAMNOTFOUND)
      szSiteName = NULL;
  else if(vSiteName.vt == VT_BSTR)
      szSiteName = W2A(vSiteName.bstrVal);
  else
  {
      hr = E_INVALIDARG;
      goto Cleanup;
  }

  for (i = 0; i < CKeyCrypto::RAWKEY_SIZE; i++)
    original[i] = static_cast<BYTE>(keyMaterial[i] & 0xFF);

  iBlob.cbData = sizeof(original);
  iBlob.pbData = &(original[0]);

  // Try to encrypt it 
  ZeroMemory(&oBlob, sizeof(oBlob));
  if (kc.encryptKey(&iBlob, &oBlob) != S_OK)
  {
    AtlReportError(CLSID_Admin, 
                  L"Failed to encrypt key, couldn't find valid network card?", 
                  IID_IPassportAdminEx, 
                  E_FAIL);
    return E_FAIL;
  }

  // Get the root key.
  if(szSiteName)
  {
      lResult = RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                              "SOFTWARE\\Microsoft\\Passport\\Sites",
                              0,
                              KEY_ALL_ACCESS,
                              &hkSites);
      if(lResult != ERROR_SUCCESS)
      {
          AtlReportError(CLSID_Admin, 
                        L"Site not found.  Please add the site before installing the key.", 
                        IID_IPassportAdminEx, 
                        PP_E_SITE_NOT_EXISTS);
          hr = PP_E_SITE_NOT_EXISTS;
          goto Cleanup;
      }

      lResult = RegOpenKeyExA(hkSites,
                              szSiteName,
                              0,
                              KEY_ALL_ACCESS,
                              &hkPassport);
      if(lResult != ERROR_SUCCESS)
      {
          AtlReportError(CLSID_Admin, 
                        L"Site not found.  Please add the site before installing the key.", 
                        IID_IPassportAdminEx, 
                        PP_E_SITE_NOT_EXISTS);
          hr = PP_E_SITE_NOT_EXISTS;
          goto Cleanup;
      }
  }
  else
  {
      lResult = RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                              "SOFTWARE\\Microsoft\\Passport",
                              0,
                              KEY_ALL_ACCESS,
                              &hkPassport);
      if(lResult != ERROR_SUCCESS)
      {
          AtlReportError(CLSID_Admin, 
                        L"Couldn't find Passport key in registry.  Reinstall Passport.", 
                        IID_IPassportAdminEx, 
                        E_FAIL);
          hr = E_FAIL;
          goto Cleanup;
      }
  }
  // Now add it to registry

  szKeyNum[0] = TOHEX(version);
  szKeyNum[1] = '\0';

  lResult = RegOpenKeyExA(hkPassport, "KeyData", 0,
			              KEY_WRITE, &hkDataKey);
  if(lResult != ERROR_SUCCESS)
    {
      AtlReportError(CLSID_Admin, 
        L"Couldn't find KeyData key in registry.  Reinstall Passport.", IID_IPassportAdminEx, E_FAIL);
      hr = E_FAIL;
      goto Cleanup;
    }
  lResult = RegOpenKeyExA(hkPassport, "KeyTimes", 0,
                          KEY_WRITE, &hkTimeKey);
  if(lResult != ERROR_SUCCESS)
    {
      AtlReportError(CLSID_Admin, 
        L"Couldn't find KeyTimes key in registry.  Reinstall Passport.", IID_IPassportAdminEx, E_FAIL);
      hr = E_FAIL;
      goto Cleanup;
    }

  lResult = RegSetValueExA(hkDataKey, szKeyNum, 0,
      REG_BINARY, oBlob.pbData, oBlob.cbData);
  if(lResult != ERROR_SUCCESS)
    {
      AtlReportError(CLSID_Admin, 
        L"Couldn't write KeyData key to registry.", IID_IPassportAdminEx, E_FAIL);
      hr = E_FAIL;
      goto Cleanup;
    }

  if (expires != 0)
  {
    DWORD dwTime = expires;
    lResult = RegSetValueExA(hkTimeKey, szKeyNum, 0,
      REG_DWORD, (LPBYTE) &dwTime, sizeof(DWORD));
    if(lResult != ERROR_SUCCESS)
      {
        AtlReportError(CLSID_Admin, 
          L"Couldn't write KeyTime value to registry.", IID_IPassportAdminEx, E_FAIL);
        hr = E_FAIL;
        goto Cleanup;
      }
  }
  else
  {
    RegDeleteValueA(hkTimeKey, szKeyNum);
  }

  *ok = VARIANT_TRUE;
Cleanup:
  if (hkPassport)
    RegCloseKey(hkPassport);
  if (hkDataKey)
    RegCloseKey(hkDataKey);
  if (hkTimeKey)
    RegCloseKey(hkTimeKey);

  if (oBlob.pbData)
    ::LocalFree(oBlob.pbData);

  if (*ok == VARIANT_TRUE)
    {
      if (g_pAlert)
        	g_pAlert->report(PassportAlertInterface::INFORMATION_TYPE,
		                	 PM_NEWKEY_INSTALLED);

    }

  return hr;
}


STDMETHODIMP CAdmin::deleteKey(int version)
{
  HRESULT hr = S_OK, lResult;
  LPSTR szKeyData = "SOFTWARE\\Microsoft\\Passport\\KeyData";
  LPSTR szKeyTimes= "SOFTWARE\\Microsoft\\Passport\\KeyTimes";
  HKEY  hkDataKey = NULL, hkTimeKey = NULL;
  char  szKeyNum[2];

  lResult = RegOpenKeyExA(HKEY_LOCAL_MACHINE, szKeyData, 0,
			  KEY_WRITE, &hkDataKey);
  if(lResult != ERROR_SUCCESS)
    {
      AtlReportError(CLSID_Admin, 
		     L"Couldn't find KeyData key in registry.  Reinstall Passport.", IID_IPassportAdmin, E_FAIL);
      hr = E_FAIL;
      goto Cleanup;
    }
  lResult = RegOpenKeyExA(HKEY_LOCAL_MACHINE, szKeyTimes, 0,
			  KEY_WRITE, &hkTimeKey);
  if(lResult != ERROR_SUCCESS)
    {
      AtlReportError(CLSID_Admin, 
		     L"Couldn't find KeyTimes key in registry.  Reinstall Passport.", IID_IPassportAdmin, E_FAIL);
      hr = E_FAIL;
      goto Cleanup;
    }

  szKeyNum[0] = TOHEX(version);
  szKeyNum[1] = '\0';

  RegDeleteValueA(hkTimeKey, szKeyNum);
  RegDeleteValueA(hkDataKey, szKeyNum);

 Cleanup:
  if (hkDataKey)
    RegCloseKey(hkDataKey);
  if (hkTimeKey)
    RegCloseKey(hkTimeKey);
  return hr;
}

STDMETHODIMP CAdmin::deleteKeyEx(
    int     version,
    VARIANT vSiteName
    )
{
  HRESULT hr = S_OK, lResult;
  HKEY  hkDataKey = NULL, hkTimeKey = NULL;
  HKEY  hkPassport = NULL, hkSites = NULL;
  char  szKeyNum[2];
  LPSTR szSiteName;

  USES_CONVERSION;

  if(vSiteName.vt == VT_ERROR && vSiteName.scode == DISP_E_PARAMNOTFOUND)
      szSiteName = NULL;
  else if(vSiteName.vt == VT_BSTR)
      szSiteName = W2A(vSiteName.bstrVal);
  else
  {
      hr = E_INVALIDARG;
      goto Cleanup;
  }

  if(szSiteName)
  {
      lResult = RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                              "Software\\Microsoft\\Passport\\Sites",
                              0,
                              KEY_ALL_ACCESS,
                              &hkSites);
      if(lResult != ERROR_SUCCESS)
      {
          AtlReportError(CLSID_Admin, 
		         L"Couldn't find Sites key in registry.  Reinstall Passport.", IID_IPassportAdminEx, 
                 PP_E_SITE_NOT_EXISTS);
          hr = PP_E_SITE_NOT_EXISTS;
          goto Cleanup;
      }

      lResult = RegOpenKeyExA(hkSites,
                              szSiteName,
                              0,
                              KEY_ALL_ACCESS,
                              &hkPassport);
      if(lResult != ERROR_SUCCESS)
      {
          AtlReportError(CLSID_Admin, 
		         L"Couldn't find site key in registry.  Reinstall Passport.", IID_IPassportAdminEx, 
                 PP_E_SITE_NOT_EXISTS);
          hr = PP_E_SITE_NOT_EXISTS;
          goto Cleanup;
      }
  }
  else
  {
      lResult = RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                              "Software\\Microsoft\\Passport",
                              0,
                              KEY_ALL_ACCESS,
                              &hkPassport);
      if(lResult != ERROR_SUCCESS)
      {
          AtlReportError(CLSID_Admin, 
		         L"Couldn't find Passport key in registry.  Reinstall Passport.", IID_IPassportAdminEx, E_FAIL);
          hr = E_FAIL;
          goto Cleanup;
      }
  }

  lResult = RegOpenKeyExA(hkPassport, "KeyData", 0,
			              KEY_WRITE, &hkDataKey);
  if(lResult != ERROR_SUCCESS)
    {
      AtlReportError(CLSID_Admin, 
		     L"Couldn't find KeyData key in registry.  Reinstall Passport.", IID_IPassportAdminEx, E_FAIL);
      hr = E_FAIL;
      goto Cleanup;
    }
  lResult = RegOpenKeyExA(hkPassport, "KeyTimes", 0,
			              KEY_WRITE, &hkTimeKey);
  if(lResult != ERROR_SUCCESS)
    {
      AtlReportError(CLSID_Admin, 
		     L"Couldn't find KeyTimes key in registry.  Reinstall Passport.", IID_IPassportAdminEx, E_FAIL);
      hr = E_FAIL;
      goto Cleanup;
    }

  szKeyNum[0] = TOHEX(version);
  szKeyNum[1] = '\0';

  RegDeleteValueA(hkTimeKey, szKeyNum);
  RegDeleteValueA(hkDataKey, szKeyNum);

 Cleanup:
  if (hkPassport)
    RegCloseKey(hkPassport);
  if (hkSites)
    RegCloseKey(hkSites);
  if (hkDataKey)
    RegCloseKey(hkDataKey);
  if (hkTimeKey)
    RegCloseKey(hkTimeKey);
  return hr;
}

STDMETHODIMP CAdmin::setKeyTime(int version, int fromNow)
{
  HRESULT hr = S_OK, lResult;
  LPSTR szKeyTimes= "SOFTWARE\\Microsoft\\Passport\\KeyTimes";
  HKEY  hkDataKey = NULL, hkTimeKey = NULL;
  char  szKeyNum[2];

  lResult = RegOpenKeyExA(HKEY_LOCAL_MACHINE, szKeyTimes, 0,
			  KEY_WRITE, &hkTimeKey);
  if(lResult != ERROR_SUCCESS)
    {
      AtlReportError(CLSID_Admin, 
		     L"Couldn't find KeyTimes key in registry.  Reinstall Passport.", IID_IPassportAdmin, E_FAIL);
      hr = E_FAIL;
      goto Cleanup;
    }

  szKeyNum[0] = TOHEX(version);
  szKeyNum[1] = '\0';

  if (fromNow == 0)
    {
      RegDeleteValueA(hkTimeKey, szKeyNum);
    }
  else
    {
      time_t now;
      time(&now);
      now += fromNow;
      DWORD dwT = now;
      lResult = RegSetValueExA(hkTimeKey, szKeyNum, 0,
			       REG_DWORD, (LPBYTE) &dwT, sizeof(DWORD));
      if(lResult != ERROR_SUCCESS)
	{
	  AtlReportError(CLSID_Admin, 
			 L"Couldn't write KeyTime key to registry.", IID_IPassportAdmin, E_FAIL);
	  hr = E_FAIL;
	  goto Cleanup;
	}
    }


 Cleanup:
  if (hkTimeKey)
    RegCloseKey(hkTimeKey);
  return hr;
}

STDMETHODIMP CAdmin::setKeyTimeEx(
    int version, 
    int fromNow,
    VARIANT vSiteName
    )
{
  HRESULT hr = S_OK, lResult;
  LPSTR szSiteName;
  HKEY  hkDataKey = NULL, hkTimeKey = NULL;
  HKEY  hkSites = NULL, hkPassport = NULL;
  char  szKeyNum[2];

  USES_CONVERSION;

  if(vSiteName.vt == VT_ERROR && vSiteName.scode == DISP_E_PARAMNOTFOUND)
      szSiteName = NULL;
  else if(vSiteName.vt == VT_BSTR)
      szSiteName = W2A(vSiteName.bstrVal);
  else
  {
      hr = E_INVALIDARG;
      goto Cleanup;
  }

  if(szSiteName)
  {
      lResult = RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                              "Software\\Microsoft\\Passport\\Sites",
                              0,
                              KEY_ALL_ACCESS,
                              &hkSites);
      if(lResult != ERROR_SUCCESS)
      {
          AtlReportError(CLSID_Admin, 
		         L"Couldn't find Sites key in registry.  Reinstall Passport.", IID_IPassportAdminEx, 
                 PP_E_SITE_NOT_EXISTS);
          hr = PP_E_SITE_NOT_EXISTS;
          goto Cleanup;
      }

      lResult = RegOpenKeyExA(hkSites,
                              szSiteName,
                              0,
                              KEY_ALL_ACCESS,
                              &hkPassport);
      if(lResult != ERROR_SUCCESS)
      {
          AtlReportError(CLSID_Admin, 
		         L"Couldn't find site key in registry.  Reinstall Passport.", IID_IPassportAdminEx, 
                 PP_E_SITE_NOT_EXISTS);
          hr = PP_E_SITE_NOT_EXISTS;
          goto Cleanup;
      }
  }
  else
  {
      lResult = RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                              "Software\\Microsoft\\Passport",
                              0,
                              KEY_ALL_ACCESS,
                              &hkPassport);
      if(lResult != ERROR_SUCCESS)
      {
          AtlReportError(CLSID_Admin, 
		         L"Couldn't find Passport key in registry.  Reinstall Passport.", IID_IPassportAdminEx, E_FAIL);
          hr = E_FAIL;
          goto Cleanup;
      }
  }

  lResult = RegOpenKeyExA(hkPassport, "KeyTimes", 0,
			  KEY_WRITE, &hkTimeKey);
  if(lResult != ERROR_SUCCESS)
    {
      AtlReportError(CLSID_Admin, 
		     L"Couldn't find KeyTimes key in registry.  Reinstall Passport.", IID_IPassportAdminEx, E_FAIL);
      hr = E_FAIL;
      goto Cleanup;
    }

  szKeyNum[0] = TOHEX(version);
  szKeyNum[1] = '\0';

  if (fromNow == 0)
    {
      RegDeleteValueA(hkTimeKey, szKeyNum);
    }
  else
    {
      time_t now;
      time(&now);
      now += fromNow;
      DWORD dwT = now;
      lResult = RegSetValueExA(hkTimeKey, szKeyNum, 0,
			       REG_DWORD, (LPBYTE) &dwT, sizeof(DWORD));
      if(lResult != ERROR_SUCCESS)
	{
	  AtlReportError(CLSID_Admin, 
			 L"Couldn't write KeyTime key to registry.", IID_IPassportAdminEx, E_FAIL);
	  hr = E_FAIL;
	  goto Cleanup;
	}
    }


 Cleanup:
  if (hkSites)
    RegCloseKey(hkSites);
  if (hkPassport)
    RegCloseKey(hkPassport);
  if (hkTimeKey)
    RegCloseKey(hkTimeKey);
  return hr;
}

STDMETHODIMP CAdmin::get_currentKeyVersion(int *pVal)
{
  if (!g_config || !g_config->isValid()) // Guarantees config is non-null
  {
    *pVal = -1;
    return S_OK;
  }

  CRegistryConfig* crc = g_config->checkoutRegistryConfig();
  *pVal = crc->getCurrentCryptVersion();
  crc->Release();
  return S_OK;
}

STDMETHODIMP CAdmin::getCurrentKeyVersionEx(
    VARIANT vSiteName,
    int *pVal
    )
{
    HRESULT           hr;
    LPSTR             szSiteName;
    CRegistryConfig*  crc = NULL;

    USES_CONVERSION;

    if(vSiteName.vt == VT_ERROR && vSiteName.scode == DISP_E_PARAMNOTFOUND)
        szSiteName = NULL;
    else if(vSiteName.vt == VT_BSTR)
        szSiteName = W2A(vSiteName.bstrVal);
    else
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!g_config || !g_config->isValid()) // Guarantees config is non-null
    {
        *pVal = -1;
        hr = S_OK;
        goto Cleanup;
    }

    crc = g_config->checkoutRegistryConfigBySite(szSiteName);
    if(szSiteName && crc == NULL)
    {
        hr = PP_E_SITE_NOT_EXISTS;
        goto Cleanup;
    }

    if(crc == NULL)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    *pVal = crc->getCurrentCryptVersion();

    hr = S_OK;

Cleanup:
    if(crc)
        crc->Release();

    return S_OK;
}

STDMETHODIMP CAdmin::put_currentKeyVersion(int Val)
{
  HRESULT hr = S_OK, lResult;
  HKEY  hkKey = NULL;
  DWORD dwCK = Val;

  if (Val < 1 || Val > 0xF)
  {
      hr = E_INVALIDARG;
      goto Cleanup;
  }

  lResult = RegOpenKeyExA(HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Passport", 0,
			                KEY_WRITE, &hkKey);
  if(lResult != ERROR_SUCCESS)
    {
      AtlReportError(CLSID_Admin, 
		     L"Couldn't find Passport key in registry.  Reinstall Passport.", IID_IPassportAdmin, E_FAIL);
      hr = E_FAIL;
      goto Cleanup;
    }
  
  lResult = RegSetValueExA(hkKey, "CurrentKey", 0,
			   REG_DWORD, (LPBYTE) &dwCK, sizeof(DWORD));
  if(lResult != ERROR_SUCCESS)
    {
      AtlReportError(CLSID_Admin, 
		     L"Couldn't write CurrentKey value to registry.", IID_IPassportAdmin, E_FAIL);
      hr = E_FAIL;
      goto Cleanup;
    }
  
 Cleanup:
  if (hkKey)
    RegCloseKey(hkKey);
  return hr;

}

STDMETHODIMP CAdmin::putCurrentKeyVersionEx(
    int Val,
    VARIANT vSiteName
    )
{
  HRESULT hr = S_OK, lResult;
  LPSTR szSiteName;
  HKEY  hkPassport = NULL, hkSites = NULL;
  DWORD dwCK = Val;

  USES_CONVERSION;

  if (Val < 1 || Val > 0xF)
  {
      hr = E_INVALIDARG;
      goto Cleanup;
  }

  if(vSiteName.vt == VT_ERROR && vSiteName.scode == DISP_E_PARAMNOTFOUND)
      szSiteName = NULL;
  else if(vSiteName.vt == VT_BSTR)
      szSiteName = W2A(vSiteName.bstrVal);
  else
  {
      hr = E_INVALIDARG;
      goto Cleanup;
  }

  if(szSiteName)
  {
      lResult = RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                              "Software\\Microsoft\\Passport\\Sites",
                              0,
                              KEY_ALL_ACCESS,
                              &hkSites);
      if(lResult != ERROR_SUCCESS)
      {
          AtlReportError(CLSID_Admin, 
		         L"Couldn't find Sites key in registry.  Reinstall Passport.", IID_IPassportAdminEx, 
                 PP_E_SITE_NOT_EXISTS);
          hr = PP_E_SITE_NOT_EXISTS;
          goto Cleanup;
      }

      lResult = RegOpenKeyExA(hkSites,
                              szSiteName,
                              0,
                              KEY_ALL_ACCESS,
                              &hkPassport);
      if(lResult != ERROR_SUCCESS)
      {
          AtlReportError(CLSID_Admin, 
		         L"Couldn't find site key in registry.  Reinstall Passport.", IID_IPassportAdminEx, 
                 PP_E_SITE_NOT_EXISTS);
          hr = PP_E_SITE_NOT_EXISTS;
          goto Cleanup;
      }
  }
  else
  {
      lResult = RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                              "Software\\Microsoft\\Passport",
                              0,
                              KEY_ALL_ACCESS,
                              &hkPassport);
      if(lResult != ERROR_SUCCESS)
      {
          AtlReportError(CLSID_Admin, 
		         L"Couldn't find Passport key in registry.  Reinstall Passport.", IID_IPassportAdminEx, E_FAIL);
          hr = E_FAIL;
          goto Cleanup;
      }
  }

  lResult = RegSetValueExA(hkPassport, "CurrentKey", 0,
			   REG_DWORD, (LPBYTE) &dwCK, sizeof(DWORD));
  if(lResult != ERROR_SUCCESS)
    {
      AtlReportError(CLSID_Admin, 
		     L"Couldn't write CurrentKey value to registry.", IID_IPassportAdminEx, E_FAIL);
      hr = E_FAIL;
      goto Cleanup;
    }
  
 Cleanup:
  if (hkPassport)
    RegCloseKey(hkPassport);
  if (hkSites)
    RegCloseKey(hkSites);
  return hr;

}

STDMETHODIMP CAdmin::Refresh(
    VARIANT_BOOL    bWait,
    VARIANT_BOOL*   pbSuccess
    )
{
    HRESULT hr;

    if(pbSuccess == NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *pbSuccess = (g_config->UpdateNow(TRUE) ? VARIANT_TRUE : VARIANT_FALSE);
    hr = S_OK;

Cleanup:

    return hr;
}

STDMETHODIMP CAdmin::setNexusPassword(
    BSTR    bstrPwd
    )
{
    HRESULT                 hr;

    BYTE        original[CKeyCrypto::RAWKEY_SIZE];
    DATA_BLOB   iBlob;
    DATA_BLOB   oBlob;
    ZeroMemory(&oBlob, sizeof(oBlob));
    CKeyCrypto  kc;
    long        lResult;
    HKEY        hkNexus = NULL;

    USES_CONVERSION;

    ZeroMemory(original,  sizeof(original));
    strncpy( (char*)original, W2A(bstrPwd), sizeof(original));
    iBlob.cbData = sizeof(original);
    iBlob.pbData = &(original[0]);
    hr = kc.encryptKey(&iBlob, &oBlob);
    if(hr != S_OK)
        goto Cleanup;

    //
    //  Now we have an encrypted key, put it in the registry.
    //

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           TEXT("Software\\Microsoft\\Passport\\Nexus"),
                           0,
                           KEY_SET_VALUE,
                           &hkNexus);
    if(lResult != ERROR_SUCCESS)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    lResult = RegSetValueEx(hkNexus,
                            TEXT("CCDPassword"),
                            0,
                            REG_BINARY,
                            oBlob.pbData,
                            oBlob.cbData
                            );
    if(lResult != ERROR_SUCCESS)
    {
        hr = E_FAIL;
        goto Cleanup;
    }                          
    
    hr = S_OK;

Cleanup:

    if(hkNexus)
        RegCloseKey(hkNexus);

    if (oBlob.pbData)
        ::LocalFree(oBlob.pbData);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\include\wml\wmlum.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    wmlum.h

Abstract:

    User mode definitions for an easy wmi tracing.

Author:

    gorn

Revision History:

Comments:

    Needs to be moved to WML\inc when DCR is approved


--*/
#ifndef WMLUM_H
#define WMLUM_H 1

#pragma warning(disable: 4201) // error C4201: nonstandard extension used : nameless struct/union
#include <wmistr.h>
#include <evntrace.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _WML_REG_STRUCT
{
    TRACEHANDLE LoggerHandle;
    ULONG EnableFlags; 
    ULONG EnableLevel;

    struct _WML_REG_STRUCT* Next;
    TRACEHANDLE RegistrationHandle;
} WML_REG_STRUCT, *PWML_REG_STRUCT;

typedef PWML_REG_STRUCT WML_REG_HANDLE;

typedef void (*WMLPRINTFUNC)(UINT Level, PCHAR String);

ULONG
WmlInitialize(
    IN LPWSTR ProductName, 
    IN WMLPRINTFUNC PrintFunc,
    OUT WML_REG_HANDLE*, 
    ... // Pairs: LPWSTR CtrlGuidName, Corresponding WML_REG_STRUCT 
    );
    
VOID
WmlUninitialize(
    IN WML_REG_HANDLE
    );

ULONG
WmlTrace(
    IN UINT Type,
    IN LPCGUID TraceGuid,
    IN TRACEHANDLE LoggerHandle,
    ... // Pairs: Address, Length
    );

typedef 
ULONG
(*PWML_INITIALIZE)(
    IN LPWSTR ProductName, 
    IN WMLPRINTFUNC PrintFunc,
    OUT WML_REG_HANDLE*, 
    ...
    );

typedef 
VOID 
(*PWML_UNINITIALIZE)(
    IN WML_REG_HANDLE);

typedef 
ULONG
(*PWML_TRACE)(
    IN UINT Type,
    IN LPCGUID TraceGuid,
    IN TRACEHANDLE LoggerHandle,
    ... 
    );

typedef 
struct _WML_DATA {

    PWML_TRACE        Trace;
    PWML_INITIALIZE   Initialize;
    PWML_UNINITIALIZE Uninitialize;
    
    WML_REG_HANDLE WmiRegHandle;
    HINSTANCE         WmlDllInstance;
    
} WML_DATA;


#define LOADWML(status, wml) \
    do \
    { \
        HINSTANCE hInst = LoadLibraryW(L"wmlum.dll"); \
        (wml).WmlDllInstance = hInst; \
        if (!hInst) { \
            status = GetLastError(); \
        } else { \
            (wml).Trace        =        (PWML_TRACE) GetProcAddress(hInst, "WmlTrace"); \
            (wml).Initialize   =   (PWML_INITIALIZE) GetProcAddress(hInst, "WmlInitialize"); \
            (wml).Uninitialize = (PWML_UNINITIALIZE) GetProcAddress(hInst, "WmlUninitialize"); \
    \
            if (!(wml).Trace || !(wml).Initialize || !(wml).Uninitialize) { \
                status = GetLastError(); \
            } else { \
                status = ERROR_SUCCESS; \
            } \
        } \
    } \
    while(0)

#define UNLOADWML(wml) \
    do \
    { \
        if ( (wml).Uninitialize ) { \
            (wml).Uninitialize( (wml).WmiRegHandle ); \
        } \
        if ( (wml).WmlDllInstance ) { \
            FreeLibrary( (wml).WmlDllInstance ); \
        } \
        RtlZeroMemory( &(wml) , sizeof(WML_DATA) ); \
    } \
    while(0)  

#ifdef __cplusplus
};
#endif

#endif // WMLUM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\passportmanager\admin.h ===
// Admin.h : Declaration of the CAdmin

#ifndef __ADMIN_H_
#define __ADMIN_H_

#include "resource.h"       // main symbols
#include <asptlb.h>         // Active Server Pages Definitions

/////////////////////////////////////////////////////////////////////////////
// CAdmin
class ATL_NO_VTABLE CAdmin : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CAdmin, &CLSID_Admin>,
	public ISupportErrorInfo,
	public IDispatchImpl<IPassportAdmin, &IID_IPassportAdmin, &LIBID_PASSPORTLib>,
	public IDispatchImpl<IPassportAdminEx, &IID_IPassportAdminEx, &LIBID_PASSPORTLib>
{
public:
  CAdmin()
    { 
    }

public:

DECLARE_REGISTRY_RESOURCEID(IDR_ADMIN)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CAdmin)
  COM_INTERFACE_ENTRY (IPassportAdmin)
  COM_INTERFACE_ENTRY (IPassportAdminEx)
  COM_INTERFACE_ENTRY2(IDispatch, IPassportAdminEx)
  COM_INTERFACE_ENTRY (ISupportErrorInfo)
END_COM_MAP()

// ISupportsErrorInfo
  STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IPassportAdmin
public:
  STDMETHOD(get_currentKeyVersion)(/*[out, retval]*/ int *pVal);
  STDMETHOD(put_currentKeyVersion)(/*[in]*/ int Val);
  STDMETHOD(setKeyTime)(/*[in]*/ int version, /*[in]*/ int fromNow);
  STDMETHOD(deleteKey)(/*[in]*/ int version);
  STDMETHOD(addKey)(/*[in]*/ BSTR keyMaterial, /*[in]*/ int version, /*[in]*/ long expires, /*[out,retval]*/ VARIANT_BOOL *ok);
  STDMETHOD(get_ErrorDescription)(/*[out, retval]*/ BSTR *pVal);
  STDMETHOD(get_IsValid)(/*[out, retval]*/ VARIANT_BOOL *pVal);
  STDMETHOD(Refresh)(/*[in]*/ VARIANT_BOOL bWait, /*[out,retval]*/ VARIANT_BOOL* pbSuccess);
  STDMETHOD(setKeyTimeEx)(/*[in]*/ int version, /*[in]*/ int fromNow, /*[in,optional]*/ VARIANT vSiteName);
  STDMETHOD(deleteKeyEx)(/*[in]*/ int version, /*[in,optional]*/ VARIANT vSiteName);
  STDMETHOD(addKeyEx)(/*[in]*/ BSTR keyMaterial, /*[in]*/ int version, /*[in]*/ long expires, /*[in,optional]*/ VARIANT vSiteName, /*[out,retval]*/ VARIANT_BOOL *ok);
  STDMETHOD(getCurrentKeyVersionEx)(/*[in,optional]*/ VARIANT vSiteName, /*[out, retval]*/ int *pVal);
  STDMETHOD(putCurrentKeyVersionEx)(/*[in]*/ int Val, /*[in,optional]*/ VARIANT vSiteName);
  STDMETHOD(setNexusPassword)(/*[in]*/ BSTR bstrPwd);
};

#endif //__ADMIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\passportmanager\alerts.h ===
// gmarks
#include "PassportAlertInterface.h"
#include "pmAlertsDefs.h"
#include "pmalerts.h"

extern PassportAlertInterface*  g_pAlert;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\passportmanager\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

//#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "passport_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\passportmanager\fastauth.cpp ===
// FastAuth.cpp : Implementation of CFastAuth
#include "stdafx.h"
#include <time.h>
#include <httpfilt.h>
#include <httpext.h>
#include "Passport.h"
#include "FastAuth.h"
#include "Ticket.h"
#include "Profile.h"
#include "VariantUtils.h"
#include "PMErrorCodes.h"
#include "HelperFuncs.h"

/////////////////////////////////////////////////////////////////////////////
// CFastAuth

STDMETHODIMP CFastAuth::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] =
    {
        &IID_IPassportFastAuth
    };
    for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}


//
//  old API. href to login
//
STDMETHODIMP
CFastAuth::LogoTag(
    BSTR            bstrTicket,
    BSTR            bstrProfile,
    VARIANT         vRU,
    VARIANT         vTimeWindow,
    VARIANT         vForceLogin,
    VARIANT         vCoBrand,
    VARIANT         vLCID,
    VARIANT         vSecure,
    VARIANT         vLogoutURL,
    VARIANT         vSiteName,
    VARIANT         vNameSpace,
    VARIANT         vKPP,
    VARIANT         vUseSecureAuth,
    BSTR*           pbstrLogoTag
    )
{
    return  CommonLogoTag(bstrTicket,
                          bstrProfile,
                          vRU,
                          vTimeWindow,
                          vForceLogin,
                          vCoBrand,
                          vLCID,
                          vSecure,
                          vLogoutURL,
                          vSiteName,
                          vNameSpace,
                          vKPP,
                          vUseSecureAuth,
                          FALSE,
                          pbstrLogoTag);

}

//
//  new API. href back to partner
//
STDMETHODIMP
CFastAuth::LogoTag2(
    BSTR            bstrTicket,
    BSTR            bstrProfile,
    VARIANT         vRU,
    VARIANT         vTimeWindow,
    VARIANT         vForceLogin,
    VARIANT         vCoBrand,
    VARIANT         vLCID,
    VARIANT         vSecure,
    VARIANT         vLogoutURL,
    VARIANT         vSiteName,
    VARIANT         vNameSpace,
    VARIANT         vKPP,
    VARIANT         vUseSecureAuth,
    BSTR*           pbstrLogoTag
    )
{
    return  CommonLogoTag(bstrTicket,
                          bstrProfile,
                          vRU,
                          vTimeWindow,
                          vForceLogin,
                          vCoBrand,
                          vLCID,
                          vSecure,
                          vLogoutURL,
                          vSiteName,
                          vNameSpace,
                          vKPP,
                          vUseSecureAuth,
                          TRUE,
                          pbstrLogoTag);

}

//
//  logotag impl
//
STDMETHODIMP
CFastAuth::CommonLogoTag(
    BSTR            bstrTicket,
    BSTR            bstrProfile,
    VARIANT         vRU,
    VARIANT         vTimeWindow,
    VARIANT         vForceLogin,
    VARIANT         vCoBrand,
    VARIANT         vLCID,
    VARIANT         vSecure,
    VARIANT         vLogoutURL,
    VARIANT         vSiteName,
    VARIANT         vNameSpace,
    VARIANT         vKPP,
    VARIANT         vUseSecureAuth,
    BOOL            fRedirToSelf,
    BSTR*           pbstrLogoTag
    )
{
    HRESULT                     hr;
    CComObjectStack<CTicket>    Ticket;
    CComObjectStack<CProfile>   Profile;
    WCHAR                       text[2048];
    time_t                      ct;
    ULONG                       TimeWindow;
    int                         nKPP;
    VARIANT_BOOL                ForceLogin, bSecure = VARIANT_FALSE;
    ULONG                       ulSecureLevel = 0;
    BSTR                        CBT = NULL, returnUrl = NULL, bstrSiteName = NULL, bstrNameSpace = NULL;
    int                         hasCB = -1, hasRU = -1, hasLCID, hasTW, hasFL, hasSec, hasSiteName, hasNameSpace, hasUseSec;
    int                         hasKPP = -1;
    USHORT                      Lang;
    CNexusConfig*               cnc = NULL;
    CRegistryConfig*            crc = NULL;
    VARIANT_BOOL                bTicketValid,bProfileValid;
    LPSTR                       szSiteName;
    VARIANT                     vFalse;

    USES_CONVERSION;
//JVP - begin changes
#ifdef PASSPORT_VERBOSE_MODE_ON
    char szLogString[LOG_STRING_LEN] = "CFastAuth::LogoTag, Enter";
    AddBSTRAsString(bstrTicket,  szLogString, sizeof(szLogString));
    AddBSTRAsString(bstrProfile,  szLogString, sizeof(szLogString));
    g_pTSLogger->AddDateTimeAndLog(szLogString);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes

    if (!g_config->isValid()) // Guarantees config is non-null
    {
        AtlReportError(CLSID_FastAuth, PP_E_NOT_CONFIGUREDSTR,
                       IID_IPassportFastAuth, PP_E_NOT_CONFIGURED);
        hr = PP_E_NOT_CONFIGURED;
        goto Cleanup;
    }

    //  Get site name if any...
    hasSiteName = GetBstrArg(vSiteName, &bstrSiteName);
    if(hasSiteName == CV_OK || hasSiteName == CV_FREE)
        szSiteName = W2A(bstrSiteName);
    else
        szSiteName = NULL;

    if(hasSiteName == CV_FREE)
        SysFreeString(bstrSiteName);

    cnc = g_config->checkoutNexusConfig();
    crc = g_config->checkoutRegistryConfig(szSiteName);

    hr = DecryptTicketAndProfile(bstrTicket,
                                 bstrProfile,
                                 FALSE,
                                 NULL,
                                 crc,
                                 &Ticket,
                                 &Profile);

    VariantInit(&vFalse);
    vFalse.vt = VT_BOOL;
    vFalse.boolVal = VARIANT_FALSE;

    Ticket.get_IsAuthenticated(0,
                               VARIANT_FALSE,
                               vFalse,
                               &bTicketValid);
    Profile.get_IsValid(&bProfileValid);

    time(&ct);

    *text = L'\0';

    // Make sure args are of the right type
    if ((hasTW = GetIntArg(vTimeWindow, (int*) &TimeWindow)) == CV_BAD)
        return E_INVALIDARG;
    if ((hasFL = GetBoolArg(vForceLogin, &ForceLogin)) == CV_BAD)
        return E_INVALIDARG;
    if ((hasSec = GetBoolArg(vSecure,&bSecure)) == CV_BAD)
        return E_INVALIDARG;
    if ((hasUseSec = GetIntArg(vUseSecureAuth,(int*)&ulSecureLevel)) == CV_BAD)
        return E_INVALIDARG;
    if ((hasLCID = GetShortArg(vLCID,&Lang)) == CV_BAD)
        return E_INVALIDARG;
    if ((hasKPP = GetIntArg(vKPP, &nKPP)) == CV_BAD)
        return E_INVALIDARG;
    hasCB = GetBstrArg(vCoBrand, &CBT);
    if (hasCB == CV_BAD)
        return E_INVALIDARG;
    if (hasCB == CV_FREE) { TAKEOVER_BSTR(CBT); }
    hasRU = GetBstrArg(vRU, &returnUrl);
    if (hasRU == CV_BAD)
    {
        if (hasCB == CV_FREE && CBT)
            SysFreeString(CBT);
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    if (hasRU == CV_FREE) { TAKEOVER_BSTR(returnUrl); }

    hasNameSpace = GetBstrArg(vNameSpace, &bstrNameSpace);
    if (hasNameSpace == CV_BAD)
    {
        if (hasCB == CV_FREE && CBT) SysFreeString(CBT);
        if (hasRU == CV_FREE && returnUrl) SysFreeString(returnUrl);
        return E_INVALIDARG;
    }
    if (hasNameSpace == CV_FREE) { TAKEOVER_BSTR(bstrNameSpace); }


    WCHAR *szSIAttrName, *szSOAttrName;
    if (hasSec == CV_OK && bSecure != VARIANT_FALSE)
    {
        szSIAttrName = L"SecureSigninLogo";
        szSOAttrName = L"SecureSignoutLogo";
    }
    else
    {
        szSIAttrName = L"SigninLogo";
        szSOAttrName = L"SignoutLogo";
    }

    WCHAR *szAUAttrName;
    if (hasUseSec == CV_OK && SECURELEVEL_USE_HTTPS(ulSecureLevel))
        szAUAttrName = L"AuthSecure";
    else
        szAUAttrName = L"Auth";

    if (hasLCID == CV_DEFAULT)
        Lang = crc->getDefaultLCID();

    if (hasTW == CV_DEFAULT)
        TimeWindow = crc->getDefaultTicketAge();
    if (hasFL == CV_DEFAULT)
        ForceLogin = crc->forceLoginP() ? VARIANT_TRUE : VARIANT_FALSE;
    if (hasCB == CV_DEFAULT)
        CBT = crc->getDefaultCoBrand();
    if (hasRU == CV_DEFAULT)
        returnUrl = crc->getDefaultRU();
    if (hasKPP == CV_DEFAULT)
        nKPP = -1;
    if (returnUrl == NULL)
        returnUrl = L"";

    if ((TimeWindow != 0 && TimeWindow < PPM_TIMEWINDOW_MIN) || TimeWindow > PPM_TIMEWINDOW_MAX)
    {
        WCHAR buf[20];
        _itow(TimeWindow,buf,10);
        if (g_pAlert)
            g_pAlert->report(PassportAlertInterface::WARNING_TYPE,
                             PM_TIMEWINDOW_INVALID, buf);
        AtlReportError(CLSID_FastAuth, (LPCOLESTR) PP_E_INVALID_TIMEWINDOWSTR,
                       IID_IPassportFastAuth, PP_E_INVALID_TIMEWINDOW);
        hr = PP_E_INVALID_TIMEWINDOW;
        goto Cleanup;
    }

    if (bTicketValid)
    {
        LPCWSTR domain = NULL;
        WCHAR url[1024];
        VARIANT freeMe;
        VariantInit(&freeMe);

        if (crc->DisasterModeP())
            lstrcpynW(url, A2W(crc->getDisasterUrl()), sizeof(url) >> 1);
        else
        {
            if (bProfileValid &&
                Profile.get_ByIndex(MEMBERNAME_INDEX, &freeMe) == S_OK &&
                freeMe.vt == VT_BSTR)
            {
                domain = wcsrchr(freeMe.bstrVal, L'@');
            }
            cnc->getDomainAttribute(domain ? domain+1 : L"Default",
                                    L"Logout",
                                    sizeof(url) >> 1,
                                    url,
                                    Lang);
        }

        // find out if there are any updates
        BSTR upd = NULL;
        Profile.get_updateString(&upd);

        if (upd)
        {
            TAKEOVER_BSTR(upd);
            // form the appropriate URL
            CCoCrypt* crypt = NULL;
            BSTR newCH = NULL;
            crypt = crc->getCurrentCrypt(); // IsValid ensures this is non-null
            // This should never fail... (famous last words)
            crypt->Encrypt(crc->getCurrentCryptVersion(), (LPSTR)upd, SysStringByteLen(upd), &newCH);
            FREE_BSTR(upd);
            TAKEOVER_BSTR(newCH);
            WCHAR iurl[1024];
            cnc->getDomainAttribute(domain ? domain+1 : L"Default",
                                    L"Update",
                                    sizeof(iurl) >> 1,
                                    iurl,
                                    Lang);

            // This is a bit gross... we need to find the $1 in the update url...
            // We'll break if null, but won't crash...
            if (*url != L'\0')
                *pbstrLogoTag = FormatUpdateLogoTag(
                                        url,
                                        crc->getSiteId(),
                                        returnUrl,
                                        TimeWindow,
                                        ForceLogin,
                                        crc->getCurrentCryptVersion(),
                                        ct,
                                        CBT,
                                        nKPP,
                                        (*iurl == L'\0' ? NULL : iurl),
                                        bSecure,
                                        newCH,
                                        PM_LOGOTYPE_SIGNOUT,
                                        ulSecureLevel,
                                        crc
                                        );
            FREE_BSTR(newCH);
        }
        else
        {
            WCHAR iurl[1024];
            cnc->getDomainAttribute(domain ? domain+1 : L"Default",
                                    szSOAttrName,
                                    sizeof(iurl) >> 1,
                                    iurl,
                                    Lang);

            if (*iurl != L'\0')
                *pbstrLogoTag = FormatNormalLogoTag(
                                        url,
                                        crc->getSiteId(),
                                        returnUrl,
                                        TimeWindow,
                                        ForceLogin,
                                        crc->getCurrentCryptVersion(),
                                        ct,
                                        CBT,
                                        iurl,
                                        NULL,
                                        nKPP,
                                        PM_LOGOTYPE_SIGNOUT,
                                        Lang,
                                        ulSecureLevel,
                                        crc,
                                        fRedirToSelf
                                        );
        }
        VariantClear(&freeMe);
    }
    else
    {
        WCHAR url[1024];

        if (!crc->DisasterModeP())
            cnc->getDomainAttribute(L"Default",
                                    szAUAttrName,
                                    sizeof(url) >> 1,
                                    url,
                                    Lang);
        else
            lstrcpynW(url, A2W(crc->getDisasterUrl()), sizeof(url) >> 1);

        WCHAR iurl[1024];
        cnc->getDomainAttribute(L"Default",
                                szSIAttrName,
                                sizeof(iurl) >> 1,
                                iurl,
                                Lang);

        if (*iurl != L'\0')
            *pbstrLogoTag = FormatNormalLogoTag(
                                    url,
                                    crc->getSiteId(),
                                    returnUrl,
                                    TimeWindow,
                                    ForceLogin,
                                    crc->getCurrentCryptVersion(),
                                    ct,
                                    CBT,
                                    iurl,
                                    bstrNameSpace,
                                    nKPP,
                                    PM_LOGOTYPE_SIGNIN,
                                    Lang,
                                    ulSecureLevel,
                                    crc,
                                    fRedirToSelf
                                    );
    }

    hr = S_OK;

Cleanup:

    if (crc) crc->Release();
    if (cnc) cnc->Release();

    if (hasRU == CV_FREE && returnUrl)
        FREE_BSTR(returnUrl);
    if (hasCB == CV_FREE && CBT)
        FREE_BSTR(CBT);
    if (hasNameSpace == CV_FREE && bstrNameSpace)
        FREE_BSTR(bstrNameSpace);

//JVP - begin changes
#ifdef PASSPORT_VERBOSE_MODE_ON
    strcpy(szLogString, "CFastAuth::LogoTag, Exit");
    AddLongAsString(hr, szLogString, sizeof(szLogString));
    AddBSTRAsString(*pbstrLogoTag, szLogString, sizeof(szLogString));
    g_pTSLogger->AddDateTimeAndLog(szLogString);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes

    return hr;
}


STDMETHODIMP
CFastAuth::IsAuthenticated(
    BSTR            bstrTicket,
    BSTR            bstrProfile,
    VARIANT         vSecure,
    VARIANT         vTimeWindow,
    VARIANT         vForceLogin,
    VARIANT         vSiteName,
    VARIANT         vDoSecureCheck,
    VARIANT_BOOL*   pbAuthenticated
    )
{
    HRESULT                     hr;
    CComObjectStack<CTicket>    Ticket;
    CComObjectStack<CProfile>   Profile;
    CRegistryConfig*            crc = NULL;
    ULONG                       TimeWindow;
    VARIANT_BOOL                ForceLogin, bTicketValid, bProfileValid;
    int                         hasSec, hasTW, hasFL, hasSiteName;
    BSTR                        bstrSecure, bstrSiteName;
    LPSTR                       szSiteName;
    VARIANT                     vFalse;

    USES_CONVERSION;

//JVP - begin changes
#ifdef PASSPORT_VERBOSE_MODE_ON
    char szLogString[LOG_STRING_LEN] = "CFastAuth::IsAuthenticated, Enter";
    AddBSTRAsString(bstrTicket,  szLogString, sizeof(szLogString));
    AddBSTRAsString(bstrProfile,  szLogString, sizeof(szLogString));
    AddVariantAsString(vTimeWindow, szLogString, sizeof(szLogString));
    AddVariantAsString(vForceLogin, szLogString, sizeof(szLogString));
    AddVariantAsString(vSiteName, szLogString, sizeof(szLogString));
    g_pTSLogger->AddDateTimeAndLog(szLogString);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes

    if (!g_config->isValid()) // Guarantees config is non-null
    {
        AtlReportError(CLSID_Manager, PP_E_NOT_CONFIGUREDSTR,
                       IID_IPassportManager, PP_E_NOT_CONFIGURED);
        hr = PP_E_NOT_CONFIGURED;
        goto Cleanup;
    }

    hasSec = GetBstrArg(vSecure, &bstrSecure);
    if(hasSec == CV_BAD)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if(hasSec == CV_DEFAULT)
        bstrSecure = NULL;

    hasSiteName = GetBstrArg(vSiteName, &bstrSiteName);
    if(hasSiteName == CV_OK || hasSiteName == CV_FREE)
        szSiteName = W2A(bstrSiteName);
    else
        szSiteName = NULL;

    if(hasSiteName == CV_FREE)
        SysFreeString(bstrSiteName);

    crc = g_config->checkoutRegistryConfig(szSiteName);

    hr = DecryptTicketAndProfile(bstrTicket,
                                 NULL,
                                 FALSE,
                                 NULL,
                                 crc,
                                 &Ticket,
                                 &Profile);
    if(hr != S_OK)
    {
        goto Cleanup;
    }

    VariantInit(&vFalse);
    vFalse.vt = VT_BOOL;
    vFalse.boolVal = VARIANT_FALSE;

    Ticket.get_IsAuthenticated(0,
                               VARIANT_FALSE,
                               vFalse,
                               &bTicketValid);
    //Profile.get_IsValid(&bProfileValid);

    // Both profile AND ticket must be valid to be authenticated
    // DARRENAN - As of 1.3, this is no longer true!!!
    /*
    if (!bProfileValid)
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    */

    if ((hasTW = GetIntArg(vTimeWindow,(int*)&TimeWindow)) == CV_BAD)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    if (hasTW == CV_DEFAULT)
        TimeWindow = crc->getDefaultTicketAge();

    if ((hasFL = GetBoolArg(vForceLogin, &ForceLogin)) == CV_BAD)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (hasFL == CV_DEFAULT)
        ForceLogin = crc->forceLoginP() ? VARIANT_TRUE : VARIANT_FALSE;

    hr = Ticket.get_IsAuthenticated(TimeWindow, ForceLogin, vDoSecureCheck, pbAuthenticated);

Cleanup:

    if (crc) crc->Release();

    if(hasSec == CV_FREE)
        SysFreeString(bstrSecure);

    if(hr != S_OK)
    {
        *pbAuthenticated = VARIANT_FALSE;
    }

//JVP - begin changes
#ifdef PASSPORT_VERBOSE_MODE_ON
    strcpy(szLogString, "CFastAuth::IsAuthenticated, Exit");
    AddLongAsString(hr, szLogString, sizeof(szLogString));
    AddVariantBoolAsString(*pbAuthenticated, szLogString, sizeof(szLogString));
    g_pTSLogger->AddDateTimeAndLog(szLogString);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes

    return hr;
}


//
//  old API. Auth URL goes to login
//
STDMETHODIMP
CFastAuth::AuthURL(
    VARIANT         vTicket,
    VARIANT         vProfile,
    VARIANT         vRU,
    VARIANT         vTimeWindow,
    VARIANT         vForceLogin,
    VARIANT         vCoBrand,
    VARIANT         vLCID,
    VARIANT         vSecure,
    VARIANT         vLogoutURL,
    VARIANT         vReserved1,
    VARIANT         vSiteName,
    VARIANT         vNameSpace,
    VARIANT         vKPP,
    VARIANT         vUseSecureAuth,
    BSTR*           pbstrAuthURL
    )
{
    return  CommonAuthURL(vTicket,
                          vProfile,
                          vRU,
                          vTimeWindow,
                          vForceLogin,
                          vCoBrand,
                          vLCID,
                          vSecure,
                          vLogoutURL,
                          vReserved1,
                          vSiteName,
                          vNameSpace,
                          vKPP,
                          vUseSecureAuth,
                          FALSE,
                          pbstrAuthURL);

}

//
//  new API. Auth URL points to partner
//
STDMETHODIMP
CFastAuth::AuthURL2(
    VARIANT         vTicket,
    VARIANT         vProfile,
    VARIANT         vRU,
    VARIANT         vTimeWindow,
    VARIANT         vForceLogin,
    VARIANT         vCoBrand,
    VARIANT         vLCID,
    VARIANT         vSecure,
    VARIANT         vLogoutURL,
    VARIANT         vReserved1,
    VARIANT         vSiteName,
    VARIANT         vNameSpace,
    VARIANT         vKPP,
    VARIANT         vUseSecureAuth,
    BSTR*           pbstrAuthURL
    )
{
    return  CommonAuthURL(vTicket,
                          vProfile,
                          vRU,
                          vTimeWindow,
                          vForceLogin,
                          vCoBrand,
                          vLCID,
                          vSecure,
                          vLogoutURL,
                          vReserved1,
                          vSiteName,
                          vNameSpace,
                          vKPP,
                          vUseSecureAuth,
                          TRUE,
                          pbstrAuthURL);

}

STDMETHODIMP
CFastAuth::CommonAuthURL(
    VARIANT         vTicket,
    VARIANT         vProfile,
    VARIANT         vRU,
    VARIANT         vTimeWindow,
    VARIANT         vForceLogin,
    VARIANT         vCoBrand,
    VARIANT         vLCID,
    VARIANT         vSecure,
    VARIANT         vLogoutURL,
    VARIANT         vReserved1,
    VARIANT         vSiteName,
    VARIANT         vNameSpace,
    VARIANT         vKPP,
    VARIANT         vUseSecureAuth,
    BOOL            fRedirToSelf,
    BSTR*           pbstrAuthURL
    )
{
    HRESULT                     hr;
    BSTR                        bstrTicket = NULL;
    BSTR                        bstrProfile = NULL;
    CComObjectStack<CTicket>    Ticket;
    CComObjectStack<CProfile>   Profile;
    time_t                      ct;
    WCHAR                       url[1024];
    VARIANT                     freeMe;
    UINT                        TimeWindow;
    int                         nKPP;
    VARIANT_BOOL                ForceLogin;
    VARIANT_BOOL                bTicketValid;
    VARIANT_BOOL                bProfileValid;
    ULONG                       ulSecureLevel = 0;
    BSTR                        CBT = NULL, returnUrl = NULL, bstrSiteName = NULL, bstrNameSpace = NULL;
    int                         hasCB = -1, hasRU = -1, hasLCID, hasTW, hasFL, hasNameSpace, hasUseSec;
    int                         hasTicket = -1, hasProfile = -1, hasSiteName = -1, hasKPP = -1;
    USHORT                      Lang;
    CNexusConfig*               cnc = NULL;
    CRegistryConfig*            crc = NULL;
    WCHAR                       buf[20];
    LPSTR                       szSiteName;
    VARIANT                     vFalse;

    USES_CONVERSION;

//JVP - begin changes
#ifdef PASSPORT_VERBOSE_MODE_ON
    char szLogString[LOG_STRING_LEN] = "CFastAuth::AuthURL, Enter";
    AddVariantAsString(vTicket, szLogString, sizeof(szLogString));
    AddVariantAsString(vProfile, szLogString, sizeof(szLogString));
    g_pTSLogger->AddDateTimeAndLog(szLogString);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes

    if (!g_config->isValid()) // Guarantees config is non-null
    {
        AtlReportError(CLSID_FastAuth, PP_E_NOT_CONFIGUREDSTR,
                       IID_IPassportFastAuth, PP_E_NOT_CONFIGURED);
        hr = PP_E_NOT_CONFIGURED;
        goto Cleanup;
    }

    hasSiteName = GetBstrArg(vSiteName, &bstrSiteName);
    if(hasSiteName == CV_OK || hasSiteName == CV_FREE)
        szSiteName = W2A(bstrSiteName);
    else
        szSiteName = NULL;

    if(hasSiteName == CV_FREE)
        SysFreeString(bstrSiteName);

    cnc = g_config->checkoutNexusConfig();
    crc = g_config->checkoutRegistryConfig(szSiteName);

    // Make sure args are of the right type
    if ((hasTicket = GetBstrArg(vTicket, &bstrTicket)) == CV_BAD)
        return E_INVALIDARG;
    if ((hasProfile = GetBstrArg(vProfile, &bstrProfile)) == CV_BAD)
        return E_INVALIDARG;
    if(hasTicket != CV_DEFAULT && hasProfile != CV_DEFAULT)
    {
        hr = DecryptTicketAndProfile(bstrTicket, bstrProfile, FALSE, NULL, crc, &Ticket, &Profile);
        if(hr != S_OK)
        {
            bTicketValid = VARIANT_FALSE;
            bProfileValid = VARIANT_FALSE;
        }
        else
        {
            VariantInit(&vFalse);
            vFalse.vt = VT_BOOL;
            vFalse.boolVal = VARIANT_FALSE;

            Ticket.get_IsAuthenticated(0,
                              VARIANT_FALSE,
                              vFalse,
                              &bTicketValid);
            Profile.get_IsValid(&bProfileValid);
        }
    }
    else
    {
        bTicketValid = VARIANT_FALSE;
        bProfileValid = VARIANT_FALSE;
    }

    if ((hasTW = GetIntArg(vTimeWindow, (int*) &TimeWindow)) == CV_BAD)
        return E_INVALIDARG;
    if ((hasFL = GetBoolArg(vForceLogin, &ForceLogin)) == CV_BAD)
        return E_INVALIDARG;
    if ((hasUseSec = GetIntArg(vUseSecureAuth, (int*)&ulSecureLevel)) == CV_BAD)
        return E_INVALIDARG;
    if ((hasLCID = GetShortArg(vLCID,&Lang)) == CV_BAD)
        return E_INVALIDARG;
    if ((hasKPP = GetIntArg(vKPP, &nKPP)) == CV_BAD)
        return E_INVALIDARG;
    hasCB = GetBstrArg(vCoBrand, &CBT);
    if (hasCB == CV_BAD)
        return E_INVALIDARG;
    if (hasCB == CV_FREE) { TAKEOVER_BSTR(CBT); }
    hasRU = GetBstrArg(vRU, &returnUrl);
    if (hasRU == CV_BAD)
    {
        if (hasCB == CV_FREE && CBT)
            FREE_BSTR(CBT);
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    if (hasRU == CV_FREE) { TAKEOVER_BSTR(returnUrl); }

    hasNameSpace = GetBstrArg(vNameSpace, &bstrNameSpace);
    if (hasNameSpace == CV_BAD)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    if (hasNameSpace == CV_FREE) { TAKEOVER_BSTR(bstrNameSpace); }

    if (hasLCID == CV_DEFAULT)
        Lang = crc->getDefaultLCID();
    if (hasKPP == CV_DEFAULT)
        nKPP = -1;

    WCHAR *szAUAttrName;
    if (hasUseSec == CV_OK && SECURELEVEL_USE_HTTPS(ulSecureLevel))
        szAUAttrName = L"AuthSecure";
    else
        szAUAttrName = L"Auth";

    VariantInit(&freeMe);

    if (!crc->DisasterModeP())
    {
        // If I'm authenticated, get my domain specific url
        if (bTicketValid && bProfileValid)
        {
            hr = Profile.get_ByIndex(MEMBERNAME_INDEX, &freeMe);
            if (hr != S_OK || freeMe.vt != VT_BSTR)
            {
                cnc->getDomainAttribute(L"Default",
                                        szAUAttrName,
                                        sizeof(url) >> 1,
                                        url,
                                        Lang);
            }
            else
            {
                LPCWSTR psz = wcsrchr(freeMe.bstrVal, L'@');
                cnc->getDomainAttribute(psz ? psz+1 : L"Default",
                                        szAUAttrName,
                                        sizeof(url) >> 1,
                                        url,
                                        Lang);
            }
        }
        else
            cnc->getDomainAttribute(L"Default",
                                    szAUAttrName,
                                    sizeof(url) >> 1,
                                    url,
                                    Lang);
    }
    else
        lstrcpynW(url, A2W(crc->getDisasterUrl()), sizeof(url) >> 1);

    time(&ct);

    if (!url)
    {
        hr = S_OK;
        goto Cleanup;
    }

    if (hasTW == CV_DEFAULT)
        TimeWindow = crc->getDefaultTicketAge();
    if (hasFL == CV_DEFAULT)
        ForceLogin = crc->forceLoginP() ? VARIANT_TRUE : VARIANT_FALSE;
    if (hasCB == CV_DEFAULT)
        CBT = crc->getDefaultCoBrand();
    if (hasRU == CV_DEFAULT)
        returnUrl = crc->getDefaultRU();
    if (returnUrl == NULL)
        returnUrl = L"";

    if ((TimeWindow != 0 && TimeWindow < PPM_TIMEWINDOW_MIN) || TimeWindow > PPM_TIMEWINDOW_MAX)
    {
        _itow(TimeWindow,buf,10);
        if (g_pAlert)
            g_pAlert->report(PassportAlertInterface::WARNING_TYPE,
            PM_TIMEWINDOW_INVALID, buf);
        AtlReportError(CLSID_FastAuth, (LPCOLESTR) PP_E_INVALID_TIMEWINDOWSTR,
                       IID_IPassportFastAuth, PP_E_INVALID_TIMEWINDOW);
        hr = PP_E_INVALID_TIMEWINDOW;
        goto Cleanup;
    }

    *pbstrAuthURL = FormatAuthURL(
                            url,
                            crc->getSiteId(),
                            returnUrl,
                            TimeWindow,
                            ForceLogin,
                            crc->getCurrentCryptVersion(),
                            ct,
                            CBT,
                            bstrNameSpace,
                            nKPP,
                            Lang,
                            ulSecureLevel,
                            crc,
                            fRedirToSelf
                            );

    hr = S_OK;

Cleanup:

    if(cnc) cnc->Release();
    if(crc) crc->Release();
    if (hasTicket == CV_FREE && bstrTicket)
        FREE_BSTR(bstrTicket);
    if (hasProfile == CV_FREE && bstrProfile)
        FREE_BSTR(bstrProfile);
    if (hasRU == CV_FREE && returnUrl)
        FREE_BSTR(returnUrl);
    if (hasCB == CV_FREE && CBT)
        FREE_BSTR(CBT);
    if (hasNameSpace == CV_FREE && bstrNameSpace)
        FREE_BSTR(bstrNameSpace);
    VariantClear(&freeMe);

//JVP - begin changes
#ifdef PASSPORT_VERBOSE_MODE_ON
    strcpy(szLogString, "CFastAuth::AuthURL, Exit");
    AddLongAsString(hr, szLogString, sizeof(szLogString));
    AddBSTRAsString(*pbstrAuthURL, szLogString, sizeof(szLogString));
    g_pTSLogger->AddDateTimeAndLog(szLogString);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes

    return hr;
}


HRESULT
CFastAuth::GetTicketAndProfilePFC(
    BYTE*   pbPFC,
    BYTE*   pbPPH,
    BSTR*   pbstrTicket,
    BSTR*   pbstrProfile,
    BSTR*   pbstrSecure,
    BSTR*   pbstrSiteName
    )
{
    HTTP_FILTER_CONTEXT*            pfc = (HTTP_FILTER_CONTEXT*)pbPFC;
    HTTP_FILTER_PREPROC_HEADERS*    pph = (HTTP_FILTER_PREPROC_HEADERS*)pbPPH;
    BSTR                            bstrF;
    CHAR                            achBuf[2048];
    DWORD                           dwBufLen;
    LPSTR                           pszQueryString;

    USES_CONVERSION;

    dwBufLen = sizeof(achBuf);
    if(GetSiteNamePFC(pfc, achBuf, &dwBufLen) == S_OK)
        *pbstrSiteName = SysAllocString(A2W(achBuf));
    else
        *pbstrSiteName = NULL;

    dwBufLen = sizeof(achBuf);
    if(pph->GetHeader(pfc, "URL", achBuf, &dwBufLen))
    {
        pszQueryString = strchr(achBuf, '?');
        if(pszQueryString)
        {
            pszQueryString++;
            if(GetQueryData(achBuf, pbstrTicket, pbstrProfile, &bstrF))
            {
//JVP - begin changes
#ifdef PASSPORT_VERBOSE_MODE_ON
    char szLogString[LOG_STRING_LEN] = "CFastAuth::GetTicketAndProfilePFC, URL";
    AddStringToString(achBuf, szLogString, sizeof(szLogString));
    g_pTSLogger->AddDateTimeAndLog(szLogString);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes
                *pbstrSecure = NULL;
                return S_OK;
            }
        }
    }

    dwBufLen = sizeof(achBuf);
    if(pph->GetHeader(pfc, "Cookie:", achBuf, &dwBufLen))
    {
        if(!GetCookie(achBuf, "MSPAuth", pbstrTicket))
            return S_FALSE;

        GetCookie(achBuf, "MSPProf", pbstrProfile);
        GetCookie(achBuf, "MSPSecAuth", pbstrSecure);

        return S_OK;
    }

//JVP - begin changes
#ifdef PASSPORT_VERBOSE_MODE_ON
    char szLogString[LOG_STRING_LEN] = "CFastAuth::GetTicketAndProfilePFC, Failed";
    AddStringToString(achBuf, szLogString, sizeof(szLogString));
    g_pTSLogger->AddDateTimeAndLog(szLogString);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes
    return S_FALSE;
}

HRESULT
CFastAuth::GetTicketAndProfileECB(
    BYTE*   pbECB,
    BSTR*   pbstrTicket,
    BSTR*   pbstrProfile,
    BSTR*   pbstrSecure,
    BSTR*   pbstrSiteName
    )
{
    EXTENSION_CONTROL_BLOCK*    pECB = (EXTENSION_CONTROL_BLOCK*)pbECB;
    CHAR                        achBuf[2048];
    DWORD                       dwBufLen;
    BSTR                        bstrF;

    USES_CONVERSION;

    dwBufLen = sizeof(achBuf);
    if(GetSiteNameECB(pECB, achBuf, &dwBufLen) == S_OK)
        *pbstrSiteName = SysAllocString(A2W(achBuf));
    else
        *pbstrSiteName = NULL;

    dwBufLen = sizeof(achBuf);
    if(pECB->GetServerVariable(pECB, "QUERY_STRING", achBuf, &dwBufLen))
    {
        if(GetQueryData(achBuf, pbstrTicket, pbstrProfile, &bstrF))
        {
//JVP - begin changes
#ifdef PASSPORT_VERBOSE_MODE_ON
    char szLogString[LOG_STRING_LEN] = "CFastAuth::GetTicketAndProfileECB, Query_String";
    AddStringToString(achBuf, szLogString, sizeof(szLogString));
    g_pTSLogger->AddDateTimeAndLog(szLogString);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes
            *pbstrSecure = NULL;
            return S_OK;
        }
    }

    dwBufLen = sizeof(achBuf);
    if(pECB->GetServerVariable(pECB, "HTTP_COOKIE", achBuf, &dwBufLen))
    {
        if(!GetCookie(achBuf, "MSPAuth", pbstrTicket))
            return S_FALSE;

        GetCookie(achBuf, "MSPProf", pbstrProfile);
        GetCookie(achBuf, "MSPSecAuth", pbstrSecure);

        return S_OK;
    }

//JVP - begin changes
#ifdef PASSPORT_VERBOSE_MODE_ON
    char szLogString[LOG_STRING_LEN] = "CFastAuth::GetTicketAndProfileECB, Failed";
    AddStringToString(achBuf, szLogString, sizeof(szLogString));
    g_pTSLogger->AddDateTimeAndLog(szLogString);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes


    return S_FALSE;
}

HRESULT GetSiteName(
    LPSTR   szServerName,
    LPSTR   szPort,
    LPSTR   szSecure,
    LPSTR   szBuf,
    LPDWORD lpdwBufLen
    )
{
    HRESULT hr;
    DWORD   dwSize;
    int     nLength;
    LPSTR   szPortTest;

    if(!szServerName)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    //  Make sure the string (plus terminating null)
    //  isn't too long to fit into the buffer
    //

    dwSize = lstrlenA(szServerName);
    if(dwSize + 1 > *lpdwBufLen)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    //  Copy the string.
    //

    lstrcpyA(szBuf, szServerName);

    //
    //  Now, if the incoming port is a port other than
    //  80/443, append it to the server name.
    //

    if(szPort)
    {
        nLength = lstrlenA(szPort);

        if(lstrcmpA(szSecure, "on") == 0)
            szPortTest = "443";
        else
            szPortTest = "80";

        if(lstrcmpA(szPort, szPortTest) != 0 &&
           (dwSize + nLength + 2) <= *lpdwBufLen)
        {
            szBuf[dwSize] = ':';
            lstrcpyA(&(szBuf[dwSize + 1]), szPort);
            *lpdwBufLen = dwSize + nLength + 2;
        }
        else
            *lpdwBufLen = dwSize + 1;
    }
    else
        *lpdwBufLen = dwSize + 1;

    hr = S_OK;

Cleanup:

    return hr;
}

HRESULT
GetSiteNamePFC(
    HTTP_FILTER_CONTEXT*    pfc,
    LPSTR                   szBuf,
    LPDWORD                 lpdwBufLen
    )
{
    HRESULT hr;

    LPSTR szServerName = GetServerVariablePFC(pfc, "SERVER_NAME");
    LPSTR szPort       = GetServerVariablePFC(pfc, "SERVER_PORT");
    LPSTR szSecure     = GetServerVariablePFC(pfc, "HTTPS");

    hr = GetSiteName(szServerName, szPort, szSecure, szBuf, lpdwBufLen);

    if(szServerName)
        delete [] szServerName;
    if(szPort)
        delete [] szPort;
    if(szSecure)
        delete [] szSecure;

    return hr;
}

HRESULT
GetSiteNameECB(
    EXTENSION_CONTROL_BLOCK*    pECB,
    LPSTR                       szBuf,
    LPDWORD                     lpdwBufLen
    )
{
    HRESULT hr;

    LPSTR szServerName = GetServerVariableECB(pECB, "SERVER_NAME");
    LPSTR szPort       = GetServerVariableECB(pECB, "SERVER_PORT");
    LPSTR szSecure     = GetServerVariableECB(pECB, "HTTPS");

    hr = GetSiteName(szServerName, szPort, szSecure, szBuf, lpdwBufLen);

    if(szServerName)
        delete [] szServerName;
    if(szPort)
        delete [] szPort;
    if(szSecure)
        delete [] szSecure;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\passportmanager\helperfuncs.cpp ===
// HelperFuncs.cpp : Useful functions
#include "stdafx.h"
#include <time.h>
#include "HelperFuncs.h"
#include "Monitoring.h"
#include "nsconst.h"
#include <wininet.h>
#include <commd5.h>
#include <atlstr.h>

using namespace ATL;

LPWSTR GetVersionString(void);
BOOL PPEscapeUrl(LPCTSTR lpszStringIn,
                 LPTSTR lpszStringOut,
                 DWORD* pdwStrLen,
                 DWORD dwMaxLength,
                 DWORD dwFlags);

LPSTR
CopyHelperA(
    LPSTR   pszDest,
    LPCSTR  pszSrc,
    LPCSTR  pszBufEnd
    )
{
    while( (*pszDest = *pszSrc) && (pszDest <= pszBufEnd))
    {
        pszDest++;
        pszSrc++;
    }
    return( pszDest );
}

LPWSTR
CopyHelperW(
    LPWSTR  pszDest,
    LPCWSTR pszSrc,
    LPCWSTR pszBufEnd
    )
{
    while( (*pszDest = *pszSrc) && (pszDest <= pszBufEnd))
    {
        pszDest++;
        pszSrc++;
    }
    return( pszDest );
}

LPWSTR
CopyNHelperW(
    LPWSTR  pszDest,
    LPCWSTR pszSrc,
    ULONG   ulCount,
    LPCWSTR pszBufEnd
    )
{
    ULONG ulCur = 0;
    while( (*pszDest = *pszSrc) && (pszDest <= pszBufEnd))
    {
        pszDest++;
        pszSrc++;
        if(++ulCur == ulCount) break;
    }

    return pszDest;
}

BSTR
FormatNormalLogoTag(
    LPCWSTR pszLoginServerURL,
    ULONG   ulSiteId,
    LPCWSTR pszReturnURL,
    ULONG   ulTimeWindow,
    BOOL    bForceLogin,
    ULONG   ulCurrentCryptVersion,
    time_t  tCurrentTime,
    LPCWSTR pszCoBrand,
    LPCWSTR pszImageURL,
    LPCWSTR pszNameSpace,
    int     nKPP,
    PM_LOGOTYPE nLogoType,
    USHORT  lang,
    ULONG   ulSecureLevel,
    CRegistryConfig* pCRC,
    BOOL    fRedirToSelf
    )
/*
The old sprintf for reference:
            _snwprintf(text, 2048, L"<A HREF=\"%s?id=%d&ru=%s&tw=%d&fs=%s&kv=%d&ct=%u%s%s\">%s</A>",
                       url, crc->getSiteId(), returnUrl, TimeWindow, ForceLogin ? L"1" : L"0",
                       crc->getCurrentCryptVersion(), ct, CBT?L"&cb=":L"", CBT?CBT:L"", iurl);
*/
{
    WCHAR   text[2048];
    LPWSTR  pszCurrent = text;
    LPCWSTR pszBufEnd = &(text[2047]);

    //  logotag specific format
    pszCurrent = CopyHelperW(pszCurrent, L"<A HREF=\"", pszBufEnd);

    //  call the common formatting function
    //  it is the same for AuthURL and LogoTag
    pszCurrent = FormatAuthURLParameters(pszLoginServerURL,
                                         ulSiteId,
                                         pszReturnURL,
                                         ulTimeWindow,
                                         bForceLogin,
                                         ulCurrentCryptVersion,
                                         tCurrentTime,
                                         pszCoBrand,
                                         pszNameSpace,
                                         nKPP,
                                         pszCurrent,
                                         pszBufEnd - pszCurrent,
                                         lang,
                                         ulSecureLevel,
                                         pCRC,
                                         fRedirToSelf &&
                                            nLogoType == PM_LOGOTYPE_SIGNIN);

    //  more logotag specific formatting
    if(nLogoType == PM_LOGOTYPE_SIGNIN)
    {
        pszCurrent = CopyHelperW(pszCurrent, L"&C=1", pszBufEnd);
    }


    pszCurrent = CopyHelperW(pszCurrent, L"\">", pszBufEnd);
    pszCurrent = CopyHelperW(pszCurrent, pszImageURL, pszBufEnd);
    pszCurrent = CopyHelperW(pszCurrent, L"</A>", pszBufEnd);

    return ALLOC_AND_GIVEAWAY_BSTR(text);
}

BSTR
FormatUpdateLogoTag(
    LPCWSTR pszLoginServerURL,
    ULONG   ulSiteId,
    LPCWSTR pszReturnURL,
    ULONG   ulTimeWindow,
    BOOL    bForceLogin,
    ULONG   ulCurrentKeyVersion,
    time_t  tCurrentTime,
    LPCWSTR pszCoBrand,
    int     nKPP,
    LPCWSTR pszUpdateServerURL,
    BOOL    bSecure,
    LPCWSTR pszProfileUpdate,
    PM_LOGOTYPE nLogoType,
    ULONG   ulSecureLevel,
    CRegistryConfig* pCRC
)
/*
The old sprintf for reference:
_snwprintf(text, 2048,
                   L"<A HREF=\"%s?id=%d&ru=%s&tw=%d&fs=%s&kv=%d&ct=%u%s%s\">%.*s?id=%d&ct=%u&sec=%s&ru=%s&up=%s%s</A>",
                   url, crc->getSiteId(), returnUrl, TimeWindow, ForceLogin ? L"1" : L"0",
                   crc->getCurrentCryptVersion(), ct, CBT?L"&cb=":L"", CBT?CBT:L"",
           (ins-iurl), iurl, crc->getSiteId(), ct, (bSecure ? L"true" : L"false"),returnUrl,
           newCH, ins+2);
*/
{
    WCHAR   text[2048];
    WCHAR   temp[32];
    WCHAR   siteid[32];
    WCHAR   curtime[32];
    LPWSTR  pszCurrent = text;
    LPCWSTR pszBufEnd = &(text[2047]);
    LPWSTR  pszFirstHalfEnd;

    pszCurrent = CopyHelperW(pszCurrent, L"<A HREF=\"", pszBufEnd);
    LPWSTR signStart1 = pszCurrent;
    pszCurrent = CopyHelperW(pszCurrent, pszLoginServerURL, pszBufEnd);

    if(wcschr(text, L'?') == NULL)
        pszCurrent = CopyHelperW(pszCurrent, L"?id=", pszBufEnd);
    else
        pszCurrent = CopyHelperW(pszCurrent, L"&id=", pszBufEnd);

    _ultow(ulSiteId, siteid, 10);
    pszCurrent = CopyHelperW(pszCurrent, siteid, pszBufEnd);
    pszCurrent = CopyHelperW(pszCurrent, L"&ru=", pszBufEnd);
    pszCurrent = CopyHelperW(pszCurrent, pszReturnURL, pszBufEnd);
    pszCurrent = CopyHelperW(pszCurrent, L"&tw=", pszBufEnd);

    _ultow(ulTimeWindow, temp, 10);
    pszCurrent = CopyHelperW(pszCurrent, temp, pszBufEnd);
    pszCurrent = CopyHelperW(pszCurrent, L"&fs=", pszBufEnd);
    pszCurrent = CopyHelperW(pszCurrent, bForceLogin ? L"1" : L"0", pszBufEnd);
    pszCurrent = CopyHelperW(pszCurrent, L"&kv=", pszBufEnd);

    _ultow(ulCurrentKeyVersion, temp, 10);
    pszCurrent = CopyHelperW(pszCurrent, temp, pszBufEnd);
    pszCurrent = CopyHelperW(pszCurrent, L"&ct=", pszBufEnd);

    _ultow(tCurrentTime, curtime, 10);
    pszCurrent = CopyHelperW(pszCurrent, curtime, pszBufEnd);
    if(pszCoBrand)
    {
        pszCurrent = CopyHelperW(pszCurrent, L"&cb=", pszBufEnd);
        pszCurrent = CopyHelperW(pszCurrent, pszCoBrand, pszBufEnd);
    }

    if(nKPP != -1)
    {
        pszCurrent = CopyHelperW(pszCurrent, L"&kpp=", pszBufEnd);

        _ultow(nKPP, temp, 10);
        pszCurrent = CopyHelperW(pszCurrent, temp, pszBufEnd);
    }

    if(ulSecureLevel != 0)
    {
        pszCurrent = CopyHelperW(pszCurrent, L"&seclog=", pszBufEnd);

        _ultow(ulSecureLevel, temp, 10);
        pszCurrent = CopyHelperW(pszCurrent, temp, pszBufEnd);
    }

    pszCurrent = CopyHelperW(pszCurrent, L"&ver=", pszBufEnd);
    pszCurrent = CopyHelperW(pszCurrent, T2W(GetVersionString()), pszBufEnd);

    if(nLogoType == PM_LOGOTYPE_SIGNIN)
    {
        pszCurrent = CopyHelperW(pszCurrent, L"&C=1", pszBufEnd);
    }
    
    SignQueryString(pCRC, ulCurrentKeyVersion, signStart1, pszCurrent, pszBufEnd);
    
    pszCurrent = CopyHelperW(pszCurrent, L"\">", pszBufEnd);

    pszFirstHalfEnd = pszUpdateServerURL ? (wcsstr(pszUpdateServerURL, L"$1")) : NULL;

    pszCurrent = CopyNHelperW(pszCurrent, pszUpdateServerURL, (ULONG)(pszFirstHalfEnd - pszUpdateServerURL), pszBufEnd);
    pszCurrent = CopyHelperW(pszCurrent, L"?id=", pszBufEnd);
    pszCurrent = CopyHelperW(pszCurrent, siteid, pszBufEnd);
    pszCurrent = CopyHelperW(pszCurrent, L"&ct=", pszBufEnd);
    pszCurrent = CopyHelperW(pszCurrent, curtime, pszBufEnd);
    pszCurrent = CopyHelperW(pszCurrent, L"&sec=", pszBufEnd);
    pszCurrent = CopyHelperW(pszCurrent, bSecure ? L"true" : L"false", pszBufEnd);
    pszCurrent = CopyHelperW(pszCurrent, L"&ru=", pszBufEnd);
    pszCurrent = CopyHelperW(pszCurrent, pszReturnURL, pszBufEnd);
    pszCurrent = CopyHelperW(pszCurrent, L"&up=", pszBufEnd);
    pszCurrent = CopyHelperW(pszCurrent, pszProfileUpdate, pszBufEnd);
    pszCurrent = CopyHelperW(pszCurrent, pszFirstHalfEnd + 2, pszBufEnd);
    pszCurrent = CopyHelperW(pszCurrent, L"</A>", pszBufEnd);

    return ALLOC_AND_GIVEAWAY_BSTR(text);
}

HRESULT SignQueryString(
    CRegistryConfig* pCRC,
    ULONG   ulCurrentKeyVersion,
    LPWSTR  pszBufStart,
    LPWSTR& pszCurrent,
    LPCWSTR pszBufEnd
    )
{
    HRESULT hr = S_OK;
    if(pCRC)
    {
       CComBSTR signature;
       LPWSTR   signStart = wcschr(pszBufStart, L'?');

       // if found before pszCurrent
       if(signStart && signStart < pszCurrent)
       {
           ++signStart;;
       }
       HRESULT hr = PartnerHash(pCRC, ulCurrentKeyVersion, signStart, pszCurrent - signStart, &signature);

       if (hr == S_OK && signature != NULL)
       {
           pszCurrent = CopyHelperW(pszCurrent, L"&tpf=", pszBufEnd);
           pszCurrent = CopyHelperW(pszCurrent, signature, pszBufEnd);
       }
       
       if (!signature && g_pAlert)
           g_pAlert->report(PassportAlertInterface::WARNING_TYPE, PM_URLSIGNATURE_NOTCREATED,
                        0, NULL);
    }  
    else if(g_pAlert)
        g_pAlert->report(PassportAlertInterface::WARNING_TYPE, PM_URLSIGNATURE_NOTCREATED,
                        0, NULL);

   return hr;
}


HRESULT PartnerHash(
    CRegistryConfig* pCRC,
    ULONG   ulCurrentKeyVersion,
    LPCWSTR tobeSigned,
    ULONG   nChars,
    BSTR*   pbstrHash)
{
    // MD5 hash the url and query strings + the key of the 
    // 
    if(!pCRC || !pbstrHash) return E_INVALIDARG;

    CCoCrypt* crypt = pCRC->getCrypt(ulCurrentKeyVersion, NULL);
    DWORD keyLen = 0;
    unsigned char* key = NULL;
    CComBSTR bstrHash;
    HRESULT  hr = S_OK;
    BOOL bSigned = FALSE;
    
    if (crypt && (key = crypt->getKeyMaterial(&keyLen)))
    {
       CBinHex  BinHex;
       CComBSTR binHexedKey;
       //encode the key
       hr = BinHex.ToBase64ASCII((BYTE*)key, keyLen, 0, NULL, &binHexedKey);
       if(hr == S_OK)
       {
          // W2A conversion here -- we sign ascii version
          CStringA tobeHashed(tobeSigned, nChars);
          
          tobeHashed += (LPCSTR)(BSTR)binHexedKey;

          CComBSTR bstrOrg;
          bstrOrg.Attach(::SysAllocStringByteLen((LPCSTR)tobeHashed, tobeHashed.GetLength()));
          
          if(bstrOrg != NULL)
          {
             CComPtr<IMD5>  md5;
 
             HRESULT hr = GetGlobalCOMmd5(&md5);
             if(hr == S_OK)
             {
                hr = md5->MD5Hash(bstrOrg, &bstrHash);
 
                if( hr == S_OK && bstrHash != NULL)
                {
                  *pbstrHash = bstrHash.Detach();
                  bSigned = TRUE;
                }
                else
                {
                   *pbstrHash = NULL;
                   bstrHash.Empty(); // so we can use value to determin if things are hashed
                }
             }
         }
      }
    }
    else
    {
        if (g_pAlert )
        {
            g_pAlert->report(PassportAlertInterface::ERROR_TYPE, PM_CURRENTKEY_NOTDEFINED,
                          0, NULL);
        }
    }

    if (!bSigned && g_pAlert)
        g_pAlert->report(PassportAlertInterface::WARNING_TYPE, PM_URLSIGNATURE_NOTCREATED,
                     0, NULL);
    return hr;
}  


BSTR
FormatAuthURL(
    LPCWSTR pszLoginServerURL,
    ULONG   ulSiteId,
    LPCWSTR pszReturnURL,
    ULONG   ulTimeWindow,
    BOOL    bForceLogin,
    ULONG   ulCurrentKeyVersion,
    time_t  tCurrentTime,
    LPCWSTR pszCoBrand,
    LPCWSTR pszNameSpace,
    int     nKPP,
    USHORT  lang,
    ULONG   ulSecureLevel,
    CRegistryConfig* pCRC,
    BOOL    fRedirToSelf
    )
/*
The old sprintf for reference:
  _snwprintf(text, 2048, L"%s?id=%d&ru=%s&tw=%d&fs=%d&kv=%d&ct=%u%s%s",
             url, crc->getSiteId(), returnUrl, TimeWindow, ForceLogin ? 1 : 0,
             crc->getCurrentCryptVersion(), ct ,CBT?L"&cb=":L"", CBT?CBT:L"");
*/
{
    WCHAR   text[2048] = L"";

    FormatAuthURLParameters(pszLoginServerURL,
                            ulSiteId,
                            pszReturnURL,
                            ulTimeWindow,
                            bForceLogin,
                            ulCurrentKeyVersion,
                            tCurrentTime,
                            pszCoBrand,
                            pszNameSpace,
                            nKPP,
                            text,
                            sizeof(text)/sizeof(WCHAR),
                            lang,
                            ulSecureLevel,
                            pCRC,
                            fRedirToSelf);
    return ALLOC_AND_GIVEAWAY_BSTR(text);
}

//
//  consolidate the code in FormatAuthUrl and NormalLogoTag
//
PWSTR
FormatAuthURLParameters(
    LPCWSTR pszLoginServerURL,
    ULONG   ulSiteId,
    LPCWSTR pszReturnURL,
    ULONG   ulTimeWindow,
    BOOL    bForceLogin,
    ULONG   ulCurrentKeyVersion,
    time_t  tCurrentTime,
    LPCWSTR pszCoBrand,
    LPCWSTR pszNameSpace,
    int     nKPP,
    PWSTR   pszBufStart,
    ULONG   cBufLen,        //  length of buffer in WCHAR
    USHORT  lang,
    ULONG   ulSecureLevel,
    CRegistryConfig* pCRC,
    BOOL    fRedirectToSelf //  if true, this is URL for self redirect
                            //  otherwise the redirect is to the login server
    )
{
    WCHAR   temp[32];
    LPWSTR  pszCurrent = pszBufStart, pszLoginStart, pszSignURLStart = NULL;
    LPCWSTR pszBufEnd = pszBufStart + cBufLen - 1;
    HRESULT hr = S_OK;

    //  helper BSTR ...
    CComBSTR bstrHelper(cBufLen);
    if (fRedirectToSelf)
    {
        //
        //  new authUrl is the return URL + indication a challenge - msppchlg=1 - has to be
        //  done + the rest of the qs parameters as they are in the original
        //  protocol
        //
        DWORD   cchLen = cBufLen;

        if(!InternetCanonicalizeUrl(pszReturnURL,
                                    pszCurrent,
                                    &cchLen,
                                    ICU_DECODE | ICU_NO_ENCODE))
        {
            //  this should not fail ...
            _ASSERT(FALSE);
            return  NULL;
        }

        //  require at least 50 chars
        if (cchLen > cBufLen - 50 )
        {
            _ASSERT(FALSE);
            return  NULL;
        }
        PWSTR psz = pszCurrent;
        while(*psz && *psz != L'?') psz++;
        //  see if URL already contains '?'
        //  if so, the sequence will start with '&'
        if (*psz)
            pszCurrent[cchLen] = L'&';
        else
            pszCurrent[cchLen] = L'?';
        pszCurrent += cchLen + 1;

        // indicate challange
        pszCurrent = CopyHelperW(pszCurrent, PPSITE_CHALLENGE, pszBufEnd);

        // login server ....
        pszCurrent = CopyHelperW(pszCurrent, L"&", pszBufEnd);
        pszCurrent = CopyHelperW(pszCurrent, PPLOGIN_PARAM, pszBufEnd);

        //
        //  remember the start of the login URL
        pszLoginStart = pszCurrent;
        //  use the temp buffer for the rest
        pszCurrent = (BSTR)bstrHelper;
        pszSignURLStart = pszCurrent;
        pszBufEnd = pszCurrent + bstrHelper.Length() - 1;
        //
        //  format loginserverUrl and qs params in a separate buffer, so
        //  they can be escaped ...
        pszCurrent = CopyHelperW(pszCurrent, pszLoginServerURL, pszBufEnd);

        //  start sequence
        if (wcschr(pszLoginServerURL, L'?'))
        {
            //  login server already contains qs
            pszCurrent = CopyHelperW(pszCurrent, L"&", pszBufEnd);
        }
        else
        {
            //  start qs sequence
            pszCurrent = CopyHelperW(pszCurrent, L"?", pszBufEnd);
        }
        //  put lcid first ....
        _ultow(lang, temp, 10);
        pszCurrent = CopyHelperW(pszCurrent, L"lcid=", pszBufEnd);
        pszCurrent = CopyHelperW(pszCurrent, temp, pszBufEnd);
        pszCurrent = CopyHelperW(pszCurrent, L"&id=", pszBufEnd);
        //  common code will fill in id and the rest ....
    }
    else
    {
        //  redirect directly to a login server
        pszSignURLStart = pszCurrent;
        pszCurrent = CopyHelperW(pszCurrent, pszLoginServerURL, pszBufEnd);
        //  start sequence
        while(*pszLoginServerURL && *pszLoginServerURL != L'?') pszLoginServerURL++;
        if (*pszLoginServerURL)
            pszCurrent = CopyHelperW(pszCurrent, L"&id=", pszBufEnd);
        else
            pszCurrent = CopyHelperW(pszCurrent, L"?id=", pszBufEnd);
    }


    _ultow(ulSiteId, temp, 10);
    pszCurrent = CopyHelperW(pszCurrent, temp, pszBufEnd);

    // keep the ru, so I don't have to reconstruct
    pszCurrent = CopyHelperW(pszCurrent, L"&ru=", pszBufEnd);
    pszCurrent = CopyHelperW(pszCurrent, pszReturnURL, pszBufEnd);

    pszCurrent = CopyHelperW(pszCurrent, L"&tw=", pszBufEnd);

    _ultow(ulTimeWindow, temp, 10);
    pszCurrent = CopyHelperW(pszCurrent, temp, pszBufEnd);
    pszCurrent = CopyHelperW(pszCurrent, L"&fs=", pszBufEnd);
    pszCurrent = CopyHelperW(pszCurrent, bForceLogin ? L"1" : L"0", pszBufEnd);
    pszCurrent = CopyHelperW(pszCurrent, L"&kv=", pszBufEnd);

    _ultow(ulCurrentKeyVersion, temp, 10);
    pszCurrent = CopyHelperW(pszCurrent, temp, pszBufEnd);
    pszCurrent = CopyHelperW(pszCurrent, L"&ct=", pszBufEnd);

    _ultow(tCurrentTime, temp, 10);
    pszCurrent = CopyHelperW(pszCurrent, temp, pszBufEnd);
    if(pszCoBrand)
    {
        pszCurrent = CopyHelperW(pszCurrent, L"&cb=", pszBufEnd);
        pszCurrent = CopyHelperW(pszCurrent, pszCoBrand, pszBufEnd);
    }

    if(pszNameSpace)
    {
        if (!_wcsicmp(pszNameSpace, L"email"))
        {
            // namespace == email -> ems=1
            pszCurrent = CopyHelperW(pszCurrent, L"&ems=1", pszBufEnd);
        }
        else
        {
            // regular namespace logic
            pszCurrent = CopyHelperW(pszCurrent, L"&ns=", pszBufEnd);
            pszCurrent = CopyHelperW(pszCurrent, pszNameSpace, pszBufEnd);
        }
    }
    else
    {
        // namespace == null : default to email
        pszCurrent = CopyHelperW(pszCurrent, L"&ems=1", pszBufEnd);
    }

    if(nKPP != -1)
    {
        pszCurrent = CopyHelperW(pszCurrent, L"&kpp=", pszBufEnd);

        _ultow(nKPP, temp, 10);
        pszCurrent = CopyHelperW(pszCurrent, temp, pszBufEnd);
    }

    if(ulSecureLevel != 0)
    {
        pszCurrent = CopyHelperW(pszCurrent, L"&seclog=", pszBufEnd);

        _ultow(ulSecureLevel, temp, 10);
        pszCurrent = CopyHelperW(pszCurrent, temp, pszBufEnd);
    }

    pszCurrent = CopyHelperW(pszCurrent, L"&ver=", pszBufEnd);
    pszCurrent = CopyHelperW(pszCurrent, T2W(GetVersionString()), pszBufEnd);

    // MD5 hash the url and query strings + the key of the 
    // 
    SignQueryString(pCRC, ulCurrentKeyVersion, pszSignURLStart, pszCurrent, pszBufEnd);
#if 0      
    if(pCRC)
    {
       CCoCrypt* crypt = pCRC->getCrypt(ulCurrentKeyVersion, NULL);
       DWORD keyLen = 0;
       DWORD wKeyLen = 0;
       unsigned char* key = NULL;
       CComBSTR bstrHash;
       HRESULT  hr = S_OK;
    
       if (crypt && (key = crypt->getKeyMaterial(&keyLen)))
       {
          CBinHex  BinHex;
          CComBSTR binHexedKey;
          //encode the key
          hr = BinHex.ToBase64((BYTE*)key, keyLen, 0, NULL, &binHexedKey);
          if(hr == S_OK)
          {
             wKeyLen = ::SysStringLen(binHexedKey);
         
             // construct the whole BSTR for hashing
             // re-use the pcurrent buffer
             if(pszCurrent + wKeyLen<= pszBufEnd) // key version has wchar
             {
               memcpy(pszCurrent, binHexedKey, wKeyLen * sizeof(WCHAR));
               *(pszCurrent + wKeyLen) = 0;  // put an end
               
               LPWSTR   signStart = wcschr(pszBufStart, L'?');

               // if found before pszCurrent
               if(signStart && signStart < pszCurrent)
               {
                  ++signStart;;

                  // W2A conversion here -- we sign ascii version
                  CStringA tobeSigned(signStart);

                  CComBSTR bstrOrg;
                  bstrOrg.Attach(::SysAllocStringByteLen((LPCSTR)tobeSigned, tobeSigned.GetLength()));
                  
                  if(bstrOrg != NULL)
                  {
                     CComPtr<IMD5>  md5;

                     HRESULT hr = GetGlobalCOMmd5(&md5);
                     if(hr == S_OK)
                     {
                        hr = md5->MD5Hash(bstrOrg, &bstrHash);

                        if( hr == S_OK && bstrHash != NULL)
                        {
                            pszCurrent = CopyHelperW(pszCurrent, L"&tpf=", pszBufEnd);
                            pszCurrent = CopyHelperW(pszCurrent, bstrHash, pszBufEnd);
                        }
                        else
                            bstrHash.Empty(); // so we can use value to determin if things are hashed
                     }
                  }
               }
            }
         }
       }
       else
       {
           if (g_pAlert )
           {
               g_pAlert->report(PassportAlertInterface::ERROR_TYPE, PM_CURRENTKEY_NOTDEFINED,
                             0, NULL);
           }
       }

       if (!bstrHash && g_pAlert)
           g_pAlert->report(PassportAlertInterface::WARNING_TYPE, PM_URLSIGNATURE_NOTCREATED,
                        0, NULL);
    }  
    else if(g_pAlert)
        g_pAlert->report(PassportAlertInterface::WARNING_TYPE, PM_URLSIGNATURE_NOTCREATED,
                        0, NULL);
      
#endif
    *pszCurrent = L'\0';
    if (fRedirectToSelf)
    {
        //  escape and put back in the original buffer.
        //  adjust the length first
        cBufLen -= (ULONG) (pszLoginStart - pszBufStart);
        if (!PPEscapeUrl((BSTR)bstrHelper,
                         pszLoginStart,
                         &cBufLen,
                         cBufLen,
                         0))
#if 0
        if(!InternetCanonicalizeUrl((BSTR)bstrHelper,
                                    pszBufStart,
                                    &cBufLen,
                                    ICU_ENCODE_PERCENT))
#endif
        {
            _ASSERT(FALSE);
            //  cut the return
            pszCurrent = pszLoginStart;
        }
        else
        {
            pszCurrent = pszLoginStart + cBufLen;
//            pszCurrent = pszBufStart + cBufLen;
        }

    }
    return  pszCurrent;
}

BOOL
GetQueryParam(LPSTR queryString, LPSTR param, BSTR* p)
{
    LPSTR aLoc, aEnd;
    int aLen, i;

    //  Find the first occurrence of the param in the queryString.
    aLoc = strstr(queryString, param);
    while(aLoc != NULL)
    {
        //  If the string was found at the beginning of the string, or was
        //  preceded by a '&' then we've found the correct param.  Otherwise
        //  we tail-matched some other query string param and should look again.

        if(aLoc == queryString ||
            *(aLoc - 1) == '&')
        {
            aLoc += strlen(param);
            aEnd = strchr(aLoc, '&');

            if(aEnd)
                aLen = aEnd - aLoc;
            else
                aLen = strlen(aLoc);

            BSTR aVal = ALLOC_BSTR_LEN(NULL, aLen);
            for (i = 0; i < aLen; i++)
                aVal[i] = aLoc[i];
            *p = aVal;
            GIVEAWAY_BSTR(aVal);
            return TRUE;
        }

        aLoc = strstr(aLoc + 1, param);
    }

    return FALSE;
}

BOOL
GetQueryData(
    LPSTR   queryString,
    BSTR*   a,
    BSTR*   p,
    BSTR*   f)
{
    //  This one is optional, don't error out if it isn't there.
    GetQueryParam(queryString, "f=", f);

    if(!GetQueryParam(queryString, "t=", a))
        return FALSE;

    // OK if we have ticket w/o profile.
    GetQueryParam(queryString, "p=", p);

    return TRUE;
}

#define ToHexDigit(x) (('0' <= x && x <= '9') ? (x - '0') : (tolower(x) - 'a' + 10))

BOOL
GetCookie(
    LPSTR   pszCookieHeader,
    LPSTR   pszCookieName,
    BSTR*   pbstrCookieVal
    )
{
    LPSTR nLoc;
    LPSTR nEnd;
    int   nLen, src, dst;

    if(pbstrCookieVal == NULL)
        return FALSE;

    *pbstrCookieVal = NULL;

    if ((nLoc = strstr(pszCookieHeader, pszCookieName)) == NULL)
    {
        *pbstrCookieVal = NULL;
        return FALSE;
    }

    // ticket

    nLoc = strchr(nLoc, '=');
    if(!nLoc)
        return FALSE;

    nLoc++;

    nEnd = strchr(nLoc,';');

    if (nEnd)
        nLen = nEnd - nLoc;
    else
        nLen = strlen(nLoc);

    BSTR nVal = ALLOC_BSTR_LEN(NULL, nLen);
    if(!nVal)
        return FALSE;

    for (src = 0, dst = 0; src < nLen;)
    {
        //handle any url encoded gunk
        if(nLoc[src] == '%')
        {
            nVal[dst++] = (ToHexDigit(nLoc[src+1]) << 4) + ToHexDigit(nLoc[src+2]);
            src+=3;
        }
        else
        {
            nVal[dst++] = nLoc[src++];
        }
    }
    nVal[dst] = 0;

    GIVEAWAY_BSTR(nVal);
    *pbstrCookieVal = nVal;

    return TRUE;
}


BOOL
BuildCookieHeaders(
    LPCSTR  pszTicket,
    LPCSTR  pszProfile,
    LPCSTR  pszConsent,
    LPCSTR  pszSecure,
    LPCSTR  pszTicketDomain,
    LPCSTR  pszTicketPath,
    LPCSTR  pszConsentDomain,
    LPCSTR  pszConsentPath,
    LPCSTR  pszSecureDomain,
    LPCSTR  pszSecurePath,
    BOOL    bSave,
    LPSTR   pszBuf,
    LPDWORD pdwBufLen
    )
/*
Here is the old code for reference:

    if (domain)
    {
        *bufSize = _snprintf(pCookieHeader, *bufSize,
                            "Set-Cookie: MSPAuth=%s; path=/; domain=%s; %s\r\n"
                            "Set-Cookie: MSPProf=%s; path=/; domain=%s; %s\r\n",
                            W2A(a), domain,
                            persist ? "expires=Mon 1-Jan-2035 12:00:00 GMT;" : "",
                            W2A(p), domain,
                            persist ? "expires=Mon 1-Jan-2035 12:00:00 GMT;" : "");
    }
    else
    {
        *bufSize = _snprintf(pCookieHeader, *bufSize,
                            "Set-Cookie: MSPAuth=%s; path=/; %s\r\n"
                            "Set-Cookie: MSPProf=%s; path=/; %s\r\n",
                            W2A(a),
                            persist ? "expires=Mon 1-Jan-2035 12:00:00 GMT;" : "",
                            W2A(p),
                            persist ? "expires=Mon 1-Jan-2035 12:00:00 GMT;" : "");
    }

*/
{
    LPSTR   pszCurrent = pszBuf;
    LPCSTR  pszBufEnd = pszBuf + *pdwBufLen - 1;

    pszCurrent = CopyHelperA(pszCurrent, "Set-Cookie: MSPAuth=", pszBufEnd);
    pszCurrent = CopyHelperA(pszCurrent, pszTicket, pszBufEnd);
    if(pszTicketPath)
    {
        pszCurrent = CopyHelperA(pszCurrent, "; path=", pszBufEnd);
        pszCurrent = CopyHelperA(pszCurrent, pszTicketPath, pszBufEnd);
        pszCurrent = CopyHelperA(pszCurrent, "; ", pszBufEnd);
    }
    else
        pszCurrent = CopyHelperA(pszCurrent, "; path=/; ", pszBufEnd);

    if(pszTicketDomain)
    {
        pszCurrent = CopyHelperA(pszCurrent, "domain=", pszBufEnd);
        pszCurrent = CopyHelperA(pszCurrent, pszTicketDomain, pszBufEnd);
        pszCurrent = CopyHelperA(pszCurrent, "; ", pszBufEnd);
    }

    if(bSave)
    {
        pszCurrent = CopyHelperA(pszCurrent, "expires=Mon 1-Jan-2035 12:00:00 GMT;", pszBufEnd);
    }

    pszCurrent = CopyHelperA(pszCurrent, "\r\n", pszBufEnd);

    if(pszProfile)
    {
        pszCurrent = CopyHelperA(pszCurrent, "Set-Cookie: MSPProf=", pszBufEnd);
        pszCurrent = CopyHelperA(pszCurrent, pszProfile, pszBufEnd);

        if(pszTicketPath)
        {
            pszCurrent = CopyHelperA(pszCurrent, "; path=", pszBufEnd);
            pszCurrent = CopyHelperA(pszCurrent, pszTicketPath, pszBufEnd);
            pszCurrent = CopyHelperA(pszCurrent, "; ", pszBufEnd);
        }
        else
            pszCurrent = CopyHelperA(pszCurrent, "; path=/; ", pszBufEnd);

        if(pszTicketDomain)
        {
            pszCurrent = CopyHelperA(pszCurrent, "domain=", pszBufEnd);
            pszCurrent = CopyHelperA(pszCurrent, pszTicketDomain, pszBufEnd);
            pszCurrent = CopyHelperA(pszCurrent, "; ", pszBufEnd);
        }

        if(bSave)
        {
            pszCurrent = CopyHelperA(pszCurrent, "expires=Mon 1-Jan-2035 12:00:00 GMT;", pszBufEnd);
        }

        pszCurrent = CopyHelperA(pszCurrent, "\r\n", pszBufEnd);

    }

    if(pszSecure)
    {
        pszCurrent = CopyHelperA(pszCurrent, "Set-Cookie: MSPSecAuth=", pszBufEnd);
        pszCurrent = CopyHelperA(pszCurrent, pszSecure, pszBufEnd);
        if(pszSecurePath)
        {
            pszCurrent = CopyHelperA(pszCurrent, "; path=", pszBufEnd);
            pszCurrent = CopyHelperA(pszCurrent, pszSecurePath, pszBufEnd);
            pszCurrent = CopyHelperA(pszCurrent, "; ", pszBufEnd);
        }
        else
            pszCurrent = CopyHelperA(pszCurrent, "; path=/; ", pszBufEnd);

        if(pszSecureDomain)
        {
            pszCurrent = CopyHelperA(pszCurrent, "domain=", pszBufEnd);
            pszCurrent = CopyHelperA(pszCurrent, pszSecureDomain, pszBufEnd);
            pszCurrent = CopyHelperA(pszCurrent, "; ", pszBufEnd);
        }

        pszCurrent = CopyHelperA(pszCurrent, "secure\r\n", pszBufEnd);
    }

    //  Set MSPConsent cookie
    pszCurrent = CopyHelperA(pszCurrent, "Set-Cookie: MSPConsent=", pszBufEnd);
    if(pszConsent)
    {
        pszCurrent = CopyHelperA(pszCurrent, pszConsent, pszBufEnd);
    }

    if(pszConsentPath)
    {
        pszCurrent = CopyHelperA(pszCurrent, "; path=", pszBufEnd);
        pszCurrent = CopyHelperA(pszCurrent, pszConsentPath, pszBufEnd);
        pszCurrent = CopyHelperA(pszCurrent, "; ", pszBufEnd);
    }
    else
        pszCurrent = CopyHelperA(pszCurrent, "; path=/; ", pszBufEnd);

    if(pszConsentDomain)
    {
        pszCurrent = CopyHelperA(pszCurrent, "domain=", pszBufEnd);
        pszCurrent = CopyHelperA(pszCurrent, pszConsentDomain, pszBufEnd);
        pszCurrent = CopyHelperA(pszCurrent, "; ", pszBufEnd);
    }

    if(pszConsent)
        {
        if(bSave)
        {
            pszCurrent = CopyHelperA(pszCurrent, "expires=Mon 1-Jan-2035 12:00:00 GMT;", pszBufEnd);
        }
    }
    else
    {
        pszCurrent = CopyHelperA(pszCurrent, "expires=Tue 1-Jan-1980 12:00:00 GMT;", pszBufEnd);
    }

    pszCurrent = CopyHelperA(pszCurrent, "\r\n", pszBufEnd);


    //  finally put the Auth-Info header
    pszCurrent = CopyHelperA(pszCurrent,
            "Authentication-Info: tname=MSPAuth,tname=MSPProf,tname=MSPConsent\r\n",
            pszBufEnd);
    *(pszCurrent++) = '\0';

    *pdwBufLen = pszCurrent - pszBuf;

    return TRUE;
}


HRESULT
DecryptTicketAndProfile(
    BSTR                bstrTicket,
    BSTR                bstrProfile,
    BOOL                bCheckConsent,
    BSTR                bstrConsent,
    CRegistryConfig*    pRegistryConfig,
    IPassportTicket*    piTicket,
    IPassportProfile*   piProfile)
{
    HRESULT             hr;
    BSTR                ret = NULL;
    CCoCrypt*           crypt = NULL;
    time_t              tValidUntil;
    time_t              tNow = time(NULL);
    int                 kv;
    int                 nMemberIdHighT, nMemberIdLowT;
    VARIANT             vMemberIdHighP, vMemberIdLowP;
    CComPtr<IPassportTicket2>   spTicket2;

    if (!g_config->isValid()) // Guarantees config is non-null
    {
        AtlReportError(CLSID_FastAuth, PP_E_NOT_CONFIGUREDSTR,
                       IID_IPassportFastAuth, PP_E_NOT_CONFIGURED);
        hr = PP_E_NOT_CONFIGURED;
        goto Cleanup;
    }

    // Make sure we have both ticket and profile first.
    if (bstrTicket == NULL || SysStringLen(bstrTicket) == 0)
    {
      /* this is no longer true for passport 2.0 -- weijiang -- 02/24/01
       it's ok to have only ticket
        //  Did we get profile w/o ticket?  This is a BAD error!
        //  It's ok to get a ticket w/o a profile however
        if(bstrProfile != NULL && SysStringLen(bstrProfile) != 0)
            if (g_pAlert)
                g_pAlert->report(PassportAlertInterface::ERROR_TYPE, PM_PROFILE_WO_TICKET,
                                 0, NULL, SysStringByteLen(bstrProfile), (LPVOID)bstrProfile);
      */
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Get key version and crypt object.
    kv = CCoCrypt::getKeyVersion(bstrTicket);
    crypt = pRegistryConfig->getCrypt(kv, &tValidUntil);

    if (crypt == NULL)
    {
        if (g_pAlert )
            g_pAlert->report(PassportAlertInterface::ERROR_TYPE, PM_INVALID_KEY,
                             0, NULL, SysStringByteLen(bstrTicket), (LPVOID)bstrTicket);
        hr = PP_E_INVALID_TICKET;
        goto Cleanup;
    }

    // Is the key still valid?
    if(tValidUntil && tValidUntil < tNow)
    {
        DWORD dwTimes[2] = { tValidUntil, tNow };
        TCHAR *pszStrings[1];
        TCHAR value[34];   // the _itot only takes upto 33 chars
        pszStrings[0] = _itot(pRegistryConfig->getSiteId(), value, 10);

        if(g_pAlert)
            g_pAlert->report(PassportAlertInterface::WARNING_TYPE, PM_KEY_EXPIRED,
                             1, (LPCTSTR*)pszStrings, sizeof(DWORD) << 1, (LPVOID)dwTimes);
        hr = PP_E_INVALID_TICKET;
        goto Cleanup;
    }

    // Decrypt the ticket and set it into the ticket object.
    if(crypt->Decrypt(bstrTicket, SysStringByteLen(bstrTicket), &ret)==FALSE)
    {
        if(g_pAlert)
            g_pAlert->report(PassportAlertInterface::WARNING_TYPE, PM_INVALID_TICKET_C,
                             0, NULL, SysStringByteLen(bstrTicket), (LPVOID)bstrTicket);
        hr = PP_E_INVALID_TICKET;
        goto Cleanup;
    }

    TAKEOVER_BSTR(ret);
    piTicket->put_unencryptedTicket(ret);
    piTicket->QueryInterface(_uuidof(IPassportTicket2), (void**)&spTicket2);
    _ASSERT(spTicket2);
    FREE_BSTR(ret);
    ret = NULL;

    // Decrypt the profile and set it into the profile object.
    if(bstrProfile && SysStringLen(bstrProfile) != 0)
    {
       if(crypt->Decrypt(bstrProfile, SysStringByteLen(bstrProfile), &ret) == FALSE)
       {
           if(g_pAlert)
               g_pAlert->report(PassportAlertInterface::WARNING_TYPE, PM_INVALID_PROFILE_C,
                             0, NULL, SysStringByteLen(bstrProfile), (LPVOID)bstrProfile);
          piProfile->put_unencryptedProfile(NULL);
       }
       else
       {

          TAKEOVER_BSTR(ret);
          piProfile->put_unencryptedProfile(ret);

          //
          //  Member id in profile MUST match member id in ticket.
          //

          piTicket->get_MemberIdHigh(&nMemberIdHighT);
          piTicket->get_MemberIdLow(&nMemberIdLowT);

          VariantInit(&vMemberIdHighP);
          VariantInit(&vMemberIdLowP);

          // these could be missing for mobile case
          HRESULT hr1 = piProfile->get_Attribute(L"memberidhigh", &vMemberIdHighP);
          HRESULT hr2 = piProfile->get_Attribute(L"memberidlow", &vMemberIdLowP);

          // these could be missing for mobile case
          if(hr1 == S_OK && hr2 == S_OK && 
             (nMemberIdHighT != vMemberIdHighP.lVal ||
              nMemberIdLowT  != vMemberIdLowP.lVal))
          {
              piProfile->put_unencryptedProfile(NULL);
          }
       }
    }
    else
       piProfile->put_unencryptedProfile(NULL);

    //
    // consent stuff
    if(bstrConsent)
    {
       FREE_BSTR(ret);
       ret = NULL;

       if(crypt->Decrypt(bstrConsent, SysStringByteLen(bstrConsent), &ret) == FALSE)
       {
           if(g_pAlert)
               g_pAlert->report(PassportAlertInterface::WARNING_TYPE, PM_INVALID_CONSENT,
                             0, NULL, SysStringByteLen(bstrProfile), (LPVOID)bstrProfile);
            // we can continue
       }
       else
       {
          TAKEOVER_BSTR(ret);
          spTicket2->SetTertiaryConsent(ret);  // we ignore return value here
       }
    }
       
    //  If the caller wants us to check consent, then do it.  If we don't have
    //  consent, then set the profile back to NULL.
    if(bCheckConsent)
    {
       NeedConsentEnum  needConsent = NeedConsent_Undefined;      
       spTicket2->needConsent(NULL, &needConsent);
       switch(needConsent)
       {
       case NeedConsent_Yes:
          piProfile->put_unencryptedProfile(NULL);
          break;
         
       case NeedConsent_Undefined:  // mean 1.X ticket
          {
          CComVariant vFlags;
          // mobile case, flags may not exist
          if(S_OK == piProfile->get_Attribute(L"flags", &vFlags) && 
            (V_I4(&vFlags)& k_ulFlagsConsentCookieNeeded)) 
          {
             piProfile->put_unencryptedProfile(NULL);
          }
          }
          break;
          
       case NeedConsent_No:
          break;
          
       default:
         _ASSERT(0); // should not be here
         break;

       }
    }

    hr = S_OK;

Cleanup:

    if (ret) FREE_BSTR(ret);

    if(g_pPerf)
    {
        switch(hr)
        {
        case PP_E_INVALID_TICKET:
        case E_INVALIDARG:
            g_pPerf->incrementCounter(PM_INVALIDREQUESTS_TOTAL);
            g_pPerf->incrementCounter(PM_INVALIDREQUESTS_SEC);
            break;

        default:
            g_pPerf->incrementCounter(PM_VALIDREQUESTS_TOTAL);
            g_pPerf->incrementCounter(PM_VALIDREQUESTS_SEC);
            break;
        }

        g_pPerf->incrementCounter(PM_REQUESTS_TOTAL);
        g_pPerf->incrementCounter(PM_REQUESTS_SEC);
    }
    else
    {
        _ASSERT(g_pPerf);
    }

    return hr;
}


HRESULT
DoSecureCheck(
    BSTR                bstrSecure,
    CRegistryConfig*    pRegistryConfig,
    IPassportTicket*    piTicket
    )
{
    HRESULT hr;
    BSTR                ret = NULL;
    CCoCrypt*           crypt = NULL;
    time_t              tValidUntil;
    time_t              tNow = time(NULL);
    int                 kv;

    if (!g_config->isValid()) // Guarantees config is non-null
    {
        AtlReportError(CLSID_FastAuth, PP_E_NOT_CONFIGUREDSTR,
                       IID_IPassportFastAuth, PP_E_NOT_CONFIGURED);
        hr = PP_E_NOT_CONFIGURED;
        goto Cleanup;
    }

    // Make sure we have both ticket and profile first.
    if (bstrSecure == NULL || SysStringLen(bstrSecure) == 0)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Get key version and crypt object.
    kv = CCoCrypt::getKeyVersion(bstrSecure);
    crypt = pRegistryConfig->getCrypt(kv, &tValidUntil);

    if (crypt == NULL)
    {
        if (g_pAlert)
            g_pAlert->report(PassportAlertInterface::ERROR_TYPE, PM_INVALID_KEY,
                             0, NULL, sizeof(DWORD), (LPVOID)&kv);
        hr = PP_E_INVALID_TICKET;
        goto Cleanup;
    }

    // Is the key still valid?
    if(tValidUntil && tValidUntil < tNow)
    {
        DWORD dwTimes[2] = { tValidUntil, tNow };
        TCHAR *pszStrings[1];
        TCHAR value[34];   // the _itot only takes upto 33 chars
        pszStrings[0] = _itot(pRegistryConfig->getSiteId(), value, 10);

        if(g_pAlert)
            g_pAlert->report(PassportAlertInterface::WARNING_TYPE, PM_KEY_EXPIRED,
                             1, (LPCTSTR*)pszStrings, sizeof(DWORD) << 1, (LPVOID)dwTimes);
        hr = PP_E_INVALID_TICKET;
        goto Cleanup;
    }

    // Decrypt the ticket and set it into the ticket object.
    if(crypt->Decrypt(bstrSecure, SysStringByteLen(bstrSecure), &ret)==FALSE)
    {
        hr = PP_E_INVALID_TICKET;
        goto Cleanup;
    }

    TAKEOVER_BSTR(ret);
    piTicket->DoSecureCheck(ret);
    FREE_BSTR(ret);
    ret = NULL;

    hr = S_OK;

Cleanup:

    return hr;
}


LPSTR
GetServerVariableECB(
    EXTENSION_CONTROL_BLOCK*    pECB,
    LPSTR                       pszHeader
    )
{
    DWORD   dwSize = 0;
    LPSTR   lpBuf;

    pECB->GetServerVariable(pECB->ConnID, pszHeader, NULL, &dwSize);
    if(GetLastError() != ERROR_INSUFFICIENT_BUFFER || dwSize == 0)
    {
        lpBuf = NULL;
        goto Cleanup;
    }

    lpBuf = new CHAR[dwSize];
    if(!lpBuf)
        goto Cleanup;

    if(!pECB->GetServerVariable(pECB->ConnID, pszHeader, lpBuf, &dwSize))
    {
        delete [] lpBuf;
        lpBuf = NULL;
    }

Cleanup:

    return lpBuf;
}

LPSTR
GetServerVariablePFC(
    PHTTP_FILTER_CONTEXT    pPFC,
    LPSTR                   pszHeader
    )
{
    DWORD   dwSize;
    LPSTR   lpBuf;
    CHAR    cDummy;

    dwSize = 1;
    pPFC->GetServerVariable(pPFC, pszHeader, &cDummy, &dwSize);

    lpBuf = new CHAR[dwSize];
    if(!lpBuf)
        goto Cleanup;

    if(!pPFC->GetServerVariable(pPFC, pszHeader, lpBuf, &dwSize))
    {
        delete [] lpBuf;
        lpBuf = NULL;
    }

Cleanup:

    return lpBuf;
}

LONG
HexToNum(
    WCHAR c
    )
{
    return ((c >= L'0' && c <= L'9') ? (c - L'0') : ((c >= 'A' && c <= 'F') ? (c - L'A' + 10) : -1));
}

LONG
FromHex(
    LPCWSTR     pszHexString
    )
{
    LONG    lResult = 0;
    LONG    lCurrent;
    LPWSTR  pszCurrent;

    for(pszCurrent = const_cast<LPWSTR>(pszHexString); *pszCurrent; pszCurrent++)
    {
        if((lCurrent = HexToNum(towupper(*pszCurrent))) == -1)
            break;  // illegal character, we're done

        lResult = (lResult << 4) + lCurrent;
    }

    return lResult;
}


//
//  helpers for (un)escaping URLs
//  The code is stolen without modifications from atlutil.h in VC7
//  for future versions, these helpers should be removed and the ATL funcs
//  called directly
//
BOOL PPUnescapeUrl(PCWSTR  lpszStringIn,
                   PWSTR   lpszStringOut,
                   LPDWORD pdwStrLen,
                   DWORD   dwMaxLength)
{
    int nValue = 0;
    TCHAR ch;
    DWORD dwLen = 0;
    BOOL bRet = TRUE;
    while ((ch = *lpszStringIn) != 0)
    {
        if (dwLen == dwMaxLength)
            bRet = FALSE;

        if (bRet)
        {
            if (ch == '%')
            {
                ch = *(++lpszStringIn);
                //currently assuming 2 hex values after '%'
                //as per the RFC 2396 document
                nValue = 16*HexToNum(ch);
                nValue+= HexToNum(*(++lpszStringIn));
                *lpszStringOut++ = (TCHAR) nValue;
            }
            else //non-escape character
            {
                if (bRet)
                    *lpszStringOut++ = ch;
            }
        }
        dwLen++;
        lpszStringIn++;
    }

    if (bRet)
        *lpszStringOut = '\0';

    if (pdwStrLen)
        *pdwStrLen = dwLen;

    return TRUE;
}

inline BOOL PPIsUnsafeUrlChar(TCHAR chIn) throw();

BOOL PPEscapeUrl(LPCTSTR lpszStringIn,
                 LPTSTR lpszStringOut,
                 DWORD* pdwStrLen,
                 DWORD dwMaxLength,
                 DWORD dwFlags)
{
    TCHAR ch;
    DWORD dwLen = 0;
    BOOL bRet = TRUE;
    BOOL bSchemeFile = FALSE;
    DWORD dwColonPos = 0;
    DWORD dwFlagsInternal = dwFlags;
    while((ch = *lpszStringIn++) != '\0')
    {
        //if we are at the maximum length, set bRet to FALSE
        //this ensures no more data is written to lpszStringOut, but
        //the length of the string is still updated, so the user
        //knows how much space to allocate
        if (dwLen == dwMaxLength)
        {
            bRet = FALSE;
        }

#if 0
        //  we want % to be encoded!!!
        if (ch == '%')
        {
            //decode the escaped sequence
            ch = (TCHAR)(16*HexToNum(*lpszStringIn++));
            ch = (TCHAR)(ch+HexToNum(*lpszStringIn++));
        }
#endif
        //if we are encoding and it is an unsafe character
        if (PPIsUnsafeUrlChar(ch))
        {
            {
                //if there is not enough space for the escape sequence
                if (dwLen >= (dwMaxLength-3))
                {
                        bRet = FALSE;
                }
                if (bRet)
                {
                        //output the percent, followed by the hex value of the character
                        *lpszStringOut++ = '%';
                        _stprintf(lpszStringOut, _T("%.2X"), (unsigned char)(ch));
                        lpszStringOut+= 2;
                }
                dwLen += 2;
            }
        }
        else //safe character
        {
            if (bRet)
                *lpszStringOut++ = ch;
        }
        dwLen++;
    }

    if (bRet)
        *lpszStringOut = L'\0';
    *pdwStrLen = dwLen;
    return  bRet;
}

//Determine if the character is unsafe under the URI RFC document
inline BOOL PPIsUnsafeUrlChar(TCHAR chIn) throw()
{
        unsigned char ch = (unsigned char)chIn;
        switch(ch)
        {
                case ';': case '\\': case '?': case '@': case '&':
                case '=': case '+': case '$': case ',': case ' ':
                case '<': case '>': case '#': case '%': case '\"':
                case '{': case '}': case '|':
                case '^': case '[': case ']': case '`':
                        return TRUE;
                default:
                {
                        if (ch < 32 || ch > 126)
                                return TRUE;
                        return FALSE;
                }
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\passportmanager\fastauth.h ===
// FastAuth.h : Declaration of the CFastAuth

#ifndef __FASTAUTH_H_
#define __FASTAUTH_H_

#include "resource.h"       // main symbols
#include "passport.h"

//JVP - start
#include "TSLog.h"
extern CTSLog *g_pTSLogger;
//JVP - end

/////////////////////////////////////////////////////////////////////////////
// CFastAuth
class ATL_NO_VTABLE CFastAuth :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CFastAuth, &CLSID_FastAuth>,
    public ISupportErrorInfo,
    public IDispatchImpl<IPassportFastAuth2, &IID_IPassportFastAuth2, &LIBID_PASSPORTLib>
{
public:
    CFastAuth()
    {
        m_pUnkMarshaler = NULL;
//JVP - begin changes
#ifdef PASSPORT_VERBOSE_MODE_ON
    g_pTSLogger->Init(NULL, THREAD_PRIORITY_NORMAL);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes
    }

DECLARE_REGISTRY_RESOURCEID(IDR_FASTAUTH)
DECLARE_NOT_AGGREGATABLE(CFastAuth)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFastAuth)
    COM_INTERFACE_ENTRY(IPassportFastAuth)
    COM_INTERFACE_ENTRY(IPassportFastAuth2)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

    HRESULT FinalConstruct()
    {
        return CoCreateFreeThreadedMarshaler(
            GetControllingUnknown(), &m_pUnkMarshaler.p);
    }

    void FinalRelease()
    {
        m_pUnkMarshaler.Release();
    }

    CComPtr<IUnknown> m_pUnkMarshaler;

// ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IPassportFastAuth
    STDMETHOD(LogoTag)(
                    BSTR            bstrTicket,
                    BSTR            bstrProfile,
                    VARIANT         vRU,
                    VARIANT         vTimeWindow,
                    VARIANT         vForceLogin,
                    VARIANT         vCoBrand,
                    VARIANT         vLangId,
                    VARIANT         vSecure,
                    VARIANT         vLogoutURL,
                    VARIANT         vSiteName,
                    VARIANT         vNameSpace,
                    VARIANT         vKPP,
                    VARIANT         vUseSecureAuth,
                    BSTR*           pbstrLogoTag
                    );
    STDMETHOD(LogoTag2)(
                    BSTR            bstrTicket,
                    BSTR            bstrProfile,
                    VARIANT         vRU,
                    VARIANT         vTimeWindow,
                    VARIANT         vForceLogin,
                    VARIANT         vCoBrand,
                    VARIANT         vLangId,
                    VARIANT         vSecure,
                    VARIANT         vLogoutURL,
                    VARIANT         vSiteName,
                    VARIANT         vNameSpace,
                    VARIANT         vKPP,
                    VARIANT         vUseSecureAuth,
                    BSTR*           pbstrLogoTag
                    );

    STDMETHOD(IsAuthenticated)(
                    BSTR            bstrTicket,
                    BSTR            bstrProfile,
                    VARIANT         vSecure,
                    VARIANT         vTimeWindow,
                    VARIANT         vForceLogin,
                    VARIANT         vSiteName,
                    VARIANT         vDoSecureCheck,
                    VARIANT_BOOL*   pbAuthenticated
                    );

    STDMETHOD(AuthURL)(
                    VARIANT         vTicket,
                    VARIANT         vProfile,
                    VARIANT         vRU,
                    VARIANT         vTimeWindow,
                    VARIANT         vForceLogin,
                    VARIANT         vCoBrand,
                    VARIANT         vLangId,
                    VARIANT         vSecure,
                    VARIANT         vLogoutURL,
                    VARIANT         vReserved1,
                    VARIANT         vSiteName,
                    VARIANT         vNameSpace,
                    VARIANT         vKPP,
                    VARIANT         vUseSecureAuth,
                    BSTR*           pbstrAuthURL
                    );
    STDMETHOD(AuthURL2)(
                    VARIANT         vTicket,
                    VARIANT         vProfile,
                    VARIANT         vRU,
                    VARIANT         vTimeWindow,
                    VARIANT         vForceLogin,
                    VARIANT         vCoBrand,
                    VARIANT         vLangId,
                    VARIANT         vSecure,
                    VARIANT         vLogoutURL,
                    VARIANT         vReserved1,
                    VARIANT         vSiteName,
                    VARIANT         vNameSpace,
                    VARIANT         vKPP,
                    VARIANT         vUseSecureAuth,
                    BSTR*           pbstrAuthURL
                    );

    STDMETHOD(GetTicketAndProfilePFC)(
                    BYTE*           pbPFC,
                    BYTE*           pbPPH,
                    BSTR*           pbstrTicket,
                    BSTR*           pbstrProfile,
                    BSTR*           pbstrSecure,
                    BSTR*           pbstrSiteName
                    );

    STDMETHOD(GetTicketAndProfileECB)(
                    BYTE*           pbECB,
                    BSTR*           pbstrTicket,
                    BSTR*           pbstrProfile,
                    BSTR*           pbstrSecure,
                    BSTR*           pbstrSiteName
                    );
public:
private:
    STDMETHOD(CommonAuthURL)(
                    VARIANT         vTicket,
                    VARIANT         vProfile,
                    VARIANT         vRU,
                    VARIANT         vTimeWindow,
                    VARIANT         vForceLogin,
                    VARIANT         vCoBrand,
                    VARIANT         vLangId,
                    VARIANT         vSecure,
                    VARIANT         vLogoutURL,
                    VARIANT         vReserved1,
                    VARIANT         vSiteName,
                    VARIANT         vNameSpace,
                    VARIANT         vKPP,
                    VARIANT         vUseSecureAuth,
                    BOOL            fRedirToSelf,
                    BSTR*           pbstrAuthURL
                    );
    STDMETHOD(CommonLogoTag)(
                    BSTR            bstrTicket,
                    BSTR            bstrProfile,
                    VARIANT         vRU,
                    VARIANT         vTimeWindow,
                    VARIANT         vForceLogin,
                    VARIANT         vCoBrand,
                    VARIANT         vLangId,
                    VARIANT         vSecure,
                    VARIANT         vLogoutURL,
                    VARIANT         vSiteName,
                    VARIANT         vNameSpace,
                    VARIANT         vKPP,
                    VARIANT         vUseSecureAuth,
                    BOOL            fRedirToSelf,
                    BSTR*           pbstrLogoTag
                    );
};

#endif //__FASTAUTH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\passportmanager\monitoring.h ===
// gmarks
#include "PassportAlertInterface.h"
#include "pmAlertsDefs.h"
#include "pmalerts.h"

#include "PassportPerfDefs.h"	    	// for SHM name defines
#include "msppcntr.h"		// for counter defines
#include "PassportPerfInterface.h"  // for object interface

extern PassportAlertInterface*  g_pAlert;
extern PassportPerfInterface*  g_pPerf;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\passportmanager\manager.h ===
// Manager.h : Declaration of the CManager

#ifndef __MANAGER_H_
#define __MANAGER_H_

#include "resource.h"       // main symbols
#include <asptlb.h>         // Active Server Pages Definitions
#include "Passport.h"
#include "Ticket.h"
#include "Profile.h"
#include "passportservice.h"
#include <httpext.h>
#include <httpfilt.h>

using namespace ATL;
//JVP - start
#include "TSLog.h"
extern CTSLog* g_pTSLogger;
//JVP - end

inline bool IsEmptyString(LPCWSTR str)
{
   if (!str) return true;
   if (*str == 0) return true;
   return false;
};

/////////////////////////////////////////////////////////////////////////////
// CManager
class ATL_NO_VTABLE CManager :
        public CComObjectRootEx<CComMultiThreadModel>,
        public CComCoClass<CManager, &CLSID_Manager>,
        public ISupportErrorInfo,
        public IPassportService,
        public IDispatchImpl<IPassportManager3, &IID_IPassportManager3, &LIBID_PASSPORTLib>,
        public IDomainMap
{
public:
    CManager();
    ~CManager();
#define PPAUTH_INFO_HEADER L"Authentication-Info"

// ?? does this change need to increase passport version # as well  #define PASSPORT_PROT14     L"Passport1.4"
// ??
#define PPCOOKIE_NAMES     L"tname=MSPAuth,tname=MSPProf,tname=MSPConsent"

public:

DECLARE_REGISTRY_RESOURCEID(IDR_MANAGER)
DECLARE_GET_CONTROLLING_UNKNOWN()
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CManager)
  COM_INTERFACE_ENTRY(IPassportManager)
  COM_INTERFACE_ENTRY(IPassportManager2)
  COM_INTERFACE_ENTRY(IPassportManager3)
  COM_INTERFACE_ENTRY(IDispatch)
  COM_INTERFACE_ENTRY(ISupportErrorInfo)
  COM_INTERFACE_ENTRY(IPassportService)
  COM_INTERFACE_ENTRY(IDomainMap)
  COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

        HRESULT FinalConstruct()
        {
            if(m_pUnkMarshaler.p != NULL)
                return S_OK;

            return CoCreateFreeThreadedMarshaler(
                        GetControllingUnknown(), &m_pUnkMarshaler.p);
        }

        void FinalRelease()
        {
                m_pUnkMarshaler.Release();
        }

        CComPtr<IUnknown> m_pUnkMarshaler;

// ISupportsErrorInfo
  STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IPassportManager
public:
        STDMETHOD(HaveConsent)(/*[in]*/ VARIANT_BOOL bNeedFullConsent, /*[in]*/ VARIANT_BOOL bNeedBirthdate, /*[out,retval]*/ VARIANT_BOOL* pbHaveConsent);
        STDMETHOD(GetServerInfo)(/*[out,retval]*/ BSTR *pbstrOut);
  STDMETHOD(Commit)(BSTR *newProf);
  STDMETHOD(get_HasSavedPassword)(/*[out, retval]*/ VARIANT_BOOL *pVal);
  STDMETHOD(get_ProfileByIndex)(/*[in]*/ int index, /*[out, retval]*/ VARIANT *pVal);
  STDMETHOD(put_ProfileByIndex)(/*[in]*/ int index, /*[in]*/ VARIANT newVal);
  STDMETHOD(get_Profile)(/*[in]*/ BSTR attributeName, /*[out, retval]*/ VARIANT *pVal);
  STDMETHOD(put_Profile)(/*[in]*/ BSTR attributeName, /*[in]*/ VARIANT newVal);
  STDMETHOD(DomainFromMemberName)(/*[in,optional]*/ VARIANT memberName, /*[out,retval]*/ BSTR *pDomainName);
  STDMETHOD(GetDomainAttribute)(/*[in]*/ BSTR attributeName, /*[in,optional]*/ VARIANT lcid, /*[in,optional]*/ VARIANT domain, /*[out,retval]*/ BSTR *pAttrVal);
  STDMETHOD(get_TimeSinceSignIn)(/*[out, retval]*/ int *pVal);
  STDMETHOD(get_TicketAge)(/*[out, retval]*/ int *pVal);
  STDMETHOD(get_SignInTime)(/*[out, retval]*/ long *pVal);
  STDMETHOD(get_TicketTime)(/*[out, retval]*/ long *pVal);
  STDMETHOD(HasFlag)(/*[in]*/ VARIANT flagMask, /*[out, retval]*/ VARIANT_BOOL *pVal);
  STDMETHOD(get_FromNetworkServer)(/*[out, retval]*/ VARIANT_BOOL *pVal);
  STDMETHOD(get_HasTicket)(/*[out, retval]*/ VARIANT_BOOL *pVal);
  STDMETHOD(HasProfile)(/*[in]*/ VARIANT profileName, /*[out, retval]*/ VARIANT_BOOL *pVal);
  STDMETHOD(LogoTag)(/*[in]*/ VARIANT returnUrl, /*[in]*/ VARIANT TimeWindow, /*[in]*/ VARIANT ForceLogin, VARIANT coBrandTemplate, VARIANT lang_id, VARIANT bSecure, VARIANT NameSpace, /*[in, optional*/ VARIANT KPP, /*[in, optional]*/ VARIANT UseSecureAuth, /*[out, retval]*/ BSTR *pVal);
  STDMETHOD(LogoTag2)(/*[in]*/ VARIANT returnUrl, /*[in]*/ VARIANT TimeWindow, /*[in]*/ VARIANT ForceLogin, VARIANT coBrandTemplate, VARIANT lang_id, VARIANT bSecure, VARIANT NameSpace, /*[in, optional*/ VARIANT KPP, /*[in, optional]*/ VARIANT UseSecureAuth, /*[out, retval]*/ BSTR *pVal);
  STDMETHOD(IsAuthenticated)(/*[in]*/ VARIANT TimeWindow, /*[in]*/ VARIANT ForceLogin, /*[in,optional]*/ VARIANT CheckSecure, /*[out, retval]*/ VARIANT_BOOL *pVal);
  STDMETHOD(AuthURL)(/*[in]*/ VARIANT returnUrl, /*[in]*/ VARIANT TimeWindow, /*[in]*/ VARIANT ForceLogin, VARIANT coBrandTemplate, VARIANT lang_id, VARIANT NameSpace, /*[in, optional]*/ VARIANT KPP, /*[in, optional]*/ VARIANT UseSecureAuth, /*[out,retval]*/ BSTR *pAuthUrl);
  STDMETHOD(AuthURL2)(/*[in]*/ VARIANT returnUrl, /*[in]*/ VARIANT TimeWindow, /*[in]*/ VARIANT ForceLogin, VARIANT coBrandTemplate, VARIANT lang_id, VARIANT NameSpace, /*[in, optional]*/ VARIANT KPP, /*[in, optional]*/ VARIANT UseSecureAuth, /*[out,retval]*/ BSTR *pAuthUrl);
  //    New API. call it to generate user logon. ASP caller will get a redirect.
  //    isapi callers should not do any more work after this
  STDMETHOD(LoginUser)(/*[in]*/ VARIANT returnUrl,
                       /*[in]*/ VARIANT TimeWindow,
                       /*[in]*/ VARIANT ForceLogin,
                       /*[in]*/ VARIANT coBrandTemplate,
                       /*[in]*/ VARIANT lang_id,
                       /*[in]*/ VARIANT NameSpace,
             /*[in, optional]*/ VARIANT KPP,
             /*[in, optional]*/ VARIANT UseSecureAuth,
             /*[in, optional]*/ VARIANT ExtraParams);
  //Active Server Pages Methods
  STDMETHOD(OnStartPage)(IUnknown* IUnk);
  STDMETHOD(OnStartPageManual)(BSTR qsT, BSTR qsP, BSTR mspauth, BSTR mspprof, BSTR mspconsent, VARIANT vmspsec, VARIANT *pCookies);
  STDMETHOD(OnStartPageECB)(/*[in]*/ LPBYTE pECB, /*[in,out]*/ DWORD *pBufSize, /*[out]*/ LPSTR pCookieHeader);
  STDMETHOD(OnStartPageFilter)(/*[in]*/ LPBYTE pPFC, /*[in,out]*/ DWORD *pBufSize, /*[out]*/ LPSTR pCookieHeader);
  STDMETHOD(OnStartPageASP)(/*[in]*/ IDispatch* pdispRequest, /*[in]*/ IDispatch* pdispResponse);
  STDMETHOD(OnEndPage)();
  STDMETHOD(_Ticket)(IPassportTicket** piTicket);
  STDMETHOD(_Profile)(IPassportProfile** piProfile);
  STDMETHOD(get_Domains)(VARIANT* pArrayVal);
  STDMETHOD(get_Error)(long* pErrorVal);

  // IPassportManager3
  STDMETHOD(get_Ticket)(/*[in]*/ BSTR attributeName, /*[out, retval]*/ VARIANT *pVal);

  #if 0 // removed -- wireless uses the same set of URLs
  STDMETHOD(AuthURL3)(
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT coBrandArgs,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT KPP,
            /* [optional][in] */ VARIANT bUseSecureAuth,
            /* [optional][in] */ VARIANT functionArea,
            /* [retval][out] */  BSTR *pAuthVal);
#endif

   STDMETHOD(GetCurrentConfig)(/*[in]*/ BSTR name, /*[out, retval]*/ VARIANT *pVal)
   {
      if (!m_pRegistryConfig) return PP_E_NOT_INITIALIZEDED;
      else
         return m_pRegistryConfig->GetCurrentConfig(name, pVal);
   };

   STDMETHOD(LogoutURL)(
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT coBrandArgs,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT bSecure,
//            /* [optional][in] */ VARIANT functionArea,
            /* [retval][out] */  BSTR *pVal);

  STDMETHOD(GetLoginChallenge)(/*[in]*/ VARIANT returnUrl,
                       /*[in]*/ VARIANT TimeWindow,
                       /*[in]*/ VARIANT ForceLogin,
                       /*[in]*/ VARIANT coBrandTemplate,
                       /*[in]*/ VARIANT lang_id,
                       /*[in]*/ VARIANT NameSpace,
             /*[in, optional]*/ VARIANT KPP,
             /*[in, optional]*/ VARIANT UseSecureAuth,
             /*[in, optional]*/ VARIANT ExtraParams,
             /*[out, optional]*/ VARIANT *pAuthHeader,
             /*[out, retval]*/ BSTR* pAuthVal
             );

STDMETHOD(get_HexPUID)(/*[out, retval]*/ BSTR *pVal);
STDMETHOD(get_PUID)(/*[out, retval]*/ BSTR *pVal);

// IDomainMap
public:
  // GetDomainAttribute and get_Domains declared above.
  STDMETHOD(DomainExists)(BSTR bstrDomainName, VARIANT_BOOL* pbExists);

// IPassportService
public:
    STDMETHOD(Initialize)(BSTR, IServiceProvider*);
    STDMETHOD(Shutdown)();
    STDMETHOD(ReloadState)(IServiceProvider*);
    STDMETHOD(CommitState)(IServiceProvider*);
    STDMETHOD(DumpState)( BSTR* );

protected:
  void wipeState();

  // return S_OK -- altered, should use two returned output params for MSPAuth and MSPSecAuth as cookies
  HRESULT   IfAlterAuthCookie(BSTR* pMSPAuth, BSTR* pMSPSecAuth);

  // return S_OK -- should use the generated MSPConsent cookie
  HRESULT   IfConsentCookie(BSTR* pMSPConsent);

private:

  STDMETHOD(CommonAuthURL)(VARIANT returnUrl,
                           VARIANT TimeWindow,
                           VARIANT ForceLogin,
                           VARIANT coBrandTemplate,
                           VARIANT lang_id,
                           VARIANT NameSpace,
                           VARIANT KPP,
                           VARIANT UseSecureAuth,
                           BOOL    fRedirToSelf,
                           VARIANT functionArea,
                           BSTR *pAuthUrl);
  BOOL handleQueryStringData(BSTR a, BSTR p);
  BOOL handleCookieData(BSTR a, BSTR p, BSTR c, BSTR s);
  BOOL checkForPassportChallenge(IRequestDictionaryPtr piServerVariables);
  BOOL HeaderFromQS(PWSTR   pszQS, _bstr_t& bstrHeader);
  STDMETHODIMP FormatAuthHeaderFromParams(PCWSTR    pszLoginUrl,    // unused for now
                                          PCWSTR    pszRetUrl,
                                          ULONG     ulTimeWindow,
                                          BOOL      fForceLogin,
                                          time_t    ct,
                                          PCWSTR    pszCBT,         // unused for now
                                          PCWSTR    pszNamespace,
                                          int       nKpp,
                                          PWSTR     pszlcid,
                                          ULONG     ulSecLevel,
                                          _bstr_t&  strHeader   //  return result
                                          );
  STDMETHOD(CommonLogoTag)(VARIANT returnUrl,
                     VARIANT TimeWindow,
                     VARIANT ForceLogin,
                     VARIANT coBrandTemplate,
                     VARIANT lang_id,
                     VARIANT bSecure,
                     VARIANT NameSpace,
                     VARIANT KPP,
                     VARIANT UseSecureAuth,
                     BOOL    fRedirToSelf,
                     BSTR *pVal);
  //    helper for coming up with login paramers based on
  //    what the site passed in and registry configs
  //    someone should put all these in a class, so the number of
  //    params stays manageable
  STDMETHOD(GetLoginParams)(//  this is what the caller passed in
                      VARIANT vRU,
                      VARIANT vTimeWindow,
                      VARIANT vForceLogin,
                      VARIANT vCoBrand,
                      VARIANT vLCID,
                      VARIANT vNameSpace,
                      VARIANT vKPP,
                      VARIANT vUseSecureAuth,
                      //    these are the processed values
                      _bstr_t&  url,
                      _bstr_t&  returnUrl,
                      UINT&     TimeWindow,
                      VARIANT_BOOL& ForceLogin,
                      time_t&   ct,
                      _bstr_t&  strCBT,
                      _bstr_t&  strNameSpace,
                      int&      nKpp,
                      ULONG&    ulSecureLevel,
                      PWSTR     pszlcid);

  VARIANT_BOOL m_profileValid;
  VARIANT_BOOL m_ticketValid;

  CComObject<CTicket>  *m_piTicket;
  CComObject<CProfile> *m_piProfile;

  CRegistryConfig*      m_pRegistryConfig;

  IRequestPtr m_piRequest;                              //Request Object
  IResponsePtr m_piResponse;                            //Response Object
  bool m_bOnStartPageCalled;                            //OnStartPage successful?
//  bool m_bUsingConsentCookie;
  bool m_valid;
  bool m_fromQueryString;
  //    for ISAPI ....
  EXTENSION_CONTROL_BLOCK   *m_pECB;
  PHTTP_FILTER_CONTEXT      m_pFC;
  //    is it 1.4 capable client?
  BOOL  m_bIsTweenerCapable;

  long m_lNetworkError;

  // secure sign in
  bool m_bSecureTransported;
};

#endif //__MANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\passportmanager\helperfuncs.h ===
// HelperFuncs.h : Useful functions

#ifndef __HELPERFUNCS_H_
#define __HELPERFUNCS_H_

#include <httpfilt.h>
#include <httpext.h>
#include "nsconst.h"
#include "passport.h"

typedef enum { PM_LOGOTYPE_SIGNIN, PM_LOGOTYPE_SIGNOUT } PM_LOGOTYPE;

#define  SECURELEVEL_USE_HTTPS(n)   (n >= k_iSeclevelSecureChannel)



BSTR
FormatNormalLogoTag(
    LPCWSTR pszLoginServerURL,
    ULONG   ulSiteId,
    LPCWSTR pszReturnURL,
    ULONG   ulTimeWindow,
    BOOL    bForceLogin,
    ULONG   ulCurrentCryptVersion,
    time_t  tCurrentTime,
    LPCWSTR pszCoBrand,
    LPCWSTR pszImageURL,
    LPCWSTR pszNameSpace,
    int     nKPP,
    PM_LOGOTYPE nLogoType,
    USHORT  lang,
    ULONG   ulSecureLevel,
    CRegistryConfig* pCRC,
    BOOL    fRedirToSelf
    );

BSTR
FormatUpdateLogoTag(
    LPCWSTR pszLoginServerURL,
    ULONG   ulSiteId,
    LPCWSTR pszReturnURL,
    ULONG   ulTimeWindows,
    BOOL    bForceLogin,
    ULONG   ulCurrentKeyVersion,
    time_t  tCurrentTime,
    LPCWSTR pszCoBrand,
    int     nKPP,
    LPCWSTR pszUpdateServerURL,
    BOOL    bSecure,
    LPCWSTR pszProfileUpdate,
    PM_LOGOTYPE nLogoType,
    ULONG   ulSecureLevel,
    CRegistryConfig* pCRC
    );

BSTR
FormatAuthURL(
    LPCWSTR pszLoginServerURL,
    ULONG   ulSiteId,
    LPCWSTR pszReturnURL,
    ULONG   ulTimeWindow,
    BOOL    bForceLogin,
    ULONG   ulCurrentKeyVersion,
    time_t  tCurrentTime,
    LPCWSTR pszCoBrand,
    LPCWSTR pszNameSpace,
    int     nKPP,
    USHORT  lang,
    ULONG   ulSecureLevel,
    CRegistryConfig* pCRC,
    BOOL    fRedirToSelf
    );

BOOL
GetQueryData(
    LPSTR   pszQueryString,
    BSTR*   pbstrTicket,
    BSTR*   pbstrProfile,
    BSTR*   pbstrFlags
    );

BOOL
GetCookie(
    LPSTR   pszCookieHeader,
    LPSTR   pszCookieName,
    BSTR*   pbstrCookieVal
    );

BOOL
BuildCookieHeaders(
    LPCSTR  pszTicket,
    LPCSTR  pszProfile,
    LPCSTR  pszConsent,
    LPCSTR  pszSecure,
    LPCSTR  pszTicketDomain,
    LPCSTR  pszTicketPath,
    LPCSTR  pszConsentDomain,
    LPCSTR  pszConsentPath,
    LPCSTR  pszSecuredomain,
    LPCSTR  pszSecurePath,
    BOOL    bSave,
    LPSTR   pszBuf,
    LPDWORD pdwBufLen
    );

HRESULT
DecryptTicketAndProfile(
    BSTR                bstrTicket,
    BSTR                bstrProfile,
    BOOL                bCheckConsent,
    BSTR                bstrConsent,
    CRegistryConfig*    pRegistryConfig,
    IPassportTicket*    piTicket,
    IPassportProfile*   piProfile
    );

HRESULT
DoSecureCheck(
    BSTR                bstrSecure,
    CRegistryConfig*    pRegistryConfig,
    IPassportTicket*    piTicket
    );

HRESULT
GetSiteNamePFC(
    PHTTP_FILTER_CONTEXT    pfc,
    LPSTR                   szBuf,
    LPDWORD                 lpdwBufLen
    );

HRESULT
GetSiteNameECB(
    EXTENSION_CONTROL_BLOCK*    pECB,
    LPSTR                       szBuf,
    LPDWORD                     lpdwBufLen
    );

LPSTR
GetServerVariableECB(
    EXTENSION_CONTROL_BLOCK*    pECB,
    LPSTR                       pszHeader
    );

LPSTR
GetServerVariablePFC(
    PHTTP_FILTER_CONTEXT    pPFC,
    LPSTR                   pszHeader
    );


LONG
FromHex(
    LPCWSTR     pszHexString
    );

//  max sizes for URLs (without qs) and with
//  these could be a bit opportunistic
#define MAX_URL_LENGTH      2048
#define MAX_QS_LENGTH       2048
#define PP_MAX_ATTRIBUTE_LENGTH MAX_URL_LENGTH
#define PPSITE_CHALLENGE   L"msppchlg=1"
#define PPSITE_CHALLENGE_A  "msppchlg=1"
#define PPLOGIN_PARAM      L"mspplogin="
#define PPLOGIN_PARAM_A     "mspplogin="

//  identification string for the auth method
#define PASSPORT_PROT14     L"Passport1.4"
#define PASSPORT_PROT14_A    "Passport1.4"

PWSTR
FormatAuthURLParameters(
    LPCWSTR pszLoginServerURL,
    ULONG   ulSiteId,
    LPCWSTR pszReturnURL,
    ULONG   ulTimeWindow,
    BOOL    bForceLogin,
    ULONG   ulCurrentKeyVersion,
    time_t  tCurrentTime,
    LPCWSTR pszCoBrand,
    LPCWSTR pszNameSpace,
    int     nKPP,
    PWSTR   pszBufStart,
    ULONG   cBufLen,
    USHORT  lang,
    ULONG   ulSecureLevel,
    CRegistryConfig* pCRC,
    BOOL    fRedirectToSelf
    );

HRESULT SignQueryString(
    CRegistryConfig* pCRC,
    ULONG   ulCurrentKeyVersion,
    LPWSTR  pszBufStart,
    LPWSTR& pszCurrent,
    LPCWSTR pszBufEnd
    );

HRESULT PartnerHash(
    CRegistryConfig* pCRC,
    ULONG   ulCurrentKeyVersion,
    LPCWSTR tobeSigned,
    ULONG   nChars,
    BSTR*   pbstrHash);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\passportmanager\manager.cpp ===
// Manager.cpp : Implementation of CManager
#include "stdafx.h"
#include <httpext.h>
#include "Manager.h"
#include <httpfilt.h>
#include <time.h>
#include <malloc.h>
#include <wininet.h>

#include <nsconst.h>

#include "VariantUtils.h"
#include "HelperFuncs.h"
#include "PassportService_i.c"


PWSTR GetVersionString();


// gmarks
#include "Monitoring.h"
/////////////////////////////////////////////////////////////////////////////
// CManager

#include "passporttypes.h"

//  static utility func
static VOID GetTicketAndProfileFromHeader(PWSTR  pszAuthHeader,
                                          PWSTR& tix,
                                          PWSTR& prof,
                                          PWSTR& F);

//  Used for cookie expiration.
const DATE g_dtExpire = 365*137;
const DATE g_dtExpired = 365*81;


CManager::CManager() :
  m_fromQueryString(false), m_ticketValid(VARIANT_FALSE), m_profileValid(VARIANT_FALSE), m_lNetworkError(0),
  m_pRegistryConfig(NULL), m_pECB(NULL), m_pFC(NULL),
  m_bIsTweenerCapable(FALSE),
  m_bSecureTransported(false)
{
  m_pUnkMarshaler = NULL;
  m_piTicket = new CComObject<CTicket>();
  m_piTicket->AddRef();
  m_piProfile = new CComObject<CProfile>();
  m_piProfile->AddRef();

  m_bOnStartPageCalled = false;

  m_valid = true;
}


CManager::~CManager()
{
  if(m_pRegistryConfig)
      m_pRegistryConfig->Release();
  m_piTicket->Release();
  m_piProfile->Release();
}

 // return S_OK -- altered, should use two returned output params for MSPAuth and MSPSecAuth as cookies
// S_FALSE -- not altered
// if MSPSecAuth != NULL, write the cookie


HRESULT CManager::IfConsentCookie(BSTR* pMSPConsent)
{
   HRESULT  hr = S_FALSE;
   LPCSTR   domain = m_pRegistryConfig->getTicketDomain();
   LPCSTR   path = m_pRegistryConfig->getTicketPath();
   LPCSTR   tertiaryDomain = m_pRegistryConfig->getProfileDomain();
   LPCSTR   tertiaryPath = m_pRegistryConfig->getProfilePath();

   if (!tertiaryPath)   tertiaryPath = "/";

   if(!domain)    domain = "";
   if(!path)    path = "";

   if(!tertiaryDomain)    tertiaryDomain = "";
   if(!tertiaryPath)    tertiaryPath = "";

   if((lstrcmpiA(domain, tertiaryDomain) || lstrcmpiA(path, tertiaryPath)) &&
                   (m_piTicket->GetPassportFlags() & k_ulFlagsConsentCookieNeeded) &&
                   !m_pRegistryConfig->bInDA() )
   {
      if (pMSPConsent == NULL)   // only to test, no output
         hr = S_OK;
      else
      {
         *pMSPConsent = NULL;

         CComBSTR bstrRawConsent;

         CCoCrypt* crypt = m_pRegistryConfig->getCurrentCrypt();
         if (!crypt)
         {
            hr = E_FAIL;
            goto Cleanup;
         }

         hr = m_piTicket->get_unencryptedCookie(CTicket::MSPConsent, 0, &bstrRawConsent);
         if (FAILED(hr)) goto Cleanup;

         crypt->Encrypt(m_pRegistryConfig->getCurrentCryptVersion(),
                  (LPSTR)(BSTR)bstrRawConsent,
                  SysStringByteLen(bstrRawConsent),
                  pMSPConsent);
      }
   }

   Cleanup:

   return hr;
 }


 // return S_OK -- altered, should use two returned output params for MSPAuth and MSPSecAuth as cookies
// S_FALSE -- not altered
// if MSPSecAuth != NULL, write the cookie
HRESULT CManager::IfAlterAuthCookie(BSTR* pMSPAuth, BSTR* pMSPSecAuth)
{
   _ASSERT(pMSPAuth && pMSPSecAuth);

   *pMSPAuth = NULL;
   *pMSPSecAuth = NULL;

   HRESULT  hr = S_FALSE;

   if (!(m_piTicket->GetPassportFlags() & k_ulFlagsSecuredTransportedTicket) || !m_bSecureTransported)
      return hr;

   CComBSTR bstrRawAuth;
   CComBSTR bstrRawSecAuth;

   CCoCrypt* crypt = m_pRegistryConfig->getCurrentCrypt();
   if (!crypt)
   {
      hr = PM_CANT_DECRYPT_CONFIG;
      goto Cleanup;
   }

   hr = m_piTicket->get_unencryptedCookie(CTicket::MSPAuth, 0, &bstrRawAuth);
   if (FAILED(hr)) goto Cleanup;

   crypt->Encrypt(m_pRegistryConfig->getCurrentCryptVersion(),
                  (LPSTR)(BSTR)bstrRawAuth,
                  SysStringByteLen(bstrRawAuth),
                  pMSPAuth);

   hr = m_piTicket->get_unencryptedCookie(CTicket::MSPSecAuth, 0, &bstrRawSecAuth);
   if (FAILED(hr)) goto Cleanup;

   crypt->Encrypt(m_pRegistryConfig->getCurrentCryptVersion(),
                  (LPSTR)(BSTR)bstrRawSecAuth,
                  SysStringByteLen(bstrRawSecAuth),
                  pMSPSecAuth);

Cleanup:

   return hr;
 }


void
CManager::wipeState()
{
    m_pECB = NULL;
    m_pFC = NULL;
    m_bIsTweenerCapable = FALSE;
    m_bOnStartPageCalled    = false;
    m_fromQueryString       = false;
    m_lNetworkError         = 0;
    m_ticketValid           = VARIANT_FALSE;
    m_profileValid          = VARIANT_FALSE;
    m_piRequest             = NULL;
    m_piResponse            = NULL;

    m_piTicket->put_unencryptedTicket(NULL);
    m_piProfile->put_unencryptedProfile(NULL);

    if(m_pRegistryConfig)
    {
        m_pRegistryConfig->Release();
        m_pRegistryConfig = NULL;
    }
}


STDMETHODIMP CManager::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] =
    {
        &IID_IPassportManager,
    };
    for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}

STDMETHODIMP CManager::OnStartPage (IUnknown* pUnk)
{
    IScriptingContextPtr  spContext;
    IRequestDictionaryPtr piServerVariables;
    _variant_t            vtItemName;
    _variant_t            vtServerName;
    _variant_t            vtServerPort;
    _variant_t            vtHTTPS;
    BOOL                  bHasPort;
    DWORD                 dwServerNameLen;

    USES_CONVERSION;

//JVP - begin changes
#ifdef PASSPORT_VERBOSE_MODE_ON
        char szLogString[LOG_STRING_LEN] = "CManager::OnStartPage, Enter";
        g_pTSLogger->AddDateTimeAndLog(szLogString);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes

    if(!pUnk)
    return E_POINTER;

    if (!m_valid || !g_config->isValid()) // Guarantees config is non-null
    {
        AtlReportError(CLSID_Manager, PP_E_NOT_CONFIGUREDSTR,
                            IID_IPassportManager, PP_E_NOT_CONFIGURED);
        return PP_E_NOT_CONFIGURED;
    }

    wipeState();

    try
    {
        // Get the IScriptingContext Interface
        spContext = pUnk;
        // Get Request Object Pointer
        m_piRequest  = spContext->Request;
        // Get Response Object Pointer
        m_piResponse = spContext->Response;

        //
        //  Get the server variables collection.
        //

        m_piRequest->get_ServerVariables(&piServerVariables);

        //
        //  now see if that's a special redirect
        //  requiring challenge generation
        //  if so processing stops here ....
        //
        if (checkForPassportChallenge(piServerVariables))
            return  S_OK;

        //
        //  Might need this for multi-site, or secure ticket/profile
        //

        vtItemName = L"HTTPS";

        piServerVariables->get_Item(vtItemName, &vtHTTPS);
        if(vtHTTPS.vt != VT_BSTR)
            vtHTTPS.ChangeType(VT_BSTR);

        if(lstrcmpiW(L"on", vtHTTPS.bstrVal) == 0)
           m_bSecureTransported = true;
        else
           m_bSecureTransported = false;

        //
        //  Use the request object to get the server name being requested
        //  so we can get the correct registry config.  But only do this
        //  if we have some configured sites.
        //

        if(g_config->HasSites())
        {
            LPWSTR  szServerName;

            vtItemName.Clear();
            vtItemName = L"SERVER_NAME";

            piServerVariables->get_Item(vtItemName, &vtServerName);
            if(vtServerName.vt != VT_BSTR)
                vtServerName.ChangeType(VT_BSTR);

            vtItemName.Clear();
            vtItemName = L"SERVER_PORT";

            piServerVariables->get_Item(vtItemName, &vtServerPort);
            if(vtServerPort.vt != VT_BSTR)
                vtServerPort.ChangeType(VT_BSTR);

            //  If not default port, append ":port" to server name.
            bHasPort = (!m_bSecureTransported && lstrcmpW(L"80", vtServerPort.bstrVal) != 0
                        || m_bSecureTransported && lstrcmpW(L"443", vtServerPort.bstrVal) != 0);
            dwServerNameLen = bHasPort ?
                lstrlenW(vtServerName.bstrVal) + lstrlenW(vtServerPort.bstrVal) + 2 :
                lstrlenW(vtServerName.bstrVal) + 1;

            szServerName = new WCHAR[dwServerNameLen];
            if(szServerName)
            {
                lstrcpyW(szServerName, vtServerName.bstrVal);
                if(bHasPort)
                {
                    lstrcatW(szServerName, L":");
                    lstrcatW(szServerName, vtServerPort.bstrVal);
                }

                if(m_pRegistryConfig)
                    m_pRegistryConfig->Release();
                m_pRegistryConfig = g_config->checkoutRegistryConfig(W2A(szServerName));

                delete [] szServerName;
            }
        }
        else
        {
            if(m_pRegistryConfig)
                m_pRegistryConfig->Release();
            m_pRegistryConfig = g_config->checkoutRegistryConfig();
        }

        m_bOnStartPageCalled = true;

        //  check if client has accept-auth header
        vtItemName.Clear();
        vtItemName = L"HTTP_Accept-Auth";
        {
            _variant_t vtAccept;
            piServerVariables->get_Item(vtItemName, &vtAccept);
            if(vtAccept.vt != VT_BSTR)
                vtAccept.ChangeType(VT_BSTR);
            if (vtAccept.vt == VT_BSTR && vtAccept.bstrVal &&
                wcsstr(vtAccept.bstrVal, PASSPORT_PROT14))
            {
                m_bIsTweenerCapable = TRUE;
            }
        }

        // BUGBUG I think this might not always return a single value
        //  Variables to hold ticket and profile
        _bstr_t bstrAuth;
        _bstr_t bstrProf;

        //  first check the auth header!!!
        BOOL        fFromAuthHeader = FALSE;
        vtItemName.Clear();
        vtItemName = L"HTTP_Authorization";

        _variant_t  vtAuth;
        piServerVariables->get_Item(vtItemName, &vtAuth);
        if(vtAuth.vt != VT_BSTR)
            vtAuth.ChangeType(VT_BSTR);

        BOOL    fQueryStringLogon = FALSE;
        if (vtAuth.vt == VT_BSTR && vtAuth.bstrVal &&
            wcsstr(vtAuth.bstrVal, PASSPORT_PROT14))
        {
            fFromAuthHeader = TRUE;
            //  ticket and profile from the header
            PWSTR   pwszTicket = NULL, pwszProfile = NULL, pwszF = NULL;
            GetTicketAndProfileFromHeader(vtAuth.bstrVal, pwszTicket, pwszProfile, pwszF);
            if(pwszF != 0)
                m_lNetworkError = _wtol(pwszF);
            //  init for more use
            bstrAuth = pwszTicket;
            bstrProf = pwszProfile;
        }
        else
        {
            // if not, check the query string
            IRequestDictionaryPtr piQueryStr = m_piRequest->QueryString;
            bstrAuth = piQueryStr->Item[L"t"];
            bstrProf = piQueryStr->Item[L"p"];
            _bstr_t bstrError = piQueryStr->Item[L"f"];

            if(bstrError.length() != 0)
                m_lNetworkError = _wtol(bstrError);
        }


        if (handleQueryStringData(bstrAuth, bstrProf))
        {
            VARIANT_BOOL persist;
            _bstr_t domain;
            _bstr_t path;

            if (m_pRegistryConfig->getTicketPath())
                path = m_pRegistryConfig->getTicketPath();
            else
                path = L"/";

            m_piTicket->get_HasSavedPassword(&persist);
            IRequestDictionaryPtr piCookies = m_piResponse->Cookies;

            VARIANT vtNoParam;
            VariantInit(&vtNoParam);
            vtNoParam.vt = VT_ERROR;
            vtNoParam.scode = DISP_E_PARAMNOTFOUND;

            CComBSTR bstrNewAuth;
            CComBSTR bstrNewSecAuth;

            BSTR  auth, secAuth; // do not call SysFreeString on them, they are skin level copy

            if (S_OK == IfAlterAuthCookie(&bstrNewAuth, &bstrNewSecAuth))
            {
               auth = bstrNewAuth;
               secAuth = bstrNewSecAuth;
            }
            else
            {
               auth = bstrAuth;
               secAuth = NULL;
            }

            // ==
            // write auth cookies

            // MSPAuth
            IWriteCookiePtr piCookie = piCookies->Item[L"MSPAuth"];
            piCookie->Item[vtNoParam] = auth;

            domain = m_pRegistryConfig->getTicketDomain();
            if (domain.length())
                piCookie->put_Domain(domain);
            if (persist)
                piCookie->put_Expires(g_dtExpire);
            piCookie->put_Path(path);

            // MSPSecAuth
            if (m_bSecureTransported)
            {
               piCookie = piCookies->Item[L"MSPSecAuth"];
               piCookie->Item[vtNoParam] = secAuth;

               domain = m_pRegistryConfig->getTicketDomain();
               if (domain.length())
                   piCookie->put_Domain(domain);
               if (persist)
                   piCookie->put_Expires(g_dtExpire);
               piCookie->put_Path(path);
               piCookie->put_Secure(VARIANT_TRUE);
            }

            // write profile cookies
            if((LPWSTR)bstrProf && bstrProf.length() != 0)
            {
                piCookie = piCookies->Item[L"MSPProf"];
                piCookie->Item[vtNoParam] = bstrProf;

                if (domain.length())
                    piCookie->put_Domain(domain);
                if (persist)
                    piCookie->put_Expires(g_dtExpire);
                piCookie->put_Path(path);

            }

            //  if New client, put the auth Info in header
            //  move out of the profile condition
            if (fFromAuthHeader)
            {
               //  ticket and profile came in a header ...
               WCHAR   wszAuthHeader[100];
               wsprintf(wszAuthHeader, L"%ws %ws", PASSPORT_PROT14, PPCOOKIE_NAMES);
               m_piResponse->AddHeader(PPAUTH_INFO_HEADER, wszAuthHeader);
            }

            //
            // MSPConsent Cookie
            _bstr_t  bstrConsentCookie;
            CComBSTR bstrtemp;
            HRESULT hr = IfConsentCookie(&bstrtemp);
            bstrConsentCookie = bstrtemp;

            piCookie = piCookies->Item[L"MSPConsent"];

            if (hr == S_OK)
            {
                piCookie->Item[vtNoParam] = bstrConsentCookie;
                if (persist) piCookie->put_Expires(g_dtExpire);
            }
            // need delete
            else
            {
                piCookie->Item[vtNoParam] = L"";
                piCookie->put_Expires(g_dtExpired);
            }


            if (m_pRegistryConfig->getProfilePath())
                path = m_pRegistryConfig->getProfilePath();
            else
                path = L"/";

            domain = m_pRegistryConfig->getProfileDomain();
            if (domain.length()) piCookie->put_Domain(domain);
            piCookie->put_Path(path);
            // end of consent cookie
            //

            if(g_pPerf)
            {
                g_pPerf->incrementCounter(PM_NEWCOOKIES_SEC);
                g_pPerf->incrementCounter(PM_NEWCOOKIES_TOTAL);
            }
            else
            {
                _ASSERT(g_pPerf);
            }
        }

        // Now, check the cookies
        if (!m_fromQueryString)
        {
            IRequestDictionaryPtr piCookies = m_piRequest->Cookies;
            bstrAuth  = piCookies->Item[L"MSPAuth"];

            bstrProf  = piCookies->Item[L"MSPProf"];
            _bstr_t bstrSec   = piCookies->Item[L"MSPSecAuth"];

            _bstr_t bstrConsent = piCookies->Item[L"MSPConsent"];

            handleCookieData(bstrAuth, bstrProf, bstrConsent, bstrSec);
        }

    }
    catch (...)
    {
        if (m_piRequest.GetInterfacePtr() != NULL)
            m_piRequest.Release();
        if (m_piResponse.GetInterfacePtr() != NULL)
            m_piResponse.Release();
        m_bOnStartPageCalled = false;
        return S_OK;
    }

//JVP - begin changes
#ifdef PASSPORT_VERBOSE_MODE_ON
        g_pTSLogger->AddDateTimeAndLog("CManager::OnStartPage, Exit");
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes

    return S_OK;
}

STDMETHODIMP CManager::OnStartPageASP(
    IDispatch*  piRequest,
    IDispatch*  piResponse
    )
{
    IRequestDictionaryPtr piServerVariables;
    _variant_t            vtItemName;
    _variant_t            vtServerName;
    _variant_t            vtServerPort;
    _variant_t            vtHTTPS;
    BOOL                  bHasPort;
    DWORD                 dwServerNameLen;

    USES_CONVERSION;

    if(!piRequest || !piResponse)
        return E_POINTER;

    if (!m_valid || !g_config->isValid()) // Guarantees config is non-null
    {
        AtlReportError(CLSID_Manager, PP_E_NOT_CONFIGUREDSTR,
                       IID_IPassportManager, PP_E_NOT_CONFIGURED);
        return PP_E_NOT_CONFIGURED;
    }

    wipeState();

    m_piRequest = piRequest;
    m_piResponse = piResponse;

    //
    //  Get the server variables collection.
    //

    m_piRequest->get_ServerVariables(&piServerVariables);

    //
    //  Might need this for multi-site, or secure ticket/profile
    //

    vtItemName = L"HTTPS";

    piServerVariables->get_Item(vtItemName, &vtHTTPS);
    if(vtHTTPS.vt != VT_BSTR)
        vtHTTPS.ChangeType(VT_BSTR);

    if(lstrcmpiW(L"on", vtHTTPS.bstrVal) == 0)
        m_bSecureTransported = true;
    else
        m_bSecureTransported = false;


    try
    {
        //
        //  Use the request object to get the server name being requested
        //  so we can get the correct registry config.  But only do this
        //  if we have some configured sites.
        //

        if(g_config->HasSites())
        {
            LPWSTR  szServerName;

            vtItemName.Clear();
            vtItemName = L"SERVER_NAME";

            piServerVariables->get_Item(vtItemName, &vtServerName);
            if(vtServerName.vt != VT_BSTR)
                vtServerName.ChangeType(VT_BSTR);

            VariantClear(&vtItemName);
            vtItemName = L"SERVER_PORT";

            piServerVariables->get_Item(vtItemName, &vtServerPort);
            if(vtServerPort.vt != VT_BSTR)
                vtServerPort.ChangeType(VT_BSTR);

            //  If not default port, append ":port" to server name.
            bHasPort = (!m_bSecureTransported && lstrcmpW(L"80", vtServerPort.bstrVal) != 0
                        || m_bSecureTransported && lstrcmpW(L"443", vtServerPort.bstrVal) != 0);
            dwServerNameLen = bHasPort ?
                              lstrlenW(vtServerName.bstrVal) + lstrlenW(vtServerPort.bstrVal) + 2 :
                              lstrlenW(vtServerName.bstrVal) + 1;

            szServerName = new WCHAR[dwServerNameLen];
            if(szServerName)
            {
                lstrcpyW(szServerName, vtServerName.bstrVal);
                if(bHasPort)
                {
                    lstrcatW(szServerName, L":");
                    lstrcatW(szServerName, vtServerPort.bstrVal);
                }

                if(m_pRegistryConfig)
                    m_pRegistryConfig->Release();
                m_pRegistryConfig = g_config->checkoutRegistryConfig(W2A(szServerName));

                delete [] szServerName;
            }
        }
        else
        {
            if(m_pRegistryConfig)
                m_pRegistryConfig->Release();
            m_pRegistryConfig = g_config->checkoutRegistryConfig();
        }


        m_bOnStartPageCalled = true;

        // BUGBUG I think this might not always return a single value
        _bstr_t bstrAuth;
        _bstr_t bstrProf;
//        _bstr_t bstrSec;
        //  check for Auth header
        vtItemName.Clear();
        vtItemName = L"HTTP_Authorization";

        _variant_t  vtAuth;
        BOOL        fFromAuthHeader = FALSE;
        piServerVariables->get_Item(vtItemName, &vtAuth);
        if(vtAuth.vt != VT_BSTR)
            vtAuth.ChangeType(VT_BSTR);

        if (vtAuth.vt == VT_BSTR && vtAuth.bstrVal &&
            wcsstr(vtAuth.bstrVal, PASSPORT_PROT14))
        {
            //  ticket and profile from the header
            PWSTR   pwszTicket = NULL, pwszProfile = NULL, pwszF = NULL;
            //  handle the auth header
            GetTicketAndProfileFromHeader(vtAuth.bstrVal, pwszTicket, pwszProfile, pwszF);
            //  initialize for later use.
            bstrAuth = pwszTicket;
            bstrProf = pwszProfile;
            if (pwszF)
                m_lNetworkError = _wtol(pwszF);
            fFromAuthHeader = TRUE;
        }
        else
        {
            //  old client - handle query string
            IRequestDictionaryPtr piQueryStr = m_piRequest->QueryString;
            // BUGBUG I think this might not always return a single value
            bstrAuth = piQueryStr->Item[L"t"];
            bstrProf = piQueryStr->Item[L"p"];
            _bstr_t bstrError = piQueryStr->Item[L"f"];
            if(bstrError.length() != 0)
                m_lNetworkError = _wtol(bstrError);
        }


        if (handleQueryStringData(bstrAuth, bstrProf))
        {
            VARIANT_BOOL persist;
            _bstr_t domain;
            _bstr_t path;

            if (m_pRegistryConfig->getTicketPath())
                path = m_pRegistryConfig->getTicketPath();
            else
                path = L"/";

            m_piTicket->get_HasSavedPassword(&persist);
            IRequestDictionaryPtr piCookies = m_piResponse->Cookies;

            VARIANT vtNoParam;
            VariantInit(&vtNoParam);
            vtNoParam.vt = VT_ERROR;
            vtNoParam.scode = DISP_E_PARAMNOTFOUND;

            // write Auth cookies
            CComBSTR bstrNewAuth;
            CComBSTR bstrNewSecAuth;

            BSTR  auth, secAuth; // do not call SysFreeString on them, they are skin level copy

            if (S_OK == IfAlterAuthCookie(&bstrNewAuth, &bstrNewSecAuth))
            {
               auth = bstrNewAuth;
               secAuth = bstrNewSecAuth;
            }
            else
            {
               auth = bstrAuth;
               secAuth = NULL;
            }

            // ==
            // write auth cookies

            // MSPAuth
            IWriteCookiePtr piCookie = piCookies->Item[L"MSPAuth"];
            piCookie->Item[vtNoParam] = auth;

            domain = m_pRegistryConfig->getTicketDomain();
            if (domain.length())
                piCookie->put_Domain(domain);
            if (persist)
                piCookie->put_Expires(g_dtExpire);
            piCookie->put_Path(path);

            // MSPSecAuth
            if (m_bSecureTransported)
            {
               piCookie = piCookies->Item[L"MSPSecAuth"];
               piCookie->Item[vtNoParam] = secAuth;

               domain = m_pRegistryConfig->getTicketDomain();
               if (domain.length())
                   piCookie->put_Domain(domain);
               if (persist)
                   piCookie->put_Expires(g_dtExpire);
               piCookie->put_Path(path);
               piCookie->put_Secure(VARIANT_TRUE);
            }


            // profile cookie
            if((LPWSTR)bstrProf)
            {
                piCookie = piCookies->Item[L"MSPProf"];
                piCookie->Item[vtNoParam] = bstrProf;

                if (domain.length())
                    piCookie->put_Domain(domain);
                if (persist)
                    piCookie->put_Expires(g_dtExpire);
                piCookie->put_Path(path);

            }

            if (fFromAuthHeader)
            {
                //  insert auth info header ...
                //  ticket and profile came in a header ...
                WCHAR   wszAuthHeader[100];
                wsprintf(wszAuthHeader, L"%ws %ws", PASSPORT_PROT14, PPCOOKIE_NAMES);
                m_piResponse->AddHeader(PPAUTH_INFO_HEADER, wszAuthHeader);
            }

            //
            // MSPConsent Cookie
            _bstr_t  bstrConsentCookie;
            CComBSTR bstrtemp;
            HRESULT hr = IfConsentCookie(&bstrtemp);
            bstrConsentCookie = bstrtemp;

            piCookie = piCookies->Item[L"MSPConsent"];

            if (hr == S_OK)
            {
                piCookie->Item[vtNoParam] = bstrConsentCookie;
                if (persist) piCookie->put_Expires(g_dtExpire);
            }
            else
            {
                piCookie->Item[vtNoParam] = L"";
                piCookie->put_Expires(g_dtExpired);
            }


            if (m_pRegistryConfig->getProfilePath())
                path = m_pRegistryConfig->getProfilePath();
            else
                path = L"/";

            domain = m_pRegistryConfig->getProfileDomain();
            if (domain.length()) piCookie->put_Domain(domain);
            piCookie->put_Path(path);
            // end of consent cookie
            //


            if(g_pPerf)
            {
                g_pPerf->incrementCounter(PM_NEWCOOKIES_SEC);
                g_pPerf->incrementCounter(PM_NEWCOOKIES_TOTAL);
            }
            else
            {
                _ASSERT(g_pPerf);
            }

        }

        // Now, check the cookies
        if (!m_fromQueryString)
        {
            IRequestDictionaryPtr piCookies = m_piRequest->Cookies;
            bstrAuth = piCookies->Item[L"MSPAuth"];
            bstrProf = piCookies->Item[L"MSPProf"];

            // secure cookie
            _bstr_t bstrSec  = piCookies->Item[L"MSPSecAuth"];

            _bstr_t bstrConsent = piCookies->Item[L"MSPConsent"];

            handleCookieData(bstrAuth, bstrProf, bstrConsent, bstrSec);
        }

    }
    catch (...)
    {
        if (m_piRequest.GetInterfacePtr() != NULL)
            m_piRequest.Release();
        if (m_piResponse.GetInterfacePtr() != NULL)
            m_piResponse.Release();
        m_bOnStartPageCalled = false;
        return S_OK;
    }

    return S_OK;
}

STDMETHODIMP CManager::OnStartPageManual(
    BSTR        qsT,
    BSTR        qsP,
    BSTR        mspauth,
    BSTR        mspprof,
    BSTR        mspconsent,
    VARIANT     mspsec,
    VARIANT*    pCookies
    )
{
    int                 hasSec;
    BSTR                bstrSec;

//JVP - begin changes
#ifdef PASSPORT_VERBOSE_MODE_ON
        char szLogString[LOG_STRING_LEN] = "CManager::OnStartPageManual, Enter";
        AddBSTRAsString(qsT, szLogString, sizeof(szLogString));
        AddBSTRAsString(qsP, szLogString, sizeof(szLogString));
        AddBSTRAsString(mspauth, szLogString, sizeof(szLogString));
        AddBSTRAsString(mspprof, szLogString, sizeof(szLogString));
        g_pTSLogger->AddDateTimeAndLog(szLogString);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes

    if (!m_valid || !g_config->isValid()) // Guarantees config is non-null
    {
        AtlReportError(CLSID_Manager, PP_E_NOT_CONFIGUREDSTR,
                       IID_IPassportManager, PP_E_NOT_CONFIGURED);
        return PP_E_NOT_CONFIGURED;
    }

    wipeState();

    if(m_pRegistryConfig)
        m_pRegistryConfig->Release();
    m_pRegistryConfig = g_config->checkoutRegistryConfig();

    if (handleQueryStringData(qsT, qsP))
    {
        VARIANT_BOOL persist;
        _bstr_t domain;
        _bstr_t path;
        _bstr_t bstrAuth;
        _bstr_t bstrProf;
        CComBSTR bstrConsent;


        bstrAuth.Assign(qsT);

        bstrProf.Assign(qsP);


        if (pCookies)
        {
            VariantInit(pCookies);

            if (m_pRegistryConfig->getTicketPath())
                path = m_pRegistryConfig->getTicketPath();
            else
                path = L"/";

            m_piTicket->get_HasSavedPassword(&persist);

            BOOL bSetConsent = (S_OK == IfConsentCookie(&bstrConsent));

            SAFEARRAYBOUND rgsabound;
            rgsabound.lLbound = 0;
            rgsabound.cElements = 2;

            // secure cookie
            if (m_bSecureTransported)
                rgsabound.cElements++;

            if(bSetConsent)
                rgsabound.cElements++;
            SAFEARRAY *sa = SafeArrayCreate(VT_VARIANT, 1, &rgsabound);

            if (!sa)
            {
                return E_OUTOFMEMORY;
            }

            pCookies->vt = VT_ARRAY | VT_VARIANT;
            pCookies->parray = sa;

            WCHAR buf[4096];
            DWORD bufSize;
            long  spot = 0;

            VARIANT *vArray;
            SafeArrayAccessData(sa, (void**)&vArray);

            // write Auth cookies
            CComBSTR bstrNewAuth;
            CComBSTR bstrNewSecAuth;

            BSTR  auth, secAuth; // do not call SysFreeString on them, they are skin level copy

            if (S_OK == IfAlterAuthCookie(&bstrNewAuth, &bstrNewSecAuth))
            {
               auth = bstrNewAuth;
               secAuth = bstrNewSecAuth;
            }
            else
            {
               auth = bstrAuth;
               secAuth = NULL;
            }


            domain = m_pRegistryConfig->getTicketDomain();

            // add MSPAuth
            if (domain.length())
            {
                bufSize = _snwprintf(buf, 4096,
                                    L"Set-Cookie: MSPAuth=%s; path=%s; domain=%s; %s\r\n",
                                    (LPWSTR)auth, (LPWSTR)path, (LPWSTR)domain,
                                    persist ? L"expires=Mon 1-Jan-2035 12:00:00 GMT;" : L"");
            }
            else
            {
                bufSize = _snwprintf(buf, 4096,
                                    L"Set-Cookie: MSPAuth=%s; path=%s; %s\r\n",
                                    (LPWSTR)auth, (LPWSTR)path,
                                    persist ? L"expires=Mon 1-Jan-2035 12:00:00 GMT;" : L"");
            }
            vArray[spot].vt = VT_BSTR;
            vArray[spot].bstrVal = ALLOC_AND_GIVEAWAY_BSTR_LEN(buf, bufSize);
            spot++;

            // add MSPSecAuth
            if (m_bSecureTransported)
            {
               if (domain.length())
               {
                   bufSize = _snwprintf(buf, 4096,
                                    L"Set-Cookie: MSPSecAuth=%s; path=%s; domain=%s; %s; secure\r\n",
                                    (LPWSTR)secAuth, (LPWSTR)path, (LPWSTR)domain,
                                    persist ? L"expires=Mon 1-Jan-2035 12:00:00 GMT;" : L"");
               }
               else
               {
                   bufSize = _snwprintf(buf, 4096,
                                    L"Set-Cookie: MSPSecAuth=%s; path=%s; %s; secure\r\n",
                                    (LPWSTR)secAuth, (LPWSTR)path,
                                    persist ? L"expires=Mon 1-Jan-2035 12:00:00 GMT;" : L"");
               }
               vArray[spot].vt = VT_BSTR;
               vArray[spot].bstrVal = ALLOC_AND_GIVEAWAY_BSTR_LEN(buf, bufSize);
               spot++;
            }


            if (domain.length())
            {
                bufSize = _snwprintf(buf, 4096,
                                    L"Set-Cookie: MSPProf=%s; path=%s; domain=%s; %s\r\n",
                                    (LPWSTR)bstrProf, (LPWSTR)path, (LPWSTR)domain,
                                    persist ? L"expires=Mon 1-Jan-2035 12:00:00 GMT;" : L"");
            }
            else
            {
                bufSize = _snwprintf(buf, 4096,
                                    L"Set-Cookie: MSPProf=%s; path=%s; %s\r\n",
                                    (LPWSTR)bstrProf, (LPWSTR)path,
                                    persist ? L"expires=Mon 1-Jan-2035 12:00:00 GMT;" : L"");
            }
            vArray[spot].vt = VT_BSTR;
            vArray[spot].bstrVal = ALLOC_AND_GIVEAWAY_BSTR_LEN(buf, bufSize);
            spot++;

            if(bSetConsent)
            {
                if (m_pRegistryConfig->getProfilePath())
                    path = m_pRegistryConfig->getProfilePath();
                else
                    path = L"/";
                domain = m_pRegistryConfig->getProfileDomain();

                if (domain.length())
                {
                    bufSize = _snwprintf(buf, 4096,
                                        L"Set-Cookie: MSPConsent=%s; path=%s; domain=%s; %s\r\n",
                                        bSetConsent ? (LPWSTR)bstrConsent : L"", (LPWSTR)path, (LPWSTR)domain,
                                        bSetConsent ? (persist ? L"expires=Mon 1-Jan-2035 12:00:00 GMT;" : L"")
                                                  : L"expires=Tue 1-Jan-1980 12:00:00 GMT;");
                }
                else
                {
                    bufSize = _snwprintf(buf, 4096,
                                        L"Set-Cookie: MSPConsent=%s; path=%s; %s\r\n",
                                        bSetConsent ? (LPWSTR)bstrConsent : L"", (LPWSTR)path,
                                        bSetConsent ? (persist ? L"expires=Mon 1-Jan-2035 12:00:00 GMT;" : L"")
                                                  : L"expires=Tue 1-Jan-1980 12:00:00 GMT;");
                }
                vArray[spot].vt = VT_BSTR;
                vArray[spot].bstrVal = ALLOC_AND_GIVEAWAY_BSTR_LEN(buf, bufSize);
                spot++;
            }

            SafeArrayUnaccessData(sa);
        }
    }

    // Now, check the cookies
    if (!m_fromQueryString)
    {
        hasSec = GetBstrArg(mspsec, &bstrSec);
        if(hasSec == CV_DEFAULT || hasSec == CV_BAD)
            bstrSec = NULL;

        handleCookieData(mspauth, mspprof, mspconsent, bstrSec);

        if(hasSec == CV_FREE)
            SysFreeString(bstrSec);
    }

//JVP - begin changes
#ifdef PASSPORT_VERBOSE_MODE_ON
        g_pTSLogger->AddDateTimeAndLog("CManager::OnStartPageManual, Exit");
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes

    return S_OK;
}

STDMETHODIMP CManager::OnStartPageECB(
    LPBYTE  pvECB,
    DWORD*  bufSize,
    LPSTR   pCookieHeader
    )
{
    char                        buffer[2048];
    DWORD                       dwSize;
    EXTENSION_CONTROL_BLOCK*    pECB = (EXTENSION_CONTROL_BLOCK*) pvECB;
    LPSTR                       pBuffer;
    LPSTR                       pHTTPS;

    USES_CONVERSION;

//JVP - begin changes
#ifdef PASSPORT_VERBOSE_MODE_ON
        g_pTSLogger->AddDateTimeAndLog("CManager::OnStartPageECB, Enter");
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes

    if (bufSize == NULL)
        return E_POINTER;

    if (!m_valid || !g_config->isValid()) // Guarantees config is non-null
    {
        AtlReportError(CLSID_Manager, PP_E_NOT_CONFIGUREDSTR,
                        IID_IPassportManager, PP_E_NOT_CONFIGURED);
        return PP_E_NOT_CONFIGURED;
    }

    wipeState();
    m_pECB = pECB;

    //
    //  Use the ECB to get the server name being requested
    //  so we can get the correct registry config.  But only do this
    //  if we have some configured sites.
    //

    if(g_config->HasSites())
    {
        dwSize = sizeof(buffer);
        GetSiteNameECB(pECB, buffer, &dwSize);

        if(m_pRegistryConfig)
            m_pRegistryConfig->Release();
        m_pRegistryConfig = g_config->checkoutRegistryConfig(buffer);
    }
    else
    {
        if(m_pRegistryConfig)
            m_pRegistryConfig->Release();
        m_pRegistryConfig = g_config->checkoutRegistryConfig();
    }

    *pCookieHeader = '\0';

    //  see if client understands passport
    pBuffer = GetServerVariableECB(pECB, "HTTP_Accept-Auth");
    if (pBuffer)
    {
        if (strstr(pBuffer, PASSPORT_PROT14_A))
            m_bIsTweenerCapable = TRUE;

        delete  pBuffer;
    }

    BSTR ret = NULL;
    CCoCrypt* crypt = NULL;

    BOOL    fParseSuccess = FALSE;
    pBuffer = GetServerVariableECB(pECB, "HTTP_Authorization");
    PWSTR   pwszTicket = NULL, pwszProfile = NULL, pwszF = NULL;
    //  use these when t&p come from qs
    BSTR a = NULL, p = NULL, f = NULL;
    if (pBuffer && !strstr(pBuffer, PASSPORT_PROT14_A))
    {
        //  not our header. BUGBUG could there be multiple headers ???
        delete  pBuffer;
        pBuffer = NULL;

    }
    if (!pBuffer)
    {
        //  an old client, let's try the QS
        pBuffer = GetServerVariableECB(pECB, "QUERY_STRING");
        if (pBuffer)
        {
            //  get ticket and profile ...
            // BUGBUG This could be optimized to avoid wide/short conversions, but later...
            GetQueryData(pBuffer, &a, &p, &f);
            TAKEOVER_BSTR(a);
            TAKEOVER_BSTR(p);
            TAKEOVER_BSTR(f);
            fParseSuccess = handleQueryStringData(a,p);
            if(f != NULL)
                m_lNetworkError = _wtol(f);
        }
    }
    else
    {
        //  convert to wide ...
        PWSTR   pwBuf = new WCHAR[strlen(pBuffer) + 1];
        if (pwBuf)
        {
            wsprintfW(pwBuf, L"%S", pBuffer);
            delete  pBuffer;
            //  transfer the ptr ...
            pBuffer = (PSTR)pwBuf;
            GetTicketAndProfileFromHeader(pwBuf, pwszTicket, pwszProfile, pwszF);
            fParseSuccess = handleQueryStringData(pwszTicket,pwszProfile);
            if (pwszF)
                m_lNetworkError = _wtol(f);
        }
    }
    if (pBuffer)
    {
        if (fParseSuccess)
        {
            //
            //  If we got secure ticket or profile, then
            //  we need to re-encrypt the insecure version
            //  before setting the cookie headers.
            //

            // Set the cookies
            LPSTR ticketDomain = m_pRegistryConfig->getTicketDomain();
            LPSTR profileDomain = m_pRegistryConfig->getProfileDomain();
            LPSTR secureDomain = m_pRegistryConfig->getSecureDomain();
            LPSTR ticketPath = m_pRegistryConfig->getTicketPath();
            LPSTR profilePath = m_pRegistryConfig->getProfilePath();
            LPSTR securePath = m_pRegistryConfig->getSecurePath();
            VARIANT_BOOL persist;
            m_piTicket->get_HasSavedPassword(&persist);

            //
            //  If we have a secure ticket/profile and the url is SSL,
            //  then tack on the MSPPuid cookie.
            //

            BSTR s = NULL;
            pHTTPS = GetServerVariableECB(pECB, "HTTPS");

            if(pHTTPS && lstrcmpiA("on", pHTTPS) == 0)
               m_bSecureTransported = true;
            else
               m_bSecureTransported = false;

            if(pHTTPS != NULL)
            {
                delete [] pHTTPS;
            }

            //  5709:  Get flags and check to see if the tertiary bit is
            //  on.  If so, pass this fact into BuildCookieHeaders so that
            //  the MSPProfC cookie can be set.

            CComBSTR bstrConsent;
            BOOL bSetConsent = (S_OK == IfConsentCookie(&bstrConsent));

            // Build the cookie headers.

            // the authentication cookies
            CComBSTR bstrNewAuth;
            CComBSTR bstrNewSecAuth;

            BSTR  auth, secAuth; // do not call SysFreeString on them, they are skin level copy

            if (S_OK == IfAlterAuthCookie(&bstrNewAuth, &bstrNewSecAuth))
            {
               auth = bstrNewAuth;
               secAuth = bstrNewSecAuth;
            }
            else
            {
               auth = a;
               secAuth = NULL;
            }

            BuildCookieHeaders((pwszTicket ? W2A(pwszTicket) : W2A(auth)),
                               (pwszProfile ? W2A(pwszProfile) : (p ? W2A(p) : NULL)),
                               (bSetConsent ? W2A(bstrConsent) : NULL),
                               (secAuth ? W2A(secAuth) : NULL),
                               ticketDomain,
                               ticketPath,
                               profileDomain,
                               profilePath,
                               secureDomain,
                               securePath,
                               persist,
                               pCookieHeader,
                               bufSize);

            FREE_BSTR(s);
        }

        if (a) FREE_BSTR(a);
        if (p) FREE_BSTR(p);
        if (f) FREE_BSTR(f);
        delete [] pBuffer;
    }

    // Now, check the cookies
    if (!m_fromQueryString)
    {
        BSTR a = NULL, p = NULL, c = NULL, s = NULL;
        if((pBuffer = GetServerVariableECB(pECB, "HTTP_COOKIE")) != NULL)
        {
            GetCookie(pBuffer, "MSPAuth", &a);
            GetCookie(pBuffer, "MSPProf", &p);
            GetCookie(pBuffer, "MSPConsent", &c);
            GetCookie(pBuffer, "MSPSecAuth", &s);

            TAKEOVER_BSTR(a);
            if(p) { TAKEOVER_BSTR(p); }
            if(c) { TAKEOVER_BSTR(c); }
            if(s) { TAKEOVER_BSTR(s); }

            handleCookieData(a,p,c,s);

            if (a) FREE_BSTR(a);
            if (p) FREE_BSTR(p);
            if (c) FREE_BSTR(c);
            if (s) FREE_BSTR(s);

            delete [] pBuffer;
        }
    }

//JVP - begin changes
#ifdef PASSPORT_VERBOSE_MODE_ON
        g_pTSLogger->AddDateTimeAndLog("CManager::OnStartPageECB, Exit");
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes

    return S_OK;
}

STDMETHODIMP CManager::OnStartPageFilter(
    LPBYTE  pvPFC,
    DWORD*  bufSize,
    LPSTR   pCookieHeader
    )
{
    char                    buffer[2048];
    DWORD                   dwSize;
    PHTTP_FILTER_CONTEXT    pfc = (PHTTP_FILTER_CONTEXT) pvPFC;
    LPSTR                   pBuffer = NULL;
    LPSTR                   pHTTPS;

    // initialize
    *bufSize = 0;

    USES_CONVERSION;

//JVP - begin changes
#ifdef PASSPORT_VERBOSE_MODE_ON
        g_pTSLogger->AddDateTimeAndLog("CManager::OnStartPageFilter, Enter");
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes

    if (!m_valid || !g_config->isValid()) // Guarantees config is non-null
    {
        AtlReportError(CLSID_Manager, PP_E_NOT_CONFIGUREDSTR,
                        IID_IPassportManager, PP_E_NOT_CONFIGURED);
        return PP_E_NOT_CONFIGURED;
    }


    wipeState();

    //
    //  Use the ECB to get the server name being requested
    //  so we can get the correct registry config.  But only do this
    //  if we have some configured sites.
    //

    if(g_config->HasSites())
    {
        dwSize = sizeof(buffer);
        GetSiteNamePFC(pfc, buffer, &dwSize);

        if(m_pRegistryConfig)
            m_pRegistryConfig->Release();
        m_pRegistryConfig = g_config->checkoutRegistryConfig(buffer);
    }
    else
    {
        if(m_pRegistryConfig)
            m_pRegistryConfig->Release();
        m_pRegistryConfig = g_config->checkoutRegistryConfig();
    }

    *pCookieHeader = '\0';

    //  store the filter context
    m_pFC = pfc;

    // see if the client "knows" tweener
    PSTR    pHeader = GetServerVariablePFC(pfc, "HTTP_Accept-Auth");
    if (pHeader)
    {
        //  does it know passport1.4?
        if (strstr(pHeader, PASSPORT_PROT14_A))
        {
            m_bIsTweenerCapable = TRUE;
        }
        delete  pHeader;
    }

    //  check the auth header
    BOOL    fParseSuccess = FALSE;
    PWSTR   pwszTicket = NULL, pwszProfile = NULL, pwszF = NULL;

    pHeader = GetServerVariablePFC(pfc, "HTTP_Authorization");
    if (pHeader)
    {
        if (!strncmp(pHeader, PASSPORT_PROT14_A, strlen(PASSPORT_PROT14_A)))
        {
            //  this is our header ....
            //  extract ticket and profile
            PWSTR   pwBuf = new WCHAR[strlen(pHeader) + 1];
            if (pwBuf)
            {
                wsprintfW(pwBuf, L"%S", pHeader);
                delete  pHeader;
                //  transfer the ptr ...
                pBuffer = (PSTR)pwBuf;
                GetTicketAndProfileFromHeader(pwBuf, pwszTicket, pwszProfile, pwszF);
                fParseSuccess = handleQueryStringData(pwszTicket,pwszProfile);
                if (pwszF)
                    m_lNetworkError = _wtol(pwszF);
            }
        }
        else
        {
            delete  pHeader;
            pHeader = NULL;
        }
    }

    BSTR a = NULL, p = NULL, f = NULL;
    if (!pBuffer && (pBuffer = GetServerVariablePFC(pfc, "QUERY_STRING")) != NULL)
    {
        // Then, check the query string
        // BUGBUG This could be optimized to avoid wide/short conversions, but later...
        GetQueryData(pBuffer, &a, &p, &f);
        TAKEOVER_BSTR(a);
        TAKEOVER_BSTR(p);
        TAKEOVER_BSTR(f);
        fParseSuccess = handleQueryStringData(a,p);
        if(f != NULL)
            m_lNetworkError = _wtol(f);
    }
    BSTR ret = NULL;
    CCoCrypt* crypt = NULL;

    if (fParseSuccess)
    {
        // Set the cookies
        LPSTR ticketDomain = m_pRegistryConfig->getTicketDomain();
        LPSTR profileDomain = m_pRegistryConfig->getProfileDomain();
        LPSTR secureDomain = m_pRegistryConfig->getSecureDomain();
        LPSTR ticketPath =  m_pRegistryConfig->getTicketPath();
        LPSTR profilePath = m_pRegistryConfig->getProfilePath();
        LPSTR securePath = m_pRegistryConfig->getSecurePath();
        VARIANT_BOOL persist;
        m_piTicket->get_HasSavedPassword(&persist);

        //
        //  If we have a secure ticket/profile and the url is SSL,
        //  then tack on the MSPPuid cookie.
        //

        BSTR s = NULL;
        pHTTPS = GetServerVariablePFC(pfc, "HTTPS");

        if(pHTTPS && lstrcmpiA("on", pHTTPS) == 0)
           m_bSecureTransported = true;
        else
           m_bSecureTransported = false;

        if(pHTTPS != NULL)
        {
            delete [] pHTTPS;
        }

        //  5709:  Get flags and check to see if the tertiary bit is
        //  on.  If so, pass this fact into BuildCookieHeaders so that
        //  the MSPProfC cookie can be set.

        CComBSTR  bstrConsent;
        BOOL bSetConsent = (S_OK == IfConsentCookie(&bstrConsent));

        // Build the cookie headers.

        // the authentication cookies
        CComBSTR bstrNewAuth;
        CComBSTR bstrNewSecAuth;

        BSTR  auth, secAuth; // do not call SysFreeString on them, they are skin level copy

        if (S_OK == IfAlterAuthCookie(&bstrNewAuth, &bstrNewSecAuth))
        {
           auth = bstrNewAuth;
           secAuth = bstrNewSecAuth;
        }
        else
        {
           auth = a;
           secAuth = NULL;
        }


        BuildCookieHeaders(pwszTicket ? W2A(pwszTicket) : W2A(auth),
                           pwszProfile ? W2A(pwszProfile) : (p ? W2A(p) : NULL),
                           (bSetConsent ? W2A(bstrConsent) : NULL),
                           (secAuth ? W2A(secAuth) : NULL),
                           ticketDomain,
                           ticketPath,
                           profileDomain,
                           profilePath,
                           secureDomain,
                           securePath,
                           persist,
                           pCookieHeader,
                           bufSize);

        FREE_BSTR(s);
    }
    if (a) FREE_BSTR(a);
    if (p) FREE_BSTR(p);
    if (f) FREE_BSTR(f);

    if (pBuffer)
        delete pBuffer;

    // Now, check the cookies
    if (!m_fromQueryString)
    {
        BSTR a = NULL, p = NULL, c = NULL, s = NULL;
        if((pBuffer = GetServerVariablePFC(pfc, "HTTP_COOKIE")) != NULL)
        {
            GetCookie(pBuffer, "MSPAuth",  &a);
            GetCookie(pBuffer, "MSPProf",  &p);
            GetCookie(pBuffer, "MSPConsent", &c);
            GetCookie(pBuffer, "MSPSecAuth",  &s);

            if(a) { TAKEOVER_BSTR(a); }
            if(p) { TAKEOVER_BSTR(p); }
            if(c) { TAKEOVER_BSTR(c); }
            if(s) { TAKEOVER_BSTR(s); }

            handleCookieData(a,p,c,s);

            if (a) FREE_BSTR(a);
            if (p) FREE_BSTR(p);
            if (c) FREE_BSTR(c);
            if (s) FREE_BSTR(s);

            delete [] pBuffer;
        }

    }

//JVP - begin changes
#ifdef PASSPORT_VERBOSE_MODE_ON
        g_pTSLogger->AddDateTimeAndLog("CManager::OnStartPageFilter, Exit");
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes
    return S_OK;
}

STDMETHODIMP CManager::OnEndPage ()
{
//JVP - begin changes
#ifdef PASSPORT_VERBOSE_MODE_ON
        g_pTSLogger->AddDateTimeAndLog("CManager::OnEndPage, Enter");
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes
    if (m_bOnStartPageCalled)
    {
        m_bOnStartPageCalled = false;
        // Release all interfaces
        m_piRequest.Release();
        m_piResponse.Release();
    }

    // Just in case...
    m_piTicket->put_unencryptedTicket(NULL);
    m_piProfile->put_unencryptedProfile(NULL);
    m_profileValid = m_ticketValid = VARIANT_FALSE;
    m_fromQueryString = false;

    if(m_pRegistryConfig)
    {
        m_pRegistryConfig->Release();
        m_pRegistryConfig = NULL;
    }

//JVP - begin changes
#ifdef PASSPORT_VERBOSE_MODE_ON
        g_pTSLogger->AddDateTimeAndLog("CManager::OnEndPage, Exit");
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes

    return S_OK;
}

//
//  Old API. Auth URL is pointing to the login server
//
STDMETHODIMP
CManager::AuthURL(
    VARIANT vRU,
    VARIANT vTimeWindow,
    VARIANT vForceLogin,
    VARIANT vCoBrand,
    VARIANT vLCID,
    VARIANT vNameSpace,
    VARIANT vKPP,
    VARIANT vUseSecureAuth,
    BSTR *pAuthUrl)
{
    CComVariant   vEmpty("");
    return CommonAuthURL(vRU, vTimeWindow, vForceLogin,
                         vCoBrand, vLCID, vNameSpace,
                         vKPP, vUseSecureAuth,
                         FALSE, vEmpty, pAuthUrl);

}

//
//  new API. return URL is to the login server
//
STDMETHODIMP
CManager::AuthURL2(
    VARIANT vRU,
    VARIANT vTimeWindow,
    VARIANT vForceLogin,
    VARIANT vCoBrand,
    VARIANT vLCID,
    VARIANT vNameSpace,
    VARIANT vKPP,
    VARIANT vUseSecureAuth,
    BSTR *pAuthUrl)
{
    CComVariant   vEmpty("");
    return CommonAuthURL(vRU, vTimeWindow, vForceLogin,
                         vCoBrand, vLCID, vNameSpace,
                         vKPP, vUseSecureAuth,
                         TRUE, vEmpty, pAuthUrl);

}

//
//  AuthURL implementation
//
STDMETHODIMP
CManager::CommonAuthURL(
    VARIANT vRU,
    VARIANT vTimeWindow,
    VARIANT vForceLogin,
    VARIANT vCoBrand,
    VARIANT vLCID,
    VARIANT vNameSpace,
    VARIANT vKPP,
    VARIANT vUseSecureAuth,
    BOOL    fRedirToSelf,
    VARIANT vFunctionArea, // BSTR: e.g. Wireless
    BSTR *pAuthUrl)
{
    USES_CONVERSION;
    time_t ct;
    WCHAR url[MAX_URL_LENGTH] = L"";
    VARIANT freeMe;
    UINT         TimeWindow;
    int          nKPP;
    VARIANT_BOOL ForceLogin = VARIANT_FALSE;
    ULONG        ulSecureLevel = 0;
    //!!! ? bstrNameSpace seems leaking memory, should we change all to CComBSTR ...
    BSTR         CBT = NULL, returnUrl = NULL, bstrNameSpace = NULL;
    int          hasCB, hasRU, hasLCID, hasTW, hasFL, hasNameSpace, hasKPP, hasUseSec;
    USHORT       Lang;
    HRESULT      hr = S_OK;

    BSTR         bstrFunctionArea = NULL;
    int          hasFunctionArea;

//JVP - begin changes
#ifdef PASSPORT_VERBOSE_MODE_ON
        char szLogString[LOG_STRING_LEN] = "CManager::AuthURL, Enter";
        AddVariantAsString(vRU, szLogString, sizeof(szLogString));
        AddVariantAsString(vTimeWindow, szLogString, sizeof(szLogString));
        AddVariantAsString(vForceLogin, szLogString, sizeof(szLogString));
        AddVariantAsString(vCoBrand, szLogString, sizeof(szLogString));
        AddVariantAsString(vLCID, szLogString, sizeof(szLogString));
        AddVariantAsString(vNameSpace, szLogString, sizeof(szLogString));
        g_pTSLogger->AddDateTimeAndLog(szLogString);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes
    if (!m_pRegistryConfig)
        m_pRegistryConfig = g_config->checkoutRegistryConfig();

    if (!m_valid || !g_config->isValid() || !m_pRegistryConfig) // Guarantees config is non-null
    {
        AtlReportError(CLSID_Manager, PP_E_NOT_CONFIGUREDSTR,
                    IID_IPassportManager, PP_E_NOT_CONFIGURED);
        return PP_E_NOT_CONFIGURED;
    }

    // Make sure args are of the right type
    if ((hasTW = GetIntArg(vTimeWindow, (int*) &TimeWindow)) == CV_BAD)
        return E_INVALIDARG;
    if ((hasFL = GetBoolArg(vForceLogin, &ForceLogin)) == CV_BAD)
        return E_INVALIDARG;
    if ((hasUseSec = GetIntArg(vUseSecureAuth, (int*)&ulSecureLevel)) == CV_BAD)
        return E_INVALIDARG;
    if ((hasLCID = GetShortArg(vLCID,&Lang)) == CV_BAD)
        return E_INVALIDARG;
    if ((hasKPP = GetIntArg(vKPP, &nKPP)) == CV_BAD)
        return E_INVALIDARG;
    hasCB = GetBstrArg(vCoBrand, &CBT);
    if (hasCB == CV_BAD)
        return E_INVALIDARG;
    if (hasCB == CV_FREE)
    {
        TAKEOVER_BSTR(CBT);
    }

    hasRU = GetBstrArg(vRU, &returnUrl);
    if (hasRU == CV_BAD)
    {
        if (hasCB == CV_FREE && CBT) FREE_BSTR(CBT);
            return E_INVALIDARG;
    }
    if (hasRU == CV_FREE)
    {
        TAKEOVER_BSTR(returnUrl);
    }

    hasNameSpace = GetBstrArg(vNameSpace, &bstrNameSpace);
    if (hasNameSpace == CV_BAD)
    {
        if (hasCB == CV_FREE && CBT) SysFreeString(CBT);
        if (hasRU == CV_FREE && returnUrl) SysFreeString(returnUrl);
        return E_INVALIDARG;
    }
    if (hasNameSpace == CV_FREE)
    {
        TAKEOVER_BSTR(bstrNameSpace);

        //!!! ? does it take care of memory leak? ...
    }

    hasFunctionArea = GetBstrArg(vFunctionArea, &bstrFunctionArea);
    if (hasFunctionArea == CV_FREE)
    {
        TAKEOVER_BSTR(bstrFunctionArea);
    }

    WCHAR *szAUAttrName;
    CComBSTR   szAttrName_FuncArea = bstrFunctionArea;
    if (hasUseSec == CV_OK && SECURELEVEL_USE_HTTPS(ulSecureLevel))
        szAUAttrName = L"AuthSecure";
    else
        szAUAttrName = L"Auth";

    if (bstrFunctionArea != NULL)
        szAttrName_FuncArea+= szAUAttrName;

    CNexusConfig* cnc = g_config->checkoutNexusConfig();

    if (hasLCID == CV_DEFAULT)
        Lang = m_pRegistryConfig->getDefaultLCID();
    if (hasKPP == CV_DEFAULT)
        nKPP = -1;
    VariantInit(&freeMe);

    if (!m_pRegistryConfig->DisasterModeP())
    {
        // If I'm authenticated, get my domain specific url
        if (m_ticketValid && m_profileValid)
        {
            HRESULT hr = m_piProfile->get_ByIndex(MEMBERNAME_INDEX, &freeMe);
            if (hr != S_OK || freeMe.vt != VT_BSTR)
            {
               if (bstrFunctionArea)
               {
                  cnc->getDomainAttribute(L"Default",
                                        szAttrName_FuncArea,
                                        sizeof(url) / sizeof(WCHAR),
                                        url,
                                        Lang);
               }

               if (*url == 0) // nothing is in URL string
               {
                   cnc->getDomainAttribute(L"Default",
                                        szAUAttrName,
                                        sizeof(url) / sizeof(WCHAR),
                                        url,
                                        Lang);
               }
            }
            else
            {
               LPCWSTR psz = wcsrchr(freeMe.bstrVal, L'@');
               if (bstrFunctionArea)
               {
                  cnc->getDomainAttribute(psz ? psz+1 : L"Default",
                                        szAttrName_FuncArea,
                                        sizeof(url) / sizeof(WCHAR),
                                        url,
                                        Lang);
               }

               if (*url == 0) // nothing is in URL string
               {
                  cnc->getDomainAttribute(psz ? psz+1 : L"Default",
                                        szAUAttrName,
                                        sizeof(url) / sizeof(WCHAR),
                                        url,
                                        Lang);
               }
            }
        }
        else
        {
           if (bstrFunctionArea)
           {
              cnc->getDomainAttribute(L"Default",
                                    szAttrName_FuncArea,
                                    sizeof(url) / sizeof(WCHAR),
                                    url,
                                    Lang);
           }

           if(*url == 0)   // nothing in URL string
           {
              cnc->getDomainAttribute(L"Default",
                                    szAUAttrName,
                                    sizeof(url) / sizeof(WCHAR),
                                    url,
                                    Lang);

           }
        }
    }
    else
        lstrcpynW(url, A2W(m_pRegistryConfig->getDisasterUrl()), sizeof(url) / sizeof(WCHAR));

    time(&ct);

    if (*url == L'\0')
    {
        hr = S_OK;
        goto Cleanup;
    }

    if (hasTW == CV_DEFAULT)
        TimeWindow = m_pRegistryConfig->getDefaultTicketAge();
    if (hasFL == CV_DEFAULT)
        ForceLogin = m_pRegistryConfig->forceLoginP() ? VARIANT_TRUE : VARIANT_FALSE;
    if (hasCB == CV_DEFAULT)
        CBT = m_pRegistryConfig->getDefaultCoBrand();
    if (hasRU == CV_DEFAULT)
        returnUrl = m_pRegistryConfig->getDefaultRU();
    if (returnUrl == NULL)
        returnUrl = L"";
    if(hasUseSec == CV_DEFAULT)
        ulSecureLevel = m_pRegistryConfig->getSecureLevel();

    if(ulSecureLevel == VARIANT_TRUE)  // special case for backward compatible
        ulSecureLevel = k_iSeclevelSecureChannel;

    if ((TimeWindow != 0 && TimeWindow < PPM_TIMEWINDOW_MIN) || TimeWindow > PPM_TIMEWINDOW_MAX)
    {
        WCHAR buf[20];
        _itow(TimeWindow,buf,10);
        AtlReportError(CLSID_Manager, (LPCOLESTR) PP_E_INVALID_TIMEWINDOWSTR,
                        IID_IPassportManager, PP_E_INVALID_TIMEWINDOW);
        hr = PP_E_INVALID_TIMEWINDOW;
        goto Cleanup;
    }

    *pAuthUrl = FormatAuthURL(
                            url,
                            m_pRegistryConfig->getSiteId(),
                            returnUrl,
                            TimeWindow,
                            ForceLogin,
                            m_pRegistryConfig->getCurrentCryptVersion(),
                            ct,
                            CBT,
                            bstrNameSpace,
                            nKPP,
                            Lang,
                            ulSecureLevel,
                            m_pRegistryConfig,
                            fRedirToSelf
                            );

    hr = S_OK;

Cleanup:

    cnc->Release();
    if (hasFunctionArea== CV_FREE && bstrFunctionArea)
        FREE_BSTR(bstrFunctionArea);

    if (hasRU == CV_FREE && returnUrl)
        FREE_BSTR(returnUrl);

    if (hasCB == CV_FREE && CBT)
        FREE_BSTR(CBT);

    // !!! need to confirmation
    if (hasNameSpace == CV_FREE && bstrNameSpace)
        FREE_BSTR(bstrNameSpace);

    VariantClear(&freeMe);

//JVP - begin changes
#ifdef PASSPORT_VERBOSE_MODE_ON
        strcpy(szLogString,"CManager::AuthURL, Exit");
        AddLongAsString(hr, szLogString, sizeof(szLogString));
        g_pTSLogger->AddDateTimeAndLog(szLogString);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes

    return hr;
}

//
//  get AuthURL and AuthHeaders
//
STDMETHODIMP CManager::GetLoginChallenge(VARIANT vReturnUrl,
                                 VARIANT vTimeWindow,
                                 VARIANT vForceLogin,
                                 VARIANT vCoBrandTemplate,
                                 VARIANT vLCID,
                                 VARIANT vNameSpace,
                                 VARIANT vKPP,
                                 VARIANT vUseSecureAuth,
                                 VARIANT vExtraParams,
                                 VARIANT *pAuthHeader,
                                 BSTR*   pAuthVal
                                 )
{
    HRESULT hr = S_OK;

    try{
    //  format qs and WWW-Authenticate header ....
    _bstr_t strUrl, strRetUrl, strCBT, strNameSpace;
    UINT    TimeWindow;
    int     nKPP;
    time_t  ct;
    VARIANT_BOOL    ForceLogin;
    ULONG   ulSecureLevel;
    WCHAR   rgLCID[10];
       HRESULT hr = GetLoginParams(vReturnUrl,
                                vTimeWindow,
                                vForceLogin,
                                vCoBrandTemplate,
                                vLCID,
                                vNameSpace,
                                vKPP,
                                vUseSecureAuth,
                                strUrl,
                                strRetUrl,
                                TimeWindow,
                                ForceLogin,
                                ct,
                                strCBT,
                                strNameSpace,
                                nKPP,
                                ulSecureLevel,
                                rgLCID);

       if (S_OK == hr)
       {
           WCHAR   szBuf[MAX_QS_LENGTH] = L"";
           //  prepare redirect URL to the login server for
           //  downlevel clients
           FormatAuthURLParameters(strUrl,
                                m_pRegistryConfig->getSiteId(),
                                strRetUrl,
                                TimeWindow,
                                ForceLogin,
                                m_pRegistryConfig->getCurrentCryptVersion(),
                                ct,
                                strCBT,
                                strNameSpace,
                                nKPP,
                                szBuf,
                                sizeof(szBuf)/sizeof(WCHAR),
                                0,      // lang does not matter ....
                                ulSecureLevel,
                                m_pRegistryConfig,
                                FALSE); //  do not redirect to self!
           //  insert the WWW-Authenticate header ...
           _bstr_t strAuthHeader;
           FormatAuthHeaderFromParams(strUrl,
                                   strRetUrl,
                                   TimeWindow,
                                   ForceLogin,
                                   ct,
                                   strCBT,
                                   strNameSpace,
                                   nKPP,
                                   rgLCID,
                                   ulSecureLevel,
                                   strAuthHeader);
           //  and add the extra ....
           BSTR    strExtra = NULL;
           int res = GetBstrArg(vExtraParams, &strExtra);
           if (res != CV_BAD && res != CV_DEFAULT)
               strAuthHeader += _bstr_t(L",") + strExtra;

           if (res == CV_FREE)
                ::SysFreeString(strExtra);


          // set return values
          if (pAuthHeader && (WCHAR*)strAuthHeader != NULL)
          {
            V_VT(pAuthHeader) = VT_BSTR;
            // TODO: should avoid this SysAllocString
            V_BSTR(pAuthHeader) = ::SysAllocString((WCHAR*)strAuthHeader);
          }

          if (pAuthVal)
            *pAuthVal = ::SysAllocString(szBuf);

       }
   }catch(...)
   {
      hr = E_OUTOFMEMORY;
   }


    return  hr;
}

//
//  client logon method
//
STDMETHODIMP CManager::LoginUser(VARIANT vReturnUrl,
                                 VARIANT vTimeWindow,
                                 VARIANT vForceLogin,
                                 VARIANT vCoBrandTemplate,
                                 VARIANT vLCID,
                                 VARIANT vNameSpace,
                                 VARIANT vKPP,
                                 VARIANT vUseSecureAuth,
                                 VARIANT vExtraParams)
{
    //  format qs and WWW-Authenticate header ....
    CComBSTR      authURL;
    CComVariant   authHeader;

    HRESULT       hr = GetLoginChallenge( vReturnUrl,
                                          vTimeWindow,
                                          vForceLogin,
                                          vCoBrandTemplate,
                                          vLCID,
                                          vNameSpace,
                                          vKPP,
                                          vUseSecureAuth,
                                          vExtraParams,
                                          &authHeader,
                                          &authURL);

    if (S_OK == hr)
    {
       _ASSERT(V_VT(&authHeader) == VT_BSTR);
       _ASSERT(authURL);
       _ASSERT(V_BSTR(&authHeader));

       // TODO: _bstr_t should be removed globaly in ppm
        if (m_piResponse)
        {
            m_piResponse->AddHeader(L"WWW-Authenticate", V_BSTR(&authHeader));

            _bstr_t    authURL1 = authURL;

            //  and redirect!
            if (!m_bIsTweenerCapable)
                m_piResponse->Redirect(authURL1);
            else
            {
                //  send a 401
                m_piResponse->put_Status(L"401 Unauthorized");
                m_piResponse->End();
            }
        }
        else if (m_pECB || m_pFC)
        {
            //  use ECB of Filter interfaces
            //  4k whould be enough ....
            char buffer[4096],
                 status[25] = "302 Object moved",
                 *psz=buffer,
                 rgszTemplate[] = "Content-Type: text/html\r\nLocation: %ws\r\n"
                               "Content-Length: 0\r\n"
                               "WWW-Authenticate: %ws\r\n\r\n";
            DWORD cbTotalLength = strlen(rgszTemplate) +
                                  wcslen(V_BSTR(&authHeader));
            if (m_bIsTweenerCapable)
                strcpy(status, "401 Unauthorized");
            if (cbTotalLength >= sizeof(buffer))
            {
                //  if not ...
                //  need to alloc
                psz = new CHAR[cbTotalLength];
                _ASSERT(psz);
            }

            if (psz)
            {
                sprintf(psz,
                        rgszTemplate,
                        authURL,
                        V_BSTR(&authHeader));
                if (m_pECB)
                {
                    //  extension
                    HSE_SEND_HEADER_EX_INFO Headers =
                    {
                        status,
                        buffer,
                        strlen(status),
                        strlen(buffer),
                        TRUE
                    };
                    m_pECB->ServerSupportFunction(m_pECB->ConnID,
                                                  HSE_REQ_SEND_RESPONSE_HEADER_EX,
                                                  &Headers,
                                                  NULL,
                                                  NULL);
                }
                else
                {
                    //  filter
                    m_pFC->ServerSupportFunction(m_pFC,
                                                 SF_REQ_SEND_RESPONSE_HEADER,
                                                 status,
                                                 (ULONG_PTR) psz,
                                                 NULL);
                }

                if (psz != buffer)
                    //  if we had to allocate
                    delete  psz;

            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }


    return  hr;
}



STDMETHODIMP CManager::IsAuthenticated(
    VARIANT vTimeWindow,
    VARIANT vForceLogin,
    VARIANT vCheckSecure,
    VARIANT_BOOL *pVal)
{
    HRESULT hr;
    ULONG TimeWindow;
    VARIANT_BOOL ForceLogin;
    ATL::CComVariant vSecureLevel;
    ULONG ulSecureLevel;
    int hasTW, hasFL, hasSecureLevel;

//JVP - begin changes
#ifdef PASSPORT_VERBOSE_MODE_ON
        char szLogString[LOG_STRING_LEN] = "CManager::IsAuthenticated, Enter";
        AddVariantAsString(vTimeWindow,  szLogString, sizeof(szLogString));
        AddVariantAsString(vForceLogin,  szLogString, sizeof(szLogString));
        g_pTSLogger->AddDateTimeAndLog(szLogString);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes

    if (!m_pRegistryConfig)
        m_pRegistryConfig = g_config->checkoutRegistryConfig();

    if (!g_config->isValid() || !m_pRegistryConfig) // Guarantees config is non-null
    {
        AtlReportError(CLSID_Manager, PP_E_NOT_CONFIGUREDSTR,
        IID_IPassportManager, PP_E_NOT_CONFIGURED);
        hr = PP_E_NOT_CONFIGURED;
        goto Cleanup;
    }

    // Both profile AND ticket must be valid to be authenticated
    // DARRENAN - As of 1.3 no longer true!!!
    /*if (!m_profileValid)
    {
        *pVal = VARIANT_FALSE;
        hr = S_OK;
        goto Cleanup;
    }
    */

    if ((hasTW = GetIntArg(vTimeWindow,(int*)&TimeWindow)) == CV_BAD)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    if (hasTW == CV_DEFAULT)
        TimeWindow = m_pRegistryConfig->getDefaultTicketAge();

    if ((hasFL = GetBoolArg(vForceLogin, &ForceLogin)) == CV_BAD)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    if (hasFL == CV_DEFAULT)
        ForceLogin = m_pRegistryConfig->forceLoginP() ? VARIANT_TRUE : VARIANT_FALSE;

    hasSecureLevel = GetIntArg(vCheckSecure, (int*)&ulSecureLevel);
    if(hasSecureLevel == CV_BAD) // try the legacy type VT_BOOL, map VARIANT_TRUE to SecureChannel
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    else if (hasSecureLevel == CV_DEFAULT)
    {
        ulSecureLevel = m_pRegistryConfig->getSecureLevel();
    }

    if(ulSecureLevel == VARIANT_TRUE)// backward compatible with 1.3X
    {
      ulSecureLevel = k_iSeclevelSecureChannel;
    }

    vSecureLevel = ulSecureLevel;

    hr = m_piTicket->get_IsAuthenticated(TimeWindow, ForceLogin, vSecureLevel, pVal);

Cleanup:

    if(g_pPerf)
    {
        if (*pVal)
        {
            g_pPerf->incrementCounter(PM_AUTHSUCCESS_TOTAL);
            g_pPerf->incrementCounter(PM_AUTHSUCCESS_SEC);
        }
        else
        {
            g_pPerf->incrementCounter(PM_AUTHFAILURE_TOTAL);
            g_pPerf->incrementCounter(PM_AUTHFAILURE_SEC);
        }
    }
    else
    {
        _ASSERT(g_pPerf);
    }

//JVP - begin changes
#ifdef PASSPORT_VERBOSE_MODE_ON
        strcpy(szLogString, "CManager::IsAuthenticated, Exit");
        AddLongAsString(hr,  szLogString, sizeof(szLogString));
        g_pTSLogger->AddDateTimeAndLog(szLogString);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes

    return hr;
}

//
//  old PM API. The URL is pointing to login server
//
STDMETHODIMP
CManager::LogoTag(
    VARIANT vRU,
    VARIANT vTimeWindow,
    VARIANT vForceLogin,
    VARIANT vCoBrand,
    VARIANT vLCID,
    VARIANT vSecure,
    VARIANT vNameSpace,
    VARIANT vKPP,
    VARIANT vUseSecureAuth,
    BSTR *pVal)
{
    return CommonLogoTag(vRU, vTimeWindow, vForceLogin,
                         vCoBrand, vLCID, vSecure,
                         vNameSpace, vKPP, vUseSecureAuth,
                         FALSE, pVal);
}

//
//  new PM API. The URL is pointing to the partner site
//
STDMETHODIMP
CManager::LogoTag2(
    VARIANT vRU,
    VARIANT vTimeWindow,
    VARIANT vForceLogin,
    VARIANT vCoBrand,
    VARIANT vLCID,
    VARIANT vSecure,
    VARIANT vNameSpace,
    VARIANT vKPP,
    VARIANT vUseSecureAuth,
    BSTR *pVal)
{
    return CommonLogoTag(vRU, vTimeWindow, vForceLogin,
                         vCoBrand, vLCID, vSecure,
                         vNameSpace, vKPP, vUseSecureAuth,
                         TRUE, pVal);
}

STDMETHODIMP
CManager::CommonLogoTag(
    VARIANT vRU,
    VARIANT vTimeWindow,
    VARIANT vForceLogin,
    VARIANT vCoBrand,
    VARIANT vLCID,
    VARIANT vSecure,
    VARIANT vNameSpace,
    VARIANT vKPP,
    VARIANT vUseSecureAuth,
    BOOL    fRedirToSelf,
    BSTR *pVal)
{
    time_t          ct;
    ULONG           TimeWindow;
    int             nKPP;
    VARIANT_BOOL    ForceLogin, bSecure = VARIANT_FALSE;
    ULONG           ulSecureLevel = 0;
    BSTR            CBT = NULL, returnUrl = NULL, NameSpace = NULL;
    int             hasCB, hasRU, hasLCID, hasTW, hasFL, hasSec, hasUseSec, hasNameSpace, hasKPP;
    USHORT          Lang;

    USES_CONVERSION;

    time(&ct);

    if (!m_pRegistryConfig)
        m_pRegistryConfig = g_config->checkoutRegistryConfig();

    if (!m_valid || !g_config->isValid() || !m_pRegistryConfig) // Guarantees config is non-null
    {
        AtlReportError(CLSID_Manager, PP_E_NOT_CONFIGUREDSTR,
                        IID_IPassportManager, PP_E_NOT_CONFIGURED);
        return PP_E_NOT_CONFIGURED;
    }

    // Make sure args are of the right type
    if ((hasTW = GetIntArg(vTimeWindow, (int*) &TimeWindow)) == CV_BAD)
        return E_INVALIDARG;
    if ((hasFL = GetBoolArg(vForceLogin, &ForceLogin)) == CV_BAD)
        return E_INVALIDARG;
    if ((hasSec = GetBoolArg(vSecure,&bSecure)) == CV_BAD)
        return E_INVALIDARG;

    // FUTURE: should introduce a new func: GetLongArg ...
    if ((hasUseSec = GetIntArg(vUseSecureAuth,(int*)&ulSecureLevel)) == CV_BAD)
        return E_INVALIDARG;

    if ((hasLCID = GetShortArg(vLCID,&Lang)) == CV_BAD)
        return E_INVALIDARG;
    if ((hasKPP = GetIntArg(vKPP, &nKPP)) == CV_BAD)
        return E_INVALIDARG;
    hasCB = GetBstrArg(vCoBrand, &CBT);
    if (hasCB == CV_BAD)
        return E_INVALIDARG;
    if (hasCB == CV_FREE) { TAKEOVER_BSTR(CBT); }
    hasRU = GetBstrArg(vRU, &returnUrl);
    if (hasRU == CV_BAD)
    {
        if (hasCB == CV_FREE && CBT) SysFreeString(CBT);
        return E_INVALIDARG;
    }
    if (hasRU == CV_FREE) { TAKEOVER_BSTR(returnUrl); }

    hasNameSpace = GetBstrArg(vNameSpace, &NameSpace);
    if (hasNameSpace == CV_BAD)
    {
                if (hasCB == CV_FREE && CBT) SysFreeString(CBT);
                if (hasRU == CV_FREE && returnUrl) SysFreeString(returnUrl);
            return E_INVALIDARG;
        }
        if (hasNameSpace == CV_FREE) { TAKEOVER_BSTR(NameSpace); }


    WCHAR *szSIAttrName, *szSOAttrName;
    if (hasSec == CV_OK && bSecure == VARIANT_TRUE)
    {
        szSIAttrName = L"SecureSigninLogo";
        szSOAttrName = L"SecureSignoutLogo";
    }
    else
    {
        szSIAttrName = L"SigninLogo";
        szSOAttrName = L"SignoutLogo";
    }

    WCHAR *szAUAttrName;
    if (hasUseSec == CV_OK && SECURELEVEL_USE_HTTPS(ulSecureLevel))
        szAUAttrName = L"AuthSecure";
    else
        szAUAttrName = L"Auth";

    CNexusConfig* cnc = g_config->checkoutNexusConfig();

    if (hasLCID == CV_DEFAULT)
        Lang = m_pRegistryConfig->getDefaultLCID();

    if (hasTW == CV_DEFAULT)
        TimeWindow = m_pRegistryConfig->getDefaultTicketAge();
    if (hasFL == CV_DEFAULT)
        ForceLogin = m_pRegistryConfig->forceLoginP() ? VARIANT_TRUE : VARIANT_FALSE;
    if (hasCB == CV_DEFAULT)
        CBT = m_pRegistryConfig->getDefaultCoBrand();
    if (hasRU == CV_DEFAULT)
        returnUrl = m_pRegistryConfig->getDefaultRU();
    if (hasKPP == CV_DEFAULT)
        nKPP = -1;
    if (returnUrl == NULL)
        returnUrl = L"";

    if ((TimeWindow != 0 && TimeWindow < PPM_TIMEWINDOW_MIN) || TimeWindow > PPM_TIMEWINDOW_MAX)
    {
        WCHAR buf[20];
        _itow(TimeWindow,buf,10);
        AtlReportError(CLSID_Manager, (LPCOLESTR) PP_E_INVALID_TIMEWINDOWSTR,
                        IID_IPassportManager, PP_E_INVALID_TIMEWINDOW);
        return PP_E_INVALID_TIMEWINDOW;
    }

    if (m_ticketValid)
    {
        LPCWSTR domain = NULL;
        WCHAR url[MAX_URL_LENGTH];
        VARIANT freeMe;
        VariantInit(&freeMe);

        if (m_pRegistryConfig->DisasterModeP())
            lstrcpynW(url, A2W(m_pRegistryConfig->getDisasterUrl()), sizeof(url)/sizeof(WCHAR));
        else
        {
            if (m_profileValid &&
                m_piProfile->get_ByIndex(MEMBERNAME_INDEX, &freeMe) == S_OK &&
                freeMe.vt == VT_BSTR)
            {
                domain = wcsrchr(freeMe.bstrVal, L'@');
            }

            cnc->getDomainAttribute(L"Default",
                                    L"Logout",
                                    sizeof(url)/sizeof(WCHAR),
                                    url,
                                    Lang);
        }

        // find out if there are any updates
        BSTR upd = NULL;
        m_piProfile->get_updateString(&upd);

        if (upd)
        {
            TAKEOVER_BSTR(upd);
            // form the appropriate URL
            CCoCrypt* crypt = NULL;
            BSTR newCH = NULL;
            crypt = m_pRegistryConfig->getCurrentCrypt(); // IsValid ensures this is non-null
            // This should never fail... (famous last words)
            crypt->Encrypt(m_pRegistryConfig->getCurrentCryptVersion(), (LPSTR)upd, SysStringByteLen(upd), &newCH);
            FREE_BSTR(upd);
            TAKEOVER_BSTR(newCH);
            WCHAR iurlbuf[1024];
            LPCWSTR iurl;
            cnc->getDomainAttribute(domain ? domain+1 : L"Default",
                                    L"Update",
                                    sizeof(iurlbuf) >> 1,
                                    iurlbuf,
                                    Lang);

            // convert this url to https as appropriate
            if(!bSecure)
                iurl = iurlbuf;
            else
            {
                LPWSTR pszNewURL;
                LPWSTR psz;

                try
                {
                    pszNewURL = (LPWSTR)alloca((lstrlenW(iurlbuf) + 2) * sizeof(WCHAR));
                }
                catch(...)
                {
                    pszNewURL = NULL;
                    // do nothing, just continue to use http url in this case.
                }

                if(pszNewURL)
                {
                    psz = wcsstr(iurlbuf, L"http:");
                    if(psz != NULL)
                    {
                        psz += 4;

                        lstrcpynW(pszNewURL, iurlbuf, (psz - iurlbuf + 1));
                        lstrcatW(pszNewURL, L"s");
                        lstrcatW(pszNewURL, psz);

                        iurl = pszNewURL;
                    }
                }
            }

            // This is a bit gross... we need to find the $1 in the update url...
            LPCWSTR ins = iurl ? (wcsstr(iurl, L"$1")) : NULL;
            // We'll break if null, but won't crash...
            if (ins && *url != L'\0')
                *pVal = FormatUpdateLogoTag(
                                        url,
                                        m_pRegistryConfig->getSiteId(),
                                        returnUrl,
                                        TimeWindow,
                                        ForceLogin,
                                        m_pRegistryConfig->getCurrentCryptVersion(),
                                        ct,
                                        CBT,
                                        nKPP,
                                        iurl,
                                        bSecure,
                                        newCH,
                                        PM_LOGOTYPE_SIGNOUT,
                                        ulSecureLevel,
                                        m_pRegistryConfig
                                        );
            FREE_BSTR(newCH);
        }
        else
        {
            WCHAR iurl[MAX_URL_LENGTH] = L"";
            cnc->getDomainAttribute(L"Default",
                                    szSOAttrName,
                                    sizeof(iurl)/sizeof(WCHAR),
                                    iurl,
                                    Lang);
            if (*iurl != L'\0')
                *pVal = FormatNormalLogoTag(
                                    url,
                                    m_pRegistryConfig->getSiteId(),
                                    returnUrl,
                                    TimeWindow,
                                    ForceLogin,
                                    m_pRegistryConfig->getCurrentCryptVersion(),
                                    ct,
                                    CBT,
                                    iurl,
                                    NULL,
                                    nKPP,
                                    PM_LOGOTYPE_SIGNOUT,
                                    Lang,
                                    ulSecureLevel,
                                    m_pRegistryConfig,
                                    fRedirToSelf
                                    );
        }
        VariantClear(&freeMe);
    }
    else
    {
        WCHAR url[MAX_URL_LENGTH];
        if (!(m_pRegistryConfig->DisasterModeP()))
            cnc->getDomainAttribute(L"Default",
                                    szAUAttrName,
                                    sizeof(url)/sizeof(WCHAR),
                                    url,
                                    Lang);
        else
            lstrcpynW(url, A2W(m_pRegistryConfig->getDisasterUrl()), sizeof(url)/sizeof(WCHAR));

        WCHAR iurl[MAX_URL_LENGTH];
        cnc->getDomainAttribute(L"Default",
                                szSIAttrName,
                                sizeof(iurl)/sizeof(WCHAR),
                                iurl,
                                Lang);
        if (*iurl != L'\0')
            *pVal = FormatNormalLogoTag(
                                url,
                                m_pRegistryConfig->getSiteId(),
                                returnUrl,
                                TimeWindow,
                                ForceLogin,
                                m_pRegistryConfig->getCurrentCryptVersion(),
                                ct,
                                CBT,
                                iurl,
                                NameSpace,
                                nKPP,
                                PM_LOGOTYPE_SIGNIN,
                                Lang,
                                ulSecureLevel,
                                m_pRegistryConfig,
                                fRedirToSelf
                                );

    }

    cnc->Release();

    if (hasRU == CV_FREE && returnUrl)
        FREE_BSTR(returnUrl);
    if (hasCB == CV_FREE && CBT)
        FREE_BSTR(CBT);
        if (hasNameSpace == CV_FREE && NameSpace)
                FREE_BSTR(NameSpace);

    return S_OK;
}

STDMETHODIMP CManager::HasProfile(VARIANT var, VARIANT_BOOL *pVal)
{

//JVP - begin changes
#ifdef PASSPORT_VERBOSE_MODE_ON
        char szLogString[LOG_STRING_LEN] = "CManager::HasProfile, Enter";
        AddVariantAsString(var, szLogString, sizeof(szLogString));
        g_pTSLogger->AddDateTimeAndLog(szLogString);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes
    LPWSTR profileName;
    if (var.vt == (VT_BSTR | VT_BYREF))
        profileName = *var.pbstrVal;
    else if (var.vt == VT_BSTR)
        profileName = var.bstrVal;
    else if (var.vt == (VT_VARIANT | VT_BYREF))
    {
        return HasProfile(*(var.pvarVal), pVal);
    }
    else
        profileName = NULL;

    if ((!profileName) || (!_wcsicmp(profileName, L"core")))
    {
        HRESULT ok = m_piProfile->get_IsValid(pVal);
        if (ok != S_OK)
            *pVal = VARIANT_FALSE;
    }
    else
    {
        VARIANT vAtt;
        VariantInit(&vAtt);
        HRESULT ok = m_piProfile->get_Attribute(profileName, &vAtt);
        if (ok != S_OK)
        {
            if (g_pAlert)
                g_pAlert->report(PassportAlertInterface::ERROR_TYPE, PM_INVALID_PROFILETYPE);
            *pVal = VARIANT_FALSE;
        }
        else
        {
            if (vAtt.vt == VT_I4)
                *pVal = vAtt.lVal > 0 ? VARIANT_TRUE : VARIANT_FALSE;
            else if (vAtt.vt == VT_I2)
                *pVal = vAtt.iVal > 0 ? VARIANT_TRUE : VARIANT_FALSE;
            else
            {
                if (g_pAlert)
                    g_pAlert->report(PassportAlertInterface::ERROR_TYPE, PM_INVALID_PROFILETYPE);
            }
            VariantClear(&vAtt);
        }
    }

//JVP - begin changes
#ifdef PASSPORT_VERBOSE_MODE_ON
        strcpy(szLogString, "CManager::HasProfile, Exit");
        AddVariantBoolAsString(*pVal, szLogString, sizeof(szLogString));
        g_pTSLogger->AddDateTimeAndLog(szLogString);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes
    return(S_OK);
}

STDMETHODIMP CManager::get_HasTicket(VARIANT_BOOL *pVal)
{
//JVP - begin changes
#ifdef PASSPORT_VERBOSE_MODE_ON
        g_pTSLogger->AddDateTimeAndLog("CManager::get_HasTicket, Calling m_piTicket->get_IsAuthenticated");
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes

    if(!pVal) return E_POINTER;

    *pVal = m_ticketValid ? VARIANT_TRUE : VARIANT_FALSE;
    return S_OK;
}

STDMETHODIMP CManager::get_FromNetworkServer(VARIANT_BOOL *pVal)
{
    *pVal = (m_fromQueryString &&
             m_valid &&
             m_ticketValid) ? VARIANT_TRUE : VARIANT_FALSE;
//JVP - begin changes
#ifdef PASSPORT_VERBOSE_MODE_ON
        char szLogString[LOG_STRING_LEN] = "CManager::get_FromNetworkServer";
        AddVariantBoolAsString(*pVal, szLogString, sizeof(szLogString));
        g_pTSLogger->AddDateTimeAndLog(szLogString);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes

    return S_OK;
}

STDMETHODIMP CManager::HasFlag(VARIANT var, VARIANT_BOOL *pVal)
{
//JVP - begin changes
#ifdef PASSPORT_VERBOSE_MODE_ON
        g_pTSLogger->AddDateTimeAndLog("CManager::HasFlag, E_NOTIMPL");
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes


    AtlReportError(CLSID_Manager, PP_E_GETFLAGS_OBSOLETESTR,
               IID_IPassportManager, E_NOTIMPL);
    return E_NOTIMPL;
}

STDMETHODIMP CManager::get_TicketAge(int *pVal)
{
//JVP - begin changes
#ifdef PASSPORT_VERBOSE_MODE_ON
        g_pTSLogger->AddDateTimeAndLog("CManager::get_TicketAge, Calling m_piTicket->get_TicketAge");
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes

    return m_piTicket->get_TicketAge(pVal);
}

STDMETHODIMP CManager::get_TicketTime(long *pVal)
{
//JVP - begin changes
#ifdef PASSPORT_VERBOSE_MODE_ON
        g_pTSLogger->AddDateTimeAndLog("CManager::get_TicketTime, Calling m_piTicket->get_TicketTime");
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes
    return m_piTicket->get_TicketTime(pVal);
}

STDMETHODIMP CManager::get_SignInTime(long *pVal)
{
//JVP - begin changes
#ifdef PASSPORT_VERBOSE_MODE_ON
        g_pTSLogger->AddDateTimeAndLog("CManager::get_SignInTime, Calling m_piTicket->get_SignInTime");
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes

    return m_piTicket->get_SignInTime(pVal);
}

STDMETHODIMP CManager::get_TimeSinceSignIn(int *pVal)
{
//JVP - begin changes
#ifdef PASSPORT_VERBOSE_MODE_ON
        g_pTSLogger->AddDateTimeAndLog("CManager::get_TimeSinceSignIn, Calling m_piTicket->get_TimeSinceSignIn");
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes

    return m_piTicket->get_TimeSinceSignIn(pVal);
}

STDMETHODIMP CManager::GetDomainAttribute(BSTR attributeName, VARIANT lcid, VARIANT domain, BSTR *pAttrVal)
{
     HRESULT   hr = S_OK;
//JVP - begin changes
#ifdef PASSPORT_VERBOSE_MODE_ON
        char szLogString[LOG_STRING_LEN] = "CManager::GetDomainAttribute, Enter";
        AddBSTRAsString(attributeName, szLogString, sizeof(szLogString));
        AddVariantAsString(lcid, szLogString, sizeof(szLogString));
        AddVariantAsString(domain, szLogString, sizeof(szLogString));
        g_pTSLogger->AddDateTimeAndLog(szLogString);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes
    if (!m_valid || !g_config->isValid()) // Guarantees config is non-null
    {
        AtlReportError(CLSID_Manager, PP_E_NOT_CONFIGUREDSTR,
                        IID_IPassportManager, PP_E_NOT_CONFIGURED);
        return PP_E_NOT_CONFIGURED;
    }

    if (!m_pRegistryConfig)
        m_pRegistryConfig = g_config->checkoutRegistryConfig();

    if (!m_pRegistryConfig) // Guarantees config is non-null
    {
        AtlReportError(CLSID_Manager, PP_E_NOT_CONFIGUREDSTR,
                        IID_IPassportManager, PP_E_NOT_CONFIGURED);
        return PP_E_NOT_CONFIGURED;
    }

    LPWSTR d;
    BSTR dn = NULL;
    if (domain.vt == (VT_BSTR | VT_BYREF))
        d = *domain.pbstrVal;
    else if (domain.vt == VT_BSTR)
        d = domain.bstrVal;
    else if (domain.vt == (VT_VARIANT | VT_BYREF))
    {
        return GetDomainAttribute(attributeName, lcid, *(domain.pvarVal), pAttrVal);
    }
    else
    {
        // domain best be not filled in this case, that's why we reuse it here
        // if not, let dfmn generate the error
        HRESULT hr = DomainFromMemberName(domain, &dn);
        if (hr != S_OK)
            return hr;
        TAKEOVER_BSTR(dn);
        d = dn;
    }

    CNexusConfig* cnc = g_config->checkoutNexusConfig();
    USHORT sLcid = 0;
    VARIANT innerLC;
    VariantInit(&innerLC);

    if (lcid.vt != VT_ERROR && VariantChangeType(&innerLC, &lcid, 0, VT_I2) == S_OK)
        sLcid = innerLC.iVal;
    else
    {
        sLcid = m_pRegistryConfig->getDefaultLCID();

        // Check user profile
        if (!sLcid && m_profileValid)
        {
            m_piProfile->get_ByIndex(LANGPREF_INDEX, &innerLC);
            if (innerLC.vt == VT_I2)
                sLcid = innerLC.iVal;
            VariantClear(&innerLC);
        }
    }

    WCHAR data[PP_MAX_ATTRIBUTE_LENGTH] = L"";
    cnc->getDomainAttribute(d,
                            attributeName,
                            sizeof(data)/sizeof(WCHAR),
                            data,
                            sLcid);
    if (*data)
    {
        *pAttrVal = ALLOC_AND_GIVEAWAY_BSTR(data);
    }
    else
    {
        // TODO: should change cnc->getDomainAttribute to return the right hr
        hr = E_INVALIDARG;
        *pAttrVal = NULL;
    }
    cnc->Release();
    if (dn) FREE_BSTR(dn);

//JVP - begin changes
#ifdef PASSPORT_VERBOSE_MODE_ON
        strcpy(szLogString, "CManager::GetDomainAttribute, Exit");
        AddBSTRAsString(*pAttrVal, szLogString, sizeof(szLogString));
        g_pTSLogger->AddDateTimeAndLog(szLogString);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes

    return hr;
}

STDMETHODIMP CManager::DomainFromMemberName(VARIANT var, BSTR *pDomainName)
{
    HRESULT hr;
    LPWSTR  psz, memberName;
    VARIANT intoVar;

//JVP - begin changes
#ifdef PASSPORT_VERBOSE_MODE_ON
        char szLogString[LOG_STRING_LEN] = "CManager::DomainFromMemberName, Enter";
        AddVariantAsString(var, szLogString, sizeof(szLogString));
        g_pTSLogger->AddDateTimeAndLog(szLogString);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes

    VariantInit(&intoVar);

    if (var.vt == (VT_BSTR | VT_BYREF))
        memberName = *var.pbstrVal;
    else if (var.vt == VT_BSTR)
        memberName = var.bstrVal;
    else if (var.vt == (VT_VARIANT | VT_BYREF))
    {
        return DomainFromMemberName(*(var.pvarVal), pDomainName);
    }
    else
    {
        // Try to get it from the profile
        if (!m_profileValid)
        {
            *pDomainName = ALLOC_AND_GIVEAWAY_BSTR(L"Default");
            return S_OK;
        }
        HRESULT hr = m_piProfile->get_Attribute(L"internalmembername", &intoVar);
        if (hr != S_OK)
        {
            *pDomainName = NULL;
            return hr;
        }
        if (VariantChangeType(&intoVar,&intoVar, 0, VT_BSTR) != S_OK)
        {
            AtlReportError(CLSID_Manager, L"PassportManager: Couldn't convert memberName to string.  Call partner support.",
                            IID_IPassportManager, E_FAIL);
            return E_FAIL;
        }
        memberName = intoVar.bstrVal;
    }


    if(memberName == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    psz = wcsrchr(memberName, L'@');
    if(psz == NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    psz++;

    *pDomainName = ALLOC_AND_GIVEAWAY_BSTR(psz);
    hr = S_OK;

    Cleanup:
    VariantClear(&intoVar);

//JVP - begin changes
#ifdef PASSPORT_VERBOSE_MODE_ON
        strcpy(szLogString, "CManager::DomainFromMemberName, Exit");
        AddLongAsString(hr,  szLogString, sizeof(szLogString));
        AddBSTRAsString(*pDomainName, szLogString, sizeof(szLogString));
        g_pTSLogger->AddDateTimeAndLog(szLogString);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes

    return hr;
}

STDMETHODIMP CManager::get_Profile(BSTR attributeName, VARIANT *pVal)
{

//JVP - begin changes
#ifdef PASSPORT_VERBOSE_MODE_ON
        g_pTSLogger->AddDateTimeAndLog("CManager::get_Profile, Calling m_piProfile->get_Attribute");
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes

    HRESULT hr = m_piProfile->get_Attribute(attributeName,pVal);

    if(hr == S_OK && pVal->vt != VT_EMPTY)
    {
        if(g_pPerf)
        {
            g_pPerf->incrementCounter(PM_VALIDPROFILEREQ_SEC);
            g_pPerf->incrementCounter(PM_VALIDPROFILEREQ_TOTAL);
        }
        else
        {
            _ASSERT(g_pPerf);
        }
    }

    return hr;
}

STDMETHODIMP CManager::put_Profile(BSTR attributeName, VARIANT newVal)
{

//JVP - begin changes
#ifdef PASSPORT_VERBOSE_MODE_ON
        g_pTSLogger->AddDateTimeAndLog("CManager::put_Profile, Calling m_piProfile->put_Attribute");
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes

    return m_piProfile->put_Attribute(attributeName,newVal);
}


STDMETHODIMP CManager::get_HexPUID(BSTR *pVal)
{
   if(!pVal) return E_INVALIDARG;

   if(m_piTicket)
      return m_piTicket->get_MemberId(pVal);
   else
      return PP_E_INVALID_TICKET;
}

STDMETHODIMP CManager::get_PUID(BSTR *pVal)
{
   if(!pVal) return E_INVALIDARG;

   if(m_piTicket)
   {
      HRESULT  hr = S_OK;
      WCHAR    id[64] = L"0";
      int      l = 0;
      int      h = 0;
      LARGE_INTEGER ui64;


      hr = m_piTicket->get_MemberIdLow(&l);
      if (S_OK != hr) return hr;
      hr = m_piTicket->get_MemberIdHigh(&h);
      if (S_OK != hr) return hr;

      ui64.HighPart = h;
      ui64.LowPart = l;

      _ui64tow(ui64.QuadPart, id, 10);

     *pVal = SysAllocString(id);

     if(*pVal == NULL)
     {
        hr = E_OUTOFMEMORY;
     }

     return hr;
   }
   else
      return PP_E_INVALID_TICKET;
}


STDMETHODIMP CManager::get_Ticket(BSTR attributeName, VARIANT *pVal)
{

//JVP - begin changes
#ifdef PASSPORT_VERBOSE_MODE_ON
        g_pTSLogger->AddDateTimeAndLog("CManager::get_Ticket, Calling m_piTicket->get_Attribute");
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes

    HRESULT hr = m_piTicket->GetProperty(attributeName,pVal);

#if 0 // we don't not need this
    if(hr == S_OK && pVal->vt != VT_EMPTY)
    {
        if(g_pPerf)
        {
// TODO -- shoud change -- we may not need this, visit back later
//            g_pPerf->incrementCounter(PM_VALIDREQUESTS_SEC);
//            g_pPerf->incrementCounter(PM_VALIDREQUESTS_TOTAL);
        }
        else
        {
            _ASSERT(g_pPerf);
        }
    }
#endif

    return hr;
}

#if 0 // removed -- wireless uses the same set of urls
STDMETHODIMP CManager::AuthURL3(
    VARIANT vRU,
    VARIANT vTimeWindow,
    VARIANT vForceLogin,
    VARIANT vCoBrand,
    VARIANT vLCID,
    VARIANT vNameSpace,
    VARIANT vKPP,
    VARIANT vUseSecureAuth,
    VARIANT functionArea,
    BSTR *pAuthUrl)
{
   return CommonAuthURL(vRU, vTimeWindow, vForceLogin,
                         vCoBrand, vLCID, vNameSpace,
                         vKPP, vUseSecureAuth,
                         FALSE, functionArea, pAuthUrl);

}
#endif

STDMETHODIMP CManager::LogoutURL(
    /* [optional][in] */ VARIANT vRU,
    /* [optional][in] */ VARIANT vCoBrand,
    /* [optional][in] */ VARIANT lang_id,
    /* [optional][in] */ VARIANT Namespace,
    /* [optional][in] */ VARIANT bSecure,
    /* [retval][out] */ BSTR __RPC_FAR *pVal)
{
   HRESULT  hr = S_OK;
   VARIANT_BOOL bUseSecure = VARIANT_FALSE;
   BSTR         CBT = NULL, returnUrl = NULL, bstrNameSpace = NULL;
   int          hasCB, hasRU, hasLCID, hasNameSpace, hasUseSec;
   USHORT       Lang;
   WCHAR        nameSpace[MAX_PATH] = L"";
   bool         bUrlFromSecureKey = false;
   WCHAR        UrlBuf[MAX_URL_LENGTH] = L"";
   WCHAR        retUrlBuf[MAX_URL_LENGTH] = L"";
   DWORD        bufLen = MAX_URL_LENGTH;
   WCHAR        qsLeadCh = L'?';
   int          iRet = 0;

   if (!pVal)  return E_INVALIDARG;

   CNexusConfig* cnc = g_config->checkoutNexusConfig();

   if (!m_pRegistryConfig)
      m_pRegistryConfig = g_config->checkoutRegistryConfig();


    if ((hasUseSec = GetBoolArg(bSecure, &bUseSecure)) == CV_BAD)
        return E_INVALIDARG;

    if ((hasLCID = GetShortArg(lang_id,&Lang)) == CV_BAD)
        return E_INVALIDARG;

    hasCB = GetBstrArg(vCoBrand, &CBT);
    if (hasCB == CV_BAD)
        return E_INVALIDARG;

    hasRU = GetBstrArg(vRU, &returnUrl);
    if (hasRU == CV_BAD)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hasNameSpace = GetBstrArg(Namespace, &bstrNameSpace);
    if (hasNameSpace == CV_BAD)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    // get the right URL -- namespace, secure

    // namespace
    if (!IsEmptyString(bstrNameSpace))
    {
      if(0 == _snwprintf(nameSpace, sizeof(nameSpace) / sizeof(WCHAR), L"%s", bstrNameSpace))
      {
         hr = HRESULT_FROM_WIN32(GetLastError());
         if FAILED(hr)
            goto Cleanup;
      }
    }

    if (hasCB == CV_DEFAULT)
        CBT = m_pRegistryConfig->getDefaultCoBrand();
    if (hasRU == CV_DEFAULT)
        returnUrl = m_pRegistryConfig->getDefaultRU();
    if (returnUrl == NULL)
        returnUrl = L"";



    if (*nameSpace == 0) // 0 length string
      wcscpy(nameSpace, L"Default");

    // secure
    if(bUseSecure == VARIANT_TRUE)
    {
       cnc->getDomainAttribute(nameSpace,
                            L"LogoutSecure",
                            sizeof(UrlBuf)/sizeof(WCHAR),
                            UrlBuf,
                            Lang);
       if (*UrlBuf != 0)
       {
           bUrlFromSecureKey = true;
       }
    }

    // insecure
    if (*UrlBuf == 0)
    {
       cnc->getDomainAttribute(nameSpace,
                            L"Logout",
                            sizeof(UrlBuf)/sizeof(WCHAR),
                            UrlBuf,
                            Lang);
    }
    // error case
    if(*UrlBuf == 0)
    {
        AtlReportError(CLSID_Profile, PP_E_LOGOUTURL_NOTDEFINEDSTR,
           IID_IPassportProfile, PP_E_LOGOUTURL_NOTDEFINED);
        hr = PP_E_LOGOUTURL_NOTDEFINED;
         goto Cleanup;
    }

    if(bUseSecure == VARIANT_TRUE && !bUrlFromSecureKey) // translate from http to https
    {
       if (_wcsnicmp(UrlBuf, L"http:", 5) == 0)  // replace with HTTPS
       {
          memmove(UrlBuf + 5, UrlBuf + 4, sizeof(UrlBuf) - 5 * sizeof(WCHAR));
          memcpy(UrlBuf, L"https", 5 * sizeof(WCHAR));
       }
    }

    // us common function to append the thing one by one ...
    if (wcsstr(UrlBuf, L"?"))  // ? already exists in the URL, use & to start
       qsLeadCh = L'&';
    if (CBT)
       _snwprintf(retUrlBuf, sizeof(retUrlBuf) / sizeof(WCHAR), L"%s%cid=%-d&ru=%s&lcid=%-d&cb=%s",
            UrlBuf, qsLeadCh, m_pRegistryConfig->getSiteId(), returnUrl, Lang, CBT);
    else
       _snwprintf(retUrlBuf, sizeof(retUrlBuf) / sizeof(WCHAR), L"%s%cid=%-d&ru=%s&lcid=%-d",
            UrlBuf, qsLeadCh, m_pRegistryConfig->getSiteId(), returnUrl, Lang);


   *pVal = ALLOC_AND_GIVEAWAY_BSTR(retUrlBuf);
Cleanup:
    cnc->Release();

    return hr;
}

#if 0 // this is not necessary, use should use 1. isAuthenticated, 2. prop bag to get secure level
STDMETHODIMP CManager::IsSecure(/*[in]*/ VARIANT secureLevel, /*[out, retval]*/ VARIANT_BOOL *pVal)
{
   if(!pVal)   return E_INVALIDARG;

   HRESULT  hr = S_OK;

   _variant_t  vFlags, vLevel;
   VARIANT  v;

   if(S_OK != VariantChangeType(&v, &secureLevel, 0, VT_I4))
      return E_INVALIDARG;;

   long requiredLevel = v.lVal;

   *pVal = VARIANT_FALSE;

   if(!m_bSecureTransported)
      return S_OK;

   if (S_OK != m_piTicket->GetProperty(ATTR_PASSPORTFLAGS, &vFlags)
         || S_OK != m_piTicket->GetProperty(ATTR_SECURELEVEL, &vLevel))
         return S_OK;

   if ( vFlags.vt != VT_I4 || vLevel.vt != VT_I4)
      return S_OK;

   if ( (vFlags.lVal & k_ulFlagsSecuredTransportedTicket) && vLevel.lVal >= requiredLevel)
      *pVal = VARIANT_TRUE;

   return S_OK;
}
#endif

STDMETHODIMP CManager::get_ProfileByIndex(int index, VARIANT *pVal)
{
    HRESULT hr = m_piProfile->get_ByIndex(index,pVal);

    if(hr == S_OK && pVal->vt != VT_EMPTY)
    {
        if(g_pPerf)
        {
            g_pPerf->incrementCounter(PM_VALIDPROFILEREQ_SEC);
            g_pPerf->incrementCounter(PM_VALIDPROFILEREQ_TOTAL);
        }
        else
        {
            _ASSERT(g_pPerf);
        }
    }

    return hr;
}

STDMETHODIMP CManager::put_ProfileByIndex(int index, VARIANT newVal)
{
    return m_piProfile->put_ByIndex(index,newVal);
}

BOOL CManager::handleQueryStringData(BSTR a, BSTR p)
{
    BOOL                retVal; //whither to set cookies
    HRESULT             hr;
    VARIANT             vFalse;
    _variant_t          vFlags;

    hr = DecryptTicketAndProfile(a, p, FALSE, NULL, m_pRegistryConfig, m_piTicket, m_piProfile);

    if(hr != S_OK)
    {
        m_ticketValid = VARIANT_FALSE;
        m_profileValid = VARIANT_FALSE;
        retVal = FALSE;
        goto Cleanup;
    }

    VariantInit(&vFalse);
    vFalse.vt = VT_BOOL;
    vFalse.boolVal = VARIANT_FALSE;

    m_piTicket->get_IsAuthenticated(0,
                                    VARIANT_FALSE,
                                    vFalse,
                                    &m_ticketValid);

    if(!m_bSecureTransported)  // secure bit should NOI set
    {
       if (S_OK == m_piTicket->GetProperty(ATTR_PASSPORTFLAGS, &vFlags))
       { // the bit should NOT set
          if ( vFlags.vt == VT_I4 && (vFlags.lVal & k_ulFlagsSecuredTransportedTicket) != 0)
             m_ticketValid = VARIANT_FALSE;
       }

    }

    // profile stuff
    m_piProfile->get_IsValid(&m_profileValid);

    if (m_ticketValid)
    {
        m_fromQueryString = true;

        // Set the cookies
        if (!m_pRegistryConfig->setCookiesP())
        {
            retVal = FALSE;
            goto Cleanup;
        }
    }
    else
    {
        retVal = FALSE;
        goto Cleanup;
    }

    retVal = TRUE;

Cleanup:

    return retVal;
}

BOOL CManager::handleCookieData(
    BSTR auth,
    BSTR prof,
    BSTR consent,
    BSTR secAuth
    )
{
    BOOL                retVal;
    HRESULT             hr;
    VARIANT             vDoSecureCheck;
    VARIANT_BOOL        bValid;
    _variant_t          vFlags;

    //  the consent cookie
    if(consent != NULL && SysStringLen(consent) != 0)
    {
        hr = DecryptTicketAndProfile(auth, prof, !(m_pRegistryConfig->bInDA()), consent, m_pRegistryConfig, m_piTicket, m_piProfile);
    }
    else
    {
        //
        //  If regular cookie domain/path is identical to consent cookie domain/path, then
        //  MSPProf cookie is equivalent to consent cookie, and we should set m_bUsingConsentCookie
        //  to true
        //

        BOOL bUsingConsentCookie = lstrcmpA(m_pRegistryConfig->getTicketDomain(), m_pRegistryConfig->getProfileDomain()) == 0 &&
                                lstrcmpA(m_pRegistryConfig->getTicketPath(), m_pRegistryConfig->getProfilePath()) == 0;

        hr = DecryptTicketAndProfile(auth, prof, !(m_pRegistryConfig->bInDA()) && !bUsingConsentCookie, NULL, m_pRegistryConfig, m_piTicket, m_piProfile);
    }

    if(hr != S_OK)
    {
        m_ticketValid = VARIANT_FALSE;
        m_profileValid = VARIANT_FALSE;
        retVal = FALSE;
        goto Cleanup;
    }

    VariantInit(&vDoSecureCheck);
    vDoSecureCheck.vt = VT_BOOL;

    if(secAuth && secAuth[0])
    {
        if(DoSecureCheck(secAuth, m_pRegistryConfig, m_piTicket) == S_OK)
            vDoSecureCheck.boolVal = VARIANT_TRUE;
        else
            vDoSecureCheck.boolVal = VARIANT_FALSE;
    }
    else
        vDoSecureCheck.boolVal = VARIANT_FALSE;

    m_piTicket->get_IsAuthenticated(0,
                                    VARIANT_FALSE,
                                    vDoSecureCheck,
                                    &m_ticketValid);

    // if the cookie should not include the secure bit
    if (S_OK == m_piTicket->GetProperty(ATTR_PASSPORTFLAGS, &vFlags))
    { // the bit should NOT set
       if ( vFlags.vt == VT_I4 && (vFlags.lVal & k_ulFlagsSecuredTransportedTicket) != 0)
          m_ticketValid = VARIANT_FALSE;
    }

    // for insecure case, the secure cookie should not come
    if(!m_bSecureTransported && (secAuth && secAuth[0]))  // this should not come
    {
       m_ticketValid = VARIANT_FALSE;
    }

    // profile stuff
    m_piProfile->get_IsValid(&m_profileValid);

    if(!m_ticketValid)
    {
        retVal = FALSE;
        goto Cleanup;
    }

    retVal = TRUE;

Cleanup:

    return retVal;
}

STDMETHODIMP CManager::get_HasSavedPassword(VARIANT_BOOL *pVal)
{
//JVP - begin changes
#ifdef PASSPORT_VERBOSE_MODE_ON
        g_pTSLogger->AddDateTimeAndLog("CManager::get_HasSavedPassword, Calling m_piTicket->get_HasSavedPassword");
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes

    return m_piTicket->get_HasSavedPassword(pVal);
}

STDMETHODIMP CManager::Commit(BSTR *pNewProfileCookie)
{

//JVP - begin changes
#ifdef PASSPORT_VERBOSE_MODE_ON
        g_pTSLogger->AddDateTimeAndLog("CManager::Commit, Enter");
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes

    if (!m_pRegistryConfig)
        m_pRegistryConfig = g_config->checkoutRegistryConfig();

    if (!m_valid || !g_config->isValid() || !m_pRegistryConfig) // Guarantees config is non-null
    {
        AtlReportError(CLSID_Manager, PP_E_NOT_CONFIGUREDSTR,
                        IID_IPassportManager, PP_E_NOT_CONFIGURED);
        return PP_E_NOT_CONFIGURED;
    }

    if (!m_ticketValid || !m_profileValid)
    {
        AtlReportError(CLSID_Manager, PP_E_IT_FOR_COMMITSTR,
                        IID_IPassportManager, PP_E_INVALID_TICKET);
        return PP_E_INVALID_TICKET;
    }

    // Write new passport profile cookie...
    // return a safearray if we aren't used from ASP
    BSTR newP = NULL;
    HRESULT hr = m_piProfile->incrementVersion();
    hr = m_piProfile->get_unencryptedProfile(&newP);
    TAKEOVER_BSTR(newP);

    if (hr != S_OK || newP == NULL)
    {
        AtlReportError(CLSID_Manager,
                        L"PassportManager.Commit: unknown failure.",
                        IID_IPassportManager, E_FAIL);
        return E_FAIL;
    }

    CCoCrypt* crypt = NULL;
    BSTR newCH = NULL;
    crypt = m_pRegistryConfig->getCurrentCrypt(); // IsValid ensures this is non-null
    crypt->Encrypt(m_pRegistryConfig->getCurrentCryptVersion(),(LPSTR)newP, SysStringByteLen(newP), &newCH);
    if (!newCH)
    {
        AtlReportError(CLSID_Manager,
                        L"PassportManager.Commit: encryption failure.",
                        IID_IPassportManager, E_FAIL);
        FREE_BSTR(newP);
        return E_FAIL;
    }
    FREE_BSTR(newP);
    TAKEOVER_BSTR(newCH);

    if (m_bOnStartPageCalled)
    {
        if (m_pRegistryConfig->setCookiesP())
        {
            try
            {
                VARIANT_BOOL persist;
                _bstr_t domain;
                _bstr_t path;

                if (m_pRegistryConfig->getTicketPath())
                    path = m_pRegistryConfig->getTicketPath();
                else
                    path = L"/";

                m_piTicket->get_HasSavedPassword(&persist);
                IRequestDictionaryPtr piCookies = m_piResponse->Cookies;

                VARIANT vtNoParam;
                VariantInit(&vtNoParam);
                vtNoParam.vt = VT_ERROR;
                vtNoParam.scode = DISP_E_PARAMNOTFOUND;

                IWriteCookiePtr piCookie = piCookies->Item[L"MSPProf"];
                piCookie->Item[vtNoParam] = newCH;
                domain = m_pRegistryConfig->getTicketDomain();
                if (domain.length())
                    piCookie->put_Domain(domain);
                if (persist)
                    piCookie->put_Expires(g_dtExpire);
                piCookie->put_Path(path);

            }
            catch (...)
            {
                FREE_BSTR(newCH);
                return E_FAIL;
            }
        }
    }
    GIVEAWAY_BSTR(newCH);
    *pNewProfileCookie = newCH;

    if(g_pPerf)
    {
        g_pPerf->incrementCounter(PM_PROFILECOMMITS_SEC);
        g_pPerf->incrementCounter(PM_PROFILECOMMITS_TOTAL);
    }
    else
    {
        _ASSERT(g_pPerf);
    }

//JVP - begin changes
#ifdef PASSPORT_VERBOSE_MODE_ON
        g_pTSLogger->AddDateTimeAndLog("CManager::Commit, Exit");
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes

    return S_OK;
}

STDMETHODIMP CManager::_Ticket(IPassportTicket** piTicket)
{
    return m_piTicket->QueryInterface(IID_IPassportTicket,(void**)piTicket);
}

STDMETHODIMP CManager::_Profile(IPassportProfile** piProfile)
{
    return m_piProfile->QueryInterface(IID_IPassportProfile,(void**)piProfile);
}

STDMETHODIMP CManager::DomainExists(
    BSTR bstrDomainName,
    VARIANT_BOOL* pbExists
    )
{
#ifdef PASSPORT_VERBOSE_MODE_ON
    g_pTSLogger->AddDateTimeAndLog("CManager::DomainExists, Enter");
#endif //PASSPORT_VERBOSE_MODE_ON

    if(!pbExists)
        return E_INVALIDARG;

    if(!g_config->isValid())
    {
        AtlReportError(CLSID_Manager, PP_E_NOT_CONFIGUREDSTR,
                        IID_IPassportManager, PP_E_NOT_CONFIGURED);
        return PP_E_NOT_CONFIGURED;
    }

    CNexusConfig* cnc = g_config->checkoutNexusConfig();

    *pbExists = cnc->DomainExists(bstrDomainName) ? VARIANT_TRUE : VARIANT_FALSE;

    cnc->Release();

#ifdef PASSPORT_VERBOSE_MODE_ON
    g_pTSLogger->AddDateTimeAndLog("CManager::DomainExists, Exit");
#endif //PASSPORT_VERBOSE_MODE_ON

    return S_OK;
}

STDMETHODIMP CManager::get_Domains(VARIANT *pArrayVal)
{
//JVP - begin changes
#ifdef PASSPORT_VERBOSE_MODE_ON
        g_pTSLogger->AddDateTimeAndLog("CManager::get_Domains, Enter");
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes

    if (!pArrayVal)
        return E_INVALIDARG;

    if (!g_config->isValid()) // Guarantees config is non-null
    {
        AtlReportError(CLSID_Manager, PP_E_NOT_CONFIGUREDSTR,
                        IID_IPassportManager, PP_E_NOT_CONFIGURED);
        return PP_E_NOT_CONFIGURED;
    }

    CNexusConfig* cnc = g_config->checkoutNexusConfig();

    int iArr = 0;
    LPCWSTR *arr = cnc->getDomains(&iArr);

    if (!arr || iArr == 0)
    {
        VariantClear(pArrayVal);
        return S_OK;
    }

    // Make a safearray with all the goods
    SAFEARRAYBOUND rgsabound;
    rgsabound.lLbound = 0;
    rgsabound.cElements = iArr;
    SAFEARRAY *sa = SafeArrayCreate(VT_VARIANT, 1, &rgsabound);

    if (!sa)
    {
        cnc->Release();
        return E_OUTOFMEMORY;
    }

    VariantInit(pArrayVal);
    pArrayVal->vt = VT_ARRAY | VT_VARIANT;
    pArrayVal->parray = sa;

    VARIANT *vArray;
    SafeArrayAccessData(sa, (void**)&vArray);

    for (long i = 0; i < iArr; i++)
    {
        vArray[i].vt = VT_BSTR;
        vArray[i].bstrVal = ALLOC_AND_GIVEAWAY_BSTR(arr[i]);
    }
    SafeArrayUnaccessData(sa);

    delete[] arr;
    cnc->Release();
    return S_OK;

//JVP - begin changes
#ifdef PASSPORT_VERBOSE_MODE_ON
        g_pTSLogger->AddDateTimeAndLog("CManager::get_Domains, Exit");
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes

}

STDMETHODIMP CManager::get_Error(long* plError)
{
    if(plError == NULL)
        return E_INVALIDARG;

    if(m_ticketValid)
    {
        m_piTicket->get_Error(plError);
        if(*plError == 0)
            *plError = m_lNetworkError;
    }
    else
    {
        *plError = m_lNetworkError;
    }


//JVP - begin changes
#ifdef PASSPORT_VERBOSE_MODE_ON
        char szLogString[LOG_STRING_LEN] = "CManager::get_Error";
        AddLongAsString(*plError, szLogString, sizeof(szLogString));
        g_pTSLogger->AddDateTimeAndLog(szLogString);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes

    return S_OK;
}

STDMETHODIMP CManager::GetServerInfo(BSTR *pbstrOut)
{
    if (!m_valid || !g_config->isValid()) // Guarantees config is non-null
    {
        AtlReportError(CLSID_Manager, PP_E_NOT_CONFIGUREDSTR,
                   IID_IPassportManager, PP_E_NOT_CONFIGURED);
        return PP_E_NOT_CONFIGURED;
    }

    if(!m_pRegistryConfig)
        //  This only happens when OnStartPage was not called first.
        m_pRegistryConfig = g_config->checkoutRegistryConfig();

    if (!m_pRegistryConfig)
    {
        AtlReportError(CLSID_Manager, PP_E_NOT_CONFIGUREDSTR,
                   IID_IPassportManager, PP_E_NOT_CONFIGURED);
        return PP_E_NOT_CONFIGURED;
    }

    CNexusConfig* cnc = g_config->checkoutNexusConfig();
    BSTR bstrVersion = cnc->GetXMLInfo();
    cnc->Release();

    WCHAR wszName[MAX_COMPUTERNAME_LENGTH+1];
    DWORD dwSize = MAX_COMPUTERNAME_LENGTH+1;
    GetComputerName(wszName, &dwSize);

    *pbstrOut = ALLOC_AND_GIVEAWAY_BSTR_LEN(NULL, wcslen(wszName)+::SysStringLen(bstrVersion)+1);

    wcscpy(*pbstrOut, wszName);
    BSTR p = *pbstrOut + wcslen(wszName);
    *p = L' ';
    wcsncpy(p+1, bstrVersion, ::SysStringLen(bstrVersion));

        return S_OK;
}

STDMETHODIMP
CManager::HaveConsent(
    VARIANT_BOOL    bNeedFullConsent,
    VARIANT_BOOL    bNeedBirthdate,
    VARIANT_BOOL*   pbHaveConsent)
{
    HRESULT hr;
    ULONG   flags = 0;
    VARIANT vBdayPrecision;
    BOOL    bKid;
    BOOL    bConsentSatisfied;
    NeedConsentEnum   needConsentCode = NeedConsent_Undefined;

    if(pbHaveConsent == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *pbHaveConsent = VARIANT_FALSE;

    VariantInit(&vBdayPrecision);

    //
    //  Get flags.
    //


    hr = m_piTicket->needConsent(&flags, &needConsentCode); // ignore return value

    if (hr != S_OK)
    {
         hr = S_OK;
         goto Cleanup;
    }

    // if old ticket, we get the consent info from the profile
    if(needConsentCode == NeedConsent_Undefined)
    {
      // then we get from profile
      VARIANT_BOOL bValid;
      CComVariant  vFlags;
      m_piProfile->get_IsValid(&bValid);

      if(bValid == VARIANT_FALSE)
      {
         hr = S_OK;
         goto Cleanup;
      }

      hr = m_piProfile->get_Attribute(L"flags", &vFlags);

      if(hr != S_OK)
         goto Cleanup;

      bKid = ((V_I4(&vFlags) & k_ulFlagsAccountType) == k_ulFlagsAccountTypeKid);
    }
    else
       bKid = ((flags & k_ulFlagsAccountType) == k_ulFlagsAccountTypeKid);

    // we should have the flags by now
    //
    //  Do we have the requested level of consent?
    //

    bConsentSatisfied = bNeedFullConsent ? (flags & 0x60) == 0x40 :
                                           (flags & 0x60) != 0;

    if(bKid)
    {
        *pbHaveConsent = (bConsentSatisfied) ? VARIANT_TRUE : VARIANT_FALSE;
    }
    else
    {
        //
        //  Make sure we have birthday if it was requested.
        //
        //  no return value check need here, always returns S_OK.
        VARIANT_BOOL bValid;
        m_piProfile->get_IsValid(&bValid);

        //  if profile is not valid, then we don't have consent.
        //  return.
        if(bValid == VARIANT_FALSE)
        {
            hr = S_OK;
            goto Cleanup;
        }

        if(bNeedBirthdate)
        {
            hr = m_piProfile->get_Attribute(L"bday_precision", &vBdayPrecision);
            if(hr != S_OK)
                goto Cleanup;

            *pbHaveConsent = (vBdayPrecision.lVal != 0 && vBdayPrecision.lVal != 3) ?
                             VARIANT_TRUE : VARIANT_FALSE;
        }
        else
            *pbHaveConsent = VARIANT_TRUE;
    }

    hr = S_OK;

Cleanup:

    VariantClear(&vBdayPrecision);

        return hr;
}


//
//  check the qs parameter. if challenge is requested,
//  build the auth header and redirect with a modified qs
//
BOOL CManager::checkForPassportChallenge(IRequestDictionaryPtr piServerVariables)
{
    //  just need the request string
    _variant_t  vtItemName, vtQueryString;
    vtItemName = L"QUERY_STRING";

    piServerVariables->get_Item(vtItemName, &vtQueryString);
    if(vtQueryString.vt != VT_BSTR)
        vtQueryString.ChangeType(VT_BSTR);

    if (vtQueryString.bstrVal && *vtQueryString.bstrVal)
    {
        // check if pchg=1 is there. It is the first parameter ....
        PWSTR   psz = wcsstr(vtQueryString.bstrVal, L"pchg=1");
        if (psz)
        {

            //  we are in business. reformat the URL, insert the headers and
            //  redirect
            psz = wcsstr(psz, PPLOGIN_PARAM);
            _ASSERT(psz);
            if (psz)
            {
                psz += wcslen(PPLOGIN_PARAM);
                PWSTR   pszEndLoginUrl = wcsstr(psz, L"&");
                _ASSERT(pszEndLoginUrl);
                if (pszEndLoginUrl)
                {
                    *pszEndLoginUrl = L'\0';
                    //  unescape the URL
                    //  use temp buffer ...
                    CComBSTR    bstrBuf(wcslen(psz)+1);
                    DWORD       cch = bstrBuf.Length();
//                    PPUnescapeUrl(psz, psz, (DWORD*)&dwLen, pszEndLoginUrl - psz);
                    if(!InternetCanonicalizeUrl(psz,
                                                bstrBuf,
                                                &cch,
                                                ICU_DECODE | ICU_NO_ENCODE))
                    {
                        //  what else can be done ???
                        _ASSERT(FALSE);
                    }
                    else
                    {
                        //  copy the unescaped URL to the orig buffer
                        wcscpy(psz, (BSTR)bstrBuf);
                        //  set headers first ...
                        //  just use the qs param with some reformatting
                        _bstr_t bstrHeader;
                        HeaderFromQS(wcsstr(psz, L"?"), bstrHeader);
                        m_piResponse->AddHeader(L"WWW-Authenticate", bstrHeader);
                        //  Url is ready, redirect ...
                        m_piResponse->Redirect(psz);
                        return  TRUE;
                    }
                }
            }
        }
    }

    return  FALSE;
}


//
//  given a queryString, format the www-authenticate header
//
BOOL
CManager::HeaderFromQS(PWSTR    pszQS, _bstr_t& bstrHeader)
{

    //  common header start ...
    bstrHeader = PASSPORT_PROT14;
    BOOL    fSuccess = TRUE;
    //  advance thru any leading junk ...
    while(!iswalnum(*pszQS) && *pszQS) pszQS++;
    if (!*pszQS)
        return  FALSE;

    WCHAR   rgszValue[1000];    // buffer large enough for most values ...
    PCWSTR psz = pszQS, pszNext = pszQS;
    while(TRUE)
    {
        //  no param name is more than 10 ....
        WCHAR   rgszName[10];
        LONG    cch = sizeof(rgszName)/sizeof(WCHAR);
        PCWSTR  pszName = psz;
        while(*pszNext && *pszNext != L'&') pszNext++;
        //  grab the next qsparam
        // name first
        while(*pszName != L'=' && pszName < pszNext) pszName++;
        _ASSERT(pszName != pszNext); // this should never happen
        if (pszName == pszNext)
        {
            //  and if it does, skip this parameter and return FALSE ...
            fSuccess = FALSE;
        }
        else
        {
            PWSTR   pszVal = rgszValue;
            _ASSERT(pszName - psz < cch);
            wcsncpy(rgszName, psz, min(pszName - psz, cch));
            rgszName[min(cch-1, pszName - psz)] = L'\0';
            //  next comes the value
            pszName++;
            if (pszNext - pszName >= sizeof(rgszValue))
            {
                //  have to allocate ...
                pszVal = new WCHAR[pszNext - pszName];
                if (!pszVal)
                {
                    fSuccess = FALSE;
                }
            }
            if (pszVal)
            {
                //  copy the value ...
                wcsncpy(pszVal, pszName, pszNext - pszName);
                pszVal[pszNext - pszName] = L'\0';
                //  and insert in the header ...
                if (psz != pszQS)
                    //  this is not the first param
                    bstrHeader += L",";
                else
                    //  first separator is a space ...
                    bstrHeader += L" ";

                bstrHeader += _bstr_t(rgszName) + L"=" + pszVal;
                if (pszVal != rgszValue)
                    //  it was alloc'd
                    delete  pszVal;
            }
        } // else '=' found
        //  skip to the next param ...
        if (!*pszNext)
            break;
        psz = ++pszNext;
    } // while


    return  fSuccess;
}


//
//  format WWW-Auth from parameters
//
STDMETHODIMP CManager::FormatAuthHeaderFromParams(PCWSTR    pszLoginUrl,    // unused for now
                                                  PCWSTR    pszRetUrl,
                                                  ULONG     ulTimeWindow,
                                                  BOOL      fForceLogin,
                                                  time_t    ct,
                                                  PCWSTR    pszCBT,         // unused for now
                                                  PCWSTR    pszNamespace,
                                                  int       nKpp,
                                                  PWSTR     pszLCID,    // tweener needs the LCID
                                                  ULONG     ulSecureLevel,
                                                  _bstr_t&  strHeader   //  return result
                                                  )
{
    WCHAR   temp[10];
    // based on the spec ...
    strHeader = _bstr_t(PASSPORT_PROT14) + L" id=";

    //  site=
    _ultow(m_pRegistryConfig->getSiteId(), temp, 10);
    strHeader += temp;

    //  rtw=
    strHeader += ",tw=";
    _ultow(ulTimeWindow, temp, 10);
    strHeader += temp;

    if (fForceLogin)
    {
        strHeader += _bstr_t(",fs=1");
    }
    if (pszNamespace && *pszNamespace)
    {
        strHeader += _bstr_t(",ns=") + pszNamespace;
    }
    //  ru=
    strHeader += _bstr_t(",ru=") + pszRetUrl;

    //  ct=
    _ultow(ct, temp, 10);
    strHeader += _bstr_t(L",ct=") + temp;

    //  kpp
    if (nKpp != -1)
    {
        _ultow(nKpp, temp, 10);
        strHeader += _bstr_t(L",kpp=") + temp;
    }

    //  key version and version
    _ultow(m_pRegistryConfig->getCurrentCryptVersion(), temp, 10);
    strHeader += _bstr_t(L",kv=") + temp;
    strHeader += _bstr_t(L",ver=") + GetVersionString();

    //  lcid
    strHeader += _bstr_t(L",lcid=") + pszLCID;
    //  secure level
    if (ulSecureLevel)
    {
        strHeader += _bstr_t(L",seclog=") + _ultow(ulSecureLevel, temp, 10);
    }

    return  S_OK;
}



//
//  common code to parse user's parameters
//  and get defaults from registry config
//
STDMETHODIMP CManager::GetLoginParams(VARIANT vRU,
                              VARIANT vTimeWindow,
                              VARIANT vForceLogin,
                              VARIANT vCoBrand,
                              VARIANT vLCID,
                              VARIANT vNameSpace,
                              VARIANT vKPP,
                              VARIANT vUseSecureAuth,
                              //    these are the processed values
                              _bstr_t&  strUrl,
                              _bstr_t&  strReturnUrl,
                              UINT&     TimeWindow,
                              VARIANT_BOOL& ForceLogin,
                              time_t&   ct,
                              _bstr_t&  strCBT,
                              _bstr_t&  strNameSpace,
                              int&      nKpp,
                              ULONG&    ulSecureLevel,
                              PWSTR     pszLCID)
{
    USES_CONVERSION;
    LPCWSTR url;
    VARIANT freeMe;
    BSTR         CBT = NULL, returnUrl = NULL, bstrNameSpace = NULL;
    int          hasCB, hasRU, hasLCID, hasTW, hasFL, hasNameSpace, hasKPP, hasUseSec;
    USHORT       Lang;
    HRESULT      hr = S_OK;

//JVP - begin changes
#ifdef PASSPORT_VERBOSE_MODE_ON
        char szLogString[LOG_STRING_LEN] = "CManager::GetLoginParams, Enter";
        AddVariantAsString(vRU, szLogString, sizeof(szLogString));
        AddVariantAsString(vTimeWindow, szLogString, sizeof(szLogString));
        AddVariantAsString(vForceLogin, szLogString, sizeof(szLogString));
        AddVariantAsString(vCoBrand, szLogString, sizeof(szLogString));
        AddVariantAsString(vLCID, szLogString, sizeof(szLogString));
        AddVariantAsString(vNameSpace, szLogString, sizeof(szLogString));
        g_pTSLogger->AddDateTimeAndLog(szLogString);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes
    if (!m_pRegistryConfig)
        m_pRegistryConfig = g_config->checkoutRegistryConfig();

    if (!m_valid || !g_config->isValid() || !m_pRegistryConfig) // Guarantees config is non-null
    {
        AtlReportError(CLSID_Manager, PP_E_NOT_CONFIGUREDSTR,
                    IID_IPassportManager, PP_E_NOT_CONFIGURED);
        return PP_E_NOT_CONFIGURED;
    }

    // Make sure args are of the right type
    if ((hasTW = GetIntArg(vTimeWindow, (int*) &TimeWindow)) == CV_BAD)
        return E_INVALIDARG;
    if ((hasFL = GetBoolArg(vForceLogin, &ForceLogin)) == CV_BAD)
        return E_INVALIDARG;
    if ((hasUseSec = GetIntArg(vUseSecureAuth, (int*)&ulSecureLevel)) == CV_BAD)
        return E_INVALIDARG;
    if ((hasLCID = GetShortArg(vLCID, &Lang)) == CV_BAD)
        return E_INVALIDARG;
    if ((hasKPP = GetIntArg(vKPP, &nKpp)) == CV_BAD)
        return E_INVALIDARG;
    hasCB = GetBstrArg(vCoBrand, &CBT);
    if (hasCB == CV_BAD)
        return E_INVALIDARG;
    strCBT = CBT;
    if (hasCB == CV_FREE)
    {
        TAKEOVER_BSTR(CBT);
    }

    hasRU = GetBstrArg(vRU, &returnUrl);
    if (hasRU == CV_BAD)
    {
        if (hasCB == CV_FREE && CBT) FREE_BSTR(CBT);
            return E_INVALIDARG;
    }
    strReturnUrl = returnUrl;
    if (hasRU == CV_FREE)
    {
        FREE_BSTR(returnUrl);
    }

    hasNameSpace = GetBstrArg(vNameSpace, &bstrNameSpace);
    if (hasNameSpace == CV_BAD)
    {
        if (hasCB == CV_FREE && CBT) SysFreeString(CBT);
        if (hasRU == CV_FREE && returnUrl) SysFreeString(returnUrl);
        return E_INVALIDARG;
    }
    if (hasNameSpace == CV_OK)
        strNameSpace = bstrNameSpace;
    else
        // default
        strNameSpace = L"";
    if (hasNameSpace == CV_FREE)
    {
        FREE_BSTR(bstrNameSpace);
    }

    WCHAR *szAUAttrName;
    if (hasUseSec == CV_OK && SECURELEVEL_USE_HTTPS(ulSecureLevel))
        szAUAttrName = L"AuthSecure";
    else
        szAUAttrName = L"Auth";

    CNexusConfig* cnc = g_config->checkoutNexusConfig();

    if (hasLCID == CV_DEFAULT)
        Lang = m_pRegistryConfig->getDefaultLCID();
    if (hasKPP == CV_DEFAULT)
        nKpp = -1;

    //  convert the LCID to str for tweener ...
    _itow((int)Lang, pszLCID, 10);
    VariantInit(&freeMe);

    if (!m_pRegistryConfig->DisasterModeP())
    {
        // If I'm authenticated, get my domain specific url
        WCHAR   UrlBuf[MAX_URL_LENGTH];
        if (m_ticketValid && m_profileValid)
        {
            HRESULT hr = m_piProfile->get_ByIndex(MEMBERNAME_INDEX, &freeMe);
            if (hr != S_OK || freeMe.vt != VT_BSTR)
            {
                cnc->getDomainAttribute(L"Default",
                                        szAUAttrName,
                                        sizeof(UrlBuf)/sizeof(WCHAR),
                                        UrlBuf,
                                        Lang);
                strUrl = UrlBuf;
            }
            else
            {
                LPCWSTR psz = wcsrchr(freeMe.bstrVal, L'@');
                cnc->getDomainAttribute(psz ? psz+1 : L"Default",
                                        szAUAttrName,
                                        sizeof(UrlBuf)/sizeof(WCHAR),
                                        UrlBuf,
                                        Lang);
                strUrl = UrlBuf;
            }
        }
        else
        {
            cnc->getDomainAttribute(L"Default",
                                    szAUAttrName,
                                    sizeof(UrlBuf)/sizeof(WCHAR),
                                    UrlBuf,
                                    Lang);
            strUrl = UrlBuf;
        }
    }
    else
        strUrl = A2W(m_pRegistryConfig->getDisasterUrl());

    time(&ct);

    if (hasTW == CV_DEFAULT)
        TimeWindow = m_pRegistryConfig->getDefaultTicketAge();
    if (hasFL == CV_DEFAULT)
        ForceLogin = m_pRegistryConfig->forceLoginP() ? VARIANT_TRUE : VARIANT_FALSE;
    if (hasCB == CV_DEFAULT)
        strCBT = m_pRegistryConfig->getDefaultCoBrand();
    if (hasRU == CV_DEFAULT)
        strReturnUrl = m_pRegistryConfig->getDefaultRU() ?
            m_pRegistryConfig->getDefaultRU() : L"";

    if ((TimeWindow != 0 && TimeWindow < PPM_TIMEWINDOW_MIN) || TimeWindow > PPM_TIMEWINDOW_MAX)
    {
        AtlReportError(CLSID_Manager, (LPCOLESTR) PP_E_INVALID_TIMEWINDOWSTR,
                        IID_IPassportManager, PP_E_INVALID_TIMEWINDOW);
        hr = PP_E_INVALID_TIMEWINDOW;
        goto Cleanup;
    }

Cleanup:
    return  hr;
}

//
//  get ticket & profile from auth header
//  params:
//  AuthHeader - [in/out] contents of HTTP_Authorization header
//  pszTicket - [out]   ptr to the ticket part in the header
//  pszProfile -[out]   ptr to the profile
//  pwszF   -   [out]   ptr to error coming in the header
//  Auth header contents is changed as a side effect of the function
//
static VOID GetTicketAndProfileFromHeader(PWSTR     pszAuthHeader,
                                          PWSTR&    pszTicket,
                                          PWSTR&    pszProfile,
                                          PWSTR&    pszF)
{
    if (pszAuthHeader && *pszAuthHeader)
    {
        // format is 'Authorization: from-PP='t=xxx&p=xxx'
        PWSTR pwsz = wcsstr(pszAuthHeader, L"from-PP");
        if (pwsz)
        {
            //  ticket and profile are enclosed in ''. Not very strict parsing indeed ....
            while(*pwsz != L'\'' && *pwsz)
                pwsz++;
            if (*pwsz++)
            {
                if (*pwsz == L'f')
                {
                    // error case
                    pszF = pwsz+2;
                }
                else
                {
                    //  ticket and profile ...
                    _ASSERT(*pwsz == L't');
                    pszTicket = pwsz+2;
                    while(*pwsz != L'&' && *pwsz)
                        pwsz++;
                    if (*pwsz)
                        *pwsz++ = L'\0', pszProfile = pwsz+2;
                    _ASSERT(*pwsz == L'p');
                    //  finally remove the last '
                }
                //  set \0 terminator
                while(*pwsz != L'\'' && *pwsz)
                    pwsz++;
                if (*pwsz)
                    *pwsz = L'\0';
            }
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
// IPassportService implementation

STDMETHODIMP CManager::Initialize(BSTR configfile, IServiceProvider* p)
{
    HRESULT hr;

    // Initialized?
    if (!g_config->isValid()) // This calls UpdateNow if not yet initialized.
    {
        AtlReportError(CLSID_Manager, PP_E_NOT_CONFIGUREDSTR,
                        IID_IPassportService, PP_E_NOT_CONFIGURED);
        hr = PP_E_NOT_CONFIGURED;
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:

    return hr;
}


STDMETHODIMP CManager::Shutdown()
{
    return S_OK;
}


STDMETHODIMP CManager::ReloadState(IServiceProvider*)
{
    HRESULT hr;

    // Initialize.

    if(!g_config->PrepareUpdate(TRUE))
    {
        AtlReportError(CLSID_Manager, PP_E_NOT_CONFIGUREDSTR,
                        IID_IPassportService, PP_E_NOT_CONFIGURED);
        hr = PP_E_NOT_CONFIGURED;
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:

    return hr;
}


STDMETHODIMP CManager::CommitState(IServiceProvider*)
{
    HRESULT hr;

    // Finish the two phase update.
    if(!g_config->CommitUpdate())
    {
        AtlReportError(CLSID_Manager, PP_E_NOT_CONFIGUREDSTR,
                        IID_IPassportService, PP_E_NOT_CONFIGURED);
        hr = PP_E_NOT_CONFIGURED;
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:

    return hr;
}


STDMETHODIMP CManager::DumpState(BSTR* pbstrState)
{
    ATLASSERT( *pbstrState != NULL &&
               "CManager:DumpState - "
               "Are you sure you want to hand me a non-null BSTR?" );

    g_config->Dump(pbstrState);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\passportmanager\passport.cpp ===
// Passport.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f Passportps.mk in the project directory.

#include "stdafx.h"
#include <atlbase.h>
#include "resource.h"
#include <initguid.h>
#include "Passport.h"

#include "Passport_i.c"
#include "Admin.h"
#include "Ticket.h"
#include "Profile.h"
#include "Manager.h"
#include "PassportCrypt.h"
#include "PassportFactory.h"
#include "PassportLock.hpp"
#include "PassportEvent.hpp"
#include "FastAuth.h"
#include "commd5.h"

HINSTANCE   hInst;
CComModule _Module;
CPassportConfiguration *g_config=NULL;
// CProfileSchema *g_authSchema = NULL;
BOOL g_bStarted = FALSE;

PassportAlertInterface* g_pAlert    = NULL;
PassportPerfInterface* g_pPerf    = NULL;
static CComPtr<IMD5>  g_spCOMmd5;

HRESULT GetGlobalCOMmd5(IMD5 ** ppMD5)
{
   HRESULT  hr = S_OK;

   if(!ppMD5) return E_INVALIDARG;
      
   if(!g_spCOMmd5)
   {
      hr = CoCreateInstance(__uuidof(CoMD5), NULL, CLSCTX_INPROC_SERVER, __uuidof(IMD5), (void**)ppMD5);
      *ppMD5 = (IMD5*) ::InterlockedExchangePointer((void**)&g_spCOMmd5, (void*)*ppMD5);
   }

   if (*ppMD5 == NULL && g_spCOMmd5 != NULL)
   {
      *ppMD5 = g_spCOMmd5;
      (*ppMD5)->AddRef();
   }

   return hr;
};
#ifdef PASSPORT_VERBOSE_MODE_ON

// logger object, this MUST be initialized before the pool object below, 
// because the pool creates one initial instance of passport manager, which
// will internall call CTSLog::Init.  If Init is called before object is
// constructed the object's internal state gets screwed up.
CTSLog* g_pTSLogger = NULL;
#endif //PASSPORT_VERBOSE_MODE_ON

// global pool object
// PassportObjectPool < CComObjectPooled < CManager > > g_Pool;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_Manager, CManager)
OBJECT_ENTRY(CLSID_Ticket, CTicket)
OBJECT_ENTRY(CLSID_Profile, CProfile)
OBJECT_ENTRY(CLSID_Crypt, CCrypt)
OBJECT_ENTRY(CLSID_Admin, CAdmin)
OBJECT_ENTRY(CLSID_FastAuth, CFastAuth)
OBJECT_ENTRY(CLSID_PassportFactory, CPassportFactory)
END_OBJECT_MAP()

// {{2D2B36FC-EB86-4e5c-9A06-20303542CCA3}
static const GUID CLSID_Manager_ALT = 
{ 0x2D2B36FC, 0xEB86, 0x4e5c, { 0x9A, 0x06, 0x20, 0x30, 0x35, 0x42, 0xCC, 0xA3 } };

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        hInst = hInstance;

        // gmarks
        // Initialize the Alert object
        if(!g_pAlert)
        {
            g_pAlert = CreatePassportAlertObject(PassportAlertInterface::EVENT_TYPE);
            if(g_pAlert)
            {
                g_pAlert->initLog(PM_ALERTS_REGISTRY_KEY, EVCAT_PM, NULL, 1);
            }
            else
            _ASSERT(g_pAlert);
        }
        if(g_pAlert)
            g_pAlert->report(PassportAlertInterface::INFORMATION_TYPE, PM_STARTED);

        // gmarks
        // Initialize the Perf object
        if(!g_pPerf) 
        {
            g_pPerf = CreatePassportPerformanceObject(PassportPerfInterface::PERFMON_TYPE);
            if(g_pPerf) 
            {
                // Initialize.
                g_pPerf->init(PASSPORT_PERF_BLOCK);
            }
            else
                _ASSERT(g_pPerf);
        }


        _Module.Init(ObjectMap, hInstance, &LIBID_PASSPORTLib);
        DisableThreadLibraryCalls(hInstance);
#ifdef MEM_DBG
        int tmpFlag = _CrtSetDbgFlag( _CRTDBG_REPORT_FLAG );
        tmpFlag |= _CRTDBG_ALLOC_MEM_DF;
        tmpFlag |= _CRTDBG_LEAK_CHECK_DF;
        _CrtSetDbgFlag( tmpFlag );
        char *myBuf = new char[64];
        strcpy(myBuf, "This leak ok!"); // Let em know it's working
#endif
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        // gmarks
        if(g_pAlert) 
        {
            g_pAlert->report(PassportAlertInterface::INFORMATION_TYPE, PM_STOPPED);
            delete g_pAlert;
        }
        if(g_pPerf)
            delete g_pPerf;

/*      
        if (g_config)
            delete g_config;
        g_config = NULL;
*/        
//        if (g_authSchema)
//            delete g_authSchema;
//        g_authSchema = NULL;

        _Module.Term();
    }
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    HRESULT hr = (_Module.GetLockCount()==0) ? S_OK : S_FALSE;

    if( hr == S_OK)
    {
      g_spCOMmd5.Release();

/*
        // gmarks
        if(g_pAlert) 
        {
            g_pAlert->report(PassportAlertInterface::INFORMATION_TYPE, PM_STOPPED);
            delete g_pAlert;
        }
        g_pAlert = NULL;
        if(g_pPerf)
            delete g_pPerf;
        g_pPerf = NULL;
*/

        if (g_config)
            delete g_config;
        g_config = NULL;
//JVP - begin changes 
#ifdef PASSPORT_VERBOSE_MODE_ON
        delete g_pTSLogger;
        g_pTSLogger = NULL;
#endif //PASSPORT_VERBOSE_MODE_ON
        g_bStarted = FALSE;
    }
    
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    HRESULT hr;
    static PassportLock startLock;

    if(!g_bStarted)
    {
        PassportGuard<PassportLock> g(startLock);

        if(!g_bStarted)
        {
            //JVP - begin changes 
            #ifdef PASSPORT_VERBOSE_MODE_ON
            if(g_pTSLogger == NULL)
            {
               g_pTSLogger = new CTSLog();
               if (g_pTSLogger == NULL)
               {
                  hr = E_OUTOFMEMORY;
                  goto Cleanup;
               }
            	g_pTSLogger->Init(NULL, THREAD_PRIORITY_NORMAL);
            }
            #endif //PASSPORT_VERBOSE_MODE_ON
            g_config = new CPassportConfiguration();
//            g_authSchema = InitAuthSchema();

            if (!g_config /* || !g_authSchema */)
            {
                hr = CLASS_E_CLASSNOTAVAILABLE;
                goto Cleanup;
            }

            g_bStarted = TRUE;
        }
    }

	GUID guidCLSID;
	if (InlineIsEqualGUID(rclsid, CLSID_Manager_ALT))
		guidCLSID = CLSID_Manager;
	else
		guidCLSID = rclsid;
    hr = _Module.GetClassObject(guidCLSID, riid, ppv);

Cleanup:

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}


/////////////////////////////////////////////////////////////////////////////
// GetMyVersion - return a version string for use in query strings.

LPWSTR
GetVersionString(void)
{
    static LONG             s_lCallersIn = 0;
    static WCHAR            s_achVersionString[32] = L"";
    static LPWSTR           s_pszVersionString = NULL;
    static PassportEvent    s_Event;

    TCHAR               achFileBuf[_MAX_PATH];
    DWORD               dwSize;
    LPVOID              lpVersionBuf = NULL;
    VS_FIXEDFILEINFO*   lpRoot;
    UINT                nRootLen;
    LONG                lCurrentCaller;

    if(s_pszVersionString == NULL)
    {
        lCurrentCaller = InterlockedIncrement(&s_lCallersIn);

        if(lCurrentCaller == 1)
        {
            //  First get my full path.
            if(GetModuleFileName(hInst, achFileBuf, sizeof(achFileBuf)) == 0)
                goto Cleanup;

            if((dwSize = GetFileVersionInfoSize(achFileBuf, &dwSize)) == 0)
                goto Cleanup;

            lpVersionBuf = new BYTE[dwSize];
            if(lpVersionBuf == NULL)
                goto Cleanup;

            if(GetFileVersionInfo(achFileBuf, 0, dwSize, lpVersionBuf) == 0)
                goto Cleanup;

            if(VerQueryValue(lpVersionBuf, TEXT("\\"), (LPVOID*)&lpRoot, &nRootLen) == 0)
                goto Cleanup;

            wsprintfW(s_achVersionString, L"%d.%d.%04d.%d", 
                     (lpRoot->dwProductVersionMS & 0xFFFF0000) >> 16,
                     lpRoot->dwProductVersionMS & 0xFFFF,
                     (lpRoot->dwProductVersionLS & 0xFFFF0000) >> 16,
                     lpRoot->dwProductVersionLS & 0xFFFF);

            s_pszVersionString = s_achVersionString;

            s_Event.Set();
        }
        else
        {
            //  Just wait to be signaled that we have the string.
            WaitForSingleObject(s_Event, INFINITE);
        }

        InterlockedDecrement(&s_lCallersIn);
    }

Cleanup:

    if(lpVersionBuf)
        delete [] lpVersionBuf;

    return s_pszVersionString;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\passportmanager\passportconfiguration.cpp ===
// PassportConfiguration.cpp: implementation of the CPassportConfiguration class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "PassportConfiguration.h"
#include <time.h>
#include "passportguard.hpp"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CPassportConfiguration::CPassportConfiguration() :
  m_rDefault(NULL), m_n(NULL), 
  m_rlastDefault(NULL), m_nlast(NULL), m_lastAttempt(0),
  m_ConfigMap(NULL), m_lastConfigMap(NULL),
  m_rPending(NULL), m_nPending(NULL), m_bUpdateInProgress(false),
  m_ConfigMapPending(NULL)
{
  m_nUpdate = RegisterCCDUpdateNotification(_T(PRCONFIG), this);
  m_rUpdate = RegisterConfigChangeNotification(this);
}

CPassportConfiguration::~CPassportConfiguration()
{
    REGCONFIGMAP::iterator it;

    if (m_nUpdate)
        UnregisterCCDUpdateNotification(m_nUpdate);
    if (m_rUpdate)
        UnregisterConfigChangeNotification(m_rUpdate);

    //
    //  Empty out config maps.
    //

    {
        PassportGuard<PassportLock> g(m_lock);

        if(m_ConfigMap)
        {
            while((it = m_ConfigMap->begin()) != m_ConfigMap->end())
            {
                it->second->Release();
                free(it->first);
                m_ConfigMap->erase(it);
            }

            delete m_ConfigMap;
            m_ConfigMap = NULL;
        }

        if(m_lastConfigMap)
        {
            while((it = m_lastConfigMap->begin()) != m_lastConfigMap->end())
            {
                it->second->Release();
                free(it->first);
                m_lastConfigMap->erase(it);
            }

            delete m_lastConfigMap;
            m_lastConfigMap = NULL;
        }
        if(m_ConfigMapPending)
        {
            while((it = m_ConfigMapPending->begin()) != m_ConfigMapPending->end())
            {
                it->second->Release();
                free(it->first);
                m_ConfigMapPending->erase(it);
            }

            delete m_ConfigMapPending;
            m_ConfigMapPending = NULL;
        }

        if (m_rDefault)
        {
            m_rDefault->Release();
            m_rDefault = NULL;
        }
        if (m_n)
        {
            m_n->Release();
            m_n = NULL;
        }
        if (m_rlastDefault)
        {
            m_rlastDefault->Release();
            m_rlastDefault = NULL;
        }
        if (m_nlast)
        {
            m_nlast->Release();
            m_nlast = NULL;
        }
        if (m_rPending)
        {
            m_rPending->Release();
            m_rPending = NULL;
        }
        if (m_nPending)
        {
            m_nPending->Release();
            m_nPending = NULL;
        }
    }
}

BOOL
CPassportConfiguration::IsIPAddress(
    LPSTR  szSiteName
    )
{
    for(LPSTR sz = szSiteName; *sz; sz++)
        if(!_istdigit(*sz) && *sz != '.' && *sz != ':')
            return FALSE;

    return TRUE;
}

CRegistryConfig* CPassportConfiguration::checkoutRegistryConfig(
    LPSTR szHost    //  Can be host name or IP
    )
{
    CRegistryConfig*        c = NULL;
    REGCONFIGMAP::iterator  it;
    PassportGuard<PassportLock> g(m_lock);

    if(m_ConfigMap != NULL && szHost && szHost[0])
    {
        if(IsIPAddress(szHost))
        {
            for(it = m_ConfigMap->begin(); it != m_ConfigMap->end(); it++)
            {
                if(lstrcmpA(szHost, it->second->getHostIP()) == 0)
                {
                    c = it->second->AddRef();
                    break;
                }
            }
        }
        else
        {
            it = m_ConfigMap->find(szHost);
            if(it != m_ConfigMap->end())
                c = it->second->AddRef();
        }
    }

    if (c == NULL)
    {
        if(!m_rDefault)
        {
            UpdateNow();
            c = m_rDefault ? m_rDefault->AddRef() : NULL;
        }
        else
            c = m_rDefault->AddRef();
    }

    return c;
}

CRegistryConfig* CPassportConfiguration::checkoutRegistryConfigBySite(
    LPSTR   szSiteName
    )
{
    CRegistryConfig*    crc = NULL;
    CHAR                achHostName[2048];
    DWORD               dwHostNameBufLen;

    if(szSiteName && szSiteName[0])
    {
        dwHostNameBufLen = sizeof(achHostName);
        if(CRegistryConfig::GetHostName(szSiteName, achHostName, &dwHostNameBufLen) != ERROR_SUCCESS)
            goto Cleanup;

        crc = checkoutRegistryConfig(achHostName);
    }
    else
    {
        crc = checkoutRegistryConfig();
    }

Cleanup:

    return crc;
}


CNexusConfig* CPassportConfiguration::checkoutNexusConfig()
{
    if (!m_n)
    {
        PassportGuard<PassportLock> g(m_lock);

        if (!m_n)  // In case it happened while we were waiting
            UpdateNow();

        return m_n ? m_n->AddRef() : NULL;
    }
    CNexusConfig *c = m_n->AddRef();
    return c;
}

BOOL CPassportConfiguration::isValid()
{
    if (m_rDefault != NULL && m_n != NULL)
        return m_rDefault->isValid() && m_n->isValid();
    else
    {
        PassportGuard<PassportLock> g(m_lock);

        if (m_rDefault == NULL || m_n == NULL)  // In case it happened while we were waiting
        {
            BOOL retVal = UpdateNow(FALSE);
            return retVal;
        }
    }
    return (m_rDefault && m_rDefault->isValid()) && (m_n && m_n->isValid());
}

BOOL CPassportConfiguration::TakeRegistrySnapshot(
    CRegistryConfig**   ppRegConfig,
    REGCONFIGMAP**      ppConfigMap
    )
{
    BOOL                    bReturn;

    *ppRegConfig = NULL;
    *ppConfigMap = NULL;

    // Registry
    CRegistryConfig* pNewRegConfig = new CRegistryConfig();
    if(!pNewRegConfig)
    {
        bReturn = FALSE;
        goto Cleanup;
    }
    pNewRegConfig->AddRef();

    //
    //  Read in all other site configs.  Only if we find a sites reg key with
    //  one or more subkeys.
    //

    REGCONFIGMAP* pNewRegMap;

    {
        CRegKey hkSites;
        LONG lResult = hkSites.Open(HKEY_LOCAL_MACHINE,
                                TEXT("Software\\Microsoft\\Passport\\Sites"),
                                KEY_READ);
        if(lResult == ERROR_SUCCESS)
        {
            DWORD dwNumSites;
            lResult = RegQueryInfoKey(hkSites, 
                                      NULL, 
                                      NULL, 
                                      NULL, 
                                      &dwNumSites, 
                                      NULL, 
                                      NULL, 
                                      NULL, 
                                      NULL, 
                                      NULL, 
                                      NULL, 
                                      NULL);
            if(lResult == ERROR_SUCCESS && dwNumSites)
            {
                pNewRegMap = new REGCONFIGMAP();
                if(pNewRegMap)
                {
                    DWORD   dwKeyIndex = 0;
                    CHAR    achSiteName[256];
                    DWORD   dwSiteNameLen = sizeof(achSiteName);
                    while(RegEnumKeyExA(hkSites, 
                                        dwKeyIndex++, 
                                        achSiteName, 
                                        &dwSiteNameLen,
                                        NULL,
                                        NULL,
                                        NULL,
                                        NULL) == ERROR_SUCCESS)
                    {
                        CRegistryConfig* crSite = new CRegistryConfig(achSiteName);
                        if(crSite)
                        {
                            crSite->AddRef();
                            if (crSite->isValid())
                            {
                                REGCONFIGMAP::value_type* v = 
                                    new REGCONFIGMAP::value_type(_strdup(crSite->getHostName()), 
                                                                 crSite);
                                if(v)
                                {
                                    pNewRegMap->insert(*v);
                                    delete v;
                                }
                                else
                                    crSite->Release();
                            }
                            else
                            {
                                if (g_pAlert)
                                    g_pAlert->report(PassportAlertInterface::ERROR_TYPE, 
                                                     PM_INVALID_CONFIGURATION,
                                crSite->getFailureString());
                                crSite->Release();
                            }
                        }

                        dwSiteNameLen = sizeof(achSiteName);
                    }
                }
            }
            else
                pNewRegMap = NULL;
        }
        else
            pNewRegMap = NULL;
    }

    // Assign out parameters and return value.
    *ppRegConfig = pNewRegConfig;
    *ppConfigMap = pNewRegMap;

    bReturn = TRUE;

Cleanup:

    return bReturn;
}


BOOL CPassportConfiguration::ApplyRegistrySnapshot(
    CRegistryConfig* pRegConfig,
    REGCONFIGMAP* pConfigMap
    )
{
    if (pRegConfig->isValid())
    {
        REGCONFIGMAP* temp = m_lastConfigMap;

        {
            PassportGuard<PassportLock> g(m_lock);

            if (m_rlastDefault)
                m_rlastDefault->Release();
            m_rlastDefault = m_rDefault;
            m_rDefault = pRegConfig;

            //
            //  Shuffle config map pointers.
            //

            m_lastConfigMap = m_ConfigMap;
            m_ConfigMap = pConfigMap;
        }

        //
        //  Delete the old site map.
        //

        if(temp)
        {
            REGCONFIGMAP::iterator it;
            while((it = temp->begin()) != temp->end())
            {
                free(it->first);
                it->second->Release();
                temp->erase(it);
            }

            delete temp;
        }

        if (g_pAlert)
            g_pAlert->report(PassportAlertInterface::INFORMATION_TYPE, PM_VALID_CONFIGURATION);
    }
    else
    {
        if (g_pAlert)
            g_pAlert->report(PassportAlertInterface::ERROR_TYPE, PM_INVALID_CONFIGURATION,
        pRegConfig->getFailureString());
        pRegConfig->Release();

        if(pConfigMap)
        {
            REGCONFIGMAP::iterator it;
            while((it = pConfigMap->begin()) != pConfigMap->end())
            {
                free(it->first);
                it->second->Release();
                pConfigMap->erase(it);
            }

            delete pConfigMap;
        }
    }

    return TRUE;
}


BOOL CPassportConfiguration::TakeNexusSnapshot(
    CNexusConfig**  ppNexusConfig,
    BOOL            bForceFetch
    )
{
    BOOL                    bReturn;
    CNexusConfig*           pNexusConfig = NULL;
    CComPtr<IXMLDocument>   pXMLDoc;

    *ppNexusConfig = NULL;

    if (GetCCD(_T(PRCONFIG),&pXMLDoc, bForceFetch))
    {
        pNexusConfig = new CNexusConfig();
        if(!pNexusConfig)
        {
            bReturn = FALSE;
            goto Cleanup;
        }

        pNexusConfig->Read(pXMLDoc);
        pNexusConfig->AddRef();
    }
    else
    {
        if (g_pAlert)
        {
            if (g_pAlert)
                g_pAlert->report(PassportAlertInterface::ERROR_TYPE, PM_CCD_NOT_LOADED, 0);
        }
        m_lastAttempt = time(NULL);
        bReturn = FALSE;
        goto Cleanup;
    }

    *ppNexusConfig = pNexusConfig;
    bReturn = TRUE;

Cleanup:

    if(pNexusConfig && bReturn == FALSE)
        delete pNexusConfig;

    return bReturn;

}


BOOL CPassportConfiguration::ApplyNexusSnapshot(
    CNexusConfig*   pNexusConfig
    )
{
    BOOL bReturn;

    if (pNexusConfig->isValid())
    {
        PassportGuard<PassportLock> g(m_lock);

        if (m_nlast)
            m_nlast->Release();
        m_nlast = m_n;
        m_n = pNexusConfig;
        if (g_pAlert)
            g_pAlert->report(PassportAlertInterface::INFORMATION_TYPE, PM_CCD_LOADED);
    }
    else
    {
        // NexusConfig throws an alert already
        bReturn = FALSE;
        goto Cleanup;
    }

    bReturn = TRUE;

Cleanup:

    return bReturn;
}


// Update both configs
BOOL CPassportConfiguration::UpdateNow(BOOL forceFetch)
{
    BOOL                    bReturn;
    time_t                  now;
    CComPtr<IXMLDocument>   is;
    time(&now);

    if(m_bUpdateInProgress)
    {
        bReturn = FALSE;
        goto Cleanup;
    }

    if (now - m_lastAttempt < 60 && m_n == NULL)
    {
        // Don't overload on attempts to the nexus
        bReturn = FALSE;
        goto Cleanup;
    }

    // Registry
    LocalConfigurationUpdated();
    if (m_rDefault == NULL)
    {
        m_lastAttempt = now - 30;
        bReturn = FALSE;
        goto Cleanup;
    }

    if (GetCCD(_T(PRCONFIG),&is, forceFetch))
    {
        NexusConfigUpdated(is);
    }
    else
    {
        if (g_pAlert)
        {
            if (g_pAlert)
                g_pAlert->report(PassportAlertInterface::ERROR_TYPE, PM_CCD_NOT_LOADED, 0);
        }
        m_lastAttempt = now;
        bReturn = FALSE;
        goto Cleanup;
    }
    if (!m_n)
    {
        m_lastAttempt = now;
        bReturn = FALSE;
        goto Cleanup;
    }
    m_lastAttempt = 0;
    bReturn = TRUE;

Cleanup:

    return bReturn;
}

BOOL CPassportConfiguration::PrepareUpdate(BOOL forceFetch)
{
    BOOL                    bReturn;

    static PassportLock prepareLock;
    PassportGuard<PassportLock> g(prepareLock);

    //  Don't allow another first phase while second phase
    //  is pending.
    if(m_bUpdateInProgress)
    {
        bReturn = FALSE;
        goto Cleanup;
    }

    //  Get the current registry config.
    TakeRegistrySnapshot(&m_rPending, &m_ConfigMapPending);

    //  Get the latest xml
    TakeNexusSnapshot(&m_nPending, forceFetch);

    m_bUpdateInProgress = true;
    bReturn = TRUE;

Cleanup:

    return bReturn;
}

BOOL CPassportConfiguration::CommitUpdate()
{
    BOOL bReturn;

    // Update default registry and any sites
    if(!ApplyRegistrySnapshot(m_rPending, m_ConfigMapPending))
    {
        bReturn = FALSE;
        goto Cleanup;
    }

    if(!ApplyNexusSnapshot(m_nPending))
    {
        bReturn = FALSE;
        goto Cleanup;
    }

    m_rPending = NULL;
    m_ConfigMapPending = NULL;
    m_nPending = NULL;

    bReturn = TRUE;

Cleanup:

    m_bUpdateInProgress = false;

    return bReturn;    
}

void CPassportConfiguration::LocalConfigurationUpdated()
{
    //
    //  Read in default config.
    //

    CRegistryConfig* pNewRegConfig;
    REGCONFIGMAP* pNewConfigMap;

    if(!TakeRegistrySnapshot(&pNewRegConfig, &pNewConfigMap))
        return;

    //
    //  Here we don't care about the results of reading in non-default sites.  pNewConfigMap will be NULL
    //  if anything bad happened and events will be in the event log.  As long as we have a valid 
    //  default configuration we can go ahead and do the switch.
    //

    ApplyRegistrySnapshot(pNewRegConfig, pNewConfigMap);

}

void CPassportConfiguration::NexusConfigUpdated(IXMLDocument *is)
{
    CNexusConfig *newc = new CNexusConfig();
    newc->AddRef();
    newc->Read(is);

    ApplyNexusSnapshot(newc);
}

LPWSTR CPassportConfiguration::getFailureString()
{
  // IsValid must be called before this
  if (!m_rDefault)
    return L"Registry configuration failed.";
  if (!m_rDefault->isValid())
    return m_rDefault->getFailureString();
  if (!m_n)
    return L"Nexus configuration failed.";
  if (!m_n->isValid())
    return m_n->getFailureString();
  return L"OK";
}

BOOL
CPassportConfiguration::HasSites()
{
    return (m_ConfigMap && m_ConfigMap->size());
}

void
CPassportConfiguration::Dump(BSTR* pbstrDump)
{
    //m_rDefault->Dump(pbstrDump);
    //m_ConfigMap->Dump(pbstrDump);
    m_n->Dump(pbstrDump);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\passportmanager\nexusconfig.cpp ===
// NexusConfig.cpp: implementation of the CNexusConfig class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "NexusConfig.h"
#include "PassportGuard.hpp"

PassportLock    CNexusConfig::m_ReadLock;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

// turn a char into it's hex value
#define XTOI(x) (isalpha(x) ? (toupper(x)-'A'+10) : (x - '0'))

CNexusConfig::CNexusConfig() :
  m_defaultProfileSchema(NULL), m_defaultTicketSchema(NULL), 
  m_valid(FALSE), m_szReason(NULL), m_refs(0)
{
}

CNexusConfig::~CNexusConfig()
{
   // profile schemata
    if (!m_profileSchemata.empty())
    {
        BSTR2PS::iterator ita = m_profileSchemata.begin();
        for (; ita != m_profileSchemata.end(); ita++)
        {
            FREE_BSTR(ita->first);
            ita->second->Release();
        }
        m_profileSchemata.clear();
    }

    // ticket schemata
    if (!m_ticketSchemata.empty())
    {
        BSTR2TS::iterator ita = m_ticketSchemata.begin();
        for (; ita != m_ticketSchemata.end(); ita++)
        {
            FREE_BSTR(ita->first);
            ita->second->Release();
        }
        m_ticketSchemata.clear();
    }

    // 
    if (!m_domainAttributes.empty())
    {
        BSTR2DA::iterator itc = m_domainAttributes.begin();
        for (; itc != m_domainAttributes.end(); itc++)
        {
            FREE_BSTR(itc->first);
            if (!itc->second->empty())
            {
                // Now we're deleting ATTRVALs
                ATTRMAP::iterator itd = itc->second->begin();
                for (; itd != itc->second->end(); itd++)
                {
                    ATTRVAL* pAttrVal = itd->second;

                    if(pAttrVal->bDoLCIDReplace)
                    {
                        FREE_BSTR(pAttrVal->bstrAttrVal);
                    }
                    else
                    {
                        LCID2ATTR::iterator ite = pAttrVal->pLCIDAttrMap->begin();
                        for (;ite != pAttrVal->pLCIDAttrMap->end(); ite++)
                        {
                            FREE_BSTR(ite->second);
                        }

                        delete pAttrVal->pLCIDAttrMap;
                    }
                    FREE_BSTR(itd->first);
                    delete itd->second;
                }
            }
            delete itc->second;
        }
        m_domainAttributes.clear();
    }
    if (m_szReason)
        FREE_BSTR(m_szReason);
}

BSTR CNexusConfig::getFailureString()
{
  if (m_valid)
    return NULL;
  return m_szReason;
}

void CNexusConfig::setReason(LPTSTR reason)
{
  if (m_szReason)
    FREE_BSTR(m_szReason);
  m_szReason = ALLOC_BSTR(reason);
}

CNexusConfig* CNexusConfig::AddRef()
{
  InterlockedIncrement(&m_refs);
  return this;
}

void CNexusConfig::Release()
{
  long refs = InterlockedDecrement(&m_refs);
  if (refs == 0)
    delete this;
}

BOOL CNexusConfig::Read(IXMLDocument* s)
{
    //BUGBUG  Put this here because having two threads in Read at the same
    //        time is almost guaranteed to cause STL maps to hurl (heap
    //        corruption, pointer nastiness, etc.  Long term solution
    //        is to move these to LKRHash tables as well.

    PassportGuard<PassportLock> readGuard(m_ReadLock);

    MSXML::IXMLDocumentPtr pDoc;
    MSXML::IXMLElementCollectionPtr pElts, pSchemas, pDomains, pAtts;
    MSXML::IXMLElementPtr pElt, pDom, pAtt;
    VARIANT iTopLevel, iSubNodes, iAtts;
    _bstr_t name(L"Name"), suffix(L"DomainSuffix"), lcidatt(L"lcid"), version(L"Version");
    LONG    cTLN, cSN, cAtts;

    try
    {
        pDoc = s;

        pElts = pDoc->root->children;
        m_bstrVersion = pDoc->root->getAttribute(version);

        VariantInit(&iTopLevel);
        iTopLevel.vt = VT_I4;
        cTLN = pElts->length;

        for (iTopLevel.lVal=0; iTopLevel.lVal < cTLN; iTopLevel.lVal++)
        {
            pElt = pElts->item(&iTopLevel);
            _bstr_t& tagName = pElt->tagName;
            if (!_wcsicmp(tagName,FOLDER_TICKET_SCHEMATA))
            {
                VariantInit(&iSubNodes);
                iSubNodes.vt = VT_I4;
                pSchemas = pElt->children;
                cSN = pSchemas->length;
                for (iSubNodes.lVal=0;iSubNodes.lVal < cSN;iSubNodes.lVal++)
                {
                    pElt = pSchemas->item(&iSubNodes);
                    // Read a schema

                    // BUGBUG probably more efficient ways to handle this variant->BSTR issue
                    BSTR schemaName = NULL;
                    _bstr_t tmp = pElt->getAttribute(name);
                    if (tmp.length() > 0) schemaName = ALLOC_BSTR(tmp);

                    CTicketSchema *pSchema = new CTicketSchema();
                    pSchema->AddRef();
                    if (schemaName && pSchema)
                    {
                        BSTR2TS::value_type pMapVal(schemaName,pSchema);
                        pSchema->ReadSchema(pElt);
                        if (!_wcsicmp(schemaName,L"CORE"))
                            m_defaultTicketSchema = pSchema;
                        m_ticketSchemata.insert(pMapVal);
                    }
                    else
                    {
                        if (schemaName)
                            FREE_BSTR(schemaName);
                        if (pSchema)
                            pSchema->Release();
                    }
                }

            }
            else if (!_wcsicmp(tagName,FOLDER_PROFILE_SCHEMATA))
            {
                VariantInit(&iSubNodes);
                iSubNodes.vt = VT_I4;
                pSchemas = pElt->children;
                cSN = pSchemas->length;
                for (iSubNodes.lVal=0;iSubNodes.lVal < cSN;iSubNodes.lVal++)
                {
                    pElt = pSchemas->item(&iSubNodes);
                    // Read a schema

                    // BUGBUG probably more efficient ways to handle this variant->BSTR issue
                    BSTR schemaName = NULL;
                    _bstr_t tmp = pElt->getAttribute(name);
                    if (tmp.length() > 0) schemaName = ALLOC_BSTR(tmp);

                    CProfileSchema *pSchema = new CProfileSchema();
                    pSchema->AddRef();
                    if (schemaName && pSchema)
                    {
                        BSTR2PS::value_type pMapVal(schemaName,pSchema);
                        pSchema->Read(pElt);
                        if (!_wcsicmp(schemaName,L"CORE"))
                            m_defaultProfileSchema = pSchema;
                        m_profileSchemata.insert(pMapVal);
                    }
                    else
                    {
                        if (schemaName)
                            FREE_BSTR(schemaName);
                        if (pSchema)
                            pSchema->Release();
                    }
                }
            }
            else if (!_wcsicmp(tagName,FOLDER_PASSPORT_NETWORK))
            {
                // individual domain attributes
                pElt = pElts->item(&iTopLevel);
                VariantInit(&iSubNodes);
                iSubNodes.vt = VT_I4;
                pDomains = pElt->children;
                cSN = pDomains->length;
                VariantInit(&iAtts);
                iAtts.vt = VT_I4;

                for (iSubNodes.lVal=0;iSubNodes.lVal < cSN;iSubNodes.lVal++)
                {
                    pDom = pDomains->item(&iSubNodes);
                    BSTR dname = NULL;
                    _bstr_t rawdn = pDom->getAttribute(suffix);
                    dname = ALLOC_BSTR(rawdn);

                    if (!dname) continue;

                    pAtts = pDom->children;
                    cAtts = pAtts->length;

                    // Add new hash table for this domain
                    ATTRMAP *newsite = new ATTRMAP;
                    BSTR2DA::value_type pNewSite(dname, newsite);
                    m_domainAttributes.insert(pNewSite);

                    for (iAtts.lVal = 0; iAtts.lVal < cAtts; iAtts.lVal++)
                    {
                        BSTR attribute = NULL, value = NULL;
                        pAtt = pAtts->item(&iAtts);
                        _bstr_t lcid = pAtt->getAttribute(lcidatt);
                        bool bIsReplaceLcid = (_wcsicmp(lcid, L"lang_replace") == 0);
                        pAtt->get_tagName(&attribute);
                        pAtt->get_text(&value);
                        TAKEOVER_BSTR(attribute);
                        TAKEOVER_BSTR(value);
                        if (attribute && value)
                        {
                            // Find or add the lcid->value map for this attr
                            ATTRMAP::const_iterator lcit = newsite->find(attribute);
                            ATTRVAL* attrval;
                            if (lcit == newsite->end())
                            {
                                attrval = new ATTRVAL;
                                if(attrval != NULL)
                                {
                                    attrval->bDoLCIDReplace = bIsReplaceLcid;
                                    if(!bIsReplaceLcid)
                                        attrval->pLCIDAttrMap = new LCID2ATTR;
                                    else
                                        attrval->bstrAttrVal = value;

                                    ATTRMAP::value_type pAtt(attribute,attrval);
                                    newsite->insert(pAtt);
                                }
                            }
                            else
                            {
                                FREE_BSTR(attribute);
                                attrval = lcit->second;
                            }
                            short iLcid = 0;
                            if(!bIsReplaceLcid)
                            {
                                if (lcid.length() == 4)
                                {
                                    LPWSTR szlcid = lcid;
                                    if (iswxdigit(szlcid[0]) && iswxdigit(szlcid[1]) &&
                                        iswxdigit(szlcid[2]) && iswxdigit(szlcid[3]))
                                    {
                                        iLcid = 
                                            (XTOI(szlcid[0]) << 12) +
                                            (XTOI(szlcid[1]) << 8) +
                                            (XTOI(szlcid[2]) << 4) +
                                            (XTOI(szlcid[3]) << 0);
                                    }
                                    else
                                    {
                                        if (g_pAlert)
                                            g_pAlert->report(PassportAlertInterface::ERROR_TYPE,
                                                             PM_LCID_ERROR, lcid);
                                    }
                                }
                                else if (lcid.length() == 2)
                                {
                                    LPWSTR szlcid = lcid;
                                    if (iswxdigit(szlcid[0]) && iswxdigit(szlcid[1]))
                                    {
                                        iLcid = 
                                            (XTOI(szlcid[0]) << 12) +
                                            (XTOI(szlcid[1]) << 8);
                                    }
                                    else
                                    {
                                        if (g_pAlert)
                                            g_pAlert->report(PassportAlertInterface::ERROR_TYPE,
                                                             PM_LCID_ERROR, lcid);
                                    }
                                }
                                else if (lcid.length() > 0)
                                {
                                    if (g_pAlert)
                                        g_pAlert->report(PassportAlertInterface::ERROR_TYPE,
                                                         PM_LCID_ERROR, lcid);
                                }
                                LCID2ATTR::value_type lcAtt(iLcid,value);
                                if (attrval && attrval->pLCIDAttrMap)
                                    attrval->pLCIDAttrMap->insert(lcAtt);
                                else
                                    delete value;
                            }
                            else
                            {
                            }
                        }
                        else
                        {
                            if (attribute) FREE_BSTR(attribute);
                            if (value) FREE_BSTR(value);
                        }
                    }
                }
            }
        }
    }
    catch (_com_error &e)
    {
        _bstr_t r = e.Description();
        return FALSE;
    }
    m_valid = TRUE;
    return TRUE;

}

bool CNexusConfig::DomainExists(LPCWSTR domain)
{
    BSTR2DA::const_iterator it = m_domainAttributes.find(_bstr_t(domain));
    return (it == m_domainAttributes.end() ? false : true);
}


void CNexusConfig::getDomainAttribute(
    LPCWSTR domain,    // in
    LPCWSTR attr,      // in
    DWORD valuebuflen, // in (chars, not bytes!)
    LPWSTR valuebuf,   // out
    USHORT lcid        // in
    )
{
    BSTR2DA::const_iterator it;
    ATTRMAP::const_iterator daiter;
    ATTRVAL* pAttrVal;

    if(valuebuf == NULL)
        goto Cleanup;

    *valuebuf = L'\0';

    it = m_domainAttributes.find(_bstr_t(domain));
    if (it == m_domainAttributes.end())
    {
        // Not found
        goto Cleanup;
    }

    daiter = (*it).second->find(_bstr_t(attr));
    if (daiter == it->second->end())
    {
        // Not found
        goto Cleanup;
    }

    pAttrVal = daiter->second;
    if(pAttrVal->bDoLCIDReplace)
    {
        LPWSTR szSrc = pAttrVal->bstrAttrVal;
        LPWSTR szDst = valuebuf;
        DWORD  dwLenRemaining = valuebuflen;

        while(*szSrc != L'\0' && dwLenRemaining != 0)
        {
            if(*szSrc == L'%')
            {
                szSrc++;

                switch((WCHAR)CharUpperW((LPWSTR)(*szSrc)))
                {
                case L'L':
                    {
                        WCHAR szLCID[8];

                        _ultow(lcid, szLCID, 10);

                        int nLength = lstrlenW(szLCID);

                        for(int nIndex = 0; 
                            nIndex < nLength && dwLenRemaining != 0; 
                            nIndex++)
                        {
                            *(szDst++) = szLCID[nIndex];
                            --dwLenRemaining;
                        }

                        szSrc++;
                    }
                    break;

                case L'C':
                    {
                        WCHAR szCharCode[3];

                        //
                        //  TODO Insert code here to lookup char code
                        //  based on lcid.
                        //

                        lstrcpyW(szCharCode, L"EN");

                        *(szDst++) = szCharCode[0];
                        --dwLenRemaining;

                        if(dwLenRemaining != 0)
                        {
                            *(szDst++) = szCharCode[1];
                            --dwLenRemaining;
                        }

                        szSrc++;
                    }
                    break;

                default:

                    *(szDst++) = L'%';
                    --dwLenRemaining;

                    if(dwLenRemaining != 0)
                    {
                        *(szDst++) = *(szSrc++);
                        --dwLenRemaining;
                    }

                    break;
                }
            }
            else
            {
                *(szDst++) = *(szSrc++);
                dwLenRemaining--;
            }
        }

        if(dwLenRemaining != 0)
            *szDst = L'\0';
        else
            valuebuf[valuebuflen - 1] = L'\0';
    }
    else
    {
        LCID2ATTR* pLcidMap = pAttrVal->pLCIDAttrMap;
        LCID2ATTR::const_iterator lciter = pLcidMap->find(lcid);
        if (lciter == pLcidMap->end())
        {
            // Not found
            if (lcid != 0)
            {
                lciter = pLcidMap->find(lcid >> 8);
                if (lciter == pLcidMap->end())
                {
                    lciter = pLcidMap->find(0);
                    if (lciter == pLcidMap->end())
                        goto Cleanup;
                }
            }
            else
                goto Cleanup;
        }

        lstrcpynW(valuebuf, (*lciter).second, valuebuflen);
    }

Cleanup:

    return;
}

CProfileSchema* CNexusConfig::getProfileSchema(BSTR schemaName)
{
  if (schemaName == NULL)
    return m_defaultProfileSchema;

  BSTR2PS::const_iterator it = m_profileSchemata.find(schemaName);
  if (it == m_profileSchemata.end())
    return NULL;
  else
    return (*it).second;
}

CTicketSchema* CNexusConfig::getTicketSchema(BSTR schemaName)
{
  if (schemaName == NULL)
    return m_defaultTicketSchema;

  BSTR2TS::const_iterator it = m_ticketSchemata.find(schemaName);
  if (it == m_ticketSchemata.end())
    return NULL;
  else
    return (*it).second;
}

LPCWSTR* CNexusConfig::getDomains(int *numDomains)
{
  int i;

  if (!numDomains) return NULL;

  *numDomains = m_domainAttributes.size();

  if (*numDomains == 0)
    return NULL;

  LPCWSTR* retVal = new LPCWSTR[*numDomains];

  if (!retVal) return NULL;

  BSTR2DA::const_iterator itc = m_domainAttributes.begin();
  for (i = 0; itc != m_domainAttributes.end(); itc++, i++)
    {
      retVal[i] = itc->first;
    }
  return retVal;
}

BSTR CNexusConfig::GetXMLInfo()
{
    return m_bstrVersion;
}


void CNexusConfig::Dump(BSTR* pbstrDump)
{
    if(pbstrDump == NULL)
        return;

    *pbstrDump = NULL;

    CComBSTR bstrDump;

    BSTR2DA::const_iterator domainIterator;
    for(domainIterator = m_domainAttributes.begin(); 
        domainIterator != m_domainAttributes.end();
        domainIterator++)
    {
        ATTRMAP* pAttrMap = domainIterator->second;

        bstrDump += L"Domain: ";
        bstrDump += domainIterator->first;
        bstrDump += L"<BR><BR>";

        ATTRMAP::const_iterator attrIterator;

        for(attrIterator = pAttrMap->begin();
            attrIterator != pAttrMap->end();
            attrIterator++)
        {
            bstrDump += L"Attribute: ";
            bstrDump += attrIterator->first;
            bstrDump += L"<BR><BR>";

            ATTRVAL* pAttrVal = attrIterator->second;
            if(pAttrVal->bDoLCIDReplace)
            {
                bstrDump += L"LCID = lang_replace  Value = ";
                bstrDump += pAttrVal->bstrAttrVal;
                bstrDump += L"<BR>";
            }
            else
            {
                LCID2ATTR* pLCIDMap = pAttrVal->pLCIDAttrMap;

                LCID2ATTR::const_iterator lcidIterator;

                for(lcidIterator = pLCIDMap->begin();
                    lcidIterator != pLCIDMap->end();
                    lcidIterator++)
                {
                    WCHAR szBuf[32];

                    bstrDump += L"LCID = ";
                    bstrDump += _itow(lcidIterator->first, szBuf, 10);
                    bstrDump += L"  Value = ";
                    bstrDump += lcidIterator->second;
                    bstrDump += L"<BR>";
                }

                bstrDump += L"<BR>";
            }
        }

        bstrDump += L"<BR>";
    }

    *pbstrDump = bstrDump.Detach();
}

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\passportmanager\nexusconfig.h ===
// NexusConfig.h: interface for the CNexusConfig class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_NEXUSCONFIG_H__74EB2516_E239_11D2_95E9_00C04F8E7A70__INCLUDED_)
#define AFX_NEXUSCONFIG_H__74EB2516_E239_11D2_95E9_00C04F8E7A70__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "BstrHash.h"
#include "CoCrypt.h"
#include "ProfileSchema.h"  // also imports msxml
#include "TicketSchema.h"  // also imports msxml
#include "PassportLock.hpp"
#include "ptstl.h"

//
// TOP FOLDER NAMES in PARTNER.XML
//
// folder for profile schemata
#define	FOLDER_PROFILE_SCHEMATA		L"SCHEMATA"
// folder for ticket schemas
#define	FOLDER_TICKET_SCHEMATA		L"TICKETSCHEMATA"
// folder for passport network
#define	FOLDER_PASSPORT_NETWORK		L"PASSPORTNETWORK"
//

// 

typedef PtStlMap<USHORT,BSTR > LCID2ATTR;

// if bDoLCIDReplace is true, bstrAttrVal will have the attribute value
// with replacement parameters.
// if bDoLCIDReplace is false, pLCIDAttrMap will point to a map of values
// indexed by lcid.
typedef struct
{
    bool        bDoLCIDReplace;
    
    union
    {
        LCID2ATTR*  pLCIDAttrMap;
        BSTR        bstrAttrVal;
    };
}
ATTRVAL;

typedef PtStlMap<BSTR,CProfileSchema*,RawBstrLT> BSTR2PS;
typedef PtStlMap<BSTR,CTicketSchema*,RawBstrLT> BSTR2TS;
typedef PtStlMap<BSTR,ATTRVAL*,RawBstrLT> ATTRMAP;
typedef PtStlMap<BSTR,ATTRMAP*,RawBstrLT> BSTR2DA;

class CNexusConfig
{
public:
    CNexusConfig();
    virtual ~CNexusConfig();

    BSTR                GetXMLInfo();

    // Get a profile schema by name, or the default if null is passed
    CProfileSchema*     getProfileSchema(BSTR schemaName = NULL);
    // Get a ticket schema by name, or the default if null is passed
    CTicketSchema*      getTicketSchema(BSTR schemaName = NULL);

    // Return a description of the failure
    BSTR                getFailureString();
    BOOL                isValid() { return m_valid; }

    // 0 is "default language", ie the entry w/o an LCID.  This does NOT do
    // the registry fallback, etc.
    void                getDomainAttribute(LPCWSTR  domain, 
                                           LPCWSTR  attr, 
                                           DWORD    valuebuflen, 
                                           LPWSTR   valuebuf, 
                                           USHORT   lcid = 0);

    // Get the domain list.  You should delete[] the pointer you receive
    LPCWSTR*            getDomains(int *numDomains);

    // Is the domain name passed in a valid domain authority?
    bool                DomainExists(LPCWSTR domain);

    CNexusConfig*       AddRef();
    void                Release();

    BOOL                Read(IXMLDocument* is);

    void                Dump(BSTR* pbstrDump);

protected:
    void                setReason(LPWSTR reason);

    // profile schemata 
    BSTR2PS             m_profileSchemata;
    CProfileSchema*     m_defaultProfileSchema;

    // ticket schemata
    BSTR2TS             m_ticketSchemata;
    CTicketSchema*      m_defaultTicketSchema;

    // 
    BSTR2DA             m_domainAttributes;

    BOOL                m_valid;

    BSTR                m_szReason;

    long                m_refs;

    static PassportLock m_ReadLock;

private:
    _bstr_t m_bstrVersion;
};

#endif // !defined(AFX_NEXUSCONFIG_H__74EB2516_E239_11D2_95E9_00C04F8E7A70__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\passportmanager\passportfactory.cpp ===
// PassportFactory.cpp : Implementation of CPassportFactory
#include "stdafx.h"
#include "PassportFactory.h"

/////////////////////////////////////////////////////////////////////////////
// CPassportFactory

STDMETHODIMP CPassportFactory::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IPassportFactory,
	};
	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}


STDMETHODIMP CPassportFactory::CreatePassportManager(
    IDispatch** ppDispPassportManager
    )
{
//JVP - begin changes 
#ifdef PASSPORT_VERBOSE_MODE_ON
	g_pTSLogger->AddDateTimeAndLog("CPassportFactory::CreatePassportManager, Enter");
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes 

    HRESULT   hr;
#if 0
    CComObjectPooled<CManager>* pManager;
#endif

    if(ppDispPassportManager == NULL)
    {
//JVP - begin changes 
#ifdef PASSPORT_VERBOSE_MODE_ON
	g_pTSLogger->AddDateTimeAndLog("CPassportFactory::CreatePassportManager, E_INVALIDARG");
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes 
      hr = E_INVALIDARG;
      goto Cleanup;
    }

#if 0
	ATLTRY(pManager = g_Pool.checkout())
	if (pManager != NULL)
	{
        pManager->SetPool(&g_Pool);
		pManager->SetVoid(NULL);
		pManager->InternalFinalConstructAddRef();
		hr = pManager->FinalConstruct();
		pManager->InternalFinalConstructRelease();
		if (hr != S_OK)
		{
		    g_Pool.checkin(pManager);
			pManager = NULL;
            goto Cleanup;
		}
	}

    hr = pManager->QueryInterface(IID_IDispatch, (void**)ppDispPassportManager);
#endif 

    hr = CoCreateInstance(__uuidof(Manager), NULL, CLSCTX_INPROC_SERVER, __uuidof(IDispatch), (void**)ppDispPassportManager);

Cleanup:

//JVP - begin changes 
#ifdef PASSPORT_VERBOSE_MODE_ON
	char szLogString[LOG_STRING_LEN] = "CPassportFactory::CreatePassportManager, Exit";
	AddLongAsString(hr, szLogString, sizeof(szLogString));
	g_pTSLogger->AddDateTimeAndLog(szLogString);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes 

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\passportmanager\passportcrypt.h ===
// PassportCrypt.h : Declaration of the CCrypt

#ifndef __CRYPT_H_
#define __CRYPT_H_

#include "resource.h"       // main symbols
#include <asptlb.h>         // Active Server Pages Definitions
#include "CoCrypt.h"	// Added by ClassView
#include "passportservice.h"

/////////////////////////////////////////////////////////////////////////////
// CCrypt
class ATL_NO_VTABLE CCrypt : 
  public CComObjectRootEx<CComMultiThreadModel>,
  public CComCoClass<CCrypt, &CLSID_Crypt>,
  public ISupportErrorInfo,
  public IPassportService,
  public IDispatchImpl<IPassportCrypt, &IID_IPassportCrypt, &LIBID_PASSPORTLib>
{
public:
  CCrypt();
  ~CCrypt()
  {
    Cleanup();

    if( m_crypt )
      delete m_crypt;
  }

public:
  
DECLARE_REGISTRY_RESOURCEID(IDR_CRYPT)
    
DECLARE_PROTECT_FINAL_CONSTRUCT()
DECLARE_GET_CONTROLLING_UNKNOWN()

BEGIN_COM_MAP(CCrypt)
  COM_INTERFACE_ENTRY(IPassportCrypt)
  COM_INTERFACE_ENTRY(IDispatch)
  COM_INTERFACE_ENTRY(ISupportErrorInfo)
  COM_INTERFACE_ENTRY(IPassportService)
  COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

HRESULT FinalConstruct()
{
    return CoCreateFreeThreadedMarshaler(
        GetControllingUnknown(), &m_pUnkMarshaler.p);
}

void FinalRelease()
{
    m_pUnkMarshaler.Release();
}

CComPtr<IUnknown> m_pUnkMarshaler;

// ISupportsErrorInfo
  STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IPassportCrypt
public:
  STDMETHOD(put_keyMaterial)(/*[in]*/ BSTR newVal);
  STDMETHOD(get_keyVersion)(/*[out, retval]*/ int *pVal);
  STDMETHOD(put_keyVersion)(/*[in]*/ int newVal);

  STDMETHOD(OnStartPage)(/*[in]*/ IUnknown* piUnk);
  STDMETHOD(Decrypt)(/*[in]*/ BSTR rawData, /*[out,retval]*/ BSTR *pUnencrypted);
  STDMETHOD(Encrypt)(/*[in]*/ BSTR rawData, /*[out,retval]*/ BSTR *pEncrypted);
  STDMETHOD(get_IsValid)(/*[out,retval]*/VARIANT_BOOL *pVal);
  STDMETHOD(Compress)(/*[in]*/ BSTR bstrIn, /*[out,retval]*/ BSTR *pbstrOut);
  STDMETHOD(Decompress)(/*[in]*/ BSTR bstrIn, /*[out,retval]*/ BSTR *pbstrOut);
  STDMETHOD(put_site)(/*[in]*/ BSTR bstrSiteName);
  STDMETHOD(put_host)(/*[in]*/ BSTR bstrHostName);
  
// IPassportService
public:
	STDMETHOD(Initialize)(BSTR, IServiceProvider*);
	STDMETHOD(Shutdown)();
	STDMETHOD(ReloadState)(IServiceProvider*);
	STDMETHOD(CommitState)(IServiceProvider*);
	STDMETHOD(DumpState)( BSTR* );

protected:
  void              Cleanup();
  CRegistryConfig*  ObtainCRC();

  int       m_keyVersion;
  time_t    m_validUntil;
  CCoCrypt* m_crypt;
  LPSTR     m_szSiteName;
  LPSTR     m_szHostName;
};

#endif //__CRYPT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\passportmanager\passportcrypt.cpp ===
// PassportCrypt.cpp : Implementation of CCrypt
#include "stdafx.h"
#include "Passport.h"
#include "PassportCrypt.h"
#include <time.h>

// max blocks + 10 should be multiples of 3 for simplicity
#define ENC_MAX_SIZE  2045
// I don't trust the compiler... (((2045+10)*4)/3)+9 = 2749 * sizeof(wchar)
#define DEC_MAX_SIZE  5498


CCrypt::CCrypt() : m_crypt(NULL), m_szSiteName(NULL), m_szHostName(NULL)
{
    m_pUnkMarshaler = NULL;
    m_keyVersion = 0;

    CRegistryConfig* crc = g_config->checkoutRegistryConfig();
    if( crc )
    {
        m_keyVersion = crc->getCurrentCryptVersion();
        crc->getCrypt(m_keyVersion, &m_validUntil);
        crc->Release();
    }
}


/////////////////////////////////////////////////////////////////////////////
// CCrypt

STDMETHODIMP CCrypt::InterfaceSupportsErrorInfo(REFIID riid)
{
  static const IID* arr[] = 
  {
    &IID_IPassportCrypt,
  };
  for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
    {
      if (InlineIsEqualGUID(*arr[i],riid))
	return S_OK;
    }
  return S_FALSE;
}


STDMETHODIMP CCrypt::OnStartPage(IUnknown* piUnk) 
{
    BOOL                    bHasPort;
    DWORD                   dwServerNameLen;
    HRESULT                 hr = S_OK;
    BOOL                    bVariantInited = FALSE;

    // param needs to cleanup
    IRequestPtr             piRequest ;
    IRequestDictionaryPtr   piServerVariables ;
    _variant_t              vtItemName;
    _variant_t              vtServerName;
    _variant_t              vtServerPort;
    _variant_t              vtHTTPS;
    WCHAR*                  szServerName = NULL; 
    CHAR*                   szServerName_A = NULL; 
    CRegistryConfig*        crc =  NULL;


    if(!piUnk)
    {
        hr = E_POINTER;
        goto exit;
    }

    if (!g_config->isValid()) // Guarantees config is non-null
    {
        AtlReportError(CLSID_Manager, PP_E_NOT_CONFIGUREDSTR,
                       IID_IPassportManager, PP_E_NOT_CONFIGURED);
        hr = PP_E_NOT_CONFIGURED;
    }

    try
    {

        // Get Request Object Pointer
        piRequest = ((IScriptingContextPtr)piUnk)->Request;

        //
        //  Use the request object to get the server name being requested
        //  so we can get the correct registry config.  But only do this
        //  if we have some configured sites.
        //

        if(g_config->HasSites())
        {
            piRequest->get_ServerVariables(&piServerVariables);

            vtItemName.vt = VT_BSTR;
            vtItemName.bstrVal = SysAllocString(L"SERVER_NAME");

            piServerVariables->get_Item(vtItemName, &vtServerName);
            if(vtServerName.vt != VT_BSTR)
            VariantChangeType(&vtServerName, &vtServerName, 0, VT_BSTR);

            VariantClear(&vtItemName);

            vtItemName.vt = VT_BSTR;
            vtItemName.bstrVal = SysAllocString(L"SERVER_PORT");

            piServerVariables->get_Item(vtItemName, &vtServerPort);
            if(vtServerPort.vt != VT_BSTR)
            VariantChangeType(&vtServerPort, &vtServerPort, 0, VT_BSTR);

            VariantClear(&vtItemName);
            vtItemName.vt = VT_BSTR;
            vtItemName.bstrVal = SysAllocString(L"HTTPS");

            piServerVariables->get_Item(vtItemName, &vtHTTPS);
            if(vtHTTPS.vt != VT_BSTR)
            VariantChangeType(&vtHTTPS, &vtHTTPS, 0, VT_BSTR);

            //  If not default port, append ":port" to server name.
            bHasPort = (lstrcmpiW(L"off", vtHTTPS.bstrVal) == 0 && 
                        lstrcmpW(L"80", vtServerPort.bstrVal) != 0) || 
                        (lstrcmpiW(L"on", vtHTTPS.bstrVal) == 0 && 
                        lstrcmpW(L"443", vtServerPort.bstrVal) != 0); 
                        dwServerNameLen = bHasPort ?   
                        lstrlenW(vtServerName.bstrVal) + lstrlenW(vtServerPort.bstrVal) + 2 :
                        lstrlenW(vtServerName.bstrVal) + 1;

            if(bHasPort)
            {
                lstrcatW(szServerName, L":");
                lstrcatW(szServerName, vtServerPort.bstrVal);
            }

            m_szHostName = new CHAR[dwServerNameLen];
            if( !m_szHostName )
            {
                hr = E_OUTOFMEMORY;
                goto exit;
            }

            WideCharToMultiByte(CP_ACP, 0, vtServerName.bstrVal, -1,
                    m_szHostName, dwServerNameLen,
                    NULL,
                    NULL);

            crc = g_config->checkoutRegistryConfig(m_szHostName);
        }
        else
        {
            crc = g_config->checkoutRegistryConfig();
        }

        m_keyVersion = 0;
        if (crc)
        {
            m_keyVersion = crc->getCurrentCryptVersion();
            crc->getCrypt(m_keyVersion,&m_validUntil);
        }
    }
    catch(...)
    {
        hr = S_OK;
    }

exit:

    if( crc )
        crc->Release();

    return hr;
}

STDMETHODIMP CCrypt::Encrypt(BSTR rawData, BSTR *pEncrypted)
{
  if (!rawData)
    return E_INVALIDARG;

  if (SysStringLen(rawData) > ENC_MAX_SIZE)
    {
      AtlReportError(CLSID_Crypt, L"Passport.Crypt: Data too large", 
		     IID_IPassportCrypt, E_FAIL);
      return E_FAIL;
    }

  if (m_crypt)
    m_crypt->Encrypt(m_keyVersion, (LPSTR)rawData, SysStringByteLen(rawData), pEncrypted);
  else
    {
      CRegistryConfig* crc = ObtainCRC();
      if (!crc)
	{
	  AtlReportError(CLSID_Crypt, 
			 L"Passport misconfigured", IID_IPassportCrypt, E_FAIL);
	  return E_FAIL;
	}
      CCoCrypt *cr = crc->getCrypt(m_keyVersion,&m_validUntil);
      if (!cr)
	{
	  AtlReportError(CLSID_Crypt, 
			 L"No such key version", IID_IPassportCrypt, E_FAIL);
	  crc->Release();
	  return E_FAIL;
	}
      cr->Encrypt(m_keyVersion,(LPSTR)rawData,SysStringByteLen(rawData),pEncrypted);
      crc->Release();
    }
  return S_OK;
}

STDMETHODIMP CCrypt::Decrypt(BSTR rawData, BSTR *pUnencrypted)
{
  if (rawData == NULL)
    {
      *pUnencrypted = NULL;
      return S_OK;
    }

  if (SysStringLen(rawData) > DEC_MAX_SIZE)
    {
      AtlReportError(CLSID_Crypt, L"Passport.Crypt: Data too large", 
		     IID_IPassportCrypt, E_FAIL);
      return E_FAIL;
    }

  if (m_crypt) // Just do our job, no questions
  {
    if (m_crypt->Decrypt(rawData, SysStringByteLen(rawData), pUnencrypted))
    {
      return S_OK;
    }
    *pUnencrypted = NULL;
    return S_OK;
  }

  // First find the key version
  int kv = CCoCrypt::getKeyVersion(rawData);
  time_t vU, now;

  CRegistryConfig* crc = ObtainCRC();
  if (!crc)
    {
      AtlReportError(CLSID_Crypt, 
		     L"Passport misconfigured", IID_IPassportCrypt, E_FAIL);
      return E_FAIL;
    }
  CCoCrypt *cr = crc->getCrypt(kv, &vU);

  time(&now);

  if ((vU != 0 && now > vU) || cr == NULL)
    {
      *pUnencrypted = NULL;
      crc->Release();
      return S_OK;
    }

  if (cr->Decrypt(rawData, SysStringByteLen(rawData), pUnencrypted))
    {
      crc->Release();
      return S_OK;
    }
  crc->Release();
  *pUnencrypted = NULL;
  return S_OK;
}

STDMETHODIMP CCrypt::get_keyVersion(int *pVal)
{
  *pVal = m_keyVersion;
  return S_OK;
}

STDMETHODIMP CCrypt::put_keyVersion(int newVal)
{
  m_keyVersion = newVal;
  if (m_crypt)
    {
      delete m_crypt;
      m_crypt = NULL;
    }
  return S_OK;
}

STDMETHODIMP CCrypt::get_IsValid(VARIANT_BOOL *pVal)
{
// fix 6695	PassportCrypt.IsValid is inconsistent to end users.
// *pVal = (m_crypt != NULL) ? VARIANT_TRUE : VARIANT_FALSE;

  *pVal = (g_config->isValid()) ? VARIANT_TRUE : VARIANT_FALSE;
  return S_OK;
}

STDMETHODIMP CCrypt::put_keyMaterial(BSTR newVal)
{
  if (m_crypt)
    {
      delete m_crypt;
      m_crypt = NULL;
    }
  m_crypt = new CCoCrypt();
  m_crypt->setKeyMaterial(newVal);
  return S_OK;
}

STDMETHODIMP CCrypt::Compress(
    BSTR    bstrIn,
    BSTR*   pbstrCompressed
    )
{
    HRESULT hr;
    UINT    nInLen;

    //
    //  Check inputs.
    //

    if(bstrIn == NULL ||
       pbstrCompressed == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    //
    //  nInLen does not include the terminating NULL.
    //

    nInLen = SysStringLen(bstrIn);

    //
    //  Always want to allocate an even number of bytes
    //  so that the corresponding decompress does not
    //  lose characters.
    //

    if(nInLen & 0x1)
        nInLen++;

    //
    //  Allocate a BSTR of the correct length.
    //

    *pbstrCompressed = SysAllocStringByteLen(NULL, nInLen);
    if(*pbstrCompressed == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    //
    //  We allocated a total of nInLen + 2 bytes.  Zero it out.
    //

    memset(*pbstrCompressed, 0, nInLen + 2);

    //
    //  Convert to multibyte.
    //

    WideCharToMultiByte(CP_ACP, 0, bstrIn, nInLen, (LPSTR)*pbstrCompressed, 
                        (nInLen + 1) << 1, // this is how many bytes were allocated by
                                 // SysAllocStringByteLen
                        NULL, NULL);

    hr = S_OK;

Cleanup:
    
    return hr;
}


STDMETHODIMP CCrypt::Decompress(
    BSTR    bstrIn,
    BSTR*   pbstrDecompressed
    )
{
    HRESULT hr;
    UINT    nInLen;

    if(bstrIn == NULL ||
       pbstrDecompressed == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    //
    //  nInLen is number of mbc's, and does not include the terminating NULL.
    //

    nInLen = SysStringLen(bstrIn) * sizeof(OLECHAR);

    //
    //  If it was an odd number of characters before, the last 
    //  wchar will be 0xNN00.  If so, decrement the number
    //  of characters.
    //

    if((bstrIn[(nInLen >> 1) - 1] & 0xFF00) == 0)
        nInLen--;

    //
    //  Allocate a BSTR of the correct length.
    //

    *pbstrDecompressed = SysAllocStringLen(NULL, nInLen);
    if(*pbstrDecompressed == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    //
    //  We allocated a total of ((nInLen + 1) * sizeof(OLECHAR)) bytes.  Zero it out.
    //

    memset(*pbstrDecompressed, 0, (nInLen + 1) * sizeof(OLECHAR));

    //
    //  Convert to wide.
    //

    MultiByteToWideChar(CP_ACP, 0, (LPCSTR)bstrIn, -1,
                        *pbstrDecompressed, (nInLen + 1) * sizeof(OLECHAR));

    hr = S_OK;

Cleanup:
    
    return hr;
}


STDMETHODIMP
CCrypt::put_site(
    BSTR    bstrSiteName
    )
{
    HRESULT             hr;
    int                 nLen;
    LPSTR               szNewSiteName;
    CRegistryConfig*    crc;

    if(!bstrSiteName)
    {
        if(m_szSiteName)
            delete [] m_szSiteName;
        m_szSiteName = NULL;
    }
    else
    {
        nLen = SysStringLen(bstrSiteName) + 1;
        szNewSiteName = new CHAR[nLen];
        if(!szNewSiteName)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        WideCharToMultiByte(CP_ACP, 0, bstrSiteName, -1,
                            szNewSiteName, nLen,
                            NULL,
                            NULL);


        Cleanup();

        m_szSiteName = szNewSiteName;
    }

    crc = ObtainCRC();
    if (!crc)
    {
        m_keyVersion = 0;
    }
    else
    {
        m_keyVersion = crc->getCurrentCryptVersion();
        crc->getCrypt(m_keyVersion,&m_validUntil);
        crc->Release();
    }

    hr = S_OK;

Cleanup:

    return hr;
}

STDMETHODIMP
CCrypt::put_host(
    BSTR    bstrHostName
    )
{
    HRESULT             hr;
    int                 nLen;
    LPSTR               szNewHostName;
    CRegistryConfig*    crc;

    if(!bstrHostName)
    {
        if(m_szHostName)
            delete [] m_szHostName;
        m_szHostName = NULL;
    }
    else
    {

        nLen = SysStringLen(bstrHostName) + 1;
        szNewHostName = new CHAR[nLen];
        if(!szNewHostName)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        WideCharToMultiByte(CP_ACP, 0, bstrHostName, -1,
                            szNewHostName, nLen,
                            NULL,
                            NULL);

        Cleanup();
        m_szHostName = szNewHostName;

        crc = ObtainCRC();
        if (!crc)
        {
            m_keyVersion = 0;
        }
        else
        {
            m_keyVersion = crc->getCurrentCryptVersion();
            crc->getCrypt(m_keyVersion,&m_validUntil);
            crc->Release();
        }
    }
    hr = S_OK;

Cleanup:

    return hr;
}

void CCrypt::Cleanup()
{
    if( m_szSiteName )
    {
        delete [] m_szSiteName;
        m_szSiteName = NULL;
    }

    if( m_szHostName )
    {
        delete [] m_szHostName;
        m_szHostName = NULL;
    }
}
    

CRegistryConfig* CCrypt::ObtainCRC()
{
    CRegistryConfig* crc = NULL;

    if( m_szHostName && m_szSiteName )
    {
        // we are in bad state now
        Cleanup();
        goto exit;
    } 
    
    if( m_szHostName )
        crc = g_config->checkoutRegistryConfig(m_szHostName);

    if( m_szSiteName )
        crc = g_config->checkoutRegistryConfigBySite(m_szSiteName);

    // if we still can't get crc at this moment, try the default one
    if( !crc )
        crc = g_config->checkoutRegistryConfig();

exit:
    return crc;
}

/////////////////////////////////////////////////////////////////////////////
// IPassportService implementation

STDMETHODIMP CCrypt::Initialize(BSTR configfile, IServiceProvider* p)
{
    HRESULT hr;

    // Initialize.
    if (!g_config->isValid())
    {
        AtlReportError(CLSID_Crypt, PP_E_NOT_CONFIGUREDSTR,
	                    IID_IPassportService, PP_E_NOT_CONFIGURED);
        hr = PP_E_NOT_CONFIGURED;
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:

    return hr;
}


STDMETHODIMP CCrypt::Shutdown()
{
    return S_OK;
}


STDMETHODIMP CCrypt::ReloadState(IServiceProvider*)
{
    return S_OK;
}


STDMETHODIMP CCrypt::CommitState(IServiceProvider*)
{
    return S_OK;
}


STDMETHODIMP CCrypt::DumpState(BSTR* pbstrState)
{
	ATLASSERT( *pbstrState != NULL && 
               "CCrypt:DumpState - "
               "Are you sure you want to hand me a non-null BSTR?" );

	HRESULT hr = S_OK;

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\passportmanager\passportfactory.h ===
// PassportFactory.h : Declaration of the CPassportFactory

#ifndef __PASSPORTFACTORY_H_
#define __PASSPORTFACTORY_H_

#include "resource.h"       // main symbols
#include <asptlb.h>         // Active Server Pages Definitions
#include "Passport.h"
#include "Manager.h"
#include "atlpool.h"

//JVP - start
#include "TSLog.h"
extern CTSLog *g_pTSLogger;
//JVP - end

// extern PassportObjectPool < CComObjectPooled < CManager > > g_Pool;

/////////////////////////////////////////////////////////////////////////////
// CPassportFactory
class ATL_NO_VTABLE CPassportFactory : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CPassportFactory, &CLSID_PassportFactory>,
	public ISupportErrorInfo,
	public IDispatchImpl<IPassportFactory, &IID_IPassportFactory, &LIBID_PASSPORTLib>
{
public:
	CPassportFactory()
	{ 
		m_pUnkMarshaler = NULL;
//JVP - begin changes 
#ifdef PASSPORT_VERBOSE_MODE_ON
	g_pTSLogger->Init(NULL, THREAD_PRIORITY_NORMAL);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes 
	}

public:

DECLARE_REGISTRY_RESOURCEID(IDR_PASSPORTFACTORY)

DECLARE_PROTECT_FINAL_CONSTRUCT()
DECLARE_GET_CONTROLLING_UNKNOWN()

BEGIN_COM_MAP(CPassportFactory)
	COM_INTERFACE_ENTRY(IPassportFactory)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IPassportFactory
public:
	STDMETHOD(CreatePassportManager)(/*[out,retval]*/ IDispatch** pDisp);

private:
};

#endif //__PASSPORTFACTORY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\passportmanager\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\passportmanager\passportconfiguration.h ===
// PassportConfiguration.h: interface for the CPassportConfiguration class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PASSPORTCONFIGURATION_H__74EB2517_E239_11D2_95E9_00C04F8E7A70__INCLUDED_)
#define AFX_PASSPORTCONFIGURATION_H__74EB2517_E239_11D2_95E9_00C04F8E7A70__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <map>
#include "nexus.h"
#include "RegistryConfig.h"
#include "NexusConfig.h"
#include "PassportLock.hpp"

#define PRCONFIG "PARTNER"

typedef PtStlMap<LPSTR, CRegistryConfig*> REGCONFIGMAP;

bool less<LPSTR>::operator()(const LPSTR& x, const LPSTR& y) const
{
    return (_strcmpi(x,y) < 0);
};

class CPassportConfiguration :
public ICCDUpdate, public IConfigurationUpdate
{
public:
  CPassportConfiguration();
  virtual ~CPassportConfiguration();

  // You must call release yourself...
  CRegistryConfig* checkoutRegistryConfig(LPSTR szHost = NULL);
  CRegistryConfig* checkoutRegistryConfigBySite(LPSTR szSiteName);
  CNexusConfig*    checkoutNexusConfig();

  BOOL   isValid();
  LPWSTR getFailureString();
  
  void CCDUpdatedA(LPCSTR pszCCDName, IXMLDocument* piStream)
    { NexusConfigUpdated(piStream); }

  void CCDUpdatedW(LPCWSTR pszCCDName, IXMLDocument* piStream)
    { NexusConfigUpdated(piStream); }

  void LocalConfigurationUpdated();

  BOOL UpdateNow(BOOL forceFetch = TRUE);

  // two phase update
  BOOL PrepareUpdate(BOOL forceFetch = TRUE);
  BOOL CommitUpdate(void);

  void Dump(BSTR* pbstrDump);

  BOOL HasSites(void);

 protected:
  void NexusConfigUpdated(IXMLDocument *pi);

  BOOL TakeRegistrySnapshot(CRegistryConfig** ppRegConfig,
                            REGCONFIGMAP** ppConfigMap);
  BOOL ApplyRegistrySnapshot(CRegistryConfig* pRegConfig,
                             REGCONFIGMAP* pConfigMap);

  BOOL TakeNexusSnapshot(CNexusConfig** ppNexusConfig, BOOL bForceFetch);
  BOOL ApplyNexusSnapshot(CNexusConfig* pNexusConfig);

  void getReadLock(PassportLock &l) { l.acquire(); }
  void releaseReadLock(PassportLock &l) { l.release(); }
  void getWriteLock(PassportLock &l) { l.acquire(); }
  void releaseWriteLock(PassportLock &l) { l.release(); }
  BOOL IsIPAddress(LPSTR szSiteName);

  REGCONFIGMAP        *m_ConfigMap, *m_lastConfigMap, *m_ConfigMapPending;
  CRegistryConfig     *m_rDefault, *m_rlastDefault, *m_rPending;
  CNexusConfig        *m_n, *m_nlast, *m_nPending;
  PassportLock        m_lock;
  HANDLE              m_nUpdate, m_rUpdate;
  time_t              m_lastAttempt;
  bool                m_bUpdateInProgress;
};

#endif // !defined(AFX_PASSPORTCONFIGURATION_H__74EB2517_E239_11D2_95E9_00C04F8E7A70__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\passportmanager\registryconfig.cpp ===
// RegistryConfig.cpp: implementation of the CRegistryConfig class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "RegistryConfig.h"
#include "KeyCrypto.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CRegistryConfig::CRegistryConfig(
    LPSTR  szSiteName
    ) :
    m_siteId(0), m_valid(FALSE), m_ticketPath(NULL), m_profilePath(NULL), m_securePath(NULL),
    m_hostName(NULL), m_hostIP(NULL), m_ticketDomain(NULL), m_profileDomain(NULL), m_secureDomain(NULL),
    m_disasterUrl(NULL), m_disasterMode(FALSE), m_forceLogin(FALSE), m_setCookies(TRUE), 
    m_szReason(NULL), m_refs(0), m_coBrand(NULL), m_ru(NULL), m_ticketAge(14400), m_bInDA(FALSE),
    m_hkPassport(NULL), m_secureLevel(0)
{
    // Get site id, key from registry
    DWORD bufSize = sizeof(m_siteId);
    LONG lResult;
    HKEY hkSites = NULL;
    DWORD dwBufSize = 0, disMode;
    DWORD dwLCID;

    if(szSiteName)
    {
        lResult = RegOpenKeyExA(
                HKEY_LOCAL_MACHINE,
                "Software\\Microsoft\\Passport\\Sites",
                0,
                KEY_READ,
                &hkSites);
        if(lResult != ERROR_SUCCESS)
        {
            m_valid = FALSE;
            setReason(L"Invalid site name.  Site not found.");
            goto Cleanup;
        }

        lResult = RegOpenKeyExA(
                hkSites,
                szSiteName,
                0,
                KEY_READ,
                &m_hkPassport);
        if(lResult != ERROR_SUCCESS)
        {
            m_valid = FALSE;
            setReason(L"Invalid site name.  Site not found.");
            goto Cleanup;
        }
    }
    else
    {
        lResult = RegOpenKeyExA(
		        HKEY_LOCAL_MACHINE,
	         "SOFTWARE\\Microsoft\\Passport\\",
	         0,
	         KEY_READ,
	         &m_hkPassport
	         );
        if(lResult != ERROR_SUCCESS)
        {
            m_valid = FALSE;
            setReason(L"No RegKey HKLM\\SOFTWARE\\Microsoft\\Passport");
            goto Cleanup;
        }
    }

    // Get the current key
    bufSize = sizeof(m_currentKey);
    if (ERROR_SUCCESS != RegQueryValueEx(m_hkPassport, _T("CurrentKey"),
                                       NULL, NULL, (LPBYTE)&m_currentKey, &bufSize))
    {
        m_valid = FALSE;
        setReason(L"No CurrentKey defined in the registry.");
        goto Cleanup;
    }

    if(m_currentKey < 1 || m_currentKey > 0xF)
    {
        m_valid = FALSE;
        setReason(L"Invalid CurrentKey value in the registry.");
        goto Cleanup;
    }

    // Get default LCID
    bufSize = sizeof(dwLCID);
    if (ERROR_SUCCESS != RegQueryValueEx(m_hkPassport, _T("LanguageID"),
                                   NULL, NULL, (LPBYTE)&dwLCID, &bufSize))
    {
        dwLCID = 0;
    }

    m_lcid = static_cast<short>(dwLCID & 0xFFFF);

    // Get disaster mode status
    bufSize = sizeof(disMode);
    if (ERROR_SUCCESS != RegQueryValueEx(m_hkPassport, _T("StandAlone"),
                                   NULL, NULL, (LPBYTE)&disMode, &bufSize))
    {
        m_disasterMode = FALSE;
    }
    else if (disMode != 0)
    {
        m_disasterMode = TRUE;
    }

    // Get the disaster URL
    if (m_disasterMode)
    {
        if (ERROR_SUCCESS == RegQueryValueExA(m_hkPassport, "DisasterURL",
					                    NULL, NULL, NULL, &dwBufSize) &&
        dwBufSize > 1)
        {
            m_disasterUrl = new char[dwBufSize];
            if ((!m_disasterUrl) || 
            ERROR_SUCCESS != RegQueryValueExA(m_hkPassport, "DisasterURL",
								            NULL, NULL, 
								            (LPBYTE) m_disasterUrl,
								            &dwBufSize))
            {
                m_valid = FALSE;
                setReason(L"Error reading DisasterURL from registry. (Query worked, but couldn't retrieve data)");
                goto Cleanup;
            }
        }
        else
        {
            m_valid = FALSE;
            setReason(L"DisasterURL missing from registry.");
            goto Cleanup;
        }
    }

    m_valid = readCryptoKeys(m_hkPassport);
    if (!m_valid)
    {
        if (!m_szReason)
            setReason(L"Error reading Passport crypto keys from registry.");
        goto Cleanup;
    }
    if (m_crypts.count(m_currentKey) == 0)
    {
        m_valid = FALSE;
        if (!m_szReason)
            setReason(L"Error reading Passport crypto keys from registry.");
        goto Cleanup;
    }

    // Get the optional default cobrand
    if (ERROR_SUCCESS == RegQueryValueExW(m_hkPassport, L"CoBrandTemplate",
				            NULL, NULL, NULL, &dwBufSize))
    {
        if (dwBufSize > 2)
        {
            m_coBrand = (WCHAR*) new char[dwBufSize];
            if (ERROR_SUCCESS != RegQueryValueExW(m_hkPassport, L"CoBrandTemplate",
						                NULL, NULL, 
						                (LPBYTE) m_coBrand, &dwBufSize))
            {
                m_valid = FALSE;
                setReason(L"Error reading CoBrand from registry. (Query worked, but couldn't retrieve data)");
                goto Cleanup;
            }
        }
    }

    // Get the optional default return URL
    if (ERROR_SUCCESS == RegQueryValueExW(m_hkPassport, L"ReturnURL",
				                        NULL, NULL, NULL, &dwBufSize))
    {
        if (dwBufSize > 2)
        {
            m_ru = (WCHAR*) new char[dwBufSize];
            if (ERROR_SUCCESS != RegQueryValueExW(m_hkPassport, L"ReturnURL",
						                    NULL, NULL, 
						                    (LPBYTE) m_ru, &dwBufSize))
            {
                m_valid = FALSE;
                setReason(L"Error reading ReturnURL from registry. (Query worked, but couldn't retrieve data)");
                goto Cleanup;
            }
        }
    }

  // Get the host name
    if (ERROR_SUCCESS == RegQueryValueExA(m_hkPassport, "HostName",
                                          NULL, NULL, NULL, &dwBufSize))
    {
        if (dwBufSize > 1)
        {
            m_hostName = new char[dwBufSize];
            if (ERROR_SUCCESS != RegQueryValueExA(m_hkPassport, "HostName",
                                                  NULL, NULL, 
                                                  (LPBYTE) m_hostName, &dwBufSize))
            {
                m_valid = FALSE;
                setReason(L"Error reading HostName from registry. (Query worked, but couldn't retrieve data)");
                goto Cleanup;
            }
        }
    }


  // Get the host ip
    if (ERROR_SUCCESS == RegQueryValueExA(m_hkPassport, "HostIP",
                                          NULL, NULL, NULL, &dwBufSize))
    {
        if (dwBufSize > 1)
        {
            m_hostIP = new char[dwBufSize];
            if (ERROR_SUCCESS != RegQueryValueExA(m_hkPassport, "HostIP",
                                                  NULL, NULL, 
                                                  (LPBYTE) m_hostIP, &dwBufSize))
            {
                m_valid = FALSE;
                setReason(L"Error reading HostIP from registry. (Query worked, but couldn't retrieve data)");
                goto Cleanup;
            }
        }
    }


    // Get the optional domain to set ticket cookies into
    if (ERROR_SUCCESS == RegQueryValueExA(m_hkPassport, "TicketDomain",
                                            NULL, NULL, NULL, &dwBufSize))
    {
        if (dwBufSize > 1)
        {
            m_ticketDomain = new char[dwBufSize];
            if (ERROR_SUCCESS != RegQueryValueExA(m_hkPassport, "TicketDomain",
                                                  NULL, NULL, 
                                                  (LPBYTE) m_ticketDomain, &dwBufSize))
            {
                m_valid = FALSE;
                setReason(L"Error reading TicketDomain from registry. (Query worked, but couldn't retrieve data)");
                goto Cleanup;
            }
        }
    }

    // Get the optional domain to set profile cookies into
    if (ERROR_SUCCESS == RegQueryValueExA(m_hkPassport, "ProfileDomain",
                                            NULL, NULL, NULL, &dwBufSize))
    {
        if (dwBufSize > 1)
        {
            m_profileDomain = new char[dwBufSize];
            if (ERROR_SUCCESS != RegQueryValueExA(m_hkPassport, "ProfileDomain",
                                                  NULL, NULL, 
                                                  (LPBYTE) m_profileDomain, &dwBufSize))
            {
                m_valid = FALSE;
                setReason(L"Error reading ProfileDomain from registry. (Query worked, but couldn't retrieve data)");
                goto Cleanup;
            }
        }
    }

    // Get the optional domain to set secure cookies into
    if (ERROR_SUCCESS == RegQueryValueExA(m_hkPassport, "SecureDomain",
                                            NULL, NULL, NULL, &dwBufSize))
    {
        if (dwBufSize > 1)
        {
            m_secureDomain = new char[dwBufSize];
            if (ERROR_SUCCESS != RegQueryValueExA(m_hkPassport, "SecureDomain",
                                                  NULL, NULL, 
                                                  (LPBYTE) m_secureDomain, &dwBufSize))
            {
                m_valid = FALSE;
                setReason(L"Error reading SecureDomain from registry. (Query worked, but couldn't retrieve data)");
                goto Cleanup;
            }
        }
    }

    // Get the optional path to set ticket cookies into
    if (ERROR_SUCCESS == RegQueryValueExA(m_hkPassport, "TicketPath",
				       NULL, NULL, NULL, &dwBufSize))
    {
        if (dwBufSize > 1)
        {
            m_ticketPath = new char[dwBufSize];
            if (ERROR_SUCCESS != RegQueryValueExA(m_hkPassport, "TicketPath",
						                          NULL, NULL, 
						                          (LPBYTE) m_ticketPath, &dwBufSize))
            {
                m_valid = FALSE;
                setReason(L"Error reading TicketPath from registry. (Query worked, but couldn't retrieve data)");
                goto Cleanup;
            }
        }
    }

    // Get the optional path to set profile cookies into
    if (ERROR_SUCCESS == RegQueryValueExA(m_hkPassport, "ProfilePath",
				       NULL, NULL, NULL, &dwBufSize))
    {
        if (dwBufSize > 1)
        {
            m_profilePath = new char[dwBufSize];
            if (ERROR_SUCCESS != RegQueryValueExA(m_hkPassport, "ProfilePath",
						                          NULL, NULL, 
						                          (LPBYTE) m_profilePath, &dwBufSize))
            {
                m_valid = FALSE;
                setReason(L"Error reading ProfilePath from registry. (Query worked, but couldn't retrieve data)");
                goto Cleanup;
            }
        }
    }

    // Get the optional path to set secure cookies into
    if (ERROR_SUCCESS == RegQueryValueExA(m_hkPassport, "SecurePath",
				       NULL, NULL, NULL, &dwBufSize))
    {
        if (dwBufSize > 1)
        {
            m_securePath = new char[dwBufSize];
            if (ERROR_SUCCESS != RegQueryValueExA(m_hkPassport, "SecurePath",
						                          NULL, NULL, 
						                          (LPBYTE) m_securePath, &dwBufSize))
            {
                m_valid = FALSE;
                setReason(L"Error reading SecurePath from registry. (Query worked, but couldn't retrieve data)");
                goto Cleanup;
            }
        }
    }

    bufSize = sizeof(m_siteId);
    // Now get the site id
    if (ERROR_SUCCESS != RegQueryValueEx(m_hkPassport, _T("SiteId"),
                                        NULL, NULL, (LPBYTE)&m_siteId, &bufSize))
    {
        m_valid = FALSE;
        setReason(L"No SiteId specified in registry");
        goto Cleanup;
    }

    // And the default ticket time window
    if (ERROR_SUCCESS != RegQueryValueEx(m_hkPassport, _T("TimeWindow"),
                                        NULL, NULL, (LPBYTE)&m_ticketAge, &bufSize))
    {
        m_ticketAge = 14400;
    }

    bufSize = sizeof(DWORD);
    DWORD forced;
    if (ERROR_SUCCESS != RegQueryValueEx(m_hkPassport, _T("ForceSignIn"),
                                        NULL, NULL, (LPBYTE)&forced, &bufSize))
    {
        m_forceLogin = FALSE;
    }
    else
    {
        m_forceLogin = forced == 0 ? FALSE : TRUE;
    }

    bufSize = sizeof(DWORD);
    DWORD noSetCookies;
    if (ERROR_SUCCESS != RegQueryValueEx(m_hkPassport, _T("DisableCookies"),
                                        NULL, NULL, (LPBYTE)&noSetCookies, &bufSize))
    {
        m_setCookies = TRUE;
    }
    else
    {
        m_setCookies = !noSetCookies;
    }

    bufSize = sizeof(DWORD);
    DWORD dwInDA;
    if (ERROR_SUCCESS != RegQueryValueEx(m_hkPassport, _T("InDA"),
                                        NULL, NULL, (LPBYTE)&dwInDA, &bufSize))
    {
        m_bInDA = FALSE;
    }
    else
    {
        m_bInDA = (dwInDA != 0);
    }

    bufSize = sizeof(m_secureLevel);
    // Now get the site id
    if (ERROR_SUCCESS != RegQueryValueEx(m_hkPassport, _T("SecureLevel"),
                                        NULL, NULL, (LPBYTE)&m_secureLevel, &bufSize))
    {
        m_secureLevel = 0;
    }

    m_szReason = NULL;
    m_valid = TRUE;

Cleanup:
   return;
}

CRegistryConfig::~CRegistryConfig()
{
    if (!m_crypts.empty())
    {
        INT2CRYPT::iterator itb = m_crypts.begin();
        for (; itb != m_crypts.end(); itb++)
        {
            delete itb->second;
        }
        m_crypts.clear();
    }
    if (m_szReason)
        SysFreeString(m_szReason);
    if (m_ticketDomain)
        delete[] m_ticketDomain;
    if (m_profileDomain)
        delete[] m_profileDomain;
    if (m_secureDomain)
        delete[] m_secureDomain;
    if (m_ticketPath)
        delete[] m_ticketPath;
    if (m_profilePath)
        delete[] m_profilePath;
    if (m_securePath)
        delete[] m_securePath;
    if (m_disasterUrl)
        delete[] m_disasterUrl;
    if (m_coBrand)
        delete[] m_coBrand;
    if (m_hostName)
        delete[] m_hostName;
    if (m_hostIP)
        delete[] m_hostIP;
    if (m_ru)
        delete[] m_ru;
    if (m_hkPassport != NULL)
    {
        RegCloseKey(m_hkPassport);
    }

}

#define  __MAX_STRING_LENGTH__   1024
HRESULT CRegistryConfig::GetCurrentConfig(LPCWSTR name, VARIANT* pVal)
{
   if(m_hkPassport == NULL || !m_valid)
   {
      return PP_E_SITE_NOT_EXISTS;
   }

   if(!name || !pVal)   return E_INVALIDARG;

   HRESULT  hr = S_OK;
   BYTE  *pBuf = NULL;
   ATL::CComVariant v;
   BYTE  dataBuf[__MAX_STRING_LENGTH__];
   DWORD bufLen = sizeof(dataBuf);
   BYTE  *pData = dataBuf;
   DWORD dwErr = ERROR_SUCCESS;
   DWORD dataType = 0;

   dwErr = RegQueryValueEx(m_hkPassport, name, NULL, &dataType, (LPBYTE)pData, &bufLen);

   if (dwErr == ERROR_MORE_DATA)
   {
      pBuf = (PBYTE)malloc(bufLen);
      if (!pBuf)
      {
         hr = E_OUTOFMEMORY;
         goto Exit;
      }
      pData = pBuf;
      dwErr = RegQueryValueEx(m_hkPassport, name, NULL, &dataType, (LPBYTE)pData, &bufLen);
   }

   if (dwErr != ERROR_SUCCESS)
      hr = HRESULT_FROM_WIN32(dwErr);
   else
   {
      switch(dataType)
      {
      case  REG_DWORD:
      case  REG_DWORD_BIG_ENDIAN:
         {
            DWORD* pdw = (DWORD*)pData;
            v = (long)*pdw;
         }
         break;
      case  REG_SZ:
      case  REG_EXPAND_SZ:
         {
            LPCWSTR pch = (LPCWSTR)pData;
            v = (LPCWSTR)pch;
         }
         break;
      default:
         hr = PP_E_TYPE_NOT_SUPPORTED;
         
         break;
      }
   }

Exit:
   if(pBuf)
      free(pBuf);

   if (hr == S_OK)
      v.Detach(pVal);
   
   return hr;

}

#define  MAX_ENCKEYSIZE 1024

BOOL CRegistryConfig::readCryptoKeys(
    HKEY    hkPassport
    )
{
  LONG   lResult;
  BOOL   retVal = FALSE;
  HKEY   hkDataKey = NULL, hkTimeKey = NULL;
  DWORD  iterIndex = 0, keySize, keyTime, keyNumSize;
  BYTE   encKeyBuf[MAX_ENCKEYSIZE];
  int    kNum;
  TCHAR  szKeyNum[4];
  CKeyCrypto kc;
  int foundKeys = 0;

  // Open both the keydata and keytimes key,
  // if there's no keytimes key, we'll assume all keys are valid forever,
  // or more importantly, we won't break if that key isn't there
  lResult = RegOpenKeyEx(hkPassport, TEXT("KeyData"), 0,
			             KEY_READ, &hkDataKey);
  if(lResult != ERROR_SUCCESS)
    {
      setReason(L"No Valid Crypto Keys");
      goto Cleanup;
    }
  RegOpenKeyEx(hkPassport, TEXT("KeyTimes"), 0,
	           KEY_READ, &hkTimeKey);

  // Ok, now enumerate the KeyData keys and create crypt objects

  while (1)
    {
      keySize = sizeof(encKeyBuf);
      keyNumSize = sizeof(szKeyNum) >> (sizeof(TCHAR) - 1);
      lResult = RegEnumValue(hkDataKey, iterIndex++, szKeyNum,
			     &keyNumSize, NULL, NULL, (LPBYTE)&(encKeyBuf[0]), &keySize);
      if (lResult != ERROR_SUCCESS)
	{
	  break;
	}

      kNum = (szKeyNum[0] >= _T('0') && szKeyNum[0] <= _T('9')) ?
                szKeyNum[0] - _T('0') :
                (szKeyNum[0] >= _T('A') && szKeyNum[0] <= _T('F')) ?
                    szKeyNum[0] - _T('A') + 10 : -1;

      if (kNum > 0)
	{
      DATA_BLOB   iBlob;
      DATA_BLOB   oBlob;

      iBlob.cbData = keySize;
      iBlob.pbData = (LPBYTE)&(encKeyBuf[0]);
      ZeroMemory(&oBlob, sizeof(oBlob));
      
      if(kc.decryptKey(&iBlob, &oBlob) != S_OK)
      {
          g_pAlert->report(PassportAlertInterface::ERROR_TYPE,
                         PM_CANT_DECRYPT_CONFIG);
          break;
      }
      else
      {
       // Now set up a crypt object
       CCoCrypt* cr = new CCoCrypt();
       BSTR km = ::SysAllocStringByteLen((LPSTR)oBlob.pbData, oBlob.cbData);
       cr->setKeyMaterial(km);
       ::SysFreeString(km);
       if(oBlob.pbData)
       {
          ::LocalFree(oBlob.pbData);
          ZeroMemory(&oBlob, sizeof(oBlob));
       }
       // Add it to the bucket...
       INT2CRYPT::value_type pMapVal(kNum, cr);
       m_crypts.insert(pMapVal);
       foundKeys++;

       keySize = sizeof(DWORD);
       if (RegQueryValueEx(hkTimeKey, szKeyNum, NULL,NULL,(LPBYTE)&keyTime,&keySize) ==
           ERROR_SUCCESS && (m_currentKey != kNum))
       {
         INT2TIME::value_type pTimeVal(kNum,keyTime);
         m_cryptValidTimes.insert(pTimeVal);
       }
     }
  }

       if (iterIndex > 100)  // Safety latch
	goto Cleanup;
    }

  retVal = foundKeys > 0 ? TRUE : FALSE;

 Cleanup:
  if (hkDataKey)
    RegCloseKey(hkDataKey);
  if (hkTimeKey)
    RegCloseKey(hkTimeKey);

  return retVal;
}

CCoCrypt* CRegistryConfig::getCrypt(int keyNum, time_t* validUntil)
{
  if (validUntil) // If they asked for the validUntil information
    {
      INT2TIME::const_iterator timeIt = m_cryptValidTimes.find(keyNum);
      if (timeIt == m_cryptValidTimes.end())
	*validUntil = 0;
      else
	*validUntil = (*timeIt).second;
    }
  // Now look up the actual crypt object
  INT2CRYPT::const_iterator it = m_crypts.find(keyNum);
  if (it == m_crypts.end())
    return NULL;
  return (*it).second;
}

BSTR CRegistryConfig::getFailureString()
{
  if (m_valid)
    return NULL;
  return m_szReason;
}

void CRegistryConfig::setReason(LPTSTR reason)
{
  if (m_szReason)
    SysFreeString(m_szReason);
  m_szReason = SysAllocString(reason);
}

CRegistryConfig* CRegistryConfig::AddRef()
{
  InterlockedIncrement(&m_refs);
  return this;
}

void CRegistryConfig::Release()
{
  long refs = InterlockedDecrement(&m_refs);
  if (refs == 0)
    delete this;
}

long
CRegistryConfig::GetHostName(
    LPSTR   szSiteName,
    LPSTR   szHostName,
    LPDWORD lpdwHostNameBufLen
    )
{
    long    lResult;
    HKEY    hkSites = NULL;
    HKEY    hkPassport = NULL;

    if(!szSiteName || szSiteName[0] == '\0')
    {
        lResult = E_UNEXPECTED;
        goto Cleanup;
    }

    lResult = RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                            "Software\\Microsoft\\Passport\\Sites",
                            0,
                            KEY_READ,
                            &hkSites
                            );
    if(lResult != ERROR_SUCCESS)
        goto Cleanup;

    lResult = RegOpenKeyExA(hkSites,
                            szSiteName,
                            0,
                            KEY_READ,
                            &hkPassport
                            );
    if(lResult != ERROR_SUCCESS)
        goto Cleanup;


    lResult = RegQueryValueExA(hkPassport,
                               "HostName",
                               NULL,
                               NULL,
                               (LPBYTE)szHostName,
                               lpdwHostNameBufLen
                               );

Cleanup:

    if(hkSites != NULL)
        RegCloseKey(hkSites);
    if(hkPassport != NULL)
        RegCloseKey(hkPassport);

    return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\passportmanager\profile.h ===
// Profile.h : Declaration of the CProfile

#ifndef __PROFILE_H_
#define __PROFILE_H_

#include "resource.h"       // main symbols
#include <asptlb.h>         // Active Server Pages Definitions

//JVP - start
#include "TSLog.h"
extern CTSLog *g_pTSLogger;
//JVP - end

/////////////////////////////////////////////////////////////////////////////
// CProfile
class ATL_NO_VTABLE CProfile : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CProfile, &CLSID_Profile>,
	public ISupportErrorInfo,
	public IDispatchImpl<IPassportProfile, &IID_IPassportProfile, &LIBID_PASSPORTLib>
{
public:
  CProfile();
  ~CProfile();

public:

DECLARE_REGISTRY_RESOURCEID(IDR_PROFILE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CProfile)
  COM_INTERFACE_ENTRY(IPassportProfile)
  COM_INTERFACE_ENTRY(IDispatch)
  COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// ISupportsErrorInfo
  STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IPassportProfile
public:
	HRESULT get_IsSecure(VARIANT_BOOL* pbIsSecure);
	BOOL IsSecure(void);
  STDMETHOD(get_unencryptedProfile)(/*[out, retval]*/ BSTR *pVal);
  STDMETHOD(put_unencryptedProfile)(/*[in]*/ BSTR newVal);
  STDMETHOD(get_SchemaName)(/*[out, retval]*/ BSTR *pVal);
  STDMETHOD(put_SchemaName)(/*[in]*/ BSTR newVal);
  STDMETHOD(get_IsValid)(/*[out, retval]*/ VARIANT_BOOL *pVal);
  STDMETHOD(get_ByIndex)(/*[in]*/ int index, /*[out, retval]*/ VARIANT *pVal);
  STDMETHOD(put_ByIndex)(/*[in]*/ int index, /*[in]*/ VARIANT newVal);
  STDMETHOD(get_Attribute)(/*[in]*/ BSTR name, /*[out, retval]*/ VARIANT *pVal);
  STDMETHOD(put_Attribute)(/*[in]*/ BSTR name, /*[in]*/ VARIANT newVal);
  STDMETHOD(get_updateString)(/*[out,retval]*/ BSTR *pVal);
  STDMETHOD(incrementVersion)(void);

protected:
    UINT*           m_bitPos;
    UINT*           m_pos;
    BSTR            m_schemaName;
    BSTR            m_raw;
    BOOL            m_valid;
    BOOL            m_secure;
    CProfileSchema* m_schema;

    int             m_versionAttributeIndex;
    void**          m_updates;

    void            parse(LPCOLESTR raw, DWORD dwByteLen);
private:
};

#endif //__PROFILE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\passportmanager\profile.cpp ===
// Profile.cpp : Implementation of CProfile
#include "stdafx.h"
#include <oleauto.h>

#include "Passport.h"
#include "Profile.h"

// gmarks
#include "Monitoring.h"

/////////////////////////////////////////////////////////////////////////////
// CProfile

CProfile::CProfile() : m_raw(NULL), m_pos(NULL), m_bitPos(NULL),
  m_schemaName(NULL), m_valid(FALSE), m_updates(NULL), m_schema(NULL),
  m_versionAttributeIndex(-1), m_secure(FALSE)
{
  
//JVP - begin changes 
#ifdef PASSPORT_VERBOSE_MODE_ON
	g_pTSLogger->Init(NULL, THREAD_PRIORITY_NORMAL);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes 
}

CProfile::~CProfile()
{
  if (m_raw)
    FREE_BSTR(m_raw);
  if (m_pos)
    delete[] m_pos;
  if (m_bitPos)
    delete[] m_bitPos;
  if (m_schemaName)
    FREE_BSTR(m_schemaName);
  if (m_updates)
    {
      for (int i = 0; i < m_schema->Count(); i++)
	{
	  if (m_updates[i])
	    delete[] m_updates[i];
	}
      delete[] m_updates;
    }
  if (m_schema)
    m_schema->Release();
}

STDMETHODIMP CProfile::InterfaceSupportsErrorInfo(REFIID riid)
{
  static const IID* arr[] = 
  {
    &IID_IPassportProfile,
  };
  for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
    {
      if (InlineIsEqualGUID(*arr[i],riid))
	return S_OK;
    }
  return S_FALSE;
}


STDMETHODIMP CProfile::get_Attribute(BSTR name, VARIANT *pVal)
{
    VariantInit(pVal);

    if (!m_valid) return S_OK;  // Already threw event somewhere else

    if (!m_schema) return PP_E_NOT_CONFIGURED;

    if (!name) return E_INVALIDARG;

    if (!_wcsicmp(name, L"internalmembername"))
    {
        // return the internal name
        return get_ByIndex(MEMBERNAME_INDEX, pVal);
    }


    int index = m_schema->GetIndexByName(name);
    if (index >= 0)
    {
        if( index != MEMBERNAME_INDEX ) 
        {
            return get_ByIndex(index, pVal);
        }
        else
        { 
            //
            // special case for MEMBERNAME, if this the name is 
            // in the format of email, we will need do something here
            //
            HRESULT hr = get_ByIndex(MEMBERNAME_INDEX, pVal); 
            if( S_OK == hr && VT_BSTR == pVal->vt )
            {
                int bstrLen = SysStringLen(pVal->bstrVal);
                int i = 0;
                int iChangePos = 0;
                int iTerminatePos = 0;

                for( i = 0; i < bstrLen; i++)
                {
                    if( pVal->bstrVal[i] == L'%' )
                        iChangePos = i;
                    if( pVal->bstrVal[i] == L'@' )
                        iTerminatePos = i;
                }

                //
                // for email format, we must have iChangePos < iTerminatePos
                // this code will convert "foo%bar.com@passport.com" into 
                //                        "foo@bar.com"
                //
                if( iChangePos && iTerminatePos && iChangePos < iTerminatePos )
                {
                    BSTR bstrTemp = pVal->bstrVal;

                    pVal->bstrVal[iChangePos] = L'@'; 
                    pVal->bstrVal[iTerminatePos] = L'\0'; 

                    pVal->bstrVal = SysAllocString(pVal->bstrVal);
                    SysFreeString(bstrTemp);
                }
            }
            return hr;
        } 
    }
    else
    {
        AtlReportError(CLSID_Profile, PP_E_NO_SUCH_ATTRIBUTESTR,
                    IID_IPassportProfile, PP_E_NO_SUCH_ATTRIBUTE);
        return PP_E_NO_SUCH_ATTRIBUTE;
    }
    return S_OK;
}

STDMETHODIMP CProfile::put_Attribute(BSTR name, VARIANT newVal)
{
//JVP - begin changes 
#ifdef PASSPORT_VERBOSE_MODE_ON
	char szLogString[LOG_STRING_LEN] = "CProfile::put_Attribute, Enter";
	AddBSTRAsString(name,  szLogString, sizeof(szLogString));
	g_pTSLogger->AddDateTimeAndLog(szLogString);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes 

    if(g_pPerf) 
    {
        g_pPerf->incrementCounter(PM_PROFILEUPDATES_TOTAL);
        g_pPerf->incrementCounter(PM_PROFILEUPDATES_SEC);
    } 
    else 
    {
        _ASSERT(g_pPerf);
    }

    if (!m_valid) return S_OK;  // Already threw event somewhere else

    if (!m_schema) return PP_E_NOT_CONFIGURED;

    if (!name) return E_INVALIDARG;

    int index = m_schema->GetIndexByName(name);
    if (index >= 0)
        return put_ByIndex(index, newVal);
    else
    {
        AtlReportError(CLSID_Profile, PP_E_NO_SUCH_ATTRIBUTESTR,
                        IID_IPassportProfile, PP_E_NO_SUCH_ATTRIBUTE);
        return PP_E_NO_SUCH_ATTRIBUTE;
    }

//JVP - begin changes 
#ifdef PASSPORT_VERBOSE_MODE_ON
	g_pTSLogger->AddDateTimeAndLog("CProfile::put_Attribute, Exit");
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes 

    return S_OK;
}

STDMETHODIMP CProfile::get_ByIndex(int index, VARIANT *pVal)
{
    if(!pVal)   return E_INVALIDARG;
   
    VariantInit(pVal);

    if (!m_valid) return S_OK;
    if (!m_schema) return PP_E_NOT_CONFIGURED;

    if (m_pos[index] == INVALID_POS) return S_FALSE;   // the return value is VT_EMPTY

    if (index >= m_schema->Count())
    {
        AtlReportError(CLSID_Profile, PP_E_NO_SUCH_ATTRIBUTESTR,
                    IID_IPassportProfile, PP_E_NO_SUCH_ATTRIBUTE);

        return PP_E_NO_SUCH_ATTRIBUTE;
    }

    LPSTR raw = (LPSTR)m_raw;
    CProfileSchema::AttrType t = m_schema->GetType(index);

    switch (t)
    {
    case CProfileSchema::tText:
        {
            u_short slen = ntohs(*(u_short*)(raw+m_pos[index]));
            pVal->vt = VT_BSTR;
            if (slen == 0)
            {
                pVal->bstrVal = ALLOC_AND_GIVEAWAY_BSTR_LEN(L"", 0);
            }
            else
            {
                int wlen = MultiByteToWideChar(CP_UTF8, 0,
                                            raw+m_pos[index]+sizeof(u_short),
                                            slen, NULL, 0);
                pVal->bstrVal = ALLOC_AND_GIVEAWAY_BSTR_LEN(NULL, wlen);
                MultiByteToWideChar(CP_UTF8, 0,
                                    raw+m_pos[index]+sizeof(u_short),
                                    slen, pVal->bstrVal, wlen);
                pVal->bstrVal[wlen] = L'\0';
            }
        }
        break;
    case CProfileSchema::tChar:
        {
            int wlen = MultiByteToWideChar(CP_UTF8, 0,
                                            raw+m_pos[index],
                                            m_schema->GetByteSize(index), NULL, 0);
            pVal->vt = VT_BSTR;
            pVal->bstrVal = ALLOC_AND_GIVEAWAY_BSTR_LEN(NULL, wlen);
            MultiByteToWideChar(CP_UTF8, 0,
                                raw+m_pos[index],
                                m_schema->GetByteSize(index), pVal->bstrVal, wlen);
            pVal->bstrVal[wlen] = L'\0';
        }
        break;
    case CProfileSchema::tByte:
        pVal->vt = VT_I2;
        pVal->iVal = *(BYTE*)(raw+m_pos[index]);
        break;
    case CProfileSchema::tWord:
        pVal->vt = VT_I2;
        pVal->iVal = ntohs(*(u_short*) (raw+m_pos[index]));
        break;
    case CProfileSchema::tLong:
        pVal->vt = VT_I4;
        pVal->lVal = ntohl(*(u_long*) (raw+m_pos[index]));
        break;
    case CProfileSchema::tDate:
        pVal->vt = VT_DATE;
        VarDateFromI4(ntohl(*(u_long*) (raw+m_pos[index])), &(pVal->date));
        break;
    default:
        AtlReportError(CLSID_Profile, PP_E_BAD_DATA_FORMATSTR,
        IID_IPassportProfile, PP_E_BAD_DATA_FORMAT);
        return PP_E_BAD_DATA_FORMAT;
    }
    return S_OK;

}

STDMETHODIMP CProfile::put_ByIndex(int index, VARIANT newVal)
{
  static int nEmailIndex, nFlagsIndex;

  if(nEmailIndex == 0)
      nEmailIndex = m_schema->GetIndexByName(L"preferredEmail");
  if(nFlagsIndex == 0)
      nFlagsIndex = m_schema->GetIndexByName(L"flags");

  if(g_pPerf) {
    g_pPerf->incrementCounter(PM_PROFILEUPDATES_TOTAL);
    g_pPerf->incrementCounter(PM_PROFILEUPDATES_SEC);
  } else {
    _ASSERT(g_pPerf);
  }

  if (!m_valid) return S_OK;
  if (!m_schema) return PP_E_NOT_CONFIGURED;

  if (index >= m_schema->Count())
    {
      AtlReportError(CLSID_Profile, PP_E_NO_SUCH_ATTRIBUTESTR,
		     IID_IPassportProfile, PP_E_NO_SUCH_ATTRIBUTE);
      return PP_E_NO_SUCH_ATTRIBUTE;
    }

  if (m_schema->IsReadOnly(index))
    {
      AtlReportError(CLSID_Profile, PP_E_READONLY_ATTRIBUTESTR,
		     IID_IPassportProfile, PP_E_READONLY_ATTRIBUTE);
      return PP_E_READONLY_ATTRIBUTE;
    }

  // Now, if the update array doesn't exist, make it
  if (!m_updates)
    {
      m_updates = (void**) new void*[m_schema->Count()];
      if (!m_updates)
	return E_OUTOFMEMORY;
      memset(m_updates, 0, m_schema->Count()*sizeof(void*));
    }

  // What type is this attribute?
  CProfileSchema::AttrType t = m_schema->GetType(index);

  if (m_updates[index] != NULL)
    {
      delete[] m_updates[index];
      m_updates[index] = NULL;
    }

  _variant_t dest;

  // I don't really like that we have to alloc memory for each entry (even bits)
  // but this happens infrequently enough that I'm not too upset
  switch (t)
  {
  case CProfileSchema::tText:
    {
      // Convert to UTF-8, stuff it
      if (VariantChangeType(&dest, &newVal, 0, VT_BSTR) != S_OK)
	{
	  AtlReportError(CLSID_Profile, PP_E_BDF_TOSTRCVT,
			 IID_IPassportProfile, PP_E_BAD_DATA_FORMAT);
	  return PP_E_BAD_DATA_FORMAT;
	}
      int wlen = WideCharToMultiByte(CP_UTF8, 0,
				     dest.bstrVal, SysStringLen(dest.bstrVal),
				     NULL, 0, NULL, NULL);
      if (wlen > 65536 || wlen < 0)
	{
	  AtlReportError(CLSID_Profile, PP_E_BDF_STRTOLG,
			 IID_IPassportProfile, PP_E_BAD_DATA_FORMAT);
	  return PP_E_BAD_DATA_FORMAT;
	}

      if (wlen >= 0)
	{
	  m_updates[index] = new char[sizeof(u_short)+wlen+1];
	  WideCharToMultiByte(CP_UTF8, 0, dest.bstrVal, SysStringLen(dest.bstrVal),
			      ((char*)m_updates[index])+sizeof(u_short), wlen,
			      NULL, NULL);
	  *(u_short*)m_updates[index] = htons((u_short)wlen);
	  ((char*)m_updates[index])[wlen+sizeof(u_short)] = '\0';
	}
      else
	{
	  AtlReportError(CLSID_Profile, PP_E_BDF_NONULL,
			 IID_IPassportProfile, PP_E_BAD_DATA_FORMAT);
	  return PP_E_BAD_DATA_FORMAT;
	}
    }
    break;
  case CProfileSchema::tChar:
    {
      int atsize = m_schema->GetByteSize(index);
      // Create array, convert to UTF-8, stuff it
      m_updates[index] = new char[atsize];
      // Convert to UTF-8, stuff it
      if (VariantChangeType(&dest, &newVal, 0, VT_BSTR) != S_OK)
	{
	  AtlReportError(CLSID_Profile, PP_E_BDF_TOSTRCVT,
			 IID_IPassportProfile, PP_E_BAD_DATA_FORMAT);
	  return PP_E_BAD_DATA_FORMAT;
	}
      int res = WideCharToMultiByte(CP_UTF8, 0, dest.bstrVal, SysStringLen(dest.bstrVal),
				    (char*)m_updates[index], atsize, NULL, NULL);
      if (res == 0)
	{
	  delete[] m_updates[index];
	  m_updates[index] = NULL;
	  AtlReportError(CLSID_Profile, PP_E_BDF_STRTOLG,
			 IID_IPassportProfile, PP_E_BAD_DATA_FORMAT);
	  return PP_E_BAD_DATA_FORMAT;
	}
    }
    break;
  case CProfileSchema::tByte:
    // Alloc single byte, put value
      if (VariantChangeType(&dest, &newVal, 0, VT_UI1) != S_OK)
	{
	  AtlReportError(CLSID_Profile, PP_E_BDF_TOBYTECVT,
			 IID_IPassportProfile, PP_E_BAD_DATA_FORMAT);
	  return PP_E_BAD_DATA_FORMAT;
	}
    m_updates[index] = new BYTE[1];
	*(unsigned char*)(m_updates[index]) = dest.bVal;

    break;
  case CProfileSchema::tWord:
    // Alloc single word, put value
    if (VariantChangeType(&dest, &newVal, 0, VT_I2) != S_OK)
      {
	AtlReportError(CLSID_Profile, PP_E_BDF_TOSHORTCVT,
		       IID_IPassportProfile, PP_E_BAD_DATA_FORMAT);
	return PP_E_BAD_DATA_FORMAT;
      }

    m_updates[index] = new u_short[1];
    *(u_short*)m_updates[index] = htons(dest.iVal);
    break;
  case CProfileSchema::tLong:
    // Alloc single long, put value
    if (VariantChangeType(&dest, &newVal, 0, VT_I4) != S_OK)
      {
	AtlReportError(CLSID_Profile, PP_E_BDF_TOINTCVT,
		       IID_IPassportProfile, PP_E_BAD_DATA_FORMAT);
	return PP_E_BAD_DATA_FORMAT;
      }
    m_updates[index] = new u_long[1];
    *(u_long*)m_updates[index] = htonl(dest.lVal);
    break;
  case CProfileSchema::tDate:
    if (VariantChangeType(&dest, &newVal, 0, VT_DATE) != S_OK)
    {
        AtlReportError(CLSID_Profile, PP_E_BDF_TOINTCVT,
                IID_IPassportProfile, PP_E_BAD_DATA_FORMAT);
        return PP_E_BAD_DATA_FORMAT;
    }
    m_updates[index] = new u_long[1];
    *(u_long*)m_updates[index] = htonl((u_long)dest.date);
    break;
  default:
    AtlReportError(CLSID_Profile, PP_E_BDF_CANTSET,
		   IID_IPassportProfile, PP_E_BAD_DATA_FORMAT);
    return PP_E_BAD_DATA_FORMAT;
  }

  //DarrenAn Bug 2157  If they just updated their email, clear the validation bit in flags.
  if(index == nEmailIndex)
  {
    if (m_updates[nFlagsIndex] != NULL)
    {
      delete[] m_updates[nFlagsIndex];
    }
    m_updates[nFlagsIndex] = new u_long[1];
    *(u_long*)m_updates[nFlagsIndex] = htonl(ntohl(*(u_long*) (((LPSTR)m_raw)+m_pos[nFlagsIndex])) & 0xFFFFFFFE);
  }

  return S_OK;
}

STDMETHODIMP CProfile::get_IsValid(VARIANT_BOOL *pVal)
{
  *pVal = m_valid ? VARIANT_TRUE : VARIANT_FALSE;

//JVP - begin changes 
#ifdef PASSPORT_VERBOSE_MODE_ON
	char szLogString[LOG_STRING_LEN] = "CProfile::get_IsValid";
	AddVariantBoolAsString(*pVal, szLogString, sizeof(szLogString));
	g_pTSLogger->AddDateTimeAndLog(szLogString);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes 

  return S_OK;
}

STDMETHODIMP CProfile::get_SchemaName(BSTR *pVal)
{
  *pVal = ALLOC_AND_GIVEAWAY_BSTR(m_schemaName);

  //JVP - begin changes 
#ifdef PASSPORT_VERBOSE_MODE_ON
	char szLogString[LOG_STRING_LEN] = "CProfile::get_SchemaName";
	AddBSTRAsString(*pVal,  szLogString, sizeof(szLogString));
	g_pTSLogger->AddDateTimeAndLog(szLogString);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes 

  return S_OK;
}

STDMETHODIMP CProfile::put_SchemaName(BSTR newVal)
{

//JVP - begin changes 
#ifdef PASSPORT_VERBOSE_MODE_ON
	char szLogString[LOG_STRING_LEN] = "CProfile::put_SchemaName";
	AddBSTRAsString(newVal,  szLogString, sizeof(szLogString));
	g_pTSLogger->AddDateTimeAndLog(szLogString);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes 

// fix: 5247	Profile Object not reseting Schema name
   return E_NOTIMPL;
   

  if (m_schemaName)
    FREE_BSTR(m_schemaName);
  m_schemaName = ALLOC_BSTR(newVal);
  return S_OK;
}

STDMETHODIMP CProfile::get_unencryptedProfile(BSTR *pVal)
{
//JVP - begin changes 
#ifdef PASSPORT_VERBOSE_MODE_ON
	g_pTSLogger->AddDateTimeAndLog("CProfile::get_unencryptedProfile, Enter");
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes 

  // Take updates into account
  if (!pVal)
    return E_INVALIDARG;

  *pVal = NULL;

  if (!m_valid) return S_OK;
  if (!m_schema) return PP_E_NOT_CONFIGURED;

  int size = 0, len;
  short i = 0;

  LPSTR inraw = (LPSTR)m_raw;

  m_versionAttributeIndex = m_schema->GetIndexByName(L"profileVersion");

  // Pack up each value, first find out how much space we need
  for (; i < m_schema->Count(); i++)
    {
      CProfileSchema::AttrType t = m_schema->GetType(i);
      void* valPtr = NULL;

      if(m_pos[i] != INVALID_POS) valPtr = inraw+m_pos[i];

      if (m_updates && m_updates[i])
	valPtr = m_updates[i];

      // neither exists, end of the loop
      if (valPtr == NULL)  
      {
#ifdef _DEBUG
      // walk through rest of the array to see if anything follows is set
#endif
         break;
      }

      switch (t)
	{
	case CProfileSchema::tText:
	  // How long is the string
	  size += (sizeof(u_short) + ntohs(*(u_short*)valPtr));
	  break;
	case CProfileSchema::tChar:
	  size += m_schema->GetByteSize(i);
	  break;
	case CProfileSchema::tByte:
	  size += 1;
	  break;
	case CProfileSchema::tWord:
	  size += sizeof(u_short);
	  break;
	case CProfileSchema::tLong:
    case CProfileSchema::tDate:
	  size += sizeof(u_long);
	  break;
	  // no default case needed, it never will be non-null
	}
    }

  // Ok, now build it up...
  *pVal = ALLOC_BSTR_BYTE_LEN(NULL, size);
  LPSTR raw = (LPSTR) *pVal;
  size = 0;

  for (i = 0; i < m_schema->Count(); i++)
    {
      void* valPtr = NULL;

      if(m_pos[i] != INVALID_POS) valPtr = inraw+m_pos[i];

      if (m_updates && m_updates[i])
	valPtr = m_updates[i];

      // neither exists, end of the loop
      if (valPtr == NULL)  break;

      CProfileSchema::AttrType t = m_schema->GetType(i);
      
      switch (t)
	{
	case CProfileSchema::tText:
	  // How long is the string
	  len = ntohs(*(u_short*)valPtr);
	  memcpy(raw+size, (char*) valPtr, len+sizeof(u_short));
	  size += len + sizeof(u_short);
	  break;
	case CProfileSchema::tChar:
	  memcpy(raw+size, (char*) valPtr, m_schema->GetByteSize(i));
	  size += m_schema->GetByteSize(i);
	  break;
	case CProfileSchema::tByte:
	  *(raw+size) = *(BYTE*)valPtr;
	  size += 1;
	  break;
	case CProfileSchema::tWord:
	  *(u_short*)(raw+size) = *(u_short*)valPtr;
	  size += sizeof(u_short);
	  break;
	case CProfileSchema::tLong:
    case CProfileSchema::tDate:
	  if (m_versionAttributeIndex == i && m_updates && m_updates[i])
	    *(u_long*)(raw+size) = htonl(ntohl(*(u_long*)valPtr)+1);
	  else
	    *(u_long*)(raw+size) = *(u_long*)valPtr;
	  size += sizeof(u_long);
	  break;
	}
    }

  GIVEAWAY_BSTR(*pVal);

//JVP - begin changes 
#ifdef PASSPORT_VERBOSE_MODE_ON
	char szLogString[LOG_STRING_LEN] = "CProfile::get_unencryptedProfile, Exit";
	AddBSTRAsString(*pVal,  szLogString, sizeof(szLogString));
	g_pTSLogger->AddDateTimeAndLog(szLogString);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes 

  return S_OK;
}

STDMETHODIMP CProfile::put_unencryptedProfile(BSTR newVal)
{

//JVP - begin changes 
#ifdef PASSPORT_VERBOSE_MODE_ON
	char szLogString[LOG_STRING_LEN] = "CProfile::put_unencryptedProfile, Enter";
	AddBSTRAsString(newVal,  szLogString, sizeof(szLogString));
	g_pTSLogger->AddDateTimeAndLog(szLogString);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes 

    if (!g_config->isValid())
    {
        AtlReportError(CLSID_Profile, PP_E_NOT_CONFIGUREDSTR,
	           IID_IPassportProfile, PP_E_NOT_CONFIGURED);
        return PP_E_NOT_CONFIGURED;
    }

    //
    //  Clean up all state associated with the previous profile.
    //

    if (m_raw)
    {
        FREE_BSTR(m_raw);
        m_raw = NULL;
    }

    if (m_pos)
    {
        delete [] m_pos;
        m_pos = NULL;
    }

    if (m_bitPos)
    {
        delete [] m_bitPos;
        m_bitPos = NULL;
    }

    if (m_updates)
    {
        for (int i = 0; i < m_schema->Count(); i++)
        {
            if (m_updates[i])
                delete[] m_updates[i];
        }
        delete[] m_updates;
        m_updates = NULL;
    }

    if (!newVal)
    {
        m_valid = FALSE;
        return S_OK;
    }

    // BOY do you have to be careful here.  If you don't
    // call BYTE version, it truncates at first pair of NULLs
    // we also need to expand beyond the key version byte
    DWORD dwByteLen = SysStringByteLen(newVal);
    if (dwByteLen > 2 && newVal[0] == SECURE_FLAG)
    {
        m_secure = TRUE;
        dwByteLen -= 2;
        m_raw = ALLOC_BSTR_BYTE_LEN((LPSTR)newVal + 2,
			                        dwByteLen);
    }
    else
    {
        m_secure = FALSE;
        m_raw = ALLOC_BSTR_BYTE_LEN((LPSTR)newVal,
			                        dwByteLen);
    }

    parse(m_raw, dwByteLen);

//JVP - begin changes 
#ifdef PASSPORT_VERBOSE_MODE_ON
	g_pTSLogger->AddDateTimeAndLog("CProfile::put_unencryptedProfile, Exit");
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes 

    return S_OK;
}

void CProfile::parse(
    LPCOLESTR   raw,
    DWORD       dwByteLen
    )
{
    // How many attributes?
    DWORD cAtts = 0;

    CNexusConfig* cnc = g_config->checkoutNexusConfig();
    m_schema = cnc->getProfileSchema(m_schemaName);
    if (m_schema) m_schema->AddRef();
        cnc->Release();

    if (!m_schema)
    {
        m_valid = FALSE;
        goto Cleanup;
    }

    cAtts = m_schema->Count();

    // Set up the arrays
    m_pos = new UINT[cAtts];
    m_bitPos = new UINT[cAtts];

    if SUCCEEDED(m_schema->parseProfile((LPSTR)raw, dwByteLen, m_pos, m_bitPos, &cAtts))
        m_valid = TRUE;
    else
        m_valid = FALSE;

Cleanup:
    if (m_valid == FALSE) 
    {
        if(g_pAlert)
            g_pAlert->report(PassportAlertInterface::WARNING_TYPE, PM_INVALID_PROFILE,
                            0,NULL, dwByteLen, (LPVOID)raw);
    }
}

STDMETHODIMP CProfile::get_updateString(BSTR *pVal)
{
  if (!pVal)
    return E_INVALIDARG;

  *pVal = NULL;

  if (!m_valid) return S_OK;
  if (!m_schema) return PP_E_NOT_CONFIGURED;

  if (!m_updates)
    return S_OK;

  int size = sizeof(u_long)*2, len;
  short i = 0;

  // Pack up each value, first find out how much space we need
  for (; i < m_schema->Count(); i++)
    {
      if (m_updates[i])
	{
	  size += sizeof(u_short);  // For the index
	  CProfileSchema::AttrType t = m_schema->GetType(i);

	  switch (t)
	    {
	    case CProfileSchema::tText:
	      // How long is the string
	      size += (sizeof(u_short) + ntohs(*(u_short*)m_updates[i]));
	      break;
	    case CProfileSchema::tChar:
	      size += m_schema->GetByteSize(i);
	      break;
	    case CProfileSchema::tByte:
	      size += 1;
	      break;
	    case CProfileSchema::tWord:
	      size += sizeof(u_short);
	      break;
	    case CProfileSchema::tLong:
        case CProfileSchema::tDate:
	      size += sizeof(u_long);
	      break;
	      // no default case needed, it never will be non-null
	    }
	}
    }

  // Ok, now build it up...
  *pVal = ALLOC_BSTR_BYTE_LEN(NULL, size);
  LPSTR raw = (LPSTR) *pVal;

  _bstr_t ml("memberIdLow"), mh("memberIdHigh");
  int iMl, iMh;
  iMl = m_schema->GetIndexByName(ml);
  iMh = m_schema->GetIndexByName(mh);

  if (iMl == -1 || iMh == -1)
    {
      AtlReportError(CLSID_Profile, PP_E_NO_SUCH_ATTRIBUTESTR,
		     IID_IPassportProfile, PP_E_NO_SUCH_ATTRIBUTE);
      return PP_E_NO_SUCH_ATTRIBUTE;
    }

  if (m_schema->GetType(iMl) != CProfileSchema::tLong ||
      m_schema->GetType(iMh) != CProfileSchema::tLong)
    {
      AtlReportError(CLSID_Profile, PP_E_NSA_BADMID,
		     IID_IPassportProfile, PP_E_NO_SUCH_ATTRIBUTE);
      return PP_E_NO_SUCH_ATTRIBUTE;
    }

  *(int*)raw = *(int*) (((LPSTR)m_raw)+m_pos[iMl]);
  *(int*)(raw+sizeof(u_long)) = *(int*) (((LPSTR)m_raw)+m_pos[iMh]);

  size = 2*sizeof(u_long);

  for (i = 0; i < m_schema->Count(); i++)
    {
      if (m_updates[i])
	{
	  *(u_short*)(raw+size) = htons(i);
	  size+=sizeof(u_short);

	  CProfileSchema::AttrType t = m_schema->GetType(i);

	  switch (t)
	    {
	    case CProfileSchema::tText:
	      // How long is the string
	      len = ntohs(*(u_short*)m_updates[i]);
	      memcpy(raw+size, (char*) m_updates[i], len+sizeof(u_short));
	      size += len + sizeof(u_short);
	      break;
	    case CProfileSchema::tChar:
	      memcpy(raw+size, (char*) m_updates[i], m_schema->GetByteSize(i));
	      size += m_schema->GetByteSize(i);
	      break;
	    case CProfileSchema::tByte:
	      *(raw+size) = *(BYTE*)m_updates[i];
	      size += 1;
	      break;
	    case CProfileSchema::tWord:
	      *(u_short*)(raw+size) = *(u_short*)m_updates[i];
	      size += sizeof(u_short);
	      break;
	    case CProfileSchema::tLong:
        case CProfileSchema::tDate:
	      *(u_long*)(raw+size) = *(u_long*)m_updates[i];
	      size += sizeof(u_long);
	      break;
	      // no default case needed, it never will be non-null
	    }
	}
    }

  GIVEAWAY_BSTR(*pVal);
  return S_OK;
}

HRESULT CProfile::incrementVersion()
{
    int size = 0, len, i;
    LPSTR raw = (LPSTR)m_raw;

    if (!m_valid) return S_OK;
    if (!m_schema) return PP_E_NOT_CONFIGURED;

    m_versionAttributeIndex = m_schema->GetIndexByName(L"profileVersion");

    for(i = 0; i < m_versionAttributeIndex; i++)
    {
        CProfileSchema::AttrType t = m_schema->GetType(i);

        switch (t)
        {
        case CProfileSchema::tText:
            // How long is the string
            len = ntohs(*(u_short*)(m_raw+size));
            size += len + sizeof(u_short);
            break;
        case CProfileSchema::tChar:
            size += m_schema->GetByteSize(i);
            break;
        case CProfileSchema::tByte:
            size += 1;
            break;
        case CProfileSchema::tWord:
            size += sizeof(u_short);
            break;
        case CProfileSchema::tLong:
        case CProfileSchema::tDate:
            size += sizeof(u_long);
            break;
        // no default case needed, it never will be non-null
        }
    }

	(*(u_long*)(raw+size)) = htonl(ntohl(*(u_long*)(raw+size)) + 1);

    return S_OK;
}

HRESULT CProfile::get_IsSecure(VARIANT_BOOL *pbIsSecure)
{
    HRESULT hr;

    if(pbIsSecure == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbIsSecure = (m_secure ? VARIANT_TRUE : VARIANT_FALSE);

    hr = S_OK;

Cleanup:

    return hr;
}

BOOL CProfile::IsSecure()
{
    return m_secure;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\passportmanager\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Passport.rc
//
#define IDS_PROJNAME                    100
#define IDR_MANAGER                     101
#define IDR_TICKET                      102
#define IDR_PROFILE                     103
#define IDR_CRYPT                       104
#define IDR_ADMIN                       105
#define IDR_PASSPORTFACTORY             107
#define IDR_FASTAUTH                    108

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           109
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\passportmanager\ticket.h ===
// Ticket.h : Declaration of the CTicket

#ifndef __TICKET_H_
#define __TICKET_H_

#include "resource.h"       // main symbols
#include <asptlb.h>         // Active Server Pages Definitions

//JVP - start
#include "TSLog.h"
extern CTSLog *g_pTSLogger;
//JVP - end

#define  ATTR_PASSPORTFLAGS  L"PassportFlags"
#define  ATTR_SECURELEVEL    L"SecureLevel"
#define  SecureLevelFromSecProp(s)  (s & 0x000000ff)

/////////////////////////////////////////////////////////////////////////////
// CTicket
class ATL_NO_VTABLE CTicket : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CTicket, &CLSID_Ticket>,
	public ISupportErrorInfo,
	public IDispatchImpl<IPassportTicket2, &IID_IPassportTicket2, &LIBID_PASSPORTLib>
{
public:
  CTicket() : m_raw(NULL), m_lastSignInTime(0), 
    m_ticketTime(0), m_valid(FALSE),
    m_bSecureCheckSucceeded(FALSE), m_schemaDrivenOffset(INVALID_OFFSET),
    m_passportFlags(0)
    {
      ZeroMemory(m_memberId, sizeof(m_memberId));

//JVP - begin changes 
#ifdef PASSPORT_VERBOSE_MODE_ON
	g_pTSLogger->Init(NULL, THREAD_PRIORITY_NORMAL);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes 

    }

  ~CTicket()
    {
        if (m_raw)
            SysFreeString(m_raw);
    }

public:

DECLARE_REGISTRY_RESOURCEID(IDR_TICKET)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTicket)
	COM_INTERFACE_ENTRY(IPassportTicket2)
	COM_INTERFACE_ENTRY(IPassportTicket)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// ISupportsErrorInfo
  STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IPassportTicket
public:
	STDMETHOD(DoSecureCheck)(/*[in]*/ BSTR bstrSec);
//	int memberIdLow(void);
//	int memberIdHigh(void);
//    LPCWSTR memberId(void);
	BOOL IsSecure();
  ULONG GetPassportFlags();
//  HRESULT get_IsSecure(VARIANT_BOOL* pbIsSecure);
  STDMETHOD(get_TicketTime)(/*[out, retval]*/ long *pVal);
  STDMETHOD(get_SignInTime)(/*[out, retval]*/ long *pVal);
  STDMETHOD(get_SignInServer)(/*[out, retval]*/ BSTR *pVal);
  STDMETHOD(get_HasSavedPassword)(/*[out, retval]*/ VARIANT_BOOL *pVal);
  STDMETHOD(get_MemberIdHigh)(/*[out, retval]*/ int *pVal);
  STDMETHOD(get_MemberIdLow)(/*[out, retval]*/ int *pVal);
  STDMETHOD(get_MemberId)(/*[out, retval]*/ BSTR *pVal);
  STDMETHOD(get_TimeSinceSignIn)(/*[out, retval]*/ int *pVal);
  STDMETHOD(get_TicketAge)(/*[out, retval]*/ int *pVal);
  STDMETHOD(get_IsAuthenticated)(/*[in]*/ ULONG timeWindow, /*[in]*/ VARIANT_BOOL forceLogin, /*[in,optional]*/ VARIANT CheckSecure, /*[out, retval]*/ VARIANT_BOOL *pVal);
  STDMETHOD(get_unencryptedTicket)(/*[out, retval]*/ BSTR *pVal);
  STDMETHOD(put_unencryptedTicket)(/*[in]*/ BSTR newVal);
  STDMETHOD(get_Error)(/*[out,retval]*/ long *pVal);

// IPassportTicket2
  STDMETHOD(GetProperty)(/*[in]*/ BSTR propName, /*[out, retval]*/ VARIANT* pVal);
  STDMETHOD(SetTertiaryConsent)(BSTR bstrConsent);
  STDMETHOD(needConsent)(/*out*/ULONG* pStatus, /*[out, retval]*/ NeedConsentEnum* pNeedConsent);

// none COM functions
enum{
  MSPAuth = 1, 
  MSPSecAuth, 
  MSPConsent
};

  // flags parameter is reserved for future use, must be 0 for this version
  STDMETHOD(get_unencryptedCookie)(/*in*/ ULONG cookieType, /*in*/ ULONG flags, /*[out, retval]*/ BSTR* pVal);
  
protected:
    BSTR    m_raw;
    BOOL    m_valid;
    BOOL    m_savedPwd;
    WCHAR   m_memberId[20];
    int     m_mIdLow;
    int     m_mIdHigh;
    long    m_flags;
    time_t  m_ticketTime;
    time_t  m_lastSignInTime;

    CComBSTR   m_bstrTertiaryConsent;

    void parse(LPCOLESTR raw, DWORD dwByteLen, DWORD* pcParsed);
private:
   // the bag for the schema driven fields
   CTicketPropertyBag   m_PropBag;
   DWORD                m_schemaDrivenOffset;     // the offset of schema driven data -- the data introduced after 1.3x
   ULONG                m_passportFlags;
   
	BOOL m_bSecureCheckSucceeded;
};

#endif //__TICKET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\passportmanager\registryconfig.h ===
// RegistryConfig.h: interface for the CRegistryConfig class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_REGISTRYCONFIG_H__74EB2515_E239_11D2_95E9_00C04F8E7A70__INCLUDED_)
#define AFX_REGISTRYCONFIG_H__74EB2515_E239_11D2_95E9_00C04F8E7A70__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "BstrHash.h"
#include "CoCrypt.h"
#include "ptstl.h"

typedef PtStlMap<int,CCoCrypt*> INT2CRYPT;
typedef PtStlMap<int,time_t> INT2TIME;

class CRegistryConfig  
{
 public:
  CRegistryConfig(LPSTR szSiteName = NULL);
  virtual ~CRegistryConfig();
  
  BOOL            isValid() { return m_valid; }

  CCoCrypt*       getCrypt(int keyNum, time_t* validUntil);
  CCoCrypt*       getCurrentCrypt() { return getCrypt(m_currentKey,NULL); }
  int             getCurrentCryptVersion() { return m_currentKey; }

  int             getSiteId() { return m_siteId; }

  // Return a description of the failure
  BSTR            getFailureString();

  // Shout out to all my LISP homies
  BOOL forceLoginP() { return m_forceLogin; }
  BOOL setCookiesP() { return m_setCookies; }
  BOOL bInDA() { return m_bInDA; }
  
  LPSTR getHostName() { return m_hostName; }
  LPSTR getHostIP() { return m_hostIP; }
  LPSTR getTicketDomain() { return m_ticketDomain; }
  LPSTR getProfileDomain() { return m_profileDomain; }
  LPSTR getSecureDomain() { return m_secureDomain; }
  LPSTR getTicketPath() { return m_ticketPath; }
  LPSTR getProfilePath() { return m_profilePath; }
  LPSTR getSecurePath() { return m_securePath; }
  ULONG getDefaultTicketAge() { return m_ticketAge; }
  USHORT getDefaultLCID() { return m_lcid; }

  LPWSTR getDefaultCoBrand() { return m_coBrand; }
  LPWSTR getDefaultRU() { return m_ru; }

  BOOL  DisasterModeP() { return m_disasterMode; }
  LPSTR getDisasterUrl() { return m_disasterUrl; }
  int getSecureLevel(){ return m_secureLevel;};

  CRegistryConfig* AddRef();
  void             Release();
  HRESULT GetCurrentConfig(LPCWSTR name, VARIANT* pVal);

  static long GetHostName(LPSTR szSiteName, 
                          LPSTR szHostNameBuf, 
                          LPDWORD lpdwHostNameBufLen);

 protected:
  void             setReason(LPWSTR reason);

  BOOL             readCryptoKeys(HKEY hkPassport);

  BOOL             m_disasterMode;
  char*            m_hostName;
  char*            m_hostIP;
  char*            m_disasterUrl;
  char*            m_ticketDomain;
  char*            m_profileDomain;
  char*            m_secureDomain;
  char*            m_ticketPath;
  char*            m_profilePath;
  char*            m_securePath;
  WCHAR*           m_coBrand;
  WCHAR*           m_ru;
  BOOL             m_setCookies;
  ULONG            m_ticketAge;
  BOOL             m_forceLogin;
  BOOL             m_bInDA;
  USHORT           m_lcid;

  INT2CRYPT        m_crypts;
  INT2TIME         m_cryptValidTimes;
  int              m_currentKey;

  int              m_siteId;

  BOOL             m_valid;

  BSTR             m_szReason;

  long             m_refs;
  int              m_secureLevel;

  HKEY             m_hkPassport;

};

#endif // !defined(AFX_REGISTRYCONFIG_H__74EB2515_E239_11D2_95E9_00C04F8E7A70__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\passportmanager\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__41651BE6_A5C8_11D2_95DF_00C04F8E7A70__INCLUDED_)
#define AFX_STDAFX_H__41651BE6_A5C8_11D2_95DF_00C04F8E7A70__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef STRICT
#define STRICT
#endif
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_FREE_THREADED

// We'll use import to pick up ASP, so make sure includes don't
// accidentally beat us to it
#define ___asptlb_h__

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <comdef.h>
#include "commd5.h"

#include "BstrDebug.h"

#ifdef MEM_DBG
  #define _CRTDBG_MAP_ALLOC
  #include <crtdbg.h>
#endif

#include "PassportConfiguration.h"
#include "Monitoring.h"
#include "PassportTypes.h"

extern CPassportConfiguration* g_config;
// extern CProfileSchema*         g_authSchema;
HRESULT GetGlobalCOMmd5(IMD5 ** ppMD5);

#define MEMBERNAME_INDEX 0
#define LANGPREF_INDEX   8

#import "asp.dll" no_namespace

using namespace ATL;

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__41651BE6_A5C8_11D2_95DF_00C04F8E7A70__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\passportmanager\tslog.cpp ===
/////////////////////////////////////////////////////////////////////////////
//File :  TSLog.cpp    Thread safe logger class
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "TSLog.h"
#include <comdef.h>

_TCHAR g_szLogFileName[MAX_PATH];

BOOL g_bVerboseModeOn = FALSE;

/////////////////////////////////////////////////////////////////////////////
// Function name        : AddStringToString
// Description      : add a "," then concat szIn to the end of szStr
//                                              if either string pointer is null, just return
// Return type          : void
// Argument         : char *szIn
// Argument         : char * szStr
// Argument         : long lMaxLen
/////////////////////////////////////////////////////////////////////////////
void AddStringToString(char *szIn,  char * szStr, long lMaxLen)
{
        if (!g_bVerboseModeOn)
                return;

        if ( (NULL == szIn) || (NULL ==szStr) )
                return;

        // default is blank
        char szTemp[1024] = ", ";

        if ( NULL != szIn )
        {
            //  1 is already used for the ',' and 1 for the terminating \0
            strncpy(szTemp + 1, szIn, sizeof(szTemp) - 2);
        }

        //make sure not to overflow the string
        long lStrLen = strlen(szStr);
        if ( lStrLen < lMaxLen )
                strncat(szStr, szTemp, (lMaxLen - lStrLen) );
}

/////////////////////////////////////////////////////////////////////////////
// Function name        : AddBSTRAsString
// Description      : Append a "," and then the value of the BSTR
//                                              (as a string) to the end of the given string
// Return type          : void
// Argument         : BSTR bsIn
// Argument         : char * szStr
// Argument         : long lMaxLen
/////////////////////////////////////////////////////////////////////////////
void AddBSTRAsString(BSTR bsIn,  char * szStr, long lMaxLen)
{
        if (!g_bVerboseModeOn)
                return;

        // init witl blank for empty str
        char szTemp[1024] = ", ";

        if ( NULL == szStr )
                return;

        if ( NULL != bsIn )
        {
            // replace blank with bsIn
            strncpy(szTemp + 1, (char *) _bstr_t(bsIn), sizeof(szTemp) - 2);
        }

        //make sure not to overflow the string
        long lStrLen = strlen(szStr);
        if ( lStrLen < lMaxLen )
            strncat(szStr, szTemp, (lMaxLen - lStrLen) );
}

/////////////////////////////////////////////////////////////////////////////
// Function name        : AddDoubleAsString
// Description      : Append a "," and then the value of the double
//                                              (as a string) to the end of the given string
// Return type          : void
// Argument         : double dIn
// Argument         : char * szStr
// Argument         : long lMaxLen
/////////////////////////////////////////////////////////////////////////////
void AddDoubleAsString(double dIn,  char * szStr, long lMaxLen)
{
        if (!g_bVerboseModeOn)
                return;

        if ( NULL == szStr )
                return;

        char szTemp[1024] = "";
        sprintf(szTemp,",%.4f", dIn);

        //make sure not to overflow the string
        long lStrLen = strlen(szStr);
        if ( lStrLen < lMaxLen )
                strncat(szStr, szTemp, (lMaxLen - lStrLen) );
}

/////////////////////////////////////////////////////////////////////////////
// Function name        : AddULAsString
// Description      : Append a "," and then the value of the unsigned long
//                                              (as a string) to the end of the given string
// Return type          : void
// Argument         : unsigned long lIn
// Argument         : char * szStr
// Argument         : long lMaxLen
/////////////////////////////////////////////////////////////////////////////
void AddULAsString(unsigned long lIn,  char * szStr, long lMaxLen)
{
        if (!g_bVerboseModeOn)
                return;

        if ( NULL == szStr )
                return;

        char szTemp[1024] = "";
        sprintf(szTemp,",%lu", lIn);

        //make sure not to overflow the string
        long lStrLen = strlen(szStr);
        if ( lStrLen < lMaxLen )
            strncat(szStr, szTemp, (lMaxLen - lStrLen) );
}

/////////////////////////////////////////////////////////////////////////////
// Function name        : AddLongAsString
// Description      : Append a "," and then the value of the long
//                                              (as a string) to the end of the given string
// Return type          : void
// Argument         : long lIn
// Argument         : char * szStr
// Argument         : long lMaxLen
/////////////////////////////////////////////////////////////////////////////
void AddLongAsString(long lIn,  char * szStr, long lMaxLen)
{
        if (!g_bVerboseModeOn)
                return;

        if ( NULL == szStr )
                return;

        char szTemp[1024] = "";
        sprintf(szTemp,",%ld", lIn);

        //make sure not to overflow the string
        long lStrLen = strlen(szStr);
        if ( lStrLen < lMaxLen )
                strncat(szStr, szTemp, (lMaxLen - lStrLen) );
}

/////////////////////////////////////////////////////////////////////////////
// Function name    : AddVariantBoolAsString
// Description      : Append a "," and then the value of the VARIANT_BOOL
//                                              (as a string) to the end of the given string
// Return type          : void
// Argument         : VARIANT_BOOL vIn
// Argument         : char * szStr
// Argument         : long lMaxLen
/////////////////////////////////////////////////////////////////////////////
void AddVariantBoolAsString(VARIANT_BOOL vIn, char * szStr, long lMaxLen)
{
        if (!g_bVerboseModeOn)
                return;

        if ( NULL == szStr )
                return;

        char szTemp[1024];

        if ( 0 == vIn )
                strcpy(szTemp,",FALSE");
        else
                strcpy(szTemp,",TRUE");

        //make sure not to overflow the string
        long lStrLen = strlen(szStr);
        if ( lStrLen < lMaxLen )
                strncat(szStr, szTemp, (lMaxLen - lStrLen) );
}

/////////////////////////////////////////////////////////////////////////////
// Function name        : AddVariantAsString
// Description      : Append a "," and then the value of the variant
//                                              (as a string) to the end of the given string
// Return type          : void
// Argument         : VARIANT vIn
// Argument         : char * szStr
// Argument         : long lMaxLen
/////////////////////////////////////////////////////////////////////////////
void AddVariantAsString(VARIANT vIn, char * szStr, long lMaxLen)
{
        if (!g_bVerboseModeOn)
                return;

        if ( NULL == szStr )
                return;

        char szTemp[1024] = ", ", *pszVal = szTemp + 1;

        switch ( vIn.vt )
        {
                case VT_UI1:
                        sprintf(pszVal,"%u", vIn.bVal);
                        break;
                case VT_UI1 | VT_BYREF:
                        sprintf(pszVal,"%u", *vIn.pbVal);
                        break;

                case VT_I2:
                        sprintf(pszVal,"%d", vIn.iVal);
                        break;
                case VT_I4:
                        sprintf(pszVal,"%ld", vIn.lVal);
                        break;
                case VT_I2 | VT_BYREF:
                        sprintf(pszVal,"%d", *vIn.piVal);
                        break;
                case VT_I4 | VT_BYREF:
                        sprintf(pszVal,"%ld", *vIn.plVal);
                        break;

                case VT_BOOL:
                        if ( 0 == vIn.boolVal )
                                sprintf(pszVal,"FALSE");
                        else
                                sprintf(pszVal,"TRUE");
                        break;
                case VT_BOOL | VT_BYREF:
                        if ( 0 == *vIn.pboolVal )
                                sprintf(pszVal,"FALSE");
                        else
                                sprintf(pszVal,"TRUE");
                        break;

                case VT_BSTR:
                        strncpy(pszVal, _bstr_t(vIn.bstrVal), sizeof(szTemp) - 2);
                        break;
                case VT_BSTR | VT_BYREF:
                        strncpy(pszVal, _bstr_t(*vIn.pbstrVal), sizeof(szTemp) - 2);
                        break;

                case VT_R4:
                        sprintf(pszVal,"%.4f", vIn.fltVal);
                        break;
                case VT_R8:
                        sprintf(pszVal,"%.4f", vIn.dblVal);
                        break;
                case VT_R4 | VT_BYREF:
                        sprintf(pszVal,"%.4f", *vIn.pfltVal);
                        break;
                case VT_R8 | VT_BYREF:
                        sprintf(pszVal,"%.4f", *vIn.pdblVal);
                        break;
                default:
                        break;
        }//switch ( vIn.vt )

        //make sure not to overflow the string
        long lStrLen = strlen(szStr);
        if ( lStrLen < lMaxLen )
                strncat(szStr, szTemp, (lMaxLen - lStrLen) );

}

/////////////////////////////////////////////////////////////////////////////
//  CTSLog

/////////////////////////////////////////////////////////////////////////////
// Function name        : CTSLog::CTSLog
// Description      : Constructor
// Return type          : NA
// Argument         : void
/////////////////////////////////////////////////////////////////////////////
CTSLog::CTSLog( void )
{
        m_bInit                         = FALSE;
        m_bQuit                         = FALSE;
        m_bVerboseModeOn        = FALSE;
        m_ulChildThread         = 0;
        m_uThreadAddr           = 0;
        m_ulNumPoolStrings      = 0;
        m_hPoolSemaphore        = NULL;
        m_hQSemaphore           = NULL;
        m_hFileSemaphore        = NULL;
        //JVP 2/23/2000 - let's start off with a valid name
        _tcscpy(g_szLogFileName, kszLogFileName);
}

/////////////////////////////////////////////////////////////////////////////
// Function name        : CTSLog::~CTSLog
// Description      : Destructor
// Return type          : NA
// Argument         : void
/////////////////////////////////////////////////////////////////////////////
CTSLog::~CTSLog( void )
{
        //make sure that we shutdown everything properly
        Close();
}

/////////////////////////////////////////////////////////////////////////////
// Function name        : CTSLog::Init
// Description      : Initialize the logger class, creates semaphores, starts
//                                              the logger thread, allocates strings for the
//                                              buffer pool
// Return type          : BOOL
// Argument         : _TCHAR * pFileName
// Argument         : int nPriority
/////////////////////////////////////////////////////////////////////////////
BOOL CTSLog::Init(_TCHAR * pFileName, int nPriority )
{
        ULONG j;

        //if verbose mode is not on, then check the registry
        if ( FALSE == m_bVerboseModeOn )
        {
                m_bVerboseModeOn = IsRegistryVerboseSet();
                g_bVerboseModeOn = m_bVerboseModeOn;
        }


        if ( TRUE == m_bInit )//let's only do this once
        {
                return TRUE;
        }

        SECURITY_ATTRIBUTES sa;

        //security attributes for our shared file semaphore handle
        sa.nLength = sizeof(SECURITY_ATTRIBUTES);
        sa.lpSecurityDescriptor = NULL;
        sa.bInheritHandle = TRUE;

        _tzset();
        m_bInit = FALSE;

        //initial value is zero because we really want to wait till somebody puts
        //something in the queue
        m_hQSemaphore    = CreateSemaphore( NULL, 0, LONG_MAX, NULL );

        m_hPoolSemaphore = CreateSemaphore( NULL, 0, LONG_MAX, NULL );


        //initial value is one because nobody is using the file when we start
        m_hFileSemaphore = CreateSemaphore( &sa, 1, LONG_MAX, kszFileSemaphoreName );


        InitializeCriticalSection( &m_outMutex );
        InitializeCriticalSection( &m_poolMutex );

        m_bQuit = FALSE;
        m_ulChildThread = 0;

        if ( (NULL == m_hQSemaphore) || (NULL == m_hFileSemaphore) || (NULL == m_hPoolSemaphore) )
                goto INIT_CLEANUP_FAIL;

        char * pStr;
        m_ulNumPoolStrings = 0;
        for ( j = 0; j < NUM_POOL_STRINGS ; j ++ )
        {
                pStr = (char*)malloc(LOG_STRING_LEN);
                if ( NULL != pStr )
                {
                        pushPool( pStr );
                        m_ulNumPoolStrings++;
                }
        }

        //JVP - 2/29/2000
        //need to do this here, because we need the file semaphore in GetLogfileName
        _tcscpy(g_szLogFileName, kszLogFileName);
        GetLogfileName();

        //
        //  Lock the DLL until the thread exits.
        //

        _Module.Lock();

        //
        //  Start thread.
        //

        m_bQuit = FALSE;
        m_ulChildThread = (HANDLE) _beginthreadex( NULL, 0, LoggerThread , (void *) this , 0, &m_uThreadAddr);

        if ( 0 == m_ulChildThread )//thread failed to start
                goto INIT_CLEANUP_FAIL;

        long lRetVal;

        switch ( nPriority )
        {
                case THREAD_PRIORITY_ABOVE_NORMAL:
                case THREAD_PRIORITY_BELOW_NORMAL:
                case THREAD_PRIORITY_HIGHEST:
                case THREAD_PRIORITY_IDLE:
                case THREAD_PRIORITY_LOWEST:
                case THREAD_PRIORITY_NORMAL:
                case THREAD_PRIORITY_TIME_CRITICAL:
                        lRetVal = SetThreadPriority( (void *) m_ulChildThread, nPriority);
                        break;
                default://if we were not given a valid priority use normal
                        lRetVal = SetThreadPriority( (void *) m_ulChildThread, THREAD_PRIORITY_NORMAL);
        }//switch ( nPriority )

        m_bInit = TRUE;

        return TRUE;

INIT_CLEANUP_FAIL:

                for ( j = 0; j < m_ulNumPoolStrings ; j ++ )
                {
                        pStr = popPool(100);
                        if ( NULL != pStr )
                                free(pStr);
                }

                if ( m_hQSemaphore )
                        CloseHandle( m_hQSemaphore );
                if ( m_hFileSemaphore )
                        CloseHandle( m_hFileSemaphore );
                if ( m_hPoolSemaphore )
                        CloseHandle( m_hPoolSemaphore );

        return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Function name        : CTSLog::Close
// Description      : close the logger class, make sure the thread dies off
//                                              empty the output queue, delete the strings for the
//                                              pool, close the semaphores, and mutexes
// Return type          : void
/////////////////////////////////////////////////////////////////////////////
void CTSLog::Close()
{
        ULONG j;
        char * pStr = NULL;

        if ( FALSE == m_bInit )
                return;

        if ( 0 == m_ulChildThread )//no thread
                return;

        //we'll signal the child thread that it's time to quit
        m_bQuit = TRUE;

        //we'll push an empty string onto the child thread's queue so that it will unblock
        //and then it will check m_bQuit and then exit gracefully
        pStr = popPool(100);
        if ( NULL != pStr )
        {
                sprintf(pStr,"");
                pushLogQueue( pStr );
        }

        //Let's set the child thread's priority up high and then give it a few cycles
        //to finish whatever it has to do (Then if it doesn't complete we'll KILL it)
        SetThreadPriority( (void *) m_ulChildThread, THREAD_PRIORITY_TIME_CRITICAL);
        Sleep(100);

        DWORD ExitCode ;
        DWORD Error;
        ULONG lCount = 0;
        do
        {
                //if the child does not exit itself after a few tries, KILL IT
                if ( lCount++ > 25 )
                {
                        TerminateThread( (void *)m_ulChildThread , 1);
                        break;
                }
                if ( 0 == GetExitCodeThread( (void *)m_ulChildThread, &ExitCode ) )
                        Error = GetLastError();

                if ( STILL_ACTIVE == ExitCode )
                        Sleep(100); //we do not want a tight loop so sleep for a while
        }while ( STILL_ACTIVE == ExitCode );

        m_ulChildThread = 0;

        //get any strings that are left in the output queue
        //and push them back into the pool
        EnterCriticalSection( &m_outMutex );
        lCount = m_outQueue.size();
        for ( j=0 ; j < lCount ; j++)
        {
                pStr = m_outQueue.front();//get the string from the queue
                m_outQueue.pop();//remove the item
                pushPool ( pStr );
        }
        LeaveCriticalSection( &m_outMutex );

        //empty out the pool of strings and delete them
        //the popPool function uses the semaphore to
        //synchronize the access to the pool
        for ( j = 0; j < m_ulNumPoolStrings ; j ++ )
        {
                //we can't wait forever here, so set the timeout
                pStr = popPool(1000);
                if ( NULL != pStr )
                        free(pStr);
        }

        //cleanup the mutexes and semaphores
        EnterCriticalSection( &m_outMutex );
        CloseHandle( m_hQSemaphore );
        LeaveCriticalSection( &m_outMutex );
        DeleteCriticalSection( &m_outMutex );

        EnterCriticalSection( &m_poolMutex );
        CloseHandle( m_hPoolSemaphore );
        LeaveCriticalSection( &m_poolMutex );
        DeleteCriticalSection( &m_poolMutex );

        //finally, set our init flag to false
        m_bInit = FALSE;

        //
        //  We're doing everything we need to do.
        //  Let's release the DLL lock we took in
        //  Init().
        //

        _Module.Unlock();

}


/////////////////////////////////////////////////////////////////////////////
// Function name        : __stdcall CTSLog::LoggerThread
// Description      : This is where the actual logging get's done.
// Return type          : unsigned int
// Argument         : void * pArg
/////////////////////////////////////////////////////////////////////////////
unsigned int __stdcall CTSLog::LoggerThread(void * pArg)
{
        CTSLog  *pParent = (CTSLog *) pArg;

        char * pStr;
        char szEOL[] = ",|\r\n";
        DWORD dwRetVal;
        unsigned long wWritten;

        //wait until our parent sets the flag to tell us to quit
        while ( FALSE == pParent->m_bQuit )
        {
                //we wait for something to be put into the output queue
                dwRetVal = WaitForSingleObject( pParent->m_hQSemaphore, INFINITE );
                if (WAIT_OBJECT_0 == dwRetVal )//OK we got something in the queue
                {
                        //make sure nobody can access the queue while we get the
                        //first item
                        EnterCriticalSection( &pParent->m_outMutex );
                        pStr = pParent->m_outQueue.front();//get the string from the queue
                        pParent->m_outQueue.pop();//remove the item
                        LeaveCriticalSection( &pParent->m_outMutex );

                        if ( NULL != pStr )//OK now we can log to the file
                        {
                                        HANDLE hFile = INVALID_HANDLE_VALUE;

                                        //don't log the string if it is empty
                                        //the parent puts an empty string in the queue to allow us to exit gracefully
                                        if ( strlen(pStr) > 0 )
                                        {
                                                //we need to get access to the file semaphore before we attempt to open the file
                                                //many copies of this thread may be running and this is how we synchronize the
                                                //file access
                                                dwRetVal = WaitForSingleObject( pParent->m_hFileSemaphore, INFINITE );

                                                //NOTES:
                                                //kszLogFileName - name of the file
                                                //GENERIC_WRITE - Data can be written and the file pointer moved
                                                //OPEN_ALWAYS - Opens the file if it exists, creates it if it does not
                                                //kdwNoFileShare - the file cannot be shared. Subsequent open operations on the object will fail, until the handle is closed.
                                                //File Attributes - FILE_ATTRIBUTE_NORMAL can binary or with FILE_FLAG_WRITE_THROUGH to get more robust writing at the expense of more disk thrashing
                                                //Template file - NULL don't use it

                                                hFile = CreateFile(g_szLogFileName, GENERIC_WRITE, kdwNoFileShare, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL /*| FILE_FLAG_WRITE_THROUGH*/ , NULL);
                                                if ( INVALID_HANDLE_VALUE != hFile )
                                                {
                                                        //go to the end of the file
                                                        SetFilePointer(hFile, 0 , NULL , FILE_END);

                                                        //write out the string
                                                        WriteFile(hFile, pStr, strlen(pStr), &wWritten, NULL);
                                                        //add a cariage return and line feed
                                                        WriteFile(hFile, szEOL, strlen(szEOL), &wWritten, NULL);

                                                        CloseHandle(hFile);
                                                }
                                                //ok we are done with the file, so let the next thread have access to it
                                                ReleaseSemaphore( pParent->m_hFileSemaphore, 1, NULL );
                                        }//if ( "" != pStr )

                                        //always push the string back into the pool of strings
                                        pParent->pushPool ( pStr );

                        }//if ( NULL != pStr )//OK now we can log to the file
                }//if (WAIT_OBJECT_0 == dwRetVal )
        }//while ( FALSE == pParent->m_bQuit )
        _endthreadex(0);//cleanup
        return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\passportmanager\ticket.cpp ===
// Ticket.cpp : Implementation of CTicket
#include "stdafx.h"
#include "Passport.h"
#include "Ticket.h"
#include <time.h>
#include <nsconst.h>
#include "helperfuncs.h"

// gmarks
#include "Monitoring.h"

/////////////////////////////////////////////////////////////////////////////
// CTicket

STDMETHODIMP CTicket::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] = 
    {
        &IID_IPassportTicket,
    };
    for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}

STDMETHODIMP CTicket::SetTertiaryConsent(BSTR bstrConsent)
{
   _ASSERT(m_raw);

   if(!m_valid ) return S_FALSE;
   if(!bstrConsent) return E_INVALIDARG;

   HRESULT hr = S_OK;
   
   if(SysStringByteLen(bstrConsent) != sizeof(long) * 4 ||
      memcmp(m_raw, bstrConsent, sizeof(long) * 2) != 0 )
      hr = E_INVALIDARG;
   else
   {
      try{
         m_bstrTertiaryConsent = bstrConsent;
      }
      catch(...)
      {
         hr = E_OUTOFMEMORY;
      }
   }
      
   return hr;
}

HRESULT CTicket::needConsent(ULONG* pStatus, NeedConsentEnum* pNeedConsent)
{
   NeedConsentEnum  ret = NeedConsent_Undefined;
   ULONG status = 0;

   if (m_bstrTertiaryConsent && SysStringByteLen(m_bstrTertiaryConsent) >= sizeof(long) * 4)
   {
      ULONG* pData = (ULONG*)(BSTR)m_bstrTertiaryConsent;
      status = (ntohl(*(pData + 3)) & k_ulFlagsConsentCookieMask);
      ret = NeedConsent_Yes;
   }
   else
   {
      TicketProperty prop;

      if (S_OK != m_PropBag.GetProperty(ATTR_PASSPORTFLAGS, prop))   // 1.X ticket, with no flags in it
      {
         goto Exit;
      }      
      
      ULONG flags = GetPassportFlags();

      if(flags & k_ulFlagsConsentCookieNeeded)
      {
         ret = NeedConsent_Yes;
      }
      else
         ret = NeedConsent_No;
         
      status = (flags & k_ulFlagsConsentCookieMask);
   }

Exit:
   if(pNeedConsent)
      *pNeedConsent = ret;
   
   if (pStatus)
      *pStatus = status;
   
   return S_OK;
}
  
STDMETHODIMP CTicket::get_unencryptedCookie(ULONG cookieType, ULONG flags, BSTR *pVal)
{
//JVP - begin changes 
#ifdef PASSPORT_VERBOSE_MODE_ON
	char szLogString[LOG_STRING_LEN] = "CTicket::get_unencryptedCookie";
	AddBSTRAsString(m_raw,  szLogString, sizeof(szLogString));
	g_pTSLogger->AddDateTimeAndLog(szLogString);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes 

    if (!m_raw)   return S_FALSE;
    
    HRESULT   hr = S_OK;

    if (!pVal || flags != 0) return E_INVALIDARG;
    
    switch(cookieType)
    {
    case MSPAuth:
      *pVal = SysAllocStringByteLen((LPSTR)m_raw, SysStringByteLen(m_raw));

      if (*pVal)
      {
         // if the secure flags is on, we should turn it off for this cookie always
         TicketProperty prop;

         if (S_OK == m_PropBag.GetProperty(ATTR_PASSPORTFLAGS, prop))
         {
            if (prop.value.vt == VT_I4 && ((prop.value.lVal & k_ulFlagsSecuredTransportedTicket) != 0))
               // we need to turn off the bit
            {
               ULONG l = prop.value.lVal;
               l &= (~k_ulFlagsSecuredTransportedTicket); // unset the bit

               // put the modified flags into the buffer.
               ULONG* pL = (ULONG*)(((PBYTE)(*pVal)) + m_schemaDrivenOffset + prop.offset);
               *pL = htonl(l);
            }
         }
      }
     
      break;

    case MSPSecAuth:

      // ticket should be long enough
      _ASSERT(SysStringByteLen(m_raw) > sizeof(long) * 3);

      // the first 3 long fields of the ticket
      // format:
      //  four bytes network long - low memberId bytes
      //  four bytes network long - high memberId bytes
      //  four bytes network long - time of last refresh
      //
      
      // generate a shorter version of the cookie for secure signin
      *pVal = SysAllocStringByteLen((LPSTR)m_raw, sizeof(long) * 3);
      
       break;

    case MSPConsent:

      // ticket should be long enough
      _ASSERT(SysStringByteLen(m_raw) > sizeof(long) * 3);

      // check if there is consent 
      if (GetPassportFlags() & k_ulFlagsConsentStatus)
      {
         // the first 3 long fields of the ticket
         // format:
         //  four bytes network long - low memberId bytes
         //  four bytes network long - high memberId bytes
         //  four bytes network long - time of last refresh
         //
         // plus the consent flags -- long
         // 
      
         // generate a shorter version of the cookie for secure signin
         *pVal = SysAllocStringByteLen((LPSTR)m_raw, sizeof(long) * 4);
      
         // plus the consent flags -- long
         // 
         if (*pVal)
         {
            long* pl = (long*)pVal;
            // we mask the flags, and put into the cookie 
            *(pl + 3) = htonl(GetPassportFlags() & k_ulFlagsConsentCookieMask);
         }
      }
      else
      {
         *pVal = NULL;
         hr = S_FALSE;
      }
      
       break;

    default:
      hr = E_INVALIDARG;
      break;
    }

    if (*pVal == 0 && hr == S_OK)
      hr = E_OUTOFMEMORY;

    return hr;
 }

STDMETHODIMP CTicket::get_unencryptedTicket(BSTR *pVal)
{
//JVP - begin changes 
#ifdef PASSPORT_VERBOSE_MODE_ON
	char szLogString[LOG_STRING_LEN] = "CTicket::get_unencryptedTicket";
	AddBSTRAsString(m_raw,  szLogString, sizeof(szLogString));
	g_pTSLogger->AddDateTimeAndLog(szLogString);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes 
    *pVal = SysAllocStringByteLen((LPSTR)m_raw, SysStringByteLen(m_raw));

    return S_OK;
}

STDMETHODIMP CTicket::put_unencryptedTicket(BSTR newVal)
{

//JVP - begin changes 
#ifdef PASSPORT_VERBOSE_MODE_ON
	char szLogString[LOG_STRING_LEN] = "CTicket::put_unencryptedTicket, Enter";
	AddBSTRAsString(m_raw,  szLogString, sizeof(szLogString));
	g_pTSLogger->AddDateTimeAndLog(szLogString);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes 
    DWORD   dw13Xlen = 0;

    if (m_raw)
    {
        SysFreeString(m_raw);
        m_raw = NULL;
    }

    if (!newVal)
    {
        m_valid = FALSE;
        return S_OK;
    }

    m_bSecureCheckSucceeded = FALSE;

    // BOY do you have to be careful here.  If you don't
    // call BYTE version, it truncates at first pair of NULLs
    // we also need to go past the key version byte
    DWORD dwByteLen = SysStringByteLen(newVal);
    {   
        m_raw = SysAllocStringByteLen((LPSTR)newVal,
                                      dwByteLen);
    }

    // parse the 1.3X ticket data
    parse(m_raw, dwByteLen, &dw13Xlen);

    // parse the schema driven data
    if (dwByteLen > dw13Xlen) // more data to parse
    {
       // the offset related to the raw data
       m_schemaDrivenOffset = dw13Xlen;

       // parse the schema driven properties
       LPCSTR  pData = (LPCSTR)(LPWSTR)m_raw;
       pData += dw13Xlen;
       dwByteLen -= dw13Xlen;
       
       // parse the schema driven fields
       CNexusConfig* cnc = g_config->checkoutNexusConfig();
       CTicketSchema* pSchema = cnc->getTicketSchema(NULL);

       if ( pSchema )
       {
           HRESULT hr = pSchema->parseTicket(pData, dwByteLen, m_PropBag);

           // passport flags is useful, should treat it special
           TicketProperty prop;
           if (S_OK == m_PropBag.GetProperty(ATTR_PASSPORTFLAGS, prop))
           {
              if (prop.value.vt == VT_I4)
                 m_passportFlags = prop.value.lVal;
           }
           
           /*
           if (FAILED(hr) )
            event log
           */
       }
    }
         

//JVP - begin changes 
#ifdef PASSPORT_VERBOSE_MODE_ON
	strcpy(szLogString, "CTicket::put_unencryptedTicket, Exit");
	AddBSTRAsString(m_raw,  szLogString, sizeof(szLogString));
	g_pTSLogger->AddDateTimeAndLog(szLogString);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes 

    return S_OK;
}

STDMETHODIMP CTicket::get_IsAuthenticated(
    ULONG           timeWindow, 
    VARIANT_BOOL    forceLogin, 
    VARIANT         SecureLevel, 
    VARIANT_BOOL*   pVal
    )
{

//JVP - begin changes 
#ifdef PASSPORT_VERBOSE_MODE_ON
	char szLogString[LOG_STRING_LEN] = "CTicket::get_IsAuthenticated, Enter";
	AddULAsString          ( timeWindow,  szLogString, sizeof(szLogString));
	AddVariantBoolAsString ( forceLogin, szLogString, sizeof(szLogString) );
	AddLongAsString        ( m_lastSignInTime,  szLogString, sizeof(szLogString));
	AddLongAsString        ( m_ticketTime,  szLogString, sizeof(szLogString));
	g_pTSLogger->AddDateTimeAndLog(szLogString);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes 

    if(!pVal)
      return E_INVALIDARG;
    
    *pVal = VARIANT_FALSE;
    
    if ((timeWindow != 0 && timeWindow < PPM_TIMEWINDOW_MIN) || timeWindow > PPM_TIMEWINDOW_MAX)
    {
        AtlReportError(CLSID_Ticket, (LPCOLESTR) PP_E_INVALID_TIMEWINDOWSTR, 
                        IID_IPassportTicket, PP_E_INVALID_TIMEWINDOW);
        return PP_E_INVALID_TIMEWINDOW;
    }

    if (m_valid == FALSE)
    {
        *pVal = VARIANT_FALSE;
        return S_OK;
    } 

    long lSecureLevel = 0;

    // time window checking
    if (timeWindow != 0) //  check time window
    {
        time_t now;
        time(&now);

        long interval = forceLogin ? now - m_lastSignInTime :
                        now - m_ticketTime;

        if (interval < 0) interval = 0;

        if ((unsigned long)(interval) > timeWindow)
        {
            // Make sure we're not in standalone mode
            CRegistryConfig* crc = g_config->checkoutRegistryConfig();
            if ((!crc) || (crc->DisasterModeP() == FALSE))
            {
                if(forceLogin)
                {
                    if(g_pPerf)
                    {
                        g_pPerf->incrementCounter(PM_FORCEDSIGNIN_TOTAL);
                        g_pPerf->incrementCounter(PM_FORCEDSIGNIN_SEC);
                    }
                    else
                    {
                        _ASSERT(g_pPerf);
                    }
                }
            }
            else
                *pVal = VARIANT_TRUE;  // we're in disaster mode, any cookie is good.
            if (crc) crc->Release();

            goto Cleanup;
        }
    }

    // check secureLevel stuff
    if(V_VT(&SecureLevel) == VT_BOOL)
    {
      if(V_BOOL(&SecureLevel) == VARIANT_TRUE)
         lSecureLevel = k_iSeclevelSecureChannel;
    }
    else if(V_VT(&SecureLevel) == VT_UI4 || V_VT(&SecureLevel) == VT_I4)
    {
         lSecureLevel = V_I4(&SecureLevel);
    }
    if(lSecureLevel != 0)
    {
       VARIANT_BOOL bCheckSecure = ( SECURELEVEL_USE_HTTPS(lSecureLevel) ? 
                                  VARIANT_TRUE : VARIANT_FALSE );
       // SSL checking
       if(bCheckSecure && !m_bSecureCheckSucceeded)
         goto Cleanup;

       // securelevel checking
       {
          CComVariant vTSecureLevel;
          TicketProperty   prop;
          HRESULT hr = m_PropBag.GetProperty(ATTR_SECURELEVEL, prop);

          // secure level is not good enough
          if(hr != S_OK || SecureLevelFromSecProp((int) (long) (prop.value)) < lSecureLevel)
            goto Cleanup;
       }
    }

    // if code can reach here, is authenticated
    *pVal = VARIANT_TRUE;
    
//JVP - begin changes 
#ifdef PASSPORT_VERBOSE_MODE_ON
	strcpy(szLogString, "CTicket::get_IsAuthenticated, Exit");
	AddVariantBoolAsString ( *pVal, szLogString, sizeof(szLogString) );
	g_pTSLogger->AddDateTimeAndLog(szLogString);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes 
Cleanup:
    return S_OK;
}

STDMETHODIMP CTicket::get_TicketAge(int *pVal)
{

//JVP - begin changes 
#ifdef PASSPORT_VERBOSE_MODE_ON
	char szLogString[LOG_STRING_LEN] = "CTicket::get_TicketAge, Enter";
	AddLongAsString        ( m_ticketTime,  szLogString, sizeof(szLogString));
	g_pTSLogger->AddDateTimeAndLog(szLogString);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes 

    if (m_valid == FALSE)
    {
        AtlReportError(CLSID_Ticket, (LPCOLESTR) PP_E_INVALID_TICKETSTR, 
                    IID_IPassportTicket, PP_E_INVALID_TICKET);
        return PP_E_INVALID_TICKET;
    }  

    time_t now;
    time(&now);
    *pVal = now - m_ticketTime;

    if (*pVal < 0)
        *pVal = 0;

//JVP - begin changes 
#ifdef PASSPORT_VERBOSE_MODE_ON
	strcpy(szLogString, "CTicket::get_TicketAge, Exit");
	AddLongAsString        ( *pVal,  szLogString, sizeof(szLogString));
	g_pTSLogger->AddDateTimeAndLog(szLogString);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes 

    return S_OK;
}

STDMETHODIMP CTicket::get_TimeSinceSignIn(int *pVal)
{
//JVP - begin changes 
#ifdef PASSPORT_VERBOSE_MODE_ON
	char szLogString[LOG_STRING_LEN] = "CTicket::get_TimeSinceSignIn, Enter";
	AddLongAsString        ( m_lastSignInTime,  szLogString, sizeof(szLogString));
	g_pTSLogger->AddDateTimeAndLog(szLogString);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes 

    if (m_valid == FALSE)
    {
        AtlReportError(CLSID_Ticket, (LPCOLESTR) PP_E_INVALID_TICKETSTR, 
                        IID_IPassportTicket, PP_E_INVALID_TICKET);
        return PP_E_INVALID_TICKET;
    }  

    time_t now;
    time(&now);
    *pVal = now - m_lastSignInTime;

    if (*pVal < 0)
        *pVal = 0;

//JVP - begin changes 
#ifdef PASSPORT_VERBOSE_MODE_ON
	strcpy(szLogString, "CTicket::get_TimeSinceSignIn, Exit");
	AddLongAsString        ( *pVal,  szLogString, sizeof(szLogString));
	g_pTSLogger->AddDateTimeAndLog(szLogString);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes 


    return S_OK;
}

STDMETHODIMP CTicket::get_MemberId(BSTR *pVal)
{
//JVP - begin changes 
#ifdef PASSPORT_VERBOSE_MODE_ON
	g_pTSLogger->AddDateTimeAndLog("CTicket::get_MemberId, E_NOTIMPL");
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes 

    HRESULT hr;

    if (m_valid == FALSE)
    {
        AtlReportError(CLSID_Ticket, (LPCOLESTR) PP_E_INVALID_TICKETSTR, 
                        IID_IPassportTicket, PP_E_INVALID_TICKET);
        hr = PP_E_INVALID_TICKET;
        goto Cleanup;
    }  

    if(pVal == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pVal = SysAllocString(m_memberId);
    if(*pVal == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

Cleanup:

    return hr;
}

STDMETHODIMP CTicket::get_MemberIdLow(int *pVal)
{
//JVP - begin changes 
#ifdef PASSPORT_VERBOSE_MODE_ON
	char szLogString[LOG_STRING_LEN] = "CTicket::get_MemberIdLow, Enter";
	AddLongAsString        ( m_mIdLow,  szLogString, sizeof(szLogString));
	g_pTSLogger->AddDateTimeAndLog(szLogString);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes 

    if (m_valid == FALSE)
    {
        AtlReportError(CLSID_Ticket, (LPCOLESTR) PP_E_INVALID_TICKETSTR, 
                        IID_IPassportTicket, PP_E_INVALID_TICKET);
        return PP_E_INVALID_TICKET;
    }  

    *pVal = m_mIdLow;

//JVP - begin changes 
#ifdef PASSPORT_VERBOSE_MODE_ON
	strcpy(szLogString, "CTicket::get_MemberIdLow, Exit");
	AddLongAsString        ( m_mIdLow,  szLogString, sizeof(szLogString));
	g_pTSLogger->AddDateTimeAndLog(szLogString);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes 

    return S_OK;
}

STDMETHODIMP CTicket::get_MemberIdHigh(int *pVal)
{
//JVP - begin changes 
#ifdef PASSPORT_VERBOSE_MODE_ON
	char szLogString[LOG_STRING_LEN] = "CTicket::get_MemberIdHigh, Enter";
	AddLongAsString        ( m_mIdHigh,  szLogString, sizeof(szLogString));
	g_pTSLogger->AddDateTimeAndLog(szLogString);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes 

    if (m_valid == FALSE)
    {
        AtlReportError(CLSID_Ticket, (LPCOLESTR) PP_E_INVALID_TICKETSTR, 
                        IID_IPassportTicket, PP_E_INVALID_TICKET);
        return PP_E_INVALID_TICKET;
    }  

    *pVal = m_mIdHigh;

//JVP - begin changes 
#ifdef PASSPORT_VERBOSE_MODE_ON
	g_pTSLogger->AddDateTimeAndLog("CTicket::get_MemberIdHigh, Exit");
	strcpy(szLogString, "CTicket::get_MemberIdHigh, Exit");
	AddLongAsString        ( m_mIdHigh,  szLogString, sizeof(szLogString));
	g_pTSLogger->AddDateTimeAndLog(szLogString);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes 

    return S_OK;
}

STDMETHODIMP CTicket::get_HasSavedPassword(VARIANT_BOOL *pVal)
{

//JVP - begin changes 
#ifdef PASSPORT_VERBOSE_MODE_ON
	g_pTSLogger->AddDateTimeAndLog("CTicket::get_HasSavedPassword, Enter");
	char szLogString[LOG_STRING_LEN] = "CTicket::get_HasSavedPassword, Enter";
	AddVariantBoolAsString ((BOOL)(m_savedPwd), szLogString, sizeof(szLogString) );
	g_pTSLogger->AddDateTimeAndLog(szLogString);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes 

    if (m_valid == FALSE)
    {
        AtlReportError(CLSID_Ticket, (LPCOLESTR) PP_E_INVALID_TICKETSTR, 
                        IID_IPassportTicket, PP_E_INVALID_TICKET);
        return PP_E_INVALID_TICKET;
    }

    *pVal = m_savedPwd ? VARIANT_TRUE : VARIANT_FALSE;

//JVP - begin changes 
#ifdef PASSPORT_VERBOSE_MODE_ON
	g_pTSLogger->AddDateTimeAndLog("CTicket::get_HasSavedPassword, Exit");
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes 

    return S_OK;
}

STDMETHODIMP CTicket::get_SignInServer(BSTR *pVal)
{
//JVP - begin changes 
#ifdef PASSPORT_VERBOSE_MODE_ON
	g_pTSLogger->AddDateTimeAndLog("CTicket::get_SignInServer, E_NOTIMPL");
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes 

    if (m_valid == FALSE)
    {
        AtlReportError(CLSID_Ticket, (LPCOLESTR) PP_E_INVALID_TICKETSTR, 
                        IID_IPassportTicket, PP_E_INVALID_TICKET);
        return PP_E_INVALID_TICKET;
    }  

    // BUGBUG
    return E_NOTIMPL;
}

// parse the 1.3X ticket fields
void CTicket::parse(
    LPCOLESTR   raw,
    DWORD       dwByteLen,
    DWORD*      pcParsed
    )
{
    LPSTR lpBase;
    UINT  byteLen, spot=0;
    long  curTime;
    time_t curTime_t;

    if (!raw)
    {
        m_valid = false;
        goto Cleanup;
    }  

    // format:
    //  four bytes network long - low memberId bytes
    //  four bytes network long - high memberId bytes
    //  four bytes network long - time of last refresh
    //  four bytes network long - time of last password entry
    //  four bytes network long - time of ticket generation
    //  one byte - is this a saved password (Y/N)
    //  four bytes network long - flags

    lpBase = (LPSTR)(LPWSTR) raw;
    byteLen = dwByteLen;
    spot=0;

    if (byteLen < sizeof(u_long)*6 + sizeof(char)) 
    { 
        m_valid = FALSE;
        goto Cleanup;
    }

    m_mIdLow  = ntohl(*(u_long*)lpBase);
    spot += sizeof(u_long);

    m_mIdHigh = ntohl(*(u_long*)(lpBase + spot));
    spot += sizeof(u_long);

    wsprintfW(m_memberId, L"%08X%08X", m_mIdHigh, m_mIdLow);

    m_ticketTime     = ntohl(*(u_long*) (lpBase+spot));
    spot += sizeof(u_long);

    m_lastSignInTime = ntohl(*(u_long*) (lpBase+spot));
    spot += sizeof(u_long);

    time(&curTime_t);

    curTime = (ULONG) curTime_t;

    // If the current time is "too" negative, bail (5 mins)
    if ((unsigned long)(curTime+300) < ntohl(*(u_long*) (lpBase+spot)))
    {
        if (g_pAlert)
        {
            DWORD dwTimes[2] = { curTime, ntohl(*(u_long*) (lpBase+spot)) };
            g_pAlert->report(PassportAlertInterface::ERROR_TYPE, PM_TIMESTAMP_BAD,
                            0, NULL, sizeof(DWORD) << 1, (LPVOID)dwTimes);
        }

        m_valid = FALSE;
        goto Cleanup;
    }
    spot += sizeof(u_long);

    m_savedPwd = (*(char*)(lpBase+spot)) == 'Y' ? TRUE : FALSE;
    spot += sizeof(char);

    m_flags = ntohl(*(u_long*) (lpBase+spot));
    spot += sizeof(u_long);

    m_valid = TRUE;
    if(pcParsed)  *pcParsed = spot;
    
    Cleanup:
    if (m_valid == FALSE) 
    {
        if(g_pAlert)
            g_pAlert->report(PassportAlertInterface::WARNING_TYPE, PM_INVALID_TICKET);
        if(g_pPerf) 
        {
            g_pPerf->incrementCounter(PM_INVALIDREQUESTS_TOTAL);
            g_pPerf->incrementCounter(PM_INVALIDREQUESTS_SEC);
        } 
        else 
        {
            _ASSERT(g_pPerf);
        }
    }

}

STDMETHODIMP CTicket::get_TicketTime(long *pVal)
{
//JVP - begin changes 
#ifdef PASSPORT_VERBOSE_MODE_ON
	char szLogString[LOG_STRING_LEN] = "CTicket::get_TicketTime";
	AddLongAsString        ( m_ticketTime,  szLogString, sizeof(szLogString));
	g_pTSLogger->AddDateTimeAndLog(szLogString);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes 

    *pVal = m_ticketTime;
    return S_OK;
}

STDMETHODIMP CTicket::get_SignInTime(long *pVal)
{
//JVP - begin changes 
#ifdef PASSPORT_VERBOSE_MODE_ON
	char szLogString[LOG_STRING_LEN] = "CTicket::get_SignInTime";
	AddLongAsString        ( m_lastSignInTime,  szLogString, sizeof(szLogString));
	g_pTSLogger->AddDateTimeAndLog(szLogString);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes 
	
    *pVal = m_lastSignInTime;
    return S_OK;
}

STDMETHODIMP CTicket::get_Error(long* pVal)
{

//JVP - begin changes 
#ifdef PASSPORT_VERBOSE_MODE_ON
	char szLogString[LOG_STRING_LEN] = "CTicket::get_Error";
	AddLongAsString        ( m_flags,  szLogString, sizeof(szLogString));
	g_pTSLogger->AddDateTimeAndLog(szLogString);
#endif //PASSPORT_VERBOSE_MODE_ON
//JVP - end changes 

    *pVal = m_flags;
    return S_OK;
}

/*
HRESULT CTicket::get_IsSecure(VARIANT_BOOL *pbIsSecure)
{
    HRESULT hr;

    if(pbIsSecure == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *pbIsSecure = ((m_passportFlags & k_ulFlagsSecuredTransportedTicket) ? VARIANT_TRUE : VARIANT_FALSE);
    hr = S_OK;

Cleanup:

    return hr;
}

int CTicket::memberIdHigh()
{
    return m_mIdHigh;
}

int CTicket::memberIdLow()
{
    return m_mIdLow;
}

LPCWSTR
CTicket::memberId()
{
    return m_memberId;
}

*/
ULONG CTicket::GetPassportFlags()
{
    return m_passportFlags;
}


BOOL CTicket::IsSecure()
{
    return ((m_passportFlags & k_ulFlagsSecuredTransportedTicket) != 0);
}

STDMETHODIMP CTicket::DoSecureCheck(BSTR bstrSec)
{
    if(bstrSec == NULL)
      return E_INVALIDARG;

    // make sure that the member id in the ticket
    // matches the member id in the secure cookie.
    m_bSecureCheckSucceeded = (memcmp(bstrSec, m_raw, sizeof(long) * 3) == 0);

    return S_OK;
}

STDMETHODIMP CTicket::GetProperty(BSTR propName, VARIANT* pVal)
{
   HRESULT hr = S_OK;
   TicketProperty prop;

   if (!pVal)  return E_POINTER;

   VariantInit(pVal);

   hr = m_PropBag.GetProperty(propName, prop);

   if (FAILED(hr)) goto Cleanup;

   if (hr == S_FALSE)   // no such property back
   {
      hr = PP_E_NO_SUCH_ATTRIBUTE;       
      goto Cleanup;
   }

   if (hr == S_OK)
   {
      //  if(prop.flags & TPF_NO_RETRIEVE)
      *pVal = prop.value;  // skin level copy
      prop.value.Detach();
   }
Cleanup:

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\passportmanager\variantutils.h ===
#ifndef PP_VARIANT_UTILS
#define PP_VARIANT_UTILS

#define DEFAULTARG(v) (v.vt==VT_ERROR && v.scode==DISP_E_PARAMNOTFOUND)
#define HASARG(v) (v.vt!=VT_ERROR || v.scode!=DISP_E_PARAMNOTFOUND)

#define CV_OK      0
#define CV_DEFAULT 1
#define CV_BAD     2
#define CV_FREE    3

inline int GetIntArg(VARIANT &vIn, int *out)
{
  if (DEFAULTARG(vIn))
    return CV_DEFAULT;
  switch (vIn.vt)
    {
    case VT_I4:
      *out = vIn.lVal;
      return CV_OK;
    case VT_I2:
      *out = vIn.iVal;
      return CV_OK;
    case VT_I4 | VT_BYREF:
      *out = *vIn.plVal;
      return CV_OK;
    case VT_I2 | VT_BYREF:
      *out = *vIn.piVal;
      return CV_OK;
    }
  VARIANT vConv;
  VariantInit(&vConv);
  if (VariantChangeType(&vConv, &vIn, 0, VT_I4) == S_OK)
    {
      *out = vConv.lVal;
      return CV_OK;
    }
  else
    return CV_BAD;
}

inline int GetShortArg(VARIANT &vIn, USHORT *out)
{
  if (DEFAULTARG(vIn))
    return CV_DEFAULT;
  switch (vIn.vt)
    {
    case VT_I4:
      *out = static_cast<unsigned short>(vIn.lVal);
      return CV_OK;
    case VT_UI4:
      *out = static_cast<unsigned short>(vIn.ulVal);
      return CV_OK;
    case VT_I2:
      *out = static_cast<unsigned short>(vIn.iVal);
      return CV_OK;
    case VT_UI2:
      *out = static_cast<unsigned short>(vIn.uiVal);
      return CV_OK;
    case VT_I4 | VT_BYREF:
      *out = static_cast<unsigned short>(*vIn.plVal);
      return CV_OK;
    case VT_UI4 | VT_BYREF:
      *out = static_cast<unsigned short>(*vIn.pulVal);
      return CV_OK;
    case VT_I2 | VT_BYREF:
      *out = static_cast<unsigned short>(*vIn.piVal);
      return CV_OK;
    case VT_UI2 | VT_BYREF:
      *out = static_cast<unsigned short>(*vIn.puiVal);
      return CV_OK;
    }
  VARIANT vConv;
  VariantInit(&vConv);
  if (VariantChangeType(&vConv, &vIn, 0, VT_UI2) == S_OK)
    {
      *out = vConv.iVal;
      return CV_OK;
    }
  else
    return CV_BAD;
}

inline int GetBoolArg(VARIANT &vIn, VARIANT_BOOL *out)
{
  if (DEFAULTARG(vIn))
    return CV_DEFAULT;
  switch (vIn.vt)
    {
    case VT_BOOL:
      *out = vIn.boolVal;
      return CV_OK;
    case VT_BOOL | VT_BYREF:
      *out = *vIn.pboolVal;
      return CV_OK;
    }
  VARIANT vConv;
  VariantInit(&vConv);
  if (VariantChangeType(&vConv, &vIn, 0, VT_BOOL) == S_OK)
    {
      *out = vConv.boolVal;
      return CV_OK;
    }
  else
    return CV_BAD;
}

inline int GetBstrArg(VARIANT &vIn, BSTR *out)
{
  if (DEFAULTARG(vIn))
    return CV_DEFAULT;
  switch (vIn.vt)
    {
    case VT_BSTR:
      *out = vIn.bstrVal;
      return CV_OK;
    case VT_BSTR | VT_BYREF:
      *out = *vIn.pbstrVal;
      return CV_OK;
    case VT_VARIANT | VT_BYREF:
      return GetBstrArg(*vIn.pvarVal, out);
    }
  VARIANT vConv;
  VariantInit(&vConv);
  if (VariantChangeType(&vConv, &vIn, 0, VT_BSTR) == S_OK)
    {
      *out = vConv.bstrVal;
      return CV_FREE;
    }
  else
    return CV_BAD;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\passportmanager\tslog.h ===
/////////////////////////////////////////////////////////////////////////////
//
//     CTSLog.h - Thread safe logger class
//
//	JVP 2/23/2000	added g_szLogFileName for use as logger file name
//					Added:
//					AddULAsString(GetCurrentProcessId(), pszOut, LOG_STRING_LEN);
//					AddULAsString(GetCurrentThreadId(), pszOut, LOG_STRING_LEN);
//					to AddDateTimeAndLog, so that the processid and thread id
//					get prepended to the string to be logged
/////////////////////////////////////////////////////////////////////////////

#ifndef _TSLog_H_
#define _TSLog_H_

#include <limits.h>
#include <queue>
#include <time.h>
#include <process.h>    /* _beginthread, _endthread */

//some helper functions
void AddStringToString(char *szIn,  char * szStr, long lMaxLen);
void AddBSTRAsString(BSTR bsIn,  char * szStr, long lMaxLen);
void AddDoubleAsString(double dIn,  char * szStr, long lMaxLen);
void AddLongAsString(long lIn,  char * szStr, long lMaxLen);
void AddULAsString(unsigned long lIn,  char * szStr, long lMaxLen);
void AddVariantBoolAsString(VARIANT_BOOL vIn, char * szStr, long lMaxLen);
void AddVariantAsString(VARIANT vIn, char * szStr, long lMaxLen);


#define PASSPORT_VERBOSE_MODE_ON


#define NUM_POOL_STRINGS 1024
#define LOG_STRING_LEN 512

//NOTE: The string result produced by asctime contains exactly 26 characters 
//		and we need to allow space for the user string to be appended to the
//		end.  512 - 26 - 1 = 486 user characters - should be plenty

//NOTE: Each instance of the CTSLog class will need storage for
//		NUM_POOL_STRINGS * LOG_STRING_LEN, just for strings

const _TCHAR kszLogFileName[] = _T("C:\\PASSPORTLOG.LOG");
extern _TCHAR g_szLogFileName[MAX_PATH];

//kszFileSemaphoreName needs to be a unique name on the system
const _TCHAR kszFileSemaphoreName[] = _T("MS_Passport_LogFile_Semaphore_Name_7771");
const DWORD kdwNoFileShare = 0 ;

/////////////////////////////////////////////////////////////////////////////
// CTSLog

/////////////////////////////////////////////////////////////////////////////
//                              N O T E S:
//
//1/28/2000 - JVP
//
//The way this class is designed to work is the following:
//We have a "pool" of strings that the class uses to pass data to a thread 
//that is in charge of logging data (string) to a file. This pool is an STL
//queue. We have another STL queue that we push strings onto to be logged
//by the "child" thread.  There is a mutex for each queue, that synchronizes 
//access to the queue (thus making it "thread safe").  There is a semaphore 
//for each queue. There is also a semaphore to synchronize access to the file
//For the log queue, the log semaphore is used to signal the
//thread that there is data to be logged (the thread blocks waiting for the
//semaphore to become signaled).  When the semaphore becomes signaled, the
//thread wakes up and uses the mutex to gain access to the log queue. It then
//gets the first item from the queue, deletes it from the queue, waits for
//the file semaphore, opens the file, logs the string and goes back to 
//waiting for the log queue semaphore.
//
//The reason for having a pool of strings rather than allocate them on the
//fly is two fold; First we would "churn" memory if we had to allocate and 
//de-allocate strings all of the time. The second is performance.  Memory
//allocation takes time.  There is also the issue of one thread allocating
//a string and the other de-allocatting the string. (I'm not sure how Windows
//handles this and it may be prone to error).
//
//Anyway, for a relativly small amount of memory we get some real advantages.
//If ,however, we allocate to many strings we are wasting memory and if we 
//don't allocate enough, we are waiting for the logger thread to log the 
//data to often.
/////////////////////////////////////////////////////////////////////////////

class CTSLog
{

/////////////////////////////////////////////////////////////////////////////
//  CTSLog      P U B L I C   M E M B E R   F U N C T I O N S
/////////////////////////////////////////////////////////////////////////////
public:
	CTSLog( void );
	~CTSLog( void );

	BOOL Init(_TCHAR * pFileName, int nPriority );

	void Close();


/////////////////////////////////////////////////////////////////////////////
// Function name	: AddDateTimeAndLog
// Description	    : This function starts the loggin process for a string.
//						We get a string from our pool of strings, then we add
//						some information to the front of it. As of this 
//						writing, we add the value from GetTickCount and 
//						asctime to the begining, then we add the string the 
//						caller gave us to the end of our pool string, then
//						we push this string onto the end of our log queue
// Return type		: BOOL 
// Argument         : char * pStr
/////////////////////////////////////////////////////////////////////////////
	BOOL AddDateTimeAndLog( char * pStr )
	{
		if ( FALSE == m_bVerboseModeOn )
			return FALSE;

		if ( FALSE == m_bInit )
			return FALSE;

		//first, we must get a string from our pool of strings
		char * pszOut = popPool();

		//we must have valid strings
		if ( (NULL != pszOut) && (NULL != pszOut) )
		{
			//get the time to add to the front of the string
			//The string result produced by asctime contains exactly 26 characters 
			time_t ltime;
			struct tm *now;
			time( &ltime );
			now = localtime( &ltime );
			//OK. we'll add the value returned from GetTickCount to the front of the string
			sprintf( pszOut, "%ld, %s", GetTickCount(), asctime( now ) );

			//asctime appends a '\n' character to the end of the string
			//so replace it with a blank
			//Note: start searching from the end of the string backwards
			char * pEnd = strrchr( pszOut , '\n');
			if ( NULL != pEnd )
				*pEnd = ' ';

			//we add processid and thread id to the end of the string
			AddULAsString(GetCurrentProcessId(), pszOut, LOG_STRING_LEN);
			AddULAsString(GetCurrentThreadId(), pszOut, LOG_STRING_LEN);
			//now we add the given string to the end of the pool string
			AddStringToString(pStr, pszOut, LOG_STRING_LEN);

			pushLogQueue ( pszOut );
			return TRUE;
		}

		return FALSE;
	};

/////////////////////////////////////////////////////////////////////////////
//  CTSLog      P R I V A T E   M E M B E R   F U N C T I O N S
/////////////////////////////////////////////////////////////////////////////
private:

	//NOTE: There is no popLogQueue because this is done in the
	//      logger thread directly.

	//push an item onto the log queue
	void pushLogQueue( char * pStr )
	{
		//synchronize access to the queue
		EnterCriticalSection( &m_outMutex );
		m_outQueue.push( pStr );
		LeaveCriticalSection( &m_outMutex );//we are done with the queue
		//signal the semaphore that there is one more item in the queue
		ReleaseSemaphore( m_hQSemaphore, 1, NULL );
	};

	//push a string onto the end of the pool of strings
	void pushPool( char * pStr )
	{
		//synchronize access to the queue
		EnterCriticalSection( &m_poolMutex );
		m_stringPool.push( pStr );
		LeaveCriticalSection( &m_poolMutex );//we are done with the queue
		//signal the semaphore that there is one more item in the queue
		ReleaseSemaphore( m_hPoolSemaphore, 1, NULL );
	};

	//get the first string from the pool, wait for one if there isn't one
	//available
	char * popPool( DWORD dwMilliseconds = -1)
	{
		DWORD dwRet;
		char * pStr = NULL;

		//wait for there to be a string in the pool
		if ( dwMilliseconds <= 0 )//wait forever
		{
			dwRet = WaitForSingleObject( m_hPoolSemaphore, INFINITE );
		}
		else
		{//wait for the given number of milliseconds
			dwRet = WaitForSingleObject( m_hPoolSemaphore, dwMilliseconds );
		}

		if (WAIT_OBJECT_0 == dwRet)
		{
			//synchronize access to the queue
			EnterCriticalSection( &m_poolMutex );
			pStr = m_stringPool.front();
			m_stringPool.pop();
			LeaveCriticalSection( &m_poolMutex );
		}	
		return pStr;
	};

	//function to check if the verbose mode is on in the registry
	BOOL IsRegistryVerboseSet()
	{
		HKEY	hKey;
		BOOL    bRet = FALSE;

		if (ERROR_SUCCESS == RegOpenKeyEx( (HKEY) HKEY_LOCAL_MACHINE, _T("Software\\Microsoft\\Passport"), 0, KEY_READ, &hKey ))
		{
			DWORD	bufSize;
			DWORD	type;
			BYTE	buffer[128];
			bufSize = sizeof(buffer);
			if (ERROR_SUCCESS == RegQueryValueEx( hKey, _T("Verbose"), 0, &type, buffer, &bufSize ))
			{
				if ( 1 == buffer[0] )
					bRet = TRUE;
			}
			RegCloseKey(hKey);
		}
		return bRet;	
	};

	void GetLogfileName()
	{
		HKEY	hKey;
		BOOL    bRet = FALSE;

		if (ERROR_SUCCESS == RegOpenKeyEx( (HKEY) HKEY_LOCAL_MACHINE, _T("Software\\Microsoft\\Passport"), 0, KEY_READ, &hKey ))
		{
			DWORD	bufSize;
			DWORD	type;
			BYTE	buffer[MAX_PATH];
			bufSize = sizeof(buffer);
			if (ERROR_SUCCESS == RegQueryValueEx( hKey, _T("InstallDir"), 0, &type, buffer, &bufSize ))
			{
				//we are going to try the new name, so put it in a temp variable first
				//and then try to open/create the file, if that fails, we don't set the name
				_TCHAR	sLocalName[MAX_PATH];
				wsprintf(sLocalName,_T("%s\\\\PASSPORTLOG.LOG"), buffer);
				HANDLE hFile = INVALID_HANDLE_VALUE;
				DWORD dwRetVal = WaitForSingleObject( m_hFileSemaphore, INFINITE );
				hFile = CreateFile(sLocalName, GENERIC_WRITE, kdwNoFileShare, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL /*| FILE_FLAG_WRITE_THROUGH*/ , NULL);
				if ( INVALID_HANDLE_VALUE != hFile )
				{
					wsprintf(g_szLogFileName,_T("%s"), sLocalName);
					CloseHandle(hFile);
				}
				ReleaseSemaphore( m_hFileSemaphore, 1, NULL );
			}
			RegCloseKey(hKey);
		}
	}
	//the logger thread
	static unsigned int __stdcall LoggerThread(void * pArg);

/////////////////////////////////////////////////////////////////////////////
//  CTSLog      P R I V A T E   M E M B E R   V A R I A B L E S
/////////////////////////////////////////////////////////////////////////////
private:

	HANDLE				m_hPoolSemaphore;	//used to signal when the pool is empty
	HANDLE				m_hQSemaphore;		//used to signal when something is in the queue
	HANDLE				m_hFileSemaphore;	//used to synchronize access to the file
	CRITICAL_SECTION		m_outMutex;		//mutex used to synchronize access to the logg queue
	CRITICAL_SECTION		m_poolMutex;		//mutex used to synchronize access to the string pool
	PtStlQueue<char *>		m_outQueue;		//the queue that holds strings to be logged to the file
	PtStlQueue<char *>		m_stringPool;		//the "pool" that holds the strings we use
	BOOL				m_bQuit;		//used to tell the child thread when to quit
	BOOL				m_bInit;		//have we been initialized
	BOOL				m_bVerboseModeOn;	//is the registry entry set to ON
	HANDLE				m_ulChildThread;	//a handle to the child thread
	unsigned int			m_uThreadAddr;		//the thread ID returned by beginthreadex
	unsigned long			m_ulNumPoolStrings;	//the number of strings actually in the pool
};

#endif // _TSLog_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\passportmanager\factorytest\factorytest.cpp ===
// FactoryTest.cpp : Defines the entry point for the DLL application.
//
#define _WINNT_WIN32 0x0400
#include <objbase.h>
#include <comdef.h>
#include <stdio.h>
#include <atlbase.h>
#include <atlconv.h>
#include <httpext.h>
#include "FactoryTest.h"
#include "passport.h"

_COM_SMARTPTR_TYPEDEF(IPassportFactory, __uuidof(IPassportFactory));
_COM_SMARTPTR_TYPEDEF(IPassportManager, __uuidof(IPassportManager));

IPassportFactoryPtr g_piFactory;

HRESULT
InitializePassportManager(
    LPEXTENSION_CONTROL_BLOCK   lpECB,
    IPassportManager**          ppiManager
    )
{
    HRESULT     hr;
    IDispatch*  piDispatch = NULL;
    DWORD       dwBufLen;
    CHAR        achCookieBuf[2048];

    hr = g_piFactory->CreatePassportManager(&piDispatch);
    if(hr != S_OK)
    {
        goto Cleanup;
    }

    hr = piDispatch->QueryInterface(IID_IPassportManager, (void**)ppiManager);
    if(hr != S_OK)
    {
        goto Cleanup;
    }

    dwBufLen = sizeof(achCookieBuf);
    hr = (*ppiManager)->OnStartPageECB((LPBYTE)lpECB,
                                   &dwBufLen,
                                   achCookieBuf
                                   );
    if(hr != S_OK)
    {
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:

    if(piDispatch) piDispatch->Release();

    return hr;
}

void
ShowErrorPage(
    LPEXTENSION_CONTROL_BLOCK   lpECB,
    HRESULT                     hError
    )
{

    CHAR    achBuf[2048];
    DWORD   dwBufLen;

    dwBufLen = _snprintf(achBuf,
                         sizeof(achBuf),
                         "<html><head><title>Error</title></head><body>Error = %d</body></html>",
                         hError
                         );

    lpECB->WriteClient(lpECB->ConnID,
                       (LPVOID)achBuf,
                       &dwBufLen,
                       HSE_IO_SYNC
                       );
}


BSTR
GetProfileValue(
    LPCWSTR             pszAttribute,
    IPassportManager*   piManager
    )
{
    BSTR    bstrReturn;
    BSTR    bstrAttribute = SysAllocString(pszAttribute);
    HRESULT hr;
    VARIANT v;
    VARIANT vBstr;

    ::VariantInit(&v);
    ::VariantInit(&vBstr);

    hr = piManager->get_Profile(bstrAttribute, &v);
    if(hr != S_OK)
    {
        bstrReturn = NULL;
        goto Cleanup;
    }

    hr = ::VariantChangeType(&vBstr, &v, 0, VT_BSTR);
    if(hr != S_OK)
    {
        bstrReturn = NULL;
        goto Cleanup;
    }

    bstrReturn = vBstr.bstrVal;

Cleanup:

    if(bstrAttribute)
        SysFreeString(bstrAttribute);

    return bstrReturn;
}


void
PrintProfileAttribute(
    LPCWSTR                     pszAttribute,
    LPEXTENSION_CONTROL_BLOCK   lpECB,
    IPassportManager*           piManager
    )
{
    CHAR    achBuf[2048];
    DWORD   dwBufLen;
    BSTR    bstrValue = GetProfileValue(pszAttribute, piManager);

    USES_CONVERSION;

    dwBufLen = _snprintf(achBuf,
                         sizeof(achBuf),
                         "%s = %s<br>\r\n",
                         W2A(pszAttribute),
                         W2A(bstrValue)
                         );

    lpECB->WriteClient(lpECB->ConnID,
                       (LPVOID)achBuf,
                       &dwBufLen,
                       HSE_IO_SYNC
                       );

    if(bstrValue)
        SysFreeString(bstrValue);

    return;
}


void
ShowProfile(
    LPEXTENSION_CONTROL_BLOCK   lpECB,
    IPassportManager*           piManager
    )
{
    PrintProfileAttribute(L"memberName", lpECB, piManager);
    PrintProfileAttribute(L"memberIdLow", lpECB, piManager);
    PrintProfileAttribute(L"memberIdHigh", lpECB, piManager);
    PrintProfileAttribute(L"profileVersion", lpECB, piManager);
    PrintProfileAttribute(L"country", lpECB, piManager);
    PrintProfileAttribute(L"postalCode", lpECB, piManager);
    PrintProfileAttribute(L"region", lpECB, piManager);
    PrintProfileAttribute(L"city", lpECB, piManager);
    PrintProfileAttribute(L"lang_preference", lpECB, piManager);
    PrintProfileAttribute(L"bday_precision", lpECB, piManager);
    PrintProfileAttribute(L"birthdate", lpECB, piManager);
    PrintProfileAttribute(L"gender", lpECB, piManager);
    PrintProfileAttribute(L"preferredEmail", lpECB, piManager);
    PrintProfileAttribute(L"nickname", lpECB, piManager);
    PrintProfileAttribute(L"accessibility", lpECB, piManager);
    PrintProfileAttribute(L"wallet", lpECB, piManager);
    PrintProfileAttribute(L"directory", lpECB, piManager);
    PrintProfileAttribute(L"inetaccess", lpECB, piManager);
    PrintProfileAttribute(L"flags", lpECB, piManager);
}


BOOL
IsAuthenticated(
    IPassportManager*   piManager,
    LONG                lTimeWindow,
    BOOL                bForceLogin
    )
{
    BOOL            bReturn;
    HRESULT         hr;
    VARIANT         vTimeWindow;
    VARIANT         vForceLogin;
    VARIANT_BOOL    vb;

    VariantInit(&vTimeWindow);
    vTimeWindow.vt = VT_I4;
    vTimeWindow.lVal = lTimeWindow;

    VariantInit(&vForceLogin);
    vForceLogin.vt = VT_BOOL;
    vTimeWindow.boolVal = (bForceLogin ? VARIANT_TRUE : VARIANT_FALSE);

    hr = piManager->IsAuthenticated(vTimeWindow, vForceLogin, &vb);
    if(hr != S_OK)
    {
        bReturn = FALSE;
        goto Cleanup;
    }

    bReturn = (vb == VARIANT_TRUE);

Cleanup:

    return bReturn;
}


BSTR
GetReturnURL(
    LPEXTENSION_CONTROL_BLOCK   lpECB
    )
{
    BSTR    bstrReturnURL;
    CHAR    achBuf[2048];
    DWORD   dwBufLen;

    USES_CONVERSION;

    lstrcpyA(achBuf, "http://");

    dwBufLen = sizeof(achBuf) - lstrlenA(achBuf);
    lpECB->GetServerVariable(lpECB->ConnID,
                             "SERVER_NAME",
                             &(achBuf[lstrlenA(achBuf)]),
                             &dwBufLen);

    dwBufLen = sizeof(achBuf) - lstrlenA(achBuf);
    lpECB->GetServerVariable(lpECB->ConnID,
                             "SCRIPT_NAME",
                             &(achBuf[lstrlenA(achBuf)]),
                             &dwBufLen);

    lstrcatA(achBuf, "?");

    dwBufLen = sizeof(achBuf) - lstrlenA(achBuf);
    lpECB->GetServerVariable(lpECB->ConnID,
                             "QUERY_STRING",
                             &(achBuf[lstrlenA(achBuf)]),
                             &dwBufLen);

    //If no query string, remove the question mark.
    if(dwBufLen == 1)
    {
        achBuf[lstrlenA(achBuf) - 1] = 0;
    }

    bstrReturnURL = SysAllocString(A2W(achBuf));

    return bstrReturnURL;
}

void
DoLogin(
    LPEXTENSION_CONTROL_BLOCK   lpECB,
    IPassportManager*           piManager
    )
{
    HRESULT hr;
    LPSTR   pszURL;
    DWORD   dwURLLen;
    BSTR    bstrURL;
    VARIANT vReturnURL;
    VARIANT vTimeWindow;
    VARIANT vForceLogin;
    VARIANT vNoParam;


    USES_CONVERSION;

    ::VariantInit(&vReturnURL);
    ::VariantInit(&vTimeWindow);
    ::VariantInit(&vForceLogin);
    ::VariantInit(&vNoParam);

    vReturnURL.vt = VT_BSTR;
    vReturnURL.bstrVal = GetReturnURL(lpECB);
    
    vTimeWindow.vt = VT_I4;
    vTimeWindow.lVal = 3600;

    vForceLogin.vt = VT_BOOL;
    vForceLogin.boolVal = VARIANT_FALSE;

    vNoParam.vt = VT_ERROR;
    vNoParam.scode = DISP_E_PARAMNOTFOUND;

    hr = piManager->AuthURL(vReturnURL,
                            vTimeWindow,
                            vForceLogin,
                            vNoParam,
                            vNoParam,
                            &bstrURL
                            );
    if(hr != S_OK)
        return;

    pszURL = W2A(bstrURL);

    dwURLLen = strlen(pszURL);
    lpECB->ServerSupportFunction(
                    lpECB->ConnID,
                    HSE_REQ_SEND_URL_REDIRECT_RESP,  
                    pszURL,
                    &dwURLLen,
                    NULL
                    );

    ::VariantClear(&vReturnURL);
}


void
ShowLogo(
    LPEXTENSION_CONTROL_BLOCK   lpECB,
    IPassportManager*           piManager
    )
{
    HRESULT hr;
    BSTR    bstrLogoTag;
    VARIANT vReturnURL;
    VARIANT vTimeWindow;
    VARIANT vForceLogin;
    VARIANT vNoParam;
    DWORD   dwBufLen;

    USES_CONVERSION;

    ::VariantInit(&vReturnURL);
    ::VariantInit(&vTimeWindow);
    ::VariantInit(&vForceLogin);
    ::VariantInit(&vNoParam);

    vReturnURL.vt = VT_BSTR;
    vReturnURL.bstrVal = GetReturnURL(lpECB);
    
    vTimeWindow.vt = VT_I4;
    vTimeWindow.lVal = 3600;

    vForceLogin.vt = VT_BOOL;
    vForceLogin.boolVal = VARIANT_FALSE;

    vNoParam.vt = VT_ERROR;
    vNoParam.scode = DISP_E_PARAMNOTFOUND;

    hr = piManager->LogoTag(
                        vReturnURL,
                        vTimeWindow,
                        vForceLogin,
                        vNoParam,
                        vNoParam,
                        vNoParam,
                        &bstrLogoTag
                        );
    if(hr != S_OK)
        return;

    dwBufLen = SysStringLen(bstrLogoTag);
    lpECB->WriteClient(lpECB->ConnID,
                       W2A(bstrLogoTag),
                       &dwBufLen,
                       HSE_IO_SYNC
                       );

    SysFreeString(bstrLogoTag);
}


BOOL APIENTRY DllMain( HANDLE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
{
    switch (ul_reason_for_call)
	{
		case DLL_PROCESS_ATTACH:

            DisableThreadLibraryCalls((HINSTANCE)hModule);
            break;

		case DLL_THREAD_ATTACH:
		case DLL_THREAD_DETACH:
		case DLL_PROCESS_DETACH:
			break;
    }
    return TRUE;
}


BOOL WINAPI 
GetExtensionVersion(
  HSE_VERSION_INFO* pVer
)
{
    BOOL                        bReturn;
    HRESULT                     hr;

    // Create the extension version string, and 
    // copy string to HSE_VERSION_INFO structure.
    pVer->dwExtensionVersion = 
    MAKELONG(HSE_VERSION_MINOR, HSE_VERSION_MAJOR);

    // Copy description string into HSE_VERSION_INFO structure.
    strcpy(pVer->lpszExtensionDesc, "Factory Test Extension");

    CoInitializeEx(NULL, COINIT_MULTITHREADED);

    hr = CoCreateInstance(CLSID_PassportFactory, 
                          NULL, 
                          CLSCTX_SERVER, 
                          IID_IPassportFactory, 
                          (void**)&g_piFactory);
    if(hr != S_OK)
    {
        bReturn = (FALSE);
        goto Cleanup;
    }        

Cleanup:

    CoUninitialize();

    return (bReturn);
}

DWORD WINAPI 
HttpExtensionProc(
    LPEXTENSION_CONTROL_BLOCK lpECB
    )
{
    DWORD               dwRet;
    HRESULT             hr;
    IDispatch*          piDispatch = NULL;
    IPassportManager*   piManager = NULL;
    CHAR                achCookieBuf[1024];
    DWORD               dwBufLen;
    
    hr = InitializePassportManager(lpECB, &piManager);
    if(hr != S_OK)
    {
        ShowErrorPage(lpECB, hr);
        dwRet = HSE_STATUS_SUCCESS;
        goto Cleanup;
    }

    ShowLogo(lpECB, piManager);

    if(IsAuthenticated(piManager, 10000, FALSE))
    {
        ShowProfile(lpECB, piManager);
        dwRet = HSE_STATUS_SUCCESS;
        goto Cleanup;
    }
    else
    {
        DoLogin(lpECB, piManager);
        dwRet = HSE_STATUS_SUCCESS;
        goto Cleanup;
    }

Cleanup:

    if(piDispatch) piDispatch->Release();
    if(piManager)  piManager->Release();

    return dwRet;
}

BOOL WINAPI 
TerminateExtension(
    DWORD dwFlags
    )
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\passportmanager\factorytest\factorytest.h ===
// The following ifdef block is the standard way of creating macros which make exporting 
// from a DLL simpler. All files within this DLL are compiled with the FACTORYTEST_EXPORTS
// symbol defined on the command line. this symbol should not be defined on any project
// that uses this DLL. This way any other project whose source files include this file see 
// FACTORYTEST_API functions as being imported from a DLL, wheras this DLL sees symbols
// defined with this macro as being exported.
#ifdef FACTORYTEST_EXPORTS
#define FACTORYTEST_API __declspec(dllexport)
#else
#define FACTORYTEST_API __declspec(dllimport)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\passportmanager\pooltest\pooltest.cpp ===
#include <windows.h>

void main(void)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\passportmanager\filtertest2\filtertest.cpp ===
#include <windows.h>
#include <httpfilt.h>
#include "passport.h"

#define AUTH_USERNAME   "PassportUser"
#define AUTH_PASSWORD   "PassportRocks"


DWORD
OnAuthentication(
    PHTTP_FILTER_CONTEXT    pfc,
    PHTTP_FILTER_AUTHENT    pPPH
    )
{
    DWORD               dwResult;
    HRESULT             hrCoInit;
    HRESULT             hr;
    VARIANT             vTimeWindow;
    VARIANT             vForceLogin;
    VARIANT_BOOL        bIsAuthenticated;
    IPassportManager*   piManager = NULL;
    CHAR                achCookieBuf[2048];
    DWORD               dwBufLen;

    hrCoInit = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    hr = CoCreateInstance(CLSID_Manager, NULL, CLSCTX_SERVER, IID_IPassportManager, (void**)&piManager);
    if(hr != S_OK)
    {
        dwResult = SF_STATUS_REQ_NEXT_NOTIFICATION;
        goto Cleanup;
    }

    dwBufLen = sizeof(achCookieBuf);
    hr = piManager->OnStartPageFilter((BYTE*)pfc, &dwBufLen, achCookieBuf);
    if(hr != S_OK)
    {
        dwResult = SF_STATUS_REQ_NEXT_NOTIFICATION;
        goto Cleanup;
    }
    
    (*(pfc->AddResponseHeaders))(pfc, achCookieBuf, NULL);

    ::VariantInit(&vTimeWindow);
    vTimeWindow.vt = VT_I4;
    vTimeWindow.lVal = 3600;

    ::VariantInit(&vForceLogin);
    vForceLogin.vt = VT_BOOL;
    vForceLogin.boolVal = VARIANT_FALSE;

    hr = piManager->IsAuthenticated(vTimeWindow, vForceLogin, &bIsAuthenticated);
    if(hr != S_OK)
    {
        dwResult = SF_STATUS_REQ_NEXT_NOTIFICATION;
        goto Cleanup;
    }

    if(bIsAuthenticated == VARIANT_TRUE)
    {
        lstrcpynA(pPPH->pszUser, AUTH_USERNAME, pPPH->cbUserBuff);
        lstrcpynA(pPPH->pszPassword, AUTH_PASSWORD, pPPH->cbPasswordBuff);
        dwResult = SF_STATUS_REQ_HANDLED_NOTIFICATION;
    }
    else
        //  Alternatively, at this point we could call g_piFastAuth->AuthURL and redirect
        //  to the passport login server.  In this simple example we're content to
        //  let the user see a 401 error page.
        dwResult = SF_STATUS_REQ_NEXT_NOTIFICATION;

Cleanup:

    if(piManager) piManager->Release();
    
    if(SUCCEEDED(hrCoInit))
        CoUninitialize();

    return dwResult;
}


BOOL WINAPI
GetFilterVersion(
    PHTTP_FILTER_VERSION    pVer
    )
{
    pVer->dwFilterVersion = HTTP_FILTER_REVISION;
    lstrcpyA(pVer->lpszFilterDesc, "Passport Test Filter");
    pVer->dwFlags = SF_NOTIFY_AUTHENTICATION;
    return TRUE;
}


DWORD WINAPI
HttpFilterProc(
    PHTTP_FILTER_CONTEXT    pfc,
    DWORD                   dwNotificationType,
    LPVOID                  lpNotification
    )
{
    DWORD   dwResult;

    switch(dwNotificationType)
    {
    case SF_NOTIFY_AUTHENTICATION:
        dwResult = OnAuthentication(pfc, (PHTTP_FILTER_AUTHENT)lpNotification);
        break;
    default:
        dwResult = SF_STATUS_REQ_NEXT_NOTIFICATION;
        break;
    }

    return dwResult;
}


BOOL WINAPI
TerminateFilter(
    DWORD   dwFlags
    )
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\passportmanager\filtertest\filtertest.cpp ===
#include <windows.h>
#include <httpfilt.h>
#include <stdio.h>
#include <string.h>
#include "passport.h"

IPassportFastAuth*  g_piFastAuth = NULL;

#define AUTH_USERNAME   "PassportUser"
#define AUTH_PASSWORD   "PassportRocks"


DWORD
OnAuthentication(
    PHTTP_FILTER_CONTEXT    pfc,
    PHTTP_FILTER_AUTHENT    pPPH
    )
{
    DWORD   dwResult;
    BOOL    bAuthed;
    
    if(pfc->pFilterContext == NULL)
    {
        dwResult = SF_STATUS_REQ_NEXT_NOTIFICATION;
        goto Cleanup;
    }

    bAuthed = *(BOOL*)pfc->pFilterContext;

    delete pfc->pFilterContext;

    if(bAuthed)
    {
        lstrcpynA(pPPH->pszUser, AUTH_USERNAME, pPPH->cbUserBuff);
        lstrcpynA(pPPH->pszPassword, AUTH_PASSWORD, pPPH->cbPasswordBuff);
        dwResult = SF_STATUS_REQ_HANDLED_NOTIFICATION;
    }
    else
        //  Alternatively, at this point we could call g_piFastAuth->AuthURL and redirect
        //  to the passport login server.  In this simple example we're content to
        //  let the user see a 401 error page.
        dwResult = SF_STATUS_REQ_NEXT_NOTIFICATION;

Cleanup:

    return dwResult;
}


DWORD
OnPreProcHeaders(
    PHTTP_FILTER_CONTEXT            pfc,
    PHTTP_FILTER_PREPROC_HEADERS    pPPH
    )
{
    DWORD           dwResult;
    HRESULT         hrCoInit;
    HRESULT         hr;
    BSTR            bstrTicket;
    BSTR            bstrProfile;
    VARIANT         vTimeWindow;
    VARIANT         vForceLogin;
    VARIANT_BOOL    bIsAuthenticated;
    BOOL*           pb;
    CHAR            achBuf[2048];
    DWORD           dwBufLen;

    dwBufLen = sizeof(achBuf);
	if (!pPPH->GetHeader(pfc, "URL", achBuf, &dwBufLen) && dwBufLen > 1)
	{
		// Return a 404 Not found error if we cannot parse a valid URL
		pfc->ServerSupportFunction(pfc, SF_REQ_SEND_RESPONSE_HEADER, (PVOID)"404 Not found", 0, 0);
				
		return SF_STATUS_REQ_FINISHED;
	}
           
    if(_strnicmp(achBuf, "/filtertest/default.htm", sizeof("/filtertest/default.htm") - 1)!=0)
    {
        // Let these requests through
        return SF_STATUS_REQ_NEXT_NOTIFICATION;	
    }

    hrCoInit = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    hr = g_piFastAuth->GetTicketAndProfilePFC((BYTE*)pfc, (BYTE*)pPPH, &bstrTicket, &bstrProfile);
    if(hr != S_OK)
    {
        // Redirect them to passport login.
        VARIANT vOptional;
        BSTR bstrAuthURL;
        VARIANT vFinishURL;

        vOptional.vt = VT_ERROR; vOptional.scode = DISP_E_PARAMNOTFOUND;                                                                                    
        vFinishURL.vt = VT_BSTR;
        vFinishURL.bstrVal = SysAllocString(L"http%3a%2f%2fdarrenan0%2ffiltertest%2fdefault%2ehtm");
        hr = g_piFastAuth->AuthURL(vOptional,vOptional,vFinishURL,vOptional,
                                  vOptional,vOptional,vOptional,vOptional,vOptional,
                                  vOptional,&bstrAuthURL);
        if(FAILED(hr))
        {
            // TODO: log this error
            OutputDebugString(TEXT("AuthURL failed\n"));
            dwResult = SF_STATUS_REQ_NEXT_NOTIFICATION;
        }
        else
        {
            // Actually redirect
            OutputDebugString(TEXT("Redirecting to passport\n"));
            
            char szFinishURL[1024];
            char szRedirect[1024];

            WideCharToMultiByte(CP_ACP,0,bstrAuthURL,-1,szFinishURL,sizeof(szFinishURL),
                                NULL,NULL);
            SysFreeString(bstrAuthURL);            
            sprintf(szRedirect,"Location: %s\r\n\r\n",szFinishURL);
            pfc->ServerSupportFunction(pfc,SF_REQ_SEND_RESPONSE_HEADER,(LPVOID) "302 Redirect",
                                       (DWORD) szRedirect,0);
            dwResult = SF_STATUS_REQ_FINISHED;
        }        
        goto Cleanup;
    }

    ::VariantInit(&vTimeWindow);
    vTimeWindow.vt = VT_I4;
    vTimeWindow.lVal = 3600;

    ::VariantInit(&vForceLogin);
    vForceLogin.vt = VT_BOOL;
    vForceLogin.boolVal = VARIANT_FALSE;

    hr = g_piFastAuth->IsAuthenticated(bstrTicket, bstrProfile, vTimeWindow, vForceLogin, &bIsAuthenticated);
    if(hr != S_OK)
    {
        dwResult = SF_STATUS_REQ_NEXT_NOTIFICATION;
        goto Cleanup;
    }

    pb = new BOOL;
    pfc->pFilterContext = (PVOID) pb;
    if(bIsAuthenticated == VARIANT_TRUE)
    {
        //lstrcpynA(pPPH->pszUser, AUTH_USERNAME, pPPH->cbUserBuff);
        //lstrcpynA(pPPH->pszPassword, AUTH_PASSWORD, pPPH->cbPasswordBuff);
        *pb = TRUE;
        dwResult = SF_STATUS_REQ_HANDLED_NOTIFICATION;
    }
    else
    {
        //  Alternatively, at this point we could call g_piFastAuth->AuthURL and redirect
        //  to the passport login server.  In this simple example we're content to
        //  let the user see a 401 error page.
        *pb = FALSE;
        dwResult = SF_STATUS_REQ_NEXT_NOTIFICATION;
    }

Cleanup:

    if(SUCCEEDED(hrCoInit))
        CoUninitialize();

    return dwResult;
}


BOOL WINAPI
GetFilterVersion(
    PHTTP_FILTER_VERSION    pVer
    )
{
    BOOL    bReturn;
    HRESULT hrCoInit;
    HRESULT hr;
    CLSID   clsid;

    hrCoInit = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    hr = CLSIDFromProgID(L"Passport.FastAuth", &clsid);
    if(hr != S_OK)
    {
        bReturn = FALSE;
        goto Cleanup;
    }

    hr = CoCreateInstance(clsid, NULL, CLSCTX_SERVER, IID_IPassportFastAuth, (void**)&g_piFastAuth);
    if(hr != S_OK)
    {
        bReturn = FALSE;
        goto Cleanup;
    }

    bReturn = TRUE;

Cleanup:

    if(SUCCEEDED(hrCoInit))
        CoUninitialize();

    pVer->dwFilterVersion = HTTP_FILTER_REVISION;
    lstrcpyA(pVer->lpszFilterDesc, "Passport Test Filter");
    pVer->dwFlags = SF_NOTIFY_PREPROC_HEADERS | SF_NOTIFY_AUTHENTICATION;
    return bReturn;
}


DWORD WINAPI
HttpFilterProc(
    PHTTP_FILTER_CONTEXT    pfc,
    DWORD                   dwNotificationType,
    LPVOID                  lpNotification
    )
{
    DWORD   dwResult;

    switch(dwNotificationType)
    {
    case SF_NOTIFY_AUTHENTICATION:
        dwResult = OnAuthentication(pfc, (PHTTP_FILTER_AUTHENT)lpNotification);
        break;

    case SF_NOTIFY_PREPROC_HEADERS:
        dwResult = OnPreProcHeaders(pfc, (PHTTP_FILTER_PREPROC_HEADERS)lpNotification);
        break;

    default:
        dwResult = SF_STATUS_REQ_NEXT_NOTIFICATION;
        break;
    }

    return dwResult;
}


BOOL WINAPI
TerminateFilter(
    DWORD   dwFlags
    )
{
    HRESULT hrCoInit;

    hrCoInit = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if(g_piFastAuth)
    {
        g_piFastAuth->Release();
        g_piFastAuth = NULL;
    }

    if(SUCCEEDED(hrCoInit))
        CoUninitialize();

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\passportmanager\localconfigstress\localconfigstress.cpp ===
#define _WIN32_WINNT 0x0403

#include "..\stdafx.h"
#include <msxml.h>
#include "..\passportconfiguration.h"
#include "PassportAlertInterface.h"
#include "..\nexusconfig.h"
#include "nexus.h"

PassportAlertInterface* g_pAlert;

void main(void)
{
    IXMLDocument*   piXMLDoc = NULL;

    CoInitializeEx(NULL, COINIT_MULTITHREADED);

    g_pAlert = CreatePassportAlertObject(PassportAlertInterface::EVENT_TYPE);
    if(g_pAlert)
    {
        g_pAlert->initLog(PM_ALERTS_REGISTRY_KEY, EVCAT_PM, NULL, 1);
    }

    //if(!GetCCD(TEXT("PARTNER"), &piXMLDoc, TRUE))
      //  return;

    CPassportConfiguration* pConfig = new CPassportConfiguration();
    if(!pConfig)
        return;

    for(int i = 0; i < 100; i++)
    {
        pConfig->UpdateNow(FALSE);
    }

    CoUninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\passportmanager\pptestext\pptestext.h ===
#if !defined(AFX_PPTESTEXT_H__DD8764F7_BB88_11D2_9454_00C04F72DC08__INCLUDED_)
#define AFX_PPTESTEXT_H__DD8764F7_BB88_11D2_9454_00C04F72DC08__INCLUDED_

// PPTESTEXT.H - Header file for your Internet Server
//    PPTestExt Extension

#include "resource.h"

class CPPTestExtExtension : public CHttpServer
{
public:
	CPPTestExtExtension();
	~CPPTestExtExtension();

// Overrides
	// ClassWizard generated virtual function overrides
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//{{AFX_VIRTUAL(CPPTestExtExtension)
	public:
	virtual BOOL GetExtensionVersion(HSE_VERSION_INFO* pVer);
	//}}AFX_VIRTUAL
	virtual BOOL TerminateExtension(DWORD dwFlags);

    DWORD HttpExtensionProc(EXTENSION_CONTROL_BLOCK *pECB);

	//{{AFX_MSG(CPPTestExtExtension)
	//}}AFX_MSG
};


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PPTESTEXT_H__DD8764F7_BB88_11D2_9454_00C04F72DC08__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\passportmanager\pptestext\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by PPTestExt.rc
//
#define IDS_SERVER                      102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         103
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\passportmanager\pptestext\pptestext.cpp ===
// PPTESTEXT.CPP - Implementation file for your Internet Server
//    PPTestExt Extension

#include "stdafx.h"
#include <comdef.h>
#include <httpext.h>
#include "passport.h"

BOOL WINAPI GetExtensionVersion(HSE_VERSION_INFO* pVer)
{
    // Create the extension version string, and 
    // copy string to HSE_VERSION_INFO structure.
    pVer->dwExtensionVersion = 
        MAKELONG(HSE_VERSION_MINOR, HSE_VERSION_MAJOR);

    // Copy description string into HSE_VERSION_INFO structure.
    lstrcpyA(pVer->lpszExtensionDesc, "Passport Test Extension");	
    
    return TRUE;
}

BOOL WINAPI TerminateExtension(DWORD dwFlags)
{
	return TRUE;
}

///////////////////////////////////////////////////////////////////////
// CPPTestExtExtension command handlers

DWORD WINAPI HttpExtensionProc(EXTENSION_CONTROL_BLOCK* pECB)
{
    HRESULT                 hr;
    DWORD                   dwRet;
    IPassportManager*       piPM = NULL;
    VARIANT_BOOL            bAuthenticated;
    CHAR                    achCookieBuf[4096];
    CHAR                    achUrlBuf[4096];
    CHAR                    achStatus[32];
    DWORD                   dwBufLen;
    _bstr_t                 bstrReturnURL;
    BSTR                    bstrAuthURL;
    VARIANT                 vtTimeWindow;
    VARIANT                 vtForceSignin;
    VARIANT                 vtReturnURL;
    VARIANT                 vtNoParam;
    VARIANT_BOOL            bFromNetworkServer;
    HSE_SEND_HEADER_EX_INFO hseSendHeaderExInfo;

    VariantInit(&vtNoParam);
    vtNoParam.vt = VT_ERROR;
    vtNoParam.scode = DISP_E_PARAMNOTFOUND;

    hr = CoCreateInstance(CLSID_Manager, NULL, CLSCTX_INPROC_SERVER, IID_IPassportManager, (void**)&piPM);
    if(hr != S_OK)
    {
        dwRet = HSE_STATUS_ERROR;
        goto Cleanup;
    }
      
    dwBufLen = sizeof(achCookieBuf);
    hr = piPM->OnStartPageECB((LPBYTE)pECB, &dwBufLen, achCookieBuf);
    if(hr != S_OK)
    {
        dwRet = HSE_STATUS_ERROR;
        goto Cleanup;
    }

    VariantInit(&vtTimeWindow);
    vtTimeWindow.vt = VT_I4;
    vtTimeWindow.lVal = 1000000;

    VariantInit(&vtForceSignin);
    vtForceSignin.vt = VT_BOOL;
    vtForceSignin.boolVal = VARIANT_FALSE;

    hr = piPM->IsAuthenticated(vtTimeWindow, vtForceSignin, vtNoParam, &bAuthenticated);
    if(hr != S_OK)
    {
        dwRet = HSE_STATUS_ERROR;
        goto Cleanup;
    }

    if(!bAuthenticated)
    {
        lstrcpyA(achUrlBuf, "http://");
        dwBufLen = sizeof(achUrlBuf) - sizeof("http://");
        pECB->GetServerVariable(pECB->ConnID, 
                                "SERVER_NAME", 
                                &(achUrlBuf[lstrlenA(achUrlBuf)]), 
                                &dwBufLen);

        dwBufLen = sizeof(achUrlBuf) - lstrlenA(achUrlBuf);
        pECB->GetServerVariable(pECB->ConnID,
                                "SCRIPT_NAME",
                                &(achUrlBuf[lstrlenA(achUrlBuf)]),
                                &dwBufLen);

        bstrReturnURL = achUrlBuf;

        //  Get the URL for the login page.

        VariantInit(&vtReturnURL);
        vtReturnURL.vt = VT_BSTR;
        vtReturnURL.bstrVal = bstrReturnURL;

        hr = piPM->AuthURL(vtReturnURL, 
                           vtTimeWindow, 
                           vtForceSignin, 
                           vtNoParam, 
                           vtNoParam, 
                           vtNoParam, 
                           vtNoParam, 
                           vtNoParam, 
                           &bstrAuthURL);
        
        //  Redirect to login page.
        dwBufLen = SysStringLen(bstrAuthURL);
        pECB->ServerSupportFunction(pECB->ConnID, 
                                    HSE_REQ_SEND_URL_REDIRECT_RESP,
                                    (char*)_bstr_t(bstrAuthURL),
                                    &dwBufLen,
                                    NULL);
    }
    else
    {
        piPM->get_FromNetworkServer(&bFromNetworkServer);

        if(bFromNetworkServer)
        {
            lstrcpyA(achUrlBuf, "http://");
            dwBufLen = sizeof(achUrlBuf) - sizeof("http://");
            pECB->GetServerVariable(pECB->ConnID, 
                                    "SERVER_NAME", 
                                    &(achUrlBuf[lstrlenA(achUrlBuf)]), 
                                    &dwBufLen);

            dwBufLen = sizeof(achUrlBuf) - lstrlenA(achUrlBuf);
            pECB->GetServerVariable(pECB->ConnID,
                                    "SCRIPT_NAME",
                                    &(achUrlBuf[lstrlenA(achUrlBuf)]),
                                    &dwBufLen);

            
            lstrcpyA(achStatus, "302 Moved");

            lstrcatA(achCookieBuf, "Location: ");
            lstrcatA(achCookieBuf, achUrlBuf);
            lstrcatA(achCookieBuf, "\r\n\r\n");

            hseSendHeaderExInfo.pszStatus = achStatus;
            hseSendHeaderExInfo.pszHeader = achCookieBuf;
            hseSendHeaderExInfo.cchStatus = lstrlenA(achStatus);
            hseSendHeaderExInfo.cchHeader = lstrlenA(achCookieBuf);
            hseSendHeaderExInfo.fKeepConn = TRUE;
        }
        else
        {
            char achNumBuf[16];

#define RESPONSE_BODY "<html><head><title>Test ISAPI Ext.</title></head><body>You're auth'ed!</body></html>"
            
            lstrcpyA(achStatus, "200 OK");

            lstrcatA(achCookieBuf, "Content-Type: text/html\r\nContent-Length: ");

            _itoa(sizeof(RESPONSE_BODY), achNumBuf, 10);

            lstrcatA(achCookieBuf, achNumBuf);
            lstrcatA(achCookieBuf, "\r\n\r\n");

            hseSendHeaderExInfo.pszStatus = achStatus;
            hseSendHeaderExInfo.pszHeader = achCookieBuf;
            hseSendHeaderExInfo.cchStatus = lstrlenA(achStatus);
            hseSendHeaderExInfo.cchHeader = lstrlenA(achCookieBuf);
            hseSendHeaderExInfo.fKeepConn = TRUE;
        }

        pECB->ServerSupportFunction(pECB->ConnID,
                                    HSE_REQ_SEND_RESPONSE_HEADER_EX,
                                    &hseSendHeaderExInfo,
                                    NULL,
                                    NULL);

        dwBufLen = sizeof(RESPONSE_BODY);
        pECB->WriteClient(pECB->ConnID,
                          RESPONSE_BODY,
                          &dwBufLen,
                          HSE_IO_SYNC);
    }

    dwRet = HSE_STATUS_SUCCESS;

Cleanup:

    VariantClear(&vtTimeWindow);
    VariantClear(&vtForceSignin);
    VariantClear(&vtReturnURL);
    VariantClear(&vtNoParam);

    if(piPM)
        piPM->Release();

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\passportmanager\pptestext\stdafx.h ===
#if !defined(AFX_STDAFX_H__DD8764FD_BB88_11D2_9454_00C04F72DC08__INCLUDED_)
#define AFX_STDAFX_H__DD8764FD_BB88_11D2_9454_00C04F72DC08__INCLUDED_

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__DD8764FD_BB88_11D2_9454_00C04F72DC08__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\pmconfig\filecfg.cpp ===
/**************************************************************************
   Copyright (C) 1999  Microsoft Corporation.  All Rights Reserved.

   MODULE:     FILECFG.CPP

   PURPOSE:    Source module reading/writing PM config sets from a file

   FUNCTIONS:

   COMMENTS:
      
**************************************************************************/

/**************************************************************************
   Include Files
**************************************************************************/

#include "pmcfg.h"

#define MAX_EXT     10
#define MAX_FILTER  256

TCHAR g_szPassportManager[] = "PassportManager";

/**************************************************************************

    PMAdmin_GetFileName

*******************************************************************************/
BOOL PMAdmin_GetFileName
(
    HWND    hWnd,
    BOOL    fOpen,
    LPTSTR  lpFileName,
    DWORD   cbFileName
)
{
    UINT            TitleStringID, FilterID;
    TCHAR           szTitle[MAX_TITLE];
    TCHAR           szDefaultExtension[MAX_EXT];
    TCHAR           szFilter[MAX_FILTER];
    LPTSTR          lpFilterChar;
    OPENFILENAME    OpenFileName;
    BOOL            fSuccess;

    //
    //  Load various strings that will be displayed and used by the common open
    //  or save dialog box.  Note that if any of these fail, the error is not
    //  fatal-- the common dialog box may look odd, but will still work.
    //

    if (fOpen)
    {
        TitleStringID = IDS_OPENFILETITLE;
        FilterID = IDS_PMOPENFILEFILTER;
    }
    else
    {
        TitleStringID = IDS_SAVEFILETITLE;
        FilterID = IDS_PMSAVEFILEFILTER;
    }        

    LoadString(g_hInst, TitleStringID, szTitle, sizeof(szTitle));
    LoadString(g_hInst, IDS_PMCONFIGDEFEXT, szDefaultExtension, sizeof(szDefaultExtension));

    if (LoadString(g_hInst, FilterID, szFilter, sizeof(szFilter)))
    {
        //
        //  The common dialog library requires that the substrings of the
        //  filter string be separated by nulls, but we cannot load a string
        //  containing nulls.  So we use some dummy character in the resource
        //  that we now convert to nulls.
        //
        for (lpFilterChar = szFilter; 
             *lpFilterChar != 0; 
              lpFilterChar = CharNext(lpFilterChar)) 
        {

            if (*lpFilterChar == TEXT('#'))
                *lpFilterChar++ = 0;
        }
    }

    ZeroMemory(&OpenFileName, sizeof(OPENFILENAME));

    OpenFileName.lStructSize = sizeof(OPENFILENAME);
    OpenFileName.hwndOwner = hWnd;
    OpenFileName.hInstance = g_hInst;
    OpenFileName.lpstrFilter = szFilter;
    OpenFileName.lpstrFile = lpFileName;
    OpenFileName.nMaxFile = cbFileName;
    OpenFileName.lpstrTitle = szTitle;
    OpenFileName.lpstrDefExt = szDefaultExtension;
    if (fOpen) 
    {
        OpenFileName.Flags = OFN_HIDEREADONLY | OFN_EXPLORER | OFN_FILEMUSTEXIST;
        fSuccess = GetOpenFileName(&OpenFileName);
    }
    else 
    {
        OpenFileName.Flags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT |
            OFN_EXPLORER | OFN_NOREADONLYRETURN | OFN_PATHMUSTEXIST;
        fSuccess = GetSaveFileName(&OpenFileName);
    }
    return fSuccess;
}

/**************************************************************************

    ReadFileConfigSet
    
    Read the current passport manager config set from the specified file
    
**************************************************************************/
BOOL ReadFileConfigSet
(
    LPPMSETTINGS    lpPMConfig,
    LPCTSTR         lpszFileName
)
{
    DWORD dwTemp;
    TCHAR achTemp[INTERNET_MAX_URL_LENGTH];

    // makesure the specified file exists.
    if (!PathFileExists(lpszFileName))
    {
        ReportError(NULL, IDS_FILENOTFOUND);
        return FALSE;
    }
        
    // Read the Time Window Number
    dwTemp = GetPrivateProfileInt(g_szPassportManager,
                                  g_szTimeWindow,
                                  -1,
                                  lpszFileName);
    if(dwTemp != -1)
        lpPMConfig->dwTimeWindow = dwTemp;
        
    // Read the value for Forced Signin
    dwTemp = GetPrivateProfileInt(g_szPassportManager,
                                  g_szForceSignIn,
                                  -1,
                                  lpszFileName);
    if(dwTemp != -1)
        lpPMConfig->dwForceSignIn = dwTemp;

    // Read the default language ID
    dwTemp = GetPrivateProfileInt(g_szPassportManager,
                                  g_szLanguageID,
                                  -1,
                                  lpszFileName);
    if(dwTemp != -1)
        lpPMConfig->dwLanguageID = dwTemp;

    // Get the co-branding template
    GetPrivateProfileString(g_szPassportManager,
                            g_szCoBrandTemplate,
                            (LPTSTR)TEXT("\xFF"),
                            achTemp,
                            sizeof(achTemp),
                            lpszFileName);
    if(lstrcmp(achTemp, TEXT("\xFF")) != 0)
        lstrcpy(lpPMConfig->szCoBrandTemplate, achTemp);

    
    // Get the SiteID
    dwTemp = GetPrivateProfileInt(g_szPassportManager,
                                  g_szSiteID,
                                  -1,
                                  lpszFileName);
    if(dwTemp != -1)
        lpPMConfig->dwSiteID = dwTemp;
    
    // Get the return URL template
    GetPrivateProfileString(g_szPassportManager,
                            g_szReturnURL,
                            (LPTSTR)TEXT("\xFF"),
                            achTemp,
                            sizeof(achTemp),
                            lpszFileName);
    if(lstrcmp(achTemp, TEXT("\xFF")) != 0)
        lstrcpy(lpPMConfig->szReturnURL, achTemp);

    // Get the ticket cookie domain
    GetPrivateProfileString(g_szPassportManager,
                            g_szTicketDomain,
                            (LPTSTR)TEXT("\xFF"),
                            achTemp,
                            sizeof(achTemp),
                            lpszFileName);
    if(lstrcmp(achTemp, TEXT("\xFF")) != 0)
        lstrcpy(lpPMConfig->szTicketDomain, achTemp);

    // Get the ticket cookie path
    GetPrivateProfileString(g_szPassportManager,
                            g_szTicketPath,
                            (LPTSTR)TEXT("\xFF"),
                            achTemp,
                            sizeof(achTemp),
                            lpszFileName);
    if(lstrcmp(achTemp, TEXT("\xFF")) != 0)
        lstrcpy(lpPMConfig->szTicketPath, achTemp);

    // Get the profile cookie domain
    GetPrivateProfileString(g_szPassportManager,
                            g_szProfileDomain,
                            (LPTSTR)TEXT("\xFF"),
                            achTemp,
                            sizeof(achTemp),
                            lpszFileName);
    if(lstrcmp(achTemp, TEXT("\xFF")) != 0)
        lstrcpy(lpPMConfig->szProfileDomain, achTemp);

    // Get the profile cookie path
    GetPrivateProfileString(g_szPassportManager,
                            g_szProfilePath,
                            (LPTSTR)TEXT("\xFF"),
                            achTemp,
                            sizeof(achTemp),
                            lpszFileName);
    if(lstrcmp(achTemp, TEXT("\xFF")) != 0)
        lstrcpy(lpPMConfig->szProfilePath, achTemp);

    // Get the secure cookie domain
    GetPrivateProfileString(g_szPassportManager,
                            g_szSecureDomain,
                            (LPTSTR)TEXT("\xFF"),
                            achTemp,
                            sizeof(achTemp),
                            lpszFileName);
    if(lstrcmp(achTemp, TEXT("\xFF")) != 0)
        lstrcpy(lpPMConfig->szSecureDomain, achTemp);

    // Get the secure cookie path
    GetPrivateProfileString(g_szPassportManager,
                            g_szSecurePath,
                            (LPTSTR)TEXT("\xFF"),
                            achTemp,
                            sizeof(achTemp),
                            lpszFileName);
    if(lstrcmp(achTemp, TEXT("\xFF")) != 0)
        lstrcpy(lpPMConfig->szSecurePath, achTemp);

    // Get the DisasterURL
    GetPrivateProfileString(g_szPassportManager,
                            g_szDisasterURL,
                            (LPTSTR)TEXT("\xFF"),
                            achTemp,
                            sizeof(achTemp),
                            lpszFileName);
    if(lstrcmp(achTemp, TEXT("\xFF")) != 0)
        lstrcpy(lpPMConfig->szDisasterURL, achTemp);

    // Get Standalone mode setting
    dwTemp = GetPrivateProfileInt(g_szPassportManager,
                                  g_szStandAlone,
                                  -1,
                                  lpszFileName);
    if(dwTemp != -1)
        lpPMConfig->dwStandAlone = dwTemp;
    
    // Get DisableCookies mode setting
    dwTemp = GetPrivateProfileInt(g_szPassportManager,
                                  g_szDisableCookies,
                                  -1,
                                  lpszFileName);
    if(dwTemp != -1)
        lpPMConfig->dwDisableCookies = dwTemp;

    // Get the HostName
    GetPrivateProfileString(g_szPassportManager,
                            g_szHostName,
                            (LPTSTR)TEXT("\xFF"),
                            achTemp,
                            sizeof(achTemp),
                            lpszFileName);
    if(lstrcmp(achTemp, TEXT("\xFF")) != 0)
        lstrcpy(lpPMConfig->szHostName, achTemp);

    // Get the HostIP
    GetPrivateProfileString(g_szPassportManager,
                            g_szHostIP,
                            (LPTSTR)TEXT("\xFF"),
                            achTemp,
                            sizeof(achTemp),
                            lpszFileName);
    if(lstrcmp(achTemp, TEXT("\xFF")) != 0)
        lstrcpy(lpPMConfig->szHostIP, achTemp);

    return TRUE; 
}


/**************************************************************************

    WriteFileConfigSet
    
    Writes the current passport manager config set to the specified file
    
**************************************************************************/
BOOL WriteFileConfigSet
(
    LPPMSETTINGS    lpPMConfig,
    LPCTSTR         lpszFileName
)
{
    TCHAR   szTemp[MAX_PATH];
    
    // Write the Time Window Number
    wsprintf (szTemp, "%d", lpPMConfig->dwTimeWindow);
    WritePrivateProfileString(g_szPassportManager,
                              g_szTimeWindow,
                              szTemp,
                              lpszFileName);
        
    // write the value for Forced Signin
    wsprintf (szTemp, "%d", lpPMConfig->dwForceSignIn);
    WritePrivateProfileString(g_szPassportManager,
                              g_szForceSignIn,
                              szTemp,
                              lpszFileName);
                              
    // Read the default language ID
    wsprintf (szTemp, "%d", lpPMConfig->dwLanguageID);
    WritePrivateProfileString(g_szPassportManager,
                              g_szLanguageID,
                              szTemp,
                              lpszFileName);
                              
    // Write the co-branding template
    WritePrivateProfileString(g_szPassportManager,
                             g_szCoBrandTemplate,
                             lpPMConfig->szCoBrandTemplate,
                             lpszFileName);
    
    // Write the SiteID
    wsprintf (szTemp, "%d",lpPMConfig->dwSiteID);
    WritePrivateProfileString(g_szPassportManager,
                              g_szSiteID,
                              szTemp,
                              lpszFileName);
    
    // Write the return URL template
    WritePrivateProfileString(g_szPassportManager,
                              g_szReturnURL,
                              lpPMConfig->szReturnURL,
                              lpszFileName);
    
    // Write the ticket cookie domain
    WritePrivateProfileString(g_szPassportManager,
                              g_szTicketDomain,
                              lpPMConfig->szTicketDomain,
                              lpszFileName);
    
    // Write the ticket cookie path
    WritePrivateProfileString(g_szPassportManager,
                              g_szTicketPath,
                              lpPMConfig->szTicketPath,
                              lpszFileName);

    // Write the profile cookie domain
    WritePrivateProfileString(g_szPassportManager,
                              g_szProfileDomain,
                              lpPMConfig->szProfileDomain,
                              lpszFileName);
    
    // Write the profile cookie path
    WritePrivateProfileString(g_szPassportManager,
                              g_szProfilePath,
                              lpPMConfig->szProfilePath,
                              lpszFileName);

    // Write the secure cookie domain
    WritePrivateProfileString(g_szPassportManager,
                              g_szSecureDomain,
                              lpPMConfig->szSecureDomain,
                              lpszFileName);

    // Write the secure profile cookie path
    WritePrivateProfileString(g_szPassportManager,
                              g_szSecurePath,
                              lpPMConfig->szSecurePath,
                              lpszFileName);

    // Write the Disaster URL
    WritePrivateProfileString(g_szPassportManager,
                              g_szDisasterURL,
                              lpPMConfig->szDisasterURL,
                              lpszFileName);
    
    // Write Standalone mode setting
    wsprintf (szTemp, "%d", lpPMConfig->dwStandAlone);
    WritePrivateProfileString(g_szPassportManager,
                           g_szStandAlone,
                           szTemp,
                           lpszFileName);
    
    // Write DisableCookies mode setting
    wsprintf (szTemp, "%d", lpPMConfig->dwDisableCookies);
    WritePrivateProfileString(g_szPassportManager,
                              g_szDisableCookies,
                              szTemp,
                              lpszFileName);

    // Write the Host Name
    WritePrivateProfileString(g_szPassportManager,
                              g_szHostName,
                              lpPMConfig->szHostName,
                              lpszFileName);
    
    // Write the Host IP
    WritePrivateProfileString(g_szPassportManager,
                              g_szHostIP,
                              lpPMConfig->szHostIP,
                              lpszFileName);
    
    return TRUE; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\pmconfig\mru.h ===
#ifndef __MRU_H
#define __MRU_H

class PpMRU
{
public:
    PpMRU(int nSize);
    ~PpMRU();

    LPCTSTR operator [] (int nIndex);

    BOOL insert(LPCTSTR sz);
    BOOL save(LPCTSTR szSection, LPCTSTR szFilename);
    BOOL load(LPCTSTR szSection, LPCTSTR szFilename);

private:

    int     m_nSize;
    LPTSTR* m_ppszList;
};

#endif // __MRU_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\pmconfig\mru.cpp ===
#include "pmcfg.h"
#include "mru.h"


PpMRU::PpMRU(int nSize) : m_nSize(nSize)
{
    m_ppszList = new LPTSTR[nSize];
    ZeroMemory(m_ppszList, m_nSize * sizeof(LPTSTR));
}


PpMRU::~PpMRU()
{
    int nIndex;

    if(m_ppszList)
    {
        for(nIndex = 0; nIndex < m_nSize; nIndex++)
        {
            if(m_ppszList[nIndex])
                delete [] m_ppszList[nIndex];
        }

        delete [] m_ppszList;
    }
}


BOOL
PpMRU::insert
(
    LPCTSTR sz
)
{
    int     nIndex;
    LPTSTR  szNew;

    //
    //  If the string is already in the list, just
    //  reshuffle so that it is at the top.  Even 
    //  simpler, if the string is already the first
    //  item in the list then do nothing!
    //

    if(m_ppszList[0] && lstrcmp(sz, m_ppszList[0]) == 0)
        return TRUE;

    for(nIndex = 1; nIndex < m_nSize && m_ppszList[nIndex]; nIndex++)
    {
        if(lstrcmp(sz, m_ppszList[nIndex]) == 0)
        {
            LPTSTR szTemp = m_ppszList[nIndex];
            for(int nIndex2 = nIndex; nIndex2 > 0; nIndex2--)
                m_ppszList[nIndex2] = m_ppszList[nIndex2 - 1];

            m_ppszList[0] = szTemp;
            return TRUE;            
        }
    }

    //
    //  New item in list.  Allocate memory, copy and 
    //  shove list down.
    //

    szNew = new TCHAR[lstrlen(sz) + 1];
    if(!szNew)
        return FALSE;

    lstrcpy(szNew, sz);

    if(m_ppszList[m_nSize - 1])
        delete [] m_ppszList[m_nSize - 1];

    for(nIndex = m_nSize - 1; nIndex > 0; nIndex--)
    {
        m_ppszList[nIndex] = m_ppszList[nIndex - 1];
    }

    m_ppszList[0] = szNew;

    return TRUE;
}


LPCTSTR
PpMRU::operator[]
(
    int nIndex
)
{
    return m_ppszList[nIndex];
}


BOOL
PpMRU::load
(
    LPCTSTR szSection,
    LPCTSTR szFilename
)
{
    int     nIndex;
    TCHAR   achNumBuf[16];
    TCHAR   achBuf[MAX_PATH];

    for(nIndex = 0; nIndex < m_nSize; nIndex++)
    {
        _itot(nIndex + 1, achNumBuf, 10);

        GetPrivateProfileString(szSection, 
                                achNumBuf, 
                                TEXT(""), 
                                achBuf, 
                                MAX_PATH, 
                                szFilename);

        if(lstrlen(achBuf))
        {
            m_ppszList[nIndex] = new TCHAR[lstrlen(achBuf) + 1];
            if(m_ppszList[nIndex])
                lstrcpy(m_ppszList[nIndex], achBuf);
        }
        else
        {
            m_ppszList[nIndex] = NULL;
        }
    }

    return TRUE;
}


BOOL
PpMRU::save
(
    LPCTSTR szSection,
    LPCTSTR szFilename
)
{
    int     nIndex;
    TCHAR   achNumBuf[16];

    //  Make sure any previously existing section is erased.
    WritePrivateProfileString(szSection, NULL, NULL, szFilename);

    //  Now save all the entries.
    for(nIndex = 0; nIndex < m_nSize && m_ppszList[nIndex]; nIndex++)
    {
        _itot(nIndex + 1, achNumBuf, 10);

        WritePrivateProfileString(szSection,
                                  achNumBuf,
                                  m_ppszList[nIndex],
                                  szFilename
                                  );
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\pmconfig\message.cpp ===
/**************************************************************************
   Copyright (C) 1999  Microsoft Corporation.  All Rights Reserved.

   MODULE:     MESSAGE.CPP

   PURPOSE:    Source module for Passport Manager config tool

   FUNCTIONS:

   COMMENTS:
      
**************************************************************************/

/**************************************************************************
   Include Files
**************************************************************************/

#include "pmcfg.h"

struct 
{
    UINT    uErrorID;
    UINT    uWarningID;    
}  g_ControlMessageTable[] = 
{
    {IDS_TIMEWINDOW_ERROR, IDS_CONSISTENCY_WARN},       //IDC_TIMEWINDOW
    {0, IDS_CONSISTENCY_WARN},                          //IDC_FORCESIGNIN
    {IDS_LANGUAGEID_ERROR, IDS_CONSISTENCY_WARN},       //IDC_LANGUAGEID
    {IDS_COBRANDING_ERROR, IDS_CONSISTENCY_WARN},       //IDC_COBRANDING_TEMPLATE   
    {IDS_SITEID_ERROR, IDS_SITEID_WARN},                //IDC_SITEID
    {IDS_RETURNURL_ERROR, IDS_CONSISTENCY_WARN},        //IDC_RETURNURL
    {IDS_COOKIEDOMAIN_ERROR, IDS_CONSISTENCY_WARN},     //IDC_COOKIEDOMAIN
    {IDS_COOKIEPATH_ERROR, IDS_CONSISTENCY_WARN},       //IDC_COOKIEPATH
    {0, IDS_STANDALONE_WARN},                           //IDC_STANDALONE
    {0, IDS_DISABLECOOKIE_WARN},                        //IDC_DISABLECOOKIES
    {IDS_DISASTERURL_ERROR, IDS_CONSISTENCY_WARN},      //IDC_DISASTERURL
    {IDS_HOSTNAME_ERROR, IDS_CONSISTENCY_WARN},         //IDC_HOSTNAMEEDIT
    {IDS_HOSTIP_ERROR, IDS_CONSISTENCY_WARN},            //IDC_HOSTIPEDIT
    {IDS_PROFILEDOMAIN_ERROR, IDS_CONSISTENCY_WARN},    //IDC_PROFILEDOMAIN
    {IDS_PROFILEPATH_ERROR, IDS_CONSISTENCY_WARN},      //IDC_PROFILEPATH
    {IDS_SECUREDOMAIN_ERROR, IDS_CONSISTENCY_WARN},     //IDC_SECUREDOMAIN
    {IDS_SECUREPATH_ERROR, IDS_CONSISTENCY_WARN}        //IDC_SECUREPATH
};

LRESULT CALLBACK    CommitOKDlgProc(HWND hWndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

void ReportControlMessage
(
    HWND    hWnd, 
    INT     idCtrl, 
    WORD    wMessageType
)
{
    UINT    uMBType = MB_OK;
    TCHAR   szMessageBoxTitle[MAX_TITLE];
    TCHAR   szMessage[MAX_MESSAGE];
    UINT    uID;
    
    // Load the appropriate title
    switch (wMessageType)
    {
        case VALIDATION_ERROR:
            LoadString(g_hInst, IDS_ERROR, szMessageBoxTitle, sizeof(szMessageBoxTitle));
            uMBType |= MB_ICONERROR;
            uID = g_ControlMessageTable[idCtrl - CTRL_BASE].uErrorID;
            break;
            
        case CHANGE_WARNING:
            LoadString(g_hInst, IDS_WARNING, szMessageBoxTitle, sizeof(szMessageBoxTitle));
            uMBType |= MB_ICONWARNING;
            uID = g_ControlMessageTable[idCtrl - CTRL_BASE].uWarningID;
            break;
    }
    
    // Load the appropriate message
    LoadString(g_hInst, uID, szMessage, sizeof(szMessage));
    MessageBox(hWnd, szMessage, szMessageBoxTitle, uMBType);               
}

BOOL CommitOKWarning
(
    HWND            hWndDlg
)
{
    if (IDOK == DialogBox( g_hInst, 
                           MAKEINTRESOURCE (IDD_CONFIRM_COMMIT), 
                           hWndDlg, 
                           (DLGPROC)CommitOKDlgProc ))
        return TRUE;
    else
        return FALSE;                                    

}

void ReportError
(
    HWND    hWndDlg,
    UINT    idError
)
{
    TCHAR   szMessageBoxTitle[MAX_TITLE];
    TCHAR   szMessage[MAX_MESSAGE];

    LoadString(g_hInst, IDS_ERROR, szMessageBoxTitle, sizeof(szMessageBoxTitle));
    LoadString(g_hInst, idError, szMessage, sizeof(szMessage));
    
    MessageBox(hWndDlg, szMessage, szMessageBoxTitle, MB_OK | MB_ICONERROR);
}

LRESULT CALLBACK CommitOKDlgProc
(
    HWND     hWndDlg,
    UINT     uMsg,
    WPARAM   wParam,
    LPARAM   lParam
)
{
    switch ( uMsg )
    {
        case WM_INITDIALOG:
        {
            TCHAR   szTemp[MAX_RESOURCE];
            TCHAR   szFields[MAX_MESSAGE];
            BOOL    bOther = FALSE;
                                    
            // See if we need to hide the other process warning.
            if (VerifyRegConfigSet(hWndDlg, &g_OriginalSettings, g_szRemoteComputer))
            {
                ShowWindow(GetDlgItem(hWndDlg, IDC_OTHERPROCESS), SW_HIDE);
            }

            // See which of the "other" fields have been modified
            szFields[0] = '\0';
            if (g_OriginalSettings.dwTimeWindow != g_CurrentSettings.dwTimeWindow)
            {
                bOther = TRUE;
                LoadString(g_hInst, IDS_TIMEWINDOW, szTemp, sizeof(szTemp));
                lstrcat(szFields, szTemp);
            }
            if (g_OriginalSettings.dwForceSignIn != g_CurrentSettings.dwForceSignIn)
            {
                bOther = TRUE;
                LoadString(g_hInst, IDS_FORCESIGNIN, szTemp, sizeof(szTemp));
                lstrcat(szFields, szTemp);
            }
            if (g_OriginalSettings.dwLanguageID != g_CurrentSettings.dwLanguageID)
            {
                bOther = TRUE;
                LoadString(g_hInst, IDS_LANGUAGEID, szTemp, sizeof(szTemp));
                lstrcat(szFields, szTemp);
            }
            if (0 != lstrcmpi(g_OriginalSettings.szCoBrandTemplate, g_CurrentSettings.szCoBrandTemplate))
            {
                bOther = TRUE;
                LoadString(g_hInst, IDS_COBRANDTEMPLATE, szTemp, sizeof(szTemp));
                lstrcat(szFields, szTemp);
            }
            if (0 != lstrcmpi(g_OriginalSettings.szReturnURL, g_CurrentSettings.szReturnURL))
            {
                bOther = TRUE;
                LoadString(g_hInst, IDS_RETURNURL, szTemp, sizeof(szTemp));
                lstrcat(szFields, szTemp);
            }
            if (0 != lstrcmpi(g_OriginalSettings.szTicketDomain, g_CurrentSettings.szTicketDomain))
            {
                bOther = TRUE;
                LoadString(g_hInst, IDS_COOKIEDOMAIN, szTemp, sizeof(szTemp));
                lstrcat(szFields, szTemp);
            }
            if (0 != lstrcmpi(g_OriginalSettings.szTicketPath, g_CurrentSettings.szTicketPath))
            {
                bOther = TRUE;
                LoadString(g_hInst, IDS_COOKIEPATH, szTemp, sizeof(szTemp));
                lstrcat(szFields, szTemp);
            }
            if (0 != lstrcmpi(g_OriginalSettings.szProfileDomain, g_CurrentSettings.szProfileDomain))
            {
                bOther = TRUE;
                LoadString(g_hInst, IDS_PROFILEDOMAIN, szTemp, sizeof(szTemp));
                lstrcat(szFields, szTemp);
            }
            if (0 != lstrcmpi(g_OriginalSettings.szProfilePath, g_CurrentSettings.szProfilePath))
            {
                bOther = TRUE;
                LoadString(g_hInst, IDS_PROFILEPATH, szTemp, sizeof(szTemp));
                lstrcat(szFields, szTemp);
            }
            if (0 != lstrcmpi(g_OriginalSettings.szSecureDomain, g_CurrentSettings.szSecureDomain))
            {
                bOther = TRUE;
                LoadString(g_hInst, IDS_SECUREDOMAIN, szTemp, sizeof(szTemp));
                lstrcat(szFields, szTemp);
            }
            if (0 != lstrcmpi(g_OriginalSettings.szSecurePath, g_CurrentSettings.szSecurePath))
            {
                bOther = TRUE;
                LoadString(g_hInst, IDS_SECUREPATH, szTemp, sizeof(szTemp));
                lstrcat(szFields, szTemp);
            }
            if (0 != lstrcmpi(g_OriginalSettings.szDisasterURL, g_CurrentSettings.szDisasterURL))
            {
                bOther = TRUE;
                LoadString(g_hInst, IDS_DISASTERURL, szTemp, sizeof(szTemp));
                lstrcat(szFields, szTemp);
            }
            if (0 != lstrcmpi(g_OriginalSettings.szHostName, g_CurrentSettings.szHostName))
            {
                bOther = TRUE;
                LoadString(g_hInst, IDS_HOSTNAME, szTemp, sizeof(szTemp));
                lstrcat(szFields, szTemp);
            }
            if (0 != lstrcmpi(g_OriginalSettings.szHostIP, g_CurrentSettings.szHostIP))
            {
                bOther = TRUE;
                LoadString(g_hInst, IDS_HOSTIP, szTemp, sizeof(szTemp));
                lstrcat(szFields, szTemp);
            }
            if (bOther)
            {
                // Kill the final comma and space, since each of the above field names has a 
                // comma and space for concatenation purposes
                szFields[lstrlen(szFields)-2] ='\0';  
                SetDlgItemText(hWndDlg, IDC_OTHER_TYPE, szFields);
            }
            else
            {
                ShowWindow(GetDlgItem(hWndDlg,IDC_OTHER_TYPE), SW_HIDE);
                ShowWindow(GetDlgItem(hWndDlg,IDC_OTHER_WARN), SW_HIDE);
            }

            // See if DisableCookies has been changed
            if (g_OriginalSettings.dwDisableCookies == g_CurrentSettings.dwDisableCookies)
            {
                ShowWindow(GetDlgItem(hWndDlg,IDC_COOKIES_TYPE), SW_HIDE);
                ShowWindow(GetDlgItem(hWndDlg,IDC_COOKIES_WARN), SW_HIDE);
            }

            // See if SiteID has been changed
            if (g_OriginalSettings.dwSiteID == g_CurrentSettings.dwSiteID)
            {
                ShowWindow(GetDlgItem(hWndDlg,IDC_SITEID_TYPE), SW_HIDE);
                ShowWindow(GetDlgItem(hWndDlg,IDC_SITEID_WARN), SW_HIDE);
            }

            // See if StandAlone Mode has been changed
            if (g_OriginalSettings.dwStandAlone == g_CurrentSettings.dwStandAlone)
            {
                ShowWindow(GetDlgItem(hWndDlg,IDC_STANDALONE_TYPE), SW_HIDE);
                ShowWindow(GetDlgItem(hWndDlg,IDC_STANDALONE_WARN), SW_HIDE);
            }
            return TRUE;
        }
        
        case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
                case IDOK:
                {
                    EndDialog( hWndDlg, TRUE );
                    break;
                }
                
                case IDCANCEL:
                {
                    EndDialog( hWndDlg, FALSE );
                    break;
                }
            }                
            break;
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\pmconfig\configset.cpp ===
#include "pmcfg.h"
#include <atlbase.h>
#include <atlconv.h>

DWORD   g_dwSiteNameBufLen;
DWORD   g_dwHostNameBufLen;
DWORD   g_dwHostIPBufLen;
LPTSTR  g_szSiteNameBuf;
LPTSTR  g_szHostNameBuf;
LPTSTR  g_szHostIPBuf;

LRESULT CALLBACK    NewConfigSetDlgProc(HWND hWndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);


BOOL IsValidIP(
    LPCTSTR pszIP
    )
{
    BOOL    bIsValid = TRUE;
    ULONG   ulAddr;

    USES_CONVERSION;

    ulAddr = inet_addr(T2A(const_cast<LPTSTR>(pszIP)));

    bIsValid = (ulAddr != INADDR_NONE);

    return bIsValid;
}


BOOL NewConfigSet
(
    HWND            hWndDlg,
    LPTSTR          szSiteNameBuf,
    DWORD           dwSiteNameBufLen,
    LPTSTR          szHostNameBuf,
    DWORD           dwHostNameBufLen,
    LPTSTR          szHostIPBuf,
    DWORD           dwHostIPBufLen
)
{
    g_dwSiteNameBufLen = dwSiteNameBufLen;
    g_dwHostNameBufLen = dwHostNameBufLen;
    g_dwHostIPBufLen   = dwHostIPBufLen;
    g_szSiteNameBuf    = szSiteNameBuf;
    g_szHostNameBuf    = szHostNameBuf;
    g_szHostIPBuf      = szHostIPBuf;

    if (IDOK == DialogBox( g_hInst, 
                           MAKEINTRESOURCE (IDD_NEW_CONFIGSET), 
                           hWndDlg, 
                           (DLGPROC)NewConfigSetDlgProc ))
        return TRUE;
    else
        return FALSE;                                    

}


BOOL RemoveConfigSetWarning
(
    HWND    hWndDlg
)
{
    TCHAR   szWarning[MAX_RESOURCE];
    TCHAR   szTitle[MAX_RESOURCE];

    LoadString(g_hInst, IDS_REMOVE_WARNING, szWarning, sizeof(szWarning));
    LoadString(g_hInst, IDS_REMOVE_TITLE, szTitle, sizeof(szTitle));

    return (MessageBox(hWndDlg, szWarning, szTitle, MB_OKCANCEL | MB_ICONQUESTION) == IDOK); 
}


LRESULT CALLBACK NewConfigSetDlgProc
(
    HWND     hWndDlg,
    UINT     uMsg,
    WPARAM   wParam,
    LPARAM   lParam
)
{
    switch ( uMsg )
    {
        case WM_INITDIALOG:
        {
            SendDlgItemMessage(hWndDlg, IDC_CONFIGSETEDIT, EM_SETLIMITTEXT, MAX_CONFIGSETNAME - 1, 0L);
            SendDlgItemMessage(hWndDlg, IDC_HOSTNAMEEDIT, EM_SETLIMITTEXT, INTERNET_MAX_HOST_NAME_LENGTH - 1, 0L);
            SendDlgItemMessage(hWndDlg, IDC_HOSTIPEDIT, EM_SETLIMITTEXT, MAX_IPLEN, 0L);
            SetFocus(GetDlgItem(hWndDlg, IDC_CONFIGSETEDIT));
            return FALSE;
        }

        case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
                case IDOK:
                {
                    TCHAR   szTemp[MAX_RESOURCE];
                    TCHAR   szTitle[MAX_RESOURCE];
                    LPTSTR  lpszConfigSetNames, lpszCur;

                    //
                    //  Check for empty site name
                    //

                    GetDlgItemText(hWndDlg, IDC_CONFIGSETEDIT, g_szSiteNameBuf, g_dwSiteNameBufLen);
                    if(lstrlen(g_szSiteNameBuf) == 0)
                    {
                        LoadString(g_hInst, IDS_EMPTYSITENAME, szTemp, sizeof(szTemp));
                        LoadString(g_hInst, IDS_ERROR, szTitle, sizeof(szTemp));
                        MessageBox(hWndDlg, szTemp, szTitle, MB_OK | MB_ICONEXCLAMATION);
                        SetFocus(GetDlgItem(hWndDlg, IDC_CONFIGSETEDIT));
                        break;
                    }

                    //
                    //  Make sure the site name isn't default
                    //

                    LoadString(g_hInst, IDS_DEFAULT, szTemp, sizeof(szTemp));
                    if(lstrcmp(g_szSiteNameBuf, szTemp) == 0)
                    {
                        LoadString(g_hInst, IDS_INVALIDSITENAME, szTemp, sizeof(szTemp));
                        LoadString(g_hInst, IDS_ERROR, szTitle, sizeof(szTitle));
                        MessageBox(hWndDlg, szTemp, szTitle, MB_OK | MB_ICONEXCLAMATION);
                        SetFocus(GetDlgItem(hWndDlg, IDC_CONFIGSETEDIT));
                        break;
                    }

                    //
                    //  Check for existing site w/same name
                    //

                    if(ReadRegConfigSetNames(hWndDlg, g_szRemoteComputer, &lpszConfigSetNames) &&
                       lpszConfigSetNames)
                    {
                        BOOL    bFoundMatch = FALSE;

                        lpszCur = lpszConfigSetNames;
                        while(*lpszCur)
                        {
                            if(lstrcmp(lpszCur, g_szSiteNameBuf) == 0)
                            {
                                LoadString(g_hInst, IDS_EXISTINGSITENAME, szTemp, sizeof(szTemp));
                                LoadString(g_hInst, IDS_ERROR, szTitle, sizeof(szTitle));
                                MessageBox(hWndDlg, szTemp, szTitle, MB_OK | MB_ICONEXCLAMATION);
                                SetFocus(GetDlgItem(hWndDlg, IDC_CONFIGSETEDIT));
                                bFoundMatch = TRUE;
                                break;
                            }

                            lpszCur = _tcschr(lpszCur, TEXT('\0')) + 1;
                        }

                        free(lpszConfigSetNames);
                        lpszConfigSetNames = NULL;

                        if(bFoundMatch)
                            break;
                    }

                    //
                    //  Get data from other controls.
                    //

                    GetDlgItemText(hWndDlg, IDC_HOSTNAMEEDIT, g_szHostNameBuf, g_dwHostNameBufLen);
                    if(lstrlen(g_szHostNameBuf) == 0)
                    {
                        LoadString(g_hInst, IDS_EMPTYHOSTNAME, szTemp, sizeof(szTemp));
                        LoadString(g_hInst, IDS_ERROR, szTitle, sizeof(szTemp));
                        MessageBox(hWndDlg, szTemp, szTitle, MB_OK | MB_ICONEXCLAMATION);
                        SetFocus(GetDlgItem(hWndDlg, IDC_HOSTNAMEEDIT));
                        break;
                    }

                    GetDlgItemText(hWndDlg, IDC_HOSTIPEDIT, g_szHostIPBuf, g_dwHostIPBufLen);
                    if(lstrlen(g_szHostIPBuf) == 0)
                    {
                        LoadString(g_hInst, IDS_EMPTYHOSTIP, szTemp, sizeof(szTemp));
                        LoadString(g_hInst, IDS_ERROR, szTitle, sizeof(szTemp));
                        MessageBox(hWndDlg, szTemp, szTitle, MB_OK | MB_ICONEXCLAMATION);
                        SetFocus(GetDlgItem(hWndDlg, IDC_HOSTIPEDIT));
                        break;
                    }

                    //
                    //  Valid IP address?
                    //

                    if(!IsValidIP(g_szHostIPBuf))
                    {
                        LoadString(g_hInst, IDS_HOSTIP_ERROR, szTemp, sizeof(szTemp));
                        LoadString(g_hInst, IDS_ERROR, szTitle, sizeof(szTemp));
                        MessageBox(hWndDlg, szTemp, szTitle, MB_OK | MB_ICONEXCLAMATION);
                        SetFocus(GetDlgItem(hWndDlg, IDC_HOSTIPEDIT));
                        break;
                    }

                    EndDialog( hWndDlg, TRUE );
                    break;
                }
                
                case IDCANCEL:
                {
                    g_szSiteNameBuf[0] = TEXT('\0');
                    g_szHostNameBuf[0] = TEXT('\0');
                    g_szHostIPBuf[0] = TEXT('\0');

                    EndDialog( hWndDlg, FALSE );
                    break;
                }
            }                
            break;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\pmconfig\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by pmconfig.rc
//
#define IDI_PMADMIN                     100
#define IDD_MAIN                        106
#define IDD_PMADMINCONNECT              107
#define IDD_CONFIRM_COMMIT              108
#define IDD_ABOUT_DIALOG                110
#define IDR_MAIN_MENU                   111
#define IDD_NEW_CONFIGSET               113
#define CTRL_BASE                       1000
#define IDC_TIMEWINDOW                  1000
#define IDC_FORCESIGNIN                 1001
#define IDC_LANGUAGEID                  1002
#define IDC_COBRANDING_TEMPLATE         1003
#define IDC_SITEID                      1004
#define IDC_RETURNURL                   1005
#define IDC_COOKIEDOMAIN                1006
#define IDC_COOKIEPATH                  1007
#define IDC_STANDALONE                  1008
#define IDC_DISABLECOOKIES              1009
#define IDC_DISASTERURL                 1010
#define IDC_HOSTNAMEEDIT                1011
#define IDC_HOSTIPEDIT                  1012
#define IDC_PROFILEDOMAIN               1013
#define IDC_PROFILEPATH                 1014
#define IDC_SECUREDOMAIN                1015
#define IDC_SECUREPATH                  1016
#define IDC_TIMEWINDOW_SECONDS          1018
#define IDC_TIMEWINDOW_SPIN             1019
#define IDC_KEYLIST                     1024
#define IDC_PROMOTE_KEY                 1025
#define IDC_INSTALLDIR                  1026
#define IDC_VERSION                     1027
#define IDC_CURRENTKEY                  1030
#define IDC_COMMIT                      1032
#define IDC_UNDO                        1033
#define IDC_LANGUAGEID_LANG             1041
#define IDC_TIMEWINDOW_TIME             1042
#define IDC_SERVERNAME                  1043
#define IDC_BROWSE                      1045
#define IDC_REMOTENAME                  1046
#define IDC_OTHER_TYPE                  1049
#define IDC_COOKIES_TYPE                1050
#define IDC_SITEID_TYPE                 1051
#define IDC_STANDALONE_TYPE             1052
#define IDC_OTHER_WARN                  1053
#define IDC_COOKIES_WARN                1054
#define IDC_SITEID_WARN                 1055
#define IDC_STANDALONE_WARN             1056
#define IDC_CHANGE_ICON                 1057
#define IDC_OTHERPROCESS                1058
#define IDC_PRODUCTID                   1059
#define IDC_PRODUCTVERSION              1060
#define IDC_NEWCONFIG                   1061
#define IDC_REMOVECONFIG                1062
#define IDC_CONFIGSETS                  1063
#define IDC_HOSTNAMETEXT                1066
#define IDC_CONFIGSETEDIT               1067
#define IDC_HOSTIPTEXT                  1068
#define IDC_COOKIEDOMAIN_TEXT           1070
#define IDC_COOKIEPATH_TEXT             1071
#define IDM_EXIT                        2001
#define IDM_SELECT                      2002
#define IDM_REFRESH                     2003
#define IDM_ABOUT                       2004
#define IDM_PRECONFIG                   2005
#define IDM_OPEN                        2006
#define IDM_SAVE                        2007
#define IDM_SAVEAS                      2008
#define IDM_HELP                        2009
#define IDM_COMPUTERMRUBASE             2100
#define IDS_ERROR                       3000
#define IDS_WARNING                     3001
#define IDS_TIMEWINDOW_ERROR            3002
#define IDS_LANGUAGEID_ERROR            3004
#define IDS_SITEID_ERROR                3006
#define IDS_SITEID_WARN                 3007
#define IDS_COBRANDING_ERROR            3009
#define IDS_RETURNURL_ERROR             3011
#define IDS_COOKIEDOMAIN_ERROR          3013
#define IDS_COOKIEPATH_ERROR            3015
#define IDS_STANDALONE_WARN             3017
#define IDS_DISABLECOOKIE_WARN          3018
#define IDS_CONSISTENCY_WARN            3019
#define IDS_ABOUTTOCOMMIT               3020
#define IDS_COMMITERROR                 3021
#define IDS_REGISTRYCHANGED             3022
#define IDS_CONFIGREAD_ERROR            3023
#define IDS_CONNECTNOTLOCAL             3024
#define IDS_CONNECTBADNAME              3025
#define IDS_CONNECTROOTFAILED           3026
#define IDS_SECURECOOKIEPATH_ERROR      3026
#define IDS_CONNECTACCESSDENIED         3027
#define IDS_COMPUTERBROWSETITLE         3028
#define IDS_LOCALHOST                   3029
#define IDS_OPENFILETITLE               3030
#define IDS_SAVEFILETITLE               3031
#define IDS_PMCONFIGDEFEXT              3032
#define IDS_PMOPENFILEFILTER            3033
#define IDS_PMSAVEFILEFILTER            3034
#define IDS_PMHELPFILE                  3035
#define IDS_TIMEWINDOW                  3036
#define IDS_FORCESIGNIN                 3037
#define IDS_LANGUAGEID                  3038
#define IDS_COBRANDTEMPLATE             3039
#define IDS_RETURNURL                   3040
#define IDS_COOKIEDOMAIN                3041
#define IDS_TICKETDOMAIN                3041
#define IDS_COOKIEPATH                  3042
#define IDS_TICKETPATH                  3042
#define IDS_DISASTERURL                 3043
#define IDS_APP_TITLE                   3044
#define IDS_NOTHINGTOCOMMIT             3045
#define IDS_PRODUCTID                   3046
#define IDS_USAGE                       3047
#define IDS_FILENOTFOUND                3048
#define IDS_PRODUCTVERSION              3049
#define IDS_DISASTERURL_ERROR           3050
#define IDS_HOSTNAME                    3051
#define IDS_HOSTIP                      3052
#define IDS_HOSTNAME_ERROR              3053
#define IDS_HOSTIP_ERROR                3054
#define IDS_DEFAULT                     3055
#define IDS_REMOVE_WARNING              3056
#define IDS_REMOVE_TITLE                3057
#define IDS_EMPTYSITENAME               3058
#define IDS_EMPTYHOSTNAME               3059
#define IDS_EMPTYHOSTIP                 3060
#define IDS_WRITENEW_ERROR              3061
#define IDS_SAVE_PROMPT                 3062
#define IDS_INVALIDSITENAME             3063
#define IDS_HOSTNAMETRUNC_WARN          3064
#define IDS_HOSTIPTRUNC_WARN            3065
#define IDS_PROFILEDOMAIN_ERROR         3066
#define IDS_PROFILEPATH_ERROR           3067
#define IDS_PROFILEDOMAIN               3068
#define IDS_PROFILEPATH                 3069
#define IDS_SECUREPATH_ERROR            3070
#define IDS_SECUREDOMAIN                3071
#define IDS_SECUREPATH                  3072
#define IDS_SECUREDOMAIN_ERROR          3073
#define IDS_EXISTINGSITENAME            3074
#define IDS_INVALIDHOSTIP               3075

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        115
#define _APS_NEXT_COMMAND_VALUE         2006
#define _APS_NEXT_CONTROL_VALUE         1073
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\pmconfig\pmhelp.h ===
// Help IDs for Passport Mananger Config 

#define NO_HELP                 ((DWORD) -1) // Disables Help for a control

#define IDH_PMADMIN_CONNECT         1000
#define IDH_PMADMIN_CONNECT_BROWSE  1001
#define IDH_SERVERNAME              1002
#define IDH_INSTALLDIR              1003
#define IDH_VERSION                 1004
#define IDH_TIMEWINDOW              1005
#define IDH_FORCESIGNIN             1006
#define IDH_LANGUAGEID              1007
#define IDH_COBRANDING_TEMPLATE     1008
#define IDH_SITEID                  1009
#define IDH_RETURNURL               1010
#define IDH_COOKIEDOMAIN            1011
#define IDH_COOKIEPATH              1012
#define IDH_STANDALONE              1013
#define IDH_DISABLECOOKIES          1014
#define IDH_COMMIT                  1015
#define IDH_UNDO                    1016
#define IDH_DISASTERURL             1017
#define IDH_CONFIGSETS              1018
#define IDH_NEWCONFIG               1019
#define IDH_REMOVECONFIG            1020
#define IDH_HOSTNAMEEDIT            1021
#define IDH_HOSTIPEDIT              1022
#define IDH_PROFILEDOMAIN           1023
#define IDH_PROFILEPATH             1024
#define IDH_SECUREDOMAIN            1025
#define IDH_SECUREPATH              1026
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\pmconfig\pmcfg.h ===
// Pre-compiled header for Passport Manager config/admin tool

#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <commdlg.h>
#include <winsock.h>
#include <wininet.h>        // for INTERNET_MAX_URL_LENGTH
#include <shlobj.h>
#include <shlwapi.h>

#include <tchar.h>

#include "resource.h"
#include "pmhelp.h"
#include "mru.h"

#ifndef GET_WM_COMMAND_ID

#define GET_WM_COMMAND_ID(wp, lp)               (wp)
#define GET_WM_COMMAND_HWND(wp, lp)             (HWND)(LOWORD(lp))
#define GET_WM_COMMAND_CMD(wp, lp)              HIWORD(lp)

#endif

#ifdef WIN32
   #define CBACK  CALLBACK
#else
   #define CBACK  _export CALLBACK
#endif

// constant defines
#define MAX_REGISTRY_STRING     256
#define DEFAULT_TIME_WINDOW     14400
#define MIN_TIME_WINDOW_SECONDS 100
#define MAX_TIME_WINDOW_SECONDS 1000000
#define DEFAULT_LANGID          1033
#define MAX_SITEID              0xFFFFFFFF
#define PRODUCTID_LEN           24

#define MAX_TITLE               80
#define MAX_MESSAGE             1024
#define MAX_RESOURCE            255
#define MAX_CONFIGSETNAME       256
#define MAX_IPLEN               16

#define SECONDS_PER_MIN         60
#define SECONDS_PER_HOUR        (60 * SECONDS_PER_MIN)
#define SECONDS_PER_DAY         (24 * SECONDS_PER_HOUR)

#define VALIDATION_ERROR            1
#define CHANGE_WARNING              2

#define COMPUTER_MRU_SIZE       4
#define FILE_MRU_SIZE           4

// Type defines
typedef struct PMSettings_tag
{
    DWORD       dwTimeWindow;                                // Time Window in Seconds
    DWORD       dwForceSignIn;
    DWORD       dwLanguageID;
    TCHAR       szCoBrandTemplate[INTERNET_MAX_URL_LENGTH];
    DWORD       cbCoBrandTemplate;                           // Size of the CobBrand template buffer
    DWORD       dwSiteID;
    TCHAR       szReturnURL[INTERNET_MAX_URL_LENGTH];
    DWORD       cbReturnURL;                                 // Size of the ReturnURL buffer
    TCHAR       szTicketDomain[INTERNET_MAX_URL_LENGTH];
    DWORD       cbTicketDomain;                              // Size of the CookieDomain buffer
    TCHAR       szTicketPath[INTERNET_MAX_URL_LENGTH];
    DWORD       cbTicketPath;                                // Size of the CookiePath buffer
    TCHAR       szProfileDomain[INTERNET_MAX_URL_LENGTH];
    DWORD       cbProfileDomain;                             // Size of the CookieDomain buffer
    TCHAR       szProfilePath[INTERNET_MAX_URL_LENGTH];
    DWORD       cbProfilePath;                               // Size of the CookiePath buffer
    TCHAR       szSecureDomain[INTERNET_MAX_URL_LENGTH];
    DWORD       cbSecureDomain;                              // Size of the CookiePath buffer
    TCHAR       szSecurePath[INTERNET_MAX_URL_LENGTH];
    DWORD       cbSecurePath;                                // Size of the CookiePath buffer
    TCHAR       szDisasterURL[INTERNET_MAX_URL_LENGTH];
    DWORD       cbDisasterURL;                               // Size of the DisasterURL buffer
    
#ifdef DO_KEYSTUFF    
    DWORD       dwCurrentKey;
#endif    
    DWORD       dwDisableCookies;
    DWORD       dwStandAlone;

    TCHAR       szHostName[INTERNET_MAX_HOST_NAME_LENGTH];
    DWORD       cbHostName;
    TCHAR       szHostIP[MAX_IPLEN];
    DWORD       cbHostIP;

} PMSETTINGS, FAR * LPPMSETTINGS;

typedef struct LanguageIDMap_tag
{
    WORD    wLangID;
    LPCTSTR lpszLang;
} LANGIDMAP, FAR * LPLANGIDMAP;


// declarations for globals that are shared across modules
extern TCHAR       g_szTRUE[];
extern TCHAR       g_szFALSE[];
extern TCHAR       g_szYes[];
extern TCHAR       g_szNo[];
extern HINSTANCE   g_hInst;
extern HWND        g_hwndMain;
extern PMSETTINGS  g_CurrentSettings;
extern PMSETTINGS  g_OriginalSettings;
extern TCHAR       g_szClassName[];
extern LANGIDMAP   g_szLanguageIDMap[];
extern TCHAR       g_szInstallPath[];
extern TCHAR       g_szPMVersion[];
extern TCHAR       g_szHelpFileName[];
extern TCHAR       g_szRemoteComputer[];
extern TCHAR       g_szPassportReg[];
extern TCHAR       g_szPassportSites[];
extern PpMRU       g_ComputerMRU;

// These globals are shared by the reg and file config read/write functions
extern TCHAR       g_szEncryptionKeyData[];
extern TCHAR       g_szInstallDir[];
extern TCHAR       g_szVersion[];
extern TCHAR       g_szTimeWindow[];
extern TCHAR       g_szForceSignIn[];
extern TCHAR       g_szLanguageID[];
extern TCHAR       g_szCoBrandTemplate[];
extern TCHAR       g_szSiteID[];
extern TCHAR       g_szReturnURL[];
extern TCHAR       g_szTicketDomain[];
extern TCHAR       g_szTicketPath[];
extern TCHAR       g_szProfileDomain[];
extern TCHAR       g_szProfilePath[];
extern TCHAR       g_szSecureDomain[];
extern TCHAR       g_szSecurePath[];
extern TCHAR       g_szCurrentKey[];
extern TCHAR       g_szStandAlone[];
extern TCHAR       g_szDisableCookies[];
extern TCHAR       g_szDisasterURL[];
extern TCHAR       g_szHostName[];
extern TCHAR       g_szHostIP[];

// declaractions for functions that are shared across modules
BOOL ReadRegConfigSet(HWND hWndDlg, LPPMSETTINGS  lpPMConfig, LPTSTR lpszRemoteComputer, LPTSTR lpszConfigSetName = NULL);
BOOL WriteRegConfigSet(HWND hWndDlg, LPPMSETTINGS  lpPMConfig, LPTSTR lpszRemoteComputer, LPTSTR lpszConfigSetName = NULL);
BOOL RemoveRegConfigSet(HWND hWndDlg, LPTSTR lpszRemoteComputer, LPTSTR lpszConfigSetName);
BOOL VerifyRegConfigSet(HWND hWndDlg, LPPMSETTINGS lpPMConfig, LPTSTR lpszRemoteComputer, LPTSTR lpszConfigSetName = NULL);

BOOL ReadRegConfigSetNames(HWND hWndDlg, LPTSTR lpszRemoteComputer, LPTSTR* lppszConfigSetNames);

void InitializePMConfigStruct(LPPMSETTINGS lpPMConfig);

void ReportControlMessage(HWND hWnd, INT idCtrl, WORD wMessageType);
BOOL CommitOKWarning(HWND hWndDlg);
void ReportError(HWND hWndDlg, UINT idError);

BOOL PMAdmin_OnCommandConnect(HWND hWnd, LPTSTR  lpszRemoteName);

BOOL PMAdmin_GetFileName(HWND hWnd, BOOL fOpen, LPTSTR lpFileName, DWORD cbFileName);
BOOL ReadFileConfigSet(LPPMSETTINGS lpPMConfig, LPCTSTR lpszFileName);
BOOL WriteFileConfigSet(LPPMSETTINGS lpPMConfig, LPCTSTR lpszFileName);

BOOL NewConfigSet(HWND      hWndDlg, 
                  LPTSTR    szSiteNameBuf, 
                  DWORD     dwBufLen, 
                  LPTSTR    szHostNameBuf, 
                  DWORD     dwHostNameLen, 
                  LPTSTR    szHostIPBuf, 
                  DWORD     dwHostIPLen);

BOOL RemoveConfigSetWarning(HWND hWndDlg);

BOOL IsValidIP(LPCTSTR lpszIP);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\pmconfig\pmnet.cpp ===
/**************************************************************************
   Copyright (C) 1999  Microsoft Corporation.  All Rights Reserved.

   MODULE:     PMNET.CPP

   PURPOSE:    Source module for Passport Manager config tool, remote
               machine access

   FUNCTIONS:

   COMMENTS:    Borrowed from Regedit
      
**************************************************************************/

#include "pmcfg.h"

const DWORD s_PMAdminConnectHelpIDs[] = 
{
    IDC_REMOTENAME, IDH_PMADMIN_CONNECT,
    IDC_BROWSE,     IDH_PMADMIN_CONNECT_BROWSE,
    0, 0
};

VOID PASCAL PMAdmin_Connect_OnCommandBrowse(HWND hWnd);
LRESULT CALLBACK PMAdmin_ConnectDlgProc(HWND hWnd, UINT Message, WPARAM wParam, LPARAM lParam);

/*******************************************************************************
*
*  PMAdmin_OnCommandConnect
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL PMAdmin_OnCommandConnect
(
    HWND    hWnd,
    LPTSTR  lpszRemoteName
)
{

    TCHAR           RemoteName[MAX_PATH];
    LPTSTR          lpUnslashedRemoteName;
    TCHAR           ComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD           cbComputerName;

    // Pre-populate the remote name if we already have one
    lstrcpyn(RemoteName, lpszRemoteName, sizeof(RemoteName));
        
    //
    //  Query the user for the name of the remote computer to connect to.
    //
    if (DialogBoxParam(g_hInst, 
                       MAKEINTRESOURCE(IDD_PMADMINCONNECT), 
                       hWnd,
                       (DLGPROC) PMAdmin_ConnectDlgProc, 
                       (LPARAM) (LPTSTR) RemoteName) != IDOK)
        return FALSE;

    lpUnslashedRemoteName = (RemoteName[0] == TEXT('\\') &&
        RemoteName[1] == TEXT('\\')) ? &RemoteName[2] : &RemoteName[0];

    CharLower(lpUnslashedRemoteName);
    CharUpperBuff(lpUnslashedRemoteName, 1);

    //
    //  Check if the user is trying to connect to the local computer and prevent
    //  this.
    //
    cbComputerName = sizeof(ComputerName)/sizeof(TCHAR);

    if (GetComputerName(ComputerName, &cbComputerName)) 
    {
        if (lstrcmpi(lpUnslashedRemoteName, ComputerName) == 0) 
        {
            ReportError(hWnd, IDS_CONNECTNOTLOCAL);
        }
        else
        {
            lstrcpy(lpszRemoteName, lpUnslashedRemoteName);
        }
    }

    return TRUE;
}

/*******************************************************************************
*
*  PMAdmin_ConnectDlgProc
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

LRESULT CALLBACK PMAdmin_ConnectDlgProc
(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
)
{

    LPTSTR lpRemoteName;

    switch (Message) 
    {

        case WM_INITDIALOG:
            SetWindowLongPtr(hWnd, DWLP_USER, (LONG) lParam);
            SendDlgItemMessage(hWnd, IDC_REMOTENAME, EM_SETLIMITTEXT, MAX_PATH, 0);
            SetDlgItemText(hWnd, IDC_REMOTENAME, (LPTSTR) lParam);
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) 
            {
                case IDC_BROWSE:
                    PMAdmin_Connect_OnCommandBrowse(hWnd);
                    break;

                case IDOK:
                    lpRemoteName = (LPTSTR) GetWindowLongPtr(hWnd, DWLP_USER);
                    GetDlgItemText(hWnd, IDC_REMOTENAME, lpRemoteName, MAX_PATH);
                    //  FALL THROUGH

                case IDCANCEL:
                    EndDialog(hWnd, GET_WM_COMMAND_ID(wParam, lParam));
                    break;

            }
            break;

        case WM_HELP:
            WinHelp( (HWND)((LPHELPINFO) lParam)->hItemHandle, g_szHelpFileName,
                HELP_WM_HELP, (ULONG_PTR) s_PMAdminConnectHelpIDs);
            break;

        case WM_CONTEXTMENU:
            WinHelp((HWND) wParam, g_szHelpFileName, HELP_CONTEXTMENU,
                (ULONG_PTR) s_PMAdminConnectHelpIDs);
            break;

        default:
            return FALSE;
    }

    return TRUE;
}

/*******************************************************************************
*
*  PMAdmin_Connect_OnCommandBrowse
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID PASCAL PMAdmin_Connect_OnCommandBrowse
(
    HWND hWnd
)
{
    BROWSEINFO      BrowseInfo;
    LPITEMIDLIST    pidlComputer;
    TCHAR           RemoteName[MAX_PATH];
    TCHAR           szTitle[MAX_TITLE];
    LPMALLOC        lpMalloc;               // Pointer to shell allocator interface
        
    BrowseInfo.hwndOwner = hWnd;
    BrowseInfo.pidlRoot = (LPITEMIDLIST) MAKEINTRESOURCE(CSIDL_NETWORK);
    BrowseInfo.pszDisplayName = RemoteName;
    
    LoadString(g_hInst, IDS_COMPUTERBROWSETITLE, szTitle, sizeof(szTitle));
    BrowseInfo.lpszTitle = (LPTSTR)&szTitle;
    BrowseInfo.ulFlags = BIF_BROWSEFORCOMPUTER;
    BrowseInfo.lpfn = NULL;

    if ((pidlComputer = SHBrowseForFolder(&BrowseInfo)) != NULL) 
    {
        // Free the pidl allocated by the BrowserForFolder call
        if ((NOERROR == SHGetMalloc(&lpMalloc)) && (NULL != lpMalloc)) 
        { 
            lpMalloc->Free(pidlComputer);
            lpMalloc->Release();
        }
        
        SetDlgItemText(hWnd, IDC_REMOTENAME, RemoteName);
        EnableWindow(GetDlgItem(hWnd, IDOK), TRUE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\pmconfig\pmconfig.cpp ===
/**************************************************************************
   Copyright (C) 1999  Microsoft Corporation.  All Rights Reserved.

   MODULE:     PMCONFIG.CPP

   PURPOSE:    Source module for Passport Manager config tool

   FUNCTIONS:

   COMMENTS:
      
**************************************************************************/

/**************************************************************************
   Include Files
**************************************************************************/

#include "pmcfg.h"
#include <htmlhelp.h>
#include <ntverp.h>

/**************************************************************************
   Local Function Prototypes
**************************************************************************/

int WINAPI          WinMain(HINSTANCE, HINSTANCE, LPSTR, int);
LRESULT CALLBACK    About(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK    DlgMain(HWND hWndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

/**************************************************************************
   Global Variables
**************************************************************************/


// Globals
HINSTANCE   g_hInst;
HWND        g_hwndMain = 0;
HWND        g_hwndMainDlg = 0;
PMSETTINGS  g_OriginalSettings;
PMSETTINGS  g_CurrentSettings;
TCHAR       g_szDlgClassName[] = TEXT("PassportManagerAdminClass");
TCHAR       g_szClassName[] = TEXT("PassportManagerMainWindowClass");
BOOL        g_bCanUndo;
TCHAR       g_szInstallPath[MAX_PATH];
TCHAR       g_szPMVersion[MAX_REGISTRY_STRING];
TCHAR       g_szPMOpsHelpFileRelativePath[] = TEXT("sdk\\Passport_SDK.chm");
TCHAR       g_szPMAdminBookmark[] = TEXT("/Reference/operations/Passport_Admin.htm");

TCHAR       g_szRemoteComputer[MAX_PATH];
TCHAR       g_szNewRemoteComputer[MAX_PATH];
TCHAR       g_szConfigFile[MAX_PATH];
TCHAR       g_szConfigSet[MAX_CONFIGSETNAME];
TCHAR       g_szHelpFileName[MAX_PATH];

PpMRU       g_ComputerMRU(COMPUTER_MRU_SIZE);

// Global constant strings
TCHAR       g_szYes[] = TEXT("Yes");
TCHAR       g_szNo[] = TEXT("No");
TCHAR       g_szUnknown[] = TEXT("Unknown");

#define MAX_LCID_VALUE  10
LANGIDMAP   g_szLanguageIDMap[] = 
{
    {0x0409, TEXT("English")},  //  This item will be the default selection below...
    {0x0407, TEXT("German")},
    {0x0411, TEXT("Japanese")},
    {0x0412, TEXT("Korean")},
    {0x0404, TEXT("Traditional Chinese")},
    {0x0804, TEXT("Simplified Chinese")},
    {0x040c, TEXT("French")},
    {0x0c0a, TEXT("Spanish")},
    {0x0416, TEXT("Brazilian")},
    {0x0410, TEXT("Italian")},
    {0x0413, TEXT("Dutch")},
    {0x041d, TEXT("Swedish")},
    {0x0406, TEXT("Danish")},
    {0x040b, TEXT("Finnish")},
    {0x040e, TEXT("Hungarian")},
    {0x0414, TEXT("Norwegian")},
    {0x0408, TEXT("Greek")},
    {0x0415, TEXT("Polish")},
    {0x0419, TEXT("Russian")},
    {0x0405, TEXT("Czech")},
    {0x0816, TEXT("Portuguese")},
    {0x041f, TEXT("Turkish")},
    {0x041b, TEXT("Slovak")},
    {0x0424, TEXT("Slovenian")},
    {0x0401, TEXT("Arabic")},
    {0x040d, TEXT("Hebrew")},
    {0x0401, TEXT("Arabic - Saudi Arabia")},
    {0x0801, TEXT("Arabic - Iraq")},
    {0x0c01, TEXT("Arabic - Egypt")},
    {0x1001, TEXT("Arabic - Libya")},
    {0x1401, TEXT("Arabic - Algeria")},
    {0x1801, TEXT("Arabic - Morocco")},
    {0x1c01, TEXT("Arabic - Tunisia")},
    {0x2001, TEXT("Arabic - Oman")},
    {0x2401, TEXT("Arabic - Yemen")},
    {0x2801, TEXT("Arabic - Syria")},
    {0x2c01, TEXT("Arabic - Jordan")},
    {0x3001, TEXT("Arabic - Lebanon")},
    {0x3401, TEXT("Arabic - Kuwait")},
    {0x3801, TEXT("Arabic - United Arab Emirates")},
    {0x3c01, TEXT("Arabic - Bahrain")},
    {0x4001, TEXT("Arabic - Qatar")},
    {0x0402, TEXT("Bulgarian - Bulgaria")},
    {0x0403, TEXT("Catalan - Spain")},
    {0x0404, TEXT("Chinese  Taiwan")},
    {0x0804, TEXT("Chinese - PRC")},
    {0x0c04, TEXT("Chinese - Hong Kong SAR, PRC")},
    {0x1004, TEXT("Chinese - Singapore")},
    {0x1404, TEXT("Chinese - Macao SAR")},
    {0x0405, TEXT("Czech - Czech Republic")},
    {0x0406, TEXT("Danish - Denmark")},
    {0x0407, TEXT("German - Germany")},
    {0x0807, TEXT("German - Switzerland")},
    {0x0c07, TEXT("German - Austria")},
    {0x1007, TEXT("German - Luxembourg")},
    {0x1407, TEXT("German - Liechtenstein")},
    {0x0408, TEXT("Greek - Greece")},
    {0x0409, TEXT("English - United States")},
    {0x0809, TEXT("English - United Kingdom")},
    {0x0c09, TEXT("English - Australia")},
    {0x1009, TEXT("English - Canada")},
    {0x1409, TEXT("English - New Zealand")},
    {0x1809, TEXT("English - Ireland")},
    {0x1c09, TEXT("English - South Africa")},
    {0x2009, TEXT("English - Jamaica")},
    {0x2409, TEXT("English - Caribbean")},
    {0x2809, TEXT("English - Belize")},
    {0x2c09, TEXT("English - Trinidad")},
    {0x3009, TEXT("English - Zimbabwe")},
    {0x3409, TEXT("English - Philippines")},
    {0x040a, TEXT("Spanish - Spain (Traditional Sort)")},
    {0x080a, TEXT("Spanish - Mexico")},
    {0x0c0a, TEXT("Spanish - Spain (Modern Sort)")},
    {0x100a, TEXT("Spanish - Guatemala")},
    {0x140a, TEXT("Spanish - Costa Rica")},
    {0x180a, TEXT("Spanish - Panama")},
    {0x1c0a, TEXT("Spanish - Dominican Republic")},
    {0x200a, TEXT("Spanish - Venezuela")},
    {0x240a, TEXT("Spanish - Colombia")},
    {0x280a, TEXT("Spanish - Peru")},
    {0x2c0a, TEXT("Spanish - Argentina")},
    {0x300a, TEXT("Spanish - Ecuador")},
    {0x340a, TEXT("Spanish - Chile")},
    {0x380a, TEXT("Spanish - Uruguay")},
    {0x3c0a, TEXT("Spanish - Paraguay")},
    {0x400a, TEXT("Spanish - Bolivia")},
    {0x440a, TEXT("Spanish - El Salvador")},
    {0x480a, TEXT("Spanish - Honduras")},
    {0x4c0a, TEXT("Spanish - Nicaragua")},
    {0x500a, TEXT("Spanish - Puerto Rico")},
    {0x040b, TEXT("Finnish - Finland")},
    {0x040c, TEXT("French - France")},
    {0x080c, TEXT("French - Belgium")},
    {0x0c0c, TEXT("French - Canada")},
    {0x100c, TEXT("French - Switzerland")},
    {0x140c, TEXT("French - Luxembourg")},
    {0x180c, TEXT("French - Monaco")},
    {0x040d, TEXT("Hebrew - Israel")},
    {0x040e, TEXT("Hungarian - Hungary")},
    {0x040f, TEXT("Icelandic - Iceland")},
    {0x0410, TEXT("Italian - Italy")},
    {0x0810, TEXT("Italian - Switzerland")},
    {0x0411, TEXT("Japanese - Japan")},
    {0x0412, TEXT("Korean (Extended Wansung) - Korea")},
    {0x0812, TEXT("Korean (Johab) - Korea")},
    {0x0413, TEXT("Dutch - Netherlands")},
    {0x0813, TEXT("Dutch - Belgium")},
    {0x0414, TEXT("Norwegian - Norway (Bokmal)")},
    {0x0814, TEXT("Norwegian - Norway (Nynorsk)")},
    {0x0415, TEXT("Polish - Poland")},
    {0x0416, TEXT("Portuguese - Brazil")},
    {0x0816, TEXT("Portuguese - Portugal")},
    {0x0417, TEXT("Rhaeto-Romanic - Rhaeto-Romanic")},
    {0x0418, TEXT("Romanian - Romania")},
    {0x0818, TEXT("Romanian - Moldavia")},
    {0x0419, TEXT("Russian - Russia")},
    {0x0819, TEXT("Russian - Moldavia")},
    {0x041a, TEXT("Croatian - Croatia")},
    {0x081a, TEXT("Serbian - Serbia (Latin)")},
    {0x0c1a, TEXT("Serbian - Serbia (Cyrillic)")},
    {0x041b, TEXT("Slovak - Slovakia")},
    {0x041c, TEXT("Albanian - Albania")},
    {0x041d, TEXT("Swedish - Sweden")},
    {0x081d, TEXT("Swedish - Finland")},
    {0x041e, TEXT("Thai - Thailand")},
    {0x041f, TEXT("Turkish - Turkey")},
    {0x0420, TEXT("Urdu - Urdu")},
    {0x0421, TEXT("Indonesian - Indonesia")},
    {0x0422, TEXT("Ukrainian - Ukraine")},
    {0x0423, TEXT("Belarussian - Belarus")},
    {0x0424, TEXT("Slovene - Slovenia")},
    {0x0425, TEXT("Estonian - Estonia")},
    {0x0426, TEXT("Latvian - Latvia")},
    {0x0427, TEXT("Lithuanian - Lithuania")},
    {0x0429, TEXT("Farsi - Iran")},
    {0x042a, TEXT("Vietnamese - Vietnam")},
    {0x042d, TEXT("Basque - Spain")},
    {0x042e, TEXT("Sorbian - Sorbian")},
    {0x042f, TEXT("FYRO Macedonian - Macedonian")},
    {0x0430, TEXT("Sutu - Sutu")},
    {0x0431, TEXT("Tsonga - Tsonga")},
    {0x0432, TEXT("Tswana - Tswana")},
    {0x0433, TEXT("Venda - Venda")},
    {0x0434, TEXT("Xhosa - Xhosa")},
    {0x0435, TEXT("Zulu - Zulu")},
    {0x0436, TEXT("Afrikaans - South Africa")},
    {0x0438, TEXT("Faeroese - Faeroe Islands")},
    {0x0439, TEXT("Hindi - Hindi")},
    {0x043a, TEXT("Maltese - Maltese")},
    {0x043b, TEXT("Saami - Saami (Lappish)")},
    {0x043c, TEXT("Gaelic - Scots")},
    {0x083c, TEXT("Gaelic - Irish")},
    {0x043d, TEXT("Yiddish - Yiddish")},
    {0x043e, TEXT("Malay - Malaysian")},
    {0x083e, TEXT("Malay - Brunei")},
    {0x0441, TEXT("Swahili - Kenya")}
};

const DWORD s_PMAdminHelpIDs[] = 
{
    IDC_SERVERNAME, IDH_SERVERNAME,
    IDC_INSTALLDIR, IDH_INSTALLDIR,
    IDC_VERSION, IDH_VERSION,
    IDC_TIMEWINDOW, IDH_TIMEWINDOW,
    IDC_FORCESIGNIN, IDH_FORCESIGNIN,
    IDC_LANGUAGEID, IDH_LANGUAGEID,
    IDC_COBRANDING_TEMPLATE, IDH_COBRANDING_TEMPLATE,
    IDC_SITEID, IDH_SITEID,
    IDC_RETURNURL, IDH_RETURNURL,
    IDC_COOKIEDOMAIN, IDH_COOKIEDOMAIN,
    IDC_COOKIEPATH, IDH_COOKIEPATH,
    IDC_PROFILEDOMAIN, IDH_PROFILEDOMAIN,
    IDC_PROFILEPATH, IDH_PROFILEPATH,
    IDC_SECUREDOMAIN, IDH_SECUREDOMAIN,
    IDC_SECUREPATH, IDH_SECUREPATH,
    IDC_STANDALONE, IDH_STANDALONE,
    IDC_DISABLECOOKIES, IDH_DISABLECOOKIES,
    IDC_DISASTERURL, IDH_DISASTERURL,
    IDC_COMMIT, IDH_COMMIT,
    IDC_UNDO, IDH_UNDO,
    IDC_CONFIGSETS, IDH_CONFIGSETS,
    IDC_NEWCONFIG, IDH_NEWCONFIG,
    IDC_REMOVECONFIG, IDH_REMOVECONFIG,
    IDC_HOSTNAMEEDIT, IDH_HOSTNAMEEDIT,
    IDC_HOSTIPEDIT, IDH_HOSTIPEDIT,
    0, 0
};

#define SERVERNAME_CMD      "/Server"
#define CONFIGFILE_CMD      "/Config"
#define CONFIGSET_CMD       "/Name"
#define HELP_CMD            "/?"

// ############################################################################
//
// Spaces are returned as a token
// modified to consider anything between paired double quotes to be a single token
// For example, the following consists of 9 tokens (4 spaces and 5 cmds)
//
//        first second "this is the third token" fourth "fifth"
//
// The quote marks are included in the returned string (pszOut)
void GetCmdLineToken(LPTSTR *ppszCmd, LPTSTR pszOut)
{
    LPTSTR  c;
    int     i = 0;
    BOOL    fInQuote = FALSE;
    
    c = *ppszCmd;

    pszOut[0] = *c;
    if (!*c) 
        return;
    if (*c == ' ') 
    {
        pszOut[1] = '\0';
        *ppszCmd = c+1;
        return;
    }
    else if( '"' == *c )
    {
        fInQuote = TRUE;
    }

NextChar:
    i++;
    c++;
    if( !*c || (!fInQuote && (*c == ' ')) )
    {
        pszOut[i] = '\0';
        *ppszCmd = c;
        return;
    }
    else if( fInQuote && (*c == '"') )
    {
        fInQuote = FALSE;
        pszOut[i] = *c;
        
        i++;
        c++;
        pszOut[i] = '\0';
        *ppszCmd = c;
        return;
    }
    else
    {
        pszOut[i] = *c;
        goto NextChar;
    }   
}

// Process the incomming command line
void Usage()
{
    ReportError(NULL, IDS_USAGE);
    exit(0);
}

void  ProcessCommandLineArgs
(
    LPTSTR      szCmdLine
)
{
    TCHAR szOut[MAX_PATH];    
    
    // Get the first token
    GetCmdLineToken(&szCmdLine,szOut);
    while (szOut[0])
    {
        if (0 == lstrcmpi(&szOut[0],SERVERNAME_CMD))
        {
            if(g_szRemoteComputer[0] != '\0') Usage();

            // Get the Name of the Server
            GetCmdLineToken(&szCmdLine,szOut);          // This one gets the space
            if (szOut[0])
            {
                GetCmdLineToken(&szCmdLine,g_szRemoteComputer);
                if(!g_szRemoteComputer[0]) Usage();
            }
            else
                Usage();
        }
        
        if (0 == lstrcmpi(&szOut[0],CONFIGFILE_CMD))
        {
            if(g_szConfigFile[0] != '\0') Usage();

            // Get the Config File name
            GetCmdLineToken(&szCmdLine, szOut);         // This one gets the space
            if (szOut[0])
            {
                GetCmdLineToken(&szCmdLine, g_szConfigFile);
                if(!g_szConfigFile[0]) Usage();
            }
            else
                Usage();
        }
        
        if (0 == lstrcmpi(&szOut[0],CONFIGSET_CMD))
        {
            if(g_szConfigSet[0] != '\0') Usage();

            // Get the Config Set name
            GetCmdLineToken(&szCmdLine, szOut);
            if (szOut[0])
            {
                GetCmdLineToken(&szCmdLine, g_szConfigSet);
                if(!g_szConfigSet[0]) Usage();
            }
            else
                Usage();
        }

        if (0 == lstrcmpi(&szOut[0],HELP_CMD))
            Usage();

        // Eat the next token, it will be null if we are at the end
        GetCmdLineToken(&szCmdLine,szOut);
    }
}

BOOL RegisterAndSetIcon
(
    HINSTANCE hInstance
)
{
    //
    // Fetch the default dialog class information.
    //
    WNDCLASS wndClass;
    if (!GetClassInfo (0, MAKEINTRESOURCE (32770), &wndClass))
    {
        return FALSE;
    }

    //
    // Assign the Icon.
    //
    wndClass.hInstance      = hInstance;
    wndClass.hIcon          = LoadIcon(NULL, IDI_APPLICATION);
    wndClass.lpszClassName  = (LPTSTR)g_szDlgClassName;
    wndClass.lpszMenuName   = MAKEINTRESOURCE(IDR_MAIN_MENU);
    

    //
    // Register the window class.
    //
    return RegisterClass( &wndClass );
}

void InitializeComputerMRU(void)
{
    g_ComputerMRU.load(TEXT("Computer MRU"), TEXT("msppcnfg.ini"));
}


void SaveComputerMRU(void)
{
    g_ComputerMRU.save(TEXT("Computer MRU"), TEXT("msppcnfg.ini"));
}


void InsertComputerMRU
(
    LPCTSTR szComputer
)
{
    g_ComputerMRU.insert(szComputer);
}


void InitializePMConfigStruct
(
    LPPMSETTINGS  lpPMConfig
)
{   
    // Zero Init the structure
    ZeroMemory(lpPMConfig, sizeof(PMSETTINGS));
 
    // Setup the buffer sizes
    lpPMConfig->cbCoBrandTemplate = sizeof(lpPMConfig->szCoBrandTemplate);
    lpPMConfig->cbReturnURL = sizeof(lpPMConfig->szReturnURL);
    lpPMConfig->cbTicketDomain = sizeof(lpPMConfig->szTicketDomain);
    lpPMConfig->cbTicketPath = sizeof(lpPMConfig->szTicketPath);
    lpPMConfig->cbProfileDomain = sizeof(lpPMConfig->szProfileDomain);
    lpPMConfig->cbProfilePath = sizeof(lpPMConfig->szProfilePath);
    lpPMConfig->cbSecureDomain = sizeof(lpPMConfig->szSecureDomain);
    lpPMConfig->cbSecurePath = sizeof(lpPMConfig->szSecurePath);
    lpPMConfig->cbDisasterURL = sizeof(lpPMConfig->szDisasterURL);
    lpPMConfig->cbHostName = sizeof(lpPMConfig->szHostName);
    lpPMConfig->cbHostIP = sizeof(lpPMConfig->szHostIP);
}

void GetDefaultSettings
(
    LPPMSETTINGS    lpPMConfig
)
{
    InitializePMConfigStruct(lpPMConfig);

    lpPMConfig->dwSiteID = 1;
    lpPMConfig->dwLanguageID = 1033;
    lpPMConfig->dwTimeWindow = 14400;
#ifdef DO_KEYSTUFF    
    lpPMConfig->dwCurrentKey = 1;
#endif    
}


void InitInstance
(
    HINSTANCE   hInstance
)
{
    InitializeComputerMRU();

    InitializePMConfigStruct(&g_OriginalSettings);
    
    g_bCanUndo = FALSE;
    g_szInstallPath[0] = '\0';
    ZeroMemory(g_szPMVersion, sizeof(g_szPMVersion));
    ZeroMemory(g_szRemoteComputer, sizeof(g_szRemoteComputer));
    ZeroMemory(g_szNewRemoteComputer, sizeof(g_szNewRemoteComputer));
    ZeroMemory(g_szConfigFile, sizeof(g_szConfigFile));
    ZeroMemory(g_szHelpFileName, sizeof(g_szHelpFileName));

    // Load the Help File Name
    LoadString(hInstance, IDS_PMHELPFILE, g_szHelpFileName, sizeof(g_szHelpFileName));    
}

INT WINAPI WinMain
(
    HINSTANCE        hInstance,
    HINSTANCE        hPrevInstance,
    LPSTR            lpszCmdLine,
    INT              nCmdShow
)
{

    MSG     msg;
    HACCEL  hAccel;
    TCHAR   szTitle[MAX_TITLE];
    TCHAR   szMessage[MAX_MESSAGE];

    g_hInst = hInstance;
        
    //don't forget this
    InitCommonControls();

    if(!hPrevInstance)
    {
        //
        // Register this app's window and set the icon only 1 time for all instances
        //
        if (!RegisterAndSetIcon(hInstance))
            return FALSE;
    }            

    // Initialize the necessary Instance Variables and settings;
    InitInstance(hInstance);
    
    // If there was a command line, then process it, otherwise show the GUI
    if (lpszCmdLine && (*lpszCmdLine != '\0'))
    {
        TCHAR   szFile[MAX_PATH];
        
        ProcessCommandLineArgs(lpszCmdLine);

        if(g_szConfigFile[0] == TEXT('\0')) Usage();
        
        // Check to see if we got a fully qualified path name for the config file
        if (PathIsFileSpec(g_szConfigFile))
        {
            // Not qualified, so assume it exists in our CWD
            lstrcpy(szFile, g_szConfigFile);
            GetCurrentDirectory(sizeof(g_szConfigFile), g_szConfigFile);
            PathAppend(g_szConfigFile, szFile);
        }
        
        // Load the Config set specified
        if (ReadFileConfigSet(&g_OriginalSettings, g_szConfigFile))
        {
            // Commit the ConfigSet Read
            WriteRegConfigSet(NULL, 
                              &g_OriginalSettings, 
                              g_szRemoteComputer,  
                              g_szConfigSet);
        }
    }
    else
    {
        //
        // Create the dialog for this instance
        //
        DialogBox( hInstance, 
                   MAKEINTRESOURCE (IDD_MAIN), 
                   NULL, 
                   (DLGPROC)DlgMain );
    }   
    
    SaveComputerMRU();

    return TRUE;
}


/**************************************************************************

   Utility functions for the dialogs
   
**************************************************************************/

/**************************************************************************

   About()

**************************************************************************/
LRESULT CALLBACK About
( 
    HWND hWnd, 
    UINT uMessage, 
    WPARAM wParam, 
    LPARAM lParam
)
{
    switch (uMessage)
    {
        case WM_INITDIALOG:
        {
            TCHAR achProductVersionBuf[64];
            TCHAR achProductIDBuf[64];
            HKEY  hkeyPassport;
            DWORD dwcbTemp;
            DWORD dwType;

            if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                              g_szPassportReg,
                                              0,
                                              KEY_READ,
                                              &hkeyPassport))
            {                                          
                ReportError(hWnd, IDS_CONFIGREAD_ERROR);
                return TRUE;                                      
            }
            
            // Load the Help File Name
            LoadString(g_hInst, IDS_PRODUCTID, achProductIDBuf, sizeof(achProductIDBuf));
            LoadString(g_hInst, IDS_PRODUCTVERSION, achProductVersionBuf, sizeof(achProductVersionBuf));

            //  Display product version
            lstrcat(achProductVersionBuf, VER_PRODUCTVERSION_STR);
            SetDlgItemText(hWnd, IDC_PRODUCTVERSION, achProductVersionBuf);        

            //  Display product id
            dwcbTemp = PRODUCTID_LEN;
            dwType = REG_SZ;
            RegQueryValueEx(hkeyPassport,
                            TEXT("ProductID"),
                            NULL,
                            &dwType,
                            (LPBYTE)&(achProductIDBuf[lstrlen(achProductIDBuf)]),
                            &dwcbTemp);

            RegCloseKey(hkeyPassport);

            SetDlgItemText(hWnd, IDC_PRODUCTID, achProductIDBuf);        

            return TRUE;
        }
      
        case WM_COMMAND:
            switch(wParam)
            {
                case IDOK:
                case IDCANCEL:
                    EndDialog(hWnd, wParam);
                    return TRUE;
            }
            break;
    } 
    return FALSE;
}


/**************************************************************************

    UpdateTimeWindowDisplay
    
    this function will update the "human" readable display of the time
    window setting.
    
**************************************************************************/
void UpdateTimeWindowDisplay
(
    HWND    hWndDlg, 
    DWORD   dwTimeWindow
)
{
    int     days, hours, minutes, seconds;
    TCHAR   szTemp[MAX_REGISTRY_STRING];

    // Format the Time display
    days = dwTimeWindow / SECONDS_PER_DAY;
    hours = (dwTimeWindow - (days * SECONDS_PER_DAY)) / SECONDS_PER_HOUR;
    minutes = (dwTimeWindow - (days * SECONDS_PER_DAY) - (hours * SECONDS_PER_HOUR)) / SECONDS_PER_MIN;
    seconds = dwTimeWindow - 
                (days * SECONDS_PER_DAY) - 
                (hours * SECONDS_PER_HOUR) - 
                (minutes * SECONDS_PER_MIN);
                
    wsprintf (szTemp, TEXT("%d d : %d h : %d m : %d s"), days, hours, minutes, seconds);
    SetDlgItemText(hWndDlg, IDC_TIMEWINDOW_TIME, szTemp);

}


/**************************************************************************

    UpdateLanguageDisplay
        
    this function will update both the combo box for selecting/entering
    the Language ID value, and the language value if possible.
    If idx is >= 0, then it is a valid index into the array, otherwise
    the index is found by searching the entries in the list
    
**************************************************************************/
void UpdateLanguageDisplay
(
    HWND    hWndDlg, 
    DWORD   dwLanguageID,
    INT     idx
)
{
    TCHAR   szTemp[MAX_LCID_VALUE];
    LRESULT idxLangID;
    
    if (idx >= 0)
    {
        SetDlgItemText(hWndDlg, IDC_LANGUAGEID_LANG, g_szLanguageIDMap[idx].lpszLang);
    }
    else
    {
        wsprintf (szTemp, TEXT("%d"), dwLanguageID);
        // Search the Combo-Box to see if we have the proposed LCID in the list already
        if (CB_ERR != 
             (idxLangID = SendDlgItemMessage(hWndDlg, IDC_LANGUAGEID, CB_FINDSTRINGEXACT, 0, (LPARAM)szTemp)))
        {
            // The Language ID is one that is in our pre-populated list, so we have a matching
            // language string as well
            SendDlgItemMessage(hWndDlg, IDC_LANGUAGEID, CB_SETCURSEL, idxLangID, 0l);
            SetDlgItemText(hWndDlg, IDC_LANGUAGEID_LANG, g_szLanguageIDMap[(int) idxLangID].lpszLang);
        }   
        else
        {
            SetDlgItemText(hWndDlg, IDC_LANGUAGEID_LANG, g_szUnknown);
        }      
    }        
}

/**************************************************************************

    SetUndoButton
    
    Sets the state of the Undo button.
    
**************************************************************************/
void SetUndoButton
(
    HWND    hWndDlg,
    BOOL    bUndoState
)
{
    g_bCanUndo = bUndoState;
    EnableWindow(GetDlgItem(hWndDlg, IDC_UNDO), bUndoState);
}

/**************************************************************************

    InitMainDlg
    
**************************************************************************/
BOOL InitMainDlg
(
    HWND            hWndDlg,
    LPPMSETTINGS    lpPMConfig
)    
{
    TCHAR           szTemp[MAX_REGISTRY_STRING];
    LPTSTR          lpszConfigSetNames, lpszCur;
    LRESULT         dwCurSel;
    int             nCmdShow;
    int             nSelectedLanguage;
    
#ifdef DO_KEYSTUFF
    HWND        hWndListView;
    LVCOLUMN    lvc;
#endif    

    // Remote Computer Name
    if (('\0' != g_szRemoteComputer[0]))
    {
        SetDlgItemText(hWndDlg, IDC_SERVERNAME, g_szRemoteComputer);
    }
    else
    {
        LoadString(g_hInst, IDS_LOCALHOST, szTemp, sizeof(szTemp));
        SetDlgItemText(hWndDlg, IDC_SERVERNAME, szTemp);
    }

    // Icon
    HICON hic = LoadIcon(g_hInst, MAKEINTRESOURCE(IDI_PMADMIN));
    SendMessage(hWndDlg, WM_SETICON, ICON_SMALL, (LPARAM)hic);
    SendMessage(hWndDlg, WM_SETICON, ICON_BIG, (LPARAM)hic);
        
    // List of config sets
    SendDlgItemMessage(hWndDlg, IDC_CONFIGSETS, CB_RESETCONTENT, 0, 0L);

    LoadString(g_hInst, IDS_DEFAULT, szTemp, sizeof(szTemp));
    SendDlgItemMessage(hWndDlg, IDC_CONFIGSETS, CB_ADDSTRING, 0, (LPARAM)szTemp);

    if(ReadRegConfigSetNames(hWndDlg, g_szRemoteComputer, &lpszConfigSetNames) &&
       lpszConfigSetNames)
    {
        lpszCur = lpszConfigSetNames;
        while(*lpszCur)
        {
            SendDlgItemMessage(hWndDlg,
                               IDC_CONFIGSETS,
                               CB_ADDSTRING,
                               0,
                               (LPARAM)lpszCur);

            lpszCur = _tcschr(lpszCur, TEXT('\0')) + 1;
        }

        free(lpszConfigSetNames);
        lpszConfigSetNames = NULL;
    }

    if(g_szConfigSet[0] != TEXT('\0'))
    {
        dwCurSel = SendDlgItemMessage(hWndDlg,
                                      IDC_CONFIGSETS,
                                      CB_FINDSTRINGEXACT,
                                      -1,
                                      (LPARAM)g_szConfigSet);
    }
    else
    {
        dwCurSel = 0;
    }

    SendDlgItemMessage(hWndDlg, IDC_CONFIGSETS, CB_SETCURSEL, dwCurSel, 0L);

    //  If the current selection was the default, then hide the
    //  host name and ip address controls.
    nCmdShow = (dwCurSel ? SW_SHOW : SW_HIDE);
    ShowWindow(GetDlgItem(hWndDlg, IDC_HOSTNAMETEXT), nCmdShow);
    ShowWindow(GetDlgItem(hWndDlg, IDC_HOSTNAMEEDIT), nCmdShow);
    ShowWindow(GetDlgItem(hWndDlg, IDC_HOSTIPTEXT),   nCmdShow);
    ShowWindow(GetDlgItem(hWndDlg, IDC_HOSTIPEDIT),   nCmdShow);

    EnableWindow(GetDlgItem(hWndDlg, IDC_REMOVECONFIG), (int) dwCurSel);

    //
    // HostName
    SetDlgItemText(hWndDlg, IDC_HOSTNAMEEDIT, lpPMConfig->szHostName);
    SendDlgItemMessage(hWndDlg, IDC_HOSTNAMEEDIT, EM_SETLIMITTEXT, INTERNET_MAX_HOST_NAME_LENGTH - 1, 0l);

    //
    // HostIP
    SetDlgItemText(hWndDlg, IDC_HOSTIPEDIT, lpPMConfig->szHostIP);
    SendDlgItemMessage(hWndDlg, IDC_HOSTIPEDIT, EM_SETLIMITTEXT, MAX_IPLEN - 1, 0l);
    // 
    // Install Dir    
    SetDlgItemText(hWndDlg, IDC_INSTALLDIR, g_szInstallPath);
    
    // Version
    SetDlgItemText(hWndDlg, IDC_VERSION, g_szPMVersion);

    // Time Window
    // Set the Range and position for the spinner
    SendDlgItemMessage(hWndDlg, IDC_TIMEWINDOW_SPIN, UDM_SETRANGE32, (int)0, (LPARAM)(int)MAX_TIME_WINDOW_SECONDS );
    SendDlgItemMessage(hWndDlg, IDC_TIMEWINDOW_SPIN, UDM_SETPOS, 0, MAKELONG(lpPMConfig->dwTimeWindow,0));
    
    wsprintf (szTemp, TEXT("%lu"), lpPMConfig->dwTimeWindow);
    SetDlgItemText(hWndDlg,     IDC_TIMEWINDOW, szTemp);

    UpdateTimeWindowDisplay(hWndDlg, lpPMConfig->dwTimeWindow);
        
    
    // Initialize the force signing values
    CheckDlgButton(hWndDlg, IDC_FORCESIGNIN, lpPMConfig->dwForceSignIn ? BST_CHECKED : BST_UNCHECKED);
        
    // language ID
    // Initialize the LanguageID dropdown with the known LCIDs
    SendDlgItemMessage(hWndDlg, IDC_LANGUAGEID, CB_RESETCONTENT, 0, 0l);
    nSelectedLanguage = -1;
    for (int i = 0; i < sizeof(g_szLanguageIDMap)/sizeof(LANGIDMAP); i++)
    {
        LRESULT lCurrent = SendDlgItemMessage(hWndDlg, 
                              IDC_LANGUAGEID, 
                              CB_ADDSTRING, 
                              0, 
                              (LPARAM)g_szLanguageIDMap[i].lpszLang);

        SendDlgItemMessage(hWndDlg, IDC_LANGUAGEID, CB_SETITEMDATA, lCurrent, (LPARAM)g_szLanguageIDMap[i].wLangID);

        if(lpPMConfig->dwLanguageID == g_szLanguageIDMap[i].wLangID)
        {
            nSelectedLanguage = i;
        }
    }

    //  Now select the correct item in the list...
    if(nSelectedLanguage == -1)
    {
        SendDlgItemMessage(hWndDlg, IDC_LANGUAGEID, CB_SETCURSEL, 0, NULL);
    }
    else
    {
        LRESULT  lLanguage = SendDlgItemMessage(hWndDlg,
                                                IDC_LANGUAGEID,
                                                CB_FINDSTRINGEXACT,
                                                -1,
                                                (LPARAM)g_szLanguageIDMap[nSelectedLanguage].lpszLang);

        SendDlgItemMessage(hWndDlg, IDC_LANGUAGEID, CB_SETCURSEL, lLanguage, NULL);
    }

    // Update the display of the combo box and the language value
    UpdateLanguageDisplay(hWndDlg, lpPMConfig->dwLanguageID, -1);
    
    // Co-branding template
    SetDlgItemText(hWndDlg, IDC_COBRANDING_TEMPLATE, lpPMConfig->szCoBrandTemplate);
    SendDlgItemMessage(hWndDlg, IDC_COBRANDING_TEMPLATE, EM_SETLIMITTEXT, INTERNET_MAX_URL_LENGTH -1, 0l);
    
    // Site ID        
    wsprintf (szTemp, TEXT("%d"), lpPMConfig->dwSiteID);
    SetDlgItemText(hWndDlg, IDC_SITEID, szTemp);
    
    // Return URL
    SetDlgItemText(hWndDlg, IDC_RETURNURL, lpPMConfig->szReturnURL);
    SendDlgItemMessage(hWndDlg, IDC_RETURNURL, EM_SETLIMITTEXT, INTERNET_MAX_URL_LENGTH -1, 0l);

    // Cookie domain
    SetDlgItemText(hWndDlg, IDC_COOKIEDOMAIN, lpPMConfig->szTicketDomain);
    SendDlgItemMessage(hWndDlg, IDC_COOKIEDOMAIN, EM_SETLIMITTEXT, INTERNET_MAX_URL_LENGTH -1, 0l);
    
    // Cookie path
    SetDlgItemText(hWndDlg, IDC_COOKIEPATH, lpPMConfig->szTicketPath);
    SendDlgItemMessage(hWndDlg, IDC_COOKIEPATH, EM_SETLIMITTEXT, INTERNET_MAX_URL_LENGTH -1, 0l);

    // Cookie domain
    SetDlgItemText(hWndDlg, IDC_PROFILEDOMAIN, lpPMConfig->szProfileDomain);
    SendDlgItemMessage(hWndDlg, IDC_PROFILEDOMAIN, EM_SETLIMITTEXT, INTERNET_MAX_URL_LENGTH -1, 0l);
    
    // Cookie path
    SetDlgItemText(hWndDlg, IDC_PROFILEPATH, lpPMConfig->szProfilePath);
    SendDlgItemMessage(hWndDlg, IDC_PROFILEPATH, EM_SETLIMITTEXT, INTERNET_MAX_URL_LENGTH -1, 0l);

    // Secure Cookie domain
    SetDlgItemText(hWndDlg, IDC_SECUREDOMAIN, lpPMConfig->szSecureDomain);
    SendDlgItemMessage(hWndDlg, IDC_SECUREDOMAIN, EM_SETLIMITTEXT, INTERNET_MAX_URL_LENGTH -1, 0l);

    // Secure Cookie path
    SetDlgItemText(hWndDlg, IDC_SECUREPATH, lpPMConfig->szSecurePath);
    SendDlgItemMessage(hWndDlg, IDC_SECUREPATH, EM_SETLIMITTEXT, INTERNET_MAX_URL_LENGTH -1, 0l);

    // Disaster URL
    SetDlgItemText(hWndDlg, IDC_DISASTERURL, lpPMConfig->szDisasterURL);
    SendDlgItemMessage(hWndDlg, IDC_DISASTERURL, EM_SETLIMITTEXT, INTERNET_MAX_URL_LENGTH -1, 0l);

    // Set the Standalone and Disable Cookies check boxes
    CheckDlgButton(hWndDlg, IDC_STANDALONE, lpPMConfig->dwStandAlone ? BST_CHECKED : BST_UNCHECKED);
    CheckDlgButton(hWndDlg, IDC_DISABLECOOKIES, lpPMConfig->dwDisableCookies ? BST_CHECKED : BST_UNCHECKED);
    
    SetUndoButton(hWndDlg, FALSE);
    
#ifdef DO_KEYSTUFF

    // Current encryption key
    wsprintf (szTemp, TEXT("%d"), lpPMConfig->dwCurrentKey);
    SetDlgItemText(hWndDlg, IDC_CURRENTKEY, szTemp);

    
    // Initialize the Listview control for the Encryption Keys
    hWndListView = GetDlgItem(hWndDlg, IDC_KEYLIST);

    // Setup for full row select
    ListView_SetExtendedListViewStyle(hWndListView, LVS_EX_FULLROWSELECT);
    
    // Setup the columns
    lvc.mask = LVCF_TEXT;
    lvc.pszText = TEXT("Key Number");
    lvc.iSubItem = 0;   
    ListView_InsertColumn(hWndListView, 0, &lvc);
   
    lvc.mask = LVCF_TEXT;
    lvc.pszText = TEXT("Expires");
    lvc.iSubItem = 1;   
    ListView_InsertColumn(hWndListView, 1, &lvc);

    lvc.mask = LVCF_TEXT;
    lvc.pszText = TEXT("Current");
    lvc.iSubItem = 2;   
    ListView_InsertColumn(hWndListView, 2, &lvc);

    // Initially size the columns    
    ListView_SetColumnWidth(hWndListView, 0, LVSCW_AUTOSIZE_USEHEADER);
    ListView_SetColumnWidth(hWndListView, 1, LVSCW_AUTOSIZE_USEHEADER);
    ListView_SetColumnWidth(hWndListView, 2, LVSCW_AUTOSIZE_USEHEADER);
    
    
    // Enumerate the KeyData sub-key to fill in the list
    DWORD   dwRet;
    DWORD   dwIndex = 0;
    TCHAR   szValue[MAX_REGISTRY_STRING];
    DWORD   dwcbValue;
    LVITEM  lvi;
        
    dwType = REG_SZ;    
    
    do {
    
        dwcbValue = sizeof(szValue);
        dwcbTemp = sizeof(szTemp);
        szTemp[0] = '\0';
        szValue[0] = '\0';
        if (ERROR_SUCCESS == (dwRet = RegEnumValue(hkeyEncryptionKeyData,
                                                     dwIndex,
                                                     szValue,
                                                     &dwcbValue,
                                                     NULL,
                                                     &dwType,
                                                     (LPBYTE)szTemp,
                                                     &dwcbTemp)))
        {
            // Insert the Column
            lvi.mask = LVIF_TEXT;
            lvi.iItem = dwIndex;
            lvi.iSubItem = 0;
            lvi.pszText = szValue;
            lvi.cchTextMax = lstrlen(szValue);
            
            ListView_InsertItem(hWndListView, &lvi);
            ListView_SetItemText(hWndListView, dwIndex, 1, szTemp);
            // See if this is the current key
            if (g_OriginalSettings.dwCurrentKey == (DWORD)atoi((LPSTR)szValue))
            {
                ListView_SetItemText(hWndListView, dwIndex, 2, g_szYes);
            }                
            else            
            {
                ListView_SetItemText(hWndListView, dwIndex, 2, g_szNo);
            }                
        }                       
        
        ++dwIndex;
    } while (dwRet == ERROR_SUCCESS);
#endif                         
    
    return TRUE; 
}


/**************************************************************************

    Update the computer MRU list based on contents of g_aszComputerMRU
    
**************************************************************************/
BOOL
UpdateComputerMRU
(
    HWND    hWndDlg
)
{
    BOOL            bReturn;
    HMENU           hMenu;
    HMENU           hComputerMenu;
    int             nIndex;
    MENUITEMINFO    mii;
    TCHAR           achMenuBuf[MAX_PATH];
    DWORD           dwError;

    hMenu = GetMenu(hWndDlg);
    if(hMenu == NULL)
    {
        bReturn = FALSE;
        goto Cleanup;
    }

    hComputerMenu = GetSubMenu(hMenu, 1);
    if(hComputerMenu == NULL)
    {
        bReturn = FALSE;
        goto Cleanup;
    }

    while(GetMenuItemID(hComputerMenu, 1) != -1)
        DeleteMenu(hComputerMenu, 1, MF_BYPOSITION);

    for(nIndex = 0; nIndex < COMPUTER_MRU_SIZE; nIndex++)
    {
        if(g_ComputerMRU[nIndex] != NULL)
            break;
    }

    if(nIndex == COMPUTER_MRU_SIZE)
    {
        bReturn = TRUE;
        goto Cleanup;
    }

    //  Add the separator.
    ZeroMemory(&mii, sizeof(MENUITEMINFO));
    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_TYPE;
    mii.fType = MFT_SEPARATOR;

    if(!InsertMenuItem(hComputerMenu, 1, TRUE, &mii))
    {
        dwError = GetLastError();
        bReturn = FALSE;
        goto Cleanup;
    }
    
    //  Now add each item in the MRU list.
    for(nIndex = 0; nIndex < COMPUTER_MRU_SIZE && g_ComputerMRU[nIndex]; nIndex++)
    {
        ZeroMemory(&mii, sizeof(MENUITEMINFO));
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_TYPE | MIIM_ID;
        mii.fType = MFT_STRING;
        mii.wID = IDM_COMPUTERMRUBASE + nIndex;

        wsprintf(achMenuBuf, TEXT("&%d %s"), nIndex + 1, g_ComputerMRU[nIndex]);

        mii.dwTypeData = achMenuBuf;
        mii.cch = lstrlen(achMenuBuf) + 1;

        InsertMenuItem(hComputerMenu, nIndex + 2, TRUE, &mii);
    }

    bReturn = TRUE;

Cleanup:

    return bReturn;
}



/**************************************************************************

    Leaving this config set, prompt for save.
    
**************************************************************************/
int
SavePrompt
(
    HWND    hWndDlg
)
{
    TCHAR   szPrompt[MAX_RESOURCE];
    TCHAR   szTitle[MAX_RESOURCE];

    LoadString(g_hInst, IDS_SAVE_PROMPT, szPrompt, sizeof(szPrompt));
    LoadString(g_hInst, IDS_APP_TITLE, szTitle, sizeof(szTitle));

    return MessageBox(hWndDlg, szPrompt, szTitle, MB_YESNOCANCEL | MB_ICONEXCLAMATION);
}


/**************************************************************************

    Switching configurations, check for unsaved changes.
    
**************************************************************************/
BOOL
DoConfigSwitch
(
    HWND    hWndDlg,
    LPTSTR  szNewComputer,
    LPTSTR  szNewConfigSet
)
{
    BOOL        bReturn;
    int         nOption;
    PMSETTINGS  newSettings;

    //
    //  If switching to current config, do nothing.
    //

    if(lstrcmp(szNewComputer, g_szRemoteComputer) == 0 &&
       lstrcmp(szNewConfigSet, g_szConfigSet) == 0)
    {
        bReturn = TRUE;
        goto Cleanup;
    }

    //
    //  If no changes then return.
    //

    if(0 == memcmp(&g_CurrentSettings, &g_OriginalSettings, sizeof(PMSETTINGS)))
        nOption = IDNO;
    else
        nOption = SavePrompt(hWndDlg);

    switch(nOption)
    {
    case IDYES:
        if(!WriteRegConfigSet(hWndDlg, &g_CurrentSettings, g_szRemoteComputer, g_szConfigSet))
        {
            bReturn = FALSE;
            break;
        }

    case IDNO:
        InitializePMConfigStruct(&newSettings);
        if (ReadRegConfigSet(hWndDlg, 
                             &newSettings, 
                             szNewComputer, 
                             szNewConfigSet))
        {
            memcpy(g_szRemoteComputer,  szNewComputer,  sizeof(g_szRemoteComputer));
            memcpy(g_szConfigSet,       szNewConfigSet, sizeof(g_szConfigSet));
            memcpy(&g_CurrentSettings,  &newSettings,   sizeof(PMSETTINGS));
            memcpy(&g_OriginalSettings, &newSettings,   sizeof(PMSETTINGS));

            bReturn = TRUE;
        }
        else
        {
            bReturn = FALSE;
        }

        InitMainDlg(hWndDlg, &g_CurrentSettings);
        break;

    case IDCANCEL:
        {
            LRESULT   lSel;

            if(g_szConfigSet[0] == TEXT('\0'))
            {
                lSel = 0;
            }
            else
            {
                lSel = SendDlgItemMessage(hWndDlg, IDC_CONFIGSETS, CB_FINDSTRINGEXACT, 0, (LPARAM)g_szConfigSet);
            }

            SendDlgItemMessage(hWndDlg, IDC_CONFIGSETS, CB_SETCURSEL, lSel, 0L);

            bReturn = FALSE;
        }
        break;
    }

Cleanup:

    return bReturn;
}

/**************************************************************************

    Switching servers, check for unsaved changes.
    
**************************************************************************/
BOOL
DoServerSwitch
(
    HWND    hWndDlg,
    LPTSTR  szNewComputer
)
{
    BOOL    bReturn;

    if(DoConfigSwitch(hWndDlg, szNewComputer, TEXT("")))
    {
        //  Put computer name on MRU list.
        if(lstrlen(szNewComputer))
            g_ComputerMRU.insert(szNewComputer);
        else
        {
            TCHAR   achTemp[MAX_REGISTRY_STRING];
            LoadString(g_hInst, IDS_LOCALHOST, achTemp, sizeof(achTemp));

            g_ComputerMRU.insert(achTemp);
        }

        //  Update MRU menu.
        UpdateComputerMRU(hWndDlg);
        
        bReturn = TRUE;
    }
    else
        bReturn = FALSE;

    return bReturn;
}

/**************************************************************************

    Closing app, check for unsaved changes.
    
**************************************************************************/
void
DoExit
(
    HWND    hWndDlg
)
{
    if(0 != memcmp(&g_CurrentSettings, &g_OriginalSettings, sizeof(PMSETTINGS)))
    {
        int     nOption;

        nOption = SavePrompt(hWndDlg);
        switch(nOption)
        {
        case IDYES:
            if(WriteRegConfigSet(hWndDlg, &g_CurrentSettings, g_szRemoteComputer, g_szConfigSet))
                EndDialog(hWndDlg, TRUE);
            break;

        case IDNO:
            EndDialog(hWndDlg, TRUE);
            break;

        case IDCANCEL:
            break;
        }
    }
    else
        EndDialog( hWndDlg, TRUE );
}

/**************************************************************************

    Dialog proc for the main dialog
    
**************************************************************************/
LRESULT CALLBACK DlgMain
(
    HWND     hWndDlg,
    UINT     uMsg,
    WPARAM   wParam,
    LPARAM   lParam
)
{
    static BOOL bOkToClose;

    switch ( uMsg )
    {
        case WM_INITDIALOG:
        
            InitializePMConfigStruct(&g_OriginalSettings);
            if (ReadRegConfigSet(hWndDlg, 
                                 &g_OriginalSettings, 
                                 g_szRemoteComputer, 
                                 g_szConfigSet))
            {
                InitMainDlg(hWndDlg, &g_OriginalSettings);
                UpdateComputerMRU(hWndDlg);

                // Make a copy of the original setting for editing purposes
                memcpy(&g_CurrentSettings, &g_OriginalSettings, sizeof(PMSETTINGS));
            }
            return TRUE;

        case WM_HELP:
        {
            WinHelp( (HWND)((LPHELPINFO) lParam)->hItemHandle, g_szHelpFileName,
                    HELP_WM_HELP, (ULONG_PTR) s_PMAdminHelpIDs);
            break;
        }
                
        case WM_CONTEXTMENU:
        {
            WinHelp((HWND) wParam, g_szHelpFileName, HELP_CONTEXTMENU,
                (ULONG_PTR) s_PMAdminHelpIDs);
            break;
        }

        case WM_COMMAND:
        {
            WORD    wCmd = LOWORD(wParam);
            LPTSTR  lpszStrToUpdate;
            DWORD   cbStrToUpdate;                    
            
            switch (wCmd)
            {
                // Handle the Menu Cases
                case IDM_OPEN:
                {
                    if (PMAdmin_GetFileName(hWndDlg, 
                                            TRUE, 
                                            g_szConfigFile, 
                                            sizeof(g_szConfigFile)/sizeof(TCHAR))) 
                    {
                        if (ReadFileConfigSet(&g_CurrentSettings, g_szConfigFile))
                        {   
                            InitMainDlg(hWndDlg, &g_CurrentSettings);
                        }
                    }                        
                    break;
                }
                
                case IDM_SAVE:
                {
                    // Have we alread opened or saved a config file, and have a file name 
                    // yet?
                    if ('\0' != g_szConfigFile[0])
                    {
                        // Write out to the current file, and then break
                        WriteFileConfigSet(&g_CurrentSettings, g_szConfigFile);
                        break;
                    }
                    // No file name yet, so fall thru to the Save AS case
                }
                
                case IDM_SAVEAS:
                {
                    if (PMAdmin_GetFileName(hWndDlg, 
                                            FALSE, 
                                            g_szConfigFile, 
                                            sizeof(g_szConfigFile)/sizeof(TCHAR))) 
                    {
                        WriteFileConfigSet(&g_CurrentSettings, g_szConfigFile);
                    }                        
                    break;
                }
                
                case IDM_EXIT:
                {
                    DoExit(hWndDlg);
                    break;
                }
                    
                case IDM_ABOUT:
                {
                    DialogBox(g_hInst, MAKEINTRESOURCE(IDD_ABOUT_DIALOG), hWndDlg, (DLGPROC)About);
                    break;
                }
                case IDM_SELECT:
                {
                    if(!PMAdmin_OnCommandConnect(hWndDlg, g_szNewRemoteComputer)) break;

                    if(!DoServerSwitch(hWndDlg, g_szNewRemoteComputer))
                        DoConfigSwitch(hWndDlg, g_szRemoteComputer, g_szConfigSet);
                        
                    break;
                }
                
                case IDM_REFRESH:
                {
                    DoConfigSwitch(hWndDlg, g_szRemoteComputer, g_szConfigSet);
                    break;
                }
                    
                case IDM_HELP:
                {
                    TCHAR   szPMHelpFile[MAX_PATH];
                    
                    lstrcpy(szPMHelpFile, g_szInstallPath);
                    PathAppend(szPMHelpFile, g_szPMOpsHelpFileRelativePath);
                    
                    HtmlHelp(hWndDlg, szPMHelpFile, HH_DISPLAY_TOPIC, (ULONG_PTR)(LPTSTR)g_szPMAdminBookmark);
                    break;
                }
                                    
                // Handle the Dialog Control Cases
                case IDC_COMMIT:
                {
                    TCHAR   szTitle[MAX_TITLE];
                    TCHAR   szMessage[MAX_MESSAGE];
                    
                    if(0 != memcmp(&g_OriginalSettings, &g_CurrentSettings, sizeof(PMSETTINGS)))
                    {                
                        if (IDOK == CommitOKWarning(hWndDlg))
                        {
                            // It is OK to commit, and the registry is consistent, or it is OK to
                            // proceed, so write out the current settings                                                
                            if (WriteRegConfigSet(hWndDlg, 
                                                  &g_CurrentSettings, 
                                                  g_szRemoteComputer, 
                                                  g_szConfigSet))
                            {
                                // The changes where committed, so current becomes original
                                memcpy(&g_OriginalSettings, &g_CurrentSettings, sizeof(PMSETTINGS));
                                SetUndoButton(hWndDlg, FALSE);
                            }
                            else
                            {                        
                                ReportError(hWndDlg,IDS_COMMITERROR);
                            }    
                        }
                    }
                    else
                    {
                        LoadString(g_hInst, IDS_APP_TITLE, szTitle, sizeof(szTitle));
                        LoadString(g_hInst, IDS_NOTHINGTOCOMMIT, szMessage, sizeof(szMessage));
                        MessageBox(hWndDlg, szMessage, szTitle, MB_OK);
                    }                        
                    break;
                }
                
                case IDC_UNDO:
                {
                    // Restore the original settings, and re-init the current settings 
                    InitMainDlg(hWndDlg, &g_OriginalSettings);
                    memcpy(&g_CurrentSettings, &g_OriginalSettings, sizeof(PMSETTINGS));
                    break;
                }
                
                case IDC_CONFIGSETS:
                {
                    TCHAR   szDefault[MAX_RESOURCE];
                    TCHAR   szConfigSet[MAX_CONFIGSETNAME];

                    if(CBN_SELCHANGE == HIWORD(wParam))
                    {
                        GetDlgItemText(hWndDlg, 
                                       IDC_CONFIGSETS, 
                                       szConfigSet, 
                                       sizeof(szConfigSet));

                        //
                        //  Convert <Default> to empty string.
                        //

                        LoadString(g_hInst, IDS_DEFAULT, szDefault, sizeof(szDefault));
                        if(lstrcmp(szConfigSet, szDefault) == 0)
                            szConfigSet[0] = TEXT('\0');

                        //
                        //  If it's the current set, do nothing.
                        //

                        if(lstrcmp(szConfigSet, g_szConfigSet) != 0)
                        {
                            DoConfigSwitch(hWndDlg, g_szRemoteComputer, szConfigSet);
                        }

                        break;
                    }

                    break;
                }

                case IDC_NEWCONFIG:
                {
                    DWORD       dwCurSel;
                    TCHAR       szConfigSet[MAX_CONFIGSETNAME];
                    PMSETTINGS  newConfig;

                    GetDefaultSettings(&newConfig);

                    if(!NewConfigSet(hWndDlg, 
                                    szConfigSet, 
                                    sizeof(szConfigSet), 
                                    newConfig.szHostName, 
                                    newConfig.cbHostName, 
                                    newConfig.szHostIP, 
                                    newConfig.cbHostIP))
                    {
                        break;
                    }

                    if(WriteRegConfigSet(hWndDlg, &newConfig, g_szRemoteComputer, szConfigSet))
                    {
                        if(DoConfigSwitch(hWndDlg, g_szRemoteComputer, szConfigSet))
                        {
                            memcpy(g_szConfigSet, szConfigSet, sizeof(g_szConfigSet));
                            memcpy(&g_OriginalSettings, &newConfig, sizeof(PMSETTINGS));
                            memcpy(&g_CurrentSettings, &newConfig, sizeof(PMSETTINGS));

                            InitMainDlg(hWndDlg, &g_OriginalSettings);
                        }
                        else
                        {
                            RemoveRegConfigSet(hWndDlg, g_szRemoteComputer, szConfigSet);
                        }
                    }
                    else
                    {
                        ReportError(hWndDlg, IDS_WRITENEW_ERROR);
                    }

                    break;
                }

                case IDC_REMOVECONFIG:
                {
                    LRESULT dwCurSel;
                    LRESULT dwNumItems;
                    TCHAR   szDefault[MAX_RESOURCE];
                
                    dwCurSel = SendDlgItemMessage(hWndDlg, IDC_CONFIGSETS, CB_GETCURSEL, 0, 0L);
                    if(dwCurSel == 0 || dwCurSel == CB_ERR)
                        break;

                    if(!RemoveConfigSetWarning(hWndDlg))
                        break;

                    if(!RemoveRegConfigSet(hWndDlg, g_szRemoteComputer, g_szConfigSet))
                    {
                        //MessageBox(
                        break;
                    }

                    dwNumItems = SendDlgItemMessage(hWndDlg, IDC_CONFIGSETS, CB_GETCOUNT, 0, 0L);


                    SendDlgItemMessage(hWndDlg, IDC_CONFIGSETS, CB_DELETESTRING, dwCurSel, 0L);

                    //  Was this the last item in the list?
                    if(dwCurSel + 1 == dwNumItems)
                        dwCurSel--;
                        
                    SendDlgItemMessage(hWndDlg, IDC_CONFIGSETS, CB_SETCURSEL, dwCurSel, 0L);

                    GetDlgItemText(hWndDlg, IDC_CONFIGSETS, g_szConfigSet, sizeof(g_szConfigSet));
                    LoadString(g_hInst, IDS_DEFAULT, szDefault, sizeof(szDefault));
                    if(lstrcmp(g_szConfigSet, szDefault) == 0)
                        g_szConfigSet[0] = TEXT('\0');

                    // [CR] Should warn if changes have not been committed!
                    InitializePMConfigStruct(&g_OriginalSettings);
                    if (ReadRegConfigSet(hWndDlg, 
                                         &g_OriginalSettings, 
                                         g_szRemoteComputer, 
                                         g_szConfigSet))
                    {
                        InitMainDlg(hWndDlg, &g_OriginalSettings);
                        // Make a copy of the original setting for editing purposes
                        memcpy(&g_CurrentSettings, &g_OriginalSettings, sizeof(PMSETTINGS));
                    }

                    break;
                }

                case IDC_TIMEWINDOW:
                {
                    BOOL    bValid = TRUE;
                    DWORD   dwEditValue = GetDlgItemInt(hWndDlg, wCmd, &bValid, FALSE);
                
                    // Look at the notification code
                    if (EN_KILLFOCUS == HIWORD(wParam))
                    {
                        if (bValid && (dwEditValue >= 100) && (dwEditValue <= MAX_TIME_WINDOW_SECONDS))
                        {
                            g_CurrentSettings.dwTimeWindow = dwEditValue;
                            SetUndoButton(hWndDlg, TRUE);
                            UpdateTimeWindowDisplay(hWndDlg, dwEditValue);
                        }                                                        
                        else
                        {
                            ReportControlMessage(hWndDlg, wCmd, VALIDATION_ERROR);
                            SetFocus(GetDlgItem(hWndDlg, wCmd));
                            bOkToClose = FALSE;
                        }
                    }

                    break;
                }    
                
                case IDC_LANGUAGEID:
                {          
                    // Look at the notification code
                    switch (HIWORD(wParam))
                    {
                        // The user selected a different value in the LangID combo
                        case CBN_SELCHANGE:
                        {
                            // Get the index of the new item selected and update with the approparite
                            // language ID string
                            LRESULT idx = SendDlgItemMessage(hWndDlg, IDC_LANGUAGEID, CB_GETCURSEL, 0, 0);
                            
                            // Update the current Settings
                            g_CurrentSettings.dwLanguageID = 
                                        (DWORD) SendDlgItemMessage(hWndDlg,
                                                                   IDC_LANGUAGEID,
                                                                   CB_GETITEMDATA,
                                                                   idx,
                                                                   0);

                            SetUndoButton(hWndDlg, TRUE);
                            break;                                
                        }       
                    }                        
                    break;                    
                }
                
                case IDC_COBRANDING_TEMPLATE:
                    lpszStrToUpdate = (LPTSTR)&g_CurrentSettings.szCoBrandTemplate;
                    cbStrToUpdate = g_CurrentSettings.cbCoBrandTemplate;
                    goto HANDLE_EN_FOR_STRING_CTRLS;
                    
                case IDC_RETURNURL:
                    lpszStrToUpdate = (LPTSTR)&g_CurrentSettings.szReturnURL;
                    cbStrToUpdate = g_CurrentSettings.cbReturnURL;
                    goto HANDLE_EN_FOR_STRING_CTRLS;
                    
                case IDC_COOKIEDOMAIN:
                    lpszStrToUpdate = (LPTSTR)&g_CurrentSettings.szTicketDomain;
                    cbStrToUpdate = g_CurrentSettings.cbTicketDomain;
                    goto HANDLE_EN_FOR_STRING_CTRLS;
                    
                case IDC_COOKIEPATH:
                    lpszStrToUpdate = (LPTSTR)&g_CurrentSettings.szTicketPath;
                    cbStrToUpdate = g_CurrentSettings.cbTicketPath;
                    goto HANDLE_EN_FOR_STRING_CTRLS;
                    
                case IDC_PROFILEDOMAIN:
                    lpszStrToUpdate = (LPTSTR)&g_CurrentSettings.szProfileDomain;
                    cbStrToUpdate = g_CurrentSettings.cbProfileDomain;
                    goto HANDLE_EN_FOR_STRING_CTRLS;
                    
                case IDC_PROFILEPATH:
                    lpszStrToUpdate = (LPTSTR)&g_CurrentSettings.szProfilePath;
                    cbStrToUpdate = g_CurrentSettings.cbProfilePath;
                    goto HANDLE_EN_FOR_STRING_CTRLS;
                    
                case IDC_SECUREDOMAIN:
                    lpszStrToUpdate = (LPTSTR)&g_CurrentSettings.szSecureDomain;
                    cbStrToUpdate = g_CurrentSettings.cbSecureDomain;
                    goto HANDLE_EN_FOR_STRING_CTRLS;
                    
                case IDC_SECUREPATH:
                    lpszStrToUpdate = (LPTSTR)&g_CurrentSettings.szSecurePath;
                    cbStrToUpdate = g_CurrentSettings.cbSecurePath;
                    goto HANDLE_EN_FOR_STRING_CTRLS;
                    
                case IDC_DISASTERURL:
                    lpszStrToUpdate = (LPTSTR)&g_CurrentSettings.szDisasterURL;
                    cbStrToUpdate = g_CurrentSettings.cbDisasterURL;
                    goto HANDLE_EN_FOR_STRING_CTRLS;
                    
                {
                
HANDLE_EN_FOR_STRING_CTRLS:                
                    switch (HIWORD(wParam))
                    {
                        case EN_CHANGE:
                            if (!g_bCanUndo)
                                SetUndoButton(hWndDlg, TRUE);
                        
                            // Get the updated Value
                            GetDlgItemText(hWndDlg, 
                                           wCmd, 
                                           lpszStrToUpdate,
                                           cbStrToUpdate);                                

                            break;                                
                            
                        case EN_MAXTEXT:
                        {
                            ReportControlMessage(hWndDlg, wCmd, VALIDATION_ERROR);
                            break;
                        }   
                    }
                    break;
                }
                
                case IDC_HOSTNAMEEDIT:
                    switch (HIWORD(wParam))
                    {
                        case EN_CHANGE:
                            {
                                TCHAR   szHostName[INTERNET_MAX_HOST_NAME_LENGTH];

                                if (!g_bCanUndo)
                                    SetUndoButton(hWndDlg, TRUE);
                            
                                // Get the updated Value
                                GetDlgItemText(hWndDlg, 
                                               wCmd, 
                                               szHostName,
                                               sizeof(szHostName));
                                
                                if(lstrlen(szHostName) == 0 && g_szConfigSet[0])
                                {
                                    ReportControlMessage(hWndDlg, wCmd, VALIDATION_ERROR);
                                    SetDlgItemText(hWndDlg, IDC_HOSTNAMEEDIT, g_CurrentSettings.szHostName);
                                    SetFocus(GetDlgItem(hWndDlg, IDC_HOSTNAMEEDIT));
                                }
                                else
                                {
                                    lstrcpy(g_CurrentSettings.szHostName, szHostName);
                                }
                            }
                            break;                                
                            
                        case EN_MAXTEXT:
                        {
                            ReportControlMessage(hWndDlg, wCmd, VALIDATION_ERROR);
                            break;
                        }   
                    }
                    break;
                    
                case IDC_HOSTIPEDIT:
                    switch (HIWORD(wParam))
                    {
                        case EN_KILLFOCUS:
                            {
                                TCHAR   szHostIP[MAX_IPLEN];

                                // Get the updated Value
                                GetDlgItemText(hWndDlg, 
                                               wCmd, 
                                               szHostIP,
                                               sizeof(szHostIP));

                                if(lstrlen(szHostIP) > 0 && g_szConfigSet[0] == 0 && !IsValidIP(szHostIP))
                                {
                                    ReportControlMessage(hWndDlg, wCmd, VALIDATION_ERROR);
                                    SetDlgItemText(hWndDlg, IDC_HOSTIPEDIT, g_CurrentSettings.szHostIP);
                                    SetFocus(GetDlgItem(hWndDlg, IDC_HOSTIPEDIT));
                                }
                            }
                            break;

                        case EN_CHANGE:
                            {
                                TCHAR   szHostIP[MAX_IPLEN];

                                if (!g_bCanUndo)
                                    SetUndoButton(hWndDlg, TRUE);
                            
                                // Get the updated Value
                                GetDlgItemText(hWndDlg, 
                                               wCmd, 
                                               szHostIP,
                                               sizeof(szHostIP));

                                if(lstrlen(szHostIP) == 0 && g_szConfigSet[0])
                                {
                                    ReportControlMessage(hWndDlg, wCmd, VALIDATION_ERROR);
                                    SetDlgItemText(hWndDlg, IDC_HOSTIPEDIT, g_CurrentSettings.szHostIP);
                                    SetFocus(GetDlgItem(hWndDlg, IDC_HOSTIPEDIT));
                                }
                                else
                                {
                                    lstrcpy(g_CurrentSettings.szHostIP, szHostIP);
                                }
                            }   
                            break;                                
                            
                        case EN_MAXTEXT:
                        {
                            ReportControlMessage(hWndDlg, wCmd, VALIDATION_ERROR);
                            break;
                        }   
                    }
                    break;
                    
                case IDC_SITEID:
                {
                    BOOL    bValid = TRUE;
                    DWORD   dwEditValue = GetDlgItemInt(hWndDlg, wCmd, &bValid, FALSE);
                
                    // Look at the notification code
                    if (EN_CHANGE == HIWORD(wParam))
                    {
                        if (bValid && (dwEditValue >= 1) && (dwEditValue <= MAX_SITEID))
                        {
                            g_CurrentSettings.dwSiteID = dwEditValue;
                            SetUndoButton(hWndDlg, TRUE);
                        }                            
                        else
                        {
                            ReportControlMessage(hWndDlg, wCmd, VALIDATION_ERROR);
                            SetDlgItemInt(hWndDlg, wCmd, g_CurrentSettings.dwSiteID, FALSE);
                            SetFocus(GetDlgItem(hWndDlg, wCmd));
                        }
                    }   
                    break;
                }    
                
                case IDC_STANDALONE:
                {
                    if (BN_CLICKED == HIWORD(wParam))
                    {
                        SetUndoButton(hWndDlg, TRUE);
                        if (BST_CHECKED == IsDlgButtonChecked(hWndDlg, wCmd))
                            g_CurrentSettings.dwStandAlone = 1l;
                        else
                            g_CurrentSettings.dwStandAlone = 0l;
                    }    
                    break;
                }
                
                case IDC_DISABLECOOKIES:
                {
                    if (BN_CLICKED == HIWORD(wParam))
                    {
                        SetUndoButton(hWndDlg, TRUE);
                        if (BST_CHECKED == IsDlgButtonChecked(hWndDlg, wCmd))
                            g_CurrentSettings.dwDisableCookies = 1l;
                        else
                            g_CurrentSettings.dwDisableCookies = 0l;
                    }
                    break;
                }
                
                case IDC_FORCESIGNIN:
                {
                    if (BN_CLICKED == HIWORD(wParam))
                    {
                        SetUndoButton(hWndDlg, TRUE);
                        if (BST_CHECKED == IsDlgButtonChecked(hWndDlg, wCmd))
                            g_CurrentSettings.dwForceSignIn = 1l;
                        else
                            g_CurrentSettings.dwForceSignIn = 0l;
                    }
                    break;
                }

                default:
                {
                    if(wCmd >= IDM_COMPUTERMRUBASE && wCmd < IDM_COMPUTERMRUBASE + COMPUTER_MRU_SIZE)
                    {
                        TCHAR   achBuf[MAX_PATH];
                        TCHAR   achTemp[MAX_REGISTRY_STRING];
                        LPTSTR  szNewRemoteComputer;

                        //
                        //  Get the selected computer.
                        //

                        if(GetMenuString(GetMenu(hWndDlg),
                                      wCmd,
                                      achBuf,
                                      MAX_PATH,
                                      MF_BYCOMMAND) == 0)
                            break;

                        //
                        //  Get past the shortcut chars.
                        //

                        szNewRemoteComputer = _tcschr(achBuf, TEXT(' '));
                        if(szNewRemoteComputer == NULL)
                            break;
                        szNewRemoteComputer++;

                        //
                        //  Is it local host?
                        //

                        LoadString(g_hInst, IDS_LOCALHOST, achTemp, sizeof(achTemp));
                        if(lstrcmp(szNewRemoteComputer, achTemp) == 0)
                        {
                            achBuf[0] = TEXT('\0');
                            szNewRemoteComputer = achBuf;
                        }

                        //
                        //  Now try to connect and read.
                        //

                        if(!DoServerSwitch(hWndDlg, szNewRemoteComputer))
                            DoConfigSwitch(hWndDlg, g_szRemoteComputer, g_szConfigSet);

                        break;
                    }

                    break;
                }
            }                
            break;
        }
        
        case WM_CLOSE:
            {
                HWND hwndFocus = GetFocus();
                
                bOkToClose = TRUE;
                SetFocus(NULL);
                
                if(bOkToClose)
                    DoExit(hWndDlg);
                else
                    SetFocus(hwndFocus);
            }
            break;
    }
    
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\pmconfig\regcfg.cpp ===
/**************************************************************************
   Copyright (C) 1999  Microsoft Corporation.  All Rights Reserved.

   MODULE:     REGCFG.CPP

   PURPOSE:    Source module reading/writing PM config sets from the registry

   FUNCTIONS:

   COMMENTS:
      
**************************************************************************/

/**************************************************************************
   Include Files
**************************************************************************/

#include "pmcfg.h"
#include "keycrypto.h"

// Reg Keys/values that we care about
TCHAR       g_szPassportReg[] = TEXT("Software\\Microsoft\\Passport");
TCHAR       g_szPassportSites[] = TEXT("Software\\Microsoft\\Passport\\Sites");
TCHAR       g_szEncryptionKeyData[] = TEXT("KeyData");
TCHAR       g_szInstallDir[] = TEXT("InstallDir");
TCHAR       g_szVersion[] = TEXT("Version");
TCHAR       g_szTimeWindow[] = TEXT("TimeWindow");
TCHAR       g_szForceSignIn[] = TEXT("ForceSignIn");
TCHAR       g_szLanguageID[] = TEXT("LanguageID");
TCHAR       g_szCoBrandTemplate[] = TEXT("CoBrandTemplate");
TCHAR       g_szSiteID[] = TEXT("SiteID");
TCHAR       g_szReturnURL[] = TEXT("ReturnURL");
TCHAR       g_szTicketDomain[] = TEXT("TicketDomain");
TCHAR       g_szTicketPath[] = TEXT("TicketPath");
TCHAR       g_szProfileDomain[] = TEXT("ProfileDomain");
TCHAR       g_szProfilePath[] = TEXT("ProfilePath");
TCHAR       g_szSecureDomain[] = TEXT("SecureDomain");
TCHAR       g_szSecurePath[] = TEXT("SecurePath");
TCHAR       g_szCurrentKey[] = TEXT("CurrentKey");
TCHAR       g_szStandAlone[] = TEXT("StandAlone");
TCHAR       g_szDisableCookies[] = TEXT("DisableCookies");
TCHAR       g_szDisasterURL[] = TEXT("DisasterURL");
TCHAR       g_szHostName[] = TEXT("HostName");
TCHAR       g_szHostIP[] = TEXT("HostIP");



/**************************************************************************

    WriteRegTestKey
    
    Installs the default test key for the named config set.  This is
    only called in the case where a new config set key was created in
    OpenRegConfigSet.
    
**************************************************************************/
BOOL
WriteRegTestKey
(
    HKEY    hkeyConfigKey
)
{	
    BOOL                    bReturn;
    CKeyCrypto              kc;
    HKEY                    hkDataKey = NULL, hkTimeKey = NULL;
    TCHAR                   szKeyNum[2];
    DWORD                   dwKeyVer = 1;

    // Try to encrypt it with MAC address
    BYTE                    original[CKeyCrypto::RAWKEY_SIZE];
    DATA_BLOB               iBlob;
    DATA_BLOB               oBlob;

    iBlob.cbData = sizeof(original);
    iBlob.pbData = original;

    ZeroMemory(&oBlob, sizeof(oBlob));
    
    memcpy(original, "123456781234567812345678", CKeyCrypto::RAWKEY_SIZE);
    if (kc.encryptKey(&iBlob, &oBlob) != S_OK)
    {
        bReturn = FALSE;
        goto Cleanup;
    }

    // Now add it to registry

    lstrcpy(szKeyNum, TEXT("1"));

    if(ERROR_SUCCESS != RegCreateKeyEx(hkeyConfigKey, 
                                     TEXT("KeyData"), 
                                     0,
                                     TEXT(""),
                                     0,
                                     KEY_ALL_ACCESS,
                                     NULL,
                                     &hkDataKey,
                                     NULL))
    {
        bReturn = FALSE;
        goto Cleanup;
    }

    if(ERROR_SUCCESS != RegCreateKeyEx(hkeyConfigKey, 
                                     TEXT("KeyTimes"), 
                                     0,
                                     TEXT(""),
                                     0,
                                     KEY_ALL_ACCESS,
                                     NULL,
                                     &hkTimeKey,
                                     NULL))
    {
        bReturn = FALSE;
        goto Cleanup;
    }

    if(ERROR_SUCCESS != RegSetValueExA(hkDataKey, 
                                       szKeyNum, 
                                       0,
                                       REG_BINARY, 
                                       oBlob.pbData, 
                                       oBlob.cbData))
    {
        bReturn = FALSE;
        goto Cleanup;
    }

    if(ERROR_SUCCESS != RegSetValueExA(hkeyConfigKey, 
                                       "CurrentKey", 
                                       0,
                                       REG_DWORD, 
                                       (LPBYTE)&dwKeyVer, 
                                       sizeof(DWORD)))
    {
        bReturn = FALSE;
        goto Cleanup;
    }

    bReturn = TRUE;

Cleanup:
    if (hkDataKey)
        RegCloseKey(hkDataKey);
    if (hkTimeKey)
        RegCloseKey(hkTimeKey);

    if (oBlob.pbData)
        ::LocalFree(oBlob.pbData);

    return bReturn;
}
/**************************************************************************

    OpenRegConfigSet
    
    Open and return an HKEY for a named configuration set 
    current passport manager config set from the registry
    
**************************************************************************/
HKEY OpenRegConfigSet
(
    HKEY    hkeyLocalMachine,   //  Local or remote HKLM
    LPTSTR  lpszConfigSetName   //  Name of config set
)
{
    HKEY    hkeyConfigSets = NULL;
    HKEY    hkeyConfigSet;
    DWORD   dwDisp;

    //
    //  Can't create an unnamed config set.
    //

    if(lpszConfigSetName == NULL || 
       lpszConfigSetName[0] == TEXT('\0'))
    {
        hkeyConfigSet = NULL;
        goto Cleanup;
    }

    if (ERROR_SUCCESS != RegCreateKeyEx(hkeyLocalMachine,
                                        g_szPassportSites,
                                        0,
                                        TEXT(""),
                                        0,
                                        KEY_ALL_ACCESS,
                                        NULL,
                                        &hkeyConfigSets,
                                        NULL))
    {
        hkeyConfigSet = NULL;
        goto Cleanup;
    }

    //
    //  Create the key if it doesn't exist, otherwise
    //  open it.
    //

    if (ERROR_SUCCESS != RegCreateKeyEx(hkeyConfigSets,
                                        lpszConfigSetName,
                                        0,
                                        TEXT(""),
                                        0,
                                        KEY_ALL_ACCESS,
                                        NULL,
                                        &hkeyConfigSet,
                                        &dwDisp))
    {
        hkeyConfigSet = NULL;
        goto Cleanup;
    }

    //
    //  If we created a new regkey, add encryption keys
    //

    if(dwDisp == REG_CREATED_NEW_KEY)
    {
        WriteRegTestKey(hkeyConfigSet);
    }

Cleanup:

    if(hkeyConfigSets)
        RegCloseKey(hkeyConfigSets);

    return hkeyConfigSet;
}

/**************************************************************************

    ReadRegConfigSet
    
    Read the current passport manager config set from the registry
    
**************************************************************************/
BOOL ReadRegConfigSet
(
    HWND            hWndDlg,
    LPPMSETTINGS    lpPMConfig,
    LPTSTR          lpszRemoteComputer,
    LPTSTR          lpszConfigSetName
)
{
    BOOL            bReturn;
    HKEY            hkeyPassport = NULL;           // Regkey where Passport Setting live
    HKEY            hkeyConfigSets = NULL;
    HKEY            hkeyConfig = NULL;
    HKEY            hklm = NULL;
    DWORD           dwcbTemp;
    DWORD           dwType;
    TCHAR           szText[MAX_RESOURCE];
    TCHAR           szTitle[MAX_RESOURCE];
            
    // Open the Passport Regkey ( either locally or remotly
    if (lpszRemoteComputer && ('\0' != lpszRemoteComputer[0]))
    {
        //
        //  Attempt to connect to the HKEY_LOCAL_MACHINE of the remote computer.
        //  If this fails, assume that the computer doesn't exist or doesn't have
        //  the registry server running.
        //
        switch (RegConnectRegistry(lpszRemoteComputer, 
                                   HKEY_LOCAL_MACHINE, 
                                   &hklm)) 
        {

            case ERROR_SUCCESS:
                break;

            case ERROR_ACCESS_DENIED:
                ReportError(hWndDlg, IDS_CONNECTACCESSDENIED);
                bReturn = FALSE;
                goto Cleanup;

            default:
                ReportError(hWndDlg, IDS_CONNECTBADNAME);
                bReturn = FALSE;
                goto Cleanup;
        }
    }
    else
    {
        hklm = HKEY_LOCAL_MACHINE;
    }

    // Open the key we want            
    if (ERROR_SUCCESS != RegOpenKeyEx(hklm,
                                      g_szPassportReg,
                                      0,
                                      KEY_ALL_ACCESS,
                                      &hkeyPassport))
    {                                          
        ReportError(hWndDlg, IDS_CONFIGREAD_ERROR);
        bReturn = FALSE;
        goto Cleanup;
    }            

    if(lpszConfigSetName && lpszConfigSetName[0] != TEXT('\0'))
    {
        hkeyConfig = OpenRegConfigSet(hklm, lpszConfigSetName);
        if(hkeyConfig == NULL)
        {
            ReportError(hWndDlg, IDS_CONFIGREAD_ERROR);
            bReturn = FALSE;
            goto Cleanup;
        }
    }
    else
    {
        hkeyConfig = hkeyPassport;
    }
    
    // The Install dir and Version number go into globals, because they are read
    // only values that must come from the target machine's registry.
    
    // Read the Install Dir. 
    dwcbTemp = MAX_PATH;
    dwType = REG_SZ;
    g_szInstallPath[0] = '\0';     // Default value
    RegQueryValueEx(hkeyPassport,
                    g_szInstallDir,
                    NULL,
                    &dwType,
                    (LPBYTE)g_szInstallPath,
                    &dwcbTemp);

    // Read the version Number
    dwcbTemp = MAX_REGISTRY_STRING;
    dwType = REG_SZ;
    g_szPMVersion[0] = '\0';          // Default value
    RegQueryValueEx(hkeyPassport,
                    g_szVersion,
                    NULL,
                    &dwType,
                    (LPBYTE)&g_szPMVersion,
                    &dwcbTemp);
    
    // The Remaining settings are read/write and get put into a PMSETTINGS struct
    
    // Read the Time Window Number
    dwcbTemp = sizeof(DWORD);
    dwType = REG_DWORD;
    lpPMConfig->dwTimeWindow = DEFAULT_TIME_WINDOW;
    RegQueryValueEx(hkeyConfig,
                    g_szTimeWindow,
                    NULL,
                    &dwType,
                    (LPBYTE)&lpPMConfig->dwTimeWindow,
                    &dwcbTemp);
        
    // Read the value for Forced Signin
    dwcbTemp = sizeof(DWORD);
    dwType = REG_DWORD;
    lpPMConfig->dwForceSignIn = 0;       // Don't force a signin by default
    RegQueryValueEx(hkeyConfig,
                    g_szForceSignIn,
                    NULL,
                    &dwType,
                    (LPBYTE)&lpPMConfig->dwForceSignIn,
                    &dwcbTemp);
                    
    // Read the default language ID
    dwcbTemp = sizeof(DWORD);
    dwType = REG_DWORD;
    lpPMConfig->dwLanguageID = DEFAULT_LANGID;                     // english
    RegQueryValueEx(hkeyConfig,
                    g_szLanguageID,
                    NULL,
                    &dwType,
                    (LPBYTE)&lpPMConfig->dwLanguageID,
                    &dwcbTemp);
                    
    // Get the co-branding template
    dwcbTemp = lpPMConfig->cbCoBrandTemplate;
    dwType = REG_SZ;
    lpPMConfig->szCoBrandTemplate[0] = '\0';       // Default value
    RegQueryValueEx(hkeyConfig,
                    g_szCoBrandTemplate,
                    NULL,
                    &dwType,
                    (LPBYTE)lpPMConfig->szCoBrandTemplate,
                    &dwcbTemp);
        
    // Get the SiteID
    dwcbTemp = sizeof(DWORD);
    dwType = REG_DWORD;
    lpPMConfig->dwSiteID = 1;                       // Default Site ID
    RegQueryValueEx(hkeyConfig,
                    g_szSiteID,
                    NULL,
                    &dwType,
                    (LPBYTE)&lpPMConfig->dwSiteID,
                    &dwcbTemp);
            
    // Get the return URL template
    dwcbTemp = lpPMConfig->cbReturnURL;
    dwType = REG_SZ;
    lpPMConfig->szReturnURL[0] = '\0';    // Set a default for the current value
    RegQueryValueEx(hkeyConfig,
                    g_szReturnURL,
                    NULL,
                    &dwType,
                    (LPBYTE)lpPMConfig->szReturnURL,
                    &dwcbTemp);

    // Get the ticket cookie domain
    dwcbTemp = lpPMConfig->cbTicketDomain;
    dwType = REG_SZ;
    lpPMConfig->szTicketDomain[0] = '\0';    // Set a default for the current value
    RegQueryValueEx(hkeyConfig,
                    g_szTicketDomain,
                    NULL,
                    &dwType,
                    (LPBYTE)lpPMConfig->szTicketDomain,
                    &dwcbTemp);
    
    // Get the ticket cookie path
    dwcbTemp = lpPMConfig->cbTicketPath;
    dwType = REG_SZ;
    lpPMConfig->szTicketPath[0] = '\0';    // Set a default for the current value
    RegQueryValueEx(hkeyConfig,
                    g_szTicketPath,
                    NULL,
                    &dwType,
                    (LPBYTE)lpPMConfig->szTicketPath,
                    &dwcbTemp);

    // Get the profile cookie domain
    dwcbTemp = lpPMConfig->cbProfileDomain;
    dwType = REG_SZ;
    lpPMConfig->szProfileDomain[0] = '\0';    // Set a default for the current value
    RegQueryValueEx(hkeyConfig,
                    g_szProfileDomain,
                    NULL,
                    &dwType,
                    (LPBYTE)lpPMConfig->szProfileDomain,
                    &dwcbTemp);
    
    // Get the profile cookie path
    dwcbTemp = lpPMConfig->cbProfilePath;
    dwType = REG_SZ;
    lpPMConfig->szProfilePath[0] = '\0';    // Set a default for the current value
    RegQueryValueEx(hkeyConfig,
                    g_szProfilePath,
                    NULL,
                    &dwType,
                    (LPBYTE)lpPMConfig->szProfilePath,
                    &dwcbTemp);

    // Get the secure cookie domain
    dwcbTemp = lpPMConfig->cbSecureDomain;
    dwType = REG_SZ;
    lpPMConfig->szSecureDomain[0] = '\0';    // Set a default for the current value
    RegQueryValueEx(hkeyConfig,
                    g_szSecureDomain,
                    NULL,
                    &dwType,
                    (LPBYTE)lpPMConfig->szSecureDomain,
                    &dwcbTemp);

    // Get the secure cookie path
    dwcbTemp = lpPMConfig->cbSecurePath;
    dwType = REG_SZ;
    lpPMConfig->szSecurePath[0] = '\0';    // Set a default for the current value
    RegQueryValueEx(hkeyConfig,
                    g_szSecurePath,
                    NULL,
                    &dwType,
                    (LPBYTE)lpPMConfig->szSecurePath,
                    &dwcbTemp);

    // Get the Disaster URL
    dwcbTemp = lpPMConfig->cbDisasterURL;
    dwType = REG_SZ;
    lpPMConfig->szDisasterURL[0] = '\0';    // Set a default for the current value
    RegQueryValueEx(hkeyConfig,
                    g_szDisasterURL,
                    NULL,
                    &dwType,
                    (LPBYTE)lpPMConfig->szDisasterURL,
                    &dwcbTemp);

    // Get Standalone mode setting
    dwcbTemp = sizeof(DWORD);
    dwType = REG_DWORD;
    lpPMConfig->dwStandAlone = 0;                       // NOT standalone by default
    RegQueryValueEx(hkeyConfig,
                    g_szStandAlone,
                    NULL,
                    &dwType,
                    (LPBYTE)&lpPMConfig->dwStandAlone,
                    &dwcbTemp);

    // Get DisableCookies mode setting
    dwcbTemp = sizeof(DWORD);
    dwType = REG_DWORD;
    lpPMConfig->dwDisableCookies = 0;                   // Cookies ENABLED by default
    RegQueryValueEx(hkeyConfig,
                    g_szDisableCookies,
                    NULL,
                    &dwType,
                    (LPBYTE)&lpPMConfig->dwDisableCookies,
                    &dwcbTemp);

#ifdef DO_KEYSTUFF
    // Get the current encryption key
    dwcbTemp = sizeof(DWORD);
    dwType = REG_DWORD;
    lpPMConfig->dwCurrentKey = 1;
    RegQueryValueEx(hkeyConfig,
                    g_szCurrentKey,
                    NULL,
                    &dwType,
                    (LPBYTE)&lpPMConfig->dwCurrentKey,
                    &dwcbTemp);
#endif    
    
    // For these next two, since they're required for named configs, we need
    // to check for too much data and truncate it.

    // Get the Host Name
    dwcbTemp = lpPMConfig->cbHostName;
    dwType = REG_SZ;
    lpPMConfig->szHostName[0] = '\0';    // Set a default for the current value
    if(ERROR_MORE_DATA == RegQueryValueEx(hkeyConfig,
                                          g_szHostName,
                                          NULL,
                                          &dwType,
                                          (LPBYTE)lpPMConfig->szHostName,
                                          &dwcbTemp))
    {
        LPBYTE pb = (LPBYTE)malloc(dwcbTemp);
        if(pb)
        {
            RegQueryValueEx(hkeyConfig,
                            g_szHostName,
                            NULL,
                            &dwType,
                            pb,
                            &dwcbTemp);

            memcpy(lpPMConfig->szHostName, pb, lpPMConfig->cbHostName);
            free(pb);

            ReportError(hWndDlg, IDS_HOSTNAMETRUNC_WARN);
        }
    }

    // Get the Host IP
    dwcbTemp = lpPMConfig->cbHostIP;
    dwType = REG_SZ;
    lpPMConfig->szHostIP[0] = '\0';    // Set a default for the current value
    if(ERROR_MORE_DATA == RegQueryValueEx(hkeyConfig,
                                          g_szHostIP,
                                          NULL,
                                          &dwType,
                                          (LPBYTE)lpPMConfig->szHostIP,
                                          &dwcbTemp))
    {
        LPBYTE pb = (LPBYTE)malloc(dwcbTemp);
        if(pb)
        {
            RegQueryValueEx(hkeyConfig,
                            g_szHostIP,
                            NULL,
                            &dwType,
                            pb,
                            &dwcbTemp);

            memcpy(lpPMConfig->szHostIP, pb, lpPMConfig->cbHostIP);
            free(pb);

            ReportError(hWndDlg, IDS_HOSTIPTRUNC_WARN);
        }
    }

    //  If we got empty strings for HostName or
    //  HostIP, and we have a named config it 
    //  means someone's been mucking with
    //  the registry.  Give them a warning and 
    //  return FALSE.
    if(lpszConfigSetName && lpszConfigSetName[0] &&
        (lpPMConfig->szHostName[0] == TEXT('\0') ||
        lpPMConfig->szHostIP[0] == TEXT('\0')))
    {
        ReportError(hWndDlg, IDS_CONFIGREAD_ERROR);
        bReturn = FALSE;
        goto Cleanup;
    }

    bReturn = TRUE; 

Cleanup:

    if (hkeyConfig && hkeyConfig != hkeyPassport)
        RegCloseKey(hkeyConfig);
    if (hkeyPassport)
        RegCloseKey(hkeyPassport);
    if (hkeyConfigSets)
        RegCloseKey(hkeyConfigSets);
    if (hklm && hklm != HKEY_LOCAL_MACHINE)
        RegCloseKey(hklm);

    return bReturn;
}

/**************************************************************************

    WriteRegConfigSet
    
    Write the current passport manager config set from the registry
    
**************************************************************************/

BOOL WriteRegConfigSet
(
    HWND            hWndDlg,
    LPPMSETTINGS    lpPMConfig,
    LPTSTR          lpszRemoteComputer,
    LPTSTR          lpszConfigSetName
)
{
    BOOL            bReturn;
    HKEY            hkeyPassport = NULL;           // Regkey where Passport Setting live
    HKEY            hkeyConfigSets = NULL;
    HKEY            hklm = NULL;
       
    // Open the Passport Regkey ( either locally or remotly
    if (lpszRemoteComputer && ('\0' != lpszRemoteComputer[0]))
    {
        //
        //  Attempt to connect to the HKEY_LOCAL_MACHINE of the remote computer.
        //  If this fails, assume that the computer doesn't exist or doesn't have
        //  the registry server running.
        //
        switch (RegConnectRegistry(lpszRemoteComputer, 
                                   HKEY_LOCAL_MACHINE, 
                                   &hklm)) 
        {

            case ERROR_SUCCESS:
                break;

            case ERROR_ACCESS_DENIED:
                ReportError(hWndDlg, IDS_CONNECTACCESSDENIED);
                bReturn = FALSE;
                goto Cleanup;

            default:
                ReportError(hWndDlg, IDS_CONNECTBADNAME);
                bReturn = FALSE;
                goto Cleanup;
        }
    }
    else
    {
        hklm = HKEY_LOCAL_MACHINE;
    }
            
    // Open the key we want
    if(lpszConfigSetName && lpszConfigSetName[0] != TEXT('\0'))
    {
        hkeyPassport = OpenRegConfigSet(hklm, lpszConfigSetName);
        if(hkeyPassport == NULL)
        {
            ReportError(hWndDlg, IDS_CONFIGREAD_ERROR);
            bReturn = FALSE;
            goto Cleanup;
        }
    }
    else
    {
        if (ERROR_SUCCESS != RegOpenKeyEx(hklm,
                                          g_szPassportReg,
                                          0,
                                          KEY_ALL_ACCESS,
                                          &hkeyPassport))
        {                                          
            ReportError(hWndDlg, IDS_CONFIGREAD_ERROR);
            bReturn = FALSE;                                      
            goto Cleanup;
        }            
    }
     
    // Write the Time Window Number
    RegSetValueEx(hkeyPassport,
                    g_szTimeWindow,
                    NULL,
                    REG_DWORD,
                    (LPBYTE)&lpPMConfig->dwTimeWindow,
                    sizeof(DWORD));
        
    // Write the value for Forced Signin
    RegSetValueEx(hkeyPassport,
                    g_szForceSignIn,
                    NULL,
                    REG_DWORD,
                    (LPBYTE)&lpPMConfig->dwForceSignIn,
                    sizeof(DWORD));
                    
    // Write the default language ID
    RegSetValueEx(hkeyPassport,
                    g_szLanguageID,
                    NULL,
                    REG_DWORD,
                    (LPBYTE)&lpPMConfig->dwLanguageID,
                    sizeof(DWORD));
                    
    // Write the co-branding template
    RegSetValueEx(hkeyPassport,
                    g_szCoBrandTemplate,
                    NULL,
                    REG_SZ,
                    (LPBYTE)lpPMConfig->szCoBrandTemplate,
                    lstrlen(lpPMConfig->szCoBrandTemplate) + 1);
        
    // Write the SiteID
    RegSetValueEx(hkeyPassport,
                    g_szSiteID,
                    NULL,
                    REG_DWORD,
                    (LPBYTE)&lpPMConfig->dwSiteID,
                    sizeof(DWORD));
            
    // Write the return URL template
    RegSetValueEx(hkeyPassport,
                    g_szReturnURL,
                    NULL,
                    REG_SZ,
                    (LPBYTE)lpPMConfig->szReturnURL,
                    lstrlen(lpPMConfig->szReturnURL) + 1);

    // Write the ticket cookie domain
    RegSetValueEx(hkeyPassport,
                    g_szTicketDomain,
                    NULL,
                    REG_SZ,
                    (LPBYTE)lpPMConfig->szTicketDomain,
                    lstrlen(lpPMConfig->szTicketDomain) + 1);
    
    // Write the ticket cookie path
    RegSetValueEx(hkeyPassport,
                    g_szTicketPath,
                    NULL,
                    REG_SZ,
                    (LPBYTE)lpPMConfig->szTicketPath,
                    lstrlen(lpPMConfig->szTicketPath) + 1);

    // Write the profile cookie domain
    RegSetValueEx(hkeyPassport,
                    g_szProfileDomain,
                    NULL,
                    REG_SZ,
                    (LPBYTE)lpPMConfig->szProfileDomain,
                    lstrlen(lpPMConfig->szProfileDomain) + 1);
    
    // Write the profile cookie path
    RegSetValueEx(hkeyPassport,
                    g_szProfilePath,
                    NULL,
                    REG_SZ,
                    (LPBYTE)lpPMConfig->szProfilePath,
                    lstrlen(lpPMConfig->szProfilePath) + 1);

    // Write the secure cookie domain
    RegSetValueEx(hkeyPassport,
                    g_szSecureDomain,
                    NULL,
                    REG_SZ,
                    (LPBYTE)lpPMConfig->szSecureDomain,
                    lstrlen(lpPMConfig->szSecureDomain) + 1);

    // Write the secure cookie path
    RegSetValueEx(hkeyPassport,
                    g_szSecurePath,
                    NULL,
                    REG_SZ,
                    (LPBYTE)lpPMConfig->szSecurePath,
                    lstrlen(lpPMConfig->szSecurePath) + 1);

    // Write the DisasterURL
    RegSetValueEx(hkeyPassport,
                    g_szDisasterURL,
                    NULL,
                    REG_SZ,
                    (LPBYTE)lpPMConfig->szDisasterURL,
                    lstrlen(lpPMConfig->szDisasterURL) + 1);

    // Write Standalone mode setting
    RegSetValueEx(hkeyPassport,
                    g_szStandAlone,
                    NULL,
                    REG_DWORD,
                    (LPBYTE)&lpPMConfig->dwStandAlone,
                    sizeof(DWORD));

    // Write DisableCookies mode setting
    RegSetValueEx(hkeyPassport,
                    g_szDisableCookies,
                    NULL,
                    REG_DWORD,
                    (LPBYTE)&lpPMConfig->dwDisableCookies,
                    sizeof(DWORD));

    // Only write HostName and HostIP for non-default config sets.
    if(lpszConfigSetName && lpszConfigSetName[0])
    {
        // Write the HostName
        RegSetValueEx(hkeyPassport,
                        g_szHostName,
                        NULL,
                        REG_SZ,
                        (LPBYTE)lpPMConfig->szHostName,
                        lstrlen(lpPMConfig->szHostName) + 1);

        // Write the HostIP
        RegSetValueEx(hkeyPassport,
                        g_szHostIP,
                        NULL,
                        REG_SZ,
                        (LPBYTE)lpPMConfig->szHostIP,
                        lstrlen(lpPMConfig->szHostIP) + 1);
    }

    bReturn = TRUE;
    
Cleanup:

    if(hklm && hklm != HKEY_LOCAL_MACHINE)
        RegCloseKey(hklm);
    if(hkeyConfigSets)
        RegCloseKey(hkeyConfigSets);
    if(hkeyPassport)
        RegCloseKey(hkeyPassport);

    return bReturn;
}


/**************************************************************************

    RemoveRegConfigSet
    
    Verify that the passed in config set is consistent with the current
    values in the registry.
    
**************************************************************************/
BOOL RemoveRegConfigSet
(
    HWND    hWndDlg,
    LPTSTR  lpszRemoteComputer,
    LPTSTR  lpszConfigSetName
)
{
    BOOL    bReturn;
    HKEY    hklm = NULL;
    HKEY    hkeyPassportConfigSets = NULL;

    //  Can't delete the default configuration set.
    if(lpszConfigSetName == NULL || lpszConfigSetName[0] == TEXT('\0'))
    {
        bReturn = FALSE;
        goto Cleanup;
    }

    // Open the Passport Configuration Sets Regkey ( either locally or remotly
    if (lpszRemoteComputer && ('\0' != lpszRemoteComputer[0]))
    {
        //
        //  Attempt to connect to the HKEY_LOCAL_MACHINE of the remote computer.
        //  If this fails, assume that the computer doesn't exist or doesn't have
        //  the registry server running.
        //
        switch (RegConnectRegistry(lpszRemoteComputer, 
                                   HKEY_LOCAL_MACHINE, 
                                   &hklm)) 
        {

            case ERROR_SUCCESS:
                break;

            case ERROR_ACCESS_DENIED:
                ReportError(hWndDlg, IDS_CONNECTACCESSDENIED);
                bReturn = FALSE;
                goto Cleanup;

            default:
                ReportError(hWndDlg, IDS_CONNECTBADNAME);
                bReturn = FALSE;
                goto Cleanup;
        }
    }
    else
    {
        hklm = HKEY_LOCAL_MACHINE;
    }
            
    // Open the key we want
    if (ERROR_SUCCESS != RegOpenKeyEx(hklm,
                                      g_szPassportSites,
                                      0,
                                      KEY_ALL_ACCESS,
                                      &hkeyPassportConfigSets))
    {
        ReportError(hWndDlg, IDS_CONFIGREAD_ERROR);
        bReturn = FALSE;
        goto Cleanup;
    }

    // Delete the config set key
    if (ERROR_SUCCESS != SHDeleteKey(hkeyPassportConfigSets, lpszConfigSetName))
    {
        ReportError(hWndDlg, IDS_CONFIGREAD_ERROR);
        bReturn = FALSE;
        goto Cleanup;
    }

    bReturn = TRUE;

Cleanup:

    if(hklm && hklm != HKEY_LOCAL_MACHINE)
        RegCloseKey(hklm);
    if(hkeyPassportConfigSets)
        RegCloseKey(hkeyPassportConfigSets);

    return bReturn;
}


/**************************************************************************

    VerifyRegConfigSet
    
    Verify that the passed in config set is consistent with the current
    values in the registry.
    
**************************************************************************/
BOOL VerifyRegConfigSet
(
    HWND            hWndDlg,
    LPPMSETTINGS    lpPMConfig,
    LPTSTR          lpszRemoteComputer,
    LPTSTR          lpszConfigSetName
)
{
    PMSETTINGS  pmCurrent;
    
    InitializePMConfigStruct(&pmCurrent);
    ReadRegConfigSet(hWndDlg, &pmCurrent, lpszRemoteComputer, lpszConfigSetName);
    
    return (0 == memcmp(&pmCurrent, lpPMConfig, sizeof(PMSETTINGS)));
}

/**************************************************************************

    ReadRegConfigSetNames
    
    Get back a list of config set names on a local or remote machine.
    Caller is responsible for calling free() on the returned pointer.

    When this function returns TRUE, lppszConfigSetNames will either
    contain NULL or a string containing the NULL delimited config set
    names on the given computer.

    When this function returns FALSE, *lppszConfigSetNames will not
    be modified.
    
**************************************************************************/
BOOL ReadRegConfigSetNames
(
    HWND            hWndDlg,
    LPTSTR          lpszRemoteComputer,
    LPTSTR*         lppszConfigSetNames
)
{
    BOOL        bReturn;
    HKEY        hklm = NULL;
    HKEY        hkeyConfigSets = NULL;
    DWORD       dwIndex;
    DWORD       dwNumSubKeys;
    DWORD       dwMaxKeyNameLen;
    TCHAR       achKeyName[MAX_PATH];
    ULONGLONG   ullAllocSize;
    LPTSTR      lpszConfigSetNames;
    LPTSTR      lpszCur;

    // Open the Passport Regkey ( either locally or remotly
    if (lpszRemoteComputer && (TEXT('\0') != lpszRemoteComputer[0]))
    {
        //
        //  Attempt to connect to the HKEY_LOCAL_MACHINE of the remote computer.
        //  If this fails, assume that the computer doesn't exist or doesn't have
        //  the registry server running.
        //
        switch (RegConnectRegistry(lpszRemoteComputer, 
                                   HKEY_LOCAL_MACHINE, 
                                   &hklm)) 
        {

            case ERROR_SUCCESS:
                break;

            case ERROR_ACCESS_DENIED:
                ReportError(hWndDlg, IDS_CONNECTACCESSDENIED);
                bReturn = FALSE;
                goto Cleanup;

            default:
                ReportError(hWndDlg, IDS_CONNECTBADNAME);
                bReturn = FALSE;
                goto Cleanup;
        }
    }
    else
    {
        hklm = HKEY_LOCAL_MACHINE;
    }

    if (ERROR_SUCCESS != RegOpenKeyEx(hklm,
                                      g_szPassportSites,
                                      0,
                                      KEY_ALL_ACCESS,
                                      &hkeyConfigSets))
    {
        bReturn = FALSE;
        goto Cleanup;
    }

    if (ERROR_SUCCESS != RegQueryInfoKey(hkeyConfigSets,
                                         NULL,
                                         NULL,
                                         NULL,
                                         &dwNumSubKeys,
                                         &dwMaxKeyNameLen,
                                         NULL,
                                         NULL,
                                         NULL,
                                         NULL,
                                         NULL,
                                         NULL))
    {
        bReturn = FALSE;
        goto Cleanup;
    }

    //
    //  Nothing to do!
    //

    if(dwNumSubKeys == 0)
    {
        bReturn = TRUE;
        *lppszConfigSetNames = NULL;
        goto Cleanup;
    }

    //  Too big?  BUGBUG - We should make sure we check for this 
    //  When writing out config sets.
    ullAllocSize = UInt32x32To64(dwNumSubKeys, dwMaxKeyNameLen);
    if(ullAllocSize & 0xFFFFFFFF00000000)
    {
        bReturn = FALSE;
        goto Cleanup;
    }

    //  This should allocate more space than we need.
    lpszConfigSetNames = (LPTSTR)malloc(((dwNumSubKeys * (dwMaxKeyNameLen + 1)) + 1) * sizeof(TCHAR));
    if(lpszConfigSetNames == NULL)
    {
        bReturn = FALSE;
        goto Cleanup;
    }

    //  Read all names into the buffer.  Names are NULL delimited and
    //  two NULLs end the entire thing.
    dwIndex = 0;
    lpszCur = lpszConfigSetNames;
    while (ERROR_SUCCESS == RegEnumKey(hkeyConfigSets, dwIndex++, achKeyName, sizeof(achKeyName)))
    {
        _tcscpy(lpszCur, achKeyName);
        lpszCur = _tcschr(lpszCur, TEXT('\0')) + 1;
    }

    *lpszCur = TEXT('\0');

    *lppszConfigSetNames = lpszConfigSetNames;
    bReturn = TRUE;

Cleanup:

    if(hklm)
        RegCloseKey(hklm);
    if(hkeyConfigSets)
        RegCloseKey(hkeyConfigSets);

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\common\common.h ===
#ifndef __COMMON_H__
#define __COMMON_H__

//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        common.cxx
//
// Contents:    Shared SSPI code
//
//
// History:     11-March-2000   Created         Todds
//
//------------------------------------------------------------------------



typedef enum _SSP_STATE {
        SspLsaMode = 1,
        SspUserMode
} SSP_STATE, *PSSP_STATE;

// point at SSP global call state for use in allocations
#ifdef MSV_SSP
EXTERN PSSP_STATE pSspState = (PSSP_STATE) NtLmState; 
#endif

#ifdef KERB_SSP
EXTERN PSSP_STATE pSspState = (PSSP_STATE) KerberosState;
#endif









#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\digest\auth.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        auth.h
//
// Contents:    include file for auth.cxx for NTDigest
//
//
// History:     KDamour 15Mar00   Stolen from msv_sspi\global.h
//
//------------------------------------------------------------------------

#ifndef NTDIGEST_AUTH_H
#define NTDIGEST_AUTH_H

#include "nonce.h"


// Contains all of the pointers and lengths for directives used in
// calculating the digest access values.  Usually the
// parameters point to an external buffer, pHTTPBuffer

enum DIGEST_TYPE
{
    DIGEST_UNDEFINED,           // Initial state
    NO_DIGEST_SPECIFIED,
    DIGEST_CLIENT,
    DIGEST_SERVER,
    SASL_SERVER,
    SASL_CLIENT
};

enum QOP_TYPE
{
    QOP_UNDEFINED,          // Initial state
    NO_QOP_SPECIFIED,
    AUTH,
    AUTH_INT,
    AUTH_CONF
};
typedef QOP_TYPE *PQOP_TYPE;

enum ALGORITHM_TYPE
{
    ALGORITHM_UNDEFINED,            // Initial state
    NO_ALGORITHM_SPECIFIED,
    MD5,
    MD5_SESS
};

enum CHARSET_TYPE
{
    CHARSET_UNDEFINED,            // Initial state
    ISO_8859_1,
    UTF_8,                        // UTF-8 encoding
    UTF_8_SUBSET                  // ISO_8859_1 subset in UTF-8
};

enum CIPHER_TYPE
{
    CIPHER_UNDEFINED,
    CIPHER_3DES,
    CIPHER_DES,                      // 56bit key
    CIPHER_RC4_40,
    CIPHER_RC4,                      // 128bit key
    CIPHER_RC4_56
};

enum DIGESTMODE_TYPE
{
    DIGESTMODE_UNDEFINED,
    DIGESTMODE_HTTP,
    DIGESTMODE_SASL
};

enum NAMEFORMAT_TYPE
{
    NAMEFORMAT_UNKNOWN,
    NAMEFORMAT_ACCOUNTNAME,
    NAMEFORMAT_UPN,
    NAMEFORMAT_NETBIOS
};

// For list of supported protocols
// Pack supported cyphers into a WORD (2 bytes)
#define SUPPORT_3DES    0x0001
#define SUPPORT_DES     0x0002
#define SUPPORT_RC4_40  0x0004
#define SUPPORT_RC4     0x0008
#define SUPPORT_RC4_56  0x0010

// Strings for the challenge and challengeResponse

#define STR_CIPHER_3DES    "3des"
#define STR_CIPHER_DES     "des"
#define STR_CIPHER_RC4_40  "rc4-40"
#define STR_CIPHER_RC4     "rc4"
#define STR_CIPHER_RC4_56  "rc4-56"

#define WSTR_CIPHER_HMAC_MD5    L"HMAC_MD5"
#define WSTR_CIPHER_RC4         L"RC4"
#define WSTR_CIPHER_DES         L"DES"
#define WSTR_CIPHER_3DES        L"3DES"


typedef enum _eSignSealOp {
    eSign,      // MakeSignature is calling
    eVerify,    // VerifySignature is calling
    eSeal,      // SealMessage is calling
    eUnseal     // UnsealMessage is calling
} eSignSealOp;



// Supplimental credentals stored in the DC (pre-calculated Digest Hashes
#define SUPPCREDS_VERSION 1
#define NUMPRECALC_HEADERS  9
#define TOTALPRECALC_HEADERS (NUMPRECALC_HEADERS + 1)

// Format in supplimental credentials
#define NAME_HEADER            0
#define NAME_ACCT              1
#define NAME_ACCT_DOWNCASE     2
#define NAME_ACCT_UPCASE       3
#define NAME_UPN               4
#define NAME_UPN_DOWNCASE      5
#define NAME_UPN_UPCASE        6
#define NAME_NT4               7
#define NAME_NT4_DOWNCASE      8
#define NAME_NT4_UPCASE        9

// Bit flags for Packed UserContext 
#define USERCONTEXT_UPDATE   0x00000001

//
// value names used by MD5 authentication.
//

enum MD5_AUTH_NAME
{
    MD5_AUTH_USERNAME = 0,
    MD5_AUTH_REALM,
    MD5_AUTH_NONCE,
    MD5_AUTH_CNONCE,
    MD5_AUTH_NC,
    MD5_AUTH_ALGORITHM,
    MD5_AUTH_QOP,
    MD5_AUTH_METHOD,
    MD5_AUTH_URI,
    MD5_AUTH_RESPONSE,
    MD5_AUTH_HENTITY,
    MD5_AUTH_AUTHZID,           // for SASL
            // Above this list are Marshalled to DC as BlobData
    MD5_AUTH_DOMAIN,
    MD5_AUTH_STALE,
    MD5_AUTH_OPAQUE,
    MD5_AUTH_MAXBUF,
    MD5_AUTH_CHARSET,
    MD5_AUTH_CIPHER,
    MD5_AUTH_DIGESTURI,          // for SASL mapped to MD5_AUTH_URI
    MD5_AUTH_RSPAUTH,           // verify server has auth data
    MD5_AUTH_LAST
};


// Structure to pass around that contains the parameters for the Digest Calculation
typedef struct _DIGEST_PARAMETER
{
    DIGEST_TYPE typeDigest;
    ALGORITHM_TYPE typeAlgorithm;
    QOP_TYPE typeQOP;
    CIPHER_TYPE typeCipher;
    CHARSET_TYPE typeCharset;
    STRING refstrParam[MD5_AUTH_LAST];         // referenced - points to non-owned memory- do not free up these Strings
    UNICODE_STRING ustrRealm;                  // extracted from the digest auth directive values
    UNICODE_STRING ustrUsername;               // extracted from the digest auth directive values
    UNICODE_STRING ustrUri;                    // extracted from the digest auth directive values

    // Results from DSCrackName
    NAMEFORMAT_TYPE  typeName;
    UNICODE_STRING ustrCrackedAccountName;     // SAMAccount name from DSCrackName
    UNICODE_STRING ustrCrackedDomain;          // Domain from DSCrackName

    STRING  strUsernameEncoded;                // contains a copy of the encoded string used in challengeresponse
    STRING  strRealmEncoded;                   // contains a copy of the realm

    STRING  strDirective[MD5_AUTH_LAST];       // NULL terminated strings that contain directive values

    STRING  strSessionKey;                   // String for Sessionkey (points to chSessionKey)

        // STRINGS Alloced by DigestInit and Freed by DigestFree
    STRING strResponse;                     // String for the BinHex Hashed Response

} DIGEST_PARAMETER, *PDIGEST_PARAMETER;

// Structure to extract MD5 hashes and passwords for user accounts
typedef struct _USER_CREDENTIALS
{
    UNICODE_STRING ustrUsername;
    UNICODE_STRING ustrDomain;
    NAMEFORMAT_TYPE  typeName;

    // The following fields might be filled in
    // Will check any precalculated hashes first and then try the password if available
    BOOL           fIsValidPasswd;                 // set true if password is valid
    BOOL           fIsValidDigestHash;             // set true if hash is valid
    BOOL           fIsEncryptedPasswd;             // set to TRUE is passwd encrypted
    SHORT          wHashSelected;                  // if hash valid, index to process
    SHORT          sHashTags[TOTALPRECALC_HEADERS];  // indicate which hashes match username format
    UNICODE_STRING ustrPasswd;
    STRING         strDigestHash;

} USER_CREDENTIALS, *PUSER_CREDENTIALS;


//     Data to use GenericPassthrough to send to the DC for processing
//  The server will create the data, BlobData, and it will be wraped for
//  transport over GenericPassthrough to the DC.  The DC will be presented
//  with only the BlobData to process
//  ALL directive-values have a NULL terminator attached to each directive
//  ALL directive-values are UNQUOTED   unq("X") -> X
//  cbBlobSize has number of bytes to hold header and the string data
//  cbCharValues has number of bytes to hold string data
//  This way future revs can Version++, increase cbBlobSize, and append to message
//
//  Data Format
//
//       USHORT                 Version
//       USHORT                 cbBlobSize
//       USHORT                 DIGEST_TYPE
//       USHORT                 cbCharValues
//
//       CHAR[cbUserName+1]     unq(username-value)
//       CHAR[cbRealm+1]        unq(realm-value)    
//       CHAR[cbNonce+1]        unq(nonce-value)    
//       CHAR[cbCnonce+1]       unq(cnonce-value)    
//       CHAR[cbNC+1]           unq(nc-value)    
//       CHAR[cbAlgorithm+1]           unq(algorithm-value)    
//       CHAR[cbQOP+1]          unq(qop-value)    
//       CHAR[cbMethod+1]       Method    
//       CHAR[cbURI+1]            unq(digest-uri-value)
//       CHAR[cbReqDigest+1]     unq(request-digest)
//       CHAR[cbHEntity+1]      unq(H(entity-body))   * maybe NULL only for qop="auth"
//       CHAR[cbAuthzId+1]     unq(AuthzId-value)
//
//
#define DIGEST_BLOB_VERSION     1
#define DIGEST_BLOB_VALUES        12              // How many field-values are sent over

// Values for separators detweent field-values
#define COLONSTR ":"
#define COLONSTR_LEN 1

#define AUTHSTR "auth"
#define AUTHSTR_LEN 4

#define AUTHINTSTR "auth-int"
#define AUTHINTSTR_LEN 8

#define AUTHCONFSTR "auth-conf"
#define AUTHCONFSTR_LEN 9
#define MAX_AUTH_LENGTH AUTHCONFSTR_LEN

#define MD5STR "MD5"

#define MD5_SESSSTR "MD5-sess"
#define MD5_SESS_SASLSTR "md5-sess"
#define MD5_UTF8STR "utf-8"

#define URI_STR "uri"
#define DIGESTURI_STR "digest-uri"

// SASL paramters
#define AUTHENTICATESTR "AUTHENTICATE"

#define ZERO32STR "00000000000000000000000000000000"

#define SASL_C2S_SIGN_KEY "Digest session key to client-to-server signing key magic constant"
#define SASL_S2C_SIGN_KEY "Digest session key to server-to-client signing key magic constant"

#define SASL_C2S_SEAL_KEY "Digest H(A1) to client-to-server sealing key magic constant"
#define SASL_S2C_SEAL_KEY "Digest H(A1) to server-to-client sealing key magic constant"


// Number of characters in the NonceCount (hex digits)
#define NCNUM             8

#define NCFIRST    "00000001"

// Overlay header for getting values in Generic Passthrough request
typedef struct _DIGEST_BLOB_REQUEST
{
    ULONG       MessageType;
    USHORT      version;
    USHORT      cbBlobSize;
    USHORT      digest_type;
    USHORT      qop_type;
    USHORT      alg_type;
    USHORT      charset_type;
    USHORT      cbCharValues;
    USHORT      name_format;
    USHORT      usReserved1;
    ULONG       ulReserved2;
    ULONG       ulReserved3;
    ULONG64     pad1;
    char        cCharValues;    // dummy char to mark start of field-values
} DIGEST_BLOB_REQUEST, *PDIGEST_BLOB_REQUEST;

// Supported MesageTypes
#define VERIFY_DIGEST_MESSAGE          0x1a                 // No specific value is needed
#define VERIFY_DIGEST_MESSAGE_RESPONSE 0x0a                 // No specific value is needed

// The response for the GenericPassthrough call is the status of the Digest Authentication
// Note: This is a fixed length response header - Authdata length not static
typedef struct _DIGEST_BLOB_RESPONSE
{
    ULONG       MessageType;
    USHORT      version;
    NTSTATUS    Status;             // Information on Success of Digest Auth
    USHORT      SessionKeyMaxLength;
    ULONG       ulAuthDataSize;
    ULONG       ulReserved1;
    ULONG       ulReserved2;
    ULONG       ulReserved3;
    char        SessionKey[MD5_HASH_HEX_SIZE + 1];
    ULONG64     pad1;
    char        cAuthData;                  // Start of AuthData opaque data
    // Place group info here for LogonUser
} DIGEST_BLOB_RESPONSE, *PDIGEST_BLOB_RESPONSE;

// SASL MAC block
//      Total of 16 bytes per rfc2831 sect 2.3
//            first 10 bytes of HMAC-MD5 [ RFC 2104]
//            2-byte message type number fixed to value 1  (0x0001)
//            4-byte sequence number
// NOTE:  This is using WORD as a 2 byte value and DWORD as a 4 byte value!
#define HMAC_MD5_HASH_BYTESIZE 16                         // MHAC-MD5 hash size per RFC 2104
#define SASL_MAC_HMAC_SIZE 10
#define SASL_MAC_MSG_SIZE  2
#define SASL_MAC_SEQ_SIZE 4
typedef struct _SASL_MAC_BLOCK
{
    UCHAR      hmacMD5[SASL_MAC_HMAC_SIZE];
    WORD       wMsgType;
    DWORD      dwSeqNumber;
} SASL_MAC_BLOCK, *PSASL_MAC_BLOCK;


    // The SASL MAC Block is 16 bytes: RFC 2831 sect 2.4
#define MAC_BLOCK_SIZE   sizeof(SASL_MAC_BLOCK)

#define MAX_PADDING  8         // max padding is currently 8 for DES



// Encode the Digest Access Parameters fields into a BYTE Buffer
NTSTATUS NTAPI BlobEncodeRequest(IN PDIGEST_PARAMETER pDigest, OUT BYTE **ppBuffer, OUT USHORT *cbBuffer);

// Decode the Digest Access Parameters fields from a BYTE Buffer
NTSTATUS NTAPI BlobDecodeRequest(IN BYTE *pBuffer, PDIGEST_PARAMETER pDigest);

// Free BYTE Buffer from BlobEncodeRequest
VOID NTAPI BlobFreeRequest(BYTE *pBuffer);

// Hash and Encode upto 7 STRINGS SOut = Hex(H(S1 ":" S2 ... ":" S7))
NTSTATUS NTAPI DigestHash7(IN PSTRING pS1, IN PSTRING pS2, IN PSTRING pS3,
           IN PSTRING pS4, IN PSTRING pS5, IN PSTRING pS6, IN PSTRING pS7,
           IN BOOL fHexOut,
           OUT PSTRING pSOut);

// Perform Digest Access Calculation
NTSTATUS NTAPI DigestCalculation(IN PDIGEST_PARAMETER pDigest, IN PUSER_CREDENTIALS pUserCreds);

// Simple checks for enough data for Digest calculation
NTSTATUS NTAPI DigestIsValid(IN PDIGEST_PARAMETER pDigest);

// Initialize the DIGEST_PARAMETER structure
NTSTATUS NTAPI DigestInit(IN PDIGEST_PARAMETER pDigest);

// Clear out the digest & free memory from Digest struct
NTSTATUS NTAPI DigestFree(IN PDIGEST_PARAMETER pDigest);

// Determine H(A1) for Digest Access
NTSTATUS NTAPI DigestCalcHA1(IN PDIGEST_PARAMETER pDigest, PUSER_CREDENTIALS pUserCreds);

// Perform Digest Access Calculation for ChallengeResponse
NTSTATUS NTAPI DigestCalcChalRsp(IN PDIGEST_PARAMETER pDigest,
                                 IN PUSER_CREDENTIALS pUserCreds,
                                 BOOL bIsChallenge);

// Processed parsed digest auth message and fill in string values
NTSTATUS NTAPI DigestDecodeDirectiveStrings(IN OUT PDIGEST_PARAMETER pDigest);


NTSTATUS PrecalcDigestHash(
    IN PUNICODE_STRING pustrUsername, 
    IN PUNICODE_STRING pustrRealm,
    IN PUNICODE_STRING pustrPassword,
    OUT PCHAR pHexHash,
    IN OUT PUSHORT piHashSize);

NTSTATUS PrecalcForms(
    IN PUNICODE_STRING pustrUsername, 
    IN PUNICODE_STRING pustrRealm,
    IN PUNICODE_STRING pustrPassword,
    OUT PCHAR pHexHash,
    IN OUT PUSHORT piHashSize);

#endif  // NTDIGEST_AUTH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\digest\cred.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        creds.cxx
//
// Contents:    Credential functions:
//
//
// History:     KDamour  15Mar00   Stolen from NTLM
//
//------------------------------------------------------------------------
#include "global.h"

//
// Crit Sect to protect various globals in this module.
//

RTL_CRITICAL_SECTION l_CredentialCritSect;

LIST_ENTRY l_CredentialList;

// Simple variable to make sure that the package was initialize
BOOL g_bCredentialsInitialized = FALSE;



//+--------------------------------------------------------------------
//
//  Function:   CredHandlerInit
//
//  Synopsis:   Initializes the credential manager package
//
//  Arguments:  none
//
//  Returns: NTSTATUS
//
//  Notes: Called by SpInitialize
//
//---------------------------------------------------------------------
NTSTATUS
CredHandlerInit(VOID)
{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Initialize the Credential list to be empty.
    //

    Status = RtlInitializeCriticalSection(&l_CredentialCritSect);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "CredHandlerInit: Failed to initialize critsec   0x%x\n", Status));
        goto CleanUp;
    }

    
    InitializeListHead( &l_CredentialList );

    // Simple variable test to make sure all initialized;
    g_bCredentialsInitialized = TRUE;

CleanUp:

    return Status;
}

NTSTATUS
CredHandlerInsertCred(
    IN PDIGEST_CREDENTIAL  pDigestCred
    )
{
    RtlEnterCriticalSection( &l_CredentialCritSect );
    pDigestCred->Unlinked = FALSE;
    InsertHeadList( &l_CredentialList, &pDigestCred->Next );
    RtlLeaveCriticalSection( &l_CredentialCritSect );

    return STATUS_SUCCESS;
}


// Initialize the Credential Structure
NTSTATUS
CredentialInit(
    IN PDIGEST_CREDENTIAL pDigestCred)
{
    NTSTATUS Status = STATUS_SUCCESS;
    ASSERT(pDigestCred);

    if (!pDigestCred)
    {
        return STATUS_INVALID_PARAMETER;
    }

    ZeroMemory(pDigestCred, sizeof(DIGEST_CREDENTIAL));
    pDigestCred->TimeCreated = time(NULL);
    pDigestCred->Unlinked = TRUE;
    pDigestCred->CredentialHandle = (ULONG_PTR)pDigestCred;
    pDigestCred->lReferences = 0;

    return(Status);
}


// Free up memory utilized by Credential the Credential Structure
NTSTATUS
CredentialFree(
    IN PDIGEST_CREDENTIAL pDigestCred)
{
    NTSTATUS Status = STATUS_SUCCESS;
    ASSERT(pDigestCred);
    ASSERT(0 == pDigestCred->lReferences);

    UnicodeStringFree(&(pDigestCred->ustrAccountName));
    UnicodeStringFree(&(pDigestCred->ustrDownlevelName));
    UnicodeStringFree(&(pDigestCred->ustrDomainName));

    // Erase any password information
    if (((pDigestCred->ustrPassword).Length) &&
        ((pDigestCred->ustrPassword).Buffer))
    {
        ZeroMemory((pDigestCred->ustrPassword).Buffer, (pDigestCred->ustrPassword).MaximumLength);
    }
    UnicodeStringFree(&(pDigestCred->ustrPassword));
    UnicodeStringFree(&(pDigestCred->ustrDnsDomainName));
    UnicodeStringFree(&(pDigestCred->ustrUpn));
    UnicodeStringFree(&(pDigestCred->ustrLogonServer));

    DigestFreeMemory(pDigestCred);

    return(Status);
}



/*++

Routine Description:

    This routine checks to see if the Credential Handle is from a currently
    active client, and references the Credential if it is valid.

    The caller can request that the Credential be dereferenced only.

    For a client's Credential to be valid, the Credential value
    must be on our list of active Credentials.


Arguments:

    CredentialHandle - Points to the CredentialHandle of the Credential
        to be referenced.

    DereferenceCredential - This boolean value indicates whether the caller
        wants the logon process's Credential to be referenced (FALSE) or
        decremented (TRUE)
        

Return Value:

    NULL - the Credential was not found.

    Otherwise - returns a pointer to the referenced credential.

--*/

NTSTATUS
CredHandlerHandleToPtr(
                      IN ULONG_PTR CredentialHandle,
                      IN BOOLEAN DereferenceCredential,
                      OUT PDIGEST_CREDENTIAL * UserCredential
                      )
{
    PLIST_ENTRY ListEntry = NULL;
    PDIGEST_CREDENTIAL Credential = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    SECPKG_CLIENT_INFO ClientInfo;
    SECPKG_CALL_INFO CallInfo;

    // LONG lDereferenceCount = 1;
    ULONG ulDereferenceCount = 1;
    LONG lReferences = 0;

    DebugLog((DEB_TRACE_FUNC, "CredHandlerHandleToPtr: Entering   Credential 0x%x\n", CredentialHandle));

      // set default output
    ASSERT(UserCredential);
    *UserCredential = NULL ;


    ZeroMemory( &CallInfo, sizeof(CallInfo) );
    ZeroMemory( &ClientInfo, sizeof(ClientInfo) );


    if(g_LsaFunctions->GetCallInfo(&CallInfo))
    {
        ulDereferenceCount = CallInfo.CallCount;
        DebugLog((DEB_TRACE, "CredHandlerHandleToPtr: CallCount  0x%x\n", CallInfo.CallCount));
        DebugLog((DEB_TRACE, "CredHandlerHandleToPtr: Attributes  0x%x\n", CallInfo.Attributes));
        DebugLog((DEB_TRACE, "CredHandlerHandleToPtr: PID %d  Thread %d\n", CallInfo.ProcessId, CallInfo.ThreadId));
    }
    else
    {
        ZeroMemory( &CallInfo, sizeof(CallInfo) );
    }

    Status = g_LsaFunctions->GetClientInfo(&ClientInfo);

    if(!NT_SUCCESS(Status))
    {
        //
        // this call can fail during a cleanup call.  so ignore that for now,
        // and check for cleanup disposition.
        //

        if ((CallInfo.Attributes & SECPKG_CALL_CLEANUP) != 0)
        {
            Status = STATUS_SUCCESS;
            RtlZeroMemory(
                &ClientInfo,
                sizeof(SECPKG_CLIENT_INFO)
                );
            ClientInfo.HasTcbPrivilege = TRUE;
            ClientInfo.ProcessID = CallInfo.ProcessId;
        }

        if( !NT_SUCCESS( Status ) )
        {
            DebugLog(( DEB_ERROR, "CredHandlerHandleToPtr: GetClientInfo returned 0x%lx\n", Status));
            return( Status );
        }
    }

    if( CallInfo.Attributes & SECPKG_CALL_CLEANUP )
    {
        DebugLog(( DEB_TRACE, "CredHandlerHandleToPtr: Cleanup Called    pid: 0x%lx handle: %p refcount: %lu\n",
                    ClientInfo.ProcessID, CredentialHandle, ulDereferenceCount));
    }

    //
    // Acquire exclusive access to the Credential list
    //

    RtlEnterCriticalSection( &l_CredentialCritSect );


    //
    // Now walk the list of Credentials looking for a match.
    //

    for ( ListEntry = l_CredentialList.Flink;
        ListEntry != &l_CredentialList;
        ListEntry = ListEntry->Flink )
    {

        Credential = CONTAINING_RECORD( ListEntry, DIGEST_CREDENTIAL, Next );


        //
        // Found a match ... reference this Credential
        // (if the Credential is being removed, we would increment
        // and then decrement the reference, so don't bother doing
        // either - since they cancel each other out).
        //

        if (( Credential == (PDIGEST_CREDENTIAL) CredentialHandle))
        {

            // Make sure we have the privilege of accessing
            // this handle

            if (!ClientInfo.HasTcbPrivilege &&
               (Credential->ClientProcessID != ClientInfo.ProcessID)
               )
            {
                DebugLog((DEB_ERROR, "CredHandlerHandleToPtr: ProcessIDs are different. Access forbidden.\n"));
                break;
            }

            if (!DereferenceCredential)
            {
                lReferences = InterlockedIncrement(&Credential->lReferences);

                DebugLog((DEB_TRACE, "CredHandlerHandleToPtr: Incremented   ReferenceCount %ld\n", lReferences));
            }
            else
            {
                DebugLog((DEB_TRACE, "CredHandlerHandleToPtr: Derefencing credential\n" ));

                ASSERT((ulDereferenceCount > 0));

                // Note: Subtract one off of the deref count, this avoids an extra interlock operation
                //    After exit, SpFreeCredentialsHandle will call CredHandlerRelease


                ulDereferenceCount--;

                if( ulDereferenceCount == 1 )
                {
                    DebugLog((DEB_TRACE, "CredHandlerHandleToPtr: Derefencing by one count\n" ));
                    lReferences = InterlockedDecrement( &Credential->lReferences );

                    ASSERT( (lReferences > 0) );

                }
                else if( ulDereferenceCount > 1 )
                {

                    //
                    // there is no equivalent to InterlockedSubtract.
                    // so, turn it into an Add with some signed magic.
                    //

                    LONG lDecrementToIncrement = 0 - ulDereferenceCount;

                    DebugLog((DEB_TRACE, "CredHandlerHandleToPtr: Derefencing by %lu count\n", ulDereferenceCount ));

                    lReferences = InterlockedExchangeAdd( &Credential->lReferences, lDecrementToIncrement );
                    lReferences += lDecrementToIncrement;

                    ASSERT( (lReferences > 0) );
                }
            }

            // Found the Credential
            *UserCredential = Credential ;
            goto CleanUp;

        }
    }


    //
    // No match found
    //
    DebugLog((DEB_WARN, "CredHandlerHandleToCredential: Tried to reference unknown Credential 0x%lx\n",
              CredentialHandle ));

    Status = STATUS_INVALID_HANDLE;

CleanUp:

    RtlLeaveCriticalSection( &l_CredentialCritSect );

    DebugLog((DEB_TRACE_FUNC, "CredHandlerHandleToPtr: Leaving   Credential 0x%x\n", CredentialHandle));

    return(Status);
}


// Locate a Credential based on a LogonId, ProcessID
// For either the Logon list or the Credential list

NTSTATUS
CredHandlerLocatePtr(
                    IN PLUID pLogonId,
                    IN ULONG   CredentialUseFlags,
                    OUT PDIGEST_CREDENTIAL * UserCredential
                    )
{
    PLIST_ENTRY ListEntry = NULL;
    PDIGEST_CREDENTIAL Credential = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    // SECPKG_CLIENT_INFO ClientInfo;
    SECPKG_CALL_INFO CallInfo;
    LONG lReferences = 0;

    DebugLog((DEB_TRACE_FUNC, "CredHandlerLocatePtr: Entering\n"));

    *UserCredential = NULL ;

    // If we do not have a LogonId
    if (!pLogonId)
    {
        return(STATUS_INVALID_HANDLE);
    }

    //
    // Match both flags
    //

    // CredentialUseFlags |= CredentialFlags;

    if (!g_LsaFunctions->GetCallInfo(&CallInfo))
    {
        DebugLog((DEB_ERROR,"CredHandlerLocatePtr: Failed to get call info\n"));
        return(STATUS_INVALID_HANDLE);    // Really this is another error
    }


    //
    // Acquire exclusive access to the Credential list
    //

    RtlEnterCriticalSection( &l_CredentialCritSect );


    //
    // Now walk the list of Credentials looking for a match.
    //

    for ( ListEntry = l_CredentialList.Flink;
        ListEntry != &l_CredentialList;
        ListEntry = ListEntry->Flink )
    {

        Credential = CONTAINING_RECORD( ListEntry, DIGEST_CREDENTIAL, Next );


        //
        // Found a match ... reference this Credential
        // (if the Credential is being removed, we would increment
        // and then decrement the reference, so don't bother doing
        // either - since they cancel each other out).
        //

        // If this is a session credential then check for appropriate flags (like inbound or outbound)
        if ((Credential->CredentialUseFlags & DIGEST_CRED_MATCH_FLAGS) != CredentialUseFlags)
        {
            continue;
        }

        if (RtlEqualLuid(&(Credential->LogonId), pLogonId) &&
            (Credential->ClientProcessID == CallInfo.ProcessId))
        {
            lReferences = InterlockedIncrement(&Credential->lReferences);

            DebugLog((DEB_TRACE, "CredHandlerLocatePtr: ReferenceCount %ld\n", lReferences));

            // Found the Credential
            *UserCredential = Credential ;

            goto CleanUp;

        }

    }

    //
    // No match found
    //
    DebugLog((DEB_WARN, "CredHandlerLocatePtr: Tried to reference unknown LogonId (%x:%lx)\n",
               pLogonId->HighPart, pLogonId->LowPart ));
    Status = STATUS_INVALID_HANDLE;

CleanUp:

    RtlLeaveCriticalSection( &l_CredentialCritSect );


    DebugLog((DEB_TRACE_FUNC, "CredHandlerLocatePtr: Leaving     Status 0x%x\n", Status));
    return(Status);

}



//+--------------------------------------------------------------------
//
//  Function:   CredHandlerRelease
//
//  Synopsis:   Releases the Credential by decreasing reference counter
//    if Credential reference count drops to zero, Credential is deleted
//
//  Arguments:  pCredential - pointer to credential to de-reference
//
//  Returns: NTSTATUS
//
//  Notes: Called by ASC. Since multiple threads can have a credential
//   checked out, simply decrease the reference counter on release.
//
//---------------------------------------------------------------------
NTSTATUS
CredHandlerRelease(
    PDIGEST_CREDENTIAL pCredential)
{
    NTSTATUS Status = STATUS_SUCCESS;

    LONG lReferences = 0;

    DebugLog((DEB_TRACE_FUNC, "CredHandlerRelease: Entering for  Credential 0x%0x\n", pCredential));

    lReferences = InterlockedDecrement(&pCredential->lReferences);

    DebugLog((DEB_TRACE, "CredHandlerRelease: ReferenceCount %ld\n", lReferences));

    ASSERT( lReferences >= 0 );

    //
    // If the count has dropped to zero, then free all alloced stuff
    // Care must be taken since Cred is still in linked list - need to grab critsec
    // and then test again if zero since another thread might have taken a ref to cred
    //

    if (lReferences == 0)
    {
        RtlEnterCriticalSection( &l_CredentialCritSect );

        // Check to make sure no one took a reference since InterlockDecrement
        if (pCredential->lReferences)
        {
            DebugLog((DEB_TRACE, "CredHandlerRelease: Another thread took a reference. No action taken\n"));
        }
        else
        {
            // Safe to remove from list and delete
            // Check if added into linked list
            if (!pCredential->Unlinked)
            {
                RemoveEntryList( &pCredential->Next );
                DebugLog((DEB_TRACE, "CredHandlerRelease: Unlinked Credential 0x%x\n", pCredential));
            }

            DebugLog((DEB_TRACE, "CredHandlerRelease: Deleting Credential 0x%x\n", pCredential));
            Status = CredentialFree(pCredential);
        }

        RtlLeaveCriticalSection( &l_CredentialCritSect );
    }

    DebugLog((DEB_TRACE_FUNC, "LogSessHandlerRelease: Leaving  Status 0x%x\n", Status));

    return(Status);
}


// Helper functions for processing fields within the credentials



//+--------------------------------------------------------------------
//
//  Function:   CredHandlerPasswdSet
//
//  Synopsis:   Set the unicode string password in the credential
//
//  Arguments:  pCredential - pointer to credential to use
//              pustrPasswd - pointer to new password
//
//  Returns: NTSTATUS
//
//  Notes:  might want to use record locking in the future instead
//      of an update flag on credentials
//
//---------------------------------------------------------------------
NTSTATUS
CredHandlerPasswdSet(
    IN OUT PDIGEST_CREDENTIAL pCredential,
    IN PUNICODE_STRING pustrPasswd)
{
    NTSTATUS Status = STATUS_SUCCESS;

           // Protect writing the info into the credential
    RtlEnterCriticalSection( &l_CredentialCritSect );
    if (pCredential->ustrPassword.Buffer)
    {
        UnicodeStringFree(&(pCredential->ustrPassword));
    }
    Status = UnicodeStringDuplicatePassword(&(pCredential->ustrPassword),pustrPasswd);
    RtlLeaveCriticalSection( &l_CredentialCritSect );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "CredHandlerPasswdSet: Error in setting Credential password, status 0x%0x\n", Status ));
    }

    return(Status);
}



//+--------------------------------------------------------------------
//
//  Function:   CredHandlerPasswdGet
//
//  Synopsis:   Get the unicode string password in the credential
//              Locking is only necessary for the logon creds and not the session creds
//              but it is just as well to keep it unifom
//
//  Arguments:  pCredential - pointer to credential to use
//              pustrPasswd - pointer to destination copy of password
//
//  Returns: NTSTATUS
//
//  Notes:
//
//---------------------------------------------------------------------
NTSTATUS
CredHandlerPasswdGet(
    IN PDIGEST_CREDENTIAL pCredential,
    OUT PUNICODE_STRING pustrPasswd)
{
    NTSTATUS Status = STATUS_SUCCESS;

    // Protect reading/writing the credential password
    RtlEnterCriticalSection( &l_CredentialCritSect );
    if (pustrPasswd->Buffer)
    {
        UnicodeStringFree(pustrPasswd);
    }
    Status = UnicodeStringDuplicatePassword(pustrPasswd, &(pCredential->ustrPassword));
    RtlLeaveCriticalSection( &l_CredentialCritSect );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "CredHandlerPasswdSet: Error in setting Credential password, status 0x%0x\n", Status ));
    }

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\common\common.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        common.cxx
//
// Contents:    Shared SSPI code
//
//
// History:     11-March-2000   Created         Todds
//
//------------------------------------------------------------------------






//+-------------------------------------------------------------------------
//
//  Function:   SspAllocate
//
//  Synopsis:   Copies a string from the client and if necessary converts
//              from ansi to unicode
//
//  Effects:    allocates output with either KerbAllocate (unicode)
//              or RtlAnsiStringToUnicodeString
//
//  Arguments:  StringPointer - address of string in client process
//              StringLength - Lenght (in characters) of string
//              AnsiString - if TRUE, string is ansi
//              LocalString - receives allocated string
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

PVOID
SspAllocate(
   IN ULONG BufferSize
   )
{

   PVOID pBuffer = NULL;
   if (*pSspState == SspLsaMode)
   {
       pBuffer = LsaFunctions->AllocateLsaHeap(BufferSize);
       if (pBuffer != NULL)
       {
           RtlZeroMemory(Buffer, BufferSize);
       }
   }
   else
   {
       ASSERT((*pSspState) == SspUserMode);
       pBuffer = LocalAlloc(LPTR, BufferSize);
   }       
           
   return pBuffer;
}                       

//+-------------------------------------------------------------------------
//
//  Function:   SspFree
//
//  Synopsis:   Copies a string from the client and if necessary converts
//              from ansi to unicode
//
//  Effects:    allocates output with either KerbAllocate (unicode)
//              or RtlAnsiStringToUnicodeString
//
//  Arguments:  StringPointer - address of string in client process
//              StringLength - Lenght (in characters) of string
//              AnsiString - if TRUE, string is ansi
//              LocalString - receives allocated string
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
SspFree(
   IN PVOID pBuffer
   )
{
  
  if (ARGUMENT_PRESENT(Buffer))
  {
      if ((*pSspState) == SspLsaMode)
      {   
          LsaFunctions->FreeLsaHeap(Buffer);
      }
      else
      {   
          ASSERT((*pSspState) == SspUserMode);
          LocalFree(Buffer);
      }
  }
          
}
 
//+-------------------------------------------------------------------------
//
//  Function:   SspCopyClientString
//
//  Synopsis:   Copies a string from the client and if necessary converts
//              from ansi to unicode
//
//  Effects:    allocates output with SspAllocate, free w/ SspFree
//
//  Arguments:  StringPointer - address of string in client process
//              StringLength - Lenght (in characters) of string
//              UnicodeString - if TRUE, string is ansi
//              MaxLength - Maximum length of string (useful for pwds)
//              LocalString - receives allocated string
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS 
SspCopyClientString(
   IN PVOID StringPointer,
   IN ULONG StringLength,
   IN BOOLEAN UnicodeString,
   OUT PUNICODE_STRING LocalString,
   IN ULONG MaxLength = 0xFFFF
   )
{

   NTSTATUS Status = STATUS_SUCCESS;
   STRING TempString = {0};
   ULONG SourceSize = 0;
   ULONG CharacterSize = (DoUnicode ? sizeof(WCHAR) : sizeof(CHAR));

   // init outputs
   LocalString->Length = LocalString->MaximumLength = 0;
   LocalString->Buffer = NULL;

   if (NULL != StringPointer)
   {
      //    For 0 length strings, allocate 2 bytes
      if (StringLength == 0) 
      {
          LocalString->Buffer = (LPWSTR) SspAllocate(sizeof(WCHAR));
          if (NULL == LocalString->Buffer)
          {
              DebugLog((DEB_ERROR,"SspCopyClientString allocation failure!\n");
              Status = STATUS_NO_MEMORY;
              goto Cleanup;
          }
          LocalString->MaximumLength = sizeof(WCHAR);
          *LocalString->Buffer = L"\0";
      } 
      else
      {

          //
          // Ensure no overflow against UNICODE_STRING, or desired string
          //
          SourceSize = (StringLength + 1) * CharacterSize;
          if ((StringLength > MaxLength) || (SourceSize > 0xFFFF))
          {
             Status = STATUS_INVALID_PARAMETER;
             DebugLog((DEB_WARN, "SspCopyClientString, String is too big for UNICODE_STRING\n"));
             goto Cleanup;
          }

          TempString.Buffer = (LPSTR) SspAllocate(SourceSize);
          if (NULL == TempString.Buffer)
          {
             DebugLog((DEB_ERROR,"SspCopyClientString allocation failure!\n");
             Status = STATUS_NO_MEMORY;
             goto Cleanup;
          }
            
          TempString.Length = (USHORT) (SourceSize - CharacterSize);
          TempString.MaximumLength = (USHORT) SourceSize;

          Status = LsaFunctions->CopyFromClientBuffer(
                        NULL,
                        SourceSize - CharacterSize,
                        TempString.Buffer,
                        StringPointer
                        );

          if (!NT_SUCCESS(Status))
          {
              DebugLog((
                   DEB_ERROR, 
                   "SspCopyClientString:LsaFn->CopyFromClientBuffer Failed - 0x%x\n",
                   Status));
              goto Cleanup; 
          }
        
          // We've put info into a STRING structure.  Now do
          // translation to UNICODE_STRING.
          if (UnicodeString)
          {
              LocalString->Buffer = (LPWSTR) TemporaryString.Buffer;
              LocalString->Length = TempString.Length;
              LocalString->MaximumLength = TempString.MaximumLength;
          }
          else
          {
             NTSTATUS Status1;
             Status1 = RtlOemStringToUnicodeString(
                        LocalString,
                        &TemporaryString,
                        TRUE
                        );      // allocate destination

             if (!NT_SUCCESS(Status1))
             {
                Status = STATUS_NO_MEMORY;
                DebugLog((
                     DEB_ERROR,
                     "SspCopyClientString, Error from RtlOemStringToUnicodeString is 0x%lx\n",
                     Status
                     ));
                goto Cleanup;
             }                     
          }                        
      }
   }

   
Cleanup:
    
   if (TempString.Buffer != NULL)
   {
        //
        // Free this if we failed and were doing unicode or if we weren't
        // doing unicode
        //

        if ((UnicodeString && !NT_SUCCESS(Status)) || !UnicodeString)
        {
            NtLmFree(TemporaryString.Buffer);
        }
   }

   return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   SspAllocate
//
//  Synopsis:   Copies a string from the client and if necessary converts
//              from ansi to unicode
//
//  Effects:    allocates output with either KerbAllocate (unicode)
//              or RtlAnsiStringToUnicodeString
//
//  Arguments:  StringPointer - address of string in client process
//              StringLength - Lenght (in characters) of string
//              AnsiString - if TRUE, string is ansi
//              LocalString - receives allocated string
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
SspCopyAuthorizationData(IN PVOID AuthorizationData,
                         IN OUT PBOOLEAN NullSession)
{

   PSEC_WINNT_AUTH_IDENTITY_EXW pAuthIdentityEx = NULL;
   BOOLEAN                      UnicodeString = TRUE;

   // Init out parameters
   *NullSession = FALSE;


   if (NULL == AuthorizationData)
   {
      return STATUS_SUCCESS;
   }

   pAuthIdentity = (PSEC_WINNT_AUTH_IDENTITY_EXW) 
                  SspAllocate(sizeof(SEC_WINNT_AUTH_IDENTITY_EXW));

   if (NULL != pAuthIdentity)
   {
      Status = LsaFunctions->CopyFromClientBuffer(
                           NULL,
                           sizeof(SEC_WINNT_AUTH_IDENTITY),
                           pAuthIdentityEx,
                           AuthorizationData
                           );
   
      if (!NT_SUCCESS(Status))
      {
         DebugLog((DEB_ERROR,"Fail: LsaFunctions->CopyFromClientBuffer is 0x%lx\n", Status));
         goto Cleanup;                                                                     
      }

   } else {        

      Status = STATUS_NO_MEMORY;
      DebugLog((DEB_ERROR, "Fail: Alloc in SspCopyAuthData\n");
      goto Cleanup;
   }

   //
   // Do we have an EX version?
   //
   if (pAuthIdentityEx->Version == SEC_WINNT_AUTH_IDENTITY_VERSION)
   {
      Status = LsaFunctions->CopyFromClientBuffer(
                                 NULL,
                                 sizeof(SEC_WINNT_AUTH_IDENTITY_EXW),
                                 pAuthIdentityEx,
                                 AuthorizationData
                                 );

      if (!NT_SUCCESS(Status))
      {
         DebugLog((DEB_ERROR,"Fail: Error from LsaFunctions->CopyFromClientBuffer 0x%lx\n", Status));
         goto Cleanup;
      }
      pAuthIdentity = (PSEC_WINNT_AUTH_IDENTITY) &pAuthIdentityEx->User;
      CredSize = pAuthIdentityEx->Length;
      Offset = FIELD_OFFSET(SEC_WINNT_AUTH_IDENTITY_EXW, User);
   }
   else
   {
      pAuthIdentity = (PSEC_WINNT_AUTH_IDENTITY_W) pAuthIdentityEx;
      CredSize = sizeof(SEC_WINNT_AUTH_IDENTITY_W);
   }

   if ((pAuthIdentity->Flags & SEC_WINNT_AUTH_IDENTITY_ANSI) != 0)
   {
      DoUnicode = FALSE;
      //
      // Turn off the marshalled flag because we don't support marshalling
      // with ansi.
      //

      pAuthIdentity->Flags &= ~SEC_WINNT_AUTH_IDENTITY_MARSHALLED;
   }
   else if ((pAuthIdentity->Flags & SEC_WINNT_AUTH_IDENTITY_UNICODE) == 0)
   {
      Status = SEC_E_INVALID_TOKEN;
      SspPrint((SSP_CRITICAL,"SpAcquireCredentialsHandle, Error from pAuthIdentity->Flags is 0x%lx\n", pAuthIdentity->Flags));
      goto Cleanup;
   }

   //
   // For NTLM, we've got to verify that this is indeed a NULL session
   //
   if ((pAuthIdentity->UserLength == 0) &&
       (pAuthIdentity->DomainLength == 0) &&
       (pAuthIdentity->PasswordLength == 0) &&
       (pAuthIdentity->User != NULL) &&
       (pAuthIdentity->Domain != NULL) &&
       (pAuthIdentity->Password != NULL))
   {
       *NullSession = TRUE;
   }

   //
   // Copy over marshalled data
   //
   if((pAuthIdentity->Flags & SEC_WINNT_AUTH_IDENTITY_MARSHALLED) != 0 ) 
   {
      ULONG TmpCredentialSize;
      ULONG_PTR EndOfCreds;
      ULONG_PTR TmpUser;
      ULONG_PTR TmpDomain;
      ULONG_PTR TmpPassword;

      if( pAuthIdentity->UserLength > UNLEN ||
          pAuthIdentity->PasswordLength > PWLEN ||
          pAuthIdentity->DomainLength > DNS_MAX_NAME_LENGTH ) {

         SspPrint((SSP_CRITICAL,"Supplied credentials illegal length.\n"));
         Status = STATUS_INVALID_PARAMETER;
         goto Cleanup;
      }

      //
      // The callers can set the length of field to n chars, but they
      // will really occupy n+1 chars (null-terminator).
      //

      TmpCredentialSize = CredSize +
         (  pAuthIdentity->UserLength +
            pAuthIdentity->DomainLength +
            pAuthIdentity->PasswordLength +
            (((pAuthIdentity->User != NULL) ? 1 : 0) +
             ((pAuthIdentity->Domain != NULL) ? 1 : 0) +
             ((pAuthIdentity->Password != NULL) ? 1 : 0)) ) * sizeof(WCHAR);

      EndOfCreds = (ULONG_PTR) AuthorizationData + TmpCredentialSize;

      //
      // Verify that all the offsets are valid and no overflow will happen
      //

      TmpUser = (ULONG_PTR) pAuthIdentity->User;

      if ((TmpUser != NULL) &&
          ( (TmpUser < (ULONG_PTR) AuthorizationData) ||
            (TmpUser > EndOfCreds) ||
            ((TmpUser + (pAuthIdentity->UserLength) * sizeof(WCHAR)) > EndOfCreds ) ||
            ((TmpUser + (pAuthIdentity->UserLength * sizeof(WCHAR))) < TmpUser)))
         {
         SspPrint((SSP_CRITICAL,"Username in supplied credentials has invalid pointer or length.\n"));
         Status = STATUS_INVALID_PARAMETER;
         goto Cleanup;
      }

      TmpDomain = (ULONG_PTR) pAuthIdentity->Domain;

      if ((TmpDomain != NULL) &&
          ( (TmpDomain < (ULONG_PTR) AuthorizationData) ||
            (TmpDomain > EndOfCreds) ||
            ((TmpDomain + (pAuthIdentity->DomainLength) * sizeof(WCHAR)) > EndOfCreds ) ||
            ((TmpDomain + (pAuthIdentity->DomainLength * sizeof(WCHAR))) < TmpDomain)))
         {
         SspPrint((SSP_CRITICAL,"Domainname in supplied credentials has invalid pointer or length.\n"));
         Status = STATUS_INVALID_PARAMETER;
         goto Cleanup;
      }

      TmpPassword = (ULONG_PTR) pAuthIdentity->Password;

      if ((TmpPassword != NULL) &&
          ( (TmpPassword < (ULONG_PTR) AuthorizationData) ||
            (TmpPassword > EndOfCreds) ||
            ((TmpPassword + (pAuthIdentity->PasswordLength) * sizeof(WCHAR)) > EndOfCreds ) ||
            ((TmpPassword + (pAuthIdentity->PasswordLength * sizeof(WCHAR))) < TmpPassword)))
         {
         SspPrint((SSP_CRITICAL,"Password in supplied credentials has invalid pointer or length.\n"));
         Status = STATUS_INVALID_PARAMETER;
         goto Cleanup;
      }

      //
      // Allocate a chunk of memory for the credentials
      //

      TmpCredentials = (PSEC_WINNT_AUTH_IDENTITY_W) NtLmAllocate(TmpCredentialSize - Offset);
      if (TmpCredentials == NULL)
         {
         Status = STATUS_INSUFFICIENT_RESOURCES;
         goto Cleanup;
      }

      //
      // Copy the credentials from the client
      //

      Status = LsaFunctions->CopyFromClientBuffer(
         NULL,
         TmpCredentialSize - Offset,
         TmpCredentials,
         (PUCHAR) AuthorizationData + Offset
         );
      if (!NT_SUCCESS(Status))
         {
         SspPrint((SSP_CRITICAL,"Failed to copy whole auth identity\n"));
         goto Cleanup;
      }

      //
      // Now convert all the offsets to pointers.
      //

      if (TmpCredentials->User != NULL)
         {
         USHORT cbUser;

         TmpCredentials->User = (LPWSTR) RtlOffsetToPointer(
            TmpCredentials->User,
            (PUCHAR) TmpCredentials - (PUCHAR) AuthorizationData - Offset
            );

         ASSERT( (TmpCredentials->UserLength*sizeof(WCHAR)) <= 0xFFFF );

         cbUser = (USHORT)(TmpCredentials->UserLength * sizeof(WCHAR));
         UserName.Buffer = (PWSTR)NtLmAllocate( cbUser );

         if (UserName.Buffer == NULL ) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
         }

         CopyMemory( UserName.Buffer, TmpCredentials->User, cbUser );
         UserName.Length = cbUser;
         UserName.MaximumLength = cbUser;
      }

      if (TmpCredentials->Domain != NULL)
         {
         USHORT cbDomain;

         TmpCredentials->Domain = (LPWSTR) RtlOffsetToPointer(
            TmpCredentials->Domain,
            (PUCHAR) TmpCredentials - (PUCHAR) AuthorizationData - Offset
            );

         ASSERT( (TmpCredentials->DomainLength*sizeof(WCHAR)) <= 0xFFFF );
         cbDomain = (USHORT)(TmpCredentials->DomainLength * sizeof(WCHAR));
         DomainName.Buffer = (PWSTR)NtLmAllocate( cbDomain );

         if (DomainName.Buffer == NULL ) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
         }

         CopyMemory( DomainName.Buffer, TmpCredentials->Domain, cbDomain );
         DomainName.Length = cbDomain;
         DomainName.MaximumLength = cbDomain;
      }

      if (TmpCredentials->Password != NULL)
         {
         USHORT cbPassword;

         TmpCredentials->Password = (LPWSTR) RtlOffsetToPointer(
            TmpCredentials->Password,
            (PUCHAR) TmpCredentials - (PUCHAR) AuthorizationData - Offset
            );


         ASSERT( (TmpCredentials->PasswordLength*sizeof(WCHAR)) <= 0xFFFF );
         cbPassword = (USHORT)(TmpCredentials->PasswordLength * sizeof(WCHAR));
         Password.Buffer = (PWSTR)NtLmAllocate( cbPassword );

         if (Password.Buffer == NULL ) {
            ZeroMemory( TmpCredentials->Password, cbPassword );
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
         }

         CopyMemory( Password.Buffer, TmpCredentials->Password, cbPassword );
         Password.Length = cbPassword;
         Password.MaximumLength = cbPassword;

         ZeroMemory( TmpCredentials->Password, cbPassword );
      }


   } 
   //
   // Data was *not* marshalled, copy strings individually
   //
   else 
   {                        
      if (pAuthIdentity->Password != NULL)
      {
         Status = SspCopyClientString(
                        pAuthIdentity->Password,
                        pAuthIdentity->PasswordLength,
                        UnicodeString,
                        &Password
                        );
         if (!NT_SUCCESS(Status))
         {
            DebugLog((DEB_ERROR,"SpAcquireCredentialsHandle, Error from CopyClientString is 0x%lx\n", Status));
            goto Cleanup;
         }

      }

      if (pAuthIdentity->User != NULL)
      {
         Status = SspCopyClientString(
                        pAuthIdentity->User,
                        pAuthIdentity->UserLength,
                        UnicodeString,
                        &UserName
                        );
         if (!NT_SUCCESS(Status))
         {
            DebugLog((DEB_ERROR, "SpAcquireCredentialsHandle, Error from CopyClientString is 0x%lx\n", Status));
            goto Cleanup;
         }

      }

      if (pAuthIdentity->Domain != NULL)
      {
         Status = SspCopyClientString(
                        pAuthIdentity->Domain,
                        pAuthIdentity->DomainLength,
                        UnicodeString,
                        &DomainName
                        );
         if (!NT_SUCCESS(Status))
         {
            DebugLog((DEB_ERROR, "SpAcquireCredentialsHandle, Error from CopyClientString is 0x%lx\n", Status));
            goto Cleanup;
         }

         //
         // Make sure that the domain name length is not greater
         // than the allowed dns domain name
         //
         if (DomainName.Length > DNS_MAX_NAME_LENGTH * sizeof(WCHAR))
         {
            DebugLog((DEB_ERROR, "SpAcquireCredentialsHandle: Invalid supplied domain name %wZ\n",
                      &DomainName ));
            Status = SEC_E_UNKNOWN_CREDENTIALS;
            goto Cleanup;
         }

      }
   }



































}




















}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\digest\cred.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        cred.h
//
// Contents:    declarations, constants for credential manager
//
//
// History:     KDamour  15Mar00   Created
//
//------------------------------------------------------------------------

#ifndef NTDIGEST_CRED_H
#define NTDIGEST_CRED_H      

#define SSP_TOKEN_ACCESS (READ_CONTROL              |\
                          WRITE_DAC                 |\
                          TOKEN_DUPLICATE           |\
                          TOKEN_IMPERSONATE         |\
                          TOKEN_QUERY               |\
                          TOKEN_QUERY_SOURCE        |\
                          TOKEN_ADJUST_PRIVILEGES   |\
                          TOKEN_ADJUST_GROUPS       |\
                          TOKEN_ADJUST_DEFAULT)

// Values for UseFlags
#define DIGEST_CRED_INBOUND       SECPKG_CRED_INBOUND
#define DIGEST_CRED_OUTBOUND      SECPKG_CRED_OUTBOUND
#define DIGEST_CRED_MATCH_FLAGS    (DIGEST_CRED_INBOUND | DIGEST_CRED_OUTBOUND)
#define DIGEST_CRED_NULLSESSION  SECPKG_CRED_RESERVED


//  Supplimental Credential format (provide a specified username, realm, password)
//  to

// Initializes the credential manager package
NTSTATUS CredHandlerInit(VOID);

// Inserts a credential into the linked list
NTSTATUS CredHandlerInsertCred(IN PDIGEST_CREDENTIAL  pDigestCred);

// Initialize the Credential Structure
NTSTATUS CredentialInit(IN PDIGEST_CREDENTIAL pDigestCred);

// Initialize the Credential Structure
NTSTATUS CredentialFree(IN PDIGEST_CREDENTIAL pDigestCred);

//    This routine checks to see if the Credential Handle is from a currently
//    active client, and references the Credential if it is valid.
//    No need to specify UseFlags since we have a reference to the Credential
NTSTATUS CredHandlerHandleToPtr(
       IN ULONG_PTR CredentialHandle,
       IN BOOLEAN DereferenceCredential,
       OUT PDIGEST_CREDENTIAL * UserCredential);

// Locate a Credential based on the LogonId & ProcessID
NTSTATUS CredHandlerLocatePtr(
       IN PLUID pLogonId,
       IN ULONG   CredentialUseFlags,
       OUT PDIGEST_CREDENTIAL * UserCredential);

//  Releases the Credential by decreasing reference counter
NTSTATUS CredHandlerRelease(PDIGEST_CREDENTIAL pCredential);

// Set the unicode string password in the credential
NTSTATUS CredHandlerPasswdSet(
    IN OUT PDIGEST_CREDENTIAL pCredential,
    IN PUNICODE_STRING pustrPasswd);

// Get the unicode string password in the credential
NTSTATUS CredHandlerPasswdGet(
    IN PDIGEST_CREDENTIAL pCredential,
    OUT PUNICODE_STRING pustrPasswd);

NTSTATUS SspGetToken (OUT PHANDLE ReturnedTokenHandle);

SECURITY_STATUS SspDuplicateToken(
    IN HANDLE OriginalToken,
    IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    OUT PHANDLE DuplicatedToken);

// Print out the credential information
NTSTATUS CredPrint(PDIGEST_CREDENTIAL pCredential);

// Extract the authz information from supplied buffer
NTSTATUS CredAuthzData(
    IN PVOID pAuthorizationData,
    IN PSECPKG_CALL_INFO pCallInfo,
    IN OUT PULONG NewCredentialUseFlags,
    IN OUT PUNICODE_STRING pUserName,
    IN OUT PUNICODE_STRING pDomainName,
    IN OUT PUNICODE_STRING pPassword);

#endif // NTDIGEST_CRED_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\digest\auth.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        auth.cxx
//
// Contents:    Digest Access creation & validation
//              Main entry points into this dll:
//                DigestIsValid
//                NonceValidate
//                NonceInitialize
//
// History:     KDamour 16Mar00   Created
//
//------------------------------------------------------------------------

#include "global.h"
#include <lmcons.h>     // For Max Passwd Length PWLEN
#include <stdio.h>



//+--------------------------------------------------------------------
//
//  Function:   DigestCalculation
//
//  Synopsis:   Perform Digest Access Calculation
//
//  Effects:
//
//  Arguments:  pDigest - pointer to digest access data fields
//
//  Returns:  STATUS_SUCCESS for normal completion
//
//  Notes:  This routine can be used for both calculating and verifying
//    the Digest Access nonce value.  The Switching parameter is
//    pDigest->type. Calling routine must provide the space for any
//    returned hashed values (like pReqDigest).
//
//   For clients, the cleartext password must be avilable to generate the
//   session key.
//
//   After the initial ISC/ASC completes, a copy of the sessionkey is kept in
//  in the context and copied over to the Digest structure.  The username, realm
//  and password are not utilized from the UserCreds since we already have a
//  sessionkey.
//
//---------------------------------------------------------------------
NTSTATUS NTAPI
DigestCalculation(
                 IN PDIGEST_PARAMETER pDigest,
                 IN PUSER_CREDENTIALS pUserCreds
                 )
{
    NTSTATUS Status = E_FAIL;
    DebugLog((DEB_TRACE_FUNC, "DigestCalculation: Entering\n"));

    Status = DigestIsValid(pDigest);
    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }

    switch (pDigest->typeDigest)
    {
    case DIGEST_CLIENT:      // Called by clients to generate Response
    case SASL_CLIENT:      // Called by clients to generate Response
        {
            Status = DigestCalcChalRsp(pDigest, pUserCreds, FALSE);
            break;
        }
    case DIGEST_SERVER:
    case SASL_SERVER:
        {
            Status = DigestCalcChalRsp(pDigest, pUserCreds, TRUE);
            break;
        }
    default:
        {     // No Digest calculations for that yet
            Status = SEC_E_UNSUPPORTED_FUNCTION;
            DebugLog((DEB_ERROR, "NTDigest: Unsupported typeDigest = %d\n", pDigest->typeDigest));
            break;
        }
    }

    DebugLog((DEB_TRACE_FUNC, "DigestCalculation: Leaving     Status 0x%x\n", Status));

    return(Status);
}



//+--------------------------------------------------------------------
//
//  Function:   DigestIsValid
//
//  Synopsis:   Simple checks for enough data for Digest calculation
//
//  Effects:
//
//  Arguments:  pDigest - pointer to digest access data fields
//
//  Returns:  STATUS_SUCCESS for normal completion
//
//  Notes:
//
//---------------------------------------------------------------------
NTSTATUS NTAPI
DigestIsValid(
          IN PDIGEST_PARAMETER pDigest
          )
{
    NTSTATUS Status = STATUS_SUCCESS;    
    int i = 0;

    DebugLog((DEB_TRACE_FUNC, "DigestIsValid: Entering\n"));

    if (!pDigest)
    {     // Fail on no Digest Parameters passed in
        
        DebugLog((DEB_ERROR, "DigestIsValid: no digest pointer arg\n"));
        Status = STATUS_INVALID_PARAMETER;
        goto CleanUp;
    }

    // Check for proper struct format for strings
    for (i=0; i< MD5_AUTH_LAST;i++)
    {
        if (!NT_SUCCESS(StringVerify(&(pDigest->refstrParam[i]))))
        {
            DebugLog((DEB_ERROR, "DigestIsValid: Digest String struct bad format\n"));
            Status = STATUS_INVALID_PARAMETER;
            goto CleanUp;
        }
    }

    if (!NT_SUCCESS(StringVerify(&(pDigest->strSessionKey))))
    {
        DebugLog((DEB_ERROR, "DigestIsValid: Digest String struct bad format in SessionKey\n"));
        Status = STATUS_INVALID_PARAMETER;
        goto CleanUp;
    }

    // Do some required checks for field-value data
    // Required Username-value, Realm-value, nonce, Method
    //          URI
    if ((!pDigest->refstrParam[MD5_AUTH_NONCE].Length) ||
        (!pDigest->refstrParam[MD5_AUTH_METHOD].Length) ||
        (!pDigest->refstrParam[MD5_AUTH_URI].Length)
       )
    {
        // Failed on a require field-value
        DebugLog((DEB_ERROR, "DigestIsValid: required digest field missing\n"));
        Status = STATUS_INVALID_PARAMETER;
        goto CleanUp;
    }


CleanUp:

    DebugLog((DEB_TRACE_FUNC, "DigestIsValid: Leaving     Status 0x%x\n", Status));
    return(Status);
}



//+--------------------------------------------------------------------
//
//  Function:   DigestFree
//
//  Synopsis:   Clear out the digest & free memory from Digest struct
//
//  Effects:
//
//  Arguments:  pDigest - pointer to digest access data fields
//
//  Returns:  STATUS_SUCCESS for normal completion
//
//  Notes:  This should be called when done with a DIGEST_PARAMTER object
//
//
//---------------------------------------------------------------------
NTSTATUS NTAPI
DigestFree(
          IN PDIGEST_PARAMETER pDigest
          )
{
    NTSTATUS Status = STATUS_SUCCESS;
    int i = 0;

    DebugLog((DEB_TRACE_FUNC, "Entering DigestFree\n"));

    if (!pDigest)
    {
        return STATUS_INVALID_PARAMETER;
    }

    StringFree(&pDigest->strSessionKey);

    StringFree(&pDigest->strResponse);
    StringFree(&pDigest->strUsernameEncoded);
    StringFree(&pDigest->strRealmEncoded);

    UnicodeStringFree(&pDigest->ustrRealm);

    UnicodeStringFree(&pDigest->ustrUsername);

    UnicodeStringFree(&pDigest->ustrUri);

    UnicodeStringFree(&pDigest->ustrCrackedAccountName);
    UnicodeStringFree(&pDigest->ustrCrackedDomain);

    // Release any directive storage
    // This was used to remove backslash encoding from directives
    for (i = 0; i < MD5_AUTH_LAST; i++)
    {
        StringFree(&(pDigest->strDirective[i]));
    }

    DebugLog((DEB_TRACE_FUNC, "Leaving DigestFree\n"));

    return(Status);
}


//+--------------------------------------------------------------------
//
//  Function:   DigestDecodeDirectiveStrings
//
//  Synopsis:   Processed parsed digest auth message and fill in string values
//
//  Effects:
//
//  Arguments:  pDigest - pointer to digest access data fields
//
//  Returns:  STATUS_SUCCESS for normal completion
//
//  Notes:  
//
//---------------------------------------------------------------------
NTSTATUS NTAPI
DigestDecodeDirectiveStrings(
          IN PDIGEST_PARAMETER pDigest
          )
{
    NTSTATUS Status = STATUS_SUCCESS;

    DebugLog((DEB_TRACE_FUNC, "DigestDecodeDirectiveStrings Entering\n"));

    if (!pDigest)
    {
        return STATUS_INVALID_PARAMETER;
    }

    // Decode URI, Username, Realm
    // Decode the username and realm directives
    if (pDigest->typeCharset == UTF_8)
    {
        DebugLog((DEB_TRACE, "DigestDecodeDirectiveStrings:      UTF-8 Character set decoding\n"));

        Status = DecodeUnicodeString(&(pDigest->refstrParam[MD5_AUTH_USERNAME]),
                                     CP_UTF8,
                                     &pDigest->ustrUsername);
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "DigestDecodeDirectiveStrings: DecodeUnicodeString    error 0x%x\n", Status));
            goto CleanUp;
        }


        Status = DecodeUnicodeString(&(pDigest->refstrParam[MD5_AUTH_REALM]),
                                     CP_UTF8,
                                     &pDige