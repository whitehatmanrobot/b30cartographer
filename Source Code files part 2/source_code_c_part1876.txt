    inpfh = (int)OpenFile( pSrcname, &OpenBuf, OF_READWRITE | OF_SHARE_EXCLUSIVE);
    GlobalUnlock(pUpdate->hFileName);
    if (inpfh == -1) {
		GlobalUnlock(hUpdate);
    	return ERROR_OPEN_FAILED;
    }

    /* read the old format EXE header */
    rc = _lread(inpfh, (char*)&oldexe, sizeof(oldexe));
    if (rc != sizeof(oldexe)) {
		_lclose(inpfh);
		GlobalUnlock(hUpdate);
		return ERROR_READ_FAULT;
    }

    /* make sure its really an EXE file */
    if (oldexe.e_magic != IMAGE_DOS_SIGNATURE) {
		_lclose(inpfh);
		GlobalUnlock(hUpdate);
		return ERROR_INVALID_EXE_SIGNATURE;
    }

    /* make sure theres a new EXE header floating around somewhere */
    if (!(onewexe = oldexe.e_lfanew)) {
		_lclose(inpfh);
		GlobalUnlock(hUpdate);
		return ERROR_BAD_EXE_FORMAT;
    }
    
    //outfh = (INT)CreateFileW(pDstname, GENERIC_READ|GENERIC_WRITE,
    //      0 /*exclusive access*/, NULL /* security attr */,
    //      CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    
    outfh = (int)OpenFile( pDstname, &OpenBuf, OF_SHARE_EXCLUSIVE | OF_READWRITE );
    if (outfh != -1) {
    	rc = PEWriteResFile(inpfh, outfh, onewexe, pUpdate);
    	_lclose(outfh);
    }
    _lclose(inpfh);
    GlobalUnlock(hUpdate);
    return rc;
}

//v-guanx rewrite this function from C++ to Windows API
/*
static UINT CopyFile( char * pszfilein, char * pszfileout )
{
    CFile filein;
    CFile fileout;
    
    if (!filein.Open(pszfilein, CFile::modeRead | CFile::typeBinary))
	return ERROR_FILE_OPEN;
    
    if (!fileout.Open(pszfileout, CFile::modeWrite | CFile::modeCreate | CFile::typeBinary))
	return ERROR_FILE_CREATE;
    
    LONG lLeft = filein.GetLength();
    WORD wRead = 0;
    DWORD dwOffset = 0;
    BYTE far * pBuf = (BYTE far *) new BYTE[32739];
    
    if(!pBuf)
	return ERROR_NEW_FAILED;
    
    while(lLeft>0){
	wRead =(WORD) (32738ul < lLeft ? 32738: lLeft);
	if (wRead!= filein.Read( pBuf, wRead))
	    return ERROR_FILE_READ;   
	fileout.Write( pBuf, wRead );
	lLeft -= wRead;
	dwOffset += wRead;
    }     
    
    delete []pBuf;     
}
*/

BOOL
EnumTypesFunc(
    HANDLE hModule,
    LPTSTR lpType,
    LONG lParam
    )
{

    EnumResourceNames(hModule, lpType, (ENUMRESNAMEPROC)EnumNamesFunc, lParam);

    return TRUE;
}



BOOL
EnumNamesFunc(
    HANDLE hModule,
    LPTSTR lpType,
    LPTSTR lpName,
    LONG lParam
    )
{
    EnumResourceLanguages(hModule, lpType, lpName, (ENUMRESLANGPROC)EnumLangsFunc, lParam);
    return TRUE;
}



BOOL
EnumLangsFunc(
    HANDLE hModule,
    LPTSTR lpType,
    LPTSTR lpName,
    WORD language,
    LONG lParam
    )
{
    HANDLE	hResInfo;
    LONG	fError;
    PSDATA	Type;
    PSDATA	Name;
    ULONG	cb;
    PVOID	lpData;
    HANDLE	hResource;
    PVOID	lpResource;

    hResInfo = FindResourceEx(hModule, lpType, lpName, language);
    if (hResInfo == NULL) {
        return FALSE;
    }
    else {
    	Type = AddStringOrID(lpType, (PUPDATEDATA)lParam);
    	if (Type == NULL) {
    	    ((PUPDATEDATA)lParam)->Status = ERROR_NOT_ENOUGH_MEMORY;
    	    return FALSE;
    	}
    	Name = AddStringOrID(lpName, (PUPDATEDATA)lParam);
    	if (Name == NULL) {
    	    ((PUPDATEDATA)lParam)->Status = ERROR_NOT_ENOUGH_MEMORY;
    	    return FALSE;
    	}

		cb = SizeofResource(hModule, hResInfo);
		if (cb == 0) {
	    	return FALSE;
		}
    	lpData = malloc(cb);
		if (lpData == NULL) {
	    	return FALSE;
		}
    	memset(lpData,0, cb);

		hResource = LoadResource(hModule, hResInfo);
		if (hResource == NULL) {
	    	free(lpData);
	    	return FALSE;
		}

		lpResource = (PVOID)LockResource(hResource);
		if (lpResource == NULL) {
	    	free(lpData);
	    	return FALSE;
		}

		memcpy(lpData, lpResource, cb);
		(VOID)UnlockResource(hResource);
		(VOID)FreeResource(hResource);

    	fError = AddResource(Type, Name, language, (PUPDATEDATA)lParam,
			lpData, cb);
    	if (fError != NO_ERROR) {
    	    ((PUPDATEDATA)lParam)->Status = ERROR_NOT_ENOUGH_MEMORY;
    	    return FALSE;
    	}
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntime\candui.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    CANDUI.C
    
++*/

#include <windows.h>
#include <immdev.h>
#include <imedefs.h>

/**********************************************************************/
/* GetCandWnd                                                         */
/* Return Value :                                                     */
/*      window handle of candidatte                                   */
/**********************************************************************/
HWND PASCAL GetCandWnd(
    HWND hUIWnd)                // UI window
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;
    HWND     hCandWnd;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {          // can not darw candidate window
        return (HWND)NULL;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw candidate window
        return (HWND)NULL;
    }

    hCandWnd = lpUIPrivate->hCandWnd;

    GlobalUnlock(hUIPrivate);
    return (hCandWnd);
}

void PASCAL CalcCandPos(
    HIMC    hIMC,
    HWND    hUIWnd,
    LPPOINT lpptWnd)            // the composition window position
{
    POINT ptNew, ptSTWPos;
    RECT  rcWorkArea;

#if 1 // MultiMonitor support
    rcWorkArea = ImeMonitorWorkAreaFromPoint(*lpptWnd);
#else
    rcWorkArea = rcWorkArea;
#endif

    ptNew.x = lpptWnd->x + lpImeL->xCompWi + UI_MARGIN;
    if (ptNew.x + sImeG.xCandWi > rcWorkArea.right) {
        // exceed screen width
        ptNew.x = lpptWnd->x - sImeG.xCandWi - UI_MARGIN;
    }

    ptNew.y = lpptWnd->y + lpImeL->cyCompBorder - sImeG.cyCandBorder;
    if (ptNew.y + sImeG.yCandHi > rcWorkArea.bottom) {
        // exceed screen high
        ptNew.y = rcWorkArea.bottom - sImeG.yCandHi;
    }

    if(!MBIndex.IMEChara[0].IC_Trace) {
        HWND hCompWnd;

           ImmGetStatusWindowPos(hIMC, (LPPOINT)&ptSTWPos);
        hCompWnd = GetCompWnd(hUIWnd);
        if (hCompWnd) {
            ptNew.x = ptSTWPos.x + sImeG.xStatusWi + lpImeL->xCompWi + 2 * UI_MARGIN;
            if((ptSTWPos.x + sImeG.xStatusWi + sImeG.xCandWi + lpImeL->xCompWi + 2 * UI_MARGIN)>
              rcWorkArea.right) {
              if (ptSTWPos.x >= (sImeG.xCandWi + lpImeL->xCompWi + 2 * UI_MARGIN)) { 
                ptNew.x = ptSTWPos.x - lpImeL->xCompWi - sImeG.xCandWi - 2 * UI_MARGIN;
              } else {
                ptNew.x = ptSTWPos.x + sImeG.xStatusWi + UI_MARGIN;
              }
            }


            ptNew.y = ptSTWPos.y + lpImeL->cyCompBorder - sImeG.cyCandBorder;
            if (ptNew.y + sImeG.yCandHi > rcWorkArea.bottom) {
                ptNew.y = rcWorkArea.bottom - sImeG.yCandHi;
            }
        } else {
            ptNew.x = ptSTWPos.x + sImeG.xStatusWi + UI_MARGIN;
            if(((ptSTWPos.x + sImeG.xStatusWi + sImeG.xCandWi + UI_MARGIN)>=
              rcWorkArea.right)
              && (ptSTWPos.x >= sImeG.xCandWi + UI_MARGIN)) { 
                ptNew.x = ptSTWPos.x - sImeG.xCandWi - UI_MARGIN;
            }

            ptNew.y = ptSTWPos.y + lpImeL->cyCompBorder - sImeG.cyCandBorder;
            if (ptNew.y + sImeG.yCandHi > rcWorkArea.bottom) {
                ptNew.y = rcWorkArea.bottom - sImeG.yCandHi;
            }
        }
    }
    
    lpptWnd->x = ptNew.x;
    lpptWnd->y = ptNew.y;

    return;
}

/**********************************************************************/
/* AdjustCandPos                                                      */
/**********************************************************************/
void AdjustCandPos(
    HIMC    hIMC,
    LPPOINT lpptWnd)            // the composition window position
{
    LPINPUTCONTEXT lpIMC;
    LONG           ptFontHi;
    UINT           uEsc;
    RECT           rcWorkArea;

#if 1 // MultiMonitor support
    rcWorkArea = ImeMonitorWorkAreaFromPoint(*lpptWnd);
#else
    rcWorkArea = sImeG.rcWorkArea;
#endif

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return;
    }

    if (lpIMC->lfFont.A.lfHeight > 0) {
        ptFontHi = lpIMC->lfFont.A.lfHeight;
    } else if (lpIMC->lfFont.A.lfWidth == 0) {
        ptFontHi = lpImeL->yCompHi;
    } else {
        ptFontHi = -lpIMC->lfFont.A.lfHeight;
    }

    if (ptFontHi > lpImeL->yCompHi * 8) {
        ptFontHi = lpImeL->yCompHi * 8;
    }

    if (ptFontHi < sImeG.yChiCharHi) {
        ptFontHi = sImeG.yChiCharHi;
    }

    // -450 to 450 index 0
    // 450 to 1350 index 1
    // 1350 to 2250 index 2
    // 2250 to 3150 index 3
    uEsc = (UINT)((lpIMC->lfFont.A.lfEscapement + 450) / 900 % 4);

    // find the location after IME do an adjustment
    ptFontHi = ptFontHi * ptInputEsc[uEsc].y;

    if(lpptWnd->y + ptFontHi + sImeG.yCandHi <= rcWorkArea.bottom) {
        lpptWnd->y += ptFontHi;
    } else {
        lpptWnd->y -= (ptFontHi + sImeG.yCandHi);
    }

    ImmUnlockIMC(hIMC);
    return;
}

/**********************************************************************/
/* AdjustCandRectBoundry                                              */
/**********************************************************************/
void PASCAL AdjustCandRectBoundry(
    LPINPUTCONTEXT lpIMC,
    LPPOINT        lpptCandWnd)            // the caret position
{
    RECT  rcExclude, rcUIRect, rcInterSect;
    UINT  uEsc;
    RECT  rcWorkArea;

#if 1 // MultiMonitor support
    {
        RECT rcCandWnd;

        *(LPPOINT)&rcCandWnd = *(LPPOINT)lpptCandWnd;

        rcCandWnd.right = rcCandWnd.left + sImeG.xCandWi;
        rcCandWnd.bottom = rcCandWnd.top + sImeG.yCandHi;

        rcWorkArea = ImeMonitorWorkAreaFromRect(&rcCandWnd);
    }
#else
    rcWorkArea = sImeG.rcWorkArea;
#endif


    // be a normal rectangle, not a negative rectangle
    if (lpIMC->cfCandForm[0].rcArea.left > lpIMC->cfCandForm[0].rcArea.right) {
        LONG tmp;

        tmp = lpIMC->cfCandForm[0].rcArea.left;
        lpIMC->cfCandForm[0].rcArea.left = lpIMC->cfCandForm[0].rcArea.right;
        lpIMC->cfCandForm[0].rcArea.right = tmp;
    }

    if (lpIMC->cfCandForm[0].rcArea.top > lpIMC->cfCandForm[0].rcArea.bottom) {
        LONG tmp;

        tmp = lpIMC->cfCandForm[0].rcArea.top;
        lpIMC->cfCandForm[0].rcArea.top = lpIMC->cfCandForm[0].rcArea.bottom;
        lpIMC->cfCandForm[0].rcArea.bottom = tmp;
    }

    // translate from client coordinate to screen coordinate
    rcExclude = lpIMC->cfCandForm[0].rcArea;

    rcExclude.left += lpptCandWnd->x - lpIMC->cfCandForm[0].ptCurrentPos.x;
    rcExclude.right += lpptCandWnd->x - lpIMC->cfCandForm[0].ptCurrentPos.x;

    rcExclude.top += lpptCandWnd->y - lpIMC->cfCandForm[0].ptCurrentPos.y;
    rcExclude.bottom += lpptCandWnd->y - lpIMC->cfCandForm[0].ptCurrentPos.y;

    // if original point is OK, we use it
    *(LPPOINT)&rcUIRect = *lpptCandWnd;

    if (rcUIRect.left < rcWorkArea.left) {
        rcUIRect.left = rcWorkArea.left;
    } else if (rcUIRect.left + sImeG.xCandWi > rcWorkArea.right) {
        rcUIRect.left = rcWorkArea.right - sImeG.xCandWi;
    } else {
    }

    if (rcUIRect.top < rcWorkArea.top) {
        rcUIRect.top = rcWorkArea.top;
    } else if (rcUIRect.top + sImeG.yCandHi > rcWorkArea.bottom) {
        rcUIRect.top = rcWorkArea.bottom - sImeG.yCandHi;
    } else {
    }

    rcUIRect.right = rcUIRect.left + sImeG.xCandWi;
    rcUIRect.bottom = rcUIRect.top + sImeG.yCandHi;

    if (!IntersectRect(&rcInterSect, &rcExclude, &rcUIRect)) {
        *lpptCandWnd = *(LPPOINT)&rcUIRect;
        return;
    }

    uEsc = (UINT)((lpIMC->lfFont.A.lfEscapement + 450) / 900 % 4);

    if (uEsc & 0x0001) {
        // 900 & 2700 we need change x coordinate
        if (ptInputEsc[uEsc].x > 0) {
            rcUIRect.left = rcExclude.right;
        } else {
            rcUIRect.left = rcExclude.left - sImeG.xCandWi;
        }
    } else {
        // 0 & 1800 we do not change x coordinate
        rcUIRect.left = lpptCandWnd->x;
    }

    if (rcUIRect.left < rcWorkArea.left) {
        rcUIRect.left = rcWorkArea.left;
    } else if (rcUIRect.left + sImeG.xCandWi > rcWorkArea.right) {
        rcUIRect.left = rcWorkArea.right - sImeG.xCandWi;
    } else {
    }

    if (uEsc & 0x0001) {
        // 900 & 2700 we do not change y coordinate
        rcUIRect.top = lpptCandWnd->y;
    } else {
        // 0 & 1800 we need change y coordinate
        if (ptInputEsc[uEsc].y > 0) {
            rcUIRect.top = rcExclude.bottom;
        } else {
            rcUIRect.top = rcExclude.top - sImeG.yCandHi;
        }
    }

    if (rcUIRect.top < rcWorkArea.top) {
        rcUIRect.top = rcWorkArea.top;
    } else if (rcUIRect.top + sImeG.yCandHi > rcWorkArea.bottom) {
        rcUIRect.top = rcWorkArea.bottom - sImeG.yCandHi;
    } else {
    }

    rcUIRect.right = rcUIRect.left + sImeG.xCandWi;
    rcUIRect.bottom = rcUIRect.top + sImeG.yCandHi;

    // the candidate window not overlapped with exclude rectangle
    // so we found a position
    if (!IntersectRect(&rcInterSect, &rcExclude, &rcUIRect)) {
        *lpptCandWnd = *(LPPOINT)&rcUIRect;
        return;
    }

    // adjust according to
    *(LPPOINT)&rcUIRect = *lpptCandWnd;

    if (uEsc & 0x0001) {
        // 900 & 2700 we prefer adjust x
        if (ptInputEsc[uEsc].x > 0) {
            rcUIRect.left = rcExclude.right;
        } else {
            rcUIRect.left = rcExclude.left - sImeG.xCandWi;
        }

        if (rcUIRect.left < rcWorkArea.left) {
        } else if (rcUIRect.left + sImeG.xCandWi > rcWorkArea.right) {
        } else {
            if (rcUIRect.top < rcWorkArea.top) {
                rcUIRect.top = rcWorkArea.top;
            } else if (rcUIRect.top + sImeG.yCandHi > rcWorkArea.bottom) {
                rcUIRect.top = rcWorkArea.bottom - sImeG.yCandHi;
            } else {
            }

            *lpptCandWnd = *(LPPOINT)&rcUIRect;
            return;
        }

        // negative try
        if (ptInputEsc[uEsc].x > 0) {
            rcUIRect.left = rcExclude.left - sImeG.xCandWi;
        } else {
            rcUIRect.left = rcExclude.right;
        }

        if (rcUIRect.left < rcWorkArea.left) {
        } else if (rcUIRect.left + sImeG.xCandWi > rcWorkArea.right) {
        } else {
            if (rcUIRect.top < rcWorkArea.top) {
                rcUIRect.top = rcWorkArea.top;
            } else if (rcUIRect.top + sImeG.yCandHi > rcWorkArea.bottom) {
                rcUIRect.top = rcWorkArea.bottom - sImeG.yCandHi;
            } else {
            }

            *lpptCandWnd = *(LPPOINT)&rcUIRect;
            return;
        }

        // negative try failure again, we use positive plus display adjust
        if (ptInputEsc[uEsc].x > 0) {
            rcUIRect.left = rcExclude.right;
        } else {
            rcUIRect.left = rcExclude.left - sImeG.xCandWi;
        }

        if (rcUIRect.left < rcWorkArea.left) {
            rcUIRect.left = rcWorkArea.left;
        } else if (rcUIRect.left + sImeG.xCandWi > rcWorkArea.right) {
            rcUIRect.left = rcWorkArea.right - sImeG.xCandWi;
        } else {
        }

        if (rcUIRect.top < rcWorkArea.top) {
            rcUIRect.top = rcWorkArea.top;
        } else if (rcUIRect.top + sImeG.yCandHi > rcWorkArea.bottom) {
            rcUIRect.top = rcWorkArea.bottom - sImeG.yCandHi;
        } else {
        }

        *lpptCandWnd = *(LPPOINT)&rcUIRect;
    } else {
        // 0 & 1800 we prefer adjust y
        if (ptInputEsc[uEsc].y > 0) {
            rcUIRect.top = rcExclude.bottom;
        } else {
            rcUIRect.top = rcExclude.top - sImeG.yCandHi;
        }

        if (rcUIRect.top < rcWorkArea.top) {
        } else if (rcUIRect.top + sImeG.yCandHi > rcWorkArea.bottom) {
        } else {
            if (rcUIRect.left < rcWorkArea.left) {
                rcUIRect.left = rcWorkArea.left;
            } else if (rcUIRect.left + sImeG.xCandWi > rcWorkArea.right) {
                rcUIRect.left = rcWorkArea.right - sImeG.xCandWi;
            } else {
            }

            *lpptCandWnd = *(LPPOINT)&rcUIRect;
            return;
        }

        // negative try
        if (ptInputEsc[uEsc].y > 0) {
            rcUIRect.top = rcExclude.top - sImeG.yCandHi;
        } else {
            rcUIRect.top = rcExclude.bottom;
        }

        if (rcUIRect.top < rcWorkArea.top) {
        } else if (rcUIRect.top + sImeG.yCandHi > rcWorkArea.right) {
        } else {
            if (rcUIRect.left < rcWorkArea.left) {
                rcUIRect.left = rcWorkArea.left;
            } else if (rcUIRect.left + sImeG.xCandWi > rcWorkArea.right) {
                rcUIRect.left = rcWorkArea.right - sImeG.xCandWi;
            } else {
            }

            *lpptCandWnd = *(LPPOINT)&rcUIRect;
            return;
        }

        // negative try failure again, we use positive plus display adjust
        if (ptInputEsc[uEsc].y > 0) {
            rcUIRect.top = rcExclude.bottom;
        } else {
            rcUIRect.top = rcExclude.top - sImeG.yCandHi;
        }

        if (rcUIRect.left < rcWorkArea.left) {
            rcUIRect.left = rcWorkArea.left;
        } else if (rcUIRect.left + sImeG.xCandWi > rcWorkArea.right) {
            rcUIRect.left = rcWorkArea.right - sImeG.xCandWi;
        } else {
        }

        if (rcUIRect.top < rcWorkArea.top) {
            rcUIRect.top = rcWorkArea.top;
        } else if (rcUIRect.top + sImeG.yCandHi > rcWorkArea.bottom) {
            rcUIRect.top = rcWorkArea.bottom - sImeG.yCandHi;
        } else {
        }

        *lpptCandWnd = *(LPPOINT)&rcUIRect;
    }

    return;
}

/**********************************************************************/
/* AdjustCandBoundry                                                  */
/**********************************************************************/
void PASCAL AdjustCandBoundry(
    LPPOINT lpptCandWnd)            // the position
{
    RECT rcWorkArea;

#if 1 // MultiMonitor support
    {
        RECT rcCandWnd;

        *(LPPOINT)&rcCandWnd = *(LPPOINT)lpptCandWnd;

        rcCandWnd.right = rcCandWnd.left + sImeG.xCandWi;
        rcCandWnd.bottom = rcCandWnd.top + sImeG.yCandHi;

        rcWorkArea = ImeMonitorWorkAreaFromRect(&rcCandWnd);
    }
#else
    rcWorkArea = sImeG.rcWorkArea;
#endif

    if (lpptCandWnd->x < rcWorkArea.left) {
        lpptCandWnd->x = rcWorkArea.left;
    } else if (lpptCandWnd->x + sImeG.xCandWi > rcWorkArea.right) {
        lpptCandWnd->x = rcWorkArea.right - sImeG.xCandWi;
    }

    if (lpptCandWnd->y < rcWorkArea.top) {
        lpptCandWnd->y = rcWorkArea.top;
    } else if (lpptCandWnd->y + sImeG.yCandHi > rcWorkArea.bottom) {
        lpptCandWnd->y = rcWorkArea.bottom - sImeG.yCandHi;
    }

    return;
}

/**********************************************************************/
/* SetCandPosition()                                                  */
/**********************************************************************/
LRESULT PASCAL SetCandPosition(
    HWND hCandWnd)
{
    HWND           hUIWnd;
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    POINT          ptNew;

    hUIWnd = GetWindow(hCandWnd, GW_OWNER);
    if (!hUIWnd) {
        return(1L);
    }

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return (1L);
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return (1L);
    }

    ptNew = lpIMC->cfCandForm[0].ptCurrentPos;

    ClientToScreen((HWND)lpIMC->hWnd, &ptNew);

    if (lpIMC->cfCandForm[0].dwStyle & CFS_FORCE_POSITION) {
    } else if (lpIMC->cfCandForm[0].dwStyle == CFS_CANDIDATEPOS) {
        AdjustCandBoundry(&ptNew);
    } else if (lpIMC->cfCandForm[0].dwStyle == CFS_EXCLUDE) {
           if(!MBIndex.IMEChara[0].IC_Trace) {
               CalcCandPos(hIMC, hUIWnd, &ptNew);
        }
        AdjustCandBoundry(&ptNew);
    }

    SetWindowPos(hCandWnd, NULL, ptNew.x, ptNew.y,
        0, 0, SWP_NOACTIVATE|SWP_NOSIZE|SWP_NOZORDER);

    ImmUnlockIMC(hIMC);

    return (0L);
}

/**********************************************************************/
/* ShowCand()                                                         */
/**********************************************************************/
void PASCAL ShowCand(           // Show the candidate window
    HWND    hUIWnd,
    int     nShowCandCmd)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {          // can not darw candidate window
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw candidate window
        return;
    }

    // add 10.9
    if (lpUIPrivate->nShowCandCmd == nShowCandCmd) {
        goto SwCandNoChange;
    }

    if (nShowCandCmd == SW_HIDE) {
        lpUIPrivate->fdwSetContext &= ~(ISC_HIDE_CAND_WINDOW);
    }

    if (!lpUIPrivate->hCandWnd) {
        // not in show candidate window mode
    } else if (lpUIPrivate->nShowCandCmd != nShowCandCmd) {
        if(nShowCandCmd == SW_HIDE) {
            uOpenCand = 0;
        } else {
            HIMC           hIMC;
            POINT          ptSTWPos;
            int            Comp_CandWndLen;

            uOpenCand = 1;

            // reset status window for LINE_UI(FIX_UI)
            hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
            if (!hIMC) {
                goto ShowCand;
            }

               ImmGetStatusWindowPos(hIMC, (LPPOINT)&ptSTWPos);
            Comp_CandWndLen = 0;
            if(uOpenCand) {
                Comp_CandWndLen += sImeG.xCandWi + UI_MARGIN;
                if(uStartComp) {
                    Comp_CandWndLen += lpImeL->xCompWi + UI_MARGIN;
                }
                if(ptSTWPos.x + sImeG.xStatusWi + Comp_CandWndLen > sImeG.rcWorkArea.right) {
                    PostMessage(GetCompWnd(hUIWnd), WM_IME_NOTIFY, IMN_SETCOMPOSITIONWINDOW, 0);
                }
            }
        }
        
ShowCand:
        ShowWindow(lpUIPrivate->hCandWnd, nShowCandCmd);
        lpUIPrivate->nShowCandCmd = nShowCandCmd;
    }

SwCandNoChange:
    GlobalUnlock(hUIPrivate);
    return;
}

/**********************************************************************/
/* OpenCand                                                           */
/**********************************************************************/
void PASCAL OpenCand(
    HWND hUIWnd)
{
    HGLOBAL        hUIPrivate;
    LPUIPRIV       lpUIPrivate;
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    POINT          ptWnd;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {          // can not darw candidate window
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw candidate window
        return;
    }

    lpUIPrivate->fdwSetContext |= ISC_SHOWUICANDIDATEWINDOW;

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        goto OpenCandUnlockUIPriv;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        goto OpenCandUnlockUIPriv;
    }

    if (lpIMC->cfCandForm[0].dwIndex == 0) {
        
        ptWnd = lpIMC->cfCandForm[0].ptCurrentPos;

        ClientToScreen(lpIMC->hWnd, &ptWnd);

        if (lpIMC->cfCandForm[0].dwStyle & CFS_FORCE_POSITION) {
        } else if (lpIMC->cfCandForm[0].dwStyle == CFS_EXCLUDE) {
               POINT ptCaret;

            AdjustCandBoundry(&ptWnd);
            if((!MBIndex.IMEChara[0].IC_Trace)
              || (!GetCaretPos(&ptCaret))) {

                if(GetCompWnd(hUIWnd)) {
                    ptWnd.x = ptWnd.y = 0;
//                    ptWnd = lpIMC->cfCompForm.ptCurrentPos;
                    ClientToScreen(lpIMC->hWnd, &ptWnd);
                    ptWnd.x -= lpImeL->cxCompBorder + 1;
                    ptWnd.y -= lpImeL->cyCompBorder + 1;
                } else {
                    ptWnd.x = lpImeL->cxCompBorder + 1;
                    ptWnd.y = lpImeL->cyCompBorder + 1;
                }

                   CalcCandPos(hIMC, hUIWnd, &ptWnd);

                lpIMC->cfCandForm[0].dwStyle |= CFS_CANDIDATEPOS;
                lpIMC->cfCandForm[0].ptCurrentPos = ptWnd;
                ScreenToClient(lpIMC->hWnd, &lpIMC->cfCandForm[0].ptCurrentPos);
            } else {
                AdjustCandPos(hIMC, &ptWnd);
            }
        } else if (lpIMC->cfCandForm[0].dwStyle == CFS_CANDIDATEPOS) {
            AdjustCandBoundry(&ptWnd);
        } else {
            if (lpUIPrivate->nShowCompCmd != SW_HIDE) {
                ptWnd.x = ptWnd.y = 0;
                ClientToScreen(lpUIPrivate->hCompWnd, &ptWnd);
            } else {
                ptWnd = lpIMC->cfCompForm.ptCurrentPos;
                ClientToScreen(lpIMC->hWnd, &ptWnd);
            }

            ptWnd.x -= lpImeL->cxCompBorder + 1;
            ptWnd.y -= lpImeL->cyCompBorder + 1;

               CalcCandPos(hIMC, hUIWnd, &ptWnd);

            lpIMC->cfCandForm[0].dwStyle |= CFS_CANDIDATEPOS;
            lpIMC->cfCandForm[0].ptCurrentPos = ptWnd;
            ScreenToClient(lpIMC->hWnd, &lpIMC->cfCandForm[0].ptCurrentPos);
        }
    } else {
        // make cand windows trace comp window !
        if (lpUIPrivate->nShowCompCmd != SW_HIDE) {
            ptWnd.x = ptWnd.y = 0;
            ClientToScreen(lpUIPrivate->hCompWnd, &ptWnd);
        } else {
            ptWnd = lpIMC->cfCompForm.ptCurrentPos;
            ClientToScreen(lpIMC->hWnd, &ptWnd);
        }

        ptWnd.x -= lpImeL->cxCompBorder + 1;
        ptWnd.y -= lpImeL->cyCompBorder + 1;

           CalcCandPos(hIMC, hUIWnd, &ptWnd);

        lpIMC->cfCandForm[0].dwStyle |= CFS_CANDIDATEPOS;
        lpIMC->cfCandForm[0].ptCurrentPos = ptWnd;
        ScreenToClient(lpIMC->hWnd, &lpIMC->cfCandForm[0].ptCurrentPos);
    }

    ImmUnlockIMC(hIMC);

    if (lpUIPrivate->hCandWnd) {
        SetWindowPos(lpUIPrivate->hCandWnd, NULL,
            ptWnd.x, ptWnd.y,
            0, 0, SWP_NOACTIVATE|SWP_NOSIZE|SWP_NOZORDER);
    } else {
        lpUIPrivate->hCandWnd = CreateWindowEx(
                                      WS_EX_WINDOWEDGE|WS_EX_DLGMODALFRAME,
                                      szCandClassName, 
                                      NULL, 
                                      WS_POPUP|WS_DISABLED,
                                      ptWnd.x,
                                      ptWnd.y,
                                      sImeG.xCandWi, 
                                      sImeG.yCandHi,
                                      hUIWnd, 
                                      (HMENU)NULL, 
                                      hInst, 
                                      NULL);

        if ( lpUIPrivate->hCandWnd )
        {
            SetWindowLong(lpUIPrivate->hCandWnd, UI_MOVE_OFFSET,WINDOW_NOT_DRAG);
            SetWindowLong(lpUIPrivate->hCandWnd, UI_MOVE_XY, 0L);
        }
    }

    ShowCand(hUIWnd, SW_SHOWNOACTIVATE);

OpenCandUnlockUIPriv:
    GlobalUnlock(hUIPrivate);
    return;
}

/**********************************************************************/
/* CloseCand                                                          */
/**********************************************************************/
void PASCAL CloseCand(
    HWND hUIWnd)
{
    ShowCand(hUIWnd, SW_HIDE);

    return;
}

/**********************************************************************/
/* DestroyCandWindow                                                  */
/**********************************************************************/
void PASCAL DestroyCandWindow(
    HWND hCandWnd)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    if (GetWindowLong(hCandWnd, UI_MOVE_OFFSET) != WINDOW_NOT_DRAG) {
        // undo the drag border
        DrawDragBorder(hCandWnd,
            GetWindowLong(hCandWnd, UI_MOVE_XY),
            GetWindowLong(hCandWnd, UI_MOVE_OFFSET));
    }

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(GetWindow(hCandWnd, GW_OWNER),
        IMMGWLP_PRIVATE);
    if (!hUIPrivate) {          // can not darw candidate window
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw candidate window
        return;
    }

    lpUIPrivate->nShowCandCmd = SW_HIDE;

    lpUIPrivate->hCandWnd = (HWND)NULL;

    GlobalUnlock(hUIPrivate);
    return;
}

/**********************************************************************/
/* MouseSelectCandStr()                                               */
/**********************************************************************/
void PASCAL MouseSelectCandStr(
    HWND    hCandWnd,
    LPPOINT lpCursor)
{
    HIMC            hIMC;
    LPINPUTCONTEXT  lpIMC;
    LPCANDIDATEINFO lpCandInfo;
    LPCANDIDATELIST lpCandList;
    DWORD           dwValue;

    hIMC = (HIMC)GetWindowLongPtr(GetWindow(hCandWnd, GW_OWNER), IMMGWLP_IMC);
    if (!hIMC) {
        return;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return;
    }

    if (!lpIMC->hCandInfo) {
        ImmUnlockIMC(hIMC);
        return;
    }

    lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo);
    if (!lpCandInfo) {
        ImmUnlockIMC(hIMC);
        return;
    }

    dwValue = (lpCursor->y - sImeG.rcCandText.top) / sImeG.yChiCharHi;

    lpCandList = (LPCANDIDATELIST)((LPBYTE)lpCandInfo +
        lpCandInfo->dwOffset[0]);

    dwValue = dwValue + lpCandList->dwSelection /
        lpCandList->dwPageSize * lpCandList->dwPageSize;

    if (dwValue >= lpCandList->dwCount) {
        // invalid choice
        MessageBeep((UINT)-1);
    } else {
        NotifyIME(hIMC, NI_SELECTCANDIDATESTR, 0, dwValue);
    }

    ImmUnlockIMCC(lpIMC->hCandInfo);

    ImmUnlockIMC(hIMC);

    return;
}

/**********************************************************************/
/* CandPageDownUP()                                                   */
/**********************************************************************/
void PASCAL CandPageDownUP(
    HWND hCandWnd,
    UINT uCandDownUp)
{
    HIMC            hIMC;
    LPINPUTCONTEXT  lpIMC;
    LPPRIVCONTEXT   lpImcP;
    LPCANDIDATEINFO lpCandInfo;
    LPCANDIDATELIST lpCandList;
    HDC             hDC;
    HBITMAP         hCandHpBmp, hCandUpBmp, hCandDpBmp, hCandEpBmp;
    HBITMAP         hOldBmp;
    HDC             hMemDC;

    // change candlist
    hIMC = (HIMC)GetWindowLongPtr(GetWindow(hCandWnd, GW_OWNER), IMMGWLP_IMC);
    if (!hIMC) {
        return;
    }

    // get lpIMC
    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return;
    }

    // get lpImcP
    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    if (!lpImcP) {
        return;
    }

    // get lpCandInfo
    lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo);

    if (!lpCandInfo) {
        return;
    }
                                                 
    // get lpCandList and init dwCount & dwSelection
    lpCandList = (LPCANDIDATELIST)
        ((LPBYTE)lpCandInfo + lpCandInfo->dwOffset[0]);
    
    switch(uCandDownUp) {
    case uCandHome:
        EngChCand(NULL, lpCandList, lpImcP, lpIMC, 0x24);
        NotifyIME(hIMC, NI_CHANGECANDIDATELIST, 0, 0);
        break;
    case uCandUp:
        EngChCand(NULL, lpCandList, lpImcP, lpIMC, 0x21);
        NotifyIME(hIMC, NI_CHANGECANDIDATELIST, 0, 0);
        break;
    case uCandDown:
        //EngChCand(NULL, lpCandList, lpImcP, lpIMC, '=');
        EngChCand(NULL, lpCandList, lpImcP, lpIMC, 0x22);
        NotifyIME(hIMC, NI_CHANGECANDIDATELIST, 0, 0);
        break;
    case uCandEnd:
        EngChCand(NULL, lpCandList, lpImcP, lpIMC, 0x23);
        NotifyIME(hIMC, NI_CHANGECANDIDATELIST, 0, 0);
        break;
    default:
        break;
    }

    ImmUnlockIMCC(lpIMC->hPrivate);
    ImmUnlockIMCC(lpIMC->hCandInfo);
    ImmUnlockIMC(hIMC);

    // draw button down
    hDC = GetDC(hCandWnd);
    hCandHpBmp = LoadBitmap(hInst, TEXT("CandHp"));
    hCandUpBmp = LoadBitmap(hInst, TEXT("CandUp"));
    hCandDpBmp = LoadBitmap(hInst, TEXT("CandDp"));
    hCandEpBmp = LoadBitmap(hInst, TEXT("CandEp"));

    hMemDC = CreateCompatibleDC(hDC);

    switch(uCandDownUp) {
    case uCandHome:
        hOldBmp = SelectObject(hMemDC, hCandHpBmp);
        BitBlt(hDC, sImeG.rcCandBTH.left, sImeG.rcCandBTH.top,
            sImeG.rcCandBTH.right - sImeG.rcCandBTH.left,
            STATUS_DIM_Y,
            hMemDC, 0, 0, SRCCOPY);
        break;
    case uCandUp:
        hOldBmp = SelectObject(hMemDC, hCandUpBmp);
        BitBlt(hDC, sImeG.rcCandBTU.left, sImeG.rcCandBTU.top,
            sImeG.rcCandBTU.right - sImeG.rcCandBTU.left,
            STATUS_DIM_Y,
            hMemDC, 0, 0, SRCCOPY);
        break;
    case uCandDown:
        hOldBmp = SelectObject(hMemDC, hCandDpBmp);
        BitBlt(hDC, sImeG.rcCandBTD.left, sImeG.rcCandBTD.top,
            sImeG.rcCandBTD.right - sImeG.rcCandBTD.left,
            STATUS_DIM_Y,
            hMemDC, 0, 0, SRCCOPY);

        break;
    case uCandEnd:
        hOldBmp = SelectObject(hMemDC, hCandEpBmp);
        BitBlt(hDC, sImeG.rcCandBTE.left, sImeG.rcCandBTE.top,
            sImeG.rcCandBTE.right - sImeG.rcCandBTE.left,
            STATUS_DIM_Y,
            hMemDC, 0, 0, SRCCOPY);
        break;
    default:
        break;
    }
        
    SelectObject(hMemDC, hOldBmp);
    DeleteDC(hMemDC);
    DeleteObject(hCandEpBmp);
    DeleteObject(hCandDpBmp);
    DeleteObject(hCandUpBmp);
    DeleteObject(hCandHpBmp);
    ReleaseDC(hCandWnd, hDC);

    return;
}

/**********************************************************************/
/* CandSetCursor()                                                    */
/**********************************************************************/
void PASCAL CandSetCursor(
    HWND   hCandWnd,
    LPARAM lParam)
{
    POINT ptCursor;
    RECT  rcWnd;

    if (GetWindowLong(hCandWnd, UI_MOVE_OFFSET) !=
        WINDOW_NOT_DRAG) {
        SetCursor(LoadCursor(NULL, IDC_SIZEALL));
        return;
    }

    if (HIWORD(lParam) == WM_LBUTTONDOWN) {
        SystemParametersInfo(SPI_GETWORKAREA, 0, &sImeG.rcWorkArea, 0);

        GetCursorPos(&ptCursor);
        ScreenToClient(hCandWnd, &ptCursor);

        if (PtInRect(&sImeG.rcCandText, ptCursor)
           && MBIndex.IMEChara[0].IC_Trace) {
            SetCursor(LoadCursor(hInst, szHandCursor));
            MouseSelectCandStr(hCandWnd, &ptCursor);
            return;
        } else if (PtInRect(&sImeG.rcCandBTH, ptCursor)) {
            CandPageDownUP(hCandWnd, uCandHome);
            return;
        } else if (PtInRect(&sImeG.rcCandBTU, ptCursor)) {
            CandPageDownUP(hCandWnd, uCandUp);
            return;
        } else if (PtInRect(&sImeG.rcCandBTD, ptCursor)) {
            CandPageDownUP(hCandWnd, uCandDown);
            return;
        } else if (PtInRect(&sImeG.rcCandBTE, ptCursor)) {
            CandPageDownUP(hCandWnd, uCandEnd);
            return;
        } else {
            SetCursor(LoadCursor(NULL, IDC_SIZEALL));
        }
    } else if (HIWORD(lParam) == WM_LBUTTONUP) {
        HDC             hDC;
        HBITMAP         hCandHBmp, hCandUBmp, hCandDBmp, hCandEBmp;
        HBITMAP         hOldBmp;
        HDC             hMemDC;

        hDC = GetDC(hCandWnd);

        hCandHBmp = LoadBitmap(hInst, TEXT("CandH"));
        hCandUBmp = LoadBitmap(hInst, TEXT("CandU"));
        hCandDBmp = LoadBitmap(hInst, TEXT("CandD"));
        hCandEBmp = LoadBitmap(hInst, TEXT("CandE"));
        hMemDC = CreateCompatibleDC(hDC);

        hOldBmp = SelectObject(hMemDC, hCandHBmp);
        BitBlt(hDC, sImeG.rcCandBTH.left, sImeG.rcCandBTH.top,
            sImeG.rcCandBTH.right - sImeG.rcCandBTH.left,
            STATUS_DIM_Y,
            hMemDC, 0, 0, SRCCOPY);

        SelectObject(hMemDC, hCandUBmp);
        BitBlt(hDC, sImeG.rcCandBTU.left, sImeG.rcCandBTU.top,
            sImeG.rcCandBTU.right - sImeG.rcCandBTU.left,
            STATUS_DIM_Y,
            hMemDC, 0, 0, SRCCOPY);

        SelectObject(hMemDC, hCandDBmp);
        BitBlt(hDC, sImeG.rcCandBTD.left, sImeG.rcCandBTD.top,
            sImeG.rcCandBTD.right - sImeG.rcCandBTD.left,
            STATUS_DIM_Y,
            hMemDC, 0, 0, SRCCOPY);

        SelectObject(hMemDC, hCandEBmp);
        BitBlt(hDC, sImeG.rcCandBTE.left, sImeG.rcCandBTE.top,
            sImeG.rcCandBTE.right - sImeG.rcCandBTE.left,
            STATUS_DIM_Y,
            hMemDC, 0, 0, SRCCOPY);

        SelectObject(hMemDC, hOldBmp);
        DeleteObject(hCandEBmp);
        DeleteObject(hCandDBmp);
        DeleteObject(hCandUBmp);
        DeleteObject(hCandEBmp);
        DeleteDC(hMemDC);
        ReleaseDC(hCandWnd, hDC);

        return;
    } else {
        SystemParametersInfo(SPI_GETWORKAREA, 0, &sImeG.rcWorkArea, 0);

        GetCursorPos(&ptCursor);
        ScreenToClient(hCandWnd, &ptCursor);

        if (PtInRect(&sImeG.rcCandText, ptCursor)) {
            SetCursor(LoadCursor(hInst, szHandCursor));
            return;
        } else if (PtInRect(&sImeG.rcCandBTH, ptCursor)) {
            SetCursor(LoadCursor(hInst, szHandCursor));
        } else if (PtInRect(&sImeG.rcCandBTU, ptCursor)) {
            SetCursor(LoadCursor(hInst, szHandCursor));
        } else if (PtInRect(&sImeG.rcCandBTD, ptCursor)) {
            SetCursor(LoadCursor(hInst, szHandCursor));
        } else if (PtInRect(&sImeG.rcCandBTE, ptCursor)) {
            SetCursor(LoadCursor(hInst, szHandCursor));
        } else {
            SetCursor(LoadCursor(NULL, IDC_SIZEALL));
        }

        return;
    }

    SetCapture(hCandWnd);
    GetCursorPos(&ptCursor);
    SetWindowLong(hCandWnd, UI_MOVE_XY,
        MAKELONG(ptCursor.x, ptCursor.y));
    GetWindowRect(hCandWnd, &rcWnd);
    SetWindowLong(hCandWnd, UI_MOVE_OFFSET,
        MAKELONG(ptCursor.x - rcWnd.left, ptCursor.y - rcWnd.top));

    DrawDragBorder(hCandWnd, MAKELONG(ptCursor.x, ptCursor.y),
        GetWindowLong(hCandWnd, UI_MOVE_OFFSET));

    return;
}

/**********************************************************************/
/* CandButtonUp()                                                     */
/**********************************************************************/
BOOL PASCAL CandButtonUp(
    HWND hCandWnd)
{
    LONG           lTmpCursor, lTmpOffset;
    POINT          pt;
    HWND           hUIWnd;
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;

    if (GetWindowLong(hCandWnd, UI_MOVE_OFFSET) == WINDOW_NOT_DRAG) {
        return (FALSE);
    }

    lTmpCursor = GetWindowLong(hCandWnd, UI_MOVE_XY);

    // calculate the org by the offset
    lTmpOffset = GetWindowLong(hCandWnd, UI_MOVE_OFFSET);

    pt.x = (*(LPPOINTS)&lTmpCursor).x - (*(LPPOINTS)&lTmpOffset).x;
    pt.y = (*(LPPOINTS)&lTmpCursor).y - (*(LPPOINTS)&lTmpOffset).y;

    DrawDragBorder(hCandWnd, lTmpCursor, lTmpOffset);
    SetWindowLong(hCandWnd, UI_MOVE_OFFSET, WINDOW_NOT_DRAG);
    ReleaseCapture();

    hUIWnd = GetWindow(hCandWnd, GW_OWNER);
    if (!hUIWnd) {
        return (FALSE);
    }

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return (FALSE);
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return (FALSE);
    }

    AdjustCandBoundry(&pt);

    ScreenToClient(lpIMC->hWnd, &pt);

    lpIMC->cfCandForm[0].dwStyle |= CFS_CANDIDATEPOS;
    lpIMC->cfCandForm[0].ptCurrentPos = pt;

    ImmUnlockIMC(hIMC);

    PostMessage(hCandWnd, WM_IME_NOTIFY, IMN_SETCANDIDATEPOS, 0x0001);

    return (TRUE);
}

/**********************************************************************/
/* UpdateCandWindow()                                                 */
/**********************************************************************/
//void PASCAL UpdateCandWindow2(
void PASCAL PaintCandWindow(
    HWND hCandWnd,
    HDC  hDC)
{
    HIMC            hIMC;
    LPINPUTCONTEXT  lpIMC;
    LPCANDIDATEINFO lpCandInfo;
    LPCANDIDATELIST lpCandList;
    LPPRIVCONTEXT   lpImcP;
    HGDIOBJ         hOldFont;
    DWORD           dwStart, dwEnd;
    TCHAR           szStrBuf[2 * MAXSTRLEN * sizeof(WCHAR) / sizeof(TCHAR) + 1];
    int             i;
	HBITMAP         hCandIconBmp, hCandInfBmp;
    HBITMAP         hOldBmp, hCandHBmp, hCandUBmp, hCandDBmp, hCandEBmp;
    HDC             hMemDC;
    LOGFONT         lfFont;

    hIMC = (HIMC)GetWindowLongPtr(GetWindow(hCandWnd, GW_OWNER), IMMGWLP_IMC);
    if (!hIMC) {
        return;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return;
    }

    if (!lpIMC->hCandInfo) {
        goto UpCandW2UnlockIMC;
    }

    lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo);
    if (!lpCandInfo) {
        goto UpCandW2UnlockIMC;
    }

    if (!lpIMC->hPrivate) {
        goto UpCandW2UnlockCandInfo;
    }

    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    if (!lpImcP) {
        goto UpCandW2UnlockCandInfo;
    }

    // set font
    
    if (sImeG.fDiffSysCharSet) {
        LOGFONT lfFont;
        ZeroMemory(&lfFont, sizeof(lfFont));
        hOldFont = GetCurrentObject(hDC, OBJ_FONT);
        lfFont.lfHeight = -MulDiv(12, GetDeviceCaps(hDC, LOGPIXELSY), 72);
        lfFont.lfCharSet = NATIVE_CHARSET;
        lstrcpy(lfFont.lfFaceName, TEXT("Simsun")); 
        SelectObject(hDC, CreateFontIndirect(&lfFont));
    }
    lpCandList = (LPCANDIDATELIST)((LPBYTE)lpCandInfo +
        lpCandInfo->dwOffset[0]);

    dwStart = lpCandList->dwSelection;
    dwEnd = dwStart + lpCandList->dwPageSize;

    if (dwEnd > lpCandList->dwCount) {
        dwEnd = lpCandList->dwCount;
    }

    // draw CandWnd Layout
    if (MBIndex.IMEChara[0].IC_Trace) {
        RECT rcWnd;

        GetClientRect(hCandWnd, &rcWnd);
        DrawConcaveRect(hDC,
            rcWnd.left,
            rcWnd.top + UI_CANDINF,
            rcWnd.right - 1,
            rcWnd.bottom - 1);
    } else {
        RECT rcWnd;

        GetClientRect(hCandWnd, &rcWnd);
        DrawConcaveRect(hDC,
            sImeG.rcCandText.left - 1,
            rcWnd.top,
            sImeG.rcCandText.right + 1,
            rcWnd.bottom - 1);
    }

    if(lpImcP->PrivateArea.Comp_Status.dwSTLX) {
        SetTextColor(hDC, RGB(0x00, 0x00, 0x255));
    } else if(lpImcP->PrivateArea.Comp_Status.dwSTMULCODE) {
        SetTextColor(hDC, RGB(0x80, 0x00, 0x00));
    } else {
        SetTextColor(hDC, RGB(0x00, 0x00, 0x00));
    }
    SetBkColor(hDC, RGB(0xC0, 0xC0, 0xC0));

    if (MBIndex.IMEChara[0].IC_Trace) {
        ExtTextOut(hDC, sImeG.rcCandText.left, sImeG.rcCandText.top,
            ETO_OPAQUE, &sImeG.rcCandText, NULL, 0, NULL);
        szStrBuf[0] = TEXT('1');
        szStrBuf[1] = TEXT(':');

        for (i = 0; dwStart < dwEnd; dwStart++, i++) {
            int  iLen;

            szStrBuf[0] = szDigit[i + CAND_START];

            iLen = lstrlen((LPTSTR)((LPBYTE)lpCandList +
                lpCandList->dwOffset[dwStart]));

#ifdef KEYSTICKER
            {
                LPTSTR p;
                BOOL fMap;
                TCHAR    mapbuf[MAXSTRLEN];
                int j,k,l;                    

                ZeroMemory(mapbuf, MAXSTRLEN*sizeof(TCHAR));
                p=(LPTSTR)((LPBYTE)lpCandList +lpCandList->dwOffset[dwStart]);
                fMap=FALSE;            
                if(MBIndex.IMEChara[0].IC_CTC) {
                    for(l=0; l<iLen; l++){
                        if(IsUsedCode(p[l], NULL)){
                            fMap=TRUE;
                            break;
                        }else{
                            l = l + 2 - sizeof(TCHAR);
                            continue;
                        }
                    }
                    if(fMap && l<iLen){
                        lstrcpyn(mapbuf, (LPTSTR)((LPBYTE)lpCandList 
                            +lpCandList->dwOffset[dwStart]), l*sizeof(TCHAR));
                        k=l;
                        mapbuf[l++] = TEXT('(');
                        j=0;
                        while(IsUsedCode(p[k++], NULL))
                            j++;
                        MapSticker((LPTSTR)p+l-1, &mapbuf[l], j);
                        lstrcat(mapbuf, TEXT(")"));
                        iLen = lstrlen(mapbuf);
                    }else{
                        lstrcpy(mapbuf,(LPTSTR)((LPBYTE)lpCandList 
                            +lpCandList->dwOffset[dwStart]));
                    }         
                }else{
                    lstrcpy(mapbuf,(LPTSTR)((LPBYTE)lpCandList 
                        +lpCandList->dwOffset[dwStart]));
                }
                // according to init.c, 11 DBCS char
                if (iLen > 14 * 2 / sizeof(TCHAR)) {
                    iLen = 14 * 2 / sizeof(TCHAR);
                    CopyMemory(&szStrBuf[2],mapbuf,
                        (iLen - 2) * sizeof(TCHAR));
                    // maybe not good for UNICODE
                    szStrBuf[iLen] = TEXT('.');
                    szStrBuf[iLen+1] = TEXT('.');
                    szStrBuf[iLen+2] = TEXT('\0');
                } else {
                    CopyMemory(&szStrBuf[2],mapbuf,iLen*sizeof(TCHAR));
                }
            }
#else
            // according to init.c, 11 DBCS char
            if (iLen > 14 * 2 / sizeof(TCHAR)) {
                iLen = 14 * 2 / sizeof(TCHAR);
                CopyMemory(&szStrBuf[2],
                    ((LPTSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[dwStart])),
                    (iLen - 2) * sizeof(TCHAR));
                // maybe not good for UNICODE
                szStrBuf[iLen] = TEXT('.');
                szStrBuf[iLen+1] = TEXT('.');
                szStrBuf[iLen+2] = TEXT('\0');
            } else {
                CopyMemory(&szStrBuf[2],
                    ((LPTSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[dwStart])),
                    iLen*sizeof(TCHAR));
            }
#endif //KEYSTICKER

            ExtTextOut(hDC, sImeG.rcCandText.left,
                sImeG.rcCandText.top + i * sImeG.yChiCharHi,
                (UINT) 0, NULL,
                szStrBuf,
                iLen+2, NULL);
        }
    } else {
        int  nX;

        ExtTextOut(hDC, sImeG.rcCandText.left, sImeG.rcCandText.top + 1,
            ETO_OPAQUE, &sImeG.rcCandText, NULL, 0, NULL);
        nX = 0;
        for (i = 0; dwStart < dwEnd; dwStart++, i++) {
            int  iLen;
            SIZE StrSize;

            // display numbers

            szStrBuf[0] = szDigit[i + CAND_START];
            szStrBuf[1] = TEXT(':');

            // display chinese word and code
            iLen = lstrlen((LPTSTR)((LPBYTE)lpCandList +
                lpCandList->dwOffset[dwStart]));

            CopyMemory((LPTSTR)&(szStrBuf[2]),
                (LPTSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[dwStart]),
                iLen*sizeof(TCHAR));

			szStrBuf[iLen+2] = TEXT(' ');
			szStrBuf[iLen+2+1] = TEXT('\0');

            
            ExtTextOut(hDC, sImeG.rcCandText.left + nX, 
                    sImeG.rcCandText.top + 1,
                    ETO_CLIPPED, &sImeG.rcCandText,
                    szStrBuf,
                    lstrlen(szStrBuf), NULL);

            if(!GetTextExtentPoint(hDC, (LPCTSTR)szStrBuf, lstrlen(szStrBuf), &StrSize))
               memset(&StrSize, 0, sizeof(SIZE));
            nX += StrSize.cx;

        }
    }
    
    // load all bitmap
    if (MBIndex.IMEChara[0].IC_Trace) {
        WORD NumCode, wFlg;

        SetTextColor(hDC, RGB(0x00, 0x00, 0x00));
        SetBkColor(hDC, RGB(0xC0, 0xC0, 0xC0));

        NumCode = 0x0030;
        for(wFlg=0; wFlg<10; wFlg++, NumCode++)
          if(IsUsedCode(NumCode, lpImcP)) break;
        if(wFlg == 10) {
            hCandInfBmp = LoadBitmap(hInst, TEXT("Candinf1"));
        } else {
            hCandInfBmp = LoadBitmap(hInst, TEXT("Candinf2"));
        }
    } else {
        hCandInfBmp = NULL;
    }

    hCandHBmp = LoadBitmap(hInst, TEXT("CandH"));
    hCandUBmp = LoadBitmap(hInst, TEXT("CandU"));
    hCandDBmp = LoadBitmap(hInst, TEXT("CandD"));
    hCandEBmp = LoadBitmap(hInst, TEXT("CandE"));
    if (lpImcP->PrivateArea.Comp_Status.dwSTLX) {
        hCandIconBmp = LoadBitmap(hInst, TEXT("CandLX"));
    } else if (lpImcP->PrivateArea.Comp_Status.dwSTMULCODE) {
        hCandIconBmp = LoadBitmap(hInst, TEXT("CandMult"));
    } else {
        hCandIconBmp = LoadBitmap(hInst, TEXT("CandSel"));
    }

    hMemDC = CreateCompatibleDC(hDC);

    hOldBmp = SelectObject(hMemDC, hCandIconBmp);

    BitBlt(hDC, sImeG.rcCandIcon.left, sImeG.rcCandIcon.top,
        sImeG.rcCandIcon.right - sImeG.rcCandIcon.left,
        STATUS_DIM_Y,
        hMemDC, 0, 0, SRCCOPY);

    if(hCandInfBmp) {
        SelectObject(hMemDC, hCandInfBmp);

        BitBlt(hDC, sImeG.rcCandInf.left, sImeG.rcCandInf.top,
            sImeG.rcCandInf.right - sImeG.rcCandInf.left,
            STATUS_DIM_Y,
            hMemDC, 0, 0, SRCCOPY);
    }

    SelectObject(hMemDC, hCandHBmp);

    BitBlt(hDC, sImeG.rcCandBTH.left, sImeG.rcCandBTH.top,
        sImeG.rcCandBTH.right - sImeG.rcCandBTH.left,
        STATUS_DIM_Y,
        hMemDC, 0, 0, SRCCOPY);

    SelectObject(hMemDC, hCandUBmp);

    BitBlt(hDC, sImeG.rcCandBTU.left, sImeG.rcCandBTU.top,
        sImeG.rcCandBTU.right - sImeG.rcCandBTU.left,
        STATUS_DIM_Y,
        hMemDC, 0, 0, SRCCOPY);

    SelectObject(hMemDC, hCandDBmp);

    BitBlt(hDC, sImeG.rcCandBTD.left, sImeG.rcCandBTD.top,
        sImeG.rcCandBTD.right - sImeG.rcCandBTD.left,
        STATUS_DIM_Y,
        hMemDC, 0, 0, SRCCOPY);

    SelectObject(hMemDC, hCandEBmp);

    BitBlt(hDC, sImeG.rcCandBTE.left, sImeG.rcCandBTE.top,
        sImeG.rcCandBTE.right - sImeG.rcCandBTE.left,
        STATUS_DIM_Y,
        hMemDC, 0, 0, SRCCOPY);

    SelectObject(hMemDC, hOldBmp);
    DeleteDC(hMemDC);
    DeleteObject(hCandIconBmp);
    DeleteObject(hCandEBmp);
    DeleteObject(hCandDBmp);
    DeleteObject(hCandUBmp);
    DeleteObject(hCandHBmp);
    DeleteObject(hCandInfBmp);
    if (sImeG.fDiffSysCharSet) {    
    DeleteObject(SelectObject(hDC, hOldFont));
    }

    ImmUnlockIMCC(lpIMC->hPrivate);
UpCandW2UnlockCandInfo:
    ImmUnlockIMCC(lpIMC->hCandInfo);
UpCandW2UnlockIMC:
    ImmUnlockIMC(hIMC);

    return;
}

/**********************************************************************/
/* CandWndProc()                                                      */
/**********************************************************************/
LRESULT CALLBACK CandWndProc(
    HWND   hCandWnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{

    switch (uMsg) {
    case WM_DESTROY:
        DestroyCandWindow(hCandWnd);
        break;
    case WM_SETCURSOR:
        CandSetCursor(hCandWnd, lParam);
        break;
    case WM_MOUSEMOVE:
        if (GetWindowLong(hCandWnd, UI_MOVE_OFFSET) != WINDOW_NOT_DRAG) {
            POINT ptCursor;

            DrawDragBorder(hCandWnd,
                GetWindowLong(hCandWnd, UI_MOVE_XY),
                GetWindowLong(hCandWnd, UI_MOVE_OFFSET));
            GetCursorPos(&ptCursor);
            SetWindowLong(hCandWnd, UI_MOVE_XY,
                MAKELONG(ptCursor.x, ptCursor.y));
            DrawDragBorder(hCandWnd, MAKELONG(ptCursor.x, ptCursor.y),
                GetWindowLong(hCandWnd, UI_MOVE_OFFSET));
        } else {
            return DefWindowProc(hCandWnd, uMsg, wParam, lParam);
        }
        break;
    case WM_LBUTTONUP:
        if (!CandButtonUp(hCandWnd)) {
            return DefWindowProc(hCandWnd, uMsg, wParam, lParam);
        }
        break;
    case WM_IME_NOTIFY:
        if (wParam == IMN_SETCANDIDATEPOS) {
            return SetCandPosition(hCandWnd);
        }
        break;
    case WM_PAINT:
        {
            HDC         hDC;
            PAINTSTRUCT ps;

            hDC = BeginPaint(hCandWnd, &ps);
            PaintCandWindow(hCandWnd, hDC);
            EndPaint(hCandWnd, &ps);
        }
        break;
    case WM_MOUSEACTIVATE:
        return (MA_NOACTIVATE);

    default:
        return DefWindowProc(hCandWnd, uMsg, wParam, lParam);
    }

    return (0L);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntime\compose.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    COMPOSE.C

++*/

#include <windows.h>
#include <immdev.h>
#include <imedefs.h>

void PASCAL EngChCand(
    LPCOMPOSITIONSTRING lpCompStr,
    LPCANDIDATELIST     lpCandList,
    LPPRIVCONTEXT       lpImcP,
    LPINPUTCONTEXT      lpIMC,
    WORD                wCharCode)
{
    int   i;

    if (MBIndex.IMEChara[0].IC_Trace) {
        MB_SUB(lpIMC->hPrivate, (TCHAR)wCharCode, 0, BOX_UI);
    } else {
        MB_SUB(lpIMC->hPrivate, (TCHAR)wCharCode, 0, LIN_UI);
    }
    //
    if((lpCandList->dwCount =
        (DWORD)lpImcP->PrivateArea.Comp_Context.Candi_Cnt)
        == 0) {
    } else {

        lstrcpy((LPTSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[0]),
                  (LPTSTR)lpImcP->PrivateArea.Comp_Context.szSelectBuffer);
        for (i=1;i<lpImcP->PrivateArea.Comp_Context.Candi_Cnt;i++) {

               lpCandList->dwOffset[i] = lpCandList->dwOffset[0]
            +(DWORD)lpImcP->PrivateArea.Comp_Context.Candi_Pos[(i+1)%10]*sizeof(TCHAR) ;

               *((LPTSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[i])-1) = TEXT('\0');
        }
    }


    return;
}

/**********************************************************************/
/* Engine()                                                           */
/* Description:                                                       */
/*      search MB and fill lpCompStr and lpCandList                   */
/**********************************************************************/
UINT PASCAL Engine(
    LPCOMPOSITIONSTRING lpCompStr,
    LPCANDIDATELIST     lpCandList,
    LPPRIVCONTEXT       lpImcP,
    LPINPUTCONTEXT      lpIMC,
    WORD                wCharCode)
{
    int   i;

    if(wCharCode == VK_ESCAPE) {

        lpCandList->dwCount = 0;
        if (MBIndex.IMEChara[0].IC_Trace) {
            MB_SUB(lpIMC->hPrivate, (TCHAR)wCharCode, 0, BOX_UI);
        } else {
            MB_SUB(lpIMC->hPrivate, (TCHAR)wCharCode, 0, LIN_UI);
        }
        return (ENGINE_ESC);
    } else if(wCharCode == TEXT('\b')) {
        EngChCand(lpCompStr, lpCandList, lpImcP, lpIMC, wCharCode);

        return (ENGINE_BKSPC);
    } else if((wCharCode == 0x21) || (wCharCode == 0x22)
           || (wCharCode == 0x23) || (wCharCode == 0x24)) {

        EngChCand(lpCompStr, lpCandList, lpImcP, lpIMC, wCharCode);

        return (ENGINE_CHCAND);
    } else if ((wCharCode >= TEXT('0') && wCharCode <= TEXT('9')) &&
        (lpImcP->iImeState == CST_CHOOSE)) {

        lpCandList->dwCount = lpImcP->PrivateArea.Comp_Context.Candi_Cnt;
        lpImcP->dwOldCandCnt = lpCandList->dwCount;

        if (MBIndex.IMEChara[0].IC_Trace) {
            MB_SUB(lpIMC->hPrivate, (TCHAR)wCharCode, 1, BOX_UI);
        } else {
            MB_SUB(lpIMC->hPrivate, (TCHAR)wCharCode, 1, LIN_UI);
        }

        // if LX on, set cand
        if(!(MBIndex.IMEChara[0].IC_LX)
         ||!(lpImcP->PrivateArea.Comp_Status.dwSTLX)) {
        } else {
            lpCandList->dwCount =
            (DWORD)lpImcP->PrivateArea.Comp_Context.Candi_Cnt;

               lstrcpy((LPTSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[0]),
                 (LPTSTR)lpImcP->PrivateArea.Comp_Context.szSelectBuffer);
               for (i=1;i<lpImcP->PrivateArea.Comp_Context.Candi_Cnt;i++) {

                   lpCandList->dwOffset[i] = lpCandList->dwOffset[0]
                   +(DWORD)lpImcP->PrivateArea.Comp_Context.Candi_Pos[(i+1)%10]*sizeof(TCHAR);

                   *((LPTSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[i])-1) = TEXT('\0');
            }
        }

        return (ENGINE_MULTISEL);
    } else {
        UINT MB_SUB_RET;

        if(IsUsedCode(wCharCode, lpImcP)
             || (wCharCode == MBIndex.MBDesc[0].cWildChar)
           || (wCharCode == TEXT(' ')))
        {

            if((wCharCode != TEXT(' ')) && (wCharCode != TEXT('?'))
              && (lpImcP->PrivateArea.Comp_Status.dwSTMULCODE)) {
                if (MBIndex.IMEChara[0].IC_Trace) {
                    MB_SUB(lpIMC->hPrivate, 0x20, 0, BOX_UI);
                } else {
                    MB_SUB(lpIMC->hPrivate, 0x20, 0, LIN_UI);
                }
                // online create word
                if(lpImcP->PrivateArea.Comp_Status.OnLineCreWord) {
                    UINT i, j;

                    for(i=lstrlen(CWDBCSStr), j=0; i<MAXINPUTWORD; i++, j++) {
                        CWDBCSStr[i] = lpImcP->PrivateArea.Comp_Context.CKBBuf[j];
                    }
                }

                if(MBIndex.IMEChara[0].IC_INSSPC) {
                    int i,j, ilen;

                    ilen = lstrlen(lpImcP->PrivateArea.Comp_Context.CKBBuf);
                    lpImcP->PrivateArea.Comp_Context.CKBBuf[ilen + ilen/2] = 0;
                    for(i = ilen, j=3*ilen/2; i>2; i-=2, j-=3) {
                        lpImcP->PrivateArea.Comp_Context.CKBBuf[j-1] = 0x20;
                        lpImcP->PrivateArea.Comp_Context.CKBBuf[j-2] =
                            lpImcP->PrivateArea.Comp_Context.CKBBuf[i-1];
                        lpImcP->PrivateArea.Comp_Context.CKBBuf[j-3] =
                            lpImcP->PrivateArea.Comp_Context.CKBBuf[i-2];
                    }
                    lpImcP->PrivateArea.Comp_Context.CKBBuf[i] = 0x20;
                } else {
                }
                lstrcpy((LPTSTR)((LPBYTE)lpCompStr + lpCompStr->dwResultStrOffset),
                        lpImcP->PrivateArea.Comp_Context.CKBBuf);

                // calculate result string length
                lpCompStr->dwResultStrLen =
                    lstrlen(lpImcP->PrivateArea.Comp_Context.CKBBuf);

                lpImcP->fdwGcsFlag |= GCS_COMPREAD|GCS_COMP|GCS_CURSORPOS|
                    GCS_DELTASTART|GCS_RESULTREAD|GCS_RESULT;

#ifdef CROSSREF
                CrossReverseConv(lpIMC, lpCompStr, lpImcP, lpCandList);
#endif

            }

            if (MBIndex.IMEChara[0].IC_Trace) {
                MB_SUB_RET = MB_SUB(lpIMC->hPrivate, (TCHAR)wCharCode, 0, BOX_UI);
            } else {
                MB_SUB_RET = MB_SUB(lpIMC->hPrivate, (TCHAR)wCharCode, 0, LIN_UI);
            }

            switch (MB_SUB_RET)
            {

            case (ENGINE_COMP):     //Engine is composeing

                if((lpCandList->dwCount =
                    (DWORD)lpImcP->PrivateArea.Comp_Context.Candi_Cnt)
                    == 0) {
                } else {
                    lstrcpy((LPTSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[0]),
                            (LPTSTR)lpImcP->PrivateArea.Comp_Context.szSelectBuffer);
                    for (i=1;i<lpImcP->PrivateArea.Comp_Context.Candi_Cnt;i++) {

                        lpCandList->dwOffset[i] = lpCandList->dwOffset[0]
                        +(DWORD)lpImcP->PrivateArea.Comp_Context.Candi_Pos[(i+1)%10]*sizeof(TCHAR);

                        *((LPTSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[i])-1) = TEXT('\0');
                    }
                }


                return (ENGINE_COMP);

            case (ENGINE_ASCII):      //Can't compose

                return ENGINE_ASCII;

            case (ENGINE_RESAULT):      //Composition complete and Result string available

                InitCompStr(lpCompStr);
                // online create word
                if(lpImcP->PrivateArea.Comp_Status.OnLineCreWord) {
                    UINT i, j;

                    for(i=lstrlen(CWDBCSStr), j=0; i<MAXINPUTWORD; i++, j++) {
                        CWDBCSStr[i] = lpImcP->PrivateArea.Comp_Context.CKBBuf[j];
                    }
                }

                if(MBIndex.IMEChara[0].IC_INSSPC) {
                    int i,j, ilen;

                    ilen = lstrlen(lpImcP->PrivateArea.Comp_Context.CKBBuf);
                    lpImcP->PrivateArea.Comp_Context.CKBBuf[ilen + ilen/2] = 0;
                    for(i = ilen, j=3*ilen/2; i>2; i-=2, j-=3) {
                        lpImcP->PrivateArea.Comp_Context.CKBBuf[j-1] = 0x20;
                        lpImcP->PrivateArea.Comp_Context.CKBBuf[j-2] =
                            lpImcP->PrivateArea.Comp_Context.CKBBuf[i-1];
                        lpImcP->PrivateArea.Comp_Context.CKBBuf[j-3] =
                            lpImcP->PrivateArea.Comp_Context.CKBBuf[i-2];
                    }
                    lpImcP->PrivateArea.Comp_Context.CKBBuf[i] = 0x20;
                } else {
                }
                lstrcpy((LPTSTR)((LPBYTE)lpCompStr + lpCompStr->dwResultStrOffset),
                        lpImcP->PrivateArea.Comp_Context.CKBBuf);

                // calculate result string length
                lpCompStr->dwResultStrLen =
                    lstrlen(lpImcP->PrivateArea.Comp_Context.CKBBuf);

#ifdef CROSSREF
                CrossReverseConv(lpIMC, lpCompStr, lpImcP, lpCandList);
#endif

                // if LX on, set cand
                if(!(MBIndex.IMEChara[0].IC_LX)
                 ||!(lpImcP->PrivateArea.Comp_Status.dwSTLX)) {
                } else {
                    lpCandList->dwCount =
                        (DWORD)lpImcP->PrivateArea.Comp_Context.Candi_Cnt;

                    lstrcpy((LPTSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[0]),
                            (LPTSTR)lpImcP->PrivateArea.Comp_Context.szSelectBuffer);
                    for (i=1;i<lpImcP->PrivateArea.Comp_Context.Candi_Cnt;i++) {

                        lpCandList->dwOffset[i] = lpCandList->dwOffset[0]
                        +(DWORD)lpImcP->PrivateArea.Comp_Context.Candi_Pos[(i+1)%10]*sizeof(TCHAR);

                        *((LPTSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[i])-1) = TEXT('\0');
                    }
                }
                return (ENGINE_RESAULT);
            default:
                return (ENGINE_COMP);
            }
        } else {
            return (ENGINE_COMP);
        }

    }
 }

/**********************************************************************/
/* CompEscapeKey()                                                    */
/**********************************************************************/
void PASCAL CompEscapeKey(
    LPINPUTCONTEXT      lpIMC,
    LPCOMPOSITIONSTRING lpCompStr,
    LPGUIDELINE         lpGuideLine,
    LPPRIVCONTEXT       lpImcP)
{
    // add temp
    lpImcP->PrivateArea.Comp_Context.szInBuffer[0] = 0;
    lpImcP->PrivateArea.Comp_Context.PromptCnt = 0;
    lpImcP->PrivateArea.Comp_Status.dwInvalid = 0;

    if (!lpGuideLine) {
        MessageBeep((UINT)-1);
    } else if (lpGuideLine->dwLevel == GL_LEVEL_NOGUIDELINE) {
    } else {
        lpGuideLine->dwLevel = GL_LEVEL_NOGUIDELINE;
        lpGuideLine->dwIndex = GL_ID_UNKNOWN;
        lpGuideLine->dwStrLen = 0;

        lpImcP->fdwImeMsg |= MSG_GUIDELINE;
    }

    if (lpImcP->iImeState == CST_CHOOSE) {
        Finalize(lpIMC, lpCompStr, lpImcP, VK_ESCAPE);
    } else if (lpImcP->fdwImeMsg & MSG_ALREADY_START) {
        lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_END_COMPOSITION) &
            ~(MSG_START_COMPOSITION);
    }

    lpImcP->iImeState = CST_INIT;

    if (lpCompStr) {
        InitCompStr(lpCompStr);
        lpImcP->fdwImeMsg |= MSG_COMPOSITION;
        lpImcP->dwCompChar = VK_ESCAPE;
        lpImcP->fdwGcsFlag |= (GCS_COMPREAD|GCS_COMP|GCS_CURSORPOS|
            GCS_DELTASTART);
    }

    return;
}

/**********************************************************************/
/* CompBackSpaceKey()                                                 */
/**********************************************************************/
void PASCAL CompBackSpaceKey(
    LPINPUTCONTEXT      lpIMC,
    LPCOMPOSITIONSTRING lpCompStr,
    LPPRIVCONTEXT       lpImcP)
{

    if (lpCompStr->dwCursorPos < sizeof(BYTE)) {
        lpCompStr->dwCursorPos = sizeof(BYTE);
    }

    // go back a compsoition char
    lpCompStr->dwCursorPos -= sizeof(BYTE);

    // clean the sequence code

    lpImcP->fdwImeMsg |= MSG_COMPOSITION;
    lpImcP->dwCompChar = TEXT('\b');
    lpImcP->fdwGcsFlag |= (GCS_COMPREAD|GCS_COMP|GCS_CURSORPOS|
        GCS_DELTASTART);

    if (!lpCompStr->dwCursorPos) {

      if ((lpImcP->fdwImeMsg & (MSG_ALREADY_OPEN))
         || (lpImcP->PrivateArea.Comp_Status.dwInvalid)
         || (lpImcP->iImeState != CST_INIT)) {
            lpImcP->iImeState = CST_INIT;

            ClearCand(lpIMC);
            lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CLOSE_CANDIDATE) &
                ~(MSG_OPEN_CANDIDATE);

            if(!(lpImcP->PrivateArea.Comp_Status.dwSTLX)) {
                lpCompStr->dwCompReadStrLen = lpCompStr->dwCompStrLen =
                lpCompStr->dwDeltaStart = lpCompStr->dwCursorPos;

                Finalize(lpIMC, lpCompStr, lpImcP, TEXT('\b'));
                lpImcP->PrivateArea.Comp_Status.dwInvalid = 0;
            }
            return;
      }

      lpImcP->iImeState = CST_INIT;
      if (lpImcP->fdwImeMsg & MSG_ALREADY_START) {
          InitCompStr(lpCompStr);
          lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_END_COMPOSITION)
                              & ~(MSG_START_COMPOSITION);
          return;
      }
    }

#ifdef EUDC
    if (lpIMC->fdwConversion & IME_CMODE_EUDC) {
    }else{
#endif     //EUDC
    // chang candidate by backspace
    if (MBIndex.IMEChara[0].IC_TS) {
        lpImcP->fdwImeMsg =
            (lpImcP->fdwImeMsg | MSG_OPEN_CANDIDATE | MSG_CHANGE_CANDIDATE) &
            ~(MSG_CLOSE_CANDIDATE);
    } else {
        if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
            lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CLOSE_CANDIDATE) &
                                ~(MSG_OPEN_CANDIDATE);
        }
    }
#ifdef EUDC
    }
#endif//EUDC
    // reading string is composition string for some simple IMEs
    // delta start is the same as cursor position for backspace
    lpCompStr->dwCompReadStrLen = lpCompStr->dwCompStrLen =
        lpCompStr->dwDeltaStart = lpCompStr->dwCursorPos;

    Finalize(lpIMC, lpCompStr, lpImcP, TEXT('\b'));
    return;
}

/**********************************************************************/
/* CompStrInfo()                                                      */
/**********************************************************************/
void PASCAL CompStrInfo(
    LPCOMPOSITIONSTRING lpCompStr,
    LPPRIVCONTEXT       lpImcP,
    LPGUIDELINE         lpGuideLine,
    WORD                wCharCode)
{
    register DWORD dwCursorPos;

    // multicode
    if(lpImcP->PrivateArea.Comp_Status.dwSTMULCODE) {
        InitCompStr(lpCompStr);
    }
    //
    dwCursorPos = lpCompStr->dwCursorPos;

    // dwCrusorPos limit

    if (dwCursorPos >= MBIndex.MBDesc[0].wMaxCodes) {
        // exceed the max input key limitation
        lpGuideLine->dwLevel = GL_LEVEL_ERROR;
        lpGuideLine->dwIndex = GL_ID_TOOMANYSTROKE;

        lpImcP->fdwImeMsg |= MSG_GUIDELINE;
        MessageBeep(0xFFFFFFFF);
        return;
    }


    // set MSG_START_COMPOSITION
    if (!(lpImcP->fdwImeMsg & MSG_ALREADY_START)) {
        lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_START_COMPOSITION) &
              ~(MSG_END_COMPOSITION);
    }

    if (lpImcP->iImeState == CST_INIT) {
    }


    // composition/reading string - UsedCode(Full Shape)
    lpImcP->dwCompChar = (DWORD)wCharCode;

    // set reading string for lpCompStr
    *((LPUNAWORD)((LPBYTE)lpCompStr + lpCompStr->dwCompReadStrOffset +
        dwCursorPos*sizeof(TCHAR))) = (BYTE)lpImcP->dwCompChar;

    // composition/reading attribute - IME has converted these chars
    *((LPUNAWORD)((LPBYTE)lpCompStr + lpCompStr->dwCompReadAttrOffset +
        dwCursorPos*sizeof(TCHAR))) = ((ATTR_TARGET_CONVERTED << 8)|ATTR_TARGET_CONVERTED);

    // set reading string lenght for lpCompStr
    if (lpCompStr->dwCompReadStrLen <= dwCursorPos) {
        lpCompStr->dwCompReadStrLen += sizeof(BYTE);
    }

    // composition string is reading string for some simple IMEs
    lpCompStr->dwCompStrLen = lpCompStr->dwCompReadStrLen;

    // composition/reading attribute length is equal to reading string length
    lpCompStr->dwCompReadAttrLen = lpCompStr->dwCompReadStrLen;
    lpCompStr->dwCompAttrLen = lpCompStr->dwCompStrLen;

    // delta start from previous cursor position
    lpCompStr->dwDeltaStart = lpCompStr->dwCursorPos;

    // set new cursor with next to the composition string
    lpCompStr->dwCursorPos = lpCompStr->dwCompStrLen;

    // tell app, there is a composition char generated
    lpImcP->fdwImeMsg |= MSG_COMPOSITION;

    // set lpImeP->fdwGcsFlag
    lpImcP->fdwGcsFlag |= GCS_COMPREAD|GCS_COMP|GCS_CURSORPOS|GCS_DELTASTART;

    return;
}

/**********************************************************************/
/* Finalize()                                                         */
/* Return vlaue                                                       */
/*      Engine Flag                                                   */
/* Description:                                                       */
/*      Call Engine finalize Chinese word(s) by searching table       */
/*      (Set lpCompStr and lpCandList)                                */
/*      Set lpImeP(iImeState, fdwImeMsg, fdwGcsFlag)                  */
/**********************************************************************/
UINT PASCAL Finalize(
    LPINPUTCONTEXT      lpIMC,
    LPCOMPOSITIONSTRING lpCompStr,
    LPPRIVCONTEXT       lpImcP,
    WORD                wCharCode)
{
    LPCANDIDATEINFO lpCandInfo;
    LPCANDIDATELIST lpCandList;
    UINT            fEngine;

    if (!lpIMC->hCandInfo) {
        return (0);
    }

    // get lpCandInfo
    lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo);

    if (!lpCandInfo) {
        return (0);
    }

    // get lpCandList and init dwCount & dwSelection
    lpCandList = (LPCANDIDATELIST)
        ((LPBYTE)lpCandInfo + lpCandInfo->dwOffset[0]);
    lpCandList->dwCount = 0;
    lpCandList->dwSelection = 0;

    // search the IME tables
    fEngine =Engine(lpCompStr, lpCandList, lpImcP, lpIMC, wCharCode);

    if (fEngine == ENGINE_COMP) {
        lpCandInfo->dwCount  = 1;

        if(lpCandList->dwCount == 0) {
            MessageBeep((UINT)-1);
            lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CLOSE_CANDIDATE) &
                ~(MSG_OPEN_CANDIDATE);
            ImmUnlockIMCC(lpIMC->hCandInfo);
            return (fEngine);
        } else {
            // open composition candidate UI window for the string(s)
            if ((MBIndex.IMEChara[0].IC_TS)
               || (lpImcP->PrivateArea.Comp_Status.dwSTMULCODE)) {
                if ((lpImcP->fdwImeMsg & (MSG_ALREADY_OPEN|MSG_CLOSE_CANDIDATE)) ==
                    (MSG_ALREADY_OPEN|MSG_CLOSE_CANDIDATE)) {
                    lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CHANGE_CANDIDATE) &
                        ~(MSG_CLOSE_CANDIDATE);
                } else if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
                    lpImcP->fdwImeMsg |= MSG_CHANGE_CANDIDATE;
                } else {
                    lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_OPEN_CANDIDATE) &
                        ~(MSG_CLOSE_CANDIDATE);
                }
            } else {
                if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
                    lpImcP->fdwImeMsg =
                        (lpImcP->fdwImeMsg | MSG_CLOSE_CANDIDATE) &
                        ~(MSG_OPEN_CANDIDATE);
                }
            }

        }

        if (lpImcP->fdwImeMsg & MSG_ALREADY_START) {
            lpImcP->fdwImeMsg |= MSG_COMPOSITION;
        }
    } else if (fEngine == ENGINE_ASCII) {
    } else if (fEngine == ENGINE_RESAULT) {

        // Set lpImep!   and tell application, there is a reslut string
        lpImcP->fdwImeMsg |= MSG_COMPOSITION;
        lpImcP->dwCompChar = (DWORD) 0;
        lpImcP->fdwGcsFlag |= GCS_COMPREAD|GCS_COMP|GCS_CURSORPOS|
            GCS_DELTASTART|GCS_RESULTREAD|GCS_RESULT;

        if(!(MBIndex.IMEChara[0].IC_LX)
        || !(lpImcP->PrivateArea.Comp_Status.dwSTLX)) {
            if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
                lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CLOSE_CANDIDATE) &
                    ~(MSG_OPEN_CANDIDATE);
            }
            // clear  candidate now
            lpCandList->dwCount = 0;
            // set iImeState with CST_INIT
            lpImcP->iImeState = CST_INIT;
        } else {
            if ((MBIndex.IMEChara[0].IC_TS)
               || (lpImcP->PrivateArea.Comp_Status.dwSTLX)) {
                if ((lpImcP->fdwImeMsg & (MSG_ALREADY_OPEN|MSG_CLOSE_CANDIDATE)) ==
                    (MSG_ALREADY_OPEN|MSG_CLOSE_CANDIDATE)) {
                    lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CHANGE_CANDIDATE) &
                        ~(MSG_CLOSE_CANDIDATE);
                } else if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
                    lpImcP->fdwImeMsg |= MSG_CHANGE_CANDIDATE;
                } else {
                    lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_OPEN_CANDIDATE) &
                        ~(MSG_CLOSE_CANDIDATE);
                }
                lpImcP->iImeState = CST_INIT;
            } else {
            }
        }

    } else if (fEngine == ENGINE_CHCAND) {
    } else if (fEngine == ENGINE_MULTISEL) {
    } else if (fEngine == ENGINE_ESC) {
    } else if (fEngine == ENGINE_BKSPC) {
    } else {
    }

    ImmUnlockIMCC(lpIMC->hCandInfo);

    return fEngine;
}

/**********************************************************************/
/* CompWord()                                                         */
/**********************************************************************/
void PASCAL CompWord(           // compose the Chinese word(s) according to
                                // input key
    WORD                wCharCode,
    LPINPUTCONTEXT      lpIMC,
    LPCOMPOSITIONSTRING lpCompStr,
    LPPRIVCONTEXT       lpImcP,
    LPGUIDELINE         lpGuideLine)
{

    // lpComStr=NULL?
    if (!lpCompStr) {
        MessageBeep((UINT)-1);
        return;
    }

    // escape key
    if ((wCharCode == VK_ESCAPE) || (wCharCode == 0x0d)) {
        lpImcP->iImeState = CST_INIT;
        CompEscapeKey(lpIMC, lpCompStr, lpGuideLine, lpImcP);
        return;
    }

    // GuideLine
    if (!lpGuideLine) {
    } else if (lpGuideLine->dwLevel == GL_LEVEL_NOGUIDELINE) {
        lpGuideLine->dwStrLen = 0;
    } else {
        // previous input error cause us trancate some chars
        if (lpGuideLine->dwLevel == GL_LEVEL_ERROR) {
            lpCompStr->dwCompReadStrLen = lpCompStr->dwCompStrLen =
                lpCompStr->dwCursorPos;
            lpCompStr->dwCompReadAttrLen = lpCompStr->dwCompReadStrLen;
            lpCompStr->dwCompAttrLen = lpCompStr->dwCompStrLen;
        }
        lpGuideLine->dwLevel = GL_LEVEL_NOGUIDELINE;
        lpGuideLine->dwIndex = GL_ID_UNKNOWN;
        lpGuideLine->dwStrLen = 0;

        lpImcP->fdwImeMsg |= MSG_GUIDELINE;
    }

    // backspace key
    if (wCharCode == TEXT('\b')) {
        CompBackSpaceKey(lpIMC, lpCompStr, lpImcP);
        return;
    }


    lpImcP->iImeState = CST_INPUT;
    if(wCharCode == TEXT(' ')) {
#ifdef EUDC
    }else if( lpIMC->fdwConversion & IME_CMODE_EUDC && lpCompStr->dwCompReadStrLen >= EUDC_MAX_READING ){
        MessageBeep((UINT)-1);
#endif //EUDC
    } else {
        // build up composition string info
        CompStrInfo(lpCompStr, lpImcP, lpGuideLine, wCharCode);
    }
#ifdef EUDC
    if (lpIMC->fdwConversion & IME_CMODE_EUDC) {
        if (lpCompStr->dwCompReadStrLen >= lpImeL->nMaxKey
         || lpCompStr->dwCompReadStrLen >= EUDC_MAX_READING
         || wCharCode == TEXT(' ')) {
            lpImcP->fdwImeMsg |= MSG_COMPOSITION;
            lpImcP->fdwGcsFlag |= GCS_RESULTREAD|GCS_RESULTSTR;
        }
    } else
#endif //EUDC
    Finalize(lpIMC, lpCompStr, lpImcP, wCharCode);    // compsition

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntime\chcand.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    CHCAND.C
    
++*/

#include <windows.h>
#include <immdev.h>
#include <imedefs.h>

/**********************************************************************/
/* SelectOneCand()                                                    */
/**********************************************************************/
void PASCAL SelectOneCand(
    LPINPUTCONTEXT      lpIMC,
    LPCOMPOSITIONSTRING lpCompStr,
    LPPRIVCONTEXT       lpImcP,
    LPCANDIDATELIST     lpCandList)
{
    if (!lpCompStr) {
        MessageBeep((UINT)-1);
        return;
    }

    if (!lpImcP) {
        MessageBeep((UINT)-1);
        return;
    }

    InitCompStr(lpCompStr);

    // online create word
    if(lpImcP->PrivateArea.Comp_Status.OnLineCreWord) {
           UINT i, j;
        
           for(i=lstrlen(CWDBCSStr), j=0; i<MAXINPUTWORD; i++, j++) {
            CWDBCSStr[i] = lpImcP->PrivateArea.Comp_Context.CKBBuf[j];
        }
    }

    // calculate result string length
    if(MBIndex.IMEChara[0].IC_INSSPC) {
        int i,j, ilen;

        ilen = lstrlen(lpImcP->PrivateArea.Comp_Context.CKBBuf);
        lpImcP->PrivateArea.Comp_Context.CKBBuf[ilen + ilen/2] = 0;
        for(i = ilen, j=3*ilen/2; i>2; i-=2, j-=3) {
            lpImcP->PrivateArea.Comp_Context.CKBBuf[j-1] = 0x20;
            lpImcP->PrivateArea.Comp_Context.CKBBuf[j-2] =
                lpImcP->PrivateArea.Comp_Context.CKBBuf[i-1];
            lpImcP->PrivateArea.Comp_Context.CKBBuf[j-3] =
                lpImcP->PrivateArea.Comp_Context.CKBBuf[i-2];
        }
        lpImcP->PrivateArea.Comp_Context.CKBBuf[i] = 0x20;
    }
    lstrcpy((LPTSTR)((LPBYTE)lpCompStr + lpCompStr->dwResultStrOffset),
           (LPTSTR)lpImcP->PrivateArea.Comp_Context.CKBBuf);

    // calculate result string length
    lpCompStr->dwResultStrLen =
           lstrlen(lpImcP->PrivateArea.Comp_Context.CKBBuf);

    // tell application, there is a reslut string
    lpImcP->fdwImeMsg |= MSG_COMPOSITION;
    lpImcP->dwCompChar = (DWORD) 0;
    lpImcP->fdwGcsFlag |= GCS_COMPREAD|GCS_COMP|GCS_CURSORPOS|
        GCS_DELTASTART|GCS_RESULTREAD|GCS_RESULT;

    lpImcP->iImeState = CST_INIT;

    if(!(MBIndex.IMEChara[0].IC_LX)
     ||!(lpImcP->PrivateArea.Comp_Status.dwSTLX)) {
        if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
            lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CLOSE_CANDIDATE) &
                ~(MSG_OPEN_CANDIDATE);
        }

        // no candidate now, the right candidate string already be finalized
        lpCandList->dwCount = 0;
        lpCandList->dwSelection = 0;
    } else {
        // chang candidate by LX state
        lpImcP->fdwImeMsg =
            (lpImcP->fdwImeMsg | MSG_OPEN_CANDIDATE | MSG_CHANGE_CANDIDATE) &
            ~(MSG_CLOSE_CANDIDATE);
        lpCandList->dwSelection = 0;
    }

#ifdef CROSSREF
    if (!CrossReverseConv(lpIMC, lpCompStr, lpImcP, lpCandList))
        // CHP
        // No refence code, not a fussy char
#ifdef FUSSYMODE
        MBIndex.IsFussyCharFlag =0;
#endif FUSSYMODE
#endif

    return;
}

/**********************************************************************/
/* CandEscapeKey()                                                    */
/**********************************************************************/
void PASCAL CandEscapeKey(
    LPINPUTCONTEXT  lpIMC,
    LPPRIVCONTEXT   lpImcP)
{
    LPCOMPOSITIONSTRING lpCompStr;
    LPGUIDELINE         lpGuideLine;

    // clean all candidate information
    if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
        ClearCand(lpIMC);
        lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CLOSE_CANDIDATE) &
            ~(MSG_OPEN_CANDIDATE);
    }

    // if it start composition, we need to clean composition
    if (!(lpImcP->fdwImeMsg & MSG_ALREADY_START)) {
        return;
    }

    lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
    if(!lpCompStr){
        return;
    }
    lpGuideLine = (LPGUIDELINE)ImmLockIMCC(lpIMC->hGuideLine);
    if(!lpGuideLine){
        return;
    }

    CompEscapeKey(lpIMC, lpCompStr, lpGuideLine, lpImcP);

    ImmUnlockIMCC(lpIMC->hGuideLine);
    ImmUnlockIMCC(lpIMC->hCompStr);

    return;
}

/**********************************************************************/
/* ChooseCand()                                                       */
/**********************************************************************/
void PASCAL ChooseCand(         // choose one of candidate strings by
                                // input char
    WORD            wCharCode,
    LPINPUTCONTEXT  lpIMC,
    LPCANDIDATEINFO lpCandInfo,
    LPPRIVCONTEXT   lpImcP)
{
    LPCANDIDATELIST     lpCandList;
    LPCOMPOSITIONSTRING lpCompStr;

    if ((wCharCode == VK_ESCAPE)
       || (wCharCode == VK_RETURN)) {       // escape key or return key
        CandEscapeKey(lpIMC, lpImcP);
        return;
    }

    if (wCharCode == VK_NEXT) {      // next selection
        lpImcP->fdwImeMsg |= MSG_CHANGE_CANDIDATE;
        return;
    }

    if (wCharCode == VK_PRIOR) {      // previous selection
        lpImcP->fdwImeMsg |= MSG_CHANGE_CANDIDATE;
        return;
    }

    if (wCharCode == VK_HOME) {      // Home selection
        lpImcP->fdwImeMsg |= MSG_CHANGE_CANDIDATE;
        return;
    }

    if (wCharCode == VK_END) {      // End selection
        lpImcP->fdwImeMsg |= MSG_CHANGE_CANDIDATE;
        return;
    }

    if (!lpCandInfo) {
        MessageBeep((UINT)-1);
        return;
    }

    lpCandList = (LPCANDIDATELIST)
        ((LPBYTE)lpCandInfo + lpCandInfo->dwOffset[0]);

    if ((wCharCode >= TEXT('0')) && wCharCode <= TEXT('9')) {

        DWORD dwSelCand;

        dwSelCand = wCharCode - TEXT('0');
        if(wCharCode == TEXT('0')) {
            dwSelCand = 10;
        }

        if(!(MBIndex.IMEChara[0].IC_LX)
         ||!(lpImcP->PrivateArea.Comp_Status.dwSTLX)) {
            if ((lpCandList->dwSelection + dwSelCand) >
                lpCandList->dwCount) {
                // out of range
                return;
            }
        } else {
            if ((lpCandList->dwSelection + dwSelCand) >
                lpImcP->dwOldCandCnt) {
                // out of range
                return;
            }
        }

        lpCandList->dwSelection = lpCandList->dwSelection + dwSelCand;
        lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
        if(!lpCompStr){
            return;
        }


        // translate into translate buffer
        SelectOneCand(lpIMC, lpCompStr, lpImcP, lpCandList);
        ImmUnlockIMCC(lpIMC->hCompStr);

        return;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntgen\upimeres\upimeres.h ===
//DATA STRUCT USED IN icon resource
#define ERR_RES_INVALID_BMP		0x01
#define ERR_RES_INVALID_ICON	0x02
#define ERR_RES_INVALID_VER		0x04
#define ERR_RES_NO_BMP			0x10
#define ERR_RES_NO_ICON			0x20
#define ERR_RES_NO_VER			0x40
#define	ERR_CANNOT_UPRES		0x100
#define	ERR_INVALID_BMP_MSG				", "
#define ERR_INVALID_ICON_MSG			", "
#define ERR_NO_BMP_MSG					""
#define ERR_NO_ICON_MSG					""
#define ERR_CANNOT_UPRES_MSG			""
#define MSG_TITLE	""

#define BMPNAME		"CHINESE"
#define ICONNAME	"IMEICO"
#define DATANAME	"IMECHARAC"

//define in imedefs.h
//these are HACK CODES, and depends on imedefs.h
//this code come from debug, don't change it
#define STR_ID			54			

//according to the file size check if it is a 20*20 bmp
#define BMP_20_SIZE		358
	
typedef struct tagICONDIRENTRY{
	BYTE	bWidth;
	BYTE	bHeight;
	BYTE	bColorCount;
	BYTE	bReserved;
	WORD	wPlanes;
	WORD	wBitCount;
	DWORD	dwBytesInRes;
	DWORD	dwImageOffset;
}ICONDIRENTRY;
typedef struct ICONDIR{
	WORD	idReserved;
	WORD	idType;
	WORD	idCount;
	ICONDIRENTRY idEntries[1];
}ICONHEADER;


#define DEFAULT_CODEPAGE    1252
#define MAJOR_RESOURCE_VERSION  4
#define MINOR_RESOURCE_VERSION  0

#define MAXSTR      (256+1)

//
// An ID_WORD indicates the following WORD is an ordinal rather
// than a string
//

#define ID_WORD 0xffff

//typedef   WCHAR   *PWCHAR;

typedef struct MY_STRING {
    ULONG discriminant;       // long to make the rest of the struct aligned
    union u {
        struct {
          struct MY_STRING *pnext;
          ULONG  ulOffsetToString;
          USHORT cbD;
          USHORT cb;
          WCHAR  *sz;
        } ss;
        WORD     Ordinal;
    } uu;
} SDATA, *PSDATA, **PPSDATA;

#define IS_STRING 1
#define IS_ID     2

// defines to make deferencing easier
#define OffsetToString uu.ss.ulOffsetToString
#define cbData         uu.ss.cbD
#define cbsz           uu.ss.cb
//v-guanx 95.09.06 to avoid conflict with zhongyi
#define szStr          uu.ss.sz
//define szStrUU          uu.ss.sz

typedef struct _RESNAME {
        struct _RESNAME *pnext; // The first three fields should be the
        PSDATA Name;        // same in both res structures
        ULONG   OffsetToData;

        PSDATA  Type;
    ULONG   SectionNumber;
        struct _RESNAME *pnextRes;
        ULONG   DataSize;
        ULONG   OffsetToDataEntry;
        USHORT  ResourceNumber;
        USHORT  NumberOfLanguages;
        WORD    LanguageId;
} RESNAME, *PRESNAME, **PPRESNAME;

typedef struct _RESTYPE {
        struct _RESTYPE *pnext; // The first three fields should be the
        PSDATA Type;        // same in both res structures
        ULONG   OffsetToData;

        struct _RESNAME *NameHeadID;
        struct _RESNAME *NameHeadName;
        ULONG  NumberOfNamesID;
        ULONG  NumberOfNamesName;
} RESTYPE, *PRESTYPE, **PPRESTYPE;

typedef struct _UPDATEDATA {
        ULONG   cbStringTable;
        PSDATA  StringHead;
        PRESNAME    ResHead;
        PRESTYPE    ResTypeHeadID;
        PRESTYPE    ResTypeHeadName;
        LONG    Status;
        HANDLE  hFileName;
} UPDATEDATA, *PUPDATEDATA;

//
// Round up a byte count to a power of 2:
//
#define ROUNDUP(cbin, align) (((cbin) + (align) - 1) & ~((DWORD)(align) - 1))

//
// Return the remainder, given a byte count and a power of 2:
//
#define REMAINDER(cbin,align) (((align)-((cbin)&((align)-1)))&((align)-1))

#define CBLONG      (sizeof(LONG))
#define BUFSIZE     (4L * 1024L)

//VERSION INFO related definitions
//these are HACK CODES
#define VER_ROOT			0
#define VER_STR_INFO		1
#define VER_LANG			2
#define VER_COMP_NAME		3
#define VER_FILE_DES		4
#define VER_FILE_VER		5
#define VER_INTL_NAME		6
#define VER_LEGAL_CR		7
#define VER_ORG_FILE_NAME	8
#define VER_PRD_NAME		9
#define VER_PRD_VER			10
#define VER_VAR_FILE_INFO	11
#define VER_TRANS			12

#define VER_BLOCK_NUM		13
#define VER_HEAD_LEN		0x98
#define VER_TAIL_LEN		0x44
#define VER_STR_INFO_OFF	0x5c
#define VER_LANG_OFF		0x80
#define VER_VAR_FILE_INFO_OFF 0x2c0

typedef struct tagVERDATA{
	WORD		cbBlock;
	WORD		cbValue;
	WORD		wKeyOffset;
	WORD		wKeyNameSize;
	BOOL		fUpdate;	//need update flag		
}VERDATA;


LONG
AddResource(
    PSDATA Type,
    PSDATA Name,
    WORD Language,
    PUPDATEDATA pupd,
    PVOID lpData,
    ULONG cb
    );

PSDATA
AddStringOrID(
    LPCTSTR     lp,
    PUPDATEDATA pupd
    );
    
LONG
WriteResFile(
    HANDLE  hUpdate, 
    char    *pDstname);

VOID
FreeData(
    PUPDATEDATA pUpd
    );

PRESNAME
WriteResSection(
    PUPDATEDATA pUpdate,
    INT outfh,
    ULONG align,
    ULONG cbLeft,
    PRESNAME    pResSave
    );
BOOL
EnumTypesFunc(
    HANDLE hModule,
    LPTSTR lpType,
    LONG lParam
    );
BOOL
EnumNamesFunc(
    HANDLE hModule,
    LPTSTR lpType,
    LPTSTR lpName,
    LONG lParam
    );
BOOL
EnumLangsFunc(
    HANDLE hModule,
    LPTSTR lpType,
    LPTSTR lpName,
    WORD language,
    LONG lParam
    );
HANDLE BeginUpdateResourceEx(LPCTSTR,BOOL);

BOOL UpdateResourceEx(HANDLE,LPCTSTR, LPCTSTR, WORD, LPVOID, DWORD);

BOOL EndUpdateResourceEx(HANDLE, BOOL);


/*explaination of parameters
LPCTSTR	pszImeDesName,		//destination IME file name
LPCTSTR	pszImeBmpName,		//Bitmap file name
LPCTSTR	pszImeIconName,		//Icon file name
LPCTSTR	pszImeVerInfo,		//version infomation string
LPCTSTR pszImeDevCorpName,	//Ime inventer corp/person name
WORD	wImeData			//Ime initial data
*/
BOOL ImeUpdateRes(LPCTSTR,LPCTSTR,LPCTSTR,LPCTSTR,LPCTSTR ,WORD);

long MakeVerInfo(LPCTSTR,LPCTSTR,LPCTSTR,BYTE *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntime\eng.h ===
/*************************************************
 *  eng.h                                        *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

// IME designer can change this file according to each IME


//#define MAX_LEN             52
#define BOX_UI                0
#define LIN_UI                1
#define MaxTabNum             40
#define MAXSTRLEN             128
#define MAXCAND               256
#define IME_MAXCAND           10
#define MAXCODE               12
#define MAXINPUTWORD          40
#define MAXNUMBER_EMB         1222   // there are at most 1222 EUDC chars. 1000


typedef struct tagCOMPPROC {
    int dwUDicQStartPos;
    int dwUDicQEndPos;
    int dwUDicQCStartPos;
    int dwUDicQCEndPos;
    int dBDicStartPos;
    int dBDicEndPos;
    int dBDicCStartPos;
    int dBDicCEndPos;
    int dBDicMCSPos;
} COMPPROC ;


typedef struct tagCOMPCONTEXT {
    TCHAR szInBuffer[MAXCODE];
    TCHAR szSelectBuffer[3000];
    BYTE  PromptCnt;
    BYTE  ResultStrCnt;
    TCHAR CKBBuf[130];
    BYTE  LxStrCnt;
    TCHAR szLxBuffer[130];
    BYTE  Candi_Cnt;
    BYTE  Candi_Pos[IME_MAXCAND];
} COMPCONTEXT;



typedef struct tagCOMPSTATUS {
    DWORD dwPPTLX;
    DWORD dwPPTS;
    DWORD dwPPTBD;
    DWORD dwPPTFH;
    DWORD dwSTLX;
    DWORD dwSTMULCODE;
    DWORD dwPPCZ;
    DWORD dwPPCTS;
    DWORD OnLineCreWord;
    DWORD dwInvalid    ;
    DWORD dwTraceCusr;
    DWORD dwSpace;
    DWORD dwEnter;
    
} COMPSTATUS;

typedef struct tagMB_Head {
    DWORD  Q_offset;
    DWORD  W_offset[48];
}MB_Head;


typedef struct tagEMB_Head     {
    TCHAR  W_Code[MAXCODE];
    TCHAR  C_Char[MAXINPUTWORD];
}EMB_Head;

//EMB_Head *LpEMB_Head;

typedef struct tagGOLBVAC {
    BYTE     ST_MUL_Cnt;
    BYTE     Page_Num;
    BYTE     Cur_MB;
    BYTE     EMB_Exist;
    WORD     EMB_Count;
    int      SBufPos;
    DWORD    Area_V_Lenth;
} GLOBVAC ;

typedef struct PRIVATEAREA {
    COMPPROC     Comp_Proc;
    COMPCONTEXT  Comp_Context;
    COMPSTATUS   Comp_Status;
    GLOBVAC      GlobVac;
    HANDLE       hMapMB;
    HANDLE       hMapEMB;
    HANDLE       hMbFile;
    HANDLE       hEmbFile;
} PRIVATEAREA;

typedef PRIVATEAREA *LPPRIVATEAREA;
LPPRIVATEAREA     lpPrivateArea;

typedef struct tagCONVERLIST {
    TCHAR szInBuffer[MAXCODE];
    TCHAR szSelectBuffer[5000];
    BYTE  Candi_Cnt;
    BYTE  Candi_Pos[100];
} CONVERLIST;

CONVERLIST ConverList;

typedef struct tagHMapStruc {
        TCHAR        MB_Name[40];
        int          RefCnt;
        TCHAR        MB_Obj[40];
        TCHAR        EMB_Obj[40];
        //HANDLE     hMapMB;
        //HANDLE     hMapEMB;
        DWORD        EMB_ID;
        HANDLE       hEmbFile;
        HANDLE       hMbFile;
} HMapStruc;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntime\crtword.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    CRTWORD.C
    
++*/

#include <windows.h>
#include <winerror.h>
#include <immdev.h>
#include <imedefs.h>

#ifdef UNICODE
#define NUMENCODEAREA   8
#else
#define NUMENCODEAREA   252
#endif

typedef struct  tagENCODEAREA {
     DWORD PreCount;   
     DWORD StartEncode;
     DWORD EndEncode;
} ENCODEAREA,FAR *LPENCODEAREA;
DWORD EncodeToXgbNo(LPTSTR, DWORD , DWORD, HANDLE );
BOOL ConvGetEncode(HANDLE ,LPENCODEAREA ,LPDWORD ,LPDWORD ,LPMAININDEX);

void ConvCreateWord(HWND hWnd,LPCTSTR MBFileName,LPTSTR szWordStr,LPTSTR lpCode)
{
   int          nWordLen=lstrlen(szWordStr)*sizeof(TCHAR)/2;
   DWORD        i,j,k,dwCodeLen;
   TCHAR        szDBCS[3],szCode[13];
   BOOL         bReturn=FALSE;
   HANDLE       hMBFile;
   DWORD        dwNumEncodeArea;
   DWORD        dwNumXgbEncodes;
   DESCRIPTION  Descript;
   HANDLE       hRuler0, hEncode;
   LPRULER      lpRuler;
   LPENCODEAREA lpEncode;
   MAININDEX    MainIndex[NUMTABLES];
   PSECURITY_ATTRIBUTES psa;

//   DWORD dwOffset=lpMainIndex[TAG_CRTWORDCODE-1].dwOffset; 

   lpCode[0] = 0;
   if(lstrlen(MBFileName)==0 || lstrlen(szWordStr) == 0)
    return;

   psa = CreateSecurityAttributes();

   hMBFile = CreateFile(MBFileName,GENERIC_READ,FILE_SHARE_READ,psa,OPEN_EXISTING,0,NULL);

   FreeSecurityAttributes(psa);

   if (hMBFile == (HANDLE)-1) { 
        FatalMessage(hWnd, IDS_ERROR_OPENFILE);
        return;
   }

   if(!ConvGetMainIndex(hWnd,hMBFile,MainIndex)) {
    CloseHandle(hMBFile);
    return;
   }

   ConvReadDescript(hMBFile,&Descript, MainIndex);

   if(Descript.wNumRulers == 0) {
    CloseHandle(hMBFile);
        return;
   }
   hRuler0 = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT,sizeof(RULER)*Descript.wNumRulers);
   if(!hRuler0) {
    CloseHandle(hMBFile);
    return;
   }
   hEncode = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT, sizeof(ENCODEAREA)*NUMENCODEAREA);
   if(!hEncode) {
    CloseHandle(hMBFile);
        GlobalFree(hRuler0);
        return;
   }

   if(!(lpRuler = GlobalLock(hRuler0)) )  {
    CloseHandle(hMBFile);
    GlobalFree(hRuler0);
        return;
   }

   ConvReadRuler(hMBFile,Descript.wNumRulers ,lpRuler, MainIndex);
   lpEncode = (LPENCODEAREA) GlobalLock(hEncode);
   if(!lpEncode){
    CloseHandle(hMBFile);
    GlobalFree(hRuler0);
        return;
   }

   ConvGetEncode(hMBFile, lpEncode, &dwNumXgbEncodes,
       &dwNumEncodeArea,MainIndex);


   for(i=0; i<Descript.wNumRulers; i++) 
     if( (lpRuler[i].byLogicOpra == 0 && nWordLen == lpRuler[i].byLength) 
       ||(lpRuler[i].byLogicOpra == 1 && nWordLen >= lpRuler[i].byLength)
       ||(lpRuler[i].byLogicOpra == 2 && nWordLen <= lpRuler[i].byLength) ) {

       int retCodeLen = 0;
         for(j=0; j<lpRuler[i].wNumCodeUnits; j++) {
           k = lpRuler[i].CodeUnit[j].wDBCSPosition;
           if(k > (DWORD)nWordLen) k = (DWORD)nWordLen;   
           if(lpRuler[i].CodeUnit[j].dwDirectMode == 0) 
                 lstrcpyn(szDBCS,&szWordStr[2*(k-1)/sizeof(TCHAR)],2/sizeof(TCHAR)+1);
           else
                 lstrcpyn(szDBCS,&szWordStr[2*(nWordLen-k)/sizeof(TCHAR)],2/sizeof(TCHAR)+1);
            szDBCS[2/sizeof(TCHAR)] = 0;
           k = EncodeToXgbNo(szDBCS, dwNumEncodeArea,dwNumXgbEncodes,hEncode);
           if((long)k < 0 || k > dwNumXgbEncodes) {
               lpCode[j] = (j > 0)?lpCode[j-1]:Descript.szUsedCode[0];
                       lpCode[j+1] = 0;
           }
           else
           {
               SetFilePointer(hMBFile,MainIndex[TAG_CRTWORDCODE-1].dwOffset+Descript.wMaxCodes*k*sizeof(TCHAR),
                     0,FILE_BEGIN);
               ReadFile(hMBFile,szCode,Descript.wMaxCodes*sizeof(TCHAR),&k,NULL);
               szCode[Descript.wMaxCodes] = 0;
               dwCodeLen = lstrlen(szCode);
               k = lpRuler[i].CodeUnit[j].wCodePosition;
               if(k > dwCodeLen) k = dwCodeLen;
               if(k == 0) {
                   if(retCodeLen + dwCodeLen > Descript.wMaxCodes)
                        szCode[Descript.wMaxCodes - retCodeLen] = 0;
                   lstrcat(lpCode,szCode);
               }
               else {
                   if(k > dwCodeLen) k = dwCodeLen;
                    lpCode[j] = (szCode[k-1] == 0)?((k > 1)? szCode[k-2]:Descript.szUsedCode[0]):szCode[k-1];
                    lpCode[j+1] = 0;
               }
               retCodeLen = lstrlen(lpCode);
           }
       }
       bReturn = TRUE;
       break;
    }

    CloseHandle(hMBFile);
    GlobalFree(hRuler0);
    return;
}


BOOL ConvGetMainIndex(HANDLE hWnd, HANDLE hMBFile, LPMAININDEX lpMainIndex)
{
  DWORD dwBytes;
  int i;
  BOOL  retVal;

  if(SetFilePointer(hMBFile,ID_LENGTH,0,FILE_BEGIN) != ID_LENGTH)
       return FALSE;
  retVal = ReadFile(hMBFile,lpMainIndex,sizeof(MAININDEX)*NUMTABLES,&dwBytes,NULL);

  if  (retVal == FALSE )
      return retVal;

  if(dwBytes < sizeof(MAININDEX)*NUMTABLES ) {
       return FALSE;
  }
  else
       return TRUE;
  for(i=0; i<NUMTABLES; i++) {
     dwBytes = lpMainIndex[i].dwTag+
               lpMainIndex[i].dwOffset+
               lpMainIndex[i].dwLength;
     if(lpMainIndex[i].dwCheckSum != dwBytes) {
         return FALSE;
     }
  }
}

#ifdef IDEBUG

extern void  OutputDbgWord(  );

#endif

BOOL ConvReadDescript(HANDLE hMBFile, 
                      LPDESCRIPTION lpDescript,
                      LPMAININDEX lpMainIndex)
//*** read description from .MB file ****
{
  DWORD dwBytes;
  BOOL  retVal;
  DWORD dwOffset = lpMainIndex[TAG_DESCRIPTION-1].dwOffset;
  if(SetFilePointer(hMBFile,dwOffset,0,FILE_BEGIN) != dwOffset)
       return FALSE;

  retVal = ReadFile(hMBFile,lpDescript,sizeof(DESCRIPTION),&dwBytes,NULL);

  if ( retVal == FALSE )
      return retVal;

#ifdef IDEBUG
{

  DWORD  dwtmp;

  OutputDebugString(L"Under ConvReadDescript\n");

  OutputDebugString(L"dwBytes=");
  OutputDbgWord(dwBytes);
  OutputDebugString(L"Sizeof(MBDESC)=");
  dwtmp = (DWORD)sizeof(MBDESC);
  OutputDbgWord(dwtmp);
  OutputDebugString(L"\n");

  OutputDebugString(L"szName=");
  OutputDebugString(lpDescript->szName);
  OutputDebugString(L"\n");

  OutputDebugString(L"wMaxCodes=");
  dwtmp = (DWORD)(lpDescript->wMaxCodes);
  OutputDbgWord( dwtmp );
  OutputDebugString(L"\n");

  OutputDebugString(L"wNumCodes=");
  dwtmp = (DWORD)(lpDescript->wNumCodes);
  OutputDbgWord(dwtmp);
  OutputDebugString(L"\n");

  OutputDebugString(L"byMaxElement=");
  dwtmp = (DWORD)(lpDescript->byMaxElement) & 0x0000000f;
  OutputDbgWord(dwtmp);
  OutputDebugString(L"\n");

  OutputDebugString(L"cWildChar=");
  dwtmp = (DWORD)(lpDescript->cWildChar);
  OutputDbgWord( dwtmp );
  OutputDebugString(L"\n");

  OutputDebugString(L"wNumRulers=");
  dwtmp = (DWORD)(lpDescript->wNumRulers);
  OutputDbgWord( dwtmp );
  OutputDebugString(L"\n");

}

#endif

  if(dwBytes < sizeof(DESCRIPTION) )
       return FALSE;
  else
       return TRUE;
}

BOOL ConvReadRuler(HANDLE hMBFile, 
                   int  nRulerNum,
                   LPRULER lpRuler,
                   LPMAININDEX lpMainIndex)
//*** read create word ruler from .MB file ****
{
  DWORD dwBytes;
  BOOL  retVal;
  DWORD dwOffset = lpMainIndex[TAG_RULER-1].dwOffset;

  if(SetFilePointer(hMBFile,dwOffset,0,FILE_BEGIN) != dwOffset)
       return FALSE;
  retVal = ReadFile(hMBFile,lpRuler,nRulerNum*sizeof(RULER),&dwBytes,NULL);
  
  if ( retVal == FALSE )
      return retVal;

  if(dwBytes < nRulerNum*sizeof(RULER) )
       return FALSE;
  else
       return TRUE;
}

BOOL ConvGetEncode(HANDLE hMBFile, 
                      LPENCODEAREA lpEncode,
                      LPDWORD fdwNumSWords,
                      LPDWORD fdwNumEncodeArea,
                      LPMAININDEX lpMainIndex)
{
  DWORD dwBytes;
  BOOL  retVal;

  DWORD dwOffset=lpMainIndex[TAG_INTERCODE-1].dwOffset; 
  if(SetFilePointer(hMBFile,dwOffset,0,FILE_BEGIN) != dwOffset)
      return FALSE;

  retVal = ReadFile(hMBFile,fdwNumSWords,4,&dwBytes,NULL);

  if ( retVal == FALSE )
      return retVal;

  retVal = ReadFile(hMBFile,fdwNumEncodeArea,4,&dwBytes,NULL);
  if ( retVal == FALSE )
      return retVal;

  retVal = ReadFile(hMBFile,lpEncode,
            lpMainIndex[TAG_INTERCODE-1].dwLength,&dwBytes,NULL);
  if ( retVal == FALSE )
      return retVal;

  if(dwBytes < lpMainIndex[TAG_INTERCODE-1].dwLength)
      return FALSE;
  else
      return TRUE;
}

DWORD EncodeToXgbNo(LPTSTR szDBCS,
                    DWORD dwNumEncodeArea,
                    DWORD dwNumXgbEncodes,
                    HANDLE hEncode)
{
    LPENCODEAREA lpEncode;
    WORD wCode;
    DWORD dwNo = 0xffffffff, i;
    
#ifdef UNICODE
    wCode = szDBCS[0];
#else
    wCode = (WORD)((UCHAR)szDBCS[0])*256 + (WORD)(UCHAR)szDBCS[1];
#endif

    lpEncode = (LPENCODEAREA) GlobalLock(hEncode);
    if(!lpEncode){
        return dwNo;
    }
    for( i = dwNumEncodeArea -1; (long)i>=0; i--) {
       if(wCode >= lpEncode[i].StartEncode) {
           dwNo = lpEncode[i].PreCount;
           dwNo += wCode - lpEncode[i].StartEncode;
           break;
       }
    }
    if(dwNo > dwNumXgbEncodes )
        dwNo = 0xffffffff;
    GlobalUnlock(hEncode);

    return dwNo;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntime\compui.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    COMPUI.C
    
++*/

#include <windows.h>
#include <immdev.h>
#include "imedefs.h"
#include <regstr.h>

/**********************************************************************/
/* GetCompWnd                                                         */
/* Return Value :                                                     */
/*      window handle of composition                                  */
/**********************************************************************/

HWND PASCAL GetCompWnd(
    HWND hUIWnd)                // UI window
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;
    HWND     hCompWnd;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {          // can not darw candidate window
        return (HWND)NULL;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw candidate window
        return (HWND)NULL;
    }

    hCompWnd = lpUIPrivate->hCompWnd;

    GlobalUnlock(hUIPrivate);

    return (hCompWnd);
}

/**********************************************************************/
/* FitInLazyOperation()                                               */
/* Return Value :                                                     */
/*      TRUE or FALSE                                                 */
/**********************************************************************/
BOOL PASCAL FitInLazyOperation( // fit in lazy operation or not
#if defined(UNIIME)
    LPIMEL  lpImeL,
#endif
    LPPOINT lpptOrg,
    LPPOINT lpptNearCaret,      // the suggested near caret position
    LPRECT  lprcInputRect,
    UINT    uEsc)
{
    POINT ptDelta, ptTol;
    RECT  rcUIRect, rcInterRect;

    ptDelta.x = lpptOrg->x - lpptNearCaret->x;

    ptDelta.x = (ptDelta.x >= 0) ? ptDelta.x : -ptDelta.x;

    ptTol.x = sImeG.iParaTol * ncUIEsc[uEsc].iParaFacX +
        sImeG.iPerpTol * ncUIEsc[uEsc].iPerpFacX;

    ptTol.x = (ptTol.x >= 0) ? ptTol.x : -ptTol.x;

    if (ptDelta.x > ptTol.x) {
        return (FALSE);
    }

    ptDelta.y = lpptOrg->y - lpptNearCaret->y;

    ptDelta.y = (ptDelta.y >= 0) ? ptDelta.y : -ptDelta.y;

    ptTol.y = sImeG.iParaTol * ncUIEsc[uEsc].iParaFacY +
        sImeG.iPerpTol * ncUIEsc[uEsc].iPerpFacY;

    ptTol.y = (ptTol.y >= 0) ? ptTol.y : -ptTol.y;

    if (ptDelta.y > ptTol.y) {
        return (FALSE);
    }

    // build up the UI rectangle (composition window)
    rcUIRect.left = lpptOrg->x;
    rcUIRect.top = lpptOrg->y;
    rcUIRect.right = rcUIRect.left + lpImeL->xCompWi;
    rcUIRect.bottom = rcUIRect.top + lpImeL->yCompHi;

    if (IntersectRect(&rcInterRect, &rcUIRect, lprcInputRect)) {
        return (FALSE);
    }

    return (TRUE);
}

/**********************************************************************/
/* GetNearCaretPosition()                                             */
/**********************************************************************/
void PASCAL GetNearCaretPosition(   // decide a near caret position according
                                    // to the caret position
#if defined(UNIIME)
    LPIMEL  lpImeL,
#endif
    LPPOINT lpptFont,
    UINT    uEsc,
    UINT    uRot,
    LPPOINT lpptCaret,
    LPPOINT lpptNearCaret,
    BOOL    fFlags)
{
    LONG lFontSize;
    LONG xWidthUI, yHeightUI, xBorder, yBorder;
    RECT rcWorkArea;

    if ((uEsc + uRot) & 0x0001) {
        lFontSize = lpptFont->x;
    } else {
        lFontSize = lpptFont->y;
    }

    xWidthUI = lpImeL->xCompWi;
    yHeightUI = lpImeL->yCompHi;
    xBorder = lpImeL->cxCompBorder;
    yBorder = lpImeL->cyCompBorder;

    if (fFlags & NEAR_CARET_FIRST_TIME) {
        lpptNearCaret->x = lpptCaret->x +
            lFontSize * ncUIEsc[uEsc].iLogFontFacX +
            sImeG.iPara * ncUIEsc[uEsc].iParaFacX +
            sImeG.iPerp * ncUIEsc[uEsc].iPerpFacX;

        if (ptInputEsc[uEsc].x >= 0) {
            lpptNearCaret->x += xBorder * 2;
        } else {
            lpptNearCaret->x -= xWidthUI - xBorder * 2;
        }

        lpptNearCaret->y = lpptCaret->y +
            lFontSize * ncUIEsc[uEsc].iLogFontFacY +
            sImeG.iPara * ncUIEsc[uEsc].iParaFacY +
            sImeG.iPerp * ncUIEsc[uEsc].iPerpFacY;

        if (ptInputEsc[uEsc].y >= 0) {
            lpptNearCaret->y += yBorder * 2;
        } else {
            lpptNearCaret->y -= yHeightUI - yBorder * 2;
        }
    } else {
        lpptNearCaret->x = lpptCaret->x +
            lFontSize * ncAltUIEsc[uEsc].iLogFontFacX +
            sImeG.iPara * ncAltUIEsc[uEsc].iParaFacX +
            sImeG.iPerp * ncAltUIEsc[uEsc].iPerpFacX;

        if (ptAltInputEsc[uEsc].x >= 0) {
            lpptNearCaret->x += xBorder * 2;
        } else {
            lpptNearCaret->x -= xWidthUI - xBorder * 2;
        }

        lpptNearCaret->y = lpptCaret->y +
            lFontSize * ncAltUIEsc[uEsc].iLogFontFacY +
            sImeG.iPara * ncAltUIEsc[uEsc].iParaFacY +
            sImeG.iPerp * ncAltUIEsc[uEsc].iPerpFacY;

        if (ptAltInputEsc[uEsc].y >= 0) {
            lpptNearCaret->y += yBorder * 2;
        } else {
            lpptNearCaret->y -= yHeightUI - yBorder * 2;
        }
    }

#if 1 // MultiMonitor
    rcWorkArea = ImeMonitorWorkAreaFromPoint(*lpptCaret);
#else
    rcWorkArea = rcWorkArea;
#endif

    if (lpptNearCaret->x < rcWorkArea.left) {
        lpptNearCaret->x = rcWorkArea.left;
    } else if (lpptNearCaret->x + xWidthUI > rcWorkArea.right) {
        lpptNearCaret->x = rcWorkArea.right - xWidthUI;

    }

    if (lpptNearCaret->y < rcWorkArea.top) {
        lpptNearCaret->y = rcWorkArea.top;
    } else if (lpptNearCaret->y + yHeightUI > rcWorkArea.bottom) {
        lpptNearCaret->y = rcWorkArea.bottom - yHeightUI;
    }

    return;
}

/**********************************************************************/
/* AdjustCompPosition()                                               */
/* Return Value :                                                     */
/*      the position of composition window is changed or not          */
/**********************************************************************/
BOOL PASCAL AdjustCompPosition(         // IME adjust position according to
                                        // composition form
#if defined(UNIIME)
    LPIMEL         lpImeL,
#endif
    LPINPUTCONTEXT lpIMC,
    LPPOINT        lpptOrg,             // original composition window
                                        // and final position
    LPPOINT        lpptNew)             // new expect position
{
    POINT ptNearCaret, ptOldNearCaret;
    UINT  uEsc, uRot;
    RECT  rcUIRect, rcInputRect, rcInterRect;
    POINT ptFont;

    // we need to adjust according to font attribute
    if (lpIMC->lfFont.A.lfWidth > 0) {
        ptFont.x = lpIMC->lfFont.A.lfWidth * 2;
    } else if (lpIMC->lfFont.A.lfWidth < 0) {
        ptFont.x = -lpIMC->lfFont.A.lfWidth * 2;
    } else if (lpIMC->lfFont.A.lfHeight > 0) {
        ptFont.x = lpIMC->lfFont.A.lfHeight;
    } else if (lpIMC->lfFont.A.lfHeight < 0) {
        ptFont.x = -lpIMC->lfFont.A.lfHeight;
    } else {
        ptFont.x = lpImeL->yCompHi;
    }

    if (lpIMC->lfFont.A.lfHeight > 0) {
        ptFont.y = lpIMC->lfFont.A.lfHeight;
    } else if (lpIMC->lfFont.A.lfHeight < 0) {
        ptFont.y = -lpIMC->lfFont.A.lfHeight;
    } else {
        ptFont.y = ptFont.x;
    }

    // if the input char is too big, we don't need to consider so much
    if (ptFont.x > lpImeL->yCompHi * 8) {
        ptFont.x = lpImeL->yCompHi * 8;
    }
    if (ptFont.y > lpImeL->yCompHi * 8) {
        ptFont.y = lpImeL->yCompHi * 8;
    }

    if (ptFont.x < sImeG.xChiCharWi) {
        ptFont.x = sImeG.xChiCharWi;
    }

    if (ptFont.y < sImeG.yChiCharHi) {
        ptFont.y = sImeG.yChiCharHi;
    }

    // -450 to 450 index 0
    // 450 to 1350 index 1
    // 1350 to 2250 index 2
    // 2250 to 3150 index 3
    uEsc = (UINT)((lpIMC->lfFont.A.lfEscapement + 450) / 900 % 4);
    uRot = (UINT)((lpIMC->lfFont.A.lfOrientation + 450) / 900 % 4);

    // decide the input rectangle
    rcInputRect.left = lpptNew->x;
    rcInputRect.top = lpptNew->y;

    // build up an input rectangle from escapemment
    rcInputRect.right = rcInputRect.left + ptFont.x * ptInputEsc[uEsc].x;
    rcInputRect.bottom = rcInputRect.top + ptFont.y * ptInputEsc[uEsc].y;

    // be a normal rectangle, not a negative rectangle
    if (rcInputRect.left > rcInputRect.right) {
        LONG tmp;

        tmp = rcInputRect.left;
        rcInputRect.left = rcInputRect.right;
        rcInputRect.right = tmp;
    }

    if (rcInputRect.top > rcInputRect.bottom) {
        LONG tmp;

        tmp = rcInputRect.top;
        rcInputRect.top = rcInputRect.bottom;
        rcInputRect.bottom = tmp;
    }

    GetNearCaretPosition(
#if defined(UNIIME)
        lpImeL,
#endif
        &ptFont, uEsc, uRot, lpptNew, &ptNearCaret, NEAR_CARET_FIRST_TIME);

    // 1st, use the adjust point
    // build up the new suggest UI rectangle (composition window)
    rcUIRect.left = ptNearCaret.x;
    rcUIRect.top = ptNearCaret.y;
    rcUIRect.right = rcUIRect.left + lpImeL->xCompWi;
    rcUIRect.bottom = rcUIRect.top + lpImeL->yCompHi;

    ptOldNearCaret = ptNearCaret;

    // OK, no intersect between the near caret position and input char
    if (IntersectRect(&rcInterRect, &rcUIRect, &rcInputRect)) {
    } else if (FitInLazyOperation(
#if defined(UNIIME)
        lpImeL,
#endif
        lpptOrg, &ptNearCaret, &rcInputRect, uEsc)) {
        // happy ending!!!, don't chaqge position
        return (FALSE);
    } else {
        *lpptOrg = ptNearCaret;

        // happy ending!!
        return (TRUE);
    }

    // unhappy case
    GetNearCaretPosition(
#if defined(UNIIME)
            lpImeL,
#endif
            &ptFont, uEsc, uRot, lpptNew, &ptNearCaret, 0);

    // build up the new suggest UI rectangle (composition window)
    rcUIRect.left = ptNearCaret.x;
    rcUIRect.top = ptNearCaret.y;
    rcUIRect.right = rcUIRect.left + lpImeL->xCompWi;
    rcUIRect.bottom = rcUIRect.top + lpImeL->yCompHi;

    // OK, no intersect between the adjust position and input char
    if (IntersectRect(&rcInterRect, &rcUIRect, &rcInputRect)) {
    } else if (FitInLazyOperation(
#if defined(UNIIME)
        lpImeL,
#endif
        lpptOrg, &ptNearCaret, &rcInputRect, uEsc)) {
        // happy ending!!!, don't chaqge position
        return (FALSE);
    } else {
        *lpptOrg = ptNearCaret;

        // happy ending!!
        return (TRUE);
    }

    // unhappy ending! :-(
    *lpptOrg = ptOldNearCaret;

    return (TRUE);
}

/**********************************************************************/
/* SetCompPosition()                                                  */
/**********************************************************************/
void PASCAL SetCompPosition(    // set the composition window position
    HWND           hCompWnd,
    HIMC           hIMC,
    LPINPUTCONTEXT lpIMC)
{
    POINT ptWnd;
    POINT ptSTWPos;
    HWND  hCandWnd;
    BOOL  fChange = FALSE;
    RECT  rcWorkArea;

#if 1 // MultiMonoitor
    rcWorkArea = ImeMonitorWorkAreaFromWindow(lpIMC->hWnd);
#else
    rcWorkArea = sImeG.rcWorkArea;
#endif


    // the client coordinate position (0, 0) of composition window
    ptWnd.x = 0;
    ptWnd.y = 0;
    // convert to screen coordinates
    ClientToScreen(hCompWnd, &ptWnd);
    ptWnd.x -= lpImeL->cxCompBorder;
    ptWnd.y -= lpImeL->cyCompBorder;
    
    if (!MBIndex.IMEChara[0].IC_Trace) {
        int  Comp_CandWndLen;

           ImmGetStatusWindowPos(hIMC, (LPPOINT)&ptSTWPos);

        // reset status window for LINE_UI(FIX_UI)
        Comp_CandWndLen = 0;
        if(uStartComp) {
            Comp_CandWndLen += lpImeL->xCompWi + UI_MARGIN;
            if(uOpenCand) {
                Comp_CandWndLen += sImeG.xCandWi + UI_MARGIN;
            }
            if(ptSTWPos.x + sImeG.xStatusWi + Comp_CandWndLen > rcWorkArea.right) {
                ptSTWPos.x = rcWorkArea.right - sImeG.xStatusWi - Comp_CandWndLen;
            }

            SetWindowPos(GetStatusWnd(GetWindow(hCompWnd, GW_OWNER)), NULL,
                (int)ptSTWPos.x, (int)ptSTWPos.y,
                0, 0, SWP_NOACTIVATE|SWP_NOCOPYBITS|SWP_NOSIZE|SWP_NOZORDER);
            ImmSetStatusWindowPos(hIMC, (LPPOINT)&ptSTWPos);
        }

        ptWnd.x = ptSTWPos.x + sImeG.xStatusWi + UI_MARGIN;
        ptWnd.y = ptSTWPos.y;
        lpIMC->cfCompForm.ptCurrentPos = ptWnd;
        ScreenToClient(lpIMC->hWnd, &lpIMC->cfCompForm.ptCurrentPos);
        fChange = TRUE;

    } else if (lpIMC->cfCompForm.dwStyle & CFS_FORCE_POSITION) {
        POINT ptNew;            // new position of UI

        ptNew.x = lpIMC->cfCompForm.ptCurrentPos.x;
        ptNew.y = lpIMC->cfCompForm.ptCurrentPos.y;
        ClientToScreen((HWND)lpIMC->hWnd, &ptNew);
        if (ptWnd.x != ptNew.x) {
            ptWnd.x = ptNew.x;
            fChange = TRUE;
        }
        if (ptWnd.y != ptNew.y) {
            ptWnd.y = ptNew.y;
            fChange = TRUE;
        }
        if (fChange) {
            ptWnd.x -= lpImeL->cxCompBorder;
            ptWnd.y -= lpImeL->cyCompBorder;
        }
    } else if (lpIMC->cfCompForm.dwStyle != CFS_DEFAULT) {
        POINT ptNew;            // new position of UI

        ptNew.x = lpIMC->cfCompForm.ptCurrentPos.x;
        ptNew.y = lpIMC->cfCompForm.ptCurrentPos.y;
        ClientToScreen((HWND)lpIMC->hWnd, &ptNew);
        fChange = AdjustCompPosition(lpIMC, &ptWnd, &ptNew);
    } else {
        POINT ptNew;            // new position of UI

        ImmGetStatusWindowPos(hIMC, (LPPOINT)&ptSTWPos);
        ptNew.x = ptSTWPos.x + sImeG.xStatusWi + UI_MARGIN;
        if((ptSTWPos.x + sImeG.xStatusWi + sImeG.xCandWi + lpImeL->xCompWi + 2 * UI_MARGIN) >=
          rcWorkArea.right) { 
            ptNew.x = ptSTWPos.x - lpImeL->xCompWi - UI_MARGIN;
        }
        ptNew.y = ptSTWPos.y;
        if (ptWnd.x != ptNew.x) {
            ptWnd.x = ptNew.x;
            fChange = TRUE;
        }

        if (ptWnd.y != ptNew.y) {
            ptWnd.y = ptNew.y;
            fChange = TRUE;
        }

        if (fChange) {
            lpIMC->cfCompForm.ptCurrentPos = ptNew;

            ScreenToClient(lpIMC->hWnd, &lpIMC->cfCompForm.ptCurrentPos);
        }
    }

    if (!fChange) {
        return;
    }
    SetWindowPos(hCompWnd, NULL,
        ptWnd.x, ptWnd.y,
        0, 0, SWP_NOACTIVATE|SWP_NOSIZE|SWP_NOZORDER);


    hCandWnd = GetCandWnd(GetWindow(hCompWnd, GW_OWNER));

    if (!hCandWnd) {
        return;
    }

    // decide the position of candidate window by UI's position
    CalcCandPos(hIMC, GetWindow(hCompWnd, GW_OWNER), &ptWnd);

    ScreenToClient(lpIMC->hWnd, &ptWnd);

    lpIMC->cfCandForm[0].dwStyle = CFS_CANDIDATEPOS;
    lpIMC->cfCandForm[0].ptCurrentPos = ptWnd;

    if (!IsWindowVisible(hCandWnd)) {
        return;
    }

    PostMessage(hCandWnd, WM_IME_NOTIFY, IMN_SETCANDIDATEPOS, 0x0001);

    return;
}


/**********************************************************************/
/* SetCompWindow()                                                    */
/**********************************************************************/
void PASCAL SetCompWindow(              // set the position of composition window
    HWND hCompWnd)
{
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    HWND           hUIWnd;

    hUIWnd = GetWindow(hCompWnd, GW_OWNER);
    if (!hUIWnd) {
        return;
    }
    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return;
    }

    SetCompPosition(hCompWnd, hIMC, lpIMC);

    ImmUnlockIMC(hIMC);

    return;
}

/**********************************************************************/
/* MoveDefaultCompPosition()                                          */
/**********************************************************************/
void PASCAL MoveDefaultCompPosition(    // the default comp position
                                        // need to near the caret
    HWND hUIWnd)
{
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    HWND           hCompWnd;

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return;
    }

    hCompWnd = GetCompWnd(hUIWnd);
    if (!hCompWnd) {
        return;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return;
    }

    if (!(lpIMC->cfCompForm.dwStyle & CFS_FORCE_POSITION)) {
        SetCompPosition(hCompWnd, hIMC, lpIMC);
    }

    ImmUnlockIMC(hIMC);

    return;
}

/**********************************************************************/
/* ShowComp()                                                         */
/**********************************************************************/
void PASCAL ShowComp(           // Show the composition window
    HWND hUIWnd,
    int  nShowCompCmd)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    // show or hid the UI window
    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {
        return;
    }

    if (lpUIPrivate->nShowCompCmd == nShowCompCmd) {
        goto SwCompNoChange;
    }

    if (nShowCompCmd == SW_HIDE) {
        lpUIPrivate->fdwSetContext &= ~(ISC_HIDE_COMP_WINDOW);
    }

    if (!lpUIPrivate->hCompWnd) {
        // not in show candidate window mode
    } else {
        if(nShowCompCmd == SW_HIDE) {
            uStartComp = 0;
        } else {
            uStartComp = 1;
        }
        
        ShowWindow(lpUIPrivate->hCompWnd, nShowCompCmd);
        lpUIPrivate->nShowCompCmd = nShowCompCmd;
    }

SwCompNoChange:
    GlobalUnlock(hUIPrivate);
    return;
}

/**********************************************************************/
/* StartComp()                                                        */
/**********************************************************************/
void PASCAL StartComp(
    HWND hUIWnd)
{
    HIMC           hIMC;
    HGLOBAL        hUIPrivate;
    LPINPUTCONTEXT lpIMC;
    LPUIPRIV       lpUIPrivate;

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {           // Oh! Oh!
        return;
    }

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {     // Oh! Oh!
        return;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {          // Oh! Oh!
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {    // can not draw composition window
        ImmUnlockIMC(hIMC);
        return;
    }

    lpUIPrivate->fdwSetContext |= ISC_SHOWUICOMPOSITIONWINDOW;

    if(!lpUIPrivate->hCompWnd) {
        lpUIPrivate->hCompWnd = CreateWindowEx(
                                  WS_EX_WINDOWEDGE|WS_EX_DLGMODALFRAME,
                                  szCompClassName, 
                                  NULL, 
                                  WS_POPUP|WS_DISABLED,
                                  0, 
                                  0, 
                                  lpImeL->xCompWi, 
                                  lpImeL->yCompHi,
                                  hUIWnd,
                                  (HMENU)NULL, 
                                  hInst, 
                                  NULL);
        SetWindowLong(lpUIPrivate->hCompWnd, UI_MOVE_OFFSET,WINDOW_NOT_DRAG);
        SetWindowLong(lpUIPrivate->hCompWnd, UI_MOVE_XY, lpImeL->nMaxKey);
    }

    uStartComp = 1;
    // try to set the position of composition UI window near the caret
    SetCompPosition(lpUIPrivate->hCompWnd, hIMC, lpIMC);

    ImmUnlockIMC(hIMC);

    ShowComp(hUIWnd, SW_SHOWNOACTIVATE);

    GlobalUnlock(hUIPrivate);

    return;
}

/**********************************************************************/
/* EndComp()                                                          */
/**********************************************************************/
void PASCAL EndComp(
    HWND hUIWnd)
{
    ShowComp(hUIWnd, SW_HIDE);

    return;
}

/**********************************************************************/
/* DestroyCompWindow()                                                */
/**********************************************************************/
void PASCAL DestroyCompWindow(          // destroy composition window
    HWND hCompWnd)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    if (GetWindowLong(hCompWnd, UI_MOVE_OFFSET) != WINDOW_NOT_DRAG) {
        // undo the drag border
        DrawDragBorder(hCompWnd,
            GetWindowLong(hCompWnd, UI_MOVE_XY),
            GetWindowLong(hCompWnd, UI_MOVE_OFFSET));
    }

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(GetWindow(hCompWnd, GW_OWNER),
        IMMGWLP_PRIVATE);
    if (!hUIPrivate) {     // Oh! Oh!
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {    // Oh! Oh!
        return;
    }

    lpUIPrivate->nShowCompCmd = SW_HIDE;

    lpUIPrivate->hCompWnd = (HWND)NULL;

    GlobalUnlock(hUIPrivate);
    return;
}

/**********************************************************************/
/* CompSetCursor()                                                    */
/**********************************************************************/
void PASCAL CompSetCursor(
    HWND   hCompWnd,
    LPARAM lParam)
{
    POINT ptCursor;
    RECT  rcWnd;

    SetCursor(LoadCursor(NULL, IDC_SIZEALL));

    if (GetWindowLong(hCompWnd, UI_MOVE_OFFSET) !=
        WINDOW_NOT_DRAG) {
        return;
    }

    if (HIWORD(lParam) != WM_LBUTTONDOWN) {
        return;
    }

    // start dragging
    SystemParametersInfo(SPI_GETWORKAREA, 0, &sImeG.rcWorkArea, 0);

    SetCapture(hCompWnd);
    GetCursorPos(&ptCursor);
    SetWindowLong(hCompWnd, UI_MOVE_XY,
        MAKELONG(ptCursor.x, ptCursor.y));
    GetWindowRect(hCompWnd, &rcWnd);
    SetWindowLong(hCompWnd, UI_MOVE_OFFSET,
        MAKELONG(ptCursor.x - rcWnd.left, ptCursor.y - rcWnd.top));

    DrawDragBorder(hCompWnd, MAKELONG(ptCursor.x, ptCursor.y),
        GetWindowLong(hCompWnd, UI_MOVE_OFFSET));

    return;
}


/**********************************************************************/
/* CompButtonUp()                                                     */
/**********************************************************************/
BOOL PASCAL CompButtonUp(       // finish drag, set comp  window to this
                                // position
    HWND   hCompWnd)
{
    LONG            lTmpCursor, lTmpOffset;
    POINT           pt;
    HWND            hUIWnd;
    HIMC            hIMC;
    LPINPUTCONTEXT  lpIMC;
    RECT            rcWorkArea;

    if (GetWindowLong(hCompWnd, UI_MOVE_OFFSET) == WINDOW_NOT_DRAG) {
        return (FALSE);
    }


    lTmpCursor = GetWindowLong(hCompWnd, UI_MOVE_XY);

    // calculate the org by the offset
    lTmpOffset = GetWindowLong(hCompWnd, UI_MOVE_OFFSET);

    pt.x = (*(LPPOINTS)&lTmpCursor).x - (*(LPPOINTS)&lTmpOffset).x;
    pt.y = (*(LPPOINTS)&lTmpCursor).y - (*(LPPOINTS)&lTmpOffset).y;

    DrawDragBorder(hCompWnd, lTmpCursor, lTmpOffset);
    SetWindowLong(hCompWnd, UI_MOVE_OFFSET, WINDOW_NOT_DRAG);

    SetWindowLong(hCompWnd, UI_MOVE_XY, lpImeL->nMaxKey);

    ReleaseCapture();

    hUIWnd = GetWindow(hCompWnd, GW_OWNER);
    if (!hUIWnd) {
        return (FALSE);
    }

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return (FALSE);
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return (FALSE);
    }

#if 1 // MultiMonoitor
    rcWorkArea = ImeMonitorWorkAreaFromWindow(lpIMC->hWnd);
#else
    rcWorkArea = sImeG.rcWorkArea;
#endif

    if (pt.x < rcWorkArea.left) {
        pt.x = rcWorkArea.left;
    } else if (pt.x + lpImeL->xCompWi > rcWorkArea.right) {
        pt.x = rcWorkArea.right - lpImeL->xCompWi;
    }

    if (pt.y < rcWorkArea.top) {
        pt.y = rcWorkArea.top;
    } else if (pt.y + lpImeL->yCompHi > rcWorkArea.bottom) {
        pt.y = rcWorkArea.bottom - lpImeL->yCompHi;
    }

    lpIMC->cfCompForm.dwStyle = CFS_FORCE_POSITION;
    lpIMC->cfCompForm.ptCurrentPos.x = pt.x + lpImeL->cxCompBorder;
    lpIMC->cfCompForm.ptCurrentPos.y = pt.y + lpImeL->cyCompBorder;

    ScreenToClient(lpIMC->hWnd, &lpIMC->cfCompForm.ptCurrentPos);

    ImmUnlockIMC(hIMC);

    // set composition window to the new poosition
    PostMessage(hCompWnd, WM_IME_NOTIFY, IMN_SETCOMPOSITIONWINDOW, 0);

    return (TRUE);
}

#ifdef KEYSTICKER
//**********************************************************************
//IndexKeySticker(int)
//**********************************************************************
int IndexKeySticker(TCHAR index)
{
int i;

    for(i=0; i<INDEXNUM; i++){
        if(KeyIndexTbl[i] == index){
            return i;
        }
    }
    return (-1);
}

//**********************************************************************
//MapSticker(LPCTSTR, LPTSTR, int)
//**********************************************************************
void MapSticker(
LPCTSTR ReadingStr,
LPTSTR szStickerLayout,
int len)
{
int    i,j,k;

    for(i=0,k=0;i<len;i++){
        j = IndexKeySticker(ReadingStr[i]);
        
        //memcpy(&szStickerLayout[i*2], MapKeyStickerTbl[j], 2);
        if(j>=0){
            memcpy(&szStickerLayout[k], MapKeyStickerTbl[j], 2);
            k+=2/sizeof(TCHAR);
        }else{
            szStickerLayout[k] = ReadingStr[i];
            k++;
        }
        
    }
}
#endif //KEYSTICKER

/**********************************************************************/
/* PaintCompWindow()                                                */
/**********************************************************************/
void PASCAL PaintCompWindow(
    HWND   hUIWnd,
    HWND   hCompWnd,
    HDC    hDC)
{
    HIMC                hIMC;
    LPINPUTCONTEXT      lpIMC;
    HGDIOBJ             hOldFont;
    LPCOMPOSITIONSTRING lpCompStr;
    LPGUIDELINE         lpGuideLine;
    BOOL                fShowString;
    LPCTSTR             lpStr;

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return;
    }

    if (sImeG.fDiffSysCharSet) {
        LOGFONT lfFont;
        ZeroMemory(&lfFont, sizeof(lfFont));
        hOldFont = GetCurrentObject(hDC, OBJ_FONT);
        lfFont.lfHeight = -MulDiv(12, GetDeviceCaps(hDC, LOGPIXELSY), 72);
        lfFont.lfCharSet = NATIVE_CHARSET;
        lstrcpy(lfFont.lfFaceName, TEXT("Simsun"));
        SelectObject(hDC, CreateFontIndirect(&lfFont));
    }

    lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
    
    if(!lpCompStr){
        return;
    }
    

    lpGuideLine = (LPGUIDELINE)ImmLockIMCC(lpIMC->hGuideLine);
    
    if(!lpGuideLine){
        return;
    }
    

    // draw CompWnd Layout
    {
    RECT rcWnd;

    GetClientRect(hCompWnd, &rcWnd);
    DrawConcaveRect(hDC,
        rcWnd.left,
        rcWnd.top,
        rcWnd.right - 1,
        rcWnd.bottom - 1);
    }
    
    SetBkColor(hDC, RGB(0xC0, 0xC0, 0xC0));

    fShowString = (BOOL) 0;

    if (!lpGuideLine) {
    } else if (lpGuideLine->dwLevel == GL_LEVEL_NOGUIDELINE) {
    } else if (!lpGuideLine->dwStrLen) {
        if (lpGuideLine->dwLevel == GL_LEVEL_ERROR) {
            fShowString |= IME_STR_ERROR;
        }
    } else {
        // if there is information string, we will show the information
        // string
        if (lpGuideLine->dwLevel == GL_LEVEL_ERROR) {
            // red text for error
            SetTextColor(hDC, RGB(0xFF, 0, 0));
            // light gray background for error
            SetBkColor(hDC, RGB(0x80, 0x80, 0x80));
        }

        lpStr = (LPCTSTR)((LPBYTE)lpGuideLine + lpGuideLine->dwStrOffset);
        ExtTextOut(hDC, lpImeL->rcCompText.left, lpImeL->rcCompText.top,
            ETO_OPAQUE, &lpImeL->rcCompText,
            lpStr, (UINT)lpGuideLine->dwStrLen, NULL);
        fShowString |= IME_STR_SHOWED;
    }

    if (fShowString & IME_STR_SHOWED) {
        // already show it, don't need to show
    } else if (lpCompStr->dwCompStrLen > 0) {
#ifdef KEYSTICKER
        {
        TCHAR     szStickerLayout[MAXCODE*2/sizeof(TCHAR)];

        memset(szStickerLayout, 0,MAXCODE*2);
        MapSticker((LPTSTR)((LPBYTE)lpCompStr + lpCompStr->dwCompStrOffset),
            szStickerLayout,lpCompStr->dwCompStrLen);
        ExtTextOut(hDC, lpImeL->rcCompText.left, lpImeL->rcCompText.top,
            ETO_OPAQUE, &lpImeL->rcCompText,
            (LPTSTR)NULL, (int)NULL, NULL);

        DrawText(hDC, (LPTSTR)szStickerLayout,
                (int)lstrlen(szStickerLayout), &lpImeL->rcCompText,
                DT_LEFT | DT_VCENTER | DT_SINGLELINE);
        }
#else
        ExtTextOut(hDC, lpImeL->rcCompText.left, lpImeL->rcCompText.top,
            ETO_OPAQUE, &lpImeL->rcCompText,
            (LPTSTR)NULL, (int) 0, NULL);
        lpStr = (LPCTSTR)((LPBYTE)lpCompStr + lpCompStr->dwCompStrOffset);
        DrawText(hDC, lpStr, (int)lpCompStr->dwCompStrLen, &lpImeL->rcCompText,
                DT_LEFT | DT_VCENTER | DT_SINGLELINE);
#endif    //KEYSTICKER
        if (fShowString & IME_STR_ERROR) {
            // red text for error
            //SetTextColor(hDC, RGB(0xFF, 0, 0));
            // light gray background for error
            SetBkColor(hDC, RGB(0x80, 0x80, 0x80));
            lpStr = (LPCTSTR)((LPBYTE)lpCompStr + lpCompStr->dwCompStrOffset + lpCompStr->dwCursorPos);
            ExtTextOut(hDC, lpImeL->rcCompText.left +
                lpCompStr->dwCursorPos * sImeG.xChiCharWi/ 2,
                lpImeL->rcCompText.top,
                ETO_CLIPPED, &lpImeL->rcCompText,
                lpStr, (UINT)lpCompStr->dwCompStrLen - lpCompStr->dwCursorPos, NULL);
        } else if (lpCompStr->dwCursorPos < lpCompStr->dwCompStrLen) {
            // light gray background for cursor start
            SetBkColor(hDC, RGB(0x80, 0x80, 0x80));
            lpStr = (LPCTSTR)((LPBYTE)lpCompStr + lpCompStr->dwCompStrOffset + lpCompStr->dwCursorPos);
            ExtTextOut(hDC, lpImeL->rcCompText.left +
                lpCompStr->dwCursorPos * sImeG.xChiCharWi/ 2,
                lpImeL->rcCompText.top,
                ETO_CLIPPED, &lpImeL->rcCompText,
                lpStr, (UINT)lpCompStr->dwCompStrLen - lpCompStr->dwCursorPos, NULL);
        } else {
        }
    } else {

        // CHP
        // Display stand code for reference
#ifdef FUSSYMODE
        if (MBIndex.IMEChara[0].IC_FCSR && MBIndex.IMEChara[0].IC_FCTS){
        if (MBIndex.IsFussyCharFlag)
        {
            LPCANDIDATELIST lpRevCandList;
            LPPRIVCONTEXT       lpImcP;
                    MBIndex.IsFussyCharFlag = 0;
            lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);

            if (lpImcP) {
                if(lpImcP->hRevCandList){ 
                       lpRevCandList = (LPCANDIDATELIST)GlobalLock((HGLOBAL)lpImcP->hRevCandList);
                       if (lpRevCandList != NULL && lpRevCandList->dwCount) {

                        // Red text for correction
                        SetTextColor(hDC, RGB(0xc0, 0x00, 0x00));
                           SetBkColor(hDC, RGB(0xc0, 0xc0, 0xc0));
                        lpStr = (LPCTSTR)((LPBYTE)lpRevCandList + lpRevCandList->dwOffset[0]);
                        ExtTextOut(hDC, lpImeL->rcCompText.left, lpImeL->rcCompText.top,
                                   ETO_OPAQUE, &lpImeL->rcCompText,
                                      lpStr, (int)lstrlen(lpStr),    NULL);
                        //MessageBox(NULL,TEXT("OK"),TEXT("Mydebug"),MB_OK);
                        GlobalFree((HGLOBAL)lpImcP->hRevCandList);
                        lpImcP->hRevCandList = (HIMCC)NULL;
                    }
                }
            }    
            else
            {
                ExtTextOut(hDC, lpImeL->rcCompText.left, lpImeL->rcCompText.top,
                           ETO_OPAQUE, &lpImeL->rcCompText,
                           (LPTSTR)NULL, 0, NULL);
            }
            ImmUnlockIMCC(lpIMC->hPrivate);

        }
        else
        ExtTextOut(hDC, lpImeL->rcCompText.left, lpImeL->rcCompText.top,
                           ETO_OPAQUE, &lpImeL->rcCompText,
                           (LPTSTR)NULL, 0, NULL);

        }
        else
#endif
#ifdef CROSSREF
        {    
            LPCANDIDATELIST lpRevCandList;
            LPPRIVCONTEXT       lpImcP;

            lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);

            if (lpImcP) {
                if(lpImcP->hRevCandList){ 
                       lpRevCandList = (LPCANDIDATELIST)GlobalLock((HGLOBAL)lpImcP->hRevCandList);
                       if (lpRevCandList != NULL && lpRevCandList->dwCount) {

                        // green text for information
                        SetTextColor(hDC, RGB(0x00, 0x80, 0x00));

                           SetBkColor(hDC, RGB(0xc0, 0xc0, 0xc0));
                        lpStr = (LPCTSTR)((LPBYTE)lpRevCandList + lpRevCandList->dwOffset[0]);
                        ExtTextOut(hDC, lpImeL->rcCompText.left, lpImeL->rcCompText.top,
                            ETO_OPAQUE, &lpImeL->rcCompText,
                            lpStr, (int)lstrlen(lpStr),    NULL);
                        GlobalFree((HGLOBAL)lpImcP->hRevCandList);
                        lpImcP->hRevCandList = (HIMCC)NULL;
                        goto CrossCodeFinish;
                    }
                }
            }    

            ExtTextOut(hDC, lpImeL->rcCompText.left, lpImeL->rcCompText.top,
            ETO_OPAQUE, &lpImeL->rcCompText,
            (LPTSTR)NULL, 0, NULL);
CrossCodeFinish:
            ImmUnlockIMCC(lpIMC->hPrivate);

        }
#else
            ExtTextOut(hDC, lpImeL->rcCompText.left, lpImeL->rcCompText.top,
            ETO_OPAQUE, &lpImeL->rcCompText,
            (LPTSTR)NULL, 0, NULL);
#endif
    }

    if (sImeG.fDiffSysCharSet) {
        DeleteObject(SelectObject(hDC, hOldFont));
    }

    ImmUnlockIMCC(lpIMC->hGuideLine);
    ImmUnlockIMCC(lpIMC->hCompStr);
    ImmUnlockIMC(hIMC);
    return;
}

/**********************************************************************/
/* UpdateCompWindow()                                                 */
/**********************************************************************/
void PASCAL UpdateCompWindow(
    HWND hUIWnd)
{
    HWND hCompWnd;
    HDC  hDC;

    hCompWnd = GetCompWnd(hUIWnd);
    hDC = GetDC(hCompWnd);
    PaintCompWindow(hUIWnd, hCompWnd, hDC);
    ReleaseDC(hCompWnd, hDC);
}

/**********************************************************************/
/* CompWndProc()                                                      */
/**********************************************************************/
LRESULT CALLBACK CompWndProc(           // composition window proc
    HWND   hCompWnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (uMsg) {
    case WM_DESTROY:
        DestroyCompWindow(hCompWnd);
        break;
    case WM_SETCURSOR:
        CompSetCursor(hCompWnd, lParam);
        break;
    case WM_MOUSEMOVE:
        if (GetWindowLong(hCompWnd, UI_MOVE_OFFSET) != WINDOW_NOT_DRAG) {
            POINT ptCursor;

            DrawDragBorder(hCompWnd,
                GetWindowLong(hCompWnd, UI_MOVE_XY),
                GetWindowLong(hCompWnd, UI_MOVE_OFFSET));
            GetCursorPos(&ptCursor);
            SetWindowLong(hCompWnd, UI_MOVE_XY,
                MAKELONG(ptCursor.x, ptCursor.y));
            DrawDragBorder(hCompWnd, MAKELONG(ptCursor.x, ptCursor.y),
                GetWindowLong(hCompWnd, UI_MOVE_OFFSET));
        } else {
            return DefWindowProc(hCompWnd, uMsg, wParam, lParam);
        }
        break;
    case WM_LBUTTONUP:
        if (!CompButtonUp(hCompWnd)) {
            return DefWindowProc(hCompWnd, uMsg, wParam, lParam);
        }
        break;
    case WM_IME_NOTIFY:
        if (wParam == IMN_SETCOMPOSITIONWINDOW) {
            SetCompWindow(hCompWnd);
        }
        break;
    case WM_PAINT:
        {
            HDC         hDC;
            PAINTSTRUCT ps;

            hDC = BeginPaint(hCompWnd, &ps);
            PaintCompWindow(GetWindow(hCompWnd, GW_OWNER), hCompWnd, hDC);
            EndPaint(hCompWnd, &ps);
        }
        break;
    case WM_MOUSEACTIVATE:
        return (MA_NOACTIVATE);
    default:
        return DefWindowProc(hCompWnd, uMsg, wParam, lParam);
    }
    return (0L);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntime\eng.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    UI.c
    
++*/

#include <stdio.h>
#include <windows.h>
#include <string.h>
#include <memory.h>
#include <immdev.h>
#include "imedefs.h"

typedef struct  tagINTERCODEAREA {
     DWORD PreCount;   
     DWORD StartInterCode;
     DWORD EndInterCode;
} INTERCODEAREA,*LPINTERCODEAREA;

PPRIVCONTEXT        lpEngPrivate;

EMB_Head         *EMB_Table;
TCHAR            *ZM_Area;
HANDLE           HmemEMB_Table;
DWORD            MaxXLen;
WORD             MaxCodes, NumCodes;
TCHAR            UsedCode[MAXUSEDCODES];        
TCHAR            WildChar;
BYTE             CodeAIndex[128];
int              MAX_LEN;
MB_Head          MB_Head_Table[48];
LPBYTE           EMBM = NULL;
LPBYTE           g_lptep = NULL;  

extern     UINT     UI_CANDSTR;
extern     MBINDEX  MBIndex;
        
#pragma data_seg (".sgroup")
HMapStruc HMapTab[MaxTabNum] = {0};

#pragma data_seg ()

UINT WINAPI MB_SUB(HIMCC,TCHAR,BYTE,UINT);
int  WINAPI StartEngine(HIMCC) ;
int  WINAPI EndEngine(HIMCC);
void CapKeyProc(TCHAR);

int   GetMBHead(void);
BYTE  GetEMBHead(void);

UINT DelDoubleBuf(void);
void ClrDoubleBuf(void);
void ClrSelBuf(void);
void DelSelBuf(void);
void DelWCEdit(void);
void ClrWCBuf(void);

UINT CoreMBComp(TCHAR,BYTE);
UINT WildProcess(TCHAR) ;
int  EMBWCWildComp(TCHAR,BYTE,int);
int  MBWCWildComp(TCHAR,BYTE,int);
void SearchEMBPos(TCHAR,BYTE);
UINT SearchEMBCompMatch(void);
UINT SearchMBCompMatch(TCHAR);
void SearchBEMBCompMatch(void);
void SearchBMBCompMatch(void);

void SearchEMBWildMatch(void);
void SearchMBWildMatch(BYTE);
void SearchBEMBWildMatch(void);
void SearchBMBWildMatch(BYTE);
void SearchBMBWWMatch(TCHAR,BYTE);
void SearchMBWWMatch(TCHAR,BYTE);
void SearchBEMBWWMatch(TCHAR,BYTE);
void SearchEMBWWMatch(TCHAR,BYTE);

void SearchEMBLXMatch(void);
void SearchMBLXMatch(void);
void SearchBEMBLXMatch(void);
void SearchBMBLXMatch(void);
void PageDnUp(BYTE);
void CoreMBCompDnUp(BYTE);
void CoreLXCompDnUp(BYTE);
int  CoreMCCompDnUp(BYTE);
void CoreWWCompDnUp(BYTE);
UINT CoreUnitProcess(TCHAR);        
void TurnToFirstPage(void);
void TurnToEndPage(void);
UINT CoreProcess(BYTE);
UINT SelectCandi(TCHAR);
UINT LXSelectCandi(TCHAR);
UINT DefSelect(void);
void TSMulCProc(void);
void CoreLXComp(void);
DWORD Skip_CaWord(DWORD);
int Scan_Word(DWORD,LPTSTR);
int VerScan_Word(DWORD,LPTSTR);
BYTE WildInBuffer(void);
BYTE CodeInSet(char);
UINT InCodeSet(TCHAR);

void Sort_EMB(int,int) ;
void IMDReset(int) ;
BOOL WriteEMBToFile(LPTSTR) ;
BOOL GetUDCItem(HIMCC,UINT,LPTSTR,LPTSTR);
int GetUDCIndex(HIMCC,LPTSTR,LPTSTR);

int  AddZCItem(HIMCC,LPTSTR,LPTSTR);
void DelSelCU(HIMCC,int) ;
void DelExmb(HIMCC);
void Swap_Item(int,int);
void ConvertCandi(void);

BYTE  MBPositionSearch(LPCTSTR ) ;
BYTE  EMBPositionSearch(LPCTSTR ) ;
int   GetFirstCode(LPTSTR ) ;
DWORD GetNumber(HANDLE ,DWORD ,LPTSTR );
UINT  Conversion(HIMCC,LPCTSTR,UINT );
UINT  ReadArea(TCHAR );
void  ResetCont(HIMCC);
int   NumInSet(void);
BOOL  UnRegisterWord(HIMCC,LPCTSTR,LPCTSTR);
UINT  EnumRegisterWord(HIMCC,LPCTSTR,LPCTSTR,LPVOID);

long GetLengthofBuf(void);
long GetLengthTepBuf(LPTSTR);
long GetLengthCCharBuf(LPTSTR);
int Inputcodelen(LPCTSTR);
int DBCSCharlen(LPCTSTR);
LPTSTR _tcschr(LPTSTR, TCHAR);
LPTSTR _rtcschr(LPTSTR string, TCHAR c);
int IsGBK(LPTSTR);

UINT WINAPI MB_SUB(HIMCC HmemPri,TCHAR code ,BYTE c_state, UINT UI_Mode) {
    
    UINT ret_state = 0;
    lpEngPrivate = (PPRIVCONTEXT) ImmLockIMCC(HmemPri);        
    if(!lpEngPrivate){
        return ((UINT)-1);
    }

    if(UI_Mode==BOX_UI)
        MAX_LEN = 3000;
    else if(UI_Mode==LIN_UI)
        MAX_LEN = UI_CANDSTR;

    if(code>=TEXT('A') && code<=TEXT('Z')) {

        if(lpEngPrivate->PrivateArea.Comp_Status.dwPPTFH==0) //QuanJiao Switch if Off
            return (1);  //English char don't do any process ,only return a status
        else {
            CapKeyProc(code);  //Process quanjiao char
            return (2);
        }
    } else {
                    //Capslock is up*/
        switch (code) {    
        case 0x08:         //Bac    kspace key
            ret_state = DelDoubleBuf();
            break;
        case 0x1b:
            ClrDoubleBuf();
            lpEngPrivate->PrivateArea.Comp_Status.dwSTLX = 0;
            ret_state = 0;
            break;
        case TEXT('='):
            if (CodeAIndex[code] != 0 )
                goto here;
            else {          
                if ((lpEngPrivate->PrivateArea.Comp_Context.PromptCnt==0) || (lpEngPrivate->PrivateArea.Comp_Status.dwInvalid==1)) 
                    ret_state = 1;
                else {
                    PageDnUp(1);
                    ret_state = 0;
                }
            }
            break;
        case TEXT('-'):
            if (CodeAIndex[code] != 0 )
                goto here;
            else {          
                if ((lpEngPrivate->PrivateArea.Comp_Context.PromptCnt==0) || (lpEngPrivate->PrivateArea.Comp_Status.dwInvalid==1)) 
                    ret_state = 1;
                else {
                    PageDnUp(0);
                    ret_state = 0;
                }
            }
            break;
        case 0x21:    //PGUP
            if ((lpEngPrivate->PrivateArea.Comp_Context.PromptCnt==0) || (lpEngPrivate->PrivateArea.Comp_Status.dwInvalid==1)) 
                ret_state = 1;
            else {
                PageDnUp(0);
                ret_state = 0;
            }
            break;
        case 0x22:    //VK_PGDN 
            if ((lpEngPrivate->PrivateArea.Comp_Context.PromptCnt==0) || (lpEngPrivate->PrivateArea.Comp_Status.dwInvalid==1)) 
                ret_state = 1;
            else {
                PageDnUp(1);
                ret_state = 0;
            }
            break;
        /////////////////
        case 0x23:    //VK_END
            if ((lpEngPrivate->PrivateArea.Comp_Context.PromptCnt==0) || (lpEngPrivate->PrivateArea.Comp_Status.dwInvalid==1)) 
                ret_state = 1;
            else {
                TurnToEndPage();
                ret_state = 0;
            }
            break;
        case 0x24:    //VK_HOME
            if ((lpEngPrivate->PrivateArea.Comp_Context.PromptCnt==0) || (lpEngPrivate->PrivateArea.Comp_Status.dwInvalid==1)) 
                ret_state = 1;
            else {
                TurnToFirstPage();
                ret_state = 0;
            }
            break;
        default:
        here:            
            if (lpEngPrivate->PrivateArea.Comp_Status.dwSTLX==1) {
                if(code>=TEXT('0') && code<=TEXT('9') && c_state==1) {
                    ret_state = LXSelectCandi(code);            // select candidate
                } else if(CodeAIndex[code] != 0) {
                    ClrDoubleBuf();
                    lpEngPrivate->PrivateArea.Comp_Status.dwSTLX = 0;
                    ret_state = CoreUnitProcess(code);           //Retriver MB
                } else if(code>=TEXT('0') && code <=TEXT('9')) {
                    ret_state = LXSelectCandi(code);            // select candidate    
                } else if(code==0x20) {
                    ret_state = DefSelect();
                }
            } else {    
                if(code>=TEXT('0') && code<=TEXT('9') && c_state==1) {
                    ret_state = SelectCandi(code);            // select candidate
                } else if(CodeAIndex[code] != 0 ) {
                    //After input invalid code ,if input code_unit ,clear double buffer and begin again.
                    if (lpEngPrivate->PrivateArea.Comp_Status.dwInvalid) {
                        ClrDoubleBuf();
                        lpEngPrivate->PrivateArea.Comp_Status.dwSTLX = 0;
                    } else {
                        ClrSelBuf();
                    }
                    if (lpEngPrivate->PrivateArea.Comp_Context.PromptCnt<MaxCodes) {
                        if(lpEngPrivate->PrivateArea.Comp_Context.PromptCnt!=0    && _tcschr(lpEngPrivate->PrivateArea.Comp_Context.szInBuffer,WildChar)!=NULL) 
                            ret_state = WildProcess(code);
                        else
                            ret_state = CoreUnitProcess(code);          //Retriver MB
                    
                        if ((lpEngPrivate->PrivateArea.Comp_Status.dwInvalid==1) && (lpEngPrivate->PrivateArea.Comp_Context.PromptCnt<MaxCodes)) {
                            lpEngPrivate->PrivateArea.Comp_Context.szInBuffer[lpEngPrivate->PrivateArea.Comp_Context.PromptCnt] = code;
                            lpEngPrivate->PrivateArea.Comp_Context.szInBuffer[lpEngPrivate->PrivateArea.Comp_Context.PromptCnt+1] = 0x0;
                            lpEngPrivate->PrivateArea.Comp_Context.PromptCnt ++;
                            MessageBeep((UINT)-1);
                        }
                    }
                } else if(code>=TEXT('0') && code<=TEXT('9')) {
                    if(NumInSet())
                        ret_state = 1;
                    else 
                        ret_state = SelectCandi(code);            // select candidate
                } else if(code==0x20) {
                    ret_state = DefSelect();
                } else if (lpEngPrivate->PrivateArea.Comp_Context.PromptCnt==0) {
                    ret_state = 1;
                } else if(code == WildChar) {
                    ClrSelBuf();
                    if ((lpEngPrivate->PrivateArea.Comp_Status.dwInvalid==0) || (lpEngPrivate->PrivateArea.Comp_Context.PromptCnt<MaxCodes)) {
                        ret_state = WildProcess(code);
                     
                        if ((lpEngPrivate->PrivateArea.Comp_Status.dwInvalid==1) && (lpEngPrivate->PrivateArea.Comp_Context.PromptCnt<MaxCodes)) {
                            lpEngPrivate->PrivateArea.Comp_Context.szInBuffer[lpEngPrivate->PrivateArea.Comp_Context.PromptCnt] = code;
                            lpEngPrivate->PrivateArea.Comp_Context.szInBuffer[lpEngPrivate->PrivateArea.Comp_Context.PromptCnt+1] = 0x0;
                            lpEngPrivate->PrivateArea.Comp_Context.PromptCnt ++;
                        }
                    }
                }
            }                                                  
        }
        ImmUnlockIMCC(HmemPri);
        return (ret_state);                                
    }
}

int WINAPI StartEngine(HIMCC HmemPri) {
    HANDLE         hFile,hCProcess,hMProcess;
    TCHAR         path_name[MAX_PATH];
    int         i,j;
    TCHAR         *tepstr;
    int         byte_t_read;
    PSECURITY_ATTRIBUTES psa = NULL;

    lpEngPrivate = (PPRIVCONTEXT) ImmLockIMCC(HmemPri);        
    if(!lpEngPrivate){
        return (0);
    }

//bugfix to get current mb_name
    lstrcpy(lpEngPrivate->MB_Name,HMapTab[0].MB_Name);
    
    for (i=0;i<MaxTabNum;i++ ) {
        if(lstrcmp(HMapTab[i].MB_Name,lpEngPrivate->MB_Name)==0) {
            break;
        }
    }
    if(HMapTab[i].RefCnt) {
        lstrcpy(lpEngPrivate->EMB_Name,lpEngPrivate->MB_Name);
        tepstr = _rtcschr(lpEngPrivate->EMB_Name,TEXT('.'));
        *tepstr = TEXT('\0');
        lstrcat(lpEngPrivate->EMB_Name,TEXT(".EMB"));
        lpEngPrivate->PrivateArea.hMapMB = OpenFileMapping(FILE_MAP_READ|FILE_MAP_WRITE,
                                                           FALSE,
                                                           HMapTab[i].MB_Obj);

        hCProcess = GetCurrentProcess();
        hMProcess = OpenProcess(STANDARD_RIGHTS_REQUIRED|PROCESS_DUP_HANDLE,
                                FALSE,HMapTab[i].EMB_ID);
        byte_t_read = DuplicateHandle(hMProcess,
                                      HMapTab[i].hMbFile,
                                      hCProcess,
                                      &lpEngPrivate->PrivateArea.hMbFile,
                                      0,
                                      FALSE,
                                      DUPLICATE_SAME_ACCESS);

        if (HMapTab[i].hEmbFile!=NULL) {
            DuplicateHandle(hMProcess,
                            HMapTab[i].hEmbFile,
                            hCProcess,
                            &lpEngPrivate->PrivateArea.hEmbFile,
                            0,
                            FALSE,
                            DUPLICATE_SAME_ACCESS);
            
            HmemEMB_Table = OpenFileMapping(FILE_MAP_READ|FILE_MAP_WRITE,
                                            FALSE,
                                            HMapTab[i].EMB_Obj);
            if(HmemEMB_Table!=NULL) {
                lpEngPrivate->PrivateArea.GlobVac.EMB_Exist = 1;
                if (EMBM) UnmapViewOfFile(EMBM);

                EMBM =MapViewOfFile(HmemEMB_Table,
                                    FILE_MAP_READ|FILE_MAP_WRITE,
                                    0,
                                    0,
                                    0);

                 lpEngPrivate->PrivateArea.GlobVac.EMB_Count = *(WORD *)EMBM;
                EMB_Table = (EMB_Head *)(EMBM+2);
                lpEngPrivate->PrivateArea.hMapEMB = HmemEMB_Table ;        
             } else
                 lpEngPrivate->PrivateArea.GlobVac.EMB_Exist = 0;    
                
        } else {
            lpEngPrivate->PrivateArea.hMapEMB = NULL ;        
            lpEngPrivate->PrivateArea.GlobVac.EMB_Exist = 0;    
        }
        GetMBHead();
        
    } else {
        if (!GetMBHead()) {
            ImmUnlockIMCC(HmemPri);
            return(0);
        }        

        lstrcpy(path_name, sImeG.szIMESystemPath);
        lstrcat(path_name,TEXT("\\"));    
        lstrcat(path_name, lpEngPrivate->MB_Name);

        psa = CreateSecurityAttributes();

        hFile = CreateFile(path_name,
                           GENERIC_READ,
                           FILE_SHARE_READ,
                           psa,
                           OPEN_EXISTING,
                           0,
                           NULL);

        if(hFile==INVALID_HANDLE_VALUE)    {
            FreeSecurityAttributes(psa);
            MessageBeep((UINT)-1);
            ImmUnlockIMCC(HmemPri);
            return(0);
        }

        HMapTab[i].hMbFile = hFile;
        lpEngPrivate->PrivateArea.hMbFile = hFile;
        lstrcpy(HMapTab[i].MB_Obj, lpEngPrivate->MB_Name);
        tepstr = _rtcschr(HMapTab[i].MB_Obj,TEXT('.'));
        *tepstr = TEXT('\0');
        HMapTab[i].EMB_Obj[0] = TEXT('e');
        HMapTab[i].EMB_Obj[1] = 0;
        lstrcat(HMapTab[i].EMB_Obj,HMapTab[i].MB_Obj);
        HMapTab[i].EMB_ID = GetCurrentProcessId();

        lpEngPrivate->PrivateArea.hMapMB = CreateFileMapping(hFile,
                                                             psa,
                                                             PAGE_READONLY,
                                                             0,
                                                             0,
                                                             HMapTab[i].MB_Obj);
        
        if(lpEngPrivate->PrivateArea.GlobVac.EMB_Exist = GetEMBHead()) {
        
            HMapTab[i].hEmbFile = lpEngPrivate->PrivateArea.hEmbFile;            
            HmemEMB_Table = CreateFileMapping(lpEngPrivate->PrivateArea.hEmbFile,
                                              psa,
                                              PAGE_READWRITE,
                                              0,
                                              sizeof(EMB_Head)*MAXNUMBER_EMB+2,
                                              HMapTab[i].EMB_Obj); 

            if (EMBM) UnmapViewOfFile(EMBM);

            EMBM = (LPBYTE)MapViewOfFile(HmemEMB_Table,
                                         FILE_MAP_READ|FILE_MAP_WRITE,
                                         0,
                                         0,
                                         sizeof(EMB_Head)*MAXNUMBER_EMB+2);
        
            EMB_Table =(EMB_Head *)(EMBM + 2);
            lpEngPrivate->PrivateArea.hMapEMB = HmemEMB_Table ;

        } else {
            HMapTab[i].hEmbFile = NULL;
            lpEngPrivate->PrivateArea.hEmbFile = NULL;
            lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQStartPos = 0;
            lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCStartPos = 0;
            lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQEndPos = 0;
            lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCEndPos = 0;
            
            EMB_Table = NULL;                         
            lpEngPrivate->PrivateArea.GlobVac.EMB_Count = 0;
        }
     
      }

    HMapTab[i].RefCnt ++;
    lpEngPrivate->PrivateArea.Comp_Context.PromptCnt = 0;
    if (psa != NULL)
            FreeSecurityAttributes(psa);
    ImmUnlockIMCC(HmemPri);
    return(1);
}


int WINAPI EndEngine(HIMCC HmemPri) {
    int i;
    int state;

    lpEngPrivate = (PPRIVCONTEXT) ImmLockIMCC(HmemPri);                  
    if(!lpEngPrivate){
        return (0);
    }

    for(i=0; i<MaxTabNum; i++ ) {
        if(lstrcmp(lpEngPrivate->MB_Name, HMapTab[i].MB_Name)==0)
               break;
    }
    if(i==MaxTabNum) {
        ImmUnlockIMCC(HmemPri);
        return(0);
    }
    if(EMBM)
        state = FlushViewOfFile(EMBM,0);
    HMapTab[i].RefCnt--;
    if(HMapTab[i].RefCnt>0)    {
        if(HMapTab[i].EMB_ID!=GetCurrentProcessId()) {
            if(lpEngPrivate->PrivateArea.hMbFile)
                state = CloseHandle(lpEngPrivate->PrivateArea.hMbFile);
            if(lpEngPrivate->PrivateArea.hEmbFile)
                state = CloseHandle(lpEngPrivate->PrivateArea.hEmbFile);
        }
    } else  {
        if(EMBM) {
            UnmapViewOfFile(EMBM);
                        EMBM = NULL;
                }
        if(lpEngPrivate->PrivateArea.hMbFile)
            state = CloseHandle(lpEngPrivate->PrivateArea.hMbFile);
        if(lpEngPrivate->PrivateArea.hEmbFile){

            SetFilePointer(lpEngPrivate->PrivateArea.hEmbFile,
                           lpEngPrivate->PrivateArea.GlobVac.EMB_Count*sizeof(EMB_Head)+2,
                           NULL,
                           FILE_BEGIN);

            state = SetEndOfFile(lpEngPrivate->PrivateArea.hEmbFile);
            state = CloseHandle(lpEngPrivate->PrivateArea.hEmbFile);
        }
        HMapTab[i].hMbFile = NULL;
        HMapTab[i].hEmbFile = NULL;        
        HMapTab[i].RefCnt = 0;
    }
    ImmUnlockIMCC(HmemPri);
    return (1);
}
        
int GetMBHead() {
    HANDLE         hFile;
    TCHAR          path_name[MAX_PATH];
    int            i;
    MB_Head        *lpMB_Head;
    DWORD          byte_w_read,byte_t_read;
    DWORD          tag,offset;
    PSECURITY_ATTRIBUTES psa;
    BOOL           retVal;

    psa = CreateSecurityAttributes();

    lstrcpy(path_name, sImeG.szIMESystemPath);
    lstrcat(path_name,TEXT("\\"));    
    lstrcat(path_name, lpEngPrivate->MB_Name);

    hFile = CreateFile(path_name,
                       GENERIC_READ,
                       FILE_SHARE_READ,
                       psa,
                       OPEN_EXISTING,
                       0,
                       NULL);

    FreeSecurityAttributes(psa);

    if(hFile==INVALID_HANDLE_VALUE)    {
        MessageBeep((UINT)-1);
        return(0);
    }
    
    SetFilePointer(hFile,28,NULL,FILE_BEGIN);

    for(;;) {
        byte_t_read = 0;
        retVal = ReadFile(hFile,&tag,4,&byte_t_read,NULL);

        if ( retVal == FALSE )
        {
           CloseHandle(hFile); 
           return 0;
        }

        if(tag==TAG_DESCRIPTION)
            break;
        SetFilePointer(hFile,12,NULL,FILE_CURRENT);
    }                                             
    retVal = ReadFile(hFile,&offset,4,&byte_t_read,NULL);
    if ( retVal == FALSE )
    {
       CloseHandle(hFile); 
       return 0;
    }

    SetFilePointer(hFile,offset,NULL,FILE_BEGIN);
    SetFilePointer(hFile,NAMESIZE*sizeof(TCHAR),NULL,FILE_CURRENT);
    retVal = ReadFile(hFile,&MaxCodes,2,&byte_t_read,NULL);
    if ( retVal == FALSE )
    {
       CloseHandle(hFile); 
       return 0;
    }

    retVal = ReadFile(hFile,&NumCodes,2,&byte_t_read,NULL);
    if ( retVal == FALSE )
    {
       CloseHandle(hFile); 
       return 0;
    }
    retVal = ReadFile(hFile,UsedCode,MAXUSEDCODES*sizeof(TCHAR),&byte_t_read,NULL);
    if ( retVal == FALSE )
    {
       CloseHandle(hFile); 
       return 0;
    }

#ifdef UNICODE
//  even though byMaxElement is a BYTE, but there is an alignment issue.
//  the next member cWildChar is a TCHAR, in NT it is a WCHAR, it will skip
//  one byte to make an aligment. 
//  so we need to skip 2 bytes here

    SetFilePointer(hFile,2,NULL,FILE_CURRENT);
#else
    SetFilePointer(hFile,1,NULL,FILE_CURRENT);
#endif

    retVal = ReadFile(hFile,&WildChar,sizeof(TCHAR),&byte_t_read,NULL);
    if ( retVal == FALSE )
    {
       CloseHandle(hFile); 
       return 0;
    }


    //Get the dic_associate info.
    SetFilePointer(hFile,28,NULL,FILE_BEGIN);
    for(;;) {
        retVal = ReadFile(hFile,&tag,4,&byte_t_read,NULL);
        if ( retVal == FALSE )
        {
            CloseHandle(hFile); 
            return 0;
        }

        if(tag==TAG_BASEDICINDEX)
            break;
        SetFilePointer(hFile,12,NULL,FILE_CURRENT);
    }
    retVal = ReadFile(hFile,&offset,4,&byte_t_read,NULL);                        
    if ( retVal == FALSE )
    {
       CloseHandle(hFile); 
       return 0;
    }

    SetFilePointer(hFile,offset,NULL,FILE_BEGIN);
    retVal = ReadFile(hFile,&MaxXLen,4,&byte_t_read,NULL);
    if ( retVal == FALSE )
    {
       CloseHandle(hFile); 
       return 0;
    }

    retVal = ReadFile(hFile,CodeAIndex,128,&byte_t_read,NULL);
    if ( retVal == FALSE )
    {
       CloseHandle(hFile); 
       return 0;
    }

    lpMB_Head = MB_Head_Table;
    byte_w_read = (NumCodes+1) * sizeof(DWORD);
    for(i=0; i<NumCodes; i++) {
        retVal = ReadFile(hFile,lpMB_Head,byte_w_read,&byte_t_read,NULL);            
        if ( retVal == FALSE )
        {
            CloseHandle(hFile); 
            return 0;
        }

        lpMB_Head++;
     }
    
    CloseHandle(hFile);
    return(1);
}

BYTE GetEMBHead() {
    HANDLE         hFile;
    TCHAR          path_name[MAX_PATH];
    TCHAR          *tepstr;
    DWORD          byte_w_read,byte_t_read;
    PSECURITY_ATTRIBUTES psa;
    BOOL           retVal;

    lstrcpy(lpEngPrivate->EMB_Name,lpEngPrivate->MB_Name);
    tepstr = _rtcschr(lpEngPrivate->EMB_Name,TEXT('.'));
    if ( tepstr != NULL )
        lstrcpy(tepstr,TEXT(".EMB"));

    lstrcpy(path_name, sImeG.szIMEUserPath);
    lstrcat(path_name, TEXT("\\") );
    lstrcat(path_name,lpEngPrivate->EMB_Name);

    psa = CreateSecurityAttributes();

    hFile = CreateFile(path_name,
                       GENERIC_READ|GENERIC_WRITE,
                       FILE_SHARE_READ|FILE_SHARE_WRITE,
                       psa,
                       OPEN_EXISTING,
                       0,
                       NULL);

    FreeSecurityAttributes(psa);

    if(hFile==INVALID_HANDLE_VALUE)
        return(0);
    else if(GetFileSize(hFile,NULL)==0){
        CloseHandle(hFile);
        return (0);
    }
    
    byte_t_read = 0;
    byte_w_read = 2;

    retVal = ReadFile(hFile,&lpEngPrivate->PrivateArea.GlobVac.EMB_Count,byte_w_read,&byte_t_read,NULL);

    if ( retVal == FALSE )
    {
       CloseHandle(hFile); 
       return 0;
    }
    
    byte_t_read = 0;
    byte_w_read = lpEngPrivate->PrivateArea.GlobVac.EMB_Count * sizeof(EMB_Head);
    lpEngPrivate->PrivateArea.hEmbFile = hFile;    
    return (1);
}

UINT DelDoubleBuf() {
    if (lpEngPrivate->PrivateArea.Comp_Context.PromptCnt<=0)
        return (1);
    else {
        DelWCEdit();
        DelSelBuf();
        return(0);
    }
}

void ClrDoubleBuf() {
    ClrSelBuf();
    ClrWCBuf();
}

void ClrSelBuf() {
    lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt = 0;
    lpEngPrivate->PrivateArea.Comp_Status.dwSTMULCODE = 0;
    
    lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[0]= TEXT('\0');
    lpEngPrivate->PrivateArea.GlobVac.SBufPos = 0;
}

void DelSelBuf() {
    BYTE i;
    TCHAR incode_buf[MAXCODE];
    BYTE  code_num;
    int   w_state = 0;

    if (lpEngPrivate->PrivateArea.Comp_Context.PromptCnt==0) 
        ClrDoubleBuf();
    else {
        code_num = lpEngPrivate->PrivateArea.Comp_Context.PromptCnt;
        lstrcpyn(incode_buf,lpEngPrivate->PrivateArea.Comp_Context.szInBuffer,code_num+1);
        ClrDoubleBuf();
        for (i=0;i<code_num;i++) {
            ClrSelBuf();
            if ((incode_buf[i]!=WildChar) && (w_state!=1)) 
                CoreMBComp((char)incode_buf[i],i);
            else {
                w_state = 1;
                WildProcess(incode_buf[i]);
            }
        }
    }
}

void DelWCEdit() {

    lpEngPrivate->PrivateArea.Comp_Context.szInBuffer[lpEngPrivate->PrivateArea.Comp_Context.PromptCnt-1] = '\0';;
    lpEngPrivate->PrivateArea.Comp_Context.PromptCnt--;
    
}

void ClrWCBuf() {
    int i;

    for(i=0; i<lpEngPrivate->PrivateArea.Comp_Context.PromptCnt;i++)
        lpEngPrivate->PrivateArea.Comp_Context.szInBuffer[i] = TEXT('\0');
    lpEngPrivate->PrivateArea.Comp_Context.PromptCnt = 0;
    lpEngPrivate->PrivateArea.Comp_Status.dwInvalid    = 0;
}


UINT  CoreMBComp(TCHAR code,BYTE code_num) {
    UINT        byte_t_read;
    int         sp;
    int         edcm,bdcm;
    BYTE        search_fail = 0;
    BYTE        code_no,code_no1;
    WORD        codelen,wordlen;
    

    if(code_num == 0 ) {
        byte_t_read = ReadArea(code);        
        if(byte_t_read!=0)    {
            lpEngPrivate->PrivateArea.Comp_Proc.dBDicStartPos = 0;
            lpEngPrivate->PrivateArea.Comp_Proc.dBDicEndPos = byte_t_read;
            lpEngPrivate->PrivateArea.Comp_Proc.dBDicCStartPos = 0;
            lpEngPrivate->PrivateArea.Comp_Proc.dBDicCEndPos = lpEngPrivate->PrivateArea.Comp_Proc.dBDicStartPos;
            lpEngPrivate->PrivateArea.GlobVac.Area_V_Lenth = byte_t_read;
            if(lpEngPrivate->PrivateArea.GlobVac.EMB_Exist)
                SearchEMBPos(code,(BYTE)(code_num+1));
        } else {
            if(lpEngPrivate->PrivateArea.GlobVac.EMB_Exist)
                SearchEMBPos(code,(BYTE)(code_num+1));
            if (lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQStartPos == lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQEndPos)
                search_fail = 1;
            else {
                lpEngPrivate->PrivateArea.Comp_Proc.dBDicCStartPos = lpEngPrivate->PrivateArea.Comp_Proc.dBDicEndPos;
                lpEngPrivate->PrivateArea.Comp_Proc.dBDicStartPos = lpEngPrivate->PrivateArea.Comp_Proc.dBDicEndPos;
            }
        }
    } else if(code_num == 1) {        
        code_no1 = CodeAIndex[lpEngPrivate->PrivateArea.Comp_Context.szInBuffer[0]];
        code_no = CodeAIndex[code];
        sp = MB_Head_Table[code_no1-1].W_offset[code_no-1]/sizeof(TCHAR);
        lpEngPrivate->PrivateArea.Comp_Proc.dBDicStartPos = sp;
        if (code_no < NumCodes)
            lpEngPrivate->PrivateArea.Comp_Proc.dBDicEndPos = MB_Head_Table[code_no1-1].W_offset[code_no]/sizeof(TCHAR);
        else 
            lpEngPrivate->PrivateArea.Comp_Proc.dBDicEndPos = lpEngPrivate->PrivateArea.GlobVac.Area_V_Lenth;

        if (lpEngPrivate->PrivateArea.Comp_Proc.dBDicStartPos!=lpEngPrivate->PrivateArea.Comp_Proc.dBDicEndPos) {
            lpEngPrivate->PrivateArea.Comp_Proc.dBDicCStartPos = lpEngPrivate->PrivateArea.Comp_Proc.dBDicStartPos;
            lpEngPrivate->PrivateArea.Comp_Proc.dBDicCEndPos = lpEngPrivate->PrivateArea.Comp_Proc.dBDicStartPos;
            if(lpEngPrivate->PrivateArea.GlobVac.EMB_Exist)
                SearchEMBPos(code,(BYTE)(code_num+1));
        } else {
            if(lpEngPrivate->PrivateArea.GlobVac.EMB_Exist)
                SearchEMBPos(code,(BYTE)(code_num+1));
            if (lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQStartPos == lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQEndPos)
                search_fail = 1;
            else {
                lpEngPrivate->PrivateArea.Comp_Proc.dBDicCStartPos = lpEngPrivate->PrivateArea.Comp_Proc.dBDicEndPos;
                   lpEngPrivate->PrivateArea.Comp_Proc.dBDicStartPos = lpEngPrivate->PrivateArea.Comp_Proc.dBDicEndPos;
            }
        }
    } else if (code_num<MaxCodes) {
        sp = lpEngPrivate->PrivateArea.Comp_Proc.dBDicStartPos;
        if(sp < lpEngPrivate->PrivateArea.Comp_Proc.dBDicEndPos) {
            for(;;) {
                codelen = ZM_Area[sp];
                if ((codelen > code_num) && (ZM_Area[sp+code_num+1]==code))
                    break;
                else {
                    sp += (codelen+1); 
                    wordlen = ZM_Area[sp];
                    sp += (2*wordlen/sizeof(TCHAR)+1);
                }
                if(sp >= lpEngPrivate->PrivateArea.Comp_Proc.dBDicEndPos)
                    break;
            }
            if (sp != lpEngPrivate->PrivateArea.Comp_Proc.dBDicEndPos)  {// no this code_word
                lpEngPrivate->PrivateArea.Comp_Proc.dBDicStartPos = sp;
                for(;;) {
                    codelen = ZM_Area[sp];
                    if (ZM_Area[sp+code_num+1]>code) 
                        break;           
                    else {
                        sp += (codelen+1); 
                        wordlen = ZM_Area[sp];
                        sp += (2*wordlen/sizeof(TCHAR)+1);
                    }
                    if(sp >= lpEngPrivate->PrivateArea.Comp_Proc.dBDicEndPos)
                        break;
                }
                   lpEngPrivate->PrivateArea.Comp_Proc.dBDicEndPos = sp;
                lpEngPrivate->PrivateArea.Comp_Proc.dBDicCStartPos = lpEngPrivate->PrivateArea.Comp_Proc.dBDicStartPos;
                lpEngPrivate->PrivateArea.Comp_Proc.dBDicCEndPos = lpEngPrivate->PrivateArea.Comp_Proc.dBDicStartPos;
                if(lpEngPrivate->PrivateArea.GlobVac.EMB_Exist)
                    SearchEMBPos(code,(BYTE)(code_num+1));
            } else {
                if(lpEngPrivate->PrivateArea.GlobVac.EMB_Exist)
                    SearchEMBPos(code,(BYTE)(code_num+1));
                if (lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQStartPos == lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQEndPos)
                    search_fail = 1;
                else {
                    lpEngPrivate->PrivateArea.Comp_Proc.dBDicCStartPos = lpEngPrivate->PrivateArea.Comp_Proc.dBDicEndPos;
                    lpEngPrivate->PrivateArea.Comp_Proc.dBDicStartPos = lpEngPrivate->PrivateArea.Comp_Proc.dBDicEndPos;
                }
            }
        } else {
            if(lpEngPrivate->PrivateArea.GlobVac.EMB_Exist)
                SearchEMBPos(code,(BYTE)(code_num+1));
            if (lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQStartPos == lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQEndPos)
                search_fail = 1;
            else {
                lpEngPrivate->PrivateArea.Comp_Proc.dBDicCStartPos = lpEngPrivate->PrivateArea.Comp_Proc.dBDicEndPos;
                lpEngPrivate->PrivateArea.Comp_Proc.dBDicStartPos = lpEngPrivate->PrivateArea.Comp_Proc.dBDicEndPos;
            }
        }

    } else {        // too many key
        search_fail =1;
    }
    

    if(!search_fail) {
        lpEngPrivate->PrivateArea.Comp_Context.szInBuffer[lpEngPrivate->PrivateArea.Comp_Context.PromptCnt] = code;
        lpEngPrivate->PrivateArea.Comp_Context.PromptCnt ++;
        lpEngPrivate->PrivateArea.Comp_Context.szInBuffer[lpEngPrivate->PrivateArea.Comp_Context.PromptCnt] = TEXT('\0');

        lpEngPrivate->PrivateArea.GlobVac.ST_MUL_Cnt = 0;
        lpEngPrivate->PrivateArea.GlobVac.Cur_MB = 1;    
                        
        bdcm = SearchMBCompMatch(code_num);
        if(lpEngPrivate->PrivateArea.GlobVac.SBufPos==0) {  //Selectbuf is empty
            lpEngPrivate->PrivateArea.GlobVac.Cur_MB = 0;
            edcm = SearchEMBCompMatch();
        } else if(GetLengthofBuf() < MAX_LEN)
            edcm = SearchEMBCompMatch();
        if(GetLengthofBuf()>=MAX_LEN) {
            lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
        }
        else {
            lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCStartPos = lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCEndPos;
            SearchEMBWildMatch();
            if (((lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCEndPos==lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQEndPos)||(lpEngPrivate->PrivateArea.GlobVac.EMB_Exist==0))&&(GetLengthofBuf() < MAX_LEN)) {
                lpEngPrivate->PrivateArea.Comp_Proc.dBDicCStartPos = lpEngPrivate->PrivateArea.Comp_Proc.dBDicCEndPos;
                SearchMBWildMatch(lpEngPrivate->PrivateArea.Comp_Context.PromptCnt);
            } else {
                lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
                lpEngPrivate->PrivateArea.GlobVac.SBufPos ++;
            }
        }
        if (lpEngPrivate->PrivateArea.GlobVac.SBufPos==0) {
            lpEngPrivate->PrivateArea.Comp_Context.szInBuffer[lpEngPrivate->PrivateArea.Comp_Context.PromptCnt-1] = 0x0;
            lpEngPrivate->PrivateArea.Comp_Context.PromptCnt --;            
            lpEngPrivate->PrivateArea.Comp_Status.dwInvalid    = 1;
            return(0);
        } else {
            lpEngPrivate->PrivateArea.GlobVac.Page_Num = 1;
            lpEngPrivate->PrivateArea.Comp_Status.dwInvalid    = 0;
            return (1);
        }
    } else {     // Invalid code
        lpEngPrivate->PrivateArea.Comp_Status.dwInvalid    = 1;
        return(0);
    }
}

UINT WildProcess(TCHAR code) {
    if (lpEngPrivate->PrivateArea.Comp_Context.PromptCnt==MaxCodes) {
        MessageBeep((UINT)-1);
        return(0);
    }        
    // wild search clear multi code number
    lpEngPrivate->PrivateArea.GlobVac.ST_MUL_Cnt = 0;            
    lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCStartPos = lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQStartPos;
    lpEngPrivate->PrivateArea.Comp_Proc.dBDicCStartPos = lpEngPrivate->PrivateArea.Comp_Proc.dBDicStartPos;
    lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCEndPos = lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQStartPos;
    lpEngPrivate->PrivateArea.Comp_Proc.dBDicCEndPos = lpEngPrivate->PrivateArea.Comp_Proc.dBDicStartPos;
    
    SearchEMBWWMatch(code,lpEngPrivate->PrivateArea.Comp_Context.PromptCnt);
    if ((lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCEndPos==lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQEndPos)&&(GetLengthofBuf() <MAX_LEN)) {
        lpEngPrivate->PrivateArea.Comp_Proc.dBDicCStartPos = lpEngPrivate->PrivateArea.Comp_Proc.dBDicStartPos;
        SearchMBWWMatch(code,lpEngPrivate->PrivateArea.Comp_Context.PromptCnt);
    } 
    lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
    
    if (lpEngPrivate->PrivateArea.GlobVac.SBufPos!=0) {
        lpEngPrivate->PrivateArea.Comp_Context.szInBuffer[lpEngPrivate->PrivateArea.Comp_Context.PromptCnt] = code;        
        lpEngPrivate->PrivateArea.Comp_Context.PromptCnt++;
    } else {
        lpEngPrivate->PrivateArea.Comp_Context.szInBuffer[lpEngPrivate->PrivateArea.Comp_Context.PromptCnt] = code;
        lpEngPrivate->PrivateArea.Comp_Context.szInBuffer[lpEngPrivate->PrivateArea.Comp_Context.PromptCnt+1] = 0x0;
        lpEngPrivate->PrivateArea.Comp_Context.PromptCnt ++;
    }
    return (0);    
}

int MBWCWildComp(TCHAR code,BYTE code_num,int sp) {
    TCHAR codebuf[13];
    int  i;

    lstrcpyn(codebuf,lpEngPrivate->PrivateArea.Comp_Context.szInBuffer,code_num+1);
    codebuf[code_num] = code;
    codebuf[code_num+1] = 0x0;
    for(i=0; i<=code_num;i++) {
        if((codebuf[i] != ZM_Area[sp+i+1]) && codebuf[i]!=WildChar)
            return(0);
    }
    return (1);
}

void SearchBMBWWMatch(TCHAR code,BYTE code_num){
    int    j;  
    int    i,end_pos;
    int    wordlen,len;
    LPTSTR lpStr;
    TCHAR  tepbuf[130];
    TCHAR  codebuf[13], codelen;

    end_pos = lpEngPrivate->PrivateArea.Comp_Proc.dBDicCEndPos-1 ;
    for(;;) {
        j = 0;
        i = end_pos;
        if(i<=lpEngPrivate->PrivateArea.Comp_Proc.dBDicStartPos)
            break;
        wordlen = VerScan_Word(i,tepbuf);
        i -= (wordlen+1);
        j = wordlen;
        for (;;) {
            if (InCodeSet(ZM_Area[i])==0)
                break;
            i--;
        }
        codelen = ZM_Area[i];
        
        if ((codelen == code_num+1) && (MBWCWildComp(code,code_num,i)==1)){
            len = WildInBuffer();
            lstrcpyn(codebuf,ZM_Area+i+len+1,codelen-len+1);
            codebuf[codelen-len] = 0;
            if(MBIndex.IMEChara[0].IC_CTC==1) {
                if(GetLengthofBuf()+GetLengthTepBuf(tepbuf)+GetLengthTepBuf(TEXT("9:"))+GetLengthTepBuf(codebuf) > MAX_LEN) {
                    lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
                    break;
                }
            } else {
                if (GetLengthofBuf()+GetLengthTepBuf(tepbuf)+GetLengthTepBuf(TEXT("9:")) > MAX_LEN) { // SelectBuf is Overflow
                    lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
                    break;
                }
            }

            if (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt==IME_MAXCAND) {  // words count is enough
                lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
                break;                                                  
            } else if ((MBIndex.IMEChara[0].IC_CZ==1) || (j==2/sizeof(TCHAR))) {
#if defined(COMBO_IME)
                {
                    int k;
                    BOOL ISGBK = FALSE;

                    if(MBIndex.IMEChara[0].IC_GB){ //should test GB/GBK
                        for(k=0;k<j;k+=2/sizeof(TCHAR)){  
                            if(ISGBK = IsGBK(&tepbuf[k])){//out of GB range
                                break;
                            }
                        }
                        if(ISGBK){
                            i --;
                            end_pos = i;
                        }else{
                            lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt = (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1);
                            lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,tepbuf,j+1);
                            lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt%IME_MAXCAND] = (BYTE)(lpEngPrivate->PrivateArea.GlobVac.SBufPos);
                            lpEngPrivate->PrivateArea.GlobVac.SBufPos += j;
                            if (MBIndex.IMEChara[0].IC_CTC) {
                                lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,ZM_Area+i+len+1,codelen-len+1);
                                lpEngPrivate->PrivateArea.GlobVac.SBufPos += (codelen-len);
                            }
                            lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT(' ');
                            lpEngPrivate->PrivateArea.GlobVac.SBufPos ++;
                            i --;
                            end_pos = i;
                        }
                    }else{
                            lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt = (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1);
                            lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,tepbuf,j+1);
                            lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt%IME_MAXCAND] = (BYTE)(lpEngPrivate->PrivateArea.GlobVac.SBufPos);
                            lpEngPrivate->PrivateArea.GlobVac.SBufPos += j;
                            if (MBIndex.IMEChara[0].IC_CTC) {
                                lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,ZM_Area+i+len+1,codelen-len+1);
                                lpEngPrivate->PrivateArea.GlobVac.SBufPos += (codelen-len);
                            }
                            lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT(' ');
                            lpEngPrivate->PrivateArea.GlobVac.SBufPos ++;
                            i --;
                            end_pos = i;
                    }

                }
#else
                lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt = (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1);
                lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,tepbuf,j+1);
                lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt%IME_MAXCAND] = lpEngPrivate->PrivateArea.GlobVac.SBufPos;
                lpEngPrivate->PrivateArea.GlobVac.SBufPos += j;
                if (MBIndex.IMEChara[0].IC_CTC) {
                    lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,ZM_Area+i+len+1,codelen-len+1);
                    lpEngPrivate->PrivateArea.GlobVac.SBufPos += (codelen-len);
                }
                lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT(' ');
                lpEngPrivate->PrivateArea.GlobVac.SBufPos ++;
                i --;
                end_pos = i;
#endif //COMBO_IME
            }
        } else {
            i--;
            end_pos = i;
        }
            
    }
    lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
    if (end_pos<=lpEngPrivate->PrivateArea.Comp_Proc.dBDicStartPos )
        lpEngPrivate->PrivateArea.Comp_Proc.dBDicCStartPos = lpEngPrivate->PrivateArea.Comp_Proc.dBDicStartPos;
    else 
        lpEngPrivate->PrivateArea.Comp_Proc.dBDicCStartPos = end_pos+1;
    return ;
}

void SearchMBWWMatch(TCHAR code,BYTE code_num) { 
    int       j;
    int     i,start_pos,sp;
    LPTSTR    lpStr;
    TCHAR     tepbuf[130];
    int     wordlen,len;
    TCHAR    codebuf[13], codelen;

    start_pos = lpEngPrivate->PrivateArea.Comp_Proc.dBDicCStartPos;
    i = start_pos;
    for(;;) {
        
        codelen = ZM_Area[i];
           if ((codelen == code_num+1) && (MBWCWildComp(code,code_num,i)==1)) {
               sp = i;
               j = 0;
            i += (codelen+1);
            wordlen = Scan_Word(i,tepbuf);
            i += (wordlen+1);
            j = wordlen;
            len = WildInBuffer();
            if ((MBIndex.IMEChara[0].IC_CZ==1) || (j==2/sizeof(TCHAR))) {
                lstrcpyn(codebuf,ZM_Area+i+len+1,codelen-len+1);
                codebuf[codelen-len] = 0;
                if(MBIndex.IMEChara[0].IC_CTC==1) {
                    if(GetLengthofBuf()+GetLengthTepBuf(tepbuf)+GetLengthTepBuf(TEXT("9:"))+GetLengthTepBuf(codebuf) > MAX_LEN) {
                        lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
                        break;
                    }
                } else {
                    if (GetLengthofBuf()+GetLengthTepBuf(tepbuf)+GetLengthTepBuf(TEXT("9:")) > MAX_LEN) { // SelectBuf is Overflow
                        lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
                        break;
                    }
                }
                if (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt==IME_MAXCAND) {
                    lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
                    break;
                }
#if defined(COMBO_IME)
                {
                    int k;
                    BOOL ISGBK = FALSE;

                    if(MBIndex.IMEChara[0].IC_GB){ //should test GB/GBK
                        for(k=0;k<j;k+=2/sizeof(TCHAR)){  
                            if(ISGBK = IsGBK(&tepbuf[k])){//out of GB range
                                break;
                            }
                        }
                        if(ISGBK){
                            i = Skip_CaWord(i);        
                        }else{
                            lpStr = lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos;
                            lstrcpyn(lpStr,tepbuf,j+1);
                            lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[(lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1)%IME_MAXCAND] = (BYTE)(lpEngPrivate->PrivateArea.GlobVac.SBufPos);
                            lpEngPrivate->PrivateArea.GlobVac.SBufPos += j;
                            if (MBIndex.IMEChara[0].IC_CTC) {
                                lpStr = lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos;
                                lstrcpyn(lpStr,ZM_Area+sp+len+1,codelen-len+1);
                                lpEngPrivate->PrivateArea.GlobVac.SBufPos += (codelen-len);
                            }
                            lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT(' ');
                            lpEngPrivate->PrivateArea.GlobVac.SBufPos ++;
                            start_pos = i;
                            lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt = (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1);
                        }
                    }else{
                        lpStr = lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos;
                        lstrcpyn(lpStr,tepbuf,j+1);
                        lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[(lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1)%IME_MAXCAND] = (BYTE)(lpEngPrivate->PrivateArea.GlobVac.SBufPos);
                        lpEngPrivate->PrivateArea.GlobVac.SBufPos += j;
                        if (MBIndex.IMEChara[0].IC_CTC) {
                            lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,ZM_Area+sp+len+1,codelen-len+1);
                            lpEngPrivate->PrivateArea.GlobVac.SBufPos += (codelen-len);
                        }
                        lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT(' ');
                        lpEngPrivate->PrivateArea.GlobVac.SBufPos ++;
                        start_pos = i;
                        lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt = (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1);
                    }

                }
#else
                lpStr = lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos;
                lstrcpyn(lpStr,tepbuf,j+1);
                lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[(lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1)%IME_MAXCAND] = lpEngPrivate->PrivateArea.GlobVac.SBufPos;
                lpEngPrivate->PrivateArea.GlobVac.SBufPos += j;
                if (MBIndex.IMEChara[0].IC_CTC) {
                    lpStr = lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos;
                    lstrcpyn(lpStr,ZM_Area+sp+len+1,codelen-len+1);
                    lpEngPrivate->PrivateArea.GlobVac.SBufPos += (codelen-len);
                }
                lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT(' ');
                lpEngPrivate->PrivateArea.GlobVac.SBufPos ++;
                start_pos = i;
                lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt = (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1);
#endif //COMBO_IME
                
            } 
        } else {
            i = Skip_CaWord(i);        
        }
        if (i>=lpEngPrivate->PrivateArea.Comp_Proc.dBDicEndPos)
            break;
    }

    if (i>= lpEngPrivate->PrivateArea.Comp_Proc.dBDicEndPos) {
        lpEngPrivate->PrivateArea.Comp_Proc.dBDicCEndPos = lpEngPrivate->PrivateArea.Comp_Proc.dBDicEndPos;
    } else {
        lpEngPrivate->PrivateArea.Comp_Proc.dBDicCEndPos = start_pos;
    }
}


UINT SearchMBCompMatch(TCHAR code_num) {
    int       j;
    int       i,start_pos;
    int       match_s = 0;
    LPTSTR    lpStr;
    TCHAR     tepbuf[130], codelen;
    int       wordlen;

    lpEngPrivate->PrivateArea.GlobVac.SBufPos = 0;
    start_pos = lpEngPrivate->PrivateArea.Comp_Proc.dBDicCStartPos;
    i = start_pos;
    for(;;) {
            if (i>=lpEngPrivate->PrivateArea.Comp_Proc.dBDicEndPos)
                break;

            codelen = ZM_Area[i];

            if (codelen == code_num+1 ) {
                j = 0;
                i += (codelen+1);
                wordlen = Scan_Word(i,tepbuf);
                i += (wordlen+1);
                j = wordlen;
            
                if ((MBIndex.IMEChara[0].IC_CZ==1) || (j==2/sizeof(TCHAR))) {
                if (GetLengthofBuf()+GetLengthTepBuf(tepbuf)+GetLengthTepBuf(TEXT("9:"))<=MAX_LEN) { //SelectBuffer enough
                
                    if (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt==IME_MAXCAND) {
                        lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
                        break;
                    }
#if defined(COMBO_IME)
                {
                    int k;
                    BOOL ISGBK = FALSE;

                    if(MBIndex.IMEChara[0].IC_GB){ //should test GB/GBK
                        for(k=0;k<j;k+=2/sizeof(TCHAR)){  
                            if(ISGBK = IsGBK(&tepbuf[k])){//out of GB range
                                break;
                            }
                        }
                        if(ISGBK){
                        }else{
                            lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,tepbuf,j+1);
                            lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[(lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1)%IME_MAXCAND] = (BYTE)(lpEngPrivate->PrivateArea.GlobVac.SBufPos);
                            lpEngPrivate->PrivateArea.GlobVac.SBufPos += j;
                            lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT(' ');
                            lpEngPrivate->PrivateArea.GlobVac.SBufPos ++;
                            match_s ++;
                            start_pos = i;
                            lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt = (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1);
                        }
                    }else{
                        lpStr = (LPTSTR)lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos;
                        lstrcpyn(lpStr,tepbuf,j+1);
                        lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[(lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1)%IME_MAXCAND] = (BYTE)(lpEngPrivate->PrivateArea.GlobVac.SBufPos);
                        lpEngPrivate->PrivateArea.GlobVac.SBufPos += j;
                        lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT(' ');
                        lpEngPrivate->PrivateArea.GlobVac.SBufPos ++;
                        match_s ++;
                        start_pos = i;
                        lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt = (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1);
                    }

                }
#else
                    lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,tepbuf,j+1);
                    lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[(lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1)%IME_MAXCAND] = lpEngPrivate->PrivateArea.GlobVac.SBufPos;
                    lpEngPrivate->PrivateArea.GlobVac.SBufPos += j;
                    lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT(' ');
                    lpEngPrivate->PrivateArea.GlobVac.SBufPos ++;
                    match_s ++;
                    start_pos = i;
                    lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt = (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1);
#endif ///COMBO_IME
                } else {
                    lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
                    break;
                }
            } 
        } else 
            break;
    }

    if (start_pos>= lpEngPrivate->PrivateArea.Comp_Proc.dBDicEndPos) {
        lpEngPrivate->PrivateArea.Comp_Proc.dBDicCEndPos = lpEngPrivate->PrivateArea.Comp_Proc.dBDicEndPos;
    } else {
        lpEngPrivate->PrivateArea.Comp_Proc.dBDicCEndPos = start_pos;
    }
    lpEngPrivate->PrivateArea.Comp_Proc.dBDicMCSPos = lpEngPrivate->PrivateArea.Comp_Proc.dBDicCEndPos;
;

    lpEngPrivate->PrivateArea.GlobVac.ST_MUL_Cnt = (BYTE)match_s;
    return (match_s);
}

void SearchBMBCompMatch() {
    int j;  
    int i,end_pos;
    int wordlen;
    TCHAR codelen, tepbuf[130];

    end_pos = lpEngPrivate->PrivateArea.Comp_Proc.dBDicCEndPos-1 ;
    for(;;) {
        j = 0;
        i = end_pos;
        if(i<=lpEngPrivate->PrivateArea.Comp_Proc.dBDicStartPos)
            break;
        wordlen = VerScan_Word(i,tepbuf);
        i -= (wordlen+1);
        j = wordlen;
        for (;;) {
            if (InCodeSet(ZM_Area[i])==0)
                break;
            i--;
        }
        codelen = ZM_Area[i];
        if (GetLengthofBuf()+GetLengthTepBuf(tepbuf)+GetLengthTepBuf(TEXT("9:")) > MAX_LEN) { //SelectBuffer enough
            lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
            break;    
        }
        else if (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt==IME_MAXCAND) {  // words count is enough
            lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
            break;                                                  
        } else if ((MBIndex.IMEChara[0].IC_CZ==1) || (j==2/sizeof(TCHAR))) {
#if defined(COMBO_IME)
                {
                    int k;
                    BOOL ISGBK = FALSE;

                    if(MBIndex.IMEChara[0].IC_GB){ //should test GB/GBK
                        for(k=0;k<j;k+=2/sizeof(TCHAR)){  
                            if(ISGBK = IsGBK(&tepbuf[k])){//out of GB range
                                break;
                            }
                        }
                        if(ISGBK){
                        }else{
                            lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt = (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1);
                            lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,tepbuf,j+1);
                            lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt%IME_MAXCAND] = (BYTE)(lpEngPrivate->PrivateArea.GlobVac.SBufPos);
                            lpEngPrivate->PrivateArea.GlobVac.SBufPos += j;
        
                            lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT(' ');
                            lpEngPrivate->PrivateArea.GlobVac.SBufPos ++;
                            i --;
                            end_pos = i;
                        }
                    }else{
                        lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt = (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1);
                        lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,tepbuf,j+1);
                        lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt%IME_MAXCAND] = (BYTE)(lpEngPrivate->PrivateArea.GlobVac.SBufPos);
                        lpEngPrivate->PrivateArea.GlobVac.SBufPos += j;
        
                        lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT(' ');
                        lpEngPrivate->PrivateArea.GlobVac.SBufPos ++;
                        i --;
                        end_pos = i;
                    }

                }
#else
            lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt = (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1);
            lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,tepbuf,j+1);
            lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt%IME_MAXCAND] = lpEngPrivate->PrivateArea.GlobVac.SBufPos;
            lpEngPrivate->PrivateArea.GlobVac.SBufPos += j;
        
            lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT(' ');
            lpEngPrivate->PrivateArea.GlobVac.SBufPos ++;
            i --;
            end_pos = i;
#endif //COMBO_IME
        }
    }
    lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
    if (end_pos<=lpEngPrivate->PrivateArea.Comp_Proc.dBDicStartPos )
        lpEngPrivate->PrivateArea.Comp_Proc.dBDicCStartPos = lpEngPrivate->PrivateArea.Comp_Proc.dBDicStartPos;
    else 
        lpEngPrivate->PrivateArea.Comp_Proc.dBDicCStartPos = end_pos+1;
    return ;
}

void SearchMBWildMatch(BYTE codecnt) {
    TCHAR tepbuf[130];
    int candi_start;  
    int i,j,start_pos;
    int wordlen;
    TCHAR codelen, codebuf[13];

    if (GetLengthofBuf()>MAX_LEN) {
        lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
        return ;
    }
    start_pos = lpEngPrivate->PrivateArea.Comp_Proc.dBDicCStartPos ;
    i = start_pos;
    for(;;) { 
        j = 0;
        if(i>=lpEngPrivate->PrivateArea.Comp_Proc.dBDicEndPos)
            break;
    
        candi_start = i;
        codelen = ZM_Area[i];
        i += (codelen+1);
        wordlen = Scan_Word(i,tepbuf);
        i += (wordlen+1);
        j = wordlen;
        if (codelen>codecnt) {
            lstrcpyn(codebuf,ZM_Area+candi_start+codecnt+1,codelen-codecnt+1);
            codebuf[codelen-codecnt] = 0;
        }
        if(MBIndex.IMEChara[0].IC_CTC==1) {
            if(GetLengthofBuf()+GetLengthTepBuf(tepbuf)+GetLengthTepBuf(TEXT("9:"))+GetLengthTepBuf(codebuf) > MAX_LEN) {
                lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
                break;
            }
        } else {
            if (GetLengthofBuf()+GetLengthTepBuf(tepbuf)+GetLengthTepBuf(TEXT("9:")) > MAX_LEN) { // SelectBuf is Overflow
                lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
                break;
            }
        }
        
        if (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt==IME_MAXCAND) {// words count is enough
            lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
            break;
        }
        else if ((MBIndex.IMEChara[0].IC_CZ==1) || (j==2/sizeof(TCHAR))) {
#if defined(COMBO_IME)
                {
                    int k;
                    BOOL ISGBK = FALSE;

                    if(MBIndex.IMEChara[0].IC_GB){ //should test GB/GBK
                        for(k=0;k<j;k+=2/sizeof(TCHAR)){  
                            if(ISGBK = IsGBK(&tepbuf[k])){//out of GB range
                                break;
                            }
                        }
                        if(ISGBK){
                        }else{
                            lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,tepbuf,j+1);
                            lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[(lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1)%IME_MAXCAND ] = (BYTE)(lpEngPrivate->PrivateArea.GlobVac.SBufPos);
                            lpEngPrivate->PrivateArea.GlobVac.SBufPos += j;
                            if(MBIndex.IMEChara[0].IC_CTC) {
                                if (codelen>codecnt) {
                                    lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,ZM_Area+candi_start+codecnt+1,codelen-codecnt+1);
                                    lpEngPrivate->PrivateArea.GlobVac.SBufPos += (codelen-codecnt);
                                }
                            }
                            lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt = (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1);
            
                            lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT(' ');
                            lpEngPrivate->PrivateArea.GlobVac.SBufPos ++;
                        }
                    }else{
                        lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,tepbuf,j+1);
                        lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[(lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1)%IME_MAXCAND ] = (BYTE)(lpEngPrivate->PrivateArea.GlobVac.SBufPos);
                        lpEngPrivate->PrivateArea.GlobVac.SBufPos += j;
                        if(MBIndex.IMEChara[0].IC_CTC) {
                            if (codelen>codecnt) {
                                lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,ZM_Area+candi_start+codecnt+1,codelen-codecnt+1);
                                lpEngPrivate->PrivateArea.GlobVac.SBufPos += (codelen-codecnt);
                            }
                        }
                        lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt = (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1);
        
                        lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT(' ');
                        lpEngPrivate->PrivateArea.GlobVac.SBufPos ++;
                    }

                }
#else
            lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,tepbuf,j+1);
            lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[(lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1)%IME_MAXCAND ] = lpEngPrivate->PrivateArea.GlobVac.SBufPos;
            lpEngPrivate->PrivateArea.GlobVac.SBufPos += j;
            if(MBIndex.IMEChara[0].IC_CTC) {
                if (codelen>codecnt) {
                    lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,ZM_Area+candi_start+codecnt+1,codelen-codecnt+1);
                    lpEngPrivate->PrivateArea.GlobVac.SBufPos += (codelen-codecnt);
                }
            }
            lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt = (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1);
        
            lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT(' ');
            lpEngPrivate->PrivateArea.GlobVac.SBufPos ++;
#endif //COMBO_IME
        }
        start_pos = i;
    }

    lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
    if (start_pos>=    lpEngPrivate->PrivateArea.Comp_Proc.dBDicEndPos )
        lpEngPrivate->PrivateArea.Comp_Proc.dBDicCEndPos = lpEngPrivate->PrivateArea.Comp_Proc.dBDicEndPos;
    else
        lpEngPrivate->PrivateArea.Comp_Proc.dBDicCEndPos = start_pos;
    lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');

    return;
}


void SearchBMBWildMatch(BYTE codecnt) {
    TCHAR tepbuf[130];
    int j;  
    int i,end_pos;
    int wordlen;
    TCHAR codelen, codebuf[13];

    end_pos = lpEngPrivate->PrivateArea.Comp_Proc.dBDicCEndPos-1 ;
    i = end_pos;
    for(;;) {
        j = 0;
    
        if(i<=lpEngPrivate->PrivateArea.Comp_Proc.dBDicMCSPos)
            break;
        wordlen = VerScan_Word(i,tepbuf);
        i -= (wordlen+1);
        j = wordlen;
        for (;;) {
            if (InCodeSet(ZM_Area[i])==0)
                break;
            i--;
        }
        codelen = ZM_Area[i];
        if(codelen>codecnt) {
            lstrcpyn(codebuf,ZM_Area+i+codecnt+1,codelen-codecnt+1);
            codebuf[codelen-codecnt] = 0;
        }        
        if(MBIndex.IMEChara[0].IC_CTC==1) {
            if(GetLengthofBuf()+GetLengthTepBuf(tepbuf)+GetLengthTepBuf(TEXT("9:"))+GetLengthTepBuf(codebuf) > MAX_LEN) {
                lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
                break;
            }
        } else {
            if (GetLengthofBuf()+GetLengthTepBuf(tepbuf)+GetLengthTepBuf(TEXT("9:")) > MAX_LEN) { // SelectBuf is Overflow
                lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
                break;    
            }
        }
        if (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt==IME_MAXCAND) {  // words count is enough
            lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
            break;                                                  
        } else if ((MBIndex.IMEChara[0].IC_CZ==1) || (j==2/sizeof(TCHAR))) {
#if defined(COMBO_IME)
                {
                    int k;
                    BOOL ISGBK = FALSE;

                    if(MBIndex.IMEChara[0].IC_GB){ //should test GB/GBK
                        for(k=0;k<j;k+=2/sizeof(TCHAR)){  
                            if(ISGBK = IsGBK(&tepbuf[k])){//out of GB range
                                break;
                            }
                        }
                        if(ISGBK){
                        }else{
                            lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt = (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1);
                            lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,tepbuf,j+1);
                            lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt%IME_MAXCAND] = (BYTE)(lpEngPrivate->PrivateArea.GlobVac.SBufPos);
                            lpEngPrivate->PrivateArea.GlobVac.SBufPos += j;
                            if(MBIndex.IMEChara[0].IC_CTC) {        
                                if (codelen>codecnt) {
                                    lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,ZM_Area+i+codecnt+1,codelen-codecnt+1);
                                    lpEngPrivate->PrivateArea.GlobVac.SBufPos += (codelen-codecnt);
                                }
                            }
                            lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT(' ');
                            lpEngPrivate->PrivateArea.GlobVac.SBufPos ++;
                            end_pos = i;
                        }
                    }else{
                        lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt = (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1);
                        lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,tepbuf,j+1);
                        lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt%IME_MAXCAND] = (BYTE)(lpEngPrivate->PrivateArea.GlobVac.SBufPos);
                        lpEngPrivate->PrivateArea.GlobVac.SBufPos += j;
                        if(MBIndex.IMEChara[0].IC_CTC) {        
                            if (codelen>codecnt) {
                                lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,ZM_Area+i+codecnt+1,codelen-codecnt+1);
                                lpEngPrivate->PrivateArea.GlobVac.SBufPos += (codelen-codecnt);
                            }
                        }
                        lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT(' ');
                        lpEngPrivate->PrivateArea.GlobVac.SBufPos ++;
                        end_pos = i;
                    }

                }
#else
            lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt = (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1);
            lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,tepbuf,j+1);
            lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt%IME_MAXCAND] = lpEngPrivate->PrivateArea.GlobVac.SBufPos;
            lpEngPrivate->PrivateArea.GlobVac.SBufPos += j;
            if(MBIndex.IMEChara[0].IC_CTC) {        
                if (codelen>codecnt) {
                    lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,ZM_Area+i+codecnt+1,codelen-codecnt+1);
                    lpEngPrivate->PrivateArea.GlobVac.SBufPos += (codelen-codecnt);
                }
            }
            lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT(' ');
            lpEngPrivate->PrivateArea.GlobVac.SBufPos ++;
            end_pos = i;
#endif //COMBO_IME
        }
        i --;
    }
    lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
    if (end_pos<=lpEngPrivate->PrivateArea.Comp_Proc.dBDicStartPos )
        lpEngPrivate->PrivateArea.Comp_Proc.dBDicCStartPos = lpEngPrivate->PrivateArea.Comp_Proc.dBDicStartPos;
    else 
        lpEngPrivate->PrivateArea.Comp_Proc.dBDicCStartPos = end_pos;//5.15 +1;
    return ;
}


void SearchBMBLXMatch() {
    TCHAR tepbuf[130];
    int   i,j,end_pos;
    int   wordlen ;
    
    end_pos = lpEngPrivate->PrivateArea.Comp_Proc.dBDicCEndPos;
    i = end_pos - 1;
    for (;;) {
        j = 0;
        wordlen = VerScan_Word(i,tepbuf);
        i -= (wordlen+1) ;
        j = wordlen;        
        if(wcsncmp(ZM_Area+i+2,lpEngPrivate->PrivateArea.Comp_Context.szLxBuffer,lpEngPrivate->PrivateArea.Comp_Context.LxStrCnt)==0 && j>lpEngPrivate->PrivateArea.Comp_Context.LxStrCnt) {
            if (GetLengthofBuf()+GetLengthTepBuf(tepbuf)+GetLengthTepBuf(TEXT("9:")) > MAX_LEN)  {// SelectBuf is Overflow
                lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
                break;
            }
            
            if (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt==IME_MAXCAND) {  // words count is enough
                lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
                break;
            }
#if defined(COMBO_IME)
                {
                    int k;
                    BOOL ISGBK = FALSE;

                    if(MBIndex.IMEChara[0].IC_GB){ //should test GB/GBK
                        for(k=0;k<j;k+=2/sizeof(TCHAR)){  
                            if(ISGBK = IsGBK(&tepbuf[k])){//out of GB range
                                break;
                            }
                        }
                        if(ISGBK){
                        }else{
                            lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt = (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1);
                            lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,tepbuf,j+1);
                            lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt%IME_MAXCAND] = (BYTE)(lpEngPrivate->PrivateArea.GlobVac.SBufPos);
                            lpEngPrivate->PrivateArea.GlobVac.SBufPos += j;
                            lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT(' ');
                            lpEngPrivate->PrivateArea.GlobVac.SBufPos ++;
                        }
                    }else{
                        lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt = (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1);
                        lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,tepbuf,j+1);
                        lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt%IME_MAXCAND] = (BYTE)(lpEngPrivate->PrivateArea.GlobVac.SBufPos);
                        lpEngPrivate->PrivateArea.GlobVac.SBufPos += j;
                        lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT(' ');
                        lpEngPrivate->PrivateArea.GlobVac.SBufPos ++;
                    }

                }
#else
            lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt = (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1);
            lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,tepbuf,j+1);
            lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt%IME_MAXCAND] = lpEngPrivate->PrivateArea.GlobVac.SBufPos;
            lpEngPrivate->PrivateArea.GlobVac.SBufPos += j;
            lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT(' ');
            lpEngPrivate->PrivateArea.GlobVac.SBufPos ++;
#endif //COMBO_IME
        }
        for (;;) {
            if (InCodeSet(ZM_Area[i])==0)
                break;
            i--;
        }
        end_pos = i;
        i --;    
        if (i<=    lpEngPrivate->PrivateArea.Comp_Proc.dBDicStartPos )
            break;
        
    }
    if (i<=lpEngPrivate->PrivateArea.Comp_Proc.dBDicStartPos )
        lpEngPrivate->PrivateArea.Comp_Proc.dBDicCStartPos = lpEngPrivate->PrivateArea.Comp_Proc.dBDicStartPos;
    else 
        lpEngPrivate->PrivateArea.Comp_Proc.dBDicCStartPos = end_pos;
}

void SearchMBLXMatch() {
    TCHAR codelen,tepbuf[130];
    int  i,j,s_pos;
    int  wordlen;
    i = lpEngPrivate->PrivateArea.Comp_Proc.dBDicCStartPos;
    for (;;) {
        j = 0;
        codelen = ZM_Area[i];
        i += (codelen+1);
        s_pos = i;
        wordlen = Scan_Word(i,tepbuf);
        i += (wordlen+1);
        j = wordlen;    
        if(wcsncmp(ZM_Area+s_pos+1,lpEngPrivate->PrivateArea.Comp_Context.szLxBuffer,lpEngPrivate->PrivateArea.Comp_Context.LxStrCnt)==0 && j>lpEngPrivate->PrivateArea.Comp_Context.LxStrCnt) {
            if(GetLengthofBuf()+GetLengthTepBuf(tepbuf)+GetLengthTepBuf(TEXT("9:")) > MAX_LEN) { // SelectBuf is Overflow
                lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
                break;
            }
            
            if (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt==IME_MAXCAND) {  // words count is enough
                lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
                break;
            }
#if defined(COMBO_IME)
                {
                    int k;
                    BOOL ISGBK = FALSE;

                    if(MBIndex.IMEChara[0].IC_GB){ //should test GB/GBK
                        for(k=0;k<j;k+=2/sizeof(TCHAR)){  
                            if(ISGBK = IsGBK(&tepbuf[k])){//out of GB range
                                break;
                            }
                        }
                        if(ISGBK){
                        }else{
                            lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,tepbuf,j+1);
                            lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt = (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1);
                            lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt%IME_MAXCAND] = (BYTE)(lpEngPrivate->PrivateArea.GlobVac.SBufPos);
                            lpEngPrivate->PrivateArea.GlobVac.SBufPos += j;
                            lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT(' ');
                            lpEngPrivate->PrivateArea.GlobVac.SBufPos ++;
                        }
                    }else{
                        lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,tepbuf,j+1);
                        lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt = (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1);
                        lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt%IME_MAXCAND] = (BYTE)(lpEngPrivate->PrivateArea.GlobVac.SBufPos);
                        lpEngPrivate->PrivateArea.GlobVac.SBufPos += j;
                        lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT(' ');
                        lpEngPrivate->PrivateArea.GlobVac.SBufPos ++;
                    }

                }
#else
            lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,tepbuf,j+1);
            lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt = (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1);
            lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt%IME_MAXCAND] = lpEngPrivate->PrivateArea.GlobVac.SBufPos;
            lpEngPrivate->PrivateArea.GlobVac.SBufPos += j;
            lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT(' ');
            lpEngPrivate->PrivateArea.GlobVac.SBufPos ++;
#endif //COMBO_IME
        }
        if (i>=    lpEngPrivate->PrivateArea.Comp_Proc.dBDicEndPos )
            break;
    }
    if (i>=lpEngPrivate->PrivateArea.Comp_Proc.dBDicEndPos)
        lpEngPrivate->PrivateArea.Comp_Proc.dBDicCEndPos = lpEngPrivate->PrivateArea.Comp_Proc.dBDicEndPos;
    else    
        lpEngPrivate->PrivateArea.Comp_Proc.dBDicCEndPos = s_pos-codelen-1;
}

                                                
void CoreLXComp() {
    
    if (MBIndex.IMEChara[0].IC_LX==1) { // lx Search
        lpEngPrivate->PrivateArea.Comp_Status.dwSTLX = 1;
        lstrcpy(lpEngPrivate->PrivateArea.Comp_Context.szInBuffer,TEXT("LLXX"));
        lpEngPrivate->PrivateArea.Comp_Context.szInBuffer[4] = TEXT('\0');
        lpEngPrivate->PrivateArea.Comp_Context.PromptCnt = 4;
        lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQStartPos = 0;
        lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQEndPos = lpEngPrivate->PrivateArea.GlobVac.EMB_Count;
        lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCStartPos = 0;
        lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCEndPos = 0;
        lpEngPrivate->PrivateArea.Comp_Proc.dBDicStartPos = 0;
        lpEngPrivate->PrivateArea.Comp_Proc.dBDicEndPos = lpEngPrivate->PrivateArea.GlobVac.Area_V_Lenth;;
        lpEngPrivate->PrivateArea.Comp_Proc.dBDicCStartPos = 0;
        lpEngPrivate->PrivateArea.Comp_Proc.dBDicCEndPos = 0;

        lpEngPrivate->PrivateArea.GlobVac.Cur_MB = 0;         //EMB
        ClrSelBuf();
        SearchEMBLXMatch();
        if (lpEngPrivate->PrivateArea.GlobVac.SBufPos ==0) {
            lpEngPrivate->PrivateArea.GlobVac.Cur_MB = 1;
            SearchMBLXMatch();
        } else if((GetLengthofBuf() <= MAX_LEN) && (lpEngPrivate->PrivateArea.GlobVac.EMB_Exist!=0))
            SearchMBLXMatch();
        if (lpEngPrivate->PrivateArea.GlobVac.SBufPos==0) {
            lpEngPrivate->PrivateArea.Comp_Status.dwSTLX = 0;
            ClrDoubleBuf();
        } else 
            lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
        lpEngPrivate->PrivateArea.GlobVac.Page_Num = 1;
    } 
}


void PageDnUp(BYTE direct) {

    
    if (lpEngPrivate->PrivateArea.Comp_Status.dwSTMULCODE) {
        CoreMCCompDnUp(direct);
    } else if (_tcschr(lpEngPrivate->PrivateArea.Comp_Context.szInBuffer,WildChar)!=NULL) {
        CoreWWCompDnUp(direct);
    } else if (lpEngPrivate->PrivateArea.Comp_Status.dwSTLX==0) {
        lpEngPrivate->PrivateArea.Comp_Status.dwSTMULCODE = 0;
        CoreMBCompDnUp(direct);
        lpEngPrivate->PrivateArea.GlobVac.ST_MUL_Cnt = 0;
    } else {
         CoreLXCompDnUp(direct);
    }
    
}

void CoreWWCompDnUp(BYTE direct) {

    switch (direct) {
    case 0:
        if (lpEngPrivate->PrivateArea.GlobVac.Page_Num ==1) {
            MessageBeep((UINT)-1);
            return;
        }
        ClrSelBuf();
        if (lpEngPrivate->PrivateArea.GlobVac.Cur_MB==1) { // Current at Basic EMB 
            lpEngPrivate->PrivateArea.Comp_Proc.dBDicCEndPos = lpEngPrivate->PrivateArea.Comp_Proc.dBDicCStartPos;
            SearchBMBWWMatch(lpEngPrivate->PrivateArea.Comp_Context.szInBuffer[lpEngPrivate->PrivateArea.Comp_Context.PromptCnt-1],(BYTE)(lpEngPrivate->PrivateArea.Comp_Context.PromptCnt-1));
            if ((lpEngPrivate->PrivateArea.Comp_Proc.dBDicCStartPos==lpEngPrivate->PrivateArea.Comp_Proc.dBDicStartPos)&&(GetLengthofBuf()<MAX_LEN))  {// Select buffer isn't overflow
                lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCEndPos = lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCStartPos;
                SearchBEMBWWMatch(lpEngPrivate->PrivateArea.Comp_Context.szInBuffer[lpEngPrivate->PrivateArea.Comp_Context.PromptCnt-1],(BYTE)(lpEngPrivate->PrivateArea.Comp_Context.PromptCnt-1)); 
                lpEngPrivate->PrivateArea.GlobVac.Cur_MB = 0;
            } 
        } else { // turn at EMB
                //8.23 emb mb connect position must be process specially
                lpEngPrivate->PrivateArea.Comp_Proc.dBDicCEndPos = lpEngPrivate->PrivateArea.Comp_Proc.dBDicCStartPos;

                lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCEndPos = lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCStartPos;
                SearchBEMBWWMatch(lpEngPrivate->PrivateArea.Comp_Context.szInBuffer[lpEngPrivate->PrivateArea.Comp_Context.PromptCnt-1],(BYTE)(lpEngPrivate->PrivateArea.Comp_Context.PromptCnt-1));
        }    
        lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
        lpEngPrivate->PrivateArea.GlobVac.Page_Num --;
        ConvertCandi();        
        break;
    case 1:
        if ((lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCEndPos >= lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQEndPos) &&
                (lpEngPrivate->PrivateArea.Comp_Proc.dBDicCEndPos >= lpEngPrivate->PrivateArea.Comp_Proc.dBDicEndPos)) { // EMB reach bottom
            MessageBeep((UINT)-1);
            return;
        }
        ClrSelBuf();
        if((lpEngPrivate->PrivateArea.Comp_Proc.dBDicCEndPos < lpEngPrivate->PrivateArea.Comp_Proc.dBDicEndPos) && (lpEngPrivate->PrivateArea.GlobVac.EMB_Exist!=0)){ // Search at MB 
            lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCStartPos  = lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCEndPos;                
            lpEngPrivate->PrivateArea.GlobVac.Cur_MB = 0;
            SearchEMBWWMatch(lpEngPrivate->PrivateArea.Comp_Context.szInBuffer[lpEngPrivate->PrivateArea.Comp_Context.PromptCnt-1],(BYTE)(lpEngPrivate->PrivateArea.Comp_Context.PromptCnt-1));    
            if (lpEngPrivate->PrivateArea.GlobVac.SBufPos == 0) {
                lpEngPrivate->PrivateArea.GlobVac.Cur_MB = 1;
                lpEngPrivate->PrivateArea.Comp_Proc.dBDicCStartPos  = lpEngPrivate->PrivateArea.Comp_Proc.dBDicCEndPos;                
                SearchMBWWMatch(lpEngPrivate->PrivateArea.Comp_Context.szInBuffer[lpEngPrivate->PrivateArea.Comp_Context.PromptCnt-1],(BYTE)(lpEngPrivate->PrivateArea.Comp_Context.PromptCnt-1));     
            } else if ((lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCEndPos==lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQEndPos) && (GetLengthofBuf()<MAX_LEN)) {        // Select buffer isn't overflow
                lpEngPrivate->PrivateArea.Comp_Proc.dBDicCStartPos  = lpEngPrivate->PrivateArea.Comp_Proc.dBDicStartPos;                
                SearchMBWWMatch(lpEngPrivate->PrivateArea.Comp_Context.szInBuffer[lpEngPrivate->PrivateArea.Comp_Context.PromptCnt-1],(BYTE)(lpEngPrivate->PrivateArea.Comp_Context.PromptCnt-1));
            }
        } else {           // Search  at EMB
            lpEngPrivate->PrivateArea.Comp_Proc.dBDicCStartPos  = lpEngPrivate->PrivateArea.Comp_Proc.dBDicCEndPos;
            lpEngPrivate->PrivateArea.GlobVac.Cur_MB = 1;
            SearchMBWWMatch(lpEngPrivate->PrivateArea.Comp_Context.szInBuffer[lpEngPrivate->PrivateArea.Comp_Context.PromptCnt-1],(BYTE)(lpEngPrivate->PrivateArea.Comp_Context.PromptCnt-1));    
        }
        lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
        lpEngPrivate->PrivateArea.GlobVac.Page_Num ++;
        break;    
    }
    lpEngPrivate->PrivateArea.GlobVac.ST_MUL_Cnt = 0;
    
}


int CoreMCCompDnUp(BYTE direct) {
    int i,len;

    switch (direct) {
    case 0:
        if (lpEngPrivate->PrivateArea.GlobVac.Page_Num ==1) {
            MessageBeep((UINT)-1);
            return(0);
        }
        ClrSelBuf();
        lpEngPrivate->PrivateArea.Comp_Status.dwSTMULCODE = 1;
        if (lpEngPrivate->PrivateArea.GlobVac.Cur_MB==0) { // Current at Basic EMB 
            lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCEndPos = lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCStartPos;
            SearchBEMBCompMatch();
            if ((lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCStartPos==lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQStartPos)&&(GetLengthofBuf() <MAX_LEN))  {// Select buffer isn't overflow
                lpEngPrivate->PrivateArea.Comp_Proc.dBDicCEndPos = lpEngPrivate->PrivateArea.Comp_Proc.dBDicCStartPos;
                SearchBMBCompMatch(); 
                lpEngPrivate->PrivateArea.GlobVac.Cur_MB = 1;
            } 
        } else { // turn at MB
                lpEngPrivate->PrivateArea.Comp_Proc.dBDicCEndPos = lpEngPrivate->PrivateArea.Comp_Proc.dBDicCStartPos;
                SearchBMBCompMatch();
        }    
        lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
        lpEngPrivate->PrivateArea.GlobVac.Page_Num --;
        ConvertCandi();        
        break;
    case 1:
        i = lpEngPrivate->PrivateArea.Comp_Proc.dBDicCEndPos;     
         len = ZM_Area[i];
        if((len>lpEngPrivate->PrivateArea.Comp_Context.PromptCnt) || (i>lpEngPrivate->PrivateArea.Comp_Proc.dBDicMCSPos) || (i>=lpEngPrivate->PrivateArea.Comp_Proc.dBDicEndPos)) {
            if (lpEngPrivate->PrivateArea.GlobVac.EMB_Exist==1) {
                i = lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCEndPos;     
                len = Inputcodelen(EMB_Table[i].W_Code);
                if((len>lpEngPrivate->PrivateArea.Comp_Context.PromptCnt) || (i==lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQEndPos)) {
                    MessageBeep((UINT)-1);
                    return(0);
                }    
            } else {

                MessageBeep((UINT)-1);
                return(0);    
            }
        }
        ClrSelBuf();
        lpEngPrivate->PrivateArea.Comp_Status.dwSTMULCODE = 1;
        if(lpEngPrivate->PrivateArea.Comp_Proc.dBDicCEndPos < lpEngPrivate->PrivateArea.Comp_Proc.dBDicEndPos){    
            lpEngPrivate->PrivateArea.Comp_Proc.dBDicCStartPos  = lpEngPrivate->PrivateArea.Comp_Proc.dBDicCEndPos;                
            lpEngPrivate->PrivateArea.GlobVac.Cur_MB = 1;
            SearchMBCompMatch((TCHAR)(lpEngPrivate->PrivateArea.Comp_Context.PromptCnt-1));    
            if (lpEngPrivate->PrivateArea.GlobVac.SBufPos == 0) {
                lpEngPrivate->PrivateArea.GlobVac.Cur_MB = 0;
                lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCStartPos  = lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCEndPos;                
                SearchEMBCompMatch();     
            } else if ((lpEngPrivate->PrivateArea.Comp_Proc.dBDicCEndPos==lpEngPrivate->PrivateArea.Comp_Proc.dBDicEndPos)&&(GetLengthofBuf()<MAX_LEN)) {        // Select buffer isn't overflow
                lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCStartPos  = lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCEndPos;                
                SearchEMBCompMatch();
            }
        } else {           // Search  at EMB
            lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCStartPos  = lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCEndPos;
            lpEngPrivate->PrivateArea.GlobVac.Cur_MB = 0;
            SearchEMBCompMatch();    
        }
        lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
        lpEngPrivate->PrivateArea.GlobVac.Page_Num ++;
        break;    
    }
    lpEngPrivate->PrivateArea.GlobVac.ST_MUL_Cnt = 0;
    return(1);    
}


void CoreLXCompDnUp(BYTE direct) {

    switch (direct) {
    case 0:               //PgUp Turn
        if (lpEngPrivate->PrivateArea.GlobVac.Page_Num ==1) {
            MessageBeep((UINT)-1);

            return;
        }
        ClrSelBuf();
        if (lpEngPrivate->PrivateArea.GlobVac.Cur_MB) { // Current at Basic MB 
            lpEngPrivate->PrivateArea.Comp_Proc.dBDicCEndPos = lpEngPrivate->PrivateArea.Comp_Proc.dBDicCStartPos;
            SearchBMBLXMatch();
            if ((lpEngPrivate->PrivateArea.Comp_Proc.dBDicCStartPos==lpEngPrivate->PrivateArea.Comp_Proc.dBDicStartPos)
                && (GetLengthofBuf() <MAX_LEN) 
                && (lpEngPrivate->PrivateArea.GlobVac.EMB_Exist!=0)) {        // Select buffer isn't overflow
                SearchBEMBLXMatch();    // pass w_code 
                lpEngPrivate->PrivateArea.GlobVac.Cur_MB = 0;
            } 
        } else { // turn at EMB
                lpEngPrivate->PrivateArea.Comp_Proc.dBDicCEndPos = lpEngPrivate->PrivateArea.Comp_Proc.dBDicCStartPos;
                lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCEndPos = lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCStartPos;
                SearchBEMBLXMatch();
        }    
        lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
        lpEngPrivate->PrivateArea.GlobVac.Page_Num --;
        ConvertCandi();
        break;
    case 1:            // PgDn Turn
        if ((lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCEndPos >= lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQEndPos) &&
                (lpEngPrivate->PrivateArea.Comp_Proc.dBDicCEndPos >= lpEngPrivate->PrivateArea.Comp_Proc.dBDicEndPos)) { // EMB reach bottom
            MessageBeep((UINT)-1);
            return;
        }
        ClrSelBuf();
        if((lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCEndPos < lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQEndPos) && (lpEngPrivate->PrivateArea.GlobVac.EMB_Exist!=0)){ // Search at EMB 
            lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCStartPos  = lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCEndPos;
            lpEngPrivate->PrivateArea.GlobVac.Cur_MB = 0;
            SearchEMBLXMatch();     
            if (lpEngPrivate->PrivateArea.GlobVac.SBufPos == 0) {
                lpEngPrivate->PrivateArea.GlobVac.Cur_MB = 1;
                lpEngPrivate->PrivateArea.Comp_Proc.dBDicCStartPos  = lpEngPrivate->PrivateArea.Comp_Proc.dBDicCEndPos;                
                SearchMBLXMatch();    // pass q_code 
            } else if ((lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCEndPos==lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQEndPos)&&(GetLengthofBuf()<MAX_LEN)) {        // Select buffer isn't overflow
                lpEngPrivate->PrivateArea.Comp_Proc.dBDicCStartPos  = lpEngPrivate->PrivateArea.Comp_Proc.dBDicCEndPos;                
                SearchMBLXMatch();    // pass w_code 
            }
        } else {           // Search  at MB
            lpEngPrivate->PrivateArea.Comp_Proc.dBDicCStartPos  = lpEngPrivate->PrivateArea.Comp_Proc.dBDicCEndPos;
            lpEngPrivate->PrivateArea.GlobVac.Cur_MB = 1;
            SearchMBLXMatch();    // pass w_code 
        }
        lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
        lpEngPrivate->PrivateArea.GlobVac.Page_Num ++;
        break;    
    }    
}

void CoreMBCompDnUp(BYTE direct) {
    int i;
    TCHAR incode_buf[MAXCODE];
    BYTE code_num;

    switch (direct) {
    case 0:               //PgUp Turn
        if (lpEngPrivate->PrivateArea.GlobVac.Page_Num ==1) {
            MessageBeep((UINT)-1);
            return ;
        }
        ClrSelBuf();
        if (lpEngPrivate->PrivateArea.GlobVac.Page_Num ==2) {
            code_num = lpEngPrivate->PrivateArea.Comp_Context.PromptCnt;
            lstrcpyn(incode_buf,lpEngPrivate->PrivateArea.Comp_Context.szInBuffer,code_num+1);
            ClrDoubleBuf();
            for (i=0; i<code_num; i++) {
                ClrSelBuf();
                CoreMBComp(incode_buf[i],(BYTE)i);
            }
            lpEngPrivate->PrivateArea.GlobVac.Page_Num = 1;
        } else {
            if (lpEngPrivate->PrivateArea.GlobVac.Cur_MB) { // Current at Basic MB 
            
                lpEngPrivate->PrivateArea.Comp_Proc.dBDicCEndPos = lpEngPrivate->PrivateArea.Comp_Proc.dBDicCStartPos;
                
                SearchBMBWildMatch(lpEngPrivate->PrivateArea.Comp_Context.PromptCnt);

                if ((lpEngPrivate->PrivateArea.Comp_Proc.dBDicCStartPos<=lpEngPrivate->PrivateArea.Comp_Proc.dBDicMCSPos) 
                        && (GetLengthofBuf() <MAX_LEN )
                        && (lpEngPrivate->PrivateArea.GlobVac.EMB_Exist!=0)) {
                    SearchBEMBWildMatch();    // pass w_code 
                    lpEngPrivate->PrivateArea.GlobVac.Cur_MB = 0;
                }
        
            } else { // turn at EMB
                lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCEndPos = lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCStartPos;
                SearchBEMBWildMatch();
            }
            lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
            lpEngPrivate->PrivateArea.GlobVac.Page_Num --;
            ConvertCandi();
        }    
    
        break;
    case 1:            // PgDn Turn
        if ((lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCEndPos >= lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQEndPos) &&
                (lpEngPrivate->PrivateArea.Comp_Proc.dBDicCEndPos >= lpEngPrivate->PrivateArea.Comp_Proc.dBDicEndPos)) { // EMB reach bottom
            MessageBeep((UINT)-1);
            return ;
        }
        ClrSelBuf();
        if((lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCEndPos < lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQEndPos) && (lpEngPrivate->PrivateArea.GlobVac.EMB_Exist!=0)){ // Search at EMB 
            
            lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCStartPos  = lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCEndPos;
            lpEngPrivate->PrivateArea.GlobVac.Cur_MB = 0;
            SearchEMBWildMatch();     
            if (lpEngPrivate->PrivateArea.GlobVac.SBufPos == 0) {
                lpEngPrivate->PrivateArea.GlobVac.Cur_MB = 1;
                lpEngPrivate->PrivateArea.Comp_Proc.dBDicCStartPos  = lpEngPrivate->PrivateArea.Comp_Proc.dBDicCEndPos;                
                SearchMBWildMatch(lpEngPrivate->PrivateArea.Comp_Context.PromptCnt);    // pass q_code 
            } else if ((lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCEndPos==lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQEndPos) && (GetLengthofBuf() <MAX_LEN)) {        // Select buffer isn't overflow
                lpEngPrivate->PrivateArea.Comp_Proc.dBDicCStartPos  = lpEngPrivate->PrivateArea.Comp_Proc.dBDicCEndPos;                
                SearchMBWildMatch(lpEngPrivate->PrivateArea.Comp_Context.PromptCnt);    // pass w_code 
            }
        } else {// Search  at MB
            lpEngPrivate->PrivateArea.Comp_Proc.dBDicCStartPos = lpEngPrivate->PrivateArea.Comp_Proc.dBDicCEndPos;
            lpEngPrivate->PrivateArea.GlobVac.Cur_MB = 1;
            SearchMBWildMatch(lpEngPrivate->PrivateArea.Comp_Context.PromptCnt);    // pass w_code 
         }
        lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
        lpEngPrivate->PrivateArea.GlobVac.Page_Num ++;
        break;    
    }    
}

void TurnToFirstPage() {
    int i;
    TCHAR incode_buf[MAXCODE];
    BYTE code_num;
    
    if(lpEngPrivate->PrivateArea.GlobVac.Page_Num == 1) {
        MessageBeep((UINT)-1);
        return;
    }
    lpEngPrivate->PrivateArea.Comp_Proc.dBDicCStartPos = lpEngPrivate->PrivateArea.Comp_Proc.dBDicStartPos;     
    lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCStartPos = lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQStartPos;     
    lpEngPrivate->PrivateArea.Comp_Proc.dBDicCEndPos = lpEngPrivate->PrivateArea.Comp_Proc.dBDicStartPos;     
    lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCEndPos = lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQStartPos;     
    
    if (lpEngPrivate->PrivateArea.Comp_Status.dwSTMULCODE) {
        ClrSelBuf();
        lpEngPrivate->PrivateArea.Comp_Status.dwSTMULCODE = 1;

        lpEngPrivate->PrivateArea.GlobVac.Cur_MB = 1;
        SearchMBCompMatch((TCHAR)(lpEngPrivate->PrivateArea.Comp_Context.PromptCnt-1));    
        if (lpEngPrivate->PrivateArea.GlobVac.SBufPos == 0) {
            lpEngPrivate->PrivateArea.GlobVac.Cur_MB = 0;
            SearchEMBCompMatch();     
        } else if ((lpEngPrivate->PrivateArea.Comp_Proc.dBDicCEndPos==lpEngPrivate->PrivateArea.Comp_Proc.dBDicEndPos)&&(GetLengthofBuf()<MAX_LEN)) {        // Select buffer isn't overflow
            SearchEMBCompMatch();
        }
    } else if (_tcschr(lpEngPrivate->PrivateArea.Comp_Context.szInBuffer,WildChar)!=NULL) {
        ClrSelBuf();

        lpEngPrivate->PrivateArea.GlobVac.Cur_MB = 0;
        SearchEMBWWMatch(lpEngPrivate->PrivateArea.Comp_Context.szInBuffer[lpEngPrivate->PrivateArea.Comp_Context.PromptCnt-1],(BYTE)(lpEngPrivate->PrivateArea.Comp_Context.PromptCnt-1));    
        if (lpEngPrivate->PrivateArea.GlobVac.SBufPos == 0) {
            lpEngPrivate->PrivateArea.GlobVac.Cur_MB = 0;
            SearchMBWWMatch(lpEngPrivate->PrivateArea.Comp_Context.szInBuffer[lpEngPrivate->PrivateArea.Comp_Context.PromptCnt-1],(BYTE)(lpEngPrivate->PrivateArea.Comp_Context.PromptCnt-1));     
        } else if ((lpEngPrivate->PrivateArea.Comp_Proc.dBDicCEndPos==lpEngPrivate->PrivateArea.Comp_Proc.dBDicEndPos) && (GetLengthofBuf()<MAX_LEN)) {        // Select buffer isn't overflow
            SearchMBWWMatch(lpEngPrivate->PrivateArea.Comp_Context.szInBuffer[lpEngPrivate->PrivateArea.Comp_Context.PromptCnt-1],(BYTE)(lpEngPrivate->PrivateArea.Comp_Context.PromptCnt-1));
        }
    } else if (lpEngPrivate->PrivateArea.Comp_Status.dwSTLX==0) {
        ClrSelBuf();
        lpEngPrivate->PrivateArea.GlobVac.ST_MUL_Cnt = 0;
        lpEngPrivate->PrivateArea.Comp_Status.dwSTMULCODE = 0;
        code_num = lpEngPrivate->PrivateArea.Comp_Context.PromptCnt;
        lstrcpyn(incode_buf,lpEngPrivate->PrivateArea.Comp_Context.szInBuffer,code_num+1);
        ClrDoubleBuf();
        for (i=0; i<code_num; i++) {
            ClrSelBuf();
            CoreMBComp(incode_buf[i],(BYTE)i);
        }
    } else {
        ClrSelBuf();
        lpEngPrivate->PrivateArea.GlobVac.Cur_MB = 0;
        SearchEMBLXMatch();     
        if (lpEngPrivate->PrivateArea.GlobVac.SBufPos == 0) {
            lpEngPrivate->PrivateArea.GlobVac.Cur_MB = 1;
            SearchMBLXMatch();    // pass q_code 
        } else if ((lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCEndPos==lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQEndPos)&&(GetLengthofBuf()<MAX_LEN)) {        // Select buffer isn't overflow
            SearchMBLXMatch();    // pass w_code 
        }
    }
    lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
    lpEngPrivate->PrivateArea.GlobVac.Page_Num = 1;
    lpEngPrivate->PrivateArea.GlobVac.ST_MUL_Cnt = 0;
}


void TurnToEndPage() {

    if (lpEngPrivate->PrivateArea.Comp_Status.dwSTMULCODE) {
        for(;;) {
            if(!CoreMCCompDnUp(1))
                break;
        }
    } else {
        for(;;) {
            PageDnUp(1);
            if((lpEngPrivate->PrivateArea.Comp_Proc.dBDicCEndPos==lpEngPrivate->PrivateArea.Comp_Proc.dBDicEndPos) && (lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCEndPos==lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQEndPos))
                break;
        }
    }
}

UINT CoreUnitProcess(TCHAR code) {        
    int search_state;

    search_state = CoreMBComp(code,lpEngPrivate->PrivateArea.Comp_Context.PromptCnt);    
    if(search_state) {
    
        if (lpEngPrivate->PrivateArea.Comp_Context.PromptCnt==MaxCodes ) { // Four_key code
            if (lpEngPrivate->PrivateArea.GlobVac.ST_MUL_Cnt>1 ) { // Mutilple code
                TSMulCProc();
                return (0);
            }
            else {           // Result string
                SelectCandi('1');
                return (2);
            }
        } 
        return(0);
    } else                                    
        return(0);
}

                
UINT SelectCandi(TCHAR code) {
    BYTE resstart;
    BYTE sel_succ,i;
    TCHAR ch;

    if (lpEngPrivate->PrivateArea.Comp_Context.PromptCnt>0) {    // there are some w_code
        if(lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt==0)     // now we have 10 Candi_words
            sel_succ = 0;
        else if((code-0x30 <= lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt) && (code-0x30 > 0))  //select is valid
            sel_succ = 1;
        else if(lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt==10 && code=='0')
            sel_succ = 1;
        else
            sel_succ = 0;
        if (sel_succ) {        //select successful
            resstart = lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[code-0x30];
            i = 0;
            for(;;) {
                lpEngPrivate->PrivateArea.Comp_Context.CKBBuf[i] = lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[resstart];
#ifdef UNICODE
                i += 1;
                resstart += 1;
#else
                lpEngPrivate->PrivateArea.Comp_Context.CKBBuf[i+1] = lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[resstart+1];
                i += 2;
                resstart += 2;
#endif
                ch = lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[resstart];
                if(ch==TEXT(' ') || ch==TEXT('\0') || InCodeSet(ch)==1)
                    break;
            }
            lpEngPrivate->PrivateArea.Comp_Context.CKBBuf[i] = TEXT('\0');
            lpEngPrivate->PrivateArea.Comp_Context.ResultStrCnt = i;
            lstrcpy(lpEngPrivate->PrivateArea.Comp_Context.szLxBuffer,lpEngPrivate->PrivateArea.Comp_Context.CKBBuf);
            lpEngPrivate->PrivateArea.Comp_Context.LxStrCnt = i;

            //CHP
#ifdef FUSSYMODE
            MBIndex.IsFussyCharFlag = 0;
            if (lstrlen(lpEngPrivate->PrivateArea.Comp_Context.CKBBuf) == 1)
            if (IsFussyChar(lpEngPrivate->PrivateArea.Comp_Context.szInBuffer, 
                            lpEngPrivate->PrivateArea.Comp_Context.CKBBuf))
            {
                MBIndex.IsFussyCharFlag = 1;
            }
#endif //FUSSYMODE
            
            if (MBIndex.IMEChara[0].IC_LX==1) //&& (lpEngPrivate->PrivateArea.Comp_Context.ResultStrCnt==2))
                CoreLXComp();
            else 
                ClrDoubleBuf();
            lpEngPrivate->PrivateArea.Comp_Status.dwSTMULCODE = 0;
            lpEngPrivate->PrivateArea.GlobVac.ST_MUL_Cnt = 0;
            return(2);
        } else {
            MessageBeep((UINT)-1);                 
            return(0);
        }
    } else {
        if (!lpEngPrivate->PrivateArea.Comp_Status.dwPPTFH)
            return (1);
        else  {
            CapKeyProc(code);
            return (2);
        }
    }
}

UINT LXSelectCandi(TCHAR code) {
    BYTE sel_succ,resstart;
    BYTE i;

    if(lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt==0)     // no candidate
        sel_succ = 0;
    else if((code-0x30 <= lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt) && (code-0x30 > 0))  //select is valid
        sel_succ = 1;
    else if(lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt==10 && code=='0')
        sel_succ = 1;    
    else 
        sel_succ = 0;
    if (sel_succ) {        //select successful
        //lpEngPrivate->PrivateArea.Comp_Status.dwSTLX = 0;
        resstart = lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[code-0x30];
        resstart += lpEngPrivate->PrivateArea.Comp_Context.LxStrCnt;
        i = 0;
        for(;;) {
            lpEngPrivate->PrivateArea.Comp_Context.CKBBuf[i] = lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[resstart];
#ifdef UNICODE
            i += 1;
            resstart += 1;
#else
            lpEngPrivate->PrivateArea.Comp_Context.CKBBuf[i+1] = lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[resstart+1];
            i += 2;
            resstart += 2;
#endif
            if(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[resstart]==TEXT(' ') || lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[resstart]==TEXT('\0'))
                break;
        }
        lpEngPrivate->PrivateArea.Comp_Context.CKBBuf[i] = TEXT('\0');
        lpEngPrivate->PrivateArea.Comp_Context.ResultStrCnt = i;

        resstart = lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[code-0x30];
        //resstart += lpEngPrivate->PrivateArea.Comp_Context.ResultStrCnt;
        i = 0;
        for(;;) {
            lpEngPrivate->PrivateArea.Comp_Context.szLxBuffer[i] = lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[resstart];
            lpEngPrivate->PrivateArea.Comp_Context.szLxBuffer[i+1] = lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[resstart+1];
            i += 2;
            resstart += 2;
            if(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[resstart]==TEXT(' ') || lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[resstart]==TEXT('\0'))
                break;
        }
        lpEngPrivate->PrivateArea.Comp_Context.szLxBuffer[i] = TEXT('\0');
        lpEngPrivate->PrivateArea.Comp_Context.LxStrCnt = i;

        if (MBIndex.IMEChara[0].IC_LX==1) //&& (lpEngPrivate->PrivateArea.Comp_Context.ResultStrCnt==2))
            CoreLXComp();
        else 
            ClrDoubleBuf();
        lpEngPrivate->PrivateArea.Comp_Status.dwSTMULCODE = 0;
        return(2);
    } else {
        MessageBeep((UINT)-1);            
        return(0);
    }
}

                        
UINT DefSelect() {
    if (lpEngPrivate->PrivateArea.GlobVac.ST_MUL_Cnt > 1) { // Mutilple code
        TSMulCProc();
        return (0);
    } else {              // Result string
        if (lpEngPrivate->PrivateArea.Comp_Status.dwSTLX)
            return(LXSelectCandi(TEXT('1')));
        else
            return (SelectCandi(TEXT('1')));
        //return(2);
    }
}


void TSMulCProc(void) {
    BYTE mul_code_end;
    if(lpEngPrivate->PrivateArea.GlobVac.ST_MUL_Cnt < lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt) {
        mul_code_end = lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[(lpEngPrivate->PrivateArea.GlobVac.ST_MUL_Cnt+1)%10]-1;
        lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[mul_code_end] = TEXT('\0');
        lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt = lpEngPrivate->PrivateArea.GlobVac.ST_MUL_Cnt;
        
    }
    lpEngPrivate->PrivateArea.GlobVac.ST_MUL_Cnt = 0;
    lpEngPrivate->PrivateArea.Comp_Status.dwSTMULCODE = 1;
    
    MessageBeep((UINT)-1);
}
void SearchEMBPos(TCHAR code,BYTE m_lenth) {
    int i;
    TCHAR codebuf[MAXCODE];
    
    if(!lpEngPrivate->PrivateArea.GlobVac.EMB_Exist)
        return;        

    lstrcpyn(codebuf,lpEngPrivate->PrivateArea.Comp_Context.szInBuffer,m_lenth-1+1);
    codebuf[m_lenth-1] = code;
    for (i=0; i<lpEngPrivate->PrivateArea.GlobVac.EMB_Count; i++) {
        if (wcsncmp(EMB_Table[i].W_Code,codebuf,m_lenth)==0)
        {
          //CHP 
#ifdef FUSSYMODE
          if ((lstrlen(EMB_Table[i].C_Char) == 1) && !MBIndex.IMEChara[0].IC_FCSR)
          {
                //If EUDC, let it go.
                if (EMB_Table[i].C_Char[0] >= 0xe000 && EMB_Table[i].C_Char[0] <= 0xf8ff)   
                   break;
          }
          else
#endif //FUSSYMODE
            break;
        }
    }
    lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQStartPos = i;
    lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCStartPos = i;
    lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCEndPos = i;    
    for (i;i<lpEngPrivate->PrivateArea.GlobVac.EMB_Count; i++) {
        if (wcsncmp(EMB_Table[i].W_Code, codebuf, m_lenth)!=0)
            break;
    }
    lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQEndPos = i;
}


//CHP
#ifdef FUSSYMODE
BOOL IsFussyChar(LPCTSTR lpReading, LPCTSTR lpString)
{
    int i;
    if(!lpEngPrivate->PrivateArea.GlobVac.EMB_Exist)
        return FALSE;
    for (i=0; i<lpEngPrivate->PrivateArea.GlobVac.EMB_Count; i++) {
        if (!lstrcmp(EMB_Table[i].W_Code,lpReading) &&
            !lstrcmp(EMB_Table[i].C_Char,lpString))
            return TRUE;
    }
    return FALSE;
    }
#endif //FUSSYMODE

int EMBWCWildComp(TCHAR code,BYTE code_num, int no) {
    TCHAR codebuf[13];
    int  i;
    
    lstrcpyn(codebuf,lpEngPrivate->PrivateArea.Comp_Context.szInBuffer,code_num+1);
    codebuf[code_num] = code;
    codebuf[code_num+1] = 0x0;
    for(i=0; i<=code_num; i++) {
        if((codebuf[i]!=EMB_Table[no].W_Code[i]) && (codebuf[i]!=WildChar))
           return(0);
    }
    return(1);
}

void SearchBEMBWWMatch(TCHAR code,BYTE code_num) {
int  i,lenw,lenc,len;
TCHAR codebuf[13];
    if(!lpEngPrivate->PrivateArea.GlobVac.EMB_Exist)
        return;
    if (GetLengthofBuf() > MAX_LEN) {
        lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
        return;
    }
        
    for (i=lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCEndPos-1 ; i>=lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQStartPos; i--) {
        lenw = Inputcodelen(EMB_Table[i].W_Code);
        if ((lenw == code_num+1) && (EMBWCWildComp(code,code_num,i)==1)) {
            lenc = DBCSCharlen(EMB_Table[i].C_Char);
            len = WildInBuffer();
            if ((MBIndex.IMEChara[0].IC_CZ==1) || (lenc==2/sizeof(TCHAR))) {
                lstrcpyn(codebuf,EMB_Table[i].W_Code+len,lenw-len+1);
                codebuf[lenw-len] = 0;
                if(MBIndex.IMEChara[0].IC_CTC) {
                    if (GetLengthCCharBuf(EMB_Table[i].C_Char)+GetLengthTepBuf(TEXT("9:"))+GetLengthofBuf()+GetLengthTepBuf(codebuf) > MAX_LEN) {
                        lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
                        i++;
                        break;    
                    }
                } else {
                    if (GetLengthCCharBuf(EMB_Table[i].C_Char)+GetLengthTepBuf(TEXT("9:"))+GetLengthofBuf() > MAX_LEN) {
                        lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
                        i++;
                        break;    
                    }
                }
                if (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt==IME_MAXCAND) {
                    lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
                    i++;
                    break;
                }
                
#if defined(COMBO_IME)
                {
                    int k;
                    BOOL ISGBK = FALSE;

                    if(MBIndex.IMEChara[0].IC_GB){ //should test GB/GBK
                        for(k=0;k<lenc;k+=2/sizeof(TCHAR)){ 
                            if(ISGBK = IsGBK(&EMB_Table[i].C_Char[k])){//out of GB range
                                break;
                            }
                        }
                        if(ISGBK){
                        }else{
                            lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt = (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1) ;
                            lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt%IME_MAXCAND] = (BYTE)(lpEngPrivate->PrivateArea.GlobVac.SBufPos);
                            lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,EMB_Table[i].C_Char,lenc+1);
                            lpEngPrivate->PrivateArea.GlobVac.SBufPos += DBCSCharlen(EMB_Table[i].C_Char);
                            if (MBIndex.IMEChara[0].IC_CTC) {
                                lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,EMB_Table[i].W_Code+len,lenw-len+1);
                                lpEngPrivate->PrivateArea.GlobVac.SBufPos += (lenw-len);
                            }
                            lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT(' ');
                            lpEngPrivate->PrivateArea.GlobVac.SBufPos ++;
                        }
                    }else{
                        lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt = (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1) ;
                        lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt%IME_MAXCAND] = (BYTE)(lpEngPrivate->PrivateArea.GlobVac.SBufPos);
                        lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,EMB_Table[i].C_Char,lenc+1);
                        lpEngPrivate->PrivateArea.GlobVac.SBufPos += DBCSCharlen(EMB_Table[i].C_Char);
                        if (MBIndex.IMEChara[0].IC_CTC) {
                            lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,EMB_Table[i].W_Code+len,lenw-len+1);
                            lpEngPrivate->PrivateArea.GlobVac.SBufPos += (lenw-len);
                        }
                        lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT(' ');
                        lpEngPrivate->PrivateArea.GlobVac.SBufPos ++;
                    }

                }
#else
                lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt = (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1) ;
                lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt%IME_MAXCAND] = lpEngPrivate->PrivateArea.GlobVac.SBufPos;
                lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,EMB_Table[i].C_Char,lenc+1);
                // modify 11.9
                //lpEngPrivate->PrivateArea.GlobVac.SBufPos += lstrlen(EMB_Table[i].C_Char);
                lpEngPrivate->PrivateArea.GlobVac.SBufPos += DBCSCharlen(EMB_Table[i].C_Char);
                if (MBIndex.IMEChara[0].IC_CTC) {
                    lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,EMB_Table[i].W_Code+len,lenw-len+1);
                    lpEngPrivate->PrivateArea.GlobVac.SBufPos += (lenw-len);
                }
                lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT(' ');
                lpEngPrivate->PrivateArea.GlobVac.SBufPos ++;
#endif //COMBO_IME
            } 
        }
    }
    lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCStartPos = i;    
}

void SearchEMBWWMatch(TCHAR code,BYTE code_num) {
    int  i,lenw,lenc,len;
    TCHAR codebuf[13];

    if(!lpEngPrivate->PrivateArea.GlobVac.EMB_Exist)
        return;
    for (i=lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCStartPos; i<lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQEndPos; i++) {
        lenw = Inputcodelen(EMB_Table[i].W_Code);
        if ((lenw == code_num+1) && (EMBWCWildComp(code,code_num,i)==1)) {
            lenc = DBCSCharlen(EMB_Table[i].C_Char);
            len = WildInBuffer();
            if ((MBIndex.IMEChara[0].IC_CZ == 1) || (lenc == 2)) {
                lstrcpyn(codebuf,EMB_Table[i].W_Code+len,lenw-len+1);
                codebuf[lenw-len] = 0;
                if(MBIndex.IMEChara[0].IC_CTC) {
                    if (GetLengthCCharBuf(EMB_Table[i].C_Char)+GetLengthTepBuf(TEXT("9:"))+GetLengthofBuf()+GetLengthTepBuf(codebuf) > MAX_LEN) {
                        lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
                        break;    
                    }
                } else {
                    if (GetLengthCCharBuf(EMB_Table[i].C_Char)+GetLengthTepBuf(TEXT("9:"))+GetLengthofBuf() > MAX_LEN) {
                        lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
                        break;    
                    }
                }
                if (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt == IME_MAXCAND) {
                    lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
                    break;
                }
#if defined(COMBO_IME)
                {
                    int k;
                    BOOL ISGBK = FALSE;

                    if(MBIndex.IMEChara[0].IC_GB){ //should test GB/GBK
                        for(k=0;k<lenc;k+=2/sizeof(TCHAR)){ 
                            if(ISGBK = IsGBK(&EMB_Table[i].C_Char[k])){//out of GB range
                                break;
                            }
                        }
                        if(ISGBK){
                        }else{
                            lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt = (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1);
                            lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt%IME_MAXCAND] = (BYTE)(lpEngPrivate->PrivateArea.GlobVac.SBufPos);
                            lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,EMB_Table[i].C_Char,lenc+1);
                            lpEngPrivate->PrivateArea.GlobVac.SBufPos += lenc;
                            if (MBIndex.IMEChara[0].IC_CTC) {
                                lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,EMB_Table[i].W_Code+len,lenw-len+1);
                                lpEngPrivate->PrivateArea.GlobVac.SBufPos += (lenw-len);
                            }
                            lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT(' ');
                            lpEngPrivate->PrivateArea.GlobVac.SBufPos++;
                        }
                    }else{
                        lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt = (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1);
                        lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt%IME_MAXCAND] = (BYTE)(lpEngPrivate->PrivateArea.GlobVac.SBufPos);
                        lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,EMB_Table[i].C_Char,lenc+1);
                        lpEngPrivate->PrivateArea.GlobVac.SBufPos += lenc;
                        if (MBIndex.IMEChara[0].IC_CTC) {
                            lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,EMB_Table[i].W_Code+len,lenw-len+1);
                            lpEngPrivate->PrivateArea.GlobVac.SBufPos += (lenw-len);
                        }
                        lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT(' ');
                        lpEngPrivate->PrivateArea.GlobVac.SBufPos++;
                    }

                }
#else
                lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt = (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1);
                lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt%IME_MAXCAND] = lpEngPrivate->PrivateArea.GlobVac.SBufPos;
                lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,EMB_Table[i].C_Char,lenc+1);
                lpEngPrivate->PrivateArea.GlobVac.SBufPos += lenc;
                if (MBIndex.IMEChara[0].IC_CTC) {
                    lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,EMB_Table[i].W_Code+len,lenw-len+1);
                    lpEngPrivate->PrivateArea.GlobVac.SBufPos += (lenw-len);
                }
                lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT(' ');
                lpEngPrivate->PrivateArea.GlobVac.SBufPos++;
#endif //COMBO_IME
            }
        } 
    }
    lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
    lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCEndPos = i;
}



UINT SearchEMBCompMatch() {
    int  i,len;
    int match_s = 0;
    
    if(!lpEngPrivate->PrivateArea.GlobVac.EMB_Exist)
        return(match_s);
    for (i=lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCStartPos; i<lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQEndPos; i++) {
        if (wcsncmp(EMB_Table[i].W_Code ,lpEngPrivate->PrivateArea.Comp_Context.szInBuffer,MaxCodes)==0) { //Complete code match
            len = DBCSCharlen(EMB_Table[i].C_Char);
            if ((MBIndex.IMEChara[0].IC_CZ == 1) || (len == 2)) {
                if (GetLengthCCharBuf(EMB_Table[i].C_Char)+GetLengthTepBuf(TEXT("9:"))+GetLengthofBuf() > MAX_LEN) {
                    lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
                    break;
                }
                if (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt == IME_MAXCAND) {
                    lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
                    break;
                }
#if defined(COMBO_IME)
                {
                    int k;
                    BOOL ISGBK = FALSE;

                    if(MBIndex.IMEChara[0].IC_GB){ //should test GB/GBK
                        for(k=0;k<len;k+=2/sizeof(TCHAR)){ 
                            if(ISGBK = IsGBK(&EMB_Table[i].C_Char[k])){//out of GB range
                                break;
                            }
                        }
                        if(ISGBK){
                        }else{
                            lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt = (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1);
                            lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt%IME_MAXCAND] = (BYTE)(lpEngPrivate->PrivateArea.GlobVac.SBufPos);
                            lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,EMB_Table[i].C_Char,len+1);
                            lpEngPrivate->PrivateArea.GlobVac.SBufPos += len;
                            lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT(' ');
                            lpEngPrivate->PrivateArea.GlobVac.SBufPos++;
                            match_s ++;
                        }
                    }else{
                        lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt = (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1);
                        lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt%IME_MAXCAND] = (BYTE)(lpEngPrivate->PrivateArea.GlobVac.SBufPos);
                        lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,EMB_Table[i].C_Char,len+1);
                        lpEngPrivate->PrivateArea.GlobVac.SBufPos += len;
                        lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT(' ');
                        lpEngPrivate->PrivateArea.GlobVac.SBufPos++;
                        match_s ++;
                    }

                }
#else
                lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt = (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1);
                lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt%IME_MAXCAND] = lpEngPrivate->PrivateArea.GlobVac.SBufPos;
                lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,EMB_Table[i].C_Char,len+1);
                lpEngPrivate->PrivateArea.GlobVac.SBufPos += len;
                lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT(' ');
                lpEngPrivate->PrivateArea.GlobVac.SBufPos++;
                match_s ++;
#endif //COMBO_IME
            }
        } else
            break;
    }
    lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
    lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCEndPos = i;
    lpEngPrivate->PrivateArea.GlobVac.ST_MUL_Cnt += (BYTE)match_s;
    return (match_s);
}

void SearchBEMBCompMatch() {
    int  i,lenw,lenc;
    
    if(!lpEngPrivate->PrivateArea.GlobVac.EMB_Exist)
        return;
    if(GetLengthofBuf() > MAX_LEN) {
        lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
        return;
    }
        
    for (i=lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCEndPos-1 ; i>=lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQStartPos; i--) {
        if (wcsncmp(EMB_Table[i].W_Code ,lpEngPrivate->PrivateArea.Comp_Context.szInBuffer,lpEngPrivate->PrivateArea.Comp_Context.PromptCnt)==0) { //Wild code match
            lenc = DBCSCharlen(EMB_Table[i].C_Char);
            lenw = Inputcodelen(EMB_Table[i].W_Code);
            if ((MBIndex.IMEChara[0].IC_CZ==1) || (lenc==2/sizeof(TCHAR))) {
                if (GetLengthCCharBuf(EMB_Table[i].C_Char)+GetLengthTepBuf(TEXT("9:"))+GetLengthofBuf() > MAX_LEN) {
                    lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
                    i++;
                    break;
                }
                if (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt==IME_MAXCAND) {
                    lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
                    i++;
                    break;
                }
                
#if defined(COMBO_IME)
                {
                    int k;
                    BOOL ISGBK = FALSE;

                    if(MBIndex.IMEChara[0].IC_GB){ //should test GB/GBK
                        for(k=0;k<lenc;k+=2/sizeof(TCHAR)){ 
                            if(ISGBK = IsGBK(&EMB_Table[i].C_Char[k])){//out of GB range
                                break;
                            }
                        }
                        if(ISGBK){
                        }else{
                            lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt = (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1) ;
                            lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt%IME_MAXCAND] = (BYTE)(lpEngPrivate->PrivateArea.GlobVac.SBufPos);
                            lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,EMB_Table[i].C_Char,lenc+1);
                            lpEngPrivate->PrivateArea.GlobVac.SBufPos += DBCSCharlen(EMB_Table[i].C_Char);
                            lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT(' ');
                            lpEngPrivate->PrivateArea.GlobVac.SBufPos ++;
                        }
                    }else{
                        lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt = (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1) ;
                        lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt%IME_MAXCAND] = (BYTE)(lpEngPrivate->PrivateArea.GlobVac.SBufPos);
                        lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,EMB_Table[i].C_Char,lenc+1);
                        lpEngPrivate->PrivateArea.GlobVac.SBufPos += DBCSCharlen(EMB_Table[i].C_Char);
                        lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT(' ');
                        lpEngPrivate->PrivateArea.GlobVac.SBufPos ++;
                    }

                }
#else
                lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt = (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1) ;
                lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt%IME_MAXCAND] = lpEngPrivate->PrivateArea.GlobVac.SBufPos;
                lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,EMB_Table[i].C_Char,lenc+1);
                lpEngPrivate->PrivateArea.GlobVac.SBufPos += DBCSCharlen(EMB_Table[i].C_Char);
                lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT(' ');
                lpEngPrivate->PrivateArea.GlobVac.SBufPos ++;
#endif //COMBO_IME
            } 
        }
    }
    lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCStartPos = i+1;    
}    

    
void SearchEMBWildMatch() {
    int  i,lenw,lenc;
    TCHAR codebuf[13];

    if(!lpEngPrivate->PrivateArea.GlobVac.EMB_Exist)
        return;
    if(GetLengthofBuf() >= MAX_LEN) {
        lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
        return;
    }
    for (i=lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCStartPos ; i<lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQEndPos; i++) {
        if (wcsncmp(EMB_Table[i].W_Code ,lpEngPrivate->PrivateArea.Comp_Context.szInBuffer,lpEngPrivate->PrivateArea.Comp_Context.PromptCnt)==0) { //Wild code match
            lenc = DBCSCharlen(EMB_Table[i].C_Char);
            lenw = Inputcodelen(EMB_Table[i].W_Code);
            if ((MBIndex.IMEChara[0].IC_CZ==1) || (lenc==2/sizeof(TCHAR))) {
                lstrcpyn(codebuf,EMB_Table[i].W_Code+lpEngPrivate->PrivateArea.Comp_Context.PromptCnt,lenw-lpEngPrivate->PrivateArea.Comp_Context.PromptCnt+1);
                codebuf[lenw-lpEngPrivate->PrivateArea.Comp_Context.PromptCnt] = 0;
                if(MBIndex.IMEChara[0].IC_CTC) {
                    if (GetLengthCCharBuf(EMB_Table[i].C_Char)+GetLengthTepBuf(TEXT("9:"))+GetLengthofBuf()+GetLengthTepBuf(codebuf) > MAX_LEN) {
                        lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
                        break;    
                    }
                } else {
                    if (GetLengthCCharBuf(EMB_Table[i].C_Char)+GetLengthTepBuf(TEXT("9:"))+GetLengthofBuf() > MAX_LEN) {
                        lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
                        break;    
                    }
                }
                if(lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt ==IME_MAXCAND) {
                    lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
                    break;
                }
#if defined(COMBO_IME)
                {
                    int k;
                    BOOL ISGBK = FALSE;

                    if(MBIndex.IMEChara[0].IC_GB){ //should test GB/GBK
                        for(k=0;k<lenc;k+=2/sizeof(TCHAR)){ 
                            if(ISGBK = IsGBK(&EMB_Table[i].C_Char[k])){//out of GB range
                                break;
                            }
                        }
                        if(ISGBK){
                        }else{
                            lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt = (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1) ;
                            lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt%IME_MAXCAND] = (BYTE)(lpEngPrivate->PrivateArea.GlobVac.SBufPos);
                            lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,EMB_Table[i].C_Char,lenc+1);
                            lpEngPrivate->PrivateArea.GlobVac.SBufPos += lenc;
                            if(MBIndex.IMEChara[0].IC_CTC) {
                                lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,
                                        EMB_Table[i].W_Code+lpEngPrivate->PrivateArea.Comp_Context.PromptCnt,lenw-lpEngPrivate->PrivateArea.Comp_Context.PromptCnt+1);
                                lpEngPrivate->PrivateArea.GlobVac.SBufPos += (lenw-lpEngPrivate->PrivateArea.Comp_Context.PromptCnt);
                            }
                            lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT(' ');
                            lpEngPrivate->PrivateArea.GlobVac.SBufPos ++;
                        }
                    }else{
                        lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt = (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1) ;
                        lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt%IME_MAXCAND] = (BYTE)(lpEngPrivate->PrivateArea.GlobVac.SBufPos);
                        lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,EMB_Table[i].C_Char,lenc+1);
                        lpEngPrivate->PrivateArea.GlobVac.SBufPos += lenc;
                        if(MBIndex.IMEChara[0].IC_CTC) {
                            lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,
                                    EMB_Table[i].W_Code+lpEngPrivate->PrivateArea.Comp_Context.PromptCnt,lenw-lpEngPrivate->PrivateArea.Comp_Context.PromptCnt+1);
                            lpEngPrivate->PrivateArea.GlobVac.SBufPos += (lenw-lpEngPrivate->PrivateArea.Comp_Context.PromptCnt);
                        }
                        lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT(' ');
                        lpEngPrivate->PrivateArea.GlobVac.SBufPos ++;
                    }

                }
#else
                lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt = (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1) ;
                lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt%IME_MAXCAND] = lpEngPrivate->PrivateArea.GlobVac.SBufPos;
                lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,EMB_Table[i].C_Char,lenc+1);
                lpEngPrivate->PrivateArea.GlobVac.SBufPos += lenc;
                if(MBIndex.IMEChara[0].IC_CTC) {
                    lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,
                            EMB_Table[i].W_Code+lpEngPrivate->PrivateArea.Comp_Context.PromptCnt,lenw-lpEngPrivate->PrivateArea.Comp_Context.PromptCnt+1);
                    lpEngPrivate->PrivateArea.GlobVac.SBufPos += (lenw-lpEngPrivate->PrivateArea.Comp_Context.PromptCnt);
                }
                lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT(' ');
                lpEngPrivate->PrivateArea.GlobVac.SBufPos ++;
#endif //COMBO_IME
            } 
        }
    }
    lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCEndPos = i;    
}    


void SearchBEMBWildMatch() {
    int  i,lenw,lenc;
    TCHAR codebuf[13];

    if(!lpEngPrivate->PrivateArea.GlobVac.EMB_Exist)
        return;
    if(GetLengthofBuf() > MAX_LEN) {
        lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
        return;
    }
        
    for (i=lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCEndPos-1 ; i>=lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQStartPos; i--) {
        if (wcsncmp(EMB_Table[i].W_Code ,lpEngPrivate->PrivateArea.Comp_Context.szInBuffer,lpEngPrivate->PrivateArea.Comp_Context.PromptCnt)==0) { //Wild code match
            lenc = DBCSCharlen(EMB_Table[i].C_Char);
            lenw = Inputcodelen(EMB_Table[i].W_Code);
            if ((MBIndex.IMEChara[0].IC_CZ==1) || (lenc==2/sizeof(TCHAR))) {
                lstrcpyn(codebuf,EMB_Table[i].W_Code+lpEngPrivate->PrivateArea.Comp_Context.PromptCnt,lenw-lpEngPrivate->PrivateArea.Comp_Context.PromptCnt+1);
                codebuf[lenw-lpEngPrivate->PrivateArea.Comp_Context.PromptCnt] = 0;
                if(MBIndex.IMEChara[0].IC_CTC) {
                    if (GetLengthCCharBuf(EMB_Table[i].C_Char)+GetLengthTepBuf(TEXT("9:"))+GetLengthofBuf()+GetLengthTepBuf(codebuf) > MAX_LEN) {
                        lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
                        i++;
                        break;    
                    }
                }else {
                    if (GetLengthCCharBuf(EMB_Table[i].C_Char)+GetLengthTepBuf(TEXT("9:"))+GetLengthofBuf() > MAX_LEN) {
                        lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
                        i++;
                        break;    
                    }
                }
                if (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt==IME_MAXCAND) {
                    lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
                    i++;
                    break;
                }
                
#if defined(COMBO_IME)
                {
                    int k;
                    BOOL ISGBK = FALSE;

                    if(MBIndex.IMEChara[0].IC_GB){ //should test GB/GBK
                        for(k=0;k<lenc;k+=2/sizeof(TCHAR)){ 
                            if(ISGBK = IsGBK(&EMB_Table[i].C_Char[k])){//out of GB range
                                break;
                            }
                        }
                        if(ISGBK){
                        }else{
                            lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt = (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1) ;
                            lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt%IME_MAXCAND] = (BYTE)(lpEngPrivate->PrivateArea.GlobVac.SBufPos);
                            lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,EMB_Table[i].C_Char,lenc+1);
                            lpEngPrivate->PrivateArea.GlobVac.SBufPos += DBCSCharlen(EMB_Table[i].C_Char);
                            if(MBIndex.IMEChara[0].IC_CTC) {
                                lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,
                                        EMB_Table[i].W_Code+lpEngPrivate->PrivateArea.Comp_Context.PromptCnt,lenw-lpEngPrivate->PrivateArea.Comp_Context.PromptCnt+1);
                                lpEngPrivate->PrivateArea.GlobVac.SBufPos += (lenw-lpEngPrivate->PrivateArea.Comp_Context.PromptCnt);
                            }
                            lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT(' ');
                            lpEngPrivate->PrivateArea.GlobVac.SBufPos ++;
                        }
                    }else{
                        lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt = (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1) ;
                        lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt%IME_MAXCAND] = (BYTE)(lpEngPrivate->PrivateArea.GlobVac.SBufPos);
                        lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,EMB_Table[i].C_Char,lenc+1);
                        lpEngPrivate->PrivateArea.GlobVac.SBufPos += DBCSCharlen(EMB_Table[i].C_Char);
                        if(MBIndex.IMEChara[0].IC_CTC) {
                            lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,
                                    EMB_Table[i].W_Code+lpEngPrivate->PrivateArea.Comp_Context.PromptCnt,lenw-lpEngPrivate->PrivateArea.Comp_Context.PromptCnt+1);
                            lpEngPrivate->PrivateArea.GlobVac.SBufPos += (lenw-lpEngPrivate->PrivateArea.Comp_Context.PromptCnt);
                        }
                        lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT(' ');
                        lpEngPrivate->PrivateArea.GlobVac.SBufPos ++;
                    }

                }
#else
                lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt = (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1) ;
                lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt%IME_MAXCAND] = lpEngPrivate->PrivateArea.GlobVac.SBufPos;
                lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,EMB_Table[i].C_Char,lenc+1);
                lpEngPrivate->PrivateArea.GlobVac.SBufPos += DBCSCharlen(EMB_Table[i].C_Char);
                if(MBIndex.IMEChara[0].IC_CTC) {
                    lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,
                            EMB_Table[i].W_Code+lpEngPrivate->PrivateArea.Comp_Context.PromptCnt,lenw-lpEngPrivate->PrivateArea.Comp_Context.PromptCnt+1);
                    lpEngPrivate->PrivateArea.GlobVac.SBufPos += (lenw-lpEngPrivate->PrivateArea.Comp_Context.PromptCnt);
                }
                lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT(' ');
                lpEngPrivate->PrivateArea.GlobVac.SBufPos ++;
#endif //COMBO_IME
            } 
        }
    }
    lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCStartPos = i;    
}    

void SearchBEMBLXMatch() {
    int  i,lenc;
    
    if(!lpEngPrivate->PrivateArea.GlobVac.EMB_Exist)
        return;
    if(GetLengthofBuf() > MAX_LEN) {
        lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
        return;
    }
        
    for (i=lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCEndPos-1 ; i>=0; i--) {
        if (wcsncmp(EMB_Table[i].C_Char ,lpEngPrivate->PrivateArea.Comp_Context.szLxBuffer,lpEngPrivate->PrivateArea.Comp_Context.LxStrCnt)==0) { //Wild code match
            lenc = DBCSCharlen(EMB_Table[i].C_Char);
            if (lenc > lpEngPrivate->PrivateArea.Comp_Context.LxStrCnt) {
                if (GetLengthCCharBuf(EMB_Table[i].C_Char)+GetLengthTepBuf(TEXT("9:"))+GetLengthofBuf() > MAX_LEN) {
                    lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
                    i++;
                    break;
                }
                if (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt==IME_MAXCAND) {  // words count is enough
                    lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
                    i++;
                    break;
                }
#if defined(COMBO_IME)
                {
                    int k;
                    BOOL ISGBK = FALSE;

                    if(MBIndex.IMEChara[0].IC_GB){ //should test GB/GBK
                        for(k=0;k<lenc;k+=2/sizeof(TCHAR)){ 
                            if(ISGBK = IsGBK(&EMB_Table[i].C_Char[k])){//out of GB range
                                break;
                            }
                        }
                        if(ISGBK){
                        }else{
                            lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt = (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1);
                            lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt%IME_MAXCAND] = (BYTE)(lpEngPrivate->PrivateArea.GlobVac.SBufPos);
                            lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,EMB_Table[i].C_Char,lenc+1);
                            lpEngPrivate->PrivateArea.GlobVac.SBufPos += lenc;
                            lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT(' ');
                            lpEngPrivate->PrivateArea.GlobVac.SBufPos ++;
                        }
                    }else{
                        lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt = (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1);
                        lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt%IME_MAXCAND] = (BYTE)(lpEngPrivate->PrivateArea.GlobVac.SBufPos);
                        lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,EMB_Table[i].C_Char,lenc+1);
                        lpEngPrivate->PrivateArea.GlobVac.SBufPos += lenc;
                        lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT(' ');
                        lpEngPrivate->PrivateArea.GlobVac.SBufPos ++;
                    }

                }
#else
                lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt = (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1);
                
                lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt%IME_MAXCAND] = lpEngPrivate->PrivateArea.GlobVac.SBufPos;
                lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,EMB_Table[i].C_Char,lenc+1);
                lpEngPrivate->PrivateArea.GlobVac.SBufPos += lenc;
                lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT(' ');
                lpEngPrivate->PrivateArea.GlobVac.SBufPos ++;
#endif //COMBO_IME
            } 
          }
    }
    lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCStartPos = i;    
}    

void SearchEMBLXMatch() {
    int  i,lenw,lenc;

    if(!lpEngPrivate->PrivateArea.GlobVac.EMB_Exist)
        return;
    if(GetLengthofBuf() >= MAX_LEN) {
        lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
        return;
    }
    for (i=lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCStartPos ; i<lpEngPrivate->PrivateArea.GlobVac.EMB_Count; i++) {
        if (wcsncmp(EMB_Table[i].C_Char ,lpEngPrivate->PrivateArea.Comp_Context.szLxBuffer,lpEngPrivate->PrivateArea.Comp_Context.LxStrCnt)==0) {
            lenc = DBCSCharlen(EMB_Table[i].C_Char);
            lenw = Inputcodelen(EMB_Table[i].W_Code);
            if (lenc > lpEngPrivate->PrivateArea.Comp_Context.LxStrCnt) {
                if (GetLengthCCharBuf(EMB_Table[i].C_Char)+GetLengthTepBuf(TEXT("9:"))+GetLengthofBuf() > MAX_LEN) {
                    lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
                    break;
                }
                
                if (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt ==IME_MAXCAND) {
                    lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
                    break;
                }
#if defined(COMBO_IME)
                {
                    int k;
                    BOOL ISGBK = FALSE;

                    if(MBIndex.IMEChara[0].IC_GB){ //should test GB/GBK
                        for(k=0;k<lenc;k+=2/sizeof(TCHAR)){ 
                            if(ISGBK = IsGBK(&EMB_Table[i].C_Char[k])){//out of GB range
                                break;
                            }
                        }
                        if(ISGBK){
                        }else{
                            lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt = (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1);
                            lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt%IME_MAXCAND] = (BYTE)(lpEngPrivate->PrivateArea.GlobVac.SBufPos);
                            lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,EMB_Table[i].C_Char,lenc+1);
                            lpEngPrivate->PrivateArea.GlobVac.SBufPos += lenc;
                            lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT(' ');
                            lpEngPrivate->PrivateArea.GlobVac.SBufPos ++;
                        }
                    }else{
                        lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt = (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1);
                        lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt%IME_MAXCAND] = (BYTE)(lpEngPrivate->PrivateArea.GlobVac.SBufPos);
                        lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,EMB_Table[i].C_Char,lenc+1);
                        lpEngPrivate->PrivateArea.GlobVac.SBufPos += lenc;
                        lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT(' ');
                        lpEngPrivate->PrivateArea.GlobVac.SBufPos ++;
                    }

                }
#else
                lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt = (lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt+1);
                lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt%IME_MAXCAND] = lpEngPrivate->PrivateArea.GlobVac.SBufPos;
                lstrcpyn(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,EMB_Table[i].C_Char,lenc+1);
                lpEngPrivate->PrivateArea.GlobVac.SBufPos += lenc;
                lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT(' ');
                lpEngPrivate->PrivateArea.GlobVac.SBufPos ++;
#endif //COMBO_IME
            } 
        }
    }
    lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCEndPos = i;    
}    



    

void CapKeyProc(TCHAR code){}


DWORD Skip_CaWord(DWORD sp) {  // sp's start position must be chinese's first byte
    TCHAR len;

    len = ZM_Area[sp];
    sp += (len+1);
    len = ZM_Area[sp];

#ifdef UNICODE
//  all the code in MB are Unicode now, len should not be mult by 2.
    sp += len + 1;
#else
    sp += (2*len+1);
#endif


    return (sp);
}

int Scan_Word(DWORD sp, LPTSTR tbuf) {

    TCHAR numwords;
    
    numwords = ZM_Area[sp];
    numwords = numwords*2/sizeof(TCHAR);

    //Engine mess up to unreasonable number, force it return. NTBUG #86303
    if (numwords > 130)
       return 0;    

    lstrcpyn(tbuf,&ZM_Area[sp+1],numwords+1);
    tbuf[numwords] = TEXT('\0');
    return (numwords);
}

            
int VerScan_Word(DWORD sp, LPTSTR tbuf) { //start position must be the last byte
    TCHAR numwords;

    for (;;) {
#ifdef UNICODE
        if(ZM_Area[sp] > 0x100) 
            sp -= 1;
#else
        if(ZM_Area[sp-1]&0x80) 
            sp -= 2;
#endif
        else
            break;
    }   
    numwords = ZM_Area[sp];
    numwords = numwords*2/sizeof(TCHAR);
    sp++;
    lstrcpyn(tbuf,ZM_Area+sp,numwords+1);
    *(tbuf+numwords) = TEXT('\0');
    return (numwords);
}

void IMDReset(int i) {
    if(i<=lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQStartPos) {
        lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQStartPos++;
        lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCStartPos++;                
        lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQEndPos++;
        lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCEndPos++;                
    } else if(i<=lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCStartPos) {
        lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCStartPos++;                
        lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCEndPos++;
        lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQEndPos++;
    } else if(i<=lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQEndPos) { 
        lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQEndPos++;
    }
}

// Write to EMB_File

BOOL WriteEMBToFile(LPTSTR embaddress) {
    HANDLE         hFile;
    DWORD         byte_t_write;
    TCHAR        path_name[MAX_PATH];
    PSECURITY_ATTRIBUTES psa;

    lstrcpy(path_name, sImeG.szIMEUserPath);
    lstrcat(path_name,TEXT("\\"));
    lstrcat(path_name,lpEngPrivate->EMB_Name);

    psa = CreateSecurityAttributes();
    hFile = CreateFile(path_name,
                       GENERIC_WRITE|GENERIC_READ,
                       FILE_SHARE_WRITE|FILE_SHARE_READ,
                       psa,
                       CREATE_ALWAYS,
                       0,
                       NULL);

    FreeSecurityAttributes(psa);

    if(hFile==INVALID_HANDLE_VALUE)    {
        byte_t_write = GetLastError();
        return(0);
    }

    WriteFile(hFile,
              &lpEngPrivate->PrivateArea.GlobVac.EMB_Count,
              2,
              &byte_t_write,
              NULL);
 
    WriteFile(hFile,
              embaddress,
              lpEngPrivate->PrivateArea.GlobVac.EMB_Count*sizeof(EMB_Head), 
              &byte_t_write, 
              NULL); 
        
    SetEndOfFile(hFile);
    CloseHandle(hFile);
    return (1);
}


BOOL GetUDCItem(HIMCC HmemPri,UINT Index,LPTSTR Read_String,LPTSTR Result_String) {

    lpEngPrivate = (PPRIVCONTEXT) ImmLockIMCC(HmemPri);
    if(!lpEngPrivate){
        return (0);
    }

    if(!lpEngPrivate->PrivateArea.GlobVac.EMB_Exist) {
        ImmUnlockIMCC(HmemPri);
        return (0);
    }
    else if (lpEngPrivate->PrivateArea.GlobVac.EMB_Count <= Index) {
        ImmUnlockIMCC(HmemPri);
        return (0);
    }
    else {
        lstrcpyn(Read_String, EMB_Table[Index].W_Code, MAXCODE+1);
        Read_String[MAXCODE] = 0;
        lstrcpyn(Result_String, EMB_Table[Index].C_Char, MAXINPUTWORD+1);
        Result_String[MAXINPUTWORD] = 0;
        return(1);
    }
}


int AddZCItem(HIMCC HmemPri,LPTSTR wai_code,LPTSTR cCharStr) { 
    HANDLE               hFile,hMProcess,hCProcess;
    TCHAR                path_name[MAX_PATH];
    int                  byte_t_write, i,j;
    TCHAR                emp;
    PSECURITY_ATTRIBUTES psa = NULL;

    EMB_Head             *emb;
    HANDLE               hemb;
    TCHAR                szW_Code[MAXCODE];
    TCHAR                szC_CharStr[MAXINPUTWORD];

    
    lpEngPrivate = (PPRIVCONTEXT) ImmLockIMCC(HmemPri);
    if(!lpEngPrivate){
       return (0);
    }

    hemb = GlobalAlloc(GMEM_DISCARDABLE,
                       (lpEngPrivate->PrivateArea.GlobVac.EMB_Count+1)*sizeof(EMB_Head));

    if(!hemb){
       ImmUnlockIMCC(HmemPri);
        return (0);
    }
    
    emb = GlobalLock(hemb);
    if(!emb){
        GlobalFree(hemb);    
        ImmUnlockIMCC(HmemPri);
        return(0);
    }

    for (i=0; i<MAXCODE; i++)
        szW_Code[i] = TEXT('\0');

    for (i=0; i<MAXINPUTWORD; i++)
        szC_CharStr[i] = TEXT('\0');

    for (i=0; i<lstrlen(wai_code); i++)
        szW_Code[i] = wai_code[i];

    for (i=0; i<lstrlen(cCharStr); i++)
        szC_CharStr[i] = cCharStr[i];

    if (!lpEngPrivate->PrivateArea.GlobVac.EMB_Exist) {

        lstrcpy(path_name, sImeG.szIMEUserPath);
        lstrcat(path_name,TEXT("\\"));
        lstrcat(path_name,lpEngPrivate->EMB_Name);

        psa = CreateSecurityAttributes();
        hFile = CreateFile(path_name,
                           GENERIC_WRITE,
                           FILE_SHARE_WRITE,
                           psa,
                           CREATE_NEW,
                           0,
                           NULL);

        if(hFile==INVALID_HANDLE_VALUE) {
            FreeSecurityAttributes(psa);
            GlobalUnlock(emb);    
            GlobalFree(hemb);    
            ImmUnlockIMCC(HmemPri);
            return(0);
        }

        lpEngPrivate->PrivateArea.GlobVac.EMB_Count = 1;
        WriteFile(hFile,
                  &lpEngPrivate->PrivateArea.GlobVac.EMB_Count,
                  2,
                  &byte_t_write,
                  NULL); 

        WriteFile(hFile,
                  szW_Code,
                  MAXCODE*sizeof(TCHAR), 
                  &byte_t_write, 
                  NULL); 

        WriteFile(hFile,
                  szC_CharStr,
                  MAXINPUTWORD * sizeof(TCHAR), 
                  &byte_t_write, 
                  NULL); 

        SetEndOfFile(hFile);
        CloseHandle(hFile);
        lpEngPrivate->PrivateArea.GlobVac.EMB_Exist = 1;

        hFile = CreateFile(path_name,
                           GENERIC_READ|GENERIC_WRITE,
                           FILE_SHARE_READ|FILE_SHARE_WRITE,
                           psa,
                           OPEN_EXISTING,
                           0,
                           NULL);

        for (i=0;i<MaxTabNum;i++) {
            if(lstrcmp(HMapTab[i].MB_Name,lpEngPrivate->MB_Name)==0)
                break;
        } 
        
        HmemEMB_Table = CreateFileMapping(hFile, 
                                          psa,
                                          PAGE_READWRITE, 
                                          0,
                                          sizeof(EMB_Head)*MAXNUMBER_EMB+2,
                                          HMapTab[i].EMB_Obj);
        if (EMBM) 
           UnmapViewOfFile(EMBM);

        EMBM = MapViewOfFile(HmemEMB_Table,
                             FILE_MAP_READ|FILE_MAP_WRITE,
                             0,
                             0,
                             sizeof(EMB_Head)*MAXNUMBER_EMB+2);

        EMB_Table =(EMB_Head *)(EMBM+2); 
        lpEngPrivate->PrivateArea.hEmbFile = hFile;
        lpEngPrivate->PrivateArea.hMapEMB = HmemEMB_Table;                
        if(GetCurrentProcessId()==HMapTab[i].EMB_ID) {
            HMapTab[i].hEmbFile = hFile;    
        } else {
            hCProcess = GetCurrentProcess();
            hMProcess = OpenProcess(STANDARD_RIGHTS_REQUIRED|PROCESS_DUP_HANDLE,
                                    FALSE,
                                    HMapTab[i].EMB_ID);
            DuplicateHandle(hCProcess,
                            lpEngPrivate->PrivateArea.hEmbFile,
                            hMProcess,
                            &HMapTab[i].hEmbFile,
                            0,
                            FALSE,
                            DUPLICATE_SAME_ACCESS);
        }
        FreeSecurityAttributes(psa);    

    } else {

        if(lpEngPrivate->PrivateArea.GlobVac.EMB_Count==MAXNUMBER_EMB){
            GlobalUnlock(emb);    
            GlobalFree(hemb);    
            ImmUnlockIMCC(HmemPri);
            return (3);
        }
    
        for(i=0; i<lpEngPrivate->PrivateArea.GlobVac.EMB_Count;i++) {
            if(wcsncmp(szW_Code, EMB_Table[i].W_Code, MAXCODE) <=0)
                break;
        }        

        if ((wcsncmp(szW_Code,EMB_Table[i].W_Code,MAXCODE)==0) && 
            (wcsncmp(EMB_Table[i].C_Char,szC_CharStr,MAXINPUTWORD)==0))
        {
            // this record has already been in the dictionary.

            GlobalUnlock(emb);   
            GlobalFree(hemb);    
            ImmUnlockIMCC(HmemPri);
            return(2);
        }
        else {
            memmove(EMB_Table+i+1, 
                    EMB_Table+i,
                   (lpEngPrivate->PrivateArea.GlobVac.EMB_Count-i)*sizeof(EMB_Head));

            for (j=0; j<MAXCODE; j++)
                EMB_Table[i].W_Code[j] = szW_Code[j];

            for (j=0; j<MAXINPUTWORD; j++)
               EMB_Table[i].C_Char[j] = szC_CharStr[j];
                
            lpEngPrivate->PrivateArea.GlobVac.EMB_Count ++;
            (LPWORD)(EMBM)[0]++;//=lpEngPrivate->PrivateArea.GlobVac.EMB_Count;

            //the file is flushed from base address to the end of the mapping
            FlushViewOfFile(EMBM, 0);

        }
    }

    IMDReset(i);
    GlobalUnlock(emb);    
    GlobalFree(hemb);    
    ImmUnlockIMCC(HmemPri);
    return(1);
}

void DelSelCU(HIMCC HmemPri,int item) {
    
    lpEngPrivate = (PPRIVCONTEXT) ImmLockIMCC(HmemPri);
    if(!lpEngPrivate){
        ImmUnlockIMCC(HmemPri);
        return ;
    }

    if(!lpEngPrivate->PrivateArea.GlobVac.EMB_Exist){     
        ImmUnlockIMCC(HmemPri);
        return;
    }
    memcpy(EMB_Table+item,EMB_Table+item+1,(lpEngPrivate->PrivateArea.GlobVac.EMB_Count-item-1)*sizeof(EMB_Head));
    lpEngPrivate->PrivateArea.GlobVac.EMB_Count --;
    *((LPWORD)EMB_Table-1) = lpEngPrivate->PrivateArea.GlobVac.EMB_Count ;
    IMDReset(item);
    
    ImmUnlockIMCC(HmemPri);
}

int GetUDCIndex(HIMCC HmemPri,LPTSTR lpreadstring,LPTSTR lpresultstring) {
    int i ;

    lpEngPrivate = (PPRIVCONTEXT) ImmLockIMCC(HmemPri);
    if(!lpEngPrivate){
        ImmUnlockIMCC(HmemPri);
        return (-1);
    }

    if(!lpEngPrivate->PrivateArea.GlobVac.EMB_Exist) {
        ImmUnlockIMCC(HmemPri);
        return (-1);
    }
    for(i=0;i<lpEngPrivate->PrivateArea.GlobVac.EMB_Count;i++) {
        if((wcsncmp(EMB_Table[i].W_Code, lpreadstring, MAXCODE)==0) && (wcsncmp(EMB_Table[i].C_Char,lpresultstring,MAXINPUTWORD)==0)){
            ImmUnlockIMCC(HmemPri);
            return(i);
        }
    }
    ImmUnlockIMCC(HmemPri);
    return(-1);
}
    
                            
void  DelExmb(HIMCC HmemPri) {

    TCHAR  path_name[MAX_PATH];

    lpEngPrivate = (PPRIVCONTEXT) ImmLockIMCC(HmemPri);    
    if(!lpEngPrivate){
        return ;
    }

    if (!lpEngPrivate->PrivateArea.GlobVac.EMB_Exist) {
        ImmUnlockIMCC(HmemPri);
        return;
    }
    lpEngPrivate->PrivateArea.GlobVac.EMB_Count = 0;

    lstrcpy(path_name, sImeG.szIMEUserPath);
    lstrcat(path_name,TEXT("\\"));
    lstrcat(path_name,lpEngPrivate->EMB_Name);

    DeleteFile(path_name);

    lpEngPrivate->PrivateArea.GlobVac.EMB_Exist = 0;
    ImmUnlockIMCC(HmemPri);
}

BYTE CodeInSet(char ch) {
    BYTE i;

    for (i=0;i<NumCodes;i++) {
        if(UsedCode[i]==ch)
            break;
    } 
    return(i);
}

UINT InCodeSet(TCHAR ch) {
    BYTE i;

    for (i=0;i<NumCodes;i++) {
        if(UsedCode[i]==ch)
            break;
    }
    if (i==NumCodes)
        return (0);
    else 
        return (1);
}

int  NumInSet() {
    int i;
    
    for (i=0;i<9;i++) {
        if(CodeAIndex[30+i]!=0)
            return(1);
    }
    return(0);
}

void ConvertCandi() {
    int        i,j;
    BYTE      tempos[IME_MAXCAND];
    BYTE     s_pos,n_pos;
    TCHAR     tembuf[3000];
    TCHAR     ch;

    n_pos = 0;
    j = 1;
    for(i=lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt; i>0; i--) {
        tempos[j%IME_MAXCAND] = n_pos;
        s_pos = lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[i%IME_MAXCAND];
        for(;;) {
            ch = lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[s_pos];
            if(ch==0x20 || ch==0x00)
                break;
            tembuf[n_pos] = ch;
            n_pos ++;
            s_pos ++;
        }
        tembuf[n_pos] = 0x20;
        n_pos ++;
        j ++;
    }
    tembuf[n_pos] = 0x00;
    for(i=0; i<=lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt; i++) 
        lpEngPrivate->PrivateArea.Comp_Context.Candi_Pos[i] = tempos[i];
        lstrcpy(lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer,tembuf);
}
    
    
BYTE WildInBuffer() {
    BYTE i;
    for (i=0;i<lpEngPrivate->PrivateArea.Comp_Context.PromptCnt;i++) {
        if(WildChar==lpEngPrivate->PrivateArea.Comp_Context.szInBuffer[i])
            break;
    }
        return(i);
}            
void ResetCont(HIMCC HmemPri) {
    int i;
    int scs,csce;
    HANDLE hMProcess,hCProcess;

    lpEngPrivate = (PPRIVCONTEXT) ImmLockIMCC(HmemPri);        
    if(!lpEngPrivate){
        return ;
    }

    GetMBHead();
    if(lpEngPrivate->PrivateArea.hMapEMB!=NULL) {
        if (EMBM) UnmapViewOfFile(EMBM);
        EMBM =MapViewOfFile(HmemEMB_Table,FILE_MAP_READ|FILE_MAP_WRITE,0,0,0);
        lpEngPrivate->PrivateArea.GlobVac.EMB_Count = *(WORD *)EMBM;
        EMB_Table = (EMB_Head *) (EMBM+2);
        scs = lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCStartPos - lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQStartPos;
        csce = lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCEndPos - lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCStartPos;
        for (i=0;i<lpEngPrivate->PrivateArea.Comp_Context.PromptCnt;i++) 
            SearchEMBPos(lpEngPrivate->PrivateArea.Comp_Context.szInBuffer[i],(BYTE)(i+1));
        
        lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCStartPos = lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQStartPos + scs;
        lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCEndPos = lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCStartPos + csce;

    } else {
        for (i=0;i<MaxTabNum;i++ ) {
            if(wcscmp(HMapTab[i].MB_Name,lpEngPrivate->MB_Name)==0) {
                break;
            }
        }
        if (HMapTab[i].hEmbFile!=NULL) {
            hCProcess = GetCurrentProcess();
            hMProcess = OpenProcess(STANDARD_RIGHTS_REQUIRED|PROCESS_DUP_HANDLE,FALSE,HMapTab[i].EMB_ID);
            DuplicateHandle(hMProcess,HMapTab[i].hEmbFile,hCProcess,&lpEngPrivate->PrivateArea.hEmbFile,0,FALSE,DUPLICATE_SAME_ACCESS);
            HmemEMB_Table = OpenFileMapping(FILE_MAP_READ|FILE_MAP_WRITE,FALSE,HMapTab[i].EMB_Obj);
            lpEngPrivate->PrivateArea.GlobVac.EMB_Exist = 1;    
            if (EMBM) UnmapViewOfFile(EMBM);
            EMBM =MapViewOfFile(HmemEMB_Table,FILE_MAP_READ|FILE_MAP_WRITE,0,0,0);
            lpEngPrivate->PrivateArea.GlobVac.EMB_Count = *(WORD *)EMBM;
            EMB_Table = (EMB_Head *) (EMBM+2);
            lpEngPrivate->PrivateArea.hMapEMB = HmemEMB_Table ;        
        
            scs = lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCStartPos - lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQStartPos;
            csce = lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCEndPos - lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCStartPos;
            for (i=0;i<lpEngPrivate->PrivateArea.Comp_Context.PromptCnt;i++) 
                SearchEMBPos(lpEngPrivate->PrivateArea.Comp_Context.szInBuffer[i],(BYTE)(i+1));
        
            lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCStartPos = lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQStartPos + scs;
            lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCEndPos = lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCStartPos + csce;
        }
    }

    ReadArea(lpEngPrivate->PrivateArea.Comp_Context.szInBuffer[0]);

    ImmUnlockIMCC(HmemPri);
}

UINT ReadArea(TCHAR code) {
    HANDLE         hFile;
    TCHAR          path_name[MAX_PATH];
    int            path_lenth;
    long           boffset,offset,area_size;
    DWORD          tag,byte_t_read;
    DWORD          b_dic_len;    
    BYTE           code_no;
    PSECURITY_ATTRIBUTES psa;
    BOOL           retVal;
    
    lstrcpy(path_name, sImeG.szIMESystemPath);
    lstrcat(path_name,TEXT("\\"));    
    lstrcat(path_name, lpEngPrivate->MB_Name);
        
    psa = CreateSecurityAttributes();
    hFile = CreateFile(path_name,
                       GENERIC_READ,
                       FILE_SHARE_READ,
                       psa,
                       OPEN_EXISTING,
                       0,
                       NULL);

    FreeSecurityAttributes(psa);

    if(hFile == INVALID_HANDLE_VALUE)
        return(0);

    SetFilePointer(hFile,28,NULL,FILE_BEGIN);

    for(;;) {
        retVal = ReadFile(hFile,&tag,4,&byte_t_read,NULL);

        if ( retVal == FALSE )
        {
            CloseHandle(hFile); 
            return 0;
        }

        if(tag==TAG_BASEDIC)
            break;
        SetFilePointer(hFile,12,NULL,FILE_CURRENT);
    }

    retVal = ReadFile(hFile,&boffset,4,&byte_t_read,NULL);
    if ( retVal == FALSE )
    {
       CloseHandle(hFile); 
       return 0;
    }

    retVal = ReadFile(hFile,&b_dic_len,4,&byte_t_read,NULL);
    if ( retVal == FALSE )
    {
       CloseHandle(hFile); 
       return 0;
    }

    SetFilePointer(hFile,boffset,NULL,FILE_BEGIN);
    code_no = CodeAIndex[code];
    offset = MB_Head_Table[code_no-1].Q_offset;
    
    SetFilePointer(hFile,offset,NULL,FILE_CURRENT);
    byte_t_read = 0;
    CloseHandle(hFile);
    if (CodeAIndex[code]<NumCodes) {
        area_size = (MB_Head_Table[code_no].Q_offset - offset)/sizeof(TCHAR);
         if(lpEngPrivate->PrivateArea.hMapMB==NULL) {            
            MessageBeep((UINT)-1);
        } else {         
        if (g_lptep == NULL)
        g_lptep = MapViewOfFile(lpEngPrivate->PrivateArea.hMapMB,FILE_MAP_READ,0,0,0);
        
        ZM_Area = (LPTSTR)((LPBYTE)g_lptep+boffset+offset);
        }//return(0);
    } else {
        area_size = (b_dic_len - offset)/sizeof(TCHAR);
        if (g_lptep == NULL)
        g_lptep = MapViewOfFile(lpEngPrivate->PrivateArea.hMapMB,FILE_MAP_READ,0,0,0);
        ZM_Area = (LPTSTR)((LPBYTE)g_lptep+boffset+offset);        
    }
    byte_t_read = area_size;
    return(byte_t_read);
        
}

UINT  Conversion(HIMCC HmemPri,LPCTSTR lpSrc,UINT uFlag) {
    UINT    srclen;    
    UINT    dstlen;
    UINT    byte_t_read;
    BYTE    search_suc ;
    UINT    wordlen,codelen,len;
    int     i,start_pos;
    TCHAR   tepbuf[130];
    int     areacode;
    TCHAR   charbuf[256];

    lpEngPrivate = (PPRIVCONTEXT) ImmLockIMCC(HmemPri);              
    if(!lpEngPrivate){
        return (0);
    }

    switch (uFlag) {
    case 0:

        srclen = lstrlen(lpSrc);
        byte_t_read = ReadArea(lpSrc[0]);
        if(byte_t_read==0){
            ImmUnlockIMCC(HmemPri);
            return(0);
        }
        lpEngPrivate->PrivateArea.Comp_Proc.dBDicStartPos = 0;
        lpEngPrivate->PrivateArea.Comp_Proc.dBDicEndPos = byte_t_read;
        lpEngPrivate->PrivateArea.Comp_Proc.dBDicCStartPos = 0;
        lpEngPrivate->PrivateArea.Comp_Proc.dBDicCEndPos = lpEngPrivate->PrivateArea.Comp_Proc.dBDicStartPos;
        lpEngPrivate->PrivateArea.GlobVac.Area_V_Lenth = byte_t_read;

        search_suc = MBPositionSearch(lpSrc);

        if(search_suc) {
            lpEngPrivate->PrivateArea.GlobVac.SBufPos = 0;
            i = lpEngPrivate->PrivateArea.Comp_Proc.dBDicStartPos;
            for(;;) {
        
                codelen = ZM_Area[i];
                if(wcsncmp(ZM_Area+i+1,lpSrc,codelen)==0) {
                    i += (codelen+1);
                    wordlen = Scan_Word(i,tepbuf);
                    i += (wordlen+1);
                    lstrcpyn(ConverList.szSelectBuffer+lpEngPrivate->PrivateArea.GlobVac.SBufPos,tepbuf,wordlen+1);
                    ConverList.Candi_Pos[ConverList.Candi_Cnt+1] = (BYTE)(lpEngPrivate->PrivateArea.GlobVac.SBufPos);
                    lpEngPrivate->PrivateArea.GlobVac.SBufPos += wordlen;
                    ConverList.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT(' ');
                    lpEngPrivate->PrivateArea.GlobVac.SBufPos ++;
                    ConverList.Candi_Cnt ++;
                } else 
                    break;
            }
            
            lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer[lpEngPrivate->PrivateArea.GlobVac.SBufPos] = TEXT('\0');
            dstlen = lstrlen(ConverList.szSelectBuffer);
            len = dstlen;
    
        } else {             // Invaild code
            ClrDoubleBuf();
            len = 0;
        }
        break;
    case 1:
        lstrcpyn(charbuf,lpSrc,2/sizeof(TCHAR)+1);
        charbuf[2/sizeof(TCHAR)] = TEXT('\0');
        areacode = GetFirstCode(charbuf);
        if(areacode==0){
            if(g_lptep)
            {
                UnmapViewOfFile(g_lptep);
                g_lptep = NULL;
            }
            ImmUnlockIMCC(HmemPri);
            return(0);
        }
        byte_t_read = ReadArea((TCHAR)areacode);
        if (byte_t_read == 0 ) {
            if(g_lptep)
            {
                UnmapViewOfFile(g_lptep);
                g_lptep = NULL;
            }
            ImmUnlockIMCC(HmemPri);
            return(0);
        }
        lpEngPrivate->PrivateArea.Comp_Proc.dBDicStartPos = 0;
        lpEngPrivate->PrivateArea.Comp_Proc.dBDicEndPos = byte_t_read;;
        srclen = lstrlen(lpSrc);
        i = 0;
        for (;;) {        
            codelen = ZM_Area[i];
            start_pos = i+1;
            i += (codelen+1);
            wordlen = Scan_Word(i,charbuf);
            if (!wordlen) // Engine mess up, force exit. hack for #86303
            {
               if(g_lptep)
               {
                   UnmapViewOfFile(g_lptep);
                  g_lptep = NULL;
                  }
                ImmUnlockIMCC(HmemPri);
                return(0);
            }
            i += (wordlen+1);
            if ((wordlen==srclen) && wcsncmp(charbuf,lpSrc,wordlen)==0) {
                lstrcpyn(tepbuf,ZM_Area+start_pos,codelen+1);
                break;
            }
            if (i>=lpEngPrivate->PrivateArea.Comp_Proc.dBDicEndPos)
                break;
        }
        if (i>lpEngPrivate->PrivateArea.Comp_Proc.dBDicEndPos) {
            len = 0;
        }else if (i==lpEngPrivate->PrivateArea.Comp_Proc.dBDicEndPos && wcsncmp(charbuf,lpSrc,wordlen)!=0){
            ConverList.szInBuffer[0] = 0x0;
            len = 0;
        } else {
            lstrcpyn(ConverList.szInBuffer,tepbuf,codelen+1);
            ConverList.szInBuffer[codelen] = 0x0;
            len = codelen;
        }

        break;
    }
    ImmUnlockIMCC(HmemPri);
    return(len);
}



BYTE MBPositionSearch(LPCTSTR lpSrc) {

    int     srclen;
    int     sp;
    BYTE    search_fail = 0;
    BYTE    code_no,code_no1;
    int     wordlen,codelen;

    
    srclen = lstrlen(lpSrc);    
    if (srclen <=2) 
    {    
        search_fail = 1;
        return 0;
    }
    else if ((BYTE)lpSrc[0]>=0x80 || (BYTE)lpSrc[1]>=0x80)
    {
        search_fail = 1;
        return 0;
    }
    code_no1 = CodeAIndex[lpSrc[0]];
    code_no = CodeAIndex[lpSrc[1]];
    sp = MB_Head_Table[code_no1-1].W_offset[code_no-1]/sizeof(TCHAR);
        
    for(;;) {
        codelen = ZM_Area[sp];
        if ((codelen == srclen) && (wcsncmp(ZM_Area+sp+1,lpSrc,codelen)==0)) {
            break;
        } else {
                sp += (codelen+1); 
                wordlen = ZM_Area[sp];
                sp += (2*wordlen/sizeof(TCHAR)+1);
        }    
        if (sp>=lpEngPrivate->PrivateArea.Comp_Proc.dBDicEndPos)
            break;
    }

    lpEngPrivate->PrivateArea.Comp_Proc.dBDicStartPos = sp;
    if (lpSrc[1] < TEXT('z'))
        lpEngPrivate->PrivateArea.Comp_Proc.dBDicEndPos = MB_Head_Table[code_no1-1].W_offset[code_no]/sizeof(TCHAR);
    else
        lpEngPrivate->PrivateArea.Comp_Proc.dBDicEndPos = lpEngPrivate->PrivateArea.GlobVac.Area_V_Lenth;
    if (lpEngPrivate->PrivateArea.Comp_Proc.dBDicStartPos==lpEngPrivate->PrivateArea.Comp_Proc.dBDicEndPos) {
        search_fail = 1;
    } else {
        lpEngPrivate->PrivateArea.Comp_Proc.dBDicCStartPos = lpEngPrivate->PrivateArea.Comp_Proc.dBDicStartPos;
        lpEngPrivate->PrivateArea.Comp_Proc.dBDicCEndPos = lpEngPrivate->PrivateArea.Comp_Proc.dBDicStartPos;

        sp = lpEngPrivate->PrivateArea.Comp_Proc.dBDicStartPos;
        for(;;) {
            codelen = ZM_Area[sp];
            if ((codelen==srclen) && (wcsncmp(ZM_Area+sp+1,lpSrc,srclen)==0)) 
                break;
            else {
                sp += (codelen+1); 
                wordlen = ZM_Area[sp];
                sp += (2*wordlen/sizeof(TCHAR)+1);
            }
            if(sp >= lpEngPrivate->PrivateArea.Comp_Proc.dBDicEndPos)
                break;
        }
        if (sp == lpEngPrivate->PrivateArea.Comp_Proc.dBDicEndPos)  {// no this code_word
            search_fail = 1;
            return 0;        
        }
    } 
    return (1);
}


int GetFirstCode(LPTSTR lpSrc) {
    HANDLE        hFile;
    TCHAR         path_name[MAX_PATH];
    long          offset;
    DWORD         tag,byte_t_read;
    DWORD         char_no;    
    TCHAR         areacode;
    PSECURITY_ATTRIBUTES psa;
    BOOL          retVal;

    lstrcpy(path_name, sImeG.szIMESystemPath);
    lstrcat(path_name,TEXT("\\"));    
    lstrcat(path_name, lpEngPrivate->MB_Name);

    psa = CreateSecurityAttributes();
    hFile = CreateFile(path_name,
                       GENERIC_READ,
                       FILE_SHARE_READ,
                       psa,
                       OPEN_EXISTING,
                       0,
                       NULL);

    FreeSecurityAttributes(psa);

    if(hFile == INVALID_HANDLE_VALUE)
        return(0);
    
    SetFilePointer(hFile,28,NULL,FILE_BEGIN);

    for(;;) {
        byte_t_read = 0;

        retVal = ReadFile(hFile,&tag,4,&byte_t_read,NULL);

        if ( retVal == FALSE )
        {
            CloseHandle(hFile); 
            return 0;
        }

        if(tag==TAG_INTERCODE)
            break;
        SetFilePointer(hFile,12,NULL,FILE_CURRENT);        
    }

    retVal = ReadFile(hFile,&offset,4,&byte_t_read,NULL);                
    if ( retVal == FALSE )
    {
        CloseHandle(hFile); 
        return 0;
    }

    char_no = GetNumber(hFile,offset,lpSrc)    ;

    SetFilePointer(hFile,28,NULL,FILE_BEGIN);
    if ((tag & 0x00000003) !=  FFLG_RULE) {
        for(;;) {
            byte_t_read = 0;
            retVal = ReadFile(hFile,&tag,4,&byte_t_read,NULL);
            if ( retVal == FALSE )
            {
                CloseHandle(hFile); 
                return 0;
            }

            if(tag==TAG_CRTWORDCODE)
                break;
            SetFilePointer(hFile,12,NULL,FILE_CURRENT);        
        }
    } else {
        for(;;) {
            byte_t_read = 0;
            retVal = ReadFile(hFile,&tag,4,&byte_t_read,NULL);

            if ( retVal == FALSE )
            {
                CloseHandle(hFile); 
                return 0;
            }

            if(tag==TAG_RECONVINDEX)
                break;
            SetFilePointer(hFile,12,NULL,FILE_CURRENT);    
        }
    }

    retVal = ReadFile(hFile,&offset,4,&byte_t_read,NULL);          
    if ( retVal == FALSE )
    {
        CloseHandle(hFile); 
        return 0;
    }

    SetFilePointer(hFile,offset,NULL,FILE_BEGIN);    
      
    SetFilePointer(hFile,char_no*MaxCodes*sizeof(TCHAR),NULL,FILE_CURRENT);            
    retVal = ReadFile(hFile,&areacode,1*sizeof(TCHAR),&byte_t_read,NULL);
    if ( retVal == FALSE )
    {
        CloseHandle(hFile); 
        return 0;
    }

    CloseHandle(hFile);        
    return(areacode);
}

DWORD GetNumber(HANDLE hFile,DWORD dwOffset,LPTSTR szDBCS) {
      DWORD             dwNumArea,dwNumWord,dwBytes;
      DWORD             i;
      DWORD             RetNo = 0;
      HANDLE            hInterCode;
      LPINTERCODEAREA   lpInterCode;
      BOOL              retVal;
  
      SetFilePointer(hFile,dwOffset,0,FILE_BEGIN);

      retVal = ReadFile(hFile,&dwNumWord,4,&dwBytes,NULL);

      if ( retVal == FALSE )
          return 0;

      retVal = ReadFile(hFile,&dwNumArea,4,&dwBytes,NULL);

      if ( retVal == FALSE )
          return 0;

      hInterCode = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT,
                             dwNumArea*sizeof(INTERCODEAREA));
      if(!hInterCode) 
        return (0); 
      lpInterCode = GlobalLock(hInterCode);
      if(!lpInterCode){
        GlobalFree(hInterCode);
        return(0);
      }

      retVal = ReadFile(hFile,lpInterCode,dwNumArea*sizeof(INTERCODEAREA),&dwBytes,NULL);

      if ( retVal )
      {

        for(i=dwNumArea-1; (long)i>=0; i--) {
#ifdef UNICODE
            dwBytes = szDBCS[0];
#else
            dwBytes = 256*(BYTE)szDBCS[0]+(BYTE)szDBCS[1];
#endif
            if(dwBytes >= lpInterCode[i].StartInterCode && dwBytes <= lpInterCode[i].EndInterCode) {
                RetNo = lpInterCode[i].PreCount+dwBytes-lpInterCode[i].StartInterCode;
                break;
            }
        }
      }

      GlobalUnlock(hInterCode);
      GlobalFree(hInterCode);

      return (RetNo);
}

BOOL  UnRegisterWord(HIMCC HmemPri,LPCTSTR lpReading,LPCTSTR lpString) {
    int i;
    int succ = 0;

    lpEngPrivate = (PPRIVCONTEXT) ImmLockIMCC(HmemPri);              
    if(!lpEngPrivate){
        return FALSE;
    }

    for (i=0;i<lpEngPrivate->PrivateArea.GlobVac.EMB_Count;i++ ) {
        if((wcsncmp(EMB_Table[i].W_Code,lpReading,MAXCODE)==0) && (wcsncmp(EMB_Table[i].C_Char,lpString,MAXINPUTWORD)==0)) {
            DelSelCU(HmemPri,i);            
            succ = 1;
        }
        if(succ==1 && wcsncmp(EMB_Table[i].W_Code,lpReading,MAXCODE)!=0)
            break;
    }
    ImmUnlockIMCC(HmemPri);
    return(succ);
}


UINT  EnumRegisterWord(HIMCC HmemPri,LPCTSTR lpReading,LPCTSTR lpString,LPVOID lpData) {
    UINT count;
    int  i,pos,wordlen;
    TCHAR *lptep;

    lpEngPrivate = (PPRIVCONTEXT) ImmLockIMCC(HmemPri);              
    if(!lpEngPrivate){
        return (0);
    }

    lptep = (TCHAR *) lpData;
    if((lpReading==NULL) && (lpString==NULL)) {
        lpData = EMB_Table;
        count = lpEngPrivate->PrivateArea.GlobVac.EMB_Count;
    } else if(lpReading==NULL) {
        pos = 0; 
        count = 0;
        for(i=0; i<lpEngPrivate->PrivateArea.GlobVac.EMB_Count; i++) {
            if (wcsncmp(EMB_Table[i].C_Char,lpString,MAXINPUTWORD)==0) {
                wordlen = Inputcodelen(EMB_Table[i].W_Code);
                lstrcpyn(lptep+pos,EMB_Table[i].W_Code,wordlen+1);
                pos += wordlen;
                lptep[pos] = 0x20;
                pos ++;
                count ++;
            }
        }
    } else if(lpString==NULL) {
        if(EMBPositionSearch(lpReading)) {
            pos = 0;
            for(i=lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQStartPos; i<lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQEndPos; i++) {
                wordlen = DBCSCharlen(EMB_Table[i].C_Char);
                lstrcpyn(lptep+pos,EMB_Table[i].C_Char,wordlen+1);
                pos += wordlen;
                lptep[pos] = 0x20;
                pos ++;
            }
            count = lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQEndPos - lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQStartPos;
        } else {
            count = 0;
        }
    } else {
        if(EMBPositionSearch(lpReading)) {
            pos = 0;
            count = 0;
            for(i=lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQStartPos; i<lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQEndPos; i++) {
                if (wcsncmp(EMB_Table[i].C_Char,lpString,MAXINPUTWORD)==0) {
                    wordlen = DBCSCharlen(EMB_Table[i].C_Char);
                    lstrcpyn(lptep+pos,EMB_Table[i].C_Char,wordlen+1);
                    pos += wordlen;
                    lptep[pos] = 0x20;
                    pos ++;
                    count ++;
                }
            }
        } else {
            count = 0;
        }
    }
    ImmUnlockIMCC(HmemPri);
    return(count);
} 

BYTE EMBPositionSearch(LPCTSTR lpSrc) {
    int     i;
    int     srclen;
    
    srclen = lstrlen(lpSrc);

    for (i=0; i<lpEngPrivate->PrivateArea.GlobVac.EMB_Count; i++) {
        if ((Inputcodelen(EMB_Table[i].W_Code)==srclen) && (wcsncmp(EMB_Table[i].W_Code,lpSrc,srclen)==0))
            break;
    }
    if(i==lpEngPrivate->PrivateArea.GlobVac.EMB_Count)
           return (0);
    
    lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQStartPos = i;
    lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCStartPos = i;
    lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQCEndPos = i;    
        
    for (i; i<lpEngPrivate->PrivateArea.GlobVac.EMB_Count; i++) {
        if ((Inputcodelen(EMB_Table[i].W_Code)!=srclen) || (wcsncmp(EMB_Table[i].W_Code,lpSrc,srclen)!=0))
            break;
    }
    lpEngPrivate->PrivateArea.Comp_Proc.dwUDicQEndPos = i;
    return (1);
}

long GetLengthofBuf() {
    SIZE        size;
    int         ncount;
    BOOL        succ;
    TCHAR       tepbuf[3000];
    long        ret_len ;

    HDC         hDC;
    HGDIOBJ     hOldFont;
    LOGFONT     lfFont;

    hDC = GetDC(NULL);

    hOldFont = GetCurrentObject(hDC, OBJ_FONT);
    GetObject(hOldFont, sizeof(LOGFONT), &lfFont);

    ZeroMemory(&lfFont, sizeof(lfFont));
    lfFont.lfHeight = -MulDiv(12, GetDeviceCaps(hDC, LOGPIXELSY), 72);
    lfFont.lfCharSet = NATIVE_CHARSET;
    lstrcpy(lfFont.lfFaceName, TEXT("Simsun"));
    SelectObject(hDC, CreateFontIndirect(&lfFont));

    ncount = lpEngPrivate->PrivateArea.GlobVac.SBufPos;
    lstrcpyn(tepbuf,lpEngPrivate->PrivateArea.Comp_Context.szSelectBuffer,ncount+1);
    tepbuf[ncount] = TEXT('\0');
    succ = GetTextExtentPoint(hDC,tepbuf,ncount,(LPSIZE)&size);
    if(!succ){
        memset(&size, 0, sizeof(SIZE));
    }
    ret_len = size.cx;
    succ = GetTextExtentPoint(hDC,TEXT("9:"),2,(LPSIZE)&size);
    if(!succ){
        memset(&size, 0, sizeof(SIZE));
    }
    ret_len += (size.cx*lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt );

    DeleteObject(SelectObject(hDC, hOldFont));
    ReleaseDC(NULL, hDC);

    return(ret_len);
}

long GetLengthTepBuf(LPTSTR lpstring) {
    SIZE        size;
    int         ncount;
    BOOL         succ;

    HDC         hDC;
    HGDIOBJ     hOldFont;
    LOGFONT     lfFont;

    hDC = GetDC(NULL);

    hOldFont = GetCurrentObject(hDC, OBJ_FONT);
    GetObject(hOldFont, sizeof(LOGFONT), &lfFont);

    ZeroMemory(&lfFont, sizeof(lfFont));
    lfFont.lfHeight = -MulDiv(12, GetDeviceCaps(hDC, LOGPIXELSY), 72);
    lfFont.lfCharSet = NATIVE_CHARSET;
    lstrcpy(lfFont.lfFaceName, TEXT("Simsun"));
    SelectObject(hDC, CreateFontIndirect(&lfFont));

    ncount = lstrlen(lpstring);
    succ = GetTextExtentPoint(hDC,lpstring,ncount,(LPSIZE)&size);
    if(!succ){
        memset(&size, 0, sizeof(SIZE));
    }


    DeleteObject(SelectObject(hDC, hOldFont));
    ReleaseDC(NULL, hDC);

    if(lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt<1 )
        return (0);
    else 
        return(size.cx);
}


long GetLengthCCharBuf(LPTSTR lpstring) {
    TCHAR       CCharStr[41];
    SIZE        size;
    int         ncount;
    BOOL         succ;

    HDC         hDC;
    HGDIOBJ     hOldFont;
    LOGFONT     lfFont;

    hDC = GetDC(NULL);

    hOldFont = GetCurrentObject(hDC, OBJ_FONT);
    GetObject(hOldFont, sizeof(LOGFONT), &lfFont);

    ZeroMemory(&lfFont, sizeof(lfFont));
    lfFont.lfHeight = -MulDiv(12, GetDeviceCaps(hDC, LOGPIXELSY), 72);
    lfFont.lfCharSet = NATIVE_CHARSET;
    lstrcpy(lfFont.lfFaceName, TEXT("Simsun"));
    SelectObject(hDC, CreateFontIndirect(&lfFont));

    lstrcpyn(CCharStr, lpstring, MAXINPUTWORD+1);
    CCharStr[MAXINPUTWORD] = TEXT('\0');
    ncount = lstrlen(CCharStr);
    succ = GetTextExtentPoint(hDC,CCharStr,ncount,(LPSIZE)&size);
    if(!succ){
        memset(&size, 0, sizeof(SIZE));
    }

    DeleteObject(SelectObject(hDC, hOldFont));
    ReleaseDC(NULL, hDC);

    if(lpEngPrivate->PrivateArea.Comp_Context.Candi_Cnt<1 )
        return (0);
    else 
        return(size.cx);
}


int Inputcodelen(LPCTSTR string) {
    TCHAR str[13];

    lstrcpyn(str, string, MAXCODE+1);
    str[MAXCODE] = TEXT('\0');
    return(lstrlen(str));
}

int DBCSCharlen(LPCTSTR string) {
    TCHAR str[41];

    lstrcpyn(str, string, MAXINPUTWORD+1);
    str[MAXINPUTWORD] = TEXT('\0');
    return(lstrlen(str));
}

LPTSTR _tcschr(LPTSTR string, TCHAR c)
{
#ifdef UNICODE
    return (wcschr(string, c));
#else
    return (strchr(string, c));
#endif
}

//Backward search specific charactor. 
LPTSTR _rtcschr(LPTSTR string, TCHAR c)
{
    int i,ilen = lstrlen(string);
    if (ilen)
        for (i=ilen;i>=0;i--)
        {
            if (string[i] == c)
                return (string+i);
        }
    return NULL;
}

int IsGBK(LPTSTR lpStr)
{
    int  iRet = FALSE;
    char szGBK[80];

#ifdef UNICODE
    WideCharToMultiByte(NATIVE_ANSI_CP, WC_COMPOSITECHECK, lpStr, -1, szGBK,
        sizeof(szGBK), NULL, NULL);
#else
    lstrcpy(szGBK, lpStr);
#endif

    if((unsigned char)szGBK[0]<0xa1 || (unsigned char)szGBK[1] < 0xa1) //out of GB range
        iRet = TRUE;
    return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntime\getdes.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    GETDES.C
    
++*/
#include <windows.h>
#include <windowsx.h>
#include <winerror.h>
#include <immdev.h>
#include <imedefs.h>
//#include "conv.h"

#ifdef IDEBUG

void  OutputDbgWord( DWORD  dwValue) {

  TCHAR  Outdbg[9];
  int    itmp, i;


  for (i=0; i<9; i++)
     Outdbg[i] = 0x0020;

  i=9;
  itmp = (int)dwValue;
  Outdbg[i--] = 0x0000;

  while (itmp) {

      if ( (itmp % 16) < 10 )
           Outdbg[i] = itmp % 16 + L'0';
      else
           Outdbg[i] = itmp % 16 + L'A' - 10;

      i --;
      itmp = itmp / 16;
  }

  OutputDebugString(Outdbg);
}

#endif

/**********************************************************************/
/* ReadDescript()                                                 */
/* Description:                                                       */
/*      read description from .MB file                                */
/**********************************************************************/
BOOL ReadDescript(
    LPCTSTR   MBFileName, 
    LPMBDESC lpDescript)
{
  HANDLE hMBFile;
  DWORD dwBytes;
  DWORD dwOffset;
  MAININDEX lpMainIndex[NUMTABLES];
  PSECURITY_ATTRIBUTES psa;
  BOOL   retVal;

  psa = CreateSecurityAttributes();
  hMBFile = CreateFile(MBFileName,GENERIC_READ,FILE_SHARE_READ,psa,OPEN_EXISTING,0,NULL);
  FreeSecurityAttributes(psa);

  if(hMBFile==INVALID_HANDLE_VALUE)
    return(0);
  SetFilePointer(hMBFile,ID_LENGTH,0,FILE_BEGIN);
  retVal = ReadFile(hMBFile,lpMainIndex,sizeof(MAININDEX)*NUMTABLES,&dwBytes,NULL);

  if ( retVal == FALSE )
  {
      CloseHandle(hMBFile);
      return retVal;
  }

  dwOffset = lpMainIndex[TAG_DESCRIPTION-1].dwOffset;
  SetFilePointer(hMBFile,dwOffset,0,FILE_BEGIN);
  retVal = ReadFile(hMBFile,lpDescript,sizeof(MBDESC),&dwBytes,NULL);

  if ( retVal == FALSE )
  {
      CloseHandle(hMBFile);
      return retVal;
  }

  CloseHandle(hMBFile);

#ifdef IDEBUG
  {
  
  DWORD  dwtmp;
 
  OutputDebugString(L"Under ReadDescript\n");
 
  OutputDebugString(L"dwBytes=");
  OutputDbgWord(dwBytes);
  OutputDebugString(L"Sizeof(MBDESC)=");
  dwtmp = (DWORD)sizeof(MBDESC);
  OutputDbgWord(dwtmp);
  OutputDebugString(L"\n");

  OutputDebugString(L"szName=");
  OutputDebugString(lpDescript->szName);
  OutputDebugString(L"\n");

  OutputDebugString(L"wMaxCodes=");
  dwtmp = (DWORD)(lpDescript->wMaxCodes);
  OutputDbgWord( dwtmp );
  OutputDebugString(L"\n");

  OutputDebugString(L"wNumCodes=");
  dwtmp = (DWORD)(lpDescript->wNumCodes);
  OutputDbgWord(dwtmp);
  OutputDebugString(L"\n");

  OutputDebugString(L"byMaxElement=");
  dwtmp = (DWORD)(lpDescript->byMaxElement) & 0x0000000f;
  OutputDbgWord(dwtmp);
  OutputDebugString(L"\n");

  OutputDebugString(L"cWildChar=");
  dwtmp = (DWORD)(lpDescript->cWildChar);
  OutputDbgWord( dwtmp );
  OutputDebugString(L"\n");
 
  OutputDebugString(L"wNumRulers=");
  dwtmp = (DWORD)(lpDescript->wNumRulers); 
  OutputDbgWord( dwtmp );
  OutputDebugString(L"\n"); 

  }

#endif

  if(dwBytes < sizeof(MBDESC) )
       return FALSE;
  else
       return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntime\imedefs.h ===
/*************************************************
 *  imedefs.h                                    *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

// for engine
#include "eng.h"
#include "immsec.h"
#define NATIVE_CHARSET          GB2312_CHARSET
#define NATIVE_LANGUAGE         0x0804
#define NATIVE_CP               936

#define NATIVE_ANSI_CP          936

#ifdef EUDC
#define EUDC_NATIVE_CP            936
#endif //EUDC

#if defined(CROSSREF)
// hack flag, I borrow one bit from fdwErrMsg for reverse conversion
#define NO_REV_LENGTH           0x80000000
#endif

//Add string format position and charactor defination
#define STR_FORMAT_POS          0x14
#define STR_FORMAT_CHAR         0x20

// resource ID
#define IDI_IME                 0x0100

#define IDS_STATUSERR           0x0200
#define IDS_CHICHAR             0x0201

#define IDS_EUDC                0x0202
#define IDS_NONE                0x0204

#define IDS_USRDIC_FILTER       0x0210

#define IDS_FILE_OPEN_ERR       0x0220
#define IDS_MEM_LESS_ERR        0x0221
#define IDS_SETFILE             0x0300
#define IDS_IMENAME             0x0320
#define IDS_IMEUICLASS          0x0321
#define IDS_IMECOMPCLASS        0x0322
#define IDS_IMECANDCLASS        0x0323
#define IDS_IMESTATUSCLASS      0x0324
#define IDS_IMECMENUCLASS       0x0325
#define IDS_IMESOFTKEYMENUCLASS 0x0326
#define IDS_VER_INFO            0x0350
#define IDS_ORG_NAME            0x0351
#define IDS_IMEMBFILENAME       0x0352
#define IDS_IMEHKMBFILENAME     0x0353
#ifdef EUDC
#define IDS_EUDC_FILE_CLS       0x0500
#define IDS_NOTOPEN_TITLE       0x0501
#define IDS_NOTOPEN_MSG         0x0502
#define IDS_FILESIZE_TITLE      0x0503
#define IDS_FILESIZE_MSG        0x0504
#define IDS_HEADERSIZE_TITLE    0x0505
#define IDS_HEADERSIZE_MSG      0x0506
#define IDS_INFOSIZE_TITLE      0x0507
#define IDS_INFOSIZE_MSG        0x0508
#define IDS_CODEPAGE_TITLE      0x0509
#define IDS_CODEPAGE_MSG        0x050a
#define IDS_CWINSIGN_TITLE      0x050b
#define IDS_CWINSIGN_MSG        0x050c
#define IDS_UNMATCHED_TITLE     0x050d
#define IDS_UNMATCHED_MSG       0x050e
#endif //EUDC

#define    IDS_ERROR_OPENFILE   0x0601
#define    IDS_WARN_OPENREG     0x0602
#define    IDS_WARN_OVEREMB     0x0603
#define    IDS_WARN_DUPPRASE    0x0604
#define    IDS_WARN_MEMPRASE    0x0605
#define    IDS_WARN_INVALIDCODE 0x0606
#define    IDS_WARN_NEEDPHRASE  0x0607

#define IDS_CZ_CONFIRM          0x0701
#define IDS_CZ_CONFIRM_TITLE    0x0702

#define IDC_STATIC              -1

#define IDM_SET                 0x0400
#define IDM_CRTWORD             0x0401
#define IDM_HLP                 0x0402
#define IDM_OPTGUD              0x0403
#define IDM_IMEGUD              0x0405
#define IDM_VER                 0x0406

#define IDM_IME                 0x0450

#define IDM_SKL1                0x0500
#define IDM_SKL2                0x0501
#define IDM_SKL3                0x0502
#define IDM_SKL4                0x0503
#define IDM_SKL5                0x0504
#define IDM_SKL6                0x0505
#define IDM_SKL7                0x0506
#define IDM_SKL8                0x0507
#define IDM_SKL9                0x0508
#define IDM_SKL10               0x0509
#define IDM_SKL11               0x050a
#define IDM_SKL12               0x050b
#define IDM_SKL13               0x050c

#define DlgPROP                 101
#define DlgUIMODE               102
#define IDC_UIMODE1             1001
#define IDC_UIMODE2             1002
#define IDC_USER1               1003

// setting offset in .SET file
#define OFFSET_MODE_CONFIG      0
#define OFFSET_READLAYOUT       4

// state of composition
#define CST_INIT                0
#define CST_INPUT               1
#define CST_CHOOSE              2
#define CST_SYMBOL              3
#define CST_SOFTKB              4           // not in iImeState
#define CST_TOGGLE_PHRASEWORD   5           // not in iImeState
#define CST_ALPHABET            6           // not in iImeState
#define CST_ALPHANUMERIC        7           // not in iImeState
#define CST_INVALID             8           // not in iImeState
#define CST_INVALID_INPUT       9           // not in iImeState
#define CST_ONLINE_CZ           10
#define CST_CAPITAL             11
// state engin
#define ENGINE_COMP             0
#define ENGINE_ASCII            1
#define ENGINE_RESAULT          2
#define ENGINE_CHCAND           3
#define ENGINE_BKSPC            4
#define ENGINE_MULTISEL         5
#define ENGINE_ESC              6

#define CANDPERPAGE             10

//CHP
#if defined(COMBO_IME)
#define    IC_NUMBER    11
#else
#define    IC_NUMBER    10
#endif //COMBO_IME

// set ime character
#define SIC_INIT                0
#define SIC_SAVE2               1
#define SIC_READY               2
#define SIC_MODIFY              3
#define SIC_SAVE1                4

#define BOX_UI                  0
#define LIN_UI                  1

// border for UI
#define UI_MARGIN               4
#define COMP_TEXT_Y             17
//
#define UI_CANDINF              20
#define UI_CANDBTW              13
#define UI_CANDBTH              13
#define UI_CANDICON             16
//#define UI_CANDSTR              300
#define STATUS_DIM_X            20
#define STATUS_DIM_Y            20
#define STATUS_NAME_MARGIN      8
// if UI_MOVE_OFFSET == WINDOW_NOTDRAG, not in drag operation
#define WINDOW_NOT_DRAG         0xFFFFFFFF

// window extra for composition window
#define UI_MOVE_OFFSET          0
#define UI_MOVE_XY              4

// the start number of candidate list
#define CAND_START              1
#define uCandHome               0
#define uCandUp                 1
#define uCandDown               2
#define uCandEnd                3

// the flag for an opened or start UI
#define IMN_PRIVATE_UPDATE_STATUS             0x0001
#define IMN_PRIVATE_COMPOSITION_SIZE          0x0002
#define IMN_PRIVATE_UPDATE_QUICK_KEY          0x0004
#define IMN_PRIVATE_UPDATE_SOFTKBD            0x0005
#define IMN_PRIVATE_DESTROYCANDWIN            0x0006
#define IMN_PRIVATE_CMENUDESTROYED            0x0007
#define IMN_PRIVATE_SOFTKEYMENUDESTROYED      0x0008

#define MSG_ALREADY_OPEN                0x000001
#define MSG_ALREADY_OPEN2               0x000002
#define MSG_OPEN_CANDIDATE              0x000010
#define MSG_OPEN_CANDIDATE2             0x000020
#define MSG_CLOSE_CANDIDATE             0x000100
#define MSG_CLOSE_CANDIDATE2            0x000200
#define MSG_CHANGE_CANDIDATE            0x001000
#define MSG_CHANGE_CANDIDATE2           0x002000
#define MSG_ALREADY_START               0x010000
#define MSG_START_COMPOSITION           0x020000
#define MSG_END_COMPOSITION             0x040000
#define MSG_COMPOSITION                 0x080000
#define MSG_IMN_COMPOSITIONPOS          0x100000
#define MSG_IMN_UPDATE_SOFTKBD          0x200000
#define MSG_IMN_UPDATE_STATUS           0x000400
#define MSG_GUIDELINE                   0x400000
#define MSG_IN_IMETOASCIIEX             0x800000
#define MSG_BACKSPACE                   0x000800
#define MSG_IMN_DESTROYCAND             0x004000
// this constant is depend on TranslateImeMessage
#define GEN_MSG_MAX             6

// the flag for set context
#define SC_SHOW_UI              0x0001
#define SC_HIDE_UI              0x0002
#define SC_ALREADY_SHOW_STATUS  0x0004
#define SC_WANT_SHOW_STATUS     0x0008
#define SC_HIDE_STATUS          0x0010

// the new flag for set context
#define ISC_SHOW_SOFTKBD        0x02000000
#define ISC_OPEN_STATUS_WINDOW  0x04000000
#define ISC_OFF_CARET_UI        0x08000000
#define ISC_SHOW_UI_ALL         (ISC_SHOWUIALL|ISC_SHOW_SOFTKBD|ISC_OPEN_STATUS_WINDOW)
#define ISC_SETCONTEXT_UI       (ISC_SHOWUIALL|ISC_SHOW_SOFTKBD)
#define ISC_HIDE_COMP_WINDOW            0x00400000
#define ISC_HIDE_CAND_WINDOW            0x00800000
#define ISC_HIDE_SOFTKBD                0x01000000
// the flag for composition string show status
#define IME_STR_SHOWED          0x0001
#define IME_STR_ERROR           0x0002

// the mode configuration for an IME
#define MODE_CONFIG_QUICK_KEY           0x0001
#define MODE_CONFIG_WORD_PREDICT        0x0002
#define MODE_CONFIG_PREDICT             0x0004

// the virtual key value
#define VK_OEM_SEMICLN                  0xba    //  ;    :
#define VK_OEM_EQUAL                    0xbb    //  =    +
#define VK_OEM_SLASH                    0xbf    //  /    ?
#define VK_OEM_LBRACKET                 0xdb    //  [    {
#define VK_OEM_BSLASH                   0xdc    //  \    |
#define VK_OEM_RBRACKET                 0xdd    //  ]    }
#define VK_OEM_QUOTE                    0xde    //  '    "

#define MAXMBNUMS               40

// for ime property info
#define MAXNUMCODES             48

#define LINE_LEN                80

#define        CLASS_LEN    24
#define        NAMESIZE    128
#define        MAXUSEDCODES 48
#define        MAXSOFTKEYS  48

#define NumsSK                  13

// mb file for create word
#define ID_LENGTH 28
#define NUMTABLES 7
#define TAG_DESCRIPTION           0x00000001
#define TAG_RULER                 0x00000002
#define TAG_CRTWORDCODE           0x00000004
#define    TAG_INTERCODE             0x00000003
#define TAG_RECONVINDEX              0x00000005
#define TAG_BASEDICINDEX             0x00000006
#define TAG_BASEDIC                  0x00000007
// window extra for context menu owner
#define CMENU_HUIWND            0
#define CMENU_MENU              (CMENU_HUIWND+sizeof(LONG_PTR))
#define WND_EXTRA_SIZE          (CMENU_MENU+sizeof(LONG_PTR))
#define SOFTKEYMENU_HUIWND      0
#define SOFTKEYMENU_MENU        (SOFTKEYMENU_HUIWND+sizeof(LONG_PTR))

#define WM_USER_DESTROY         (WM_USER + 0x0400)
// the flags for GetNearCaretPosition
#define NEAR_CARET_FIRST_TIME   0x0001
#define NEAR_CARET_CANDIDATE    0x0002
#define FFLG_MULTIELEMENT         0x2
#define FFLG_RULE                 0x1

#define ADD_FALSE               0x0000
#define ADD_TRUE                0x0001
#define ADD_REP                 0x0002
#define ADD_FULL                0x0003

#ifdef EUDC
#define SIGN_CWIN               0x4E495743
#define SIGN__TBL               0x4C42545F
#define EUDC_MAX_READING        6    //TEMPORARY SOLUTION
#endif

typedef DWORD UNALIGNED FAR *LPUNADWORD;
typedef WORD  UNALIGNED FAR *LPUNAWORD;
typedef TCHAR UNALIGNED FAR *LPUNATCHAR;

typedef struct tagImeL {        // local structure, per IME structure
// SK data
    DWORD       dwSKState[NumsSK];//95.10.24
    DWORD       dwSKWant;            //95.10.24
    HMENU       hSKMenu;        // SoftKeyboard Menu
    HMENU       hPropMenu;      // Property Menu
    HMENU       hObjImeMenu;    // Object IME Menu
    HINSTANCE   hInst;          // IME DLL instance handle
    int         xCompWi;        // width
    int         yCompHi;        // height
    POINT       ptDefComp;      // default composition window position
    int         cxCompBorder;   // border width of composition window
    int         cyCompBorder;   // border height of composition window
    RECT        rcCompText;     // text position relative to composition window
    WORD        nMaxKey;        // max key of compsiton str
    BOOL        fWinLogon;      // if the current client is running in WinLogon Mode.
} IMEL;

typedef IMEL      *PIMEL;
typedef IMEL NEAR *NPIMEL;
typedef IMEL FAR  *LPIMEL;

#define NFULLABC        95
typedef struct _tagFullABC {   // match with the IMEG
    WORD wFullABC[NFULLABC];
} FULLABC;

typedef FULLABC      *PFULLABC;
typedef FULLABC NEAR *NPFULLABC;
typedef FULLABC FAR  *LPFULLABC;

// global sturcture for ime init data
typedef struct _tagImeG {       // global structure, can be share by all IMEs,
                                // the seperation (IMEL and IMEG) is only
                                // useful in UNI-IME, other IME can use one
// the system charset is not NATIVE_CHARSET
    BOOL        fDiffSysCharSet;
    RECT        rcWorkArea;     // the work area of applications
// Chinese char width & height
    int         xChiCharWi;
    int         yChiCharHi;
// candidate list of composition
    int         xCandWi;        // width of candidate list
    int         yCandHi;        // high of candidate list
    int         cxCandBorder;   // border width of candidate list
    int         cyCandBorder;   // border height of candidate list
    RECT        rcCandText;     // text position relative to candidate window
    RECT        rcCandBTD;
    RECT        rcCandBTU;
    RECT        rcCandBTE;
    RECT        rcCandBTH;
    RECT        rcCandInf;
    RECT        rcCandIcon;
// status window
    int         xStatusWi;      // width of status window
    int         yStatusHi;      // high of status window
    RECT        rcStatusText;   // text position relative to status window
    RECT        rcImeIcon;      // ImeIcon position relative to status window
    RECT        rcImeName;       // ImeName position relative to status window
    RECT        rcShapeText;    // shape text relative to status window
    RECT        rcSymbol;       // symbol relative to status window
    RECT        rcSKText;       // SK text relative to status window
// full shape space (reversed internal code)
    WORD        wFullSpace;
// full shape chars (internal code)
    WORD        wFullABC[NFULLABC];
// error string
    TCHAR       szStatusErr[8];
    int         cbStatusErr;
// candidate string start from 0 or 1
    int         iCandStart;
// setting of UI
    int         iPara;
    int         iPerp;
    int         iParaTol;
    int         iPerpTol;
    TCHAR       szIMESystemPath[MAX_PATH];  // keep the system path for MB file
    TCHAR       szIMEUserPath[MAX_PATH];    // keep the path for EMB file
} IMEG;

typedef IMEG      *PIMEG;
typedef IMEG NEAR *NPIMEG;
typedef IMEG FAR  *LPIMEG;


//#include <privcon.h>
#include "privcon.h"

typedef struct _tagUIPRIV {     // IME private UI data
    HWND    hCompWnd;           // composition window
    int     nShowCompCmd;
    HWND    hCandWnd;           // candidate window for composition
    int     nShowCandCmd;
    HWND    hSoftKbdWnd;        // soft keyboard window
    int     nShowSoftKbdCmd;
    HWND    hStatusWnd;         // status window
    int     nShowStatusCmd;
    DWORD   fdwSetContext;      // the actions to take at set context time
    HIMC    hIMC;               // the recent selected hIMC
    HWND    hCMenuWnd;          // a window owner for context menu
    HWND    hSoftkeyMenuWnd;        // a window owner for softkeyboard menu
} UIPRIV;

typedef UIPRIV      *PUIPRIV;
typedef UIPRIV NEAR *NPUIPRIV;
typedef UIPRIV FAR  *LPUIPRIV;

typedef struct tagNEARCARET {   // for near caret offset calculatation
    int iLogFontFacX;
    int iLogFontFacY;
    int iParaFacX;
    int iPerpFacX;
    int iParaFacY;
    int iPerpFacY;
} NEARCARET;

typedef NEARCARET      *PNEARCARET;
typedef NEARCARET NEAR *NPNEARCARET;
typedef NEARCARET FAR  *LPNEARCARET;

// mb file for create word
typedef struct tagMAININDEX {
     DWORD dwTag;
     DWORD dwOffset;
     DWORD dwLength;
     DWORD dwCheckSum;   //Check if dwCheckSum=dwTag+dwOffset+dwLength
}  MAININDEX, FAR *LPMAININDEX;

typedef struct tagDESCRIPTION {
     TCHAR szName[MAXSTRLEN];
     WORD  wMaxCodes;
        WORD  wNumCodes;
        TCHAR szUsedCode[MAXNUMCODES];
     BYTE  byMaxElement;
        TCHAR  cWildChar;
        WORD  wNumRulers;
} DESCRIPTION,FAR * LPDESCRIPTION;

typedef struct tagCREATEWORDRULER {
     BYTE byLogicOpra;
     BYTE byLength;
     WORD wNumCodeUnits;
     struct CODEUNIT {
          DWORD dwDirectMode;
          WORD  wDBCSPosition;
          WORD  wCodePosition;
     } CodeUnit[MAXCODE];
} RULER,FAR *LPRULER;

extern HINSTANCE hInst;
extern IMEG      sImeG;
extern IMEL      sImeL;
extern LPIMEL    lpImeL;
extern MBINDEX   MBIndex;
extern HMapStruc HMapTab[];
extern HWND      hCrtDlg;
extern UINT      uStartComp;
extern UINT      uOpenCand;
extern UINT      uCaps;
extern DWORD     SaTC_Trace;
extern UINT      UI_CANDSTR;
extern TCHAR     szImeMBFileName[];
extern TCHAR     szUIClassName[];
extern TCHAR     szCompClassName[];
extern TCHAR     szCandClassName[];
extern TCHAR     szStatusClassName[];
extern TCHAR     szCMenuClassName[];
extern TCHAR     szSoftkeyMenuClassName[];
extern TCHAR     szOrgName[];
extern TCHAR     szVerInfo[];
extern TCHAR     szAuthorName[];
extern TCHAR     szHandCursor[];
extern TCHAR     szChinese[];
extern TCHAR     szCZ[];
extern TCHAR     szCandInf1[];
extern TCHAR     szCandInf2[];
extern TCHAR     szImeName[];
extern TCHAR     szSymbol[];
extern TCHAR     szNoSymbol[];
extern TCHAR     szEnglish[];
extern TCHAR     szCode[];
extern TCHAR     szEudc[];
extern TCHAR     szFullShape[];
extern TCHAR     szHalfShape[];
extern TCHAR     szNone[];
extern TCHAR     szSoftKBD[];
extern TCHAR     szNoSoftKBD[];
extern TCHAR     szDigit[];
extern BYTE      bUpper[];
extern WORD      fMask[];
extern TCHAR     szRegIMESetting[];
extern TCHAR     szPerp[];
extern TCHAR     szPara[];
extern TCHAR     szPerpTol[];
extern TCHAR     szParaTol[];
extern const NEARCARET ncUIEsc[], ncAltUIEsc[];
extern const POINT ptInputEsc[], ptAltInputEsc[];
extern BYTE      VirtKey48Map[];
extern BYTE      VirtKey48Map[];
extern TCHAR     CWCodeStr[];
extern TCHAR     CWDBCSStr[];
extern TCHAR         szTrace[];
extern TCHAR         szWarnTitle[];
extern TCHAR         szErrorTitle[];
#ifdef KEYSTICKER
#ifdef CHAJEI
#define INDEXNUM    26
#endif
#ifdef PHON
#define INDEXNUM    48
#endif
extern     TCHAR KeyIndexTbl[];
extern    LPTSTR MapKeyStickerTbl[];
#endif //KEYSTICKER

#if defined(CROSSREF)
extern TCHAR szRegRevKL[];
extern TCHAR szRegRevMaxKey[];
#endif

#if defined(EUDC)
extern TCHAR szRegEudcDictName[];
extern TCHAR szRegEudcMapFileName[];
#endif

int WINAPI LibMain(HANDLE, WORD, WORD, LPTSTR);                  // init.c
LRESULT CALLBACK UIWndProc(HWND, UINT, WPARAM, LPARAM);         // ui.c
LRESULT PASCAL UIPaint(HWND);                                    //UI.C

// for engine
WORD PASCAL GBEngine(LPPRIVCONTEXT);
WORD PASCAL AsciiToGB(LPPRIVCONTEXT);
WORD PASCAL AsciiToArea(LPPRIVCONTEXT);
WORD PASCAL CharToHex(TCHAR);

void PASCAL AddCodeIntoCand(LPCANDIDATELIST, WORD);             // compose.c
void PASCAL CompWord(WORD, LPINPUTCONTEXT, LPCOMPOSITIONSTRING, LPPRIVCONTEXT,
     LPGUIDELINE);                                              // compose.c
UINT PASCAL Finalize(LPINPUTCONTEXT, LPCOMPOSITIONSTRING,
     LPPRIVCONTEXT, WORD);                                      // compose.c
void PASCAL CompEscapeKey(LPINPUTCONTEXT, LPCOMPOSITIONSTRING,
     LPGUIDELINE, LPPRIVCONTEXT);                               // compose.c

void PASCAL SelectOneCand(LPINPUTCONTEXT, LPCOMPOSITIONSTRING,
     LPPRIVCONTEXT, LPCANDIDATELIST);                           // chcand.c
void PASCAL CandEscapeKey(LPINPUTCONTEXT, LPPRIVCONTEXT);       // chcand.c
void PASCAL ChooseCand(WORD, LPINPUTCONTEXT, LPCANDIDATEINFO,
     LPPRIVCONTEXT);                                            // chcand.c

void PASCAL SetPrivateFileSetting(LPBYTE, int, DWORD, LPCTSTR); // ddis.c

void PASCAL InitCompStr(LPCOMPOSITIONSTRING);                   // ddis.c
BOOL PASCAL ClearCand(LPINPUTCONTEXT);                          // ddis.c
LONG OpenReg_PathSetup(HKEY *);
LONG OpenReg_User(HKEY ,LPCTSTR ,PHKEY);
VOID InfoMessage(HANDLE ,WORD );                                //ddis.c
VOID FatalMessage(HANDLE ,WORD);                                //ddis.c

#if defined(CROSSREF)
void PASCAL ReverseConversionList(HWND);                        // ddis.c
//CHP
int CrossReverseConv(LPINPUTCONTEXT, LPCOMPOSITIONSTRING, LPPRIVCONTEXT, LPCANDIDATELIST);
#endif

#ifdef EUDC
BOOL EUDCDicName( HWND );
#endif //EUDC

//UINT PASCAL TranslateImeMessage(LPTRANSMSGLIST, LPPRIVCONTEXT);        // toascii.c
UINT PASCAL TranslateImeMessage(LPTRANSMSGLIST, LPINPUTCONTEXT, LPPRIVCONTEXT);        // toascii.c

void PASCAL GenerateMessage(HIMC, LPINPUTCONTEXT,
     LPPRIVCONTEXT);                                            // notify.c

DWORD PASCAL ReadingToPattern(LPCTSTR, BOOL);                   // regword.c
void  PASCAL ReadingToSequence(LPCTSTR, LPBYTE, BOOL);          // regword.c

void PASCAL DrawDragBorder(HWND, LONG, LONG);                   // uisubs.c
void PASCAL DrawFrameBorder(HDC, HWND);                         // uisubs.c

void PASCAL ContextMenu(HWND, int, int);                        // uisubs.c
void PASCAL SoftkeyMenu(HWND, int, int);                        // uisubs.c
LRESULT CALLBACK ContextMenuWndProc(HWND, UINT, WPARAM,LPARAM); // uisubs.c
LRESULT CALLBACK SoftkeyMenuWndProc(HWND, UINT, WPARAM,LPARAM); // uisubs.c

#if 1 // MultiMonitor support
RECT PASCAL ImeMonitorWorkAreaFromWindow(HWND);                 // uisubs.c
RECT PASCAL ImeMonitorWorkAreaFromPoint(POINT);                 // uisubs.c
RECT PASCAL ImeMonitorWorkAreaFromRect(LPRECT);                 // uisubs.c
#endif


HWND    PASCAL GetCompWnd(HWND);                                // compui.c
void    PASCAL SetCompPosition(HWND, HIMC, LPINPUTCONTEXT);     // compui.c
void    PASCAL SetCompWindow(HWND);                             // compui.c
void    PASCAL MoveDefaultCompPosition(HWND);                   // compui.c
void    PASCAL ShowComp(HWND, int);                             // compui.c
void    PASCAL StartComp(HWND);                                 // compui.c
void    PASCAL EndComp(HWND);                                   // compui.c
void    PASCAL UpdateCompWindow(HWND);                          // compui.c
LRESULT CALLBACK CompWndProc(HWND, UINT, WPARAM, LPARAM);       // compui.c
void    PASCAL CompCancel(HIMC, LPINPUTCONTEXT);
void PASCAL PaintCompWindow(HWND, HWND, HDC);
#ifdef KEYSTICKER
int     IndexKeySticker(TCHAR);
void     MapSticker(LPCTSTR, LPTSTR, int);
#endif //KEYSTICKER

HWND    PASCAL GetCandWnd(HWND);                                // candui.c
void    PASCAL CalcCandPos(HIMC, HWND, LPPOINT);                // candui.c
LRESULT PASCAL SetCandPosition(HWND);          // candui.c
void    PASCAL ShowCand(HWND, int);                             // candui.c
void    PASCAL OpenCand(HWND);                                  // candui.c
void    PASCAL CloseCand(HWND);                                 // candui.c
void    PASCAL PaintCandWindow(HWND, HDC);                      // candui.c
void    AdjustCandPos(HIMC, LPPOINT);
void    PASCAL AdjustStatusBoundary(LPPOINTS, HWND);

LRESULT CALLBACK CandWndProc(HWND, UINT, WPARAM, LPARAM);       // candui.c
void    PASCAL UpdateSoftKbd(HWND);

HWND    PASCAL GetStatusWnd(HWND);                              // statusui.c
LRESULT PASCAL SetStatusWindowPos(HWND);                        // statusui.c
void    PASCAL ShowStatus(HWND, int);                           // statusui.c
void    PASCAL OpenStatus(HWND);                                // statusui.c
LRESULT CALLBACK StatusWndProc(HWND, UINT, WPARAM, LPARAM);     // statusui.c
void DrawConvexRect(HDC, int, int, int, int);
void DrawConvexRectP(HDC, int, int, int, int);
void DrawConcaveRect(HDC, int, int, int, int);
BOOL IsUsedCode(WORD, LPPRIVCONTEXT);
BOOL UpdateStatusWindow(HWND);
void PASCAL EngChCand(LPCOMPOSITIONSTRING, LPCANDIDATELIST, LPPRIVCONTEXT, LPINPUTCONTEXT, WORD);
void PASCAL CandPageDownUP(HWND, UINT);
void PASCAL GenerateImeMessage(HIMC, LPINPUTCONTEXT, DWORD);
UINT PASCAL TranslateSymbolChar(LPTRANSMSGLIST, WORD, BOOL);
UINT PASCAL TranslateFullChar(LPTRANSMSGLIST, WORD);
void PASCAL InitStatusUIData(int, int, int);
void PASCAL InitCandUIData(int, int, int);

// for engine
UINT        WINAPI MB_SUB(HIMCC, TCHAR, BYTE, UINT);
int         WINAPI StartEngine(HIMCC);
int         WINAPI EndEngine(HIMCC);
void         ResetCont(HIMCC);
BOOL        ReadDescript(LPCTSTR, LPMBDESC);
UINT        Conversion(HIMCC, LPCTSTR, UINT);
UINT PASCAL ForwordConversion(HIMC, LPCTSTR, LPCANDIDATELIST, UINT);
int         AddZCItem(HIMCC, LPTSTR, LPTSTR);
BOOL        GetUDCItem(HIMCC, UINT, LPTSTR, LPTSTR);

// dialog procedure
BOOL FAR PASCAL ImeVerDlgProc(HWND, UINT, DWORD, LONG);
BOOL FAR PASCAL CrtWordDlgProc(HWND, UINT, DWORD, LONG);
BOOL FAR PASCAL SetImeDlgProc(HWND, UINT, DWORD, LONG);
void SetImeCharac(HWND, int, int, DWORD);
//void InitImeCharac(LPPRIVCONTEXT);
void InitImeCharac(DWORD);

// create word
DWORD InterCodeToNo(TCHAR szDBCS[3]);
void  ConvCreateWord(HWND ,LPCTSTR ,LPTSTR ,LPTSTR);
void  MyStrFormat(LPTSTR dest, LPTSTR s1, LPTSTR s2);
BOOL  ConvGetMainIndex(HANDLE , HANDLE , LPMAININDEX );
BOOL  ConvReadDescript(HANDLE ,LPDESCRIPTION ,LPMAININDEX );
BOOL  ConvReadRuler(HANDLE , int,LPRULER ,LPMAININDEX );

#ifdef UNICODE
extern TCHAR SKLayout[NumsSK][MAXSOFTKEYS];
extern TCHAR SKLayoutS[NumsSK][MAXSOFTKEYS];
#else
extern BYTE SKLayout[NumsSK][MAXSOFTKEYS*2];
extern BYTE SKLayoutS[NumsSK][MAXSOFTKEYS*2];
#endif  //UNICODE

//CHP
#ifdef FUSSYMODE
BOOL IsFussyChar(LPCTSTR, LPCTSTR);
#endif //FUSSYMODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntime\data.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    DATA.C
    
++*/

#include <windows.h>
#include <immdev.h>
#include "imedefs.h"

#pragma data_seg(".ShareDate")
IMEG      sImeG = {0};
MBINDEX   MBIndex = {0};

#ifdef UNICODE
TCHAR SKLayout[NumsSK][MAXSOFTKEYS] = {
#ifdef KEYSTICKER
#ifdef CHAJEI
        0x3000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x65E5, 0x6708, 0x91D1, 0x6728, 0x6C34,
        0x706B, 0x571F, 0x7AF9, 0x6208, 0x5341, 0x5927, 0x4E2D, 0x4E00,
        0x5F13, 0x4EBA, 0x5FC3, 0x624B, 0x53E3, 0x5C38, 0x5EFF, 0x5C71,
        0x5973, 0x7530, 0x96E3, 0x535C, 0xFF3A, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 
#else //if PHON
        0x3000, 0x3122, 0x3105, 0x3109, 0x02C7, 0x02CB, 0x3113, 0x02CA,
        0x02D9, 0x311A, 0x311E, 0x3107, 0x3116, 0x310F, 0x310E, 0x310D,
        0x3111, 0x3115, 0x3118, 0x311B, 0x3128, 0x311C, 0x3120, 0x3129,
        0x3119, 0x311F, 0x3123, 0x3106, 0x3110, 0x310B, 0x3114, 0x3127,
        0x3112, 0x310A, 0x310C, 0x3117, 0x3108, 0x3124, 0x0020, 0x311D,
        0x3126, 0x3121, 0x3125, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 
#endif //CHAJEI
#else //KEYSTICKER
        0x3000, 0xFF10, 0xFF11, 0xFF12, 0xFF13, 0xFF14, 0xFF15, 0xFF16,
        0xFF17, 0xFF18, 0xFF19, 0xFF41, 0xFF42, 0xFF43, 0xFF44, 0xFF45,
        0xFF46, 0xFF47, 0xFF48, 0xFF49, 0xFF4A, 0xFF4B, 0xFF4C, 0xFF4D,
        0xFF4E, 0xFF4F, 0xFF50, 0xFF51, 0xFF52, 0xFF53, 0xFF54, 0xFF55,
        0xFF56, 0xFF57, 0xFF58, 0xFF59, 0xFF5A, 0xFF1B, 0xFF1D, 0xFF0C,
        0xFF0D, 0xFF0E, 0xFF0F, 0xFF40, 0xFF3B, 0xFF3C, 0xFF3D, 0xFF07, 
#endif //KEYSTICKER
        0x3000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x03BA, 0x03C7, 0x03C5, 0x03BC, 0x03B3,
        0x03BD, 0x03BE, 0x03BF, 0x03B8, 0x03C0, 0x03C1, 0x0020, 0x03C9,
        0x03C8, 0x03B9, 0x0020, 0x03B1, 0x03B4, 0x03BB, 0x03B5, 0x03B7,
        0x03C6, 0x03B2, 0x03C4, 0x03B6, 0x03C3, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 

        0x3000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x043B, 0x044A, 0x0448, 0x043D, 0x0432,
        0x043E, 0x043F, 0x0440, 0x0436, 0x0441, 0x0442, 0x0443, 0x044C,
        0x044B, 0x0437, 0x0438, 0x0430, 0x0433, 0x043C, 0x0434, 0x0451,
        0x0449, 0x0431, 0x0447, 0x0435, 0x0446, 0x0444, 0x0020, 0x044D,
        0x0020, 0x044E, 0x044F, 0x0020, 0x0439, 0x0020, 0x043A, 0x0445, 

        0x3000, 0x3122, 0x3105, 0x3109, 0x02C7, 0x02CB, 0x3113, 0x02CA,
        0x02D9, 0x311A, 0x311E, 0x3107, 0x3116, 0x310F, 0x310E, 0x310D,
        0x3111, 0x3115, 0x3118, 0x311B, 0x3128, 0x311C, 0x3120, 0x3129,
        0x3119, 0x311F, 0x3123, 0x3106, 0x3110, 0x310B, 0x3114, 0x3127,
        0x3112, 0x310A, 0x310C, 0x3117, 0x3108, 0x3124, 0x0020, 0x311D,
        0x3126, 0x3121, 0x3125, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 

        0x3000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0113, 0x0020, 0x01D4, 0x011B, 0x01CE,
        0x00E8, 0x0020, 0x012B, 0x01D2, 0x00ED, 0x01D0, 0x00EC, 0x01D8,
        0x01D6, 0x00F2, 0x0020, 0x0101, 0x00E0, 0x00E9, 0x0020, 0x00F3,
        0x00F9, 0x00E1, 0x00FA, 0x014D, 0x016B, 0x0020, 0x0020, 0x01DA,
        0x0020, 0x01DC, 0x00FC, 0x0020, 0x00EA, 0x0020, 0x0020, 0x0020, 

        0x3000, 0x0020, 0x3043, 0x3045, 0x3047, 0x3049, 0x304B, 0x304D,
        0x304F, 0x3051, 0x3053, 0x306A, 0x3082, 0x3080, 0x306C, 0x3059,
        0x306D, 0x306E, 0x306F, 0x3064, 0x3072, 0x3075, 0x3078, 0x3085,
        0x3083, 0x3063, 0x3066, 0x3055, 0x305B, 0x306B, 0x305D, 0x3061,
        0x3081, 0x3057, 0x307F, 0x305F, 0x307E, 0x307B, 0x0020, 0x3087,
        0x3093, 0x308E, 0x3092, 0x3041, 0x3068, 0x0020, 0x3090, 0x3091, 

        0x3000, 0x30B1, 0x30A3, 0x30A5, 0x30F4, 0x30A7, 0x30A9, 0x30AB,
        0x30F5, 0x30AD, 0x30AF, 0x30CA, 0x30E2, 0x30E0, 0x30CC, 0x30B9,
        0x30CD, 0x30CE, 0x30CF, 0x30C4, 0x30D2, 0x30D5, 0x30D8, 0x30E5,
        0x30E3, 0x30C3, 0x30C6, 0x30B5, 0x30BB, 0x30CB, 0x30BD, 0x30C1,
        0x30E1, 0x30B7, 0x30DF, 0x30BF, 0x30DE, 0x30DB, 0x30B3, 0x30E7,
        0x30F6, 0x30EE, 0x30F2, 0x30A1, 0x30C8, 0x30F3, 0x30F0, 0x30F1, 

        0x3000, 0x02C9, 0xFF0C, 0x3001, 0xFF1B, 0xFF1A, 0xFF1F, 0xFF01,
        0x2026, 0x2014, 0x00B7, 0x3014, 0xFF08, 0x3010, 0x3008, 0x201C,
        0x3009, 0x300A, 0x300B, 0x2236, 0x300C, 0x300D, 0x300E, 0xFF3B,
        0xFF09, 0xFF02, 0xFF07, 0x2018, 0x201D, 0x3015, 0x3005, 0x2016,
        0x3011, 0x2019, 0x3017, 0xFF5E, 0x3016, 0x300F, 0x00A8, 0xFF3D,
        0x02C7, 0xFF5B, 0xFF5D, 0x3002, 0xFF40, 0x3003, 0xFF5C, 0xFF0E, 

        0x3000, 0x216A, 0x2161, 0x2162, 0x2163, 0x2164, 0x2165, 0x2166,
        0x2167, 0x2168, 0x2169, 0x3220, 0x2478, 0x2476, 0x3222, 0x248A,
        0x3223, 0x3224, 0x3225, 0x248F, 0x3226, 0x3227, 0x3228, 0x247A,
        0x2479, 0x2490, 0x2491, 0x2488, 0x248B, 0x3221, 0x248C, 0x248E,
        0x2477, 0x2489, 0x2475, 0x248D, 0x2474, 0x3229, 0x0020, 0x247B,
        0x216B, 0x247C, 0x247D, 0x2160, 0x0020, 0x0020, 0x0020, 0x0020, 

        0x3000, 0x0020, 0x2261, 0x2260, 0xFF1D, 0x2264, 0x2265, 0xFF1C,
        0xFF1E, 0x226E, 0x226F, 0x2227, 0x2299, 0x2220, 0x2211, 0xFF0D,
        0x220F, 0x222A, 0x2229, 0x222B, 0x2208, 0x0020, 0x2235, 0x223D,
        0x224C, 0x222E, 0x221D, 0x00B1, 0x00D7, 0x2228, 0x00F7, 0x0020,
        0x2312, 0xFF0B, 0x2225, 0xFF0F, 0x22A5, 0x2234, 0x0020, 0x0020,
        0x2237, 0x221A, 0x0020, 0x2248, 0x221E, 0x0020, 0x0020, 0x0020, 

        0x3000, 0x00A4, 0x00B0, 0x2032, 0x2033, 0xFF04, 0xFFE1, 0xFFE5,
        0x2030, 0xFF05, 0x2103, 0x767E, 0x0020, 0x6BEB, 0x4E07, 0x4E8C,
        0x4EBF, 0x5146, 0x5409, 0x4E03, 0x592A, 0x62CD, 0x827E, 0x0020,
        0x0020, 0x516B, 0x4E5D, 0x25CB, 0x4E09, 0x5343, 0x56DB, 0x516D,
        0x5FAE, 0x4E00, 0x5398, 0x4E94, 0x5206, 0x0020, 0x0020, 0x0020,
        0xFFE0, 0x0020, 0x0020, 0x0020, 0x5341, 0x0020, 0x0020, 0x0020, 

        0x3000, 0x2504, 0x250D, 0x250E, 0x250F, 0x2510, 0x2511, 0x2512,
        0x2513, 0x0020, 0x2500, 0x252C, 0x2540, 0x253E, 0x252E, 0x251E,
        0x252F, 0x2530, 0x2531, 0x2523, 0x2532, 0x2533, 0x0020, 0x2542,
        0x2541, 0x0020, 0x2502, 0x251C, 0x251F, 0x252D, 0x2520, 0x2522,
        0x253F, 0x251D, 0x253D, 0x2521, 0x253C, 0x0020, 0x0020, 0x2543,
        0x2508, 0x0020, 0x0020, 0x250C, 0x2506, 0x0020, 0x250A, 0x0020, 

        0x3000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x25A0, 0xFF3E, 0xFF20, 0x25B2, 0x2606,
        0x203B, 0x2192, 0x2190, 0x25C7, 0x2191, 0x2193, 0x3013, 0xFFE3,
        0xFF3F, 0x25C6, 0x25A1, 0x00A7, 0x2605, 0x25B3, 0x25CB, 0x25CE,
        0xFF3C, 0x2116, 0xFF06, 0x25CF, 0xFF03, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 
    };

TCHAR SKLayoutS[NumsSK][MAXSOFTKEYS] = {
#ifdef KEYSTICKER
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
#else
        0x3000, 0xFF09, 0xFF01, 0xFF20, 0xFF03, 0xFF04, 0xFF05, 0xFF3E,
        0xFF06, 0xFF0A, 0xFF08, 0xFF21, 0xFF22, 0xFF23, 0xFF24, 0xFF25,
        0xFF26, 0xFF27, 0xFF28, 0xFF29, 0xFF2A, 0xFF2B, 0xFF2C, 0xFF2D,
        0xFF2E, 0xFF2F, 0xFF30, 0xFF31, 0xFF32, 0xFF33, 0xFF34, 0xFF35,
        0xFF36, 0xFF37, 0xFF38, 0xFF39, 0xFF3A, 0xFF1A, 0xFF0B, 0xFF1C,
        0xFF3F, 0xFF1E, 0xFF1F, 0xFF5E, 0xFF5B, 0xFF5C, 0xFF5D, 0xFF02, 
#endif //KEYSTICKER
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x039A, 0x03A7, 0x03A5, 0x039C, 0x0393,
        0x039D, 0x039E, 0x039F, 0x0398, 0x03A0, 0x03A1, 0x0020, 0x03A9,
        0x03A8, 0x0399, 0x0020, 0x0391, 0x0394, 0x039B, 0x0395, 0x0397,
        0x03A6, 0x0392, 0x03A4, 0x0396, 0x03A3, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 

        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x041B, 0x042A, 0x0428, 0x041D, 0x0412,
        0x041E, 0x041F, 0x0420, 0x0416, 0x0421, 0x0422, 0x0423, 0x042C,
        0x042B, 0x0417, 0x0418, 0x0410, 0x0413, 0x041C, 0x0414, 0x0401,
        0x0429, 0x0411, 0x0427, 0x0415, 0x0426, 0x0424, 0x0020, 0x042D,
        0x0020, 0x042E, 0x042F, 0x0020, 0x0419, 0x0020, 0x041A, 0x0425, 

        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,

        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,

        0x0020, 0x0020, 0x3044, 0x3046, 0x3048, 0x304A, 0x304C, 0x304E,
        0x3050, 0x3052, 0x3054, 0x3071, 0x308D, 0x308B, 0x3077, 0x305A,
        0x307A, 0x307D, 0x3070, 0x3065, 0x3073, 0x3076, 0x3079, 0x3086,
        0x3084, 0x0020, 0x3067, 0x3056, 0x305C, 0x3074, 0x305E, 0x3062,
        0x308C, 0x3058, 0x308A, 0x3060, 0x3089, 0x307C, 0x0020, 0x3088,
        0x0020, 0x308F, 0x0020, 0x3042, 0x3069, 0x0020, 0x0020, 0x0020, 

        0x0020, 0x30B2, 0x30A4, 0x30A6, 0x0020, 0x30A8, 0x30AA, 0x30AC,
        0x0020, 0x30AE, 0x30B0, 0x30D1, 0x30ED, 0x30EB, 0x30D7, 0x30BA,
        0x30DA, 0x30DD, 0x30D0, 0x30C5, 0x30D3, 0x30D6, 0x30D9, 0x30E6,
        0x30E4, 0x0020, 0x30C7, 0x30B6, 0x30BC, 0x30D4, 0x30BE, 0x30C2,
        0x30EC, 0x30B8, 0x30EA, 0x30C0, 0x30E9, 0x30DC, 0x30B4, 0x30E8,
        0x0020, 0x30EF, 0x0020, 0x30A2, 0x30C9, 0x0020, 0x0020, 0x0020, 

        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,

        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x2460, 0x2482, 0x2480, 0x2462, 0x2494,
        0x2463, 0x2464, 0x2465, 0x2499, 0x2466, 0x2467, 0x2468, 0x2484,
        0x2483, 0x249A, 0x249B, 0x2492, 0x2495, 0x2461, 0x2496, 0x2498,
        0x2481, 0x2493, 0x247F, 0x2497, 0x247E, 0x2469, 0x0020, 0x2485,
        0x0020, 0x2486, 0x2487, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 

        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,

        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x4F70, 0x0020, 0x0020, 0x0020, 0x8D30,
        0x0020, 0x0020, 0x0020, 0x67D2, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x634C, 0x7396, 0x96F6, 0x53C1, 0x4EDF, 0x8086, 0x9646,
        0x0020, 0x58F9, 0x0020, 0x4F0D, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x62FE, 0x0020, 0x0020, 0x0020, 

        0x0020, 0x2505, 0x2515, 0x2516, 0x2517, 0x2518, 0x2519, 0x251A,
        0x251B, 0x0020, 0x2501, 0x2534, 0x2548, 0x2546, 0x2536, 0x2526,
        0x2537, 0x2538, 0x2539, 0x252B, 0x253A, 0x253B, 0x0020, 0x254A,
        0x2549, 0x0020, 0x2503, 0x2524, 0x2527, 0x2535, 0x2528, 0x252A,
        0x2547, 0x2525, 0x2545, 0x2529, 0x2544, 0x0020, 0x0020, 0x254B,
        0x2509, 0x0020, 0x0020, 0x2514, 0x2507, 0x0020, 0x250B, 0x0020, 

        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
    };
#else

BYTE SKLayout[NumsSK][MAXSOFTKEYS*2] = {
#ifdef KEYSTICKER
#ifdef CHAJEI
    "                    y                      "),
#else //if PHON
    "A@B            ",
#endif //CHAJEI
#else //KEYSTICKER
    "",
#endif //KEYSTICKER
    "                                              ",
    "                            ",
    "A@B            ",
//    "                      ",
    "                                          ",
    "      ",
    "",
    "",
    "          ",
    "                  ",
    "                        ",
    "                  ",
    "                                          ",
    };
BYTE SKLayoutS[NumsSK][MAXSOFTKEYS*2] = {
#ifdef KEYSTICKER
    "                                                                                                ",
#else
    "",
#endif //KEYSTICKER
    "                                                ",
    "                              ",
    "                                                                                                ",
    "                                                                                                ",
    "                  ",
    "                  ",
    "                                                                                                ",
    "                                    ",
    "                                                                                                ",
    "                                                                      ",
    "                    ",
    "                                                                                                ",
    };
#endif //UNICODE

#pragma data_seg()

//
TCHAR  CWCodeStr[13] = {0};
TCHAR  CWDBCSStr[41] = {0};
HWND  hCrtDlg = NULL;
UINT  uStartComp = 0;
UINT  uOpenCand = 0;
UINT  uCaps = 0;
DWORD SaTC_Trace;
UINT  UI_CANDSTR = 300;

HINSTANCE hInst;
IMEL      sImeL;
LPIMEL    lpImeL = NULL;
TCHAR      szImeMBFileName[MAX_PATH] = TEXT("");
TCHAR      szUIClassName[CLASS_LEN] = TEXT("");
TCHAR      szCompClassName[CLASS_LEN] = TEXT("");
TCHAR      szCandClassName[CLASS_LEN] = TEXT("");
TCHAR      szStatusClassName[CLASS_LEN] = TEXT("");
TCHAR      szCMenuClassName[CLASS_LEN];            
TCHAR      szSoftkeyMenuClassName[CLASS_LEN];    
TCHAR      szOrgName[NAMESIZE/2] = TEXT("");
TCHAR      szVerInfo[NAMESIZE] = TEXT("");
TCHAR      szHandCursor[] = TEXT("Hand");
TCHAR      szChinese[] = TEXT("Chinese");
TCHAR      szCZ[] = TEXT("CZ");
#ifdef UNICODE
WCHAR      szCandInf1[] = {
        0x0020, 0x0020, 0x0053, 0x0068, 0x0069, 0x0066, 0x0074, 0x0020,
        0x002B, 0x0020, 0x6570, 0x5B57, 0x952E, 0x0000
    };

WCHAR      szCandInf2[] = {
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x6570, 0x5B57,
        0x952E, 0x0000
    };
#else
TCHAR      szCandInf1[] = TEXT("  Shift + ");
TCHAR      szCandInf2[] = TEXT("      ");
#endif
TCHAR      szEnglish[] = TEXT("English");
TCHAR      szImeName[] = TEXT("ImeName");
TCHAR      szCode[] = TEXT("Code");
TCHAR      szEudc[] = TEXT("Eudc");
TCHAR      szFullShape[] = TEXT("FullShape");
TCHAR      szHalfShape[] = TEXT("HalfShape");
TCHAR      szSymbol[] = TEXT("Symbol");
TCHAR      szNoSymbol[] = TEXT("NoSymbol");
TCHAR      szNone[] = TEXT("None");
TCHAR      szSoftKBD[] = TEXT("SoftKBD");
TCHAR      szNoSoftKBD[] = TEXT("NoSoftKBD");
TCHAR      szDigit[] = TEXT("01234567890");
#ifdef UNICODE
WCHAR      szTrace[] = { 0x5149, 0x6807, 0x8DDF, 0x968F, 0x0000 };
WCHAR     szWarnTitle[] = { 0x8B66, 0x544A, 0x0000 };
WCHAR      szErrorTitle[] = { 0x9519, 0x8BEF, 0x0000 };
#else
TCHAR      szTrace[]= TEXT("");
TCHAR      szWarnTitle[]=TEXT("");    
TCHAR      szErrorTitle[]=TEXT("");
#endif

// convert char to upper case
BYTE bUpper[] = {
    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
    0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,
    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
    0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
    0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,
    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
    0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,
    '`', 'A', 'B', 'C', 'D', 'E', 'F', 'G',
    'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W',
    'X', 'Y', 'Z'
};

TCHAR szRegIMESetting[] = TEXT("Control Panel\\Input Method");
TCHAR szPara[] = TEXT("Parallel Distance");
TCHAR szPerp[] = TEXT("Perpendicular Distance");
TCHAR szParaTol[] = TEXT("Parallel Tolerance");
TCHAR szPerpTol[] = TEXT("Perpendicular Tolerance");

#if defined(CROSSREF)
#ifdef UNICODE
WCHAR szRegRevKL[] = { 0x7F16, 0x7801, 0x67E5, 0x8BE2, 0x0000 };
WCHAR szRegRevMaxKey[] = { 0x7F16, 0x7801, 0x67E5, 0x8BE2, 0x7801, 0x957F, 0x0000 };
#else
TCHAR szRegRevKL[] = TEXT("");
TCHAR szRegRevMaxKey[] = TEXT("");
#endif
#endif //CROSSREF

#if defined(EUDC)
TCHAR szRegEudcDictName[] = TEXT("EUDCDictName");
TCHAR szRegEudcMapFileName[] = TEXT("EUDCMapFileName");
#endif


// decide UI offset base on escapement
const NEARCARET ncUIEsc[] = {
   // LogFontX  LogFontY  ParaX   PerpX   ParaY   PerpY
    { 0,        1,        1,      0,      0,      1},       // 0
    { 1,        0,        0,      1,      1,      0},       // 900
    { 0,        0,       -1,      0,      0,      1},       // 1800
    {-1,        0,        0,     -1,     -1,      0}        // 2700
};
// decide another UI offset base on escapement
const NEARCARET ncAltUIEsc[] = {
   // LogFontX  LogFontY  ParaX   PerpX   ParaY   PerpY
    { 0,        0,        1,      0,      0,     -1},       // 0
    { 0,        0,        0,     -1,      1,      0},       // 900
    { 0,        0,       -1,      0,      0,     -1},       // 1800
    { 0,        0,        0,      1,     -1,      0}        // 2700
};
// decide input rectangle base on escapement
const POINT ptInputEsc[] = {
    // LogFontWi   LogFontHi
    {1,            1},                                  // 0
    {1,           -1},                                  // 900
    {1,            1},                                  // 1800
    {-1,           1}                                   // 2700
};

// decide another input rectangle base on escapement
const POINT ptAltInputEsc[] = {
    // LogFontWi   LogFontHi
    {1,           -1},                                  // 0
    {-1,          -1},                                  // 900
    {1,           -1},                                  // 1800
    {1,            1}                                   // 2700
};

BYTE VirtKey48Map[MAXSOFTKEYS] = {
    0x20, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
    0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49,
    0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53,
    0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0xba, 0xbb, 0xbc,
    0xbd, 0xbe, 0xbf, 0xc0, 0xdb, 0xdc, 0xdd, 0xde
};

#ifdef KEYSTICKER

#ifdef CHAJEI
TCHAR KeyIndexTbl[INDEXNUM] = {
    TEXT('a'), TEXT('b'), TEXT('c'), TEXT('d'),
    TEXT('e'), TEXT('f'), TEXT('g'), TEXT('h'),
    TEXT('i'), TEXT('j'), TEXT('k'), TEXT('l'),
    TEXT('m'), TEXT('n'), TEXT('o'), TEXT('p'),
    TEXT('q'), TEXT('r'), TEXT('s'), TEXT('t'),
    TEXT('u'), TEXT('v'), TEXT('w'), TEXT('x'),
    TEXT('y'), TEXT('z')};

#ifdef UNICODE
WCHAR  MapKeySticker_a[] = { 0x65E5, 0x0000 };
WCHAR  MapKeySticker_b[] = { 0x6708, 0x0000 };
WCHAR  MapKeySticker_c[] = { 0x91D1, 0x0000 };
WCHAR  MapKeySticker_d[] = { 0x6728, 0x0000 };
WCHAR  MapKeySticker_e[] = { 0x6C34, 0x0000 };
WCHAR  MapKeySticker_f[] = { 0x706B, 0x0000 };
WCHAR  MapKeySticker_g[] = { 0x571F, 0x0000 };
WCHAR  MapKeySticker_h[] = { 0x7AF9, 0x0000 };
WCHAR  MapKeySticker_i[] = { 0x6208, 0x0000 };
WCHAR  MapKeySticker_j[] = { 0x5341, 0x0000 };
WCHAR  MapKeySticker_k[] = { 0x5927, 0x0000 };
WCHAR  MapKeySticker_l[] = { 0x4E2D, 0x0000 };
WCHAR  MapKeySticker_m[] = { 0x4E00, 0x0000 };
WCHAR  MapKeySticker_n[] = { 0x5F13, 0x0000 };
WCHAR  MapKeySticker_o[] = { 0x4EBA, 0x0000 };
WCHAR  MapKeySticker_p[] = { 0x5FC3, 0x0000 };
WCHAR  MapKeySticker_q[] = { 0x624B, 0x0000 };
WCHAR  MapKeySticker_r[] = { 0x53E3, 0x0000 };
WCHAR  MapKeySticker_s[] = { 0x5C38, 0x0000 };
WCHAR  MapKeySticker_t[] = { 0x5EFF, 0x0000 };
WCHAR  MapKeySticker_u[] = { 0x5C71, 0x0000 };
WCHAR  MapKeySticker_v[] = { 0x5973, 0x0000 };
WCHAR  MapKeySticker_w[] = { 0x7530, 0x0000 };
WCHAR  MapKeySticker_x[] = { 0x96E3, 0x0000 };
WCHAR  MapKeySticker_y[] = { 0x535C, 0x0000 };
WCHAR  MapKeySticker_z[] = { 0xFF3A, 0x0000 };

LPWSTR MapKeyStickerTbl[INDEXNUM] = {
        MapKeySticker_a, MapKeySticker_b, MapKeySticker_c, 
        MapKeySticker_d, MapKeySticker_e, MapKeySticker_f, 
        MapKeySticker_g, MapKeySticker_h, MapKeySticker_i, 
        MapKeySticker_j, MapKeySticker_k, MapKeySticker_l, 
        MapKeySticker_m, MapKeySticker_n, MapKeySticker_o, 
        MapKeySticker_p, MapKeySticker_q, MapKeySticker_r, 
        MapKeySticker_s, MapKeySticker_t, MapKeySticker_u, 
        MapKeySticker_v, MapKeySticker_w, MapKeySticker_x, 
        MapKeySticker_y, MapKeySticker_z
    };
#else
LPTSTR MapKeyStickerTbl[INDEXNUM] = {
    TEXT(""), TEXT(""), TEXT(""),
    TEXT(""), TEXT(""), TEXT(""),
    TEXT(""), TEXT(""), TEXT(""),
    TEXT(""), TEXT(""), TEXT(""),
    TEXT(""), TEXT(""), TEXT(""),
    TEXT(""), TEXT(""), TEXT(""),
    TEXT(""), TEXT(""), TEXT(""),
    TEXT(""), TEXT(""), TEXT("y"),
    TEXT(""), TEXT("")};
#endif // UNICODE

#endif // CHAJEI

#ifdef PHON
TCHAR KeyIndexTbl[INDEXNUM] = {
    TEXT('a'), TEXT('b'), TEXT('c'), TEXT('d'),
    TEXT('e'), TEXT('f'), TEXT('g'), TEXT('h'),
    TEXT('i'), TEXT('j'), TEXT('k'), TEXT('l'),
    TEXT('m'), TEXT('n'), TEXT('o'), TEXT('p'),
    TEXT('q'), TEXT('r'), TEXT('s'), TEXT('t'),
    TEXT('u'), TEXT('v'), TEXT('w'), TEXT('x'),
    TEXT('y'), TEXT('z'), TEXT('1'), TEXT('2'),
    TEXT('3'), TEXT('4'), TEXT('5'), TEXT('6'),
    TEXT('7'), TEXT('8'), TEXT('9'), TEXT('0'),
    TEXT('-'), TEXT('='), TEXT('\\'),TEXT('['),
    TEXT(']'), TEXT(';'), TEXT('\''),TEXT(','),
    TEXT('.'), TEXT('/')};

#ifdef UNICODE
WCHAR  MapKeySticker_a[] = { 0x3107, 0x0000 };
WCHAR  MapKeySticker_b[] = { 0x3116, 0x0000 };
WCHAR  MapKeySticker_c[] = { 0x310F, 0x0000 };
WCHAR  MapKeySticker_d[] = { 0x310E, 0x0000 };
WCHAR  MapKeySticker_e[] = { 0x310D, 0x0000 };
WCHAR  MapKeySticker_f[] = { 0x3111, 0x0000 };
WCHAR  MapKeySticker_g[] = { 0x3115, 0x0000 };
WCHAR  MapKeySticker_h[] = { 0x3118, 0x0000 };
WCHAR  MapKeySticker_i[] = { 0x311B, 0x0000 };
WCHAR  MapKeySticker_j[] = { 0x3128, 0x0000 };
WCHAR  MapKeySticker_k[] = { 0x311C, 0x0000 };
WCHAR  MapKeySticker_l[] = { 0x3120, 0x0000 };
WCHAR  MapKeySticker_m[] = { 0x3129, 0x0000 };
WCHAR  MapKeySticker_n[] = { 0x3119, 0x0000 };
WCHAR  MapKeySticker_o[] = { 0x311F, 0x0000 };
WCHAR  MapKeySticker_p[] = { 0x3123, 0x0000 };
WCHAR  MapKeySticker_q[] = { 0x3106, 0x0000 };
WCHAR  MapKeySticker_r[] = { 0x3110, 0x0000 };
WCHAR  MapKeySticker_s[] = { 0x310B, 0x0000 };
WCHAR  MapKeySticker_t[] = { 0x3114, 0x0000 };
WCHAR  MapKeySticker_u[] = { 0x3127, 0x0000 };
WCHAR  MapKeySticker_v[] = { 0x3112, 0x0000 };
WCHAR  MapKeySticker_w[] = { 0x310A, 0x0000 };
WCHAR  MapKeySticker_x[] = { 0x310C, 0x0000 };
WCHAR  MapKeySticker_y[] = { 0x3117, 0x0000 };
WCHAR  MapKeySticker_z[] = { 0x3108, 0x0000 };
WCHAR  MapKeySticker_1[] = { 0x3105, 0x0000 };
WCHAR  MapKeySticker_2[] = { 0x3109, 0x0000 };
WCHAR  MapKeySticker_3[] = { 0x02C7, 0x0000 };
WCHAR  MapKeySticker_4[] = { 0x02CB, 0x0000 };
WCHAR  MapKeySticker_5[] = { 0x3113, 0x0000 };
WCHAR  MapKeySticker_6[] = { 0x02CA, 0x0000 };
WCHAR  MapKeySticker_7[] = { 0x02D9, 0x0000 };
WCHAR  MapKeySticker_8[] = { 0x311A, 0x0000 };
WCHAR  MapKeySticker_9[] = { 0x311E, 0x0000 };
WCHAR  MapKeySticker_0[] = { 0x3122, 0x0000 };
WCHAR  MapKeySticker_MINUS[]    = { 0x3126, 0x0000 };
WCHAR  MapKeySticker_EQUAL[]    = { 0x0000, 0x0000 };
WCHAR  MapKeySticker_BSLASH[]   = { 0x0000, 0x0000 };
WCHAR  MapKeySticker_LBRACKET[] = { 0x0000 };
WCHAR  MapKeySticker_RBRACKET[] = { 0x0000 };
WCHAR  MapKeySticker_SEMICLN[]  = { 0x3124, 0x0000 };
WCHAR  MapKeySticker_QUOTE[]    = { 0x0000 };
WCHAR  MapKeySticker_COMMA[]    = { 0x311D, 0x0000 };
WCHAR  MapKeySticker_DOT[]      = { 0x3121, 0x0000 };
WCHAR  MapKeySticker_SLASH[]    = { 0x3125, 0x0000 };

LPWSTR MapKeyStickerTbl[INDEXNUM] = {
        MapKeySticker_a, MapKeySticker_b, MapKeySticker_c, 
        MapKeySticker_d, MapKeySticker_e, MapKeySticker_f, 
        MapKeySticker_g, MapKeySticker_h, MapKeySticker_i, 
        MapKeySticker_j, MapKeySticker_k, MapKeySticker_l, 
        MapKeySticker_m, MapKeySticker_n, MapKeySticker_o, 
        MapKeySticker_p, MapKeySticker_q, MapKeySticker_r, 
        MapKeySticker_s, MapKeySticker_t, MapKeySticker_u, 
        MapKeySticker_v, MapKeySticker_w, MapKeySticker_x, 
        MapKeySticker_y, MapKeySticker_z, MapKeySticker_1,
        MapKeySticker_2, MapKeySticker_3, MapKeySticker_4,
        MapKeySticker_5, MapKeySticker_6, MapKeySticker_7,
        MapKeySticker_8, MapKeySticker_9, MapKeySticker_0,
        MapKeySticker_MINUS, MapKeySticker_EQUAL, MapKeySticker_BSLASH,
        MapKeySticker_LBRACKET, MapKeySticker_RBRACKET, MapKeySticker_SEMICLN,
        MapKeySticker_QUOTE, MapKeySticker_COMMA, MapKeySticker_DOT,
        MapKeySticker_SLASH
    };

#else

LPTSTR MapKeyStickerTbl[INDEXNUM] = {
    TEXT(""), TEXT(""), TEXT(""),
    TEXT(""), TEXT(""), TEXT(""),
    TEXT(""), TEXT(""), TEXT(""),
    TEXT(""), TEXT(""), TEXT(""),
    TEXT(""), TEXT(""), TEXT(""),
    TEXT(""), TEXT(""), TEXT(""),
    TEXT(""), TEXT(""), TEXT(""),
    TEXT(""), TEXT(""), TEXT(""),
    TEXT(""), TEXT(""), TEXT(""),
    TEXT(""), TEXT(""), TEXT("A"),
    TEXT(""), TEXT("@"), TEXT("B"),
    TEXT(""), TEXT(""), TEXT(""),
    TEXT(""), TEXT(""),   TEXT(""),
    TEXT(""),   TEXT(""),   TEXT(""),
    TEXT(""),   TEXT(""), TEXT(""),
    TEXT("")};
#endif  // UNICODE 
#endif  // PHON

#endif    //KEYSTICKER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntime\ddis.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    DDIS.C
    
++*/

#include <windows.h>
#include <windowsx.h>
#include <winerror.h>
#ifdef CROSSREF
#include <winuser.h>    
#endif
#include <immdev.h>
#include <string.h>
#include <regstr.h>
#include <ctype.h>
#include <shlobj.h>

#include "imedefs.h"
#include "resource.h"

LPTSTR _rtcschr(LPTSTR string, TCHAR c);

LONG    lLock = 0;  // this variable is for Lock and Unlock.

//we must init hprivate->mb_name
//*******************************************************************
//    InitMbName(hIMC);
//*******************************************************************
void InitMbName(HIMC hIMC)
{
LPINPUTCONTEXT    lpIMC;

    if (!hIMC) {
        return ;
    }
    
    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if(!lpIMC){
        return;
    }

    StartEngine(lpIMC->hPrivate);

    ImmUnlockIMC(hIMC);
    return;

}


// Get the current user's EMB file path, and IME's MB path
// fill global variable sImeG.szIMESystemPath and sImeG.szIMEUserPath

void GetCurrentUserEMBPath(  )
{

    PSECURITY_ATTRIBUTES psa = NULL;
    TCHAR   szModuleName[MAX_PATH], *lpszStart, *lpszDot;
    int     i;

    // Get the path for MB and EMB

    GetSystemDirectory(sImeG.szIMESystemPath, MAX_PATH);

    GetModuleFileName(hInst, szModuleName, sizeof(szModuleName)/sizeof(TCHAR) );
   
    lpszStart = szModuleName + lstrlen(szModuleName) - 1;

    while ( (lpszStart != szModuleName) && ( *lpszStart != TEXT('\\') ) ) {
          
          if ( *lpszStart == TEXT('.') ) {
             lpszDot = lpszStart;
             *lpszDot = TEXT('\0');
          }

          lpszStart --;
    }

    if ( *lpszStart == TEXT('\\') ) {
         lpszStart ++;
    }

    if ( lpszStart != szModuleName ) {
       for (i=0; i<lstrlen(lpszStart); i++) 
           szModuleName[i] = lpszStart[i];

       szModuleName[i] = TEXT('\0');
    }

//    psa = CreateSecurityAttributes();

    SHGetSpecialFolderPath(NULL,sImeG.szIMEUserPath,CSIDL_APPDATA, FALSE);

    if ( sImeG.szIMEUserPath[lstrlen(sImeG.szIMEUserPath)-1] == TEXT('\\') )
         sImeG.szIMEUserPath[lstrlen(sImeG.szIMEUserPath) - 1] = TEXT('\0');

    // Because CreateDirectory( ) cannot create directory like \AA\BB, 
    // if AA and BB both do not exist. It can create only one layer of 
    // directory each time. so we must call twice CreateDirectory( ) for 
    // \AA\BB

    lstrcat(sImeG.szIMEUserPath, TEXT("\\Microsoft") );

    if ( GetFileAttributes(sImeG.szIMEUserPath) != FILE_ATTRIBUTE_DIRECTORY) 
       CreateDirectory(sImeG.szIMEUserPath, psa);

    lstrcat(sImeG.szIMEUserPath, TEXT("\\IME") );

    if ( GetFileAttributes(sImeG.szIMEUserPath) != FILE_ATTRIBUTE_DIRECTORY)
       CreateDirectory(sImeG.szIMEUserPath, psa);

    lstrcat(sImeG.szIMEUserPath, TEXT("\\") );
    lstrcat(sImeG.szIMEUserPath, szModuleName);
    
    //
    // Create the directory, so that CreateFile( ) can work fine later. 
    // ortherwise, if the directory does not exist, and you try to create 
    // a file under that dir,  CreateFile will return error.
    //

    if ( GetFileAttributes(sImeG.szIMEUserPath) != FILE_ATTRIBUTE_DIRECTORY)
        CreateDirectory(sImeG.szIMEUserPath, psa);
//    FreeSecurityAttributes(psa);

    return;
}



/**********************************************************************/
/* ImeInquire()                                                       */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL WINAPI ImeInquire(         // initialized data structure of IME
    LPIMEINFO lpImeInfo,        // IME specific data report to IMM
    LPTSTR    lpszWndCls,       // the class name of UI
    DWORD     dwSystemInfoFlags)
{
    if (!lpImeInfo) {
        return (FALSE);
    }
    
    lpImeInfo->dwPrivateDataSize = sizeof(PRIVCONTEXT);
    lpImeInfo->fdwProperty = IME_PROP_KBD_CHAR_FIRST|
#ifdef UNICODE
        IME_PROP_UNICODE|
#endif
        IME_PROP_CANDLIST_START_FROM_1|
        IME_PROP_IGNORE_UPKEYS;

    lpImeInfo->fdwConversionCaps = IME_CMODE_NATIVE|IME_CMODE_FULLSHAPE|
        IME_CMODE_CHARCODE|IME_CMODE_SOFTKBD|IME_CMODE_NOCONVERSION|
        IME_CMODE_EUDC;
    lpImeInfo->fdwSentenceCaps = 0;
    // IME will have different distance base multiple of 900 escapement
    lpImeInfo->fdwUICaps = UI_CAP_ROT90|UI_CAP_SOFTKBD;
    // composition string is the reading string for simple IME
    lpImeInfo->fdwSCSCaps = SCS_CAP_COMPSTR|SCS_CAP_MAKEREAD;
    // IME want to decide conversion mode on ImeSelect
    lpImeInfo->fdwSelectCaps = (DWORD) 0;

    lstrcpy(lpszWndCls, (LPTSTR)szUIClassName);

    if ( lpImeL )
    {
       if ( dwSystemInfoFlags & IME_SYSINFO_WINLOGON )
       {
            //  the client app is running in logon mode.
            lpImeL->fWinLogon = TRUE;
       }
       else
            lpImeL->fWinLogon = FALSE;

    }

    return (TRUE);
}

/**********************************************************************/
/* SetImeDlgProc()                                                    */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL FAR PASCAL SetImeDlgProc(
    HWND  hDlg,
    UINT  uMessage,
    DWORD wParam,
    LONG  lParam)
{
    RECT           rc;
    LONG           DlgWidth, DlgHeight;
    HIMC           hIMC;
#ifdef CROSSREF
    HWND          hLayoutListBox;
    static HIMC   hOldIMC;
#endif //CROSSREF
 

    switch (uMessage) {
    case WM_INITDIALOG:
        hCrtDlg = hDlg;    
        // reset position
        GetWindowRect(hDlg, &rc);
        DlgWidth =  rc.right - rc.left;
        DlgHeight =  rc.bottom - rc.top;
        
        SetWindowPos(hDlg, HWND_TOP,
            (int)(sImeG.rcWorkArea.right - DlgWidth)/2,
            (int)(sImeG.rcWorkArea.bottom - DlgHeight)/2,
            (int) 0, (int) 0, SWP_NOSIZE);

        // Init CheckFrame State
        SetImeCharac(hDlg, (int) 0, SIC_READY, 0);

        CheckDlgButton (hDlg, IDC_LX, 
                MBIndex.IMEChara[0].IC_LX);
        CheckDlgButton (hDlg, IDC_CZ,
                MBIndex.IMEChara[0].IC_CZ);
        CheckDlgButton (hDlg, IDC_TS,
                MBIndex.IMEChara[0].IC_TS);
        CheckDlgButton (hDlg, IDC_CTS,
                MBIndex.IMEChara[0].IC_CTC);
        CheckDlgButton (hDlg, IDC_TC,
                MBIndex.IMEChara[0].IC_Trace);

        //CHP    
#ifdef FUSSYMODE
        CheckDlgButton (hDlg, IDC_FCSR,
                MBIndex.IMEChara[0].IC_FCSR);
        CheckDlgButton (hDlg, IDC_FCTS,
                MBIndex.IMEChara[0].IC_FCTS);

        EnableWindow(GetDlgItem(hDlg, IDC_CZ), FALSE);

#endif //FUSSYMODE

#if defined(COMBO_IME)        
         if (MBIndex.IMEChara[0].IC_GB)
            SendMessage(GetDlgItem(hDlg, IDC_GB),
                    BM_SETCHECK,
                    TRUE,
                    0L);
        else
            SendMessage(GetDlgItem(hDlg, IDC_GBK),
                    BM_SETCHECK,
                    TRUE,
                    0L);
#endif //COMBO_IME

        if(MBIndex.IMEChara[0].IC_TS) {
            EnableWindow(GetDlgItem(hDlg, IDC_CTS), TRUE);
        } else {
            EnableWindow(GetDlgItem(hDlg, IDC_CTS), FALSE);
        }


#ifdef CROSSREF
        hLayoutListBox = GetDlgItem(hDlg, IDD_LAYOUT_LIST);

        hIMC = ImmGetContext(hLayoutListBox);
        if(hIMC){
            ImmSetOpenStatus(hIMC, FALSE);
        }
        ImmReleaseContext(hLayoutListBox, hIMC);
        // put all reverse conversion hKL into this list
        ReverseConversionList(hLayoutListBox);
#endif //CROSSREF

        return (TRUE);          // don't want to set focus to special control
    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:
            SetImeCharac(hDlg, (int) 0, SIC_SAVE1, 0);
#ifdef CROSSREF
            hLayoutListBox = GetDlgItem(hDlg, IDD_LAYOUT_LIST);
            hIMC = ImmGetContext(hLayoutListBox);
            if(hIMC) {
                   ImmSetOpenStatus(hIMC, TRUE);
            }
            ImmReleaseContext(hLayoutListBox, hIMC);
#endif //CROSSREF
            EndDialog(hDlg, FALSE);
            break;
        case IDCANCEL:
#ifdef CROSSREF
            hLayoutListBox = GetDlgItem(hDlg, IDD_LAYOUT_LIST);
            hIMC = ImmGetContext(hLayoutListBox);
            if(hIMC) {
                   ImmSetOpenStatus(hIMC, TRUE);
            }
            ImmReleaseContext(hLayoutListBox, hIMC);
#endif //CROSSREF
            EndDialog(hDlg, FALSE);
            break;
        case IDC_LX:
        case IDC_CZ:
        case IDC_TS:
        case IDC_CTS:
        case IDC_TC:

                //CHP
#ifdef FUSSYMODE
                case IDC_FCSR:
                case IDC_FCTS:
#endif //FUSSYMODE

            // Set Current InputMode Param(temp)
            SetImeCharac(hDlg, (wParam - IDC_LX), SIC_MODIFY, (int) 0);
            break;
#if defined(COMBO_IME)
        case IDC_GB:
        case IDC_GBK:
            // Set Current InputMode Param(temp)
            SetImeCharac(hDlg, 7, SIC_MODIFY, (int) 0);
            break;
#endif //COMBO_IME
        default:
            return (FALSE);
        }
        return (TRUE);
    case WM_PAINT:
        {
            RECT rc;

            GetClientRect(hDlg, &rc);
            DrawConvexRect(GetDC(hDlg),
                rc.left + 6,
                rc.top + 8,
                rc.right - 6 - 1,
                rc.bottom - 40 - 1);

            DrawConvexRectP(GetDC(hDlg),
                rc.left + 6,
                rc.top + 8,
                rc.right - 6,
                rc.bottom - 40);
        }
        
        return (FALSE);
    case WM_CLOSE:
#ifdef CROSSREF
        hLayoutListBox = GetDlgItem(hDlg, IDD_LAYOUT_LIST);
        hIMC = ImmGetContext(hLayoutListBox);
        if(hIMC) {
            ImmSetOpenStatus(hIMC, TRUE);
        }
        ImmReleaseContext(hLayoutListBox, hIMC);
#endif //CROSSREF
        EndDialog(hDlg, FALSE);
        return (TRUE);
    default:
        return (FALSE);
    }

    return (TRUE);
}

/**********************************************************************/
/* SetImeCharac()                                                    */
/* Return Value: voide                                                */
/* Entry:                                                             */
/*     code=0, init                                                   */
/*     code=1, Save temp                                              */
/*     code=2, Save resault                                           */
/**********************************************************************/
void SetImeCharac (
    HWND  hDlg,
    int   ParamNum,
    int   Mode,
    DWORD ObjImeIndex)
{
    HIMC            hIMC;
    LPINPUTCONTEXT  lpIMC;
    LPPRIVCONTEXT   lpImcP;
#if defined(COMBO_IME)
    static DWORD    TempParam[8];
#else
    static DWORD    TempParam[7];
#endif //COMBO_IME
    HKEY            hKeyCurrVersion;
    HKEY            hKey;
    DWORD           retCode;
#ifdef UNICODE
    TCHAR           ValueName[][9] = { 
        {0x8BCD, 0x8BED, 0x8054, 0x60F3, 0x0000},
        {0x8BCD, 0x8BED, 0x8F93, 0x5165, 0x0000},
        {0x9010, 0x6E10, 0x63D0, 0x793A, 0x0000},
        {0x5916, 0x7801, 0x63D0, 0x793A, 0x0000},
        {0x5149, 0x6807, 0x8DDF, 0x968F, 0x0000},
#else
   TCHAR ValueName[][9] = { 
        TEXT(""),
        TEXT(""),
        TEXT(""),
        TEXT(""),
          TEXT(""),
#endif
        TEXT("FC input"),
        TEXT("FC aid"),

#if defined(COMBO_IME)
           TEXT("GB/GBK")
#endif //COMBO_IME
        };
    UINT i;

    switch (Mode)
    {
    case SIC_READY:

        InitImeCharac(ObjImeIndex);
        //CHP
#ifdef FUSSYMODE
        if (MBIndex.IMEChara[ObjImeIndex].IC_FCSR)
        {
              if (MBIndex.IMEChara[ObjImeIndex].IC_FCTS)
                    EnableWindow(GetDlgItem(hDlg, IDD_LAYOUT_LIST), FALSE);
        }
        else
              EnableWindow(GetDlgItem(hDlg, IDC_FCTS), FALSE);
#endif //FUSSYMODE


        TempParam[0] = MBIndex.IMEChara[ObjImeIndex].IC_LX;
        TempParam[1] = MBIndex.IMEChara[ObjImeIndex].IC_CZ;
        TempParam[2] = MBIndex.IMEChara[ObjImeIndex].IC_TS;
        TempParam[3] = MBIndex.IMEChara[ObjImeIndex].IC_CTC;
        TempParam[4] = MBIndex.IMEChara[ObjImeIndex].IC_Trace;

                //CHP
        TempParam[5] = MBIndex.IMEChara[ObjImeIndex].IC_FCSR;
        TempParam[6] = MBIndex.IMEChara[ObjImeIndex].IC_FCTS;
     
#if defined(COMBO_IME)
        TempParam[7] = MBIndex.IMEChara[ObjImeIndex].IC_GB;
#endif //COMBO_IME

        break;
    case SIC_MODIFY:
        TempParam[ParamNum] = (TempParam[ParamNum] ^ 0x00000001) & 0x00000001;
        if(TempParam[2]) {
            EnableWindow(GetDlgItem(hDlg, IDC_CTS), TRUE);
        } else {
            EnableWindow(GetDlgItem(hDlg, IDC_CTS), FALSE);
            TempParam[3] = 0;
            CheckDlgButton (hDlg, IDC_CTS, FALSE);
        }

        //CHP
#ifdef FUSSYMODE
        if (TempParam[5]) 
        {
            EnableWindow(GetDlgItem(hDlg, IDC_FCTS), TRUE);
            if  (TempParam[6])
                EnableWindow(GetDlgItem(hDlg, IDD_LAYOUT_LIST), FALSE);
            else
                EnableWindow(GetDlgItem(hDlg, IDD_LAYOUT_LIST), TRUE);
        }
        else
        {
            EnableWindow(GetDlgItem(hDlg, IDC_FCTS), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDD_LAYOUT_LIST), TRUE);
        }
#endif //FUSSYMODE

        break;
    case SIC_SAVE1:
        MBIndex.IMEChara[ObjImeIndex].IC_LX = TempParam[0];
        MBIndex.IMEChara[ObjImeIndex].IC_CZ = TempParam[1];
        MBIndex.IMEChara[ObjImeIndex].IC_TS = TempParam[2];
        MBIndex.IMEChara[ObjImeIndex].IC_CTC = TempParam[3];
        MBIndex.IMEChara[ObjImeIndex].IC_Trace = TempParam[4];

                // CHP
#ifdef FUSSYMODE
        MBIndex.IMEChara[ObjImeIndex].IC_FCSR = TempParam[5];
        MBIndex.IMEChara[ObjImeIndex].IC_FCTS = TempParam[6];
#endif //FUSSYMODE

#if defined(COMBO_IME)
        MBIndex.IMEChara[ObjImeIndex].IC_GB = TempParam[7];
#endif //COMBO_IME

        retCode = OpenReg_PathSetup(&hKeyCurrVersion);
        if (retCode) {
            RegCreateKey(HKEY_CURRENT_USER, REGSTR_PATH_SETUP, &hKeyCurrVersion);
        }

        if ( hKeyCurrVersion )
            retCode = RegCreateKeyEx(hKeyCurrVersion, MBIndex.MBDesc[ObjImeIndex].szName, 0,
                        NULL, REG_OPTION_NON_VOLATILE,    KEY_ALL_ACCESS    , NULL, &hKey, NULL);
        else
            return;


        if ( hKey == NULL )
        {
            RegCloseKey(hKeyCurrVersion);
            return;
        }

#if defined(COMBO_IME)
        for(i=0; i<8; i++) {
#else
        for(i=0; i<7; i++) {
#endif //COMBO_IME
             DWORD Value;

            switch (i)
            {
                case 0:
                    Value = MBIndex.IMEChara[ObjImeIndex].IC_LX;
                    break;
                case 1:
                    Value = MBIndex.IMEChara[ObjImeIndex].IC_CZ;
                    break;
                case 2:
                    Value = MBIndex.IMEChara[ObjImeIndex].IC_TS;
                    break;
                case 3:
                    Value = MBIndex.IMEChara[ObjImeIndex].IC_CTC;
                    break;
                case 4:
                    Value = MBIndex.IMEChara[ObjImeIndex].IC_Trace;
                    break;

                                //CHP
#ifdef FUSSYMODE
                case 5:
                    Value = MBIndex.IMEChara[ObjImeIndex].IC_FCSR;
                    break;
                case 6:
                    Value = MBIndex.IMEChara[ObjImeIndex].IC_FCTS;
                    break;
#endif //FUSSYMODE
#if defined(COMBO_IME)
                case 7:
                    Value = MBIndex.IMEChara[ObjImeIndex].IC_GB;
                    break;
#endif //COMBO_IME
            }
            
            if ( hKey != NULL )
            {
                RegSetValueEx (hKey, ValueName[i],
                                      (DWORD) 0,
                                      REG_DWORD,
                                      (LPBYTE)&Value,
                                      sizeof(DWORD));
            }
        }

        RegCloseKey(hKey);
        RegCloseKey(hKeyCurrVersion);

#ifdef CROSSREF
    {
        HWND hLayoutListBox;
        int  iCurSel;
        HKL  hKL;
       
        DWORD retCode;

        hLayoutListBox = GetDlgItem(hDlg, IDD_LAYOUT_LIST);
        iCurSel = (int)SendMessage(hLayoutListBox, LB_GETCURSEL, 0, 0);
        hKL = (HKL)SendMessage(hLayoutListBox, LB_GETITEMDATA,
               iCurSel, 0);

        //CHP
#ifdef FUSSYMODE
        if (MBIndex.IMEChara[ObjImeIndex].IC_FCSR &&
            MBIndex.IMEChara[ObjImeIndex].IC_FCTS)
            hKL = GetKeyboardLayout(0);
#endif //FUSSYMODE

        if (MBIndex.hRevKL != hKL) {
            WORD nRevMaxKey;
            HKEY hKeyAppUser, hKeyIMEUser;
            LPPRIVCONTEXT  lpImcP;

            MBIndex.hRevKL = hKL;


            //set reverse layout to registry
            retCode = OpenReg_PathSetup(&hKeyAppUser);
            if (retCode) {
                RegCreateKey(HKEY_CURRENT_USER, REGSTR_PATH_SETUP, &hKeyCurrVersion);
            }

            retCode = RegCreateKeyEx(hKeyAppUser, MBIndex.MBDesc[0].szName, 0,
                NULL, REG_OPTION_NON_VOLATILE,    KEY_ALL_ACCESS    , NULL, &hKeyIMEUser, NULL);

            if (retCode) {
                DWORD   dwDisposition;
        
                retCode = RegCreateKeyEx (hKeyCurrVersion,
                                 MBIndex.MBDesc[0].szName,
                              0,
                              0,
                              REG_OPTION_NON_VOLATILE,
                              KEY_ALL_ACCESS,
                              NULL,
                              &hKey,
                              &dwDisposition);
            }

            RegSetValueEx(hKeyIMEUser, szRegRevKL, 0, REG_DWORD, (LPBYTE)&hKL,sizeof(hKL));

            // get the new size
            nRevMaxKey = (WORD)ImmEscape(hKL, (HIMC)NULL, IME_ESC_MAX_KEY,
                NULL);

            if (lpImeL->nMaxKey != nRevMaxKey) {
                if(lpImeL->nMaxKey < nRevMaxKey)
                    lpImeL->nMaxKey = nRevMaxKey;

                // set the width & height for composition window
                 lpImeL->rcCompText.right = lpImeL->rcCompText.left +
                    sImeG.xChiCharWi * ((lpImeL->nMaxKey+2)/2);
                lpImeL->xCompWi = lpImeL->rcCompText.right + lpImeL->cxCompBorder * (2 + 4);

                //generate message to broadcast change comp win size
                hIMC = (HIMC)ImmGetContext(hDlg);
                if (!hIMC) {
                    return;
                }
                lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
                if (!lpIMC) {
                    return;
                }
                lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
                if (!lpImcP) {
                    goto ChgConfigUnlockIMC;
                }
                lpImcP->fdwImeMsg |= MSG_IMN_COMPOSITIONPOS;
                GenerateMessage(hIMC, lpIMC, lpImcP);
                ImmUnlockIMCC(lpIMC->hPrivate);
ChgConfigUnlockIMC:
                ImmUnlockIMC(hIMC);
            } //end of change nMaxKey

            RegSetValueEx(hKeyIMEUser, szRegRevMaxKey, 0, REG_DWORD, (LPBYTE)&lpImeL->nMaxKey,sizeof(DWORD));

            RegCloseKey(hKeyAppUser);
            RegCloseKey(hKeyIMEUser);

        } //end of change RegRevKL
    }
#endif    //CROSSREF

        break;
    }

    return;
}
#if defined(CROSSREF)
/**********************************************************************/
/* ReverseConversionList()                                            */
/**********************************************************************/
void PASCAL ReverseConversionList(HWND   hLayoutListBox)
{
    int      nLayouts, i, nIMEs;
    TCHAR    szImeName[16];
    HKL FAR *lpKLMem;

    LoadString(hInst, IDS_NONE, szImeName, sizeof(szImeName)/sizeof(TCHAR));

    SendMessage(hLayoutListBox, LB_INSERTSTRING,
        0, (LPARAM)szImeName);

    SendMessage(hLayoutListBox, LB_SELECTSTRING,
        0, (LPARAM)szImeName);

    SendMessage(hLayoutListBox, LB_SETITEMDATA,
        0, (LPARAM)(HKL)NULL);

    nLayouts = GetKeyboardLayoutList(0, NULL);

    lpKLMem = GlobalAlloc(GPTR, sizeof(HKL) * nLayouts);
    if (!lpKLMem) {
        return;
    }

    GetKeyboardLayoutList(nLayouts, lpKLMem);

    for (i = 0, nIMEs = 0; i < nLayouts; i++) {
        HKL hKL;

        hKL = *(lpKLMem + i);

        if (LOWORD(hKL) != NATIVE_LANGUAGE) {
            // not support other language
            continue;
        }

        // NULL hIMC ???????
        if (!ImmGetConversionList(hKL, (HIMC)NULL, NULL,
            NULL, 0, GCL_REVERSECONVERSION)) {
            // this IME not support reverse conversion
            continue;
        }

        if (!ImmEscape(hKL, (HIMC)NULL, IME_ESC_IME_NAME,
            szImeName)) {
            // this IME does not report the IME name
            continue;
        }

        if( lstrcmp(szImeName, MBIndex.MBDesc[0].szName) == 0)
            continue;

        nIMEs++;

        SendMessage(hLayoutListBox, LB_INSERTSTRING,
            nIMEs, (LPARAM)szImeName);

        if (hKL == MBIndex.hRevKL) {
            SendMessage(hLayoutListBox, LB_SELECTSTRING, nIMEs,
                (LPARAM)szImeName);
        }

        SendMessage(hLayoutListBox, LB_SETITEMDATA,
            nIMEs, (LPARAM)hKL);
    }

    GlobalFree((HGLOBAL)lpKLMem);

    return;
}
#endif //CROSSREF

#ifdef EUDC
//**********************************************************************
//BOOL EUDCDicName( HWND hWnd)
//**********************************************************************
BOOL EUDCDicName( HWND hWnd)
{
    HANDLE       hUsrDicFile;
    BOOL         fRet;
    TCHAR        szFileName[MAX_PATH];
    TCHAR        szMapFileName[MAX_PATH];
    TCHAR        EUDCMB_PathAndName[MAX_PATH];
    TCHAR        *tepstr;
    HKEY         hKeyCurrVersion,hKey;
    PSECURITY_ATTRIBUTES psa;

    LoadString(hInst, IDS_IMEMBFILENAME, szFileName, MAX_PATH);
    tepstr = _rtcschr(szFileName,TEXT('.'));

    if ( tepstr != NULL )
        lstrcpy(tepstr,TEXT(".EMB"));

    lstrcpy(EUDCMB_PathAndName, sImeG.szIMEUserPath);
    lstrcat(EUDCMB_PathAndName, TEXT("\\") );
    lstrcat(EUDCMB_PathAndName, szFileName); 

    psa = CreateSecurityAttributes();

    hUsrDicFile = CreateFile(EUDCMB_PathAndName, 
                             GENERIC_WRITE,
                             FILE_SHARE_READ|FILE_SHARE_WRITE,
                             psa, 
                             OPEN_ALWAYS,
                             FILE_ATTRIBUTE_NORMAL, 
                             (HANDLE)NULL);

    if (hUsrDicFile == INVALID_HANDLE_VALUE) {
        FreeSecurityAttributes(psa);
        return (FALSE);
    }

    CloseHandle(hUsrDicFile);
    FreeSecurityAttributes(psa);

    lstrcpy(MBIndex.EUDCData.szEudcDictName, EUDCMB_PathAndName);

    // if we have already got a map file, we just use it. 
    if (MBIndex.EUDCData.szEudcMapFileName[0]) {
        return (TRUE);
    }
 
    // Otherwise, generate the Map File Name, which is Basic Filename plus EUDC
   
    lstrcpy(szMapFileName, szFileName); 
    tepstr = _rtcschr(szMapFileName,TEXT('.'));
    lstrcpy(tepstr, TEXT("EUDC"));

    lstrcpy(MBIndex.EUDCData.szEudcMapFileName, szMapFileName);

    fRet = OpenReg_PathSetup(&hKeyCurrVersion);

    if (fRet)  return FALSE;

    fRet = OpenReg_User (hKeyCurrVersion,
                         MBIndex.MBDesc[0].szName,
                         &hKey);
    if (fRet) {
        DWORD   dwDisposition;
        
        fRet = RegCreateKeyEx (hKeyCurrVersion,
                                 MBIndex.MBDesc[0].szName,
                              0,
                              0,
                              REG_OPTION_NON_VOLATILE,
                              KEY_ALL_ACCESS,
                              NULL,
                              &hKey,
                              &dwDisposition);

        if (fRet != ERROR_SUCCESS) return FALSE;
    }

    fRet = RegSetValueEx (hKey, 
                          szRegEudcDictName,
                          (DWORD) 0,
                          REG_SZ,
                          (const unsigned char *)MBIndex.EUDCData.szEudcDictName,
                          lstrlen(MBIndex.EUDCData.szEudcDictName)*sizeof(TCHAR));

    if (fRet != ERROR_SUCCESS ) return FALSE;

    fRet = RegSetValueEx (hKey, 
                          szRegEudcMapFileName,
                          (DWORD) 0,
                          REG_SZ,
                          (const unsigned char *)MBIndex.EUDCData.szEudcMapFileName,
                          lstrlen(MBIndex.EUDCData.szEudcMapFileName)*sizeof(TCHAR));

    if (fRet) return FALSE;

    return (TRUE);
}
#endif    //EUDC

/**********************************************************************/
/* ImeConfigure()                                                     */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL WINAPI ImeConfigure(      // configurate the IME setting
    HKL     hKL,               // hKL of this IME
    HWND    hAppWnd,           // the owner window
    DWORD   dwMode,               // mode of dialog
    LPVOID  lpData)            
{
    switch (dwMode) {
    case IME_CONFIG_GENERAL:
        DialogBox(hInst, TEXT("SETIME"), hAppWnd, (DLGPROC) SetImeDlgProc);
        break;

#ifdef EUDC
    case IME_CONFIG_SELECTDICTIONARY:
        return(EUDCDicName(hAppWnd));
        break;
#endif //EUDC
    default:
        return (FALSE);
        break;
    }
    return (TRUE);
}

/**********************************************************************/
/* ForwordConversion()                                                */
/**********************************************************************/
UINT PASCAL ForwordConversion(
    HIMC            hIMC,
    LPCTSTR         lpszSrc,
    LPCANDIDATELIST lpCandList,
    UINT            uBufLen)

{
    unsigned int   i;
    LPTSTR wCode;
    LPINPUTCONTEXT      lpIMC;
    UINT        uMaxCand;
    DWORD       dwSize;

    wCode = ConverList.szSelectBuffer;

    ConverList.szSelectBuffer[0] =TEXT('\0');
    ConverList.szInBuffer[0]     =TEXT('\0');
    ConverList.Candi_Cnt         =0;
    ConverList.Candi_Pos[0]      =TEXT('\0');


    if (!hIMC) {
        return (0);
    }
    
    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);

    if (!lpIMC) {
        return (0);
    }

    if (!Conversion (lpIMC->hPrivate,lpszSrc,0)) {
    return (0);
    }
    ConverList.szSelectBuffer [lstrlen(ConverList.szSelectBuffer)-1]
        =TEXT('\0');
    dwSize =
        // header length
        sizeof(CANDIDATELIST) +
        // candidate string pointers
        sizeof(DWORD) * ConverList.Candi_Cnt+
        // string plus NULL terminator
        sizeof(TCHAR) * lstrlen (wCode);


    if (!uBufLen) {
        return (dwSize);
    }

    uMaxCand = uBufLen - sizeof(CANDIDATELIST);

    uMaxCand /= sizeof(DWORD) + lstrlen (wCode);
    if (!uMaxCand) {
        // can not even put one string
        return (0);
    }

    lpCandList->dwSize = dwSize;
    lpCandList->dwStyle = IME_CAND_READ;    // candidate having same reading
    lpCandList->dwCount = 0;
    lpCandList->dwSelection = 0;
    lpCandList->dwPageSize = CANDPERPAGE;
    lpCandList->dwOffset[0] = sizeof(CANDIDATELIST) + sizeof(DWORD) *
        (uMaxCand - 1);

     lstrcpy((LPTSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[0]),
              (LPTSTR)wCode);   

     lpCandList->dwCount =(DWORD)ConverList.Candi_Cnt;

        for (i=1;i<lpCandList->dwCount;i++) {
          lpCandList->dwOffset[i] = lpCandList->dwOffset[0]
          +(DWORD)ConverList.Candi_Pos[i+1];

          *(LPTSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[i]-1) = TEXT('\0');

        }


    return (dwSize);
}


#if defined(CROSSREF)
//*******************************************************************
// The parameters are inherited from SelectOneCand
//    CrossReverseConv()
//*******************************************************************

int CrossReverseConv(
    LPINPUTCONTEXT      lpIMC,
    LPCOMPOSITIONSTRING lpCompStr,
    LPPRIVCONTEXT       lpImcP,
    LPCANDIDATELIST     lpCandList)
{
    LPGUIDELINE lpGuideLine;
    UINT uSize=0;

    if (!MBIndex.hRevKL) {
        return 0;
    }


    lpGuideLine = ImmLockIMCC(lpIMC->hGuideLine);

    if (!lpGuideLine) {
        return 0;
    }

    if (lpCompStr->dwResultStrLen != 2/sizeof(TCHAR)) {
        // we only can reverse convert one DBCS character for now
        lpGuideLine->dwLevel = GL_LEVEL_NOGUIDELINE;
        lpGuideLine->dwIndex = GL_ID_UNKNOWN;
    } else {
        TCHAR szStrBuf[4];

         LPCANDIDATELIST     lpRevCandList;

        if(lpImcP->hRevCandList == (HIMCC)NULL){
            //we alloc memory in lpImcP->hRevCandList, for reverse convert
            //result codes; When finish reconvert, should read out this info.
REALLOC:
            lpImcP->hRevCandList = (HIMCC)GlobalAlloc(GHND, sizeof(CANDIDATELIST)+1*sizeof(DWORD)+MAXCODE*sizeof(TCHAR)+1);
            if (lpImcP->hRevCandList == (HIMCC)NULL) {
                return 0 ;
            }
               lpRevCandList = (LPCANDIDATELIST)GlobalLock((HGLOBAL)lpImcP->hRevCandList);
            if (lpRevCandList == NULL) {
                return 0 ;
            }
           }else{
               lpRevCandList = (LPCANDIDATELIST)GlobalLock((HGLOBAL)lpImcP->hRevCandList);
               if (lpRevCandList == NULL) {
                goto REALLOC;
               }
        }

        *(LPUNAWORD)szStrBuf = *(LPUNAWORD)((LPBYTE)lpCompStr + lpCompStr->dwResultStrOffset);
        szStrBuf[2/sizeof(TCHAR)] = TEXT('\0');

        memset(lpRevCandList, 0, sizeof(CANDIDATELIST)+1*sizeof(DWORD)+MAXCODE*sizeof(TCHAR)+1);
        lpRevCandList->dwSize = sizeof(CANDIDATELIST)+1*sizeof(DWORD)+MAXCODE*sizeof(TCHAR)+1;

        uSize = ImmGetConversionList(MBIndex.hRevKL, (HIMC)NULL, szStrBuf,
            (LPCANDIDATELIST)lpRevCandList, 
            lpRevCandList->dwSize, GCL_REVERSECONVERSION);

        GlobalUnlock((HGLOBAL)lpImcP->hRevCandList);
        

        if (uSize) {
            if (lpImcP->fdwImeMsg & MSG_ALREADY_START) {
                lpImcP->fdwImeMsg &= ~(MSG_END_COMPOSITION|
                    MSG_START_COMPOSITION);
            } else {
                lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg|
                    MSG_START_COMPOSITION) & ~(MSG_END_COMPOSITION);
            }
        } else {
            GlobalFree((HGLOBAL)lpImcP->hRevCandList);
            lpImcP->hRevCandList = (HIMCC)NULL; 
        }
    }

    ImmUnlockIMCC(lpIMC->hGuideLine);
    //CHP 
    //We need to know the result.
    return uSize;
}
#endif //CROSSREF



/**********************************************************************/
/* ReverseConversion()                                                */
/**********************************************************************/
UINT PASCAL ReverseConversion(

    HIMCC            hPrivate,
    LPCTSTR         lpszSrc,
    LPCANDIDATELIST lpCandList,
    UINT            uBufLen)
{
    LPTSTR        wCode;
    UINT        uMaxCand;
    DWORD       dwSize;


    wCode = ConverList.szInBuffer;

    ConverList.szSelectBuffer[0] =TEXT('\0');
    ConverList.szInBuffer[0]     =TEXT('\0');
    ConverList.Candi_Cnt         =0;
    ConverList.Candi_Pos[0]      =TEXT('\0');

    dwSize =                
        // header length
        sizeof(CANDIDATELIST) +
        // candidate string pointers
        sizeof(DWORD) +
        // string plus NULL terminator
        MAXCODE*sizeof(TCHAR);


    if (!uBufLen) {
        return (dwSize);
    }

    if(lpszSrc ==NULL){
        return (0);
    }

    if (!Conversion (hPrivate,lpszSrc,1)) {
        return (0);
    }
    uMaxCand = uBufLen - sizeof(CANDIDATELIST);

    uMaxCand /= sizeof(DWORD) + lstrlen (wCode);
    if (!uMaxCand) {
        // can not even put one string
        return (0);
    }

    lpCandList->dwSize = dwSize;
    lpCandList->dwStyle = IME_CAND_READ;    // candidate having same reading
    lpCandList->dwCount = 1;
    lpCandList->dwSelection = 0;
    lpCandList->dwPageSize = CANDPERPAGE;
    lpCandList->dwOffset[0] = sizeof(CANDIDATELIST) + sizeof(DWORD) *
        (uMaxCand - 1);

    lstrcpy((LPTSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[0]),
              (LPTSTR)wCode);   

    return (dwSize);

}

/**********************************************************************/
/* ImeConversionList()                                                */
/**********************************************************************/
DWORD WINAPI ImeConversionList(
    HIMC            hIMC,
    LPCTSTR         lpszSrc,
    LPCANDIDATELIST lpCandList,
    DWORD           dwBufLen,
    UINT            uFlag)
{


    if (!dwBufLen) {            
    } else if (!lpszSrc) {
        return (0);
    } else if (!*lpszSrc) {
        return (0);
    } else if (!lpCandList) {
        return (0);
    } else if (dwBufLen <= sizeof(CANDIDATELIST)) {
        // buffer size can not even put the header information
        return (0);
    } else {
    }


    switch (uFlag) {

    case GCL_CONVERSION:
        return ForwordConversion(hIMC,lpszSrc, lpCandList, dwBufLen);
        break;

    case GCL_REVERSECONVERSION:
        if (!dwBufLen) {
            return ReverseConversion(NULL,0, lpCandList, dwBufLen);
        } else { 
 
           DWORD fRet=0;
           HIMCC hPrivate;

           hPrivate = (HIMCC)ImmCreateIMCC(sizeof(PRIVCONTEXT));
           if(hPrivate == (HIMCC)NULL){
               return 0;
           }
           StartEngine(hPrivate);
        
           fRet = ReverseConversion(hPrivate,lpszSrc, lpCandList, dwBufLen);

           EndEngine(hPrivate);
           ImmDestroyIMCC(hPrivate);
           return fRet;
        }
        break;

    default:
        return (0);
        break;
    }
}

/**********************************************************************/
/* ImeDestroy()                                                       */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL WINAPI ImeDestroy(         // this dll is unloaded
    UINT uReserved)
{
    if (uReserved) {
        return (FALSE);
    }

    return (TRUE);
}

/**********************************************************************/
/* ImeEscape()                                                        */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
#define IME_INPUTKEYTOSEQUENCE  0x22

LRESULT WINAPI ImeEscape(       // escape function of IMEs
    HIMC   hIMC,
    UINT   uSubFunc,
    LPVOID lpData)
{
    LRESULT lRet;

    switch (uSubFunc) {
    case IME_ESC_QUERY_SUPPORT:
        if (lpData == NULL)
            return FALSE;

        switch (*(LPUINT)lpData) {
        case IME_ESC_QUERY_SUPPORT:
#ifdef     EUDC
        case IME_ESC_GET_EUDC_DICTIONARY:
        case IME_ESC_SET_EUDC_DICTIONARY:
#endif    //EUDC
        case IME_ESC_SEQUENCE_TO_INTERNAL:
        case IME_ESC_MAX_KEY:
        case IME_ESC_IME_NAME:
        case IME_ESC_GETHELPFILENAME:
                               return (TRUE);
        default:
                               return (FALSE);
        }
        break;
    case IME_ESC_SEQUENCE_TO_INTERNAL:
                  if (!lpData || (*(LPBYTE)lpData) == '\0') {
                     return (FALSE);
                  }

                  lRet = *(LPWORD)lpData;
                  return (lRet);

#ifdef     EUDC
    case IME_ESC_GET_EUDC_DICTIONARY:
                  if (!lpData) {
                     return (FALSE);
                  }

                  if (MBIndex.EUDCData.szEudcDictName[0] == TEXT('\0')) {        
                     *(LPTSTR)lpData = TEXT('\0');
                     return(TRUE);
                  } else {
                     lstrcpy((LPTSTR)lpData,MBIndex.EUDCData.szEudcDictName);
                     return TRUE;
                  }    
 
    case IME_ESC_SET_EUDC_DICTIONARY:
                  return TRUE;
#endif    //EUDC
    case IME_ESC_MAX_KEY:
#ifdef EUDC
         {
            TCHAR          szFullFileName[MAX_PATH], szFileName[MAX_PATH];
            unsigned int   cb;

            cb = MAX_PATH;

            if  (lpImeL->nMaxKey > EUDC_MAX_READING) {
                GetModuleFileName(NULL,szFullFileName ,cb);
                GetFileTitle(szFullFileName, szFileName, (WORD)cb);
            
#ifdef UNICODE
                // Compare first 8 chars only
                if (_wcsnicmp(szFileName,TEXT("EUDCEDIT.EXE"),8)) 
#else
                if (_strnicmp(szFileName,"EUDCEDIT.EXE",8)) 
#endif 
                   return (lpImeL->nMaxKey);
                else 
                   return EUDC_MAX_READING;
            } else {
                return (lpImeL->nMaxKey);
            }            
        }
#else
        return (lpImeL->nMaxKey);
#endif //EUDC

    case IME_ESC_IME_NAME:
   
            if ( lpData == NULL ) 
               return FALSE;

            lstrcpy(lpData,MBIndex.MBDesc[0].szName);
            return (TRUE);

    case IME_ESC_GETHELPFILENAME :
         {
           TCHAR szIMEGUDHlpName[MAX_PATH];
           int iLen;

           if (lpData == NULL )
              return FALSE;
   
           szIMEGUDHlpName[0] = 0;
           GetWindowsDirectory((LPTSTR)szIMEGUDHlpName, MAX_PATH);
           lstrcat((LPTSTR)szIMEGUDHlpName, TEXT("\\HELP\\"));
           lstrcat((LPTSTR)szIMEGUDHlpName, (LPTSTR)szImeMBFileName);
           iLen = lstrlen(szIMEGUDHlpName);
           szIMEGUDHlpName[iLen-3] = 0;
           lstrcat((LPTSTR)szIMEGUDHlpName, TEXT(".CHM"));

           lstrcpy(lpData, szIMEGUDHlpName);

           return TRUE;

         }      

    default:
        return (FALSE);
    }

    return (lRet);
}

/**********************************************************************/
/* InitCompStr()                                                      */
/**********************************************************************/
void PASCAL InitCompStr(                // init setting for composing string
    LPCOMPOSITIONSTRING lpCompStr)
{
    if (!lpCompStr) {
        return;
    }

    lpCompStr->dwCompReadAttrLen = 0;
    lpCompStr->dwCompReadClauseLen = 0;
    lpCompStr->dwCompReadStrLen = 0;

    lpCompStr->dwCompAttrLen = 0;
    lpCompStr->dwCompClauseLen = 0;
    lpCompStr->dwCompStrLen = 0;

    lpCompStr->dwCursorPos = 0;
    lpCompStr->dwDeltaStart = 0;

    lpCompStr->dwResultReadClauseLen = 0;
    lpCompStr->dwResultReadStrLen = 0;

    lpCompStr->dwResultClauseLen = 0;
    lpCompStr->dwResultStrLen = 0;

    return;
}

/**********************************************************************/
/* ClearCompStr()                                                     */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL PASCAL ClearCompStr(
    LPINPUTCONTEXT lpIMC)
{
    HIMCC               hMem;
    LPCOMPOSITIONSTRING lpCompStr;
    DWORD               dwSize;

    if(!lpIMC) {
        return (FALSE);
    }

    dwSize =
        // header length
        sizeof(COMPOSITIONSTRING) +
        // composition reading attribute plus NULL terminator
        lpImeL->nMaxKey * sizeof(BYTE) + sizeof(BYTE) +
        // composition reading clause
        sizeof(DWORD) + sizeof(DWORD) +
        // composition reading string plus NULL terminator
        lpImeL->nMaxKey * sizeof(WORD) + sizeof(WORD) +
        // result reading clause
        sizeof(DWORD) + sizeof(DWORD) +
        // result reading string plus NULL terminateor
        lpImeL->nMaxKey * sizeof(WORD) + sizeof(WORD) +
        // result clause
        sizeof(DWORD) + sizeof(DWORD) +
        // result string plus NULL terminateor
        MAXSTRLEN * sizeof(WORD) + sizeof(WORD);

    if (!lpIMC->hCompStr) {
        // it maybe free by other IME, init it
        lpIMC->hCompStr = ImmCreateIMCC(dwSize);
    } else if (hMem = ImmReSizeIMCC(lpIMC->hCompStr, dwSize)) {
        lpIMC->hCompStr = hMem;
    } else {
        ImmDestroyIMCC(lpIMC->hCompStr);
        lpIMC->hCompStr = ImmCreateIMCC(dwSize);
        return (FALSE);
    }

    if (!lpIMC->hCompStr) {
        return (FALSE);
    }

    lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
    if (!lpCompStr) {
        ImmDestroyIMCC(lpIMC->hCompStr);
        lpIMC->hCompStr = ImmCreateIMCC(dwSize);
        return (FALSE);
    }

    lpCompStr->dwSize = dwSize;

     // 1. composition (reading) string - simple IME
     // 2. result reading string
     // 3. result string

    lpCompStr->dwCompReadAttrLen = 0;
    lpCompStr->dwCompReadAttrOffset = sizeof(COMPOSITIONSTRING);
    lpCompStr->dwCompReadClauseLen = 0;
    lpCompStr->dwCompReadClauseOffset = lpCompStr->dwCompReadAttrOffset +
        lpImeL->nMaxKey * sizeof(TCHAR) + sizeof(TCHAR);
    lpCompStr->dwCompReadStrLen = 0;
    lpCompStr->dwCompReadStrOffset = lpCompStr->dwCompReadClauseOffset +
        sizeof(DWORD) + sizeof(DWORD);

    // composition string is the same with composition reading string 
    // for simple IMEs
    lpCompStr->dwCompAttrLen = 0;
    lpCompStr->dwCompAttrOffset = lpCompStr->dwCompReadAttrOffset;
    lpCompStr->dwCompClauseLen = 0;
    lpCompStr->dwCompClauseOffset = lpCompStr->dwCompReadClauseOffset;
    lpCompStr->dwCompStrLen = 0;
    lpCompStr->dwCompStrOffset = lpCompStr->dwCompReadStrOffset;

    lpCompStr->dwCursorPos = 0;
    lpCompStr->dwDeltaStart = 0;

    lpCompStr->dwResultReadClauseLen = 0;
    lpCompStr->dwResultReadClauseOffset = lpCompStr->dwCompStrOffset +
        lpImeL->nMaxKey * sizeof(WORD) + sizeof(WORD);
    lpCompStr->dwResultReadStrLen = 0;
    lpCompStr->dwResultReadStrOffset = lpCompStr->dwResultReadClauseOffset +
        sizeof(DWORD) + sizeof(DWORD);

    lpCompStr->dwResultClauseLen = 0;
    lpCompStr->dwResultClauseOffset = lpCompStr->dwResultReadStrOffset +
        lpImeL->nMaxKey * sizeof(WORD) + sizeof(WORD);
    lpCompStr->dwResultStrOffset = 0;
    lpCompStr->dwResultStrOffset = lpCompStr->dwResultClauseOffset +
        sizeof(DWORD) + sizeof(DWORD);

    GlobalUnlock((HGLOBAL)lpIMC->hCompStr);
    return (TRUE);
}

/**********************************************************************/
/* ClearCand()                                                        */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL PASCAL ClearCand(
    LPINPUTCONTEXT lpIMC)
{
    HIMCC           hMem;
    LPCANDIDATEINFO lpCandInfo;
    LPCANDIDATELIST lpCandList;
    DWORD           dwSize =
        // header length
        sizeof(CANDIDATEINFO) + sizeof(CANDIDATELIST) +
        // candidate string pointers
        sizeof(DWORD) * (MAXCAND) +
        // string plus NULL terminator
        (sizeof(WORD) * MAXSTRLEN + sizeof(WORD)) * MAXCAND;

    if (!lpIMC) {
        return (FALSE);
    }

    if (!lpIMC->hCandInfo) {
        // it maybe free by other IME, init it
        lpIMC->hCandInfo = ImmCreateIMCC(dwSize);
    } else if (hMem = ImmReSizeIMCC(lpIMC->hCandInfo, dwSize)) {
        lpIMC->hCandInfo = hMem;
    } else {
        ImmDestroyIMCC(lpIMC->hCandInfo);
        lpIMC->hCandInfo = ImmCreateIMCC(dwSize);
        return (FALSE);
    }

    if (!lpIMC->hCandInfo) {
        return (FALSE);
    } 

    lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo);
    if (!lpCandInfo) {
        ImmDestroyIMCC(lpIMC->hCandInfo);
        lpIMC->hCandInfo = ImmCreateIMCC(dwSize);
        return (FALSE);
    }

    // ordering of strings are
    // buffer size
    lpCandInfo->dwSize = dwSize;
    lpCandInfo->dwCount = 0;
    lpCandInfo->dwOffset[0] = sizeof(CANDIDATEINFO);
    lpCandList = (LPCANDIDATELIST)((LPBYTE)lpCandInfo +
        lpCandInfo->dwOffset[0]);
    // whole candidate info size - header
    lpCandList->dwSize = lpCandInfo->dwSize - sizeof(CANDIDATEINFO);
    lpCandList->dwStyle = IME_CAND_READ;
    lpCandList->dwCount = 0;
    lpCandList->dwSelection = 0;
    lpCandList->dwPageSize = CANDPERPAGE;
    lpCandList->dwOffset[0] = sizeof(CANDIDATELIST) +
        sizeof(DWORD) * (MAXCAND - 1);

    ImmUnlockIMCC(lpIMC->hCandInfo);
    return (TRUE);
}

/**********************************************************************/
/* ClearGuideLine()                                                   */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL PASCAL ClearGuideLine(
    LPINPUTCONTEXT lpIMC)
{
    HIMCC       hMem;
    LPGUIDELINE lpGuideLine;
    DWORD       dwSize = sizeof(GUIDELINE) + sImeG.cbStatusErr;

    if (!lpIMC->hGuideLine) {
        // it maybe free by IME
        lpIMC->hGuideLine = ImmCreateIMCC(dwSize);
    } else if (hMem = ImmReSizeIMCC(lpIMC->hGuideLine, dwSize)) {
        lpIMC->hGuideLine = hMem;
    } else {
        ImmDestroyIMCC(lpIMC->hGuideLine);
        lpIMC->hGuideLine = ImmCreateIMCC(dwSize);
    }

    lpGuideLine = (LPGUIDELINE)ImmLockIMCC(lpIMC->hGuideLine);
    if (!lpGuideLine) {
        return (FALSE);
    }

    lpGuideLine->dwSize = dwSize;
    lpGuideLine->dwLevel = GL_LEVEL_NOGUIDELINE;
    lpGuideLine->dwIndex = GL_ID_UNKNOWN;
    lpGuideLine->dwStrLen = 0;
    lpGuideLine->dwStrOffset = sizeof(GUIDELINE);

    CopyMemory((LPBYTE)lpGuideLine + lpGuideLine->dwStrOffset,
        sImeG.szStatusErr, sImeG.cbStatusErr);

    ImmUnlockIMCC(lpIMC->hGuideLine);

    return (TRUE);
}

/**********************************************************************/
/* InitContext()                                                      */
/**********************************************************************/
void PASCAL InitContext(
    LPINPUTCONTEXT lpIMC)
{
    if (lpIMC->fdwInit & INIT_STATUSWNDPOS) {
    } else if (!lpIMC->hWnd) {
    } else {
#if 0 // MultiMonitor support
        POINT ptWnd;

        // 10.10 modify
        //ptWnd.x = sImeG.rcWorkArea.left;
        //ptWnd.y = sImeG.rcWorkArea.top;
        ptWnd.x = 0;
        ptWnd.y = 0;
        ClientToScreen(lpIMC->hWnd, &ptWnd);

        if (ptWnd.x < sImeG.rcWorkArea.left) {
            lpIMC->ptStatusWndPos.x = sImeG.rcWorkArea.left;
        } else if (ptWnd.x + sImeG.xStatusWi > sImeG.rcWorkArea.right) {
            lpIMC->ptStatusWndPos.x = sImeG.rcWorkArea.right -
                sImeG.xStatusWi;
        } else {
            lpIMC->ptStatusWndPos.x = ptWnd.x;
        }

        lpIMC->ptStatusWndPos.y = sImeG.rcWorkArea.bottom -
            sImeG.yStatusHi;

#else
        RECT rcWorkArea;

        rcWorkArea = ImeMonitorWorkAreaFromWindow(lpIMC->hWnd);

        lpIMC->ptStatusWndPos.x = rcWorkArea.left;

        lpIMC->ptStatusWndPos.y = rcWorkArea.bottom -
            sImeG.yStatusHi;
#endif
        lpIMC->fdwInit |= INIT_STATUSWNDPOS;
    }

    if (!(lpIMC->fdwInit & INIT_COMPFORM)) {
        lpIMC->cfCompForm.dwStyle = CFS_DEFAULT;
    }

    if (lpIMC->cfCompForm.dwStyle != CFS_DEFAULT) {
    } else if (!lpIMC->hWnd) {
    } else {
        POINT ptWnd;

        ptWnd = lpImeL->ptDefComp;
        ScreenToClient(lpIMC->hWnd, &ptWnd);
        lpIMC->cfCompForm.dwStyle = CFS_DEFAULT;
        lpIMC->cfCompForm.ptCurrentPos = ptWnd;
        lpIMC->fdwInit |= INIT_COMPFORM;
    }

    return;
}


/**********************************************************************/
/* Select()                                                           */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL PASCAL Select(
    HIMC           hIMC,
    LPINPUTCONTEXT lpIMC,
    BOOL           fSelect)
{
    LPPRIVCONTEXT  lpImcP;

    if (fSelect) {

        if (!ClearCompStr(lpIMC))
            return FALSE;

        if (!ClearCand(lpIMC))
            return FALSE;

        ClearGuideLine(lpIMC);
    }

    if (lpIMC->cfCandForm[0].dwIndex != 0)
        lpIMC->cfCandForm[0].dwStyle = CFS_DEFAULT;

    // We add this hack for switching from other IMEs, this IME has a bug.
    // Before this bug fixed in this IME, it depends on this hack.
    if (lpIMC->cfCandForm[0].dwStyle == CFS_DEFAULT) {
        lpIMC->cfCandForm[0].dwIndex = (DWORD)-1;
    }

    if (!lpIMC->hPrivate)
        return FALSE;

    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    if (!lpImcP)
        return FALSE;

    if (fSelect) {

        static BOOL  bFirstTimeCallHere = TRUE;
        //
        // Init. ime character
        //
        InitImeCharac(0);

        InterlockedIncrement( &lLock );

        if ( bFirstTimeCallHere == TRUE )  {

            GetCurrentUserEMBPath( );
            bFirstTimeCallHere = FALSE;
        }

        InterlockedDecrement( &lLock );

        //
        // init fields of hPrivate
        //
        lpImcP->iImeState = CST_INIT;
        lpImcP->fdwImeMsg = (DWORD) 0;
        lpImcP->dwCompChar = (DWORD) 0;
        lpImcP->fdwGcsFlag = (DWORD) 0;
        lpImcP->uSYHFlg = 0x00000000;
        lpImcP->uDYHFlg = 0x00000000;
        lpImcP->uDSMHCount = 0x00000000;
        lpImcP->uDSMHFlg = 0x00000000;
        lpImcP->iActMBIndex = 0;
        lstrcpy(lpImcP->MB_Name, HMapTab[0].MB_Name);

        lpImcP->PrivateArea.Comp_Status.dwSTLX = 0;
        lpImcP->PrivateArea.Comp_Status.dwSTMULCODE = 0;
        lpImcP->PrivateArea.Comp_Status.dwInvalid = 0;
        lpImcP->PrivateArea.Comp_Status.OnLineCreWord = 0;

        //
        // Set IME properties
        //
        lpImcP->PrivateArea.Comp_Status.dwPPTLX = MBIndex.IMEChara[lpImcP->iActMBIndex].IC_LX;
        lpImcP->PrivateArea.Comp_Status.dwPPCZ = MBIndex.IMEChara[lpImcP->iActMBIndex].IC_CZ;
        lpImcP->PrivateArea.Comp_Status.dwPPTS = MBIndex.IMEChara[lpImcP->iActMBIndex].IC_TS;
        lpImcP->PrivateArea.Comp_Status.dwPPCTS = MBIndex.IMEChara[lpImcP->iActMBIndex].IC_CTC;
        lpImcP->PrivateArea.Comp_Status.dwTraceCusr = MBIndex.IMEChara[lpImcP->iActMBIndex].IC_Trace;
                
        CWCodeStr[0] = 0;
        CWDBCSStr[0] = 0;
        
        lpIMC->fOpen = TRUE;

        if (!(lpIMC->fdwInit & INIT_CONVERSION)) {
            lpIMC->fdwConversion = (lpIMC->fdwConversion & IME_CMODE_SOFTKBD) |
                IME_CMODE_NATIVE;
            lpIMC->fdwInit |= INIT_CONVERSION;
        }

        if (!(lpIMC->fdwInit & INIT_LOGFONT)) {
            HDC hDC;
            HGDIOBJ hSysFont;

            //hSysFont = GetStockObject(SYSTEM_FONT);
            hDC = GetDC(NULL);
            hSysFont = GetCurrentObject(hDC, OBJ_FONT);
            GetObject(hSysFont, sizeof(LOGFONT), &lpIMC->lfFont.A);
            ReleaseDC(NULL, hDC);

            lpIMC->fdwInit |= INIT_LOGFONT;
        }

        InitContext(lpIMC);

        //
        // Set Caps status
        //
        {
            DWORD fdwConversion;
        
            if (GetKeyState(VK_CAPITAL) & 0x01) {

                //
                // Change to alphanumeric mode.
                //
               fdwConversion = lpIMC->fdwConversion &
                        ~(IME_CMODE_NATIVE | IME_CMODE_CHARCODE | IME_CMODE_EUDC);
            } else {

                //
                // Change to native mode
                //
                fdwConversion = (lpIMC->fdwConversion | IME_CMODE_NATIVE) &
                        ~(IME_CMODE_CHARCODE | IME_CMODE_EUDC );
            }

            ImmSetConversionStatus(hIMC, fdwConversion, lpIMC->fdwSentence);
        }

    } else {

        if (lpImeL->hSKMenu) {
            DestroyMenu(lpImeL->hSKMenu);
            lpImeL->hSKMenu = NULL;
        }

        if (lpImeL->hPropMenu) {
            DestroyMenu(lpImeL->hPropMenu);
            lpImeL->hPropMenu = NULL;
        }

        if (lpImeL->hObjImeMenu) {
            DestroyMenu(lpImeL->hObjImeMenu);
            lpImeL->hObjImeMenu = NULL;
        }

        if (hCrtDlg) {
            SendMessage(hCrtDlg, WM_CLOSE, (WPARAM)NULL, (LPARAM)NULL);
            hCrtDlg = NULL;
        }
    }

    //
    // Start or end MB engine
    //
    if (fSelect) {
        StartEngine(lpIMC->hPrivate);
        SaTC_Trace = MBIndex.IMEChara[0].IC_Trace;
    } else {
        EndEngine(lpIMC->hPrivate);
    }

    ImmUnlockIMCC(lpIMC->hPrivate);

    return (TRUE);
}

/**********************************************************************/
/* ImeSelect()                                                        */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL WINAPI ImeSelect(
    HIMC hIMC,
    BOOL fSelect)
{
    LPINPUTCONTEXT lpIMC;
    BOOL           fRet;


    if (!hIMC) {
        return (FALSE);
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return (FALSE);
    }

    fRet = Select(hIMC, lpIMC, fSelect);

    ImmUnlockIMC(hIMC);

    return (fRet);
}

/**********************************************************************/
/* ImeSetActiveContext()                                              */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL WINAPI ImeSetActiveContext(
    HIMC        hIMC,
    BOOL        fOn)
{
    if (!fOn) {
    } else if (!hIMC) {
    } else {
        LPINPUTCONTEXT lpIMC;
        LPPRIVCONTEXT  lpImcP;

        lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
        if (!lpIMC) {
            goto SetActEnd;
        }

        lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
        if (!lpImcP) {
            goto SetActUnlockIMC;
        }

        InitContext(lpIMC);

        ImmUnlockIMCC(lpIMC->hPrivate);
SetActUnlockIMC:
        ImmUnlockIMC(hIMC);

SetActEnd:
        return (TRUE);
    }

    return (TRUE);
}

/**********************************************************************/
//OpenReg_PathSetup(HKEY *phKey);
/**********************************************************************/
LONG OpenReg_PathSetup(HKEY *phKey)
{
    return RegOpenKeyEx (HKEY_CURRENT_USER,
                         REGSTR_PATH_SETUP,
                         0,
                         KEY_ENUMERATE_SUB_KEYS |
                         KEY_EXECUTE |
                         KEY_QUERY_VALUE,
                         phKey);
}

/**********************************************************************/
//LONG OpenReg_User(HKEY hKey,        // handle of open key 
//                LPCTSTR  lpszSubKey,    // address of name of subkey to open 
//                PHKEY  phkResult);     // address of handle of open key 
/**********************************************************************/
LONG OpenReg_User(HKEY hKey,            // handle of open key 
                  LPCTSTR  lpszSubKey,    // address of name of subkey to open 
                  PHKEY  phkResult)     // address of handle of open key 
{
    return RegOpenKeyEx (hKey,
                         lpszSubKey,
                         0,
                         KEY_ENUMERATE_SUB_KEYS |
                         KEY_EXECUTE |
                         KEY_QUERY_VALUE|KEY_SET_VALUE,       
                         phkResult);
}

VOID InfoMessage(HANDLE hWnd,WORD wMsgID)
{
   TCHAR   szStr[256];

   LoadString(hInst,wMsgID,szStr, sizeof(szStr)/sizeof(TCHAR));
   MessageBox(hWnd,szStr,szWarnTitle,MB_ICONINFORMATION|MB_OK);
}

VOID FatalMessage(HANDLE hWnd,WORD wMsgID)
{
    TCHAR   szStr[256];

    LoadString(hInst,wMsgID,szStr, sizeof(szStr)/sizeof(TCHAR));
    MessageBox(hWnd,szStr,szErrorTitle,MB_ICONSTOP|MB_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntime\immsec.h ===
/*************************************************
 *  immsec.h                                     *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

PSECURITY_ATTRIBUTES CreateSecurityAttributes( );
VOID FreeSecurityAttributes( PSECURITY_ATTRIBUTES psa);
BOOL IsNT();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntime\privcon.h ===
/*************************************************
 *  privconv.h                                   *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

// PRIVATE CONTEXT STRU
typedef struct _tagPRIVCONTEXT {// IME private data for each context
    int         iImeState;      // the composition state - input, choose, or
    BOOL        fdwImeMsg;      // what messages should be generated
    DWORD       dwCompChar;     // wParam of WM_IME_COMPOSITION
    DWORD       fdwGcsFlag;     // lParam for WM_IME_COMPOSITION
// Old Candidate List Count
    DWORD        dwOldCandCnt;
// Symbol pair Flag
    UINT        uSYHFlg;
    UINT        uDYHFlg;
    UINT        uDSMHCount;
    UINT        uDSMHFlg;
// mb file name
    int         iActMBIndex;
    TCHAR        MB_Name[40];
    TCHAR        EMB_Name[40];
// input engine data
    PRIVATEAREA PrivateArea;
#ifdef CROSSREF
    HIMCC        hRevCandList;    // memory for reconsion result
#endif //CROSSREF
} PRIVCONTEXT;

typedef PRIVCONTEXT      *PPRIVCONTEXT;
typedef PRIVCONTEXT NEAR *NPPRIVCONTEXT;
typedef PRIVCONTEXT FAR  *LPPRIVCONTEXT;

typedef struct tagMBDesc {
    TCHAR szName[NAMESIZE]; 
    WORD  wMaxCodes;
    WORD  wNumCodes;
    TCHAR szUsedCode[MAXUSEDCODES];
    BYTE  byMaxElement;
    TCHAR cWildChar;
    WORD  wNumRulers;
} MBDESC;

typedef MBDESC        *PMBDESC;
typedef MBDESC NEAR *NPMBDESC;
typedef MBDESC FAR  *LPMBDESC;

typedef struct tagIMEChara {
    DWORD  IC_LX; 
    DWORD  IC_CZ;
    DWORD  IC_TS;
    DWORD  IC_CTC;
    DWORD  IC_INSSPC;
    DWORD  IC_Space;
    DWORD  IC_Enter;
    DWORD  IC_Trace;
    //CHP
    DWORD  IC_FCSR;
    DWORD  IC_FCTS;
#if defined(COMBO_IME)
    DWORD  IC_GB;
#endif
} IMECHARA;

typedef IMECHARA      *PIMECHARA;
typedef IMECHARA NEAR *NPIMECHARA;
typedef IMECHARA FAR  *LPIMECHARA;

#ifdef EUDC
typedef struct tagEUDCDATA {
    TCHAR        szEudcDictName[MAX_PATH];
    TCHAR        szEudcMapFileName[MAX_PATH];
}EUDCDATA;
typedef EUDCDATA      *PEUDCDATA;
typedef EUDCDATA NEAR *NPEUDCDATA;
typedef EUDCDATA FAR  *LPEUDCDATA;

#endif //EUDC

typedef struct tagMBIndex {
    int      MBNums;
    MBDESC   MBDesc[MAXMBNUMS];
    IMECHARA IMEChara[MAXMBNUMS];
    TCHAR    ObjImeKey[MAXMBNUMS][MAXSTRLEN];
#ifdef EUDC
    EUDCDATA EUDCData;
#endif //EUDC
#if defined(CROSSREF)
// reverse conversion
    HKL      hRevKL;         // the HKL of reverse mapping IME
    DWORD    nRevMaxKey;
#endif //CROSSREF    
    // CHP
    int      IsFussyCharFlag; //fussy char flag

} MBINDEX;

typedef MBINDEX         *PMBINDEX;
typedef MBINDEX NEAR *NPMBINDEX;
typedef MBINDEX FAR  *LPMBINDEX;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntime\notify.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    NOTIFY.C
    
++*/

#include <windows.h>
#include <immdev.h>
#include <imedefs.h>

/**********************************************************************/
/* GenerateMessage()                                                  */
/**********************************************************************/
void PASCAL GenerateMessage(
    HIMC           hIMC,
    LPINPUTCONTEXT lpIMC,
    LPPRIVCONTEXT  lpImcP)
{

    if (!hIMC) {
        return;
    } else if (!lpIMC) {
        return;
    } else if (!lpImcP) {
        return;
    } else if (lpImcP->fdwImeMsg & MSG_IN_IMETOASCIIEX) {
        return;
    } else {
    }

    lpIMC->dwNumMsgBuf += TranslateImeMessage(NULL, lpIMC, lpImcP);

    lpImcP->fdwImeMsg &= (MSG_ALREADY_OPEN|MSG_ALREADY_START);
    lpImcP->fdwGcsFlag = 0;

    ImmGenerateMessage(hIMC);
    return;
}

/**********************************************************************/
/* GenerateImeMessage()                                               */
/**********************************************************************/
void PASCAL GenerateImeMessage(
    HIMC           hIMC,
    LPINPUTCONTEXT lpIMC,
    DWORD          fdwImeMsg)
{
    LPPRIVCONTEXT lpImcP;

    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    if (!lpImcP) {
        return;
    }

    lpImcP->fdwImeMsg |= fdwImeMsg;

    if (fdwImeMsg & MSG_CLOSE_CANDIDATE) {
        lpImcP->fdwImeMsg &= ~(MSG_OPEN_CANDIDATE|MSG_CHANGE_CANDIDATE);
    } else if (fdwImeMsg & (MSG_OPEN_CANDIDATE|MSG_CHANGE_CANDIDATE)) {
        lpImcP->fdwImeMsg &= ~(MSG_CLOSE_CANDIDATE);
    } else {
    }

    if (fdwImeMsg & MSG_END_COMPOSITION) {
        lpImcP->fdwImeMsg &= ~(MSG_START_COMPOSITION);
    } else if (fdwImeMsg & MSG_START_COMPOSITION) {
        lpImcP->fdwImeMsg &= ~(MSG_END_COMPOSITION);
    } else {
    }

    GenerateMessage(hIMC, lpIMC, lpImcP);

    ImmUnlockIMCC(lpIMC->hPrivate);

    return;
}

/**********************************************************************/
/* CompCancel()                                                       */
/**********************************************************************/
void PASCAL CompCancel(
    HIMC            hIMC,
    LPINPUTCONTEXT  lpIMC)
{
    LPPRIVCONTEXT lpImcP;

    if (!lpIMC->hPrivate) {
        return;
    }

    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    if (!lpImcP) {
        return;
    }

    lpImcP->fdwGcsFlag = (DWORD) 0;

    if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
        CandEscapeKey(lpIMC, lpImcP);
    } else if (lpImcP->fdwImeMsg & MSG_ALREADY_START) {
        LPCOMPOSITIONSTRING lpCompStr;
        LPGUIDELINE         lpGuideLine;

        lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
        if(!lpCompStr){
            return ;
        }

        lpGuideLine = (LPGUIDELINE)ImmLockIMCC(lpIMC->hGuideLine);
        if(!lpGuideLine){
            return ;
        }

        CompEscapeKey(lpIMC, lpCompStr, lpGuideLine, lpImcP);

        if (lpGuideLine) {
            ImmUnlockIMCC(lpIMC->hGuideLine);
        }
        if (lpCompStr) {
            ImmUnlockIMCC(lpIMC->hCompStr);
        }
    } else {
        ImmUnlockIMCC(lpIMC->hPrivate);
        return;
    }

    GenerateMessage(hIMC, lpIMC, lpImcP);

    ImmUnlockIMCC(lpIMC->hPrivate);

    return;
}

/**********************************************************************/
/* SetCompForwordConversion()                                                       */
/**********************************************************************/

int PASCAL SetCompForwordConversion(
    HIMC            hIMC,
    LPCTSTR         lpszSrc,
    LPCANDIDATELIST lpCandList)

{
    DWORD           i;
    LPTSTR          wCode;
    LPINPUTCONTEXT lpIMC;

    wCode = ConverList.szSelectBuffer;
    // ConverList is Globle Var.
    ConverList.szSelectBuffer[0] =TEXT('\0');
    ConverList.szInBuffer[0]     =TEXT('\0');
    ConverList.Candi_Cnt         =0;
    ConverList.Candi_Pos[0]      =TEXT('\0');
    if (!hIMC) {
        return (-1);
    }
    
    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);

    if (!lpIMC) {
        return (-1);
    }

    if (!Conversion (lpIMC->hPrivate,lpszSrc,0)) {
    return (-1);
    }
    ConverList.szSelectBuffer [lstrlen(ConverList.szSelectBuffer)-1]
    =TEXT('\0');
    // Because it's space witch before the last char.

    lpCandList->dwCount = 0;

     lstrcpy((LPTSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[0]),
              (LPTSTR)wCode);   

     lpCandList->dwCount =(DWORD)ConverList.Candi_Cnt;

     //Selectbuf to candidatelist

        for (i=1;i<lpCandList->dwCount;i++) {
          lpCandList->dwOffset[i] = lpCandList->dwOffset[0]
          +(DWORD)ConverList.Candi_Pos[i+1];

          *((LPTSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[i])-1) = TEXT('\0');

        }

    return (i);
}
/**********************************************************************/
/* SetString()                                                        */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL PASCAL SetString(
    HIMC                hIMC,
    LPINPUTCONTEXT      lpIMC,
    LPCOMPOSITIONSTRING lpCompStr,
    LPPRIVCONTEXT       lpImcP,
    LPTSTR               lpszRead,
    DWORD               dwReadLen)
{
    LPCANDIDATELIST lpCandList;
    LPCANDIDATEINFO lpCandInfo;
    LPGUIDELINE lpGuideLine;

    DWORD       i;


    // For Windows NT Unicode,
    // dwCompReadStrLen is the number of the Unicode characters(Not in Bytes)
    // But the above the Parameter dwReadLen is in Bytes.
    // the length of the attribute information is
    // the same as the length in Unicode character counts.
    // Each attribute byte corresponds to each Unicode character of
    // the string.

    //
    // convert from byte count to the string length
    dwReadLen = dwReadLen / sizeof(TCHAR);


    if (dwReadLen > MBIndex.MBDesc[0].wMaxCodes) {
        return (FALSE);
    }
    lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo);

    if (!lpCandInfo) {
        return (-1);
    }
                                                 
    // get lpCandList and init dwCount & dwSelection
    lpCandList = (LPCANDIDATELIST)
        ((LPBYTE)lpCandInfo + lpCandInfo->dwOffset[0]);

    InitCompStr(lpCompStr);
    ClearCand(lpIMC);

    lpGuideLine = (LPGUIDELINE)ImmLockIMCC(lpIMC->hGuideLine);
    if (lpGuideLine) {
        ImmUnlockIMCC(lpIMC->hGuideLine);
    }

    CopyMemory((LPBYTE)lpCompStr + lpCompStr->dwCompReadStrOffset, lpszRead,
       dwReadLen * sizeof(TCHAR) + sizeof(TCHAR) );
    CopyMemory((LPBYTE)lpCompStr + lpCompStr->dwCompStrOffset,lpszRead,
       dwReadLen * sizeof(TCHAR) + sizeof(TCHAR) );

    lpCompStr->dwCompReadAttrLen = dwReadLen;
    lpCompStr->dwCompAttrLen = lpCompStr->dwCompReadAttrLen;
    for (i = 0; i < dwReadLen; i++) {   // The IME has converted these chars
        *((LPBYTE)lpCompStr + lpCompStr->dwCompReadAttrOffset + i) =
            ATTR_TARGET_CONVERTED;

    }
    lpCompStr->dwCompReadStrLen = dwReadLen;
    lpCompStr->dwCompStrLen = lpCompStr->dwCompReadStrLen;

    // dlta start from 0;
    lpCompStr->dwDeltaStart = 0;
    // cursor is next to composition string
    lpCompStr->dwCursorPos = lpCompStr->dwCompStrLen;


    lpCompStr->dwResultReadClauseLen = 0;
    lpCompStr->dwResultReadStrLen = 0;
    lpCompStr->dwResultClauseLen = 0;
    lpCompStr->dwResultStrLen = 0;

    // set private input context
    lpImcP->iImeState = CST_INPUT;

    if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
        lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CLOSE_CANDIDATE) &
            ~(MSG_OPEN_CANDIDATE);
    }

    if (!(lpImcP->fdwImeMsg & MSG_ALREADY_START)) {
        lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_START_COMPOSITION) &
            ~(MSG_END_COMPOSITION);
    }

    lpImcP->fdwImeMsg |= MSG_COMPOSITION;
    lpImcP->fdwGcsFlag = GCS_COMPREAD|GCS_COMP|
        GCS_DELTASTART|GCS_CURSORPOS;

    lpImcP->fdwImeMsg |= MSG_GUIDELINE;
   
    if ( lpIMC->fdwConversion & IME_CMODE_EUDC ) {

     // when this API is used by EUDC application to set the Compostion
     // there is no need to handle Candidate window.

        GenerateMessage(hIMC, lpIMC, lpImcP);

        return (TRUE);
    }
    else {
    
     lpCandList->dwCount = 0;
     if((SetCompForwordConversion(hIMC,lpszRead,lpCandList))==-1){
       return FALSE;
     }
     if (lpCandList->dwCount == 1) {

       lstrcpy((LPTSTR)((LPBYTE)lpCompStr + lpCompStr->dwResultStrOffset),
               ConverList.szSelectBuffer);

       // calculate result string length
       lpCompStr->dwResultStrLen = lstrlen(ConverList.szSelectBuffer);

       lpImcP->fdwImeMsg |= MSG_COMPOSITION;
       lpImcP->dwCompChar = (DWORD) 0;
       lpImcP->fdwGcsFlag |= GCS_CURSORPOS|GCS_RESULTREAD|GCS_RESULT;

       if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
          lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CLOSE_CANDIDATE) &
                              ~(MSG_OPEN_CANDIDATE);
       } else {
        lpImcP->fdwImeMsg &= ~(MSG_CLOSE_CANDIDATE|MSG_OPEN_CANDIDATE);
       }

       lpImcP->iImeState = CST_INIT;

     } else if(lpCandList->dwCount > 1) {
        lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg |MSG_OPEN_CANDIDATE ) &
            ~(MSG_CLOSE_CANDIDATE);

     } else if(lpCandList->dwCount == 0) {
        lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg |MSG_CLOSE_CANDIDATE ) &
            ~(MSG_OPEN_CANDIDATE);

     }


     GenerateMessage(hIMC, lpIMC, lpImcP);

     return (TRUE);
   }
}

/**********************************************************************/
/* ImeSetCompositionString()                                          */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL WINAPI ImeSetCompositionString(
    HIMC   hIMC,
    DWORD  dwIndex,
    LPVOID lpComp,
    DWORD  dwCompLen,
    LPVOID lpRead,
    DWORD  dwReadLen)
{

    LPINPUTCONTEXT      lpIMC;
    LPCOMPOSITIONSTRING lpCompStr;
    LPPRIVCONTEXT       lpImcP;
    BOOL                fRet;

    if (!hIMC) {
        return (FALSE);
    }

    // composition string must  == reading string
    // reading is more important
    if (!dwReadLen) {
        dwReadLen = dwCompLen;
    }

    // composition string must  == reading string
    // reading is more important
    if (!lpRead) {
        lpRead = lpComp;
    }

    if (!dwReadLen) {
        lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
        if (!lpIMC) {
            return (FALSE);
        }

        CompCancel(hIMC, lpIMC);
        ImmUnlockIMC(hIMC);
        return (TRUE);
    } else if (!lpRead) {
        return (FALSE);
    } else if (!dwCompLen) {
    } else if (!lpComp) {
    } else if (dwReadLen != dwCompLen) {
        return (FALSE);
    } else if (lpRead == lpComp) {
    } else if (!lstrcmp(lpRead, lpComp)) {
        // composition string must  == reading string
    } else {
        // composition string != reading string
        return (FALSE);
    }

    if (dwIndex != SCS_SETSTR) {
        return (FALSE);
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return (FALSE);
    }

    if (!lpIMC->hCompStr) {
        ImmUnlockIMC(hIMC);
        return (FALSE);
    }

    lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
    if (!lpCompStr) {
        ImmUnlockIMC(hIMC);
        return (FALSE);
    }

    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    if(!lpImcP){
        ImmUnlockIMC(hIMC);
        return (FALSE);
    }

    fRet = SetString(hIMC, lpIMC, lpCompStr, lpImcP, lpRead, dwReadLen);

    ImmUnlockIMCC(lpIMC->hPrivate);
    ImmUnlockIMCC(lpIMC->hCompStr);
    ImmUnlockIMC(hIMC);

    return (fRet);
}

/**********************************************************************/
/* ToggleSoftKbd()                                                    */
/**********************************************************************/
void PASCAL ToggleSoftKbd(
    HIMC            hIMC,
    LPINPUTCONTEXT  lpIMC)
{
    LPPRIVCONTEXT lpImcP;

    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    if (!lpImcP) {
        return;
    }

    lpImcP->fdwImeMsg |= MSG_IMN_UPDATE_SOFTKBD;

    GenerateMessage(hIMC, lpIMC, lpImcP);

    ImmUnlockIMCC(lpIMC->hPrivate);

    return;
}

/**********************************************************************/
/* NotifySelectCand()                                                 */
/**********************************************************************/
void PASCAL NotifySelectCand( // app tell IME that one candidate string is
                              // selected (by mouse or non keyboard action
                              // - for example sound)
    HIMC            hIMC,
    LPINPUTCONTEXT  lpIMC,
    LPCANDIDATEINFO lpCandInfo,
    DWORD           dwIndex,
    DWORD           dwValue)
{
    LPCANDIDATELIST     lpCandList;
    LPCOMPOSITIONSTRING lpCompStr;
    LPPRIVCONTEXT       lpImcP;

    if (!lpCandInfo) {
        return;
    }

    if (dwIndex >= lpCandInfo->dwCount) {
        // wanted candidate list is not created yet!
        return;
    } else if (dwIndex == 0) {
        if (lpIMC->fdwConversion & IME_CMODE_CHARCODE) {
            return;         // not implemented yet
        }
    }

    lpCandList = (LPCANDIDATELIST)
        ((LPBYTE)lpCandInfo + lpCandInfo->dwOffset[0]);

    // the selected value even more than the number of total candidate
    // strings, it is imposible. should be error of app
    if (dwValue >= lpCandList->dwCount) {
        return;
    }

    // app select this candidate string
    lpCandList->dwSelection = dwValue;

    lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
    if(!lpCompStr){
        return ;
    }

    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    if(!lpImcP){
        return ;
    }

    lpImcP->iImeState = CST_CHOOSE;
    Finalize(lpIMC, lpCompStr, lpImcP, (WORD)((dwValue + 1)%10 + 0x30));

    // translate into message buffer
    SelectOneCand(lpIMC, lpCompStr, lpImcP, lpCandList);

    // let app generate those messages in its message loop
    GenerateMessage(hIMC, lpIMC, lpImcP);

    ImmUnlockIMCC(lpIMC->hPrivate);
    ImmUnlockIMCC(lpIMC->hCompStr);

    return;
}

/**********************************************************************/
/* NotifyIME()                                                        */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL WINAPI NotifyIME(
    HIMC        hIMC,
    DWORD       dwAction,
    DWORD       dwIndex,
    DWORD       dwValue)
{
    LPINPUTCONTEXT lpIMC;
    DWORD          fdwImeMsg;
    BOOL           fRet;

    fRet = FALSE;

    if (!hIMC) {
        return (fRet);
    }

    switch (dwAction) {
    case NI_OPENCANDIDATE:      // after a composition string is determined
                                // if an IME can open candidate, it will.
                                // if it can not, app also can not open it.
    case NI_CLOSECANDIDATE:
        return (fRet);          // not supported
    case NI_SELECTCANDIDATESTR:
    case NI_SETCANDIDATE_PAGESTART:
    case NI_SETCANDIDATE_PAGESIZE:
        break;                  // need to handle it
    case NI_CHANGECANDIDATELIST:
        break;
    case NI_CONTEXTUPDATED:
        switch (dwValue) {
        case IMC_SETCONVERSIONMODE:
        case IMC_SETOPENSTATUS:
            break;              // need to handle it
        case IMC_SETCANDIDATEPOS:
        case IMC_SETCOMPOSITIONFONT:
        case IMC_SETCOMPOSITIONWINDOW:
            return (TRUE);      // not important to the IME
        default:
            return (fRet);      // not supported
        }
        break;
    case NI_COMPOSITIONSTR:
        switch (dwIndex) {
        case CPS_COMPLETE:
            break;              // need to handle it
        case CPS_CONVERT:       // all composition string can not be convert
        case CPS_REVERT:        // any more, it maybe work for some
                                // intelligent phonetic IMEs
            return (fRet);
        case CPS_CANCEL:
            break;              // need to handle it
        default:
            return (fRet);      // not supported
        }
        break;                  // need to handle it
    default:
        return (fRet);          // not supported
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return (fRet);
    }

    fRet = TRUE;

    switch (dwAction) {
    case NI_CONTEXTUPDATED:
        switch (dwValue) {
        case IMC_SETCONVERSIONMODE:
            if ((lpIMC->fdwConversion ^ dwIndex) & IME_CMODE_CHARCODE) {
                // reject CHARCODE
                lpIMC->fdwConversion &= ~IME_CMODE_CHARCODE;
                MessageBeep((UINT)-1);
                break;
            }

            fdwImeMsg = 0;

            if ((lpIMC->fdwConversion ^ dwIndex) & IME_CMODE_NOCONVERSION) {
                lpIMC->fdwConversion |= IME_CMODE_NATIVE;
#ifdef EUDC
                lpIMC->fdwConversion &= ~(IME_CMODE_CHARCODE|
                    IME_CMODE_EUDC|IME_CMODE_SYMBOL|IME_CMODE_NOCONVERSION);
#else
                lpIMC->fdwConversion &= ~(IME_CMODE_CHARCODE|
                    IME_CMODE_EUDC|IME_CMODE_SYMBOL|IME_CMODE_NOCONVERSION);
#endif //EUDC
            }

            if ((lpIMC->fdwConversion ^ dwIndex) & IME_CMODE_EUDC) {
                lpIMC->fdwConversion |= IME_CMODE_NATIVE;
                lpIMC->fdwConversion &= ~(IME_CMODE_CHARCODE|
                    IME_CMODE_NOCONVERSION|IME_CMODE_SYMBOL);
            }

            if ((lpIMC->fdwConversion ^ dwIndex) & IME_CMODE_SOFTKBD) {

                fdwImeMsg |= MSG_IMN_UPDATE_SOFTKBD;

            }

            if ((lpIMC->fdwConversion ^ dwIndex) & IME_CMODE_NATIVE) {
#ifdef EUDC
               lpIMC->fdwConversion &= ~(IME_CMODE_CHARCODE|
                    IME_CMODE_NOCONVERSION);
#else
               lpIMC->fdwConversion &= ~(IME_CMODE_CHARCODE|
                    IME_CMODE_NOCONVERSION|IME_CMODE_EUDC);
#endif //EUDC
                fdwImeMsg |= MSG_IMN_UPDATE_SOFTKBD;
            }

            if (fdwImeMsg) {
                GenerateImeMessage(hIMC, lpIMC, fdwImeMsg);
            }

            if ((lpIMC->fdwConversion ^ dwIndex) & ~(IME_CMODE_FULLSHAPE|
                IME_CMODE_SOFTKBD)) {
            } else {
                break;
            }

            CompCancel(hIMC, lpIMC);
            break;
        case IMC_SETOPENSTATUS:
            if (lpIMC->fdwConversion & IME_CMODE_SOFTKBD) {
                GenerateImeMessage(hIMC, lpIMC, MSG_IMN_UPDATE_SOFTKBD);
            }
            CompCancel(hIMC, lpIMC);
            break;
        default:
            break;
        }
        break;
    case NI_SELECTCANDIDATESTR:
        if (!lpIMC->fOpen) {
            fRet = FALSE;
            break;
        } else if (lpIMC->fdwConversion & IME_CMODE_NOCONVERSION) {
            fRet = FALSE;
            break;
        } else if (lpIMC->fdwConversion & IME_CMODE_EUDC) {
            fRet = FALSE;
            break;
        } else if (!lpIMC->hCandInfo) {
            fRet = FALSE;
            break;
        } else {
            LPCANDIDATEINFO lpCandInfo;

            lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo);
            
            if(!lpCandInfo){
                fRet = FALSE;
                break;
            }
            

            NotifySelectCand(hIMC, lpIMC, lpCandInfo, dwIndex, dwValue);

            ImmUnlockIMCC(lpIMC->hCandInfo);
        }

        break;
    case NI_CHANGECANDIDATELIST:
        fdwImeMsg = 0;
        
        fdwImeMsg |= MSG_CHANGE_CANDIDATE;
        GenerateImeMessage(hIMC, lpIMC, fdwImeMsg);
        
        break;
    case NI_SETCANDIDATE_PAGESTART:
    case NI_SETCANDIDATE_PAGESIZE:
        if (dwIndex != 0) {
            fRet = FALSE;
            break;
        } else if (!lpIMC->fOpen) {
            fRet = FALSE;
            break;
        } else if (lpIMC->fdwConversion & IME_CMODE_NOCONVERSION) {
            fRet = FALSE;
            break;
        } else if (lpIMC->fdwConversion & (IME_CMODE_EUDC|IME_CMODE_SYMBOL)) {
            fRet = FALSE;
            break;
        } else if (!lpIMC->hCandInfo) {
            fRet = FALSE;
            break;
        } else {
            LPCANDIDATEINFO lpCandInfo;
            LPCANDIDATELIST lpCandList;

            lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo);
            if (!lpCandInfo) {
                fRet = FALSE;
                break;
            }

            lpCandList = (LPCANDIDATELIST)((LPBYTE)lpCandInfo +
                lpCandInfo->dwOffset[0]);

            if (dwAction == NI_SETCANDIDATE_PAGESTART) {
                if (dwValue < lpCandList->dwCount) {
                    lpCandList->dwPageStart = lpCandList->dwSelection =
                        dwValue;
                }
            } else {
                if (lpCandList->dwCount) {
                    lpCandList->dwPageSize = dwValue;
                }
            }

            ImmUnlockIMCC(lpIMC->hCandInfo);
        }

        break;
    case NI_COMPOSITIONSTR:
        switch (dwIndex) {
        case CPS_CANCEL:
            CompCancel(hIMC, lpIMC);
            break;
        case CPS_COMPLETE:
            {
                LPPRIVCONTEXT lpImcP;

                lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
                if (!lpImcP) {
                    break;
                }

                if (lpImcP->iImeState == CST_INIT) {
                    CompCancel(hIMC, lpIMC);
                    // can not do any thing
                } else if (lpImcP->iImeState == CST_CHOOSE) {
                    LPCOMPOSITIONSTRING lpCompStr;
                    LPCANDIDATEINFO     lpCandInfo;

                    lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
                    
                    if(!lpCompStr){
                        break ;
                    }
                    
                    lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo);
                    if (lpCandInfo) {
                        LPCANDIDATELIST lpCandList;

                        lpCandList = (LPCANDIDATELIST)((LPBYTE)lpCandInfo +
                            lpCandInfo->dwOffset[0]);

                        SelectOneCand(lpIMC, lpCompStr, lpImcP, lpCandList);

                       ImmUnlockIMCC(lpIMC->hCandInfo);

                       GenerateMessage(hIMC, lpIMC, lpImcP);
                    }

                    if (lpCompStr) ImmUnlockIMCC(lpIMC->hCompStr);
                } else if ((lpIMC->fdwConversion & (IME_CMODE_NATIVE|
                    IME_CMODE_EUDC|IME_CMODE_SYMBOL)) != IME_CMODE_NATIVE) {
                    CompCancel(hIMC, lpIMC);
                } else if (lpImcP->iImeState == CST_INPUT) {
                    LPCOMPOSITIONSTRING lpCompStr;
                    LPGUIDELINE         lpGuideLine;
                    LPCANDIDATEINFO     lpCandInfo;

                    lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
                    
                    if(!lpCompStr){
                        break;
                    }

                    lpGuideLine = (LPGUIDELINE)ImmLockIMCC(lpIMC->hGuideLine);
                    
                    if(!lpGuideLine){
                        break;
                    }

                    CompWord(TEXT(' '), lpIMC, lpCompStr, lpImcP, lpGuideLine);

                    if (lpImcP->iImeState == CST_INPUT) {
                        CompCancel(hIMC, lpIMC);
                    } else if (lpImcP->iImeState != CST_CHOOSE) {
                    } else if (lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(
                        lpIMC->hCandInfo)) {
                        LPCANDIDATELIST lpCandList;

                        lpCandList = (LPCANDIDATELIST)((LPBYTE)lpCandInfo +
                            lpCandInfo->dwOffset[0]);

                        SelectOneCand(lpIMC, lpCompStr, lpImcP, lpCandList);

                       ImmUnlockIMCC(lpIMC->hCandInfo);
                    } else {
                    }

                    if (lpCompStr) ImmUnlockIMCC(lpIMC->hCompStr);
                    if (lpGuideLine) ImmUnlockIMCC(lpIMC->hGuideLine);

                    // don't phrase predition under this case
                    if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
                        lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CLOSE_CANDIDATE) &
                            ~(MSG_OPEN_CANDIDATE|MSG_CHANGE_CANDIDATE);
                    } else {
                        lpImcP->fdwImeMsg &= ~(MSG_CLOSE_CANDIDATE|MSG_OPEN_CANDIDATE);
                    }

                    GenerateMessage(hIMC, lpIMC, lpImcP);
                } else {
                    CompCancel(hIMC, lpIMC);
                }

                ImmUnlockIMCC(lpIMC->hPrivate);
            }
            break;
        default:
            break;
        }
        break;
    default:
        break;
    }

    ImmUnlockIMC(hIMC);
    return (fRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntime\immsec.c ===
/*++

Copyright (c) 1995-1999  Microsoft Corporation

Module Name:

    immsec.c

Abstract:

    security code called by IMEs 

Author:

    Takao Kitano [takaok] 01-May-1996

Revision History:

--*/

#include <windows.h>
#include <stdio.h>
#include "immsec.h"

#define MEMALLOC(x)      LocalAlloc(LMEM_FIXED, x)
#define MEMFREE(x)       LocalFree(x)

//
// internal functions
//
PSID MyCreateSid();
POSVERSIONINFO GetVersionInfo();

//
// debug functions
//
#ifdef DEBUG
#define ERROROUT(x)      ErrorOut( x )
#define WARNOUT(x)       WarnOut( x )
#else
#define ERROROUT(x) 
#define WARNOUT(x)       
#endif

#ifdef DEBUG
VOID WarnOut( PTSTR pStr )
{
    OutputDebugString( pStr );
}

VOID ErrorOut( PTSTR pStr )
{
    DWORD dwError;
    DWORD dwResult;
    TCHAR buf1[512];
    TCHAR buf2[512];

    dwError = GetLastError();
    dwResult = FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM,
                              NULL,
                              dwError,
                              MAKELANGID( LANG_ENGLISH, LANG_NEUTRAL ),
                              buf1,
                              512,
                              NULL );                                   
    
    if ( dwResult > 0 ) {
        sprintf( buf2, "%s:%s(0x%x)", pStr, buf1, dwError);
    } else {
        sprintf( buf2, "%s:(0x%x)", pStr, dwError);
    }
    OutputDebugString( buf2 );
}
#endif


//
// CreateSecurityAttributes()
//
// The purpose of this function:
//
//      Allocate and set the security attributes that is 
//      appropriate for named objects created by an IME.
//      The security attributes will give GENERIC_ALL
//      access for everyone
//      
//
// Return value:
//
//      If the function succeeds, the return value is a 
//      pointer to SECURITY_ATTRIBUTES. If the function fails,
//      the return value is NULL. To get extended error 
//      information, call GetLastError().
//
// Remarks:
//
//      FreeSecurityAttributes() should be called to free up the
//      SECURITY_ATTRIBUTES allocated by this function.
//
PSECURITY_ATTRIBUTES CreateSecurityAttributes()
{
    PSECURITY_ATTRIBUTES psa;
    PSECURITY_DESCRIPTOR psd;
    PACL                 pacl;
    DWORD                cbacl;

    PSID                 psid;
    BOOL                 fResult;

    INT                  i,j;

    if (!IsNT())
        return NULL;

    //
    // create a sid for everyone access
    //
    psid = MyCreateSid();
    if ( psid == NULL ) {
        return NULL;
    } 

    //
    // allocate and initialize an access control list (ACL) that will 
    // contain the SID we've just created.
    //
    cbacl =  sizeof(ACL) + 
             (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) + 
             GetLengthSid(psid);

    pacl = MEMALLOC( cbacl );
    if ( pacl == NULL ) {
        ERROROUT( TEXT("CreateSecurityAttributes:LocalAlloc for ACL failed") );
        FreeSid ( psid );
        return NULL;
    }

    fResult = InitializeAcl( pacl, cbacl, ACL_REVISION );
    if ( ! fResult ) {
        ERROROUT( TEXT("CreateSecurityAttributes:InitializeAcl failed") );
        FreeSid ( psid );
        MEMFREE( pacl );
        return NULL;
    }

    //
    // adds an access-allowed ACE for interactive users to the ACL
    // 
    fResult = AddAccessAllowedAce( pacl,
                                   ACL_REVISION,
                                   GENERIC_ALL,
                                   psid );

    if ( !fResult ) {
        ERROROUT( TEXT("CreateSecurityAttributes:AddAccessAllowedAce failed") );
        MEMFREE( pacl );
        FreeSid ( psid );
        return NULL;
    }


    //
    // Those SIDs have been copied into the ACL. We don't need'em any more.
    //
    FreeSid ( psid );

    //
    // Let's make sure that our ACL is valid.
    //
    if (!IsValidAcl(pacl)) {
        WARNOUT( TEXT("CreateSecurityAttributes:IsValidAcl returns FALSE!"));
        MEMFREE( pacl );
        return NULL;
    }

    //
    // allocate security attribute
    //
    psa = (PSECURITY_ATTRIBUTES)MEMALLOC( sizeof( SECURITY_ATTRIBUTES ) );
    if ( psa == NULL ) {
        ERROROUT( TEXT("CreateSecurityAttributes:LocalAlloc for psa failed") );
        MEMFREE( pacl );
        return NULL;
    }
    
    //
    // allocate and initialize a new security descriptor
    //
    psd = MEMALLOC( SECURITY_DESCRIPTOR_MIN_LENGTH );
    if ( psd == NULL ) {
        ERROROUT( TEXT("CreateSecurityAttributes:LocalAlloc for psd failed") );
        MEMFREE( pacl );
        MEMFREE( psa );
        return NULL;
    }

    if ( ! InitializeSecurityDescriptor( psd, SECURITY_DESCRIPTOR_REVISION ) ) {
        ERROROUT( TEXT("CreateSecurityAttributes:InitializeSecurityDescriptor failed") );
        MEMFREE( pacl );
        MEMFREE( psa );
        MEMFREE( psd );
        return NULL;
    }


    fResult = SetSecurityDescriptorDacl( psd,
                                         TRUE,
                                         pacl,
                                         FALSE );

    // The discretionary ACL is referenced by, not copied 
    // into, the security descriptor. We shouldn't free up ACL
    // after the SetSecurityDescriptorDacl call. 

    if ( ! fResult ) {
        ERROROUT( TEXT("CreateSecurityAttributes:SetSecurityDescriptorDacl failed") );
        MEMFREE( pacl );
        MEMFREE( psa );
        MEMFREE( psd );
        return NULL;
    } 


    if (!IsValidSecurityDescriptor(psd)) {
        WARNOUT( TEXT("CreateSecurityAttributes:IsValidSecurityDescriptor failed!") );
        MEMFREE( pacl );
        MEMFREE( psa );
        MEMFREE( psd );
        return NULL;
    }

    //
    // everything is done
    //
    psa->nLength = sizeof( SECURITY_ATTRIBUTES );
    psa->lpSecurityDescriptor = (PVOID)psd;
    psa->bInheritHandle = FALSE;

    return psa;
}

PSID MyCreateSid()
{
    PSID        psid;
    BOOL        fResult;
    SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_WORLD_SID_AUTHORITY;

    //
    // allocate and initialize an SID
    // 
    fResult = AllocateAndInitializeSid( &SidAuthority,
                                        1,
                                        SECURITY_WORLD_RID,
                                        0,0,0,0,0,0,0,
                                        &psid );
    if ( ! fResult ) {
        ERROROUT( TEXT("MyCreateSid:AllocateAndInitializeSid failed") );
        return NULL;
    }

    if ( ! IsValidSid( psid ) ) {
        WARNOUT( TEXT("MyCreateSid:AllocateAndInitializeSid returns bogus sid"));
        FreeSid( psid );
        return NULL;
    }

    return psid;
}

//
// FreeSecurityAttributes()
//
// The purpose of this function:
//
//      Frees the memory objects allocated by previous
//      CreateSecurityAttributes() call.
//
VOID FreeSecurityAttributes( PSECURITY_ATTRIBUTES psa )
{
    BOOL fResult;
    BOOL fDaclPresent;
    BOOL fDaclDefaulted;
    PACL pacl;

    if (psa == NULL)
        return;

    fResult = GetSecurityDescriptorDacl( psa->lpSecurityDescriptor,
                                         &fDaclPresent,
                                         &pacl,
                                         &fDaclDefaulted );                  
    if ( fResult ) {
        if ( pacl != NULL )
            MEMFREE( pacl );
    } else {
        ERROROUT( TEXT("FreeSecurityAttributes:GetSecurityDescriptorDacl failed") );
    }

    MEMFREE( psa->lpSecurityDescriptor );
    MEMFREE( psa );
}

//
// IsNT()
//
// Return value:
//
//      TRUE if the current system is Windows NT
//
// Remarks:
//
//      The implementation of this function is not multi-thread safe.
//      You need to modify the function if you call the function in 
//      multi-thread environment.
//
BOOL IsNT()
{
    return GetVersionInfo()->dwPlatformId == VER_PLATFORM_WIN32_NT;
}

POSVERSIONINFO GetVersionInfo()
{
    static BOOL fFirstCall = TRUE;
    static OSVERSIONINFO os;

    if ( fFirstCall ) {
        os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        if ( GetVersionEx( &os ) ) {
            fFirstCall = FALSE;
        }
    }
    return &os;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntime\init.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    INIT.C
    
++*/

#include <windows.h>
#include <winerror.h>
#include <memory.h>
#include <immdev.h>
#include <immsec.h>
#include <imedefs.h>
#include <regstr.h>


void PASCAL InitStatusUIData(
    int     cxBorder,
    int     cyBorder,
    int     iActMBIndex)
{
   
    int   iContentHi;


    // iContentHi is to get the maximum value of predefined STATUS_DIM_Y and
    // a real Chinese character's height in the current HDC.

    iContentHi = STATUS_DIM_Y;
 
    if ( iContentHi < sImeG.yChiCharHi )
       iContentHi = sImeG.yChiCharHi ;

    // right bottom of status
    sImeG.rcStatusText.left = 0;
    sImeG.rcStatusText.top = 0;
    sImeG.rcStatusText.right = sImeG.rcStatusText.left +
           lstrlen(MBIndex.MBDesc[iActMBIndex].szName) * sImeG.xChiCharWi*sizeof(TCHAR)/2 + STATUS_NAME_MARGIN + STATUS_DIM_X * 4;
    sImeG.rcStatusText.bottom = sImeG.rcStatusText.top + iContentHi;

    sImeG.xStatusWi = STATUS_DIM_X * 4 + STATUS_NAME_MARGIN +
            lstrlen(MBIndex.MBDesc[iActMBIndex].szName) * sImeG.xChiCharWi*sizeof(TCHAR)/2 + 6 * cxBorder;
    sImeG.yStatusHi = iContentHi + 6 * cxBorder;
    
    // left bottom of imeicon bar
    sImeG.rcImeIcon.left = sImeG.rcStatusText.left;
    sImeG.rcImeIcon.top = sImeG.rcStatusText.top;
    sImeG.rcImeIcon.right = sImeG.rcImeIcon.left + STATUS_DIM_X;
    sImeG.rcImeIcon.bottom = sImeG.rcImeIcon.top + iContentHi;

    // left bottom of imename bar
    sImeG.rcImeName.left = sImeG.rcImeIcon.right;
    sImeG.rcImeName.top = sImeG.rcStatusText.top;
    sImeG.rcImeName.right = sImeG.rcImeName.left +
                lstrlen(MBIndex.MBDesc[iActMBIndex].szName) * sImeG.xChiCharWi*sizeof(TCHAR)/2 + STATUS_NAME_MARGIN;
    sImeG.rcImeName.bottom = sImeG.rcImeName.top + iContentHi;
    

    // middle bottom of Shape bar
    sImeG.rcShapeText.left = sImeG.rcImeName.right;
    sImeG.rcShapeText.top = sImeG.rcStatusText.top;
    sImeG.rcShapeText.right = sImeG.rcShapeText.left + STATUS_DIM_X;
    sImeG.rcShapeText.bottom = sImeG.rcShapeText.top + iContentHi;

    // middle bottom of Symbol bar
    sImeG.rcSymbol.left = sImeG.rcShapeText.right;
    sImeG.rcSymbol.top = sImeG.rcStatusText.top;
    sImeG.rcSymbol.right = sImeG.rcSymbol.left + STATUS_DIM_X;
    sImeG.rcSymbol.bottom = sImeG.rcSymbol.top + iContentHi;

    // right bottom of SK bar
    sImeG.rcSKText.left = sImeG.rcSymbol.right;     
    sImeG.rcSKText.top = sImeG.rcStatusText.top;
    sImeG.rcSKText.right = sImeG.rcSKText.left + STATUS_DIM_X;
    sImeG.rcSKText.bottom = sImeG.rcSKText.top + iContentHi;

    return;
}

void PASCAL InitCandUIData(
    int     cxBorder,
    int     cyBorder,
    int     UIMode)
{

    int   iContentHi;


    // iContentHi is to get the maximum value of predefined COMP_TEXT_Y and
    // a real Chinese character's height in the current HDC.

    iContentHi = COMP_TEXT_Y;

    if ( iContentHi < sImeG.yChiCharHi )
       iContentHi = sImeG.yChiCharHi ;


    sImeG.cxCandBorder = cxBorder * 2;
    sImeG.cyCandBorder = cyBorder * 2;

    if(UIMode == LIN_UI) {
        sImeG.rcCandIcon.left = 0;
        sImeG.rcCandIcon.top = cyBorder + 2;
        sImeG.rcCandIcon.right = sImeG.rcCandIcon.left + UI_CANDICON;
        sImeG.rcCandIcon.bottom = sImeG.rcCandIcon.top + UI_CANDICON;
                          
        sImeG.rcCandText.left = sImeG.rcCandIcon.right + 3;
        sImeG.rcCandText.top =  cyBorder ;
        sImeG.rcCandText.right = sImeG.rcCandText.left + UI_CANDSTR;
        sImeG.rcCandText.bottom = sImeG.rcCandText.top + iContentHi;

        sImeG.rcCandBTH.top = cyBorder * 4;
        sImeG.rcCandBTH.left = sImeG.rcCandText.right + 5;
        sImeG.rcCandBTH.right = sImeG.rcCandBTH.left + UI_CANDBTW;
        sImeG.rcCandBTH.bottom = sImeG.rcCandBTH.top + UI_CANDBTH;

        sImeG.rcCandBTU.top = cyBorder * 4;
        sImeG.rcCandBTU.left = sImeG.rcCandBTH.right;
        sImeG.rcCandBTU.right = sImeG.rcCandBTU.left + UI_CANDBTW;
        sImeG.rcCandBTU.bottom = sImeG.rcCandBTU.top + UI_CANDBTH;

        sImeG.rcCandBTD.top = cyBorder * 4;
        sImeG.rcCandBTD.left = sImeG.rcCandBTU.right;
        sImeG.rcCandBTD.right = sImeG.rcCandBTD.left + UI_CANDBTW;
        sImeG.rcCandBTD.bottom = sImeG.rcCandBTD.top + UI_CANDBTH;

        sImeG.rcCandBTE.top = cyBorder * 4;
        sImeG.rcCandBTE.left = sImeG.rcCandBTD.right;
        sImeG.rcCandBTE.right = sImeG.rcCandBTE.left + UI_CANDBTW;
        sImeG.rcCandBTE.bottom = sImeG.rcCandBTE.top + UI_CANDBTH;

        sImeG.xCandWi = sImeG.rcCandBTE.right + sImeG.cxCandBorder * 2 + cxBorder * 4;
        sImeG.yCandHi = sImeG.rcCandText.bottom + sImeG.cyCandBorder * 2 + cyBorder * 4;

    } else {
        sImeG.rcCandText.left = cxBorder;
        sImeG.rcCandText.top = 2 * cyBorder + UI_CANDINF;
        if(sImeG.xChiCharWi*11 > (UI_CANDICON*6 + UI_CANDBTH*4))
            sImeG.rcCandText.right = sImeG.rcCandText.left + sImeG.xChiCharWi * 11;
        else
            sImeG.rcCandText.right = sImeG.rcCandText.left + (UI_CANDICON*6 + UI_CANDBTH*4);
        sImeG.rcCandText.bottom = sImeG.rcCandText.top + sImeG.yChiCharHi * CANDPERPAGE;

        sImeG.xCandWi = sImeG.rcCandText.right + sImeG.cxCandBorder * 2 + cxBorder * 4;
        sImeG.yCandHi = sImeG.rcCandText.bottom + sImeG.cyCandBorder * 2 + cyBorder * 4;

        sImeG.rcCandIcon.left = cxBorder;
        sImeG.rcCandIcon.top = cyBorder + 2;
        sImeG.rcCandIcon.right = sImeG.rcCandIcon.left + UI_CANDICON;
        sImeG.rcCandIcon.bottom = sImeG.rcCandIcon.top + UI_CANDICON;
                          
        sImeG.rcCandInf.left = sImeG.rcCandIcon.right;
        sImeG.rcCandInf.top = cyBorder + 3;
        sImeG.rcCandInf.right = sImeG.rcCandInf.left + UI_CANDICON * 5;
        sImeG.rcCandInf.bottom = sImeG.rcCandInf.top + UI_CANDBTH;

        sImeG.rcCandBTE.top = cyBorder * 5;
        sImeG.rcCandBTE.right = sImeG.rcCandText.right + cxBorder;
        sImeG.rcCandBTE.bottom = sImeG.rcCandBTE.top + UI_CANDBTH;
        sImeG.rcCandBTE.left = sImeG.rcCandBTE.right - UI_CANDBTW;

        sImeG.rcCandBTD.top = cyBorder * 5;
        sImeG.rcCandBTD.right = sImeG.rcCandBTE.left;
        sImeG.rcCandBTD.bottom = sImeG.rcCandBTD.top + UI_CANDBTH;
        sImeG.rcCandBTD.left = sImeG.rcCandBTD.right - UI_CANDBTW;

        sImeG.rcCandBTU.top = cyBorder * 5;
        sImeG.rcCandBTU.right = sImeG.rcCandBTD.left;
        sImeG.rcCandBTU.bottom = sImeG.rcCandBTU.top + UI_CANDBTH;
        sImeG.rcCandBTU.left = sImeG.rcCandBTU.right - UI_CANDBTW;

        sImeG.rcCandBTH.top = cyBorder * 5;
        sImeG.rcCandBTH.right = sImeG.rcCandBTU.left;
        sImeG.rcCandBTH.bottom = sImeG.rcCandBTH.top + UI_CANDBTH;
        sImeG.rcCandBTH.left = sImeG.rcCandBTH.right - UI_CANDBTW;
    }

}
/**********************************************************************/
/* InitImeGlobalData()                                                */
/**********************************************************************/
void PASCAL InitImeGlobalData(
    HINSTANCE hInstance)
{
    int     cxBorder, cyBorder;
    int     UI_MODE;
    HDC     hDC;
    HGDIOBJ hOldFont;
    LOGFONT lfFont;
    TCHAR   szChiChar[4];
    SIZE    lTextSize;
    HGLOBAL hResData;
    int     i;
    DWORD   dwSize;
    HKEY    hKeyIMESetting;
    LONG    lRet;

    hInst = hInstance;

    // get the UI class name
    LoadString(hInst, IDS_IMEUICLASS, szUIClassName, CLASS_LEN);

    // get the composition class name
    LoadString(hInst, IDS_IMECOMPCLASS, szCompClassName, CLASS_LEN);

    // get the candidate class name
    LoadString(hInst, IDS_IMECANDCLASS, szCandClassName, CLASS_LEN);

    // get the status class name
    LoadString(hInst, IDS_IMESTATUSCLASS, szStatusClassName, CLASS_LEN);

    //get the ContextMenu class name
    LoadString(hInst, IDS_IMECMENUCLASS, szCMenuClassName, CLASS_LEN);

    //get the softkeyboard Menu class name
    LoadString(hInst, IDS_IMESOFTKEYMENUCLASS, szSoftkeyMenuClassName, CLASS_LEN);

    // get ime org name
    LoadString(hInst, IDS_ORG_NAME, szOrgName, NAMESIZE/2);

    // get ime version info
    LoadString(hInst, IDS_VER_INFO, szVerInfo, NAMESIZE);

    // work area
    SystemParametersInfo(SPI_GETWORKAREA, 0, &sImeG.rcWorkArea, 0);

    // border
    cxBorder = GetSystemMetrics(SM_CXBORDER);
    cyBorder = GetSystemMetrics(SM_CYBORDER);

    // get the Chinese char
    LoadString(hInst, IDS_CHICHAR, szChiChar, sizeof(szChiChar)/sizeof(TCHAR));

    // get size of Chinese char
    hDC = GetDC(NULL);
    
    hOldFont = GetCurrentObject(hDC, OBJ_FONT);
    GetObject(hOldFont, sizeof(LOGFONT), &lfFont);
    sImeG.fDiffSysCharSet = TRUE;

    ZeroMemory(&lfFont, sizeof(lfFont));
    lfFont.lfHeight = -MulDiv(12, GetDeviceCaps(hDC, LOGPIXELSY), 72);
    lfFont.lfCharSet = NATIVE_CHARSET;
    lstrcpy(lfFont.lfFaceName, TEXT("Simsun"));
    SelectObject(hDC, CreateFontIndirect(&lfFont));
    if(!GetTextExtentPoint(hDC, (LPTSTR)szChiChar, lstrlen(szChiChar), &lTextSize))
       memset(&lTextSize, 0, sizeof(SIZE));
    if (sImeG.rcWorkArea.right < 2 * UI_MARGIN) {
       sImeG.rcWorkArea.left = 0;
       sImeG.rcWorkArea.right = GetDeviceCaps(hDC, HORZRES);
    }
    if (sImeG.rcWorkArea.bottom < 2 * UI_MARGIN) {
        sImeG.rcWorkArea.top = 0;
        sImeG.rcWorkArea.bottom = GetDeviceCaps(hDC, VERTRES);
    }

    if (sImeG.fDiffSysCharSet) {
        DeleteObject(SelectObject(hDC, hOldFont));
    }

    ReleaseDC(NULL, hDC);

    // get text metrics to decide the width & height of composition window
    // these IMEs always use system font to show
    sImeG.xChiCharWi = lTextSize.cx;
    sImeG.yChiCharHi = lTextSize.cy;

    if(MBIndex.IMEChara[0].IC_Trace) {
        UI_MODE = BOX_UI;
    } else {
        UI_MODE = LIN_UI;
    }

    InitCandUIData(cxBorder, cyBorder, UI_MODE);

    InitStatusUIData(cxBorder, cyBorder ,0);

    // load full ABC table
    {
        HRSRC    hResSrc;
        hResSrc = FindResource(hInst,TEXT("FULLABC"), RT_RCDATA);
        if(hResSrc == NULL){
            return;
        }
        hResData = LoadResource(hInst, hResSrc);
    }

    *(LPFULLABC)sImeG.wFullABC = *(LPFULLABC)LockResource(hResData);

    // full shape space
    sImeG.wFullSpace = sImeG.wFullABC[0];

#ifdef LATER
    // reverse internal code to internal code, NT don't need it
    for (i = 0; i < (sizeof(sImeG.wFullABC) / 2); i++) {
        sImeG.wFullABC[i] = (sImeG.wFullABC[i] << 8) |
            (sImeG.wFullABC[i] >> 8);
    }
#endif

    LoadString(hInst, IDS_STATUSERR, sImeG.szStatusErr,
        sizeof(sImeG.szStatusErr)/sizeof(TCHAR));
    sImeG.cbStatusErr = lstrlen(sImeG.szStatusErr);

    sImeG.iCandStart = CAND_START;

    // get the UI offset for near caret operation
    RegCreateKey(HKEY_CURRENT_USER, szRegIMESetting, &hKeyIMESetting);

    dwSize = sizeof(DWORD);
    lRet  = RegQueryValueEx(hKeyIMESetting, szPara, NULL, NULL,
        (LPBYTE)&sImeG.iPara, &dwSize);

    if (lRet != ERROR_SUCCESS) {
        sImeG.iPara = 0;
        RegSetValueEx(hKeyIMESetting, szPara, (DWORD) 0, REG_BINARY,
            (LPBYTE)&sImeG.iPara, sizeof(int));
    }

    dwSize = sizeof(DWORD);
    lRet = RegQueryValueEx(hKeyIMESetting, szPerp, NULL, NULL,
        (LPBYTE)&sImeG.iPerp, &dwSize);

    if (lRet != ERROR_SUCCESS) {
        sImeG.iPerp = sImeG.yChiCharHi;
        RegSetValueEx(hKeyIMESetting, szPerp, (DWORD) 0, REG_BINARY,
            (LPBYTE)&sImeG.iPerp, sizeof(int));
    }

    dwSize = sizeof(DWORD);
    lRet = RegQueryValueEx(hKeyIMESetting, szParaTol, NULL, NULL,
        (LPBYTE)&sImeG.iParaTol, &dwSize);

    if (lRet != ERROR_SUCCESS) {
        sImeG.iParaTol = sImeG.xChiCharWi * 4;
        RegSetValueEx(hKeyIMESetting, szParaTol, (DWORD) 0, REG_BINARY,
            (LPBYTE)&sImeG.iParaTol, sizeof(int));
    }

    dwSize = sizeof(DWORD);
    lRet = RegQueryValueEx(hKeyIMESetting, szPerpTol, NULL, NULL,
        (LPBYTE)&sImeG.iPerpTol, &dwSize);

    if (lRet != ERROR_SUCCESS) {
        sImeG.iPerpTol = lTextSize.cy;
        RegSetValueEx(hKeyIMESetting, szPerpTol, (DWORD) 0, REG_BINARY,
            (LPBYTE)&sImeG.iPerpTol, sizeof(int));
    }

    RegCloseKey(hKeyIMESetting);

    return;
}

/**********************************************************************/
/* InitImeLocalData()                                                 */
/**********************************************************************/
BOOL PASCAL InitImeLocalData(
    HINSTANCE hInstL)
{
    int      cxBorder, cyBorder;


    int   iContentHi;


    // iContentHi is to get the maximum value of predefined COMP_TEXT_Y and
    // a real Chinese character's height in the current HDC.

    iContentHi = COMP_TEXT_Y;

    if ( iContentHi < sImeG.yChiCharHi )
       iContentHi = sImeG.yChiCharHi ;


    lpImeL->hInst = hInstL;

    lpImeL->nMaxKey = MBIndex.MBDesc[0].wMaxCodes;

    // border + raising edge + sunken edge
    cxBorder = GetSystemMetrics(SM_CXBORDER);
    cyBorder = GetSystemMetrics(SM_CYBORDER);
                                        
    // text position relative to the composition window
    lpImeL->cxCompBorder = cxBorder * 2;
    lpImeL->cyCompBorder = cyBorder * 2;

    lpImeL->rcCompText.left = cxBorder;
    lpImeL->rcCompText.top = cyBorder;

#ifdef KEYSTICKER
    lpImeL->rcCompText.right = lpImeL->rcCompText.left + sImeG.xChiCharWi * ((lpImeL->nMaxKey * 2 + 2) / 2);
#else
    lpImeL->rcCompText.right = lpImeL->rcCompText.left + sImeG.xChiCharWi * ((lpImeL->nMaxKey + 2) / 2);
#endif    //KEYSTICKER
    lpImeL->rcCompText.bottom = lpImeL->rcCompText.top + iContentHi;
    // set the width & height for composition window
    lpImeL->xCompWi = lpImeL->rcCompText.right + lpImeL->cxCompBorder * 2 + cxBorder * 4;
    lpImeL->yCompHi = lpImeL->rcCompText.bottom + lpImeL->cyCompBorder * 2 + cyBorder * 4;

    // default position of composition window
    lpImeL->ptDefComp.x = sImeG.rcWorkArea.right -
        lpImeL->xCompWi - cxBorder * 2;
    lpImeL->ptDefComp.y = sImeG.rcWorkArea.bottom -
        lpImeL->yCompHi - cyBorder * 2;

    return (TRUE);
}

/**********************************************************************/
/* RegisterIme()                                                      */
/**********************************************************************/
void PASCAL RegisterIme(
    HINSTANCE hInstance)
{
    UINT  j;
    HKEY  hKeyCurrVersion;
    DWORD retCode;
    DWORD retValue;
    HKEY  hKey;
    LANGID LangID;
#ifdef UNICODE
    TCHAR ValueName[][9] = {
        {0x8BCD, 0x8BED, 0x8054, 0x60F3, 0x0000},
        {0x8BCD, 0x8BED, 0x8F93, 0x5165, 0x0000},
        {0x9010, 0x6E10, 0x63D0, 0x793A, 0x0000},
        {0x5916, 0x7801, 0x63D0, 0x793A, 0x0000},
        {0x63D2, 0x7A7A, 0x683C, 0x0000},
        {0x5149, 0x6807, 0x8DDF, 0x968F, 0x0000},
#else
    TCHAR ValueName[][9] = { 
        TEXT(""),
        TEXT(""),
        TEXT(""),
        TEXT(""),
        TEXT(""),
        TEXT(""),
#endif
         TEXT("<SPACE>"),
        TEXT("<ENTER>"),
        TEXT("FC Input"),
        TEXT("FC aid"),
#if defined(COMBO_IME)

        TEXT("GB/GBK")
#endif
        };
    DWORD dwcValueName = MAXSTRLEN;
    TCHAR bData[MAXSTRLEN];
    LONG  bcData = sizeof(DWORD);


    // load mb file name string according to current locale.
    TCHAR szMBFilePath[MAX_PATH];
    BYTE szAnsiMBFilePath[MAX_PATH];
    OFSTRUCT OpenBuff;
    HFILE hFile;

    GetSystemDirectory(szMBFilePath, MAX_PATH);
    LoadString(hInstance, IDS_IMEMBFILENAME, szImeMBFileName, MAX_PATH);
    lstrcat(szMBFilePath, TEXT("\\"));
    lstrcat(szMBFilePath, szImeMBFileName);

    WideCharToMultiByte(NATIVE_ANSI_CP, 
                        WC_COMPOSITECHECK, 
                        szMBFilePath, 
                        -1, 
                        szAnsiMBFilePath, 
                        MAX_PATH, 
                        NULL, 
                        NULL);

    if ((hFile = OpenFile(szAnsiMBFilePath, &OpenBuff, OF_EXIST))==HFILE_ERROR)
    {
       if (LOWORD(GetSystemDefaultLangID()) == 0xC04) {

         // for HongKong Special treat.

          ZeroMemory(szImeMBFileName,sizeof(TCHAR)*MAX_PATH);
          LoadString(hInstance, IDS_IMEHKMBFILENAME, szImeMBFileName,MAX_PATH);
       }
    }

    lstrcpy((LPTSTR)HMapTab[0].MB_Name, szImeMBFileName);

    if(!ReadDescript((LPTSTR)szMBFilePath, &(MBIndex.MBDesc[0]))) {
        return;
    }
    MBIndex.MBNums = 1;
    
    retCode = OpenReg_PathSetup(&hKeyCurrVersion);

    if (retCode) {
        RegCreateKey(HKEY_CURRENT_USER, REGSTR_PATH_SETUP, &hKeyCurrVersion);
    }

    retCode = OpenReg_User (hKeyCurrVersion,
                           MBIndex.MBDesc[0].szName,
                           &hKey);
    if (retCode) {
        HGLOBAL hResData;
        WORD    wIMECharac;
        DWORD   dwDisposition;
        
        retCode = RegCreateKeyEx (hKeyCurrVersion,
                                 MBIndex.MBDesc[0].szName,
                              0,
                              0,
                              REG_OPTION_NON_VOLATILE,
                              KEY_ALL_ACCESS,
                              NULL,
                              &hKey,
                              &dwDisposition);

        // set value
        // load imecharac

        {
            HRSRC    hResSrc;
            hResSrc = FindResource(hInstance,TEXT("IMECHARAC"), RT_RCDATA);
            if(hResSrc == NULL){
                 return;
        }
        hResData = LoadResource(hInstance, hResSrc);
        }

        if(hResData == NULL){
            return;
        }

        memcpy(&wIMECharac, LockResource(hResData), sizeof(WORD));


        for(j=0; j<IC_NUMBER; j++) {
             DWORD Value;

            switch (j)
            {
                case 0:
                    Value = wIMECharac & 0x0001;
                    break;
                case 1:
                    Value = (wIMECharac & 0x0002) >> 1;
                    break;
                case 2:
                    Value = (wIMECharac & 0x0004) >> 2;
                    break;
                case 3:
                    Value = (wIMECharac & 0x0008) >> 3;
                    break;
                case 4:
                    Value = (wIMECharac & 0x0010) >> 4;
                    break;
                case 5:
                    Value = (wIMECharac & 0x0020) >> 5;
                    break;
                case 6:
                    Value = (wIMECharac & 0x0040) >> 6;
                    break;
                case 7:
                    Value = (wIMECharac & 0x0080) >> 7;
                    break;
                //CHP
                    case 8:
                    Value = (wIMECharac & 0x0100) >> 8;
                    break;
                    case 9:
                    Value = (wIMECharac & 0x0200) >> 9;
                    break;

#if defined(COMBO_IME)
                case 10:
                    Value = (wIMECharac & 0x0400) >> 10;
                    break;
#endif
            }
            
            RegSetValueEx (hKey, ValueName[j],
                                      (DWORD) 0,
                                      REG_DWORD,
                                      (LPBYTE)&Value,
                                      sizeof(DWORD));
        }

    }

    for(j=0; j<IC_NUMBER; j++) {
        bData[0] = TEXT('\0');

        bcData = MAXSTRLEN;
        retValue = RegQueryValueEx (hKey, ValueName[j],
                                 NULL,
                                 NULL,                   //&dwType,
                                 (unsigned char *)bData, //&bData,
                                 &bcData);               //&bcData);
        switch (j)
        {
            case 0:
                MBIndex.IMEChara[0].IC_LX = *((LPDWORD)bData);
                break;
            case 1:
                MBIndex.IMEChara[0].IC_CZ = *((LPDWORD)bData);
                break;
            case 2:
                MBIndex.IMEChara[0].IC_TS = *((LPDWORD)bData);
                break;
            case 3:
                MBIndex.IMEChara[0].IC_CTC = *((LPDWORD)bData);
                break;
            case 4:
                MBIndex.IMEChara[0].IC_INSSPC = *((LPDWORD)bData);
                break;
            case 5:
                MBIndex.IMEChara[0].IC_Trace = *((LPDWORD)bData);
                break;
            case 6:
                MBIndex.IMEChara[0].IC_Space = *((LPDWORD)bData);
                break;
            case 7:
                MBIndex.IMEChara[0].IC_Enter = *((LPDWORD)bData);
                break;
                        //CHP
            case 8:
                MBIndex.IMEChara[0].IC_FCSR = *((LPDWORD)bData);
                break;
            case 9:
                MBIndex.IMEChara[0].IC_FCTS = *((LPDWORD)bData);
                break;

#if defined(COMBO_IME)
            case 10:
                MBIndex.IMEChara[0].IC_GB = *((LPDWORD)bData);
                break;
#endif
            default:
                break;
        }
    }
#ifdef EUDC
    //just query the value, do not set any value here
    bcData = sizeof(TCHAR) * MAX_PATH;
    RegQueryValueEx (hKey, szRegEudcDictName,
                     NULL,
                     NULL,                                              //null-terminate string
                     (unsigned char *)MBIndex.EUDCData.szEudcDictName,  //&bData,
                     &bcData);                   //&bcData); 
    bcData = sizeof(TCHAR) * MAX_PATH;
    RegQueryValueEx (hKey, szRegEudcMapFileName,
                     NULL,
                     NULL,                                              //null-terminate string
                     (unsigned char *)MBIndex.EUDCData.szEudcMapFileName,//&bData,
                     &bcData);                                          //&bcData);
#endif //EUDC
#ifdef CROSSREF         
    bcData = sizeof(HKL);
    if(RegQueryValueEx (hKey, szRegRevKL,
                     NULL,
                     NULL,                      //null-terminate string
                     (LPBYTE)&MBIndex.hRevKL,   //&bData,
                     &bcData) != ERROR_SUCCESS)
        MBIndex.hRevKL = NULL;

    bcData = sizeof(DWORD); 
    if(RegQueryValueEx (hKey, szRegRevMaxKey,
                     NULL,
                     NULL,                          //null-terminate string
                     (LPBYTE)&MBIndex.nRevMaxKey,   //&bData,
                     &bcData) != ERROR_SUCCESS)
        MBIndex.hRevKL = NULL;
#endif
    RegCloseKey(hKey);
    RegCloseKey(hKeyCurrVersion);

    return;
}

/**********************************************************************/
/* RegisterImeClass()                                                 */
/**********************************************************************/
void PASCAL RegisterImeClass(
    HINSTANCE hInstance,
    HINSTANCE hInstL)
{
    WNDCLASSEX wcWndCls;

    // IME UI class
    // Register IME UI class
    wcWndCls.cbSize        = sizeof(WNDCLASSEX);
    wcWndCls.cbClsExtra    = 0;
    wcWndCls.cbWndExtra    = WND_EXTRA_SIZE;
    wcWndCls.hIcon         = LoadImage(hInstL, 
                                       MAKEINTRESOURCE(IDI_IME),
                                       IMAGE_ICON, 
                                       16, 
                                       16, 
                                       LR_DEFAULTCOLOR);
    wcWndCls.hInstance     = hInstance;
    wcWndCls.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wcWndCls.hbrBackground = GetStockObject(NULL_BRUSH);
    wcWndCls.lpszMenuName  = (LPTSTR)NULL;
    wcWndCls.hIconSm       = LoadImage(hInstL, 
                                       MAKEINTRESOURCE(IDI_IME),
                                       IMAGE_ICON, 
                                       16, 
                                       16, 
                                       LR_DEFAULTCOLOR);

    // IME UI class
    if (!GetClassInfoEx(hInstance, szUIClassName, &wcWndCls)) {
        wcWndCls.style         = CS_IME;
        wcWndCls.lpfnWndProc   = UIWndProc;
        wcWndCls.lpszClassName = (LPTSTR)szUIClassName;

        RegisterClassEx(&wcWndCls);
    }

    wcWndCls.style         = CS_IME|CS_HREDRAW|CS_VREDRAW;
    wcWndCls.hbrBackground = GetStockObject(LTGRAY_BRUSH);


    // IME composition class
    // register IME composition class
    if (!GetClassInfoEx(hInstance, szCompClassName, &wcWndCls)) {
        wcWndCls.lpfnWndProc   = CompWndProc;
        wcWndCls.lpszClassName = (LPTSTR)szCompClassName;

        RegisterClassEx(&wcWndCls);
    }

    // IME candidate class
    // register IME candidate class
    if (!GetClassInfoEx(hInstance, szCandClassName, &wcWndCls)) {
        wcWndCls.lpfnWndProc   = CandWndProc;
        wcWndCls.lpszClassName = (LPTSTR)szCandClassName;

        RegisterClassEx(&wcWndCls);
    }

    // IME status class
    // register IME status class
    if (!GetClassInfoEx(hInstance, szStatusClassName, &wcWndCls)) {
        wcWndCls.lpfnWndProc   = StatusWndProc;
        wcWndCls.lpszClassName = (LPTSTR)szStatusClassName;

        RegisterClassEx(&wcWndCls);
    }

    // IME context menu class
    if (!GetClassInfoEx(hInstance, szCMenuClassName, &wcWndCls)) {
        wcWndCls.style         = 0;
        wcWndCls.hbrBackground = GetStockObject(NULL_BRUSH);
        wcWndCls.lpfnWndProc   = ContextMenuWndProc;
        wcWndCls.lpszClassName = (LPTSTR)szCMenuClassName;

        RegisterClassEx(&wcWndCls);
    }
    // IME softkeyboard menu class
    if (!GetClassInfoEx(hInstance, szSoftkeyMenuClassName, &wcWndCls)) {
        wcWndCls.style         = 0;
        wcWndCls.hbrBackground = GetStockObject(NULL_BRUSH);
        wcWndCls.lpfnWndProc   = SoftkeyMenuWndProc;
        wcWndCls.lpszClassName = (LPTSTR)szSoftkeyMenuClassName;

        RegisterClassEx(&wcWndCls);
    }

    return;
}

/**********************************************************************/
/* ImeDllInit()                                                       */
/* Return Value:                                                      */
/*      TRUE - successful                                             */
/*      FALSE - failure                                               */
/**********************************************************************/
BOOL CALLBACK ImeDllInit(
    HINSTANCE hInstance,        // instance handle of this library
    DWORD     fdwReason,        // reason called
    LPVOID    lpvReserve)       // reserve pointer
{
    switch (fdwReason) {
    case DLL_PROCESS_ATTACH:

        // init MB Index
        RegisterIme(hInstance);

        // init globaldata & load globaldata from resource
        if (!hInst) {
            InitImeGlobalData(hInstance);
        }

        if (!lpImeL) {
            lpImeL = &sImeL;
            InitImeLocalData(hInstance);
        }

        RegisterImeClass(hInstance, hInstance);

        break;
    case DLL_PROCESS_DETACH:
        {
            WNDCLASSEX wcWndCls;

            if (GetClassInfoEx(hInstance, szCMenuClassName, &wcWndCls)) {
                UnregisterClass(szCMenuClassName, hInstance);
            }

            if (GetClassInfoEx(hInstance, szSoftkeyMenuClassName, &wcWndCls)) {
                UnregisterClass(szSoftkeyMenuClassName, hInstance);
            }

            if (GetClassInfoEx(hInstance, szStatusClassName, &wcWndCls)) {
                UnregisterClass(szStatusClassName, hInstance);
            }

            if (GetClassInfoEx(hInstance, szCandClassName, &wcWndCls)) {
                UnregisterClass(szCandClassName, hInstance);
            }

            if (GetClassInfoEx(hInstance, szCompClassName, &wcWndCls)) {
                UnregisterClass(szCompClassName, hInstance);
            }

            if (!GetClassInfoEx(hInstance, szUIClassName, &wcWndCls)) {
            } else if (!UnregisterClass(szUIClassName, hInstance)) {
            } else {
                DestroyIcon(wcWndCls.hIcon);
                DestroyIcon(wcWndCls.hIconSm);
            }
        }
        break;
    default:
        break;
    }

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntime\regword.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    REGWORD.C - register word into dictionary of IME
    
++*/

#include <windows.h>
#include <immdev.h>
#include <imedefs.h>
#include <regstr.h>


#ifdef EUDC

/**********************************************************************/
/* ImeRegsisterWord                                                   */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL WINAPI ImeRegisterWord(
    LPCTSTR lpszReading,
    DWORD   dwStyle,
    LPCTSTR lpszString)
{
    HIMCC      hPrivate;

    if (!lpszString || (lpszString[0] ==TEXT('\0'))) {
        return (FALSE);
    }

    if (!lpszReading || (lpszReading[0] == TEXT('\0'))) {
        return (FALSE);
    }

    // only handle word not string now, should consider string later?
    if (*(LPCTSTR)((LPBYTE)lpszString + sizeof(WORD)) != TEXT('\0')) {
        return (FALSE);
    }

    hPrivate = (HIMCC)ImmCreateIMCC(sizeof(PRIVCONTEXT));
                
    if (hPrivate != (HIMCC)NULL){
        StartEngine(hPrivate);
        AddZCItem(hPrivate, (LPTSTR)lpszReading, (LPTSTR)lpszString);
        EndEngine(hPrivate);
        ImmDestroyIMCC(hPrivate);
        return (TRUE);
    }
    else
        return (FALSE);
}

/**********************************************************************/
/* ImeUnregsisterWord                                                 */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL WINAPI ImeUnregisterWord(
    LPCTSTR lpszReading,
    DWORD   dwStyle,
    LPCTSTR lpszString)
{
    BOOL                  fRet;
    HANDLE                hUsrDicMem, hUsrDicFile;
    LPTSTR                lpUsrDicStart, lpCurr, lpUsrDicLimit, lpUsrDic;
    LPWORD                lpwStart;
    WORD                  wNum_EMB;
    PSECURITY_ATTRIBUTES  psa;
    TCHAR                 szReading[MAXCODE];
    int                   i;

    fRet = FALSE;

    if (!lpszString || !lpszReading) {
        return (fRet);
    }

    if (!(dwStyle & IME_REGWORD_STYLE_EUDC)) {
        return (fRet);
    }

    // only handle word not string now, should consider string later?
    if (*(LPCTSTR)((LPBYTE)lpszString + sizeof(WORD)) != TEXT('\0')) {
        return (fRet);
    }

    if (!MBIndex.EUDCData.szEudcDictName[0]) {
        return (fRet);
    }

    psa = CreateSecurityAttributes();

    hUsrDicFile = CreateFile(MBIndex.EUDCData.szEudcDictName,
                             GENERIC_READ | GENERIC_WRITE,
                             FILE_SHARE_READ|FILE_SHARE_WRITE,
                             psa,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL,
                             (HANDLE)NULL);

    if (hUsrDicFile == INVALID_HANDLE_VALUE) {
       FreeSecurityAttributes(psa);
       return FALSE;
    }

    hUsrDicMem = CreateFileMapping(hUsrDicFile,
                                   psa,
                                   PAGE_READWRITE,
                                   0,
                                   sizeof(EMB_Head)*MAXNUMBER_EMB+2,
                                   MBIndex.EUDCData.szEudcMapFileName);
    if (!hUsrDicMem) {

        CloseHandle(hUsrDicFile);
        FreeSecurityAttributes(psa);
        return (fRet);
    }

    FreeSecurityAttributes(psa);

    lpUsrDic = MapViewOfFile(hUsrDicMem, FILE_MAP_WRITE, 0, 0, 0);

    if (!lpUsrDic) {
        CloseHandle(hUsrDicFile);
        CloseHandle(hUsrDicMem);
        return (fRet);
    }

    lpwStart = (LPWORD)lpUsrDic;
    wNum_EMB = *lpwStart;

    // skip the first two bytes which contain the numeber of EMB records.

    lpUsrDicStart =(LPTSTR) ( (LPBYTE)lpUsrDic + sizeof(WORD) ); 

    lpUsrDicLimit=lpUsrDicStart+(sizeof(EMB_Head)*wNum_EMB)/sizeof(TCHAR);

    for (i=0; i<MAXCODE; i++) 
        szReading[i] = TEXT('\0');

    for (i=0; i<lstrlen(lpszReading); i++)
        szReading[i] = lpszReading[i];

    for (lpCurr = lpUsrDicStart; lpCurr < lpUsrDicLimit;
                  lpCurr += sizeof(EMB_Head) / sizeof(TCHAR) ) {

         EMB_Head  *lpEMB_Head;

         lpEMB_Head = (EMB_Head *)lpCurr;

        // find the internal code, if this record contains a phrase, skip it.
        if ( lpEMB_Head->C_Char[sizeof(WORD)/sizeof(TCHAR)] != TEXT('\0') )
           continue;

        if (memcmp((LPBYTE)lpszString, (LPBYTE)(lpEMB_Head->C_Char), 2) != 0) 
           continue;

        if (memcmp((LPBYTE)szReading,(LPBYTE)(lpEMB_Head->W_Code),
                    MAXCODE*sizeof(TCHAR) ) == 0 ) 
            break;
        
    }

    if (lpCurr < lpUsrDicLimit) {
       // we found a record matching the requested lpszReading and lpszString 

       LPTSTR    lpCurrNext;

       wNum_EMB --;
       *lpwStart = wNum_EMB;
       
       lpCurrNext = lpCurr + sizeof(EMB_Head)/sizeof(TCHAR);

       // move every next EMB record ahead.

       while (lpCurrNext < lpUsrDicLimit) {
             for (i=0; i<sizeof(EMB_Head)/sizeof(TCHAR); i++)
                 *lpCurr++ = *lpCurrNext++;

       }

       // put zero to the last EMB record.

       for (i=0; i<sizeof(EMB_Head)/sizeof(TCHAR); i++)
           *lpCurr++ = TEXT('\0');
                  
    } 

    UnmapViewOfFile(lpUsrDic);
    
    CloseHandle(hUsrDicMem);
    CloseHandle(hUsrDicFile);

    return (TRUE);
}

/**********************************************************************/
/* ImeGetRegsisterWordStyle                                           */
/* Return Value:                                                      */
/*      number of styles copied/required                              */
/**********************************************************************/
UINT WINAPI ImeGetRegisterWordStyle(
    UINT       nItem,
    LPSTYLEBUF lpStyleBuf)
{
    if (!nItem) {
        return (1);
    }

    // invalid case
    if (!lpStyleBuf) {
        return (0);
    }

    lpStyleBuf->dwStyle = IME_REGWORD_STYLE_EUDC;

    LoadString(hInst, IDS_EUDC, lpStyleBuf->szDescription,
        sizeof(lpStyleBuf->szDescription)/sizeof(TCHAR));

    return (1);
}

/**********************************************************************/
/* ImeEnumRegisterWord                                                */
/* Return Value:                                                      */
/*      the last value return by the callback function                */
/**********************************************************************/
UINT WINAPI ImeEnumRegisterWord(
    REGISTERWORDENUMPROC lpfnRegisterWordEnumProc,
    LPCTSTR              lpszReading,
    DWORD                dwStyle,
    LPCTSTR              lpszString,
    LPVOID               lpData)
{
    HANDLE                hUsrDicMem;
    HANDLE                hUsrDicFile;
    LPTSTR                lpUsrDicStart, lpCurr, lpUsrDicLimit, lpUsrDic;
    UINT                  uRet;
    int                   i;
    LPWORD                lpwStart;
    WORD                  wNum_EMB;
    PSECURITY_ATTRIBUTES  psa;
    TCHAR                 szReading[MAXCODE];
    TCHAR                 szString[MAXINPUTWORD];

    uRet = 0;

    if (dwStyle != IME_REGWORD_STYLE_EUDC) {
        return (uRet);
    }

    if (lpszString && (*(LPCTSTR)((LPBYTE)lpszString+sizeof(WORD))!=TEXT('\0')) )
        return (uRet);

    if (!MBIndex.EUDCData.szEudcDictName[0]) {
        return (uRet);
    }

    psa = CreateSecurityAttributes();

    hUsrDicFile = CreateFile(MBIndex.EUDCData.szEudcDictName,
                             GENERIC_READ | GENERIC_WRITE,
                             FILE_SHARE_READ|FILE_SHARE_WRITE,
                             psa,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL,
                             (HANDLE)NULL);

    if (hUsrDicFile == INVALID_HANDLE_VALUE) {
       FreeSecurityAttributes(psa);
       return (uRet);
    }

    hUsrDicMem = CreateFileMapping(hUsrDicFile,
                                   psa,
                                   PAGE_READWRITE,
                                   0,
                                   sizeof(EMB_Head)*MAXNUMBER_EMB+2,
                                   MBIndex.EUDCData.szEudcMapFileName);
    if (!hUsrDicMem) {

        CloseHandle(hUsrDicFile);
        FreeSecurityAttributes(psa);
        return (uRet);
    }

    FreeSecurityAttributes(psa);

    lpUsrDic = MapViewOfFile(hUsrDicMem, FILE_MAP_WRITE, 0, 0, 0);

    if (!lpUsrDic) {
        CloseHandle(hUsrDicMem);
        CloseHandle(hUsrDicFile);
        return (uRet);
    }

    lpwStart = (LPWORD)lpUsrDic;
    wNum_EMB = *lpwStart;

    lpUsrDicStart = (LPTSTR)( (LPBYTE)lpUsrDic + sizeof(WORD) );
    lpUsrDicLimit = lpUsrDicStart+(sizeof(EMB_Head)*wNum_EMB)/sizeof(TCHAR);

    for (i=0; i<MAXCODE; i++)
        szReading[i] = TEXT('\0');

    for (i=0; i<MAXINPUTWORD; i++)
        szString[i] = TEXT('\0');

    if ( lpszReading )
       for (i=0; i<lstrlen(lpszReading); i++)
           szReading[i] = lpszReading[i];

    if ( lpszString )
       for (i=0; i<lstrlen(lpszString); i++) 
            szString[i]=lpszString[i];

    for (lpCurr = lpUsrDicStart; lpCurr < lpUsrDicLimit;
                  lpCurr += (sizeof(EMB_Head)*wNum_EMB)/sizeof(TCHAR)) {

        TCHAR    szBufReading[MAXCODE];
        TCHAR    szBufString[MAXINPUTWORD];
        EMB_Head *lpEMB_Head;
        BOOL     fMatched;

        lpEMB_Head = (EMB_Head *)lpCurr;

        for ( i=0; i<MAXCODE; i++)
            szBufReading[i] = lpEMB_Head->W_Code[i];

        for ( i=0; i<MAXINPUTWORD; i++)
            szBufString[i] = lpEMB_Head->C_Char[i];

        // Because here we handle only EUDC chars, if it is a phrase, 
        // just skip it.

        fMatched = FALSE;

        if ( szBufString[sizeof(WORD)/sizeof(TCHAR)] != TEXT('\0') )
           continue;

        if ( !lpszReading  && !lpszString) {
            fMatched = TRUE;
        }
        else {

        // if lpszReading is NULL, enumerate all availible reading strings
        // matching with the specified lpszString

            if ( !lpszReading) {
               if (memcmp((LPBYTE)szBufString,(LPBYTE)szString, 2) ==0) {
                   fMatched = TRUE; 
               }
            }
         
            if ( !lpszString ) {
               if (memcmp((LPBYTE)szBufReading, (LPBYTE)szReading, 
                           MAXCODE*sizeof(TCHAR) ) == 0 ) {
                   fMatched = TRUE;
               }
            }

            if ( lpszReading && lpszString) {
               if ( (memcmp((LPBYTE)szBufString,(LPBYTE)szString, 2) ==0) &&
                    (memcmp((LPBYTE)szBufReading, (LPBYTE)szReading,
                             MAXCODE*sizeof(TCHAR) ) == 0 ) ) {
                   fMatched = TRUE;
               }
            }
            
        }

        if ( fMatched == TRUE ) {

          uRet=(*lpfnRegisterWordEnumProc)((const unsigned short *)szBufReading,
                                           IME_REGWORD_STYLE_EUDC, 
                                           (const unsigned short *)szBufString,
                                           lpData);
          if (!uRet)  break;
        }
                
    }

    UnmapViewOfFile(lpUsrDic);

    CloseHandle(hUsrDicMem);
    CloseHandle(hUsrDicFile);

    return (uRet);
}

#else
/**********************************************************************/
/* ImeRegsisterWord                                                   */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL WINAPI ImeRegisterWord(
    LPCTSTR lpszReading,
    DWORD   dwStyle,
    LPCTSTR lpszString)
{
    return (FALSE);
}

/**********************************************************************/
/* ImeUnregsisterWord                                                 */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL WINAPI ImeUnregisterWord(
    LPCTSTR lpszReading,
    DWORD   dwStyle,
    LPCTSTR lpszString)
{
    return (FALSE);
}

/**********************************************************************/
/* ImeGetRegsisterWordStyle                                           */
/* Return Value:                                                      */
/*      number of styles copied/required                              */
/**********************************************************************/
UINT WINAPI ImeGetRegisterWordStyle(
    UINT       nItem,
    LPSTYLEBUF lpStyleBuf)
{
    return (FALSE);
}

/**********************************************************************/
/* ImeEnumRegisterWord                                                */
/* Return Value:                                                      */
/*      the last value return by the callback function                */
/**********************************************************************/
UINT WINAPI ImeEnumRegisterWord(
    REGISTERWORDENUMPROC lpfnRegisterWordEnumProc,
    LPCTSTR              lpszReading,
    DWORD                dwStyle,
    LPCTSTR              lpszString,
    LPVOID               lpData)
{
    return (FALSE);
}
#endif //EUDC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntime\resource.h ===
/*************************************************
 *  resource.h                                   *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

#define IDC_CURSOR1                     120
#define IDC_LX                          1001
#define IDC_CZ                          1002
#define IDC_TS                          1003
#define IDC_CTS                         1004
#define IDC_TC                          1005
#define IDC_FCSR                        1006
#define IDC_FCTS                        1007
#if defined(COMBO_IME)
#define IDC_GB                          1026
#define IDC_GBK                         1027
#endif //COMBO_IME


#define IDC_INPUTWORD                   1007
#define IDC_INPUTCODE                   1008
#define IDC_HLP                         1009
#define IDC_LIST_WORD                   1010
#define IDC_STATIC1                     1011
#define IDC_STATIC2                     1012
#define IDC_UI1                         1013
#define IDC_UI2                         1014
#define IDC_BT_MODIFY                   1016
#define IDC_LIST2                       1016
#define IDC_BT_DEL                      1017
#define IDC_IMECOMBO                    1017
#define IDC_CLOSE                       1018
#define IDD_LAYOUT_LIST                 1018
#define IDC_BT_HLP                      1019
#define IDC_RADIOADD                    1020
#define IDC_BT_INS                      1021
#define IDC_RADIOMOD                    1022
#define IDC_MODI_WORD                   1023
#define IDC_MODI_CODE                   1024

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        121
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1019
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntime\winbx\makefile.inc ===
!INCLUDE ..\MAKEFILE.INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntime\wincha\makefile.inc ===
!INCLUDE ..\MAKEFILE.INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntime\toascii.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    TOASCII.c
    
++*/

#include <windows.h>
#include <immdev.h>
#include <imedefs.h>

/**********************************************************************/
/* IsUsedCode()                                                       */
/* Return Value:                                                      */
/*      TURE: is UsedCode;  FALSE: is'nt UsedCode;                    */
/**********************************************************************/
BOOL IsUsedCode(
    WORD          wCharCode,
    LPPRIVCONTEXT lpImcP)
{
        WORD wFlg;

      for(wFlg=0; wFlg<MBIndex.MBDesc[0].wNumCodes; wFlg++)
        if (wCharCode == MBIndex.MBDesc[0].szUsedCode[wFlg])
            break;
      if(wFlg < MBIndex.MBDesc[0].wNumCodes)
          return (TRUE);
      return (FALSE);
}

/**********************************************************************/
/* ProcessKey()                                                       */
/* Return Value:                                                      */
/*      different state which input key will change IME to (CST_)     */
/**********************************************************************/
UINT PASCAL ProcessKey(     // this key will cause the IME go to what state
    WORD           wCharCode,
    UINT           uVirtKey,
    UINT           uScanCode,
    LPBYTE         lpbKeyState,
    LPINPUTCONTEXT lpIMC,
    LPPRIVCONTEXT  lpImcP)
{
    LPCOMPOSITIONSTRING lpCompStr;

    if (!lpIMC) {
        return (CST_INVALID);
    }

    if (!lpImcP) {
        return (CST_INVALID);
    }

    // filter system key (alt,alt+,ctrl,shift)
    // and fOpen, IME_CMODE_NOCONVERSION
    if (uVirtKey == VK_MENU) {               // ALT key
        return (CST_INVALID);
    } else if (uScanCode & KF_ALTDOWN) {    // ALT-xx key
        return (CST_INVALID);
    } else if (uVirtKey == VK_CONTROL) {    // CTRL key
        return (CST_INVALID);
    } else if (uVirtKey == VK_SHIFT) {      // SHIFT key
        return (CST_INVALID);
    } else if (!lpIMC->fOpen) {             // don't compose in 
                                            // close status
        return (CST_INVALID);
    } else if (lpIMC->fdwConversion & IME_CMODE_NOCONVERSION) {
        // Caps on/off
        if(uVirtKey == VK_CAPITAL) {
            return (CST_CAPITAL);
        }else        
            return (CST_INVALID);
    } else {
        // need more check
    }

    // Caps on/off
    if(uVirtKey == VK_CAPITAL) {
        return (CST_CAPITAL);
    }

    // SoftKBD
    if ((lpIMC->fdwConversion & IME_CMODE_SOFTKBD)
       && (lpImeL->dwSKWant != 0)){
        if (wCharCode >= TEXT(' ') && wCharCode <= TEXT('~')) {
          return (CST_SOFTKB);
        } else {
          return (CST_INVALID);
        }
    }
    
    // Online create word Hot Key
    if (lpbKeyState[VK_CONTROL] & 0x80) {
        if((uVirtKey == 0xc0) && (MBIndex.MBDesc[0].wNumRulers)) {
            return (CST_ONLINE_CZ);
        } else {
            return (CST_INVALID);
        }
    }
    
    // candidate alaredy open,  Choose State
    // PagUp, PagDown, -, =, Home, End,ECS,key
    if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
        if (uVirtKey == VK_PRIOR) {            // PageUp
            return (CST_CHOOSE);
        } else if (uVirtKey == VK_NEXT) {    // PageDown
            return (CST_CHOOSE);
        } else if (uVirtKey == VK_HOME) {    // Home
            return (CST_CHOOSE);
        } else if (uVirtKey == VK_END) {    // End
            return (CST_CHOOSE);
        } else if ((wCharCode == TEXT('-')) && (!IsUsedCode(TEXT('-'), lpImcP))) {
            return (CST_CHOOSE);
        } else if ((wCharCode == TEXT('=')) && (!IsUsedCode(TEXT('='), lpImcP))) {
            return (CST_CHOOSE);
        } else if (uVirtKey == VK_ESCAPE) {    // Esc
            return (CST_CHOOSE);
        } else if (uVirtKey == VK_RETURN) {
            if(MBIndex.IMEChara[0].IC_Enter) {
                return (CST_CHOOSE);
            }
        } else {
            // need more check
        }
    }

    // candidate alaredy open, shift + num key
    if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {

        WORD NumCode, wFlg;

        if(uVirtKey == TEXT(' ')) {
            if(MBIndex.IMEChara[0].IC_Space) {
                return (CST_CHOOSE);
            }
        }

        NumCode = 0x0030;
        for(wFlg=0; wFlg<10; wFlg++, NumCode++)
          if(IsUsedCode(NumCode, lpImcP)) break;
        if(wFlg == 10) {
            if (uVirtKey >= TEXT('0') && uVirtKey <= TEXT('9')
               && !(lpbKeyState[VK_SHIFT] & 0x80))
                return (CST_CHOOSE);
        } else {
            if (lpbKeyState[VK_SHIFT] & 0x80) {
                if ((uVirtKey >= TEXT('0')) && uVirtKey <= TEXT('9'))
                    return (CST_CHOOSE);
            }
        }
    }

    // IME_CMODE_CHARCODE
    if (lpIMC->fdwConversion & IME_CMODE_CHARCODE) {    //Code Input Mode
          return (CST_INVALID);
    }

    if (!(lpIMC->fdwConversion & IME_CMODE_NATIVE)) {
        // alphanumeric mode
        if (wCharCode >= TEXT(' ') && wCharCode <= TEXT('~')) {
            return (CST_ALPHANUMERIC);
        } else {
            return (CST_INVALID);
        }
    } else if(wCharCode == MBIndex.MBDesc[0].cWildChar) {
        if (lpImcP->iImeState != CST_INIT) {
       } else {
           return (CST_ALPHANUMERIC);
       }
    } else if (wCharCode == TEXT(' ')){
       if ((lpImcP->iImeState == CST_INIT)
        && !(lpImcP->PrivateArea.Comp_Status.dwSTLX)) {
              return (CST_ALPHANUMERIC);
       }
    } else if(wCharCode >= TEXT(' ') && wCharCode <= TEXT('~')) {
        if(!IsUsedCode(wCharCode, lpImcP)
        && lpImcP->iImeState != CST_INIT)
            return (CST_INVALID_INPUT);
    }

    // Esc key
    if ((uVirtKey == VK_ESCAPE)
       || ((uVirtKey == VK_RETURN)
       && (MBIndex.IMEChara[0].IC_Enter))) {

        register LPGUIDELINE lpGuideLine;
        register UINT        iImeState;

        lpGuideLine = ImmLockIMCC(lpIMC->hGuideLine);
        if(!lpGuideLine){
            return(CST_INVALID);
        }

        if (lpImcP->fdwImeMsg & MSG_ALREADY_START) {
            iImeState = CST_INPUT;
        } else if(lpImcP->PrivateArea.Comp_Status.OnLineCreWord) {
            iImeState = CST_ONLINE_CZ;
        } else if (!lpGuideLine) {
            iImeState = CST_INVALID;
        } else if (lpGuideLine->dwLevel == GL_LEVEL_NOGUIDELINE) {
            iImeState = CST_INVALID;
        } else {
            iImeState = CST_INVALID;
        }

        ImmUnlockIMCC(lpIMC->hGuideLine);

        return (iImeState);
    } 
    
    // BackSpace Key
    else if (uVirtKey == VK_BACK) {
        if (lpImcP->fdwImeMsg & MSG_ALREADY_START) {
            return (CST_INPUT);
        } else {
            return (CST_INVALID);
        }
    }
    
    else if (uVirtKey >= VK_NUMPAD0 && uVirtKey <= VK_DIVIDE) {
       if (lpImcP->iImeState != CST_INIT) {
            return (CST_INVALID_INPUT);
       } else {
            return (CST_ALPHANUMERIC);
       }
    }

    {
        register UINT iImeState;

        lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);

        if (!lpCompStr) {
           return (CST_INVALID);
        }

        // check finalize char
        if (lpIMC->fdwConversion & IME_CMODE_NATIVE) {
           if((IsUsedCode(wCharCode, lpImcP))
            || (wCharCode == MBIndex.MBDesc[0].cWildChar)) {
              if ((wCharCode == MBIndex.MBDesc[0].cWildChar)
                        && (lpImcP->PrivateArea.Comp_Status.dwSTMULCODE)) {
                iImeState = CST_INVALID_INPUT;
              } else if((!lpImcP->PrivateArea.Comp_Status.dwInvalid)
                && (lpCompStr->dwCursorPos < MBIndex.MBDesc[0].wMaxCodes)){
                  iImeState = CST_INPUT;
              } else if((lpCompStr->dwCursorPos == MBIndex.MBDesc[0].wMaxCodes)
                       && (lpImcP->PrivateArea.Comp_Status.dwSTMULCODE)) {
                  iImeState = CST_INPUT;
              } else {
                iImeState = CST_INVALID_INPUT;
              }
          } else if(wCharCode == TEXT(' ')) {
              iImeState = CST_INPUT;
          } else if (wCharCode >= TEXT(' ') && wCharCode <= TEXT('~')) {
              iImeState = CST_ALPHANUMERIC;
          } else {
            iImeState = CST_INVALID;
          }
        } else {
            iImeState = CST_INVALID;
        }


        ImmUnlockIMCC(lpIMC->hCompStr);
        return (iImeState);
    }
}

/**********************************************************************/
/* ImeProcessKey()                                                    */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL WINAPI ImeProcessKey(   // if this key is need by IME?
    HIMC   hIMC,
    UINT   uVirtKey,
    LPARAM lParam,
    CONST LPBYTE lpbKeyState)
{
    LPINPUTCONTEXT lpIMC;
    LPPRIVCONTEXT  lpImcP;
    BYTE           szAscii[4];
    int            nChars;
    int            iRet;
    BOOL           fRet;

    // can't compose in NULL hIMC
    if (!hIMC) {
        return (FALSE);
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return (FALSE);
    }

    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    if (!lpImcP) {
        ImmUnlockIMC(hIMC);
        return (FALSE);
    }

    nChars = ToAscii(uVirtKey, HIWORD(lParam), lpbKeyState,
                (LPVOID)szAscii, 0);

    if (!nChars) {
        szAscii[0] = 0;
    }

    iRet = ProcessKey((WORD)szAscii[0], uVirtKey, HIWORD(lParam), lpbKeyState, lpIMC, lpImcP);
    if(iRet == CST_INVALID) {
        if ((lpImcP->fdwImeMsg & MSG_ALREADY_OPEN)
           && (lpImcP->iImeState == CST_INIT)
           && !lpImcP->PrivateArea.Comp_Status.dwSTLX) {
            lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CLOSE_CANDIDATE) &
                ~(MSG_OPEN_CANDIDATE) & ~(MSG_IN_IMETOASCIIEX);
               GenerateMessage(hIMC, lpIMC, lpImcP);
            // init lpImcP
            lpImcP->PrivateArea.Comp_Context.szInBuffer[0] = 0;
            lpImcP->PrivateArea.Comp_Context.PromptCnt = 0;
            lpImcP->PrivateArea.Comp_Status.dwInvalid = 0;
            lpImcP->PrivateArea.Comp_Status.dwSTLX = 0;
            lpImcP->PrivateArea.Comp_Status.dwSTMULCODE = 0;
        }

        fRet = FALSE;
    } else if((iRet == CST_INPUT) && (uVirtKey == TEXT('\b'))
             && (lpImcP->iImeState == CST_INIT)) {
        lpImcP->fdwImeMsg = ((lpImcP->fdwImeMsg | MSG_END_COMPOSITION)
                            & ~(MSG_START_COMPOSITION)) & ~(MSG_IN_IMETOASCIIEX);

          if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
            ClearCand(lpIMC);
            lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CLOSE_CANDIDATE) &
                ~(MSG_OPEN_CANDIDATE);
        }

        GenerateMessage(hIMC, lpIMC, lpImcP);
        fRet = FALSE;
    } else if(uVirtKey == VK_CAPITAL) {
        DWORD fdwConversion;

        // init ime Private status
        lpImcP->PrivateArea.Comp_Status.dwSTLX = 0;
        lpImcP->PrivateArea.Comp_Status.dwSTMULCODE = 0;
        lpImcP->PrivateArea.Comp_Status.dwInvalid = 0;
//Change VK_CAPITAL status check to NT .351 IMM style.
#ifdef LATER    
//Code for Win95
        if (lpbKeyState[VK_CAPITAL] & 0x01) {
            // change to native mode
#ifdef EUDC
            fdwConversion = (lpIMC->fdwConversion |IME_CMODE_NATIVE);
            fdwConversion &= ~(IME_CMODE_CHARCODE | IME_CMODE_NOCONVERSION);
 
#else
            fdwConversion = (lpIMC->fdwConversion | IME_CMODE_NATIVE);
            fdwConversion &= ~(IME_CMODE_CHARCODE | IME_CMODE_EUDC | IME_CMODE_NOCONVERSION);
#endif    //EUDC
            uCaps = 0;
        } else {
#else //LATER
//Code for NT 3.51 
        if (lpbKeyState[VK_CAPITAL] & 0x01) {
            // change to alphanumeric mode
#ifdef EUDC
            fdwConversion = lpIMC->fdwConversion & ~(IME_CMODE_CHARCODE |
                IME_CMODE_NATIVE);
#else
            fdwConversion = lpIMC->fdwConversion & ~(IME_CMODE_CHARCODE |
                IME_CMODE_NATIVE | IME_CMODE_EUDC);
#endif //EUDC
            uCaps = 1;
        } else {
            // change to native mode
#ifdef EUDC
            fdwConversion = (lpIMC->fdwConversion |IME_CMODE_NATIVE);
            fdwConversion &= ~(IME_CMODE_CHARCODE | IME_CMODE_NOCONVERSION);
 
#else
            fdwConversion = (lpIMC->fdwConversion | IME_CMODE_NATIVE);
            fdwConversion &= ~(IME_CMODE_CHARCODE | IME_CMODE_EUDC | IME_CMODE_NOCONVERSION);
#endif    //EUDC
            uCaps = 0;
        }
#endif //LATER

        ImmSetConversionStatus(hIMC, fdwConversion, lpIMC->fdwSentence);
        fRet = FALSE;
    } else if((iRet == CST_ALPHANUMERIC)
              && !(lpIMC->fdwConversion & IME_CMODE_FULLSHAPE)
              && (uVirtKey == VK_SPACE)) {
        fRet = FALSE;
    } else {
        fRet = TRUE;
    }

    ImmUnlockIMCC(lpIMC->hPrivate);
    ImmUnlockIMC(hIMC);

    return (fRet);
}

/**********************************************************************/
/* TranslateSymbolChar()                                              */
/* Return Value:                                                      */
/*      the number of translated chars                                */
/**********************************************************************/
UINT PASCAL TranslateSymbolChar(
    LPTRANSMSGLIST lpTransBuf,
    WORD    wSymbolCharCode,
    BOOL    SymbolMode)
{
    UINT uRet;
    LPTRANSMSG lpTransMsg;

    uRet = 0;

    lpTransMsg = lpTransBuf->TransMsg;

    // NT need to modify this!
#ifdef UNICODE
    lpTransMsg->message = WM_CHAR;
    lpTransMsg->wParam  = (DWORD)wSymbolCharCode;
    lpTransMsg->lParam  = 1UL;
    lpTransMsg++;
    uRet++;
#else
    lpTransMsg->message = WM_CHAR;
    lpTransMsg->wParam  = (DWORD)HIBYTE(wSymbolCharCode);
    lpTransMsg->lParam  = 1UL;
    lpTransMsg++;
    uRet++;

    lpTransMsg->message = WM_CHAR;
    lpTransMsg->wParam  = (DWORD)LOBYTE(wSymbolCharCode);
    lpTransMsg->lParam  = 1UL;
    lpTransMsg++;
    uRet++;
#endif
    if(SymbolMode) {
//        lpTransMsg = lpTransBuf->TransMsg;
#ifdef UNICODE
        lpTransMsg->message = WM_CHAR;
        lpTransMsg->wParam  = (DWORD)wSymbolCharCode;
        lpTransMsg->lParam  = 1UL;
        lpTransMsg++;
        uRet++;
#else
        lpTransMsg->message = WM_CHAR;
        lpTransMsg->wParam  = (DWORD)HIBYTE(wSymbolCharCode);
        lpTransMsg->lParam  = 1UL;
        lpTransMsg++;
        uRet++;

        lpTransMsg->message = WM_CHAR;
        lpTransMsg->wParam  = (DWORD)LOBYTE(wSymbolCharCode);
        lpTransMsg->lParam  = 1UL;
        lpTransMsg++;
        uRet++;
#endif
    }

    if(MBIndex.IMEChara[0].IC_INSSPC) {
        lpTransMsg = lpTransBuf->TransMsg;
        lpTransMsg->message = WM_CHAR;
        lpTransMsg->wParam  = (DWORD)0x20;
        lpTransMsg->lParam  = 1UL;
        lpTransMsg++;
        uRet++;
    }

    return (uRet);         // generate two messages
}

/**********************************************************************/
/* TranslateFullChar()                                                */
/* Return Value:                                                      */
/*      the number of translated chars                                */
/**********************************************************************/
UINT PASCAL TranslateFullChar(
    LPTRANSMSGLIST lpTransBuf,
    WORD    wCharCode)
{
    // if your IME is possible to generate over ? messages,
    // you need to take care about it
    LPTRANSMSG lpTransMsg;

    wCharCode = sImeG.wFullABC[wCharCode - TEXT(' ')];

    lpTransMsg = lpTransBuf->TransMsg;

    // NT need to modify this!
#ifdef UNICODE
    lpTransMsg->message = WM_CHAR;
    lpTransMsg->wParam  = (DWORD)wCharCode;
    lpTransMsg->lParam  = 1UL;
    lpTransMsg++;
#else
    lpTransMsg->message = WM_CHAR;
    lpTransMsg->wParam  = (DWORD)HIBYTE(wCharCode);
    lpTransMsg->lParam  = 1UL;
    lpTransMsg++;

    lpTransMsg->message = WM_CHAR;
    lpTransMsg->wParam  = (DWORD)LOBYTE(wCharCode);
    lpTransMsg->lParam  = 1UL;
    lpTransMsg++;
#endif
    if(MBIndex.IMEChara[0].IC_INSSPC) {
        lpTransMsg = lpTransBuf->TransMsg;
        lpTransMsg->message = WM_CHAR;
        lpTransMsg->wParam  = (DWORD)0x20;
        lpTransMsg->lParam  = 1UL;
        lpTransMsg++;
        return (3);         // generate two messages
    } else {
        return (2);         // generate two messages
    }
}

/**********************************************************************/
/* TranslateToAscii()                                                 */
/* Return Value:                                                      */
/*      the number of translated chars                                */
/**********************************************************************/
UINT PASCAL TranslateToAscii(       // translate the key to WM_CHAR
                                    // as keyboard driver
    UINT    uVirtKey,
    UINT    uScanCode,
    LPTRANSMSGLIST lpTransBuf,
    WORD    wCharCode)
{
    LPTRANSMSG lpTransMsg;

    lpTransMsg = lpTransBuf->TransMsg;

    if (wCharCode) {                    // one char code
        lpTransMsg->message = WM_CHAR;
        lpTransMsg->wParam  = wCharCode;
        lpTransMsg->lParam  = (uScanCode << 16) | 1UL;
        return (1);
    }

    // no char code case
    return (0);
}

/**********************************************************************/
/* TranslateImeMessage()                                              */
/* Return Value:                                                      */
/*      the number of translated messages                             */
/**********************************************************************/
UINT PASCAL TranslateImeMessage(
    LPTRANSMSGLIST lpTransBuf,
    LPINPUTCONTEXT lpIMC,
    LPPRIVCONTEXT  lpImcP)
{
    UINT uNumMsg;
    UINT i;
    BOOL bLockMsgBuf;
    LPTRANSMSG lpTransMsg;

    uNumMsg = 0;
    bLockMsgBuf = FALSE;

    for (i = 0; i < 2; i++) {
        if (lpImcP->fdwImeMsg & MSG_CLOSE_CANDIDATE) {
            if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
                if (!i) {
                    uNumMsg++;
                } else {
                    lpTransMsg->message = WM_IME_NOTIFY;
                    lpTransMsg->wParam  = IMN_CLOSECANDIDATE;
                    lpTransMsg->lParam  = 0x0001;
                    lpTransMsg++;
                    lpImcP->fdwImeMsg &= ~(MSG_ALREADY_OPEN);
                }
            }
        }

        if (lpImcP->fdwImeMsg & MSG_END_COMPOSITION) {
            if (lpImcP->fdwImeMsg & MSG_ALREADY_START) {
                if (!i) {
                    uNumMsg++;
                } else {
                    lpTransMsg->message = WM_IME_ENDCOMPOSITION;
                    lpTransMsg->wParam  = 0;
                    lpTransMsg->lParam  = 0;
                    lpTransMsg++;
                    lpImcP->fdwImeMsg &= ~(MSG_ALREADY_START);
                }
            }
        }

        if (lpImcP->fdwImeMsg & MSG_START_COMPOSITION) {
            if (!(lpImcP->fdwImeMsg & MSG_ALREADY_START)) {
                if (!i) {
                    uNumMsg++;
                } else {
                    lpTransMsg->message = WM_IME_STARTCOMPOSITION;
                    lpTransMsg->wParam  = 0;
                    lpTransMsg->lParam  = 0;
                    lpTransMsg++;
                    lpImcP->fdwImeMsg |= MSG_ALREADY_START;
                }
            }
        }

        if (lpImcP->fdwImeMsg & MSG_IMN_COMPOSITIONPOS) {
            if (!i) {
                uNumMsg++;
            } else {
                lpTransMsg->message = WM_IME_NOTIFY;
                lpTransMsg->wParam  = IMN_SETCOMPOSITIONWINDOW;
                lpTransMsg->lParam  = 0;
                lpTransMsg++;
            }
        }

        if (lpImcP->fdwImeMsg & MSG_COMPOSITION) {
            if (!i) {
                uNumMsg++;
            } else {
                lpTransMsg->message = WM_IME_COMPOSITION;
                lpTransMsg->wParam  = (DWORD)lpImcP->dwCompChar;
                lpTransMsg->lParam  = (DWORD)lpImcP->fdwGcsFlag;
                lpTransMsg++;
            }
        }

        if (lpImcP->fdwImeMsg & MSG_GUIDELINE) {
            if (!i) {
                uNumMsg++;
            } else {
                lpTransMsg->message = WM_IME_NOTIFY;
                lpTransMsg->wParam  = IMN_GUIDELINE;
                lpTransMsg->lParam  = 0;
                lpTransMsg++;
            }
        }

        if (lpImcP->fdwImeMsg & MSG_OPEN_CANDIDATE) {
            if (!(lpImcP->fdwImeMsg & MSG_ALREADY_OPEN)
               || (lpImcP->PrivateArea.Comp_Status.dwSTMULCODE)
               || (lpImcP->PrivateArea.Comp_Status.dwSTLX)) {
                if (!i) {
                    uNumMsg++;
                } else {
                    lpTransMsg->message = WM_IME_NOTIFY;
                    lpTransMsg->wParam  = IMN_OPENCANDIDATE;
                    lpTransMsg->lParam  = 0x0001;
                    lpTransMsg++;
                    lpImcP->fdwImeMsg |= MSG_ALREADY_OPEN;
                }
            }
        }

        if (lpImcP->fdwImeMsg & MSG_CHANGE_CANDIDATE) {
            if (!i) {
                uNumMsg++;
            } else {
                lpTransMsg->message = WM_IME_NOTIFY;
                lpTransMsg->wParam  = IMN_CHANGECANDIDATE;
                lpTransMsg->lParam  = 0x0001;
                lpTransMsg++;
            }
        }

        if (lpImcP->fdwImeMsg & MSG_IMN_UPDATE_SOFTKBD) {
            if (!i) {
                uNumMsg++;
            } else {
                lpTransMsg->message = WM_IME_NOTIFY;
                lpTransMsg->wParam  = IMN_PRIVATE;
                lpTransMsg->lParam  = IMN_PRIVATE_UPDATE_SOFTKBD;
                lpTransMsg++;
            }
        }

        if (lpImcP->fdwImeMsg & MSG_IMN_UPDATE_STATUS) {
            if (!i) {
                uNumMsg++;
            } else {
                lpTransMsg->message = WM_IME_NOTIFY;
                lpTransMsg->wParam  = IMN_PRIVATE;
                lpTransMsg->lParam  = IMN_PRIVATE_UPDATE_STATUS;
                lpTransMsg++;
            }
        }

        if (lpImcP->fdwImeMsg & MSG_IMN_DESTROYCAND) {
            if (!i) {
                uNumMsg++;
            } else {
                lpTransMsg->message = WM_IME_NOTIFY;
                lpTransMsg->wParam  = IMN_PRIVATE;
                lpTransMsg->lParam  = IMN_PRIVATE_DESTROYCANDWIN;
                lpTransMsg++;
            }
        }

        if (lpImcP->fdwImeMsg & MSG_BACKSPACE) {
            if (!i) {
                uNumMsg++;
            } else {
                lpTransMsg->message = WM_CHAR;
                lpTransMsg->wParam  = TEXT('\b');
                lpTransMsg->lParam  = 0x000e;
                lpTransMsg++;
            }
        }

        if (!i) {
            HIMCC hMem;

            if (!uNumMsg) {
                return (uNumMsg);
            }

            if (lpImcP->fdwImeMsg & MSG_IN_IMETOASCIIEX) {
                UINT uNumMsgLimit;

                uNumMsgLimit = lpTransBuf->uMsgCount;

                if (uNumMsg <= uNumMsgLimit) {
                    lpTransMsg = lpTransBuf->TransMsg;
                    continue;
                }
            }

            // we need to use message buffer
            if (!lpIMC->hMsgBuf) {
                lpIMC->hMsgBuf = ImmCreateIMCC(uNumMsg * sizeof(TRANSMSG));
                lpIMC->dwNumMsgBuf = 0;
            } else if (hMem = ImmReSizeIMCC(lpIMC->hMsgBuf,
                (lpIMC->dwNumMsgBuf + uNumMsg) * sizeof(TRANSMSG))) {
                if (hMem != lpIMC->hMsgBuf) {
                    ImmDestroyIMCC(lpIMC->hMsgBuf);
                    lpIMC->hMsgBuf = hMem;
                }
            } else {
                return (0);
            }

            lpTransMsg= (LPTRANSMSG) ImmLockIMCC(lpIMC->hMsgBuf);
            if (!lpTransMsg) {
                return (0);
            }

            lpTransMsg += lpIMC->dwNumMsgBuf;

            bLockMsgBuf = TRUE;
        } else {
            if (bLockMsgBuf) {
                ImmUnlockIMCC(lpIMC->hMsgBuf);
            }
        }
    }

    return (uNumMsg);
}

/**********************************************************************/
/* ImeToAsciiEx()                                                     */
/* Return Value:                                                      */
/*      the number of translated message                              */
/**********************************************************************/
UINT WINAPI ImeToAsciiEx(
    UINT    uVirtKey,
    UINT    uScanCode,
    CONST LPBYTE  lpbKeyState,
    LPTRANSMSGLIST lpTransBuf,
    UINT    fuState,
    HIMC    hIMC)
{
    WORD                wCharCode;
    LPINPUTCONTEXT      lpIMC;
    LPCOMPOSITIONSTRING lpCompStr;
    LPPRIVCONTEXT       lpImcP;
    UINT                uNumMsg;
    int                 iRet;

#ifdef UNICODE
    wCharCode = HIWORD(uVirtKey);
#else
    wCharCode = HIBYTE(uVirtKey);
#endif
    uVirtKey = LOBYTE(uVirtKey);

    // hIMC=NULL?
    if (!hIMC) {
        uNumMsg = TranslateToAscii(uVirtKey, uScanCode, lpTransBuf,
            wCharCode);
        return (uNumMsg);
    }

    // get lpIMC
    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    
    if (!lpIMC) {
        uNumMsg = TranslateToAscii(uVirtKey, uScanCode, lpTransBuf,
            wCharCode);
        return (uNumMsg);
    }

    // get lpImcP
    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    
    if (!lpImcP) {
        ImmUnlockIMC(hIMC);
        uNumMsg = TranslateToAscii(uVirtKey, uScanCode, lpTransBuf,
            wCharCode);
        return (uNumMsg);
    }

    // get lpCompStr and init
    if (lpImcP->fdwGcsFlag & (GCS_RESULTREAD|GCS_RESULT)) {
        lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);

        if (lpCompStr) {
            lpCompStr->dwResultStrLen = 0;
        }

        ImmUnlockIMCC(lpIMC->hCompStr);

        lpImcP->fdwGcsFlag = (DWORD) 0;
    }

    // Now all composition realated information already pass to app
    // a brand new start

    // init lpImcP->fdwImeMsg
    lpImcP->fdwImeMsg = lpImcP->fdwImeMsg & (MSG_ALREADY_OPEN|
        MSG_ALREADY_START) | MSG_IN_IMETOASCIIEX;
    
    // Process Key(wCharCode)
    iRet = ProcessKey(wCharCode, uVirtKey, uScanCode, lpbKeyState, lpIMC,
        lpImcP);

    // iRet process
    // CST_ONLINE_CZ
    if (iRet == CST_ONLINE_CZ) {
        lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_IMN_UPDATE_STATUS) & ~(MSG_IN_IMETOASCIIEX);
        if(wCharCode == VK_ESCAPE) {
            CWCodeStr[0] = 0;
            CWDBCSStr[0] = 0;
            lpImcP->PrivateArea.Comp_Status.OnLineCreWord = 0;
        } else {
            lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
            if (!lpCompStr) {
                return 0;
            }

            Finalize(lpIMC, lpCompStr, lpImcP, 0x1b);    // compsition
            ClearCand(lpIMC);
            lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CLOSE_CANDIDATE) &
            ~(MSG_OPEN_CANDIDATE);

            lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_END_COMPOSITION) &
            ~(MSG_START_COMPOSITION);

            InitCompStr(lpCompStr);

            lpImcP->PrivateArea.Comp_Status.OnLineCreWord ^= 1;
            lpImcP->iImeState = CST_INIT;
            // init fields of hPrivate
            lpImcP->dwCompChar = (DWORD) 0;
            lpImcP->PrivateArea.Comp_Status.dwSTLX = 0;
            lpImcP->PrivateArea.Comp_Status.dwSTMULCODE = 0;
            lpImcP->PrivateArea.Comp_Status.dwInvalid = 0;
            
            // online create word
            if((!lpImcP->PrivateArea.Comp_Status.OnLineCreWord)
              && (lstrlen(CWDBCSStr))) {
                TCHAR MBName[MAXSTRLEN];
                TCHAR Buf[LINE_LEN];
                  
                lstrcpy(MBName, sImeG.szIMESystemPath);
                  lstrcat((LPTSTR)MBName, TEXT("\\"));
                  lstrcat((LPTSTR)MBName, (LPCTSTR)lpImcP->MB_Name);
                ConvCreateWord( lpIMC->hWnd, 
                                (LPCTSTR)MBName,
                                (LPTSTR)CWDBCSStr, 
                                (LPTSTR)CWCodeStr);

                // In current GBK and Unicode Encoding, one Chinese character
                // has two bytes as its internal code.

                if(lstrlen(CWDBCSStr) <= (sizeof(WORD) / sizeof(TCHAR))) {
                    InfoMessage(NULL, IDS_WARN_MEMPRASE);
                    CWCodeStr[0] = 0;
                    CWDBCSStr[0] = 0;
                } else if(lstrlen(CWDBCSStr) && lstrlen(CWCodeStr)) {
                    int iAddRet;
                    TCHAR czCZ_Confirm_Title[20];

                    LoadString(hInst, IDS_CZ_CONFIRM, Buf, sizeof(Buf)/sizeof(TCHAR) );
                    LoadString(hInst, IDS_CZ_CONFIRM_TITLE, czCZ_Confirm_Title, 
                               sizeof(czCZ_Confirm_Title) / sizeof(TCHAR) );

                    lstrcat(Buf, TEXT("\n\n") );
                    lstrcat(Buf, CWDBCSStr);
                    lstrcat(Buf, TEXT(" ") );
                    lstrcat(Buf, CWCodeStr); 

                    if ( MessageBox(lpIMC->hWnd, Buf,czCZ_Confirm_Title, 
                                    MB_YESNO | MB_ICONINFORMATION) == IDYES) {
                        iAddRet = AddZCItem(lpIMC->hPrivate, CWCodeStr, CWDBCSStr);
                        if (iAddRet == ADD_FALSE) {
                            InfoMessage(NULL, IDS_WARN_MEMPRASE);
                        } else if (iAddRet == ADD_REP) {
                            InfoMessage(NULL, IDS_WARN_DUPPRASE);
                        } else if (iAddRet == ADD_FULL) {
                            InfoMessage(NULL, IDS_WARN_OVEREMB);
                        }
                    } else {
                        CWCodeStr[0] = 0;
                        CWDBCSStr[0] = 0;
                    }
                } else {
                    CWCodeStr[0] = 0;
                    CWDBCSStr[0] = 0;
                }
            } else {
                CWCodeStr[0] = 0;
                CWDBCSStr[0] = 0;
            }

            ImmUnlockIMCC(lpIMC->hCompStr);
        }

        lpImcP->fdwImeMsg = lpImcP->fdwImeMsg | MSG_IMN_UPDATE_STATUS;
        GenerateMessage(hIMC, lpIMC, lpImcP);
        uNumMsg = 0;
    }

    // CST_SOFTKB
    if (iRet == CST_SOFTKB) {
        WORD wSymbolCharCode;
        WORD CHIByte, CLOByte;
        int  SKDataIndex;

        // Mapping VK
        if(uVirtKey == 0x20) {
            SKDataIndex = 0;
        } else if(uVirtKey >= 0x30 && uVirtKey <= 0x39) {
            SKDataIndex = uVirtKey - 0x30 + 1;
        } else if (uVirtKey >= 0x41 && uVirtKey <= 0x5a) {
            SKDataIndex = uVirtKey - 0x41 + 0x0b;
        } else if (uVirtKey >= 0xba && uVirtKey <= 0xbf) {
            SKDataIndex = uVirtKey - 0xba + 0x25;
        } else if (uVirtKey >= 0xdb && uVirtKey <= 0xde) {
            SKDataIndex = uVirtKey - 0xdb + 0x2c;
        } else if (uVirtKey == 0xc0) {
            SKDataIndex = 0x2b;
        } else {
            SKDataIndex = 0;
        }

#ifdef UNICODE        //
        if (lpbKeyState[VK_SHIFT] & 0x80) {
            wSymbolCharCode = SKLayoutS[lpImeL->dwSKWant][SKDataIndex];
        } else {
            wSymbolCharCode = SKLayout[lpImeL->dwSKWant][SKDataIndex];
        }

        if(wSymbolCharCode == 0x0020) {
#else
        if (lpbKeyState[VK_SHIFT] & 0x80) {
            CHIByte = SKLayoutS[lpImeL->dwSKWant][SKDataIndex*2] & 0x00ff;
            CLOByte = SKLayoutS[lpImeL->dwSKWant][SKDataIndex*2 + 1] & 0x00ff;
        } else {
            CHIByte = SKLayout[lpImeL->dwSKWant][SKDataIndex*2] & 0x00ff;
            CLOByte = SKLayout[lpImeL->dwSKWant][SKDataIndex*2 + 1] & 0x00ff;
        }

        wSymbolCharCode = (CHIByte << 8) | CLOByte;
        if(wSymbolCharCode == 0x2020) {
#endif    //UNICODE

            MessageBeep((UINT) -1);
            uNumMsg = 0;
        } else {
            uNumMsg = TranslateSymbolChar(lpTransBuf, wSymbolCharCode, FALSE);
        }
    } 

    // CST_ALPHANUMERIC
    else if (iRet == CST_ALPHANUMERIC) {
        if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
            lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CLOSE_CANDIDATE) &
                ~(MSG_OPEN_CANDIDATE) & ~(MSG_IN_IMETOASCIIEX);
               GenerateMessage(hIMC, lpIMC, lpImcP);
            // init lpImcP
            lpImcP->PrivateArea.Comp_Context.szInBuffer[0] = 0;
            lpImcP->PrivateArea.Comp_Context.PromptCnt = 0;
            lpImcP->PrivateArea.Comp_Status.dwInvalid = 0;
            lpImcP->PrivateArea.Comp_Status.dwSTLX = 0;
            lpImcP->PrivateArea.Comp_Status.dwSTMULCODE = 0;
        }

        if (lpIMC->fdwConversion & IME_CMODE_SYMBOL) {
            WORD wSymbolCharCode;

            if(wCharCode == TEXT('.')) {
#ifdef UNICODE
                               wSymbolCharCode = 0x3002;
#else
                wSymbolCharCode = TEXT('');
#endif
                uNumMsg = TranslateSymbolChar(lpTransBuf, wSymbolCharCode, FALSE);
            } else if(wCharCode == TEXT(',')) {
#ifdef UNICODE
                wSymbolCharCode = 0xff0c;
#else
                wSymbolCharCode = TEXT('');
#endif
                uNumMsg = TranslateSymbolChar(lpTransBuf, wSymbolCharCode, FALSE);
            } else if(wCharCode == TEXT(';')) {
#ifdef UNICODE
                wSymbolCharCode = 0xff1b;
#else
                wSymbolCharCode = TEXT('');
#endif
                uNumMsg = TranslateSymbolChar(lpTransBuf, wSymbolCharCode, FALSE);
            } else if(wCharCode == TEXT(':')) {
#ifdef UNICODE
                wSymbolCharCode = 0xff1a;
#else
                wSymbolCharCode = TEXT('');
#endif
                uNumMsg = TranslateSymbolChar(lpTransBuf, wSymbolCharCode, FALSE);
            } else if(wCharCode == TEXT('?')) {
#ifdef UNICODE
                wSymbolCharCode = 0xff1f;
#else
                wSymbolCharCode = TEXT('');
#endif
                uNumMsg = TranslateSymbolChar(lpTransBuf, wSymbolCharCode, FALSE);
            } else if(wCharCode == TEXT('!')) {
#ifdef UNICODE
                wSymbolCharCode = 0xff01;
#else
                wSymbolCharCode = TEXT('');
#endif
                uNumMsg = TranslateSymbolChar(lpTransBuf, wSymbolCharCode, FALSE);
            } else if(wCharCode == TEXT('(')) {
#ifdef UNICODE
                wSymbolCharCode = 0xff08;
#else
                wSymbolCharCode = TEXT('');
#endif
                uNumMsg = TranslateSymbolChar(lpTransBuf, wSymbolCharCode, FALSE);
            } else if(wCharCode == TEXT(')')) {
#ifdef UNICODE
                wSymbolCharCode = 0xff09;
#else
                wSymbolCharCode = TEXT('');
#endif
                uNumMsg = TranslateSymbolChar(lpTransBuf, wSymbolCharCode, FALSE);
            } else if(wCharCode == TEXT('\\')) {
#ifdef UNICODE
                wSymbolCharCode = 0x3001;
#else
                wSymbolCharCode = TEXT('');
#endif
                uNumMsg = TranslateSymbolChar(lpTransBuf, wSymbolCharCode, FALSE);
            } else if(wCharCode == TEXT('@')) {
#ifdef UNICODE
                wSymbolCharCode = 0x00b7;
#else
                wSymbolCharCode = TEXT('');
#endif
                uNumMsg = TranslateSymbolChar(lpTransBuf, wSymbolCharCode, FALSE);
            } else if(wCharCode == TEXT('&')) {
#ifdef UNICODE
                wSymbolCharCode = 0x2014;
#else
                wSymbolCharCode = TEXT('');
#endif
                uNumMsg = TranslateSymbolChar(lpTransBuf, wSymbolCharCode, FALSE);
            } else if(wCharCode == TEXT('$')) {
#ifdef UNICODE
                wSymbolCharCode = 0xffe5;
#else
                wSymbolCharCode = TEXT('');
#endif
                uNumMsg = TranslateSymbolChar(lpTransBuf, wSymbolCharCode, FALSE);
            } else if(wCharCode == TEXT('_')) {
#ifdef UNICODE
                wSymbolCharCode = 0x2014;
#else
                wSymbolCharCode = TEXT('');
#endif
                uNumMsg = TranslateSymbolChar(lpTransBuf, wSymbolCharCode, 1);
            } else if(wCharCode == TEXT('^')) {
#ifdef UNICODE
                wSymbolCharCode = 0x2026;
#else
                wSymbolCharCode = TEXT('');
#endif
                uNumMsg = TranslateSymbolChar(lpTransBuf, wSymbolCharCode, 1);
            } else if(wCharCode == TEXT('"')) {
                if(lpImcP->uSYHFlg) {
#ifdef UNICODE
                    wSymbolCharCode = 0x201d;
                } else {
                    wSymbolCharCode = 0x201c;

#else
                    wSymbolCharCode = TEXT('');
                } else {
                    wSymbolCharCode = TEXT('');
#endif
                }
                lpImcP->uSYHFlg ^= 0x00000001;
                uNumMsg = TranslateSymbolChar(lpTransBuf, wSymbolCharCode, FALSE);
            } else if(wCharCode == TEXT('\'')) {
                if(lpImcP->uDYHFlg) {
#ifdef UNICODE
                    wSymbolCharCode = 0x2019;
                } else {
                    wSymbolCharCode = 0x2018;
#else
                    wSymbolCharCode = TEXT('');
                } else {
                    wSymbolCharCode = TEXT('');
#endif
                }
                lpImcP->uDYHFlg ^= 0x00000001;
                uNumMsg = TranslateSymbolChar(lpTransBuf, wSymbolCharCode, FALSE);
            } else if(wCharCode == TEXT('<')) {
                if(lpImcP->uDSMHFlg) {
#ifdef UNICODE
                    wSymbolCharCode = 0x3008;
#else
                    wSymbolCharCode = TEXT('');
#endif
                    lpImcP->uDSMHCount++;
                } else {
#ifdef UNICODE
                    wSymbolCharCode = 0x300a;
#else
                    wSymbolCharCode = TEXT('');
#endif
                    lpImcP->uDSMHFlg = 0x00000001;
                }
                uNumMsg = TranslateSymbolChar(lpTransBuf, wSymbolCharCode, FALSE);
            } else if(wCharCode == TEXT('>')) {
                if((lpImcP->uDSMHFlg) && (lpImcP->uDSMHCount)) {
#ifdef UNICODE
                    wSymbolCharCode = 0x3009;
#else
                    wSymbolCharCode = TEXT('');
#endif
                    lpImcP->uDSMHCount--;
                } else {
#ifdef UNICODE
                    wSymbolCharCode = 0x300b;
#else
                    wSymbolCharCode = TEXT('');
#endif
                    lpImcP->uDSMHFlg = 0x00000000;
                }
                uNumMsg = TranslateSymbolChar(lpTransBuf, wSymbolCharCode, FALSE);
            } else {
                if (lpIMC->fdwConversion & IME_CMODE_FULLSHAPE) {
                    // convert to DBCS
                    uNumMsg = TranslateFullChar(lpTransBuf, wCharCode);
                } else {
                    uNumMsg = TranslateToAscii(uVirtKey, uScanCode, lpTransBuf,
                        wCharCode);
                }
            }
        } else if (lpIMC->fdwConversion & IME_CMODE_FULLSHAPE) {
            // convert to DBCS
            uNumMsg = TranslateFullChar(lpTransBuf, wCharCode);
        } else {
            uNumMsg = TranslateToAscii(uVirtKey, uScanCode, lpTransBuf,
                wCharCode);
        }
    }
    // CST_CHOOSE
    else if (iRet == CST_CHOOSE) {
         LPCANDIDATEINFO lpCandInfo;

        lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo);
        if(!lpCandInfo){
            ImmUnlockIMC(hIMC);
            uNumMsg = TranslateToAscii(uVirtKey, uScanCode, lpTransBuf,
                wCharCode);
            return (uNumMsg);
        }

        if (uVirtKey == VK_PRIOR) {
            wCharCode = VK_PRIOR;
        } else if (uVirtKey == VK_NEXT) {
            wCharCode = VK_NEXT;
        } else if (uVirtKey == TEXT(' ')) {
            // convert space to '1'
            wCharCode = '1';
        } else if (uVirtKey >= TEXT('0') && uVirtKey <= TEXT('9')) {
            // convert shift-0 ... shift-9 to 0 ... 9
            wCharCode = (WORD) uVirtKey;
        } else if (uVirtKey == VK_HOME) {
            wCharCode = VK_HOME;
        } else if (uVirtKey == VK_END) {
            wCharCode = VK_END;
        } else if (wCharCode == TEXT('-')) {
            wCharCode = VK_PRIOR;
        } else if (wCharCode == TEXT('=')) {
            wCharCode = VK_NEXT;
        } else {
        }

        lpImcP->iImeState = CST_CHOOSE;
        Finalize(lpIMC, lpCompStr, lpImcP, wCharCode);    // compsition

        ChooseCand(wCharCode, lpIMC, lpCandInfo, lpImcP);

        ImmUnlockIMCC(lpIMC->hCandInfo);

        uNumMsg = TranslateImeMessage(lpTransBuf, lpIMC, lpImcP);
    }

    // CST_INPUT(IME_CMODE_CHARCODE)
    else if (iRet == CST_INPUT &&
        lpIMC->fdwConversion & IME_CMODE_CHARCODE) {
        lpImcP->iImeState = CST_INPUT;
        uNumMsg = TranslateToAscii(uVirtKey, uScanCode, lpTransBuf,
            wCharCode);
    }
    // CST_INPUT 
    else if (iRet == CST_INPUT) {
        LPGUIDELINE         lpGuideLine;

        // get lpCompStr & lpGuideLine
        lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
        
        if(!lpCompStr){
            ImmUnlockIMC(hIMC);
            uNumMsg = TranslateToAscii(uVirtKey, uScanCode, lpTransBuf,
                wCharCode);
            return (uNumMsg);
        }

        lpGuideLine = (LPGUIDELINE)ImmLockIMCC(lpIMC->hGuideLine);
        
        if(!lpGuideLine){
            ImmUnlockIMC(hIMC);
            uNumMsg = TranslateToAscii(uVirtKey, uScanCode, lpTransBuf,
                wCharCode);
            return (uNumMsg);
        }


        // composition
        CompWord(wCharCode, lpIMC, lpCompStr, lpImcP, lpGuideLine);

        ImmUnlockIMCC(lpIMC->hGuideLine);
        ImmUnlockIMCC(lpIMC->hCompStr);
        
        // generate message
        uNumMsg = TranslateImeMessage(lpTransBuf, lpIMC, lpImcP);
    }
    // ELSE
    else if (iRet == CST_INVALID_INPUT) {
            //MessageBeep((UINT) -1);
            uNumMsg = 0;
    }else {
        uNumMsg = TranslateToAscii(uVirtKey, uScanCode, lpTransBuf,
            wCharCode);
    }

    // reset lpImcP->fdwImeMsg
    lpImcP->fdwImeMsg &= (MSG_ALREADY_OPEN|MSG_ALREADY_START);
    lpImcP->fdwGcsFlag &= (GCS_RESULTREAD|GCS_RESULT);

    ImmUnlockIMCC(lpIMC->hPrivate);
    ImmUnlockIMC(hIMC);

    return (uNumMsg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntime\ui.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    UI.c
    
++*/

#include <windows.h>
#include <immdev.h>
#include <imedefs.h>

/**********************************************************************/
/* CMenuDestryed()                                                    */
/**********************************************************************/
void PASCAL CMenuDestroyed(             // context menu window
                                        // already destroyed
    HWND hUIWnd)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {     // Oh! Oh!
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {    // Oh! Oh!
        return;
    }

    lpUIPrivate->hCMenuWnd = NULL;

    GlobalUnlock(hUIPrivate);
}
/**********************************************************************/
/* SoftkeyMenuDestroyed()                                                    */
/**********************************************************************/
void PASCAL SoftkeyMenuDestroyed(             // context menu window
                                        // already destroyed
    HWND hUIWnd)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {     // Oh! Oh!
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {    // Oh! Oh!
        return;
    }

    lpUIPrivate->hSoftkeyMenuWnd = NULL;

    GlobalUnlock(hUIPrivate);
}

/**********************************************************************/
/* CreateUIWindow()                                                   */
/**********************************************************************/
void PASCAL CreateUIWindow(             // create composition window
    HWND hUIWnd)
{
    HGLOBAL hUIPrivate;

    // create storage for UI setting
    hUIPrivate = GlobalAlloc(GHND, sizeof(UIPRIV));
    if (!hUIPrivate) {     // Oh! Oh!
        return;
    }

    SetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE, (LONG_PTR)hUIPrivate);

    // set the default position for UI window, it is hide now
    SetWindowPos(hUIWnd, NULL, 0, 0, 0, 0, SWP_NOACTIVATE|SWP_NOZORDER);

    ShowWindow(hUIWnd, SW_SHOWNOACTIVATE);

    return;
}

/**********************************************************************/
/* DestroyUIWindow()                                                  */
/**********************************************************************/
void PASCAL DestroyUIWindow(            // destroy composition window
    HWND hUIWnd)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {     // Oh! Oh!
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {    // Oh! Oh!
        return;
    }

    //destroy ContextMenuWnd
    if (lpUIPrivate->hCMenuWnd) {
        SetWindowLongPtr(lpUIPrivate->hCMenuWnd, CMENU_HUIWND,(LONG_PTR)0);
        PostMessage(lpUIPrivate->hCMenuWnd, WM_USER_DESTROY, 0, 0);
    }
    //destroy SoftkeyMenuWnd
    if (lpUIPrivate->hSoftkeyMenuWnd) {
        SetWindowLongPtr(lpUIPrivate->hSoftkeyMenuWnd, SOFTKEYMENU_HUIWND,(LONG_PTR)0);
        PostMessage(lpUIPrivate->hSoftkeyMenuWnd, WM_USER_DESTROY, 0, 0);
    }

    // composition window need to be destroyed
    if (lpUIPrivate->hCompWnd) {
        DestroyWindow(lpUIPrivate->hCompWnd);
    }

    // candidate window need to be destroyed
    if (lpUIPrivate->hCandWnd) {
        DestroyWindow(lpUIPrivate->hCandWnd);
    }

    // status window need to be destroyed
    if (lpUIPrivate->hStatusWnd) {
        DestroyWindow(lpUIPrivate->hStatusWnd);
    }

    // soft keyboard window need to be destroyed
    if (lpUIPrivate->hSoftKbdWnd) {
        ImmDestroySoftKeyboard(lpUIPrivate->hSoftKbdWnd);
    }

    GlobalUnlock(hUIPrivate);

    // free storage for UI settings
    GlobalFree(hUIPrivate);

    return;
}

/**********************************************************************/
/* ShowSoftKbd                                                        */
/**********************************************************************/
void PASCAL ShowSoftKbd(   // Show the soft keyboard window
    HWND          hUIWnd,
    int           nShowSoftKbdCmd,
    LPPRIVCONTEXT lpImcP)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {          // can not darw status window
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw status window
        return;
    }

    CheckMenuItem(lpImeL->hSKMenu, IDM_SKL1, MF_UNCHECKED);
    CheckMenuItem(lpImeL->hSKMenu, IDM_SKL2, MF_UNCHECKED);
    CheckMenuItem(lpImeL->hSKMenu, IDM_SKL3, MF_UNCHECKED);
    CheckMenuItem(lpImeL->hSKMenu, IDM_SKL4, MF_UNCHECKED);
    CheckMenuItem(lpImeL->hSKMenu, IDM_SKL5, MF_UNCHECKED);
    CheckMenuItem(lpImeL->hSKMenu, IDM_SKL6, MF_UNCHECKED);
    CheckMenuItem(lpImeL->hSKMenu, IDM_SKL7, MF_UNCHECKED);
    CheckMenuItem(lpImeL->hSKMenu, IDM_SKL8, MF_UNCHECKED);
    CheckMenuItem(lpImeL->hSKMenu, IDM_SKL9, MF_UNCHECKED);
    CheckMenuItem(lpImeL->hSKMenu, IDM_SKL10, MF_UNCHECKED);
    CheckMenuItem(lpImeL->hSKMenu, IDM_SKL11, MF_UNCHECKED);
    CheckMenuItem(lpImeL->hSKMenu, IDM_SKL12, MF_UNCHECKED);
    CheckMenuItem(lpImeL->hSKMenu, IDM_SKL13, MF_UNCHECKED);

    if (!lpUIPrivate->hSoftKbdWnd) {
        // not in show status window mode
    } else if (lpUIPrivate->nShowSoftKbdCmd != nShowSoftKbdCmd) {
        ImmShowSoftKeyboard(lpUIPrivate->hSoftKbdWnd, nShowSoftKbdCmd);
        lpUIPrivate->nShowSoftKbdCmd = nShowSoftKbdCmd;
    }

    GlobalUnlock(hUIPrivate);
    return;
}

/**********************************************************************/
/* CheckSoftKbdPosition()                                             */
/**********************************************************************/
void PASCAL CheckSoftKbdPosition(
    LPUIPRIV       lpUIPrivate,
    LPINPUTCONTEXT lpIMC)
{
#if 0 // MultiMonitor support
    UINT fPortionBits = 0;
    UINT fPortionTest;
    int  xPortion, yPortion, nPortion;
    RECT rcWnd;

    // portion of dispaly
    // 0  1
    // 2  3

    if (lpUIPrivate->hCompWnd) {
        GetWindowRect(lpUIPrivate->hCompWnd, &rcWnd);

        if (rcWnd.left > sImeG.rcWorkArea.right / 2) {
            xPortion = 1;
        } else {
            xPortion = 0;
        }

        if (rcWnd.top > sImeG.rcWorkArea.bottom / 2) {
            yPortion = 1;
        } else {
            yPortion = 0;
        }

        fPortionBits |= 0x0001 << (yPortion * 2 + xPortion);
    }

    if (lpUIPrivate->hStatusWnd) {
        GetWindowRect(lpUIPrivate->hStatusWnd, &rcWnd);

        if (rcWnd.left > sImeG.rcWorkArea.right / 2) {
            xPortion = 1;
        } else {
            xPortion = 0;
        }

        if (rcWnd.top > sImeG.rcWorkArea.bottom / 2) {
            yPortion = 1;
        } else {
            yPortion = 0;
        }

        fPortionBits |= 0x0001 << (yPortion * 2 + xPortion);
    }

    GetWindowRect(lpUIPrivate->hSoftKbdWnd, &rcWnd);

    // start from portion 3
    for (nPortion = 3, fPortionTest = 0x0008; fPortionTest;
        nPortion--, fPortionTest >>= 1) {
        if (fPortionTest & fPortionBits) {
            // someone here!
            continue;
        }

        if (nPortion % 2) {
            lpIMC->ptSoftKbdPos.x = sImeG.rcWorkArea.right -
                (rcWnd.right - rcWnd.left) - UI_MARGIN;
        } else {
            lpIMC->ptSoftKbdPos.x = sImeG.rcWorkArea.left;
        }

        if (nPortion / 2) {
            lpIMC->ptSoftKbdPos.y = sImeG.rcWorkArea.bottom -
                (rcWnd.bottom - rcWnd.top) - UI_MARGIN;
        } else {
            lpIMC->ptSoftKbdPos.y = sImeG.rcWorkArea.top;
        }

        lpIMC->fdwInit |= INIT_SOFTKBDPOS;

        break;
    }
#else
    RECT rcWorkArea, rcWnd;

    GetWindowRect(lpUIPrivate->hSoftKbdWnd, &rcWnd);

    rcWorkArea = ImeMonitorWorkAreaFromWindow(lpIMC->hWnd);

    lpIMC->ptSoftKbdPos.x = rcWorkArea.right -
        (rcWnd.right - rcWnd.left) - UI_MARGIN;

    lpIMC->ptSoftKbdPos.y = rcWorkArea.bottom -
        (rcWnd.bottom - rcWnd.top) - UI_MARGIN;
#endif

    return;
}

/**********************************************************************/
/* SetSoftKbdData()                                                   */
/**********************************************************************/
void PASCAL SetSoftKbdData(
    HWND           hSoftKbdWnd,
    LPINPUTCONTEXT lpIMC)
{
    int         i;
    LPSOFTKBDDATA lpSoftKbdData;
    LPPRIVCONTEXT  lpImcP;

    HGLOBAL hsSoftKbdData;

       lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    if (!lpImcP) {
        return;
    }
    
    hsSoftKbdData = GlobalAlloc(GHND, sizeof(SOFTKBDDATA) * 2);
    if (!hsSoftKbdData) {
        ImmUnlockIMCC(lpIMC->hPrivate);
        return;
    }

    lpSoftKbdData = (LPSOFTKBDDATA)GlobalLock(hsSoftKbdData);
    if (!lpSoftKbdData) {         // can not draw soft keyboard window
        ImmUnlockIMCC(lpIMC->hPrivate);
        return;
    }

    lpSoftKbdData->uCount = 2;

    for (i = 0; i < MAXSOFTKEYS; i++) {
        BYTE bVirtKey;

        bVirtKey = VirtKey48Map[i];

        if (!bVirtKey) {
            continue;
        }

        {
            WORD CHIByte, CLOByte;
#ifdef UNICODE
            lpSoftKbdData->wCode[0][bVirtKey] = SKLayout[lpImeL->dwSKWant][i];
            lpSoftKbdData->wCode[1][bVirtKey] = SKLayoutS[lpImeL->dwSKWant][i];
#else
            CHIByte = SKLayout[lpImeL->dwSKWant][i*2] & 0x00ff;
            CLOByte = SKLayout[lpImeL->dwSKWant][i*2 + 1] & 0x00ff;
            lpSoftKbdData->wCode[0][bVirtKey] = (CHIByte << 8) | CLOByte;
            CHIByte = SKLayoutS[lpImeL->dwSKWant][i*2] & 0x00ff;
            CLOByte = SKLayoutS[lpImeL->dwSKWant][i*2 + 1] & 0x00ff;
            lpSoftKbdData->wCode[1][bVirtKey] = (CHIByte << 8) | CLOByte;
#endif
        }
    }

    SendMessage(hSoftKbdWnd, WM_IME_CONTROL, IMC_SETSOFTKBDDATA,
        (LPARAM)lpSoftKbdData);

    GlobalUnlock(hsSoftKbdData);

    // free storage for UI settings
    GlobalFree(hsSoftKbdData);
    ImmUnlockIMCC(lpIMC->hPrivate);
    return;
}

/**********************************************************************/
/* UpdateSoftKbd()                                                    */
/**********************************************************************/
void PASCAL UpdateSoftKbd(
    HWND   hUIWnd)
{
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    LPPRIVCONTEXT  lpImcP;
    HGLOBAL        hUIPrivate;
    LPUIPRIV       lpUIPrivate;

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return;
    }

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {          // can not darw soft keyboard window
        ImmUnlockIMC(hIMC);
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw soft keyboard window
        ImmUnlockIMC(hIMC);
        return;
    }

    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    if (!lpImcP) {
        GlobalUnlock(hUIPrivate);    
        ImmUnlockIMC(hIMC);
        return;
    }

    if (!(lpIMC->fdwConversion & IME_CMODE_SOFTKBD)) {
        if (lpUIPrivate->hSoftKbdWnd) {

            ImmDestroySoftKeyboard(lpUIPrivate->hSoftKbdWnd);
            lpUIPrivate->hSoftKbdWnd = NULL;
        }

        lpUIPrivate->nShowSoftKbdCmd = SW_HIDE;
    } else if (!lpIMC->fOpen) {
        if (lpUIPrivate->nShowSoftKbdCmd != SW_HIDE) {
            ShowSoftKbd(hUIWnd, SW_HIDE, NULL);
        }
    } else {
        if (!lpUIPrivate->hSoftKbdWnd) {
            // create soft keyboard
            lpUIPrivate->hSoftKbdWnd =
                ImmCreateSoftKeyboard(SOFTKEYBOARD_TYPE_C1, hUIWnd,
                0, 0);
        }

        if (!(lpIMC->fdwInit & INIT_SOFTKBDPOS)) {
            CheckSoftKbdPosition(lpUIPrivate, lpIMC);
        }

        SetSoftKbdData(lpUIPrivate->hSoftKbdWnd, lpIMC);

        lpUIPrivate->fdwSetContext |= ISC_SHOW_SOFTKBD;

        if (lpUIPrivate->nShowSoftKbdCmd == SW_HIDE) {
            SetWindowPos(lpUIPrivate->hSoftKbdWnd, NULL,
                lpIMC->ptSoftKbdPos.x, lpIMC->ptSoftKbdPos.y,
                0, 0, SWP_NOACTIVATE|SWP_NOSIZE|SWP_NOZORDER);

            // only show, if the application want to show it
            if (lpUIPrivate->fdwSetContext & ISC_SHOW_SOFTKBD) {
                ShowSoftKbd(hUIWnd, SW_SHOWNOACTIVATE, lpImcP);
            }
        }
    }

    ImmUnlockIMCC(lpIMC->hPrivate);
    GlobalUnlock(hUIPrivate);
    ImmUnlockIMC(hIMC);

    return;
}

/**********************************************************************/
/* SoftKbdDestryed()                                                  */
/**********************************************************************/
void PASCAL SoftKbdDestroyed(           // soft keyboard window
                                        // already destroyed
    HWND hUIWnd)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {     // Oh! Oh!
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {    // Oh! Oh!
        return;
    }

    lpUIPrivate->hSoftKbdWnd = NULL;

    GlobalUnlock(hUIPrivate);
}

/**********************************************************************/
/* StatusWndMsg()                                                     */
/**********************************************************************/
void PASCAL StatusWndMsg(       // set the show hide state and
    HWND        hUIWnd,
    BOOL        fOn)
{
    HGLOBAL  hUIPrivate;
    HIMC     hIMC;
    HWND     hStatusWnd;

    register LPUIPRIV lpUIPrivate;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {
        return;
    }

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    
    if (!hIMC) {
        GlobalUnlock(hUIPrivate);
    return;
    }
             
    if (fOn) {
        lpUIPrivate->fdwSetContext |= ISC_OPEN_STATUS_WINDOW;

        if (!lpUIPrivate->hStatusWnd) {
            OpenStatus(
                hUIWnd);
        }
    } else {
        lpUIPrivate->fdwSetContext &= ~(ISC_OPEN_STATUS_WINDOW);
    }

    hStatusWnd = lpUIPrivate->hStatusWnd;

    GlobalUnlock(hUIPrivate);

    if (!hStatusWnd) {
        return;
    }

    if (!fOn) {
        register DWORD fdwSetContext;

        fdwSetContext = lpUIPrivate->fdwSetContext &
            (ISC_SHOWUICOMPOSITIONWINDOW|ISC_HIDE_COMP_WINDOW);

        if (fdwSetContext == ISC_HIDE_COMP_WINDOW) {
            ShowComp(
                hUIWnd, SW_HIDE);
        }

        fdwSetContext = lpUIPrivate->fdwSetContext &
            (ISC_SHOWUICANDIDATEWINDOW|ISC_HIDE_CAND_WINDOW);

        if (fdwSetContext == ISC_HIDE_CAND_WINDOW) {
            ShowCand(
                hUIWnd, SW_HIDE);
        }

        fdwSetContext = lpUIPrivate->fdwSetContext &
            (ISC_SHOW_SOFTKBD|ISC_HIDE_SOFTKBD);

        if (fdwSetContext == ISC_HIDE_SOFTKBD) {
            lpUIPrivate->fdwSetContext &= ~(ISC_HIDE_SOFTKBD);
            ShowSoftKbd(hUIWnd, SW_HIDE, NULL);
        }

        ShowStatus(
            hUIWnd, SW_HIDE);
    } else if (hIMC) {
        ShowStatus(
            hUIWnd, SW_SHOWNOACTIVATE);
    } else {
        ShowStatus(
            hUIWnd, SW_HIDE);
    }

    return;
}


/**********************************************************************/
/* ShowUI()                                                           */
/**********************************************************************/
void PASCAL ShowUI(             // show the sub windows
    HWND   hUIWnd,
    int    nShowCmd)
{
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    LPPRIVCONTEXT  lpImcP;
    HGLOBAL        hUIPrivate;
    LPUIPRIV       lpUIPrivate;

    if (nShowCmd == SW_HIDE) {
    } else if (!(hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC))) {
        nShowCmd = SW_HIDE;
    } else if (!(lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC))) {
        nShowCmd = SW_HIDE;
    } else if (!(lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate))) {
        ImmUnlockIMC(hIMC);
        nShowCmd = SW_HIDE;
    } else {
    }

    if (nShowCmd == SW_HIDE) {
        ShowStatus(hUIWnd, nShowCmd);
        ShowComp(hUIWnd, nShowCmd);
        ShowCand(hUIWnd, nShowCmd);
        ShowSoftKbd(hUIWnd, nShowCmd, NULL);
        return;
    }

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {          // can not darw status window
        goto ShowUIUnlockIMCC;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw status window
        goto ShowUIUnlockIMCC;
    }

    lpUIPrivate->fdwSetContext |= ISC_SHOWUICOMPOSITIONWINDOW;

    if ((lpUIPrivate->fdwSetContext & ISC_SHOWUICOMPOSITIONWINDOW) &&
        (lpImcP->fdwImeMsg & MSG_ALREADY_START)) {
        if (lpUIPrivate->hCompWnd) {

            if (lpUIPrivate->nShowCompCmd != SW_HIDE) {
                // some time the WM_NCPAINT is eaten by the app
                RedrawWindow(lpUIPrivate->hCompWnd, NULL, NULL,
                    RDW_FRAME|RDW_INVALIDATE|RDW_ERASE);
            }

            if (MBIndex.IMEChara[0].IC_Trace) {            // modify 95.7.17
                SendMessage(lpUIPrivate->hCompWnd, WM_IME_NOTIFY,
                    IMN_SETCOMPOSITIONWINDOW, 0);
            }

            if (lpUIPrivate->nShowCompCmd == SW_HIDE) {
                ShowComp(hUIWnd, nShowCmd);
            }
        } else {
            StartComp(hUIWnd);
        }
    } else if (lpUIPrivate->nShowCompCmd == SW_HIDE) {
    } else if (lpUIPrivate->fdwSetContext & ISC_OPEN_STATUS_WINDOW) {
        lpUIPrivate->fdwSetContext |= ISC_HIDE_COMP_WINDOW;
    } else {
        ShowComp(hUIWnd, SW_HIDE);
    }

    if ((lpUIPrivate->fdwSetContext & ISC_SHOWUICANDIDATEWINDOW) &&
        (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN)) {
        if (lpUIPrivate->hCandWnd) {
// ????
            if (lpUIPrivate->nShowCandCmd != SW_HIDE) {
                // some time the WM_NCPAINT is eaten by the app
                RedrawWindow(lpUIPrivate->hCandWnd, NULL, NULL,
                    RDW_FRAME|RDW_INVALIDATE|RDW_ERASE);
            }

            if (MBIndex.IMEChara[0].IC_Trace) {            // 9.12
                SendMessage(lpUIPrivate->hCandWnd, WM_IME_NOTIFY,
                    IMN_SETCANDIDATEPOS, 0x0001);
            }

            if (lpUIPrivate->nShowCandCmd == SW_HIDE) {
                ShowCand(hUIWnd, nShowCmd);
            }
        } else {
            OpenCand(hUIWnd);
        }
    } else if (lpUIPrivate->nShowCandCmd == SW_HIDE) {
    } else if (lpUIPrivate->fdwSetContext & ISC_OPEN_STATUS_WINDOW) {
        lpUIPrivate->fdwSetContext |= ISC_HIDE_CAND_WINDOW;
    } else {
        ShowCand(hUIWnd, SW_HIDE);
    }

    if (lpUIPrivate->fdwSetContext & ISC_OPEN_STATUS_WINDOW) {
        if(lpUIPrivate->hStatusWnd) {
            OpenStatus(hUIWnd);
        }
        if (lpUIPrivate->nShowStatusCmd != SW_HIDE) {
            // some time the WM_NCPAINT is eaten by the app
            RedrawWindow(lpUIPrivate->hStatusWnd, NULL, NULL,
                RDW_FRAME|RDW_INVALIDATE|RDW_ERASE);
        }

        SendMessage(lpUIPrivate->hStatusWnd, WM_IME_NOTIFY,
            IMN_SETSTATUSWINDOWPOS, 0);
        if (lpUIPrivate->nShowStatusCmd == SW_HIDE) {
            ShowStatus(hUIWnd, nShowCmd);
        }
        else{
            ShowStatus(hUIWnd, nShowCmd);
        }
    } else if (lpUIPrivate->hStatusWnd) {
        DestroyWindow(lpUIPrivate->hStatusWnd);
    }

    if (!lpIMC->fOpen) {
        if (lpUIPrivate->nShowCompCmd != SW_HIDE) {
            ShowSoftKbd(hUIWnd, SW_HIDE, NULL);
        }
    } else if ((lpUIPrivate->fdwSetContext & ISC_SHOW_SOFTKBD) &&
        (lpIMC->fdwConversion & IME_CMODE_SOFTKBD)) {
        if (!lpUIPrivate->hSoftKbdWnd) {
            UpdateSoftKbd(hUIWnd);
        } else if (lpUIPrivate->nShowSoftKbdCmd == SW_HIDE) {
            ShowSoftKbd(hUIWnd, nShowCmd, lpImcP);
        } else if (lpUIPrivate->hIMC != hIMC) {
            UpdateSoftKbd(hUIWnd);
        } else {
            RedrawWindow(lpUIPrivate->hSoftKbdWnd, NULL, NULL,
                RDW_FRAME|RDW_INVALIDATE);
        }
    } else if (lpUIPrivate->nShowSoftKbdCmd == SW_HIDE) {
    } else if (lpUIPrivate->fdwSetContext & ISC_OPEN_STATUS_WINDOW) {
        lpUIPrivate->fdwSetContext |= ISC_HIDE_SOFTKBD;
    } else {
        ShowSoftKbd(hUIWnd, SW_HIDE, NULL);
    }

    // we switch to this hIMC
    lpUIPrivate->hIMC = hIMC;

    GlobalUnlock(hUIPrivate);

ShowUIUnlockIMCC:
    ImmUnlockIMCC(lpIMC->hPrivate);
    ImmUnlockIMC(hIMC);

    return;
}

/**********************************************************************/
/* ShowGuideLine                                                      */
/**********************************************************************/
void PASCAL ShowGuideLine(
    HWND hUIWnd)
{
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    LPGUIDELINE    lpGuideLine;

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return;
    }

    lpGuideLine = (LPGUIDELINE)ImmLockIMCC(lpIMC->hGuideLine);

    if (!lpGuideLine) {
    } else if (lpGuideLine->dwLevel == GL_LEVEL_ERROR) {
        MessageBeep((UINT)-1);
        MessageBeep((UINT)-1);
    } else if (lpGuideLine->dwLevel == GL_LEVEL_WARNING) {
        MessageBeep((UINT)-1);
    } else {
    }

    ImmUnlockIMCC(lpIMC->hGuideLine);
    ImmUnlockIMC(hIMC);

    return;
}

/**********************************************************************/
/* UpdateStatusWindow()                                               */
/* Return Value:                                                      */
/*     none                                                             */
/**********************************************************************/
BOOL UpdateStatusWindow(
    HWND   hUIWnd)
{
    HWND           hStatusWnd;

    if (!(hStatusWnd = GetStatusWnd(hUIWnd))) {
        return (FALSE);
    }

    InvalidateRect(hStatusWnd, &(sImeG.rcStatusText), TRUE);
    UpdateWindow(hStatusWnd);

    return (TRUE);
}


/**********************************************************************/
/* NotifyUI()                                                         */
/**********************************************************************/
void PASCAL NotifyUI(
    HWND        hUIWnd,
    WPARAM      wParam,
    LPARAM      lParam)
{
    HWND hStatusWnd;

    switch (wParam) {
    case IMN_OPENSTATUSWINDOW:
        //PostStatus(hUIWnd, TRUE);
        StatusWndMsg(hUIWnd, TRUE);
        break;
    case IMN_CLOSESTATUSWINDOW:
        //PostStatus(hUIWnd, FALSE);
        StatusWndMsg(hUIWnd, FALSE);
        break;
    case IMN_OPENCANDIDATE:
        if (lParam & 0x00000001) {
            OpenCand(hUIWnd);
        }
        break;
    case IMN_CHANGECANDIDATE:
        if (lParam & 0x00000001) {
            HDC  hDC;
            HWND hCandWnd;
            //RECT rcRect;

            hCandWnd = GetCandWnd(hUIWnd);
            if (!hCandWnd) {
                return;
            }

            hDC = GetDC(hCandWnd);
            PaintCandWindow(hCandWnd, hDC);
            ReleaseDC(hCandWnd, hDC);
        }
        break;
    case IMN_CLOSECANDIDATE:
        if (lParam & 0x00000001) {
            CloseCand(hUIWnd);
        }
        break;
    case IMN_SETSENTENCEMODE:
        break;
    case IMN_SETOPENSTATUS:
    case IMN_SETCONVERSIONMODE:
        hStatusWnd = GetStatusWnd(hUIWnd);
        if (!hStatusWnd) {
            return;
        }

        {
            RECT rcRect;

            rcRect = sImeG.rcStatusText;
            
            // off by 1
            rcRect.right += 1;
            rcRect.bottom += 1;

            RedrawWindow(hStatusWnd, &rcRect, NULL, RDW_INVALIDATE);
        }
        break;
    case IMN_SETCOMPOSITIONFONT:
        // we are not going to change font, but an IME can do this if it want
        break;
    case IMN_SETCOMPOSITIONWINDOW:
        {
            HWND hCompWnd;

            hCompWnd = GetCompWnd(hUIWnd);
            if (!hCompWnd) {
                return;
            }

            PostMessage(hCompWnd, WM_IME_NOTIFY, wParam, lParam);
        }
        break;
    case IMN_SETCANDIDATEPOS:
        {
            HWND hCandWnd;

            hCandWnd = GetCandWnd(hUIWnd);
            if (!hCandWnd) {
                return;
            }

            PostMessage(hCandWnd, WM_IME_NOTIFY, wParam, lParam);
        }
        break;
    case IMN_SETSTATUSWINDOWPOS:
        hStatusWnd = GetStatusWnd(hUIWnd);
        if (hStatusWnd) {
            PostMessage(hStatusWnd, WM_IME_NOTIFY, wParam, lParam);
        } else {
        }
        break;
    case IMN_GUIDELINE:
        ShowGuideLine(hUIWnd);
        break;
    case IMN_PRIVATE:
        switch (lParam) {
        case IMN_PRIVATE_UPDATE_SOFTKBD:
            UpdateSoftKbd(hUIWnd);
            break;
        case IMN_PRIVATE_UPDATE_STATUS:
            UpdateStatusWindow(hUIWnd);
            break;
        case IMN_PRIVATE_DESTROYCANDWIN:
            SendMessage(GetCandWnd(hUIWnd), WM_DESTROY, (WPARAM)NULL, (LPARAM)NULL);
            break;
        case IMN_PRIVATE_CMENUDESTROYED:
            CMenuDestroyed(hUIWnd);
            break;
        case IMN_PRIVATE_SOFTKEYMENUDESTROYED:
            SoftkeyMenuDestroyed(hUIWnd);
            break;
        }
        break;
    case IMN_SOFTKBDDESTROYED:
        SoftKbdDestroyed(hUIWnd);
        break;
    default:
        break;
    }

    return;
}

/**********************************************************************/
/* SetContext()                                                       */
/**********************************************************************/
void PASCAL SetContext(         // the context activated/deactivated
    HWND   hUIWnd,
    BOOL   fOn,
    LPARAM lShowUI)
{
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    LPPRIVCONTEXT  lpImcP;
    HGLOBAL        hUIPrivate;
    register LPUIPRIV lpUIPrivate;

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if(!hIMC){
        return;
    }

    // get lpIMC
    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return;
    }

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {
        ImmUnlockIMC(hIMC);
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {
        ImmUnlockIMC(hIMC);
        return;
    }

    if (fOn) {
        register DWORD fdwSetContext;

        lpUIPrivate->fdwSetContext = lpUIPrivate->fdwSetContext &
            ~(ISC_SHOWUIALL|ISC_HIDE_SOFTKBD);

        lpUIPrivate->fdwSetContext |= (lShowUI & ISC_SHOWUIALL) |
            ISC_SHOW_SOFTKBD;

        {
        HKEY hKey;
        DWORD bcData; 
        TCHAR buf[256];
        bcData=256;
        if(RegOpenKeyEx (HKEY_CURRENT_USER,
                         TEXT("Control Panel\\Input Method"),
                         0,
                         KEY_ENUMERATE_SUB_KEYS |
                         KEY_EXECUTE |
                         KEY_QUERY_VALUE,
                         &hKey)){
            goto SetShowStatus;
        }
        if(RegQueryValueEx (hKey, TEXT("show status"),
                     NULL,
                     NULL,             //null-terminate string
                     (LPBYTE)buf,              //&bData,
                     &bcData) != ERROR_SUCCESS){
                     // Set defaut value as ON if no entry found in registry
                     lpUIPrivate->fdwSetContext |= ISC_OPEN_STATUS_WINDOW;
                 goto SetShowStatus;
             }
        if(lstrcmp(buf, TEXT("1"))==0)
            lpUIPrivate->fdwSetContext |= ISC_OPEN_STATUS_WINDOW;
        else
            lpUIPrivate->fdwSetContext &= ~ISC_OPEN_STATUS_WINDOW;
SetShowStatus:
        RegCloseKey(hKey);
        }

        fdwSetContext = lpUIPrivate->fdwSetContext &
            (ISC_SHOWUICOMPOSITIONWINDOW|ISC_HIDE_COMP_WINDOW);

        if (fdwSetContext == ISC_HIDE_COMP_WINDOW) {
            ShowComp(
                hUIWnd, SW_HIDE);
        } else if (fdwSetContext & ISC_HIDE_COMP_WINDOW) {
            lpUIPrivate->fdwSetContext &= ~(ISC_HIDE_COMP_WINDOW);
        }

        fdwSetContext = lpUIPrivate->fdwSetContext &
            (ISC_SHOWUICANDIDATEWINDOW|ISC_HIDE_CAND_WINDOW);

        if (fdwSetContext == ISC_HIDE_CAND_WINDOW) {
            ShowCand(
                hUIWnd, SW_HIDE);
        } else if (fdwSetContext & ISC_HIDE_CAND_WINDOW) {
            lpUIPrivate->fdwSetContext &= ~(ISC_HIDE_CAND_WINDOW);
        }

        if (lpIMC->cfCandForm[0].dwIndex != 0) {
            lpIMC->cfCandForm[0].dwStyle = CFS_DEFAULT;
        }

        lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
        if (!lpImcP) {
            GlobalUnlock(hUIPrivate);
            ImmUnlockIMC(hIMC);
            return;
        }

        // init ime properties & reset context
        InitImeCharac(0);

        if(MBIndex.IMEChara[0].IC_Trace != SaTC_Trace) {
            int UI_MODE;

            lpImcP->iImeState = CST_INIT;
            CompCancel(hIMC, lpIMC);
            
            // init fields of hPrivate
            lpImcP->fdwImeMsg = (DWORD) 0;
            lpImcP->dwCompChar = (DWORD) 0;
            lpImcP->fdwGcsFlag = (DWORD) 0;
            lpImcP->uSYHFlg = 0x00000000;
            lpImcP->uDYHFlg = 0x00000000;

            // init input state(all)
            lpImcP->PrivateArea.Comp_Status.OnLineCreWord = 0;
            lpImcP->PrivateArea.Comp_Status.dwSTLX = 0;
            lpImcP->PrivateArea.Comp_Status.dwSTMULCODE = 0;
            lpImcP->PrivateArea.Comp_Status.dwInvalid = 0;

            CWCodeStr[0] = 0;
            CWDBCSStr[0] = 0;

            // change compwnd size

            // init fields of hIMC
            lpIMC->fOpen = TRUE;

            SendMessage(GetCandWnd(hUIWnd), WM_DESTROY, (WPARAM)NULL, (LPARAM)NULL);
            
            // set cand window data
            if(MBIndex.IMEChara[0].IC_Trace) {
                UI_MODE = BOX_UI;
            } else {
                POINT ptSTFixPos;
                
                UI_MODE = LIN_UI;
                ptSTFixPos.x = 0;
                ptSTFixPos.y = sImeG.rcWorkArea.bottom - sImeG.yStatusHi;
                ImmSetStatusWindowPos(hIMC, (LPPOINT)&ptSTFixPos);
            }
            
            InitCandUIData(
                GetSystemMetrics(SM_CXBORDER),
                GetSystemMetrics(SM_CYBORDER), UI_MODE);
        }
            
        SaTC_Trace = MBIndex.IMEChara[0].IC_Trace;

        // init Caps
        {
            BYTE  lpbKeyState[256];
            DWORD fdwConversion;

            GetKeyboardState(lpbKeyState);
            if (lpbKeyState[VK_CAPITAL] & 0x01) {
                uCaps = 1;
                // change to alphanumeric mode
                fdwConversion = lpIMC->fdwConversion & ~(IME_CMODE_CHARCODE |
                    IME_CMODE_NATIVE | IME_CMODE_EUDC);
                // init ime Private status
                lpImcP->PrivateArea.Comp_Status.dwSTLX = 0;
                lpImcP->PrivateArea.Comp_Status.dwSTMULCODE = 0;
                lpImcP->PrivateArea.Comp_Status.dwInvalid = 0;
            } else {
                // change to native mode
                if(uCaps == 1) {
                    fdwConversion = (lpIMC->fdwConversion | IME_CMODE_NATIVE) &
                        ~(IME_CMODE_CHARCODE | IME_CMODE_EUDC);
                } else {
                    fdwConversion = lpIMC->fdwConversion;
                }
                uCaps = 0;
            }
            ImmSetConversionStatus(hIMC, fdwConversion, lpIMC->fdwSentence);
        }
        if ((lpIMC->cfCompForm.dwStyle & CFS_FORCE_POSITION)
            && (MBIndex.IMEChara[0].IC_Trace)) {
            POINT ptNew;            // new position of UI
            POINT ptSTWPos;

            ImmGetStatusWindowPos(hIMC, (LPPOINT)&ptSTWPos);

            ptNew.x = ptSTWPos.x + sImeG.xStatusWi + UI_MARGIN;
            if((ptSTWPos.x + sImeG.xStatusWi + sImeG.xCandWi + lpImeL->xCompWi + 2 * UI_MARGIN) >=
              sImeG.rcWorkArea.right) { 
                ptNew.x = ptSTWPos.x - lpImeL->xCompWi - UI_MARGIN;
            }
            ptNew.x += lpImeL->cxCompBorder;
            ptNew.y = ptSTWPos.y + lpImeL->cyCompBorder;
            lpIMC->cfCompForm.ptCurrentPos = ptNew;

            ScreenToClient(lpIMC->hWnd, &lpIMC->cfCompForm.ptCurrentPos);
            lpIMC->cfCompForm.dwStyle = CFS_DEFAULT;
        }
    } else {
        lpUIPrivate->fdwSetContext &= ~ISC_SETCONTEXT_UI;
    }

    GlobalUnlock(hUIPrivate);

    UIPaint(hUIWnd);

    ImmUnlockIMC(hIMC);
    return;
}


/**********************************************************************/
/* GetCompWindow()                                                    */
/**********************************************************************/
LRESULT PASCAL GetCompWindow(
    HWND              hUIWnd,
    LPCOMPOSITIONFORM lpCompForm)
{
    HWND hCompWnd;
    RECT rcCompWnd;

    hCompWnd = GetCompWnd(hUIWnd);

    if (!hCompWnd) {
        return (1L);
    }

    if (!GetWindowRect(hCompWnd, &rcCompWnd)) {
        return (1L);
    }

    lpCompForm->dwStyle = CFS_POINT|CFS_RECT;
    lpCompForm->ptCurrentPos = *(LPPOINT)&rcCompWnd;
    lpCompForm->rcArea = rcCompWnd;

    return (0L);
}

/**********************************************************************/
/* SelectIME()                                                        */
/**********************************************************************/
void PASCAL SelectIME(          // switch IMEs
    HWND hUIWnd,
    BOOL fSelect)
{
    if (!fSelect) {
        ShowUI(hUIWnd, SW_HIDE);
    } else {
        ShowUI(hUIWnd, SW_SHOWNOACTIVATE);
    }

    return;
}

/**********************************************************************/
/* UIPaint()                                                          */
/**********************************************************************/
LRESULT PASCAL UIPaint(
    HWND        hUIWnd)
{
    PAINTSTRUCT ps;
    MSG         sMsg;
    HGLOBAL     hUIPrivate;
    LPUIPRIV    lpUIPrivate;

    // for safety
    BeginPaint(hUIWnd, &ps);
    EndPaint(hUIWnd, &ps);

    // some application will not remove the WM_PAINT messages
    PeekMessage(&sMsg, hUIWnd, WM_PAINT, WM_PAINT, PM_REMOVE|PM_NOYIELD);

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {
        return (0L);
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {
        return (0L);
    }

    if (lpUIPrivate->fdwSetContext & ISC_SETCONTEXT_UI) {
        ShowUI(hUIWnd, SW_SHOWNOACTIVATE);
    } else {
        ShowUI(hUIWnd, SW_HIDE);
    }

    GlobalUnlock(hUIPrivate);

    return (0L);
}

/**********************************************************************/
/* UIWndProc()                                                        */
/**********************************************************************/
LRESULT CALLBACK UIWndProc(
    HWND   hUIWnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (uMsg) {
    case WM_CREATE:
        CreateUIWindow(hUIWnd);
        break;
    case WM_DESTROY:
        DestroyUIWindow(hUIWnd);
        break;
    case WM_IME_STARTCOMPOSITION:
        // you can create a window as the composition window here
        StartComp(hUIWnd);
        break;
    case WM_IME_COMPOSITION:
        if (!MBIndex.IMEChara[0].IC_Trace) {
        } else if (lParam & GCS_RESULTSTR) {
            MoveDefaultCompPosition(hUIWnd);
        } else {
        }

        {
            HWND hCompWnd;

            hCompWnd = GetCompWnd(hUIWnd);

            if (hCompWnd) {
                RECT rcRect;

                rcRect = lpImeL->rcCompText;
                // off by 1
                rcRect.right += 1;
                rcRect.bottom += 1;

                RedrawWindow(hCompWnd, &rcRect, NULL, RDW_INVALIDATE);
            }
        }
        break;
    case WM_IME_ENDCOMPOSITION:
        // you can destroy the composition window here
        EndComp(hUIWnd);
        break;
    case WM_IME_NOTIFY:
        NotifyUI(hUIWnd, wParam, lParam);
        break;
    case WM_IME_SETCONTEXT:
        SetContext(hUIWnd, (BOOL)wParam, lParam);

        break;
    case WM_IME_CONTROL:
        switch (wParam) {
        case IMC_GETCANDIDATEPOS:
            return (1L);                    // not implemented yet
        case IMC_GETCOMPOSITIONFONT:
            return (1L);                    // not implemented yet
        case IMC_GETCOMPOSITIONWINDOW:
            return GetCompWindow(hUIWnd, (LPCOMPOSITIONFORM)lParam);
        case IMC_GETSTATUSWINDOWPOS:
            {
                HWND   hStatusWnd;
                RECT   rcStatusWnd;
                LPARAM lParam;

                hStatusWnd = GetStatusWnd(hUIWnd);
                if (!hStatusWnd) {
                    return (0L);    // fail, return (0, 0)?
                }

                if (!GetWindowRect(hStatusWnd, &rcStatusWnd)) {
                     return (0L);    // fail, return (0, 0)?
                }

                lParam = MAKELRESULT(rcStatusWnd.left, rcStatusWnd.top);

                return (lParam);
            }
            return (0L);
        case IMC_SETSTATUSWINDOWPOS:
            {
                HIMC            hIMC;
                LPINPUTCONTEXT  lpIMC;
                LPPRIVCONTEXT   lpImcP;
                POINT           ptPos;

                ptPos.x = ((LPPOINTS)&lParam)->x;
                ptPos.y = ((LPPOINTS)&lParam)->y;

                hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
                if (!hIMC) {
                    return (1L);
                }

                if(!ImmSetStatusWindowPos(hIMC, &ptPos)) {
                    return (1L);
                }

                // set comp window position when TraceCuer
                lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
                if (!lpIMC) {
                    return (1L);
                }

                lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
                if (!lpImcP) {
                    return (1L);
                }

                if(!MBIndex.IMEChara[0].IC_Trace) {
                    lpIMC->cfCompForm.dwStyle = CFS_RECT;
                    lpIMC->cfCompForm.ptCurrentPos.x = ptPos.x + sImeG.xStatusWi + UI_MARGIN;
                    lpIMC->cfCompForm.ptCurrentPos.y = ptPos.y;
                    CopyRect(&lpIMC->cfCompForm.rcArea, &sImeG.rcWorkArea);

                    ScreenToClient(lpIMC->hWnd, &lpIMC->cfCompForm.ptCurrentPos);
                    // set composition window to the new poosition
                    PostMessage(GetCompWnd(hUIWnd), WM_IME_NOTIFY, IMN_SETCOMPOSITIONWINDOW, 0);

                }

                ImmUnlockIMCC(lpIMC->hPrivate);
                ImmUnlockIMC(hIMC);

                return (0L);
            }
            return (1L);
        default:
            return (1L);
        }
        break;
    case WM_IME_COMPOSITIONFULL:
        return (0L);
    case WM_IME_SELECT:
        SetContext(hUIWnd, (BOOL)wParam, 0);
        return (0L);
    case WM_MOUSEACTIVATE:
        return (MA_NOACTIVATE);
    default:
        return DefWindowProc(hUIWnd, uMsg, wParam, lParam);
    }
    return (0L);
}

void DrawConvexRect(HDC hDC, int x1, int y1, int x2, int y2)
{
    HPEN hPen, hOldPen;
    
    SelectObject(hDC, GetStockObject(LTGRAY_BRUSH));
    SelectObject(hDC, GetStockObject(WHITE_PEN));
    MoveToEx(hDC, x1, y1,NULL);
    LineTo(hDC, x2, y1);
    MoveToEx(hDC, x1, y1,NULL);
    LineTo(hDC, x1, y2);
    hPen = CreatePen(PS_SOLID, 1, RGB(128, 128, 128));
    hOldPen = SelectObject (hDC, hPen);
    MoveToEx(hDC, x2-1, y2-1,NULL);
    LineTo(hDC, x2-1, y1);
    MoveToEx(hDC, x2-1, y2-1,NULL);
    LineTo(hDC, x1, y2-1);
    SelectObject(hDC, hOldPen);
    DeleteObject(hPen);          
}

void DrawConvexRectP(HDC hDC, int x1, int y1, int x2, int y2)
{
    HPEN hPen, hOldPen;
    
    SelectObject(hDC, GetStockObject(LTGRAY_BRUSH));
    SelectObject(hDC, GetStockObject(WHITE_PEN));
    MoveToEx(hDC, x1, y1,NULL);
    LineTo(hDC, x2 - 1, y1);
    MoveToEx(hDC, x1, y1,NULL);
    LineTo(hDC, x1, y2 - 1);
    hPen = CreatePen(PS_SOLID, 1, RGB(0, 0, 0));
    hOldPen = SelectObject (hDC, hPen);
    MoveToEx(hDC, x2-1, y2-1,NULL);
    LineTo(hDC, x2-1, y1);
    MoveToEx(hDC, x2-1, y2-1,NULL);
    LineTo(hDC, x1, y2-1);
    SelectObject(hDC, hOldPen);
    DeleteObject(hPen);          
}

void DrawConcaveRect(HDC hDC, int x1, int y1, int x2, int y2)
{
    HPEN hLtPen = CreatePen(PS_SOLID, 1, 0x00808080);
    HPEN OldPen = SelectObject(hDC, hLtPen);
    MoveToEx(hDC, x1, y1,NULL);
    LineTo(hDC, x2, y1);
    MoveToEx(hDC, x1, y1,NULL);
    LineTo(hDC, x1, y2);
    SelectObject(hDC, GetStockObject(WHITE_PEN));
    MoveToEx(hDC, x2  , y2,NULL);
    LineTo(hDC, x2  , y1-1);
    MoveToEx(hDC, x2  , y2,NULL);
    LineTo(hDC, x1-1, y2);
    SelectObject(hDC, OldPen);
    DeleteObject(hLtPen);     
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntime\uisubs.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    UISUBS.c
    
++*/

#include <windows.h>
#include <htmlhelp.h>
#include <immdev.h>
#include <imedefs.h>

/**********************************************************************/
/* DrawDragBorder()                                                   */
/**********************************************************************/
void PASCAL DrawDragBorder(
    HWND hWnd,                  // window of IME is dragged
    LONG lCursorPos,            // the cursor position
    LONG lCursorOffset)         // the offset form cursor to window org
{
    HDC  hDC;
    int  cxBorder, cyBorder;
    int  x, y;
    RECT rcWnd;

    cxBorder = GetSystemMetrics(SM_CXBORDER);   // width of border
    cyBorder = GetSystemMetrics(SM_CYBORDER);   // height of border

    // get cursor position
    x = (*(LPPOINTS)&lCursorPos).x;
    y = (*(LPPOINTS)&lCursorPos).y;

    // calculate the org by the offset
    x -= (*(LPPOINTS)&lCursorOffset).x;
    y -= (*(LPPOINTS)&lCursorOffset).y;

#if 0 // MultiMonitor support
    // check for the min boundary of the display
    if (x < sImeG.rcWorkArea.left) {
        x = sImeG.rcWorkArea.left;
    }

    if (y < sImeG.rcWorkArea.top) {
        y = sImeG.rcWorkArea.top;
    }
#endif

    // check for the max boundary of the display
    GetWindowRect(hWnd, &rcWnd);

#if 0 // MultiMonitor support    
    if (x + rcWnd.right - rcWnd.left > sImeG.rcWorkArea.right) {
        x = sImeG.rcWorkArea.right - (rcWnd.right - rcWnd.left);
    }

    if (y + rcWnd.bottom - rcWnd.top > sImeG.rcWorkArea.bottom) {
        y = sImeG.rcWorkArea.bottom - (rcWnd.bottom - rcWnd.top);
    }
#endif

    // draw the moving track
    hDC = CreateDC(TEXT("DISPLAY"), NULL, NULL, NULL);
    SelectObject(hDC, GetStockObject(GRAY_BRUSH));

    // ->
    PatBlt(hDC, x, y, rcWnd.right - rcWnd.left - cxBorder, cyBorder,
        PATINVERT);
    // v
    PatBlt(hDC, x, y + cyBorder, cxBorder, rcWnd.bottom - rcWnd.top -
        cyBorder, PATINVERT);
    // _>
    PatBlt(hDC, x + cxBorder, y + rcWnd.bottom - rcWnd.top,
        rcWnd.right - rcWnd.left - cxBorder, -cyBorder, PATINVERT);
    //  v
    PatBlt(hDC, x + rcWnd.right - rcWnd.left, y,
        - cxBorder, rcWnd.bottom - rcWnd.top - cyBorder, PATINVERT);

    DeleteDC(hDC);
    return;
}

/**********************************************************************/
/* DrawFrameBorder()                                                  */
/**********************************************************************/
void PASCAL DrawFrameBorder(    // border of IME
    HDC  hDC,
    HWND hWnd)                  // window of IME
{
    RECT rcWnd;
    int  xWi, yHi;

    GetWindowRect(hWnd, &rcWnd);

    xWi = rcWnd.right - rcWnd.left;
    yHi = rcWnd.bottom - rcWnd.top;

    // 1, ->
    PatBlt(hDC, 0, 0, xWi, 1, WHITENESS);

    // 1, v
    PatBlt(hDC, 0, 0, 1, yHi, WHITENESS);

    // 1, _>
    PatBlt(hDC, 0, yHi, xWi, -1, BLACKNESS);

    // 1,  v
    PatBlt(hDC, xWi, 0, -1, yHi, BLACKNESS);

    xWi -= 2;
    yHi -= 2;

    SelectObject(hDC, GetStockObject(LTGRAY_BRUSH));

    // 2, ->
    PatBlt(hDC, 1, 1, xWi, 1, PATCOPY);

    // 2, v
    PatBlt(hDC, 1, 1, 1, yHi, PATCOPY);

    // 2,  v
    PatBlt(hDC, xWi + 1, 1, -1, yHi, PATCOPY);

    SelectObject(hDC, GetStockObject(GRAY_BRUSH));

    // 2, _>
    PatBlt(hDC, 1, yHi + 1, xWi, -1, PATCOPY);

    xWi -= 2;
    yHi -= 2;

    // 3, ->
    PatBlt(hDC, 2, 2, xWi, 1, PATCOPY);

    // 3, v
    PatBlt(hDC, 2, 2, 1, yHi, PATCOPY);

    // 3,  v
    PatBlt(hDC, xWi + 2, 3, -1, yHi - 1, WHITENESS);

    SelectObject(hDC, GetStockObject(LTGRAY_BRUSH));

    // 3, _>
    PatBlt(hDC, 2, yHi + 2, xWi, -1, PATCOPY);

    SelectObject(hDC, GetStockObject(GRAY_BRUSH));

    xWi -= 2;
    yHi -= 2;

    // 4, ->
    PatBlt(hDC, 3, 3, xWi, 1, PATCOPY);

    // 4, v
    PatBlt(hDC, 3, 3, 1, yHi, PATCOPY);

    SelectObject(hDC, GetStockObject(LTGRAY_BRUSH));

    // 4,  v
    PatBlt(hDC, xWi + 3, 4, -1, yHi - 1, PATCOPY);

    // 4, _>
    PatBlt(hDC, 3, yHi + 3, xWi, -1, WHITENESS);

    return;
}

/**********************************************************************/
/* ContextMenuWndProc()                                               */
/**********************************************************************/
LRESULT CALLBACK ContextMenuWndProc(
    HWND        hCMenuWnd,
    UINT        uMsg,
    WPARAM      wParam,
    LPARAM      lParam)
{
    switch (uMsg) {
    case WM_DESTROY:
        {
            HWND hUIWnd;

            hUIWnd = (HWND)GetWindowLongPtr(hCMenuWnd, CMENU_HUIWND);

            if (hUIWnd) {
                SendMessage(hUIWnd, WM_IME_NOTIFY, IMN_PRIVATE,
                    IMN_PRIVATE_CMENUDESTROYED);
            }
        }
        break;
    case WM_USER_DESTROY:
        {
            SendMessage(hCMenuWnd, WM_CLOSE, 0, 0);
            DestroyWindow(hCMenuWnd);
        }
        break;
    case WM_COMMAND:
     switch(LOWORD(wParam)) {
        case IDM_SET:
            {
            HIMC            hIMC;
            LPINPUTCONTEXT  lpIMC;
            LPPRIVCONTEXT   lpImcP;
            int             UI_MODE;
            HWND            hUIWnd;
            RECT rcWorkArea;
            hUIWnd = (HWND)GetWindowLongPtr(hCMenuWnd, CMENU_HUIWND);

#if 1 // MultiMonitor support
            rcWorkArea = ImeMonitorWorkAreaFromWindow(hCMenuWnd);
#endif

               if (!hUIWnd) {
                   return (0L);
               }

            hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
            if (!hIMC) {
                return (0L);
            }

            lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
            if (!lpIMC) {
                return (0L);
            }

            lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
            if (!lpImcP) {
                return (0L);
            }

            ImeConfigure(GetKeyboardLayout(0), lpIMC->hWnd, IME_CONFIG_GENERAL, NULL);

#ifdef CROSSREF
            {
            HWND hCompWnd;
            hCompWnd = GetCompWnd(hUIWnd);
            DestroyWindow(hCompWnd);
            }
#endif
                
            lpImcP->iImeState = CST_INIT;
            CompCancel(hIMC, lpIMC);
            
            // change compwnd size

            // init fields of hIMC
            lpIMC->fOpen = TRUE;

            if (!(lpIMC->fdwInit & INIT_CONVERSION)) {
                lpIMC->fdwConversion = IME_CMODE_NATIVE;
                lpIMC->fdwInit |= INIT_CONVERSION;
            }

            lpImcP->fdwImeMsg = lpImcP->fdwImeMsg | MSG_IMN_DESTROYCAND;
            GenerateMessage(hIMC, lpIMC, lpImcP);
            
            // set cand window data
            if(MBIndex.IMEChara[0].IC_Trace) {
                UI_MODE = BOX_UI;
            } else {
                POINT ptSTFixPos;
                
                UI_MODE = LIN_UI;
                ptSTFixPos.x = 0;
                ptSTFixPos.y = rcWorkArea.bottom - sImeG.yStatusHi;
                ImmSetStatusWindowPos(hIMC, (LPPOINT)&ptSTFixPos);
            }
            InitCandUIData(
                GetSystemMetrics(SM_CXBORDER),
                GetSystemMetrics(SM_CYBORDER), UI_MODE);
            
            ImmUnlockIMCC(lpIMC->hPrivate);
            ImmUnlockIMC(hIMC);
            break;
            }
        case IDM_CRTWORD:
            {
            HIMC           hIMC;
            LPINPUTCONTEXT lpIMC;
            HWND hUIWnd;

               hUIWnd = (HWND)GetWindowLongPtr(hCMenuWnd, CMENU_HUIWND);

               if (!hUIWnd) {
                   return (0L);
               }

            hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
            if(!hIMC){
                break;
            }
             
            lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
            if (!lpIMC) {
                break;
            }

            DialogBox(hInst, TEXT("CREATEWORD"), (HWND)lpIMC->hWnd, (DLGPROC)CrtWordDlgProc);

            ImmUnlockIMC(hIMC);
            break;
            }
        case IDM_OPTGUD:
            {
               TCHAR szOPTGUDHlpName[MAX_PATH];
                    
               szOPTGUDHlpName[0] = 0;
               GetWindowsDirectory((LPTSTR)szOPTGUDHlpName, MAX_PATH);
               lstrcat((LPTSTR)szOPTGUDHlpName, TEXT("\\HELP\\WINIME.CHM"));
               HtmlHelp(hCMenuWnd,szOPTGUDHlpName,HH_DISPLAY_TOPIC,0L);
            }
            break;
        case IDM_IMEGUD:
            {
               TCHAR szIMEGUDHlpName[MAX_PATH];
               int iLen;
                    
               szIMEGUDHlpName[0] = 0;
               GetWindowsDirectory((LPTSTR)szIMEGUDHlpName, MAX_PATH);
               lstrcat((LPTSTR)szIMEGUDHlpName, TEXT("\\HELP\\"));
               lstrcat((LPTSTR)szIMEGUDHlpName, (LPTSTR)szImeMBFileName);
               iLen = lstrlen(szIMEGUDHlpName);
               szIMEGUDHlpName[iLen-3] = 0;
               lstrcat((LPTSTR)szIMEGUDHlpName, TEXT(".CHM"));
               HtmlHelp(hCMenuWnd,szIMEGUDHlpName,HH_DISPLAY_TOPIC,0L);
            }
            break;
        case IDM_VER:
            {
            HIMC           hIMC;
            LPINPUTCONTEXT lpIMC;
            HWND hUIWnd;

               hUIWnd = (HWND)GetWindowLongPtr(hCMenuWnd, CMENU_HUIWND);

               if (!hUIWnd) {
                   return (0L);
               }

            hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
            if (!hIMC) {          // Oh! Oh!
                return (0L);
            }

            lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
            if (!lpIMC) {          // Oh! Oh!
                return (0L);
            }

            DialogBox(hInst, TEXT("IMEVER"), (HWND)lpIMC->hWnd, (DLGPROC)ImeVerDlgProc);

            ImmUnlockIMC(hIMC);
            break;
            }

        }

        break;

    case WM_CLOSE:
        {
            HMENU hMenu;

            GetMenu(hCMenuWnd);

            hMenu = (HMENU)GetWindowLongPtr(hCMenuWnd, CMENU_MENU);
            if (hMenu) {
                SetWindowLongPtr(hCMenuWnd, CMENU_MENU, (LONG_PTR)NULL);
                DestroyMenu(hMenu);
            }
        }
        return DefWindowProc(hCMenuWnd, uMsg, wParam, lParam);
    default:
        return DefWindowProc(hCMenuWnd, uMsg, wParam, lParam);
    }

    return (0L);
}

/**********************************************************************/
/* SoftkeyMenuWndProc()                                               */
/**********************************************************************/
LRESULT CALLBACK SoftkeyMenuWndProc(
    HWND        hKeyMenuWnd,
    UINT        uMsg,
    WPARAM      wParam,
    LPARAM      lParam)
{
    switch (uMsg) {
    case WM_DESTROY:
        {
            HWND hUIWnd;

            hUIWnd = (HWND)GetWindowLongPtr(hKeyMenuWnd, SOFTKEYMENU_HUIWND);

            if (hUIWnd) {
                SendMessage(hUIWnd, WM_IME_NOTIFY, IMN_PRIVATE,
                    IMN_PRIVATE_SOFTKEYMENUDESTROYED);
            }
        }
        break;
    case WM_USER_DESTROY:
        {
            SendMessage(hKeyMenuWnd, WM_CLOSE, 0, 0);
            DestroyWindow(hKeyMenuWnd);
        }
        break;
    case WM_COMMAND:
        switch(LOWORD(wParam)) {
        case IDM_SKL1:
        case IDM_SKL2:
        case IDM_SKL3:
        case IDM_SKL4:
        case IDM_SKL5:
        case IDM_SKL6:
        case IDM_SKL7:
        case IDM_SKL8:
        case IDM_SKL9:
        case IDM_SKL10:
        case IDM_SKL11:
        case IDM_SKL12:
        case IDM_SKL13:
            {
                HIMC           hIMC;
                LPINPUTCONTEXT lpIMC;
                LPPRIVCONTEXT  lpImcP;
                DWORD          fdwConversion;
                HWND hUIWnd;

                hUIWnd = (HWND)GetWindowLongPtr(hKeyMenuWnd, SOFTKEYMENU_HUIWND);

                if (!hUIWnd) {
                    return (0L);
                }

                hIMC = (HIMC)GetWindowLongPtr(hUIWnd,IMMGWLP_IMC);
                if (!hIMC) {          // Oh! Oh!
                    return (0L);
                }

                lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
                if (!lpIMC) {          // Oh! Oh!
                    return (0L);
                }

                lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    
                if (!lpImcP) {
                    return (0L);
                }

                {
                    UINT i;

                    lpImeL->dwSKWant = LOWORD(wParam) - IDM_SKL1;
                    lpImeL->dwSKState[lpImeL->dwSKWant] = 
                        lpImeL->dwSKState[lpImeL->dwSKWant]^1;
                
                    // clear other SK State
                    for(i=0; i<NumsSK; i++) {
                        if(i == lpImeL->dwSKWant) continue;
                          lpImeL->dwSKState[i] = 0;
                    }

                    if(lpImeL->dwSKState[lpImeL->dwSKWant]) {
                        if(LOWORD(wParam) == IDM_SKL1)
                            lpImcP->iImeState = CST_INIT;
                        else
                            lpImcP->iImeState = CST_SOFTKB;
                        fdwConversion = lpIMC->fdwConversion | IME_CMODE_SOFTKBD;
                    } else {
                           lpImcP->iImeState = CST_INIT;
                        fdwConversion = lpIMC->fdwConversion & ~(IME_CMODE_SOFTKBD);
                    }
                }

                ImmSetConversionStatus(hIMC, (fdwConversion & ~(IME_CMODE_SOFTKBD)),
                    lpIMC->fdwSentence);
                ImmSetConversionStatus(hIMC, fdwConversion, lpIMC->fdwSentence);

                ImmUnlockIMCC(lpIMC->hPrivate);
                ImmUnlockIMC(hIMC);
                break;
            }
        }

        break;

    case WM_CLOSE:
        {
            HMENU hMenu;

            GetMenu(hKeyMenuWnd);

            hMenu = (HMENU)GetWindowLongPtr(hKeyMenuWnd, SOFTKEYMENU_MENU);
            if (hMenu) {
                SetWindowLongPtr(hKeyMenuWnd, SOFTKEYMENU_MENU, (LONG_PTR)NULL);
                DestroyMenu(hMenu);
            }
        }
        return DefWindowProc(hKeyMenuWnd, uMsg, wParam, lParam);
    default:
        return DefWindowProc(hKeyMenuWnd, uMsg, wParam, lParam);
    }

    return (0L);
}


/**********************************************************************/
/* ContextMenu()                                                      */
/**********************************************************************/
void PASCAL ContextMenu(
    HWND        hStatusWnd,
    int         x,
    int         y)
{
    HWND           hUIWnd;
    HWND           hCMenuWnd;
    HGLOBAL        hUIPrivate;
    LPUIPRIV       lpUIPrivate;
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    HMENU          hMenu, hCMenu;
    RECT           rcStatusWnd;
    RECT           rcWorkArea;

    hUIWnd = GetWindow(hStatusWnd, GW_OWNER);
    if(!hUIWnd){
        return;
    }
    GetWindowRect(hStatusWnd, &rcStatusWnd);

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return;
    }

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {
        goto ContextMenuUnlockIMC;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {
        goto ContextMenuUnlockIMC;
    }

#if 1 // MultiMonitor support
    rcWorkArea = ImeMonitorWorkAreaFromWindow(lpIMC->hWnd);
#endif
    if (lpUIPrivate->hCMenuWnd) {
        SetWindowPos(lpUIPrivate->hCMenuWnd, NULL,
            rcWorkArea.left, rcWorkArea.top, 0, 0,
            SWP_NOACTIVATE|SWP_NOSIZE|SWP_NOZORDER);
    } else {

        // this is important to assign owner window, otherwise the focus
        // will be gone

        // When UI terminate, it need to destroy this window
        lpUIPrivate->hCMenuWnd = CreateWindowEx(CS_HREDRAW|CS_VREDRAW,
            szCMenuClassName, TEXT("Context Menu"),
            WS_POPUP|WS_DISABLED, 0, 0, 0, 0,
            lpIMC->hWnd, (HMENU)NULL, hInst, NULL);

    }

    hCMenuWnd = lpUIPrivate->hCMenuWnd;

    // Unlock before we call into TrackPopupMenu().
    GlobalUnlock(hUIPrivate);

    if (!hCMenuWnd) {
        goto ContextMenuUnlockIMC;
    }

    hMenu = LoadMenu(hInst, TEXT("PROPMENU"));
    hCMenu = GetSubMenu(hMenu, 0);

    if ( lpImeL->fWinLogon == TRUE )
    {
        // In Logon Mode, we don't want to show help and configuration dialog

        EnableMenuItem(hCMenu, 0, MF_BYPOSITION | MF_GRAYED );
        EnableMenuItem(hCMenu, IDM_CRTWORD, MF_BYCOMMAND | MF_GRAYED);
        EnableMenuItem(hCMenu, IDM_SET, MF_BYCOMMAND | MF_GRAYED);
    }

    SetWindowLongPtr(hCMenuWnd, CMENU_HUIWND, (LONG_PTR)hUIWnd);
    SetWindowLongPtr(hCMenuWnd, CMENU_MENU, (LONG_PTR)hMenu);

    TrackPopupMenu (hCMenu, TPM_LEFTBUTTON,
          rcStatusWnd.left, rcStatusWnd.top, 0, hCMenuWnd, NULL);

    hMenu = (HMENU)GetWindowLongPtr(hCMenuWnd, CMENU_MENU);
    if (hMenu) {
        SetWindowLongPtr(hCMenuWnd, CMENU_MENU, (LONG_PTR)NULL);
        DestroyMenu(hMenu);
    }

ContextMenuUnlockIMC:
    ImmUnlockIMC(hIMC);

    return;
}

/**********************************************************************/
/* SoftkeyMenu()                                                      */
/**********************************************************************/
void PASCAL SoftkeyMenu(
    HWND        hStatusWnd,
    int         x,
    int         y)
{
    HWND           hUIWnd;
    HWND           hSoftkeyMenuWnd;
    HGLOBAL        hUIPrivate;
    LPUIPRIV       lpUIPrivate;
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    HMENU          hMenu, hKeyMenu;
    RECT  rcStatusWnd;

    hUIWnd = GetWindow(hStatusWnd, GW_OWNER);
    if(!hUIWnd){
        return;
    }
    GetWindowRect(hStatusWnd, &rcStatusWnd);

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return;
    }

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {
        goto KeyMenuUnlockIMC;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {
        goto KeyMenuUnlockIMC;
    }

    if (!lpUIPrivate->hSoftkeyMenuWnd) {
        // this is important to assign owner window, otherwise the focus
        // will be gone

        // When UI terminate, it need to destroy this window
        lpUIPrivate->hSoftkeyMenuWnd = CreateWindowEx(CS_HREDRAW|CS_VREDRAW,
            szSoftkeyMenuClassName, TEXT("Softkey Menu"),
            WS_POPUP|WS_DISABLED, 0, 0, 0, 0,
            lpIMC->hWnd, (HMENU)NULL, hInst, NULL);

    }

    hSoftkeyMenuWnd = lpUIPrivate->hSoftkeyMenuWnd;

    // Unlock before we call into TrackPopupMenu().
    GlobalUnlock(hUIPrivate);

    if (!hSoftkeyMenuWnd) {
        goto KeyMenuUnlockIMC;
    }

    hMenu = LoadMenu(hInst, TEXT("SKMENU"));
    hKeyMenu = GetSubMenu(hMenu, 0);

    SetWindowLongPtr(hSoftkeyMenuWnd, SOFTKEYMENU_HUIWND, (LONG_PTR)hUIWnd);
    SetWindowLongPtr(hSoftkeyMenuWnd, SOFTKEYMENU_MENU, (LONG_PTR)hMenu);

    if(lpImeL->dwSKState[lpImeL->dwSKWant]) {
        CheckMenuItem(hMenu,lpImeL->dwSKWant + IDM_SKL1, MF_CHECKED);
    }

    TrackPopupMenu (hKeyMenu, TPM_LEFTBUTTON,
          rcStatusWnd.left, rcStatusWnd.top, 0, hSoftkeyMenuWnd, NULL);

    hMenu = (HMENU)GetWindowLongPtr(hSoftkeyMenuWnd, SOFTKEYMENU_MENU);
    if (hMenu) {
        SetWindowLongPtr(hSoftkeyMenuWnd, SOFTKEYMENU_MENU, (LONG_PTR)NULL);
        DestroyMenu(hMenu);
    }

KeyMenuUnlockIMC:
    ImmUnlockIMC(hIMC);

    return;
}
#if 1 // MultiMonitor support

/**********************************************************************/
/* ImeMonitorWorkAreaFromWindow()                                     */
/**********************************************************************/
RECT PASCAL ImeMonitorWorkAreaFromWindow(
    HWND hAppWnd)
{
    HMONITOR hMonitor;

    hMonitor = MonitorFromWindow(hAppWnd, MONITOR_DEFAULTTONEAREST);

    if (hMonitor) {
        MONITORINFO sMonitorInfo;

        sMonitorInfo.cbSize = sizeof(sMonitorInfo);
        // init a default value to avoid GetMonitorInfo fails
        sMonitorInfo.rcWork = sImeG.rcWorkArea;
#ifdef UNICODE
        GetMonitorInfoW(hMonitor, &sMonitorInfo);
#else
        GetMonitorInfoA(hMonitor, &sMonitorInfo);
#endif
        return sMonitorInfo.rcWork;
    } else {
        return sImeG.rcWorkArea;
    }
}

/**********************************************************************/
/* ImeMonitorWorkAreaFromPoint()                                      */
/**********************************************************************/
RECT PASCAL ImeMonitorWorkAreaFromPoint(
    POINT ptPoint)
{
    HMONITOR hMonitor;

    hMonitor = MonitorFromPoint(ptPoint, MONITOR_DEFAULTTONEAREST);

    if (hMonitor) {
        MONITORINFO sMonitorInfo;

        sMonitorInfo.cbSize = sizeof(sMonitorInfo);
        // init a default value to avoid GetMonitorInfo fails
        sMonitorInfo.rcWork = sImeG.rcWorkArea;
#ifdef UNICODE
        GetMonitorInfoW(hMonitor, &sMonitorInfo);
#else
        GetMonitorInfoA(hMonitor, &sMonitorInfo);
#endif
        return sMonitorInfo.rcWork;
    } else {
        return sImeG.rcWorkArea;
    }
}


/**********************************************************************/
/* ImeMonitorWorkAreaFromRect()                                       */
/**********************************************************************/
RECT PASCAL ImeMonitorWorkAreaFromRect(
    LPRECT lprcRect)
{
    HMONITOR hMonitor;

    hMonitor = MonitorFromRect(lprcRect, MONITOR_DEFAULTTONEAREST);

    if (hMonitor) {
        MONITORINFO sMonitorInfo;

        sMonitorInfo.cbSize = sizeof(sMonitorInfo);
        // init a default value to avoid GetMonitorInfo fails
        sMonitorInfo.rcWork = sImeG.rcWorkArea;

#ifdef UNICODE
        GetMonitorInfoW(hMonitor, &sMonitorInfo);
#else
        GetMonitorInfoA(hMonitor, &sMonitorInfo);
#endif
        return sMonitorInfo.rcWork;
    } else {
        return sImeG.rcWorkArea;
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntime\winhk\makefile.inc ===
!INCLUDE ..\MAKEFILE.INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntime\winpho\makefile.inc ===
!INCLUDE ..\MAKEFILE.INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntime\statusui.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    STATUSUI.c
    
++*/

#include <windows.h>
#include <htmlhelp.h>
#include <immdev.h>
#include <string.h>
#include <regstr.h>
#include <imedefs.h>
#include <resource.h>
extern HWND hCrtDlg;
HWND hChildDlg;
/**********************************************************************/
/* GetStatusWnd                                                       */
/* Return Value :                                                     */
/*      window handle of status window                                */
/**********************************************************************/
HWND PASCAL GetStatusWnd(
    HWND hUIWnd)                // UI window
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;
    HWND     hStatusWnd;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {          // can not darw status window
    return (HWND)NULL;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw status window
    return (HWND)NULL;
    }

    hStatusWnd = lpUIPrivate->hStatusWnd;

    GlobalUnlock(hUIPrivate);
    return (hStatusWnd);
}

/**********************************************************************/
/* AdjustStatusBoundary()                                             */
/**********************************************************************/
void PASCAL AdjustStatusBoundary(
    LPPOINTS lppt,
    HWND     hUIWnd)
{
    RECT rcWorkArea;

#if 1 // MultiMonitor support
    {
        RECT rcStatusWnd;

        rcStatusWnd.left = lppt->x; 
        rcStatusWnd.top = lppt->y; 
        rcStatusWnd.right = rcStatusWnd.left + sImeG.xStatusWi;
        rcStatusWnd.bottom = rcStatusWnd.top + sImeG.yStatusHi;

        rcWorkArea = ImeMonitorWorkAreaFromRect(&rcStatusWnd);
   }
#else
    rcWorkArea = sImeG.rcWorkArea;
#endif
    // display boundary check
    if (lppt->x < rcWorkArea.left) {
    lppt->x = (short)rcWorkArea.left;
    } else if (lppt->x + sImeG.xStatusWi > rcWorkArea.right) {
    lppt->x = (short)(rcWorkArea.right - sImeG.xStatusWi);
    }

    if (lppt->y < rcWorkArea.top) {
    lppt->y = (short)rcWorkArea.top;
    } else if (lppt->y + sImeG.yStatusHi > rcWorkArea.bottom) {
    lppt->y = (short)(rcWorkArea.bottom - sImeG.yStatusHi);
    }

    if(MBIndex.IMEChara[0].IC_Trace) {
    } else {
        int             Comp_CandWndLen;

        Comp_CandWndLen = 0;
        if(uStartComp) {
                Comp_CandWndLen += lpImeL->xCompWi + UI_MARGIN;
        }
        
        if(uOpenCand) {
                Comp_CandWndLen += sImeG.xCandWi + UI_MARGIN;
        }

        if(lppt->x + sImeG.xStatusWi + Comp_CandWndLen > rcWorkArea.right) {
          lppt->x=(SHORT)(rcWorkArea.right-sImeG.xStatusWi-Comp_CandWndLen);
        }
    }

    
    return;
}

/**********************************************************************/
/* SetStatusWindowPos()                                               */
/**********************************************************************/
LRESULT PASCAL SetStatusWindowPos(
    HWND   hStatusWnd)
{
    HWND           hUIWnd;
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    //RECT           rcStatusWnd;
    POINTS         ptPos;

    hUIWnd = GetWindow(hStatusWnd, GW_OWNER);
    if (!hUIWnd) {
    return (1L);
    }

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
    return (1L);
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {           // Oh! Oh!
    return (1L);
    }

    ptPos.x = (short)lpIMC->ptStatusWndPos.x;
    ptPos.y = (short)lpIMC->ptStatusWndPos.y;

    // display boundary adjust
    AdjustStatusBoundary(&ptPos, hUIWnd);

    SetWindowPos(hStatusWnd, NULL,
    ptPos.x, ptPos.y,
    0, 0, SWP_NOACTIVATE|SWP_NOCOPYBITS|SWP_NOSIZE|SWP_NOZORDER);

    ImmUnlockIMC(hIMC);

    return (0L);
}

/**********************************************************************/
/* ShowStatus()                                                       */
/**********************************************************************/
void PASCAL ShowStatus(         // Show the status window - shape / soft KBD
                // alphanumeric ...
    HWND hUIWnd,
    int  nShowStatusCmd)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {          // can not darw status window
    return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw status window
    return;
    }

    if (!lpUIPrivate->hStatusWnd) {
    // not in show status window mode
    } else if (lpUIPrivate->nShowStatusCmd != nShowStatusCmd) {
        SystemParametersInfo(SPI_GETWORKAREA, 0, &sImeG.rcWorkArea, 0);
    SetStatusWindowPos(lpUIPrivate->hStatusWnd);
    ShowWindow(lpUIPrivate->hStatusWnd, nShowStatusCmd);
    lpUIPrivate->nShowStatusCmd = nShowStatusCmd;
    } else {
    }

    GlobalUnlock(hUIPrivate);
    return;
}

/**********************************************************************/
/* OpenStatus()                                                       */
/**********************************************************************/
void PASCAL OpenStatus(         // open status window
    HWND hUIWnd)
{
    HGLOBAL        hUIPrivate;
    LPUIPRIV       lpUIPrivate;
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    POINT          ptPos;
    int            nShowStatusCmd;
    RECT           rcWorkArea;

    rcWorkArea = sImeG.rcWorkArea;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {          // can not darw status window
       return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw status window
       return;
    }

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
       ptPos.x = rcWorkArea.left;
       ptPos.y = rcWorkArea.bottom - sImeG.yStatusHi;
       nShowStatusCmd = SW_HIDE;
    } else if (lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC)) {
            POINTS TempPoints;

            //  for MUL_MONITOR
            rcWorkArea = ImeMonitorWorkAreaFromWindow(lpIMC->hWnd);


            TempPoints.x = (short) lpIMC->ptStatusWndPos.x;
            TempPoints.y = (short) lpIMC->ptStatusWndPos.y;
            AdjustStatusBoundary(&TempPoints, hUIWnd);
            lpIMC->ptStatusWndPos.x = TempPoints.x;
            lpIMC->ptStatusWndPos.y = TempPoints.y;

            if (MBIndex.IMEChara[0].IC_Trace) {
               ptPos = lpIMC->ptStatusWndPos;
            } 
            else {
               ptPos.x = sImeG.rcWorkArea.left;
               ptPos.y = sImeG.rcWorkArea.bottom - sImeG.yStatusHi;
            }

            ImmUnlockIMC(hIMC);
            nShowStatusCmd = SW_SHOWNOACTIVATE;
    } else {
       ptPos.x = rcWorkArea.left;
       ptPos.y = rcWorkArea.bottom - sImeG.yStatusHi;
       nShowStatusCmd = SW_HIDE;
    }

    if (lpUIPrivate->hStatusWnd) {
       SetWindowPos(lpUIPrivate->hStatusWnd, NULL,
                    ptPos.x, ptPos.y,
                    0, 0,
                    SWP_NOACTIVATE|SWP_NOSIZE|SWP_NOZORDER);
    } else {                            // create status window
       lpUIPrivate->hStatusWnd = CreateWindowEx(
                                    WS_EX_WINDOWEDGE|WS_EX_DLGMODALFRAME,
                                    szStatusClassName, NULL, 
                                    WS_POPUP|WS_DISABLED,
                                    ptPos.x, ptPos.y,
                                    sImeG.xStatusWi, sImeG.yStatusHi,
                                    hUIWnd, (HMENU)NULL, hInst, NULL);

        SetWindowLong(lpUIPrivate->hStatusWnd, UI_MOVE_OFFSET,
                      WINDOW_NOT_DRAG);
        SetWindowLong(lpUIPrivate->hStatusWnd, UI_MOVE_XY, 0L);
    }

    lpUIPrivate->fdwSetContext |= ISC_OPEN_STATUS_WINDOW;

    if (hIMC) {
        ShowStatus(
                   hUIWnd, SW_SHOWNOACTIVATE);
    }

    GlobalUnlock(hUIPrivate);
    return;
}

/**********************************************************************/
/* DestroyStatusWindow()                                              */
/**********************************************************************/
void PASCAL DestroyStatusWindow(
    HWND hStatusWnd)
{
    HWND     hUIWnd;
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    if (GetWindowLong(hStatusWnd, UI_MOVE_OFFSET) != WINDOW_NOT_DRAG) {
    // undo the drag border
    DrawDragBorder(hStatusWnd,
        GetWindowLong(hStatusWnd, UI_MOVE_XY),
        GetWindowLong(hStatusWnd, UI_MOVE_OFFSET));
    }

    hUIWnd = GetWindow(hStatusWnd, GW_OWNER);
    if (!hUIWnd) {
    return;
    }

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {          // can not darw status window
    return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw status window
    return;
    }

    lpUIPrivate->nShowStatusCmd = SW_HIDE;

    lpUIPrivate->hStatusWnd = (HWND)NULL;

    GlobalUnlock(hUIPrivate);
    return;
}

/**********************************************************************/
/* SetStatus                                                          */
/**********************************************************************/
void PASCAL SetStatus(
    HWND    hStatusWnd,
    LPPOINT lpptCursor)
{
    HWND           hUIWnd;
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;

    hUIWnd = GetWindow(hStatusWnd, GW_OWNER);
    if (!hUIWnd) {
    return;
    }

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
    return;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
    return;
    }

    if (!lpIMC->fOpen) {
    ImmSetOpenStatus(hIMC, TRUE);
    } else if (PtInRect(&sImeG.rcImeIcon, *lpptCursor)) {
    DWORD fdwConversion;

    if (lpIMC->fdwConversion & (IME_CMODE_CHARCODE|IME_CMODE_EUDC)) {
        // change to native mode
        fdwConversion = (lpIMC->fdwConversion | IME_CMODE_NATIVE) &
        ~(IME_CMODE_CHARCODE | IME_CMODE_EUDC);
    } else if (lpIMC->fdwConversion & IME_CMODE_NATIVE) {
        // change to alphanumeric mode
        fdwConversion = lpIMC->fdwConversion & ~(IME_CMODE_CHARCODE |
        IME_CMODE_NATIVE | IME_CMODE_EUDC);
    } else {

            BYTE  lpbKeyState[256];
        
            GetKeyboardState(lpbKeyState);
            if (lpbKeyState[VK_CAPITAL] & 1)       
            {
               // Simulate a key press
               keybd_event( VK_CAPITAL,
                   0x3A,
                   KEYEVENTF_EXTENDEDKEY | 0,
                   0 );
 
               // Simulate a key release
               keybd_event( VK_CAPITAL,
                   0x3A,
                   KEYEVENTF_EXTENDEDKEY | KEYEVENTF_KEYUP,
                   0);
           }
           fdwConversion = (lpIMC->fdwConversion | IME_CMODE_NATIVE) &
                          ~(IME_CMODE_CHARCODE | IME_CMODE_EUDC);
            uCaps = 0;
          }

        // init ime Private status
        {
        LPPRIVCONTEXT       lpImcP;

            lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    
            if(lpImcP) {
                lpImcP->PrivateArea.Comp_Status.dwSTLX = 0;
                lpImcP->PrivateArea.Comp_Status.dwSTMULCODE = 0;
                lpImcP->PrivateArea.Comp_Status.dwInvalid = 0;
            ImmUnlockIMCC(lpIMC->hPrivate);
            }
        }

        ImmSetConversionStatus(hIMC, fdwConversion, lpIMC->fdwSentence);
    } else if (PtInRect(&sImeG.rcImeName, *lpptCursor)) {
    } else if (PtInRect(&sImeG.rcShapeText, *lpptCursor)) {
    DWORD dwConvMode;

    if (lpIMC->fdwConversion & IME_CMODE_CHARCODE) {
        MessageBeep((UINT)-1);
    } else if (lpIMC->fdwConversion & IME_CMODE_EUDC) {
        MessageBeep((UINT)-1);
    } else {
        dwConvMode = lpIMC->fdwConversion ^ IME_CMODE_FULLSHAPE;
        ImmSetConversionStatus(hIMC, dwConvMode, lpIMC->fdwSentence);
    }
    } else if (PtInRect(&sImeG.rcSymbol, *lpptCursor)) {
    DWORD fdwConversion;

    if (lpIMC->fdwConversion & IME_CMODE_CHARCODE) {
        MessageBeep((UINT)-1);
    } else {
        fdwConversion = lpIMC->fdwConversion ^ IME_CMODE_SYMBOL;
        ImmSetConversionStatus(hIMC, fdwConversion, lpIMC->fdwSentence);
    }
    } else if (PtInRect(&sImeG.rcSKText, *lpptCursor)) {
    DWORD fdwConversion;
        LPPRIVCONTEXT  lpImcP;

    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    
    if(lpImcP) {
            if(!(lpImeL->hSKMenu)) {
                lpImeL->hSKMenu = LoadMenu (hInst, TEXT("SKMENU"));
            }

        lpImeL->dwSKState[lpImeL->dwSKWant] = 
                lpImeL->dwSKState[lpImeL->dwSKWant]^1;
        fdwConversion = lpIMC->fdwConversion ^ IME_CMODE_SOFTKBD;
        ImmSetConversionStatus(hIMC, fdwConversion, lpIMC->fdwSentence);
            ImmUnlockIMCC(lpIMC->hPrivate);
        } else {
        MessageBeep((UINT)-1);
        }
    } else {
    MessageBeep((UINT)-1);
    }

    ImmUnlockIMC(hIMC);

    return;
}

/**********************************************************************/
/* StatusSetCursor()                                                  */
/**********************************************************************/
void PASCAL StatusSetCursor(
    HWND        hStatusWnd,
    LPARAM      lParam)
{
    POINT ptCursor, ptSavCursor;
    RECT  rcWnd;

    if (GetWindowLong(hStatusWnd, UI_MOVE_OFFSET) != WINDOW_NOT_DRAG) {
    SetCursor(LoadCursor(NULL, IDC_SIZEALL));
    return;
    }
    
    GetCursorPos(&ptCursor);
    ptSavCursor = ptCursor;

    ScreenToClient(hStatusWnd, &ptCursor);

    if (PtInRect(&sImeG.rcStatusText, ptCursor)) {
    SetCursor(LoadCursor(hInst, szHandCursor));

    if (HIWORD(lParam) == WM_LBUTTONDOWN) {
        SetStatus(hStatusWnd, &ptCursor);
    } else if (HIWORD(lParam) == WM_RBUTTONUP) {
        if (PtInRect(&sImeG.rcSKText, ptCursor)) {
            static BOOL fSoftkey= FALSE;
            // prevent recursive
            if (fSoftkey) {
                // configuration already bring up
            return;
            }
            fSoftkey = TRUE;
                SoftkeyMenu(hStatusWnd, ptSavCursor.x, ptSavCursor.y);
            fSoftkey = FALSE;
            }else{
            static BOOL fCmenu=FALSE;
            // prevent recursive
            if (fCmenu) {
                // configuration already bring up
            return;
            }
            fCmenu = TRUE;
        ContextMenu(hStatusWnd, ptSavCursor.x, ptSavCursor.y);
            fCmenu = FALSE;
            }

    }

    return;
    } else {
    SetCursor(LoadCursor(NULL, IDC_SIZEALL));

    if (HIWORD(lParam) == WM_LBUTTONDOWN) {
        // start drag
        SystemParametersInfo(SPI_GETWORKAREA, 0, &sImeG.rcWorkArea, 0);
    } else {
        return;
    }
    }

    SetCapture(hStatusWnd);
    SetWindowLong(hStatusWnd, UI_MOVE_XY,
    MAKELONG(ptSavCursor.x, ptSavCursor.y));
    GetWindowRect(hStatusWnd, &rcWnd);
    SetWindowLong(hStatusWnd, UI_MOVE_OFFSET,
    MAKELONG(ptSavCursor.x - rcWnd.left, ptSavCursor.y - rcWnd.top));

    DrawDragBorder(hStatusWnd, MAKELONG(ptSavCursor.x, ptSavCursor.y),
    GetWindowLong(hStatusWnd, UI_MOVE_OFFSET));

    return;
}




/**********************************************************************/
/* PaintStatusWindow()                                                */
/**********************************************************************/
void PASCAL PaintStatusWindow(
    HDC  hDC,
    HWND hStatusWnd)
{
    HWND           hUIWnd;
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    LPPRIVCONTEXT  lpImcP;
    HGDIOBJ        hOldFont;
    HBITMAP        hImeIconBmp, hShapeBmp, hSymbolBmp, hSKBmp;
    HBITMAP        hOldBmp;
    HDC            hMemDC;

    hUIWnd = GetWindow(hStatusWnd, GW_OWNER);
    if (!hUIWnd) {
    MessageBeep((UINT)-1);
    return;
    }

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
    MessageBeep((UINT)-1);
    return;
    }

    if (!(lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC))) {
    MessageBeep((UINT)-1);
    return;
    }

    // get lpImcP
    if(!(lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate))) {
    MessageBeep((UINT)-1);
    return;
    }

    // set font
    if (sImeG.fDiffSysCharSet) {
        LOGFONT lfFont;
        ZeroMemory(&lfFont, sizeof(lfFont));
        hOldFont = GetCurrentObject(hDC, OBJ_FONT);
        lfFont.lfHeight = -MulDiv(12, GetDeviceCaps(hDC, LOGPIXELSY), 72);
        lfFont.lfCharSet = NATIVE_CHARSET;
        lstrcpy(lfFont.lfFaceName, TEXT("Simsun"));
        SelectObject(hDC, CreateFontIndirect(&lfFont));
    }

    // draw Ime Name
    {
    if (lpIMC->fOpen) {
    SetTextColor(hDC, RGB(0x00, 0x00, 0x00));
    } else {
    SetTextColor(hDC, RGB(0x80, 0x80, 0x80));
    }
    SetBkColor(hDC, RGB(0xC0, 0xC0, 0xC0));
    DrawText(hDC, MBIndex.MBDesc[0].szName, lstrlen(MBIndex.MBDesc[0].szName),
         &sImeG.rcImeName, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
    }
    
    DrawConvexRect(hDC,
    sImeG.rcImeName.left,
    sImeG.rcImeName.top,
    sImeG.rcImeName.right - 1,
    sImeG.rcImeName.bottom - 1);

    DrawConvexRectP(hDC,
    sImeG.rcImeName.left,
    sImeG.rcImeName.top,
    sImeG.rcImeName.right,
    sImeG.rcImeName.bottom);

    // load all bitmap
    hSymbolBmp = (HBITMAP)NULL;
    hShapeBmp = (HBITMAP)NULL;
    hSKBmp = (HBITMAP)NULL;

    if (!lpIMC->fOpen) {
    hSymbolBmp = LoadBitmap(hInst, szNone);
    hShapeBmp = LoadBitmap(hInst, szNone);
    hSKBmp = LoadBitmap(hInst, szNone);
    hImeIconBmp = LoadBitmap(hInst, szChinese);
    } else if (lpIMC->fdwConversion & IME_CMODE_NATIVE) {
    if(!lpImcP->PrivateArea.Comp_Status.OnLineCreWord){
        hImeIconBmp = LoadBitmap(hInst, szChinese);
        } else {
        hImeIconBmp = LoadBitmap(hInst, szCZ);
        }
    } else {
    hImeIconBmp = LoadBitmap(hInst, szEnglish);
    }

    if (!hShapeBmp) {
    if (lpIMC->fdwConversion & IME_CMODE_FULLSHAPE) {
        hShapeBmp = LoadBitmap(hInst, szFullShape);
    } else {
        hShapeBmp = LoadBitmap(hInst, szHalfShape);
    }
    }

    if (!hSymbolBmp) {
    if (lpIMC->fdwConversion & IME_CMODE_SYMBOL) {
        hSymbolBmp = LoadBitmap(hInst, szSymbol);
    } else {
        hSymbolBmp = LoadBitmap(hInst, szNoSymbol);
    }
    }

    if (!hSKBmp) {
    if (lpIMC->fdwConversion & IME_CMODE_SOFTKBD) {
        hSKBmp = LoadBitmap(hInst, szSoftKBD);
    } else {
        hSKBmp = LoadBitmap(hInst, szNoSoftKBD);
    }
    }

    ImmUnlockIMC(hIMC);
    ImmUnlockIMCC(lpIMC->hPrivate);

    hMemDC = CreateCompatibleDC(hDC);

    hOldBmp = SelectObject(hMemDC, hImeIconBmp);

    BitBlt(hDC, sImeG.rcImeIcon.left, sImeG.rcImeIcon.top,
    sImeG.rcImeIcon.right - sImeG.rcImeIcon.left,
    STATUS_DIM_Y,
    hMemDC, 0, 0, SRCCOPY);

    SelectObject(hMemDC, hShapeBmp);

    BitBlt(hDC, sImeG.rcShapeText.left, sImeG.rcShapeText.top,
    sImeG.rcShapeText.right - sImeG.rcShapeText.left,
    STATUS_DIM_Y,
    hMemDC, 0, 0, SRCCOPY);

    SelectObject(hMemDC, hSymbolBmp);

    BitBlt(hDC, sImeG.rcSymbol.left, sImeG.rcSymbol.top,
    sImeG.rcSymbol.right - sImeG.rcSymbol.left,
    STATUS_DIM_Y,
    hMemDC, 0, 0, SRCCOPY);

    SelectObject(hMemDC, hSKBmp);

    BitBlt(hDC, sImeG.rcSKText.left, sImeG.rcSKText.top,
    sImeG.xStatusWi - sImeG.rcSKText.left,
    STATUS_DIM_Y,
    hMemDC, 0, 0, SRCCOPY);

    SelectObject(hMemDC, hOldBmp);

    DeleteDC(hMemDC);

    DeleteObject(hImeIconBmp);
    DeleteObject(hSymbolBmp);
    DeleteObject(hShapeBmp);
    DeleteObject(hSKBmp);
    if (sImeG.fDiffSysCharSet) {
        DeleteObject(SelectObject(hDC, hOldFont));
    }

    return;
}

/**********************************************************************/
/* StatusWndProc()                                                    */
/**********************************************************************/
LRESULT CALLBACK StatusWndProc(
    HWND   hStatusWnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (uMsg) {
    case WM_DESTROY:
         DestroyStatusWindow(hStatusWnd);
         break;
    case WM_SETCURSOR:
         StatusSetCursor(hStatusWnd, lParam);
         break;
    case WM_MOUSEMOVE:
         if (GetWindowLong(hStatusWnd, UI_MOVE_OFFSET) != WINDOW_NOT_DRAG) {
            POINT ptCursor;

            DrawDragBorder(hStatusWnd,
            GetWindowLong(hStatusWnd, UI_MOVE_XY),
            GetWindowLong(hStatusWnd, UI_MOVE_OFFSET));
            GetCursorPos(&ptCursor);
            SetWindowLong(hStatusWnd, UI_MOVE_XY,
            MAKELONG(ptCursor.x, ptCursor.y));
            DrawDragBorder(hStatusWnd, MAKELONG(ptCursor.x, ptCursor.y),
            GetWindowLong(hStatusWnd, UI_MOVE_OFFSET));
        } else {
            return DefWindowProc(hStatusWnd, uMsg, wParam, lParam);
        }
        break;
    case WM_LBUTTONUP:

         if (GetWindowLong(hStatusWnd, UI_MOVE_OFFSET) != WINDOW_NOT_DRAG) {
            LONG  lTmpCursor, lTmpOffset;

            lTmpCursor = GetWindowLong(hStatusWnd, UI_MOVE_XY);

            // calculate the org by the offset
            lTmpOffset = GetWindowLong(hStatusWnd, UI_MOVE_OFFSET);

            DrawDragBorder(hStatusWnd, lTmpCursor, lTmpOffset);

            (*(LPPOINTS)&lTmpCursor).x -= (*(LPPOINTS)&lTmpOffset).x;
            (*(LPPOINTS)&lTmpCursor).y -= (*(LPPOINTS)&lTmpOffset).y;

            SetWindowLong(hStatusWnd, UI_MOVE_OFFSET, WINDOW_NOT_DRAG);
            ReleaseCapture();

            AdjustStatusBoundary((LPPOINTS)&lTmpCursor,
                        GetWindow(hStatusWnd, GW_OWNER));

            SendMessage(GetWindow(hStatusWnd, GW_OWNER), WM_IME_CONTROL,
            IMC_SETSTATUSWINDOWPOS, lTmpCursor);
        } else {
            return DefWindowProc(hStatusWnd, uMsg, wParam, lParam);
        }
        break;
    case WM_IME_NOTIFY:
        // get work area for changing
        SystemParametersInfo(SPI_GETWORKAREA, 0, &sImeG.rcWorkArea, 0);

        if (wParam == IMN_SETSTATUSWINDOWPOS) {
            SetStatusWindowPos(hStatusWnd);
        }
        break;
    case WM_PAINT:
        {
          HDC         hDC;
          PAINTSTRUCT ps;

          hDC = BeginPaint(hStatusWnd, &ps);
          PaintStatusWindow(hDC, hStatusWnd);
          EndPaint(hStatusWnd, &ps);
        }
        break;
    case WM_MOUSEACTIVATE:
         return (MA_NOACTIVATE);
    default:
         return DefWindowProc(hStatusWnd, uMsg, wParam, lParam);
    }

    return (0L);
}

///////
int     CheckCodeKey (TCHAR szInputCode[]);
BOOL    CrtIsUsedCode(TCHAR   wCharCode);
int     CheckKey (TCHAR szInputWord[]);
void    BreakString (LPTSTR, LPTSTR, LPTSTR);
int     DelItem (HIMCC, LPTSTR, LPTSTR);


void    AddStringTolist ( LPINPUTCONTEXT lpIMC, HWND hDlg);
BOOL    GetUDCItem(HIMCC, UINT, LPTSTR, LPTSTR);
void    DelSelCU (HIMCC, int);
int     GetUDCIndex(HIMCC, LPTSTR, LPTSTR);

BOOL FAR PASCAL ListWordProc(HWND, UINT, WPARAM, LPARAM);
BOOL FAR PASCAL ModiWordDlgProc(HWND, UINT, DWORD, LONG);

FARPROC lpListWordOld;

#define LBN_DELETE      6

static TCHAR szModiWord [MAXINPUTWORD + 1];
static TCHAR szModiCode [MAXCODE + 1];

/**********************************************************************/
/* CrtWordDlgProc()                                                   */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL FAR PASCAL CrtWordDlgProc(
    HWND hDlg,
    UINT uMessage,
    DWORD wParam,
    LONG lParam)
{
    RECT rc;
    LONG DlgWidth, DlgHeight;

    static TCHAR szInputWord [MAXINPUTWORD + 1];
    static TCHAR szInputCode [MAXCODE + 1];

    static TCHAR szInputWordOld [MAXINPUTWORD + 1] ;
    static TCHAR szInputCodeOld [MAXCODE + 1] ;

    switch (uMessage) {

        case WM_PAINT:
            {
                RECT rc;

            GetClientRect(hDlg, &rc);
                DrawConvexRect(GetDC(hDlg),
                rc.left + 10,
                rc.top + 10,
                rc.right - 10 - 1,
                rc.bottom - 20 - 1);

                DrawConvexRectP(GetDC(hDlg),
                rc.left + 10,
                rc.top + 10,
                rc.right - 10,
                rc.bottom - 20);
            }
        
        return (FALSE);

        case WM_INITDIALOG:
        {
        TCHAR szStr[54];
        HDC     hDC;
        DWORD   nStrLenth;
        RECT rcWorkArea;        
        
        hCrtDlg = hDlg;
#ifdef UNICODE
        {
           TCHAR UniTmp1[] = {0x006D, 0x006D, 0x006D, 0x006D, 0x006D, 0x006D, 0x006D, 0x006D, 0x006D, 0x006D, 0x006D, 0x006D, 0x0000};
           TCHAR UniTmp2[] = {0x96F6, 0x4E00, 0x4E8C, 0x4E09, 0x56DB, 0x4E94, 0x516D, 0x4E03, 0x516B, 0x4E5D, 0x96F6, 0x4E00, 0x4E8C, 0x4E09, 0x56DB, 0x4E94, 0x516D, 0x4E03, 0x516B, 0x4E5D, 0x0000};
           MyStrFormat (szStr, UniTmp1, UniTmp2);
        }
#else
        MyStrFormat (szStr, TEXT("mmmmmmmmmmmm"), TEXT(""));
#endif //UNICODE
        // reset position
        GetWindowRect(hDlg, &rc);
        DlgWidth =  rc.right - rc.left;
        DlgHeight =  rc.bottom - rc.top;

        rcWorkArea = ImeMonitorWorkAreaFromWindow(hDlg);
    
        SetWindowPos(hDlg, HWND_TOP,
                (int)(rcWorkArea.right - DlgWidth)/2,
                (int)(rcWorkArea.bottom - DlgHeight)/2,
                (int)0, (int)0, SWP_NOSIZE);
        CheckRadioButton (hDlg, IDC_RADIOADD, IDC_RADIOMOD, IDC_RADIOADD);

        lpListWordOld = (FARPROC)GetWindowLongPtr(GetDlgItem (hDlg,IDC_LIST_WORD),
                GWLP_WNDPROC);
        SetWindowLongPtr(GetDlgItem (hDlg,IDC_LIST_WORD), GWLP_WNDPROC,
                (LONG_PTR)ListWordProc);

        EnableWindow (GetDlgItem (hDlg,IDC_BT_MODIFY), FALSE);
        EnableWindow (GetDlgItem (hDlg,IDC_BT_DEL), FALSE);

        EnableWindow (GetDlgItem (hDlg,IDC_INPUTWORD), TRUE);
        EnableWindow (GetDlgItem (hDlg,IDC_INPUTCODE), TRUE);
        EnableWindow (GetDlgItem (hDlg,IDC_BT_INS), TRUE);

        SendDlgItemMessage (hDlg, IDC_INPUTWORD, EM_LIMITTEXT, MAXINPUTWORD, 0);
        SendDlgItemMessage (hDlg, IDC_INPUTCODE, EM_LIMITTEXT, MBIndex.MBDesc[0].wMaxCodes, 0);

        hDC = GetDC (hDlg);

            nStrLenth = GetTabbedTextExtent (hDC, szStr, lstrlen(szStr), 0, (LPINT)NULL);
    
        ReleaseDC (hDlg, hDC);

        SendDlgItemMessage (hDlg, IDC_LIST_WORD, LB_SETHORIZONTALEXTENT, nStrLenth, 0);

        return (TRUE);          // don't want to set focus to special control
        }
        case WM_COMMAND:

        switch (LOWORD(wParam)) {

            case IDC_RADIOADD:

                EnableWindow (GetDlgItem (hDlg,IDC_BT_MODIFY), FALSE);
                EnableWindow (GetDlgItem (hDlg,IDC_BT_DEL), FALSE);

                EnableWindow (GetDlgItem (hDlg,IDC_INPUTWORD), TRUE);
                EnableWindow (GetDlgItem (hDlg,IDC_INPUTCODE), TRUE);
                EnableWindow (GetDlgItem (hDlg,IDC_STATIC), TRUE);
                EnableWindow (GetDlgItem (hDlg,IDC_BT_INS), TRUE);

                SendDlgItemMessage (hDlg, IDC_BT_INS, BM_SETSTYLE, BS_DEFPUSHBUTTON, TRUE);
                SendDlgItemMessage (hDlg, IDC_CLOSE, BM_SETSTYLE, BS_PUSHBUTTON, TRUE);
                SendDlgItemMessage (hDlg, IDC_LIST_WORD, LB_RESETCONTENT, 0, 0L);

                SetFocus (GetDlgItem (hDlg, IDC_INPUTWORD));

                break;

            case IDC_RADIOMOD:

                EnableWindow (GetDlgItem (hDlg,IDC_BT_MODIFY), TRUE);
                EnableWindow (GetDlgItem (hDlg,IDC_BT_DEL), TRUE);

                EnableWindow (GetDlgItem (hDlg,IDC_INPUTWORD), FALSE);
                EnableWindow (GetDlgItem (hDlg,IDC_INPUTCODE), FALSE);
                EnableWindow (GetDlgItem (hDlg,IDC_STATIC), FALSE);
                EnableWindow (GetDlgItem (hDlg,IDC_BT_INS), FALSE);

                SendDlgItemMessage (hDlg, IDC_CLOSE, BM_SETSTYLE, BS_DEFPUSHBUTTON, TRUE);
                SendDlgItemMessage (hDlg, IDC_BT_INS, BM_SETSTYLE, BS_PUSHBUTTON, TRUE);
                SendDlgItemMessage (hDlg, IDC_LIST_WORD, LB_RESETCONTENT, 0, 0L);

            SetDlgItemText (hDlg,IDC_INPUTCODE, TEXT(""));
            SetDlgItemText (hDlg,IDC_INPUTWORD, TEXT(""));
            lstrcpy (szInputWordOld, TEXT(""));
            lstrcpy (szInputCodeOld, TEXT(""));

                {
                HIMC           hIMC; 
                LPINPUTCONTEXT lpIMC;
                HCURSOR        hOldCursor;
                WORD           wTabStops [1]; 
                wTabStops[0] = 80; 
                hIMC = (HIMC)ImmGetContext(GetParent(hDlg));
                if (!hIMC) {
                    return (0L);
                }

                lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
                if (!lpIMC) {          // Oh! Oh!
                    return (0L);
                }

                hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

                SendDlgItemMessage (hDlg, IDC_LIST_WORD, LB_SETTABSTOPS, 1, (LPARAM)&wTabStops[0]);

                AddStringTolist (lpIMC, hDlg);

                SetCursor(hOldCursor);

                ImmUnlockIMC(hIMC);
                ImmReleaseContext (GetParent(hDlg), hIMC);
                }
                SetFocus (GetDlgItem (hDlg,IDC_LIST_WORD));

                break;

            case IDC_INPUTCODE:

                {
                    HIMC           hIMC;

                    hIMC = (HIMC)ImmGetContext(hDlg);
                    if (!hIMC) {
                        return FALSE;
                    }

                    switch(HIWORD(wParam)) {
                      case EN_SETFOCUS:
                            if(hIMC) {
                                ImmSetOpenStatus(hIMC, FALSE);
                                ImmUnlockIMC(hIMC);
                            }
                            break;
                      case EN_KILLFOCUS:
                            if(hIMC) {
                                ImmSetOpenStatus(hIMC, TRUE);
                                ImmUnlockIMC(hIMC);
                            }
                            break;
                      default:
                            break;
                    }
                }

                GetDlgItemText (hDlg, IDC_INPUTCODE, szInputCode, MAXCODE);

                if (SendDlgItemMessage(hDlg,IDC_INPUTCODE,EM_GETMODIFY,0,0)){
                    
                    int i, CaretPos;

                    GetDlgItemText (hDlg, IDC_INPUTCODE, szInputCode, MAXCODE);

                    if (((CaretPos = CheckCodeKey (szInputCode)) != (-1))) {

                    lstrcpy (szInputCode, szInputCodeOld);
                    SetDlgItemText (hDlg,IDC_INPUTCODE, szInputCode);

                    for (i = 0; i < 1; i++){
                        MessageBeep (0xFFFFFFFF);
                    }

                    }
                    lstrcpy (szInputCodeOld, szInputCode);
                 }
                break;



            case IDC_INPUTWORD:

                GetDlgItemText (hDlg, IDC_INPUTWORD, szInputWord, MAXINPUTWORD);

                if (SendDlgItemMessage(hDlg,IDC_INPUTWORD,EM_GETMODIFY,0,0)){
                    int i, CaretPos;

                    GetDlgItemText(hDlg,IDC_INPUTWORD,szInputWord,MAXINPUTWORD);
                    if (((CaretPos = CheckKey (szInputWord)) != (-1))) {
                       lstrcpy (szInputWord, szInputWordOld);
                       SetDlgItemText (hDlg,IDC_INPUTWORD, szInputWord);
                       SendDlgItemMessage(hDlg,
                                          IDC_INPUTWORD, 
                                          EM_SETSEL, 
                                          CaretPos, 
                                          CaretPos);

                       for (i = 0; i < 1; i++){
                            MessageBeep (0xFFFFFFFF);
                       }

                    }

                    if (MBIndex.MBDesc[0].wNumRulers != 0){
    
                       TCHAR MBName[MAXSTRLEN];
                       static TCHAR szAutoCode [MAXCODE + 1];                                       
    
                       HIMC           hIMC;
                       LPINPUTCONTEXT lpIMC;
                       LPPRIVCONTEXT  lpImcP;
    
                       hIMC = (HIMC)ImmGetContext(GetParent(hDlg));
                       if (!hIMC) {
                          return (0L);
                       }
                
                       lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
                       if (!lpIMC) {          // Oh! Oh!
                          return (0L);
                       }

                       lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    
                       if (!lpImcP) {          // Oh! Oh!
                          return (0L);
                       }
        
                       // auto coding
                       lstrcpy(MBName, sImeG.szIMESystemPath);
                       lstrcat((LPTSTR)MBName, TEXT("\\"));
                       lstrcat((LPTSTR)MBName, (LPCTSTR)lpImcP->MB_Name);
                       ConvCreateWord(lpIMC->hWnd, 
                                      (LPCTSTR)MBName,
                                      (LPTSTR)szInputWord,
                                      (LPTSTR)szAutoCode);
    
                       ImmUnlockIMC(hIMC);
                       ImmUnlockIMCC(lpIMC->hPrivate);
                       ImmReleaseContext (GetParent(hDlg), hIMC);
                       SetDlgItemText (hDlg,IDC_INPUTCODE, szAutoCode);
                       SendDlgItemMessage(hDlg,IDC_INPUTCODE,EM_SETSEL, 0, -1);

                       lstrcpy (szInputCodeOld, szAutoCode);
                    }
    
                    lstrcpy (szInputWordOld, szInputWord);
                 }

                 break;
    
                case IDC_LIST_WORD:

                    if (SendDlgItemMessage(hDlg,IDC_RADIOADD,BM_GETCHECK,0,0))
                        break;

                    if (HIWORD(wParam) == LBN_DBLCLK) {
                       SendMessage(hDlg,WM_COMMAND,MAKELONG(IDC_BT_MODIFY,0),0);
                       break;
                    }

                    if (!(HIWORD(wParam) == LBN_DELETE)) {
                       break;
                    }
                    MessageBeep (0xFFFFFFFF);

                case IDC_BT_DEL:

                    {
                    HIMC           hIMC;
                    LPINPUTCONTEXT lpIMC;
                    TCHAR szList [80];
                    TCHAR szCode [MAXCODE + 1];
                    TCHAR szWord [MAXINPUTWORD + 1];
                    WORD nLenth;
                    int SelFlag;
                    int SelIndex [MAXNUMBER_EMB], NewIndex;
                    WORD SelCount, i;
                    
                    if ((SelCount=(WORD)SendDlgItemMessage(hDlg,
                                                  IDC_LIST_WORD,
                                                  LB_GETSELITEMS, 
                                                  (WPARAM)MAXNUMBER_EMB,
                                                  (LPARAM)SelIndex)) == LB_ERR) 
                        break;
                
                    if(SelCount) {
                      TCHAR szDelMessageString [40];

                      wsprintf (szDelMessageString, TEXT("%d"), SelCount);
#ifdef UNICODE
                      {
                        TCHAR UniTmp[] = {0x0020, 0x4E2A, 0x8BCD, 0x6761, 
                                          0x5C06, 0x88AB, 0x5220, 0x9664, 
                                          0x0021, 0x0020, 0x0020, 0x0020, 
                                          0x0020, 0x0020, 0x0020, 0x0020, 
                                          0x0020, 0x0000}; 
   
                        lstrcat (szDelMessageString, UniTmp);
                      }
#else
                      lstrcat(szDelMessageString, 
                              TEXT(" !        "));
#endif
                      if (IDNO == MessageBox (hDlg, 
                                              szDelMessageString, 
                                              szWarnTitle, 
                                              MB_YESNO|MB_ICONINFORMATION))
                         break;
                    } else {
                         break;
                    }

                    hIMC = (HIMC)ImmGetContext(GetParent(hDlg));
                    if (!hIMC) {
                         return 0L;
                    }

        
                    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
                    if (!lpIMC) {          // Oh! Oh!
                       return (0L);
                    }                                

                    for (i = 0; i < SelCount; i++){

                      nLenth = (WORD)SendDlgItemMessage(hDlg,
                                               IDC_LIST_WORD,
                                               LB_GETTEXT, 
                                               (WPARAM)SelIndex[SelCount-i-1],
                                               (LPARAM)(LPTSTR)szList);

                      if ( nLenth == LB_ERR) break;

                      BreakString((LPTSTR)szList,(LPTSTR)szCode,(LPTSTR)szWord);

                      NewIndex=GetUDCIndex(lpIMC->hPrivate,
                                           (LPTSTR)szCode,
                                           (LPTSTR)szWord);

                      DelSelCU (lpIMC->hPrivate,  NewIndex);

#ifdef EUDC
                      if(strlen((const char *)szWord) == sizeof(WORD)){
                        ImeUnregisterWord(szCode,IME_REGWORD_STYLE_EUDC,szWord);
                      }
#endif

                      //For modify
                      SendDlgItemMessage (hDlg,IDC_LIST_WORD,
                         LB_DELETESTRING, SelIndex [SelCount - i - 1], 0L);

                      SelFlag = SelIndex [SelCount - i - 1];
                   } 
        
                   if (SelFlag>=SendDlgItemMessage(hDlg,IDC_LIST_WORD,
                                                   LB_GETCOUNT, 0,0)){
                        SelFlag = (int) SendDlgItemMessage(hDlg,
                                                           IDC_LIST_WORD, 
                                                           LB_GETCOUNT, 
                                                           (WPARAM)0,
                                                           (LPARAM)0) -1;
                    } // Keep current item
                    SendDlgItemMessage (hDlg,IDC_LIST_WORD,
                         LB_SELITEMRANGE, 1, MAKELONG(SelFlag, SelFlag));

                    SendDlgItemMessage (hDlg,IDC_LIST_WORD,
                         LB_SETCARETINDEX, SelFlag, 0L);

                    ImmUnlockIMC(hIMC);
                    ImmReleaseContext (GetParent(hDlg), hIMC);

                    SetFocus (GetDlgItem (hDlg, IDC_LIST_WORD));
                    break;
                    }
                case IDC_BT_MODIFY:
                    { 
                      // get string in listbox
                      TCHAR szList [80];
                      WORD nLenth;

                      int SelIndex [50];
                      WORD SelCount;

                      SelCount=(WORD)SendDlgItemMessage(hDlg,
                                                      IDC_LIST_WORD,
                                                      LB_GETSELITEMS, 
                                                      (WPARAM)50, 
                                                      (LPARAM)SelIndex);

                      if ((SelCount == LB_ERR)||(SelCount != 1)) break;
             

                      nLenth=(WORD)SendDlgItemMessage(hDlg,
                                                      IDC_LIST_WORD,
                                                      LB_GETTEXT, 
                                                      (WPARAM)SelIndex[0],
                                                      (LPARAM)(LPTSTR)szList);
                      if (nLenth == LB_ERR) break;

                      BreakString((LPTSTR)szList,
                                  (LPTSTR)szModiCode,
                                  (LPTSTR)szModiWord);

                      SendDlgItemMessage (hDlg,IDC_LIST_WORD,
                      LB_DELETESTRING, SelIndex [0], 0L);

                    }
                    DialogBox(hInst,TEXT("MODIWORD"),hDlg,(DLGPROC)ModiWordDlgProc);
                    SetFocus(GetDlgItem (hDlg, IDC_BT_MODIFY));
                    SendDlgItemMessage (hDlg, 
                                        IDC_BT_MODIFY, 
                                        BM_SETSTYLE, 
                                        BS_DEFPUSHBUTTON, 
                                        TRUE);

                    { 
                      TCHAR   WCodeStr[MAXCODE + 1];
                      TCHAR   DBCSStr [MAXINPUTWORD + 1];
                      TCHAR   szOutList[80];
                      int     ModiIndex;
        
                            
                      lstrcpy (WCodeStr,  szModiCode);
                      lstrcpy (DBCSStr ,  szModiWord);
                      MyStrFormat (szOutList, WCodeStr, DBCSStr); 
                      SendDlgItemMessage (hDlg, 
                                          IDC_LIST_WORD, 
                                          LB_ADDSTRING, 
                                          (WPARAM)0,
                                          (LPARAM)(LPTSTR)szOutList);
    
                      ModiIndex =(int)SendDlgItemMessage(hDlg, 
                                                    IDC_LIST_WORD, 
                                                    LB_FINDSTRING, 
                                                    (WPARAM) -1,
                                                    (LPARAM)(LPTSTR)szOutList);
    
                      SendDlgItemMessage (hDlg,IDC_LIST_WORD,
                                          LB_SELITEMRANGE, 
                                          1, 
                                          MAKELONG(ModiIndex, ModiIndex));

                      SendDlgItemMessage (hDlg,IDC_LIST_WORD,
                                          LB_SETCARETINDEX, 
                                          ModiIndex, 
                                          0L);

                      SetFocus (GetDlgItem (hDlg, IDC_BT_MODIFY));
                   }
        
                   break;

                case IDC_BT_INS:
                    { 
                     HIMC           hIMC;
                     LPINPUTCONTEXT lpIMC;
                     int            fAddWordFlag;
                     HWND hControl;
    
                     TCHAR szListWord [80];
                     {
                        TCHAR szWord [MAXINPUTWORD + 1];
                        TCHAR szCode [MAXCODE + 1] ;
                        GetDlgItemText(hDlg,IDC_INPUTWORD,szWord,MAXINPUTWORD);
                        GetDlgItemText (hDlg, IDC_INPUTCODE, szCode, MAXCODE);
                        if (lstrlen(szWord) == 0){
                           SetFocus (GetDlgItem (hDlg,IDC_INPUTWORD));    
                           break;
                        } else if (lstrlen(szCode) == 0){
    
                            SetFocus (GetDlgItem (hDlg,IDC_INPUTCODE));
                            break;
                        }
                    }

                    GetDlgItemText(hDlg,IDC_INPUTWORD,szInputWord,MAXINPUTWORD);
                    GetDlgItemText (hDlg, IDC_INPUTCODE, szInputCode, MAXCODE);
                    MyStrFormat (szListWord, szInputCode, szInputWord); 
                    if(lstrlen(szInputWord) && lstrlen(szInputCode)) {

                       hIMC = (HIMC)ImmGetContext(GetParent (hDlg));
                      
                       if (!hIMC) {
                          return 0L;
                       }
            
                       lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
                       if (!lpIMC) {          // Oh! Oh!
                          return (0L);
                       }
                                    
                       CharLowerBuff(szInputCode, lstrlen(szInputCode));

                       {
                          UINT i;
                          for(i=0;i<strlen((const char *)szInputCode);i++){
                             if(!IsUsedCode(szInputCode[i], NULL)){
                               InfoMessage(NULL, IDS_WARN_INVALIDCODE);
                               ImmUnlockIMC(hIMC);
                               ImmReleaseContext(GetParent(GetParent(hDlg)), 
                                                 hIMC);
                               return(0L);
                             }
                          }
                       }
                       fAddWordFlag = AddZCItem(lpIMC->hPrivate, 
                                                szInputCode, 
                                                szInputWord);

                       ImmUnlockIMC(hIMC);
                       ImmReleaseContext (GetParent(hDlg), hIMC);

                       if (fAddWordFlag == ADD_REP){
                          InfoMessage(NULL, IDS_WARN_DUPPRASE);
                          break;
                       } else if (fAddWordFlag == ADD_FULL){
                             InfoMessage(NULL, IDS_WARN_OVEREMB);
                             break;
                       }
                       hControl = GetDlgItem (hDlg,IDC_LIST_WORD);
         
                       SendMessage (hControl, LB_ADDSTRING, (WPARAM) 0, 
                            (LPARAM)(LPTSTR)szListWord);


                    } else {
                        szInputWord[0] = 0;
                        szInputCode[0] = 0;
                    }
    
                   }
                   SetDlgItemText (hDlg,IDC_INPUTWORD, TEXT(""));
                   SetDlgItemText (hDlg,IDC_INPUTCODE, TEXT(""));

                   lstrcpy (szInputWordOld, TEXT(""));
                   lstrcpy (szInputCodeOld, TEXT(""));

                   SetFocus (GetDlgItem (hDlg,IDC_INPUTWORD));
                   break;
                case IDC_CLOSE:
                     hCrtDlg = NULL;
                     lstrcpy (szInputWordOld, TEXT(""));
                     lstrcpy (szInputCodeOld, TEXT(""));

                     EndDialog (hDlg, FALSE);
                     break;
                case IDCANCEL:
                     hCrtDlg = NULL;
                     lstrcpy (szInputWordOld, TEXT(""));
                     lstrcpy (szInputCodeOld, TEXT(""));

                     EndDialog(hDlg, FALSE);
                     break;
                default:
                    return (FALSE);
                    break;
                }
                return (TRUE);
        case WM_CLOSE:
            if (hChildDlg) SendMessage(hChildDlg, WM_CLOSE, 0, 0);
            hCrtDlg = NULL;
            lstrcpy (szInputWordOld, TEXT(""));
            lstrcpy (szInputCodeOld, TEXT(""));

            EndDialog(hDlg, FALSE);
            return (TRUE);
        default:
            return (FALSE);
    }

    return (TRUE);
}

/*********************************************************************/
/* void AddStringTolist ( LPINPUTCONTEXT lpIMC)                     */
/*********************************************************************/
void AddStringTolist ( LPINPUTCONTEXT lpIMC,
               HWND           hDlg)
{
    TCHAR   WCodeStr[MAXCODE + 1];
    TCHAR   DBCSStr [MAXINPUTWORD + 1];
    TCHAR   szOutList[80];
    int     i = 0, n = 0;
    while (GetUDCItem(lpIMC->hPrivate, i, (LPTSTR)&WCodeStr, (LPTSTR)&DBCSStr)){
    MyStrFormat(szOutList, WCodeStr, DBCSStr); 
    SendDlgItemMessage (hDlg, IDC_LIST_WORD, LB_ADDSTRING, (WPARAM)0,
                (LPARAM)(LPTSTR)szOutList);
    i ++;
    }

}
/*********************************************************************/
/* int CheckKey (char szInputWord[])                                */
/*                                                                   */
/*********************************************************************/
int CheckKey (TCHAR szInputWord[])
{
    int i;

#ifdef UNICODE
    for (i = 0; i < lstrlen (szInputWord); i++ ){

        if ((WORD)szInputWord [i] < 0x100) return i;
    }
#else
    for (i = 0; i < lstrlen (szInputWord); i += 2 ){

        if ((BYTE)szInputWord [i] < 128) return i;
    }
#endif
    return (-1);
}
/************************************************************************/
/*BOOL CrtIsUsedCode(TCHAR    wCharCode)                                 */
/************************************************************************/
BOOL CrtIsUsedCode(TCHAR    wCharCode)
{
      WORD wFlg;

      for(wFlg=0; wFlg<MBIndex.MBDesc[0].wNumCodes; wFlg++){

        if (wCharCode == MBIndex.MBDesc[0].szUsedCode[wFlg])
            break;
      }

      if(wFlg < MBIndex.MBDesc[0].wNumCodes)
        return (TRUE);
    
      return (FALSE);
}

/*********************************************************************/
/* int CheckCodeKey (TCHAR szInputCode[])                                */
/*                                                                   */
/*********************************************************************/
int CheckCodeKey (TCHAR szInputCode[])
{
    int i;

    for (i = 0; i < lstrlen (szInputCode); i++){

#ifdef UNICODE
        if (szInputCode[i] > 0x100) return i;
#else
        if ((BYTE)szInputCode [i] > 128) return i;
#endif
        if(IsCharUpper(szInputCode [i])) {
            szInputCode [i] |= 0x20;
        }
        if (!CrtIsUsedCode (szInputCode [i])) return i;
    }
    return (-1);
}
/********************************************************************/
/*BOOL FAR PASCAL ListWordProc( HWND    hwnd,                               */
/*                      UINT    uMessage,                           */
/*                      WPARAM  wParam,                             */    
/*                      LPARAM  lParam)                             */
/********************************************************************/
BOOL FAR PASCAL ListWordProc(
    HWND    hwnd,
    UINT    uMessage,
    WPARAM  wParam,
    LPARAM  lParam)

{
    switch (uMessage){

    case WM_KEYDOWN:

        if (wParam == VK_DELETE){

        SendMessage (GetParent (hwnd), WM_COMMAND,
                MAKELONG(IDC_LIST_WORD, (WORD)LBN_DELETE), (LPARAM)hwnd);
        return TRUE;
        }
        break;
    default :

        break;

    }

    return (BOOL) CallWindowProc ((WNDPROC)lpListWordOld, hwnd, uMessage, wParam, lParam);

}


/**********************************************************************/
/* ModiWordDlgProc()                                                   */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL FAR PASCAL ModiWordDlgProc(
    HWND  hDlg,
    UINT  uMessage,
    DWORD wParam,
    LONG  lParam)
{
    RECT rc;
    LONG DlgWidth, DlgHeight;
    RECT rcWorkArea;

    static TCHAR szInputWord [MAXINPUTWORD + 1];
    static TCHAR szInputCode [MAXCODE + 1];

    static TCHAR szInputWordOld [MAXINPUTWORD + 1] ;
    static TCHAR szInputCodeOld [MAXCODE + 1] ;
    switch (uMessage) {

    case WM_INITDIALOG:
    
    // reset position
    hChildDlg = hDlg;
    GetWindowRect(hDlg, &rc);
    DlgWidth =  rc.right - rc.left;
    DlgHeight =  rc.bottom - rc.top;
    rcWorkArea = ImeMonitorWorkAreaFromWindow(hDlg);
    SetWindowPos(hDlg, HWND_TOP,
            (int)(rcWorkArea.right - DlgWidth)/2,
            (int)(rcWorkArea.bottom - DlgHeight)/2,
            (int) 0, (int) 0, SWP_NOSIZE);
    SendDlgItemMessage (hDlg, IDC_MODI_WORD, EM_LIMITTEXT, MAXINPUTWORD, 0);
    SendDlgItemMessage (hDlg, IDC_MODI_CODE, EM_LIMITTEXT, MBIndex.MBDesc[0].wMaxCodes, 0);

    SetDlgItemText (hDlg,IDC_MODI_CODE, szModiCode);
    SetDlgItemText (hDlg,IDC_MODI_WORD, szModiWord);
    SetFocus (GetDlgItem (hDlg,IDC_MODI_WORD)); 

    lstrcpy (szInputWordOld, szModiWord);
    lstrcpy (szInputCodeOld, szModiCode);
    return (TRUE);          // don't want to set focus to special control

    case WM_PAINT:
    {
        RECT rc;

        GetClientRect(hDlg, &rc);
        DrawConvexRect(GetDC(hDlg),
        rc.left + 5,
        rc.top + 5,
        rc.right - 5 - 1,
        rc.bottom - 10 - 1);

        DrawConvexRectP(GetDC(hDlg),
        rc.left + 5,
        rc.top + 5,
        rc.right - 5,
        rc.bottom - 10);
    }
 
    return (FALSE);


    case WM_COMMAND:

    switch (LOWORD(wParam)) {

        case IDC_MODI_CODE:
            {
                HIMC           hIMC;

                hIMC = (HIMC)ImmGetContext(hDlg);
                if (!hIMC) {
                    return 0L;
                }

                switch(HIWORD(wParam)) {
                    case EN_SETFOCUS:
                        if(hIMC) {
                            ImmSetOpenStatus(hIMC, FALSE);
                            ImmUnlockIMC(hIMC);
                        }
                        break;
                    case EN_KILLFOCUS:
                        if(hIMC) {
                            ImmSetOpenStatus(hIMC, TRUE);
                            ImmUnlockIMC(hIMC);
                        }
                        break;
                    default:
                        break;
                }
            }
            GetDlgItemText (hDlg, IDC_MODI_CODE, szInputCode, MAXCODE);

            if (SendDlgItemMessage (hDlg,IDC_MODI_CODE, EM_GETMODIFY, 0, 0)){
                int i, CaretPos;

                GetDlgItemText (hDlg, IDC_MODI_CODE, szInputCode, MAXCODE);

                if ( ((CaretPos = CheckCodeKey (szInputCode)) != (-1))) {

                lstrcpy (szInputCode, szInputCodeOld);
                SetDlgItemText (hDlg,IDC_MODI_CODE, szInputCode);

                    for (i = 0; i < 1; i++){
                        MessageBeep (0XFFFFFFFF);
                    }

                }
                lstrcpy (szInputCodeOld, szInputCode);

            }
            break;


        case IDC_MODI_WORD:

            GetDlgItemText (hDlg, IDC_MODI_WORD, szInputWord, MAXINPUTWORD);

            if (SendDlgItemMessage (hDlg,IDC_MODI_WORD, EM_GETMODIFY, 0, 0)){
                int i, CaretPos;

                GetDlgItemText (hDlg, IDC_MODI_WORD, szInputWord, MAXINPUTWORD);
                if (((CaretPos = CheckKey (szInputWord)) != (-1))) {
                   lstrcpy (szInputWord, szInputWordOld);
                   SetDlgItemText (hDlg,IDC_MODI_WORD, szInputWord);
                   SendDlgItemMessage (hDlg,
                                       IDC_MODI_WORD, 
                                       EM_SETSEL, 
                                       CaretPos, 
                                       CaretPos);

                   for (i = 0; i < 1; i++){
                       MessageBeep (0xFFFFFFFF);
                   }

                }

                if (MBIndex.MBDesc[0].wNumRulers != 0){
    
                    TCHAR MBName[MAXSTRLEN];
                    TCHAR szAutoCode [MAXCODE + 1];                                       
    
                    HIMC           hIMC;
                    LPINPUTCONTEXT lpIMC;
                    LPPRIVCONTEXT  lpImcP;
    
                    hIMC = (HIMC)ImmGetContext(GetParent(GetParent(hDlg)));
                    if (!hIMC) {
                            return 0L;
                    }
                
                    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
                    if (!lpIMC) {          // Oh! Oh!
                        return (0L);
                    }

                    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);

                    if (!lpImcP) {          // Oh! Oh!
                       return (0L);
                    }
        
                   // auto coding
                   lstrcpy(MBName, sImeG.szIMESystemPath);
                   lstrcat((LPTSTR)MBName, TEXT("\\"));
                   lstrcat((LPTSTR)MBName, (LPCTSTR)lpImcP->MB_Name);

                   ConvCreateWord( lpIMC->hWnd, 
                                   (LPCTSTR)MBName,
                                   (LPTSTR)szInputWord, 
                                   (LPTSTR)szAutoCode);
    
                   ImmUnlockIMC(hIMC);
                   ImmUnlockIMCC(lpIMC->hPrivate);
                   ImmReleaseContext(GetParent(GetParent (hDlg)), hIMC);
    
                   SetDlgItemText (hDlg,IDC_MODI_CODE, szAutoCode);
                   SendDlgItemMessage (hDlg,IDC_MODI_CODE, EM_SETSEL, 0, -1);

                   lstrcpy (szInputCodeOld, szAutoCode);
                }
    
                lstrcpy (szInputWordOld, szInputWord);
             }

            break;

        case IDOK:
             {
            int            iIndexFind;
            TCHAR szFinalCode [MAXCODE + 1];
            TCHAR szFinalWord [MAXINPUTWORD + 1];

            GetDlgItemText (hDlg, IDC_MODI_WORD, szFinalWord, MAXINPUTWORD);
            GetDlgItemText (hDlg, IDC_MODI_CODE, szFinalCode, MAXCODE);

            CharLowerBuff (szFinalWord, lstrlen(szFinalWord));
            CharLowerBuff (szFinalCode, lstrlen(szFinalCode));

            if (lstrlen(szFinalWord) == 0){
                SetFocus (GetDlgItem (hDlg,IDC_MODI_WORD));    
                break;
            } else if (lstrlen(szFinalCode) == 0){
                SetFocus (GetDlgItem (hDlg,IDC_MODI_CODE));
                break;
            }
            if ((!lstrcmpi (szFinalCode, szModiCode)) && (!lstrcmpi (szFinalWord, szModiWord))){
                //hadn't modify
                hCrtDlg = NULL;
                EndDialog(hDlg, FALSE);
                break;
            }else {
                HIMC           hIMC;
                LPINPUTCONTEXT lpIMC;

                hIMC = (HIMC)ImmGetContext(GetParent(GetParent (hDlg)));
                if (!hIMC) {
                    return 0L;
                }

            
                lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
                if (!lpIMC) {          // Oh! Oh!
                   return (0L);
                }

                {
                   UINT i;
                   for(i=0;i<strlen((const char *)szFinalCode);i++){
                     if(!IsUsedCode(szFinalCode[i], NULL)){
                        InfoMessage(NULL, IDS_WARN_INVALIDCODE);
                        ImmUnlockIMC(hIMC);
                        ImmReleaseContext (GetParent(GetParent (hDlg)), hIMC);
                        return(0L);
                     }
                   }
                }
                                    
                iIndexFind = GetUDCIndex(lpIMC->hPrivate, szFinalCode, szFinalWord);
                if (iIndexFind == -1 || iIndexFind >= MAXNUMBER_EMB){
                  //hadn't found
                  DelItem (lpIMC->hPrivate, szModiCode, szModiWord);
                  AddZCItem(lpIMC->hPrivate, szFinalCode, szFinalWord);
                  lstrcpy (szModiWord, szFinalWord);
                  lstrcpy (szModiCode, szFinalCode);

                  ImmUnlockIMC(hIMC);
                  ImmReleaseContext (GetParent(GetParent (hDlg)), hIMC);

                  hCrtDlg = NULL;
                  EndDialog(hDlg, FALSE);
                  break;
                }else{
                  InfoMessage(NULL, IDS_WARN_DUPPRASE);
                  break;
                }
                ImmUnlockIMC(hIMC);
                ImmReleaseContext (GetParent(GetParent (hDlg)), hIMC);
                
            }

          }
          hCrtDlg = NULL;
          EndDialog(hDlg, FALSE);
          break;
        case IDCANCEL:
            hCrtDlg = NULL;
            EndDialog(hDlg, FALSE);
            break;
        default:
            return (FALSE);
            break;
        }
        return (TRUE);
    case WM_CLOSE:
        hChildDlg = NULL;
        EndDialog(hDlg, FALSE);
        return (TRUE);
    default:
        return (FALSE);
    }

    return (TRUE);

}
/*************************************************************************/
/* int DelItem (HIMCC, LPTSTR, LPTSTR)                                   */
/*************************************************************************/
int DelItem (HIMCC hPrivate, LPTSTR szCode, LPTSTR szWord)
{
    int iStringIndex;
    iStringIndex = GetUDCIndex(hPrivate, szCode, szWord);
    if (iStringIndex == -1 || iStringIndex >= MAXNUMBER_EMB){
    return -1;
    }else{
    DelSelCU (hPrivate, iStringIndex);
    }
    return iStringIndex;     
}
/*************************************************************************/
/* void BreakString (LPTSTR szList, LPTSTR szCode, LPTSTR szWord)           */
/*************************************************************************/
void BreakString (LPTSTR szList,
          LPTSTR szCode,
          LPTSTR szWord)
{
    
    int i = 0, j = 0;
    while (szList[i] != TEXT(' ')){
        szCode[j] = szList[i];
        i ++;
        j ++;
    }
    szCode[j] = TEXT('\0');
    lstrcpy(szWord, &szList[20]);   
}

/**********************************************************************/
/* ImeVerDlgProc()                                                    */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL FAR PASCAL ImeVerDlgProc(  // dialog procedure of configuration
    HWND  hDlg,
    UINT  uMessage,
    DWORD wParam,
    LONG  lParam)
{
    RECT rc;
    LONG DlgWidth, DlgHeight;
    RECT rcWorkArea;

    rcWorkArea = ImeMonitorWorkAreaFromWindow(hDlg);

    switch (uMessage) {
    case WM_INITDIALOG:
    hCrtDlg = hDlg;
    // reset position
    GetWindowRect(hDlg, &rc);
    DlgWidth =  rc.right - rc.left;
    DlgHeight =  rc.bottom - rc.top;
    
    SetWindowPos(hDlg, HWND_TOP,
        (int)(rcWorkArea.right - DlgWidth)/2,
        (int)(rcWorkArea.bottom - DlgHeight)/2,
        (int) 0, (int) 0, SWP_NOSIZE);

    return (TRUE);          // don't want to set focus to special control
    case WM_COMMAND:
    switch (wParam) {
    case IDOK:
        EndDialog(hDlg, FALSE);
        break;
    case IDCANCEL:
        EndDialog(hDlg, FALSE);
        break;
    default:
        return (FALSE);
        break;
    }
    return (TRUE);
    case WM_CLOSE:
        EndDialog(hDlg, FALSE);
        return FALSE;

    case WM_PAINT:
        {
            HDC     hDC;
            PAINTSTRUCT ps;
            RECT    rc;
            RECT    rcVerInfo, rcOrgAuthorName;
            HGDIOBJ hOldFont;
            LOGFONT lfFont;
            HFONT   hNewFont;

            hDC = BeginPaint(hDlg, &ps);

            GetClientRect(hDlg, &rc);
            DrawConvexRect(hDC,
            rc.left + 10,
            rc.top + 10,
            rc.right - 10 - 1,
            rc.bottom - 43 - 1);

            DrawConvexRectP(hDC,
            rc.left + 10,
            rc.top + 10,
            rc.right - 10,
            rc.bottom - 43);
            
            // draw ver info and org&auther name
            rcVerInfo.left = rc.left+10;
            rcVerInfo.right = rc.right;
            rcVerInfo.top = rc.top + 30;             
            rcVerInfo.bottom = rcVerInfo.top + 19;  

            rcOrgAuthorName.left = rc.left;
            rcOrgAuthorName.right = rc.right;
            //rcOrgAuthorName.top = rcVerInfo.bottom + 12;
            rcOrgAuthorName.top = rcVerInfo.bottom + 4;
            rcOrgAuthorName.bottom = rcOrgAuthorName.top + 19; 

            SetTextColor(hDC, RGB(0x00, 0x00, 0x00));
            SetBkColor(hDC, RGB(0xC0, 0xC0, 0xC0));
            // set font
            if (sImeG.fDiffSysCharSet) {
                LOGFONT lfFont;

                hOldFont = GetCurrentObject(hDC, OBJ_FONT);
                GetObject(hOldFont, sizeof(lfFont), &lfFont);
                lfFont.lfCharSet = NATIVE_CHARSET;
                                lstrcpy(lfFont.lfFaceName, TEXT("Simsun"));

                hNewFont = CreateFontIndirect(&lfFont);

                if ( hNewFont )
                    SelectObject(hDC, (HGDIOBJ)hNewFont);
            }

            DrawText(hDC, szVerInfo, lstrlen(szVerInfo),
                &rcVerInfo, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
            if (sImeG.fDiffSysCharSet){
                SelectObject(hDC, hOldFont);
                if ( hNewFont )
                    DeleteObject( (HGDIOBJ) hNewFont );
            }
            EndPaint(hDlg, &ps);
        }
        
        return (FALSE);
    default:
        return (FALSE);
    }

    return (TRUE);
}

/**********************************************************************/
/* InitImeCharac()                                                    */
/**********************************************************************/
void InitImeCharac(
    DWORD ObjImeIndex)
{
    HKEY  hKeyCurrVersion;
    DWORD retCode;
    DWORD retValue;
    HKEY  hKey;
#ifdef UNICODE
    TCHAR  ValueName[][9] = { 
        {0x8BCD, 0x8BED, 0x8054, 0x60F3, 0x0000},
        {0x8BCD, 0x8BED, 0x8F93, 0x5165, 0x0000},
        {0x9010, 0x6E10, 0x63D0, 0x793A, 0x0000},
        {0x5916, 0x7801, 0x63D0, 0x793A, 0x0000},
        {0x63D2, 0x7A7A, 0x683C, 0x0000},
        {0x5149, 0x6807, 0x8DDF, 0x968F, 0x0000},
#else
    TCHAR  ValueName[][9] = { TEXT(""),
                  TEXT(""),
                  TEXT(""),
                  TEXT(""),
                  TEXT(""),
                  TEXT(""),
#endif 
                    TEXT("<SPACE>"),
                  TEXT("<ENTER>"),
                  //CHP
                  TEXT("FC input"),
                  TEXT("FC aid")
        };
    DWORD dwcValueName = MAXSTRLEN;
    BYTE  bData[MAXSTRLEN];
    LONG  bcData = MAXSTRLEN;
    UINT i;

    retCode = OpenReg_PathSetup(&hKeyCurrVersion);

    if (retCode) {
        RegCreateKey(HKEY_CURRENT_USER, REGSTR_PATH_SETUP, &hKeyCurrVersion);
    }

    if ( hKeyCurrVersion )
        retCode = OpenReg_User (hKeyCurrVersion,
                      MBIndex.MBDesc[ObjImeIndex].szName,
                      &hKey);
    else
        return;
    
        
    if ( hKey == NULL )
    {
        RegCloseKey(hKeyCurrVersion);
        return;
    }

    //CHP
    for(i=0; i<10; i++) {
        bData[0] = 0;

        bcData = MAXSTRLEN;
        retValue = RegQueryValueEx (hKey, ValueName[i],
                        NULL,
                        NULL,               //&dwType,
                        bData,              //&bData,
                        &bcData);           //&bcData);
        switch (i)
        {
        case 0:
            MBIndex.IMEChara[ObjImeIndex].IC_LX = *((LPDWORD)bData);
            break;
        case 1:
            MBIndex.IMEChara[ObjImeIndex].IC_CZ = *((LPDWORD)bData);
            break;
        case 2:
            MBIndex.IMEChara[ObjImeIndex].IC_TS = *((LPDWORD)bData);
            break;
        case 3:
            MBIndex.IMEChara[ObjImeIndex].IC_CTC = *((LPDWORD)bData);
            break;
        case 4:
            MBIndex.IMEChara[ObjImeIndex].IC_INSSPC = *((LPDWORD)bData);
            break;
        case 5:
            MBIndex.IMEChara[ObjImeIndex].IC_Trace = *((LPDWORD)bData);
            break;
        case 6:
            MBIndex.IMEChara[ObjImeIndex].IC_Space = *((LPDWORD)bData);
            break;
        case 7:
            MBIndex.IMEChara[ObjImeIndex].IC_Enter = *((LPDWORD)bData);
            break;
        case 8:
            MBIndex.IMEChara[ObjImeIndex].IC_FCSR = *((LPDWORD)bData);
            break;
        case 9:
            MBIndex.IMEChara[ObjImeIndex].IC_FCTS = *((LPDWORD)bData);
            break;

        default:
            break;
        }
    }
#ifdef EUDC
    //just query the value, do not set any value here
    bcData = sizeof(TCHAR) * MAX_PATH;
    RegQueryValueEx (hKey, szRegEudcDictName,
             NULL,
             NULL,             //null-terminate string
             (unsigned char *)MBIndex.EUDCData.szEudcDictName,          //&bData,
             &bcData);           //&bcData);
    bcData = sizeof(TCHAR) * MAX_PATH;
    RegQueryValueEx (hKey, szRegEudcMapFileName,
             NULL,
             NULL,             //null-terminate string
             (unsigned char *)MBIndex.EUDCData.szEudcMapFileName,       //&bData,
             &bcData);           //&bcData);
#endif //EUDC

#ifdef CROSSREF        
    bcData = sizeof(HKL);         
    if(RegQueryValueEx (hKey, szRegRevKL,
             NULL,
             NULL,                                 //null-terminate string
             (LPBYTE)&MBIndex.hRevKL,              //&bData,
             &bcData) != ERROR_SUCCESS)
        MBIndex.hRevKL = NULL;

    bcData = sizeof(DWORD);
    if(RegQueryValueEx (hKey, szRegRevMaxKey,
             NULL,
             NULL,                                     //null-terminate string
             (LPBYTE)&MBIndex.nRevMaxKey,              //&bData,
             &bcData) != ERROR_SUCCESS)
        MBIndex.hRevKL = NULL;
#endif
        
    RegCloseKey(hKey);
    RegCloseKey(hKeyCurrVersion);

    return;
}

// Combine 's1' and 's2' and fill space chars in between, result str stored in 'dest'.
void MyStrFormat(LPTSTR dest, LPTSTR s1, LPTSTR s2)
{
    int i;
    int len = lstrlen(s1);
    lstrcpy(dest, s1);
    for (i = 0; i < STR_FORMAT_POS-len; i++)
        dest[len+i] = STR_FORMAT_CHAR;
    lstrcpy(&dest[STR_FORMAT_POS], s2);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\candui.c ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    CANDUI.c
    
++*/

#include <windows.h>
#include <immdev.h>
#include "imeattr.h"
#include "imedefs.h"
#include "imerc.h"
#if defined(UNIIME)
#include "uniime.h"
#endif

#if !defined(ROMANIME)
/**********************************************************************/
/* GetCandWnd                                                         */
/* Return Value :                                                     */
/*      window handle of candidatte                                   */
/**********************************************************************/
HWND PASCAL GetCandWnd(
    HWND hUIWnd)                // UI window
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;
    HWND     hCandWnd;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {          // can not darw candidate window
        return (HWND)NULL;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw candidate window
        return (HWND)NULL;
    }

    hCandWnd = lpUIPrivate->hCandWnd;

    GlobalUnlock(hUIPrivate);
    return (hCandWnd);
}

/**********************************************************************/
/* CalcCandPos                                                        */
/**********************************************************************/
BOOL PASCAL CalcCandPos(
#if defined (UNIIME)
    LPIMEL         lpImeL,
#endif
    LPINPUTCONTEXT lpIMC,
    LPPOINT        lpptWnd)         // the composition window position
{
    UINT  uEsc;
    POINT ptCurPos, ptNew;
    BOOL  fAdjust;
    RECT  rcWorkArea;

#if 1 // MultiMonitor support
    rcWorkArea = ImeMonitorWorkAreaFromPoint(*lpptWnd);
#else
    rcWorkArea = sImeG.rcWorkArea;
#endif

    uEsc = (UINT)((lpIMC->lfFont.A.lfEscapement + 450) / 900 % 4);

    ptCurPos = lpIMC->cfCompForm.ptCurrentPos;
    ClientToScreen(lpIMC->hWnd, &ptCurPos);
    fAdjust = FALSE;

    if (uEsc == 0) {
        ptNew.x = lpptWnd->x + lpImeL->xCompWi + UI_MARGIN * 2;
        if (ptNew.x + lpImeL->xCandWi > rcWorkArea.right) {
            // exceed screen width
            ptNew.x = lpptWnd->x - lpImeL->xCandWi - UI_MARGIN * 2;
        }

        if (lpptWnd->y >= ptCurPos.y) {
            ptNew.y = lpptWnd->y + lpImeL->cyCompBorder - lpImeL->cyCandBorder;

            if (ptNew.y + lpImeL->yCandHi > rcWorkArea.bottom) {
                // exceed screen high
                ptNew.y = rcWorkArea.bottom - lpImeL->yCandHi;
            }
        } else {
            ptNew.y = lpptWnd->y + lpImeL->yCompHi - lpImeL->yCandHi;

            if (ptNew.y < rcWorkArea.top) {
                ptNew.y = rcWorkArea.top;
            }
        }
    } else if (uEsc == 1) {
        if (lpptWnd->x >= ptCurPos.x) {
            ptNew.x = lpptWnd->x + lpImeL->cxCompBorder -
                lpImeL->cxCandBorder;

            if (ptNew.x + lpImeL->xCandWi > rcWorkArea.right) {
                // exceed screen width
                ptNew.x = rcWorkArea.right - lpImeL->xCandWi;
                fAdjust = TRUE;
            }
        } else {
            ptNew.x = lpptWnd->x + lpImeL->xCompWi - lpImeL->xCandWi;

            if (ptNew.x < rcWorkArea.left) {
                // exceed screen width
                ptNew.x = rcWorkArea.left;
                fAdjust = TRUE;
            }
        }

        ptNew.y = lpptWnd->y + lpImeL->yCompHi + UI_MARGIN * 2;
        if (ptNew.y + lpImeL->yCandHi > rcWorkArea.bottom) {
            // exceed screen high
            ptNew.y = lpptWnd->y - lpImeL->yCandHi - UI_MARGIN * 2;
        }
    } else if (uEsc == 2) {
        ptNew.x = lpptWnd->x - lpImeL->xCandWi - UI_MARGIN * 2;
        if (ptNew.x < 0) {
            ptNew.x = lpptWnd->x + lpImeL->xCompWi + UI_MARGIN * 2;
        }

        if (lpptWnd->y >= ptCurPos.y) {
            ptNew.y = lpptWnd->y + lpImeL->cyCompBorder - lpImeL->cyCandBorder;

            if (ptNew.y + lpImeL->yCandHi > rcWorkArea.bottom) {
                // exceed screen high
                ptNew.y = rcWorkArea.bottom - lpImeL->yCandHi;
            }
        } else {
            ptNew.y = lpptWnd->y + lpImeL->yCompHi - lpImeL->yCandHi;

            if (ptNew.y < rcWorkArea.top) {
                ptNew.y = rcWorkArea.top;
            }
        }
    } else {
        if (lpptWnd->x >= ptCurPos.x) {
            ptNew.x = lpptWnd->x + lpImeL->cxCompBorder -
                lpImeL->cxCandBorder;

            if (ptNew.x + lpImeL->xCandWi > rcWorkArea.right) {
                // exceed screen width
                ptNew.x = rcWorkArea.right - lpImeL->xCandWi;
                fAdjust = TRUE;
            }
        } else {
            ptNew.x = lpptWnd->x + lpImeL->xCompWi - lpImeL->xCandWi;

            if (ptNew.x < rcWorkArea.left) {
                // exceed screen width
                ptNew.x = rcWorkArea.left;
                fAdjust = TRUE;
            }
        }

        ptNew.y = lpptWnd->y + lpImeL->yCompHi + UI_MARGIN * 2;
        if (ptNew.y + lpImeL->yCandHi > rcWorkArea.bottom) {
            // exceed screen high
            ptNew.y = lpptWnd->y - lpImeL->yCandHi - UI_MARGIN * 2;
        }
    }

    *lpptWnd = ptNew;

    return (fAdjust);
}

/**********************************************************************/
/* AdjustCandBoundry                                                  */
/**********************************************************************/
void PASCAL AdjustCandBoundry(
#if defined (UNIIME)
    LPIMEL  lpImeL,
#endif
    LPPOINT lpptCandWnd)            // the position
{
    RECT rcWorkArea;

#if 1 // MultiMonitor support
    {
        RECT rcCandWnd;

        *(LPPOINT)&rcCandWnd = *(LPPOINT)lpptCandWnd;

        rcCandWnd.right = rcCandWnd.left + lpImeL->xCandWi;
        rcCandWnd.bottom = rcCandWnd.top + lpImeL->yCandHi;

        rcWorkArea = ImeMonitorWorkAreaFromRect(&rcCandWnd);
    }
#else
    rcWorkArea = sImeG.rcWorkArea;
#endif

    if (lpptCandWnd->x < rcWorkArea.left) {
        lpptCandWnd->x = rcWorkArea.left;
    } else if (lpptCandWnd->x + lpImeL->xCandWi > rcWorkArea.right) {
        lpptCandWnd->x = rcWorkArea.right - lpImeL->xCandWi;
    } else {
    }

    if (lpptCandWnd->y < rcWorkArea.top) {
        lpptCandWnd->y = rcWorkArea.top;
    } else if (lpptCandWnd->y + lpImeL->yCandHi > rcWorkArea.bottom) {
        lpptCandWnd->y = rcWorkArea.bottom - lpImeL->yCandHi;
    } else {
    }

    return;
}

/**********************************************************************/
/* FitInCandLazyOperation()                                           */
/* Return Value :                                                     */
/*      TRUE or FALSE                                                 */
/**********************************************************************/
BOOL PASCAL FitInCandLazyOperation(     // fit in lazy operation or not
#if defined(UNIIME)
    LPIMEL  lpImeL,
#endif
    LPPOINT lpptOrg,
    LPPOINT lpptNearCaret,              // the suggested near caret position
    LPRECT  lprcInputRect,
    UINT    uEsc)
{
    POINT ptDelta, ptTol;
    RECT  rcUIRect, rcInterRect;

    ptDelta.x = lpptOrg->x - lpptNearCaret->x;

    ptDelta.x = (ptDelta.x >= 0) ? ptDelta.x : -ptDelta.x;

    ptTol.x = sImeG.iParaTol * ncUIEsc[uEsc].iParaFacX +
        sImeG.iPerpTol * ncUIEsc[uEsc].iPerpFacX;

    ptTol.x = (ptTol.x >= 0) ? ptTol.x : -ptTol.x;

    if (ptDelta.x > ptTol.x) {
        return (FALSE);
    }

    ptDelta.y = lpptOrg->y - lpptNearCaret->y;

    ptDelta.y = (ptDelta.y >= 0) ? ptDelta.y : -ptDelta.y;

    ptTol.y = sImeG.iParaTol * ncUIEsc[uEsc].iParaFacY +
        sImeG.iPerpTol * ncUIEsc[uEsc].iPerpFacY;

    ptTol.y = (ptTol.y >= 0) ? ptTol.y : -ptTol.y;

    if (ptDelta.y > ptTol.y) {
        return (FALSE);
    }

    // build up the UI rectangle (candidate window)
    rcUIRect.left = lpptOrg->x;
    rcUIRect.top = lpptOrg->y;
    rcUIRect.right = rcUIRect.left + lpImeL->xCandWi;
    rcUIRect.bottom = rcUIRect.top + lpImeL->yCandHi;

    if (IntersectRect(&rcInterRect, &rcUIRect, lprcInputRect)) {
        return (FALSE);
    }

    return (TRUE);
}

/**********************************************************************/
/* AdjustCandRectBoundry                                              */
/**********************************************************************/
void PASCAL AdjustCandRectBoundry(
#if defined (UNIIME)
    LPIMEL         lpImeL,
#endif
    LPINPUTCONTEXT lpIMC,
    LPPOINT        lpptOrg,                 // original candidate position
    LPPOINT        lpptCaret)               // the caret position
{
    RECT  rcExclude, rcUIRect, rcInterSect;
    UINT  uEsc, uRot;
    POINT ptCaret, ptOldNearCaret, ptFont;

    // be a normal rectangle, not a negative rectangle
    if (lpIMC->cfCandForm[0].rcArea.left > lpIMC->cfCandForm[0].rcArea.right) {
        LONG tmp;

        tmp = lpIMC->cfCandForm[0].rcArea.left;
        lpIMC->cfCandForm[0].rcArea.left = lpIMC->cfCandForm[0].rcArea.right;
        lpIMC->cfCandForm[0].rcArea.right = tmp;
    }

    if (lpIMC->cfCandForm[0].rcArea.top > lpIMC->cfCandForm[0].rcArea.bottom) {
        LONG tmp;

        tmp = lpIMC->cfCandForm[0].rcArea.top;
        lpIMC->cfCandForm[0].rcArea.top = lpIMC->cfCandForm[0].rcArea.bottom;
        lpIMC->cfCandForm[0].rcArea.bottom = tmp;
    }

    // translate from client coordinate to screen coordinate
    rcExclude = lpIMC->cfCandForm[0].rcArea;

    rcExclude.left += lpptCaret->x - lpIMC->cfCandForm[0].ptCurrentPos.x;
    rcExclude.right += lpptCaret->x - lpIMC->cfCandForm[0].ptCurrentPos.x;

    rcExclude.top += lpptCaret->y - lpIMC->cfCandForm[0].ptCurrentPos.y;
    rcExclude.bottom += lpptCaret->y - lpIMC->cfCandForm[0].ptCurrentPos.y;

    uEsc = (UINT)((lpIMC->lfFont.A.lfEscapement + 450) / 900 % 4);
    uRot = (UINT)((lpIMC->lfFont.A.lfOrientation + 450) / 900 % 4);

    if (uEsc == 0) {
        ptCaret.x = lpptCaret->x;
        ptCaret.y = rcExclude.top;
    } else if (uEsc == 1) {
        ptCaret.x = rcExclude.left;
        ptCaret.y = lpptCaret->y;
    } else if (uEsc == 2) {
        ptCaret.x = lpptCaret->x;
        ptCaret.y = rcExclude.bottom;
    } else {
        ptCaret.x = rcExclude.right;
        ptCaret.y = lpptCaret->y;
    }

    ptFont.x = rcExclude.right - rcExclude.left;
    ptFont.y = rcExclude.bottom - rcExclude.top;

    // the first try
    GetNearCaretPosition(
#if defined(UNIIME)
        lpImeL,
#endif
        &ptFont, uEsc, uRot, &ptCaret, &ptOldNearCaret,
        NEAR_CARET_FIRST_TIME|NEAR_CARET_CANDIDATE);

    AdjustCandBoundry(
#if defined(UNIIME)
        lpImeL,
#endif
        &ptOldNearCaret);

    *(LPPOINT)&rcUIRect = ptOldNearCaret;
    rcUIRect.right = rcUIRect.left + lpImeL->xCandWi;
    rcUIRect.bottom = rcUIRect.top + lpImeL->yCandHi;

    if (IntersectRect(&rcInterSect, &rcExclude, &rcUIRect)) {
    } else if (FitInCandLazyOperation(
#if defined(UNIIME)
        lpImeL,
#endif
        lpptOrg, (LPPOINT)&rcUIRect, &rcExclude, uEsc)) {

        *lpptCaret = *lpptOrg;
        return;
    } else {
        *lpptCaret = *(LPPOINT)&rcUIRect;
        return;
    }

    // the second try
    GetNearCaretPosition(
#if defined(UNIIME)
        lpImeL,
#endif
        &ptFont, uEsc, uRot, &ptCaret, (LPPOINT)&rcUIRect,
        NEAR_CARET_CANDIDATE);

    AdjustCandBoundry(
#if defined(UNIIME)
        lpImeL,
#endif
        (LPPOINT)&rcUIRect);

    rcUIRect.right = rcUIRect.left + lpImeL->xCandWi;
    rcUIRect.bottom = rcUIRect.top + lpImeL->yCandHi;

    if (IntersectRect(&rcInterSect, &rcExclude, &rcUIRect)) {
    } else if (FitInCandLazyOperation(
#if defined(UNIIME)
        lpImeL,
#endif
        lpptOrg, (LPPOINT)&rcUIRect, &rcExclude, uEsc)) {

        *lpptCaret = *lpptOrg;
        return;
    } else {
        *lpptCaret = *(LPPOINT)&rcUIRect;
        return;
    }

    // unhappy ending! :-(
    *lpptCaret = ptOldNearCaret;

    return;
}

/**********************************************************************/
/* SetCandPosition()                                                  */
/**********************************************************************/
LRESULT PASCAL SetCandPosition(
#if defined(UNIIME)
    LPIMEL lpImeL,
#endif
    HWND   hCandWnd)
{
    HWND           hUIWnd;
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    POINT          ptWnd;

    hUIWnd = GetWindow(hCandWnd, GW_OWNER);

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return (1L);
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return (1L);
    }

    ptWnd = lpIMC->cfCandForm[0].ptCurrentPos;

    ClientToScreen((HWND)lpIMC->hWnd, &ptWnd);

    if (lpIMC->cfCandForm[0].dwStyle & CFS_FORCE_POSITION) {
    } else if (lpIMC->cfCandForm[0].dwStyle == CFS_EXCLUDE) {
        RECT rcCand;

        GetWindowRect(hCandWnd, &rcCand);

        AdjustCandRectBoundry(
#if defined(UNIIME)
            lpImeL,
#endif
            lpIMC, (LPPOINT)&rcCand, &ptWnd);

        if (ptWnd.x != rcCand.left) {
        } else if (ptWnd.y != rcCand.right) {
        } else {
            goto SetCandPosUnlockIMC;
        }
    } else if (lpIMC->cfCandForm[0].dwStyle == CFS_CANDIDATEPOS) {
        HWND hCompWnd;

        AdjustCandBoundry(
#if defined(UNIIME)
            lpImeL,
#endif
            &ptWnd);

        if (lpIMC->cfCandForm[0].dwIndex == 0) {
        } else if (!(hCompWnd = GetCompWnd(hUIWnd))) {
        } else {
            RECT rcComp, rcCand, rcInterSect;

            GetWindowRect(hCompWnd, &rcComp);

            *(LPPOINT)&rcCand = ptWnd;
            rcCand.right = rcCand.left + lpImeL->xCandWi;
            rcCand.bottom = rcCand.top + lpImeL->yCandHi;

            if (IntersectRect(&rcInterSect, &rcComp, &rcCand)) {
                ptWnd = *(LPPOINT)&rcComp;

                CalcCandPos(
#if defined(UNIIME)
                    lpImeL,
#endif
                    lpIMC, &ptWnd);
            }
        }
    } else if (lpIMC->cfCandForm[0].dwStyle == CFS_DEFAULT) {
        HWND hCompWnd;
        BOOL fUseCompWndPos;

        hCompWnd = GetCompWnd(hUIWnd);

        if (!hCompWnd) {
            fUseCompWndPos = FALSE;
        } else if (IsWindowVisible(hCompWnd)) {
            fUseCompWndPos = TRUE;
        } else {
            fUseCompWndPos = FALSE;
        }

        if (fUseCompWndPos) {
            ptWnd.x = 0;
            ptWnd.y = 0;

            ClientToScreen(hCompWnd, &ptWnd);

            ptWnd.x -= lpImeL->cxCompBorder;
            ptWnd.y -= lpImeL->cyCompBorder;
        } else {
            POINT ptNew;

            ptWnd = lpIMC->cfCompForm.ptCurrentPos;

            ClientToScreen((HWND)lpIMC->hWnd, &ptWnd);

            ptWnd.x -= lpImeL->cxCompBorder;
            ptWnd.y -= lpImeL->cyCompBorder;
            ptNew = ptWnd;

            // try to simulate the position of composition window
            AdjustCompPosition(
#if defined(UNIIME)
                lpImeL,
#endif
                lpIMC, &ptWnd, &ptNew);
        }

        CalcCandPos(
#if defined(UNIIME)
            lpImeL,
#endif
            lpIMC, &ptWnd);
    } else {
    }

    SetWindowPos(hCandWnd, NULL, ptWnd.x, ptWnd.y,
        0, 0, SWP_NOACTIVATE|SWP_NOSIZE|SWP_NOZORDER);

SetCandPosUnlockIMC:
    ImmUnlockIMC(hIMC);

    return (0L);
}

/**********************************************************************/
/* ShowCand()                                                         */
/**********************************************************************/
void PASCAL ShowCand(           // Show the candidate window
#if defined(UNIIME)
    LPIMEL lpImeL,
#endif
    HWND    hUIWnd,
    int     nShowCandCmd)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {          // can not darw candidate window
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw candidate window
        return;
    }

    if (lpUIPrivate->nShowCandCmd == nShowCandCmd) {
        goto SwCandNoChange;
    }

    if (nShowCandCmd == SW_HIDE) {
        lpUIPrivate->fdwSetContext &= ~(ISC_HIDE_CAND_WINDOW);
    }

    if (!lpUIPrivate->hCandWnd) {
        // not in show candidate window mode
    } else if (lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI) {
        int nCurrShowState;

        lpUIPrivate->nShowCandCmd = nShowCandCmd;

        nCurrShowState = lpUIPrivate->nShowStatusCmd;
        nCurrShowState |= lpUIPrivate->nShowCompCmd;

        if (nCurrShowState == SW_HIDE) {
            // if other two are hide, the current show state is determined
            // by this candidate section
            ShowWindow(lpUIPrivate->hCandWnd, nShowCandCmd);
        } else {
            RedrawWindow(lpUIPrivate->hCandWnd, NULL, NULL,
                RDW_INVALIDATE|RDW_ERASE);
        }
    } else {
        ShowWindow(lpUIPrivate->hCandWnd, nShowCandCmd);
        lpUIPrivate->nShowCandCmd = nShowCandCmd;
    }

SwCandNoChange:
    GlobalUnlock(hUIPrivate);
    return;
}

/**********************************************************************/
/* CandPageSizeDown                                                   */
/**********************************************************************/
void PASCAL CandPageSizeDown(
    LPINPUTCONTEXT lpIMC)
{
    DWORD           dwSize;
    LPCANDIDATEINFO lpCandInfo;
    LPCANDIDATELIST lpCandList;
    DWORD           dwStart, dwEnd;
    int             nChars, iLen;

    if (!lpIMC) {
        return;
    }

    if (!lpIMC->hCandInfo) {
        return;
    }

    lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo);
    if (!lpCandInfo) {
        return;
    }

    lpCandList = (LPCANDIDATELIST)((LPBYTE)lpCandInfo +
        lpCandInfo->dwOffset[0]);

    dwStart = lpCandList->dwPageStart;

    dwEnd = dwStart + CANDPERPAGE;

    if (dwEnd > lpCandList->dwCount) {
        dwEnd = lpCandList->dwCount;
    }

    dwSize = 0;

    for (nChars = 0; dwStart < dwEnd; dwStart++, dwSize++) {
        LPTSTR lpStr;
#ifdef UNICODE
        LPTSTR lpTmpStr;
#endif

        // for displaying digit
        nChars++;

        lpStr = (LPTSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[dwStart]);

#ifdef UNICODE
        iLen = 0;

        for (lpTmpStr = lpStr; *lpTmpStr; lpTmpStr++) {
            if (*lpTmpStr < 0x200) {
                iLen += 1;
            } else {
                iLen += 2;
            }
        }
#else
        iLen = lstrlen(lpStr);
#endif

#if defined(WINAR30)
        if (!iLen) {
            iLen = sizeof(WCHAR)/sizeof(TCHAR);
        }
#endif

        // buffer is not enough
        if ((CANDPERPAGE * 3 - nChars) < iLen) {
            if (!dwSize) {
                dwSize = 1;
            }

            break;
        }

        nChars += iLen;
    }

    if (!dwSize) {
        dwSize = CANDPERPAGE;
    }

    lpCandList->dwPageSize = dwSize;

    ImmUnlockIMCC(lpIMC->hCandInfo);

    return;
}

/**********************************************************************/
/* OpenCand                                                           */
/**********************************************************************/
void PASCAL OpenCand(
#if defined(UNIIME)
    LPINSTDATAL lpInstL,
    LPIMEL      lpImeL,
#endif
    HWND        hUIWnd)
{
    HGLOBAL        hUIPrivate;
    LPUIPRIV       lpUIPrivate;
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    LPPRIVCONTEXT  lpImcP;
    DWORD          fdwImeMsg;
    POINT          ptWnd;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {          // can not darw candidate window
        return;
    }

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw candidate window
        return;
    }

    lpUIPrivate->fdwSetContext |= ISC_SHOWUICANDIDATEWINDOW;

    // in the timing of the transition, we will wait
    if (lpUIPrivate->fdwSetContext & ISC_OFF_CARET_UI) {
        if (!(lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI)) {
            PostMessage(hUIWnd, WM_USER_UICHANGE, 0, 0);
            goto OpenCandUnlockUIPriv;
        }
    } else {
        if (lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI) {
            PostMessage(hUIWnd, WM_USER_UICHANGE, 0, 0);
            goto OpenCandUnlockUIPriv;
        }
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        goto OpenCandUnlockUIPriv;
    }

    fdwImeMsg = 0;

    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);

    if (lpImcP) {
        fdwImeMsg = lpImcP->fdwImeMsg;
        ImmUnlockIMCC(lpIMC->hPrivate);
    }

    if (!(fdwImeMsg & MSG_ALREADY_OPEN)) {
        // Sometime the application call ImmNotifyIME to cancel the
        // composition before it process IMN_OPENCANDIDATE.
        // We should avoid to process this kind of IMN_OPENCANDIDATE.
        goto OpenCandUnlockIMC;
    }

    if (lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI) {
        if (lpUIPrivate->hCandWnd) {
        } else if (lpUIPrivate->hStatusWnd) {
            lpUIPrivate->hCandWnd = lpUIPrivate->hStatusWnd;
            lpUIPrivate->nShowCandCmd = lpUIPrivate->nShowStatusCmd;
        } else if (lpUIPrivate->hCompWnd) {
            lpUIPrivate->hCandWnd = lpUIPrivate->hCompWnd;
            lpUIPrivate->nShowCandCmd = lpUIPrivate->nShowCompCmd;
        } else {
        }

        CandPageSizeDown(lpIMC);

        ptWnd = lpIMC->ptStatusWndPos;
    } else if (lpIMC->cfCandForm[0].dwIndex == 0) {
        ptWnd = lpIMC->cfCandForm[0].ptCurrentPos;

        ClientToScreen(lpIMC->hWnd, &ptWnd);

        if (lpIMC->cfCandForm[0].dwStyle & CFS_FORCE_POSITION) {
        } else if (lpIMC->cfCandForm[0].dwStyle == CFS_EXCLUDE) {
            RECT rcCand;

            if (lpUIPrivate->hCandWnd) {
                GetWindowRect(lpUIPrivate->hCandWnd, &rcCand);
            } else {
                *(LPPOINT)&rcCand = ptWnd;
            }

            AdjustCandRectBoundry(
#if defined(UNIIME)
                lpImeL,
#endif
                lpIMC, (LPPOINT)&rcCand, &ptWnd);
        } else if (lpIMC->cfCandForm[0].dwStyle == CFS_CANDIDATEPOS) {
            AdjustCandBoundry(
#if defined(UNIIME)
                lpImeL,
#endif
                &ptWnd);
        } else {
            goto OpenCandDefault;
        }
    } else {
OpenCandDefault:
        if (lpUIPrivate->nShowCompCmd != SW_HIDE) {
            ptWnd.x = ptWnd.y = 0;
            ClientToScreen(lpUIPrivate->hCompWnd, &ptWnd);

            ptWnd.x -= lpImeL->cxCompBorder;
            ptWnd.y -= lpImeL->cyCompBorder;
        } else {
            POINT ptNew;

            ptWnd = lpIMC->cfCompForm.ptCurrentPos;
            ClientToScreen(lpIMC->hWnd, &ptWnd);

            ptWnd.x -= lpImeL->cxCompBorder;
            ptWnd.y -= lpImeL->cyCompBorder;
            ptNew = ptWnd;

            // try to simulate the position of composition window
            AdjustCompPosition(
#if defined(UNIIME)
                lpImeL,
#endif
                lpIMC, &ptWnd, &ptNew);
        }

        CalcCandPos(
#if defined(UNIIME)
            lpImeL,
#endif
            lpIMC, &ptWnd);

        lpIMC->cfCandForm[0].dwStyle = CFS_CANDIDATEPOS;
        lpIMC->cfCandForm[0].ptCurrentPos = ptWnd;
        ScreenToClient(lpIMC->hWnd, &lpIMC->cfCandForm[0].ptCurrentPos);
    }

    if (lpUIPrivate->hCandWnd) {
        if (lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI) {
            RECT rcRect;

            rcRect = lpImeL->rcCandText;
            // off by 1
            rcRect.right += 1;
            rcRect.bottom += 1;

            InvalidateRect(lpUIPrivate->hCandWnd, &rcRect, FALSE);

            rcRect = lpImeL->rcCandPrompt;
            // off by 1
            rcRect.right += 1;
            rcRect.bottom += 1;

            InvalidateRect(lpUIPrivate->hCandWnd, &rcRect, TRUE);

            rcRect = lpImeL->rcCandPageText;
            // off by 1
            rcRect.right += 1;
            rcRect.bottom += 1;

            InvalidateRect(lpUIPrivate->hCandWnd, &rcRect, TRUE);
        } else {
            SetWindowPos(lpUIPrivate->hCandWnd, NULL,
                ptWnd.x, ptWnd.y,
                0, 0, SWP_NOACTIVATE|SWP_NOSIZE|SWP_NOZORDER);
        }
    } else {
        if (lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI) {
            lpUIPrivate->hCandWnd = CreateWindowEx(
                WS_EX_WINDOWEDGE|WS_EX_DLGMODALFRAME,
                lpImeL->szOffCaretClassName, NULL,
                WS_POPUP|WS_DISABLED,
                ptWnd.x, ptWnd.y,
                lpImeL->xCandWi, lpImeL->yCandHi,
                hUIWnd, (HMENU)NULL, lpInstL->hInst, NULL);


            if (lpUIPrivate->hSoftKbdWnd) {
                // insert soft keyboard in front of other UI
                SetWindowPos(lpUIPrivate->hCandWnd,
                    lpUIPrivate->hSoftKbdWnd,
                    0, 0, 0, 0,
                    SWP_NOACTIVATE|SWP_NOMOVE|SWP_NOSIZE);
            }
        } else {
            lpUIPrivate->hCandWnd = CreateWindowEx(0,
//              WS_EX_WINDOWEDGE|WS_EX_DLGMODALFRAME,
                lpImeL->szCandClassName, NULL,
                WS_POPUP|WS_DISABLED|WS_BORDER,
                ptWnd.x, ptWnd.y,
                lpImeL->xCandWi, lpImeL->yCandHi,
                hUIWnd, (HMENU)NULL, lpInstL->hInst, NULL);
        }

        SetWindowLong(lpUIPrivate->hCandWnd, UI_MOVE_OFFSET,
            WINDOW_NOT_DRAG);
        SetWindowLong(lpUIPrivate->hCandWnd, UI_MOVE_XY, 0L);
    }

    ShowCand(
#if defined(UNIIME)
        lpImeL,
#endif
        hUIWnd, SW_SHOWNOACTIVATE);

OpenCandUnlockIMC:
    ImmUnlockIMC(hIMC);

OpenCandUnlockUIPriv:
    GlobalUnlock(hUIPrivate);
    return;
}

/**********************************************************************/
/* CloseCand                                                          */
/**********************************************************************/
void PASCAL CloseCand(
#if defined(UNIIME)
    LPIMEL lpImeL,
#endif
    HWND   hUIWnd)
{
    ShowCand(
#if defined(UNIIME)
        lpImeL,
#endif
        hUIWnd, SW_HIDE);

    return;
}

/**********************************************************************/
/* CandPageSizeUp                                                     */
/**********************************************************************/
void PASCAL CandPageSizeUp(
    HIMC           hIMC,
    LPINPUTCONTEXT lpIMC,
    DWORD          dwPrevPageStart)
{
    DWORD           dwSize;
    LPCANDIDATEINFO lpCandInfo;
    LPCANDIDATELIST lpCandList;
    int             iStart, iEnd;
    int             nChars, iLen;

    if (!lpIMC) {
        return;
    }

    if (!lpIMC->hCandInfo) {
        return;
    }

    lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo);
    if (!lpCandInfo) {
        return;
    }

    lpCandList = (LPCANDIDATELIST)((LPBYTE)lpCandInfo +
        lpCandInfo->dwOffset[0]);

    if (dwPrevPageStart) {
        iStart = dwPrevPageStart - 1;
    } else {
        goto CandPageSizeUpUnlockCandInfo;
    }

    if (iStart > (CANDPERPAGE - 1)) {
        iEnd = iStart - (CANDPERPAGE - 1);
    } else {
        iEnd = 0;
    }

    dwSize = 0;

    for (nChars = 0; iStart >= iEnd; iStart--, dwSize++) {
        LPTSTR lpStr;
#ifdef UNICODE
        LPTSTR lpTmpStr;
#endif

        // for displaying digit
        nChars++;

        lpStr = (LPTSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[iStart]);

#ifdef UNICODE
        iLen = 0;

        for (lpTmpStr = lpStr; *lpTmpStr; lpTmpStr++) {
            if (*lpTmpStr < 0x200) {
                iLen += 1;
            } else {
                iLen += 2;
            }
        }
#else
        iLen = lstrlen(lpStr);
#endif

#if defined(WINAR30)
        if (!iLen) {
            iLen = sizeof(WCHAR);
        }
#endif

        // buffer is not enough
        if ((CANDPERPAGE * 3 - nChars) < iLen) {
            if (!dwSize) {
                dwSize = 1;
            }

            break;
        }

        nChars += iLen;
    }

    if (!dwSize) {
        dwSize = CANDPERPAGE;
    }

    lpCandList->dwPageStart = lpCandList->dwSelection =
        dwPrevPageStart - dwSize;

    lpCandList->dwPageSize = dwSize;

CandPageSizeUpUnlockCandInfo:
    ImmUnlockIMCC(lpIMC->hCandInfo);

    return;
}

/**********************************************************************/
/* CandPageSize                                                       */
/**********************************************************************/
void PASCAL CandPageSize(
    HWND hUIWnd,
    BOOL fForward)
{
    HGLOBAL        hUIPrivate;
    LPUIPRIV       lpUIPrivate;
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    LPPRIVCONTEXT  lpImcP;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {          // can not darw candidate window
        return;
    }

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw candidate window
        return;
    }

    if (!(lpUIPrivate->fdwSetContext & ISC_SHOWUICANDIDATEWINDOW)) {
        goto CandPageDownUnlockUIPriv;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        goto CandPageDownUnlockUIPriv;
    }

    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    if (!lpImcP) {
        goto CandPageDownUnlockIMC;
    }

    if (fForward) {
        CandPageSizeDown(lpIMC);
    } else {
        CandPageSizeUp(hIMC, lpIMC, lpImcP->dwPrevPageStart);
    }

    ImmUnlockIMCC(lpIMC->hPrivate);

CandPageDownUnlockIMC:
    ImmUnlockIMC(hIMC);

CandPageDownUnlockUIPriv:
    GlobalUnlock(hUIPrivate);

    return;
}

/**********************************************************************/
/* DestroyCandWindow                                                  */
/**********************************************************************/
void PASCAL DestroyCandWindow(
    HWND hCandWnd)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    if (GetWindowLong(hCandWnd, UI_MOVE_OFFSET) != WINDOW_NOT_DRAG) {
        // undo the drag border
        DrawDragBorder(hCandWnd,
            GetWindowLong(hCandWnd, UI_MOVE_XY),
            GetWindowLong(hCandWnd, UI_MOVE_OFFSET));
    }

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(GetWindow(hCandWnd, GW_OWNER),
        IMMGWLP_PRIVATE);
    if (!hUIPrivate) {          // can not darw candidate window
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw candidate window
        return;
    }

    lpUIPrivate->nShowCandCmd = SW_HIDE;

    lpUIPrivate->hCandWnd = (HWND)NULL;

    GlobalUnlock(hUIPrivate);
    return;
}

/**********************************************************************/
/* MouseSelectCandStr()                                               */
/**********************************************************************/
void PASCAL MouseSelectCandStr(
#if defined(UNIIME)
    LPINSTDATAL lpInstL,
    LPIMEL      lpImeL,
#endif
    HWND    hCandWnd,
    LPPOINT lpCursor)
{
    HIMC            hIMC;
    LPINPUTCONTEXT  lpIMC;
    LPCANDIDATEINFO lpCandInfo;
    LPCANDIDATELIST lpCandList;
    DWORD           dwValue;

    hIMC = (HIMC)GetWindowLongPtr(GetWindow(hCandWnd, GW_OWNER), IMMGWLP_IMC);
    if (!hIMC) {
        return;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return;
    }

    if (!lpIMC->hCandInfo) {
        ImmUnlockIMC(hIMC);
        return;
    }

    lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo);
    if (!lpCandInfo) {
        ImmUnlockIMC(hIMC);
        return;
    }

    dwValue = (lpCursor->y - lpImeL->rcCandText.top) / sImeG.yChiCharHi;

    lpCandList = (LPCANDIDATELIST)((LPBYTE)lpCandInfo +
        lpCandInfo->dwOffset[0]);

    dwValue = dwValue + lpCandList->dwPageStart;

    if (dwValue >= lpCandList->dwCount) {
        // invalid choice
        MessageBeep((UINT)-1);
    } else {
#if defined(UNIIME)
        UniNotifyIME(lpInstL, lpImeL, hIMC, NI_SELECTCANDIDATESTR,
            0, dwValue);
#else
        NotifyIME(hIMC, NI_SELECTCANDIDATESTR, 0, dwValue);
#endif
    }

    ImmUnlockIMCC(lpIMC->hCandInfo);

    ImmUnlockIMC(hIMC);

    return;
}

/**********************************************************************/
/* CandSetCursor()                                                    */
/**********************************************************************/
void PASCAL CandSetCursor(
#if defined(UNIIME)
    LPINSTDATAL lpInstL,
    LPIMEL      lpImeL,
#endif
    HWND        hCandWnd,
    LPARAM      lParam)
{
    POINT ptCursor, ptSavCursor;
    RECT  rcWnd;

    if (GetWindowLong(hCandWnd, UI_MOVE_OFFSET) !=
        WINDOW_NOT_DRAG) {
        SetCursor(LoadCursor(NULL, IDC_SIZEALL));
        return;
    }

    GetCursorPos(&ptCursor);
    ptSavCursor = ptCursor;

    ScreenToClient(hCandWnd, &ptCursor);

    if (PtInRect(&lpImeL->rcCandText, ptCursor)) {
        SetCursor(LoadCursor(hInst, MAKEINTRESOURCE(IDCR_HAND_CURSOR)));

        if (HIWORD(lParam) == WM_LBUTTONDOWN) {
            MouseSelectCandStr(
#if defined(UNIIME)
                lpInstL, lpImeL,
#endif
                hCandWnd, &ptCursor);
        }
        return;
    } else if (PtInRect(&lpImeL->rcCandPageUp, ptCursor)) {
        if (HIWORD(lParam) != WM_LBUTTONDOWN) {
            SetCursor(LoadCursor(hInst, MAKEINTRESOURCE(IDCR_HAND_CURSOR)));
            return;
        }

        if (MouseSelectCandPage(
#if defined(UNIIME)
            lpImeL,
#endif
            hCandWnd, CHOOSE_PREVPAGE)) {
            return;
        }

        SetCursor(LoadCursor(NULL, IDC_SIZEALL));
    } else if (PtInRect(&lpImeL->rcCandPageDn, ptCursor)) {
        if (HIWORD(lParam) != WM_LBUTTONDOWN) {
            SetCursor(LoadCursor(hInst, MAKEINTRESOURCE(IDCR_HAND_CURSOR)));
            return;
        }

        if (MouseSelectCandPage(
#if defined(UNIIME)
            lpImeL,
#endif
            hCandWnd, CHOOSE_NEXTPAGE)) {
            return;
        }

        SetCursor(LoadCursor(NULL, IDC_SIZEALL));
    } else {
        SetCursor(LoadCursor(NULL, IDC_SIZEALL));

        if (HIWORD(lParam) == WM_LBUTTONDOWN) {
            // start drag
            SystemParametersInfo(SPI_GETWORKAREA, 0, &sImeG.rcWorkArea, 0);
        } else {
            return;
        }
    }

    SetCapture(hCandWnd);
    SetWindowLong(hCandWnd, UI_MOVE_XY,
        MAKELONG(ptSavCursor.x, ptSavCursor.y));
    GetWindowRect(hCandWnd, &rcWnd);
    SetWindowLong(hCandWnd, UI_MOVE_OFFSET,
        MAKELONG(ptSavCursor.x - rcWnd.left, ptSavCursor.y - rcWnd.top));

    DrawDragBorder(hCandWnd, MAKELONG(ptSavCursor.x, ptSavCursor.y),
        GetWindowLong(hCandWnd, UI_MOVE_OFFSET));

    return;
}

/**********************************************************************/
/* CandButtonUp()                                                     */
/**********************************************************************/
BOOL PASCAL CandButtonUp(
#if defined(UNIIME)
    LPIMEL lpImeL,
#endif
    HWND   hCandWnd)
{
    LONG           lTmpCursor, lTmpOffset;
    POINT          pt;
    HWND           hUIWnd;
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;

    if (GetWindowLong(hCandWnd, UI_MOVE_OFFSET) == WINDOW_NOT_DRAG) {
        return (FALSE);
    }

    lTmpCursor = GetWindowLong(hCandWnd, UI_MOVE_XY);

    // calculate the org by the offset
    lTmpOffset = GetWindowLong(hCandWnd, UI_MOVE_OFFSET);

    pt.x = (*(LPPOINTS)&lTmpCursor).x - (*(LPPOINTS)&lTmpOffset).x;
    pt.y = (*(LPPOINTS)&lTmpCursor).y - (*(LPPOINTS)&lTmpOffset).y;

    DrawDragBorder(hCandWnd, lTmpCursor, lTmpOffset);
    SetWindowLong(hCandWnd, UI_MOVE_OFFSET, WINDOW_NOT_DRAG);
    ReleaseCapture();

    hUIWnd = GetWindow(hCandWnd, GW_OWNER);

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return (FALSE);
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return (FALSE);
    }

    AdjustCandBoundry(
#if defined(UNIIME)
        lpImeL,
#endif
        &pt);

    ScreenToClient(lpIMC->hWnd, &pt);

    lpIMC->cfCandForm[0].dwStyle = CFS_CANDIDATEPOS;
    lpIMC->cfCandForm[0].ptCurrentPos = pt;

    ImmUnlockIMC(hIMC);

    PostMessage(hCandWnd, WM_IME_NOTIFY, IMN_SETCANDIDATEPOS, 0x0001);

    return (TRUE);
}

/**********************************************************************/
/* PaintCandPage()                                                    */
/**********************************************************************/
void PASCAL PaintCandPage(
#if defined(UNIIME)
    LPIMEL          lpImeL,
#endif
    HDC             hDC,
    UINT            uCandMode,
    LPCANDIDATELIST lpCandList)
{
    HBITMAP hCandPromptBmp;
    HBITMAP hPageUpBmp, hPageDnBmp, hOldBmp;
    HDC     hMemDC;

    hMemDC = CreateCompatibleDC(hDC);
    if ( hMemDC == NULL )
       return;

    if (uCandMode == CAND_PROMPT_PHRASE) {
        hCandPromptBmp = LoadBitmap(hInst,
            MAKEINTRESOURCE(IDBM_CAND_PROMPT_PHRASE));
#if defined(WINAR30)
    } else if (uCandMode == CAND_PROMPT_QUICK_VIEW) {
        hCandPromptBmp = LoadBitmap(hInst,
            MAKEINTRESOURCE(IDBM_CAND_PROMPT_QUICK_VIEW));
#endif
    } else {
        hCandPromptBmp = LoadBitmap(hInst,
            MAKEINTRESOURCE(IDBM_CAND_PROMPT_NORMAL));
    }

    if ( hCandPromptBmp == NULL )
    {
       DeleteDC(hMemDC);
       return;
    }

    hOldBmp = SelectObject(hMemDC, hCandPromptBmp);

    BitBlt(hDC, lpImeL->rcCandPrompt.left, lpImeL->rcCandPrompt.top,
        lpImeL->rcCandPrompt.right - lpImeL->rcCandPrompt.left,
        lpImeL->rcCandPrompt.bottom - lpImeL->rcCandPrompt.top,
        hMemDC, 0, 0, SRCCOPY);

    if (lpCandList->dwCount <= lpCandList->dwPageSize) {
        goto PaintCandPageOvr;
    }

    if (lpCandList->dwPageStart > 0) {
        hPageUpBmp = LoadBitmap(hInst, MAKEINTRESOURCE(IDBM_PAGEUP_VERT));
    } else {
        hPageUpBmp = LoadBitmap(hInst, MAKEINTRESOURCE(IDBM_NO_PAGEUP_VERT));
    }
  
    if ( hPageUpBmp == NULL )
    {
       goto PaintCandPageOvr;
    }

    if ((lpCandList->dwPageStart + lpCandList->dwPageSize) <
        lpCandList->dwCount) {
        hPageDnBmp = LoadBitmap(hInst, MAKEINTRESOURCE(IDBM_PAGEDN_VERT));
    } else {
        hPageDnBmp = LoadBitmap(hInst, MAKEINTRESOURCE(IDBM_NO_PAGEDN_VERT));
    }

    if ( hPageDnBmp == NULL )
    {
       DeleteObject(hPageUpBmp);
       goto PaintCandPageOvr;
    }

    SelectObject(hMemDC, hPageUpBmp);

    BitBlt(hDC, lpImeL->rcCandPageUp.left, lpImeL->rcCandPageUp.top,
        lpImeL->rcCandPageUp.right - lpImeL->rcCandPageUp.left,
        lpImeL->rcCandPageUp.bottom - lpImeL->rcCandPageUp.top,
        hMemDC, 0, 0, SRCCOPY);

    SelectObject(hMemDC, hPageDnBmp);

    BitBlt(hDC, lpImeL->rcCandPageDn.left, lpImeL->rcCandPageDn.top,
        lpImeL->rcCandPageDn.right - lpImeL->rcCandPageDn.left,
        lpImeL->rcCandPageDn.bottom - lpImeL->rcCandPageDn.top,
        hMemDC, 0, 0, SRCCOPY);

    SelectObject(hMemDC, hOldBmp);

    DeleteObject(hPageUpBmp);
    DeleteObject(hPageDnBmp);

PaintCandPageOvr:
    SelectObject(hMemDC, hOldBmp);

    DeleteDC(hMemDC);

    DeleteObject(hCandPromptBmp);

    return;
}

/**********************************************************************/
/* PaintCompWindow()                                                  */
/**********************************************************************/
void PASCAL PaintCandWindow(
#if defined(UNIIME)
    LPIMEL lpImeL,
#endif
    HWND   hCandWnd,
    HDC    hDC)
{
    HIMC            hIMC;
    LPINPUTCONTEXT  lpIMC;
    LPCANDIDATEINFO lpCandInfo;
    LPCANDIDATELIST lpCandList;
    LPPRIVCONTEXT   lpImcP;
    HGDIOBJ         hOldFont;
    DWORD           dwStart, dwEnd;
    UINT            uCandMode;
    TCHAR           szStrBuf[16];
    int             i;
    RECT            rcSunken;
    LOGFONT         lfFont;

    hIMC = (HIMC)GetWindowLongPtr(GetWindow(hCandWnd, GW_OWNER), IMMGWLP_IMC);
    if (!hIMC) {
        return;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return;
    }

    rcSunken = lpImeL->rcCandText;

    rcSunken.left -= lpImeL->cxCandMargin;
    rcSunken.top -= lpImeL->cyCandMargin;
    rcSunken.right += lpImeL->cxCandMargin;
    rcSunken.bottom += lpImeL->cyCandMargin;

    DrawEdge(hDC, &rcSunken, BDR_SUNKENOUTER, BF_RECT);

    if (!lpIMC->hCandInfo) {
        goto UpCandW2UnlockIMC;
    }

    if (!lpIMC->hPrivate) {
        goto UpCandW2UnlockIMC;
    }

    lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo);
    if (!lpCandInfo) {
        goto UpCandW2UnlockIMC;
    }

    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    if (!lpImcP) {
        goto UpCandW2UnlockCandInfo;
    }

    hOldFont = GetCurrentObject(hDC, OBJ_FONT);
    GetObject(hOldFont, sizeof(lfFont), &lfFont);

    if (sImeG.fDiffSysCharSet) {
        lfFont.lfCharSet = NATIVE_CHARSET;
        lfFont.lfFaceName[0] = TEXT('\0');
    }
    lfFont.lfWeight = FW_DONTCARE;

    SelectObject(hDC, CreateFontIndirect(&lfFont));

    lpCandList = (LPCANDIDATELIST)((LPBYTE)lpCandInfo +
        lpCandInfo->dwOffset[0]);

    dwStart = lpCandList->dwPageStart;

    dwEnd = dwStart + lpCandList->dwPageSize;

    if (dwEnd > lpCandList->dwCount) {
        dwEnd = lpCandList->dwCount;
    }

    if (lpImcP->iImeState == CST_INIT) {
        // phrase prediction
        SetTextColor(hDC, RGB(0x00, 0x80, 0x00));
        uCandMode = CAND_PROMPT_PHRASE;
#if defined(WINAR30)
    } else if (lpImcP->iImeState != CST_CHOOSE) {
        // quick key
        SetTextColor(hDC, RGB(0x80, 0x00, 0x80));
        uCandMode = CAND_PROMPT_QUICK_VIEW;
#endif
    } else {
        uCandMode = CAND_PROMPT_NORMAL;
    }

    PaintCandPage(
#if defined(UNIIME)
        lpImeL,
#endif
        hDC, uCandMode, lpCandList);

    SetBkColor(hDC, RGB(0xC0, 0xC0, 0xC0));

    ExtTextOut(hDC, lpImeL->rcCandText.left, lpImeL->rcCandText.top,
        ETO_OPAQUE, &lpImeL->rcCandText, NULL, 0, NULL);
    szStrBuf[0] = TEXT('1');
    szStrBuf[1] = TEXT(':');

    for (i = 0; dwStart < dwEnd; dwStart++, i++) {
        LPTSTR lpStr;
        int    nCharsInOneStr;
        int    nHalfCharsInOneStr;      // how many half width chars
                                        // one full width char ==
                                        // 2 half width chars
        int    nLimit;          // the room left to the candidate window
#ifdef UNICODE
        LPTSTR lpTmpStr;
        int    iDx[3 * CANDPERPAGE + 1];
#endif

        lpStr = (LPTSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[dwStart]);

        // the candidate window width allow 7 + 1 full shape DBCS chars
        // only 8 chars can accomendate the width of three bitmaps.

        nLimit = 16;

        szStrBuf[0] = szDigit[i + lpImeL->wCandStart];

#ifdef UNICODE
        nCharsInOneStr = 0;

        iDx[nCharsInOneStr++] = sImeG.xChiCharWi / 2;
        iDx[nCharsInOneStr++] = sImeG.xChiCharWi - iDx[0];

        nHalfCharsInOneStr = 2;

        for (lpTmpStr = lpStr; *lpTmpStr; lpTmpStr++, nCharsInOneStr++) {
            if (nHalfCharsInOneStr > nLimit) {
                break;
            } else if (*lpTmpStr < 0x0200) {
                nHalfCharsInOneStr += 1;
                iDx[nCharsInOneStr] = sImeG.xChiCharWi / 2;
            } else {
                nHalfCharsInOneStr += 2;
                iDx[nCharsInOneStr] = sImeG.xChiCharWi;
            }
        }
#else
        nHalfCharsInOneStr = nCharsInOneStr = lstrlen(lpStr) + 2;
#endif

        if (nHalfCharsInOneStr <= nLimit) {
            CopyMemory(&szStrBuf[2], lpStr,
                (nCharsInOneStr - 2) * sizeof(TCHAR));
        } else {
#ifdef UNICODE
            if (lpStr[nCharsInOneStr - 2 - 2] < 0x0200) {
                // we need more room to put ..
                nCharsInOneStr -= 3;
            } else {
                nCharsInOneStr -= 2;
            }
#else
            nHalfCharsInOneStr = nCharsInOneStr = nLimit - 2;
#endif
            CopyMemory(&szStrBuf[2], lpStr,
                (nCharsInOneStr - 2) * sizeof(TCHAR));

#ifdef UNICODE
            // unicode of ..
            iDx[nCharsInOneStr] = sImeG.xChiCharWi;
            szStrBuf[nCharsInOneStr++] = 0x2025;
#else
            szStrBuf[nCharsInOneStr++] = '.';
            szStrBuf[nCharsInOneStr++] = '.';
#endif
        }

#if defined(WINAR30)
        if (nCharsInOneStr <= 2) {
#ifdef UNICODE
            // add unicode 0x25A1
            *(LPWSTR)&szStrBuf[2] = 0x25A1;
            iDx[2] = sImeG.xChiCharWi;
#else
            // add big-5 0xA1BC
            *(LPWSTR)&szStrBuf[2] = 0xBCA1;
#endif
            nCharsInOneStr = 2 + sizeof(WCHAR) / sizeof(TCHAR);
        }
#endif

        ExtTextOut(hDC, lpImeL->rcCandText.left,
            lpImeL->rcCandText.top + i * sImeG.yChiCharHi,
            (UINT)0, NULL,
            szStrBuf,
            nCharsInOneStr, iDx);
    }

    DeleteObject(SelectObject(hDC, hOldFont));

    ImmUnlockIMCC(lpIMC->hPrivate);
UpCandW2UnlockCandInfo:
    ImmUnlockIMCC(lpIMC->hCandInfo);
UpCandW2UnlockIMC:
    ImmUnlockIMC(hIMC);

    return;
}

/**********************************************************************/
/* CandWndProc()                                                      */
/**********************************************************************/
#if defined(UNIIME)
LRESULT WINAPI UniCandWndProc(
    LPINSTDATAL lpInstL,
    LPIMEL      lpImeL,
#else
LRESULT CALLBACK CandWndProc(
#endif
    HWND   hCandWnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (uMsg) {
    case WM_DESTROY:
        DestroyCandWindow(hCandWnd);
        break;
    case WM_SETCURSOR:
        CandSetCursor(
#if defined(UNIIME)
            lpInstL, lpImeL,
#endif
            hCandWnd, lParam);
        break;
    case WM_MOUSEMOVE:
        if (GetWindowLong(hCandWnd, UI_MOVE_OFFSET) != WINDOW_NOT_DRAG) {
            POINT ptCursor;

            DrawDragBorder(hCandWnd,
                GetWindowLong(hCandWnd, UI_MOVE_XY),
                GetWindowLong(hCandWnd, UI_MOVE_OFFSET));
            GetCursorPos(&ptCursor);
            SetWindowLong(hCandWnd, UI_MOVE_XY,
                MAKELONG(ptCursor.x, ptCursor.y));
            DrawDragBorder(hCandWnd, MAKELONG(ptCursor.x, ptCursor.y),
                GetWindowLong(hCandWnd, UI_MOVE_OFFSET));
        } else {
            return DefWindowProc(hCandWnd, uMsg, wParam, lParam);
        }
        break;
    case WM_LBUTTONUP:
        if (!CandButtonUp(
#if defined(UNIIME)
            lpImeL,
#endif
            hCandWnd)) {
            return DefWindowProc(hCandWnd, uMsg, wParam, lParam);
        }
        break;
    case WM_IME_NOTIFY:
        if (wParam != IMN_SETCANDIDATEPOS) {
        } else if (lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI) {
        } else if (lParam & 0x0001) {
            return SetCandPosition(
#if defined(UNIIME)
                lpImeL,
#endif
                hCandWnd);
        } else {
        }
        break;
    case WM_PAINT:
        {
            HDC         hDC;
            PAINTSTRUCT ps;

            hDC = BeginPaint(hCandWnd, &ps);
            PaintCandWindow(
#if defined(UNIIME)
                lpImeL,
#endif
                hCandWnd, hDC);
            EndPaint(hCandWnd, &ps);
        }
        break;
    case WM_MOUSEACTIVATE:
        return (MA_NOACTIVATE);
    default:
        return DefWindowProc(hCandWnd, uMsg, wParam, lParam);
    }

    return (0L);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\chcand.c ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    CHCAND.c
    
++*/

#include <windows.h>
#include <immdev.h>
#include "imeattr.h"
#include "imedefs.h"
#include "uniime.h"

#if !defined(ROMANIME)
/**********************************************************************/
/* PhrasePredition()                                                  */
/* Return vlaue                                                       */
/*      the number of candidates in the candidate list                */
/**********************************************************************/
UINT PASCAL PhrasePrediction(   // predict Chinese word(s) by searching
                                // phrase data base
#if defined(UNIIME)
    LPIMEL              lpImeL,
#endif
    LPINPUTCONTEXT      lpIMC,
    LPCOMPOSITIONSTRING lpCompStr,
    LPPRIVCONTEXT       lpImcP)
{
    LPCANDIDATEINFO lpCandInfo;
    LPCANDIDATELIST lpCandList;
    DWORD           dwStartLen, dwEndLen;
    UINT            nCand;

    if (!lpCompStr) {
        return (0);
    }

    if ((lpIMC->fdwConversion & (IME_CMODE_NATIVE|IME_CMODE_EUDC|
        IME_CMODE_SYMBOL)) != IME_CMODE_NATIVE) {
        // should not do phrase prediction, if not under IME_CMODE_NATIVE
        return (0);
    }

    //if ((WORD)lpIMC->fdwSentence != IME_SMODE_PHRASEPREDICT) {
        if (!(lpIMC->fdwSentence & IME_SMODE_PHRASEPREDICT)) {
        // should not do phrase prediction, if not under IME_SMODE_PHRASEPREDICT
        return (0);
    }

    if (!lpIMC->hCandInfo) {
        return (0);
    }

    lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo);

    if (!lpCandInfo) {
        return (0);
    }

    lpCandList = (LPCANDIDATELIST)
        ((LPBYTE)lpCandInfo + lpCandInfo->dwOffset[0]);

    // ImeToAsciiEx will call into this function, so we need to init again
    lpCandList->dwCount = 0;

    // default start from 0
    lpCandList->dwPageStart = lpCandList->dwSelection = 0;

    dwStartLen = sizeof(WCHAR) / sizeof(TCHAR);
    dwEndLen = (UINT)-1;

    // one day may be this API can accept bo po mo fo as aid information
    // so we pass the ResultReadStr for Phonetic

    // one DBCS char may have two pronounciations but when it is in a
    // phrase it may only use one pronounciation of them

    UniSearchPhrasePrediction(lpImeL, NATIVE_CP,
        (LPTSTR)((LPBYTE)lpCompStr + lpCompStr->dwResultStrOffset),
        lpCompStr->dwResultStrLen,
#if defined(PHON)
        (LPTSTR)((LPBYTE)lpCompStr + lpCompStr->dwResultReadStrOffset),
        lpCompStr->dwResultReadStrLen,
#else
        NULL, 0,
#endif
        dwStartLen, dwEndLen, (UINT)-1, lpCandList);

    // how many strings we got?
    nCand = lpCandList->dwCount;

    if (nCand == 0) {
        lpCandInfo->dwCount  = 0;
        lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CLOSE_CANDIDATE) &
            ~(MSG_OPEN_CANDIDATE|MSG_CHANGE_CANDIDATE);
        goto PhPrUnlockCandInfo;
    }

    // for showing phrase prediction string(s)
    lpCandInfo->dwCount  = 1;

    // open composition candidate UI window for the string(s)
    if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
        lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CHANGE_CANDIDATE) &
            ~(MSG_CLOSE_CANDIDATE);
    } else {
        lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_OPEN_CANDIDATE) &
            ~(MSG_CLOSE_CANDIDATE);
    }

PhPrUnlockCandInfo:
    ImmUnlockIMCC(lpIMC->hCandInfo);

    return (nCand);
}

/**********************************************************************/
/* SelectOneCand()                                                    */
/**********************************************************************/
void PASCAL SelectOneCand(
#if defined(UNIIME)
    LPIMEL              lpImeL,
#endif
    HIMC                hIMC,
    LPINPUTCONTEXT      lpIMC,
    LPCOMPOSITIONSTRING lpCompStr,
    LPPRIVCONTEXT       lpImcP,
    LPCANDIDATELIST     lpCandList)
{
    DWORD       dwCompStrLen;
    DWORD       dwReadClauseLen, dwReadStrLen;
    LPTSTR      lpSelectStr;
    LPGUIDELINE lpGuideLine;

    if (!lpCompStr) {
        MessageBeep((UINT)-1);
        return;
    }

    if (!lpImcP) {
        MessageBeep((UINT)-1);
        return;
    }

    // backup the dwCompStrLen, this value decide whether
    // we go for phrase prediction
    dwCompStrLen = lpCompStr->dwCompStrLen;
    // backup the value, this value will be destroyed in InitCompStr
    dwReadClauseLen = lpCompStr->dwCompReadClauseLen;
    dwReadStrLen = lpCompStr->dwCompReadStrLen;
    lpSelectStr = (LPTSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[
        lpCandList->dwSelection]);

    InitCompStr(lpCompStr);

    if (lpIMC->fdwConversion & IME_CMODE_SYMBOL) {
        ImmSetConversionStatus(hIMC,
            lpIMC->fdwConversion & ~(IME_CMODE_SYMBOL),
            lpIMC->fdwSentence);
    }

    // the result reading clause = compsotion reading clause
    CopyMemory((LPBYTE)lpCompStr + lpCompStr->dwResultReadClauseOffset,
        (LPBYTE)lpCompStr + lpCompStr->dwCompReadClauseOffset,
        dwReadClauseLen * sizeof(TCHAR) + sizeof(TCHAR));
    lpCompStr->dwResultReadClauseLen = dwReadClauseLen;

    // the result reading string = compsotion reading string
    CopyMemory((LPBYTE)lpCompStr + lpCompStr->dwResultReadStrOffset,
        (LPBYTE)lpCompStr + lpCompStr->dwCompReadStrOffset,
        dwReadStrLen * sizeof(TCHAR) + sizeof(TCHAR));
    lpCompStr->dwResultReadStrLen = dwReadStrLen;

    // calculate result string length
    lpCompStr->dwResultStrLen = lstrlen(lpSelectStr);

    // the result string = the selected candidate;
    CopyMemory((LPBYTE)lpCompStr + lpCompStr->dwResultStrOffset, lpSelectStr,
        lpCompStr->dwResultStrLen * sizeof(TCHAR) + sizeof(TCHAR));

    lpCompStr->dwResultClauseLen = 2 * sizeof(DWORD);
    *(LPDWORD)((LPBYTE)lpCompStr + lpCompStr->dwResultClauseOffset +
        sizeof(DWORD)) = lpCompStr->dwResultStrLen;

    // tell application, there is a reslut string
    lpImcP->fdwImeMsg |= MSG_COMPOSITION;
    lpImcP->dwCompChar = (DWORD) 0;
    lpImcP->fdwGcsFlag |= GCS_COMPREAD|GCS_COMP|GCS_CURSORPOS|
        GCS_DELTASTART|GCS_RESULTREAD|GCS_RESULT;

    if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
        lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CLOSE_CANDIDATE) &
            ~(MSG_OPEN_CANDIDATE|MSG_CHANGE_CANDIDATE);
    } else {
        lpImcP->fdwImeMsg &= ~(MSG_CLOSE_CANDIDATE|MSG_OPEN_CANDIDATE);
    }

    // no candidate now, the right candidate string already be finalized
    lpCandList->dwCount = 0;

    lpImcP->iImeState = CST_INIT;
    *(LPDWORD)lpImcP->bSeq = 0;
#if defined(CHAJEI) || defined(QUICK) || defined(WINAR30) || defined(UNIIME)
    *(LPDWORD)&lpImcP->bSeq[4] = 0;
#endif

    //if ((WORD)lpIMC->fdwSentence != IME_SMODE_PHRASEPREDICT) {
        if (!(lpIMC->fdwSentence & IME_SMODE_PHRASEPREDICT)) {
        // not in phrase prediction mode
    } else if (!dwCompStrLen) {
    } else if (lpCompStr->dwResultStrLen != sizeof(WCHAR) / sizeof(TCHAR)) {
    } else {
        // we only predict when we have composition string before and
        // result string is one DBCS char
        PhrasePrediction(
#if defined(UNIIME)
            lpImeL,
#endif
            lpIMC, lpCompStr, lpImcP);
    }

    if (!lpCandList->dwCount) {
        if (lpImcP->fdwImeMsg & MSG_ALREADY_START) {
            lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_END_COMPOSITION) &
                ~(MSG_START_COMPOSITION);
        } else {
            lpImcP->fdwImeMsg &= ~(MSG_END_COMPOSITION|MSG_START_COMPOSITION);
        }
    }

    if (!lpImeL->hRevKL) {
        return;
    }

    if (lpCompStr->dwResultStrLen != sizeof(WCHAR) / sizeof(TCHAR)) {
        // we only can reverse convert one DBCS character for now
        if (lpImcP->fdwImeMsg & MSG_GUIDELINE) {
            return;
        }
    }

    lpGuideLine = ImmLockIMCC(lpIMC->hGuideLine);

    if (!lpGuideLine) {
        return;
    }

    if (lpCompStr->dwResultStrLen != sizeof(WCHAR) / sizeof(TCHAR)) {
        // we only can reverse convert one DBCS character for now
        lpGuideLine->dwLevel = GL_LEVEL_NOGUIDELINE;
        lpGuideLine->dwIndex = GL_ID_UNKNOWN;
    } else {
        TCHAR szStrBuf[4];
        UINT  uSize;

        *(LPDWORD)szStrBuf = 0;

        *(LPWSTR)szStrBuf = *(LPWSTR)((LPBYTE)lpCompStr +
            lpCompStr->dwResultStrOffset);

        uSize = ImmGetConversionList(lpImeL->hRevKL, (HIMC)NULL, szStrBuf,
            (LPCANDIDATELIST)((LPBYTE)lpGuideLine + lpGuideLine->dwPrivateOffset),
            lpGuideLine->dwPrivateSize, GCL_REVERSECONVERSION);

        if (uSize) {
            lpGuideLine->dwLevel = GL_LEVEL_INFORMATION;
            lpGuideLine->dwIndex = GL_ID_REVERSECONVERSION;

            lpImcP->fdwImeMsg |= MSG_GUIDELINE;

            if (lpImcP->fdwImeMsg & MSG_ALREADY_START) {
                lpImcP->fdwImeMsg &= ~(MSG_END_COMPOSITION|
                    MSG_START_COMPOSITION);
            } else {
                lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg|
                    MSG_START_COMPOSITION) & ~(MSG_END_COMPOSITION);
            }
        } else {
            lpGuideLine->dwLevel = GL_LEVEL_NOGUIDELINE;
            lpGuideLine->dwIndex = GL_ID_UNKNOWN;
        }
    }

    ImmUnlockIMCC(lpIMC->hGuideLine);

    return;
}

/**********************************************************************/
/* CandEscapeKey()                                                    */
/**********************************************************************/
void PASCAL CandEscapeKey(
    LPINPUTCONTEXT  lpIMC,
    LPPRIVCONTEXT   lpImcP)
{
    LPCOMPOSITIONSTRING lpCompStr;
    LPGUIDELINE         lpGuideLine;

    // clean all candidate information
    if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
        ClearCand(lpIMC);
        lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CLOSE_CANDIDATE) &
            ~(MSG_OPEN_CANDIDATE|MSG_CHANGE_CANDIDATE);
    } else if (lpImcP->fdwImeMsg & MSG_OPEN_CANDIDATE) {
        ClearCand(lpIMC);
        lpImcP->fdwImeMsg &= ~(MSG_OPEN_CANDIDATE|MSG_CHANGE_CANDIDATE);
    } else {
    }

    lpImcP->iImeState = CST_INPUT;

    // if it start composition, we need to clean composition
    if (!(lpImcP->fdwImeMsg & (MSG_ALREADY_START|MSG_START_COMPOSITION))) {
        return;
    }

    lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
    lpGuideLine = (LPGUIDELINE)ImmLockIMCC(lpIMC->hGuideLine);

    CompEscapeKey(lpIMC, lpCompStr, lpGuideLine, lpImcP);

    ImmUnlockIMCC(lpIMC->hGuideLine);
    ImmUnlockIMCC(lpIMC->hCompStr);

    return;
}

/**********************************************************************/
/* ChooseCand()                                                       */
/**********************************************************************/
void PASCAL ChooseCand(         // choose one of candidate strings by
                                // input char
#if defined(UNIIME)
    LPINSTDATAL     lpInstL,
    LPIMEL          lpImeL,
#endif
    WORD            wCharCode,
    HIMC            hIMC,
    LPINPUTCONTEXT  lpIMC,
    LPCANDIDATEINFO lpCandInfo,
    LPPRIVCONTEXT   lpImcP)
{
    LPCANDIDATELIST     lpCandList;
    LPCOMPOSITIONSTRING lpCompStr;
    LPGUIDELINE         lpGuideLine;
#if defined(PHON)
    WORD                wStandardChar;
    char                cIndex;
#endif

    if (wCharCode == VK_ESCAPE) {           // escape key
        CandEscapeKey(lpIMC, lpImcP);
        return;
    }

    if (!lpCandInfo) {
        MessageBeep((UINT)-1);
        return;
    }

    if (!lpCandInfo->dwCount) {
        MessageBeep((UINT)-1);
        return;
    }

    lpCandList = (LPCANDIDATELIST)
        ((LPBYTE)lpCandInfo + lpCandInfo->dwOffset[0]);

#if defined(WINAR30)
    if (wCharCode == CHOOSE_CIRCLE) {       // circle selection
        if (lpCandList->dwCount <= lpCandList->dwPageSize) {
            wCharCode = lpImeL->wCandStart;
        }
    }
#endif

    if (wCharCode == CHOOSE_CIRCLE) {       // circle selection
        lpCandList->dwPageStart = lpCandList->dwSelection =
            lpCandList->dwSelection + lpCandList->dwPageSize;

        if (lpCandList->dwSelection >= lpCandList->dwCount) {
            // no more candidates, restart it!
            lpCandList->dwPageStart = lpCandList->dwSelection = 0;
            MessageBeep((UINT)-1);
        }
        // inform UI, dwSelectedCand is changed
        lpImcP->fdwImeMsg |= MSG_CHANGE_CANDIDATE;
        return;
    }

    if (wCharCode == CHOOSE_NEXTPAGE) {     // next selection
        lpCandList->dwPageStart = lpCandList->dwSelection =
            lpCandList->dwSelection + lpCandList->dwPageSize;

        if (lpCandList->dwSelection >= lpCandList->dwCount) {
            // no more candidates, restart it!
            lpCandList->dwPageStart = lpCandList->dwSelection = 0;
            MessageBeep((UINT)-1);
        }

        // inform UI, dwSelectedCand is changed
        lpImcP->fdwImeMsg |= MSG_CHANGE_CANDIDATE;
        return;
    }

    if (wCharCode == CHOOSE_PREVPAGE) {     // previous selection
        if (!lpCandList->dwSelection) {
            MessageBeep((UINT)-1);
            return;
        }

        // maybe we can not use this size, it totally depend on
        // whether the application draw UI by itself
        if (lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI) {
            lpImcP->dwPrevPageStart = lpCandList->dwPageStart;
            lpImcP->fdwImeMsg |= MSG_IMN_PAGEUP;
        }

        if (lpCandList->dwSelection < lpCandList->dwPageSize) {
            lpCandList->dwPageStart = lpCandList->dwSelection = 0;
        } else {
            lpCandList->dwPageStart = lpCandList->dwSelection =
                lpCandList->dwSelection - lpCandList->dwPageSize;
        }
        // inform UI, dwSelectedCand is changed
        lpImcP->fdwImeMsg |= MSG_CHANGE_CANDIDATE;

        return;
    }

    if (wCharCode == CHOOSE_HOME) {      // home selection
        if (lpCandList->dwSelection == 0) {
            MessageBeep((UINT)-1);      // already home!
            return;
        }

        lpCandList->dwPageStart = lpCandList->dwSelection = 0;
        // inform UI, dwSelectedCand is changed
        lpImcP->fdwImeMsg |= MSG_CHANGE_CANDIDATE;
        return;
    }

    if ((wCharCode >= 0 + lpImeL->wCandRangeStart) && (wCharCode <= 9)) {
        // dayi starts from 0, CandRangeStart == 0
        // array starts from 1, CandPerPage == 10
        DWORD dwSelection;

        // choose one candidate from the candidate list
        dwSelection = lpCandList->dwSelection + (wCharCode +
            lpImeL->wCandPerPage - lpImeL->wCandStart) %
            lpImeL->wCandPerPage;

        if (dwSelection >= lpCandList->dwCount) {
            // out of range
            MessageBeep((UINT)-1);
            return;
        }

        // one candidate is selected by 1, 2, or 3 ...
#if defined(WINAR30)
        if (!*(LPWSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[
            dwSelection])) {
            MessageBeep((UINT)-1);
            return;
        }
#endif

        lpCandList->dwSelection = dwSelection;

        lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);

        // translate into translate buffer
        SelectOneCand(
#if defined(UNIIME)
            lpImeL,
#endif
            hIMC, lpIMC, lpCompStr, lpImcP, lpCandList);

        ImmUnlockIMCC(lpIMC->hCompStr);

        return;
    }

#if defined(UNIIME)
    if (!lpInstL) {
        MessageBeep((UINT)-1);
        return;
    }
#endif

    // don't select by choose key, the 1st candidate is default selected
    // candidate string is decided but we also need to decide the
    //  composition string for this input
#if defined(PHON)
    // this check only useful in IBM and other layout

    wStandardChar = bUpper[wCharCode - ' '];

    // even for ETen 26 Keys, this is OK we don't need to access ETen2ndLayout
    wStandardChar = bStandardLayout[lpImeL->nReadLayout][wStandardChar - ' '];

    cIndex = cIndexTable[wStandardChar - ' '];

    if (cIndex >= 3)  {
        MessageBeep((UINT)-1);
        return;
    }
#endif
    lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
    lpGuideLine = (LPGUIDELINE)ImmLockIMCC(lpIMC->hGuideLine);

    // translate into translate buffer
    SelectOneCand(
#if defined(UNIIME)
        lpImeL,
#endif
        hIMC, lpIMC, lpCompStr, lpImcP, lpCandList);

    // don't phrase prediction under this case
    if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
        lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CLOSE_CANDIDATE) &
          ~(MSG_OPEN_CANDIDATE|MSG_CHANGE_CANDIDATE);
    } else {
        lpImcP->fdwImeMsg &= ~(MSG_CLOSE_CANDIDATE|MSG_OPEN_CANDIDATE);
    }

    CompWord(
#if defined(UNIIME)
        lpInstL, lpImeL,
#endif
        wCharCode, hIMC, lpIMC, lpCompStr, lpGuideLine, lpImcP);

    if (lpGuideLine) {
        ImmUnlockIMCC(lpIMC->hGuideLine);
    }

    if (lpCompStr) {
        ImmUnlockIMCC(lpIMC->hCompStr);
    }

    return;
}

#if defined(WINAR30) || defined(DAYI)
/**********************************************************************/
/* SearchSymbol                                                       */
/**********************************************************************/
void PASCAL SearchSymbol(       // serach symbol characters
    WORD            wSymbolSet,
    HIMC            hIMC,
    LPINPUTCONTEXT  lpIMC,
    LPPRIVCONTEXT   lpImcP)
{
    LPCANDIDATEINFO lpCandInfo;
    LPCANDIDATELIST lpCandList;
    UINT            i;

    if ((lpIMC->fdwConversion & (IME_CMODE_NATIVE|IME_CMODE_EUDC|
        IME_CMODE_SYMBOL)) != (IME_CMODE_NATIVE|IME_CMODE_SYMBOL)) {
        return;
    }

    if (!lpIMC->hCandInfo) {
        return;
    }

    lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo);

    if (!lpCandInfo) {
        return;
    }

    lpCandList = (LPCANDIDATELIST)
        ((LPBYTE)lpCandInfo + lpCandInfo->dwOffset[0]);

    lpCandList->dwCount = 0;

#if defined(DAYI)
    if (wSymbolSet >= 'A' && wSymbolSet <= 'Z') {
        AddCodeIntoCand(lpCandList, sImeG.wFullABC[wSymbolSet - ' ']);
    } else if (wSymbolSet >= 'a' && wSymbolSet <= 'z') {
        AddCodeIntoCand(lpCandList, sImeG.wFullABC[wSymbolSet - ' ']);
    } else {
#endif
#if defined(WINAR30)
    {
#endif
        for (i = 0; i < sizeof(lpImeL->wSymbol) / sizeof(WORD); i++) {
            if (lpImeL->wSymbol[i] == wSymbolSet) {
                break;
            }
        }

        if (++i < sizeof(lpImeL->wSymbol) / sizeof(WORD)) {
            for (; lpImeL->wSymbol[i] > 0x007F; i++) {
                AddCodeIntoCand(lpCandList, lpImeL->wSymbol[i]);
            }
        }
    }

    if (!lpCandList->dwCount) {
        ImmSetConversionStatus(hIMC,
            lpIMC->fdwConversion & ~(IME_CMODE_SYMBOL),
            lpIMC->fdwSentence);
        CompCancel(hIMC, lpIMC);
        Select(
#if defined(UNIIME)
            lpImeL,
#endif
            lpIMC, TRUE);
    } else if (lpCandList->dwCount == 1) {
        LPCOMPOSITIONSTRING lpCompStr;

        lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
        if (lpCompStr) {
            SelectOneCand(hIMC, lpIMC, lpCompStr, lpImcP, lpCandList);
            ImmUnlockIMCC(lpIMC->hCompStr);
        }
    } else {
        lpCandInfo->dwCount = 1;

        if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
            lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CHANGE_CANDIDATE) &
                ~(MSG_CLOSE_CANDIDATE);
        } else {
            lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_OPEN_CANDIDATE) &
                ~(MSG_CLOSE_CANDIDATE);
        }

        lpImcP->iImeState = CST_CHOOSE;
    }

    ImmUnlockIMCC(lpIMC->hCandInfo);
}
#endif // defined(WINAR30) || defined(DAYI)
#endif // !defined(ROMANIME)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\config.c ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    CONFIG.c
    
++*/

/**********************************************************************/
#include <windows.h>
#include <commdlg.h>
#include <immdev.h>
#include <shlobj.h>
#include "imeattr.h"
#include "imedefs.h"
#include "imerc.h"
#if defined(UNIIME)
#include "uniime.h"
#endif

#if !defined(ROMANIME)
/**********************************************************************/
/* ReverseConversionList()                                            */
/**********************************************************************/
void PASCAL ReverseConversionList(
#if defined(UNIIME)
    LPIMEL lpImeL,
#endif
    HWND   hLayoutListBox)
{
    TCHAR    szImeName[16];
    HKL FAR *lpKLMem;
    int      nLayouts, i, nIMEs;

    LoadString(hInst, IDS_NONE, szImeName, sizeof(szImeName)/sizeof(TCHAR));

    SendMessage(hLayoutListBox, LB_INSERTSTRING,
        0, (LPARAM)szImeName);

    SendMessage(hLayoutListBox, LB_SELECTSTRING,
        0, (LPARAM)szImeName);

    SendMessage(hLayoutListBox, LB_SETITEMDATA,
        0, (LPARAM)(HKL)NULL);

    nLayouts = GetKeyboardLayoutList(0, NULL);

    lpKLMem = GlobalAlloc(GPTR, sizeof(HKL) * nLayouts);
    if (!lpKLMem) {
        return;
    }

    GetKeyboardLayoutList(nLayouts, lpKLMem);

    for (i = 0, nIMEs = 0; i < nLayouts; i++) {
        HKL hKL;

        hKL = *(lpKLMem + i);

        if (LOWORD(hKL) != NATIVE_LANGUAGE) {
            // not support other language
            continue;
        }

        // NULL hIMC ???????
        if (!ImmGetConversionList(hKL, (HIMC)NULL, NULL,
            NULL, 0, GCL_REVERSECONVERSION)) {
            // this IME not support reverse conversion
            continue;
        }

        if (!ImmEscape(hKL, (HIMC)NULL, IME_ESC_IME_NAME,
            szImeName)) {
            // this IME does not report the IME name
            continue;
        }

        nIMEs++;

        SendMessage(hLayoutListBox, LB_INSERTSTRING,
            nIMEs, (LPARAM)szImeName);

        if (hKL == lpImeL->hRevKL) {
            SendMessage(hLayoutListBox, LB_SELECTSTRING, nIMEs,
                (LPARAM)szImeName);
        }

        SendMessage(hLayoutListBox, LB_SETITEMDATA,
            nIMEs, (LPARAM)hKL);
    }

    GlobalFree((HGLOBAL)lpKLMem);

    return;
}
#endif

/**********************************************************************/
/* ChangeConfiguration()                                              */
/**********************************************************************/
void PASCAL ChangeConfiguration(
#if defined(UNIIME)
    LPIMEL lpImeL,
#endif
    HWND   hDlg)
{
#if !defined(ROMANIME)
    DWORD fdwModeConfig;
    DWORD fdwImeMsg;
#if defined(PHON)
    int   i;
#endif

    fdwModeConfig = 0;
    fdwImeMsg = 0;

    if (IsDlgButtonChecked(hDlg, IDD_OFF_CARET_UI)) {
        fdwModeConfig |= MODE_CONFIG_OFF_CARET_UI;

    }

    if ((lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI) ^
        (fdwModeConfig & MODE_CONFIG_OFF_CARET_UI)) {
        fdwImeMsg |= MSG_IMN_TOGGLE_UI;
    }

#if defined(WINAR30)
    if (IsDlgButtonChecked(hDlg, IDD_QUICK_KEY)) {
        fdwModeConfig |= MODE_CONFIG_QUICK_KEY;

    }

    if ((lpImeL->fdwModeConfig & MODE_CONFIG_QUICK_KEY) ^
        (fdwModeConfig & MODE_CONFIG_QUICK_KEY)) {
        fdwImeMsg |= MSG_IMN_UPDATE_QUICK_KEY;
    }
#endif

    if (IsDlgButtonChecked(hDlg, IDD_PREDICT)) {
        fdwModeConfig |= MODE_CONFIG_PREDICT;

    }

    if ((lpImeL->fdwModeConfig & MODE_CONFIG_PREDICT) ^
        (fdwModeConfig & MODE_CONFIG_PREDICT)) {
        fdwImeMsg |= MSG_IMN_UPDATE_PREDICT;
    }

    // check BIG5ONLY 
    if (IsDlgButtonChecked(hDlg, IDD_BIG5ONLY)) {
        fdwModeConfig |= MODE_CONFIG_BIG5ONLY;

    }

    if (lpImeL->fdwModeConfig != fdwModeConfig) {
        SetUserSetting(
#if defined(UNIIME)
            lpImeL,
#endif
            szRegModeConfig, REG_DWORD, (LPBYTE)&fdwModeConfig,
            sizeof(fdwModeConfig));

        lpImeL->fdwModeConfig = fdwModeConfig;

        if (fdwImeMsg & MSG_IMN_TOGGLE_UI) {
            InitImeUIData(lpImeL);
        }
    }

#if defined(PHON)
    // get the reading layout
    for (i = IDD_DEFAULT_KB; i < IDD_DEFAULT_KB + READ_LAYOUTS; i++) {
        if (IsDlgButtonChecked(hDlg, i)) {
            break;
        }
    }

    if (i >= IDD_DEFAULT_KB + READ_LAYOUTS) {
        i = READ_LAYOUT_DEFAULT;
    } else {
        i -= IDD_DEFAULT_KB;
    }

    if ((int)lpImeL->nReadLayout != i) {
        SetUserSetting(
#if defined(UNIIME)
            lpImeL,
#endif
            szRegReadLayout, REG_DWORD, (LPBYTE)&i, sizeof(i));

        lpImeL->nReadLayout = (WORD)i;

        fdwImeMsg |= MSG_IMN_UPDATE_SOFTKBD;
    }
#endif

    {
        HWND hLayoutListBox;
        int  iCurSel;
        HKL  hKL;

        hLayoutListBox = GetDlgItem(hDlg, IDD_LAYOUT_LIST);

        iCurSel = (int)SendMessage(hLayoutListBox, LB_GETCURSEL, 0, 0);

        hKL = (HKL)SendMessage(hLayoutListBox, LB_GETITEMDATA,
            iCurSel, 0);

        if (lpImeL->hRevKL != hKL) {
            WORD nRevMaxKey;

            lpImeL->hRevKL = hKL;

            SetUserSetting(
#if defined(UNIIME)
                lpImeL,
#endif
                szRegRevKL, REG_DWORD, (LPBYTE)&hKL, sizeof(hKL));

            // get the new size
            nRevMaxKey = (WORD)ImmEscape(hKL, (HIMC)NULL, IME_ESC_MAX_KEY,
                NULL);

            if (nRevMaxKey < lpImeL->nMaxKey) {
                nRevMaxKey = lpImeL->nMaxKey;
            }

            if (lpImeL->nRevMaxKey != nRevMaxKey) {
                lpImeL->nRevMaxKey = nRevMaxKey;

                SetCompLocalData(lpImeL);

                fdwImeMsg |= MSG_IMN_COMPOSITIONSIZE;
            }
        }
    }

    if (fdwImeMsg) {
        HIMC           hIMC;
        LPINPUTCONTEXT lpIMC;
        LPPRIVCONTEXT  lpImcP;

        hIMC = (HIMC)ImmGetContext(hDlg);

        if (!hIMC) {
            return;
        }

        lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);

        if (!lpIMC) {
            return;
        }

        lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
        if (!lpImcP) {
            goto ChgConfigUnlockIMC;
        }

        lpImcP->fdwImeMsg |= fdwImeMsg;

        GenerateMessage(hIMC, lpIMC, lpImcP);

        ImmUnlockIMCC(lpIMC->hPrivate);

ChgConfigUnlockIMC:
        ImmUnlockIMC(hIMC);
    }
#endif

    return;
}

#if !defined(ROMANIME) && !defined(WINIME) && !defined(UNICDIME)
/**********************************************************************/
/* BinaryMatched()                                                    */
/**********************************************************************/
BOOL PASCAL BinaryMatched(
    LPBYTE lpData1,
    LPBYTE lpData2,
    UINT   uLen)
{
    UINT i;

    for (i = 0; i < uLen; i++) {
        if (*lpData1++ != *lpData2++) {
            return (FALSE);
        }
    }

    return (TRUE);
}

/**********************************************************************/
/* VerifyEudcDic()                                                    */
/**********************************************************************/
#define TITLE_BUF_SIZE      32
#define MESSAGE_BUF_SIZE    256

BOOL PASCAL VerifyEudcDic(
#if defined(UNIIME)
    LPIMEL lpImeL,
#endif
    HWND   hWnd,
    LPTSTR szTitle,         // this buffer size must >= TITLE_BUF_SIZE
    LPTSTR szMessage)       // this buffer size must >= MESSAGE_BUF_SIZE
{
    HANDLE        hUsrDicFile, hUsrDic;
    LPUSRDICIMHDR lpUsrDic;
    BOOL          fRet;
    int           i;
    DWORD         dwSize, dwFileSize;
    PSECURITY_ATTRIBUTES psa;

    psa = CreateSecurityAttributes();

    hUsrDicFile = CreateFile(szMessage, GENERIC_READ,
        FILE_SHARE_READ|FILE_SHARE_WRITE,
        psa, OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);

    if (hUsrDicFile == INVALID_HANDLE_VALUE) {
        FreeSecurityAttributes(psa);
        if (!hWnd) {
            return (FALSE);
        }

        LoadString(hInst, IDS_NOTOPEN_TITLE, szTitle, TITLE_BUF_SIZE);
        LoadString(hInst, IDS_NOTOPEN_MSG, szMessage, MESSAGE_BUF_SIZE);

        MessageBox(hWnd, szMessage, szTitle,
            MB_OK|MB_ICONHAND|MB_TASKMODAL|MB_TOPMOST);
        return (FALSE);
    }

    fRet = FALSE;

    // we do not need to care about DBCS here, even no problem for DBCS
    for (i = 0; i < MAX_PATH; i++) {
        if (szMessage[i] == '\\') {
            szMessage[i] = '!';
        }
    }

    hUsrDic = CreateFileMapping((HANDLE)hUsrDicFile, psa,
        PAGE_READONLY, 0, 0, szMessage);

    if (!hUsrDic) {
        if (!hWnd) {
            goto VerifyCloseEudcDic;
        }

        LoadString(hInst, IDS_NOTOPEN_TITLE, szTitle, TITLE_BUF_SIZE);
        LoadString(hInst, IDS_NOTOPEN_MSG, szMessage, MESSAGE_BUF_SIZE);

        MessageBox(hWnd, szMessage, szTitle,
            MB_OK|MB_ICONHAND|MB_TASKMODAL|MB_TOPMOST);
        goto VerifyCloseEudcDicFile;
    }

    lpUsrDic = MapViewOfFile(hUsrDic, FILE_MAP_READ, 0, 0, 0);

    if (!lpUsrDic) {
        if (!hWnd) {
            goto VerifyCloseEudcDic;
        }

        LoadString(hInst, IDS_NOTOPEN_TITLE, szTitle, TITLE_BUF_SIZE);
        LoadString(hInst, IDS_NOTOPEN_MSG, szMessage, MESSAGE_BUF_SIZE);

        MessageBox(hWnd, szMessage, szTitle,
            MB_OK|MB_ICONHAND|MB_TASKMODAL|MB_TOPMOST);
        goto VerifyCloseEudcDic;
    }

    dwSize = lpUsrDic->ulTableCount * (sizeof(WORD) + sizeof(WORD) +
        lpUsrDic->cMethodKeySize) + 256;

    dwFileSize = GetFileSize(hUsrDicFile, (LPDWORD)NULL);

    if (dwSize != dwFileSize) {
        if (!hWnd) {
            goto VerifyUnmapEudcDic;
        }

        LoadString(hInst, IDS_FILESIZE_TITLE, szTitle, TITLE_BUF_SIZE);
        LoadString(hInst, IDS_FILESIZE_MSG, szMessage, MESSAGE_BUF_SIZE);

        MessageBox(hWnd, szMessage, szTitle,
            MB_OK|MB_ICONHAND|MB_TASKMODAL|MB_TOPMOST);
    } else if (lpUsrDic->uHeaderSize != 256) {
        if (!hWnd) {
            goto VerifyUnmapEudcDic;
        }

        LoadString(hInst, IDS_HEADERSIZE_TITLE, szTitle, TITLE_BUF_SIZE);
        LoadString(hInst, IDS_HEADERSIZE_MSG, szMessage, MESSAGE_BUF_SIZE);

        MessageBox(hWnd, szMessage, szTitle,
            MB_OK|MB_ICONHAND|MB_TASKMODAL|MB_TOPMOST);
    } else if (lpUsrDic->uInfoSize != 13) {
        if (!hWnd) {
            goto VerifyUnmapEudcDic;
        }

        LoadString(hInst, IDS_INFOSIZE_TITLE, szTitle, TITLE_BUF_SIZE);
        LoadString(hInst, IDS_INFOSIZE_MSG, szMessage, MESSAGE_BUF_SIZE);

        MessageBox(hWnd, szMessage, szTitle,
            MB_OK|MB_ICONHAND|MB_TASKMODAL|MB_TOPMOST);
    } else if (lpUsrDic->idCP != NATIVE_CP && lpUsrDic->idCP != ALT_NATIVE_CP) {
        if (!hWnd) {
            goto VerifyUnmapEudcDic;
        }

        LoadString(hInst, IDS_CODEPAGE_TITLE, szTitle, TITLE_BUF_SIZE);
        LoadString(hInst, IDS_CODEPAGE_MSG, szMessage, MESSAGE_BUF_SIZE);

        MessageBox(hWnd, szMessage, szTitle,
            MB_OK|MB_ICONHAND|MB_TASKMODAL|MB_TOPMOST);
    } else if (*(LPUNADWORD)lpUsrDic->idUserCharInfoSign != SIGN_CWIN) {
            // != CWIN
        if (!hWnd) {
            goto VerifyUnmapEudcDic;
        }

        LoadString(hInst, IDS_CWINSIGN_TITLE, szTitle, TITLE_BUF_SIZE);
        LoadString(hInst, IDS_CWINSIGN_MSG, szMessage, MESSAGE_BUF_SIZE);

        MessageBox(hWnd, szMessage, szTitle,
            MB_OK|MB_ICONHAND|MB_TASKMODAL|MB_TOPMOST);
    } else if (*(LPUNADWORD)((LPBYTE)lpUsrDic->idUserCharInfoSign +
        sizeof(DWORD)) != SIGN__TBL) {
            // != _TBL
        if (!hWnd) {
            goto VerifyUnmapEudcDic;
        }

        LoadString(hInst, IDS_CWINSIGN_TITLE, szTitle, TITLE_BUF_SIZE);
        LoadString(hInst, IDS_CWINSIGN_MSG, szMessage, MESSAGE_BUF_SIZE);

        MessageBox(hWnd, szMessage, szTitle,
            MB_OK|MB_ICONHAND|MB_TASKMODAL|MB_TOPMOST);
    } else if (!BinaryMatched((LPBYTE)lpImeL->szIMEName,
        (LPBYTE)lpUsrDic->achMethodName, sizeof(lpUsrDic->achMethodName))) {
        if (!hWnd) {
            goto VerifyUnmapEudcDic;
        }

        // The IME Name is not match with this file
        LoadString(hInst, IDS_UNMATCHED_TITLE, szTitle, TITLE_BUF_SIZE);
        LoadString(hInst, IDS_UNMATCHED_MSG, szMessage, MESSAGE_BUF_SIZE);

        MessageBox(hWnd, szMessage, szTitle,
            MB_OK|MB_ICONHAND|MB_TASKMODAL|MB_TOPMOST);
    } else {
        fRet = TRUE;
    }

VerifyUnmapEudcDic:
    UnmapViewOfFile(lpUsrDic);

VerifyCloseEudcDic:
    CloseHandle(hUsrDic);

VerifyCloseEudcDicFile:
    CloseHandle(hUsrDicFile);
    FreeSecurityAttributes(psa);

    return (fRet);
}

#if 0
/**********************************************************************/
/* GetEudcDic()                                                       */
/**********************************************************************/
void PASCAL GetEudcDic(
#if defined(UNIIME)
    LPIMEL lpImeL,
#endif
    HWND   hWnd)
{
    TCHAR        chReplace;
    int          i, cbString;

    OPENFILENAME ofn;
    TCHAR        szFilter[64];
    TCHAR        szFileName[MAX_PATH];
    TCHAR        szDirName[MAX_PATH];

    cbString = LoadString(hInst, IDS_USRDIC_FILTER,
        szFilter, sizeof(szFilter)/sizeof(TCHAR));
    chReplace = szFilter[cbString - 1];

    for (i = 0; szFilter[i]; i++) {
        if (szFilter[i] == chReplace) {
            szFilter[i] = '\0';
        }
    }

    GetWindowsDirectory(szDirName, sizeof(szDirName));
    lstrcpy(szFileName, TEXT("*.TBL"));

    // prompt a dialog
    ofn.lStructSize = sizeof(OPENFILENAME);
    ofn.hwndOwner = (HWND)NULL;
    ofn.lpstrFilter = szFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = szFileName;
    ofn.nMaxFile = sizeof(szFileName) / sizeof(TCHAR);
    ofn.lpstrFileTitle = NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = szDirName;
    ofn.lpstrTitle = lpImeL->szIMEName;
    ofn.Flags = OFN_NOCHANGEDIR|OFN_HIDEREADONLY|OFN_PATHMUSTEXIST|
        OFN_FILEMUSTEXIST;
    ofn.lpstrDefExt = NULL;

    if (!GetOpenFileName(&ofn)) {
        return;
    }

    lstrcpy( szDirName, szFileName );

    if (!VerifyEudcDic(
#if defined(UNIIME)
        lpImeL,
#endif
        hWnd, szFilter, szDirName)) {
        return;
    }

    SetWindowText(hWnd, szFileName);

    return;
}

/**********************************************************************/
/* ChangeEudcDic()                                                    */
/**********************************************************************/
BOOL PASCAL ChangeEudcDic(
#if defined(UNIIME)
    LPINSTDATAL lpInstL,
    LPIMEL      lpImeL,
#endif
    HWND        hWnd)
{
    BOOL  fRet;

    TCHAR szFileName[MAX_PATH];
    TCHAR szTitle[32];
    TCHAR szMessage[MAX_PATH];

#if defined(DEBUG)
    // internal error, the data structure need byte alignment
    // it should not use WORD or DWORD alignment

    if (sizeof(USRDICIMHDR) != 256) {
        LoadString(hInst, IDS_INTERNAL_TITLE, szTitle, sizeof(szTitle)/sizeof(TCHAR));
        LoadString(hInst, IDS_INTERNAL_MSG, szMessage, sizeof(szMessage)/sizeof(TCHAR));

        MessageBox(hWnd, szMessage, szTitle,
            MB_OK|MB_ICONHAND|MB_TASKMODAL|MB_TOPMOST);
        return (FALSE);
    }
#endif

    GetWindowText(hWnd, szFileName, sizeof(szFileName) / sizeof(TCHAR));

    if (!lstrcmp(szFileName, lpImeL->szUsrDic)) {
        return (TRUE);
    }

    if (szFileName[0] == '\0') {
        LRESULT lRet;

#if defined(UNIIME)
        lRet = UniImeEscape(lpInstL, lpImeL, (HIMC)NULL,
            IME_ESC_SET_EUDC_DICTIONARY, szFileName);
#else
        lRet = ImeEscape((HIMC)NULL, IME_ESC_SET_EUDC_DICTIONARY, szFileName);
#endif
        if (lRet) {
            return (TRUE);
        } else {
            LoadString(hInst, IDS_EUDCDICFAIL_TITLE, szTitle, sizeof(szTitle)/sizeof(TCHAR));
            LoadString(hInst, IDS_EUDCDICFAIL_MSG, szMessage, sizeof(szMessage)/sizeof(TCHAR));

            MessageBox(hWnd, szMessage, szTitle,
                MB_OK|MB_ICONHAND|MB_TASKMODAL|MB_TOPMOST);
            return (FALSE);
        }
    }

    lstrcpy( szMessage, szFileName );

    if (fRet = VerifyEudcDic(
#if defined(UNIIME)
        lpImeL,
#endif
        hWnd, szTitle, szMessage)) {
        LRESULT lRet;

#if defined(UNIIME)
        lRet = UniImeEscape(lpInstL, lpImeL, (HIMC)NULL,
            IME_ESC_SET_EUDC_DICTIONARY, szFileName);
#else
        lRet = ImeEscape((HIMC)NULL, IME_ESC_SET_EUDC_DICTIONARY, szFileName);
#endif

        if (lRet) {
            fRet = TRUE;
        } else {
            LoadString(hInst, IDS_EUDCDICFAIL_TITLE, szTitle, sizeof(szTitle)/sizeof(TCHAR));
            LoadString(hInst, IDS_EUDCDICFAIL_MSG, szMessage, sizeof(szMessage)/sizeof(TCHAR));

            MessageBox(hWnd, szMessage, szTitle,
                MB_OK|MB_ICONHAND|MB_TASKMODAL|MB_TOPMOST);
        }
    }

    return (fRet);
}
#endif
#endif

/**********************************************************************/
/* ConfigureDlgProc()                                                 */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
INT_PTR CALLBACK ConfigDlgProc(  // dialog procedure of configuration
    HWND   hDlg,
    UINT   uMessage,
    WPARAM wParam,
    LPARAM lParam)
{
#if !defined(ROMANIME)
    HWND          hLayoutListBox;
    HIMC          hIMC;
    static HIMC   hOldIMC;
#endif
#if defined(UNIIME)
    static LPINSTDATAL lpInstL;
    static LPIMEL      lpImeL;
#endif

    switch (uMessage) {
    case WM_INITDIALOG:
#if defined(UNIIME)
        lpInstL = (LPINSTDATAL)lParam;
        lpImeL = lpInstL->lpImeL;
#endif

        if (lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI) {
            CheckDlgButton(hDlg, IDD_OFF_CARET_UI, BST_CHECKED);
        }

#if !defined(ROMANIME)
#if defined(PHON)
        CheckRadioButton(hDlg, IDD_DEFAULT_KB,
            IDD_DEFAULT_KB + READ_LAYOUTS - 1,
            lpImeL->nReadLayout + IDD_DEFAULT_KB);
#endif
        hLayoutListBox = GetDlgItem(hDlg, IDD_LAYOUT_LIST);

        hIMC = ImmCreateContext();

        if (hIMC) {
            ImmSetOpenStatus(hIMC, FALSE);
            hOldIMC = ImmAssociateContext(hLayoutListBox, hIMC);
        }

        if (!hOldIMC) {
        } else if (!hIMC) {
        } else {
            LPINPUTCONTEXT lpIMC;
            POINT          ptPos;

            lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hOldIMC);
            if (!lpIMC) {
                goto ConfigDlgStatusPosOvr;
            }

            ptPos = lpIMC->ptStatusWndPos;

            ImmUnlockIMC(hOldIMC);

            ImmSetStatusWindowPos(hIMC, &ptPos);
        }

ConfigDlgStatusPosOvr:
        // put all reverse conversion hKL into this list
        ReverseConversionList(
#if defined(UNIIME)
            lpImeL,
#endif
            hLayoutListBox);

        if (lpImeL->fdwModeConfig & MODE_CONFIG_PREDICT) {
            CheckDlgButton(hDlg, IDD_PREDICT, BST_CHECKED);
        }

        if ( lpImeL->fdwModeConfig & MODE_CONFIG_BIG5ONLY ) {
            CheckDlgButton(hDlg, IDD_BIG5ONLY, BST_CHECKED);
        }

#if defined(WINAR30)
        if (lpImeL->fdwModeConfig & MODE_CONFIG_QUICK_KEY) {
            CheckDlgButton(hDlg, IDD_QUICK_KEY, BST_CHECKED);
        }
#endif
#endif
        SetWindowText(hDlg, lpImeL->szIMEName);

        return (TRUE);      // don't want to set focus to special control
    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:
            ChangeConfiguration(
#if defined(UNIIME)
                lpImeL,
#endif
                hDlg);
            // falling throgh ....

        case IDCANCEL:
#if !defined(ROMANIME)
            hLayoutListBox = GetDlgItem(hDlg, IDD_LAYOUT_LIST);

            hIMC = ImmGetContext(hLayoutListBox);
            ImmAssociateContext(hLayoutListBox, hOldIMC);

            ImmDestroyContext(hIMC);
#endif

            EndDialog(hDlg, FALSE);
            break;
        default:
            return (FALSE);
            break;
        }
        return (TRUE);
    default:
        return (FALSE);
    }

    return (TRUE);
}

#if !defined(WINIME) && !defined(UNICDIME) && !defined(ROMANIME)
/**********************************************************************/
/* SetUsrDic                                                         */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL PASCAL SetUsrDic(
#if defined(UNIIME)
    LPINSTDATAL lpInstL,
    LPIMEL      lpImeL,
#endif
    HWND        hWnd,
    LPCTSTR     szEudcDic,
    LPTSTR      szTitle,        // this buffer size must >= TITLE_BUF_SIZE
    LPTSTR      szMessage)      // this buffer size must >= MESSAGE_BUF_SIZE
{
    HANDLE hUsrDicFile, hUsrDicMem, hReadUsrDicMem;
    BOOL   fRet;
    DWORD  dwUsrDicSize;
    UINT   uRecLen, uReadLen, uWriteLen;
    UINT   uUsrDicSize;
    PSECURITY_ATTRIBUTES psa;

    psa = CreateSecurityAttributes();

    hUsrDicFile = CreateFile(szEudcDic, GENERIC_WRITE,
        FILE_SHARE_READ|FILE_SHARE_WRITE,
        psa, OPEN_ALWAYS,
        FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);

    if (hUsrDicFile == INVALID_HANDLE_VALUE) {
        FreeSecurityAttributes(psa);
        return (FALSE);
    }

    fRet = TRUE;

    if (GetLastError() == ERROR_ALREADY_EXISTS) {

        lstrcpy( szMessage, szEudcDic );

        fRet = VerifyEudcDic(
#if defined(UNIIME)
            lpImeL,
#endif
            hWnd, szTitle, szMessage);
    } else {
        LPUSRDICIMHDR lpUsrDicImHdr;
        DWORD         dwWriteBytes;

        lpUsrDicImHdr = (LPUSRDICIMHDR)GlobalAlloc(GPTR, sizeof(USRDICIMHDR));

        if (!lpUsrDicImHdr) {
            fRet = FALSE;
            goto SetUsrDicClose;
        }

        // write the header
        lpUsrDicImHdr->uHeaderSize = sizeof(USRDICIMHDR);
        lpUsrDicImHdr->idMajor = 1;
        lpUsrDicImHdr->ulTableCount = 0;
        lpUsrDicImHdr->cMethodKeySize = lpImeL->nMaxKey;
        lpUsrDicImHdr->uInfoSize = 13;
        lpUsrDicImHdr->idCP = NATIVE_CP;
        *(LPUNADWORD)lpUsrDicImHdr->idUserCharInfoSign = SIGN_CWIN;
        *(LPUNADWORD)((LPBYTE)lpUsrDicImHdr->idUserCharInfoSign +
            sizeof(DWORD)) = SIGN__TBL;

        *(LPMETHODNAME)lpUsrDicImHdr->achMethodName =
            *(LPMETHODNAME)lpImeL->szIMEName;

        WriteFile(hUsrDicFile, lpUsrDicImHdr, sizeof(USRDICIMHDR),
            &dwWriteBytes, NULL);

        GlobalFree((HANDLE)lpUsrDicImHdr);
    }

SetUsrDicClose:
    CloseHandle(hUsrDicFile);

    if (!fRet) {
        FreeSecurityAttributes(psa);
        return (fRet);
    }


    lstrcpy( lpImeL->szUsrDic, szEudcDic );

    SetUserSetting(
#if defined(UNIIME)
        lpImeL,
#endif
        szRegUserDic, REG_SZ, (LPBYTE)lpImeL->szUsrDic,
        lstrlen(lpImeL->szUsrDic) * sizeof(TCHAR));

    if (!lpImeL->szUsrDicMap[0]) {
        UINT  i;
        TCHAR szDirName[MAX_PATH];

        GetTempPath(sizeof(szDirName) / sizeof(TCHAR), szDirName);

        // we do not want to create a real file so we GetTickCount()
        i = (UINT)GetTickCount();

        if (!i) {
            i++;
        }

        GetTempFileName(szDirName, lpImeL->szUIClassName, i, szMessage);

        GetFileTitle(szMessage, lpImeL->szUsrDicMap,
            sizeof(lpImeL->szUsrDicMap) / sizeof(TCHAR));
    }

    hUsrDicFile = CreateFile(szEudcDic, GENERIC_READ,
        FILE_SHARE_READ|FILE_SHARE_WRITE,
        psa, OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);

    if (hUsrDicFile == INVALID_HANDLE_VALUE) {
        FreeSecurityAttributes(psa);
        return (FALSE);
    }

    uRecLen = lpImeL->nMaxKey + 4;
    uReadLen = lpImeL->nMaxKey + 2;
    uWriteLen = lpImeL->nSeqBytes + 2;

    dwUsrDicSize = GetFileSize(hUsrDicFile, (LPDWORD)NULL);
    uUsrDicSize = (UINT)(dwUsrDicSize - 256) / uRecLen * uWriteLen;

    // max EUDC chars
    hUsrDicMem = CreateFileMapping(INVALID_HANDLE_VALUE,
        psa, PAGE_READWRITE, 0, MAX_EUDC_CHARS * uWriteLen + 20,
        lpImeL->szUsrDicMap);

    if (!hUsrDicMem) {
        fRet = FALSE;
        goto SetUsrDicCloseRead;
    }

    if (lpInstL->hUsrDicMem) {
        CloseHandle(lpInstL->hUsrDicMem);
        lpInstL->hUsrDicMem = NULL;
    }

    lpInstL->hUsrDicMem = hUsrDicMem;

    fRet = ReadUsrDicToMem(
#if defined(UNIIME)
        lpInstL, lpImeL,
#endif
        hUsrDicFile, dwUsrDicSize, uUsrDicSize, uRecLen, uReadLen, uWriteLen);

    if (fRet) {
        hReadUsrDicMem = OpenFileMapping(FILE_MAP_READ, FALSE,
            lpImeL->szUsrDicMap);
    } else {
        hReadUsrDicMem = NULL;
        uUsrDicSize = 0;
    }

    CloseHandle(lpInstL->hUsrDicMem);
    lpInstL->hUsrDicMem = hReadUsrDicMem;
    lpImeL->uUsrDicSize = uUsrDicSize;

SetUsrDicCloseRead:
    CloseHandle(hUsrDicFile);
    FreeSecurityAttributes(psa);

    return (fRet);
}

/**********************************************************************/
/* UsrDicFileName                                                     */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL PASCAL UsrDicFileName(
#if defined(UNIIME)
    LPINSTDATAL lpInstL,
    LPIMEL      lpImeL,
#endif
    HWND        hWnd)
{

#if !defined(ROMANIME) && !defined(UNICDIME) && !defined(WINIME)

    TCHAR                szFileName[MAX_PATH];
    TCHAR                szTitle[TITLE_BUF_SIZE+1];
    TCHAR                szMessage[MESSAGE_BUF_SIZE+1];
    TCHAR                szIMEUserPath[MAX_PATH];
    PSECURITY_ATTRIBUTES psa = NULL;

    if ( lpImeL->szUsrDic[0] == TEXT('\0') ) {

//        psa = CreateSecurityAttributes();

        SHGetSpecialFolderPath(NULL, szIMEUserPath, CSIDL_APPDATA , FALSE);

        if ( szIMEUserPath[lstrlen(szIMEUserPath) - 1] == TEXT('\\') )
             szIMEUserPath[lstrlen(szIMEUserPath) - 1] = TEXT('\0');

        lstrcat(szIMEUserPath, TEXT("\\Microsoft") ); 

    // Because CreateDirectory( ) cannot create directory like \AA\BB, 
    // if AA and BB  both do not exist. It can create only one layer of 
    // directory each time. so we must call twice CreateDirectory( ) for 
    // \AA\BB

        if ( GetFileAttributes(szIMEUserPath) != FILE_ATTRIBUTE_DIRECTORY)
            CreateDirectory(szIMEUserPath, psa);

        lstrcat(szIMEUserPath, TEXT("\\IME") );

        if ( GetFileAttributes(szIMEUserPath) != FILE_ATTRIBUTE_DIRECTORY)
            CreateDirectory(szIMEUserPath, psa);

        lstrcat(szIMEUserPath, TEXT("\\") );
        lstrcat(szIMEUserPath, lpImeL->szUIClassName);
    
    //
    // Create the directory, so that CreateFile( ) can work fine later. 
    // ortherwise, if the directory does not exist, and you try to create a 
    // file under that dir,  CreateFile will return error.
    //

        if ( GetFileAttributes(szIMEUserPath) != FILE_ATTRIBUTE_DIRECTORY)
            CreateDirectory(szIMEUserPath, psa);
//        FreeSecurityAttributes(psa);

        lstrcpy(szFileName, szIMEUserPath);
        lstrcat(szFileName, TEXT("\\"));
        lstrcat(szFileName, lpImeL->szUIClassName);
        lstrcat(szFileName, TEXT(".TBL") );

    }

    return SetUsrDic(
#if defined(UNIIME)
        lpInstL, lpImeL,
#endif
        hWnd, szFileName, szTitle, szMessage);

#endif  //!defined(ROMANIME) && !defined(UNICDIME) && !defined(WINIME)

}
#endif

/**********************************************************************/
/* ImeConfigure() / UniImeConfigure()                                 */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
// configurate the IME setting
#if defined(UNIIME)
BOOL WINAPI UniImeConfigure(
    LPINSTDATAL lpInstL,
    LPIMEL      lpImeL,
#else
BOOL WINAPI ImeConfigure(
#endif
    HKL         hKL,            // hKL of this IME
    HWND        hAppWnd,        // the owner window
    DWORD       dwMode,         // mode of dialog
    LPVOID      lpData)         // the data depend on each mode
{
#if !defined(WINIME) && !defined(UNICDIME) && !defined(ROMANIME)
    BOOL fRet;
#endif

    switch (dwMode) {
    case IME_CONFIG_GENERAL:
        if (lpImeL->lConfigGeneral) {
            ResourceLocked(
#if defined(UNIIME)
                lpImeL,
#endif
                hAppWnd);
            return (FALSE);
        }

        InterlockedIncrement(&lpImeL->lConfigGeneral);

        if (lpImeL->lConfigGeneral > 1) {
            InterlockedDecrement(&lpImeL->lConfigGeneral);
            ResourceLocked(
#if defined(UNIIME)
                lpImeL,
#endif
                hAppWnd);
            return (FALSE);
        }

        DialogBoxParam(hInst, MAKEINTRESOURCE(IDDG_IME_CONFIG), hAppWnd,
            ConfigDlgProc, (LPARAM)lpInstL);

        InterlockedDecrement(&lpImeL->lConfigGeneral);
        break;

#if !defined(WINIME) && !defined(UNICDIME) && !defined(ROMANIME)
    case IME_CONFIG_SELECTDICTIONARY:
        if (lpImeL->lConfigSelectDic) {
            ResourceLocked(
#if defined(UNIIME)
                lpImeL,
#endif
                hAppWnd);
            return (FALSE);
        }

        InterlockedIncrement(&lpImeL->lConfigSelectDic);

        if (lpImeL->lConfigSelectDic != 1) {
            InterlockedDecrement(&lpImeL->lConfigSelectDic);
            ResourceLocked(
#if defined(UNIIME)
                lpImeL,
#endif
                hAppWnd);
            return (FALSE);
        }

        // currently, we can only select end user dictionary
        // because we do not multiple phrase prediction dictionary or
        // multiple phrase box.

        fRet = UsrDicFileName(
#if defined(UNIIME)
            lpInstL, lpImeL,
#endif
            hAppWnd);

        InterlockedDecrement(&lpImeL->lConfigSelectDic);

        return (fRet);
        break;
#endif

    default:
        return (FALSE);
        break;
    }
    return (TRUE);
}

#if !defined(WINIME) && !defined(UNICDIME) && !defined(ROMANIME)
/**********************************************************************/
/* Input2Sequence                                                     */
/* Return Value:                                                      */
/*      LOWORD - Internal Code, HIWORD - sequence code                */
/**********************************************************************/
LRESULT PASCAL Input2Sequence(
#if defined(UNIIME)
    LPIMEL lpImeL,
#endif
    DWORD  uVirtKey,
    LPBYTE lpSeqCode)
{
    UINT uCharCode;
    UINT uSeqCode;
    UINT uInternalCode;
    char cIndex;

    uVirtKey = LOWORD(uVirtKey);

    uCharCode = MapVirtualKey(uVirtKey, 2);

    if (uCharCode < ' ') {
        return (FALSE);
    } else if (uCharCode > 'z') {
        return (FALSE);
    } else {
    }

    uCharCode = bUpper[uCharCode - ' '];

#if defined(PHON)
    uCharCode = bStandardLayout[lpImeL->nReadLayout][uCharCode - ' '];
#endif

    if (lpImeL->fCompChar[(uCharCode - ' ') >> 4] &
        fMask[uCharCode & 0x000F]) {
    } else {
        return (FALSE);
    }

    uSeqCode = lpImeL->wChar2SeqTbl[uCharCode - ' '];

#if defined(PHON)
    cIndex = cIndexTable[uCharCode - ' '];

    if (*(lpSeqCode + cIndex)) {
        uSeqCode |= 0x4000;
    }

    {
        int i;

        for (i = 0; i < cIndex; i++) {
            if (*(lpSeqCode + i) == 0) {
                *(lpSeqCode + i) = 0xFF;
            }
        }
    }
#else
    for (cIndex = 0; cIndex < lpImeL->nMaxKey; cIndex++) {
        if (*(lpSeqCode + cIndex) == 0) {
            break;
        }
    }
#endif

    if (cIndex >= lpImeL->nMaxKey) {
        return (FALSE);
    } else if (cIndex == lpImeL->nMaxKey - 1) {
        uSeqCode |= 0x8000;
    } else if (uCharCode == ' ') {
        uSeqCode |= 0x8000;
    } else {
    }

    *(lpSeqCode + cIndex) = (BYTE)uSeqCode;

    uInternalCode = lpImeL->wSeq2CompTbl[(BYTE)uSeqCode];

#ifndef UNICODE
    uInternalCode = HIBYTE(uInternalCode) | (LOBYTE(uInternalCode) << 8);
#endif

    return MAKELRESULT(uInternalCode, uSeqCode);
}
#endif

/**********************************************************************/
/* ImeEscape() / UniImeEscape()                                       */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
#define IME_INPUTKEYTOSEQUENCE  0x22

// escape function of IMEs
#if defined(UNIIME)
LRESULT WINAPI UniImeEscape(
    LPINSTDATAL lpInstL,
    LPIMEL      lpImeL,
#else
LRESULT WINAPI ImeEscape(
#endif
    HIMC        hIMC,
    UINT        uSubFunc,
    LPVOID      lpData)
{
    LRESULT lRet;

    switch (uSubFunc) {
    case IME_ESC_QUERY_SUPPORT:
        if (!lpData) {
            return (FALSE);
        }

        switch (*(LPUINT)lpData) {
        case IME_ESC_QUERY_SUPPORT:
#if !defined(WINIME) && !defined(UNICDIME) && !defined(ROMANIME)
        case IME_ESC_SEQUENCE_TO_INTERNAL:
        case IME_ESC_GET_EUDC_DICTIONARY:
        case IME_ESC_SET_EUDC_DICTIONARY:
        case IME_INPUTKEYTOSEQUENCE:      // will not supported in next version
                                          // and not support 32 bit applications
#endif
        case IME_ESC_MAX_KEY:
        case IME_ESC_IME_NAME:
        case IME_ESC_SYNC_HOTKEY:
#ifndef HANDLE_PRIVATE_HOTKEY
        case IME_ESC_PRIVATE_HOTKEY:
#endif
            return (TRUE);
        default:
            return (FALSE);
        }
        break;
#if !defined(WINIME) && !defined(UNICDIME) && !defined(ROMANIME)
    case IME_ESC_SEQUENCE_TO_INTERNAL:
        if (!lpData) {
            return (FALSE);
        }

        if (*(LPDWORD)lpData > lpImeL->nSeqCode) {
            return (FALSE);
        }

        lRet = lpImeL->wSeq2CompTbl[*(LPDWORD)lpData];

#ifndef UNICODE
        lRet = HIBYTE(lRet) | (LOBYTE(lRet) << 8);
#endif
        return (lRet);
    case IME_ESC_GET_EUDC_DICTIONARY:
        if (!lpData) {
            return (FALSE);
        }

        if (lpImeL->szUsrDic[0] == '\0') {
            *(LPTSTR)lpData = '\0';
            return (TRUE);
        }

        lstrcpy(lpData, lpImeL->szUsrDic);
        return (TRUE);
    case IME_ESC_SET_EUDC_DICTIONARY:
        {
            TCHAR szTitle[TITLE_BUF_SIZE];
            TCHAR szMessage[MESSAGE_BUF_SIZE];

            return SetUsrDic(
#if defined(UNIIME)
                lpInstL, lpImeL,
#endif
                NULL, lpData, szTitle, szMessage);
        }
    case IME_INPUTKEYTOSEQUENCE:
        return Input2Sequence(
#if defined(UNIIME)
            lpImeL,
#endif
            *(LPDWORD)lpData, *(LPBYTE FAR *)((LPBYTE)lpData + sizeof(DWORD)));
#endif
    case IME_ESC_MAX_KEY:
        return (lpImeL->nMaxKey);
    case IME_ESC_IME_NAME:
        if (!lpData) {
            return (FALSE);
        }

        *(LPMETHODNAME)lpData = *(LPMETHODNAME)lpImeL->szIMEName;

        // append a NULL terminator
        *(LPTSTR)((LPBYTE)lpData + sizeof(METHODNAME)) = '\0';
        return (TRUE);
    case IME_ESC_SYNC_HOTKEY:
#ifdef HANDLE_PRIVATE_HOTKEY
        {
            UINT i;

            for (i = 0; i < NUM_OF_IME_HOTKEYS; i++) {
                BOOL fRet;

                fRet = ImmGetHotKey(IME_ITHOTKEY_RESEND_RESULTSTR + i,
                    &sImeG.uModifiers[i], &sImeG.uVKey[i], NULL);

                if (!fRet) {
                    sImeG.uVKey[i] = 0;
                    sImeG.uModifiers[i] = 0;
                }
            }
        }
#endif
        return (TRUE);
#ifndef HANDLE_PRIVATE_HOTKEY 
    case IME_ESC_PRIVATE_HOTKEY: {

        LPINPUTCONTEXT      lpIMC;
        lRet = FALSE;

        //
        // early return for invalid input context
        //
        if ( (lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC)) == NULL ) {
            return (FALSE);
        }

        //
        // those private hotkeys are effective only in NATIVE mode
        //
        if ((lpIMC->fdwConversion & (IME_CMODE_NATIVE|IME_CMODE_EUDC|
            IME_CMODE_NOCONVERSION|IME_CMODE_CHARCODE)) == IME_CMODE_NATIVE) {

            LPPRIVCONTEXT       lpImcP;
            LPCOMPOSITIONSTRING lpCompStr;

            if ( (lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate)) == NULL ) {
                ImmUnlockIMC(hIMC);
                return (FALSE);
            }
            
            switch (*(LPUINT)lpData) {
            case IME_ITHOTKEY_RESEND_RESULTSTR:             //  0x200
                lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
                if ( lpCompStr != NULL ) {
                    if (lpCompStr->dwResultStrLen) {
                        lpImcP->fdwImeMsg |=  MSG_COMPOSITION;
                        lpImcP->dwCompChar = 0;
                        lpImcP->fdwGcsFlag |= GCS_RESULTREAD|GCS_RESULT;
                        GenerateMessage(hIMC, lpIMC, lpImcP);
                        lRet = TRUE;
                    }
                    ImmUnlockIMCC(lpIMC->hCompStr);
                }          
                break;

            case IME_ITHOTKEY_PREVIOUS_COMPOSITION:          //  0x201
                lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
                if ( lpCompStr == NULL ) {
                    break;
                }
                if (lpCompStr->dwResultReadStrLen) {
                    DWORD dwResultReadStrLen;
                    TCHAR szReading[16];

                    dwResultReadStrLen = lpCompStr->dwResultReadStrLen;

                    if (dwResultReadStrLen > lpImeL->nMaxKey*sizeof(WCHAR)/sizeof(TCHAR)) {
                        dwResultReadStrLen = lpImeL->nMaxKey*sizeof(WCHAR)/sizeof(TCHAR);
                    }
                    CopyMemory(szReading, (LPBYTE)lpCompStr +
                        lpCompStr->dwResultReadStrOffset,
                        dwResultReadStrLen * sizeof(TCHAR));

                    // NULL termainator
                    szReading[dwResultReadStrLen] = TEXT('\0');
#if defined(UNIIME)
                    UniImeSetCompositionString(lpInstL, lpImeL, hIMC, SCS_SETSTR,
                        NULL, 0, szReading, dwResultReadStrLen * sizeof(TCHAR));
#else
                    ImeSetCompositionString(hIMC, SCS_SETSTR, NULL, 0, szReading,
                        dwResultReadStrLen * sizeof(TCHAR));
#endif
                    GenerateMessage(hIMC, lpIMC, lpImcP);
                    lRet = TRUE;
                }
                ImmUnlockIMCC(lpIMC->hCompStr);
                break; 

            case IME_ITHOTKEY_UISTYLE_TOGGLE:                //  0x202
                lpImeL->fdwModeConfig ^= MODE_CONFIG_OFF_CARET_UI;

                SetUserSetting(
#if defined(UNIIME)
                    lpImeL,
#endif
                    szRegModeConfig, REG_DWORD, (LPBYTE)&lpImeL->fdwModeConfig,
                    sizeof(lpImeL->fdwModeConfig));

                InitImeUIData(lpImeL);

                lpImcP->fdwImeMsg |= MSG_IMN_TOGGLE_UI;

                GenerateMessage(hIMC, lpIMC, lpImcP);
                lRet = TRUE;
                break;

            default:
                break;
            }

            ImmUnlockIMCC(lpIMC->hPrivate);
            if ( ! lRet ) {
                MessageBeep((UINT)-1);
            }
        } 
        ImmUnlockIMC(hIMC);
        return (lRet);
    }
#endif // HANDLE_PRIVATE_HOTKEY 

    default:
        return (FALSE);
    }

    return (lRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\convlist.c ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    CONVLIST.c
    
++*/

#include <windows.h>
#include <immdev.h>
#include "imeattr.h"
#include "imedefs.h"
#if defined(UNIIME)
#include "uniime.h"
#endif

#if !defined(ROMANIME)
/**********************************************************************/
/* Conversion()                                                       */
/**********************************************************************/
DWORD PASCAL Conversion(
#if defined(UNIIME)
    LPINSTDATAL     lpInstL,
    LPIMEL          lpImeL,
#endif
    LPCTSTR         lpszReading,
    LPCANDIDATELIST lpCandList,
    DWORD           dwBufLen)
{
    UINT        uMaxCand;
    DWORD       dwSize =        // similar to ClearCand
        // header length
        sizeof(CANDIDATELIST) +
        // candidate string pointers
        sizeof(DWORD) * MAXCAND +
        // string plus NULL terminator
        (sizeof(WCHAR) + sizeof(TCHAR)) * MAXCAND;
    DWORD       dwPattern;
    PRIVCONTEXT ImcP;
#if !defined(WINIME) && !defined(UNICDIME)
    BOOL        fNeedUnload;
#endif

    if (!dwBufLen) {
        return (dwSize);
    }

    uMaxCand = dwBufLen - sizeof(CANDIDATELIST);

    uMaxCand /= sizeof(DWORD) + sizeof(WCHAR) + sizeof(TCHAR);
    if (!uMaxCand) {
        // can not even put one string
        return (0);
    }

    lpCandList->dwSize = dwSize;
    lpCandList->dwStyle = IME_CAND_READ;    // candidate having same reading
    lpCandList->dwCount = 0;
    lpCandList->dwSelection = 0;
    lpCandList->dwPageStart = 0;
    lpCandList->dwPageSize = CANDPERPAGE;
    lpCandList->dwOffset[0] = sizeof(CANDIDATELIST) + sizeof(DWORD) *
        (uMaxCand - 1);

    dwPattern = ReadingToPattern(
#if defined(UNIIME)
        lpImeL,
#endif
        lpszReading, ImcP.bSeq, TRUE);

    if (!dwPattern) {
        return (0);
    }

#if !defined(WINIME) && !defined(UNICDIME)
    if (lpInstL->fdwTblLoad == TBL_LOADED) {
        fNeedUnload = FALSE;
    } else if (lpInstL->fdwTblLoad == TBL_NOTLOADED) {
        LoadTable(lpInstL, lpImeL);
        fNeedUnload = TRUE;
    } else {
       return (0);
    }
#endif

    if (!ConvertSeqCode2Pattern(
#if defined(UNIIME)
        lpImeL,
#endif
        ImcP.bSeq, &ImcP)) {
        return (0);
    }

    SearchTbl(
#if defined(UNIIME)
        lpImeL,
#endif
        0, lpCandList, &ImcP);

#if defined(WINAR30)
    if (!lpCandList->dwCount) {
        SearchTbl(3, lpCandList, &ImcP);
    }
#endif

#if !defined(WINIME) && !defined(UNICDIME)
    if (lpInstL->hUsrDicMem) {
        SearchUsrDic(
#if defined(UNIIME)
            lpImeL,
#endif
            lpCandList, &ImcP);
    }

    if (fNeedUnload) {
        FreeTable(lpInstL);
    }
#endif

    return (dwSize);
}

/**********************************************************************/
/* SearchOffset()                                                     */
/* Return Value :                                                     */
/*      the offset in table file which include this uOffset           */
/**********************************************************************/
UINT PASCAL SearchOffset(
    LPBYTE lpTbl,
    UINT   uTblSize,
    UINT   uOffset)
{
    int    iLo, iMid, iHi;
    LPWORD lpwPtr;

    iLo = 0;
    iHi = uTblSize / sizeof(WORD);
    iMid = (iLo + iHi) / 2;

    // binary search
    for (; iLo <= iHi; ) {
        lpwPtr = (LPWORD)lpTbl + iMid;

        if (uOffset > *lpwPtr) {
            iLo = iMid + 1;
        } else if (uOffset < *lpwPtr) {
            iHi = iMid - 1;
        } else {
            break;
        }

        iMid = (iLo + iHi) / 2;
    }

    if (iMid > 0) {
        iLo = iMid - 1;
    } else {
        iLo = 0;
    }

    iHi = uTblSize / sizeof(WORD);

    lpwPtr = (LPWORD)lpTbl + iLo;

    for (; iLo < iHi; iLo++, lpwPtr++) {
        if (*lpwPtr > uOffset) {
            return (iLo - 1);
        }
    }

    return (0);
}

/**********************************************************************/
/* ReverseConversion()                                                */
/**********************************************************************/
#if defined(PHON)
typedef struct {
    BYTE szTmpBuf[sizeof(WORD) * 4 + sizeof(TCHAR)];
} PHONREVERSEBUF;

typedef PHONREVERSEBUF FAR *LPPHONREVERSEBUF;
#endif

DWORD PASCAL ReverseConversion(
#if defined(UNIIME)
    LPINSTDATAL     lpInstL,
    LPIMEL          lpImeL,
#endif
    UINT            uCode,
    LPCANDIDATELIST lpCandList,
    DWORD           dwBufLen)
{
    UINT   uMaxCand;
    DWORD  dwSize =         // similar to ClearCand
        // header length
        sizeof(CANDIDATELIST) +
        // candidate string pointers
        sizeof(DWORD) * MAX_COMP +
        // string plus NULL terminator
#if defined(QUICK)
        (sizeof(WCHAR) * 2 + sizeof(TCHAR)) * MAX_COMP;
#elif defined(WINIME) || defined(UNICDIME)
        (sizeof(WCHAR) * lpImeL->nMaxKey + sizeof(TCHAR));
#else
        (sizeof(WCHAR) * lpImeL->nMaxKey + sizeof(TCHAR)) * MAX_COMP;
#endif

#if defined(WINIME) || defined(UNICDIME)
    UINT   uTmpCode;
    int    i;
#else
    BOOL   fNeedUnload;
    HANDLE hTbl;
    LPBYTE lpTbl, lpStart, lpEnd;
#endif
#if defined(CHAJEI) || defined(PHON) || defined(QUICK)
    HANDLE hTbl0;
    LPBYTE lpTbl0;
#endif
#if defined(CHAJEI) || defined(PHON)
    HANDLE hTbl1;
    LPBYTE lpTbl1;
#endif

    if (!dwBufLen) {
        return (dwSize);
    }

    uMaxCand = dwBufLen - sizeof(CANDIDATELIST);

#if defined(QUICK)
    uMaxCand /= sizeof(DWORD) +
        (sizeof(WCHAR) * 2 + sizeof(TCHAR));
#else
    uMaxCand /= sizeof(DWORD) +
        (sizeof(WCHAR) * lpImeL->nMaxKey + sizeof(TCHAR));
#endif
    if (uMaxCand == 0) {
        // can not put one string
        return (0);
    }

    lpCandList->dwSize = sizeof(CANDIDATELIST) +
        sizeof(DWORD) * uMaxCand +
#if defined(QUICK)
        (sizeof(WCHAR) * 2 + sizeof(TCHAR)) * uMaxCand;
#elif defined(WINIME) || defined(UNICDIME)
        (sizeof(WCHAR) * lpImeL->nMaxKey + sizeof(TCHAR));
#else
        (sizeof(WCHAR) * lpImeL->nMaxKey + sizeof(TCHAR)) * uMaxCand;
#endif
    lpCandList->dwStyle = IME_CAND_READ;
    lpCandList->dwCount = 0;
    lpCandList->dwSelection = 0;
    lpCandList->dwPageSize = CANDPERPAGE;
    lpCandList->dwOffset[0] = sizeof(CANDIDATELIST) + sizeof(DWORD) *
        (uMaxCand - 1);

#if defined(WINIME) || defined(UNICDIME)
#if defined(WINIME) && defined(UNICODE)
    {
        int  iChars;
        CHAR szCode[4];

        iChars = WideCharToMultiByte(sImeG.uAnsiCodePage, WC_COMPOSITECHECK,
            (LPCWSTR)&uCode, 1, szCode, sizeof(szCode), NULL, NULL);

        if (iChars >= 2) {
            uTmpCode = ((UINT)(BYTE)szCode[0] << 8) | (BYTE)szCode[1];
        } else {
            uTmpCode = (BYTE)szCode[0];
        }

        if (uCode == 0x003F) {
        } else if (uTmpCode == 0x003F) {
            // no cooresponding BIG5 code
            return (0);
        } else {
        }

        uCode = uTmpCode;
    }
#endif

    uTmpCode = uCode;

    for (i = lpImeL->nMaxKey - 1; i >= 0; i--) {
        UINT uCompChar;

        uCompChar = lpImeL->wSeq2CompTbl[(uTmpCode & 0xF) + 1];

        *(LPWSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[
            lpCandList->dwCount] + sizeof(WCHAR) * i) = (WCHAR)uCompChar;

        uTmpCode >>= 4;
    }

    // null terminator
    *(LPTSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[
        lpCandList->dwCount] + sizeof(WCHAR) * lpImeL->nMaxKey) = '\0';

    // string count ++
    lpCandList->dwCount++;
#else
    if (lpInstL->fdwTblLoad == TBL_LOADED) {
        fNeedUnload = FALSE;
    } else if (lpInstL->fdwTblLoad == TBL_NOTLOADED) {
        LoadTable(lpInstL, lpImeL);
        fNeedUnload = TRUE;
    } else {
       return (0);
    }

#if defined(CHAJEI) || defined(PHON) || defined(QUICK)
    hTbl = OpenFileMapping(FILE_MAP_READ, FALSE, lpImeL->szTblFile[2]);
#else
    hTbl = OpenFileMapping(FILE_MAP_READ, FALSE, lpImeL->szTblFile[0]);
#endif
    if (!hTbl) {
        return (0);
    }

    lpTbl = MapViewOfFile(hTbl, FILE_MAP_READ, 0, 0, 0);
    if (!lpTbl) {
        dwSize = 0;
        goto RevConvCloseCodeTbl;
    }

#if defined(CHAJEI) || defined(PHON) || defined(QUICK)
    hTbl0 = OpenFileMapping(FILE_MAP_READ, FALSE, lpImeL->szTblFile[0]);
    if (!hTbl0) {
        dwSize = 0;
        goto RevConvUnmapCodeTbl;
    }

    lpTbl0 = MapViewOfFile(hTbl0, FILE_MAP_READ, 0, 0, 0);
    if (!lpTbl0) {
        dwSize = 0;
        goto RevConvCloseTbl0;
    }
#endif

#if defined(CHAJEI) || defined(PHON)
    hTbl1 = OpenFileMapping(FILE_MAP_READ, FALSE, lpImeL->szTblFile[1]);
    if (!hTbl1) {
        dwSize = 0;
        goto RevConvUnmapTbl0;
    }

    lpTbl1 = MapViewOfFile(hTbl1, FILE_MAP_READ, 0, 0, 0);
    if (!lpTbl1) {
        dwSize = 0;
        goto RevConvCloseTbl1;
    }
#endif

#if defined(CHAJEI) || defined(PHON) || defined(QUICK)
    lpStart = lpTbl;
    lpEnd = lpTbl + lpImeL->uTblSize[2];
#else
    lpStart = lpTbl + lpImeL->nSeqBytes;
    lpEnd = lpTbl + lpImeL->uTblSize[0];
#endif

#if defined(CHAJEI) || defined(PHON) || defined(QUICK)
    for (; lpStart < lpEnd; lpStart += sizeof(WORD)) {
#else
    for (; lpStart < lpEnd; lpStart += lpImeL->nSeqBytes + sizeof(WORD)) {
#endif
        DWORD dwPattern;
        int   i;
#if defined(CHAJEI) || defined(PHON) || defined(QUICK)
        UINT  uOffset;
#endif
#if defined(CHAJEI) || defined(QUICK)
        DWORD dwSeqA1, dwSeqA5;
#endif
#if defined(PHON)
        UINT  uPhoneticCode;
#endif

#if defined(PHON)
        uPhoneticCode = *(LPUNAWORD)lpStart;

#ifdef UNICODE
        if (IsValidCode(uPhoneticCode)) {
            if (uPhoneticCode != uCode) {
                continue;
            }
        } else {
            if (InverseEncode(uPhoneticCode) != uCode) {
                continue;
            }
        }
#else
        if ((uPhoneticCode | 0x8000) != uCode) {
            continue;
        }
#endif
#else
        if (*(LPUNAWORD)lpStart != uCode) {
            continue;
        }
#endif

        // find the code
#if defined(CHAJEI) || defined(QUICK)
        uOffset = SearchOffset(lpTbl0, lpImeL->uTblSize[0],
            (UINT)(lpStart - lpTbl) / sizeof(WORD));
        dwSeqA1 = uOffset / 27;         // seq code of A1
        dwSeqA5 = uOffset % 27;         // seq code of A5
#endif
#if defined(PHON)
        uOffset = SearchOffset(lpTbl1, lpImeL->uTblSize[1],
            (UINT)(lpStart - lpTbl) / sizeof(WORD));
#endif

#if defined(CHAJEI)
        // pattern of A234
        dwPattern = *(LPWORD)(lpTbl1 + (lpStart - lpTbl)) << lpImeL->nSeqBits;
        // sequence code of A1
        dwPattern |= dwSeqA1 << (lpImeL->nSeqBits * 4);
        // test if 0 for A234 pattern
        dwSeqA1 = lpImeL->dwSeqMask << (lpImeL->nSeqBits * 3);

        // sequence code of A5
        for (i = 1; i < lpImeL->nMaxKey; i++) {
            if (!(dwPattern & dwSeqA1)) {
                dwPattern |= dwSeqA5 <<
                    (lpImeL->nSeqBits * (lpImeL->nMaxKey - i - 1));
                break;
            } else {
                dwSeqA1 >>= lpImeL->nSeqBits;
            }
        }
#elif defined(PHON)
        dwPattern = *(LPUNADWORD)(lpTbl0 + uOffset * lpImeL->nSeqBytes) &
            lpImeL->dwPatternMask;
#elif defined(QUICK)
        dwPattern = (DWORD)dwSeqA1 << lpImeL->nSeqBits;
        dwPattern |= dwSeqA5;
#else
        dwPattern = *(LPUNADWORD)(lpStart - lpImeL->nSeqBytes) &
            lpImeL->dwPatternMask;
#endif

#if defined(QUICK)
        for (i = 2 - 1; i >= 0; i--) {
#else
        for (i = lpImeL->nMaxKey - 1; i >= 0; i--) {
#endif
            WORD wCompChar;

            wCompChar = lpImeL->wSeq2CompTbl[dwPattern & lpImeL->dwSeqMask];

            *(LPUNAWORD)((LPBYTE)lpCandList + lpCandList->dwOffset[
                lpCandList->dwCount] + sizeof(WORD) * i) = wCompChar;

            dwPattern >>= lpImeL->nSeqBits;
        }

        // null terminator
#if defined(QUICK)
        *(LPTSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[
            lpCandList->dwCount] + sizeof(WCHAR) * 2) = '\0';
#else
        *(LPTSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[
            lpCandList->dwCount] + sizeof(WCHAR) * lpImeL->nMaxKey) = '\0';
#endif

#if defined(PHON)
        if (!lpCandList->dwCount) {
#ifdef UNICODE
        } else if (IsValidCode(uPhoneticCode)) {
#else
        } else if (uPhoneticCode & 0x8000) {
#endif
            PHONREVERSEBUF phTmpBuf;

            phTmpBuf = *(LPPHONREVERSEBUF)((LPBYTE)
                lpCandList + lpCandList->dwOffset[lpCandList->dwCount]);

            *(LPPHONREVERSEBUF)((LPBYTE)lpCandList +
                lpCandList->dwOffset[lpCandList->dwCount]) =
                *(LPPHONREVERSEBUF)((LPBYTE)lpCandList +
                lpCandList->dwOffset[0]);

            *(LPPHONREVERSEBUF)((LPBYTE)lpCandList +
                lpCandList->dwOffset[0]) = phTmpBuf;
        } else {
        }
#endif

        // string count ++
        lpCandList->dwCount++;

#if defined(CHAJEI) || defined(WINAR30) || defined(DAYI)
        // do not need to search more canidate
        break;
#endif

        if (lpCandList->dwCount >= (DWORD)uMaxCand) {
            break;
        }

#if defined(QUICK)
        lpCandList->dwOffset[lpCandList->dwCount] =
            lpCandList->dwOffset[lpCandList->dwCount - 1] +
            sizeof(WCHAR) * 2 + sizeof(TCHAR);
#else
        lpCandList->dwOffset[lpCandList->dwCount] =
            lpCandList->dwOffset[lpCandList->dwCount - 1] +
            sizeof(WCHAR) * lpImeL->nMaxKey + sizeof(TCHAR);
#endif
    }

    if (!lpCandList->dwCount) {
        dwSize = 0;
    }

#if defined(CHAJEI) || defined(PHON)
    UnmapViewOfFile(lpTbl1);

RevConvCloseTbl1:
    CloseHandle(hTbl1);

RevConvUnmapTbl0:
#endif

#if defined(CHAJEI) || defined(PHON) || defined(QUICK)
    UnmapViewOfFile(lpTbl0);

RevConvCloseTbl0:
    CloseHandle(hTbl0);

RevConvUnmapCodeTbl:
#endif

    UnmapViewOfFile(lpTbl);

RevConvCloseCodeTbl:
    CloseHandle(hTbl);

    if (fNeedUnload) {
        FreeTable(lpInstL);
    }
#endif

    return (dwSize);
}
#endif

/**********************************************************************/
/* ImeConversionList() / UniImeConversionList()                       */
/**********************************************************************/
#if defined(UNIIME)
DWORD WINAPI UniImeConversionList(
    LPINSTDATAL     lpInstL,
    LPIMEL          lpImeL,
#else
DWORD WINAPI ImeConversionList(
#endif
    HIMC            hIMC,
    LPCTSTR         lpszSrc,
    LPCANDIDATELIST lpCandList,
    DWORD           dwBufLen,
    UINT            uFlag)
{
#if defined(ROMANIME)
    return (0);
#else
    UINT uCode;

    if (!dwBufLen) {
    } else if (!lpszSrc) {
        return (0);
    } else if (!*lpszSrc) {
        return (0);
    } else if (!lpCandList) {
        return (0);
    } else if (dwBufLen <= sizeof(CANDIDATELIST)) {
        // buffer size can not even put the header information
        return (0);
    } else {
    }

    switch (uFlag) {
    case GCL_CONVERSION:
        return Conversion(
#if defined(UNIIME)
            lpInstL, lpImeL,
#endif
            lpszSrc, lpCandList, dwBufLen);
        break;
    case GCL_REVERSECONVERSION:
        if (!dwBufLen) {
            return ReverseConversion(
#if defined(UNIIME)
                lpInstL, lpImeL,
#endif
                0, lpCandList, dwBufLen);
        }

        // only support one DBCS char reverse conversion
        if (*(LPTSTR)((LPBYTE)lpszSrc + sizeof(WORD)) != '\0') {
            return (0);
        }

        uCode = *(LPUNAWORD)lpszSrc;

#ifndef UNICODE
        // swap lead byte & second byte, UNICODE don't need it
        uCode = HIBYTE(uCode) | (LOBYTE(uCode) << 8);
#endif

        return ReverseConversion(
#if defined(UNIIME)
            lpInstL, lpImeL,
#endif
            uCode, lpCandList, dwBufLen);
        break;
    case GCL_REVERSE_LENGTH:
        return sizeof(WCHAR);
        break;
    default:
        return (0);
        break;
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\compui.c ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    COMPUI.c
    
++*/

#include <windows.h>
#include <immdev.h>
#include "imeattr.h"
#include "imedefs.h"
#if defined(UNIIME)
#include "uniime.h"
#endif

#if !defined(ROMANIME)
/**********************************************************************/
/* GetCompWnd                                                         */
/* Return Value :                                                     */
/*      window handle of composition                                  */
/**********************************************************************/
HWND PASCAL GetCompWnd(
    HWND hUIWnd)                // UI window
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;
    HWND     hCompWnd;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {          // can not darw candidate window
        return (HWND)NULL;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw candidate window
        return (HWND)NULL;
    }

    hCompWnd = lpUIPrivate->hCompWnd;

    GlobalUnlock(hUIPrivate);
    return (hCompWnd);
}

/**********************************************************************/
/* GetNearCaretPosition()                                             */
/**********************************************************************/
void PASCAL GetNearCaretPosition(   // decide a near caret position according
                                    // to the caret position
#if defined(UNIIME)
    LPIMEL  lpImeL,
#endif
    LPPOINT lpptFont,
    UINT    uEsc,
    UINT    uRot,
    LPPOINT lpptCaret,
    LPPOINT lpptNearCaret,
    BOOL    fFlags)
{
    LONG lFontSize;
    LONG xWidthUI, yHeightUI, xBorder, yBorder;
    RECT rcWorkArea;

#ifdef IDEBUG
    _DebugOut(DEB_WARNING, "caret position, x - %d, y - %d",
        lpptCaret->x, lpptCaret->y);
#endif
    if ((uEsc + uRot) & 0x0001) {
        lFontSize = lpptFont->x;
    } else {
        lFontSize = lpptFont->y;
    }

    if (fFlags & NEAR_CARET_CANDIDATE) {
        xWidthUI = lpImeL->xCandWi;
        yHeightUI = lpImeL->yCandHi;
        xBorder = lpImeL->cxCandBorder;
        yBorder = lpImeL->cyCandBorder;
    } else {
        xWidthUI = lpImeL->xCompWi;
        yHeightUI = lpImeL->yCompHi;
        xBorder = lpImeL->cxCompBorder;
        yBorder = lpImeL->cyCompBorder;
    }

    if (fFlags & NEAR_CARET_FIRST_TIME) {
        lpptNearCaret->x = lpptCaret->x +
            lFontSize * ncUIEsc[uEsc].iLogFontFacX +
            sImeG.iPara * ncUIEsc[uEsc].iParaFacX +
            sImeG.iPerp * ncUIEsc[uEsc].iPerpFacX;

        if (ptInputEsc[uEsc].x >= 0) {
            lpptNearCaret->x += xBorder * 2;
        } else {
            lpptNearCaret->x -= xWidthUI - xBorder * 2;
        }

        lpptNearCaret->y = lpptCaret->y +
            lFontSize * ncUIEsc[uEsc].iLogFontFacY +
            sImeG.iPara * ncUIEsc[uEsc].iParaFacY +
            sImeG.iPerp * ncUIEsc[uEsc].iPerpFacY;

        if (ptInputEsc[uEsc].y >= 0) {
            lpptNearCaret->y += yBorder * 2;
        } else {
            lpptNearCaret->y -= yHeightUI - yBorder * 2;
        }
    } else {
        lpptNearCaret->x = lpptCaret->x +
            lFontSize * ncAltUIEsc[uEsc].iLogFontFacX +
            sImeG.iPara * ncAltUIEsc[uEsc].iParaFacX +
            sImeG.iPerp * ncAltUIEsc[uEsc].iPerpFacX;

        if (ptAltInputEsc[uEsc].x >= 0) {
            lpptNearCaret->x += xBorder * 2;
        } else {
            lpptNearCaret->x -= xWidthUI - xBorder * 2;
        }

        lpptNearCaret->y = lpptCaret->y +
            lFontSize * ncAltUIEsc[uEsc].iLogFontFacY +
            sImeG.iPara * ncAltUIEsc[uEsc].iParaFacY +
            sImeG.iPerp * ncAltUIEsc[uEsc].iPerpFacY;

        if (ptAltInputEsc[uEsc].y >= 0) {
            lpptNearCaret->y += yBorder * 2;
        } else {
            lpptNearCaret->y -= yHeightUI - yBorder * 2;
        }
    }

#if 1 // MultiMonitor
    rcWorkArea = ImeMonitorWorkAreaFromPoint(*lpptCaret);
#else
    rcWorkArea = sImeG.rcWorkArea;
#endif

    if (lpptNearCaret->x < rcWorkArea.left) {
        lpptNearCaret->x = rcWorkArea.left;
    } else if (lpptNearCaret->x + xWidthUI > rcWorkArea.right) {
        lpptNearCaret->x = rcWorkArea.right - xWidthUI;
    } else {
    }

    if (lpptNearCaret->y < rcWorkArea.top) {
        lpptNearCaret->y = rcWorkArea.top;
    } else if (lpptNearCaret->y + yHeightUI > rcWorkArea.bottom) {
        lpptNearCaret->y = rcWorkArea.bottom - yHeightUI;
    } else {
    }

#ifdef IDEBUG
    _DebugOut(DEB_WARNING, "Near caret position, x - %d, y - %d",
        lpptNearCaret->x, lpptNearCaret->y);
#endif

    return;
}

/**********************************************************************/
/* FitInLazyOperation()                                               */
/* Return Value :                                                     */
/*      TRUE or FALSE                                                 */
/**********************************************************************/
BOOL PASCAL FitInLazyOperation( // fit in lazy operation or not
#if defined(UNIIME)
    LPIMEL  lpImeL,
#endif
    LPPOINT lpptOrg,
    LPPOINT lpptNearCaret,      // the suggested near caret position
    LPRECT  lprcInputRect,
    UINT    uEsc)
{
    POINT ptDelta, ptTol;
    RECT  rcUIRect, rcInterRect;

    ptDelta.x = lpptOrg->x - lpptNearCaret->x;

    ptDelta.x = (ptDelta.x >= 0) ? ptDelta.x : -ptDelta.x;

    ptTol.x = sImeG.iParaTol * ncUIEsc[uEsc].iParaFacX +
        sImeG.iPerpTol * ncUIEsc[uEsc].iPerpFacX;

    ptTol.x = (ptTol.x >= 0) ? ptTol.x : -ptTol.x;

    if (ptDelta.x > ptTol.x) {
        return (FALSE);
    }

    ptDelta.y = lpptOrg->y - lpptNearCaret->y;

    ptDelta.y = (ptDelta.y >= 0) ? ptDelta.y : -ptDelta.y;

    ptTol.y = sImeG.iParaTol * ncUIEsc[uEsc].iParaFacY +
        sImeG.iPerpTol * ncUIEsc[uEsc].iPerpFacY;

    ptTol.y = (ptTol.y >= 0) ? ptTol.y : -ptTol.y;

    if (ptDelta.y > ptTol.y) {
        return (FALSE);
    }

    // build up the UI rectangle (composition window)
    rcUIRect.left = lpptOrg->x;
    rcUIRect.top = lpptOrg->y;
    rcUIRect.right = rcUIRect.left + lpImeL->xCompWi;
    rcUIRect.bottom = rcUIRect.top + lpImeL->yCompHi;

    if (IntersectRect(&rcInterRect, &rcUIRect, lprcInputRect)) {
        return (FALSE);
    }

    return (TRUE);
}

/**********************************************************************/
/* AdjustCompPosition()                                               */
/* Return Value :                                                     */
/*      the position of composition window is changed or not          */
/**********************************************************************/
BOOL PASCAL AdjustCompPosition(         // IME adjust position according to
                                        // composition form
#if defined(UNIIME)
    LPIMEL         lpImeL,
#endif
    LPINPUTCONTEXT lpIMC,
    LPPOINT        lpptOrg,             // original composition window
                                        // and final position
    LPPOINT        lpptNew)             // new expect position
{
    POINT ptNearCaret, ptOldNearCaret, ptCompWnd;
    UINT  uEsc, uRot;
    RECT  rcUIRect, rcInputRect, rcInterRect;
    POINT ptFont;

#ifdef IDEBUG
    _DebugOut(DEB_WARNING, "Original Position, x - %d, y - %d",
        lpptOrg->x, lpptOrg->y);
    _DebugOut(DEB_WARNING, "New Position, x - %d, y - %d",
        lpptNew->x, lpptNew->y);
#endif
    // we need to adjust according to font attribute
    if (lpIMC->lfFont.A.lfWidth > 0) {
        ptFont.x = lpIMC->lfFont.A.lfWidth * 2;
    } else if (lpIMC->lfFont.A.lfWidth < 0) {
        ptFont.x = -lpIMC->lfFont.A.lfWidth * 2;
    } else if (lpIMC->lfFont.A.lfHeight > 0) {
        ptFont.x = lpIMC->lfFont.A.lfHeight;
    } else if (lpIMC->lfFont.A.lfHeight < 0) {
        ptFont.x = -lpIMC->lfFont.A.lfHeight;
    } else {
        ptFont.x = lpImeL->yCompHi;
    }

    if (lpIMC->lfFont.A.lfHeight > 0) {
        ptFont.y = lpIMC->lfFont.A.lfHeight;
    } else if (lpIMC->lfFont.A.lfHeight < 0) {
        ptFont.y = -lpIMC->lfFont.A.lfHeight;
    } else {
        ptFont.y = ptFont.x;
    }
#ifdef IDEBUG
    _DebugOut(DEB_WARNING, "All positve, x - %d, y - %d",
        ptFont.x, ptFont.y);
#endif

    // if the input char is too big, we don't need to consider so much
    if (ptFont.x > lpImeL->yCompHi * 8) {
        ptFont.x = lpImeL->yCompHi * 8;
    }
    if (ptFont.y > lpImeL->yCompHi * 8) {
        ptFont.y = lpImeL->yCompHi * 8;
    }

    if (ptFont.x < sImeG.xChiCharWi) {
        ptFont.x = sImeG.xChiCharWi;
    }

    if (ptFont.y < sImeG.yChiCharHi) {
        ptFont.y = sImeG.yChiCharHi;
    }

#ifdef IDEBUG
    _DebugOut(DEB_WARNING, "Not too large or too samll, x - %d, y - %d",
        ptFont.x, ptFont.y);
#endif

    // -450 to 450 index 0
    // 450 to 1350 index 1
    // 1350 to 2250 index 2
    // 2250 to 3150 index 3
    uEsc = (UINT)((lpIMC->lfFont.A.lfEscapement + 450) / 900 % 4);
    uRot = (UINT)((lpIMC->lfFont.A.lfOrientation + 450) / 900 % 4);

    // decide the input rectangle
    rcInputRect.left = lpptNew->x;
    rcInputRect.top = lpptNew->y;

    // build up an input rectangle from escapemment
    rcInputRect.right = rcInputRect.left + ptFont.x * ptInputEsc[uEsc].x;
    rcInputRect.bottom = rcInputRect.top + ptFont.y * ptInputEsc[uEsc].y;

    // be a normal rectangle, not a negative rectangle
    if (rcInputRect.left > rcInputRect.right) {
        LONG tmp;

        tmp = rcInputRect.left;
        rcInputRect.left = rcInputRect.right;
        rcInputRect.right = tmp;
    }

    if (rcInputRect.top > rcInputRect.bottom) {
        LONG tmp;

        tmp = rcInputRect.top;
        rcInputRect.top = rcInputRect.bottom;
        rcInputRect.bottom = tmp;
    }
#ifdef IDEBUG
    _DebugOut(DEB_WARNING, "Input Rect, top - %d, left - %d, bottom %d, right - %d",
        rcInputRect.top, rcInputRect.left, rcInputRect.bottom, rcInputRect.right);
#endif

    GetNearCaretPosition(
#if defined(UNIIME)
        lpImeL,
#endif
        &ptFont, uEsc, uRot, lpptNew, &ptNearCaret, NEAR_CARET_FIRST_TIME);

    // 1st, use the adjust point
    // build up the new suggest UI rectangle (composition window)
    rcUIRect.left = ptNearCaret.x;
    rcUIRect.top = ptNearCaret.y;
    rcUIRect.right = rcUIRect.left + lpImeL->xCompWi;
    rcUIRect.bottom = rcUIRect.top + lpImeL->yCompHi;

#ifdef IDEBUG
    _DebugOut(DEB_WARNING, "Near caret UI Rect, top - %d, left - %d, bottom %d, right - %d",
        rcUIRect.top, rcUIRect.left, rcUIRect.bottom, rcUIRect.right);
#endif

    ptCompWnd = ptOldNearCaret = ptNearCaret;

    // OK, no intersect between the near caret position and input char
    if (IntersectRect(&rcInterRect, &rcUIRect, &rcInputRect)) {
    } else if (CalcCandPos(
#if defined(UNIIME)
        lpImeL,
#endif
        lpIMC, &ptCompWnd)) {
        // can not fit the candidate window
    } else if (FitInLazyOperation(
#if defined(UNIIME)
        lpImeL,
#endif
        lpptOrg, &ptNearCaret, &rcInputRect, uEsc)) {
#ifdef IDEBUG
        _DebugOut(DEB_WARNING, "Fit in lazy operation");
#endif
        // happy ending!!!, don't chaqge position
        return (FALSE);
    } else {
#ifdef IDEBUG
        _DebugOut(DEB_WARNING, "Go to adjust point");
#endif
        *lpptOrg = ptNearCaret;

        // happy ending!!
        return (TRUE);
    }

    // unhappy case
    GetNearCaretPosition(
#if defined(UNIIME)
            lpImeL,
#endif
            &ptFont, uEsc, uRot, lpptNew, &ptNearCaret, 0);

    // build up the new suggest UI rectangle (composition window)
    rcUIRect.left = ptNearCaret.x;
    rcUIRect.top = ptNearCaret.y;
    rcUIRect.right = rcUIRect.left + lpImeL->xCompWi;
    rcUIRect.bottom = rcUIRect.top + lpImeL->yCompHi;

#ifdef IDEBUG
    _DebugOut(DEB_WARNING, "Another NearCaret UI Rect, top - %d, left - %d, bottom %d, right - %d",
        rcUIRect.top, rcUIRect.left, rcUIRect.bottom, rcUIRect.right);
#endif

    ptCompWnd = ptNearCaret;

    // OK, no intersect between the adjust position and input char
    if (IntersectRect(&rcInterRect, &rcUIRect, &rcInputRect)) {
    } else if (CalcCandPos(
#if defined(UNIIME)
        lpImeL,
#endif
        lpIMC, &ptCompWnd)) {
        // can not fit the candidate window
    } else if (FitInLazyOperation(
#if defined(UNIIME)
        lpImeL,
#endif
        lpptOrg, &ptNearCaret, &rcInputRect, uEsc)) {
#ifdef IDEBUG
        _DebugOut(DEB_WARNING, "Fit in Another lazy operation");
#endif
        // happy ending!!!, don't chaqge position
        return (FALSE);
    } else {
#ifdef IDEBUG
        _DebugOut(DEB_WARNING, "Go to Another near caret point");
#endif
        *lpptOrg = ptNearCaret;

        // happy ending!!
        return (TRUE);
    }

    // unhappy ending! :-(
    *lpptOrg = ptOldNearCaret;

    return (TRUE);
}

/**********************************************************************/
/* SetCompPosition()                                                  */
/**********************************************************************/
void PASCAL SetCompPosition(    // set the composition window position
#if defined(UNIIME)
    LPIMEL         lpImeL,
#endif
    HWND           hCompWnd,
    LPINPUTCONTEXT lpIMC)
{
    POINT ptWnd;
    BOOL  fChange = FALSE;
    HWND  hCandWnd;

    if (lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI) {
        return;
    }

    // the client coordinate position (0, 0) of composition window
    ptWnd.x = 0;
    ptWnd.y = 0;
    // convert to screen coordinates
    ClientToScreen(hCompWnd, &ptWnd);
    ptWnd.x -= lpImeL->cxCompBorder;
    ptWnd.y -= lpImeL->cyCompBorder;

    if (lpIMC->cfCompForm.dwStyle & CFS_FORCE_POSITION) {
        POINT ptNew;            // new position of UI

        ptNew = lpIMC->cfCompForm.ptCurrentPos;
        ClientToScreen((HWND)lpIMC->hWnd, &ptNew);
        if (ptWnd.x != ptNew.x) {
            ptWnd.x = ptNew.x;
            fChange = TRUE;
        }
        if (ptWnd.y != ptNew.y) {
            ptWnd.y = ptNew.y;
            fChange = TRUE;
        }
        if (fChange) {
            ptWnd.x -= lpImeL->cxCompBorder;
            ptWnd.y -= lpImeL->cyCompBorder;
        }
    } else if (lpIMC->cfCompForm.dwStyle != CFS_DEFAULT) {
        // aplication tell us the position, we need to adjust
        POINT ptNew;            // new position of UI

        ptNew = lpIMC->cfCompForm.ptCurrentPos;
        ClientToScreen((HWND)lpIMC->hWnd, &ptNew);
        fChange = AdjustCompPosition(
#if defined(UNIIME)
            lpImeL,
#endif
            lpIMC, &ptWnd, &ptNew);
    } else {
        POINT ptNew;            // new position of UI
        RECT  rcWorkArea;

        ptNew.x = lpIMC->ptStatusWndPos.x + lpImeL->xStatusWi + UI_MARGIN;

        if (ptNew.x + lpImeL->xCompWi > sImeG.rcWorkArea.right) {
            ptNew.x = lpIMC->ptStatusWndPos.x -
                lpImeL->xCompWi - lpImeL->cxCompBorder * 2 -
                UI_MARGIN;
        }

#if 1 // MultiMonoitor
        rcWorkArea = ImeMonitorWorkAreaFromWindow(lpIMC->hWnd);
#else
        rcWorkArea = sImeG.rcWorkArea;
#endif

        ptNew.y = rcWorkArea.bottom - lpImeL->yCompHi - 2 * UI_MARGIN;

        if (ptWnd.x != ptNew.x) {
            ptWnd.x = ptNew.x;
            fChange = TRUE;
        }

        if (ptWnd.y != ptNew.y) {
            ptWnd.y = ptNew.y;
            fChange = TRUE;
        }

        if (fChange) {
            lpIMC->cfCompForm.ptCurrentPos = ptNew;

            ScreenToClient(lpIMC->hWnd, &lpIMC->cfCompForm.ptCurrentPos);
        }
    }

    if (!fChange) {
        return;
    }

    SetWindowPos(hCompWnd, NULL,
        ptWnd.x, ptWnd.y,
        0, 0, SWP_NOACTIVATE|SWP_NOSIZE|SWP_NOZORDER);

    if (lpIMC->cfCandForm[0].dwIndex == 0) {
        // application the candidate position by itself
        return;
    }

    hCandWnd = GetCandWnd(GetWindow(hCompWnd, GW_OWNER));

    if (!hCandWnd) {
        return;
    }

    // decide the position of candidate window by compoistion's position
    CalcCandPos(
#if defined(UNIIME)
        lpImeL,
#endif
        lpIMC, &ptWnd);

    ScreenToClient(lpIMC->hWnd, &ptWnd);

    lpIMC->cfCandForm[0].dwStyle = CFS_CANDIDATEPOS;
    lpIMC->cfCandForm[0].ptCurrentPos = ptWnd;

    if (!IsWindowVisible(hCandWnd)) {
        return;
    }

    PostMessage(hCandWnd, WM_IME_NOTIFY, IMN_SETCANDIDATEPOS, 0x0001);

    return;
}

/**********************************************************************/
/* SetCompWindow()                                                    */
/**********************************************************************/
void PASCAL SetCompWindow(              // set the position of composition window
#if defined(UNIIME)
    LPIMEL lpImeL,
#endif
    HWND   hCompWnd)
{
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    HWND           hUIWnd;

    hUIWnd = GetWindow(hCompWnd, GW_OWNER);
    if (!hUIWnd) {
        return;
    }

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return;
    }

    SetCompPosition(
#if defined(UNIIME)
        lpImeL,
#endif
        hCompWnd, lpIMC);

    ImmUnlockIMC(hIMC);

    return;
}

/**********************************************************************/
/* MoveDefaultCompPosition()                                          */
/**********************************************************************/
void PASCAL MoveDefaultCompPosition(    // the default comp position
                                        // need to near the caret
#if defined(UNIIME)
    LPIMEL lpImeL,
#endif
    HWND   hUIWnd)
{
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    HWND           hCompWnd;

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return;
    }

    hCompWnd = GetCompWnd(hUIWnd);
    if (!hCompWnd) {
        return;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return;
    }

    if (!(lpIMC->cfCompForm.dwStyle & CFS_FORCE_POSITION)) {
        SetCompPosition(
#if defined(UNIIME)
            lpImeL,
#endif
            hCompWnd, lpIMC);
    }

    ImmUnlockIMC(hIMC);

    return;
}

/**********************************************************************/
/* ShowComp()                                                         */
/**********************************************************************/
void PASCAL ShowComp(           // Show the composition window
#if defined(UNIIME)
    LPIMEL lpImeL,
#endif
    HWND   hUIWnd,
    int    nShowCompCmd)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    // show or hid the UI window
    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {
        return;
    }

    if (lpUIPrivate->nShowCompCmd == nShowCompCmd) {
        goto SwCompNoChange;
    }

    if (nShowCompCmd == SW_HIDE) {
        lpUIPrivate->fdwSetContext &= ~(ISC_HIDE_COMP_WINDOW);
    }

    if (!lpUIPrivate->hCompWnd) {
        // not in show candidate window mode
    } else if (lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI) {
        int nCurrShowState;

        lpUIPrivate->nShowCompCmd = nShowCompCmd;

        nCurrShowState = lpUIPrivate->nShowStatusCmd;
        nCurrShowState |= lpUIPrivate->nShowCandCmd;

        if (nCurrShowState == SW_HIDE) {
            // if other two are hide, the current show state is determined
            // by this composition section
            ShowWindow(lpUIPrivate->hCompWnd, lpUIPrivate->nShowCompCmd);
        } else {
            RECT rcRect;

            rcRect = lpImeL->rcCompText;
            // off by 1
            rcRect.right += 1;
            rcRect.bottom += 1;

            RedrawWindow(lpUIPrivate->hCompWnd, &rcRect, NULL,
                RDW_INVALIDATE);
        }
    } else {
        ShowWindow(lpUIPrivate->hCompWnd, nShowCompCmd);
        lpUIPrivate->nShowCompCmd = nShowCompCmd;
    }

SwCompNoChange:
    GlobalUnlock(hUIPrivate);
    return;
}

/**********************************************************************/
/* StartComp()                                                        */
/**********************************************************************/
void PASCAL StartComp(
#if defined(UNIIME)
    LPINSTDATAL lpInstL,
    LPIMEL      lpImeL,
#endif
    HWND   hUIWnd)
{
    HIMC           hIMC;
    HGLOBAL        hUIPrivate;
    LPINPUTCONTEXT lpIMC;
    LPUIPRIV       lpUIPrivate;
    LPPRIVCONTEXT  lpImcP;
    DWORD          fdwImeMsg;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {     // Oh! Oh!
        return;
    }

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {           // Oh! Oh!
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {    // can not draw composition window
        return;
    }

    lpUIPrivate->fdwSetContext |= ISC_SHOWUICOMPOSITIONWINDOW;

    // in the timing of the transition, we will wait
    if (lpUIPrivate->fdwSetContext & ISC_OFF_CARET_UI) {
        if (!(lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI)) {
            PostMessage(hUIWnd, WM_USER_UICHANGE, 0, 0);
            goto StartCompUnlockUIPriv;
        }
    } else {
        if (lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI) {
            PostMessage(hUIWnd, WM_USER_UICHANGE, 0, 0);
            goto StartCompUnlockUIPriv;
        }
    }

    if (lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI) {
        if (lpUIPrivate->hCompWnd) {
        } else if (lpUIPrivate->hStatusWnd) {
            lpUIPrivate->hCompWnd = lpUIPrivate->hStatusWnd;
            lpUIPrivate->nShowCompCmd = lpUIPrivate->nShowStatusCmd;
        } else if (lpUIPrivate->hCandWnd) {
            lpUIPrivate->hCompWnd = lpUIPrivate->hCandWnd;
            lpUIPrivate->nShowCompCmd = lpUIPrivate->nShowCandCmd;
        } else {
        }
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {          // Oh! Oh!
        goto StartCompUnlockUIPriv;
    }

    fdwImeMsg = 0;

    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);

    if (lpImcP) {
        fdwImeMsg = lpImcP->fdwImeMsg;
        ImmUnlockIMCC(lpIMC->hPrivate);
    }

    if (!(fdwImeMsg & MSG_ALREADY_START)) {
        // Sometime the application call ImmNotifyIME to cancel the
        // composition before it process WM_IME_STARTCOMPOSITION.
        // We should avoid to process this kind of WM_IME_STARTCOMPOSITION.
        goto StartCompUnlockIMC;
    }

    if (lpUIPrivate->hCompWnd) {
        if (lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI) {
            RECT rcRect;

            rcRect = lpImeL->rcCompText;
            // off by 1
            rcRect.right += 1;
            rcRect.bottom += 1;

            RedrawWindow(lpUIPrivate->hCompWnd, &rcRect, NULL,
                RDW_INVALIDATE);
        }
    } else {
        if (lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI) {
            lpUIPrivate->hCompWnd = CreateWindowEx(
                WS_EX_WINDOWEDGE|WS_EX_DLGMODALFRAME,
                lpImeL->szOffCaretClassName, NULL,
                WS_POPUP|WS_DISABLED,
                lpIMC->ptStatusWndPos.x, lpIMC->ptStatusWndPos.y,
                lpImeL->xCompWi, lpImeL->yCompHi,
                hUIWnd, (HMENU)NULL, lpInstL->hInst, NULL);

            if (lpUIPrivate->hSoftKbdWnd) {
                // insert soft keyboard in front of other UI
                SetWindowPos(lpUIPrivate->hCompWnd,
                    lpUIPrivate->hSoftKbdWnd,
                    0, 0, 0, 0,
                    SWP_NOACTIVATE|SWP_NOMOVE|SWP_NOSIZE);
            }
        } else {
            POINT ptNew;

            ptNew = lpIMC->cfCompForm.ptCurrentPos;

            ClientToScreen((HWND)lpIMC->hWnd, &ptNew);

            lpUIPrivate->hCompWnd = CreateWindowEx(0,
//              WS_EX_WINDOWEDGE|WS_EX_DLGMODALFRAME,
                lpImeL->szCompClassName, NULL,
                WS_POPUP|WS_DISABLED|WS_BORDER,
                ptNew.x, ptNew.y, lpImeL->xCompWi, lpImeL->yCompHi,
                hUIWnd, (HMENU)NULL, lpInstL->hInst, NULL);
        }

        SetWindowLong(lpUIPrivate->hCompWnd, UI_MOVE_OFFSET,
            WINDOW_NOT_DRAG);

        SetWindowLong(lpUIPrivate->hCompWnd, UI_MOVE_XY, lpImeL->nRevMaxKey);
    }

    if (!(lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI)) {
        // try to set the position of composition UI window near the caret
        SetCompPosition(
#if defined(UNIIME)
            lpImeL,
#endif
            lpUIPrivate->hCompWnd, lpIMC);
    }

    ShowComp(
#if defined(UNIIME)
        lpImeL,
#endif
        hUIWnd, SW_SHOWNOACTIVATE);

StartCompUnlockIMC:
    ImmUnlockIMC(hIMC);

StartCompUnlockUIPriv:
    GlobalUnlock(hUIPrivate);

    return;
}

/**********************************************************************/
/* EndComp()                                                          */
/**********************************************************************/
void PASCAL EndComp(
#if defined(UNIIME)
    LPIMEL lpImeL,
#endif
    HWND   hUIWnd)
{
    ShowComp(
#if defined(UNIIME)
        lpImeL,
#endif
        hUIWnd, SW_HIDE);

    return;
}

/**********************************************************************/
/* ChangeCompositionSize()                                            */
/**********************************************************************/
void PASCAL ChangeCompositionSize(
#if defined(UNIIME)
    LPIMEL lpImeL,
#endif
    HWND   hUIWnd)
{
    HWND            hCompWnd, hCandWnd;
    RECT            rcWnd;
    UINT            nMaxKey;
    HIMC            hIMC;
    LPINPUTCONTEXT  lpIMC;

    hCompWnd = GetCompWnd(hUIWnd);

    if (!hCompWnd) {
        return;
    }

    GetWindowRect(hCompWnd, &rcWnd);

    if ((rcWnd.right - rcWnd.left) != lpImeL->xCompWi) {
    } else if ((rcWnd.bottom - rcWnd.top) != lpImeL->yCompHi) {
    } else {
        return;
    }

    SetWindowPos(hCompWnd, NULL,
        0, 0, lpImeL->xCompWi, lpImeL->yCompHi,
        SWP_NOACTIVATE|SWP_NOMOVE|SWP_NOZORDER);

    if (lpImeL->nRevMaxKey >= lpImeL->nMaxKey) {
        nMaxKey = lpImeL->nRevMaxKey;
    } else {
        nMaxKey = lpImeL->nMaxKey;
    }

    SetWindowLong(hCompWnd, UI_MOVE_XY, nMaxKey);

    if (lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI) {
        return;
    }

    hCandWnd = GetCandWnd(hUIWnd);

    if (!hCandWnd) {
        return;
    }

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return;
    }

    CalcCandPos(
#if defined(UNIIME)
        lpImeL,
#endif
        lpIMC, (LPPOINT)&rcWnd);

    ImmUnlockIMC(hIMC);

    SetWindowPos(hCandWnd, NULL,
        rcWnd.left, rcWnd.top,
        0, 0, SWP_NOACTIVATE|SWP_NOSIZE|SWP_NOZORDER);

    return;
}

/**********************************************************************/
/* DestroyCompWindow()                                                */
/**********************************************************************/
void PASCAL DestroyCompWindow(          // destroy composition window
    HWND hCompWnd)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    if (GetWindowLong(hCompWnd, UI_MOVE_OFFSET) != WINDOW_NOT_DRAG) {
        // undo the drag border
        DrawDragBorder(hCompWnd,
            GetWindowLong(hCompWnd, UI_MOVE_XY),
            GetWindowLong(hCompWnd, UI_MOVE_OFFSET));
    }

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(GetWindow(hCompWnd, GW_OWNER),
        IMMGWLP_PRIVATE);
    if (!hUIPrivate) {     // Oh! Oh!
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {    // Oh! Oh!
        return;
    }

    lpUIPrivate->nShowCompCmd = SW_HIDE;

    lpUIPrivate->hCompWnd = (HWND)NULL;

    GlobalUnlock(hUIPrivate);
    return;
}

/**********************************************************************/
/* CompSetCursor()                                                    */
/**********************************************************************/
void PASCAL CompSetCursor(
    HWND   hCompWnd,
    LPARAM lParam)
{
    POINT ptCursor;
    RECT  rcWnd;

    SetCursor(LoadCursor(NULL, IDC_SIZEALL));

    if (GetWindowLong(hCompWnd, UI_MOVE_OFFSET) !=
        WINDOW_NOT_DRAG) {
        return;
    }

    if (HIWORD(lParam) != WM_LBUTTONDOWN) {
        return;
    }

    // start dragging
    SystemParametersInfo(SPI_GETWORKAREA, 0, &sImeG.rcWorkArea, 0);

    SetCapture(hCompWnd);
    GetCursorPos(&ptCursor);
    SetWindowLong(hCompWnd, UI_MOVE_XY,
        MAKELONG(ptCursor.x, ptCursor.y));
    GetWindowRect(hCompWnd, &rcWnd);
    SetWindowLong(hCompWnd, UI_MOVE_OFFSET,
        MAKELONG(ptCursor.x - rcWnd.left, ptCursor.y - rcWnd.top));

    DrawDragBorder(hCompWnd, MAKELONG(ptCursor.x, ptCursor.y),
        GetWindowLong(hCompWnd, UI_MOVE_OFFSET));

    return;
}

/**********************************************************************/
/* CompButtonUp()                                                     */
/**********************************************************************/
BOOL PASCAL CompButtonUp(       // finish drag, set comp  window to this
                                // position
#if defined(UNIIME)
    LPIMEL lpImeL,
#endif
    HWND   hCompWnd)
{
    LONG            lTmpCursor, lTmpOffset;
    POINT           pt;
    HWND            hUIWnd;
    HIMC            hIMC;
    LPINPUTCONTEXT  lpIMC;
    RECT            rcWorkArea;

    if (GetWindowLong(hCompWnd, UI_MOVE_OFFSET) == WINDOW_NOT_DRAG) {
        return (FALSE);
    }

    lTmpCursor = GetWindowLong(hCompWnd, UI_MOVE_XY);

    // calculate the org by the offset
    lTmpOffset = GetWindowLong(hCompWnd, UI_MOVE_OFFSET);

    pt.x = (*(LPPOINTS)&lTmpCursor).x - (*(LPPOINTS)&lTmpOffset).x;
    pt.y = (*(LPPOINTS)&lTmpCursor).y - (*(LPPOINTS)&lTmpOffset).y;

    DrawDragBorder(hCompWnd, lTmpCursor, lTmpOffset);
    SetWindowLong(hCompWnd, UI_MOVE_OFFSET, WINDOW_NOT_DRAG);

    SetWindowLong(hCompWnd, UI_MOVE_XY, lpImeL->nRevMaxKey);
    ReleaseCapture();

    hUIWnd = GetWindow(hCompWnd, GW_OWNER);

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return (FALSE);
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return (FALSE);
    }

#if 1 // MultiMonitor
    rcWorkArea = ImeMonitorWorkAreaFromWindow(lpIMC->hWnd);
#else
    rcWorkArea = sImeG.rcWorkArea;
#endif

    if (pt.x < rcWorkArea.left) {
        pt.x = rcWorkArea.left;
    } else if (pt.x + lpImeL->xCompWi > rcWorkArea.right) {
        pt.x = rcWorkArea.right - lpImeL->xCompWi;
    }

    if (pt.y < rcWorkArea.top) {
        pt.y = rcWorkArea.top;
    } else if (pt.y + lpImeL->yCompHi > rcWorkArea.bottom) {
        pt.y = rcWorkArea.bottom - lpImeL->yCompHi;
    }

    lpIMC->cfCompForm.dwStyle = CFS_FORCE_POSITION;
    lpIMC->cfCompForm.ptCurrentPos.x = pt.x + lpImeL->cxCompBorder;
    lpIMC->cfCompForm.ptCurrentPos.y = pt.y + lpImeL->cyCompBorder;

    ScreenToClient(lpIMC->hWnd, &lpIMC->cfCompForm.ptCurrentPos);

    ImmUnlockIMC(hIMC);

    // set composition window to the new poosition
    PostMessage(hCompWnd, WM_IME_NOTIFY, IMN_SETCOMPOSITIONWINDOW, 0);

    return (TRUE);
}

/**********************************************************************/
/* PaintCompWindow()                                                  */
/**********************************************************************/
void PASCAL PaintCompWindow(
#if defined(UNIIME)
    LPIMEL lpImeL,
#endif
    HWND   hUIWnd,
    HDC    hDC)
{
    HIMC                hIMC;
    LPINPUTCONTEXT      lpIMC;
    LPCOMPOSITIONSTRING lpCompStr;
    HGDIOBJ             hOldFont;
//  RECT                rcSunken;
    LOGFONT lfFont;

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return;
    }

    lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);

    hOldFont = GetCurrentObject(hDC, OBJ_FONT);
    GetObject(hOldFont, sizeof(lfFont), &lfFont);

    if (sImeG.fDiffSysCharSet) {
        lfFont.lfCharSet = NATIVE_CHARSET;
        lfFont.lfFaceName[0] = TEXT('\0');
    }
    lfFont.lfWeight = FW_DONTCARE;

    SelectObject(hDC, CreateFontIndirect(&lfFont));

    // light gray background for normal case
    SetBkColor(hDC, RGB(0xC0, 0xC0, 0xC0));

    if (!lpCompStr) {
        goto UpdCompWndShowGuideLine;
    } else if (!lpCompStr->dwCompStrLen) {
        LPGUIDELINE lpGuideLine;

UpdCompWndShowGuideLine:
        lpGuideLine = (LPGUIDELINE)ImmLockIMCC(lpIMC->hGuideLine);

        if (lpGuideLine) {
            BOOL            fReverseConversion;
            LPCANDIDATELIST lpCandList;
            LPTSTR          lpStr;
            UINT            uStrLen;

            fReverseConversion = FALSE;

            if (lpGuideLine->dwLevel != GL_LEVEL_INFORMATION) {
                goto UpdCompWndUnlockGuideLine;
            } else if (lpGuideLine->dwIndex != GL_ID_REVERSECONVERSION) {
                goto UpdCompWndUnlockGuideLine;
            } else {
            }

            lpCandList = (LPCANDIDATELIST)((LPBYTE)lpGuideLine +
                lpGuideLine->dwPrivateOffset);

            if (!lpCandList) {
                goto UpdCompWndUnlockGuideLine;
            } else if (!lpCandList->dwCount) {
                goto UpdCompWndUnlockGuideLine;
            } else {
                fReverseConversion = TRUE;
            }

            // green text for information
            SetTextColor(hDC, RGB(0x00, 0x80, 0x00));

            lpStr = (LPTSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[0]);

            uStrLen = lstrlen(lpStr);

            ExtTextOut(hDC, lpImeL->rcCompText.left, lpImeL->rcCompText.top,
                ETO_OPAQUE, &lpImeL->rcCompText,
                lpStr, uStrLen, iDx);

UpdCompWndUnlockGuideLine:
            ImmUnlockIMCC(lpIMC->hGuideLine);

            if (!fReverseConversion) {
                goto UpdCompWndNoString;
            }
        } else {
UpdCompWndNoString:
            // no any information
            ExtTextOut(hDC, lpImeL->rcCompText.left, lpImeL->rcCompText.top,
                ETO_OPAQUE, &lpImeL->rcCompText,
                (LPTSTR)NULL, 0, NULL);
        }
    } else {
        ExtTextOut(hDC, lpImeL->rcCompText.left, lpImeL->rcCompText.top,
            ETO_OPAQUE, &lpImeL->rcCompText,
            (LPTSTR)((LPBYTE)lpCompStr + lpCompStr->dwCompStrOffset),
            (UINT)lpCompStr->dwCompStrLen, iDx);

        if (lpCompStr->dwCompStrLen <= lpCompStr->dwCursorPos) {
            goto UpdCompWndUnselectObj;
        }

        // there is error part
        // red text for error
        SetTextColor(hDC, RGB(0xFF, 0x00, 0x00));
        // dark gray background for error
        SetBkColor(hDC, RGB(0x80, 0x80, 0x80));

        ExtTextOut(hDC, lpImeL->rcCompText.left +
            lpCompStr->dwCursorPos * sImeG.xChiCharWi /
            (sizeof(WCHAR) / sizeof(TCHAR)),
            lpImeL->rcCompText.top,
            ETO_OPAQUE, NULL,
            (LPTSTR)((LPBYTE)lpCompStr + lpCompStr->dwCompStrOffset +
            lpCompStr->dwCursorPos * sizeof(TCHAR)),
            (UINT)(lpCompStr->dwCompStrLen - lpCompStr->dwCursorPos), iDx);
    }

UpdCompWndUnselectObj:
    DeleteObject(SelectObject(hDC, hOldFont));

    if (lpCompStr) {
        ImmUnlockIMCC(lpIMC->hCompStr);
    }

    ImmUnlockIMC(hIMC);

#if 0
    rcSunken = lpImeL->rcCompText;

    rcSunken.left -= lpImeL->cxCompBorder;
    rcSunken.top -= lpImeL->cyCompBorder;
    rcSunken.right += lpImeL->cxCompBorder;
    rcSunken.bottom += lpImeL->cyCompBorder;

    DrawEdge(hDC, &rcSunken, BDR_SUNKENOUTER, BF_RECT);
#endif

    return;
}

/**********************************************************************/
/* CompWndProc() / UniCompWndProc()                                   */
/**********************************************************************/
// composition window proc
#if defined(UNIIME)
LRESULT WINAPI   UniCompWndProc(
    LPINSTDATAL lpInstL,
    LPIMEL      lpImeL,
#else
LRESULT CALLBACK CompWndProc(
#endif
    HWND        hCompWnd,
    UINT        uMsg,
    WPARAM      wParam,
    LPARAM      lParam)
{
    switch (uMsg) {
    case WM_DESTROY:
        DestroyCompWindow(hCompWnd);
        break;
    case WM_SETCURSOR:
        CompSetCursor(hCompWnd, lParam);
        break;
    case WM_MOUSEMOVE:
        if (GetWindowLong(hCompWnd, UI_MOVE_OFFSET) != WINDOW_NOT_DRAG) {
            POINT ptCursor;

            DrawDragBorder(hCompWnd,
                GetWindowLong(hCompWnd, UI_MOVE_XY),
                GetWindowLong(hCompWnd, UI_MOVE_OFFSET));
            GetCursorPos(&ptCursor);
            SetWindowLong(hCompWnd, UI_MOVE_XY,
                MAKELONG(ptCursor.x, ptCursor.y));
            DrawDragBorder(hCompWnd, MAKELONG(ptCursor.x, ptCursor.y),
                GetWindowLong(hCompWnd, UI_MOVE_OFFSET));
        } else {
            return DefWindowProc(hCompWnd, uMsg, wParam, lParam);
        }
        break;
    case WM_LBUTTONUP:
        if (!CompButtonUp(
#if defined(UNIIME)
            lpImeL,
#endif
            hCompWnd)) {
            return DefWindowProc(hCompWnd, uMsg, wParam, lParam);
        }
        break;
    case WM_IME_NOTIFY:
        if (wParam != IMN_SETCOMPOSITIONWINDOW) {
        } else if (lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI) {
        } else {
            SetCompWindow(
#if defined(UNIIME)
                lpImeL,
#endif
                hCompWnd);
        }
        break;
    case WM_PAINT:
        {
            HDC         hDC;
            PAINTSTRUCT ps;

            hDC = BeginPaint(hCompWnd, &ps);
            PaintCompWindow(
#if defined(UNIIME)
                lpImeL,
#endif
                GetWindow(hCompWnd, GW_OWNER), hDC);
            EndPaint(hCompWnd, &ps);
        }
        break;
    case WM_MOUSEACTIVATE:
        return (MA_NOACTIVATE);
    default:
        return DefWindowProc(hCompWnd, uMsg, wParam, lParam);
    }
    return (0L);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\ddis.c ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    DDIS.c
    
++*/

#include <windows.h>
#include <immdev.h>
#include "imeattr.h"
#include "imedefs.h"
#include "imerc.h"
#if defined(UNIIME)
#include "uniime.h"
#endif

/**********************************************************************/
/* ImeInquire() / UniImeInquire()                                     */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
// initialized data structure of IME
#if defined(UNIIME)
BOOL WINAPI UniImeInquire(
    LPINSTDATAL lpInstL,
    LPIMEL      lpImeL,
#else
BOOL WINAPI ImeInquire(
#endif
    LPIMEINFO   lpImeInfo,      // IME specific data report to IMM
    LPTSTR      lpszWndCls,     // the class name of UI
    DWORD       dwSystemInfoFlags)
{
    if (!lpImeInfo) {
        return (FALSE);
    }

    lpImeInfo->dwPrivateDataSize = sizeof(PRIVCONTEXT);

    lpImeInfo->fdwProperty = IME_PROP_KBD_CHAR_FIRST|
#if defined(UNICODE)
        IME_PROP_UNICODE|
#endif
#if !defined(DAYI)
        IME_PROP_CANDLIST_START_FROM_1|
#endif
        IME_PROP_NEED_ALTKEY|IME_PROP_IGNORE_UPKEYS;
    lpImeInfo->fdwConversionCaps = IME_CMODE_NATIVE|IME_CMODE_FULLSHAPE|
#if !defined(ROMANIME)
#if !defined(WINAR30)
        IME_CMODE_SOFTKBD|
#endif
#if !defined(WINIME) && !defined(UNICDIME)
        IME_CMODE_EUDC|
#endif
#endif
        IME_CMODE_NOCONVERSION;
#if defined(ROMANIME)
    lpImeInfo->fdwSentenceCaps = 0;
    lpImeInfo->fdwSCSCaps = 0;
    lpImeInfo->fdwUICaps = UI_CAP_ROT90;
#else
    lpImeInfo->fdwSentenceCaps = IME_SMODE_PHRASEPREDICT;
    // composition string is the reading string for simple IME
    lpImeInfo->fdwSCSCaps = SCS_CAP_COMPSTR|SCS_CAP_MAKEREAD;
    // IME will have different distance base multiple of 900 escapement
#if defined(WINAR30)
    // if an IME want to draw soft keyboard by itself, it also can set this
    // off
    lpImeInfo->fdwUICaps = UI_CAP_ROT90;
#else
    lpImeInfo->fdwUICaps = UI_CAP_ROT90|UI_CAP_SOFTKBD;
#endif
#endif
    // IME want to decide conversion mode on ImeSelect
    lpImeInfo->fdwSelectCaps = (DWORD) 0;

    lstrcpy(lpszWndCls, lpImeL->szUIClassName);

    return (TRUE);
}

/**********************************************************************/
/* ImeDestroy() / UniImeDestroy                                       */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
// this dll is unloaded
#if defined(UNIIME)
BOOL WINAPI UniImeDestroy(
    LPINSTDATAL lpInstL,
    LPIMEL      lpImeL,
#else
BOOL WINAPI ImeDestroy(
#endif
    UINT        uReserved)
{
    if (uReserved) {
        return (FALSE);
    }

#if !defined(ROMANIME)
    // free the IME table or data base
    FreeTable(lpInstL);
#endif

    return (TRUE);
}

/**********************************************************************/
/* InitCompStr()                                                      */
/**********************************************************************/
void PASCAL InitCompStr(                // init setting for composing string
    LPCOMPOSITIONSTRING lpCompStr)
{
    if (!lpCompStr) {
        return;
    }

    lpCompStr->dwCompReadAttrLen = 0;
    lpCompStr->dwCompReadClauseLen = 0;
    lpCompStr->dwCompReadStrLen = 0;

    lpCompStr->dwCompAttrLen = 0;
    lpCompStr->dwCompClauseLen = 0;
    lpCompStr->dwCompStrLen = 0;

    lpCompStr->dwCursorPos = 0;
    lpCompStr->dwDeltaStart = 0;

    lpCompStr->dwResultReadClauseLen = 0;
    lpCompStr->dwResultReadStrLen = 0;

    lpCompStr->dwResultClauseLen = 0;
    lpCompStr->dwResultStrLen = 0;

    return;
}

/**********************************************************************/
/* ClearCompStr()                                                     */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
#define NMAXKEY 8
BOOL PASCAL ClearCompStr(
#if defined(UNIIME)
    LPIMEL         lpImeL,
#endif
    LPINPUTCONTEXT lpIMC)
{
    HIMCC               hMem;
    LPCOMPOSITIONSTRING lpCompStr;
    DWORD               dwSize;
    LPBYTE              lpbAttr;
    UINT                i;
    LPDWORD             lpdwClause;
    LPWSTR              lpwStr;

    if (!lpIMC) {
        return (FALSE);
    }

    dwSize =
        // header length
        sizeof(COMPOSITIONSTRING) +
        // composition reading attribute plus NULL terminator
        NMAXKEY * sizeof(WCHAR) / sizeof(TCHAR) + sizeof(DWORD) +
        // composition reading clause
        sizeof(DWORD) + sizeof(DWORD) +
        // composition reading string plus NULL terminator
        NMAXKEY * sizeof(WCHAR) + sizeof(DWORD) +
        // result reading clause
        sizeof(DWORD) + sizeof(DWORD) +
        // result reading string plus NULL terminateor
        NMAXKEY * sizeof(WCHAR) + sizeof(DWORD) +
        // result clause
        sizeof(DWORD) + sizeof(DWORD) +
        // result string plus NULL terminateor
        MAXSTRLEN * sizeof(WCHAR) + sizeof(DWORD);

    if (!lpIMC->hCompStr) {
        // it maybe free by other IME, init it
        lpIMC->hCompStr = ImmCreateIMCC(dwSize);
    } else if (hMem = ImmReSizeIMCC(lpIMC->hCompStr, dwSize)) {
        lpIMC->hCompStr = hMem;
    } else {
        ImmDestroyIMCC(lpIMC->hCompStr);
        lpIMC->hCompStr = ImmCreateIMCC(dwSize);
        return (FALSE);
    }

    if (!lpIMC->hCompStr) {
        return (FALSE);
    }

    lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
    if (!lpCompStr) {
        ImmDestroyIMCC(lpIMC->hCompStr);
        lpIMC->hCompStr = ImmCreateIMCC(dwSize);
        return (FALSE);
    }

    lpCompStr->dwSize = dwSize;

     // 1. composition (reading) string - simple IME
     // 2. result reading string
     // 3. result string

    lpCompStr->dwCompReadAttrLen = 0;
    lpCompStr->dwCompReadAttrOffset = sizeof(COMPOSITIONSTRING);

    lpbAttr = (LPBYTE)lpCompStr + lpCompStr->dwCompReadAttrOffset;

    for (i = 0; i < NMAXKEY * sizeof(WCHAR) / sizeof(TCHAR); i++) {
        // for simple IMEs, we have no way to reconvert it
        *lpbAttr++ = ATTR_TARGET_CONVERTED;
    }

    *(LPDWORD)lpbAttr = 0;

    lpCompStr->dwCompReadClauseLen = 0;
    lpCompStr->dwCompReadClauseOffset = lpCompStr->dwCompReadAttrOffset +
        NMAXKEY * sizeof(WCHAR) / sizeof(TCHAR) + sizeof(DWORD);

    lpdwClause = (LPDWORD)((LPBYTE)lpCompStr +
        lpCompStr->dwCompReadClauseOffset);
    // clause start from 0
    *lpdwClause++ = 0;
    // clause length is 0
    *lpdwClause = 0;

    lpCompStr->dwCompReadStrLen = 0;
    lpCompStr->dwCompReadStrOffset = lpCompStr->dwCompReadClauseOffset +
        sizeof(DWORD) + sizeof(DWORD);

    // clean up the composition reading string
    lpwStr = (LPWSTR)((LPBYTE)lpCompStr + lpCompStr->dwCompReadStrOffset);

    for (i = 0; i < NMAXKEY; i++) {
        *lpwStr++ = 0;
    }

    *(LPDWORD)((LPBYTE)lpCompStr + lpCompStr->dwCompReadStrOffset +
        NMAXKEY * sizeof(WCHAR)) = 0;

    // composition string is the same with composition reading string 
    // for simple IMEs
    lpCompStr->dwCompAttrLen = 0;
    lpCompStr->dwCompAttrOffset = lpCompStr->dwCompReadAttrOffset;
    lpCompStr->dwCompClauseLen = 0;
    lpCompStr->dwCompClauseOffset = lpCompStr->dwCompReadClauseOffset;
    lpCompStr->dwCompStrLen = 0;
    lpCompStr->dwCompStrOffset = lpCompStr->dwCompReadStrOffset;

    lpCompStr->dwCursorPos = 0;
    lpCompStr->dwDeltaStart = 0;

    lpCompStr->dwResultReadClauseLen = 0;
    lpCompStr->dwResultReadClauseOffset = lpCompStr->dwCompStrOffset +
        NMAXKEY * sizeof(WCHAR) + sizeof(DWORD);

    lpdwClause = (LPDWORD)((LPBYTE)lpCompStr +
        lpCompStr->dwResultReadClauseOffset);
    // clause start from 0
    *lpdwClause++ = 0;
    // clause length is 0
    *lpdwClause = 0;

    lpCompStr->dwResultReadStrLen = 0;
    lpCompStr->dwResultReadStrOffset = lpCompStr->dwResultReadClauseOffset +
        sizeof(DWORD) + sizeof(DWORD);

    // clean up the result reading string
    lpwStr = (LPWSTR)((LPBYTE)lpCompStr + lpCompStr->dwResultReadStrOffset);

    for (i = 0; i < NMAXKEY; i++) {
        *lpwStr++ = 0;
    }

    *(LPDWORD)((LPBYTE)lpCompStr + lpCompStr->dwResultReadStrOffset +
        NMAXKEY * sizeof(WCHAR)) = 0;

    lpCompStr->dwResultClauseLen = 0;
    lpCompStr->dwResultClauseOffset = lpCompStr->dwResultReadStrOffset +
        NMAXKEY * sizeof(WCHAR) + sizeof(DWORD);

    lpdwClause = (LPDWORD)((LPBYTE)lpCompStr +
        lpCompStr->dwResultClauseOffset);
    // clause start from 0
    *lpdwClause++ = 0;
    // clause length is 0
    *lpdwClause = 0;

    lpCompStr->dwResultStrOffset = 0;
    lpCompStr->dwResultStrOffset = lpCompStr->dwResultClauseOffset +
        sizeof(DWORD) + sizeof(DWORD);

    // clean up the result string
    lpwStr = (LPWSTR)((LPBYTE)lpCompStr + lpCompStr->dwResultStrOffset);

    for (i = 0; i < NMAXKEY; i++) {
        *lpwStr++ = 0;
    }

    *(LPDWORD)((LPBYTE)lpCompStr + lpCompStr->dwResultStrOffset +
        NMAXKEY * sizeof(WCHAR)) = 0;

    ImmUnlockIMCC(lpIMC->hCompStr);
    return (TRUE);
}

/**********************************************************************/
/* ClearCand()                                                        */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL PASCAL ClearCand(
    LPINPUTCONTEXT lpIMC)
{
    HIMCC           hMem;
    LPCANDIDATEINFO lpCandInfo;
    LPCANDIDATELIST lpCandList;
    DWORD           dwSize =
        // header length
        sizeof(CANDIDATEINFO) + sizeof(CANDIDATELIST) +
        // candidate string pointers
        sizeof(DWORD) * (MAXCAND) +
        // string plus NULL terminator
        (sizeof(WCHAR) + sizeof(TCHAR)) * MAXCAND;

    if (!lpIMC) {
        return (FALSE);
    }

    if (!lpIMC->hCandInfo) {
        // it maybe free by other IME, init it
        lpIMC->hCandInfo = ImmCreateIMCC(dwSize);
    } else if (hMem = ImmReSizeIMCC(lpIMC->hCandInfo, dwSize)) {
        lpIMC->hCandInfo = hMem;
    } else {
        ImmDestroyIMCC(lpIMC->hCandInfo);
        lpIMC->hCandInfo = ImmCreateIMCC(dwSize);
        return (FALSE);
    }

    if (!lpIMC->hCandInfo) {
        return (FALSE);
    } 

    lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo);
    if (!lpCandInfo) {
        ImmDestroyIMCC(lpIMC->hCandInfo);
        lpIMC->hCandInfo = ImmCreateIMCC(dwSize);
        return (FALSE);
    }

    // ordering of strings are
    // buffer size
    lpCandInfo->dwSize = dwSize;
    lpCandInfo->dwCount = 0;
    lpCandInfo->dwOffset[0] = sizeof(CANDIDATEINFO);
    lpCandList = (LPCANDIDATELIST)((LPBYTE)lpCandInfo +
        lpCandInfo->dwOffset[0]);
    // whole candidate info size - header
    lpCandList->dwSize = lpCandInfo->dwSize - sizeof(CANDIDATEINFO);
    lpCandList->dwStyle = IME_CAND_READ;
    lpCandList->dwCount = 0;
    lpCandList->dwPageStart = lpCandList->dwSelection = 0;
    lpCandList->dwPageSize = CANDPERPAGE;
    lpCandList->dwOffset[0] = sizeof(CANDIDATELIST) +
        sizeof(DWORD) * (MAXCAND - 1);

    ImmUnlockIMCC(lpIMC->hCandInfo);
    return (TRUE);
}

/**********************************************************************/
/* InitGuideLine()                                                    */
/**********************************************************************/
void PASCAL InitGuideLine(              // init guide line
    LPGUIDELINE lpGuideLine)
{
#if !defined(ROMANIME)
    LPCANDIDATELIST lpCandList;
#endif

    if (!lpGuideLine) {
        return;
    }

    lpGuideLine->dwLevel = GL_LEVEL_NOGUIDELINE;
    lpGuideLine->dwIndex = GL_ID_UNKNOWN;
    lpGuideLine->dwStrLen = 0;
    lpGuideLine->dwStrOffset = sizeof(GUIDELINE);

    lpGuideLine->dwPrivateOffset = sizeof(GUIDELINE);
#if defined(ROMANIME)
    lpGuideLine->dwPrivateSize = sizeof(lpGuideLine->dwPrivateSize) +
        sizeof(lpGuideLine->dwPrivateOffset);
#else
    lpGuideLine->dwPrivateSize = lpGuideLine->dwSize - sizeof(GUIDELINE) -
        sizeof(lpGuideLine->dwPrivateSize) -
        sizeof(lpGuideLine->dwPrivateOffset);
    lpCandList = (LPCANDIDATELIST)((LPBYTE)lpGuideLine +
        lpGuideLine->dwPrivateOffset);

    lpCandList->dwSize = lpGuideLine->dwSize - sizeof(GUIDELINE);
    lpCandList->dwStyle = IME_CAND_READ;
    lpCandList->dwCount = 0;
    lpCandList->dwSelection = 0;
    lpCandList->dwPageSize = CANDPERPAGE;
    lpCandList->dwOffset[0] = sizeof(CANDIDATELIST) + sizeof(DWORD) *
        (MAX_COMP_BUF - 1);
#endif

    return;
}

/**********************************************************************/
/* ClearGuideLine()                                                   */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL PASCAL ClearGuideLine(
#if defined(UNIIME)
    LPIMEL         lpImeL,
#endif
    LPINPUTCONTEXT lpIMC)
{
    HIMCC           hMem;
    LPGUIDELINE     lpGuideLine;
    DWORD           dwSize =
        // header length
        sizeof(GUIDELINE) +
        // string for status error
#if defined(ROMANIME)
        0;
#else
        // private header length
        sizeof(CANDIDATELIST) +
        // candidate string pointers
        sizeof(DWORD) * MAX_COMP_BUF +
        // string plus NULL terminator
        (sizeof(WCHAR) * lpImeL->nRevMaxKey + sizeof(TCHAR)) * MAX_COMP_BUF;
#endif

    if (!lpIMC->hGuideLine) {
        // it maybe free by IME
        lpIMC->hGuideLine = ImmCreateIMCC(dwSize);
    } else if (hMem = ImmReSizeIMCC(lpIMC->hGuideLine, dwSize)) {
        lpIMC->hGuideLine = hMem;
    } else {
        ImmDestroyIMCC(lpIMC->hGuideLine);
        lpIMC->hGuideLine = ImmCreateIMCC(dwSize);
    }

    lpGuideLine = (LPGUIDELINE)ImmLockIMCC(lpIMC->hGuideLine);
    if (!lpGuideLine) {
        return (FALSE);
    }

    lpGuideLine->dwSize = dwSize;

    InitGuideLine(lpGuideLine);

    ImmUnlockIMCC(lpIMC->hGuideLine);

    return (TRUE);
}

/**********************************************************************/
/* InitContext()                                                      */
/**********************************************************************/
void PASCAL InitContext(
#if defined(UNIIME)
    LPIMEL         lpImeL,
#endif
    LPINPUTCONTEXT lpIMC,
    LPPRIVCONTEXT  lpImcP)
{
    if (lpIMC->fdwInit & INIT_STATUSWNDPOS) {
    } else if (!lpIMC->hWnd) {
#if 0 // MultiMonitor support
    } else if (lpImcP->fdwInit & INIT_STATUSWNDPOS) {
#endif
    } else {
#if 0 // MultiMonitor support
        POINT ptWnd;

        ptWnd.x = 0;
        ptWnd.y = 0;
        ClientToScreen(lpIMC->hWnd, &ptWnd);

        if (ptWnd.x > sImeG.rcWorkArea.right / 3) {
            ptWnd.x = sImeG.rcWorkArea.right / 3;
        }

        if (ptWnd.x < sImeG.rcWorkArea.left) {
            lpIMC->ptStatusWndPos.x = sImeG.rcWorkArea.left;
        } else if (ptWnd.x + lpImeL->xStatusWi > sImeG.rcWorkArea.right) {
            lpIMC->ptStatusWndPos.x = sImeG.rcWorkArea.right -
                lpImeL->xStatusWi;
        } else {
            lpIMC->ptStatusWndPos.x = ptWnd.x;
        }

        lpIMC->ptStatusWndPos.y = sImeG.rcWorkArea.bottom -
            lpImeL->yStatusHi - 2 * UI_MARGIN;

        lpImcP->fdwInit |= INIT_STATUSWNDPOS;
#else
        RECT rcWorkArea;

        rcWorkArea = ImeMonitorWorkAreaFromWindow(lpIMC->hWnd);

        lpIMC->ptStatusWndPos.x = rcWorkArea.left + 2 * UI_MARGIN;

        lpIMC->ptStatusWndPos.y = rcWorkArea.bottom -
            lpImeL->yStatusHi - 2 * UI_MARGIN;
#endif
    }

#if !defined(ROMANIME)
    if (!(lpIMC->fdwInit & INIT_COMPFORM)) {
        lpIMC->cfCompForm.dwStyle = CFS_DEFAULT;
    }

    if (lpIMC->cfCompForm.dwStyle != CFS_DEFAULT) {
    } else if (!lpIMC->hWnd) {
    } else if (lpImcP->fdwInit & INIT_COMPFORM) {
    } else {
        if (lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI) {
            lpIMC->cfCompForm.ptCurrentPos.x = lpIMC->ptStatusWndPos.x +
                lpImeL->rcStatusText.right + lpImeL->cxCompBorder * 2 +
                UI_MARGIN;

            if (lpIMC->cfCompForm.ptCurrentPos.x + (lpImeL->nRevMaxKey *
                sImeG.xChiCharWi) > sImeG.rcWorkArea.right) {
                lpIMC->cfCompForm.ptCurrentPos.x = lpIMC->ptStatusWndPos.x -
                    lpImeL->nRevMaxKey * sImeG.xChiCharWi -
                    lpImeL->cxCompBorder * 3;
            }
        } else {
            lpIMC->cfCompForm.ptCurrentPos.x = lpIMC->ptStatusWndPos.x +
                lpImeL->xStatusWi + UI_MARGIN;

            if (lpIMC->cfCompForm.ptCurrentPos.x + lpImeL->xCompWi >
                sImeG.rcWorkArea.right) {
                lpIMC->cfCompForm.ptCurrentPos.x = lpIMC->ptStatusWndPos.x -
                    lpImeL->xCompWi - lpImeL->cxCompBorder * 2 -
                    UI_MARGIN;
            }
        }

        lpIMC->cfCompForm.ptCurrentPos.y = sImeG.rcWorkArea.bottom -
            lpImeL->yCompHi - 2 * UI_MARGIN;

        ScreenToClient(lpIMC->hWnd, &lpIMC->cfCompForm.ptCurrentPos);

        lpImcP->fdwInit |= INIT_COMPFORM;
    }
#endif

    return;
}

/**********************************************************************/
/* Select()                                                           */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL PASCAL Select(
#if defined(UNIIME)
    LPIMEL         lpImeL,
#endif
    LPINPUTCONTEXT lpIMC,
    BOOL           fSelect)
{
    LPPRIVCONTEXT  lpImcP;

    if (fSelect) {      // init "every" fields of hPrivate, please!!!
        if (!ClearCompStr(
#if defined(UNIIME)
                lpImeL,
#endif
                lpIMC)) {
            return (FALSE);
        }

        if (!ClearCand(lpIMC)) {
            return (FALSE);
        }

        ClearGuideLine(
#if defined(UNIIME)
            lpImeL,
#endif
            lpIMC);
    }

    if (lpIMC->cfCandForm[0].dwIndex != 0) {
        lpIMC->cfCandForm[0].dwStyle = CFS_DEFAULT;
    }

    // We add this hack for switching from other IMEs, this IME has a bug.
    // Before this bug fixed in this IME, it depends on this hack.
    if (lpIMC->cfCandForm[0].dwStyle == CFS_DEFAULT) {
        lpIMC->cfCandForm[0].dwIndex = (DWORD)-1;
    }

    if (!lpIMC->hPrivate) {
        return (FALSE);
    }

    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    if (!lpImcP) {
        return (FALSE);
    }

    if (fSelect) {      // init "every" fields of hPrivate, please!!!
#if !defined(ROMANIME)
        lpImcP->iImeState = CST_INIT;           // init the IME state machine
        lpImcP->fdwImeMsg = 0;                  // no message be generated now
        lpImcP->dwCompChar = 0;
        lpImcP->fdwGcsFlag = 0;
        lpImcP->fdwInit = 0;

        *(LPDWORD)lpImcP->bSeq = 0;
#if defined(CHAJEI) || defined(QUICK) || defined(WINAR30) || defined(UNIIME)
        *(LPDWORD)&lpImcP->bSeq[4] = 0;
#endif
#endif

        lpIMC->fOpen = TRUE;

        if (!(lpIMC->fdwInit & INIT_CONVERSION)) {
            lpIMC->fdwConversion = (lpIMC->fdwConversion & IME_CMODE_SOFTKBD) |
                IME_CMODE_NATIVE;
            lpIMC->fdwInit |= INIT_CONVERSION;
        }

#if !defined(ROMANIME)
        if (lpIMC->fdwConversion & IME_CMODE_SOFTKBD) {
            lpImcP->fdwImeMsg |= MSG_ALREADY_SOFTKBD;
        }

        if (lpIMC->fdwInit & INIT_SENTENCE) {
        } else if (lpImeL->fdwModeConfig & MODE_CONFIG_PREDICT) {
            *(LPWORD)&lpIMC->fdwSentence |= IME_SMODE_PHRASEPREDICT;
        } else {
        }
#endif

        if (!(lpIMC->fdwInit & INIT_LOGFONT)) {
            HDC hDC;
            HGDIOBJ hSysFont;

            hDC = GetDC(NULL);
            hSysFont = GetCurrentObject(hDC, OBJ_FONT);
            GetObject(hSysFont, sizeof(LOGFONT), &lpIMC->lfFont.A);
            ReleaseDC(NULL, hDC);

            lpIMC->fdwInit |= INIT_LOGFONT;
        }

        // if this IME is run under Chicago Simplified Chinese version
        lpIMC->lfFont.A.lfCharSet = NATIVE_CHARSET;

        InitContext(
#if defined(UNIIME)
            lpImeL,
#endif
            lpIMC, lpImcP);
    }

    ImmUnlockIMCC(lpIMC->hPrivate);

    return (TRUE);
}

/**********************************************************************/
/* ImeSelect() / UniImeSelect()                                       */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
#if defined(UNIIME)
BOOL WINAPI UniImeSelect(
    LPINSTDATAL lpInstL,
    LPIMEL      lpImeL,
#else
BOOL WINAPI ImeSelect(
#endif
    HIMC   hIMC,
    BOOL   fSelect)
{
    LPINPUTCONTEXT lpIMC;
    BOOL           fRet;

    if (!hIMC) {
        return (TRUE);
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return (FALSE);
    }

#if !defined(ROMANIME)
    // to load/free IME table
    if (fSelect) {
        if (!lpInstL->cRefCount++) {
            LoadTable(lpInstL, lpImeL);
        }
    } else {
        if (!--lpInstL->cRefCount) {
            FreeTable(lpInstL);
        }
    }
#endif

    fRet = Select(
#if defined(UNIIME)
        lpImeL,
#endif
        lpIMC, fSelect);

    ImmUnlockIMC(hIMC);

    return (fRet);
}

/**********************************************************************/
/* ImeSetActiveContext() / UniImeSetActiveContext()                   */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
#if defined(UNIIME)
BOOL WINAPI UniImeSetActiveContext(
    LPINSTDATAL lpInstL,
    LPIMEL      lpImeL,
#else
BOOL WINAPI ImeSetActiveContext(
#endif
    HIMC        hIMC,
    BOOL        fOn)
{
    if (!fOn) {
    } else if (!hIMC) {
    } else {
        LPINPUTCONTEXT lpIMC;
        LPPRIVCONTEXT  lpImcP;

        lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
        if (!lpIMC) {
            goto SetActSyncDic;
        }

        lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
        if (!lpImcP) {
            goto SetActUnlockIMC;
        }

        InitContext(
#if defined(UNIIME)
            lpImeL,
#endif
            lpIMC, lpImcP);

        ImmUnlockIMCC(lpIMC->hPrivate);
SetActUnlockIMC:
        ImmUnlockIMC(hIMC);

SetActSyncDic:
        ;       // NULL statement for goto
#if !defined(ROMANIME) && !defined(WINIME) && !defined(UNICDIME)
        if (lpImeL->szUsrDic[0]) {
            if (lpInstL->hUsrDicMem) {
            } else if (lpImeL->fdwErrMsg & (ERRMSG_LOAD_USRDIC|
                ERRMSG_MEM_USRDIC)) {
            } else if (lpInstL->fdwTblLoad != TBL_LOADED) {
            } else {
                LoadUsrDicFile(lpInstL, lpImeL);
            }
        } else {
            if (lpInstL->hUsrDicMem) {
                CloseHandle(lpInstL->hUsrDicMem);
                lpInstL->hUsrDicMem = (HANDLE)NULL;
            }
        }
#endif
    }

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\compose.c ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    COMPOSE.c

++*/

#include <windows.h>
#include <immdev.h>
#include "imeattr.h"
#include "imedefs.h"

#if !defined(ROMANIME)
BOOL  IsBig5Character( WCHAR  wChar )
{
    CHAR  szBig5[3];
    WCHAR wszUnicode[2];
    BOOL  bUsedDefaultChar;

    wszUnicode[0] = wChar;
    wszUnicode[1] = 0x0000;

    WideCharToMultiByte(NATIVE_ANSI_CP, WC_COMPOSITECHECK,
                        wszUnicode, -1, szBig5,
                        sizeof(szBig5), NULL, &bUsedDefaultChar);


    if ( bUsedDefaultChar != TRUE )
        return TRUE;
    else
        return FALSE;

}

#endif

#if !defined(ROMANIME)
/**********************************************************************/
/* AddCodeIntoCand()                                                  */
/**********************************************************************/
void PASCAL AddCodeIntoCand(
#ifdef UNIIME
    LPIMEL      lpImeL,
#endif
    LPCANDIDATELIST lpCandList,
    UINT            uCode)
{
    if (lpCandList->dwCount >= MAXCAND) {
        // Grow memory here and do something,
        // if you still want to process it.
        return;
    }

#ifndef UNICODE
    // swap lead byte & second byte, UNICODE don't need it
    uCode = HIBYTE(uCode) | (LOBYTE(uCode) << 8);
#endif

    // Before add this char, check if BIG5ONLY mode is set
    // if BIG5ONLY is set, and the character is out of Big5 Range
    // we just ignore this character.

    if ( lpImeL->fdwModeConfig & MODE_CONFIG_BIG5ONLY ) {

        if ( IsBig5Character( (WCHAR)uCode ) == FALSE ) {
            // this character is not in the range of Big5 charset
            return ;
        }

    }

    // add this string into candidate list
    *(LPWSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[
        lpCandList->dwCount]) = (WCHAR)uCode;
    // null terminator
    *(LPTSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[
        lpCandList->dwCount] + sizeof(WCHAR)) = '\0';

    lpCandList->dwCount++;

    if (lpCandList->dwCount >= MAXCAND) {
        return;
    }

    lpCandList->dwOffset[lpCandList->dwCount] =
        lpCandList->dwOffset[lpCandList->dwCount - 1] +
        sizeof(WCHAR) + sizeof(TCHAR);

    return;
}

/**********************************************************************/
/* ConvertSeqCode2Pattern()                                           */
/**********************************************************************/
DWORD PASCAL ConvertSeqCode2Pattern(
#if defined(UNIIME)
    LPIMEL        lpImeL,
#endif
    LPBYTE        lpbSeqCode,
    LPPRIVCONTEXT lpImcP)
{
#if defined(CHAJEI) || defined(WINAR30)
    int   iInputEnd, iGhostCard;
    BOOL  fGhostCard;
#endif
#if defined(WINAR30)
    DWORD dwWildCardMask;
    DWORD dwLastWildCard;
    BOOL  fWildCard;
#endif
    DWORD dwPattern;
    int   i;

    // we will convert the sequence codes into compact bits
    dwPattern = 0;

#if defined(CHAJEI) || defined(WINAR30)
    iInputEnd = iGhostCard = lpImeL->nMaxKey;
    fGhostCard = FALSE;
#if defined(WINAR30)
    dwWildCardMask = 0;
    dwLastWildCard = 0;
    fWildCard = FALSE;
#endif
#endif

#if defined(CHAJEI)
    // only support X*Y

    if (lpbSeqCode[0] == GHOSTCARD_SEQCODE) {
        // not support *XY
        goto CvtPatOvr;
    } else if (lpbSeqCode[1] != GHOSTCARD_SEQCODE) {
    } else if (lpbSeqCode[3]) {
        // not support X*YZ
        goto CvtPatOvr;
    } else if (lpbSeqCode[2] == GHOSTCARD_SEQCODE) {
        // not support X**
        goto CvtPatOvr;
    } else if (lpbSeqCode[2]) {
    } else {
        // not support X*
        goto CvtPatOvr;
    }
#endif

#if defined(QUICK)
    if (lpbSeqCode[1]) {
        lpImcP->iInputEnd = 2;
    } else {
        lpImcP->iInputEnd = 1;
    }
#endif

    for (i = 0; i < lpImeL->nMaxKey; i++, lpbSeqCode++) {
        dwPattern <<= lpImeL->nSeqBits;

#if defined(WINAR30)
        dwWildCardMask <<= lpImeL->nSeqBits;
        dwLastWildCard <<= lpImeL->nSeqBits;

        if (*lpbSeqCode == WILDCARD_SEQCODE) {
            // X?Y

            if (fGhostCard) {
                // can not support wild card with ghost card X*Y?
                dwPattern = 0;
                break;
            }

            dwLastWildCard = lpImeL->dwSeqMask;

            fWildCard = TRUE;
        } else {
            dwWildCardMask |= lpImeL->dwSeqMask;
        }
#endif

#if defined(CHAJEI) || defined(WINAR30)
        if (!*lpbSeqCode) {
            if (i < iInputEnd) {
                iInputEnd = i;
            }
        }

        if (*lpbSeqCode == GHOSTCARD_SEQCODE) {
            // X*Y

            if (fGhostCard) {
                // can not support multiple ghost cards X*Y*
                dwPattern = 0;
                break;
            }

#if defined(WINAR30)
            if (fWildCard) {
                // can not support ghost card with wild card X?Y*
                dwPattern = 0;
                break;
            }

            dwLastWildCard = lpImeL->dwSeqMask;
#endif

            iGhostCard = i;
        }
#endif

#if defined(CHAJEI) || defined(WINAR30)
        if (*lpbSeqCode == GHOSTCARD_SEQCODE) {
            continue;
#if defined(WINAR30)
        } else if (*lpbSeqCode == WILDCARD_SEQCODE) {
            continue;
#endif
        } else {
        }
#endif

        dwPattern |= *lpbSeqCode;
    }

#if defined(CHAJEI)
CvtPatOvr:
#endif
    if (lpImcP) {
        lpImcP->dwPattern = dwPattern;

#if defined(QUICK)
        lpImcP->iGhostCard = 1;
#endif

#if defined(CHAJEI) || defined(WINAR30)
        if (dwPattern) {
            lpImcP->iInputEnd = iInputEnd;
            lpImcP->iGhostCard = iGhostCard;
#if defined(WINAR30)
            lpImcP->dwWildCardMask = dwWildCardMask;
            lpImcP->dwLastWildCard = dwLastWildCard;
#endif
        } else {
            lpImcP->iInputEnd = lpImcP->iGhostCard = lpImeL->nMaxKey;
#if defined(WINAR30)
            lpImcP->dwWildCardMask = lpImeL->dwPatternMask;
            lpImcP->dwLastWildCard = 0;
#endif
        }
#endif
    }

    return (dwPattern);
}

/**********************************************************************/
/* CompEscapeKey()                                                    */
/**********************************************************************/
void PASCAL CompEscapeKey(
    LPINPUTCONTEXT      lpIMC,
    LPCOMPOSITIONSTRING lpCompStr,
    LPGUIDELINE         lpGuideLine,
    LPPRIVCONTEXT       lpImcP)
{
    if (!lpGuideLine) {
        MessageBeep((UINT)-1);
    } else if (lpGuideLine->dwLevel != GL_LEVEL_NOGUIDELINE) {
        InitGuideLine(lpGuideLine);

        lpImcP->fdwImeMsg |= MSG_GUIDELINE;
    } else {
    }

    if (lpImcP->fdwImeMsg & MSG_OPEN_CANDIDATE) {
        // we have candidate window, so keep composition
    } else if ((lpImcP->fdwImeMsg & (MSG_ALREADY_OPEN|MSG_CLOSE_CANDIDATE)) ==
        (MSG_ALREADY_OPEN)) {
        // we have candidate window, so keep composition
    } else if (lpImcP->fdwImeMsg & MSG_ALREADY_START) {
        lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg|MSG_END_COMPOSITION) &
            ~(MSG_START_COMPOSITION);
    } else {
        lpImcP->fdwImeMsg &= ~(MSG_END_COMPOSITION|MSG_START_COMPOSITION);
    }

    lpImcP->iImeState = CST_INIT;
    *(LPDWORD)lpImcP->bSeq = 0;
#if defined(CHAJEI) || defined(WINAR30) || defined(UNIIME)
    *(LPDWORD)&lpImcP->bSeq[4] = 0;
#endif

    if (lpCompStr) {
        InitCompStr(lpCompStr);
        lpImcP->fdwImeMsg |= MSG_COMPOSITION;
        lpImcP->dwCompChar = VK_ESCAPE;
        lpImcP->fdwGcsFlag |= (GCS_COMPREAD|GCS_COMP|GCS_CURSORPOS|
            GCS_DELTASTART);
    }

    return;
}

/**********************************************************************/
/* CompBackSpaceKey()                                                 */
/**********************************************************************/
void PASCAL CompBackSpaceKey(
    HIMC                hIMC,
    LPINPUTCONTEXT      lpIMC,
    LPCOMPOSITIONSTRING lpCompStr,
    LPPRIVCONTEXT       lpImcP)
{
    if (lpCompStr->dwCursorPos < sizeof(WCHAR) / sizeof(TCHAR)) {
        lpCompStr->dwCursorPos = sizeof(WCHAR) / sizeof(TCHAR);
    }

    // go back a compsoition char
    lpCompStr->dwCursorPos -= sizeof(WCHAR) / sizeof(TCHAR);

    // clean the sequence code
    lpImcP->bSeq[lpCompStr->dwCursorPos / (sizeof(WCHAR) / sizeof(TCHAR))] = 0;

#if defined(PHON)
    // phonetic has index (position) for each symbol, if it is
    // no symbol for this position we back more
    for (; lpCompStr->dwCursorPos > 0; ) {
        if (lpImcP->bSeq[lpCompStr->dwCursorPos / (sizeof(WCHAR) /
            sizeof(TCHAR)) - 1]) {
            break;
        } else {
            // no symbol in this position skip
            lpCompStr->dwCursorPos -= sizeof(WCHAR) / sizeof(TCHAR);
        }
    }
#endif

    lpImcP->fdwImeMsg |= MSG_COMPOSITION;
    lpImcP->dwCompChar = '\b';
    lpImcP->fdwGcsFlag |= (GCS_COMPREAD|GCS_COMP|GCS_CURSORPOS|
        GCS_DELTASTART);

    if (!lpCompStr->dwCursorPos) {
        if (lpImcP->fdwImeMsg & (MSG_ALREADY_OPEN)) {
            ClearCand(lpIMC);
            lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CLOSE_CANDIDATE) &
                ~(MSG_OPEN_CANDIDATE);
        }

        lpImcP->iImeState = CST_INIT;

        if (lpImcP->fdwImeMsg & MSG_ALREADY_START) {
            InitCompStr(lpCompStr);
            lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_END_COMPOSITION) &
                ~(MSG_START_COMPOSITION);
            return;
        }
    }

    // reading string is composition string for some simple IMEs
    // delta start is the same as cursor position for backspace
    lpCompStr->dwCompReadAttrLen = lpCompStr->dwCompAttrLen =
        lpCompStr->dwCompReadStrLen = lpCompStr->dwCompStrLen =
        lpCompStr->dwDeltaStart = lpCompStr->dwCursorPos;
    // clause also back one
    *(LPDWORD)((LPBYTE)lpCompStr + lpCompStr->dwCompReadClauseOffset +
        sizeof(DWORD)) = lpCompStr->dwCompReadStrLen;

#if defined(WINAR30)
    // for quick key
    if (lpIMC->fdwConversion & IME_CMODE_EUDC) {
    } else if (lpImeL->fdwModeConfig & MODE_CONFIG_QUICK_KEY) {
        Finalize(hIMC, lpIMC, lpCompStr, lpImcP, FALSE);
    } else {
    }
#endif

    return;
}

#if defined(WINIME)
/**********************************************************************/
/* InternalCodeRange()                                                */
/**********************************************************************/
BOOL PASCAL InternalCodeRange(
    LPPRIVCONTEXT       lpImcP,
    WORD                wCharCode)
{
    if (!lpImcP->bSeq[0]) {
        if (wCharCode >= '8' && wCharCode <= 'F') {
            // 0x8??? - 0xF??? is OK
            return (TRUE);
        } else {
            // there is no 0x0??? - 0x7???
            return (FALSE);
        }
    } else if (!lpImcP->bSeq[1]) {
        if (lpImcP->bSeq[0] == (0x08 + 1)) {
            if (wCharCode <= '0') {
                // there is no 0x80??
                return (FALSE);
            } else {
                return (TRUE);
            }
        } else if (lpImcP->bSeq[0] == (0x0F + 1)) {
            if (wCharCode >= 'F') {
                // there is no 0xFF??
                return (FALSE);
            } else {
                return (TRUE);
            }
        } else {
            return (TRUE);
        }
    } else if (!lpImcP->bSeq[2]) {
        if (wCharCode < '4') {
            // there is no 0x??0?, 0x??1?, 0x??2?, 0x??3?
            return (FALSE);
        } else if (wCharCode < '8') {
            return (TRUE);
        } else if (wCharCode < 'A') {
            // there is no 0x??8? & 0x??9?
            return (FALSE);
        } else {
            return (TRUE);
        }
    } else if (!lpImcP->bSeq[3]) {
        if (lpImcP->bSeq[2] == (0x07 + 1)) {
            if (wCharCode >= 'F') {
               // there is no 0x??7F
                return (FALSE);
            } else {
                return (TRUE);
            }
        } else if (lpImcP->bSeq[2] == (0x0A + 1)) {
            if (wCharCode <= '0') {
                // there is no 0x??A0
                return (FALSE);
            } else {
                return (TRUE);
            }
        } else if (lpImcP->bSeq[2] == (0x0F + 1)) {
            if (wCharCode >= 'F') {
                // there is no 0x??FF
                return (FALSE);
            } else {
                return (TRUE);
            }
        } else {
            return (TRUE);
        }
    } else {
        return (TRUE);
    }
}
#endif

/**********************************************************************/
/* CompStrInfo()                                                      */
/**********************************************************************/
void PASCAL CompStrInfo(
#if defined(UNIIME)
    LPIMEL              lpImeL,
#endif
    LPCOMPOSITIONSTRING lpCompStr,
    LPPRIVCONTEXT       lpImcP,
    LPGUIDELINE         lpGuideLine,
    WORD                wCharCode)
{
#if defined(PHON)
    DWORD i;
    int   cIndex;
#endif

    register DWORD dwCursorPos;

    if (lpCompStr->dwCursorPos < lpCompStr->dwCompStrLen) {
        // for this kind of simple IME, previos is an error case
        for (dwCursorPos = lpCompStr->dwCursorPos;
            dwCursorPos < lpCompStr->dwCompStrLen;
            dwCursorPos += sizeof(WCHAR) / sizeof(TCHAR)) {
            lpImcP->bSeq[dwCursorPos / (sizeof(WCHAR) / sizeof(TCHAR))] = 0;
        }

        lpCompStr->dwCompReadAttrLen = lpCompStr->dwCompAttrLen =
        lpCompStr->dwCompReadStrLen = lpCompStr->dwCompStrLen =
            lpCompStr->dwDeltaStart = lpCompStr->dwCursorPos;

        // tell app, there is a composition char changed
        lpImcP->fdwImeMsg |= MSG_COMPOSITION;
        lpImcP->fdwGcsFlag |= GCS_COMPREAD|GCS_COMP|
            GCS_CURSORPOS|GCS_DELTASTART;
    }

#if defined(PHON)
    if (lpCompStr->dwCursorPos >= lpImeL->nMaxKey * sizeof(WCHAR) /
        sizeof(TCHAR)) {
        // this is for ImeSetCompositionString case
        if (wCharCode == ' ') {
            // finalized char is OK
            lpImcP->dwCompChar = ' ';
            return;
        }
    }
#else
    if (wCharCode == ' ') {
        // finalized char is OK
        lpImcP->dwCompChar = ' ';
        return;
    }
  #if defined(WINAR30)   //****  1996/2/5
    if (wCharCode == 0x27) {
        // finalized char is OK
        lpImcP->dwCompChar = 0x27;
        return;
    }
  #endif

    if (lpCompStr->dwCursorPos < lpImeL->nMaxKey * sizeof(WCHAR) /
        sizeof(TCHAR)) {
    } else if (lpGuideLine) {
        // exceed the max input key limitation
        lpGuideLine->dwLevel = GL_LEVEL_ERROR;
        lpGuideLine->dwIndex = GL_ID_TOOMANYSTROKE;

        lpImcP->fdwImeMsg |= MSG_GUIDELINE;
#if defined(WINAR30)  //1996/3/4
    dwCursorPos = lpCompStr->dwCursorPos;
    lpImcP->bSeq[dwCursorPos / (sizeof(WCHAR) / sizeof(TCHAR))] =
        (BYTE)lpImeL->wChar2SeqTbl[wCharCode - ' '];
#endif
        return;
    } else {
        MessageBeep((UINT)-1);
        return;
    }
#endif

    if (lpImeL->fdwErrMsg & NO_REV_LENGTH) {
        WORD nRevMaxKey;

        nRevMaxKey = (WORD)ImmEscape(lpImeL->hRevKL, (HIMC)NULL,
            IME_ESC_MAX_KEY, NULL);

        if (nRevMaxKey > lpImeL->nMaxKey) {
            lpImeL->nRevMaxKey = nRevMaxKey;

            SetCompLocalData(lpImeL);

            lpImcP->fdwImeMsg |= MSG_IMN_COMPOSITIONSIZE;
        } else {
            lpImeL->nRevMaxKey = lpImeL->nMaxKey;

            if (!nRevMaxKey) {
                lpImeL->hRevKL = NULL;
            }
        }

        lpImeL->fdwErrMsg &= ~(NO_REV_LENGTH);
    }

    if (lpImcP->fdwImeMsg & MSG_ALREADY_START) {
        lpImcP->fdwImeMsg &= ~(MSG_END_COMPOSITION);
    } else {
        lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_START_COMPOSITION) &
            ~(MSG_END_COMPOSITION);
    }

    if (lpImcP->iImeState == CST_INIT) {
        // clean the 4 bytes in one time
        *(LPDWORD)lpImcP->bSeq = 0;
#if defined(CHAJEI) || defined(WINAR30) || defined(UNIIME)
        *(LPDWORD)&lpImcP->bSeq[4] = 0;
#endif
    }

    // get the sequence code, you can treat sequence code as a kind
    // of compression - bo, po, mo, fo to 1, 2, 3, 4
    // phonetic and array table file are in sequence code format

    dwCursorPos = lpCompStr->dwCursorPos;

#if defined(PHON)
    cIndex = cIndexTable[wCharCode - ' '];

    if (cIndex * sizeof(WCHAR) / sizeof(TCHAR) >= dwCursorPos) {
    } else if (lpGuideLine) {
        lpGuideLine->dwLevel = GL_LEVEL_WARNING;
        lpGuideLine->dwIndex = GL_ID_READINGCONFLICT;

        lpImcP->fdwImeMsg |= MSG_GUIDELINE;
    } else {
    }

    if (lpImcP->iImeState != CST_INIT) {
    } else if (cIndex != 3) {
    } else if (lpGuideLine) {
        lpGuideLine->dwLevel = GL_LEVEL_WARNING;
        lpGuideLine->dwIndex = GL_ID_TYPINGERROR;

        lpImcP->fdwImeMsg |= MSG_GUIDELINE;

        return;
    } else {
        MessageBeep((UINT)-1);
        return;
    }

    lpImcP->bSeq[cIndex] = (BYTE)lpImeL->wChar2SeqTbl[wCharCode - ' '];

    for (i = lpCompStr->dwCompReadStrLen; i < cIndex * sizeof(WCHAR) /
        sizeof(TCHAR); i += sizeof(WCHAR) / sizeof(TCHAR)) {
        // clean sequence code
        lpImcP->bSeq[i / (sizeof(WCHAR) / sizeof(TCHAR))] = 0;
        // add full shape space among the blank part
        *((LPWSTR)((LPBYTE)lpCompStr + lpCompStr->dwCompReadStrOffset +
            sizeof(TCHAR) * i)) = sImeG.wFullSpace;
    }

    dwCursorPos = cIndex * sizeof(WCHAR) / sizeof(TCHAR);
#else
    lpImcP->bSeq[dwCursorPos / (sizeof(WCHAR) / sizeof(TCHAR))] =
        (BYTE)lpImeL->wChar2SeqTbl[wCharCode - ' '];
#endif

    // composition/reading string - bo po mo fo, reversed internal code
    lpImcP->dwCompChar = (DWORD)lpImeL->wSeq2CompTbl[
        lpImcP->bSeq[dwCursorPos / (sizeof(WCHAR) / sizeof(TCHAR))]];

    // assign to reading string
    *((LPWSTR)((LPBYTE)lpCompStr + lpCompStr->dwCompReadStrOffset +
        dwCursorPos * sizeof(TCHAR))) = (WCHAR)lpImcP->dwCompChar;

#if defined(PHON)
    // if the index greater, reading should be the same with index
    if (lpCompStr->dwCompReadStrLen < (cIndex + 1) * (sizeof(WCHAR) /
        sizeof(TCHAR))) {
        lpCompStr->dwCompReadStrLen = (cIndex + 1) * (sizeof(WCHAR) /
        sizeof(TCHAR));
    }
#else
    // add one composition reading for this input key
    if (lpCompStr->dwCompReadStrLen <= dwCursorPos) {
        lpCompStr->dwCompReadStrLen += sizeof(WCHAR) / sizeof(TCHAR);
    }
#endif
    // composition string is reading string for some simple IMEs
    lpCompStr->dwCompStrLen = lpCompStr->dwCompReadStrLen;

    // composition/reading attribute length is equal to reading string length
    lpCompStr->dwCompReadAttrLen = lpCompStr->dwCompReadStrLen;
    lpCompStr->dwCompAttrLen = lpCompStr->dwCompStrLen;

#ifdef UNICODE
    *((LPBYTE)lpCompStr + lpCompStr->dwCompReadAttrOffset +
        dwCursorPos) = ATTR_TARGET_CONVERTED;
#else
    // composition/reading attribute - IME has converted these chars
    *((LPWORD)((LPBYTE)lpCompStr + lpCompStr->dwCompReadAttrOffset +
        dwCursorPos)) = ((ATTR_TARGET_CONVERTED << 8)|ATTR_TARGET_CONVERTED);
#endif

    // composition/reading clause, 1 clause only
    lpCompStr->dwCompReadClauseLen = 2 * sizeof(DWORD);
    lpCompStr->dwCompClauseLen = lpCompStr->dwCompReadClauseLen;
    *(LPDWORD)((LPBYTE)lpCompStr + lpCompStr->dwCompReadClauseOffset +
        sizeof(DWORD)) = lpCompStr->dwCompReadStrLen;

    // delta start from previous cursor position
    lpCompStr->dwDeltaStart = lpCompStr->dwCursorPos;
#if defined(PHON)
    if (dwCursorPos < lpCompStr->dwDeltaStart) {
        lpCompStr->dwDeltaStart = dwCursorPos;
    }
#endif

    // cursor is next to the composition string
    lpCompStr->dwCursorPos = lpCompStr->dwCompStrLen;

    lpImcP->iImeState = CST_INPUT;

    // tell app, there is a composition char generated
    lpImcP->fdwImeMsg |= MSG_COMPOSITION;

#if !defined(UNICODE)
    // swap the char from reversed internal code to internal code
    lpImcP->dwCompChar = HIBYTE(lpImcP->dwCompChar) |
        (LOBYTE(lpImcP->dwCompChar) << 8);
#endif
    lpImcP->fdwGcsFlag |= GCS_COMPREAD|GCS_COMP|GCS_CURSORPOS|GCS_DELTASTART;

    return;
}

/**********************************************************************/
/* Finalize()                                                         */
/* Return vlaue                                                       */
/*      the number of candidates in the candidate list                */
/**********************************************************************/
UINT PASCAL Finalize(           // finalize Chinese word(s) by searching table
#if defined(UNIIME)
    LPINSTDATAL         lpInstL,
    LPIMEL              lpImeL,
#endif
    HIMC                hIMC,
    LPINPUTCONTEXT      lpIMC,
    LPCOMPOSITIONSTRING lpCompStr,
    LPPRIVCONTEXT       lpImcP,
    BOOL                fFinalized)
{
    LPCANDIDATEINFO lpCandInfo;
    LPCANDIDATELIST lpCandList;
    UINT            nCand;

#if defined(WINIME) || defined(UNICDIME)
    // quick key case
    if (!lpImcP->bSeq[1]) {
        lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CLOSE_CANDIDATE) &
            ~(MSG_OPEN_CANDIDATE|MSG_CHANGE_CANDIDATE);
        return (0);
    }
#endif

    if (!lpIMC->hCandInfo) {
        return (0);
    }

    lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo);

    if (!lpCandInfo) {
        return (0);
    }

    lpCandList = (LPCANDIDATELIST)
        ((LPBYTE)lpCandInfo + lpCandInfo->dwOffset[0]);
    // start from 0
    lpCandList->dwCount = 0;

    // default start from 0
    lpCandList->dwPageStart = lpCandList->dwSelection = 0;

#if defined(PHON)
    if (!fFinalized) {
        lpImcP->bSeq[3] = 0x26;         // ' '
    }
#endif

    if (!ConvertSeqCode2Pattern(
#if defined(UNIIME)
        lpImeL,
#endif
        lpImcP->bSeq, lpImcP)) {
        goto FinSrchOvr;
    }

#if defined(WINAR30)
    if (!fFinalized) {
        if (lpImcP->iGhostCard != lpImeL->nMaxKey) {
            // do not preview the ghost card '*'
            goto FinSrchOvr;
        } else if (lpImcP->dwLastWildCard) {
            // do not preview the wild card '?'
            goto FinSrchOvr;
        } else if (!lpImcP->bSeq[2]) {
            SearchQuickKey(lpCandList, lpImcP);
        } else {
            // search the IME tables
            SearchTbl(0, lpCandList, lpImcP);
        }
    } else {
#else
    {
#endif

        // search the IME tables
        SearchTbl(
#if defined(UNIIME)
            lpImeL,
#endif
            0, lpCandList, lpImcP);
    }

#if !defined(WINIME) && !defined(UNICDIME) && !defined(ROMANIME)
#if defined(WINAR30)
    if (!fFinalized) {
        // quick key is not in fault tolerance table & user dictionary
        goto FinSrchOvr;
    }
#endif

    if (lpInstL->hUsrDicMem) {
        SearchUsrDic(
#if defined(UNIIME)
            lpImeL,
#endif
            lpCandList, lpImcP);
    }

#endif

FinSrchOvr:
    nCand = lpCandList->dwCount;

    if (!fFinalized) {
#if defined(PHON)
        lpImcP->bSeq[3] = 0x00;         // clean previous assign one
#endif

        // for quick key
        lpCandInfo->dwCount = 1;

        // open composition candidate UI window for the string(s)
        if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
            lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CHANGE_CANDIDATE) &
                ~(MSG_CLOSE_CANDIDATE);
        } else {
            lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_OPEN_CANDIDATE) &
                ~(MSG_CLOSE_CANDIDATE);
        }
    } else if (nCand == 0) {             // nothing found, error
        // move cursor back because this is wrong
#if defined(PHON)
        // go back a compsoition char
        lpCompStr->dwCursorPos -= sizeof(WCHAR) / sizeof(TCHAR);

        for (; lpCompStr->dwCursorPos > 0; ) {
            if (lpImcP->bSeq[lpCompStr->dwCursorPos / (sizeof(WCHAR) /
                sizeof(TCHAR)) - 1]) {
                break;
            } else {
                // no symbol in this position skip
                lpCompStr->dwCursorPos -= sizeof(WCHAR) / sizeof(TCHAR);
            }
        }

        if (lpCompStr->dwCursorPos < sizeof(WCHAR) / sizeof(TCHAR)) {
            lpCompStr->dwCursorPos = 0;
            lpImcP->iImeState = CST_INIT;
        }
#elif defined(QUICK) || defined(WINIME) || defined(UNICDIME)
        if (lpCompStr->dwCursorPos > sizeof(WCHAR) / sizeof(TCHAR)) {
            lpCompStr->dwCursorPos = lpCompStr->dwCompReadStrLen -
                sizeof(WCHAR) / sizeof(TCHAR);
        } else {
            lpCompStr->dwCursorPos = 0;
            lpImcP->iImeState = CST_INIT;
        }
#else
        lpCompStr->dwCursorPos = 0;
        lpImcP->iImeState = CST_INIT;
#endif

        lpCompStr->dwDeltaStart = lpCompStr->dwCursorPos;

        if (lpImcP->fdwImeMsg & MSG_ALREADY_START) {
            lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_COMPOSITION) &
                ~(MSG_END_COMPOSITION);
        } else {
            lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_START_COMPOSITION) &
                ~(MSG_END_COMPOSITION);
        }

        // for quick key
        lpCandInfo->dwCount = 0;

        // close the quick key
        if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
            lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CLOSE_CANDIDATE) &
                ~(MSG_OPEN_CANDIDATE|MSG_CHANGE_CANDIDATE);
        } else {
            lpImcP->fdwImeMsg &= ~(MSG_OPEN_CANDIDATE|MSG_CLOSE_CANDIDATE);
        }

        lpImcP->fdwGcsFlag |= GCS_CURSORPOS|GCS_DELTASTART;
    } else if (nCand == 1) {      // only one choice
        SelectOneCand(
#if defined(UNIIME)
            lpImeL,
#endif
            hIMC, lpIMC, lpCompStr, lpImcP, lpCandList);
    } else {
        lpCandInfo->dwCount = 1;

        // there are more than one strings, open composition candidate UI window
        if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
            lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CHANGE_CANDIDATE) &
                ~(MSG_CLOSE_CANDIDATE);
        } else {
            lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_OPEN_CANDIDATE) &
                ~(MSG_CLOSE_CANDIDATE);
        }

        lpImcP->iImeState = CST_CHOOSE;
    }

    if (fFinalized) {
        LPGUIDELINE lpGuideLine;

        lpGuideLine = ImmLockIMCC(lpIMC->hGuideLine);

        if (!lpGuideLine) {
        } else if (!nCand) {
            // nothing found, end user, you have an error now

            lpGuideLine->dwLevel = GL_LEVEL_ERROR;
            lpGuideLine->dwIndex = GL_ID_TYPINGERROR;

            lpImcP->fdwImeMsg |= MSG_GUIDELINE;
        } else if (nCand == 1) {
        } else if (lpImeL->fwProperties1 & IMEPROP_CAND_NOBEEP_GUIDELINE) {
        } else {
            lpGuideLine->dwLevel = GL_LEVEL_WARNING;
            // multiple selection
            lpGuideLine->dwIndex = GL_ID_CHOOSECANDIDATE;

            lpImcP->fdwImeMsg |= MSG_GUIDELINE;
        }

        if (lpGuideLine) {
            ImmUnlockIMCC(lpIMC->hGuideLine);
        }
    }

    ImmUnlockIMCC(lpIMC->hCandInfo);

    return (nCand);
}

/**********************************************************************/
/* CompWord()                                                         */
/**********************************************************************/
void PASCAL CompWord(           // compose the Chinese word(s) according to
                                // input key
#if defined(UNIIME)
    LPINSTDATAL         lpInstL,
    LPIMEL              lpImeL,
#endif
    WORD                wCharCode,
    HIMC                hIMC,
    LPINPUTCONTEXT      lpIMC,
    LPCOMPOSITIONSTRING lpCompStr,
    LPGUIDELINE         lpGuideLine,
    LPPRIVCONTEXT       lpImcP)
{
    if (!lpCompStr) {
        MessageBeep((UINT)-1);
        return;
    }

    // escape key
    if (wCharCode == VK_ESCAPE) {       // not good to use VK as char, but...
        CompEscapeKey(lpIMC, lpCompStr, lpGuideLine, lpImcP);
        return;
    }

    if (wCharCode == '\b') {
        CompBackSpaceKey(hIMC, lpIMC, lpCompStr, lpImcP);
        return;
    }

    if (wCharCode >= 'a' && wCharCode <= 'z') {
        wCharCode ^= 0x20;
    }

#if defined(PHON)
    {
        // convert to standard phonetic layout
        wCharCode = bStandardLayout[lpImeL->nReadLayout][wCharCode - ' '];
    }
#endif

#if defined(WINIME)
    if (InternalCodeRange(lpImcP, wCharCode)) {
    } else if (lpGuideLine) {
        lpGuideLine->dwLevel = GL_LEVEL_ERROR;
        lpGuideLine->dwIndex = GL_ID_TYPINGERROR;

        lpImcP->fdwImeMsg |= MSG_GUIDELINE;
        return;
    } else {
        MessageBeep((UINT)-1);
        return;
    }
#endif

    // build up composition string info
    CompStrInfo(
#if defined(UNIIME)
        lpImeL,
#endif
        lpCompStr, lpImcP, lpGuideLine, wCharCode);

    if (lpIMC->fdwConversion & IME_CMODE_EUDC) {
#if defined(PHON) || defined(WINIME) || defined(UNICDIME)
        if (lpCompStr->dwCompReadStrLen >= sizeof(WCHAR) / sizeof(TCHAR) *
            lpImeL->nMaxKey) {
#else
        if (wCharCode == ' ') {
#endif
            lpImcP->fdwImeMsg |= MSG_COMPOSITION;
            lpImcP->fdwGcsFlag |= GCS_RESULTREAD|GCS_RESULTSTR;
        }
    } else {
#if defined(PHON) || defined(WINIME) || defined(UNICDIME)
        if (lpCompStr->dwCompReadStrLen < sizeof(WCHAR) / sizeof(TCHAR) *
            lpImeL->nMaxKey) {
#elif defined(QUICK)
        if (wCharCode != ' ' &&
            lpCompStr->dwCompReadStrLen < sizeof(WCHAR) / sizeof(TCHAR) * 2) {
#else
        if (wCharCode != ' ') {
#endif
#if defined(WINAR30)
            // quick key
           if(wCharCode != 0x27)  //19963/9
           {
            if (lpImeL->fdwModeConfig & MODE_CONFIG_QUICK_KEY) {
                Finalize(hIMC, lpIMC, lpCompStr, lpImcP, FALSE);
            }
           }
           else
           {
        Finalize(
#if defined(UNIIME)
            lpInstL, lpImeL,
#endif
            hIMC, lpIMC, lpCompStr, lpImcP, TRUE);
           }
#endif

            return;
        }

        Finalize(
#if defined(UNIIME)
            lpInstL, lpImeL,
#endif
            hIMC, lpIMC, lpCompStr, lpImcP, TRUE);
    }

    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\immsec.h ===
/*************************************************
 *  immsec.h                                     *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

PSECURITY_ATTRIBUTES CreateSecurityAttributes( );
VOID FreeSecurityAttributes( PSECURITY_ATTRIBUTES psa);
BOOL IsNT();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\data.c ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    DATA.c
    
++*/

#include <windows.h>
#include <regstr.h>
#include <immdev.h>
#include "imeattr.h"
#include "imedefs.h"

#pragma data_seg("INSTDATA")
HINSTANCE   hInst = NULL;
#if defined(UNIIME)
INSTDATAG   sInstG = {0};
#endif
#if !defined(UNIIME)
LPIMEL      lpImeL = NULL;      // per instance pointer to &sImeL
INSTDATAL   sInstL = {0};
LPINSTDATAL lpInstL = NULL;
#endif
#pragma data_seg()

#if !defined(MINIIME)
IMEG       sImeG;
#endif
#if !defined(UNIIME)
IMEL       sImeL;
#endif

#if !defined(MINIIME)

#if !defined(ROMANIME)
int   iDx[3 * CANDPERPAGE];
#endif

#if !defined(ROMANIME)
const TCHAR szDigit[] = TEXT("01234567890");
#endif

#if !defined(ROMANIME)
// convert char to upper case
const BYTE bUpper[] = {
// 0x20 - 0x27
    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
// 0x28 - 0x2F
    0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,
// 0x30 - 0x37
    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
// 0x38 - 0x3F
    0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
// 0x40 - 0x47
    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
// 0x48 - 0x4F
    0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,
// 0x50 - 0x57
    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
// 0x58 - 0x5F
    0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,
//   `    a    b    c    d    e    f    g 
    '`', 'A', 'B', 'C', 'D', 'E', 'F', 'G',
//   h    i    j    k    l    m    n    o
    'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
//   p    q    r    s    t    u    v    w
    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W',
//   x    y    z    {    |    }    ~
    'X', 'Y', 'Z', '{', '|', '}', '~'
};

const WORD fMask[] = {          // offset of bitfield
    0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080,
    0x0100, 0x0200, 0x0400, 0x0800, 0x1000, 0x2000, 0x4000, 0x8000
};

const TCHAR szRegNearCaret[] = TEXT("Control Panel\\Input Method");
const TCHAR szPhrasePtr[] = TEXT("Phrase Prediction Pointer");
const TCHAR szPhraseDic[] = TEXT("Phrase Prediction Dictionary");
const TCHAR szPara[] = TEXT("Parallel Distance");
const TCHAR szPerp[] = TEXT("Perpendicular Distance");
const TCHAR szParaTol[] = TEXT("Parallel Tolerance");
const TCHAR szPerpTol[] = TEXT("Perpendicular Tolerance");

//  0
//                                   |
//        Parallel Dist should on x, Penpendicular Dist should on y
//        LofFontHi also need to be considered as the distance
//               *-----------+
// 1 * LogFontHi |           |
//               +-----------+
//               1 * LogFontWi

//  900                                 1 * LogFontWi
//                                      +------------+
//                     -1 * LogFontHi   |            |
//                                      *------------+
//        Parallel Dist should on y, Penpendicular Dist should on x
//        LofFontHi also need be considered as distance
//                                   -

//  1800
//                                   |
//        Parallel Dist should on (- x), Penpendicular Dist should on y
//        LofFontHi do not need be considered as distance
//                                              *------------+
//                                1 * LogFontHi |            |
//                                              +------------+
//                                               1 * LogFontWi

//  2700
//                                   _
//        Parallel Dist should on (- y), Penpendicular Dist should on (- x)
//        LofFontHi also need to be considered as the distance
//                   +------------*
//     1 * LogFontHi |            |
//                   +------------+
//                   -1 * LogFontWi

// decide UI offset base on escapement
const NEARCARET ncUIEsc[] = {
   // LogFontX  LogFontY  ParaX   PerpX   ParaY   PerpY
    { 0,        1,        1,      0,      0,      1},       // 0
    { 1,        0,        0,      1,      1,      0},       // 900
    { 0,        0,       -1,      0,      0,      1},       // 1800
    {-1,        0,        0,     -1,     -1,      0}        // 2700
};


// decide input rectangle base on escapement
const POINT ptInputEsc[] = {
    // LogFontWi   LogFontHi
    {1,            1},                                  // 0
    {1,           -1},                                  // 900
    {1,            1},                                  // 1800
    {-1,           1}                                   // 2700
};

// decide another UI offset base on escapement
const NEARCARET ncAltUIEsc[] = {
   // LogFontX  LogFontY  ParaX   PerpX   ParaY   PerpY
    { 0,        0,        1,      0,      0,     -1},       // 0
    { 0,        0,        0,     -1,      1,      0},       // 900
    { 0,        0,       -1,      0,      0,     -1},       // 1800
    { 0,        0,        0,      1,     -1,      0}        // 2700
};


// decide another input rectangle base on escapement
const POINT ptAltInputEsc[] = {
    // LogFontWi   LogFontHi
    {1,           -1},                                  // 0
    {-1,          -1},                                  // 900
    {1,           -1},                                  // 1800
    {1,            1}                                   // 2700
};


#if defined(PHON)
const TCHAR szRegReadLayout[] = TEXT("Keyboard Mapping");
#endif

const TCHAR szRegRevKL[] = TEXT("Reverse Layout");
const TCHAR szRegUserDic[] = TEXT("User Dictionary");
#endif

// per user setting for
const TCHAR szRegAppUser[] = REGSTR_PATH_SETUP;
const TCHAR szRegModeConfig[] = TEXT("Mode Configuration");


// all shift keys are not for typing reading characters
const BYTE bChar2VirtKey[] = {
//   ' ' !    "    #    $    %    &    '
     0,  0,   0,   0,   0,   0,   0, VK_OEM_QUOTE,
//   (    )    *    +    ,             -             .              /
     0,   0,   0,   0, VK_OEM_COMMA, VK_OEM_MINUS, VK_OEM_PERIOD, VK_OEM_SLASH,
//   0    1    2    3    4    5    6    7
    '0', '1', '2', '3', '4', '5', '6', '7',
//   8    9    :    ;              <    =            >   ?
    '8', '9',  0, VK_OEM_SEMICLN,  0, VK_OEM_EQUAL,  0,  0,
//   @    A    B    C    D    E    F    G
     0,  'A', 'B', 'C', 'D', 'E', 'F', 'G',
//   H    I    J    K    L    M    N    O
    'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
//   P    Q    R    S    T    U    V    W
    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W',
//   X    Y    Z     [                \              ]               ^   _
    'X', 'Y', 'Z', VK_OEM_LBRACKET, VK_OEM_BSLASH, VK_OEM_RBRACKET,  0,  0
//   '           a    b    c
    , VK_OEM_3,  0,   0,   0

//  For Dayi, the above VK_OEM_3 for ROAD input,
//  For Other IMEs, it is for EURO symbol input.

};

#if defined(PHON)
// this table will convert key of other layout to the standard layout
// '!' for invalid key
const BYTE bStandardLayout[READ_LAYOUTS][0x41] = {
    {
//  ' '   !    "    #    $    %    &    '
    ' ', '!', '!', '!', '!', '!', '!', '!',
//   (    )    *    +    ,    -    .    /
    '!', '!', '!', '!', ',', '-', '.', '/',
//   0    1    2    3    4    5    6    7
    '0', '1', '2', '3', '4', '5', '6', '7',
//   8    9    :    ;    <    =    >    ?
    '8', '9', '!', ';', '<', '!', '>', '?',
//   @    A    B    C    D    E    F    G
    '!', 'A', 'B', 'C', 'D', 'E', 'F', 'G',
//   H    I    J    K    L    M    N    O
    'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
//   P    Q    R    S    T    U    V    W
    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W',
//   X    Y    Z    [    \    ]    ^    _    `
    'X', 'Y', 'Z', '!', '!', '!', '!', '!', '`'
    }
    , {
//  ' '   !    "    #    $    %    &    '
    ' ', '!', '!', '!', '!', '!', '!', 'H',
//   (    )    *    +    ,    -    .    /
    '!', '!', '!', '!', '5', '/', 'T', 'G',
//   0    1    2    3    4    5    6    7
    ';', '7', '6', '3', '4', '!', '!', 'F',
//   8    9    :    ;    <    =    >    ?
    '0', 'P', '!', 'Y', '<', '-', '>', '?',
//   @    A    B    C    D    E    F    G
    '!', '8', '1', 'V', '2', 'U', 'Z', 'R',
//   H    I    J    K    L    M    N    O
    'C', '9', 'B', 'D', 'X', 'A', 'S', 'I',
//   P    Q    R    S    T    U    V    W
    'Q', 'O', 'K', 'N', 'W', 'M', 'E', ',',
//   X    Y    Z    [    \    ]    ^    _    `
    'J', '.', 'L', '!', '!', '!', '!', '!', '`'
    }
    , {
//  ' '   !    "    #    $    %    &    '
    ' ', '!', '!', '!', '!', '!', '!', '!',
//   (    )    *    +    ,    -    .    /
    '!', '!', '!', '!', '3', 'C', '4', '7',
//   0    1    2    3    4    5    6    7
    'D', '1', 'Q', 'A', 'Z', '2', 'W', 'S',
//   8    9    :    ;    <    =    >    ?
    'X', 'E', '!', 'L', '<', '!', '>', '?',
//   @    A    B    C    D    E    F    G
    '!', 'U', '/', 'P', 'M', 'V', '8', 'I',
//   H    I    J    K    L    M    N    O
    'K', 'Y', ',', '9', 'O', '6', '-', 'H',
//   P    Q    R    S    T    U    V    W
    'N', 'R', '5', 'J', 'T', 'B', ';', 'F',
//   X    Y    Z    [    \    ]    ^    _    `
    '0', 'G', '.', '!', '!', '!', '!', '!', '`'
    }
    , {
//  ' '   !    "    #    $    %    &    '
    ' ', '!', '!', '!', '!', '!', '!', 'M',
//   (    )    *    +    ,    -    .    /
    '!', '!', '!', '!', ',', 'U', '.', '/',
//   0    1    2    3    4    5    6    7
    '0', '7', '1', '2', '!', '!', '5', '!',
//   8    9    :    ;    <    =    >    ?
    '8', '9', '!', ';', '<', '-', '>', '?',
//   @    A    B    C    D    E    F    G
    '!', '3', 'V', 'X', 'S', 'W', 'D', 'F',
//   H    I    J    K    L    M    N    O
    'G', 'I', 'H', 'K', 'L', 'N', 'B', 'O',
//   P    Q    R    S    T    U    V    W
    'P', '6', 'E', 'A', 'R', 'Y', 'C', 'Q',
//   X    Y    Z    [    \    ]    ^    _    `
    'Z', 'T', '4', 'J', '!', '!', '!', '!', '`'
    }
};

// the index (position) of bo, po, mo, and fo.
// only 0 to 3 is a valid value
const char cIndexTable[] = {
//  ' '   !    "    #    $    %    &    '
     3,   -1,  -1,  -1,  -1,  -1,  -1,  -1,
//   (    )    *    +    ,    -    .    /
     -1,  -1,  -1,  -1,  2,   2,   2,   2,
//   0    1    2    3    4    5    6    7
     2,   0,   0,   3,   3,   0,   3,   3,
//   8    9    :    ;    <    =    >    ?
     2,   2,   -1,  2,   -1,  -1,  -1,  -1,
//   @    A    B    C    D    E    F    G
     -1,  0,   0,   0,   0,   0,   0,   0,
//   H    I    J    K    L    M    N    O
     0,   2,   1,   2,   2,   1,   0,   2,
//   P    Q    R    S    T    U    V    W
     2,   0,   0,   0,   0,   1,   0,   0,
//   X    Y    Z    [    \    ]    ^    _    `
     0,   0,   0,   -1,  -1,  -1,  -1,  -1,  -1
};

// convert sequence code to index [position]
const char cSeq2IndexTbl[] = {
//    0   1   2   3   4   5   6   7
     -1,  0,  0,  0,  0,  0,  0,  0,
//    8   9  10  11  12  13  14  15
      0,  0,  0,  0,  0,  0,  0,  0,
//   16  17  18  19  20  21  22  23
      0,  0,  0,  0,  0,  0,  1,  1,
//   24  25  26  27  28  29  30  31
      1,  2,  2,  2,  2,  2,  2,  2,
//   32  33  34  35  36  37  38  39
      2,  2,  2,  2,  2,  2,  3,  3,
//   40  41  42
      3,  3,  3
};

#endif // defined(PHON)

#ifdef UNICODE
#if defined(PHON) || defined(DAYI)
const BYTE bValidFirstHex[] = {
//  0  1  2  3  4  5  6  7  8  9, A  B  C  D  E  F
    0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1
};

const BYTE bInverseEncode[] = {
//    0    1    2    3    4    5    6    7
    0x3, 0x4, 0x5, 0x0, 0x1, 0x2, 0xA, 0xB,
//    8    9,   A    B    C    D    E    F
    0xC, 0xD, 0x6, 0x7, 0x8, 0x9, 0xF, 0xE
};
#endif
#endif

#endif // !defined(MINIIME)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\imedefs.h ===
/*************************************************
 *  imedefs.h                                    *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

// IME designer can change this file according to each IME
#include "immsec.h"

// debug flag
#define DEB_FATAL               0
#define DEB_ERR                 1
#define DEB_WARNING             2
#define DEB_TRACE               3

#ifdef _WIN32
void FAR cdecl _DebugOut(UINT, LPCSTR, ...);
#endif

#define NATIVE_CHARSET          CHINESEBIG5_CHARSET
#define NATIVE_LANGUAGE         0x0404


#ifdef UNICODE
#define NATIVE_CP               1200
#define ALT_NATIVE_CP           938
#define MAX_EUDC_CHARS          6217
#else
#define NATIVE_CP               950
#define ALT_NATIVE_CP           938
#define MAX_EUDC_CHARS          5809
#endif

#define NATIVE_ANSI_CP          950


#if !defined(ROMANIME) && !defined(WINIME)
#define SIGN_CWIN               0x4E495743
#define SIGN__TBL               0x4C42545F
#endif


#if !defined(MINIIME)

#if !defined(ROMANIME)
// table load status
#define TBL_NOTLOADED           0
#define TBL_LOADED              1
#define TBL_LOADERR             2

// error MessageBox flags
#define ERRMSG_LOAD_0           0x0010
#define ERRMSG_LOAD_1           0x0020
#define ERRMSG_LOAD_2           0x0040
#define ERRMSG_LOAD_3           0x0080
#define ERRMSG_LOAD_USRDIC      0x0400
#define ERRMSG_MEM_0            0x1000
#define ERRMSG_MEM_1            0x2000
#define ERRMSG_MEM_2            0x4000
#define ERRMSG_MEM_3            0x8000
#define ERRMSG_MEM_USRDIC       0x00040000


// hack flag, I borrow one bit from fdwErrMsg for reverse conversion
#define NO_REV_LENGTH           0x80000000


// state of composition
#define CST_INIT                0
#define CST_INPUT               1
#define CST_CHOOSE              2
#define CST_SYMBOL              3
#define CST_ALPHABET            4           // not in iImeState
#endif

#if defined(DAYI)
#define CST_ROAD                5           // not in iImeState
#else
#define CST_EURO                5
#endif

#define CST_ALPHANUMERIC        6           // not in iImeState
#define CST_INVALID             7           // not in iImeState

#define CST_IME_HOTKEYS         0x40        // not in iImeState
#define CST_RESEND_RESULT       (CST_IME_HOTKEYS)
#define CST_PREVIOUS_COMP       (CST_IME_HOTKEYS+1)
#define CST_TOGGLE_UI           (CST_IME_HOTKEYS+2)

// IME specific constants
#if defined(WINAR30) || defined(DAYI)
#define CANDPERPAGE             10
#else
#define CANDPERPAGE             9
#endif

#define CHOOSE_PREVPAGE         0x10
#define CHOOSE_NEXTPAGE         0x11
#define CHOOSE_CIRCLE           0x12
#define CHOOSE_HOME             0x13

#define MAXSTRLEN               128
#define MAXCAND                 256

#define CAND_PROMPT_PHRASE      0
#define CAND_PROMPT_QUICK_VIEW  1
#define CAND_PROMPT_NORMAL      2

// max composition ways of one big5 code, it is for reverse conversion
#if defined(ROMANIME)
#define MAX_COMP                0
#elif defined(WINIME)
#define MAX_COMP                1
#else
#define MAX_COMP                10
#endif
#define MAX_COMP_BUF            10

// border for UI
#define UI_MARGIN               4

#define STATUS_DIM_X            24
#define STATUS_DIM_Y            24

#define CAND_PROMPT_DIM_X       80
#define CAND_PROMPT_DIM_Y       16

#define PAGE_DIM_X              16
#define PAGE_DIM_Y              CAND_PROMPT_DIM_Y

// if UI_MOVE_OFFSET == WINDOW_NOTDRAG, not in drag operation
#define WINDOW_NOT_DRAG         0xFFFFFFFF

// window extra for composition window
#define UI_MOVE_OFFSET          0
#define UI_MOVE_XY              4

// window extra for context menu owner
#define CMENU_HUIWND            0
#define CMENU_MENU              (CMENU_HUIWND+sizeof(LONG_PTR))
#define WND_EXTRA_SIZE          (CMENU_MENU+sizeof(LONG_PTR))

#define WM_USER_DESTROY         (WM_USER + 0x0400)
#define WM_USER_UICHANGE        (WM_USER + 0x0401)

// the flags for GetNearCaretPosition
#define NEAR_CARET_FIRST_TIME   0x0001
#define NEAR_CARET_CANDIDATE    0x0002

// the flag for an opened or start UI
#define IMN_PRIVATE_TOGGLE_UI           0x0001
#define IMN_PRIVATE_CMENUDESTROYED      0x0002

#if !defined(ROMANIME)
#define IMN_PRIVATE_COMPOSITION_SIZE    0x0003
#define IMN_PRIVATE_UPDATE_PREDICT      0x0004
#if defined(WINAR30)
#define IMN_PRIVATE_UPDATE_QUICK_KEY    0x0005
#else
#define IMN_PRIVATE_UPDATE_SOFTKBD      0x0006
#endif
#define IMN_PRIVATE_PAGEUP              0x0007
#endif

#define MSG_COMPOSITION                 0x0000001

#if !defined(ROMANIME)
#define MSG_START_COMPOSITION           0x0000002
#define MSG_END_COMPOSITION             0x0000004
#define MSG_ALREADY_START               0x0000008
#define MSG_CHANGE_CANDIDATE            0x0000010
#define MSG_OPEN_CANDIDATE              0x0000020
#define MSG_CLOSE_CANDIDATE             0x0000040
#define MSG_ALREADY_OPEN                0x0000080
#define MSG_GUIDELINE                   0x0000100
#define MSG_IMN_COMPOSITIONPOS          0x0000200
#define MSG_IMN_COMPOSITIONSIZE         0x0000400
#define MSG_IMN_UPDATE_PREDICT          0x0000800
#if defined(WINAR30)
#define MSG_IMN_UPDATE_QUICK_KEY        0x0001000
#else
#define MSG_IMN_UPDATE_SOFTKBD          0x0002000
#endif
#define MSG_ALREADY_SOFTKBD             0x0004000
#define MSG_IMN_PAGEUP                  0x0008000

// original reserve for old array, now we switch to new, no one use yet
#define MSG_CHANGE_CANDIDATE2           0x1000000
#define MSG_OPEN_CANDIDATE2             0x2000000
#define MSG_CLOSE_CANDIDATE2            0x4000000
#define MSG_ALREADY_OPEN2               0x8000000

#define MSG_STATIC_STATE                (MSG_ALREADY_START|MSG_ALREADY_OPEN|MSG_ALREADY_SOFTKBD|MSG_ALREADY_OPEN2)
#endif // !defined(ROMANIME)

#define MSG_IMN_TOGGLE_UI               0x0400000
#define MSG_IN_IMETOASCIIEX             0x0800000

#define ISC_HIDE_COMP_WINDOW            0x00400000
#define ISC_HIDE_CAND_WINDOW            0x00800000
#define ISC_HIDE_SOFTKBD                0x01000000
#define ISC_LAZY_OPERATION              (ISC_HIDE_COMP_WINDOW|ISC_HIDE_CAND_WINDOW|ISC_HIDE_SOFTKBD)
#define ISC_SHOW_SOFTKBD                0x02000000
#define ISC_OPEN_STATUS_WINDOW          0x04000000
#define ISC_OFF_CARET_UI                0x08000000
#define ISC_SHOW_PRIV_UI                (ISC_SHOW_SOFTKBD|ISC_OPEN_STATUS_WINDOW|ISC_OFF_CARET_UI)
#define ISC_SHOW_UI_ALL                 (ISC_SHOWUIALL|ISC_SHOW_SOFTKBD|ISC_OPEN_STATUS_WINDOW)
#define ISC_SETCONTEXT_UI               (ISC_SHOWUIALL|ISC_SHOW_SOFTKBD)

#if (ISC_SHOWUIALL & (ISC_LAZY_OPERATION|ISC_SHOW_PRIV_UI))
#error bit confliction
#endif

#if defined(CHAJEI) || defined(QUICK) || defined(WINAR30)
#define GHOSTCARD_SEQCODE               0x3F
#endif

#if defined(WINAR30)
#define WILDCARD_SEQCODE                0x3E
#endif

// the virtual key value
#define VK_OEM_SEMICLN                  0xba    //  ;    :
#define VK_OEM_EQUAL                    0xbb    //  =    +
#define VK_OEM_SLASH                    0xbf    //  /    ?
#define VK_OEM_LBRACKET                 0xdb    //  [    {
#define VK_OEM_BSLASH                   0xdc    //  \    |
#define VK_OEM_RBRACKET                 0xdd    //  ]    }
#define VK_OEM_QUOTE                    0xde    //  '    "


typedef DWORD UNALIGNED FAR *LPUNADWORD;
typedef WORD  UNALIGNED FAR *LPUNAWORD;
typedef WCHAR UNALIGNED *LPUNAWSTR;

#define NFULLABC        95
typedef struct tagFullABC {
    WORD wFullABC[NFULLABC];
} FULLABC;

typedef FULLABC      *PFULLABC;
typedef FULLABC NEAR *NPFULLABC;
typedef FULLABC FAR  *LPFULLABC;


#if defined(DAYI)
#define NSYMBOL         0x41
#else
#define NSYMBOL         0x40
#endif

typedef struct tagSymbol {
    WORD wSymbol[NSYMBOL];
} SYMBOL;

typedef SYMBOL      *PSYMBOL;
typedef SYMBOL NEAR *NPSYMBOL;
typedef SYMBOL FAR  *LPSYMBOL;


#define NUM_OF_IME_HOTKEYS      3

#if defined(UNIIME)
#define MAX_PHRASE_TABLES       2
#if defined(MAX_NAME_LENGTH)

#if (MAX_NAME_LENGTH) != 32
#error MAX_NAME_LENGTH not the same in other header file
#endif

#else
#define MAX_NAME_LENGTH         32
#endif

typedef struct tagPhraseTables {        // match with the IMEG
    TCHAR szTblFile[MAX_PHRASE_TABLES][MAX_NAME_LENGTH / sizeof(TCHAR)];
} PHRASETABLES;

typedef PHRASETABLES      *PPHRASETABLES;
typedef PHRASETABLES NEAR *NPPHRASETABLES;
typedef PHRASETABLES FAR  *LPPHRASETABLES;
#endif


typedef struct tagImeG {        // global structure, can be shared by all
                                // IMEs, the seperation (IMEL and IMEG) is
                                // only useful in UNI-IME, other IME can use
                                // one data structure
    RECT        rcWorkArea;     // the work area of applications
// full shape space (reversed internal code)
    WORD        wFullSpace;
// full shape chars (internal code)
    WORD        wFullABC[NFULLABC];
#ifdef HANDLE_PRIVATE_HOTKEY
// IME hot keys
                                // modifiers of IME hot key
    UINT        uModifiers[NUM_OF_IME_HOTKEYS];
                                // virtual key of IME hot key
    UINT        uVKey[NUM_OF_IME_HOTKEYS];
#endif
    UINT        uAnsiCodePage;
#if !defined(ROMANIME)
// the system charset is not NATIVE_CHARSET
    BOOL        fDiffSysCharSet;
// Chinese char width & height
    int         xChiCharWi;
    int         yChiCharHi;
#if !defined(WINAR30)
// symbol chars (internal code)
    WORD        wSymbol[NSYMBOL];
#if defined(DAYI)
    WORD        wDummy;         // DWORD boundary
#endif
#endif
#if defined(UNIIME)
    DWORD       fdwErrMsg;      // error message flag
    UINT        uPathLen;
    TCHAR       szPhrasePath[MAX_PATH];
                                // size of phrase tables
    UINT        uTblSize[MAX_PHRASE_TABLES];
                                // filename of phrase tables
    TCHAR       szTblFile[MAX_PHRASE_TABLES][MAX_NAME_LENGTH / sizeof(TCHAR)];
                                // the phrase table handle
#endif
// setting of UI
    int         iPara;
    int         iPerp;
    int         iParaTol;
    int         iPerpTol;
#endif // !defined(ROMANIME)
} IMEG;

typedef IMEG      *PIMEG;
typedef IMEG NEAR *NPIMEG;
typedef IMEG FAR  *LPIMEG;


#if defined(UNIIME)
typedef struct tagInstG {       // instance global structure, can be
                                // shared by all IMEs
    HANDLE      hMapTbl[MAX_PHRASE_TABLES];
} INSTDATAG;
#endif


typedef struct tagPRIVCONTEXT { // IME private data for each context
    BOOL        fdwImeMsg;      // what messages should be generated
    DWORD       dwCompChar;     // wParam of WM_IME_COMPOSITION
    DWORD       fdwGcsFlag;     // lParam for WM_IME_COMPOSITION
    DWORD       fdwInit;        // position init
#if !defined(ROMANIME)
    int         iImeState;      // the composition state - input, choose, or
// input data
    BYTE        bSeq[8];        // sequence code of input char
    DWORD       dwPattern;
    int         iInputEnd;
#if defined(CHAJEI) || defined(QUICK) || defined(WINAR30)
    int         iGhostCard;
#endif
#if defined(WINAR30)
    DWORD       dwWildCardMask;
    DWORD       dwLastWildCard;
#endif
// the previous dwPageStart before page up
    DWORD       dwPrevPageStart;
#endif
} PRIVCONTEXT;

typedef PRIVCONTEXT      *PPRIVCONTEXT;
typedef PRIVCONTEXT NEAR *NPPRIVCONTEXT;
typedef PRIVCONTEXT FAR  *LPPRIVCONTEXT;


typedef struct tagUIPRIV {      // IME private UI data
#if !defined(ROMANIME)
    HWND    hCompWnd;           // composition window
    int     nShowCompCmd;
    HWND    hCandWnd;           // candidate window for composition
    int     nShowCandCmd;
    HWND    hSoftKbdWnd;        // soft keyboard window
    int     nShowSoftKbdCmd;
#endif
    HWND    hStatusWnd;         // status window
    int     nShowStatusCmd;
    DWORD   fdwSetContext;      // the actions to take at set context time
    HIMC    hCacheIMC;          // the recent selected hIMC
    HWND    hCMenuWnd;          // a window owner for context menu
} UIPRIV;

typedef UIPRIV      *PUIPRIV;
typedef UIPRIV NEAR *NPUIPRIV;
typedef UIPRIV FAR  *LPUIPRIV;


typedef struct tagNEARCARET {   // for near caret offset calculatation
    int iLogFontFacX;
    int iLogFontFacY;
    int iParaFacX;
    int iPerpFacX;
    int iParaFacY;
    int iPerpFacY;
} NEARCARET;

typedef NEARCARET      *PNEARCARET;
typedef NEARCARET NEAR *NPNEARCARET;
typedef NEARCARET FAR  *LPNEARCARET;


#ifndef RC_INVOKED
#pragma pack(1)
#endif

typedef struct tagUSRDICIMHDR {
    WORD  uHeaderSize;                  // 0x00
    BYTE  idUserCharInfoSign[8];        // 0x02
    BYTE  idMajor;                      // 0x0A
    BYTE  idMinor;                      // 0x0B
    DWORD ulTableCount;                 // 0x0C
    WORD  cMethodKeySize;               // 0x10
    BYTE  uchBankID;                    // 0x12
    WORD  idInternalBankID;             // 0x13
    BYTE  achCMEXReserved1[43];         // 0x15
    WORD  uInfoSize;                    // 0x40
    BYTE  chCmdKey;                     // 0x42
    BYTE  idStlnUpd;                    // 0x43
    BYTE  cbField;                      // 0x44
    WORD  idCP;                         // 0x45
    BYTE  achMethodName[6];             // 0x47
    BYTE  achCSIReserved2[51];          // 0x4D
    BYTE  achCopyRightMsg[128];         // 0x80
} USRDICIMHDR;

typedef USRDICIMHDR      *PUSRDICIMHDR;
typedef USRDICIMHDR NEAR *NPUSRDICIMHDR;
typedef USRDICIMHDR FAR  *LPUSRDICIMHDR;


typedef struct tagMETHODNAME {
    BYTE  achMethodName[6];
} METHODNAME;

typedef METHODNAME      *PMETHODNAME;
typedef METHODNAME NEAR *NPMETHODNAME;
typedef METHODNAME FAR  *LPMETHODNAME;


#ifndef RC_INVOKED
#pragma pack()
#endif

#endif // !defined(MINIIME)


extern HINSTANCE   hInst;
#if defined(UNIIME)
extern INSTDATAG   sInstG;
#endif


#if !defined(MINIIME)
extern IMEG        sImeG;


#if !defined(ROMANIME)
extern int iDx[3 * CANDPERPAGE];

extern const TCHAR szDigit[];

extern const BYTE  bUpper[];
extern const WORD  fMask[];

extern const TCHAR szRegNearCaret[];
extern const TCHAR szPhraseDic[];
extern const TCHAR szPhrasePtr[];
extern const TCHAR szPerp[];
extern const TCHAR szPara[];
extern const TCHAR szPerpTol[];
extern const TCHAR szParaTol[];
extern const NEARCARET ncUIEsc[], ncAltUIEsc[];
extern const POINT ptInputEsc[], ptAltInputEsc[];

#if defined(PHON)
extern const TCHAR szRegReadLayout[];
#endif
extern const TCHAR szRegRevKL[];
extern const TCHAR szRegUserDic[];
#endif

extern const TCHAR szRegAppUser[];
extern const TCHAR szRegModeConfig[];

extern const BYTE  bChar2VirtKey[];

#if defined(PHON)
extern const BYTE  bStandardLayout[READ_LAYOUTS][0x41];
extern const char  cIndexTable[];
extern const char  cSeq2IndexTbl[];
#endif


#ifdef UNICODE

#if defined(PHON) || defined(DAYI)
extern const BYTE bValidFirstHex[];
extern const BYTE bInverseEncode[];

#define IsValidCode(uCode)      bValidFirstHex[uCode >> 12]
#define InverseEncode(uCode)    ((uCode & 0x0FFF) | (bInverseEncode[uCode >> 12] << 12))
#endif // defined(PHON) || defined(DAYI)

#endif // UNICODE

int WINAPI LibMain(HANDLE, WORD, WORD, LPSTR);                  // init.c
void PASCAL InitImeUIData(LPIMEL);                              // init.c
void PASCAL SetCompLocalData(LPIMEL);                           // init.c

void PASCAL SetUserSetting(
#if defined(UNIIME)
            LPIMEL,
#endif
            LPCTSTR, DWORD, LPBYTE, DWORD);                     // init.c


#if !defined(ROMANIME)
void PASCAL AddCodeIntoCand(
#if defined(UNIIME)
                            LPIMEL,
#endif
                            LPCANDIDATELIST, UINT);             // compose.c

DWORD   PASCAL ConvertSeqCode2Pattern(
#if defined(UNIIME)
               LPIMEL,
#endif
               LPBYTE, LPPRIVCONTEXT);                          // compose.c

void PASCAL CompWord(
#if defined(UNIIME)
            LPINSTDATAL, LPIMEL,
#endif
            WORD, HIMC, LPINPUTCONTEXT, LPCOMPOSITIONSTRING,
            LPGUIDELINE, LPPRIVCONTEXT);                        // compose.c

UINT PASCAL Finalize(
#if defined(UNIIME)
            LPINSTDATAL, LPIMEL,
#endif
            HIMC, LPINPUTCONTEXT, LPCOMPOSITIONSTRING,
            LPPRIVCONTEXT, BOOL);                               // compose.c

void PASCAL CompEscapeKey(LPINPUTCONTEXT, LPCOMPOSITIONSTRING,
            LPGUIDELINE, LPPRIVCONTEXT);                        // compose.c


UINT PASCAL PhrasePrediction(
#if defined(UNIIME)
            LPIMEL,
#endif
            LPINPUTCONTEXT, LPCOMPOSITIONSTRING,
            LPPRIVCONTEXT);                                     // chcand.c

void PASCAL SelectOneCand(
#if defined(UNIIME)
            LPIMEL,
#endif
            HIMC, LPINPUTCONTEXT, LPCOMPOSITIONSTRING,
            LPPRIVCONTEXT, LPCANDIDATELIST);                    // chcand.c

void PASCAL CandEscapeKey(LPINPUTCONTEXT, LPPRIVCONTEXT);       // chcand.c

void PASCAL ChooseCand(
#if defined(UNIIME)
            LPINSTDATAL, LPIMEL,
#endif
            WORD, HIMC, LPINPUTCONTEXT, LPCANDIDATEINFO,
            LPPRIVCONTEXT);                                     // chcand.c

#if defined(WINAR30) || defined(DAYI)
void PASCAL SearchSymbol(WORD, HIMC, LPINPUTCONTEXT,
            LPPRIVCONTEXT);                                     // chcand.c
#endif // defined(WINAR30) || defined(DAYI)

#endif // !defined(ROMANIME)


void PASCAL InitGuideLine(LPGUIDELINE);                         // ddis.c
void PASCAL InitCompStr(LPCOMPOSITIONSTRING);                   // ddis.c
BOOL PASCAL ClearCand(LPINPUTCONTEXT);                          // ddis.c

BOOL PASCAL Select(
#if defined(UNIIME)
            LPIMEL,
#endif
            LPINPUTCONTEXT, BOOL);                              // ddis.c

UINT PASCAL TranslateImeMessage(LPTRANSMSGLIST, LPINPUTCONTEXT,
            LPPRIVCONTEXT);                                     // toascii.c

void PASCAL GenerateMessage(HIMC, LPINPUTCONTEXT,
            LPPRIVCONTEXT);                                     // notify.c

void PASCAL CompCancel(HIMC, LPINPUTCONTEXT);                   // notify.c


#if !defined(WINIME) && !defined(ROMANIME)
BOOL PASCAL ReadUsrDicToMem(
#if defined(UNIIME)
            LPINSTDATAL, LPIMEL,
#endif
            HANDLE, DWORD, UINT, UINT, UINT, UINT);             // dic.c

void PASCAL LoadUsrDicFile(LPINSTDATAL, LPIMEL);                // dic.c
#endif

#if !defined(ROMANIME)
BOOL PASCAL LoadPhraseTable(UINT, LPTSTR);                      // dic.c
#endif

#if !defined(ROMANIME)
BOOL PASCAL LoadTable(LPINSTDATAL, LPIMEL);                     // dic.c
void PASCAL FreeTable(LPINSTDATAL);                             // dic.c


#if defined(WINAR30)
void PASCAL SearchQuickKey(LPCANDIDATELIST, LPPRIVCONTEXT);     // search.c

#if defined(DAYI) || defined(UNIIME)
void PASCAL SearchPhraseTbl(
#if defined(UNIIME)
            LPIMEL,
#endif
            UINT, LPCANDIDATELIST, DWORD dwPattern);            // search.c
#endif

#endif

void PASCAL SearchTbl(
#if defined(UNIIME)
            LPIMEL,
#endif
            UINT, LPCANDIDATELIST, LPPRIVCONTEXT);              // search.c

void PASCAL SearchUsrDic(
#if defined(UNIIME)
            LPIMEL,
#endif
            LPCANDIDATELIST, LPPRIVCONTEXT);                    // search.c


DWORD PASCAL ReadingToPattern(
#if defined(UNIIME)
             LPIMEL,
#endif
             LPCTSTR, LPBYTE, BOOL);                            // regword.c
#endif


BOOL PASCAL UsrDicFileName(
#if defined(UNIIME)
            LPINSTDATAL, LPIMEL,
#endif
            HWND);                                              // config.c


void    PASCAL DrawDragBorder(HWND, LONG, LONG);                // uisubs.c
void    PASCAL DrawFrameBorder(HDC, HWND);                      // uisubs.c

void    PASCAL ContextMenu(
#if defined(UNIIME)
               LPINSTDATAL, LPIMEL,
#endif
               HWND, int, int);                                 // uisubs.c

#if 1 // MultiMonitor support
RECT PASCAL ImeMonitorWorkAreaFromWindow(HWND);                 // uisubs.c
RECT PASCAL ImeMonitorWorkAreaFromPoint(POINT);                 // uisubs.c
RECT PASCAL ImeMonitorWorkAreaFromRect(LPRECT);                 // uisubs.c
#endif

#if !defined(ROMANIME)
HWND    PASCAL GetCompWnd(HWND);                                // compui.c

void    PASCAL GetNearCaretPosition(
#if defined (UNIIME)
               LPIMEL,
#endif
               LPPOINT, UINT, UINT, LPPOINT, LPPOINT, BOOL);    // compui.c

BOOL    PASCAL AdjustCompPosition(
#if defined (UNIIME)
               LPIMEL,
#endif
               LPINPUTCONTEXT, LPPOINT, LPPOINT);               // compui.c

void    PASCAL SetCompPosition(
#if defined (UNIIME)
               LPIMEL,
#endif
               HWND, LPINPUTCONTEXT);                           // compui.c

void    PASCAL SetCompWindow(
#if defined(UNIIME)
               LPIMEL,
#endif
               HWND);                                           // compui.c

void    PASCAL MoveDefaultCompPosition(
#if defined(UNIIME)
               LPIMEL,
#endif
               HWND);                                           // compui.c

void    PASCAL ShowComp(
#if defined(UNIIME)
               LPIMEL,
#endif
               HWND, int);                                      // compui.c

void    PASCAL StartComp(
#if defined(UNIIME)
               LPINSTDATAL, LPIMEL,
#endif
               HWND);                                           // compui.c

void    PASCAL EndComp(
#if defined(UNIIME)
               LPIMEL,
#endif
               HWND);                                           // compui.c

void    PASCAL ChangeCompositionSize(
#if defined(UNIIME)
               LPIMEL,
#endif
               HWND);                                           // compui.c


HWND    PASCAL GetCandWnd(HWND);                                // candui.c

BOOL    PASCAL CalcCandPos(
#if defined(UNIIME)
               LPIMEL,
#endif
               LPINPUTCONTEXT, LPPOINT);                        // candui.c

void    PASCAL ShowCand(
#if defined(UNIIME)
               LPIMEL,
#endif
               HWND, int);                                      // candui.c

void    PASCAL OpenCand(
#if defined(UNIIME)
               LPINSTDATAL, LPIMEL,
#endif
               HWND);                                           // candui.c

void    PASCAL CloseCand(
#if defined(UNIIME)
               LPIMEL,
#endif
               HWND);                                           // candui.c

void    PASCAL CandPageSize(HWND, BOOL);                        // candui.c

#endif // !defined(ROMANIME)

HWND    PASCAL GetStatusWnd(HWND);                              // statusui.c

LRESULT PASCAL SetStatusWindowPos(
#if defined(UNIIME)
               LPIMEL,
#endif
               HWND);                                           // statusui.c

void    PASCAL AdjustStatusBoundary(
#if defined(UNIIME)
               LPIMEL,
#endif
               LPPOINT);                                        // statusui.c

void    PASCAL DestroyStatusWindow(HWND);                       // statusui.c

void    PASCAL ShowStatus(
#if defined(UNIIME)
               LPIMEL,
#endif
               HWND, int);                                      // statusui.c

void    PASCAL OpenStatus(
#if defined(UNIIME)
               LPINSTDATAL, LPIMEL,
#endif
               HWND);                                           // statusui.c

void    PASCAL SetStatus(
#if defined(UNIIME)
               LPIMEL,
#endif
               HWND, LPPOINT);                                  // statusui.c

void    PASCAL ResourceLocked(
#if defined(UNIIME)
               LPIMEL,
#endif
               HWND);                                           // statusui.c

void    PASCAL PaintStatusWindow(
#if defined(UNIIME)
               LPINSTDATAL, LPIMEL,
#endif
               HWND, HDC);                                      // statusui.c


BOOL    PASCAL MouseSelectCandPage(
#if defined(UNIIME)
               LPIMEL,
#endif
               HWND, WORD);                                     // offcaret.c

#endif // !defined(MINIIME)

#if !defined(UNIIME)

LRESULT CALLBACK UIWndProc(HWND, UINT, WPARAM, LPARAM);         // ui.c

LRESULT CALLBACK CompWndProc(HWND, UINT, WPARAM, LPARAM);       // compui.c

LRESULT CALLBACK CandWndProc(HWND, UINT, WPARAM, LPARAM);       // candui.c

LRESULT CALLBACK StatusWndProc(HWND, UINT, WPARAM, LPARAM);     // statusui.c

LRESULT CALLBACK OffCaretWndProc(HWND, UINT, WPARAM, LPARAM);   // offcaret.c

LRESULT CALLBACK ContextMenuWndProc(HWND, UINT, WPARAM,
                 LPARAM);                                       // uisubs.c

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\dic.c ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    DIC.c
    
++*/
#include <windows.h>
#include <winerror.h>
#include <immdev.h>
#include "imeattr.h"
#include "imedefs.h"
#include "imerc.h"

#if !defined(ROMANIME)
#if !defined(WINIME) && !defined(UNICDIME)
/**********************************************************************/
/* MemoryLess()                                                       */
/**********************************************************************/
void PASCAL MemoryLess(
#if defined(UNIIME)
    LPINSTDATAL lpInstL,
    LPIMEL      lpImeL,
#endif
    DWORD       fdwErrMsg)
{
    TCHAR szErrMsg[64];

    if (lpImeL->fdwErrMsg & fdwErrMsg) {
        // message already prompted
        return;
    }

    LoadString(hInst, IDS_MEM_LESS_ERR, szErrMsg, sizeof(szErrMsg)/sizeof(TCHAR));

    lpImeL->fdwErrMsg |= fdwErrMsg;
    MessageBeep((UINT)-1);
    MessageBox((HWND)NULL, szErrMsg, lpImeL->szIMEName,
        MB_OK|MB_ICONHAND|MB_TASKMODAL|MB_TOPMOST);

    return;
}

/**********************************************************************/
/* ReadUsrDicToMem()                                                  */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL PASCAL ReadUsrDicToMem(
#if defined(UNIIME)
    LPINSTDATAL lpInstL,
    LPIMEL      lpImeL,
#endif
    HANDLE      hUsrDicFile,
    DWORD       dwUsrDicSize,
    UINT        uUsrDicSize,
    UINT        uRecLen,
    UINT        uReadLen,
    UINT        uWriteLen)
{
    LPBYTE lpUsrDicMem, lpMem, lpMemLimit;
    DWORD  dwPos, dwReadByte;

    if (dwUsrDicSize < 258) {   // no char in this dictionary
        return (TRUE);
    }

    lpUsrDicMem = MapViewOfFile(lpInstL->hUsrDicMem, FILE_MAP_WRITE, 0, 0,
        uUsrDicSize + 20);

    if (!lpUsrDicMem) {
        CloseHandle(lpInstL->hUsrDicMem);
        MemoryLess(
#if defined(UNIIME)
            lpInstL, lpImeL,
#endif
            ERRMSG_MEM_USRDIC);
        lpInstL->hUsrDicMem = NULL;
        return (FALSE);
    }

    lpMemLimit = lpUsrDicMem + uUsrDicSize;

    // read in data, skip header - two headers are similiar
    dwPos = SetFilePointer(hUsrDicFile, 258, (LPLONG)NULL, FILE_BEGIN);

    for (lpMem = lpUsrDicMem; dwPos < dwUsrDicSize; lpMem += uWriteLen) {
        short i;
        DWORD dwPattern;
        BOOL  retVal;

        if (lpMem >= lpMemLimit) {
            break;
        }

        retVal = ReadFile(hUsrDicFile, lpMem, uReadLen, &dwReadByte,
                          (LPOVERLAPPED)NULL);

        if ( retVal == FALSE )
        {
            UnmapViewOfFile(lpUsrDicMem);
            CloseHandle(lpInstL->hUsrDicMem);
            MemoryLess(
#if defined(UNIIME)
                lpInstL, lpImeL,
#endif
                ERRMSG_MEM_USRDIC);
            lpInstL->hUsrDicMem = NULL;
            return (FALSE);
        }
           
        // Compress the sequence code and put the first char most significant.
        // Limitation - 32 bits only

        dwPattern = 0;

        for (i = 0; i < lpImeL->nMaxKey; i++) {
            dwPattern <<= lpImeL->nSeqBits;
            dwPattern |= *(lpMem + 2 + i);
        }

        *(LPUNADWORD)(lpMem + 2) = dwPattern;

        // go to next record
        dwPos = SetFilePointer(hUsrDicFile, dwPos + uRecLen, (LPLONG)NULL,
            FILE_BEGIN);
    }

    UnmapViewOfFile(lpUsrDicMem);

    return (TRUE);
}

/**********************************************************************/
/* LoadUsrDicFile()                                                   */
/* Description:                                                       */
/*      try to convert to sequence code format, compression and       */
/*      don't use two way to search                                   */
/**********************************************************************/
void PASCAL LoadUsrDicFile(             // load user dic file into memory
    LPINSTDATAL lpInstL,
    LPIMEL      lpImeL)
{
    HANDLE hReadUsrDicMem;
    HANDLE hUsrDicFile;
    DWORD  dwUsrDicFileSize;
    UINT   uRecLen, uReadLen, uWriteLen;
    UINT   uUsrDicSize;
    BOOL   fRet;
    PSECURITY_ATTRIBUTES psa;

    // no user dictionary
    if (!lpImeL->szUsrDicMap[0]) {
        lpImeL->uUsrDicSize = 0;
        CloseHandle(lpInstL->hUsrDicMem);
        lpInstL->hUsrDicMem = NULL;
        lpImeL->fdwErrMsg &= ~(ERRMSG_LOAD_USRDIC | ERRMSG_MEM_USRDIC);
        return;
    }

    psa = CreateSecurityAttributes();

    if (lpInstL->hUsrDicMem) {
        // the memory is already here
        goto LoadUsrDicErrMsg;
    }

    hReadUsrDicMem = OpenFileMapping(FILE_MAP_READ, FALSE,
        lpImeL->szUsrDicMap);

    if (hReadUsrDicMem) {
        // another process already create a mapping file, we will use it
        goto LoadUsrDicMem;
    }

    // read the user dic file into memory
    hUsrDicFile = CreateFile(lpImeL->szUsrDic, GENERIC_READ,
        FILE_SHARE_READ|FILE_SHARE_WRITE,
        psa, OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);

    if (hUsrDicFile != INVALID_HANDLE_VALUE) {  // OK
        goto OpenUsrDicFile;
    }

    // if the work station version, SHARE_WRITE may fail
    hUsrDicFile = CreateFile(lpImeL->szUsrDic, GENERIC_READ,
        FILE_SHARE_READ,
        psa, OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);

OpenUsrDicFile:
    if (hUsrDicFile != INVALID_HANDLE_VALUE) {  // OK
        lpImeL->fdwErrMsg &= ~(ERRMSG_LOAD_USRDIC);
    } else if (lpImeL->fdwErrMsg & ERRMSG_LOAD_USRDIC) {
        // already prompt error message before, no more
        FreeSecurityAttributes(psa);
        return;
    } else {
        TCHAR szFmtStr[64];
        TCHAR szErrMsg[2 * MAX_PATH];

        // temp use szIMEName as format string buffer of error message
        LoadString(hInst, IDS_FILE_OPEN_ERR, szFmtStr, sizeof(szFmtStr)/sizeof(TCHAR));
        wsprintf(szErrMsg, szFmtStr, lpImeL->szUsrDic);

        lpImeL->fdwErrMsg |= ERRMSG_LOAD_USRDIC;
        MessageBeep((UINT)-1);
        MessageBox((HWND)NULL, szErrMsg, lpImeL->szIMEName,
            MB_OK|MB_ICONHAND|MB_TASKMODAL|MB_TOPMOST);
        FreeSecurityAttributes(psa);
        return;
    }

    // one record length - only sequence code, now
    uRecLen = lpImeL->nMaxKey + 4;
    // read sequence code and internal code
    uReadLen = lpImeL->nMaxKey + 2;
    // length write into memory handle
    uWriteLen = lpImeL->nSeqBytes + 2;

    // get the length of the file
    dwUsrDicFileSize = GetFileSize(hUsrDicFile, (LPDWORD)NULL);
    uUsrDicSize = (UINT)(dwUsrDicFileSize - 256) / uRecLen * uWriteLen;

    // max EUDC chars
    lpInstL->hUsrDicMem = CreateFileMapping(INVALID_HANDLE_VALUE,
        psa, PAGE_READWRITE, 0, MAX_EUDC_CHARS * uWriteLen + 20,
        lpImeL->szUsrDicMap);

    if (!lpInstL->hUsrDicMem) {
        MemoryLess(
#if defined(UNIIME)
            lpInstL, lpImeL,
#endif
            ERRMSG_MEM_USRDIC);
        fRet = FALSE;
    } else if (GetLastError() == ERROR_ALREADY_EXISTS) {
        // another process also create another one, we will use it
        hReadUsrDicMem = OpenFileMapping(FILE_MAP_READ, FALSE,
            lpImeL->szUsrDicMap);
        CloseHandle(lpInstL->hUsrDicMem);
        CloseHandle(hUsrDicFile);

        if (hReadUsrDicMem != NULL) {  // OK
            lpInstL->hUsrDicMem = hReadUsrDicMem;
            lpImeL->uUsrDicSize = uUsrDicSize;
            lpImeL->fdwErrMsg &= ~(ERRMSG_MEM_USRDIC);
        } else {
            MemoryLess(
#if defined(UNIIME)
                lpInstL, lpImeL,
#endif
                ERRMSG_MEM_USRDIC);
            lpInstL->hUsrDicMem = NULL;
        }

        FreeSecurityAttributes(psa);
        return;
    } else {
        fRet = ReadUsrDicToMem(
#if defined(UNIIME)
            lpInstL, lpImeL,
#endif
            hUsrDicFile, dwUsrDicFileSize, uUsrDicSize, uRecLen,
            uReadLen, uWriteLen);
    }

    CloseHandle(hUsrDicFile);

    if (!fRet) {
        if (lpInstL->hUsrDicMem) {
            CloseHandle(lpInstL->hUsrDicMem);
            lpInstL->hUsrDicMem = NULL;
        }
        FreeSecurityAttributes(psa);
        return;
    }

    // open a read only memory for EUDC table
    hReadUsrDicMem = OpenFileMapping(FILE_MAP_READ, FALSE,
        lpImeL->szUsrDicMap);

    // reopen a read file and close the original write file
    CloseHandle(lpInstL->hUsrDicMem);

    lpImeL->uUsrDicSize = uUsrDicSize;

LoadUsrDicMem:
    lpInstL->hUsrDicMem = hReadUsrDicMem;
LoadUsrDicErrMsg:
    lpImeL->fdwErrMsg &= ~(ERRMSG_LOAD_USRDIC | ERRMSG_MEM_USRDIC);

    FreeSecurityAttributes(psa);

    return;
}

/**********************************************************************/
/* LoadOneTable()                                                     */
/* Description:                                                       */
/*      memory handle & size of .TBL file will be assigned to         */
/*      lpImeL                                                        */
/* Eeturn Value:                                                      */
/*      length of directory of the .TBL file                          */
/**********************************************************************/
UINT PASCAL LoadOneTable(       // load one of table file
#if defined(UNIIME)
    LPINSTDATAL lpInstL,
    LPIMEL      lpImeL,
#endif
    LPTSTR      szTable,        // file name of .TBL
    UINT        uIndex,         // the index of array to store memory handle
    UINT        uLen,           // length of the directory
    LPTSTR      szPath)         // buffer for directory
{
    HANDLE  hTblFile;
    HGLOBAL hMap;
    DWORD   dwFileSize;
    PSECURITY_ATTRIBUTES psa;

    if (lpInstL->hMapTbl[uIndex]) {    // already loaded
        CloseHandle(lpInstL->hMapTbl[uIndex]);
        lpInstL->hMapTbl[uIndex] = (HANDLE)NULL;
    }

    psa = CreateSecurityAttributes();

    if (uLen) {
        lstrcpy((LPTSTR)&szPath[uLen], szTable);
        hTblFile = CreateFile(szPath, GENERIC_READ,
            FILE_SHARE_READ|FILE_SHARE_WRITE,
            psa, OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);

        if (hTblFile != INVALID_HANDLE_VALUE) {
            goto OpenDicFile;
        }

        // if the work station version, SHARE_WRITE will fail
        hTblFile = CreateFile(szPath, GENERIC_READ,
            FILE_SHARE_READ, psa,
            OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
    } else {
        // try system directory next
        uLen = GetSystemDirectory(szPath, MAX_PATH);
        if (szPath[uLen - 1] != '\\') {  // consider N:\ ;
            szPath[uLen++] = '\\';
        }

        lstrcpy((LPTSTR)&szPath[uLen], szTable);
        hTblFile = CreateFile(szPath, GENERIC_READ,
            FILE_SHARE_READ|FILE_SHARE_WRITE,
            psa, OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);

        if (hTblFile != INVALID_HANDLE_VALUE) {
            goto OpenDicFile;
        }

        // if the work station version, SHARE_WRITE will fail
        hTblFile = CreateFile(szPath, GENERIC_READ,
            FILE_SHARE_READ, psa,
            OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
    }

OpenDicFile:
    // can not find the table file
    if (hTblFile != INVALID_HANDLE_VALUE) {     // OK
    } else if (lpImeL->fdwErrMsg & (ERRMSG_LOAD_0 << uIndex)) {
        // already prompt error message before, no more
        FreeSecurityAttributes(psa);
        return (0);
    } else {                    // prompt error message
        TCHAR szFmtStr[64];
        TCHAR szErrMsg[2 * MAX_PATH];
#if defined(WINAR30)
       if(uIndex==4 || uIndex==5)
       {
        return (uLen);
       }
#endif

        // temp use szIMEName as format string buffer of error message
        LoadString(hInst, IDS_FILE_OPEN_ERR, szFmtStr, sizeof(szFmtStr)/sizeof(TCHAR));
        wsprintf(szErrMsg, szFmtStr, szTable);

        lpImeL->fdwErrMsg |= ERRMSG_LOAD_0 << uIndex;
        MessageBeep((UINT)-1);
        MessageBox((HWND)NULL, szErrMsg, lpImeL->szIMEName,
            MB_OK|MB_ICONHAND|MB_TASKMODAL|MB_TOPMOST);
        FreeSecurityAttributes(psa);
        return (0);
    }

    lpImeL->fdwErrMsg &= ~(ERRMSG_LOAD_0 << uIndex);

    // create file mapping for IME tables
    hMap = CreateFileMapping((HANDLE)hTblFile, psa, PAGE_READONLY,
        0, 0, szTable);

    dwFileSize = GetFileSize(hTblFile, (LPDWORD)NULL);

    CloseHandle(hTblFile);

    FreeSecurityAttributes(psa);

    if (!hMap) {
        MemoryLess(
#if defined(UNIIME)
            lpInstL, lpImeL,
#endif
            ERRMSG_MEM_0 << uIndex);
        return (0);
    }

    lpImeL->fdwErrMsg &= ~(ERRMSG_MEM_0 << uIndex);

    lpInstL->hMapTbl[uIndex] = hMap;

    // get file length
    lpImeL->uTblSize[uIndex] = dwFileSize;
    return (uLen);
}
#endif

/**********************************************************************/
/* LoadTable()                                                        */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL PASCAL LoadTable(          // check the table files of IME, include user
                                // defined dictionary
    LPINSTDATAL lpInstL,
    LPIMEL      lpImeL)
{
#if !defined(WINIME) && !defined(UNICDIME)
    int   i;
    UINT  uLen;
    TCHAR szBuf[MAX_PATH];
#endif

    if (lpInstL->fdwTblLoad == TBL_LOADED) {
        return (TRUE);
    }

#if !defined(WINIME) && !defined(UNICDIME)
    uLen = 0;

    // A15.TBL, A234.TBL, ACODE.TBL, / PHON.TBL, PHONPTR.TBL, PHONCODE.TBL,

    for (i = 0; i < MAX_IME_TABLES; i++) {
        if (!*lpImeL->szTblFile[i]) {
        } else if (uLen = LoadOneTable(
#if defined(UNIIME)
            lpInstL, lpImeL,
#endif
            lpImeL->szTblFile[i], i, uLen, szBuf)) {
        } else {
            int j;

            for (j = 0; j < i; j++) {
                if (lpInstL->hMapTbl[j]) {
                    CloseHandle(lpInstL->hMapTbl[j]);
                    lpInstL->hMapTbl[j] = (HANDLE)NULL;
                }
            }

            lpInstL->fdwTblLoad = TBL_LOADERR;
            return (FALSE);
        }
    }
#endif

    lpInstL->fdwTblLoad = TBL_LOADED;

#if !defined(WINIME) && !defined(UNICDIME)
    if (lpImeL->szUsrDic[0]) {
        LoadUsrDicFile(lpInstL, lpImeL);
    }
#endif

    return (TRUE);
}

/**********************************************************************/
/* FreeTable()                                                        */
/**********************************************************************/
void PASCAL FreeTable(
    LPINSTDATAL lpInstL)
{
#if !defined(WINIME) && !defined(UNICDIME)
    int i;

    // A15.TBL, A234.TBL, ACODE.TBL, / PHON.TBL, PHONPTR.TBL, PHONCODE.TBL,

    for (i = 0; i < MAX_IME_TABLES; i++) {
        if (lpInstL->hMapTbl[i]) {
            CloseHandle(lpInstL->hMapTbl[i]);
            lpInstL->hMapTbl[i] = (HANDLE)NULL;
        }
    }

    // do not need to free phrase data base, maybe next IME will use it
    // uniime.dll will free it on library detach time

    if (lpInstL->hUsrDicMem) {
        CloseHandle(lpInstL->hUsrDicMem);
        lpInstL->hUsrDicMem = (HANDLE)NULL;
    }
#endif

    lpInstL->fdwTblLoad = TBL_NOTLOADED;

    return;
}
#endif // !defined(ROMANIME)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\imerc.h ===
/*************************************************
 *  imerc.h                                      *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

#define IDIC_IME_ICON                   0x0100


#define IDBM_CMODE_NATIVE               0x0100

#if !defined(MINIIME)
#define IDBM_CMODE_NONE                 0x0110

#if !defined(ROMANIME)
#define IDBM_CMODE_ALPHANUMERIC         0x0111
#endif

#define IDBM_CMODE_FULLSHAPE            0x0113
#define IDBM_CMODE_HALFSHAPE            0x0114

#if !defined(ROMANIME)
#if !defined(WINIME) && !defined(UNICDIME)
#define IDBM_CMODE_EUDC                 0x0115
#endif
#define IDBM_CMODE_SYMBOL               0x0116
#endif


#if !defined(ROMANIME)
#define IDBM_CAND_PROMPT_PHRASE         0x0120

#if defined(WINAR30)
#define IDBM_CAND_PROMPT_QUICK_VIEW     0x0121
#endif

#define IDBM_CAND_PROMPT_NORMAL         0x0122


#define IDBM_PAGEUP_HORIZ               0x0130
#define IDBM_NO_PAGEUP_HORIZ            0x0131
#define IDBM_HOME_HORIZ                 0x0132
#define IDBM_NO_HOME_HORIZ              0x0133
#define IDBM_PAGEDN_HORIZ               0x0134
#define IDBM_NO_PAGEDN_HORIZ            0x0135
#define IDBM_PAGEUP_VERT                0x0136
#define IDBM_NO_PAGEUP_VERT             0x0137
#define IDBM_PAGEDN_VERT                0x0138
#define IDBM_NO_PAGEDN_VERT             0x0139
#endif // !defined(ROMANIME)


#define IDDG_IME_CONFIG                 0x0100


#define IDMN_CONTEXT_MENU               0x0100
#endif // !defined(MINIIME)


#define IDRC_VALIDCHAR                  0x0100


#define IDRC_TABLEFILES                 0x0110

#if !defined(MINIIME)
#define IDRC_FULLABC                    0x0120
#if !defined(ROMANIME) && !defined(WINAR30)
#define IDRC_SYMBOL                     0x0121
#endif

#if defined(UNIIME)
#define IDRC_PHRASETABLES               0x0130
#endif


#define IDCR_HAND_CURSOR                0x0100
#endif // !defined(MINIIME)


#define IDS_IMENAME                     0x0100
#define IDS_IMEUICLASS                  0x0101
#define IDS_IMECOMPCLASS                0x0102
#define IDS_IMECANDCLASS                0x0103
#define IDS_IMESTATUSCLASS              0x0104
#define IDS_IMEOFFCARETCLASS            0x0105
#define IDS_IMECMENUCLASS               0x0106


#if !defined(MINIIME)
#define IDS_CHICHAR                     0x0200
#define IDS_NONE                        0x0201


#if !defined(ROMANIME) && !defined(WINIME) && !defined(UNICDIME)
#define IDS_EUDC                        0x0210
#define IDS_USRDIC_FILTER               0x0211


#define IDS_INTERNAL_TITLE              0x0220
#define IDS_INTERNAL_MSG                0x0221
#define IDS_EUDCDICFAIL_TITLE           0x0222
#define IDS_EUDCDICFAIL_MSG             0x0223
#define IDS_NOTOPEN_TITLE               0x0224
#define IDS_NOTOPEN_MSG                 0x0225
#define IDS_FILESIZE_TITLE              0x0226
#define IDS_FILESIZE_MSG                0x0227
#define IDS_HEADERSIZE_TITLE            0x0228
#define IDS_HEADERSIZE_MSG              0x0229
#define IDS_INFOSIZE_TITLE              0x022A
#define IDS_INFOSIZE_MSG                0x022B
#define IDS_CODEPAGE_TITLE              0x022E
#define IDS_CODEPAGE_MSG                0x022F
#define IDS_CWINSIGN_TITLE              0x0230
#define IDS_CWINSIGN_MSG                0x0231
#define IDS_UNMATCHED_TITLE             0x0232
#define IDS_UNMATCHED_MSG               0x0233

#define IDS_FILE_OPEN_ERR               0x0260
#define IDS_MEM_LESS_ERR                0x0261
#endif // !defined(ROMANIME) && !defined(WINIME) && !defined(UNICDIME)


#if defined(UNIIME)
#define IDS_FILE_OPEN_FAIL              0x0300
#define IDS_MEM_LACK_FAIL               0x0301
#endif


#define IDS_SHARE_VIOLATION             0x0310


#if defined(PHON)
#define IDD_DEFAULT_KB                  0x0100
#define IDD_ETEN_KB                     0x0101
#define IDD_IBM_KB                      0x0102
#define IDD_CHING_KB                    0x0103
#endif


#define IDD_OFF_CARET_UI                0x0200
#if !defined(ROMANIME)
#define IDD_QUICK_KEY                   0x0201
#define IDD_PREDICT                     0x0202

#define IDD_LAYOUT_LIST                 0x0210

#define IDD_EUDC_DIC                    0x0211
#define IDD_BIG5ONLY                    0x0212
#endif

#define IDM_SOFTKBD                     0x0100
#define IDM_SYMBOL                      0x0101
#define IDM_PROPERTIES                  0x0102
#endif // !defined(MINIIME)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\imeattr.h ===
/*************************************************
 *  imeattr.h                                    *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

#if !defined(ROMANIME)
// the mode configuration for an IME
#define MODE_CONFIG_QUICK_KEY           0x0001
#define MODE_CONFIG_PREDICT             0x0004
#define MODE_CONFIG_BIG5ONLY            0x0002

#endif

#define MODE_CONFIG_OFF_CARET_UI        0x0008

#if defined(PHON)
// the different layout for Phonetic reading
#define READ_LAYOUT_DEFAULT             0
#define READ_LAYOUT_ETEN                1
#define READ_LAYOUT_IBM                 2
#define READ_LAYOUT_CHINGYEAH           3
#define READ_LAYOUTS                    4
#endif


// the bit of fwProperties1
#define IMEPROP_CAND_NOBEEP_GUIDELINE   0x0001
#define IMEPROP_UNICODE                 0x0002


//#if !defined(WINIME) && !defined(UNICDIME) && !defined(ROMANIME)
//#define USR_DIC_SIZE    160

//typedef struct tagUsrDic {
//    TCHAR szUsrDic[USR_DIC_SIZE/sizeof(TCHAR)];
//} USRDIC;

//typedef USRDIC      *PUSRDIC;
//typedef USRDIC NEAR *NPUSRDIC;
//typedef USRDIC FAR  *LPUSRDIC;
//#endif

#define MAX_NAME_LENGTH         32

#if !defined(ROMANIME)

#if defined(UNIIME) || defined(MINIIME)
#define MAX_IME_TABLES          6
#else
#define MAX_IME_TABLES          4
#endif

typedef struct tagTableFiles {  // match with the IMEL
    TCHAR szTblFile[MAX_IME_TABLES][MAX_NAME_LENGTH / sizeof(TCHAR)];
} TABLEFILES;

typedef TABLEFILES      *PTABLEFILES;
typedef TABLEFILES NEAR *NPTABLEFILES;
typedef TABLEFILES FAR  *LPTABLEFILES;


typedef struct tagValidChar {   // match with the IMEL
    DWORD dwVersion;
    WORD  fwProperties1;
    WORD  fwProperties2;
    WORD  nMaxKey;
    WORD  nSeqCode;
    WORD  fChooseChar[6];
    WORD  wReserved1[2];
#if defined(DAYI) || defined(UNIIME) || defined(MINIIME)
    BYTE  cChooseTrans[0x60];
#endif
    WORD  fCompChar[6];
    WORD  wReserved2[2];
    WORD  wCandPerPage;
    WORD  wCandStart;
    WORD  wCandRangeStart;
    WORD  wReserved3[1];
    WORD  wSeq2CompTbl[64];
    WORD  wChar2SeqTbl[0x42];
    WORD  wReserved4[2];
#if defined(WINAR30)
    WORD  wSymbol[356];
#elif defined(DAYI)
    WORD  wSymbol[340];
#elif defined(UNIIME) || defined(MINIME)
    DWORD dwReserved5[32];
#endif
} VALIDCHAR;

typedef VALIDCHAR      *PVALIDCHAR;
typedef VALIDCHAR NEAR *NPVALIDCHAR;
typedef VALIDCHAR FAR  *LPVALIDCHAR;
#endif // !defined(ROMANIME)


typedef struct tagImeL {        // local structure, per IME structure
// interlock protection variables
    LONG        lConfigGeneral;
    LONG        lConfigRegWord;
    LONG        lConfigSelectDic;
    TCHAR       szIMEName[MAX_NAME_LENGTH / sizeof(TCHAR)];
    TCHAR       szUIClassName[MAX_NAME_LENGTH / sizeof(TCHAR)];
    TCHAR       szStatusClassName[MAX_NAME_LENGTH / sizeof(TCHAR)];
    TCHAR       szOffCaretClassName[MAX_NAME_LENGTH / sizeof(TCHAR)];
    TCHAR       szCMenuClassName[MAX_NAME_LENGTH / sizeof(TCHAR)];
// Configuration of the IME
    DWORD       fdwModeConfig;  // quick key/prediction mode
// status window
    int         xStatusWi;      // width of status window
    int         yStatusHi;      // high of status window
    int         cxStatusBorder; // border width of status window
    int         cyStatusBorder; // border height of status window
    RECT        rcStatusText;   // text position relative to status window
    RECT        rcInputText;    // input text relateive to status window
    RECT        rcShapeText;    // shape text relative to status window
#if defined(ROMANIME)
    WORD        nMaxKey;        // max key of a Chinese word
    WORD        wDummy;         // DWORD bounary
#else
    int         xCompWi;        // width
    int         yCompHi;        // height
    int         cxCompBorder;   // border width of composition window
    int         cyCompBorder;   // border height of composition window
    RECT        rcCompText;     // text position relative to composition window
// candidate list of composition
    int         xCandWi;        // width of candidate list
    int         yCandHi;        // high of candidate list
    int         cxCandBorder;   // border width of candidate list
    int         cyCandBorder;   // border height of candidate list
    int         cxCandMargin;   // interior border width of candidate list
    int         cyCandMargin;   // interior border height of candidate list
    RECT        rcCandText;     // text position relative to candidate window
    RECT        rcCandPrompt;   // candidate prompt bitmap
    RECT        rcCandPageText; // candidate page controls - up / home / down
    RECT        rcCandPageUp;   // candidate page up
    RECT        rcCandHome;     // candidate home page
    RECT        rcCandPageDn;   // candidate page down
    TCHAR       szCompClassName[MAX_NAME_LENGTH / sizeof(TCHAR)];
    TCHAR       szCandClassName[MAX_NAME_LENGTH / sizeof(TCHAR)];
    DWORD       fdwErrMsg;      // error message flag
#if !defined(WINIME) && !defined(UNICDIME)
// standard table related data
                                // size of standard table
    UINT        uTblSize[MAX_IME_TABLES];
                                // filename of tables
    TCHAR       szTblFile[MAX_IME_TABLES][MAX_NAME_LENGTH / sizeof(TCHAR)];
                                // the IME tables
// user create word related data
                                // user dictionary file name of IME
    TCHAR       szUsrDic[MAX_PATH];
                                // user dictionary map file name
    TCHAR       szUsrDicMap[MAX_PATH];
    UINT        uUsrDicSize;    // memory size of user create words table

    UINT        uUsrDicReserved1;
    UINT        uUsrDicReserved2;
// user create phrase box       // not implemented
    TCHAR       szUsrBox[MAX_PATH];
    TCHAR       szUsrBoxMap[MAX_PATH];
    UINT        uUsrBoxSize;
    UINT        uUsrBoxReserved1;
    UINT        uUsrBoxReserved2;
#endif
// the calculated sequence mask bits
    DWORD       dwSeqMask;      // the sequence bits for one stoke
    DWORD       dwPatternMask;  // the pattern bits for one result string
    int         nSeqBytes;      // how many bytes for nMaxKey sequence chars
// reverse conversion
    HKL         hRevKL;         // the HKL of reverse mapping IME
    WORD        nRevMaxKey;
// key related data
#if defined(PHON)
    WORD        nReadLayout;    // ACER, ETen, IBM, or other - phonetic only
#else
    WORD        wDummy;         // DWORD boundary
#endif
    WORD        nSeqBits;       // no. of sequence bits
    // must match with .RC file and VALIDCHAR
    DWORD       dwVersion;
    WORD        fwProperties1;
    WORD        fwProperties2;
    WORD        nMaxKey;        // max key of a Chinese word
    WORD        nSeqCode;       // no. of sequence code
    WORD        fChooseChar[6]; // valid char in choose state
                                // translate the char code to
                                // choose constants
    WORD        wReserved1[2];
#if defined(DAYI) || defined(UNIIME) || defined(MINIIME)
    BYTE        cChooseTrans[0x60];
#endif
    WORD        fCompChar[6];   // valid char in input state
    WORD        wReserved2[2];
    WORD        wCandPerPage;   // number of candidate strings per page
    WORD        wCandStart;     // 1. 2. 3. ... 0. start from 1
                                // 1. 2. 3. ... 0. range start from 0
    WORD        wCandRangeStart;
    WORD        wReserved3[1];
// convert sequence code to composition char
    WORD        wSeq2CompTbl[64];
// convert char to sequence code
    WORD        wChar2SeqTbl[0x42];
    WORD        wReserved4[2];
#if defined(WINAR30)
    WORD        wSymbol[524];
#elif defined(DAYI)
    WORD        wSymbol[340];
#elif defined(UNIIME) || defined(MINIIME)
    DWORD       fdwReserved5[32];
#endif
#endif // defined(ROMANIME)
} IMEL;

typedef IMEL      *PIMEL;
typedef IMEL NEAR *NPIMEL;
typedef IMEL FAR  *LPIMEL;


typedef struct tagInstL {       // local instance structure, per IME instance
    HINSTANCE   hInst;          // IME DLL instance handle
    LPIMEL      lpImeL;
#if !defined(ROMANIME)
    DWORD       fdwTblLoad;     // the *.TBL load status
    int         cRefCount;      // reference count
#if !defined(WINIME) && !defined(UNICDIME)
    HANDLE      hMapTbl[MAX_IME_TABLES];
    HANDLE      hUsrDicMem;     // memory handle for user dictionary
    TCHAR       szUsrDicReserved[MAX_PATH];
    UINT        uUsrDicReserved1;
    UINT        uUsrDicReserved2;
    HANDLE      hUsrBoxMem;
    TCHAR       szUsrBoxReserved[MAX_PATH];
    UINT        uUsrBoxReserved1;
    UINT        uUsrBoxReserved2;
#endif
#endif
    DWORD       dwReserved1[32];
} INSTDATAL;

typedef INSTDATAL      *PINSTDATAL;
typedef INSTDATAL NEAR *NPINSTDATAL;
typedef INSTDATAL FAR  *LPINSTDATAL;


#if !defined(UNIIME)
extern IMEL        sImeL;
extern LPIMEL      lpImeL;
extern INSTDATAL   sInstL;
extern LPINSTDATAL lpInstL;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\init.c ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    INIT.c
    
Abstract:
    IME sample source code. This is pure UNICODE implementation of IME.
    
++*/

#include <windows.h>
#include <commdlg.h>
#include <winerror.h>
#include <immdev.h>
#include "imeattr.h"
#include "imerc.h"
#include "imedefs.h"
#if defined(MINIIME) || defined(UNIIME)
#include "uniime.h"
#endif

#if !defined(MINIIME)
/**********************************************************************/
/* InitImeGlobalData()                                                */
/**********************************************************************/
void PASCAL InitImeGlobalData(void)
{
#if !defined(ROMANIME)
    TCHAR   szChiChar[4];
    HDC     hDC;
    HGDIOBJ hOldFont;
    LOGFONT lfFont;
    SIZE    lTextSize;
    int     xHalfWi[2];
#endif
    HGLOBAL hResData;
    int     i;
#if !defined(ROMANIME)
    DWORD   dwSize;
    HKEY    hKeyNearCaret;
    LONG    lRet;
#endif

    {
        RECT rcWorkArea;

        // get work area
        SystemParametersInfo(SPI_GETWORKAREA, 0, &rcWorkArea, 0);

        if (rcWorkArea.right < 2 * UI_MARGIN) {
        } else if (rcWorkArea.bottom < 2 * UI_MARGIN) {
        } else {
            sImeG.rcWorkArea = rcWorkArea;
        }
    }

    if (sImeG.wFullSpace) {
        // the global data already init 
        return;
    }

    sImeG.uAnsiCodePage = NATIVE_ANSI_CP;

#if !defined(ROMANIME)
    // get the Chinese char
    LoadString(hInst, IDS_CHICHAR, szChiChar, sizeof(szChiChar)/sizeof(TCHAR));

    // get size of Chinese char
    hDC = GetDC(NULL);

    hOldFont = GetCurrentObject(hDC, OBJ_FONT);
    GetObject(hOldFont, sizeof(LOGFONT), &lfFont);

    if (lfFont.lfCharSet != NATIVE_CHARSET) {
        // Chicago Simplified Chinese
        sImeG.fDiffSysCharSet = TRUE;
        lfFont.lfCharSet = NATIVE_CHARSET;
        lfFont.lfFaceName[0] = TEXT('\0');
    } else {
        sImeG.fDiffSysCharSet = FALSE;
    }
    lfFont.lfWeight = FW_DONTCARE;

    SelectObject(hDC, CreateFontIndirect(&lfFont));

    GetTextExtentPoint(hDC, szChiChar, lstrlen(szChiChar), &lTextSize);
    if (sImeG.rcWorkArea.right < 2 * UI_MARGIN) {
        sImeG.rcWorkArea.left = 0;
        sImeG.rcWorkArea.right = GetDeviceCaps(hDC, HORZRES);
    }
    if (sImeG.rcWorkArea.bottom < 2 * UI_MARGIN) {
        sImeG.rcWorkArea.top = 0;
        sImeG.rcWorkArea.bottom = GetDeviceCaps(hDC, VERTRES);
    }

    DeleteObject(SelectObject(hDC, hOldFont));

    ReleaseDC(NULL, hDC);

    // get text metrics to decide the width & height of composition window
    // these IMEs always use system font to show
    sImeG.xChiCharWi = lTextSize.cx;
    sImeG.yChiCharHi = lTextSize.cy;

    // if unfortunate the xChiCharWi is odd number, xHalfWi[0] != xHalfWi[1]
    xHalfWi[0] = sImeG.xChiCharWi / 2;
    xHalfWi[1] = sImeG.xChiCharWi - xHalfWi[0];

    for (i = 0; i < sizeof(iDx) / sizeof(int); i++) {
#ifdef UNICODE
        iDx[i] = sImeG.xChiCharWi;
#else
        iDx[i] = xHalfWi[i % 2];
#endif
    }
#endif

    // load full ABC chars
    hResData = LoadResource(hInst, FindResource(hInst,
        MAKEINTRESOURCE(IDRC_FULLABC), RT_RCDATA));
    *(LPFULLABC)sImeG.wFullABC = *(LPFULLABC)LockResource(hResData);
    UnlockResource(hResData);
    FreeResource(hResData);

    // full shape space
    sImeG.wFullSpace = sImeG.wFullABC[0];

#ifndef UNICODE
    // reverse internal code to internal code, NT don't need it
    for (i = 0; i < NFULLABC; i++) {
        sImeG.wFullABC[i] = (sImeG.wFullABC[i] << 8) |
            (sImeG.wFullABC[i] >> 8);
    }
#endif

#if !defined(ROMANIME) && !defined(WINAR30)
    // load symbol chars
    hResData = LoadResource(hInst, FindResource(hInst,
        MAKEINTRESOURCE(IDRC_SYMBOL), RT_RCDATA));
    *(LPSYMBOL)sImeG.wSymbol = *(LPSYMBOL)LockResource(hResData);
    UnlockResource(hResData);
    FreeResource(hResData);

#ifndef UNICODE
    // reverse internal code to internal code, UNICODE don't need it
    for (i = 0; i < NSYMBOL; i++) {
        sImeG.wSymbol[i] = (sImeG.wSymbol[i] << 8) |
            (sImeG.wSymbol[i] >> 8);
    }
#endif
#endif

#ifdef HANDLE_PRIVATE_HOTKEY
    // get IME hot key
    for (i = 0; i < NUM_OF_IME_HOTKEYS; i++) {
        ImmGetHotKey(IME_ITHOTKEY_RESEND_RESULTSTR + i, &sImeG.uModifiers[i],
            &sImeG.uVKey[i], NULL);
    }
#endif

#if defined(UNIIME)
    // phrase table files
    hResData = LoadResource(hInst, FindResource(hInst,
        MAKEINTRESOURCE(IDRC_PHRASETABLES), RT_RCDATA));
    *(LPPHRASETABLES)sImeG.szTblFile[0] =
        *(LPPHRASETABLES)LockResource(hResData);
    UnlockResource(hResData);
    FreeResource(hResData);
#endif

#if !defined(ROMANIME)
    // get the UI offset for near caret operation
    RegCreateKey(HKEY_CURRENT_USER, szRegNearCaret, &hKeyNearCaret);

#if defined(UNIIME) && defined(UNICODE)
    // if the user has its own phrase table file, we will overwrite it
    {
        TCHAR szPhraseDictionary[MAX_PATH];
        TCHAR szPhrasePointer[MAX_PATH];

        dwSize = sizeof(szPhraseDictionary);
        lRet = RegQueryValueEx(hKeyNearCaret, szPhraseDic, NULL, NULL,
            (LPBYTE)&szPhraseDictionary, &dwSize);

        if (lRet != ERROR_SUCCESS) {
            goto PharseOvr;
        }

        if (dwSize >= sizeof(szPhraseDictionary)) {
            goto PharseOvr;
        } else {
            szPhraseDictionary[dwSize / sizeof(TCHAR)] = TEXT('\0');
        }

        dwSize = sizeof(szPhrasePointer);
        lRet = RegQueryValueEx(hKeyNearCaret, szPhrasePtr, NULL, NULL,
            (LPBYTE)&szPhrasePointer, &dwSize);

        if (lRet != ERROR_SUCCESS) {
            goto PharseOvr;
        }

        if (dwSize >= sizeof(szPhrasePointer)) {
            goto PharseOvr;
        } else {
            szPhrasePointer[dwSize / sizeof(TCHAR)] = TEXT('\0');
        }

        dwSize = dwSize / sizeof(TCHAR) - 1;

        for (; dwSize > 0; dwSize--) {
            if (szPhrasePointer[dwSize] == TEXT('\\')) {
                CopyMemory(sImeG.szPhrasePath, szPhrasePointer,
                    (dwSize + 1) * sizeof(TCHAR));
                sImeG.uPathLen = dwSize + 1;

                // phrase pointer file name
                CopyMemory(sImeG.szTblFile[0], &szPhrasePointer[dwSize + 1],
                    sizeof(sImeG.szTblFile[0]));
                // phrase file name
                CopyMemory(sImeG.szTblFile[1], &szPhraseDictionary[dwSize + 1],
                    sizeof(sImeG.szTblFile[1]));
                break;
            }
        }


PharseOvr:  ; // NULL statement for goto
    }
#endif

    dwSize = sizeof(dwSize);
    lRet  = RegQueryValueEx(hKeyNearCaret, szPara, NULL, NULL,
        (LPBYTE)&sImeG.iPara, &dwSize);

    if (lRet != ERROR_SUCCESS) {
        sImeG.iPara = 0;
        RegSetValueEx(hKeyNearCaret, szPara, 0, REG_DWORD,
            (LPBYTE)&sImeG.iPara, sizeof(int));
    }

    dwSize = sizeof(dwSize);
    lRet = RegQueryValueEx(hKeyNearCaret, szPerp, NULL, NULL,
        (LPBYTE)&sImeG.iPerp, &dwSize);

    if (lRet != ERROR_SUCCESS) {
        sImeG.iPerp = sImeG.yChiCharHi;
        RegSetValueEx(hKeyNearCaret, szPerp, 0, REG_DWORD,
            (LPBYTE)&sImeG.iPerp, sizeof(int));
    }

    dwSize = sizeof(dwSize);
    lRet = RegQueryValueEx(hKeyNearCaret, szParaTol, NULL, NULL,
        (LPBYTE)&sImeG.iParaTol, &dwSize);

    if (lRet != ERROR_SUCCESS) {
        sImeG.iParaTol = sImeG.xChiCharWi * 4;
        RegSetValueEx(hKeyNearCaret, szParaTol, 0, REG_DWORD,
            (LPBYTE)&sImeG.iParaTol, sizeof(int));
    }

    dwSize = sizeof(dwSize);
    lRet = RegQueryValueEx(hKeyNearCaret, szPerpTol, NULL, NULL,
        (LPBYTE)&sImeG.iPerpTol, &dwSize);

    if (lRet != ERROR_SUCCESS) {
        sImeG.iPerpTol = sImeG.yChiCharHi;
        RegSetValueEx(hKeyNearCaret, szPerpTol, 0, REG_DWORD,
            (LPBYTE)&sImeG.iPerpTol, sizeof(int));
    }

    RegCloseKey(hKeyNearCaret);
#endif

    return;
}

/**********************************************************************/
/* GetUserSetting()                                                */
/**********************************************************************/
DWORD PASCAL GetUserSetting(
#if defined(UNIIME)
    LPIMEL  lpImeL,
#endif
    LPCTSTR lpszValueName,
    LPVOID  lpbData,
    DWORD   dwDataSize)
{
    HKEY hKeyAppUser, hKeyIMEUser;

    RegCreateKey(HKEY_CURRENT_USER, szRegAppUser, &hKeyAppUser);

    RegCreateKey(hKeyAppUser, lpImeL->szUIClassName, &hKeyIMEUser);

    RegCloseKey(hKeyAppUser);

    RegQueryValueEx(hKeyIMEUser, lpszValueName, NULL, NULL,
        lpbData, &dwDataSize);

    RegCloseKey(hKeyIMEUser);

    return (dwDataSize);
}

/**********************************************************************/
/* SetUserSetting()                                                   */
/**********************************************************************/
void PASCAL SetUserSetting(
#if defined(UNIIME)
    LPIMEL  lpImeL,
#endif
    LPCTSTR lpszValueName,
    DWORD   dwType,
    LPBYTE  lpbData,
    DWORD   dwDataSize)
{
    HKEY hKeyAppUser, hKeyIMEUser;

    RegCreateKey(HKEY_CURRENT_USER, szRegAppUser, &hKeyAppUser);

    RegCreateKey(hKeyAppUser, lpImeL->szUIClassName, &hKeyIMEUser);

    RegCloseKey(hKeyAppUser);

    RegSetValueEx(hKeyIMEUser, lpszValueName, 0, dwType, lpbData,
        dwDataSize);

    RegCloseKey(hKeyIMEUser);

    return;
}

void  RemoveRearSpaces( LPTSTR   lpStr ) 
{

    INT   iLen;

    if (lpStr == NULL )  return;

    iLen = lstrlen(lpStr);

    if ( iLen == 0 )  return;

    iLen = iLen - 1;

    while ( iLen >= 0 ) {

        if ( lpStr[iLen] == TEXT(' ') ) {
           lpStr[iLen] = TEXT('\0');
           iLen --;
        }
        else
           break;
    }

    return;

}



/**********************************************************************/
/* InitImeLocalData()                                                 */
/**********************************************************************/
BOOL PASCAL InitImeLocalData(
    LPINSTDATAL lpInstL,
    LPIMEL      lpImeL)
{
#if !defined(ROMANIME)
    HGLOBAL hResData;

    UINT    i;
    WORD    nSeqCode;
#if defined(PHON)
    UINT    nReadLayout;
#endif
#endif

    // the local data already init
    if (lpImeL->szIMEName[0]) {
        return (TRUE);
    }

    // we will use the same string length for W version so / sizeof(WORD)
    // get the IME name
    LoadString(lpInstL->hInst, IDS_IMENAME, lpImeL->szIMEName,
        sizeof(lpImeL->szIMEName) / sizeof(WCHAR));


    // get the UI class name
    LoadString(lpInstL->hInst, IDS_IMEUICLASS, lpImeL->szUIClassName,
        sizeof(lpImeL->szUIClassName) / sizeof(WCHAR));

    RemoveRearSpaces(lpImeL->szUIClassName);

#if !defined(ROMANIME)
    // get the composition class name
    LoadString(lpInstL->hInst, IDS_IMECOMPCLASS, lpImeL->szCompClassName,
        sizeof(lpImeL->szCompClassName) / sizeof(WCHAR));

    RemoveRearSpaces(lpImeL->szCompClassName);

    // get the candidate class name
    LoadString(lpInstL->hInst, IDS_IMECANDCLASS, lpImeL->szCandClassName,
        sizeof(lpImeL->szCandClassName) / sizeof(WCHAR));

    RemoveRearSpaces(lpImeL->szCandClassName);

#endif

    // get the status class name
    LoadString(lpInstL->hInst, IDS_IMESTATUSCLASS, lpImeL->szStatusClassName,
        sizeof(lpImeL->szStatusClassName) / sizeof(WCHAR));

    RemoveRearSpaces(lpImeL->szStatusClassName);

    // get the off caret class name
    LoadString(lpInstL->hInst, IDS_IMEOFFCARETCLASS,
        lpImeL->szOffCaretClassName,
        sizeof(lpImeL->szOffCaretClassName) / sizeof(WCHAR));

    RemoveRearSpaces(lpImeL->szOffCaretClassName);

    LoadString(lpInstL->hInst, IDS_IMECMENUCLASS, lpImeL->szCMenuClassName,
        sizeof(lpImeL->szCMenuClassName) / sizeof(WCHAR));

    RemoveRearSpaces(lpImeL->szCMenuClassName);

#if defined(ROMANIME)
    lpImeL->nMaxKey = 1;
#else
    // table not loaded
//  lpInstL->fdwTblLoad = TBL_NOTLOADED;
    // reference count is 0
//  lpInstL->cRefCount = 0;
    // tables are NULL
//  lpInstL->hMapTbl[] = (HANDLE)NULL;
    // user dictionary is NULL
//  lpInstL->hUsrDicMem = (HANLE)NULL;

    // load valid char in choose/input state
    hResData = LoadResource(lpInstL->hInst, FindResource(lpInstL->hInst,
        MAKEINTRESOURCE(IDRC_VALIDCHAR), RT_RCDATA));
    *(LPVALIDCHAR)&lpImeL->dwVersion = *(LPVALIDCHAR)LockResource(hResData);
    UnlockResource(hResData);
    FreeResource(hResData);

#if !defined(WINIME) && !defined(UNICDIME)
    // IME table files
    hResData = LoadResource(lpInstL->hInst, FindResource(lpInstL->hInst,
        MAKEINTRESOURCE(IDRC_TABLEFILES), RT_RCDATA));
    *(LPTABLEFILES)lpImeL->szTblFile[0] =
        *(LPTABLEFILES)LockResource(hResData);
    UnlockResource(hResData);
    FreeResource(hResData);

#ifndef UNICODE
#if defined(DAYI) || defined(WINAR30)
    for (i = 0; i < sizeof(lpImeL->wSymbol) / sizeof(WORD); i++) {
        lpImeL->wSymbol[i] = (lpImeL->wSymbol[i] << 8) |
            (lpImeL->wSymbol[i] >> 8);
    }
#endif
#endif

    // file name of user dictionary
    lpImeL->szUsrDic[0] = TEXT('\0');       // default value

    i = GetUserSetting(
#if defined(UNIIME)
        lpImeL,
#endif
        szRegUserDic, lpImeL->szUsrDic, sizeof(lpImeL->szUsrDic));

    if (i >= sizeof(lpImeL->szUsrDic)) {
        lpImeL->szUsrDic[sizeof(lpImeL->szUsrDic) / sizeof(TCHAR) - 1] = '\0';
    } else {
        lpImeL->szUsrDic[i / sizeof(TCHAR)] = '\0';
    }

    lpImeL->szUsrDicMap[0] = '\0';

    if (lpImeL->szUsrDic[0]) {
        TCHAR szTempDir[MAX_PATH];
        TCHAR szTempFile[MAX_PATH];

        GetTempPath(sizeof(szTempDir) / sizeof(TCHAR), szTempDir);

        // we do not want to create a real file so we GetTickCount
        i = (UINT)GetTickCount();

        if (!i) {
            i++;
        }

        GetTempFileName(szTempDir, lpImeL->szUIClassName, i, szTempFile);

        GetFileTitle(szTempFile, lpImeL->szUsrDicMap,
            sizeof(lpImeL->szUsrDicMap) / sizeof(TCHAR));
    }
#endif

    nSeqCode = 0x0001;

    for (i = 1; i < sizeof(DWORD) * 8; i++) {
        nSeqCode <<= 1;
        if (nSeqCode > lpImeL->nSeqCode) {
            lpImeL->nSeqBits = (WORD)i;
            break;
        }
    }

    // calculate sequence code mask for one stoke (reading char)
    if (!lpImeL->dwSeqMask) {           // check again, it is still possible
                                        // that multiple thread reach here
        for (i = 0; i < lpImeL->nSeqBits; i++) {
            lpImeL->dwSeqMask <<= 1;
            lpImeL->dwSeqMask |= 0x0001;
        }
    }

    // data bytes for one finalized char
    lpImeL->nSeqBytes = (lpImeL->nSeqBits * lpImeL->nMaxKey + 7) / 8;

    // valid bits mask for all strokes
    if (!lpImeL->dwPatternMask) {       // check again, it is still possible
                                        // that multiple thread reach here
        for (i =0; i < lpImeL->nMaxKey; i++) {
            lpImeL->dwPatternMask <<= lpImeL->nSeqBits;
            lpImeL->dwPatternMask |= lpImeL->dwSeqMask;
        }
    }

    lpImeL->hRevKL = NULL;
    GetUserSetting(
#if defined(UNIIME)
        lpImeL,
#endif
        szRegRevKL, &lpImeL->hRevKL, sizeof(lpImeL->hRevKL));

    // mark this event for later check reverse length
    if (lpImeL->hRevKL) {
        lpImeL->fdwErrMsg |= NO_REV_LENGTH;
    }

    // we assume the max key is the same as this IME, check later
    lpImeL->nRevMaxKey = lpImeL->nMaxKey;


#if defined(PHON)
    // keyboard arrangement, ACER ETen IBM ... for bo po mo fo
    nReadLayout = READ_LAYOUT_DEFAULT;                  // default value

    // can not use lpImeL->nReadLayout, its size is WORD only
    GetUserSetting(
#if defined(UNIIME)
        lpImeL,
#endif
        szRegReadLayout, &nReadLayout, sizeof(nReadLayout));

    lpImeL->nReadLayout = (WORD)nReadLayout;

    if (lpImeL->nReadLayout >= READ_LAYOUTS) {
        lpImeL->nReadLayout = READ_LAYOUT_DEFAULT;
    }
#endif
#endif

#if defined(WINAR30)
    lpImeL->fdwModeConfig = MODE_CONFIG_QUICK_KEY|MODE_CONFIG_PREDICT;
#elif defined(ROMANIME)
    lpImeL->fdwModeConfig = 0;
#else
    lpImeL->fdwModeConfig = MODE_CONFIG_PREDICT;
#endif

    GetUserSetting(
#if defined(UNIIME)
        lpImeL,
#endif
        szRegModeConfig, &lpImeL->fdwModeConfig, sizeof(lpImeL->fdwModeConfig));

    return (TRUE);
}

/**********************************************************************/
/* InitImeUIData()                                                    */
/**********************************************************************/
void PASCAL InitImeUIData(      // initialize each UI component coordination
    LPIMEL      lpImeL)
{
    int cxBorder, cyBorder, cxEdge, cyEdge, cxMinWindowWidth;

    cxEdge = GetSystemMetrics(SM_CXEDGE);
    cyEdge = GetSystemMetrics(SM_CYEDGE);

    // border + raising edge
    cxBorder = GetSystemMetrics(SM_CXBORDER);
    cyBorder = GetSystemMetrics(SM_CYBORDER);

    lpImeL->cxStatusBorder = cxBorder + cxEdge;
    lpImeL->cyStatusBorder = cyBorder + cyEdge;

    // the width/high and status position relative to status window
    lpImeL->rcStatusText.left = 0;
    lpImeL->rcStatusText.top = 0;

    lpImeL->rcStatusText.bottom = lpImeL->rcStatusText.top + STATUS_DIM_Y;

    // conversion mode status
    lpImeL->rcInputText.left = lpImeL->rcStatusText.left;
    lpImeL->rcInputText.top = lpImeL->rcStatusText.top;
    lpImeL->rcInputText.right = lpImeL->rcInputText.left + STATUS_DIM_X;
    lpImeL->rcInputText.bottom = lpImeL->rcStatusText.bottom;

    // full/half shape status
    lpImeL->rcShapeText.left = lpImeL->rcInputText.right;
    lpImeL->rcShapeText.top = lpImeL->rcStatusText.top;
    lpImeL->rcShapeText.right = lpImeL->rcShapeText.left + STATUS_DIM_X;
    lpImeL->rcShapeText.bottom = lpImeL->rcStatusText.bottom;

    lpImeL->rcStatusText.right = lpImeL->rcShapeText.right;

    lpImeL->xStatusWi = (lpImeL->rcStatusText.right -
        lpImeL->rcStatusText.left) + lpImeL->cxStatusBorder * 2;
    lpImeL->yStatusHi = (lpImeL->rcStatusText.bottom -
        lpImeL->rcStatusText.top) + lpImeL->cyStatusBorder * 2;

#if !defined(ROMANIME)
    if (lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI) {
        lpImeL->cxCompBorder = cxBorder + cxEdge;
        lpImeL->cyCompBorder = cyBorder + cyEdge;
    } else {
        lpImeL->cxCompBorder = cxBorder;
        lpImeL->cyCompBorder = cyBorder;
    }

    lpImeL->rcCompText.top = lpImeL->cyCompBorder;
    lpImeL->rcCompText.bottom = lpImeL->rcCompText.top +
        sImeG.yChiCharHi;

    // two borders, outsize & candidate inside border
    if (lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI) {
        lpImeL->cxCandBorder = cxBorder + cxEdge;
        lpImeL->cyCandBorder = cyBorder + cyEdge;
    } else {
        lpImeL->cxCandBorder = cxBorder;
        lpImeL->cyCandBorder = cyBorder;
    }

    lpImeL->cxCandMargin = cxBorder + cxEdge;
    lpImeL->cyCandMargin = cyBorder + cyEdge;

    // the width/high and text position relative to candidate window

    if (lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI) {
        lpImeL->rcCandText.top = lpImeL->cyCandBorder;
#if defined(WINAR30)
        lpImeL->rcCompText.left = lpImeL->rcStatusText.right +
            lpImeL->cxCompBorder * 2;

        lpImeL->rcCompText.right = lpImeL->rcCompText.left +
            sImeG.xChiCharWi * lpImeL->nRevMaxKey;

        lpImeL->rcCandText.left = lpImeL->rcCompText.right +
            lpImeL->cxCompBorder * 2 + lpImeL->cxCandBorder;

        lpImeL->rcCandText.right = lpImeL->rcCandText.left +
            sImeG.xChiCharWi * CANDPERPAGE * 3 / 2;
#else
        lpImeL->rcCandText.left = lpImeL->rcCompText.left =
            lpImeL->rcStatusText.right + lpImeL->cxCompBorder +
            lpImeL->cxCandBorder;

        lpImeL->rcCandText.right = lpImeL->rcCompText.right =
            lpImeL->rcCompText.left + sImeG.xChiCharWi * CANDPERPAGE * 3 / 2;
#endif

        lpImeL->rcCandText.bottom = lpImeL->rcCandText.top + sImeG.yChiCharHi;

        lpImeL->rcCandPrompt.left = lpImeL->rcCandText.right +
            lpImeL->cxCandMargin + lpImeL->cxCandBorder;
        lpImeL->rcCandPrompt.top = lpImeL->rcStatusText.top +
            (STATUS_DIM_Y - CAND_PROMPT_DIM_Y) / 2;
        lpImeL->rcCandPrompt.right = lpImeL->rcCandPrompt.left +
            CAND_PROMPT_DIM_X;
        lpImeL->rcCandPrompt.bottom = lpImeL->rcCandPrompt.top +
            CAND_PROMPT_DIM_Y;

        lpImeL->rcCandPageText.left = lpImeL->rcCandPrompt.right +
            lpImeL->cxCandMargin + lpImeL->cxCandBorder;
        lpImeL->rcCandPageText.top = lpImeL->rcStatusText.top +
            (STATUS_DIM_Y - PAGE_DIM_Y) / 2;
        lpImeL->rcCandPageText.bottom = lpImeL->rcCandPageText.top +
            PAGE_DIM_Y;

        lpImeL->rcCandPageUp.left = lpImeL->rcCandPageText.left;
        lpImeL->rcCandPageUp.top = lpImeL->rcCandPageText.top;
        lpImeL->rcCandPageUp.right = lpImeL->rcCandPageUp.left + PAGE_DIM_X;
        lpImeL->rcCandPageUp.bottom = lpImeL->rcCandPageText.bottom;

        lpImeL->rcCandHome.left = lpImeL->rcCandPageUp.right;
        lpImeL->rcCandHome.top = lpImeL->rcCandPageUp.top;
        lpImeL->rcCandHome.right = lpImeL->rcCandHome.left + PAGE_DIM_X;
        lpImeL->rcCandHome.bottom = lpImeL->rcCandPageUp.bottom;

        lpImeL->rcCandPageDn.left = lpImeL->rcCandHome.right;
        lpImeL->rcCandPageDn.top = lpImeL->rcCandHome.top;
        lpImeL->rcCandPageDn.right = lpImeL->rcCandPageDn.left + PAGE_DIM_X;
        lpImeL->rcCandPageDn.bottom = lpImeL->rcCandHome.bottom;

        lpImeL->rcCandPageText.right = lpImeL->rcCandPageDn.right;

        lpImeL->xCompWi = lpImeL->rcCandPageDn.right +
            lpImeL->cxCandMargin + lpImeL->cxCandBorder;
        lpImeL->xCandWi = lpImeL->xCompWi;
        lpImeL->xStatusWi = lpImeL->xCompWi;
    } else {
        lpImeL->rcCompText.left = lpImeL->cxCompBorder;
        lpImeL->rcCompText.right = lpImeL->rcCompText.left +
            sImeG.xChiCharWi * lpImeL->nRevMaxKey;

        lpImeL->rcCandPrompt.left = lpImeL->cxCandMargin;
        lpImeL->rcCandPrompt.top = lpImeL->cyCandBorder;
        lpImeL->rcCandPrompt.right = lpImeL->rcCandPrompt.left +
            CAND_PROMPT_DIM_X;
        lpImeL->rcCandPrompt.bottom = lpImeL->rcCandPrompt.top +
            CAND_PROMPT_DIM_Y;

        lpImeL->rcCandPageText.top = lpImeL->rcCandPrompt.top;
        lpImeL->rcCandPageText.bottom = lpImeL->rcCandPageText.top +
            PAGE_DIM_Y;

        lpImeL->rcCandPageUp.top = lpImeL->rcCandPageText.top;
        lpImeL->rcCandPageUp.bottom = lpImeL->rcCandPageText.bottom;
        lpImeL->rcCandHome.top = lpImeL->rcCandPageUp.top;
        lpImeL->rcCandHome.bottom = lpImeL->rcCandPageUp.bottom;
        lpImeL->rcCandPageDn.top = lpImeL->rcCandHome.top;
        lpImeL->rcCandPageDn.bottom = lpImeL->rcCandHome.bottom;

        lpImeL->rcCandText.left = lpImeL->cxCandMargin;
        lpImeL->rcCandText.top = lpImeL->rcCandPageText.bottom +
            lpImeL->cyCandBorder + lpImeL->cyCandMargin;
//Window width should be at least 8 characters AND greater than total 
//width of the bitmaps. 
        cxMinWindowWidth= CAND_PROMPT_DIM_X + 2 * PAGE_DIM_X + 
            lpImeL->cxCandMargin + lpImeL->cxCandBorder; 
        lpImeL->rcCandText.right = lpImeL->rcCandText.left +
            sImeG.xChiCharWi * 8 > cxMinWindowWidth ? 
            sImeG.xChiCharWi * 8 : cxMinWindowWidth;
        lpImeL->rcCandText.bottom = lpImeL->rcCandText.top +
            sImeG.yChiCharHi * CANDPERPAGE;

        lpImeL->rcCandPageText.right = lpImeL->rcCandText.right;
        lpImeL->rcCandPageDn.right = lpImeL->rcCandPageText.right;
        lpImeL->rcCandPageDn.left = lpImeL->rcCandPageDn.right - PAGE_DIM_X;
        lpImeL->rcCandPageUp.right = lpImeL->rcCandPageDn.left;
        lpImeL->rcCandPageUp.left = lpImeL->rcCandPageUp.right - PAGE_DIM_X;
        lpImeL->rcCandPageText.left = lpImeL->rcCandPageUp.left;

        lpImeL->xCompWi = (lpImeL->rcCompText.right -
            lpImeL->rcCompText.left) + lpImeL->cxCompBorder * 2 * 2;
        lpImeL->xCandWi = (lpImeL->rcCandText.right -
            lpImeL->rcCandText.left) + lpImeL->cxCandBorder * 2 +
            lpImeL->cxCandMargin * 2;
    }

    lpImeL->yCompHi = (lpImeL->rcCompText.bottom - lpImeL->rcCompText.top) +
        lpImeL->cyCompBorder * 2 * 2;

    lpImeL->yCandHi = lpImeL->rcCandText.bottom + lpImeL->cyCandBorder * 2 +
        lpImeL->cyCandMargin;
#endif

#if !defined(ROMANIME)
    if (lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI) {
        // the font in composition window is higher than status bitmap
        if (lpImeL->yStatusHi < lpImeL->yCompHi) {
            int cyDelta;

            cyDelta = (lpImeL->yCompHi - lpImeL->yStatusHi) / 2;

            lpImeL->yStatusHi = lpImeL->yCompHi;

            lpImeL->rcShapeText.top = lpImeL->rcInputText.top =
                lpImeL->rcStatusText.top += cyDelta;

            lpImeL->rcShapeText.bottom = lpImeL->rcInputText.bottom =
                lpImeL->rcStatusText.bottom += cyDelta;

            lpImeL->rcCandPageUp.top = lpImeL->rcCandHome.top =
                lpImeL->rcCandPageDn.top += cyDelta;

            lpImeL->rcCandPageUp.bottom = lpImeL->rcCandHome.bottom =
                lpImeL->rcCandPageDn.bottom += cyDelta;
        }

        // the font in composition window is smaller than status bitmap
        if (lpImeL->yCompHi < lpImeL->yStatusHi) {
            int cyDelta;

            cyDelta = (lpImeL->yStatusHi - lpImeL->yCompHi) / 2;

            lpImeL->yCandHi = lpImeL->yCompHi = lpImeL->yStatusHi;

            lpImeL->rcCandText.top = lpImeL->rcCompText.top += cyDelta;

            lpImeL->rcCandText.bottom = lpImeL->rcCompText.bottom += cyDelta;
        }
    }
#endif

    return;
}

#if !defined(ROMANIME)
/**********************************************************************/
/* SetCompLocalData()                                                 */
/**********************************************************************/
void PASCAL SetCompLocalData(
    LPIMEL lpImeL)
{
    if (lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI) {
#if defined(WINAR30)
        InitImeUIData(lpImeL);
#endif
        return;
    }

    // text position relative to the composition window
    lpImeL->rcCompText.right = lpImeL->rcCompText.left +
        sImeG.xChiCharWi * lpImeL->nRevMaxKey;

    // set the width & height for composition window
    lpImeL->xCompWi = lpImeL->rcCompText.right + lpImeL->cxCompBorder * 3;

    return;
}
#endif

/**********************************************************************/
/* RegisterImeClass()                                                 */
/**********************************************************************/
void PASCAL RegisterImeClass(
#if defined(UNIIME)
    LPINSTDATAL lpInstL,
    LPIMEL      lpImeL,
#endif
    WNDPROC     lpfnUIWndProc,
#if !defined(ROMANIME)
    WNDPROC     lpfnCompWndProc,
    WNDPROC     lpfnCandWndProc,
#endif
    WNDPROC     lpfnStatusWndProc,
    WNDPROC     lpfnOffCaretWndProc,
    WNDPROC     lpfnContextMenuWndProc)
{
    WNDCLASSEX wcWndCls;

    // IME UI class
    wcWndCls.cbSize        = sizeof(WNDCLASSEX);
    wcWndCls.cbClsExtra    = 0;
    wcWndCls.cbWndExtra    = WND_EXTRA_SIZE;
    wcWndCls.hIcon         = LoadIcon(lpInstL->hInst,
        MAKEINTRESOURCE(IDIC_IME_ICON));
    wcWndCls.hInstance     = lpInstL->hInst;
    wcWndCls.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wcWndCls.hbrBackground = GetStockObject(NULL_BRUSH);
    wcWndCls.lpszMenuName  = (LPTSTR)NULL;
    wcWndCls.hIconSm       = LoadImage(lpInstL->hInst,
        MAKEINTRESOURCE(IDIC_IME_ICON), IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);

    // IME UI class
    if (!GetClassInfoEx(lpInstL->hInst, lpImeL->szUIClassName, &wcWndCls)) {
        wcWndCls.style         = CS_IME;
        wcWndCls.lpfnWndProc   = lpfnUIWndProc;
        wcWndCls.lpszClassName = lpImeL->szUIClassName;

        RegisterClassEx(&wcWndCls);
    }

    wcWndCls.style         = CS_IME|CS_HREDRAW|CS_VREDRAW;

    wcWndCls.hbrBackground = GetStockObject(LTGRAY_BRUSH);

#if !defined(ROMANIME)
    // IME composition class
    if (!GetClassInfoEx(lpInstL->hInst, lpImeL->szCompClassName, &wcWndCls)) {
        wcWndCls.lpfnWndProc   = lpfnCompWndProc;
        wcWndCls.lpszClassName = lpImeL->szCompClassName;

        RegisterClassEx(&wcWndCls);
    }

    // IME candidate class
    if (!GetClassInfoEx(lpInstL->hInst, lpImeL->szCandClassName, &wcWndCls)) {
        wcWndCls.lpfnWndProc   = lpfnCandWndProc;
        wcWndCls.lpszClassName = lpImeL->szCandClassName;

        RegisterClassEx(&wcWndCls);
    }
#endif

    // IME status class
    if (!GetClassInfoEx(lpInstL->hInst, lpImeL->szStatusClassName, &wcWndCls)) {
        wcWndCls.lpfnWndProc   = lpfnStatusWndProc;
        wcWndCls.lpszClassName = lpImeL->szStatusClassName;

        RegisterClassEx(&wcWndCls);
    }

    // IME off caret class
    if (!GetClassInfoEx(lpInstL->hInst, lpImeL->szOffCaretClassName, &wcWndCls)) {
        wcWndCls.lpfnWndProc   = lpfnOffCaretWndProc;
        wcWndCls.lpszClassName = lpImeL->szOffCaretClassName;

        RegisterClassEx(&wcWndCls);
    }

    // IME context menu class
    if (!GetClassInfoEx(lpInstL->hInst, lpImeL->szCMenuClassName, &wcWndCls)) {
        wcWndCls.style         = 0;
        wcWndCls.hbrBackground = GetStockObject(NULL_BRUSH);
        wcWndCls.lpfnWndProc   = lpfnContextMenuWndProc;
        wcWndCls.lpszClassName = lpImeL->szCMenuClassName;

        RegisterClassEx(&wcWndCls);
    }

    return;
}

/**********************************************************************/
/* AttachIME() / UniAttachMiniIME()                                   */
/**********************************************************************/
#if defined(UNIIME)
void WINAPI UniAttachMiniIME(
#else
void PASCAL AttachIME(
#endif
#if defined(UNIIME)
    LPINSTDATAL lpInstL,
    LPIMEL      lpImeL,
#endif
    WNDPROC     lpfnUIWndProc,
#if !defined(ROMANIME)
    WNDPROC     lpfnCompWndProc,
    WNDPROC     lpfnCandWndProc,
#endif
    WNDPROC     lpfnStatusWndProc,
    WNDPROC     lpfnOffCaretWndProc,
    WNDPROC     lpfnContextMenuWndProc)
{
#if !defined(UNIIME)
    InitImeGlobalData();
#endif

    InitImeLocalData(lpInstL, lpImeL);

    if (!lpImeL->rcStatusText.bottom) {
        InitImeUIData(lpImeL);
    }

    RegisterImeClass(
#if defined(UNIIME)
        lpInstL, lpImeL,
#endif
        lpfnUIWndProc,
#if !defined(ROMANIME)
        lpfnCompWndProc, lpfnCandWndProc,
#endif
        lpfnStatusWndProc, lpfnOffCaretWndProc,
        lpfnContextMenuWndProc);

     return;
}

/**********************************************************************/
/* DetachIME() / UniDetachMiniIME()                                   */
/**********************************************************************/
#if defined(UNIIME)
void WINAPI UniDetachMiniIME(
#else
void PASCAL DetachIME(
#endif
    LPINSTDATAL lpInstL,
    LPIMEL      lpImeL)
{
    WNDCLASSEX wcWndCls;

    if (GetClassInfoEx(lpInstL->hInst, lpImeL->szCMenuClassName, &wcWndCls)) {
        UnregisterClass(lpImeL->szCMenuClassName, lpInstL->hInst);
    }

    if (GetClassInfoEx(lpInstL->hInst, lpImeL->szOffCaretClassName, &wcWndCls)) {
        UnregisterClass(lpImeL->szOffCaretClassName, lpInstL->hInst);
    }

    if (GetClassInfoEx(lpInstL->hInst, lpImeL->szStatusClassName, &wcWndCls)) {
        UnregisterClass(lpImeL->szStatusClassName, lpInstL->hInst);
    }

#if !defined(ROMANIME)
    if (GetClassInfoEx(lpInstL->hInst, lpImeL->szCandClassName, &wcWndCls)) {
        UnregisterClass(lpImeL->szCandClassName, lpInstL->hInst);
    }

    if (GetClassInfoEx(lpInstL->hInst, lpImeL->szCompClassName, &wcWndCls)) {
        UnregisterClass(lpImeL->szCompClassName, lpInstL->hInst);
    }
#endif

    if (!GetClassInfoEx(lpInstL->hInst, lpImeL->szUIClassName, &wcWndCls)) {
    } else if (!UnregisterClass(lpImeL->szUIClassName, lpInstL->hInst)) {
    } else {
         DestroyIcon(wcWndCls.hIcon);
         DestroyIcon(wcWndCls.hIconSm);
    }

#if !defined(ROMANIME)
    FreeTable(lpInstL);
#endif
}
#endif // !defined(MINIIME)

/**********************************************************************/
/* ImeDllInit() / UniImeDllInit()                                     */
/* Return Value:                                                      */
/*      TRUE - successful                                             */
/*      FALSE - failure                                               */
/**********************************************************************/
#if defined(UNIIME)
BOOL CALLBACK UniImeDllInit(
#else
BOOL CALLBACK ImeDllInit(
#endif
    HINSTANCE hInstance,        // instance handle of this library
    DWORD     fdwReason,        // reason called
    LPVOID    lpvReserve)       // reserve pointer
{
    switch (fdwReason) {
    case DLL_PROCESS_ATTACH:
        hInst = hInstance;

#if !defined(UNIIME)
        if (lpInstL) {
            // the local instance data already init
            return (TRUE);
        }

        lpInstL = &sInstL;

        lpInstL->hInst = hInstance;

        lpInstL->lpImeL = lpImeL = &sImeL;
#endif

#if defined(MINIIME)
        UniAttachMiniIME(lpInstL, lpImeL, UIWndProc, CompWndProc,
            CandWndProc, StatusWndProc, OffCaretWndProc,
            ContextMenuWndProc);
#elif defined(UNIIME)
        InitImeGlobalData();

        {
            LoadPhraseTable(sImeG.uPathLen, sImeG.szPhrasePath);
        }
#else
        AttachIME(UIWndProc,
#if !defined(ROMANIME)
            CompWndProc, CandWndProc,
#endif
            StatusWndProc, OffCaretWndProc, ContextMenuWndProc);
#endif
        break;
    case DLL_PROCESS_DETACH:
#if defined(MINIIME)
        UniDetachMiniIME(lpInstL, lpImeL);
#elif defined(UNIIME)
        {
            int i;

            for (i = 0; i < MAX_PHRASE_TABLES; i++) {
                if (sInstG.hMapTbl[i]) {
                    CloseHandle(sInstG.hMapTbl[i]);
                    sInstG.hMapTbl[i] = (HANDLE)NULL;
                }
            }
        }
#else
        DetachIME(lpInstL, lpImeL);
#endif
        break;
    default:
        break;
    }

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\immsec.c ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    immsec.c

Abstract:

    security code called by IMEs 

Author:

    Takao Kitano [takaok] 01-May-1996

Revision History:

--*/

#include <windows.h>
#include <stdio.h>
#include "immsec.h"

#define MEMALLOC(x)      LocalAlloc(LMEM_FIXED, x)
#define MEMFREE(x)       LocalFree(x)

//
// internal functions
//
PSID MyCreateSid();
POSVERSIONINFO GetVersionInfo();

//
// debug functions
//
#ifdef DEBUG
#define ERROROUT(x)      ErrorOut( x )
#define WARNOUT(x)       WarnOut( x )
#else
#define ERROROUT(x) 
#define WARNOUT(x)       
#endif

#ifdef DEBUG
VOID WarnOut( PTSTR pStr )
{
    OutputDebugString( pStr );
}

VOID ErrorOut( PTSTR pStr )
{
    DWORD dwError;
    DWORD dwResult;
    TCHAR buf1[512];
    TCHAR buf2[512];

    dwError = GetLastError();
    dwResult = FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM,
                              NULL,
                              dwError,
                              MAKELANGID( LANG_ENGLISH, LANG_NEUTRAL ),
                              buf1,
                              512,
                              NULL );                                   
    
    if ( dwResult > 0 ) {
        sprintf( buf2, "%s:%s(0x%x)", pStr, buf1, dwError);
    } else {
        sprintf( buf2, "%s:(0x%x)", pStr, dwError);
    }
    OutputDebugString( buf2 );
}
#endif


//
// CreateSecurityAttributes()
//
// The purpose of this function:
//
//      Allocate and set the security attributes that is 
//      appropriate for named objects created by an IME.
//      The security attributes will give GENERIC_ALL
//      access for everyone
//      
//
// Return value:
//
//      If the function succeeds, the return value is a 
//      pointer to SECURITY_ATTRIBUTES. If the function fails,
//      the return value is NULL. To get extended error 
//      information, call GetLastError().
//
// Remarks:
//
//      FreeSecurityAttributes() should be called to free up the
//      SECURITY_ATTRIBUTES allocated by this function.
//
PSECURITY_ATTRIBUTES CreateSecurityAttributes()
{
    PSECURITY_ATTRIBUTES psa;
    PSECURITY_DESCRIPTOR psd;
    PACL                 pacl;
    DWORD                cbacl;

    PSID                 psid;
    BOOL                 fResult;

    INT                  i,j;

    if (!IsNT())
        return NULL;

    //
    // create a sid for everyone access
    //
    psid = MyCreateSid();
    if ( psid == NULL ) {
        return NULL;
    } 

    //
    // allocate and initialize an access control list (ACL) that will 
    // contain the SID we've just created.
    //
    cbacl =  sizeof(ACL) + 
             (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) + 
             GetLengthSid(psid);

    pacl = MEMALLOC( cbacl );
    if ( pacl == NULL ) {
        ERROROUT( TEXT("CreateSecurityAttributes:LocalAlloc for ACL failed") );
        FreeSid ( psid );
        return NULL;
    }

    fResult = InitializeAcl( pacl, cbacl, ACL_REVISION );
    if ( ! fResult ) {
        ERROROUT( TEXT("CreateSecurityAttributes:InitializeAcl failed") );
        FreeSid ( psid );
        MEMFREE( pacl );
        return NULL;
    }

    //
    // adds an access-allowed ACE for interactive users to the ACL
    // 
    fResult = AddAccessAllowedAce( pacl,
                                   ACL_REVISION,
                                   GENERIC_ALL,
                                   psid );

    if ( !fResult ) {
        ERROROUT( TEXT("CreateSecurityAttributes:AddAccessAllowedAce failed") );
        MEMFREE( pacl );
        FreeSid ( psid );
        return NULL;
    }


    //
    // Those SIDs have been copied into the ACL. We don't need'em any more.
    //
    FreeSid ( psid );

    //
    // Let's make sure that our ACL is valid.
    //
    if (!IsValidAcl(pacl)) {
        WARNOUT( TEXT("CreateSecurityAttributes:IsValidAcl returns FALSE!"));
        MEMFREE( pacl );
        return NULL;
    }

    //
    // allocate security attribute
    //
    psa = (PSECURITY_ATTRIBUTES)MEMALLOC( sizeof( SECURITY_ATTRIBUTES ) );
    if ( psa == NULL ) {
        ERROROUT( TEXT("CreateSecurityAttributes:LocalAlloc for psa failed") );
        MEMFREE( pacl );
        return NULL;
    }
    
    //
    // allocate and initialize a new security descriptor
    //
    psd = MEMALLOC( SECURITY_DESCRIPTOR_MIN_LENGTH );
    if ( psd == NULL ) {
        ERROROUT( TEXT("CreateSecurityAttributes:LocalAlloc for psd failed") );
        MEMFREE( pacl );
        MEMFREE( psa );
        return NULL;
    }

    if ( ! InitializeSecurityDescriptor( psd, SECURITY_DESCRIPTOR_REVISION ) ) {
        ERROROUT( TEXT("CreateSecurityAttributes:InitializeSecurityDescriptor failed") );
        MEMFREE( pacl );
        MEMFREE( psa );
        MEMFREE( psd );
        return NULL;
    }


    fResult = SetSecurityDescriptorDacl( psd,
                                         TRUE,
                                         pacl,
                                         FALSE );

    // The discretionary ACL is referenced by, not copied 
    // into, the security descriptor. We shouldn't free up ACL
    // after the SetSecurityDescriptorDacl call. 

    if ( ! fResult ) {
        ERROROUT( TEXT("CreateSecurityAttributes:SetSecurityDescriptorDacl failed") );
        MEMFREE( pacl );
        MEMFREE( psa );
        MEMFREE( psd );
        return NULL;
    } 


    if (!IsValidSecurityDescriptor(psd)) {
        WARNOUT( TEXT("CreateSecurityAttributes:IsValidSecurityDescriptor failed!") );
        MEMFREE( pacl );
        MEMFREE( psa );
        MEMFREE( psd );
        return NULL;
    }

    //
    // everything is done
    //
    psa->nLength = sizeof( SECURITY_ATTRIBUTES );
    psa->lpSecurityDescriptor = (PVOID)psd;
    psa->bInheritHandle = FALSE;

    return psa;
}

PSID MyCreateSid()
{
    PSID        psid;
    BOOL        fResult;
    SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_WORLD_SID_AUTHORITY;

    //
    // allocate and initialize an SID
    // 
    fResult = AllocateAndInitializeSid( &SidAuthority,
                                        1,
                                        SECURITY_WORLD_RID,
                                        0,0,0,0,0,0,0,
                                        &psid );
    if ( ! fResult ) {
        ERROROUT( TEXT("MyCreateSid:AllocateAndInitializeSid failed") );
        return NULL;
    }

    if ( ! IsValidSid( psid ) ) {
        WARNOUT( TEXT("MyCreateSid:AllocateAndInitializeSid returns bogus sid"));
        FreeSid( psid );
        return NULL;
    }

    return psid;
}

//
// FreeSecurityAttributes()
//
// The purpose of this function:
//
//      Frees the memory objects allocated by previous
//      CreateSecurityAttributes() call.
//
VOID FreeSecurityAttributes( PSECURITY_ATTRIBUTES psa )
{
    BOOL fResult;
    BOOL fDaclPresent;
    BOOL fDaclDefaulted;
    PACL pacl;

    if (psa == NULL)
        return;

    fResult = GetSecurityDescriptorDacl( psa->lpSecurityDescriptor,
                                         &fDaclPresent,
                                         &pacl,
                                         &fDaclDefaulted );                  
    if ( fResult ) {
        if ( pacl != NULL )
            MEMFREE( pacl );
    } else {
        ERROROUT( TEXT("FreeSecurityAttributes:GetSecurityDescriptorDacl failed") );
    }

    MEMFREE( psa->lpSecurityDescriptor );
    MEMFREE( psa );
}

//
// IsNT()
//
// Return value:
//
//      TRUE if the current system is Windows NT
//
// Remarks:
//
//      The implementation of this function is not multi-thread safe.
//      You need to modify the function if you call the function in 
//      multi-thread environment.
//
BOOL IsNT()
{
    return GetVersionInfo()->dwPlatformId == VER_PLATFORM_WIN32_NT;
}

POSVERSIONINFO GetVersionInfo()
{
    static BOOL fFirstCall = TRUE;
    static OSVERSIONINFO os;

    if ( fFirstCall ) {
        os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        if ( GetVersionEx( &os ) ) {
            fFirstCall = FALSE;
        }
    }
    return &os;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\offcaret.c ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    OFFCARET.C
    
++*/

#include <windows.h>
#include <immdev.h>
#include "imeattr.h"
#include "imedefs.h"
#include "imerc.h"
#if defined(UNIIME)
#include "uniime.h"
#endif

/**********************************************************************/
/* DestroyOffCaretWindow()                                            */
/**********************************************************************/
void PASCAL DestroyOffCaretWindow(      // destroy composition window
    HWND hOffCaretWnd)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    if (GetWindowLong(hOffCaretWnd, UI_MOVE_OFFSET) != WINDOW_NOT_DRAG) {
        // undo the drag border
        DrawDragBorder(hOffCaretWnd,
            GetWindowLong(hOffCaretWnd, UI_MOVE_XY),
            GetWindowLong(hOffCaretWnd, UI_MOVE_OFFSET));
    }

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(GetWindow(hOffCaretWnd, GW_OWNER),
        IMMGWLP_PRIVATE);
    if (!hUIPrivate) {
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {
        return;
    }

#if !defined(ROMANIME)
    lpUIPrivate->nShowCompCmd = lpUIPrivate->nShowCandCmd = SW_HIDE;
#endif

    lpUIPrivate->nShowStatusCmd = SW_HIDE;

#if !defined(ROMANIME)
    lpUIPrivate->hCompWnd = lpUIPrivate->hCandWnd = NULL;
#endif

    lpUIPrivate->hStatusWnd = NULL;

    GlobalUnlock(hUIPrivate);

    return;
}

#if !defined(ROMANIME)
/**********************************************************************/
/* MouseSelectOffCaretCandStr()                                       */
/**********************************************************************/
BOOL PASCAL MouseSelectOffCaretCandStr(
#if defined(UNIIME)
    LPINSTDATAL lpInstL,
    LPIMEL      lpImeL,
#endif
    HWND        hOffCaretWnd,
    LPPOINT     lpCursor)
{
    BOOL            fRet;
    HWND            hUIWnd;
    HIMC            hIMC;
    LPINPUTCONTEXT  lpIMC;
    HGLOBAL         hUIPrivate;
    LPUIPRIV        lpUIPrivate;
    LPCANDIDATEINFO lpCandInfo;
    LPCANDIDATELIST lpCandList;
    DWORD           dwValue, dwLimit;
    UINT            nMouseChars, nChars;

    fRet = FALSE;

    hUIWnd = GetWindow(hOffCaretWnd, GW_OWNER);

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return (fRet);
    }

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {
        return (fRet);
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return (fRet);
    }

    if (!lpIMC->hCandInfo) {
        goto MouseSelOffCaretCandStrUnlockIMC;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {
        goto MouseSelOffCaretCandStrUnlockIMC;
    }

    dwValue = lpUIPrivate->nShowCandCmd;

    GlobalUnlock(hUIPrivate);

    if (dwValue == SW_HIDE) {
        // may application draw the UI or currently is not in candidate list
        goto MouseSelOffCaretCandStrUnlockIMC;
    }

    // we can select candidate
    fRet = TRUE;

    lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo);
    if (!lpCandInfo) {
        goto MouseSelOffCaretCandStrUnlockIMC;
    }

    nMouseChars = (lpCursor->x - lpImeL->rcCandText.left) * 2 /
        sImeG.xChiCharWi;

    lpCandList = (LPCANDIDATELIST)((LPBYTE)lpCandInfo +
        lpCandInfo->dwOffset[0]);

    dwValue = lpCandList->dwPageStart;

    // process one page
    dwLimit = dwValue + lpCandList->dwPageSize;

    if (dwLimit > lpCandList->dwCount) {
        dwLimit = lpCandList->dwCount;
    }

    for (nChars = 0; dwValue < dwLimit; dwValue++) {
        UINT   uStrLen;
#ifdef UNICODE
        LPTSTR lpTmpStr;
#endif

#ifdef UNICODE
        // this is not a real string length just an approximate char width
        uStrLen = 0;

        lpTmpStr = (LPTSTR)((LPBYTE)lpCandList +
            lpCandList->dwOffset[dwValue]);

        for (; *lpTmpStr; lpTmpStr++) {
            if (*lpTmpStr < 0x0200) {
                uStrLen += 1;
            } else {
                uStrLen += 2;
            }
        }
#else
        uStrLen =  lstrlen((LPTSTR)((LPBYTE)lpCandList +
            lpCandList->dwOffset[dwValue]));
#endif

#if defined(WINAR30)
        if (!uStrLen) {
            uStrLen = sizeof(WCHAR);
        }
#endif
        // + 1 for the '1' '2' '3' ....
        nChars += uStrLen + 1;

        if (nMouseChars < nChars) {
#if defined(UNIIME)
            UniNotifyIME(lpInstL, lpImeL, hIMC, NI_SELECTCANDIDATESTR, 0,
                dwValue);
#else
            NotifyIME(hIMC, NI_SELECTCANDIDATESTR, 0, dwValue);
#endif
            break;
        }
    }

    ImmUnlockIMCC(lpIMC->hCandInfo);

    if (nMouseChars >= nChars) {
        // invalid choice
        MessageBeep((UINT)-1);
    }

MouseSelOffCaretCandStrUnlockIMC:
    ImmUnlockIMC(hIMC);

    return (fRet);
}

/**********************************************************************/
/* MouseSelectCandPage()                                              */
/**********************************************************************/
BOOL PASCAL MouseSelectCandPage(
#if defined(UNIIME)
    LPIMEL lpImeL,
#endif
    HWND   hCandWnd,
    WORD   wCharCode)
{
    BOOL            fRet;
    HWND            hUIWnd;
    HIMC            hIMC;
    LPINPUTCONTEXT  lpIMC;
    HGLOBAL         hUIPrivate;
    LPUIPRIV        lpUIPrivate;
    LPCANDIDATEINFO lpCandInfo;
    LPPRIVCONTEXT   lpImcP;

    fRet = FALSE;

    hUIWnd = GetWindow(hCandWnd, GW_OWNER);

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return (fRet);
    }

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {
        return (fRet);
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return (fRet);
    }

    if (!lpIMC->hCandInfo) {
        goto MouseSelCandPageUnlockIMC;
    }

    if (!lpIMC->hPrivate) {
        goto MouseSelCandPageUnlockIMC;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {
        goto MouseSelCandPageUnlockIMC;
    }

    if (lpUIPrivate->nShowCandCmd == SW_HIDE) {
        // may application draw the UI or currently is not in candidate list
        goto MouseSelCandPageUnlockIMC;
    }

    // we can select candidate
    fRet = TRUE;

    lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo);
    if (!lpCandInfo) {
        goto MouseSelCandPageUnlockUIPriv;
    }

    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    if (!lpImcP) {
        goto MouseSelCandPageUnlockCandInfo;
    }

    ChooseCand(
#if defined(UNIIME)
        NULL, lpImeL,
#endif
        wCharCode, hIMC, lpIMC, lpCandInfo, lpImcP);

    GenerateMessage(hIMC, lpIMC, lpImcP);

    ImmUnlockIMCC(lpIMC->hPrivate);

MouseSelCandPageUnlockCandInfo:
    ImmUnlockIMCC(lpIMC->hCandInfo);

MouseSelCandPageUnlockUIPriv:
    GlobalUnlock(hUIPrivate);

MouseSelCandPageUnlockIMC:
    ImmUnlockIMC(hIMC);

    return (fRet);
}
#endif

/**********************************************************************/
/* OffCaretSetCursor()                                                */
/**********************************************************************/
void PASCAL OffCaretSetCursor(
#if defined(UNIIME)
    LPINSTDATAL lpInstL,
    LPIMEL      lpImeL,
#endif
    HWND        hOffCaretWnd,
    LPARAM      lParam)
{
    POINT ptCursor, ptSavCursor;
    RECT  rcWnd;
 
    if (GetWindowLong(hOffCaretWnd, UI_MOVE_OFFSET) != WINDOW_NOT_DRAG) {
        SetCursor(LoadCursor(NULL, IDC_SIZEALL));
        return;
    }

    GetCursorPos(&ptCursor);
    ptSavCursor = ptCursor;

    ScreenToClient(hOffCaretWnd, &ptCursor);

    if (PtInRect(&lpImeL->rcStatusText, ptCursor)) {
        SetCursor(LoadCursor(hInst, MAKEINTRESOURCE(IDCR_HAND_CURSOR)));

        if (HIWORD(lParam) == WM_LBUTTONDOWN) {
            HWND hStatusWnd;

            SystemParametersInfo(SPI_GETWORKAREA, 0, &sImeG.rcWorkArea, 0);

            hStatusWnd = GetStatusWnd(GetWindow(hOffCaretWnd, GW_OWNER));
            if (hStatusWnd) {
                SetStatus(
#if defined(UNIIME)
                    lpImeL,
#endif
                    hStatusWnd, &ptCursor);
                return;
            } else {
               SetCursor(LoadCursor(NULL, IDC_SIZEALL));
            }
        } else if (HIWORD(lParam) == WM_RBUTTONUP) {
            static BOOL fImeConfigure = FALSE;

            HWND           hUIWnd, hStatusWnd;

            // prevent recursive
            if (fImeConfigure) {
                // configuration already bring up
                return;
            }

            hUIWnd = GetWindow(hOffCaretWnd, GW_OWNER);

            hStatusWnd = GetStatusWnd(hUIWnd);
            if (!hStatusWnd) {
                return;
            }

            fImeConfigure = TRUE;

            ContextMenu(
#if defined(UNIIME)
                lpInstL, lpImeL,
#endif
                hStatusWnd, ptSavCursor.x, ptSavCursor.y);

            fImeConfigure = FALSE;

            return;
        } else {
            return;
        }
#if !defined(ROMANIME)
    } else if (PtInRect(&lpImeL->rcCandText, ptCursor)) {
        if (HIWORD(lParam) != WM_LBUTTONDOWN) {
            SetCursor(LoadCursor(hInst, MAKEINTRESOURCE(IDCR_HAND_CURSOR)));
            return;
        }

        if (MouseSelectOffCaretCandStr(
#if defined(UNIIME)
            lpInstL, lpImeL,
#endif
            hOffCaretWnd, &ptCursor)) {
            return;
        }

        SetCursor(LoadCursor(NULL, IDC_SIZEALL));
#if defined(WINAR30)
    } else if (PtInRect(&lpImeL->rcCompText, ptCursor)) {
        SetCursor(LoadCursor(NULL, IDC_SIZEALL));

        if (HIWORD(lParam) != WM_LBUTTONDOWN) {
            return;
        }
#endif
    } else if (PtInRect(&lpImeL->rcCandPageUp, ptCursor)) {
        if (HIWORD(lParam) != WM_LBUTTONDOWN) {
            SetCursor(LoadCursor(hInst, MAKEINTRESOURCE(IDCR_HAND_CURSOR)));
            return;
        }

        if (MouseSelectCandPage(
#if defined(UNIIME)
            lpImeL,
#endif
            hOffCaretWnd, CHOOSE_PREVPAGE)) {
            return;
        }

        SetCursor(LoadCursor(NULL, IDC_SIZEALL));
    } else if (PtInRect(&lpImeL->rcCandHome, ptCursor)) {
        if (HIWORD(lParam) != WM_LBUTTONDOWN) {
            SetCursor(LoadCursor(hInst, MAKEINTRESOURCE(IDCR_HAND_CURSOR)));
            return;
        }

        if (MouseSelectCandPage(
#if defined(UNIIME)
            lpImeL,
#endif
            hOffCaretWnd, CHOOSE_HOME)) {
            return;
        }

        SetCursor(LoadCursor(NULL, IDC_SIZEALL));
    } else if (PtInRect(&lpImeL->rcCandPageDn, ptCursor)) {
        if (HIWORD(lParam) != WM_LBUTTONDOWN) {
            SetCursor(LoadCursor(hInst, MAKEINTRESOURCE(IDCR_HAND_CURSOR)));
            return;
        }

        if (MouseSelectCandPage(
#if defined(UNIIME)
            lpImeL,
#endif
            hOffCaretWnd, CHOOSE_NEXTPAGE)) {
            return;
        }

        SetCursor(LoadCursor(NULL, IDC_SIZEALL));
#endif
    } else {
        SetCursor(LoadCursor(NULL, IDC_SIZEALL));

        if (HIWORD(lParam) != WM_LBUTTONDOWN) {
            return;
        }
    }

    SetCapture(hOffCaretWnd);
    SetWindowLong(hOffCaretWnd, UI_MOVE_XY,
        MAKELONG(ptSavCursor.x, ptSavCursor.y));
    GetWindowRect(hOffCaretWnd, &rcWnd);
    SetWindowLong(hOffCaretWnd, UI_MOVE_OFFSET,
        MAKELONG(ptSavCursor.x - rcWnd.left, ptSavCursor.y - rcWnd.top));

    DrawDragBorder(hOffCaretWnd, MAKELONG(ptSavCursor.x, ptSavCursor.y),
        GetWindowLong(hOffCaretWnd, UI_MOVE_OFFSET));

    return;
}

/**********************************************************************/
/* PaintOffCaretStatus()                                              */
/**********************************************************************/
void PASCAL PaintOffCaretStatus(
#if defined(UNIIME)
    LPINSTDATAL lpInstL,
    LPIMEL      lpImeL,
#endif
    HWND        hOffCaretWnd,
    HDC         hDC)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(GetWindow(hOffCaretWnd, GW_OWNER),
        IMMGWLP_PRIVATE);
    if (!hUIPrivate) {
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {
        return;
    }

    if (lpUIPrivate->fdwSetContext & ISC_OPEN_STATUS_WINDOW) {
        PaintStatusWindow(
#if defined(UNIIME)
            lpInstL, lpImeL,
#endif
            hOffCaretWnd, hDC);
    }

    GlobalUnlock(hUIPrivate);

    return;
}

#if !defined(ROMANIME)
/**********************************************************************/
/* PaintOffCaretCandPage()                                            */
/**********************************************************************/
void PASCAL PaintOffCaretCandPage(
#if defined(UNIIME)
    LPIMEL          lpImeL,
#endif
    HDC             hDC,
    UINT            uCandMode,
    LPCANDIDATELIST lpCandList)
{
    HBITMAP hCandPromptBmp;
    HBITMAP hPageUpBmp, hHomeBmp, hPageDnBmp, hOldBmp;
    HDC     hMemDC;

    hMemDC = CreateCompatibleDC(hDC);

    if ( hMemDC == NULL )
    {
       return;
    }

    if (uCandMode == CAND_PROMPT_PHRASE) {
        hCandPromptBmp = LoadBitmap(hInst,
            MAKEINTRESOURCE(IDBM_CAND_PROMPT_PHRASE));
#if defined(WINAR30)
    } else if (uCandMode == CAND_PROMPT_QUICK_VIEW) {
        hCandPromptBmp = LoadBitmap(hInst,
            MAKEINTRESOURCE(IDBM_CAND_PROMPT_QUICK_VIEW));
#endif
    } else {
        hCandPromptBmp = LoadBitmap(hInst,
            MAKEINTRESOURCE(IDBM_CAND_PROMPT_NORMAL));
    }

    if ( hCandPromptBmp == NULL )
    {
       DeleteDC(hMemDC);
       return;
    }
       
    hOldBmp = SelectObject(hMemDC, hCandPromptBmp);

    BitBlt(hDC, lpImeL->rcCandPrompt.left, lpImeL->rcCandPrompt.top,
        lpImeL->rcCandPrompt.right - lpImeL->rcCandPrompt.left,
        lpImeL->rcCandPrompt.bottom - lpImeL->rcCandPrompt.top,
        hMemDC, 0, 0, SRCCOPY);

    if (lpCandList->dwCount <= lpCandList->dwPageSize) {
        goto PaintOffCaretCandPageOvr;
    }

    if (lpCandList->dwPageStart > 0) {
        hPageUpBmp = LoadBitmap(hInst, MAKEINTRESOURCE(IDBM_PAGEUP_HORIZ));
    } else {
        hPageUpBmp = LoadBitmap(hInst, MAKEINTRESOURCE(IDBM_NO_PAGEUP_HORIZ));
    }

    if ( hPageUpBmp == NULL )
    {
       goto PaintOffCaretCandPageOvr;
    }

    if (lpCandList->dwPageStart > 0) {
        hHomeBmp = LoadBitmap(hInst, MAKEINTRESOURCE(IDBM_HOME_HORIZ));
    } else {
        hHomeBmp = LoadBitmap(hInst, MAKEINTRESOURCE(IDBM_NO_HOME_HORIZ));
    }

    if ( hHomeBmp == NULL )
    {
       DeleteObject(hPageUpBmp);
       goto PaintOffCaretCandPageOvr;
    }   

    if ((lpCandList->dwPageStart + lpCandList->dwPageSize) <
        lpCandList->dwCount) {
        hPageDnBmp = LoadBitmap(hInst, MAKEINTRESOURCE(IDBM_PAGEDN_HORIZ));
    } else {
        hPageDnBmp = LoadBitmap(hInst, MAKEINTRESOURCE(IDBM_NO_PAGEDN_HORIZ));
    }

    if ( hPageDnBmp == NULL )
    {
      DeleteObject(hPageUpBmp);
      DeleteObject(hHomeBmp);
      goto PaintOffCaretCandPageOvr;
    }


    SelectObject(hMemDC, hPageUpBmp);

    BitBlt(hDC, lpImeL->rcCandPageUp.left, lpImeL->rcCandPageUp.top,
        lpImeL->rcCandPageUp.right - lpImeL->rcCandPageUp.left,
        lpImeL->rcCandPageUp.bottom - lpImeL->rcCandPageUp.top,
        hMemDC, 0, 0, SRCCOPY);

    SelectObject(hMemDC, hHomeBmp);

    BitBlt(hDC, lpImeL->rcCandHome.left, lpImeL->rcCandHome.top,
        lpImeL->rcCandHome.right - lpImeL->rcCandHome.left,
        lpImeL->rcCandHome.bottom - lpImeL->rcCandHome.top,
        hMemDC, 0, 0, SRCCOPY);

    SelectObject(hMemDC, hPageDnBmp);

    BitBlt(hDC, lpImeL->rcCandPageDn.left, lpImeL->rcCandPageDn.top,
        lpImeL->rcCandPageDn.right - lpImeL->rcCandPageDn.left,
        lpImeL->rcCandPageDn.bottom - lpImeL->rcCandPageDn.top,
        hMemDC, 0, 0, SRCCOPY);

    SelectObject(hMemDC, hOldBmp);

    DeleteObject(hPageUpBmp);
    DeleteObject(hHomeBmp);
    DeleteObject(hPageDnBmp);

PaintOffCaretCandPageOvr:
    SelectObject(hMemDC, hOldBmp);

    DeleteDC(hMemDC);

    DeleteObject(hCandPromptBmp);

    return;
}

/**********************************************************************/
/* PaintOffCaretComposition()                                         */
/**********************************************************************/
void PASCAL PaintOffCaretComposition(
#if defined(UNIIME)
    LPIMEL lpImeL,
#endif
    HWND   hOffCaretWnd,
    HDC    hDC)
{
    HWND            hUIWnd;
    HIMC            hIMC;
    LPINPUTCONTEXT  lpIMC;
    HGLOBAL         hUIPrivate;
    LPUIPRIV        lpUIPrivate;
    LPPRIVCONTEXT   lpImcP;
    HGDIOBJ         hOldFont;
    LPTSTR          lpStr;
    RECT            rcSunken;
    LOGFONT         lfFont;
    HFONT           hNewFont;

    hUIWnd = GetWindow(hOffCaretWnd, GW_OWNER);

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return;
    }

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {
        return;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {
        goto PaintOffCaretCompUnlockIMC;
    }

    rcSunken = lpImeL->rcCompText;

    rcSunken.left -= lpImeL->cxCompBorder;
    rcSunken.top -= lpImeL->cyCompBorder;
    rcSunken.right += lpImeL->cxCompBorder;
    rcSunken.bottom += lpImeL->cyCompBorder;

    DrawEdge(hDC, &rcSunken, BDR_SUNKENOUTER, BF_RECT);

    hOldFont = GetCurrentObject(hDC, OBJ_FONT);
    GetObject(hOldFont, sizeof(lfFont), &lfFont);

    if (sImeG.fDiffSysCharSet) {
        lfFont.lfCharSet = NATIVE_CHARSET;
        lfFont.lfFaceName[0] = TEXT('\0');
    }
    lfFont.lfWeight = FW_DONTCARE;

    hNewFont = CreateFontIndirect(&lfFont);

    if ( hNewFont != NULL )
    {
      SelectObject(hDC, (HGDIOBJ)hNewFont);
    }
    else
    {
    //  return error
        GlobalUnlock(hUIPrivate);
        ImmUnlockIMC(hIMC);
        return;
    }


#if defined(WINAR30)
    rcSunken = lpImeL->rcCandText;

    rcSunken.left -= lpImeL->cxCandMargin;
    rcSunken.top -= lpImeL->cyCandMargin;
    rcSunken.right += lpImeL->cxCandMargin;
    rcSunken.bottom += lpImeL->cyCandMargin;

    DrawEdge(hDC, &rcSunken, BDR_SUNKENOUTER, BF_RECT);
#endif

    // light gray background
    SetBkColor(hDC, RGB(0xC0, 0xC0, 0xC0));

    if (lpUIPrivate->nShowCandCmd != SW_HIDE) {
        LPCANDIDATEINFO lpCandInfo;
        LPCANDIDATELIST lpCandList;
        BOOL            fCandidate;
        DWORD           dwStart, dwEnd;
        UINT            uCandMode;
        int             i, nChars, nHalfChars;
        TCHAR           szStrBuf[CANDPERPAGE * 3 + 1];
#ifdef UNICODE
        int             iDx[CANDPERPAGE * 3 + 1];
#endif

        fCandidate = FALSE;

        if (!lpIMC->hCandInfo) {
            goto PaintOffCaretCompChkCandInfo;
        }

        lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo);
        if (!lpCandInfo) {
            goto PaintOffCaretCompChkCandInfo;
        }

        if (!lpCandInfo->dwCount) {
            goto PaintOffCaretCompUnlockCandInfo;
        }

        lpCandList = (LPCANDIDATELIST)((LPBYTE)lpCandInfo +
            lpCandInfo->dwOffset[0]);

        if (!lpCandList->dwCount) {
            goto PaintOffCaretCompUnlockCandInfo;
        }

        dwStart = lpCandList->dwPageStart;

        dwEnd = dwStart + lpCandList->dwPageSize;

        if (dwEnd > lpCandList->dwCount) {
            dwEnd = lpCandList->dwCount;
        }

        fCandidate = TRUE;

        lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);

        if (!lpImcP) {
            uCandMode = CAND_PROMPT_NORMAL;
        } else if (lpImcP->iImeState == CST_INIT) {
            // phrase prediction
            SetTextColor(hDC, RGB(0x00, 0x80, 0x00));
            uCandMode = CAND_PROMPT_PHRASE;
#if defined(WINAR30)
        } else if (lpImcP->iImeState != CST_CHOOSE) {
            // quick key
            SetTextColor(hDC, RGB(0x80, 0x00, 0x80));
            uCandMode = CAND_PROMPT_QUICK_VIEW;
#endif
        } else {
            uCandMode = CAND_PROMPT_NORMAL;
        }

        if (lpImcP) {
            ImmUnlockIMCC(lpIMC->hPrivate);
        }

        PaintOffCaretCandPage(
#if defined(UNIIME)
            lpImeL,
#endif
            hDC, uCandMode, lpCandList);

        for (i = 0, nChars = 0, nHalfChars = 0; dwStart < dwEnd;
            dwStart++, i++) {
            int    nCharsInOneStr;
            int    nHalfCharsInOneStr;  // how many half width chars
                                        // one full width char ==
                                        // 2 half width chars
            int    nLimit;      // the room left to the candidate window
#ifdef UNICODE
            LPTSTR lpTmpStr;
#endif

            lpStr = (LPTSTR)((LPBYTE)lpCandList +
                lpCandList->dwOffset[dwStart]);

            nLimit = CANDPERPAGE * 3 - nHalfChars;

            if (nLimit <= 1) {
                break;
            }

            szStrBuf[nChars] = szDigit[i + lpImeL->wCandStart];

#ifdef UNICODE
            // the digit for select candidate
            iDx[nChars] = sImeG.xChiCharWi / 2;

            nCharsInOneStr = nHalfCharsInOneStr = 1;
#if defined(WINAR30) //1996/12/12
            iDx[nChars + nCharsInOneStr] = sImeG.xChiCharWi;
#endif

            for (lpTmpStr = lpStr; *lpTmpStr; lpTmpStr++, nCharsInOneStr++) {
                if (nHalfCharsInOneStr > nLimit) {
                    break;
                } else if (*lpTmpStr < 0x0200) {
                    nHalfCharsInOneStr += 1;
                    iDx[nChars + nCharsInOneStr] = sImeG.xChiCharWi / 2;
                } else {
                    nHalfCharsInOneStr += 2;
                    iDx[nChars + nCharsInOneStr] = sImeG.xChiCharWi;
                }
            }
#else
            nHalfCharsInOneStr = nCharsInOneStr = lstrlen(lpStr) + 1;
#endif

            if (nHalfCharsInOneStr <= nLimit) {
                // the room is enough, nChars + 1 for "1", "2", "3", ...
                CopyMemory(&szStrBuf[nChars + 1], lpStr,
                    (nCharsInOneStr - 1) * sizeof(TCHAR));
            } else if (i) {
                break;
            } else {
#ifdef UNICODE
                if (lpStr[nCharsInOneStr - 2 - 1] < 0x0200) {
                    // we need more room to put ".."
                    nCharsInOneStr -= 2;
                } else {
                    nCharsInOneStr -= 1;
                }
#else
                nHalfCharsInOneStr = nCharsInOneStr = nLimit - 2;
#endif
                // nChars + 1 for "1", "2", "3", ...
                CopyMemory(&szStrBuf[nChars + 1], lpStr,
                    (nCharsInOneStr - 1) * sizeof(TCHAR));

#ifdef UNICODE
                // unicode of ..
                iDx[nChars + nCharsInOneStr] = sImeG.xChiCharWi;
                szStrBuf[nChars + nCharsInOneStr++] = 0x2025;
#else
                szStrBuf[nChars + nCharsInOneStr++] = '.';
                szStrBuf[nChars + nCharsInOneStr++] = '.';
#endif
            }
#if defined(WINAR30)
        if (nCharsInOneStr <= 1) {
#ifdef UNICODE
            // add unicode 0x25A1
            *(LPWSTR)&szStrBuf[nChars +1] = 0x25A1;
#else
            // add big-5 0xA1BC
            *(LPWSTR)&szStrBuf[nChars +1] = 0xBCA1;
#endif
            nCharsInOneStr =1+ sizeof(WCHAR) / sizeof(TCHAR);
        }
#endif

            nChars += nCharsInOneStr;
            nHalfChars += nHalfCharsInOneStr;

            if (nHalfCharsInOneStr >= nLimit) {
                break;
            }
        }

        ExtTextOut(hDC, lpImeL->rcCandText.left, lpImeL->rcCandText.top,
            ETO_OPAQUE, &lpImeL->rcCandText,
            szStrBuf, nChars, iDx);

PaintOffCaretCompUnlockCandInfo:
        ImmUnlockIMCC(lpIMC->hCandInfo);

PaintOffCaretCompChkCandInfo:
        if (fCandidate) {
#if !defined(WINAR30)
            goto PaintOffCaretCompUnlockUIPriv;
#else
        } else {
            goto PaintOffCaretCandNone;
#endif
        }
#if defined(WINAR30)
    } else {
PaintOffCaretCandNone:
        ExtTextOut(hDC, lpImeL->rcCandText.left, lpImeL->rcCandText.top,
            ETO_OPAQUE, &lpImeL->rcCandText, (LPTSTR)NULL, 0, NULL);
#endif
    }

    // the composition window has daul function 1. composition window
    // 2. guideline so we need more check on ISC_xxx flags

    if (lpUIPrivate->nShowCompCmd == SW_HIDE) {
        goto PaintOffCaretCompNone;
    } else if (lpUIPrivate->fdwSetContext & ISC_SHOWUICOMPOSITIONWINDOW) {
        LPCOMPOSITIONSTRING lpCompStr;
        DWORD               dwCompStrLen;

        if (!lpIMC->hCompStr) {
            goto PaintOffCaretCompGuideLine;
        }

        lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
        if (!lpCompStr) {
            goto PaintOffCaretCompGuideLine;
        }

        dwCompStrLen = lpCompStr->dwCompStrLen;

        if (!lpCompStr->dwCompStrLen) {
            goto PaintOffCaretCompUnlockCompStr;
        }

        // black text for compistion string
        SetTextColor(hDC, RGB(0x00, 0x00, 0x00));

        ExtTextOut(hDC, lpImeL->rcCompText.left, lpImeL->rcCompText.top,
            ETO_OPAQUE, &lpImeL->rcCompText,
            (LPTSTR)((LPBYTE)lpCompStr + lpCompStr->dwCompStrOffset),
            lpCompStr->dwCompStrLen, iDx);

        if (lpCompStr->dwCompStrLen <= lpCompStr->dwCursorPos) {
            goto PaintOffCaretCompUnlockCompStr;
        }

        // there is error part
        // red text for error
        SetTextColor(hDC, RGB(0xFF, 0x00, 0x00));
        // dark gray background for error
        SetBkColor(hDC, RGB(0x80, 0x80, 0x80));

        ExtTextOut(hDC, lpImeL->rcCompText.left +
            lpCompStr->dwCursorPos * sImeG.xChiCharWi /
                (sizeof(WCHAR) / sizeof(TCHAR)),
            lpImeL->rcCompText.top,
            ETO_OPAQUE, NULL,
            (LPTSTR)((LPBYTE)lpCompStr + lpCompStr->dwCompStrOffset +
            lpCompStr->dwCursorPos),
            (lpCompStr->dwCompStrLen - lpCompStr->dwCursorPos), iDx);

PaintOffCaretCompUnlockCompStr:
        ImmUnlockIMCC(lpIMC->hCompStr);

        if (!dwCompStrLen) {
            goto PaintOffCaretCompGuideLine;
        }
    } else if (lpUIPrivate->fdwSetContext & ISC_SHOWUIGUIDELINE) {
        LPGUIDELINE     lpGuideLine;
        BOOL            fGuideLine;
        LPCANDIDATELIST lpCandList;
        UINT            uStrLen;

PaintOffCaretCompGuideLine:
        if (!lpIMC->hGuideLine) {
            goto PaintOffCaretCompNone;
        }

        lpGuideLine = (LPGUIDELINE)ImmLockIMCC(lpIMC->hGuideLine);
        if (!lpGuideLine) {
            goto PaintOffCaretCompNone;
        }

        fGuideLine = FALSE;

        if (lpGuideLine->dwLevel != GL_LEVEL_INFORMATION) {
            goto PaintOffCaretCompUnlockGuideLine;
        } else if (lpGuideLine->dwIndex != GL_ID_REVERSECONVERSION) {
            goto PaintOffCaretCompUnlockGuideLine;
        } else {
        }

        lpCandList = (LPCANDIDATELIST)((LPBYTE)lpGuideLine +
            lpGuideLine->dwPrivateOffset);

        if (!lpCandList) {
            goto PaintOffCaretCompUnlockGuideLine;
        } else if (!lpCandList->dwCount) {
            goto PaintOffCaretCompUnlockGuideLine;
        } else {
            fGuideLine = TRUE;
        }

        // green text for information
        SetTextColor(hDC, RGB(0x00, 0x80, 0x00));

        lpStr = (LPTSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[0]);

        uStrLen = lstrlen(lpStr);

        ExtTextOut(hDC, lpImeL->rcCompText.left, lpImeL->rcCompText.top,
            ETO_OPAQUE, &lpImeL->rcCompText, lpStr, uStrLen, iDx);

PaintOffCaretCompUnlockGuideLine:
        ImmUnlockIMCC(lpIMC->hGuideLine);

        if (!fGuideLine) {
            goto PaintOffCaretCompNone;
        }
    } else {
PaintOffCaretCompNone:
        ExtTextOut(hDC, lpImeL->rcCompText.left, lpImeL->rcCompText.top,
            ETO_OPAQUE, &lpImeL->rcCompText, (LPTSTR)NULL, 0, NULL);
    }

    DeleteObject(SelectObject(hDC, hOldFont));

#if !defined(WINAR30)
PaintOffCaretCompUnlockUIPriv:
#endif
    GlobalUnlock(hUIPrivate);

PaintOffCaretCompUnlockIMC:
    ImmUnlockIMC(hIMC);
    return;
}
#endif

/**********************************************************************/
/* OffCaretWndProc() / UniOffCaretWndProc()                           */
/**********************************************************************/
#if defined(UNIIME)
LRESULT WINAPI   UniOffCaretWndProc(
    LPINSTDATAL lpInstL,
    LPIMEL      lpImeL,
#else
LRESULT CALLBACK OffCaretWndProc(
#endif
    HWND   hOffCaretWnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (uMsg) {
    case WM_DESTROY:
        DestroyOffCaretWindow(hOffCaretWnd);
        break;
    case WM_SETCURSOR:
        OffCaretSetCursor(
#if defined(UNIIME)
            lpInstL, lpImeL,
#endif
            hOffCaretWnd, lParam);
        break;
    case WM_MOUSEMOVE:
        if (GetWindowLong(hOffCaretWnd, UI_MOVE_OFFSET) != WINDOW_NOT_DRAG) {
            POINT ptCursor;

            DrawDragBorder(hOffCaretWnd,
                GetWindowLong(hOffCaretWnd, UI_MOVE_XY),
                GetWindowLong(hOffCaretWnd, UI_MOVE_OFFSET));
            GetCursorPos(&ptCursor);
            SetWindowLong(hOffCaretWnd, UI_MOVE_XY,
                MAKELONG(ptCursor.x, ptCursor.y));
            DrawDragBorder(hOffCaretWnd, MAKELONG(ptCursor.x, ptCursor.y),
                GetWindowLong(hOffCaretWnd, UI_MOVE_OFFSET));
        } else {
            return DefWindowProc(hOffCaretWnd, uMsg, wParam, lParam);
        }
        break;
    case WM_LBUTTONUP:
        if (GetWindowLong(hOffCaretWnd, UI_MOVE_OFFSET) != WINDOW_NOT_DRAG) {
            LONG   lTmpCursor, lTmpOffset;
            POINT  ptCursor;
            HWND   hUIWnd;

            lTmpCursor = GetWindowLong(hOffCaretWnd, UI_MOVE_XY);

            // calculate the org by the offset
            lTmpOffset = GetWindowLong(hOffCaretWnd, UI_MOVE_OFFSET);

            DrawDragBorder(hOffCaretWnd, lTmpCursor, lTmpOffset);

            ptCursor.x = (*(LPPOINTS)&lTmpCursor).x - (*(LPPOINTS)&lTmpOffset).x;
            ptCursor.y = (*(LPPOINTS)&lTmpCursor).y - (*(LPPOINTS)&lTmpOffset).y;

            SetWindowLong(hOffCaretWnd, UI_MOVE_OFFSET, WINDOW_NOT_DRAG);
            ReleaseCapture();

            AdjustStatusBoundary(
#if defined(UNIIME)
                lpImeL,
#endif
                &ptCursor);

            hUIWnd = GetWindow(hOffCaretWnd, GW_OWNER);

            ImmSetStatusWindowPos((HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC),
                &ptCursor);
        } else {
            return DefWindowProc(hOffCaretWnd, uMsg, wParam, lParam);
        }
        break;
    case WM_IME_NOTIFY:
        if (wParam == IMN_SETSTATUSWINDOWPOS) {
            SetStatusWindowPos(
#if defined(UNIIME)
                lpImeL,
#endif
                hOffCaretWnd);
        }
        break;
    case WM_PAINT:
        {
            HDC         hDC;
            PAINTSTRUCT ps;

            hDC = BeginPaint(hOffCaretWnd, &ps);
            PaintOffCaretStatus(
#if defined(UNIIME)
                lpInstL, lpImeL,
#endif
                hOffCaretWnd, hDC);
#if !defined(ROMANIME)
            PaintOffCaretComposition(
#if defined(UNIIME)
                lpImeL,
#endif
                hOffCaretWnd, hDC);
#endif
            EndPaint(hOffCaretWnd, &ps);
        }
        break;
    case WM_MOUSEACTIVATE:
        return (MA_NOACTIVATE);
    default:
        return DefWindowProc(hOffCaretWnd, uMsg, wParam, lParam);
    }

    return (0L);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\notify.c ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    NOTIFY.C
    
++*/

#include <windows.h>
#include <immdev.h>
#include "imeattr.h"
#include "imedefs.h"
#if defined(UNIIME)
#include "uniime.h"
#endif

/**********************************************************************/
/* GenerateMessage()                                                  */
/**********************************************************************/
void PASCAL GenerateMessage(
    HIMC           hIMC,
    LPINPUTCONTEXT lpIMC,
    LPPRIVCONTEXT  lpImcP)
{
    if (!hIMC) {
        return;
    } else if (!lpIMC) {
        return;
    } else if (!lpImcP) {
        return;
    } else if (lpImcP->fdwImeMsg & MSG_IN_IMETOASCIIEX) {
        return;
    } else {
    }

    lpIMC->dwNumMsgBuf += TranslateImeMessage(NULL, lpIMC, lpImcP);

#if !defined(ROMANIME)
    lpImcP->fdwImeMsg &= (MSG_STATIC_STATE);
    lpImcP->fdwGcsFlag = 0;
#endif

    ImmGenerateMessage(hIMC);
    return;
}

#if !defined(ROMANIME)
/**********************************************************************/
/* SetString()                                                        */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL PASCAL SetString(
#if defined(UNIIME)
    LPIMEL              lpImeL,
#endif
    HIMC                hIMC,
    LPINPUTCONTEXT      lpIMC,
    LPCOMPOSITIONSTRING lpCompStr,
    LPPRIVCONTEXT       lpImcP,
    LPTSTR              lpszRead,
    DWORD               dwReadLen)
{
    DWORD       dwPattern;
    LPGUIDELINE lpGuideLine;
    DWORD       i;

    // convert from byte count to the string length
    dwReadLen = dwReadLen / sizeof(TCHAR);

    if (dwReadLen > lpImeL->nMaxKey * sizeof(WCHAR) / sizeof(TCHAR)) {
        return (FALSE);
    }

    dwPattern = ReadingToPattern(
#if defined(UNIIME)
        lpImeL,
#endif
        lpszRead, lpImcP->bSeq, FALSE);

    if (!dwPattern) {
        return (FALSE);
    }

    InitCompStr(lpCompStr);
    ClearCand(lpIMC);

    lpGuideLine = (LPGUIDELINE)ImmLockIMCC(lpIMC->hGuideLine);
    if (lpGuideLine) {
        InitGuideLine(lpGuideLine);
        ImmUnlockIMCC(lpIMC->hGuideLine);
    }

    // compoition/reading attribute
    lpCompStr->dwCompReadAttrLen = dwReadLen;
    lpCompStr->dwCompAttrLen = lpCompStr->dwCompReadAttrLen;

    // The IME has converted these chars
    for (i = 0; i < dwReadLen; i++) {
        *((LPBYTE)lpCompStr + lpCompStr->dwCompReadAttrOffset + i) =
            ATTR_TARGET_CONVERTED;
    }

    // composition/reading clause, 1 clause only
    lpCompStr->dwCompReadClauseLen = 2 * sizeof(DWORD);
    lpCompStr->dwCompClauseLen = lpCompStr->dwCompReadClauseLen;
    *(LPDWORD)((LPBYTE)lpCompStr + lpCompStr->dwCompReadClauseOffset +
        sizeof(DWORD)) = dwReadLen;

    lpCompStr->dwCompReadStrLen = dwReadLen;
    lpCompStr->dwCompStrLen = lpCompStr->dwCompReadStrLen;
    CopyMemory((LPBYTE)lpCompStr + lpCompStr->dwCompReadStrOffset, lpszRead,
        dwReadLen * sizeof(TCHAR) + sizeof(TCHAR));

    // dlta start from 0;
    lpCompStr->dwDeltaStart = 0;
    // cursor is next to composition string
    lpCompStr->dwCursorPos = lpCompStr->dwCompStrLen;

    lpCompStr->dwResultReadClauseLen = 0;
    lpCompStr->dwResultReadStrLen = 0;
    lpCompStr->dwResultClauseLen = 0;
    lpCompStr->dwResultStrLen = 0;

    // set private input context
    lpImcP->iImeState = CST_INPUT;

    if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
        lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CLOSE_CANDIDATE) &
            ~(MSG_OPEN_CANDIDATE|MSG_CHANGE_CANDIDATE);
    }

    if (!(lpImcP->fdwImeMsg & MSG_ALREADY_START)) {
        lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_START_COMPOSITION) &
            ~(MSG_END_COMPOSITION);
    }

    lpImcP->fdwImeMsg |= MSG_COMPOSITION;
    lpImcP->dwCompChar = (DWORD)lpImeL->wSeq2CompTbl[
        lpImcP->bSeq[lpCompStr->dwCompReadStrLen / 2 - 1]];
#ifndef UNICODE
    lpImcP->dwCompChar = HIBYTE(lpImcP->dwCompChar) |
        (LOBYTE(lpImcP->dwCompChar) << 8);
#endif
    lpImcP->fdwGcsFlag = GCS_COMPREAD|GCS_COMP|
        GCS_DELTASTART|GCS_CURSORPOS;

    lpImcP->fdwImeMsg |= MSG_GUIDELINE;

    if (lpIMC->fdwConversion & IME_CMODE_EUDC) {
#if defined(PHON) || defined(WINIME) || defined(UNICDIME)
        if (lpCompStr->dwCompReadStrLen >= sizeof(WORD) * lpImeL->nMaxKey) {
            lpImcP->fdwImeMsg |= MSG_COMPOSITION;
            lpImcP->fdwGcsFlag |= GCS_RESULTREAD|GCS_RESULTSTR;
        }
#endif
    } else {
#if defined(PHON) || defined(WINIME) || defined(UNICDIME)
        if (dwReadLen < sizeof(WCHAR) / sizeof(TCHAR) * lpImeL->nMaxKey) {
#elif defined(QUICK)
        if (dwReadLen < sizeof(WCHAR) / sizeof(TCHAR) * 2) {
#else
        {
#endif
#if defined(WINAR30)
            // quick key
            if (lpImeL->fdwModeConfig & MODE_CONFIG_QUICK_KEY) {
                Finalize(hIMC, lpIMC, lpCompStr, lpImcP, FALSE);
            }
#endif
        }
    }

    GenerateMessage(hIMC, lpIMC, lpImcP);

    return (TRUE);
}

/**********************************************************************/
/* CompCancel()                                                       */
/**********************************************************************/
void PASCAL CompCancel(
    HIMC            hIMC,
    LPINPUTCONTEXT  lpIMC)
{
    LPPRIVCONTEXT lpImcP;

    if (!lpIMC->hPrivate) {
        return;
    }

    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    if (!lpImcP) {
        return;
    }

    lpImcP->fdwGcsFlag = (DWORD) 0;

    if (lpImcP->fdwImeMsg & (MSG_ALREADY_OPEN|MSG_OPEN_CANDIDATE)) {
        CandEscapeKey(lpIMC, lpImcP);
    } else if (lpImcP->fdwImeMsg & (MSG_ALREADY_START|MSG_START_COMPOSITION)) {
        LPCOMPOSITIONSTRING lpCompStr;
        LPGUIDELINE         lpGuideLine;

        lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
        lpGuideLine = (LPGUIDELINE)ImmLockIMCC(lpIMC->hGuideLine);

        CompEscapeKey(lpIMC, lpCompStr, lpGuideLine, lpImcP);

        if (lpGuideLine) {
            ImmUnlockIMCC(lpIMC->hGuideLine);
        }
        if (lpCompStr) {
            ImmUnlockIMCC(lpIMC->hCompStr);
        }
    } else {
        ImmUnlockIMCC(lpIMC->hPrivate);
        return;
    }

    GenerateMessage(hIMC, lpIMC, lpImcP);

    ImmUnlockIMCC(lpIMC->hPrivate);

    return;
}
#endif

/**********************************************************************/
/* ImeSetCompositionString()                                          */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
#if defined(UNIIME)
BOOL WINAPI UniImeSetCompositionString(
    LPINSTDATAL lpInstL,
    LPIMEL      lpImeL,
#else
BOOL WINAPI ImeSetCompositionString(
#endif
    HIMC        hIMC,
    DWORD       dwIndex,
    LPVOID      lpComp,
    DWORD       dwCompLen,
    LPVOID      lpRead,
    DWORD       dwReadLen)
{
#if defined(ROMANIME)
    return (FALSE);
#else
    LPINPUTCONTEXT      lpIMC;
    LPCOMPOSITIONSTRING lpCompStr;
    LPPRIVCONTEXT       lpImcP;
    BOOL                fRet;
    TCHAR               szReading[16];

    if (!hIMC) {
        return (FALSE);
    }

    // composition string must  == reading string
    // reading is more important
    if (!dwReadLen) {
        dwReadLen = dwCompLen;
    }

    // composition string must  == reading string
    // reading is more important
    if (!lpRead) {
        lpRead = lpComp;
    }

    if (!dwReadLen) {
        lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
        if (!lpIMC) {
            return (FALSE);
        }

        CompCancel(hIMC, lpIMC);
        ImmUnlockIMC(hIMC);
        return (TRUE);
    } else if (!lpRead) {
        return (FALSE);
    } else if (dwReadLen >= sizeof(szReading)) {
        return (FALSE);
    } else if (!dwCompLen) {
    } else if (!lpComp) {
    } else if (dwReadLen != dwCompLen) {
        return (FALSE);
    } else if (lpRead == lpComp) {
    } else if (!lstrcmp(lpRead, lpComp)) {
        // composition string must  == reading string
    } else {
        // composition string != reading string
        return (FALSE);
    }

    if (dwIndex != SCS_SETSTR) {
        return (FALSE);
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return (FALSE);
    }

    fRet = FALSE;

    if ((lpIMC->fdwConversion & (IME_CMODE_NATIVE|IME_CMODE_SYMBOL)) !=
        IME_CMODE_NATIVE) {
        goto ImeSetCompStrUnlockIMC;
    }

    lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
    if (!lpCompStr) {
        goto ImeSetCompStrUnlockIMC;
    }

    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    if (!lpImcP) {
        goto ImeSetCompStrUnlockCompStr;
    }

    if (*(LPTSTR)((LPBYTE)lpRead + dwReadLen) != '\0') {
        CopyMemory(szReading, (LPBYTE)lpRead, dwReadLen);
        lpRead = szReading;
        *(LPTSTR)((LPBYTE)lpRead + dwReadLen) = '\0';
    }

    fRet = SetString(
#if defined(UNIIME)
        lpImeL,
#endif
        hIMC, lpIMC, lpCompStr, lpImcP, lpRead, dwReadLen);

    ImmUnlockIMCC(lpIMC->hPrivate);
ImeSetCompStrUnlockCompStr:
    ImmUnlockIMCC(lpIMC->hCompStr);
ImeSetCompStrUnlockIMC:
    ImmUnlockIMC(hIMC);

    return (fRet);
#endif
}

#if !defined(ROMANIME)
/**********************************************************************/
/* GenerateImeMessage()                                               */
/**********************************************************************/
void PASCAL GenerateImeMessage(
    HIMC           hIMC,
    LPINPUTCONTEXT lpIMC,
    DWORD          fdwImeMsg)
{
    LPPRIVCONTEXT lpImcP;

    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    if (!lpImcP) {
        return;
    }

    lpImcP->fdwImeMsg |= fdwImeMsg;

    if (fdwImeMsg & MSG_CLOSE_CANDIDATE) {
        lpImcP->fdwImeMsg &= ~(MSG_OPEN_CANDIDATE|MSG_CHANGE_CANDIDATE);
    } else if (fdwImeMsg & (MSG_OPEN_CANDIDATE|MSG_CHANGE_CANDIDATE)) {
        lpImcP->fdwImeMsg &= ~(MSG_CLOSE_CANDIDATE);
    } else {
    }

    if (fdwImeMsg & MSG_END_COMPOSITION) {
        lpImcP->fdwImeMsg &= ~(MSG_START_COMPOSITION);
    } else if (fdwImeMsg & MSG_START_COMPOSITION) {
        lpImcP->fdwImeMsg &= ~(MSG_END_COMPOSITION);
    } else {
    }

    GenerateMessage(hIMC, lpIMC, lpImcP);

    ImmUnlockIMCC(lpIMC->hPrivate);

    return;
}

/**********************************************************************/
/* NotifySelectCand()                                                 */
/**********************************************************************/
void PASCAL NotifySelectCand( // app tell IME that one candidate string is
                              // selected (by mouse or non keyboard action
                              // - for example sound)
#if defined(UNIIME)
    LPIMEL          lpImeL,
#endif
    HIMC            hIMC,
    LPINPUTCONTEXT  lpIMC,
    LPCANDIDATEINFO lpCandInfo,
    DWORD           dwIndex,
    DWORD           dwValue)
{
    LPCANDIDATELIST     lpCandList;
    LPCOMPOSITIONSTRING lpCompStr;
    LPPRIVCONTEXT       lpImcP;

    if (!lpCandInfo) {
        return;
    }

    if (dwIndex >= lpCandInfo->dwCount) {
        // wanted candidate list is not created yet!
        return;
    } else if (dwIndex == 0) {
    } else {
    }

    lpCandList = (LPCANDIDATELIST)
        ((LPBYTE)lpCandInfo + lpCandInfo->dwOffset[0]);

    // the selected value even more than the number of total candidate
    // strings, it is imposible. should be error of app
    if (dwValue >= lpCandList->dwCount) {
        return;
    }

#if defined(WINAR30)
    if (!*(LPWSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[dwValue])) {
        MessageBeep((UINT)-1);
        return;
    }
#endif

    // app select this candidate string
    lpCandList->dwSelection = dwValue;

    lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);

    // translate into message buffer
    SelectOneCand(
#if defined(UNIIME)
        lpImeL,
#endif
        hIMC, lpIMC, lpCompStr, lpImcP, lpCandList);

    // let app generate those messages in its message loop
    GenerateMessage(hIMC, lpIMC, lpImcP);

    ImmUnlockIMCC(lpIMC->hPrivate);
    ImmUnlockIMCC(lpIMC->hCompStr);

    return;
}
#endif

/**********************************************************************/
/* SetConvMode()                                                      */
/**********************************************************************/
void PASCAL SetConvMode(
    HIMC           hIMC,
    LPINPUTCONTEXT lpIMC,
    DWORD          dwIndex)
{
    DWORD fdwImeMsg;

    if ((lpIMC->fdwConversion ^ dwIndex) & IME_CMODE_CHARCODE) {
        // reject CHARCODE
        lpIMC->fdwConversion &= ~IME_CMODE_CHARCODE;
        MessageBeep((UINT)-1);
        return;
    }

    fdwImeMsg = 0;

    if ((lpIMC->fdwConversion ^ dwIndex) & IME_CMODE_NOCONVERSION) {
        lpIMC->fdwConversion |= IME_CMODE_NATIVE;
        lpIMC->fdwConversion &= ~(IME_CMODE_CHARCODE|
        IME_CMODE_EUDC|IME_CMODE_SYMBOL);
    }

    if ((lpIMC->fdwConversion ^ dwIndex) & IME_CMODE_EUDC) {
        lpIMC->fdwConversion |= IME_CMODE_NATIVE;
        lpIMC->fdwConversion &= ~(IME_CMODE_CHARCODE|
        IME_CMODE_NOCONVERSION|IME_CMODE_SYMBOL);
    }

#if !defined(ROMANIME) && !defined(WINAR30)
    if ((lpIMC->fdwConversion ^ dwIndex) & IME_CMODE_SOFTKBD) {
        LPPRIVCONTEXT lpImcP;

        if (!(lpIMC->fdwConversion & IME_CMODE_NATIVE)) {
            MessageBeep((UINT)-1);
            return;
        }

        fdwImeMsg |= MSG_IMN_UPDATE_SOFTKBD;

        if (lpIMC->fdwConversion & IME_CMODE_SOFTKBD) {
        } else if (lpIMC->fdwConversion & IME_CMODE_SYMBOL) {
            lpIMC->fdwConversion &= ~(IME_CMODE_SYMBOL);
        } else {
        }

        lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);

        if (!lpImcP) {
            goto NotifySKOvr;
        }

        if (lpIMC->fdwConversion & IME_CMODE_SOFTKBD) {
            // now we already in soft keyboard state by
            // this change

            // even end user finish the symbol, we should not
            // turn off soft keyboard

            lpImcP->fdwImeMsg |= MSG_ALREADY_SOFTKBD;
        } else {
            // now we are not in soft keyboard state by
            // this change

            // after end user finish the symbol, we should
            // turn off soft keyboard

            lpImcP->fdwImeMsg &= ~(MSG_ALREADY_SOFTKBD);
        }

        ImmUnlockIMCC(lpIMC->hPrivate);
NotifySKOvr:
        ;   // NULL statement for goto
    }
#endif

    if ((lpIMC->fdwConversion ^ dwIndex) == IME_CMODE_NATIVE) {
        lpIMC->fdwConversion &= ~(IME_CMODE_CHARCODE|
            IME_CMODE_NOCONVERSION|IME_CMODE_EUDC|IME_CMODE_SYMBOL);
#if !defined(ROMANIME) && !defined(WINAR30)
        fdwImeMsg |= MSG_IMN_UPDATE_SOFTKBD;
#endif
    }

#if !defined(ROMANIME)
    if ((lpIMC->fdwConversion ^ dwIndex) & IME_CMODE_SYMBOL) {
        LPCOMPOSITIONSTRING lpCompStr;
#if !defined(WINAR30)
        LPPRIVCONTEXT       lpImcP;
#endif

        if (lpIMC->fdwConversion & IME_CMODE_EUDC) {
            lpIMC->fdwConversion &= ~(IME_CMODE_SYMBOL);
            MessageBeep((UINT)-1);
            return;
        }

        if (!(lpIMC->fdwConversion & IME_CMODE_NATIVE)) {
            lpIMC->fdwConversion &= ~(IME_CMODE_SYMBOL);
            lpIMC->fdwConversion |= (dwIndex & IME_CMODE_SYMBOL);
            MessageBeep((UINT)-1);
            return;
        }

        lpCompStr = ImmLockIMCC(lpIMC->hCompStr);

        if (lpCompStr) {
            if (!lpCompStr->dwCompStrLen) {
            } else if (lpIMC->fdwConversion & IME_CMODE_SYMBOL) {
                // if there is a string we could not change
                // to symbol mode

                lpIMC->fdwConversion &= ~(IME_CMODE_SYMBOL);
                MessageBeep((UINT)-1);
                return;
            } else { 
            }

            ImmUnlockIMCC(lpIMC->hCompStr);
        }

        lpIMC->fdwConversion &= ~(IME_CMODE_CHARCODE|
            IME_CMODE_NOCONVERSION|IME_CMODE_EUDC);

#if !defined(WINAR30)
        if (lpIMC->fdwConversion & IME_CMODE_SYMBOL) {
            lpIMC->fdwConversion |= IME_CMODE_SOFTKBD;
        } else if (lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate)) {
            // we borrow the bit for this usage
            if (!(lpImcP->fdwImeMsg & MSG_ALREADY_SOFTKBD)) {
                lpIMC->fdwConversion &= ~(IME_CMODE_SOFTKBD);
            }

            ImmUnlockIMCC(lpIMC->hPrivate);
        } else {
        }

        fdwImeMsg |= MSG_IMN_UPDATE_SOFTKBD;
#endif
    }
#endif

#if !defined(ROMANIME) && !defined(WINAR30)
    if (fdwImeMsg) {
        GenerateImeMessage(hIMC, lpIMC, fdwImeMsg);
    }
#endif

    if ((lpIMC->fdwConversion ^ dwIndex) & ~(IME_CMODE_FULLSHAPE|
        IME_CMODE_SOFTKBD)) {
    } else {
        return;
    }

#if !defined(ROMANIME)
    CompCancel(hIMC, lpIMC);
#endif
    return;
}

#if !defined(ROMANIME)
/**********************************************************************/
/* CompComplete()                                                     */
/**********************************************************************/
void PASCAL CompComplete(
#if defined(UNIIME)
    LPINSTDATAL    lpInstL,
    LPIMEL         lpImeL,
#endif
    HIMC           hIMC,
    LPINPUTCONTEXT lpIMC)
{
    LPPRIVCONTEXT lpImcP;

    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);

    if (!lpImcP) {
        return;
    }

    if (lpImcP->iImeState == CST_INIT) {
        // can not do any thing
        CompCancel(hIMC, lpIMC);
    } else if (lpImcP->iImeState == CST_CHOOSE) {
        LPCOMPOSITIONSTRING lpCompStr;
        LPCANDIDATEINFO     lpCandInfo;

        lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);

        lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo);

        if (lpCandInfo) {
            LPCANDIDATELIST lpCandList;

            lpCandList = (LPCANDIDATELIST)((LPBYTE)lpCandInfo +
                lpCandInfo->dwOffset[0]);

            SelectOneCand(
#if defined(UNIIME)
                lpImeL,
#endif
                hIMC, lpIMC, lpCompStr, lpImcP, lpCandList);

            ImmUnlockIMCC(lpIMC->hCandInfo);

            GenerateMessage(hIMC, lpIMC, lpImcP);
        }

        if (lpCompStr) ImmUnlockIMCC(lpIMC->hCompStr);
    } else if ((lpIMC->fdwConversion & (IME_CMODE_NATIVE|
        IME_CMODE_EUDC|IME_CMODE_SYMBOL)) != IME_CMODE_NATIVE) {
        CompCancel(hIMC, lpIMC);
    } else if (lpImcP->iImeState == CST_INPUT) {
        LPCOMPOSITIONSTRING lpCompStr;
        LPGUIDELINE         lpGuideLine;
        LPCANDIDATEINFO     lpCandInfo;

        lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
        lpGuideLine = (LPGUIDELINE)ImmLockIMCC(lpIMC->hGuideLine);

        CompWord(
#if defined(UNIIME)
            lpInstL, lpImeL,
#endif
            ' ', hIMC, lpIMC, lpCompStr, lpGuideLine, lpImcP);

        if (lpImcP->iImeState == CST_INPUT) {
            CompCancel(hIMC, lpIMC);
        } else if (lpImcP->iImeState != CST_CHOOSE) {
        } else if (lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(
            lpIMC->hCandInfo)) {
            LPCANDIDATELIST lpCandList;

            lpCandList = (LPCANDIDATELIST)((LPBYTE)lpCandInfo +
                lpCandInfo->dwOffset[0]);

            SelectOneCand(
#if defined(UNIIME)
                lpImeL,
#endif
                hIMC, lpIMC, lpCompStr, lpImcP, lpCandList);

            ImmUnlockIMCC(lpIMC->hCandInfo);
        } else {
        }

        if (lpCompStr) ImmUnlockIMCC(lpIMC->hCompStr);
        if (lpGuideLine) ImmUnlockIMCC(lpIMC->hGuideLine);

        // don't phrase predition under this case
        if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
            lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CLOSE_CANDIDATE) &
                ~(MSG_OPEN_CANDIDATE|MSG_CHANGE_CANDIDATE);
        } else {
            lpImcP->fdwImeMsg &= ~(MSG_CLOSE_CANDIDATE|MSG_OPEN_CANDIDATE);
        }

        GenerateMessage(hIMC, lpIMC, lpImcP);
    } else {
        CompCancel(hIMC, lpIMC);
    }

    ImmUnlockIMCC(lpIMC->hPrivate);

    return;
}
#endif

/**********************************************************************/
/* NotifyIME() / UniNotifyIME()                                       */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
#if defined(UNIIME)
BOOL WINAPI UniNotifyIME(
    LPINSTDATAL lpInstL,
    LPIMEL      lpImeL,
#else
BOOL WINAPI NotifyIME(
#endif
    HIMC        hIMC,
    DWORD       dwAction,
    DWORD       dwIndex,
    DWORD       dwValue)
{
    LPINPUTCONTEXT lpIMC;
    BOOL           fRet;

    fRet = FALSE;

    if (!hIMC) {
        return (fRet);
    }

    switch (dwAction) {
    case NI_OPENCANDIDATE:      // after a composition string is determined
                                // if an IME can open candidate, it will.
                                // if it can not, app also can not open it.
    case NI_CLOSECANDIDATE:
        return (fRet);          // not supported
    case NI_SELECTCANDIDATESTR:
    case NI_SETCANDIDATE_PAGESTART:
    case NI_SETCANDIDATE_PAGESIZE:
#if defined(ROMANIME)
        return (fRet);
#else
        break;                  // need to handle it
#endif
    case NI_CHANGECANDIDATELIST:
        return (TRUE);          // not important to the IME
    case NI_CONTEXTUPDATED:
        switch (dwValue) {
        case IMC_SETCONVERSIONMODE:
        case IMC_SETSENTENCEMODE:
        case IMC_SETOPENSTATUS:
            break;              // need to handle it
        case IMC_SETCANDIDATEPOS:
        case IMC_SETCOMPOSITIONFONT:
        case IMC_SETCOMPOSITIONWINDOW:
            return (TRUE);      // not important to the IME
        default:
            return (fRet);      // not supported
        }
        break;
    case NI_COMPOSITIONSTR:
        switch (dwIndex) {
#if !defined(ROMANIME)
        case CPS_COMPLETE:
            break;              // need to handle it
        case CPS_CONVERT:       // all composition string can not be convert
        case CPS_REVERT:        // any more, it maybe work for some
                                // intelligent phonetic IMEs
            return (fRet);
        case CPS_CANCEL:
            break;              // need to handle it
#endif
        default:
            return (fRet);      // not supported
        }
        break;                  // need to handle it
    default:
        return (fRet);          // not supported
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return (fRet);
    }

    fRet = TRUE;

    switch (dwAction) {
    case NI_CONTEXTUPDATED:
        switch (dwValue) {
        case IMC_SETCONVERSIONMODE:
            SetConvMode(hIMC, lpIMC, dwIndex);
            break;
        case IMC_SETSENTENCEMODE:
#if !defined(ROMANIME)
            //if ((WORD)lpIMC->fdwSentence == IME_SMODE_PHRASEPREDICT) {
                          if (lpIMC->fdwSentence & IME_SMODE_PHRASEPREDICT) {
                if ((lpIMC->fdwConversion & (IME_CMODE_NATIVE|
                    IME_CMODE_EUDC)) != IME_CMODE_NATIVE) {

                    lpIMC->fdwSentence = dwIndex;
                    break;
                }
            } else {
                LPPRIVCONTEXT lpImcP;

                lpImcP = ImmLockIMCC(lpIMC->hPrivate);

                if (lpImcP) {
                    if (lpImcP->iImeState == CST_INIT) {
                        if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
                            ClearCand(lpIMC);
                            lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg|
                                MSG_CLOSE_CANDIDATE) & ~(MSG_OPEN_CANDIDATE|
                                MSG_CHANGE_CANDIDATE);
                            GenerateMessage(hIMC, lpIMC, lpImcP);
                        } else if (lpImcP->fdwImeMsg & (MSG_OPEN_CANDIDATE|
                            MSG_CHANGE_CANDIDATE)) {
                            lpImcP->fdwImeMsg &= ~(MSG_OPEN_CANDIDATE|
                                MSG_CHANGE_CANDIDATE);
                        } else {
                        }
                    }

                    ImmUnlockIMCC(lpIMC->hPrivate);
                }
            }
#endif
            break;
        case IMC_SETOPENSTATUS:
#if !defined(ROMANIME)
#if !defined(WINAR30)
            if (lpIMC->fdwConversion & IME_CMODE_SOFTKBD) {
                GenerateImeMessage(hIMC, lpIMC, MSG_IMN_UPDATE_SOFTKBD);
            }
#endif
            CompCancel(hIMC, lpIMC);
#endif
            break;
        default:
            break;
        }
        break;
#if !defined(ROMANIME)
    case NI_SELECTCANDIDATESTR:
        if (!lpIMC->fOpen) {
            fRet = FALSE;
            break;
        } else if (lpIMC->fdwConversion & IME_CMODE_NOCONVERSION) {
            fRet = FALSE;
            break;
#if defined(WINAR30) || defined(DAYI)
        } else if (lpIMC->fdwConversion & IME_CMODE_EUDC) {
            fRet = FALSE;
            break;
#else
        } else if (lpIMC->fdwConversion & (IME_CMODE_EUDC|IME_CMODE_SYMBOL)) {
            fRet = FALSE;
            break;
#endif
        } else if (!lpIMC->hCandInfo) {
            fRet = FALSE;
            break;
        } else {
            LPCANDIDATEINFO lpCandInfo;

            lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo);

            NotifySelectCand(
#if defined(UNIIME)
                lpImeL,
#endif
                hIMC, lpIMC, lpCandInfo, dwIndex, dwValue);

            ImmUnlockIMCC(lpIMC->hCandInfo);
        }

        break;
    case NI_SETCANDIDATE_PAGESTART:
    case NI_SETCANDIDATE_PAGESIZE:
        if (dwIndex != 0) {
            fRet = FALSE;
            break;
        } else if (!lpIMC->fOpen) {
            fRet = FALSE;
            break;
        } else if (lpIMC->fdwConversion & IME_CMODE_NOCONVERSION) {
            fRet = FALSE;
            break;
        } else if (lpIMC->fdwConversion & (IME_CMODE_EUDC|IME_CMODE_SYMBOL)) {
            fRet = FALSE;
            break;
        } else if (!lpIMC->hCandInfo) {
            fRet = FALSE;
            break;
        } else {
            LPCANDIDATEINFO lpCandInfo;
            LPCANDIDATELIST lpCandList;

            lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo);
            if (!lpCandInfo) {
                fRet = FALSE;
                break;
            }

            lpCandList = (LPCANDIDATELIST)((LPBYTE)lpCandInfo +
                lpCandInfo->dwOffset[0]);

            if (dwAction == NI_SETCANDIDATE_PAGESTART) {
                if (dwValue < lpCandList->dwCount) {
                    lpCandList->dwPageStart = lpCandList->dwSelection =
                        dwValue;
                }
            } else {
                if (dwValue) {
                    lpCandList->dwPageSize = dwValue;
                }
            }

            GenerateImeMessage(hIMC, lpIMC, MSG_CHANGE_CANDIDATE);

            ImmUnlockIMCC(lpIMC->hCandInfo);
        }

        break;
    case NI_COMPOSITIONSTR:
        switch (dwIndex) {
        case CPS_CANCEL:
            CompCancel(hIMC, lpIMC);
            break;
        case CPS_COMPLETE:
            CompComplete(
#if defined(UNIIME)
                lpInstL, lpImeL,
#endif
                hIMC, lpIMC);
            break;
        default:
            break;
        }
        break;
#endif // !defined(ROMANIME)
    default:
        break;
    }

    ImmUnlockIMC(hIMC);
    return (fRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\search.c ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    SEARCH.c
    
++*/

#include <windows.h>
#include <immdev.h>
#include "imeattr.h"
#include "imedefs.h"

#if !defined(ROMANIME)
#if defined(WINAR30)
/**********************************************************************/
/* SearchQuickKey()                                                   */
/* Description:                                                       */
/*      Search for the quick key table                                */
/*      file format can be changed in different version for           */
/*      performance consideration, ISVs should not assume its format  */
/*      Array has the CopyRight of this table file                    */
/**********************************************************************/
void PASCAL SearchQuickKey(
    LPCANDIDATELIST     lpCandList,
    LPPRIVCONTEXT       lpImcP)
{
    UINT   uStart, uEnd;
    HANDLE hHighWordTbl;
    LPWORD lpHighWordTbl;

    if (lpImcP->bSeq[1]) {
        uStart = (lpImcP->bSeq[0] - 1) * 300 + (lpImcP->bSeq[1] - 1) * 10 +
            300;
    } else {
        uStart = (lpImcP->bSeq[0] - 1) * 10;
    }

    hHighWordTbl = OpenFileMapping(FILE_MAP_READ, FALSE,
        lpImeL->szTblFile[1]);
    if (!hHighWordTbl) {
        return;
    }

    lpHighWordTbl = MapViewOfFile(hHighWordTbl, FILE_MAP_READ,
        0, 0, 0);
    if (!lpHighWordTbl) {
        goto SrchQuickKeyOvr;
    }

    uEnd = uStart + 10;

    for (; uStart < uEnd; uStart++) {
        UINT uCode;

        uCode = (WORD)*(lpHighWordTbl + uStart);

        AddCodeIntoCand(lpCandList, uCode);
    }

    UnmapViewOfFile(lpHighWordTbl);

SrchQuickKeyOvr:
    CloseHandle(hHighWordTbl);
}
#endif

#if defined(DAYI) || defined(UNIIME)
/**********************************************************************/
/* SearchPhraseTbl()                                                  */
/* Description:                                                       */
/*      file format can be changed in different version for           */
/*      performance consideration, ISVs should not assume its format  */
/**********************************************************************/
void PASCAL SearchPhraseTbl(        // searching the phrase table files
#if defined(UNIIME)
    LPIMEL          lpImeL,
#endif
    UINT            uTblIndex,
    LPCANDIDATELIST lpCandList,
    DWORD           dwPattern)
{
    HANDLE  hTbl;
    LPBYTE  lpTbl;
    int     iLo, iHi, iMid;
    BOOL    bFound;
    LPBYTE  lpPattern;

    hTbl = OpenFileMapping(FILE_MAP_READ, FALSE,
        lpImeL->szTblFile[uTblIndex]);
    if (!hTbl) {
        return;
    }

    lpTbl = (LPBYTE)MapViewOfFile(hTbl, FILE_MAP_READ, 0, 0, 0);
    if (!lpTbl) {
        CloseHandle(hTbl);
        return;
    }

    iLo = 0;
#ifdef UNICODE
    iHi = lpImeL->uTblSize[uTblIndex] / (lpImeL->nSeqBytes + sizeof(DWORD));
#else
    iHi = lpImeL->uTblSize[uTblIndex] / (lpImeL->nSeqBytes + sizeof(WORD));
#endif
    iMid = (iHi + iLo) /2;

    // binary search
    for (; iLo <= iHi; ) {
        LPUNADWORD lpCurr;

#ifdef UNICODE
        lpCurr = (LPDWORD)(lpTbl + (lpImeL->nSeqBytes + sizeof(DWORD)) *
            iMid);
#else
        lpCurr = (LPDWORD)(lpTbl + (lpImeL->nSeqBytes + sizeof(WORD)) *
            iMid);
#endif

        if (dwPattern > (*lpCurr & lpImeL->dwPatternMask)) {
            iLo = iMid + 1;
        } else if (dwPattern < (*lpCurr & lpImeL->dwPatternMask)) {
            iHi = iMid - 1;
        } else {
            bFound = TRUE;
            break;
        }

        iMid = (iHi + iLo) /2;
    }

    if (bFound) {
        HANDLE  hPhrase;
        LPBYTE  lpPhrase;
        LPWORD  lpStart, lpEnd;

        // find the lower bound
#ifdef UNICODE
        lpPattern = lpTbl + (lpImeL->nSeqBytes + sizeof(DWORD)) * iMid;
#else
        lpPattern = lpTbl + (lpImeL->nSeqBytes + sizeof(WORD)) * iMid;
#endif

#ifdef UNICODE
        for (; (LPBYTE)lpPattern >= lpTbl; (LPBYTE)lpPattern -=
            lpImeL->nSeqBytes + sizeof(DWORD)) {
#else
        for (; (LPBYTE)lpPattern >= lpTbl; (LPBYTE)lpPattern -=
            lpImeL->nSeqBytes + sizeof(WORD)) {
#endif
            if (dwPattern > (*(LPUNADWORD)lpPattern & lpImeL->dwPatternMask)) {
                // previous one is the lower bound
#ifdef UNICODE
                (LPBYTE)lpPattern += lpImeL->nSeqBytes + sizeof(DWORD);
#else
                (LPBYTE)lpPattern += lpImeL->nSeqBytes + sizeof(WORD);
#endif
                break;
            }
        }

        if ((LPBYTE)lpPattern <= lpTbl) {
            goto SrchPhrUnmapPattern;
        }

        hPhrase = OpenFileMapping(FILE_MAP_READ, FALSE,
            lpImeL->szTblFile[uTblIndex + 1]);
        if (!hPhrase) {
            goto SrchPhrUnmapPattern;
        }

        lpPhrase = (LPBYTE)MapViewOfFile(hPhrase, FILE_MAP_READ, 0, 0, 0);
        if (!lpPhrase) {
            goto SrchPhrClosePhr;
        }

        // offset of the string
#ifdef UNICODE
        lpEnd = (LPWORD)lpPhrase + *(LPUNADWORD)(lpPattern +
            lpImeL->nSeqBytes);
#else
        lpEnd = (LPWORD)lpPhrase + *(LPUNAWORD)(lpPattern + lpImeL->nSeqBytes);
#endif

#ifdef UNICODE
        for (; dwPattern == (*(LPUNADWORD)lpPattern & lpImeL->dwPatternMask);
            (LPBYTE)lpPattern += lpImeL->nSeqBytes + sizeof(DWORD)) {
#else
        for (; dwPattern == (*(LPUNADWORD)lpPattern & lpImeL->dwPatternMask);
            (LPBYTE)lpPattern += lpImeL->nSeqBytes + sizeof(WORD)) {
#endif
            WORD   wCode;
            DWORD  dwStrLen;

            lpStart = lpEnd;

            // offset of next string
#ifdef UNICODE
            lpEnd = (LPWORD)lpPhrase + *(LPUNADWORD)(lpPattern +
                lpImeL->nSeqBytes * 2 + sizeof(DWORD));
#else
            lpEnd = (LPWORD)lpPhrase + *(LPUNAWORD)(lpPattern +
                lpImeL->nSeqBytes * 2 + sizeof(WORD));
#endif

            for (dwStrLen = 0; lpStart < lpEnd; lpStart++,
                dwStrLen += sizeof(WORD)) {

                wCode = *lpStart;

#ifndef UNICODE
                wCode = HIBYTE(wCode) | (LOBYTE(wCode) << 8);
#endif

                // add this char into candidate list
                *(LPWSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[
                    lpCandList->dwCount] + dwStrLen) = wCode;
            }

            // null terminator
            *(LPTSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[
              lpCandList->dwCount] + dwStrLen) = '\0';

            dwStrLen += sizeof(TCHAR);

            // add one string into candidate list
            lpCandList->dwCount++;

            if (lpCandList->dwCount >= MAXCAND) {
                // Grow memory here and do something,
                // if you still want to process it.
                break;
            }

            // string length plus size of the null terminator
            lpCandList->dwOffset[lpCandList->dwCount] =
                lpCandList->dwOffset[lpCandList->dwCount - 1] +
                dwStrLen + sizeof(TCHAR);
        }

        UnmapViewOfFile(lpPhrase);

SrchPhrClosePhr:
        CloseHandle(hPhrase);
    }

SrchPhrUnmapPattern:
    UnmapViewOfFile(lpTbl);

    CloseHandle(hTbl);

    return;
}
#endif
#if defined(WINAR30)  
/**********************************************************************/
/* SearchPhraseTbl()                                                  */
/* Description:                                                       */
/*      file format can be changed in different version for           */
/*      performance consideration, ISVs should not assume its format  */
/**********************************************************************/
void PASCAL SearchPhraseTbl(        // searching the phrase table files
    UINT            uTblIndex,
    LPCANDIDATELIST lpCandList,
    DWORD           dwPattern)
{
    HANDLE  hTbl;
    LPBYTE  lpTbl;
    int     iLo, iHi, iMid;
    BOOL    bFound;
    LPBYTE  lpPattern,lpPattern_end;
    hTbl = OpenFileMapping(FILE_MAP_READ, FALSE,
        lpImeL->szTblFile[uTblIndex]);
    if (!hTbl) {
        return;
    }

    lpTbl = (LPBYTE)MapViewOfFile(hTbl, FILE_MAP_READ, 0, 0, 0);
    if (!lpTbl) {
        CloseHandle(hTbl);
        return;
    }

    iLo = 1;
//    iHi = lpImeL->uTblSize[uTblIndex] / (lpImeL->nSeqBytes *2);
    iHi = (*(LPDWORD)(lpTbl) & lpImeL->dwPatternMask);
    iMid = (iHi + iLo) /2;

    // binary search
    for (; iLo <= iHi; ) {
        LPUNADWORD lpCurr;

        lpCurr = (LPDWORD)(lpTbl + (lpImeL->nSeqBytes * 2 ) *
            iMid);

        if (dwPattern > (*lpCurr & lpImeL->dwPatternMask)) {
            iLo = iMid + 1;
        } else if (dwPattern < (*lpCurr & lpImeL->dwPatternMask)) {
            iHi = iMid - 1;
        } else {
            bFound = TRUE;
            break;
        }

        iMid = (iHi + iLo) /2;
    }

    if (bFound) {
        HANDLE  hPhrase;
        LPBYTE  lpPhrase;
        LPWORD  lpStart, lpEnd;

        // find the lower bound
        lpPattern = lpTbl + (lpImeL->nSeqBytes * 2) * iMid;

        for (; (LPBYTE)lpPattern >= lpTbl; (LPBYTE)lpPattern -=
            lpImeL->nSeqBytes * 2 ) {
            if (dwPattern > (*(LPUNADWORD)lpPattern & lpImeL->dwPatternMask)) {
                // previous one is the lower bound
                (LPBYTE)lpPattern += lpImeL->nSeqBytes * 2;
                break;
            }
        }

        if ((LPBYTE)lpPattern <= lpTbl) {
            goto SrchPhrUnmapPattern;
        }

        hPhrase = OpenFileMapping(FILE_MAP_READ, FALSE,
            lpImeL->szTblFile[uTblIndex + 1]);
        if (!hPhrase) {
            goto SrchPhrUnmapPattern;
        }

        lpPhrase = (LPBYTE)MapViewOfFile(hPhrase, FILE_MAP_READ, 0, 0, 0);
        if (!lpPhrase) {
            goto SrchPhrClosePhr;
        }

        // offset of the string
        lpEnd = (LPWORD)lpPhrase + (*(LPUNADWORD)(lpPattern + lpImeL->nSeqBytes) & lpImeL->dwPatternMask);

        for (; dwPattern == (*(LPUNADWORD)lpPattern & lpImeL->dwPatternMask);
            (LPBYTE)lpPattern += lpImeL->nSeqBytes * 2 ) {
            WORD   wCode;
            DWORD  dwStrLen;

            lpStart = lpEnd;

            // offset of next string
            lpEnd = (LPWORD)lpPhrase + (*(LPUNADWORD)(lpPattern +
                lpImeL->nSeqBytes * 3) & lpImeL->dwPatternMask);

            for (dwStrLen = 0; lpStart < lpEnd; lpStart++,
                dwStrLen += sizeof(WORD)) {

                wCode = *lpStart;

                // add this char into candidate list
                *(LPWSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[
                    lpCandList->dwCount] + dwStrLen) = wCode;
            }

            // null terminator
            *(LPTSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[
              lpCandList->dwCount] + dwStrLen) = '\0';

            dwStrLen += sizeof(TCHAR);

            // add one string into candidate list
            lpCandList->dwCount++;

            if (lpCandList->dwCount >= MAXCAND) {
                // Grow memory here and do something,
                // if you still want to process it.
                break;
            }

            // string length plus size of the null terminator
            lpCandList->dwOffset[lpCandList->dwCount] =
                lpCandList->dwOffset[lpCandList->dwCount - 1] +
                dwStrLen + sizeof(TCHAR);
        }

iHi = (*(LPDWORD)(lpTbl) & lpImeL->dwPatternMask);
lpPattern = lpTbl + (lpImeL->nSeqBytes * 2) * iHi;
iHi = (*(LPDWORD)(lpTbl+4) & lpImeL->dwPatternMask);
lpPattern_end = lpTbl + (lpImeL->nSeqBytes * 2) * iHi;

    for (; (LPBYTE)lpPattern < lpPattern_end; (LPBYTE)lpPattern +=
        lpImeL->nSeqBytes * 2 ) {
            WORD   wCode;
            DWORD  dwStrLen;
        if (dwPattern == (*(LPUNADWORD)lpPattern & lpImeL->dwPatternMask)) {
            lpStart = (LPWORD)lpPhrase + (*(LPUNADWORD)(lpPattern + lpImeL->nSeqBytes) & lpImeL->dwPatternMask);
            lpEnd = (LPWORD)lpPhrase + (*(LPUNADWORD)(lpPattern + (lpImeL->nSeqBytes *3)) & lpImeL->dwPatternMask);
            for (dwStrLen = 0; lpStart < lpEnd; lpStart++,
                    dwStrLen += sizeof(WORD)) {
                    wCode = *lpStart;
                    // add this char into candidate list
                    *(LPWSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[
                        lpCandList->dwCount] + dwStrLen) = wCode;
            }
            // null terminator
            *(LPTSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[
                 lpCandList->dwCount] + dwStrLen) = '\0';
            dwStrLen += sizeof(TCHAR);
            // add one string into candidate list
            lpCandList->dwCount++;
            if (lpCandList->dwCount >= MAXCAND) {
                // Grow memory here and do something,
                // if you still want to process it.
                break;
            }
            // string length plus size of the null terminator
            lpCandList->dwOffset[lpCandList->dwCount] =
                lpCandList->dwOffset[lpCandList->dwCount - 1] +
                dwStrLen + sizeof(TCHAR);
        }
     }
        UnmapViewOfFile(lpPhrase);

SrchPhrClosePhr:

        CloseHandle(hPhrase);
    }

SrchPhrUnmapPattern:
    UnmapViewOfFile(lpTbl);

    CloseHandle(hTbl);

    return;
}
#endif

#if defined(CHAJEI) || defined(QUICK) || defined(WINAR30)
/**********************************************************************/
/* MatchPattern()                                                     */
/**********************************************************************/
DWORD PASCAL MatchPattern(
    DWORD         dwSearchPattern,
    LPPRIVCONTEXT lpImcP)
{
    int i;

    if (lpImcP->iGhostCard == lpImeL->nMaxKey) {
#if defined(WINAR30)
    } else if (lpImcP->iGhostCard == 0) {
        // no order search
        BYTE bSeq[8];
        int  j;

        *(LPDWORD)bSeq = *(LPDWORD)lpImcP->bSeq;
        *(LPDWORD)&bSeq[4] = *(LPDWORD)&lpImcP->bSeq[4];
        // 0 out the ghost card *XYZ -> 0XYZ
        bSeq[0] = 0;

        for (j = 0; j < lpImeL->nMaxKey; j++,
            dwSearchPattern >>= lpImeL->nSeqBits) {
            DWORD dwSeqCode;

            dwSeqCode = dwSearchPattern & lpImeL->dwSeqMask;

            if (!dwSeqCode) {
                continue;
            }

            for (i = 1; i < lpImcP->iInputEnd; i++) {
                if (dwSeqCode == bSeq[i]) {
                    // find one - turn off this one not search again
                    bSeq[i] = 0;
                    break;
                }
            }
        }

        if (*(LPDWORD)bSeq) {
            // not matched, next one
            dwSearchPattern = 0;
        } else if (*(LPDWORD)&bSeq[4]) {
            // not matched, next one
            dwSearchPattern = 0;
        } else {
            dwSearchPattern = lpImcP->dwPattern;
        }
#endif
    } else {
        DWORD dwPatternTmp;
        DWORD dwPrefixMask, dwPostfixMask;
        int   iGhostCard;

#if defined(QUICK)
        if (lpImcP->iInputEnd == 1) {
            // for quick the single input X can not get any mask
            return (dwSearchPattern);
        }
#endif

        dwPatternTmp = dwSearchPattern;

        // prepare prefix mask - for example XX mask of XX*Y
        dwPrefixMask = lpImeL->dwPatternMask;

        for (i = lpImeL->nMaxKey - 1; i >= lpImcP->iGhostCard; i--) {
            dwPrefixMask <<= lpImeL->nSeqBits;
        }

        dwSearchPattern &= dwPrefixMask;

        // prepare postfix mask - for example YY mask of X*YY
#if defined(QUICK)
        // we do not have X*Y for quick IME, we use a virtual * here
        iGhostCard = lpImcP->iGhostCard - 1;
#else
        iGhostCard = lpImcP->iGhostCard;
#endif
        // + 1 because this first mask do not need to shift
        // so the shift time will be one time less
        for (i = iGhostCard + 1 + 1; i < lpImeL->nMaxKey; i++,
            dwPatternTmp >>= lpImeL->nSeqBits) {
            if (dwPatternTmp & lpImeL->dwSeqMask) {
                break;
            }
        }

        dwPostfixMask = 0;

        for (i = iGhostCard + 1; i < lpImcP->iInputEnd; i++) {
            dwPostfixMask <<= lpImeL->nSeqBits;
            dwPostfixMask |= lpImeL->dwSeqMask;
        }

        dwPatternTmp &= dwPostfixMask;

        for (; i < lpImeL->nMaxKey; i++) {
            dwPatternTmp <<= lpImeL->nSeqBits;
        }

        dwSearchPattern |= dwPatternTmp;
    }

    return (dwSearchPattern);
}
#endif

#if defined(WINAR30)
/**********************************************************************/
/* WildCardSearchPattern()                                            */
/**********************************************************************/
void PASCAL WildCardSearchPattern(
    LPBYTE          lpCurr,
    LPBYTE          lpEnd,
    LPPRIVCONTEXT   lpImcP,
    LPCANDIDATELIST lpCandList)
{
    DWORD dwRecLen;

    dwRecLen = lpImeL->nSeqBytes + sizeof(WORD);

    for (; lpCurr < lpEnd; lpCurr += dwRecLen) {
        DWORD dwSearchPattern;
#if defined(WINAR30)
        DWORD dwWildCardPattern;
#endif
        UINT  uCode;

        // skip the first word (bank ID) of internal code
        dwSearchPattern = *(LPUNADWORD)lpCurr & lpImeL->dwPatternMask;

#if defined(WINAR30)
        dwWildCardPattern = dwSearchPattern;
#endif

        if (lpImcP->iGhostCard != lpImeL->nMaxKey) {
            dwSearchPattern = MatchPattern(dwSearchPattern, lpImcP);
        }

#if defined(WINAR30)
        dwSearchPattern &= lpImcP->dwWildCardMask;
#endif

        if (lpImcP->dwPattern != dwSearchPattern) {
            continue;
        }

#if defined(WINAR30)
        if (!lpImcP->dwLastWildCard) {
        } else if (dwWildCardPattern & lpImcP->dwLastWildCard) {
            // a ? wild card or a * ghost card must have a stroke there
        } else {
            // a ? wild card or a * ghost card do not have a stroke there
            // - can not match
            continue;
        }
#endif

        uCode = *(LPWSTR)(lpCurr + lpImeL->nSeqBytes);

        AddCodeIntoCand(lpCandList, uCode);

        if (lpCandList->dwCount >= MAXCAND) {
            // Grow memory here and do something,
            // if you still want to process it.
            break;
        }
    }

    return;
}
#endif

#if !defined(WINIME) && !defined(UNICDIME)
/**********************************************************************/
/* SearchPattern()                                                    */
/**********************************************************************/
#if defined(CHAJEI) || defined(QUICK)
int PASCAL SearchPattern(
    LPBYTE        lpTbl,
    LPPRIVCONTEXT lpImcP)
{
    int   iLo, iMid, iHi;
#if defined(CHAJEI)
    DWORD dwCompReadStrLen;
#endif

    if (lpImcP->bSeq[0] > lpImeL->nSeqCode) {
        return (0);
    }

    iMid = lpImcP->bSeq[0] * (lpImeL->nSeqCode + 1);        // A1 char

#if defined(QUICK)
    if (lpImcP->bSeq[1] > lpImeL->nSeqCode) {
        return (0);
    }

    iMid += lpImcP->bSeq[1];
#endif
#if defined(CHAJEI)
    if (!lpImcP->bSeq[0]) {
        dwCompReadStrLen = 0;
    } else if (!lpImcP->bSeq[1]) {
        dwCompReadStrLen = sizeof(WORD);
    } else if (!lpImcP->bSeq[2]) {
        dwCompReadStrLen = 2 * sizeof(WORD);
    } else if (!lpImcP->bSeq[3]) {
        dwCompReadStrLen = 3 * sizeof(WORD);
    } else if (!lpImcP->bSeq[4]) {
        dwCompReadStrLen = 4 * sizeof(WORD);
    } else {
        dwCompReadStrLen = 5 * sizeof(WORD);
    } 

    if (dwCompReadStrLen > sizeof(WORD)) {
        if (lpImcP->bSeq[dwCompReadStrLen / 2 - 1] > lpImeL->nSeqCode) {
            return (0);
        }

        iMid += lpImcP->bSeq[dwCompReadStrLen / 2 - 1];
    }
#endif

    iLo = *((LPWORD)lpTbl + iMid);      // start WORD of A234.TBL & ACODE.TBL
    iHi = *((LPWORD)lpTbl + iMid + 1);  // end WORD of A234.TBL & ACODE.TBL

    if (iLo < iHi) {
        return (iMid);
    } else {
        return (0);
    }
}
#else
int PASCAL SearchPattern(
#if defined(UNIIME)
    LPIMEL        lpImeL,
#endif
    LPBYTE        lpTbl,
    UINT          uTblIndex,
    LPPRIVCONTEXT lpImcP)
{
    int   iLo, iMid, iHi;
    BOOL  fFound;
    DWORD dwRecLen;

    fFound = FALSE;

#if defined(PHON)
    dwRecLen = lpImeL->nSeqBytes;
#else
    dwRecLen = lpImeL->nSeqBytes + sizeof(WORD);
#endif

    iLo = 0;
    iHi = lpImeL->uTblSize[uTblIndex] / dwRecLen;
    iMid = (iLo + iHi) / 2;

#if defined(WINAR30)  //1996/3/3
    for (; iHi >= iLo; ) {
        LPUNADWORD lpCurr;
        lpCurr = (LPDWORD)(lpTbl + dwRecLen * iHi);
        if (lpImcP->dwPattern == (*lpCurr & lpImeL->dwPatternMask)) {
            fFound = TRUE;
            iMid = iHi;
            break;
        }
        iHi = iHi - 1;
#else
    for (; iLo <= iHi; ) {
        LPUNADWORD lpCurr;

        lpCurr = (LPDWORD)(lpTbl + dwRecLen * iMid);

        if (lpImcP->dwPattern > (*lpCurr & lpImeL->dwPatternMask)) {
            iLo = iMid + 1;
        } else if (lpImcP->dwPattern < (*lpCurr & lpImeL->dwPatternMask)) {
            iHi = iMid - 1;
        } else {
            fFound = TRUE;
            break;
        }

        iMid = (iLo + iHi) / 2;
#endif
    }

    if (fFound) {
        return (iMid);
    } else {
        return (0);
    }
}
#endif

/**********************************************************************/
/* FindPattern()                                                      */
/**********************************************************************/
void PASCAL FindPattern(
#if defined(UNIIME)
    LPIMEL          lpImeL,
#endif
    LPBYTE          lpTbl,
    int             iMid,
    LPCANDIDATELIST lpCandList,
    LPPRIVCONTEXT   lpImcP)
{
#ifndef WINAR30
     int    iLo, iHi;
#endif
    DWORD  dwRecLen;
#if defined(CHAJEI)
    HANDLE hTblA234;
    LPBYTE lpTblA234, lpA234;
    DWORD  dwPatternA234;
#endif
#if defined(PHON) || defined(CHAJEI) || defined(QUICK)
    HANDLE hTblCode;
    LPBYTE lpTblCode;
#endif
    LPBYTE lpStart, lpEnd;

#if defined(PHON)
    dwRecLen = lpImeL->nSeqBytes;
#elif !defined(CHAJEI) && !defined(QUICK)
    dwRecLen = lpImeL->nSeqBytes + sizeof(WORD);
#else
#endif

    // find the lower bound
#if defined(PHON)
    {
        HANDLE hTable;
        LPWORD lpTable;

        hTable = OpenFileMapping(FILE_MAP_READ, FALSE, lpImeL->szTblFile[1]);
        if (!hTable) {
            return;
        }

        lpTable = MapViewOfFile(hTable, FILE_MAP_READ, 0, 0, 0);
        if (!lpTable) {
            goto FndPatCloseTbl1;
        }

        iLo = *(lpTable + iMid);
        iHi = *(lpTable + iMid + 1);

        UnmapViewOfFile(lpTable);

FndPatCloseTbl1:
        CloseHandle(hTable);

        if (!lpTable) {
            return;
        }
    }
#elif defined(CHAJEI) || defined(QUICK)
    iLo = *((LPWORD)lpTbl + iMid);

    iHi = *((LPWORD)lpTbl + iMid + 1);

    if (iLo >= iHi) {
        return;
    }
#else
  #if defined(WINAR30)   //1996/3/4
    lpStart = lpTbl;
    lpEnd = lpTbl + dwRecLen * (iMid+1);
  #else
    // find the lower bound
    iLo = iMid - 1;

    lpStart = lpTbl + dwRecLen * iLo;

    for (; lpStart >= lpTbl; lpStart -= dwRecLen) {
        register DWORD dwSearchPattern;

        dwSearchPattern = *(LPUNADWORD)lpStart & lpImeL->dwPatternMask;

        if (lpImcP->dwPattern > dwSearchPattern) {
            // previous one is the lower bound
            lpStart += dwRecLen;
            break;
        }
    }

    if (lpStart <= lpTbl) {
        return;
    }

    // offset of code
    lpStart += lpImeL->nSeqBytes;

    // find the higher bound
    iHi = iMid + 1;

    lpEnd = lpTbl + dwRecLen * iHi;

    for (; ; lpEnd += dwRecLen) {
        register DWORD dwSearchPattern;

        dwSearchPattern = *(LPUNADWORD)lpEnd & lpImeL->dwPatternMask;

        if (lpImcP->dwPattern < dwSearchPattern) {
            // the one is the higher bound, not including
            break;
        }
    }

    // offset of code
    lpEnd += lpImeL->nSeqBytes;
  #endif
#endif

#if defined(CHAJEI)
    // A234.TBL
    hTblA234 = OpenFileMapping(FILE_MAP_READ, FALSE, lpImeL->szTblFile[1]);
    if (!hTblA234) {
        return;
    }

    lpTblA234 = MapViewOfFile(hTblA234, FILE_MAP_READ, 0, 0, 0);
    if (!lpTblA234) {
        goto FndPatCloseTblA234;
    }

    lpA234 = lpTblA234 + sizeof(WORD) * iLo;

    dwPatternA234 = 0;

    if (lpImcP->bSeq[2]) {
        dwPatternA234 |= lpImcP->bSeq[1] << (lpImeL->nSeqBits * 2);
    }

    if (lpImcP->bSeq[3]) {
        dwPatternA234 |= lpImcP->bSeq[2] << lpImeL->nSeqBits;
    }

    if (lpImcP->bSeq[4]) {
        dwPatternA234 |= lpImcP->bSeq[3];
    }
#endif

#if defined(PHON) || defined(CHAJEI) || defined(QUICK)
    // PHONCODE.TBL ACODE.TBL
    hTblCode = OpenFileMapping(FILE_MAP_READ, FALSE, lpImeL->szTblFile[2]);
    if (!hTblCode) {
        return;
    }

    lpTblCode = MapViewOfFile(hTblCode, FILE_MAP_READ, 0, 0, 0);
    if (!lpTblCode) {
        goto FndPatCloseTblCode;
    }

    lpStart = lpTblCode + sizeof(WORD) * iLo;

    lpEnd = lpTblCode + sizeof(WORD) * iHi;

    dwRecLen = sizeof(WORD);
#endif

#if defined(CHAJEI)
    for (; lpStart < lpEnd; lpStart += dwRecLen, lpA234 += sizeof(WORD)) {
#else
    for (; lpStart < lpEnd; lpStart += dwRecLen) {
#endif
        UINT uCode;

#if defined(CHAJEI)
        if (lpImcP->bSeq[1] == GHOSTCARD_SEQCODE) {
            if (!lpImcP->bSeq[2]) {
                // if the 3rd sequence code is 0, it is not a ghost card
                continue;
            }
        } else if (dwPatternA234 != *(LPWORD)lpA234) {
            continue;
        } else {
        }
#endif

  #if defined(WINAR30)   //1996/3/4
        register DWORD dwSearchPattern;
        dwSearchPattern = *(LPUNADWORD)lpStart & lpImeL->dwPatternMask;
        if (lpImcP->dwPattern == dwSearchPattern) {
           uCode = *(LPUNAWORD)(lpStart+lpImeL->nSeqBytes);
           AddCodeIntoCand(lpCandList, uCode);
        }
  #else
        uCode = *(LPUNAWORD)lpStart;

#if defined(PHON) || defined(DAYI)
#ifdef UNICODE
        if (!IsValidCode(uCode)) {
            uCode = InverseEncode(uCode);
        }
#else
        // resolve duplicate composition for one code
        if (!(uCode & 0x8000)) {
            uCode |= 0x8000;
        }
#endif
#endif
#if defined(UNIIME)
        AddCodeIntoCand(lpImeL,lpCandList, uCode);
#else
        AddCodeIntoCand(lpCandList, uCode);
#endif

  #endif
        if (lpCandList->dwCount >= MAXCAND) {
            // Grow memory here and do something,
            // if you still want to process it.
            break;
        }
    }

#if defined(PHON) || defined(CHAJEI) || defined(QUICK)
    UnmapViewOfFile(lpTblCode);

FndPatCloseTblCode:
    CloseHandle(hTblCode);
#endif

#if defined(CHAJEI)
    UnmapViewOfFile(lpTblA234);

FndPatCloseTblA234:
    CloseHandle(hTblA234);
#endif

    return;
}
#endif // !defined(WINIME) && !defined(UNICDIME)

/**********************************************************************/
/* SearchTbl()                                                        */
/* Description:                                                       */
/*      file format can be changed in different version for           */
/*      performance consideration, ISVs should not assume its format  */
/**********************************************************************/
void PASCAL SearchTbl(          // searching the standard table files
#if defined(UNIIME)
    LPIMEL          lpImeL,
#endif
    UINT            uTblIndex,
    LPCANDIDATELIST lpCandList,
    LPPRIVCONTEXT   lpImcP)
{
#if defined(WINIME) || defined(UNICDIME)
    if (!lpImcP->bSeq[0]) {
    } else if (!lpImcP->bSeq[1]) {
    } else if (!lpImcP->bSeq[3]) {
        DWORD i;
        UINT  uCode;

        uCode = (lpImcP->bSeq[0] - 1) << 12;
        uCode |= (lpImcP->bSeq[1] - 1) << 8;
        if (lpImcP->bSeq[2]) {
            // we want it match with internal code here so | 0x0001
            uCode |= (lpImcP->bSeq[2] - 1) << 4 | 0x0001;
        } else {
            uCode |= 0x0040;
        }

        for (i = 0; i < lpCandList->dwPageSize; i++, uCode++) {
#if defined(WINIME) && defined(UNICODE)
            CHAR  szCode[2];
            WCHAR wCode[2];

            szCode[0] = HIBYTE(uCode);
            szCode[1] = LOBYTE(uCode);

            wCode[0] = 0;

            MultiByteToWideChar(sImeG.uAnsiCodePage, MB_PRECOMPOSED,
                szCode, 2, wCode, sizeof(wCode) / sizeof(WCHAR));

            uCode = wCode[0];
#endif
#if defined(UNIIME)
            AddCodeIntoCand(lpImeL,lpCandList, uCode);
#else
            AddCodeIntoCand(lpCandList, uCode);
#endif
        }
    } else if (!lpImcP->bSeq[2]) {
        return;
    } else {
        UINT  uCode;
#if defined(WINIME) && defined(UNICODE)
        CHAR  szCode[2];
        WCHAR wCode[2];
#endif

        uCode = (lpImcP->bSeq[0] - 1) << 12;
        uCode |= (lpImcP->bSeq[1] - 1) << 8;
        uCode |= (lpImcP->bSeq[2] - 1) << 4;
        uCode |= (lpImcP->bSeq[3] - 1);

#if defined(WINIME) && defined(UNICODE)
        szCode[0] = HIBYTE(uCode);
        szCode[1] = LOBYTE(uCode);

        wCode[0] = 0;

        MultiByteToWideChar(sImeG.uAnsiCodePage, MB_PRECOMPOSED,
            szCode, 2, wCode, sizeof(wCode) / sizeof(WCHAR));

        uCode = wCode[0];
#endif
#if defined(UNIIME)
        AddCodeIntoCand(lpImeL,lpCandList, uCode);
#else
        AddCodeIntoCand(lpCandList, uCode);
#endif
    }

    return;
#else
    HANDLE      hTbl;
    LPBYTE      lpTbl;

    if (!lpImcP->dwPattern) {
        return;
    }
#if defined(WINAR30)  // 1996/2/5
    if (lpImcP->dwCompChar==0x27) 
          goto SearchTblOvr;
#endif

    hTbl = OpenFileMapping(FILE_MAP_READ, FALSE,
        lpImeL->szTblFile[uTblIndex]);
    if (!hTbl) {
        return;
    }

    lpTbl = (LPBYTE)MapViewOfFile(hTbl, FILE_MAP_READ, 0, 0, 0);
    if (!lpTbl) {
        goto SearchTblOvr;
    }

#if defined(WINAR30)
    if (lpImcP->iGhostCard != lpImeL->nMaxKey) {
        WildCardSearchPattern(lpTbl, lpTbl + lpImeL->uTblSize[uTblIndex],
            lpImcP, lpCandList);
    } else if (lpImcP->dwLastWildCard) {
        WildCardSearchPattern(lpTbl, lpTbl + lpImeL->uTblSize[uTblIndex],
            lpImcP, lpCandList);
    } else {
#else
    {
#endif // defined(WINAR30)
        int iMid;

#if defined(CHAJEI) || defined(QUICK)
        iMid = SearchPattern(lpTbl, lpImcP);
#else
        iMid = SearchPattern(
#if defined(UNIIME)
            lpImeL,
#endif
            lpTbl, uTblIndex, lpImcP);
#endif

        if (iMid > 0) {
            FindPattern(
#if defined(UNIIME)
                lpImeL,
#endif
                lpTbl, iMid, lpCandList, lpImcP);
        }
    }

    UnmapViewOfFile(lpTbl);

SearchTblOvr:
    CloseHandle(hTbl);

#if defined(DAYI)
    if (uTblIndex == 0) {       // do not duplciate search the phrase table
        SearchPhraseTbl(1, lpCandList, lpImcP->dwPattern);
    }
#endif
#if defined(WINAR30)           // 1996/2/5
    if (uTblIndex == 0 && lpImcP->dwCompChar==0x27) {       // do not duplciate search the phrase table
        SearchPhraseTbl(4, lpCandList, lpImcP->dwPattern);
    }
#endif

#if defined(UNIIME)             // same as Dayi need to search phrase table
    SearchPhraseTbl(lpImeL, 1, lpCandList, lpImcP->dwPattern);
#endif

    return;
#endif // !defined(WINIME) && !defined(UNICDIME)
}

#if !defined(WINIME) && !defined(UNICDIME) && !defined(ROMANIME)
/**********************************************************************/
/* SearchUsrDic()                                                     */
/**********************************************************************/
void PASCAL SearchUsrDic(       // searching the user dictionary
#if defined(UNIIME)
    LPIMEL          lpImeL,
#endif
    LPCANDIDATELIST lpCandList,
    LPPRIVCONTEXT   lpImcP)
{
    HANDLE hUsrDicMem;
    LPBYTE lpUsrDicStart, lpCurr, lpUsrDicLimit;

    hUsrDicMem = OpenFileMapping(FILE_MAP_READ, FALSE,
        lpImeL->szUsrDicMap);
    if (!hUsrDicMem) {
        return;
    }

    lpUsrDicStart = (LPBYTE)MapViewOfFile(hUsrDicMem, FILE_MAP_READ,
        0, 0, lpImeL->uUsrDicSize);
    if (!lpUsrDicStart) {
        goto SearchUsrDicOvr;
    }

    lpUsrDicLimit = lpUsrDicStart + lpImeL->uUsrDicSize;

    for (lpCurr = lpUsrDicStart; lpCurr < lpUsrDicLimit;
        lpCurr += lpImeL->nSeqBytes + sizeof(WORD)) {
        DWORD dwSearchPattern;
        UINT  uCode;

        // skip the first word (bank ID) of internal code
        dwSearchPattern = *(LPUNADWORD)(lpCurr + sizeof(WORD)) &
            lpImeL->dwPatternMask;

#if defined(CHAJEI) || defined(QUICK) || defined(WINAR30)
        if (lpImcP->iGhostCard != lpImeL->nMaxKey) {
            dwSearchPattern = MatchPattern(dwSearchPattern, lpImcP);
        }
#endif

#if defined(WINAR30)
        dwSearchPattern &= lpImcP->dwWildCardMask;
#endif

        if (lpImcP->dwPattern != dwSearchPattern) {
            continue;
        }

#if defined(WINAR30)
        if (!lpImcP->dwLastWildCard) {
        } else if (dwSearchPattern & lpImcP->dwLastWildCard) {
            // a ? wild card must have a stroke there
        } else {
            // a ? wild card do not have a stroke there - can not match
            continue;
        }
#endif

        uCode = *(LPUNAWSTR)lpCurr;

#if defined(UNIIME)
        AddCodeIntoCand(lpImeL,lpCandList, uCode);
#else
        AddCodeIntoCand(lpCandList, uCode);
#endif

        if (lpCandList->dwCount >= MAXCAND) {
            // Grow memory here and do something,
            // if you still want to process it.
            break;
        }
    }

    UnmapViewOfFile(lpUsrDicStart);

SearchUsrDicOvr:
    CloseHandle(hUsrDicMem);

    return;
}
#endif // !defined(WINIME) && !defined(UNICDIME) && !defined(ROMANIME)

#endif // !defined(ROMANIME)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\statusui.c ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    STATUSUI.c
    
++*/
#include <windows.h>
#include <immdev.h>
#include "imeattr.h"
#include "imedefs.h"
#include "imerc.h"
#if defined(UNIIME)
#include "uniime.h"
#endif

/**********************************************************************/
/* GetStatusWnd                                                       */
/* Return Value :                                                     */
/*      window handle of status window                                */
/**********************************************************************/
HWND PASCAL GetStatusWnd(
    HWND hUIWnd)                // UI window
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;
    HWND     hStatusWnd;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {          // can not darw status window
        return (HWND)NULL;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw status window
        return (HWND)NULL;
    }

    hStatusWnd = lpUIPrivate->hStatusWnd;

    GlobalUnlock(hUIPrivate);
    return (hStatusWnd);
}

/**********************************************************************/
/* AdjustStatusBoundary()                                             */
/**********************************************************************/
void PASCAL AdjustStatusBoundary(
#if defined(UNIIME)
    LPIMEL  lpImeL,
#endif
    LPPOINT lppt)
{
    RECT rcWorkArea;

#if 1 // MultiMonitor support
    {
        RECT rcStatusWnd;

        *(LPPOINT)&rcStatusWnd = *lppt;

        rcStatusWnd.right = rcStatusWnd.left + lpImeL->xStatusWi;
        rcStatusWnd.bottom = rcStatusWnd.top + lpImeL->yStatusHi;

        rcWorkArea = ImeMonitorWorkAreaFromRect(&rcStatusWnd);
    }
#else
    rcWorkArea = sImeG.rcWorkArea;
#endif

    // display boundary check
    if (lppt->x < rcWorkArea.left) {
        lppt->x = rcWorkArea.left;
    } else if (lppt->x + lpImeL->xStatusWi > rcWorkArea.right) {
        lppt->x = (rcWorkArea.right - lpImeL->xStatusWi);
    }

    if (lppt->y < rcWorkArea.top) {
        lppt->y = rcWorkArea.top;
    } else if (lppt->y + lpImeL->yStatusHi > rcWorkArea.bottom) {
        lppt->y = (rcWorkArea.bottom - lpImeL->yStatusHi);
    }

    return;
}

/**********************************************************************/
/* SetStatusWindowPos()                                               */
/**********************************************************************/
LRESULT PASCAL SetStatusWindowPos(
#if defined(UNIIME)
    LPIMEL lpImeL,
#endif
    HWND   hStatusWnd)
{
    HWND           hUIWnd;
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    RECT           rcStatusWnd;
    POINT          ptPos;

    hUIWnd = GetWindow(hStatusWnd, GW_OWNER);

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return (1L);
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {           // Oh! Oh!
        return (1L);
    }

    GetWindowRect(hStatusWnd, &rcStatusWnd);

    if (lpIMC->ptStatusWndPos.x != rcStatusWnd.left) {
    } else if (lpIMC->ptStatusWndPos.y != rcStatusWnd.top) {
    } else {
        ImmUnlockIMC(hIMC);
        return (0L);
    }

    ptPos = lpIMC->ptStatusWndPos;

    // display boundary adjust
    AdjustStatusBoundary(
#if defined(UNIIME)
        lpImeL,
#endif
        &ptPos);

    SetWindowPos(hStatusWnd, NULL,
        ptPos.x, ptPos.y,
        0, 0, SWP_NOACTIVATE|SWP_NOCOPYBITS|SWP_NOSIZE|SWP_NOZORDER);

    ImmUnlockIMC(hIMC);

    return (0L);
}

/**********************************************************************/
/* ShowStatus()                                                       */
/**********************************************************************/
void PASCAL ShowStatus(         // Show the status window - shape / soft KBD
                                // alphanumeric ...
#if defined(UNIIME)
    LPIMEL lpImeL,
#endif
    HWND   hUIWnd,
    int    nShowStatusCmd)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {          // can not darw status window
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw status window
        return;
    }

    if (!lpUIPrivate->hStatusWnd) {
        // not in show status window mode
    } else if (lpUIPrivate->nShowStatusCmd == nShowStatusCmd) {
    } else if (lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI) {
        int nCurrShowState;

        lpUIPrivate->nShowStatusCmd = nShowStatusCmd;

#if defined(ROMANIME)
        nCurrShowState = SW_HIDE;
#else
        nCurrShowState = lpUIPrivate->nShowCompCmd;
        nCurrShowState |= lpUIPrivate->nShowCandCmd;
#endif

        if (nCurrShowState == SW_HIDE) {
            // if other two are hide, the current show state is determined
            // by this status section
            ShowWindow(lpUIPrivate->hStatusWnd, nShowStatusCmd);
        }
    } else {
        ShowWindow(lpUIPrivate->hStatusWnd, nShowStatusCmd);
        lpUIPrivate->nShowStatusCmd = nShowStatusCmd;
    }

    GlobalUnlock(hUIPrivate);
    return;
}

/**********************************************************************/
/* OpenStatus()                                                       */
/**********************************************************************/
void PASCAL OpenStatus(         // open status window
#if defined(UNIIME)
    LPINSTDATAL lpInstL,
    LPIMEL      lpImeL,
#endif
    HWND        hUIWnd)
{
    HGLOBAL        hUIPrivate;
    LPUIPRIV       lpUIPrivate;
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    POINT          ptPos;
    int            nShowStatusCmd;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {          // can not darw status window
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw status window
        return;
    }

    // in the timing of the transition, we will wait
    if (lpUIPrivate->fdwSetContext & ISC_OFF_CARET_UI) {
        if (!(lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI)) {
            PostMessage(hUIWnd, WM_USER_UICHANGE, 0, 0);
            goto OpenStatusUnlockUIPriv;
        }
    } else {
        if (lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI) {
            PostMessage(hUIWnd, WM_USER_UICHANGE, 0, 0);
            goto OpenStatusUnlockUIPriv;
        }
    }

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        ptPos.x = sImeG.rcWorkArea.left;
        ptPos.y = sImeG.rcWorkArea.bottom - lpImeL->yStatusHi;
        nShowStatusCmd = SW_HIDE;
    } else if (lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC)) {
        AdjustStatusBoundary(
#if defined(UNIIME)
            lpImeL,
#endif
            &lpIMC->ptStatusWndPos);

        ptPos = lpIMC->ptStatusWndPos;
        ImmUnlockIMC(hIMC);
        nShowStatusCmd = SW_SHOWNOACTIVATE;
    } else {
        ptPos.x = sImeG.rcWorkArea.left;
        ptPos.y = sImeG.rcWorkArea.bottom - lpImeL->yStatusHi;
        nShowStatusCmd = SW_HIDE;
    }

#if !defined(ROMANIME)
    if (lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI) {
        if (lpUIPrivate->hStatusWnd) {
        } else if (lpUIPrivate->hCompWnd) {
            lpUIPrivate->hStatusWnd = lpUIPrivate->hCompWnd;
            lpUIPrivate->nShowStatusCmd = lpUIPrivate->nShowCompCmd;
        } else if (lpUIPrivate->hCandWnd) {
            lpUIPrivate->hStatusWnd = lpUIPrivate->hCandWnd;
            lpUIPrivate->nShowStatusCmd = lpUIPrivate->nShowCandCmd;
        } else {
        }
    }
#endif

    if (lpUIPrivate->hStatusWnd) {
        if (lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI) {
            RECT rcRect;

            rcRect = lpImeL->rcStatusText;
            // off by 1
            rcRect.right += 1;
            rcRect.bottom += 1;

            RedrawWindow(lpUIPrivate->hStatusWnd, &rcRect, NULL,
                RDW_INVALIDATE);
        } else {
            SetWindowPos(lpUIPrivate->hStatusWnd, NULL,
                ptPos.x, ptPos.y,
                0, 0,
                SWP_NOACTIVATE|SWP_NOSIZE|SWP_NOZORDER);
        }
    } else {                            // create status window
        if (lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI) {
            lpUIPrivate->hStatusWnd = CreateWindowEx(
                WS_EX_WINDOWEDGE|WS_EX_DLGMODALFRAME,
                lpImeL->szOffCaretClassName, NULL,
                WS_POPUP|WS_DISABLED,
                ptPos.x, ptPos.y,
                lpImeL->xStatusWi, lpImeL->yStatusHi,
                hUIWnd, (HMENU)NULL, lpInstL->hInst, NULL);

#if !defined(ROMANIME) && !defined(WINAR30)
            if (lpUIPrivate->hSoftKbdWnd) {
                // insert soft keyboard in front of other UI
                SetWindowPos(lpUIPrivate->hStatusWnd,
                    lpUIPrivate->hSoftKbdWnd,
                    0, 0, 0, 0,
                    SWP_NOACTIVATE|SWP_NOMOVE|SWP_NOSIZE);
            }
#endif
        } else {
            lpUIPrivate->hStatusWnd = CreateWindowEx(
                WS_EX_WINDOWEDGE|WS_EX_DLGMODALFRAME,
                lpImeL->szStatusClassName, NULL,
                WS_POPUP|WS_DISABLED,
                ptPos.x, ptPos.y,
                lpImeL->xStatusWi, lpImeL->yStatusHi,
                hUIWnd, (HMENU)NULL, lpInstL->hInst, NULL);
        }

        if (!lpUIPrivate->hStatusWnd) {
            goto OpenStatusUnlockUIPriv;
        }

        SetWindowLong(lpUIPrivate->hStatusWnd, UI_MOVE_OFFSET,
            WINDOW_NOT_DRAG);
        SetWindowLong(lpUIPrivate->hStatusWnd, UI_MOVE_XY, 0L);
    }

    lpUIPrivate->fdwSetContext |= ISC_OPEN_STATUS_WINDOW;

    if (hIMC) {
        ShowStatus(
#if defined(UNIIME)
            lpImeL,
#endif
            hUIWnd, SW_SHOWNOACTIVATE);
    }

OpenStatusUnlockUIPriv:
    GlobalUnlock(hUIPrivate);
    return;
}

/**********************************************************************/
/* DestroyStatusWindow()                                              */
/**********************************************************************/
void PASCAL DestroyStatusWindow(
    HWND hStatusWnd)
{
    HWND     hUIWnd;
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    if (GetWindowLong(hStatusWnd, UI_MOVE_OFFSET) != WINDOW_NOT_DRAG) {
        // undo the drag border
        DrawDragBorder(hStatusWnd,
            GetWindowLong(hStatusWnd, UI_MOVE_XY),
            GetWindowLong(hStatusWnd, UI_MOVE_OFFSET));
    }

    hUIWnd = GetWindow(hStatusWnd, GW_OWNER);

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {          // can not darw status window
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw status window
        return;
    }

    lpUIPrivate->nShowStatusCmd = SW_HIDE;

    lpUIPrivate->hStatusWnd = (HWND)NULL;

    GlobalUnlock(hUIPrivate);
    return;
}

/**********************************************************************/
/* SetStatus                                                          */
/**********************************************************************/
void PASCAL SetStatus(
#if defined(UNIIME)
    LPIMEL  lpImeL,
#endif
    HWND    hStatusWnd,
    LPPOINT lpptCursor)
{
    HWND           hUIWnd;
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;

    hUIWnd = GetWindow(hStatusWnd, GW_OWNER);
    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return;
    }

    if (!lpIMC->fOpen) {
        ImmSetOpenStatus(hIMC, TRUE);
    } else if (PtInRect(&lpImeL->rcInputText, *lpptCursor)) {
#if defined(ROMANIME)
        MessageBeep((UINT)-1);
#else
        DWORD fdwConversion;

        if (lpIMC->fdwConversion & IME_CMODE_NATIVE) {
            if (lpIMC->fdwConversion & (IME_CMODE_CHARCODE|
                IME_CMODE_NOCONVERSION|IME_CMODE_EUDC|IME_CMODE_SYMBOL)) {
                // change to native mode
                fdwConversion = (lpIMC->fdwConversion | IME_CMODE_NATIVE) &
                    ~(IME_CMODE_CHARCODE|IME_CMODE_NOCONVERSION|
                    IME_CMODE_EUDC|IME_CMODE_SYMBOL);
            } else {
                // change to alphanumeric mode
                fdwConversion = lpIMC->fdwConversion & ~(IME_CMODE_NATIVE|
                    IME_CMODE_CHARCODE|IME_CMODE_NOCONVERSION|
                    IME_CMODE_EUDC|IME_CMODE_SYMBOL);
            }
        } else {
            // change to native mode
            fdwConversion = (lpIMC->fdwConversion | IME_CMODE_NATIVE) &
                ~(IME_CMODE_CHARCODE|IME_CMODE_NOCONVERSION|
                IME_CMODE_EUDC|IME_CMODE_SYMBOL);
        }

        ImmSetConversionStatus(hIMC, fdwConversion, lpIMC->fdwSentence);
#endif
    } else if (PtInRect(&lpImeL->rcShapeText, *lpptCursor)) {
        DWORD dwConvMode;

        if (lpIMC->fdwConversion & IME_CMODE_CHARCODE) {
            MessageBeep((UINT)-1);
        } else if (lpIMC->fdwConversion & IME_CMODE_EUDC) {
            MessageBeep((UINT)-1);
        } else {
            dwConvMode = lpIMC->fdwConversion ^ IME_CMODE_FULLSHAPE;
            ImmSetConversionStatus(hIMC, dwConvMode, lpIMC->fdwSentence);
        }
    } else {
        MessageBeep((UINT)-1);
    }

    ImmUnlockIMC(hIMC);

    return;
}

/**********************************************************************/
/* ResourceLocked()                                                   */
/**********************************************************************/
void PASCAL ResourceLocked(
#if defined(UNIIME)
    LPIMEL      lpImeL,
#endif
    HWND        hWnd)
{
    TCHAR szErrMsg[32];

    LoadString(hInst, IDS_SHARE_VIOLATION, szErrMsg, sizeof(szErrMsg)/sizeof(TCHAR));

    MessageBeep((UINT)-1);
    MessageBox(hWnd, szErrMsg, lpImeL->szIMEName,
        MB_OK|MB_ICONHAND|MB_TASKMODAL|MB_TOPMOST);

    return;
}

/**********************************************************************/
/* StatusSetCursor()                                                  */
/**********************************************************************/
void PASCAL StatusSetCursor(
#if defined(UNIIME)
    LPINSTDATAL lpInstL,
    LPIMEL      lpImeL,
#endif
    HWND        hStatusWnd,
    LPARAM      lParam)
{
    POINT ptCursor, ptSavCursor;
    RECT  rcWnd;

    if (GetWindowLong(hStatusWnd, UI_MOVE_OFFSET) != WINDOW_NOT_DRAG) {
        SetCursor(LoadCursor(NULL, IDC_SIZEALL));
        return;
    }
    
    GetCursorPos(&ptCursor);
    ptSavCursor = ptCursor;

    ScreenToClient(hStatusWnd, &ptCursor);

    if (PtInRect(&lpImeL->rcStatusText, ptCursor)) {
        SetCursor(LoadCursor(hInst, MAKEINTRESOURCE(IDCR_HAND_CURSOR)));

        if (HIWORD(lParam) == WM_LBUTTONDOWN) {
            SetStatus(
#if defined(UNIIME)
                lpImeL,
#endif
                hStatusWnd, &ptCursor);
        } else if (HIWORD(lParam) == WM_RBUTTONUP) {
            static BOOL fImeConfigure = FALSE;

            // prevent recursive
            if (fImeConfigure) {
                // configuration already bring up
                return;
            }

            fImeConfigure = TRUE;

            ContextMenu(
#if defined(UNIIME)
                lpInstL, lpImeL,
#endif
                hStatusWnd, ptSavCursor.x, ptSavCursor.y);

            fImeConfigure = FALSE;
        } else {
        }

        return;
    } else {
        SetCursor(LoadCursor(NULL, IDC_SIZEALL));

        if (HIWORD(lParam) == WM_LBUTTONDOWN) {
            // start drag
            SystemParametersInfo(SPI_GETWORKAREA, 0, &sImeG.rcWorkArea, 0);
        } else {
            return;
        }
    }

    SetCapture(hStatusWnd);
    SetWindowLong(hStatusWnd, UI_MOVE_XY,
        MAKELONG(ptSavCursor.x, ptSavCursor.y));
    GetWindowRect(hStatusWnd, &rcWnd);
    SetWindowLong(hStatusWnd, UI_MOVE_OFFSET,
        MAKELONG(ptSavCursor.x - rcWnd.left, ptSavCursor.y - rcWnd.top));

    DrawDragBorder(hStatusWnd, MAKELONG(ptSavCursor.x, ptSavCursor.y),
        GetWindowLong(hStatusWnd, UI_MOVE_OFFSET));

    return;
}

/**********************************************************************/
/* PaintStatusWindow()                                                */
/**********************************************************************/
void PASCAL PaintStatusWindow(
#if defined(UNIIME)
    LPINSTDATAL lpInstL,
    LPIMEL      lpImeL,
#endif
    HWND   hStatusWnd,
    HDC    hDC)
{
    HWND           hUIWnd;
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    HBITMAP        hInputBmp, hShapeBmp;
    HBITMAP        hOldBmp;
    HDC            hMemDC;

    hUIWnd = GetWindow(hStatusWnd, GW_OWNER);

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return;
    }

    if (!(lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC))) {
#ifdef DEBUG
        MessageBeep((UINT)-1);
#endif
        return;
    }

    hInputBmp = (HBITMAP)NULL;
    hShapeBmp = (HBITMAP)NULL;

    if (!lpIMC->fOpen) {
        hInputBmp = LoadBitmap(hInst, MAKEINTRESOURCE(IDBM_CMODE_NONE));
        hShapeBmp = LoadBitmap(hInst, MAKEINTRESOURCE(IDBM_CMODE_NONE));
#if !defined(ROMANIME)
    } else if (!(lpIMC->fdwConversion & IME_CMODE_NATIVE)) {
        hInputBmp = LoadBitmap(hInst, MAKEINTRESOURCE(IDBM_CMODE_ALPHANUMERIC));
#if !defined(WINIME) && !defined(UNICDIME)
    } else if (lpIMC->fdwConversion & IME_CMODE_EUDC) {
        hInputBmp = LoadBitmap(hInst, MAKEINTRESOURCE(IDBM_CMODE_EUDC));
        hShapeBmp = LoadBitmap(hInst, MAKEINTRESOURCE(IDBM_CMODE_NONE));
#endif
    } else if (lpIMC->fdwConversion & IME_CMODE_SYMBOL) {
        hInputBmp = LoadBitmap(hInst, MAKEINTRESOURCE(IDBM_CMODE_SYMBOL));
#endif
    } else {
        hInputBmp = LoadBitmap(lpInstL->hInst,
            MAKEINTRESOURCE(IDBM_CMODE_NATIVE));
    }

    if (!hShapeBmp) {
        if (lpIMC->fdwConversion & IME_CMODE_FULLSHAPE) {
            hShapeBmp = LoadBitmap(hInst,
                MAKEINTRESOURCE(IDBM_CMODE_FULLSHAPE));
        } else {
            hShapeBmp = LoadBitmap(hInst,
                MAKEINTRESOURCE(IDBM_CMODE_HALFSHAPE));
        }
    }

    ImmUnlockIMC(hIMC);

    hMemDC = CreateCompatibleDC(hDC);
    if ( hMemDC == NULL )
    {
       if ( hInputBmp != NULL)
          DeleteObject(hInputBmp);
       if ( hShapeBmp != NULL)
          DeleteObject(hShapeBmp);
       return;
    }

    hOldBmp = SelectObject(hMemDC, hInputBmp);

    BitBlt(hDC, lpImeL->rcInputText.left, lpImeL->rcInputText.top,
        lpImeL->rcInputText.right - lpImeL->rcInputText.left,
        lpImeL->rcInputText.bottom - lpImeL->rcInputText.top,
        hMemDC, 0, 0, SRCCOPY);

    SelectObject(hMemDC, hShapeBmp);

    BitBlt(hDC, lpImeL->rcShapeText.left, lpImeL->rcShapeText.top,
        lpImeL->rcShapeText.right - lpImeL->rcShapeText.left,
        lpImeL->rcShapeText.bottom - lpImeL->rcShapeText.top,
        hMemDC, 0, 0, SRCCOPY);

    SelectObject(hMemDC, hOldBmp);

    DeleteDC(hMemDC);

    DeleteObject(hInputBmp);
    DeleteObject(hShapeBmp);

    return;
}

/**********************************************************************/
/* StatusWndProc()                                                    */
/**********************************************************************/
#if defined(UNIIME)
LRESULT CALLBACK UniStatusWndProc(
    LPINSTDATAL lpInstL,
    LPIMEL      lpImeL,
#else
LRESULT CALLBACK StatusWndProc(
#endif
    HWND   hStatusWnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (uMsg) {
    case WM_DESTROY:
        DestroyStatusWindow(hStatusWnd);
        break;
    case WM_SETCURSOR:
        StatusSetCursor(
#if defined(UNIIME)
            lpInstL, lpImeL,
#endif
            hStatusWnd, lParam);
        break;
    case WM_MOUSEMOVE:
        if (GetWindowLong(hStatusWnd, UI_MOVE_OFFSET) != WINDOW_NOT_DRAG) {
            POINT ptCursor;

            DrawDragBorder(hStatusWnd,
                GetWindowLong(hStatusWnd, UI_MOVE_XY),
                GetWindowLong(hStatusWnd, UI_MOVE_OFFSET));
            GetCursorPos(&ptCursor);
            SetWindowLong(hStatusWnd, UI_MOVE_XY,
                MAKELONG(ptCursor.x, ptCursor.y));
            DrawDragBorder(hStatusWnd, MAKELONG(ptCursor.x, ptCursor.y),
                GetWindowLong(hStatusWnd, UI_MOVE_OFFSET));
        } else {
            return DefWindowProc(hStatusWnd, uMsg, wParam, lParam);
        }
        break;
    case WM_LBUTTONUP:
        if (GetWindowLong(hStatusWnd, UI_MOVE_OFFSET) != WINDOW_NOT_DRAG) {
            LONG   lTmpCursor, lTmpOffset;
            POINT  ptCursor;
            HWND   hUIWnd;

            lTmpCursor = GetWindowLong(hStatusWnd, UI_MOVE_XY);

            // calculate the org by the offset
            lTmpOffset = GetWindowLong(hStatusWnd, UI_MOVE_OFFSET);

            DrawDragBorder(hStatusWnd, lTmpCursor, lTmpOffset);

            ptCursor.x = (*(LPPOINTS)&lTmpCursor).x - (*(LPPOINTS)&lTmpOffset).x;
            ptCursor.y = (*(LPPOINTS)&lTmpCursor).y - (*(LPPOINTS)&lTmpOffset).y;

            SetWindowLong(hStatusWnd, UI_MOVE_OFFSET, WINDOW_NOT_DRAG);
            ReleaseCapture();

            AdjustStatusBoundary(
#if defined(UNIIME)
                lpImeL,
#endif
                &ptCursor);

            hUIWnd = GetWindow(hStatusWnd, GW_OWNER);

            ImmSetStatusWindowPos((HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC),
                &ptCursor);
        } else {
            return DefWindowProc(hStatusWnd, uMsg, wParam, lParam);
        }
        break;
    case WM_IME_NOTIFY:
        if (wParam == IMN_SETSTATUSWINDOWPOS) {
            SetStatusWindowPos(
#if defined(UNIIME)
                lpImeL,
#endif
                hStatusWnd);
        }
        break;
    case WM_PAINT:
        {
            HDC         hDC;
            PAINTSTRUCT ps;

            hDC = BeginPaint(hStatusWnd, &ps);
            PaintStatusWindow(
#if defined(UNIIME)
                lpInstL,
                lpImeL,
#endif
                hStatusWnd, hDC);
            EndPaint(hStatusWnd, &ps);
        }
        break;
    case WM_MOUSEACTIVATE:
        return (MA_NOACTIVATE);
    default:
        return DefWindowProc(hStatusWnd, uMsg, wParam, lParam);
    }

    return (0L);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\regword.c ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    REGWORD.C - register word into dictionary of IME
    
++*/

#include <windows.h>
#include <immdev.h>
#include "imeattr.h"
#include "imedefs.h"
#include "imerc.h"
#if defined(UNIIME)
#include "uniime.h"
#endif

#if !defined(ROMANIME)
/**********************************************************************/
/* ReadingToPattern                                                   */
/* Return Value:                                                      */
/*      the pattern of the reading (packed sequence code)             */
/**********************************************************************/
DWORD PASCAL ReadingToPattern(
#if defined(UNIIME)
    LPIMEL  lpImeL,
#endif
    LPCTSTR lpszReading,
    LPBYTE  lpbSeq,
    BOOL    fFinalized)
{
    BYTE  bSeq[8];
    char  cIndex;
    DWORD dwPattern;
    int   i;
#if defined(PHON)
    char  cOldIndex;
#endif

    cIndex = 0;
#if defined(PHON)
    cOldIndex = -1;
#endif

    *(LPDWORD)bSeq = 0;
#if defined(CHAJEI) || defined(QUICK) || defined(WINAR30) || defined(UNIIME)
    *(LPDWORD)&bSeq[4] = 0;
#endif

    for (; *lpszReading; (LPBYTE)lpszReading += sizeof(WCHAR)) {
        int iSeqCode;

        for (iSeqCode = lpImeL->nSeqCode; iSeqCode >= 0; iSeqCode--) {
            if (lpImeL->wSeq2CompTbl[iSeqCode] == *(LPWORD)lpszReading) {
                break;
            }
        }

        if (iSeqCode < 0) {
            return (0);
        }

#if defined(PHON)   // phontic can have space between reading
        if (iSeqCode == 0) {
            continue;
        }
#else
        if (iSeqCode == 0) {
            break;
        }
#endif

#if defined(PHON)
        cIndex = cSeq2IndexTbl[iSeqCode];
        // the index is conflict with previous reading
        if (cIndex <= cOldIndex) {
            return (0);
        }
#endif

        // too many reading
        if (cIndex >= lpImeL->nMaxKey) {
            return (0);
        }

        bSeq[cIndex] = (BYTE)iSeqCode;

#if defined(PHON)
        if (cIndex == 3 && cOldIndex == -1) {
            return (0);
        }

        cOldIndex = cIndex;
#else
        cIndex++;
#endif
    }

#if defined(PHON)
    // the index of a finalized char must be 3
    if (cIndex != 3 && fFinalized) {
        return (0);
    }
#elif (WINIME)
    // internal code must be 4 digits
    if (!bSeq[3] && fFinalized) {
        return (0);
    }

    if (bSeq[0]) {
        // similar to InternalCodeRange
        // 0x8??? - 0xF??? is OK
        if (bSeq[0] >= 0x09 && bSeq[0] <= 0x10) {
        } else {
            // there is no 0x0??? - 0x7???
            return (0);
        }
    }

    if (bSeq[1]) {
        if (bSeq[0] == (0x08 + 1)) {
            if (bSeq[1] <= (0x00 + 1)) {
                // there is no 0x80??
                return (0);
            } else {
            }
        } else if (bSeq[0] == (0x0F + 1)) {
            if (bSeq[1] >= (0x0F + 1)) {
                // there is no 0xFF??
                return (0);
            } else {
            }
        } else {
        }
    }

    if (bSeq[2]) {
        if (bSeq[2] < (0x04 + 1)) {
            // there is no 0x??0?, 0x??1?, 0x??2?, 0x??3?
            return (0);
        } else if (bSeq[2] < (0x08 + 1)) {
        } else if (bSeq[2] < (0x0A + 1)) {
            // there is no 0x??8?, 0x??9?
            return (0);
        } else {
        }
    }

    if (bSeq[3]) {
        if (bSeq[2] == (0x07 + 1)) {
            if (bSeq[3] >= (0x0F + 1)) {
                // there is no 0x??7F
                return (0);
            } else {
            }
        } else if (bSeq[2] == (0x0A + 1)) {
            if (bSeq[3] <= (0x00 + 1)) {
                // there is no 0x??A0
                return (0);
            } else {
            }
        } else if (bSeq[2] == (0x0F + 1)) {
            if (bSeq[3] <= (0x0F + 1)) {
                // there is no 0x??FF
                return (0);
            } else {
            }
        } else {
        }
    }
#endif

    dwPattern = 0;

    for (i = 0; i < lpImeL->nMaxKey; i++) {
        dwPattern <<= lpImeL->nSeqBits;
        dwPattern |= bSeq[i];
    }

    if (lpbSeq) {
        *(LPDWORD)lpbSeq = *(LPDWORD)bSeq;
#if defined(CHAJEI) || defined(QUICK) || defined(WINAR30) || defined(UNIIME)
        *(LPDWORD)&lpbSeq[4] = *(LPDWORD)&bSeq[4];
#endif
    }

    return (dwPattern);
}
#endif

#if !defined(WINIME) && !defined(UNICDIME) && !defined(ROMANIME)
/**********************************************************************/
/* RegsisterWord                                                      */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL PASCAL RegisterWord(
#if defined(UNIIME)
    LPIMEL  lpImeL,
#endif
    LPCTSTR lpszReading,
    LPCTSTR lpszString,
    LPBYTE  lpUsrDicStart,
    LPBYTE  lpCurr)
{
    DWORD  dwPattern;
    DWORD  dwWriteByte;
    BYTE   bBuf[10];
    HANDLE hUsrDicFile;
    DWORD  dwPos;
    PSECURITY_ATTRIBUTES psa;

    if (lpCurr > lpUsrDicStart + lpImeL->uUsrDicSize) {
        // invalid offset
        return (FALSE);
    }

    dwPattern = ReadingToPattern(
#if defined(UNIIME)
        lpImeL,
#endif
        lpszReading, &bBuf[4], TRUE);

    if (!dwPattern) {
        return (FALSE);
    }

    if (lpCurr == lpUsrDicStart + lpImeL->uUsrDicSize) {
    } else if (dwPattern == (*(LPUNADWORD)(lpCurr + sizeof(WORD)) &
        lpImeL->dwPatternMask)) {
        // the same one as old, don't need update
        return (TRUE);
    }

    *(LPWORD)bBuf = 1;          // bank ID
#ifdef UNICODE
    *(LPWORD)&bBuf[2] = *(LPWORD)lpszString;
#else
    // internal code, reverve the ANSI string
    bBuf[2] = *((LPBYTE)lpszString + 1);
    bBuf[3] = *((LPBYTE)lpszString);
#endif

    psa = CreateSecurityAttributes();

    // write this word into file
    hUsrDicFile = CreateFile(lpImeL->szUsrDic, GENERIC_WRITE,
        FILE_SHARE_READ|FILE_SHARE_WRITE,
        psa, OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);

    if (hUsrDicFile == INVALID_HANDLE_VALUE) {
        FreeSecurityAttributes(psa);
        return (FALSE);
    }

    dwPos = (DWORD) ((lpCurr - lpUsrDicStart) / (lpImeL->nSeqBytes + 2) *
        (lpImeL->nMaxKey + 4) + 256);

    SetFilePointer(hUsrDicFile, dwPos, (LPLONG)NULL, FILE_BEGIN);

    WriteFile(hUsrDicFile, bBuf, lpImeL->nMaxKey + 4, &dwWriteByte,
        NULL);

    *(LPUNAWORD)lpCurr = *(LPWORD)&bBuf[2];

    CopyMemory((LPBYTE)lpCurr + sizeof(WORD), &dwPattern, lpImeL->nSeqBytes);

    if (lpCurr == (lpUsrDicStart + lpImeL->uUsrDicSize)) {
        // add new word
        lpImeL->uUsrDicSize += lpImeL->nSeqBytes + sizeof(WORD);

        *(LPDWORD)bBuf = lpImeL->uUsrDicSize / (lpImeL->nSeqBytes +
            sizeof(WORD));

        // offset of ulTableCount
        SetFilePointer(hUsrDicFile, 0x0C, (LPLONG)NULL, FILE_BEGIN);

        // write to ulTableCount
        WriteFile(hUsrDicFile, bBuf, sizeof(DWORD), &dwWriteByte,
            NULL);
    }

    CloseHandle(hUsrDicFile);
    FreeSecurityAttributes(psa);

    return (TRUE);
}
#endif

/**********************************************************************/
/* ImeRegsisterWord                                                   */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
#if defined(UNIIME)
BOOL WINAPI UniImeRegisterWord(
    LPINSTDATAL lpInstL,
    LPIMEL      lpImeL,
#else
BOOL WINAPI ImeRegisterWord(
#endif
    LPCTSTR     lpszReading,
    DWORD       dwStyle,
    LPCTSTR     lpszString)
{
#if defined(WINIME) || defined(UNICDIME) || defined(ROMANIME)
    return (FALSE);
#else
    BOOL   fRet, fNeedUnload;
    HANDLE hUsrDicMem;
    WORD   wCode;
    LPBYTE lpUsrDicStart, lpCurr, lpUsrDicLimit;

    fRet = FALSE;

    if (!lpszString) {
        return (fRet);
    }

    if (!lpszReading) {
        return (fRet);
    }

    // only handle word not string now, should consider string later?
    if (*(LPCTSTR)((LPBYTE)lpszString + sizeof(WORD)) != '\0') {
        return (fRet);
    }

    if (!lpImeL->szUsrDic[0]) {
        if (!UsrDicFileName(
#if defined(UNIIME)
            lpInstL, lpImeL,
#endif
            NULL)) {
            return (fRet);
        }
    }

    if (!lpInstL->hUsrDicMem) {
        // we load here, and maybe need to unload
        LoadUsrDicFile(lpInstL, lpImeL);

        if (!lpInstL->hUsrDicMem) {
            return (fRet);
        }
    }

    if (lpInstL->fdwTblLoad == TBL_LOADED) {
        fNeedUnload = FALSE;
    } else if (lpInstL->fdwTblLoad == TBL_NOTLOADED) {
        // we only load dic, we will unload it
        fNeedUnload = TRUE;
    } else {
        return (fRet);
    }

    hUsrDicMem = OpenFileMapping(FILE_MAP_WRITE, FALSE,
        lpImeL->szUsrDicMap);
    if (!hUsrDicMem) {
        goto RegWordUnloadUsrDic;
    }

    lpUsrDicStart = MapViewOfFile(hUsrDicMem, FILE_MAP_WRITE,
        0, 0, 0);
    if (!lpUsrDicStart) {
        goto RegWordUnloadUsrDic;
    }

#ifdef UNICODE
    wCode = *lpszString;
#else
    wCode = ((BYTE)lpszString[0] << 8) | (BYTE)lpszString[1];
#endif

    lpUsrDicLimit = lpUsrDicStart + lpImeL->uUsrDicSize;

    for (lpCurr = lpUsrDicStart; lpCurr < lpUsrDicLimit;
        lpCurr += lpImeL->nSeqBytes + sizeof(WORD)) {

        // find the internal code
        if (wCode == *(LPUNAWORD)lpCurr) {
            break;
        }
    }

    fRet = RegisterWord(
#if defined(UNIIME)
        lpImeL,
#endif
        lpszReading, lpszString, lpUsrDicStart, lpCurr);

    UnmapViewOfFile(lpUsrDicStart);

    CloseHandle(hUsrDicMem);

RegWordUnloadUsrDic:
    if (fNeedUnload) {
        if (lpInstL->hUsrDicMem) {
            CloseHandle(lpInstL->hUsrDicMem);
        }
        lpInstL->hUsrDicMem = (HANDLE)NULL;
    }

    return (fRet);
#endif
}

#if !defined(WINIME) && !defined(UNICDIME) && !defined(ROMANIME)
/**********************************************************************/
/* UnregsisterWord                                                    */
/**********************************************************************/
void PASCAL UnregisterWord(
#if defined(UNIIME)
    LPIMEL  lpImeL,
#endif
    LPBYTE  lpUsrDicStart,
    LPBYTE  lpCurr,
    LPBYTE  lpUsrDicLimit)
{
    LPBYTE  lpMem;
    HANDLE  hUsrDicFile;
    DWORD   dwPos;
    DWORD   dwByte;
    PSECURITY_ATTRIBUTES psa;
    BOOL    retVal;

    MoveMemory(lpCurr, lpCurr + lpImeL->nSeqBytes + sizeof(WORD),
        lpUsrDicLimit - lpCurr - lpImeL->nSeqBytes - sizeof(WORD));

    lpMem = (LPBYTE)GlobalAlloc(GPTR, (LONG)(lpUsrDicLimit - lpCurr) );
    if (!lpMem) {
        return;
    }

    psa = CreateSecurityAttributes();

    // delete this word from file
    hUsrDicFile = CreateFile(lpImeL->szUsrDic,
        GENERIC_WRITE|GENERIC_READ,
        FILE_SHARE_READ, psa, OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);

    if (hUsrDicFile == INVALID_HANDLE_VALUE) {
        FreeSecurityAttributes(psa);
        GlobalFree((HGLOBAL)lpMem);
        return;
    }

    dwPos = (DWORD) ((lpCurr - lpUsrDicStart) / (lpImeL->nSeqBytes + 2) *
        (lpImeL->nMaxKey + 4) + 256);

    SetFilePointer(hUsrDicFile, dwPos + lpImeL->nMaxKey + 4,
        (LPLONG)NULL, FILE_BEGIN);

    retVal = ReadFile(hUsrDicFile, lpMem,(DWORD)(lpUsrDicLimit-lpCurr-lpImeL->nMaxKey-4),
        &dwByte, NULL);

    if ( retVal == FALSE )
    {
        CloseHandle(hUsrDicFile);
        FreeSecurityAttributes(psa);
        GlobalFree((HGLOBAL)lpMem);
        return;
    }

    SetFilePointer(hUsrDicFile, dwPos, (LPLONG)NULL, FILE_BEGIN);

    WriteFile(hUsrDicFile,lpMem,(DWORD)(lpUsrDicLimit-lpCurr-lpImeL->nMaxKey-4),
        &dwByte, NULL);

    SetEndOfFile(hUsrDicFile);

    lpImeL->uUsrDicSize -= lpImeL->nSeqBytes + sizeof(WORD);

    *(LPDWORD)lpMem = lpImeL->uUsrDicSize / (lpImeL->nSeqBytes +
        sizeof(WORD));

    // offset of ulTableCount
    SetFilePointer(hUsrDicFile, 0x0C, (LPLONG)NULL, FILE_BEGIN);

    // write to ulTableCount
    WriteFile(hUsrDicFile, lpMem, sizeof(DWORD), &dwByte,
        NULL);

    CloseHandle(hUsrDicFile);
    FreeSecurityAttributes(psa);
    GlobalFree((HGLOBAL)lpMem);

    return;
}
#endif

/**********************************************************************/
/* ImeUnregsisterWord / UniImeUnregisterWord                          */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
#if defined(UNIIME)
BOOL WINAPI UniImeUnregisterWord(
    LPINSTDATAL lpInstL,
    LPIMEL      lpImeL,
#else
BOOL WINAPI ImeUnregisterWord(
#endif
    LPCTSTR     lpszReading,
    DWORD       dwStyle,
    LPCTSTR     lpszString)
{
#if defined(WINIME) || defined(UNICDIME) || defined(ROMANIME)
    return (FALSE);
#else
    BOOL   fRet, fNeedUnload;
    HANDLE hUsrDicMem;
    LPBYTE lpUsrDicStart, lpCurr, lpUsrDicLimit;
    DWORD  dwPattern;
    WORD   wCode;

    fRet = FALSE;

    if (!lpszString) {
        return (fRet);
    }

    if (dwStyle != IME_REGWORD_STYLE_EUDC) {
        return (fRet);
    }

    // only handle word not string now, should consider string later?
    if (*(LPCTSTR)((LPBYTE)lpszString + sizeof(WORD)) != '\0') {
        return (fRet);
    }

    if (!lpImeL->szUsrDic[0]) {
        return (fRet);
    }

    if (lpInstL->fdwTblLoad == TBL_LOADED) {
        fNeedUnload = FALSE;
    } else if (lpInstL->fdwTblLoad == TBL_NOTLOADED) {
        LoadUsrDicFile(lpInstL, lpImeL);

        if (lpImeL->fdwErrMsg & (ERRMSG_LOAD_USRDIC|ERRMSG_MEM_USRDIC)) {
            return (fRet);
        }
        // we only load dic, we will unload it
        fNeedUnload = TRUE;
    } else {
        return (fRet);
    }

    hUsrDicMem = OpenFileMapping(FILE_MAP_WRITE, FALSE,
        lpImeL->szUsrDicMap);
    if (!hUsrDicMem) {
        goto IUWUnloadUsrDic;
    }

    lpUsrDicStart = MapViewOfFile(hUsrDicMem, FILE_MAP_WRITE,
        0, 0, 0);
    if (!lpUsrDicStart) {
        goto IUWUnloadUsrDic;
    }


    lpUsrDicLimit = lpUsrDicStart + lpImeL->uUsrDicSize;

    dwPattern = ReadingToPattern(
#if defined(UNIIME)
        lpImeL,
#endif
        lpszReading, NULL, TRUE);

#ifdef UNICODE
    wCode = *(LPWORD)lpszString;
#else
    wCode = ((BYTE)lpszString[0] << 8) | (BYTE)lpszString[1];
#endif

    for (lpCurr = lpUsrDicStart; lpCurr < lpUsrDicLimit;
        lpCurr += lpImeL->nSeqBytes + sizeof(WORD)) {
        DWORD dwDicPattern;

        // find the internal code
        if (wCode != *(LPUNAWORD)lpCurr) {
            continue;
        }

        dwDicPattern = *(LPUNADWORD)(lpCurr + sizeof(WORD)) &
            lpImeL->dwPatternMask;

        if (!lpszReading) {
            // no reading, specify internal code only
        } else if (dwDicPattern == dwPattern) {
        } else {
            continue;
        }

        fRet = TRUE;

        UnregisterWord(
#if defined(UNIIME)
            lpImeL,
#endif
            lpUsrDicStart, lpCurr, lpUsrDicLimit);
        break;
    }

    UnmapViewOfFile(lpUsrDicStart);

    CloseHandle(hUsrDicMem);

IUWUnloadUsrDic:
    if (fNeedUnload) {
        if (lpInstL->hUsrDicMem) {
            CloseHandle(lpInstL->hUsrDicMem);
        }
        lpInstL->hUsrDicMem = (HANDLE)NULL;
    }

    return (fRet);
#endif
}

/**********************************************************************/
/* ImeGetRegsisterWordStyle / UniImeGetRegsisterWordStyle             */
/* Return Value:                                                      */
/*      number of styles copied/required                              */
/**********************************************************************/
#if defined(UNIIME)
UINT WINAPI UniImeGetRegisterWordStyle(
    LPINSTDATAL lpInstL,
    LPIMEL      lpImeL,
#else
UINT WINAPI ImeGetRegisterWordStyle(
#endif
    UINT        nItem,
    LPSTYLEBUF  lpStyleBuf)
{
#if defined(WINIME) || defined(UNICDIME) || defined(ROMANIME)
    return (FALSE);
#else
    if (!nItem) {
        return (1);
    }

    // invalid case
    if (!lpStyleBuf) {
        return (0);
    }

    lpStyleBuf->dwStyle = IME_REGWORD_STYLE_EUDC;

    LoadString(hInst, IDS_EUDC, lpStyleBuf->szDescription,
        sizeof(lpStyleBuf->szDescription)/sizeof(TCHAR));

    return (1);
#endif
}

#if !defined(ROMANIME)
/**********************************************************************/
/* PatternToReading                                                   */
/**********************************************************************/
void PASCAL PatternToReading(
#if defined(UNIIME)
    LPIMEL lpImeL,
#endif
    DWORD  dwPattern,
    LPTSTR lpszReading)
{
    int i;

    i = lpImeL->nMaxKey;

    *(LPTSTR)((LPBYTE)lpszReading + sizeof(WCHAR) * i) = '\0';

    // delete the ending 0 sequence code
    for (i--; i >= 0; i--) {
        if (dwPattern & lpImeL->dwSeqMask) {
            break;
        }
         *(LPWSTR)((LPBYTE)lpszReading + sizeof(WCHAR) * i) = '\0';
         dwPattern >>= lpImeL->nSeqBits;
    }

    for (; i >= 0; i--) {
         *(LPWORD)((LPBYTE)lpszReading + sizeof(WORD) * i) =
            lpImeL->wSeq2CompTbl[dwPattern & lpImeL->dwSeqMask];
         dwPattern >>= lpImeL->nSeqBits;
    }

    return;
}
#endif

/**********************************************************************/
/* ImeEnumRegisterWord                                                */
/* Return Value:                                                      */
/*      the last value return by the callback function                */
/**********************************************************************/
#if defined(UNIIME)
UINT WINAPI UniImeEnumRegisterWord(
    LPINSTDATAL          lpInstL,
    LPIMEL               lpImeL,
#else
UINT WINAPI ImeEnumRegisterWord(
#endif
    REGISTERWORDENUMPROC lpfnRegisterWordEnumProc,
    LPCTSTR              lpszReading,
    DWORD                dwStyle,
    LPCTSTR              lpszString,
    LPVOID               lpData)
{
#if defined(WINIME) || defined(UNICDIME) || defined(ROMANIME)
    return (FALSE);
#else
    HANDLE hUsrDicMem;
    WORD   wCode;
    BOOL   fNeedUnload;
    LPBYTE lpUsrDicStart, lpCurr, lpUsrDicLimit;
    DWORD  dwPattern;
    UINT   uRet;

    uRet = 0;

    if (!dwStyle) {
    } else if (dwStyle == IME_REGWORD_STYLE_EUDC) {
    } else {
        return (uRet);
    }

    if (!lpszString) {
    } else if (*(LPCTSTR)((LPBYTE)lpszString + sizeof(WORD)) == '\0') {
#ifdef UNICODE
        wCode = *(LPWORD)lpszString;
#else
        wCode = ((BYTE)lpszString[0] << 8) | (BYTE)lpszString[1];
#endif
    } else {
        return (uRet);
    }

    if (lpInstL->fdwTblLoad == TBL_LOADED) {
        fNeedUnload = FALSE;
    } else if (!lpImeL->szUsrDic[0]) {
        return (uRet);
    } else if (lpInstL->fdwTblLoad == TBL_NOTLOADED) {
        LoadUsrDicFile(lpInstL, lpImeL);

        if (lpImeL->fdwErrMsg & (ERRMSG_LOAD_USRDIC|ERRMSG_MEM_USRDIC)) {
            return (uRet);
        }
        // we only load dic, we will unload it
        fNeedUnload = TRUE;
    } else {
        return (uRet);
    }

    hUsrDicMem = OpenFileMapping(FILE_MAP_READ, FALSE,
        lpImeL->szUsrDicMap);
    if (!hUsrDicMem) {
        goto IERWUnloadUsrDic;
    }

    lpUsrDicStart = MapViewOfFile(hUsrDicMem, FILE_MAP_READ,
        0, 0, 0);
    if (!lpUsrDicStart) {
        goto IERWUnloadUsrDic;
    }

    if (lpszReading) {
        dwPattern = ReadingToPattern(
#if defined(UNIIME)
            lpImeL,
#endif
            lpszReading, NULL, TRUE);
    }

    lpUsrDicLimit = lpUsrDicStart + lpImeL->uUsrDicSize;

    for (lpCurr = lpUsrDicStart; lpCurr < lpUsrDicLimit;
        lpCurr += lpImeL->nSeqBytes + sizeof(WORD)) {
        DWORD  dwDicPattern;
        LPTSTR lpszMatchReading, lpszMatchString;
        BYTE   szBufReading[sizeof(WORD) * 12];
        BYTE   szBufString[sizeof(WORD) * 2];

        // match string

        if (!lpszString) {
            lpszMatchString = (LPTSTR)szBufString;
            *(LPWORD)lpszMatchString = *(LPUNAWORD)lpCurr;
            *(LPTSTR)((LPBYTE)lpszMatchString + sizeof(WORD)) = '\0';
#ifndef UNICODE
            // reverse it to ANSI string
            wCode = szBufString[0];
            szBufString[0] = szBufString[1];
            szBufString[1] = (BYTE)wCode;
#endif
        } else if (wCode == *(LPUNAWORD)lpCurr) {
            lpszMatchString = (LPTSTR)lpszString;
        } else {
            continue;                   // not matched
        }

        // match reading

        dwDicPattern = *(LPUNADWORD)(lpCurr + sizeof(WORD)) &
            lpImeL->dwPatternMask;

        if (!lpszReading) {
            lpszMatchReading = (LPTSTR)szBufReading;
            PatternToReading(
#if defined(UNIIME)
                lpImeL,
#endif
                dwDicPattern, lpszMatchReading);
        } else if (dwDicPattern == dwPattern) {
            lpszMatchReading = (LPTSTR)lpszReading;
        } else {
            continue;                   // not matched
        }

        uRet = (*lpfnRegisterWordEnumProc)(lpszMatchReading,
            IME_REGWORD_STYLE_EUDC, lpszMatchString, lpData);

        if (!uRet) {
            break;
        }
    }

    UnmapViewOfFile(lpUsrDicStart);

    CloseHandle(hUsrDicMem);

IERWUnloadUsrDic:
    if (fNeedUnload) {
        if (lpInstL->hUsrDicMem) {
            CloseHandle(lpInstL->hUsrDicMem);
        }

        lpInstL->hUsrDicMem = (HANDLE)NULL;
    }

    return (uRet);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\toascii.c ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    TOASCII.c
    
++*/
#include <windows.h>
#include <immdev.h>
#include "imeattr.h"
#include "imedefs.h"
#if defined(UNIIME)
#include "uniime.h"
#endif

#if  HANDLE_PRIVATE_HOTKEY  
/**********************************************************************/
/* ChkIMEHotKey()                                                     */
/* Return Value:                                                      */
/*      the ID of hot key                                             */
/**********************************************************************/
UINT PASCAL ChkIMEHotKey(
    UINT           uVirtKey,
    CONST LPBYTE   lpbKeyState)
{
    UINT uModifyKeys;
    UINT uRL;
    UINT i;

    // find IME hot keys
    uModifyKeys = 0;
    uRL = 0;

    if (lpbKeyState[VK_MENU] & 0x80) {
        uModifyKeys |= MOD_ALT;

        if (lpbKeyState[VK_LMENU] & 0x80) {
            uRL |= MOD_LEFT;
        } else if (lpbKeyState[VK_RMENU] & 0x80) {
            uRL |= MOD_RIGHT;
        } else {
            // above can not work in Win95, so fall into this
            uRL = (MOD_LEFT|MOD_RIGHT);
        }
    }

    if (lpbKeyState[VK_CONTROL] & 0x80) {
        uModifyKeys |= MOD_CONTROL;

        if (lpbKeyState[VK_LCONTROL] & 0x80) {
            uRL |= MOD_LEFT;
        } else if (lpbKeyState[VK_RCONTROL] & 0x80) {
            uRL |= MOD_RIGHT;
        } else {
            // above can not work in Win95, so fall into this
            uRL = (MOD_LEFT|MOD_RIGHT);
        }
    }

    if (lpbKeyState[VK_SHIFT] & 0x80) {
        uModifyKeys |= MOD_SHIFT;

        if (lpbKeyState[VK_LSHIFT] & 0x80) {
            uRL |= MOD_LEFT;
        } else if (lpbKeyState[VK_RSHIFT] & 0x80) {
            uRL |= MOD_RIGHT;
        } else {
            // above can not work in Win95, so fall into this
            uRL = (MOD_LEFT|MOD_RIGHT);
        }
    }

    if (lpbKeyState[VK_LWIN] & 0x80) {
        uModifyKeys |= MOD_WIN;
        uRL |= MOD_LEFT;
    } else if (lpbKeyState[VK_RWIN] & 0x80) {
        uModifyKeys |= MOD_WIN;
        uRL |= MOD_RIGHT;
    } else {
    }

    if (!uRL) {
        uRL = (MOD_LEFT|MOD_RIGHT);
    }

    for (i = 0; i < NUM_OF_IME_HOTKEYS; i++) {
        // virtual key
        if (sImeG.uVKey[i] != uVirtKey) {
            // virtual key unmatched!
            continue;
        }

        if (sImeG.uModifiers[i] & MOD_IGNORE_ALL_MODIFIER) {
        } else if ((sImeG.uModifiers[i] &
            (MOD_ALT|MOD_CONTROL|MOD_SHIFT|MOD_WIN)) != uModifyKeys) {
            // modifiers unmatched!
            continue;
        } else {
        }

        if ((sImeG.uModifiers[i] & (MOD_LEFT|MOD_RIGHT)) ==
            (MOD_LEFT|MOD_RIGHT)) {
            return (CST_IME_HOTKEYS + i);
        }

        // we don't have way to distinguish left & right yet
        if ((sImeG.uModifiers[i] & (MOD_LEFT|MOD_RIGHT)) == uRL) {
            return (CST_IME_HOTKEYS + i);
        }
    }

    // not a hot key
    return (0);
}
#endif

/**********************************************************************/
/* ProcessKey()                                                       */
/* Return Value:                                                      */
/*      different state which input key will change IME to            */
/**********************************************************************/
UINT PASCAL ProcessKey(     // this key will cause the IME go to what state
#if defined(UNIIME)
    LPINSTDATAL    lpInstL,
    LPIMEL         lpImeL,
#endif
    WORD           wCharCode,
    UINT           uVirtKey,
    UINT           uScanCode,
    CONST LPBYTE   lpbKeyState,
    LPINPUTCONTEXT lpIMC,
    LPPRIVCONTEXT  lpImcP)
{
    if (!lpIMC) {
        return (CST_INVALID);
    }

    if (!lpImcP) {
        return (CST_INVALID);
    }

//
// On NT 4.0, the hotkey checking is done by the system and the
// system  will call ImeEscape( himc, IME_ESC_PRIVATE_HOTKEY, pdwHotkeyID).
// If you build IMEs that support the ImeEscape(IME_ESC_PRIVATE_HOTKEY), 
// HANDLE_PRIVATE_HOTKEY should be disabled.
//
#ifdef HANDLE_PRIVATE_HOTKEY
    if ((lpIMC->fdwConversion & (IME_CMODE_NATIVE|IME_CMODE_EUDC|
        IME_CMODE_NOCONVERSION|IME_CMODE_CHARCODE)) == IME_CMODE_NATIVE) {
        UINT uHotKeyID;

        uHotKeyID = ChkIMEHotKey(uVirtKey, lpbKeyState);

        if (uHotKeyID) {
            return (uHotKeyID);
        }
    }
#endif

    if (uVirtKey == VK_MENU) {       // no ALT key
        return (CST_INVALID);
    } else if (uScanCode & KF_ALTDOWN) {    // no ALT-xx key
        return (CST_INVALID);
    } else if (uVirtKey == VK_CONTROL) {    // no CTRL key
        return (CST_INVALID);
    } else if (lpbKeyState[VK_CONTROL] & 0x80) {    // no CTRL-xx key
        return (CST_INVALID);
    } else if (uVirtKey == VK_SHIFT) {      // no SHIFT key
        return (CST_INVALID);
    } else if (!lpIMC->fOpen) {             // don't compose in close status
        return (CST_INVALID);
    } else if (lpIMC->fdwConversion & IME_CMODE_NOCONVERSION) {
        // don't compose in no coversion status
        return (CST_INVALID);
    } else if (lpIMC->fdwConversion & IME_CMODE_CHARCODE) {
        // not support
        return (CST_INVALID);
    } else {
        // need more check
    }

#if !defined(ROMANIME)
    if (lpIMC->fdwConversion & IME_CMODE_SYMBOL) {
        if (uVirtKey == VK_ESCAPE) {
            return (CST_SYMBOL);
        }
    }
#endif

#if defined(DAYI)
    if (lpIMC->fdwConversion & IME_CMODE_NATIVE) {
        if (wCharCode == '=') {
            return (CST_SYMBOL);
        }
    }
#endif

#if !defined(ROMANIME)
    if (lpImcP->fdwImeMsg & (MSG_ALREADY_OPEN|MSG_ALREADY_OPEN2)) {
        if (uVirtKey == VK_PRIOR) {
            return (CST_CHOOSE);
        } else if (uVirtKey == VK_NEXT) {
            return (CST_CHOOSE);
        } else if (uVirtKey == VK_ESCAPE) {
            return (CST_CHOOSE);
#if defined(DAYI)
        } else if (uVirtKey == VK_LEFT) {
            return (CST_CHOOSE);
        } else if (uVirtKey == VK_UP) {
            return (CST_CHOOSE);
        } else if (uVirtKey == VK_RIGHT) {
            return (CST_CHOOSE);
#elif defined(WINAR30)
#else
        } else if (wCharCode == '<') {
            return (CST_CHOOSE);
        } else if (wCharCode == '>') {
            return (CST_CHOOSE);
        } else if (wCharCode == '?') {
            return (CST_CHOOSE);
#endif
        } else {
            // need more check
        }
    }

    if (lpImcP->iImeState == CST_CHOOSE) {
        if (wCharCode > 'z') {
            return (CST_INVALID);
        } else if (wCharCode < ' ') {
            return (CST_INVALID);
        } else if (wCharCode >= '0' && wCharCode <= '9') {
#if defined(WINAR30)
        } else if (wCharCode == '<') {
            return (CST_CHOOSE);
        } else if (wCharCode == '>') {
            return (CST_CHOOSE);
        } else if (wCharCode == '?') {
            return (CST_CHOOSE);
#endif
        } else {
            wCharCode = bUpper[wCharCode - ' '];

#if defined(PHON)
            // convert different phonetic keyboard layout to ACER
            wCharCode = bStandardLayout[lpImeL->nReadLayout]
                [wCharCode - ' '];
#endif
        }

        if (wCharCode > '_') {
        } else if (uVirtKey >= VK_NUMPAD0 && uVirtKey <= VK_NUMPAD9) {
            if (uVirtKey >= (VK_NUMPAD0 + (UINT)lpImeL->wCandRangeStart)) {
                return (CST_CHOOSE);
            } else {
                return (CST_ALPHANUMERIC);
            }
        } else if (lpImeL->fChooseChar[(wCharCode - ' ') >> 4] &
            fMask[wCharCode & 0x000F]) {        // convert to upper case
            return (CST_CHOOSE);
        } else {
        }

        if (!(lpIMC->fdwConversion & IME_CMODE_NATIVE)) {
            // alphanumeric mode
            if (wCharCode >= ' ' && wCharCode <= '~') {
                return (CST_ALPHANUMERIC);
            } else {
                return (CST_INVALID);
            }
        } else if (uVirtKey >= 'A' && uVirtKey <= 'Z') {
            return (CST_ALPHABET);
        } else if (wCharCode >= ' ' && wCharCode <= '~') {
            return (CST_ALPHANUMERIC);
        } else {
            return (CST_INVALID);
        }
    }

    // not in choose mode but candidate alaredy open,
    // we must under quick view or phrase prediction
    if (lpImcP->fdwImeMsg & (MSG_ALREADY_OPEN|MSG_ALREADY_OPEN2)) {
        if (lpImcP->iImeState == CST_INIT) {
            if (lpbKeyState[VK_SHIFT] & 0x80) {
                if ((uVirtKey >= '0' + (UINT)lpImeL->wCandRangeStart) &&
                    uVirtKey <= '9') {
                    return (CST_CHOOSE);
                }
            }
#if defined(WINAR30)
        } else {
            if (wCharCode >= '0' && wCharCode <= '9') {
                if (*(LPDWORD)lpImcP->bSeq != 0x1B) {   //1996/12/12
                    return (CST_CHOOSE);
                }
            }
#endif
        }
    }

    if (uVirtKey >= VK_NUMPAD0 && uVirtKey <= VK_DIVIDE) {
        // as PM decide all numpad should be past to app
        return (CST_ALPHANUMERIC);
    }
#endif

#if defined(ROMANIME)
    if (wCharCode >= ' ' && wCharCode <= '~') {
        if (lpIMC->fdwConversion & IME_CMODE_FULLSHAPE) {
            return (CST_ALPHANUMERIC);
        } else {
            return (CST_INVALID);
        }
    }
#else
    if (!(lpIMC->fdwConversion & IME_CMODE_NATIVE)) {
        // alphanumeric mode
        if (wCharCode >= ' ' && wCharCode <= '~') {
            if (lpIMC->fdwConversion & IME_CMODE_FULLSHAPE) {
                return (CST_ALPHANUMERIC);
            } else {
                return (CST_INVALID);
            }
        } else {
            return (CST_INVALID);
        }
    } else if (!(lpbKeyState[VK_SHIFT] & 0x80)) {
        // need more check for IME_CMODE_NATIVE
#if defined(DAYI)
    } else if (lpIMC->fdwConversion & IME_CMODE_SYMBOL) {
#endif
    } else if (uVirtKey >= 'A' && uVirtKey <= 'Z') {
        return (CST_ALPHABET);
    } else if (wCharCode >= ' ' && wCharCode <= '~') {
        // need more check for IME_CMODE_NATIVE
    } else {
        return (CST_INVALID);
    }

    // IME_CMODE _EUDC will use the same state with IME_CMODE_NATIVE

    if (wCharCode >= ' ' && wCharCode <= 'z') {
        wCharCode = bUpper[wCharCode - ' '];
#if defined(PHON)
        {
            // convert different phonetic keyboard layout to ACER
            wCharCode = bStandardLayout[lpImeL->nReadLayout][wCharCode - ' '];
        }
#endif
    }

    if (uVirtKey == VK_ESCAPE) {
        register LPGUIDELINE lpGuideLine;
        register UINT        iImeState;

        if (lpImcP->fdwImeMsg & MSG_ALREADY_START) {
            return (CST_INPUT);
        }

        lpGuideLine = ImmLockIMCC(lpIMC->hGuideLine);

        if (!lpGuideLine) {
            return (CST_INVALID);
        } else if (lpGuideLine->dwLevel == GL_LEVEL_NOGUIDELINE) {
            iImeState = CST_INVALID;
        } else {
            // need this key to clean information string or guideline state
            iImeState = CST_INPUT;
        }

        ImmUnlockIMCC(lpIMC->hGuideLine);

        return (iImeState);
    } else if (uVirtKey == VK_BACK) {
        if (lpImcP->fdwImeMsg & MSG_ALREADY_START) {
            return (CST_INPUT);
        } else {
            return (CST_INVALID);
        }
#if 0
    } else if (uVirtKey >= VK_NUMPAD0 && uVirtKey <= VK_DIVIDE) {
        // as PM decide all numpad should be past to app
        return (CST_ALPHANUMERIC);
#endif
    } else if (wCharCode > '~') {
        return (CST_INVALID);
    } else if (wCharCode < ' ') {
        return (CST_INVALID);
#if !defined(ROMANIME)
    } else if (lpIMC->fdwConversion & IME_CMODE_EUDC) {
    } else if (lpIMC->fdwConversion & IME_CMODE_SYMBOL) {
        return (CST_SYMBOL);
    } else if (lpInstL->fdwTblLoad == TBL_LOADERR) {
        return (CST_INVALID);
    } else if (lpInstL->fdwTblLoad == TBL_NOTLOADED) {
        if (++lpInstL->cRefCount <= 0) {
            lpInstL->cRefCount = 1;
        }

        LoadTable(lpInstL, lpImeL);
#endif
    } else {
    }

    // check finalize char
    if (wCharCode == ' ' && lpImcP->iImeState == CST_INIT) {
        if (lpIMC->fdwConversion & IME_CMODE_FULLSHAPE) {
            return (CST_ALPHANUMERIC);
        } else {
            return (CST_INVALID);
        }
  #if defined(WINAR30)   //****  1996/2/5
    } else if (wCharCode == 0x27 && lpImcP->iImeState == CST_INIT) {
        if (lpIMC->fdwConversion & IME_CMODE_FULLSHAPE) {
            return (CST_ALPHANUMERIC);
        } else {
            return (CST_INVALID);
        }
  #endif
    } else if (lpImeL->fCompChar[(wCharCode - ' ') >> 4] &
        fMask[wCharCode & 0x000F]) {
        return (CST_INPUT);
  #if defined(WINAR30)   //****  1996/2/5
    } else if (wCharCode ==0x27) {
        return (CST_INPUT);
  #endif
    } else if (lpIMC->fdwConversion & IME_CMODE_EUDC) {
        return (CST_INVALID);
#if defined(WINAR30)
    } else if (*(LPDWORD)lpImcP->bSeq == 0x1B && wCharCode >= '0' && //1996/12/12
        wCharCode <= '9') {
        return (CST_SYMBOL);
#elif defined(DAYI)
    } else if (lpImeL->wChar2SeqTbl[wCharCode - ' '] >= 0x30 &&
        lpImeL->wChar2SeqTbl[wCharCode - ' '] <= 0x35) {
        return (CST_ROAD);
#elif  !defined(ROMANIME)  // for all other IMEs, input EURO.
       // Porbably, different Value for different IMEs.
       // But Now, we take use 3D as all IMEs EURO Input Key's Seq value.
    } else if (lpImeL->wChar2SeqTbl[wCharCode - ' '] == 0x3D ) {
        return (CST_EURO);
#endif
    } else if (lpIMC->fdwConversion & IME_CMODE_FULLSHAPE) {
        return (CST_ALPHANUMERIC);
    } else {
        return (CST_INVALID);
    }
#endif // !ROMANIME

    return (CST_INVALID);
}

/**********************************************************************/
/* ImeProcessKey() / UniImeProcessKey()                               */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
// if this key is need by IME?
#if defined(UNIIME)
BOOL WINAPI UniImeProcessKey(
    LPINSTDATAL  lpInstL,
    LPIMEL       lpImeL,
#else
BOOL WINAPI ImeProcessKey(
#endif
    HIMC         hIMC,
    UINT         uVirtKey,
    LPARAM       lParam,
    CONST LPBYTE lpbKeyState)
{
    LPINPUTCONTEXT lpIMC;
    LPPRIVCONTEXT  lpImcP;
    BYTE           szAscii[4];
    int            nChars;
    BOOL           fRet;

    // can't compose in NULL hIMC
    if (!hIMC) {
        return (FALSE);
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return (FALSE);
    }

    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    if (!lpImcP) {
        ImmUnlockIMC(hIMC);
        return (FALSE);
    }

    nChars = ToAscii(uVirtKey, HIWORD(lParam), lpbKeyState,
                (LPVOID)szAscii, 0);

    if (!nChars) {
        szAscii[0] = 0;
    }

    if (ProcessKey(
#if defined(UNIIME)
        lpInstL, lpImeL,
#endif
        (WORD)szAscii[0], uVirtKey, HIWORD(lParam), lpbKeyState,
        lpIMC, lpImcP) == CST_INVALID) {
        fRet = FALSE;
    } else {
        fRet = TRUE;
    }

    ImmUnlockIMCC(lpIMC->hPrivate);
    ImmUnlockIMC(hIMC);

    return (fRet);
}

/**********************************************************************/
/* TranslateToAscii()                                                 */
/* Return Value:                                                      */
/*      the number of translated chars                                */
/**********************************************************************/
UINT PASCAL TranslateToAscii(       // translate the key to WM_CHAR
                                    // as keyboard driver
    UINT           uVirtKey,
    UINT           uScanCode,
    LPTRANSMSGLIST lpTransBuf,
    UINT           uNumMsg,
    WORD           wCharCode)
{
    LPTRANSMSG lpTransMsg;

    if (wCharCode) {                    // one char code
        // 3 DWORD (message, wParam, lParam)
        lpTransMsg = (lpTransBuf->TransMsg) + uNumMsg;

        lpTransMsg->message = WM_CHAR;
        lpTransMsg->wParam = wCharCode;
        lpTransMsg->lParam = (uScanCode << 16) | 1UL;
        return (1);
    }

    // no char code case
    return (0);
}

/**********************************************************************/
/* TranslateImeMessage()                                              */
/* Return Value:                                                      */
/*      the number of translated messages                             */
/**********************************************************************/
UINT PASCAL TranslateImeMessage(
    LPTRANSMSGLIST lpTransBuf,
    LPINPUTCONTEXT lpIMC,
    LPPRIVCONTEXT  lpImcP)
{
    UINT uNumMsg;
    UINT i;
    BOOL bLockMsgBuf;
    LPTRANSMSG lpTransMsg;

    uNumMsg = 0;
    bLockMsgBuf = FALSE;

    for (i = 0; i < 2; i++) {
#if !defined(ROMANIME)
        if (lpImcP->fdwImeMsg & MSG_IMN_COMPOSITIONSIZE) {
            if (!i) {
                uNumMsg++;
            } else {
                lpTransMsg->message = WM_IME_NOTIFY;
                lpTransMsg->wParam  = IMN_PRIVATE;
                lpTransMsg->lParam  = IMN_PRIVATE_COMPOSITION_SIZE;
                lpTransMsg++;
            }
        }

        if (lpImcP->fdwImeMsg & MSG_START_COMPOSITION) {
            if (!(lpImcP->fdwImeMsg & MSG_ALREADY_START)) {
                if (!i) {
                    uNumMsg++;
                } else {
                    lpTransMsg->message = WM_IME_STARTCOMPOSITION;
                    lpTransMsg->wParam  = 0;
                    lpTransMsg->lParam  = 0;
                    lpTransMsg++;
                    lpImcP->fdwImeMsg |= MSG_ALREADY_START;
                }
            }
        }

        if (lpImcP->fdwImeMsg & MSG_IMN_COMPOSITIONPOS) {
            if (!i) {
                uNumMsg++;
            } else {
                lpTransMsg->message = WM_IME_NOTIFY;
                lpTransMsg->wParam  = IMN_SETCOMPOSITIONWINDOW;
                lpTransMsg->lParam  = 0;
                lpTransMsg++;
            }
        }
#endif

        if (lpImcP->fdwImeMsg & MSG_COMPOSITION) {
            if (!i) {
                uNumMsg++;
            } else {
                lpTransMsg->message = WM_IME_COMPOSITION;
                lpTransMsg->wParam  = (DWORD)lpImcP->dwCompChar;
                lpTransMsg->lParam  = (DWORD)lpImcP->fdwGcsFlag;
                lpTransMsg++;
            }
        }

#if !defined(ROMANIME)
        if (lpImcP->fdwImeMsg & MSG_GUIDELINE) {
            if (!i) {
                uNumMsg++;
            } else {
                lpTransMsg->message = WM_IME_NOTIFY;
                lpTransMsg->wParam  = IMN_GUIDELINE;
                lpTransMsg->lParam  = 0;
                lpTransMsg++;
            }
        }

        if (lpImcP->fdwImeMsg & MSG_IMN_PAGEUP) {
            if (!i) {
                uNumMsg++;
            } else {
                lpTransMsg->message = WM_IME_NOTIFY;
                lpTransMsg->wParam  = IMN_PRIVATE;
                lpTransMsg->lParam  = IMN_PRIVATE_PAGEUP;
                lpTransMsg++;
            }
        }

        if (lpImcP->fdwImeMsg & MSG_OPEN_CANDIDATE) {
            if (!(lpImcP->fdwImeMsg & MSG_ALREADY_OPEN)) {
                if (!i) {
                    uNumMsg++;
                } else {
                    lpTransMsg->message = WM_IME_NOTIFY;
                    lpTransMsg->wParam  = IMN_OPENCANDIDATE;
                    lpTransMsg->lParam  = 0x0001;
                    lpTransMsg++;
                    lpImcP->fdwImeMsg |= MSG_ALREADY_OPEN;
                }
            }
        }

        if (lpImcP->fdwImeMsg & MSG_CHANGE_CANDIDATE) {
            if (!i) {
                uNumMsg++;
            } else {
                lpTransMsg->message = WM_IME_NOTIFY;
                lpTransMsg->wParam  = IMN_CHANGECANDIDATE;
                lpTransMsg->lParam  = 0x0001;
                lpTransMsg++;
            }
        }

        if (lpImcP->fdwImeMsg & MSG_IMN_UPDATE_PREDICT) {
            if (!i) {
                uNumMsg++;
            } else {
                lpTransMsg->message = WM_IME_NOTIFY;
                lpTransMsg->wParam  = IMN_PRIVATE;
                lpTransMsg->lParam  = IMN_PRIVATE_UPDATE_PREDICT;
                lpTransMsg++;
            }
        }

#if defined(WINAR30)
        if (lpImcP->fdwImeMsg & MSG_IMN_UPDATE_QUICK_KEY) {
            if (!i) {
                uNumMsg++;
            } else {
                lpTransMsg->message = WM_IME_NOTIFY;
                lpTransMsg->wParam  = IMN_PRIVATE;
                lpTransMsg->lParam  = IMN_PRIVATE_UPDATE_QUICK_KEY;
                lpTransMsg++;
            }
        }
#else
        if (lpImcP->fdwImeMsg & MSG_IMN_UPDATE_SOFTKBD) {
            if (!i) {
                uNumMsg++;
            } else {
                lpTransMsg->message = WM_IME_NOTIFY;
                lpTransMsg->wParam  = IMN_PRIVATE;
                lpTransMsg->lParam  = IMN_PRIVATE_UPDATE_SOFTKBD;
                lpTransMsg++;
            }
        }
#endif

        if (lpImcP->fdwImeMsg & MSG_CLOSE_CANDIDATE) {
            if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
                if (!i) {
                    uNumMsg++;
                } else {
                    lpTransMsg->message = WM_IME_NOTIFY;
                    lpTransMsg->wParam  = IMN_CLOSECANDIDATE;
                    lpTransMsg->lParam  = 0x0001;
                    lpTransMsg++;
                    lpImcP->fdwImeMsg &= ~(MSG_ALREADY_OPEN);
                }
            }
        }

        if (lpImcP->fdwImeMsg & MSG_END_COMPOSITION) {
            if (lpImcP->fdwImeMsg & MSG_ALREADY_START) {
                if (!i) {
                    uNumMsg++;
                } else {
                    lpTransMsg->message = WM_IME_ENDCOMPOSITION;
                    lpTransMsg->wParam  = 0;
                    lpTransMsg->lParam  = 0;
                    lpTransMsg++;
                    lpImcP->fdwImeMsg &= ~(MSG_ALREADY_START);
                }
            }
        }
#endif

        if (lpImcP->fdwImeMsg & MSG_IMN_TOGGLE_UI) {
            if (!i) {
                uNumMsg++;
            } else {
                lpTransMsg->message = WM_IME_NOTIFY;
                lpTransMsg->wParam  = IMN_PRIVATE;
                lpTransMsg->lParam  = IMN_PRIVATE_TOGGLE_UI;
                lpTransMsg++;
            }
        }

        if (!i) {
            HIMCC hMem;

            if (!uNumMsg) {
                return (uNumMsg);
            }

            if (lpImcP->fdwImeMsg & MSG_IN_IMETOASCIIEX) {
                UINT uNumMsgLimit;

                // ++ for the start position of buffer to strore the messages
                uNumMsgLimit = lpTransBuf->uMsgCount;

                if (uNumMsg <= uNumMsgLimit) {
                    lpTransMsg = lpTransBuf->TransMsg;
                    continue;
                }
            }

            // we need to use message buffer
            if (!lpIMC->hMsgBuf) {
                lpIMC->hMsgBuf = ImmCreateIMCC(uNumMsg * sizeof(TRANSMSG));
                lpIMC->dwNumMsgBuf = 0;
            } else if (hMem = ImmReSizeIMCC(lpIMC->hMsgBuf,
                (lpIMC->dwNumMsgBuf + uNumMsg) * sizeof(TRANSMSG))) {
                if (hMem != lpIMC->hMsgBuf) {
                    ImmDestroyIMCC(lpIMC->hMsgBuf);
                    lpIMC->hMsgBuf = hMem;
                }
            } else {
                return (0);
            }

            lpTransMsg = (LPTRANSMSG)ImmLockIMCC(lpIMC->hMsgBuf);
            if (!lpTransMsg) {
                return (0);
            }

            lpTransMsg += lpIMC->dwNumMsgBuf;

            bLockMsgBuf = TRUE;
        } else {
            if (bLockMsgBuf) {
                ImmUnlockIMCC(lpIMC->hMsgBuf);
            }
        }
    }

    return (uNumMsg);
}

/**********************************************************************/
/* TranslateFullChar()                                                */
/* Return Value:                                                      */
/*      the number of translated chars                                */
/**********************************************************************/
UINT PASCAL TranslateFullChar(          // convert to Double Byte Char
    LPTRANSMSGLIST lpTransBuf,
    LPINPUTCONTEXT lpIMC,
    LPPRIVCONTEXT  lpImcP,
    WCHAR          wCharCode)
{
    LPCOMPOSITIONSTRING lpCompStr;

    lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);

    if (!lpCompStr) {
        return TranslateImeMessage(lpTransBuf, lpIMC, lpImcP);
    }

    lpCompStr->dwResultReadClauseLen = 0;
    lpCompStr->dwResultReadStrLen = 0;

    lpCompStr->dwResultStrLen = sizeof(WCHAR) / sizeof(TCHAR);
#if defined(UNICODE)
    *(LPWSTR)((LPBYTE)lpCompStr + lpCompStr->dwResultStrOffset) =
        wCharCode;
#else
    *((LPBYTE)lpCompStr + lpCompStr->dwResultStrOffset) =
        HIBYTE(wCharCode);
    *((LPBYTE)lpCompStr + lpCompStr->dwResultStrOffset + sizeof(BYTE)) =
        LOBYTE(wCharCode);
#endif
    // add a null terminator
    *(LPTSTR)((LPBYTE)lpCompStr + lpCompStr->dwResultStrOffset +
        sizeof(WCHAR)) = '\0';

    lpCompStr->dwResultClauseLen = 2 * sizeof(DWORD);
    *(LPDWORD)((LPBYTE)lpCompStr + lpCompStr->dwResultClauseOffset +
        sizeof(DWORD)) = lpCompStr->dwResultStrLen;

    ImmUnlockIMCC(lpIMC->hCompStr);

    lpImcP->fdwImeMsg |=  MSG_COMPOSITION;
    lpImcP->dwCompChar = 0;
    lpImcP->fdwGcsFlag |= GCS_RESULTREAD|GCS_RESULT;

    return TranslateImeMessage(lpTransBuf, lpIMC, lpImcP);
}

/**********************************************************************/
/* ImeToAsciiEx() / UniImeToAsciiex()                                 */
/* Return Value:                                                      */
/*      the number of translated message                              */
/**********************************************************************/
#if defined(UNIIME)
UINT WINAPI UniImeToAsciiEx(
    LPINSTDATAL  lpInstL,
    LPIMEL       lpImeL,
#else
UINT WINAPI ImeToAsciiEx(
#endif
    UINT           uVirtKey,
    UINT           uScanCode,
    CONST LPBYTE   lpbKeyState,
    LPTRANSMSGLIST lpTransBuf,
    UINT           fuState,
    HIMC           hIMC)
{
    WORD                wCharCode;
    LPINPUTCONTEXT      lpIMC;
    LPCOMPOSITIONSTRING lpCompStr;
#if !defined(ROMANIME)
    LPGUIDELINE         lpGuideLine;
#endif
    LPPRIVCONTEXT       lpImcP;
    UINT                uNumMsg;
    int                 iRet;

#ifdef UNICODE
    wCharCode = HIWORD(uVirtKey);
#else
    wCharCode = HIBYTE(uVirtKey);
#endif
    uVirtKey = LOBYTE(uVirtKey);

    if (!hIMC) {
        uNumMsg = TranslateToAscii(uVirtKey, uScanCode, lpTransBuf,
            0, wCharCode);
        return (uNumMsg);
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        uNumMsg = TranslateToAscii(uVirtKey, uScanCode, lpTransBuf,
            0, wCharCode);
        return (uNumMsg);
    }

    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    if (!lpImcP) {
        ImmUnlockIMC(hIMC);
        uNumMsg = TranslateToAscii(uVirtKey, uScanCode, lpTransBuf,
            0, wCharCode);
        return (uNumMsg);
    }

    // Now all composition realated information already pass to app
    // a brand new start
#if defined(ROMANIME)
    lpImcP->fdwImeMsg = MSG_IN_IMETOASCIIEX;
#else
    lpImcP->fdwImeMsg = lpImcP->fdwImeMsg & (MSG_STATIC_STATE) |
        MSG_IN_IMETOASCIIEX;
#endif

    iRet = ProcessKey(
#if defined(UNIIME)
        lpInstL, lpImeL,
#endif
        wCharCode, uVirtKey, uScanCode, lpbKeyState, lpIMC, lpImcP);

#if !defined(ROMANIME)
    if (iRet == CST_ALPHABET) {
        // A-Z convert to a-z, a-z convert to A-Z
        wCharCode ^= 0x20;

        iRet = CST_ALPHANUMERIC;
    }

    if (iRet == CST_CHOOSE) {
    } else if (iRet == CST_TOGGLE_UI) {
    } else if (lpImcP->iImeState == CST_INPUT) {
    } else if (lpImcP->iImeState == CST_CHOOSE) {
    } else {
        ClearCand(lpIMC);

        if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
            lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg |
                MSG_CLOSE_CANDIDATE) & ~(MSG_OPEN_CANDIDATE);
        } else {
            lpImcP->fdwImeMsg &= ~(MSG_OPEN_CANDIDATE);
        }
    }
#endif

    if (iRet == CST_ALPHANUMERIC) {
        if (lpIMC->fdwConversion & IME_CMODE_FULLSHAPE) {   // convert to DBCS
            uNumMsg = TranslateFullChar(lpTransBuf, lpIMC, lpImcP,
                sImeG.wFullABC[wCharCode - ' ']);
        } else {
            uNumMsg = TranslateImeMessage(lpTransBuf, lpIMC, lpImcP);

            uNumMsg += TranslateToAscii(uVirtKey, uScanCode, lpTransBuf,
                uNumMsg, wCharCode);
        }
#if !defined(ROMANIME)
    } else if (iRet == CST_SYMBOL) {
        if (uVirtKey == VK_ESCAPE) {
            CandEscapeKey(lpIMC, lpImcP);

            ImmSetConversionStatus(hIMC,
                lpIMC->fdwConversion & ~(IME_CMODE_SYMBOL),
                lpIMC->fdwSentence);
        } else if (lpIMC->fdwConversion & IME_CMODE_SYMBOL) {
#if defined(WINAR30) || defined(DAYI)
#if defined(DAYI)
            if (wCharCode == '=') {
                CandEscapeKey(lpIMC, lpImcP);

                ImmSetConversionStatus(hIMC,
                    lpIMC->fdwConversion ^ (IME_CMODE_SYMBOL),
                    lpIMC->fdwSentence);
#endif
#if defined(WINAR30)
            if (wCharCode >= '0' && wCharCode <= '9') {
#endif
#if defined(DAYI)
            } else if (wCharCode >= ' ' && wCharCode <= '~') {
#endif
                CandEscapeKey(lpIMC, lpImcP);

                ImmSetConversionStatus(hIMC,
                    lpIMC->fdwConversion | IME_CMODE_SYMBOL,
                    lpIMC->fdwSentence);

                SearchSymbol(wCharCode, hIMC, lpIMC, lpImcP);
            } else {
                MessageBeep((UINT)-1);

                CandEscapeKey(lpIMC, lpImcP);

                ImmSetConversionStatus(hIMC,
                    lpIMC->fdwConversion & ~(IME_CMODE_SYMBOL),
                    lpIMC->fdwSentence);
            }
#else
            ImmSetConversionStatus(hIMC,
                lpIMC->fdwConversion & ~(IME_CMODE_SYMBOL),
                lpIMC->fdwSentence);

            if (wCharCode >= ' ' && wCharCode <= '}') {
                wCharCode = bUpper[wCharCode - ' '];

                uNumMsg = TranslateFullChar(lpTransBuf, lpIMC, lpImcP,
                    sImeG.wSymbol[wCharCode - ' ']);

                goto ImToAsExExit;
            }
#endif
        } else {
#if defined(WINAR30) || defined(DAYI)
            CandEscapeKey(lpIMC, lpImcP);

            ImmSetConversionStatus(hIMC,
                lpIMC->fdwConversion | IME_CMODE_SYMBOL,
                lpIMC->fdwSentence);

#if defined(WINAR30)
            SearchSymbol(wCharCode, hIMC, lpIMC, lpImcP);
#endif
#endif
        }

        uNumMsg = TranslateImeMessage(lpTransBuf, lpIMC, lpImcP);
    } else if (iRet == CST_CHOOSE) {
        LPCANDIDATEINFO lpCandInfo;

        lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo);

        if (uVirtKey == VK_PRIOR) {
            wCharCode = CHOOSE_PREVPAGE;
        } else if (uVirtKey == VK_NEXT) {
            wCharCode = CHOOSE_NEXTPAGE;
        } else if (uVirtKey >= (VK_NUMPAD0 + (UINT)lpImeL->wCandRangeStart) &&
            uVirtKey <= VK_NUMPAD9) {
            wCharCode = uVirtKey - VK_NUMPAD0;
#if defined(DAYI)
        } else if (lpImcP->iImeState != CST_CHOOSE && uVirtKey >= '0' &&
            uVirtKey <= '9') {
            // convert shift-0 ... shift-9 to 0 ... 9
            wCharCode = uVirtKey - '0';
        } else if (uVirtKey == VK_LEFT) {
            wCharCode = CHOOSE_PREVPAGE;
        } else if (uVirtKey == VK_UP) {
            wCharCode = CHOOSE_HOME;
        } else if (uVirtKey == VK_RIGHT) {
            wCharCode = CHOOSE_NEXTPAGE;
        } else if (wCharCode < ' ') {
        } else if (wCharCode > '~') {
        } else {
            wCharCode = lpImeL->cChooseTrans[wCharCode - ' '];
#else
        } else if (uVirtKey >= ('0' + (UINT)lpImeL->wCandRangeStart) &&
            uVirtKey <= '9') {
            // convert shift-0 ... shift-9 to 0 ... 9
            wCharCode = uVirtKey - '0';
        } else if (wCharCode == '<') {
            wCharCode = CHOOSE_PREVPAGE;
        } else if (wCharCode == '?') {
            wCharCode = CHOOSE_HOME;
        } else if (wCharCode == '>') {
            wCharCode = CHOOSE_NEXTPAGE;
        } else if (wCharCode == ' ') {
            wCharCode = CHOOSE_CIRCLE;
        } else {
#endif
        }

        ChooseCand(
#if defined(UNIIME)
            lpInstL, lpImeL,
#endif
            wCharCode, hIMC, lpIMC, lpCandInfo, lpImcP);

        ImmUnlockIMCC(lpIMC->hCandInfo);

        uNumMsg = TranslateImeMessage(lpTransBuf, lpIMC, lpImcP);
    } else if (iRet == CST_INPUT) {
        lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
        lpGuideLine = (LPGUIDELINE)ImmLockIMCC(lpIMC->hGuideLine);

        CompWord(
#if defined(UNIIME)
            lpInstL, lpImeL,
#endif
            wCharCode, hIMC, lpIMC, lpCompStr, lpGuideLine, lpImcP);

        if (lpGuideLine) {
            ImmUnlockIMCC(lpIMC->hGuideLine);
        }

        if (lpCompStr) {
            ImmUnlockIMCC(lpIMC->hCompStr);
        }

        uNumMsg = TranslateImeMessage(lpTransBuf, lpIMC, lpImcP);
#endif
#if defined(DAYI)
    } else if (iRet == CST_ROAD) {
        wCharCode = lpImeL->wSeq2CompTbl[lpImeL->wChar2SeqTbl[wCharCode - ' ']];

#ifndef UNICODE
        wCharCode = HIBYTE(wCharCode)|(LOBYTE(wCharCode) << 8);
#endif

        uNumMsg = TranslateFullChar(lpTransBuf, lpIMC, lpImcP, wCharCode);
#endif

#if !defined(DAYI) && !defined(ROMANIME) 
    } else if (iRet == CST_EURO) {
        wCharCode = lpImeL->wSeq2CompTbl[lpImeL->wChar2SeqTbl[wCharCode - ' ']];

#ifndef UNICODE
        wCharCode = HIBYTE(wCharCode)|(LOBYTE(wCharCode) << 8);
#endif

        uNumMsg = TranslateFullChar(lpTransBuf, lpIMC, lpImcP, wCharCode);
#endif

    } 
#ifdef HANDLE_PRIVATE_HOTKEY
    else if (iRet == CST_RESEND_RESULT) {
        DWORD dwResultStrLen;

        lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);

        if (lpCompStr) {
            if (lpCompStr->dwResultStrLen) {
                dwResultStrLen = lpCompStr->dwResultStrLen;
            } else {
                dwResultStrLen = 0;
            }

            ImmUnlockIMCC(lpIMC->hCompStr);
        } else {
            dwResultStrLen = 0;
        }

        if (dwResultStrLen) {
            lpImcP->fdwImeMsg |=  MSG_COMPOSITION;
            lpImcP->dwCompChar = 0;
            lpImcP->fdwGcsFlag |= GCS_RESULTREAD|GCS_RESULT;
        } else {
            MessageBeep((UINT)-1);
        }

        uNumMsg = TranslateImeMessage(lpTransBuf, lpIMC, lpImcP);
    } else if (iRet == CST_PREVIOUS_COMP) {
        DWORD dwResultReadStrLen;
        TCHAR szReading[16];

        lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);

        if (lpCompStr) {
            if (lpCompStr->dwResultReadStrLen) {
                dwResultReadStrLen = lpCompStr->dwResultReadStrLen;

                if (dwResultReadStrLen > lpImeL->nMaxKey * sizeof(WCHAR)
                    / sizeof(TCHAR)) {
                    dwResultReadStrLen = lpImeL->nMaxKey * sizeof(WCHAR)
                        / sizeof(TCHAR);
                }

                CopyMemory(szReading, (LPBYTE)lpCompStr +
                    lpCompStr->dwResultReadStrOffset,
                    dwResultReadStrLen * sizeof(TCHAR));

                // NULL termainator
                szReading[dwResultReadStrLen] = '\0';
            } else {
                dwResultReadStrLen = 0;
            }

            ImmUnlockIMCC(lpIMC->hCompStr);
        } else {
            dwResultReadStrLen = 0;
        }

        if (dwResultReadStrLen) {
#if defined(UNIIME)
            UniImeSetCompositionString(lpInstL, lpImeL, hIMC, SCS_SETSTR,
                NULL, 0, szReading, dwResultReadStrLen * sizeof(TCHAR));
#else
            ImeSetCompositionString(hIMC, SCS_SETSTR, NULL, 0, szReading,
                dwResultReadStrLen * sizeof(TCHAR));
#endif
        } else {
            MessageBeep((UINT)-1);
        }

        uNumMsg = TranslateImeMessage(lpTransBuf, lpIMC, lpImcP);
    } else if (iRet == CST_TOGGLE_UI) {
        lpImeL->fdwModeConfig ^= MODE_CONFIG_OFF_CARET_UI;

        SetUserSetting(
#if defined(UNIIME)
            lpImeL,
#endif
            szRegModeConfig, REG_DWORD, (LPBYTE)&lpImeL->fdwModeConfig,
            sizeof(lpImeL->fdwModeConfig));

        InitImeUIData(lpImeL);

        lpImcP->fdwImeMsg |= MSG_IMN_TOGGLE_UI;

        uNumMsg = TranslateImeMessage(lpTransBuf, lpIMC, lpImcP);
    } 
#endif // HANDLE_PRIVATE_HOTKEY
    else {
        uNumMsg = TranslateToAscii(uVirtKey, uScanCode, lpTransBuf,
            0, wCharCode);
    }

#if !defined(ROMANIME)
#if !defined(DAYI) && !defined(WINAR30)
ImToAsExExit:
#endif
    lpImcP->fdwImeMsg &= (MSG_STATIC_STATE);
    lpImcP->fdwGcsFlag = 0;
#endif

    ImmUnlockIMCC(lpIMC->hPrivate);
    ImmUnlockIMC(hIMC);

    return (uNumMsg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\cblocks\about.cpp ===
/*************************************************
 *  about.cpp                                    *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

#include "stdafx.h"
#include "cblocks.h"
#include "about.h"
						    
CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
    //{{AFX_DATA_INIT(CAboutDlg)
    //}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAboutDlg)
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
    //{{AFX_MSG_MAP(CAboutDlg)
        // No message handlers
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\cblocks\about.h ===
/*************************************************
 *  about.h                                      *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About
#ifndef _ABOUT_H_
#define _ABOUT_H_
						  
class CAboutDlg : public CDialog
{
public:
    CAboutDlg();

// Dialog Data
    //{{AFX_DATA(CAboutDlg)
    enum { IDD = IDD_ABOUTBOX };
    //}}AFX_DATA

// Implementation
protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //{{AFX_MSG(CAboutDlg)
        // No message handlers
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\uisubs.c ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    UISUBS.c
    
++*/
#include <windows.h>
#include <immdev.h>
#include "imeattr.h"
#include "imedefs.h"
#include "imerc.h"
#if defined(UNIIME)
#include "uniime.h"
#endif

/**********************************************************************/
/* DrawDragBorder()                                                   */
/**********************************************************************/
void PASCAL DrawDragBorder(
    HWND hWnd,                  // window of IME is dragged
    LONG lCursorPos,            // the cursor position
    LONG lCursorOffset)         // the offset form cursor to window org
{
    HDC  hDC;
    int  cxBorder, cyBorder;
    int  x, y;
    RECT rcWnd;

    cxBorder = GetSystemMetrics(SM_CXBORDER);   // width of border
    cyBorder = GetSystemMetrics(SM_CYBORDER);   // height of border

    // get cursor position
    x = (*(LPPOINTS)&lCursorPos).x;
    y = (*(LPPOINTS)&lCursorPos).y;

    // calculate the org by the offset
    x -= (*(LPPOINTS)&lCursorOffset).x;
    y -= (*(LPPOINTS)&lCursorOffset).y;

#if 0 // MultiMonitor support
    // check for the min boundary of the display
    if (x < sImeG.rcWorkArea.left) {
        x = sImeG.rcWorkArea.left;
    }

    if (y < sImeG.rcWorkArea.top) {
        y = sImeG.rcWorkArea.top;
    }
#endif

    // check for the max boundary of the display
    GetWindowRect(hWnd, &rcWnd);

#if 0 // MultiMonitor support
    if (x + rcWnd.right - rcWnd.left > sImeG.rcWorkArea.right) {
        x = sImeG.rcWorkArea.right - (rcWnd.right - rcWnd.left);
    }

    if (y + rcWnd.bottom - rcWnd.top > sImeG.rcWorkArea.bottom) {
        y = sImeG.rcWorkArea.bottom - (rcWnd.bottom - rcWnd.top);
    }
#endif

    // draw the moving track
    hDC = CreateDC(TEXT("DISPLAY"), NULL, NULL, NULL);
    SelectObject(hDC, GetStockObject(GRAY_BRUSH));

    // ->
    PatBlt(hDC, x, y, rcWnd.right - rcWnd.left - cxBorder, cyBorder,
        PATINVERT);
    // v
    PatBlt(hDC, x, y + cyBorder, cxBorder, rcWnd.bottom - rcWnd.top -
        cyBorder, PATINVERT);
    // _>
    PatBlt(hDC, x + cxBorder, y + rcWnd.bottom - rcWnd.top,
        rcWnd.right - rcWnd.left - cxBorder, -cyBorder, PATINVERT);
    //  v
    PatBlt(hDC, x + rcWnd.right - rcWnd.left, y,
        - cxBorder, rcWnd.bottom - rcWnd.top - cyBorder, PATINVERT);

    DeleteDC(hDC);
    return;
}

/**********************************************************************/
/* DrawFrameBorder()                                                  */
/**********************************************************************/
void PASCAL DrawFrameBorder(    // border of IME
    HDC  hDC,
    HWND hWnd)                  // window of IME
{
    RECT rcWnd;
    int  xWi, yHi;

    GetWindowRect(hWnd, &rcWnd);

    xWi = rcWnd.right - rcWnd.left;
    yHi = rcWnd.bottom - rcWnd.top;

    // 1, ->
    PatBlt(hDC, 0, 0, xWi, 1, WHITENESS);

    // 1, v
    PatBlt(hDC, 0, 0, 1, yHi, WHITENESS);

    // 1, _>
    PatBlt(hDC, 0, yHi, xWi, -1, BLACKNESS);

    // 1,  v
    PatBlt(hDC, xWi, 0, -1, yHi, BLACKNESS);

    xWi -= 2;
    yHi -= 2;

    SelectObject(hDC, GetStockObject(LTGRAY_BRUSH));

    // 2, ->
    PatBlt(hDC, 1, 1, xWi, 1, PATCOPY);

    // 2, v
    PatBlt(hDC, 1, 1, 1, yHi, PATCOPY);

    // 2,  v
    PatBlt(hDC, xWi + 1, 1, -1, yHi, PATCOPY);

    SelectObject(hDC, GetStockObject(GRAY_BRUSH));

    // 2, _>
    PatBlt(hDC, 1, yHi + 1, xWi, -1, PATCOPY);

    xWi -= 2;
    yHi -= 2;

    // 3, ->
    PatBlt(hDC, 2, 2, xWi, 1, PATCOPY);

    // 3, v
    PatBlt(hDC, 2, 2, 1, yHi, PATCOPY);

    // 3,  v
    PatBlt(hDC, xWi + 2, 3, -1, yHi - 1, WHITENESS);

    SelectObject(hDC, GetStockObject(LTGRAY_BRUSH));

    // 3, _>
    PatBlt(hDC, 2, yHi + 2, xWi, -1, PATCOPY);

    SelectObject(hDC, GetStockObject(GRAY_BRUSH));

    xWi -= 2;
    yHi -= 2;

    // 4, ->
    PatBlt(hDC, 3, 3, xWi, 1, PATCOPY);

    // 4, v
    PatBlt(hDC, 3, 3, 1, yHi, PATCOPY);

    SelectObject(hDC, GetStockObject(LTGRAY_BRUSH));

    // 4,  v
    PatBlt(hDC, xWi + 3, 4, -1, yHi - 1, PATCOPY);

    // 4, _>
    PatBlt(hDC, 3, yHi + 3, xWi, -1, WHITENESS);

    return;
}

/**********************************************************************/
/* ContextMenuWndProc()                                               */
/**********************************************************************/
#if defined(UNIIME)
LRESULT WINAPI   UniContextMenuWndProc(
    LPINSTDATAL lpInstL,
    LPIMEL      lpImeL,
#else
LRESULT CALLBACK ContextMenuWndProc(
#endif
    HWND        hCMenuWnd,
    UINT        uMsg,
    WPARAM      wParam,
    LPARAM      lParam)
{
    switch (uMsg) {
    case WM_DESTROY:
        {
            HWND hUIWnd;

            hUIWnd = (HWND)GetWindowLongPtr(hCMenuWnd, CMENU_HUIWND);

            if (hUIWnd) {
                SendMessage(hUIWnd, WM_IME_NOTIFY, IMN_PRIVATE,
                    IMN_PRIVATE_CMENUDESTROYED);
            }
        }
        break;
    case WM_USER_DESTROY:
        {
            SendMessage(hCMenuWnd, WM_CLOSE, 0, 0);
            DestroyWindow(hCMenuWnd);
        }
        break;
    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDM_SOFTKBD:
        case IDM_SYMBOL:
            {
                HWND  hUIWnd;
                HIMC  hIMC;
                DWORD fdwConversion=0;
                DWORD fdwSentence=0;

                hUIWnd = (HWND)GetWindowLongPtr(hCMenuWnd, CMENU_HUIWND);
                hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);

                ImmGetConversionStatus(hIMC, &fdwConversion,
                    &fdwSentence);

                if (LOWORD(wParam) == IDM_SOFTKBD) {
                    ImmSetConversionStatus(hIMC, fdwConversion ^
                        IME_CMODE_SOFTKBD, fdwSentence);
                }

                if (LOWORD(wParam) == IDM_SYMBOL) {
                    ImmSetConversionStatus(hIMC, fdwConversion ^
                        IME_CMODE_SYMBOL, fdwSentence);
                }

                SendMessage(hCMenuWnd, WM_CLOSE, 0, 0);
            }
            break;
        case IDM_PROPERTIES:
#if defined(UNIIME)
            UniImeConfigure(lpInstL, lpImeL,
                GetKeyboardLayout(0), hCMenuWnd, IME_CONFIG_GENERAL, NULL);
#else
            ImeConfigure(GetKeyboardLayout(0), hCMenuWnd,
                IME_CONFIG_GENERAL, NULL);
#endif
            SendMessage(hCMenuWnd, WM_CLOSE, 0, 0);
            break;
        default:
            return DefWindowProc(hCMenuWnd, uMsg, wParam, lParam);
        }
        break;
    case WM_CLOSE:
        {
            HMENU hMenu;

            hMenu = (HMENU)GetWindowLongPtr(hCMenuWnd, CMENU_MENU);
            if (hMenu) {
                SetWindowLongPtr(hCMenuWnd, CMENU_MENU, (LONG_PTR)NULL);
                DestroyMenu(hMenu);
            }
        }
        return DefWindowProc(hCMenuWnd, uMsg, wParam, lParam);
    default:
        return DefWindowProc(hCMenuWnd, uMsg, wParam, lParam);
    }

    return (0L);
}

/**********************************************************************/
/* ContextMenu()                                                      */
/**********************************************************************/
void PASCAL ContextMenu(
#if defined(UNIIME)
    LPINSTDATAL lpInstL,
    LPIMEL      lpImeL,
#endif
    HWND        hStatusWnd,
    int         x,
    int         y)
{
    HWND           hUIWnd;
    HWND           hCMenuWnd;
    HGLOBAL        hUIPrivate;
    LPUIPRIV       lpUIPrivate;
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    HMENU          hMenu, hCMenu;
    RECT           rcWorkArea;

    hUIWnd = GetWindow(hStatusWnd, GW_OWNER);

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return;
    }

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {
        goto ContextMenuUnlockIMC;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {
        goto ContextMenuUnlockIMC;
    }

#if 1 // MultiMonitor support
    rcWorkArea = ImeMonitorWorkAreaFromWindow(lpIMC->hWnd);
#endif
    if (lpUIPrivate->hCMenuWnd) {
        SetWindowPos(lpUIPrivate->hCMenuWnd, NULL,
            rcWorkArea.left, rcWorkArea.top, 0, 0,
            SWP_NOACTIVATE|SWP_NOSIZE|SWP_NOZORDER);
    } else {
        // this is important to assign owner window, otherwise the focus
        // will be gone

        // When UI terminate, it need to destroy this window
        lpUIPrivate->hCMenuWnd = CreateWindowEx(CS_HREDRAW|CS_VREDRAW,
            lpImeL->szCMenuClassName, TEXT("Context Menu"),
            WS_POPUP|WS_DISABLED, 0, 0, 0, 0,
            lpIMC->hWnd, (HMENU)NULL, lpInstL->hInst, NULL);
    }

    hCMenuWnd = lpUIPrivate->hCMenuWnd;

    // Unlock before we call into TrackPopupMenu().
    GlobalUnlock(hUIPrivate);

    if (!hCMenuWnd) {
        goto ContextMenuUnlockIMC;
    }

    hMenu = LoadMenu(hInst, MAKEINTRESOURCE(IDMN_CONTEXT_MENU));
    hCMenu = GetSubMenu(hMenu, 0);

    SetWindowLongPtr(hCMenuWnd, CMENU_HUIWND, (LONG_PTR)hUIWnd);
    SetWindowLongPtr(hCMenuWnd, CMENU_MENU, (LONG_PTR)hMenu);

    if (!(lpIMC->fdwConversion & IME_CMODE_NATIVE)) {
        EnableMenuItem(hCMenu, IDM_SYMBOL, MF_BYCOMMAND|MF_GRAYED);
        EnableMenuItem(hCMenu, IDM_SOFTKBD, MF_BYCOMMAND|MF_GRAYED);
    } else if (lpIMC->fOpen) {
        // can not go into symbol mode
        if (lpIMC->fdwConversion & IME_CMODE_EUDC) {
            EnableMenuItem(hCMenu, IDM_SYMBOL, MF_BYCOMMAND|MF_GRAYED);
        } else {
            if (lpIMC->fdwConversion & IME_CMODE_SYMBOL) {
                CheckMenuItem(hCMenu, IDM_SYMBOL, MF_BYCOMMAND|MF_CHECKED);
            }
        }

        if (lpIMC->fdwConversion & IME_CMODE_SOFTKBD) {
            CheckMenuItem(hCMenu, IDM_SOFTKBD, MF_BYCOMMAND|MF_CHECKED);
        }
    } else {
        EnableMenuItem(hCMenu, IDM_SYMBOL, MF_BYCOMMAND|MF_GRAYED);
        EnableMenuItem(hCMenu, IDM_SOFTKBD, MF_BYCOMMAND|MF_GRAYED);
    }

    TrackPopupMenu(hCMenu, TPM_RIGHTBUTTON, x, y, 0,
                   hCMenuWnd, NULL);

    hMenu = (HMENU)GetWindowLongPtr(hCMenuWnd, CMENU_MENU);
    if (hMenu) {
        SetWindowLongPtr(hCMenuWnd, CMENU_MENU, (LONG_PTR)NULL);
        DestroyMenu(hMenu);
    }

ContextMenuUnlockIMC:
    ImmUnlockIMC(hIMC);

    return;
}

#if 1 // MultiMonitor support

/**********************************************************************/
/* ImeMonitorWorkAreaFromWindow()                                     */
/**********************************************************************/
RECT PASCAL ImeMonitorWorkAreaFromWindow(
    HWND hAppWnd)
{
    HMONITOR hMonitor;

    hMonitor = MonitorFromWindow(hAppWnd, MONITOR_DEFAULTTONEAREST);

    if (hMonitor) {
        MONITORINFO sMonitorInfo;

        sMonitorInfo.cbSize = sizeof(sMonitorInfo);
        // init a default value to avoid GetMonitorInfo fails
        sMonitorInfo.rcWork = sImeG.rcWorkArea;
#ifdef UNICODE
        GetMonitorInfoW(hMonitor, &sMonitorInfo);
#else
        GetMonitorInfoA(hMonitor, &sMonitorInfo);
#endif
        return sMonitorInfo.rcWork;
    } else {
        return sImeG.rcWorkArea;
    }
}

/**********************************************************************/
/* ImeMonitorWorkAreaFromPoint()                                      */
/**********************************************************************/
RECT PASCAL ImeMonitorWorkAreaFromPoint(
    POINT ptPoint)
{
    HMONITOR hMonitor;

    hMonitor = MonitorFromPoint(ptPoint, MONITOR_DEFAULTTONEAREST);

    if (hMonitor) {
        MONITORINFO sMonitorInfo;

        sMonitorInfo.cbSize = sizeof(sMonitorInfo);
        // init a default value to avoid GetMonitorInfo fails
        sMonitorInfo.rcWork = sImeG.rcWorkArea;
#ifdef UNICODE
        GetMonitorInfoW(hMonitor, &sMonitorInfo);
#else
        GetMonitorInfoA(hMonitor, &sMonitorInfo);
#endif
        return sMonitorInfo.rcWork;
    } else {
        return sImeG.rcWorkArea;
    }
}


/**********************************************************************/
/* ImeMonitorWorkAreaFromRect()                                       */
/**********************************************************************/
RECT PASCAL ImeMonitorWorkAreaFromRect(
    LPRECT lprcRect)
{
    HMONITOR hMonitor;

    hMonitor = MonitorFromRect(lprcRect, MONITOR_DEFAULTTONEAREST);

    if (hMonitor) {
        MONITORINFO sMonitorInfo;

        sMonitorInfo.cbSize = sizeof(sMonitorInfo);
        // init a default value to avoid GetMonitorInfo fails
        sMonitorInfo.rcWork = sImeG.rcWorkArea;

#ifdef UNICODE
        GetMonitorInfoW(hMonitor, &sMonitorInfo);
#else
        GetMonitorInfoA(hMonitor, &sMonitorInfo);
#endif
        return sMonitorInfo.rcWork;
    } else {
        return sImeG.rcWorkArea;
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\ui.c ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    UI.c
    
++*/

#include <windows.h>
#include <immdev.h>
#include "imeattr.h"
#include "imedefs.h"
#if defined(UNIIME)
#include "uniime.h"
#endif

/**********************************************************************/
/* CreateUIWindow()                                                   */
/**********************************************************************/
void PASCAL CreateUIWindow(             // create composition window
#if defined(UNIIME)
    LPIMEL lpImeL,
#endif
    HWND   hUIWnd)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    // create storage for UI setting
    hUIPrivate = GlobalAlloc(GHND, sizeof(UIPRIV));
    if (!hUIPrivate) {     // Oh! Oh!
        return;
    }

    SetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE, (LONG_PTR)hUIPrivate);

    // set the default position for UI window, it is hide now
    SetWindowPos(hUIWnd, NULL, 0, 0, 0, 0, SWP_NOACTIVATE|SWP_NOZORDER);

    ShowWindow(hUIWnd, SW_SHOWNOACTIVATE);

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw candidate window
        return;
    }

    if (lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI) {
        lpUIPrivate->fdwSetContext |= ISC_OFF_CARET_UI;
    }

    GlobalUnlock(hUIPrivate);

    return;
}

/**********************************************************************/
/* DestroyUIWindow()                                                  */
/**********************************************************************/
void PASCAL DestroyUIWindow(            // destroy composition window
    HWND hUIWnd)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {     // Oh! Oh!
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {    // Oh! Oh!
        return;
    }

    if (lpUIPrivate->hCMenuWnd) {
        SetWindowLongPtr(lpUIPrivate->hCMenuWnd, CMENU_HUIWND,(LONG_PTR)0);
        PostMessage(lpUIPrivate->hCMenuWnd, WM_USER_DESTROY, 0, 0);
    }

#if !defined(ROMANIME)
    // composition window need to be destroyed
    if (lpUIPrivate->hCompWnd) {
        DestroyWindow(lpUIPrivate->hCompWnd);
    }

    // candidate window need to be destroyed
    if (lpUIPrivate->hCandWnd) {
        DestroyWindow(lpUIPrivate->hCandWnd);
    }
#endif

    // status window need to be destroyed
    if (lpUIPrivate->hStatusWnd) {
        DestroyWindow(lpUIPrivate->hStatusWnd);
    }

#if !defined(ROMANIME) && !defined(WINAR30)
    // soft keyboard window need to be destroyed
    if (lpUIPrivate->hSoftKbdWnd) {
        ImmDestroySoftKeyboard(lpUIPrivate->hSoftKbdWnd);
    }
#endif

    GlobalUnlock(hUIPrivate);

    // free storage for UI settings
    GlobalFree(hUIPrivate);

    return;
}

#if !defined(ROMANIME) && !defined(WINAR30)
/**********************************************************************/
/* GetSoftKbdWnd                                                      */
/* Return Value :                                                     */
/*      window handle of composition                                  */
/**********************************************************************/
HWND PASCAL GetSoftKbdWnd(
    HWND hUIWnd)                // UI window
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;
    HWND     hSoftKbdWnd;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {          // can not darw candidate window
        return (HWND)NULL;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw candidate window
        return (HWND)NULL;
    }

    hSoftKbdWnd = lpUIPrivate->hSoftKbdWnd;

    GlobalUnlock(hUIPrivate);
    return (hSoftKbdWnd);
}

/**********************************************************************/
/* ShowSoftKbd                                                        */
/**********************************************************************/
void PASCAL ShowSoftKbd(   // Show the soft keyboard window
    HWND hUIWnd,
    int  nShowSoftKbdCmd)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {          // can not darw status window
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw status window
        return;
    }

    if (lpUIPrivate->nShowSoftKbdCmd == nShowSoftKbdCmd) {
        goto SwSftKbNoChange;
    }

    if (nShowSoftKbdCmd == SW_HIDE) {
        lpUIPrivate->fdwSetContext &= ~(ISC_HIDE_SOFTKBD);
    }

    if (!lpUIPrivate->hSoftKbdWnd) {
        // not in show status window mode
    } else {
        ImmShowSoftKeyboard(lpUIPrivate->hSoftKbdWnd, nShowSoftKbdCmd);
        lpUIPrivate->nShowSoftKbdCmd = nShowSoftKbdCmd;
    }

SwSftKbNoChange:
    GlobalUnlock(hUIPrivate);
    return;
}

/**********************************************************************/
/* CheckSoftKbdPosition()                                             */
/**********************************************************************/
void PASCAL CheckSoftKbdPosition(
    LPUIPRIV       lpUIPrivate,
    LPINPUTCONTEXT lpIMC)
{
#if 0 // MultiMonitor support
    UINT fPortionBits = 0;
    UINT fPortionTest;
    int  xPortion, yPortion, nPortion;
    RECT rcWnd;

    // portion of dispaly
    // 0  1
    // 2  3

    if (lpUIPrivate->hCompWnd) {
        GetWindowRect(lpUIPrivate->hCompWnd, &rcWnd);

        if (rcWnd.left > sImeG.rcWorkArea.right / 2) {
            xPortion = 1;
        } else {
            xPortion = 0;
        }

        if (rcWnd.top > sImeG.rcWorkArea.bottom / 2) {
            yPortion = 1;
        } else {
            yPortion = 0;
        }

        fPortionBits |= 0x0001 << (yPortion * 2 + xPortion);
    }

    if (lpUIPrivate->hStatusWnd) {
        GetWindowRect(lpUIPrivate->hStatusWnd, &rcWnd);

        if (rcWnd.left > sImeG.rcWorkArea.right / 2) {
            xPortion = 1;
        } else {
            xPortion = 0;
        }

        if (rcWnd.top > sImeG.rcWorkArea.bottom / 2) {
            yPortion = 1;
        } else {
            yPortion = 0;
        }

        fPortionBits |= 0x0001 << (yPortion * 2 + xPortion);
    }

    GetWindowRect(lpUIPrivate->hSoftKbdWnd, &rcWnd);

    // start from portion 3
    for (nPortion = 3, fPortionTest = 0x0008; fPortionTest;
        nPortion--, fPortionTest >>= 1) {
        if (fPortionTest & fPortionBits) {
            // someone here!
            continue;
        }

        if (nPortion % 2) {
            lpIMC->ptSoftKbdPos.x = sImeG.rcWorkArea.right -
                (rcWnd.right - rcWnd.left) - UI_MARGIN;
        } else {
            lpIMC->ptSoftKbdPos.x = sImeG.rcWorkArea.left;
        }

        if (nPortion / 2) {
            lpIMC->ptSoftKbdPos.y = sImeG.rcWorkArea.bottom -
                (rcWnd.bottom - rcWnd.top) - UI_MARGIN;
        } else {
            lpIMC->ptSoftKbdPos.y = sImeG.rcWorkArea.top;
        }

        lpIMC->fdwInit |= INIT_SOFTKBDPOS;

        break;
    }
#else
    RECT rcWorkArea, rcWnd;

    GetWindowRect(lpUIPrivate->hSoftKbdWnd, &rcWnd);

    rcWorkArea = ImeMonitorWorkAreaFromWindow(lpIMC->hWnd);

    lpIMC->ptSoftKbdPos.x = rcWorkArea.right -
        (rcWnd.right - rcWnd.left) - UI_MARGIN;

    lpIMC->ptSoftKbdPos.y = rcWorkArea.bottom -
        (rcWnd.bottom - rcWnd.top) - UI_MARGIN;
#endif

    return;
}

/**********************************************************************/
/* SetSoftKbdData()                                                   */
/**********************************************************************/
void PASCAL SetSoftKbdData(
#if defined(UNIIME)
    LPIMEL         lpImeL,
#endif
    HWND           hSoftKbdWnd,
    LPINPUTCONTEXT lpIMC)
{
    int         i;
    SOFTKBDDATA sSoftKbdData;

    sSoftKbdData.uCount = 1;

    // initialize the char array to 0s
    for (i = 0; i < sizeof(sSoftKbdData.wCode)/sizeof(WORD); i++) {
        sSoftKbdData.wCode[0][i] = 0;
    }

    for (i = 0; i < 0x41; i++) {
        BYTE bVirtKey;

        bVirtKey = bChar2VirtKey[i];

        if (!bVirtKey) {
            continue;
        }

#if defined(ROMANIME) || defined(WINAR30)
        {
#else
        if (lpIMC->fdwConversion & IME_CMODE_SYMBOL) {
            sSoftKbdData.wCode[0][bVirtKey] = sImeG.wSymbol[i];
        } else {
#endif
#if defined(PHON)
            BYTE     bStandardChar;
#endif
            register short iSeq;

#if defined(PHON)
            {
                bStandardChar = bStandardLayout[lpImeL->nReadLayout][i];
            }

            iSeq = lpImeL->wChar2SeqTbl[bStandardChar - ' '];
#else
            iSeq = lpImeL->wChar2SeqTbl[i];
#endif
            if (!iSeq) {
                continue;
            }

            sSoftKbdData.wCode[0][bVirtKey] =
#ifdef UNICODE
                lpImeL->wSeq2CompTbl[iSeq];
#else
                HIBYTE(lpImeL->wSeq2CompTbl[iSeq]) |
                (LOBYTE(lpImeL->wSeq2CompTbl[iSeq]) << 8);
#endif
        }
    }

    if (sImeG.fDiffSysCharSet) {
        LOGFONT lfFont;

        GetObject(GetStockObject(SYSTEM_FONT), sizeof(lfFont), &lfFont);

        lfFont.lfCharSet = NATIVE_CHARSET;
        lfFont.lfFaceName[0] = TEXT('\0');

        SendMessage(hSoftKbdWnd, WM_IME_CONTROL, IMC_SETSOFTKBDFONT,
            (LPARAM)&lfFont);
    }

    SendMessage(hSoftKbdWnd, WM_IME_CONTROL, IMC_SETSOFTKBDDATA,
        (LPARAM)&sSoftKbdData);

#if defined(PHON)
    SendMessage(hSoftKbdWnd, WM_IME_CONTROL, IMC_SETSOFTKBDSUBTYPE,
        lpImeL->nReadLayout);
#endif

    return;
}

/**********************************************************************/
/* UpdateSoftKbd()                                                    */
/**********************************************************************/
void PASCAL UpdateSoftKbd(
#if defined(UNIIME)
    LPIMEL lpImeL,
#endif
    HWND   hUIWnd)
{
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    HGLOBAL        hUIPrivate;
    LPUIPRIV       lpUIPrivate;

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return;
    }

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {          // can not darw soft keyboard window
        ImmUnlockIMC(hIMC);
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw soft keyboard window
        ImmUnlockIMC(hIMC);
        return;
    }

    if (!(lpIMC->fdwConversion & IME_CMODE_SOFTKBD)) {
        if (lpUIPrivate->hSoftKbdWnd) {
            ImmDestroySoftKeyboard(lpUIPrivate->hSoftKbdWnd);
            lpUIPrivate->hSoftKbdWnd = NULL;
        }

        lpUIPrivate->nShowSoftKbdCmd = SW_HIDE;
    } else if (!lpIMC->fOpen) {
        if (lpUIPrivate->nShowSoftKbdCmd != SW_HIDE) {
            ShowSoftKbd(hUIWnd, SW_HIDE);
        }
    } else if ((lpIMC->fdwConversion & (IME_CMODE_NATIVE|IME_CMODE_CHARCODE|
        IME_CMODE_NOCONVERSION)) == IME_CMODE_NATIVE) {
        if (!lpUIPrivate->hSoftKbdWnd) {
            HWND hInsertWnd;

            // create soft keyboard
            lpUIPrivate->hSoftKbdWnd =
                ImmCreateSoftKeyboard(SOFTKEYBOARD_TYPE_T1, hUIWnd,
                0, 0);

            if (lpUIPrivate->hStatusWnd) {
                hInsertWnd = lpUIPrivate->hStatusWnd;
            } else if (lpUIPrivate->hCompWnd) {
                hInsertWnd = lpUIPrivate->hCompWnd;
            } else if (lpUIPrivate->hCandWnd) {
                hInsertWnd = lpUIPrivate->hCandWnd;
            } else {
                hInsertWnd = NULL;
            }

            if (!hInsertWnd) {
            } else if (lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI) {
                // insert soft keyboard in front of other UI
                SetWindowPos(hInsertWnd, lpUIPrivate->hSoftKbdWnd,
                    0, 0, 0, 0,
                    SWP_NOACTIVATE|SWP_NOMOVE|SWP_NOSIZE);
            } else {
                // insert soft keyboard behind other UI
                SetWindowPos(lpUIPrivate->hSoftKbdWnd, hInsertWnd,
                    0, 0, 0, 0,
                    SWP_NOACTIVATE|SWP_NOMOVE|SWP_NOSIZE);
            }
        }

        if (!(lpIMC->fdwInit & INIT_SOFTKBDPOS)) {
            CheckSoftKbdPosition(lpUIPrivate, lpIMC);
        }

        SetSoftKbdData(
#if defined(UNIIME)
            lpImeL,
#endif
            lpUIPrivate->hSoftKbdWnd, lpIMC);

        if (lpUIPrivate->nShowSoftKbdCmd == SW_HIDE) {
            SetWindowPos(lpUIPrivate->hSoftKbdWnd, NULL,
                lpIMC->ptSoftKbdPos.x, lpIMC->ptSoftKbdPos.y,
                0, 0, SWP_NOACTIVATE|SWP_NOSIZE|SWP_NOZORDER);

            // only show, if the application want to show it
            if (lpUIPrivate->fdwSetContext & ISC_SHOW_SOFTKBD) {
                ShowSoftKbd(hUIWnd, SW_SHOWNOACTIVATE);
            }
        }
    } else {
        if (lpUIPrivate->nShowSoftKbdCmd != SW_HIDE) {
            ShowSoftKbd(hUIWnd, SW_HIDE);
        }
    }

    GlobalUnlock(hUIPrivate);
    ImmUnlockIMC(hIMC);

    return;
}

/**********************************************************************/
/* SoftKbdDestryed()                                                  */
/**********************************************************************/
void PASCAL SoftKbdDestroyed(           // soft keyboard window
                                        // already destroyed
    HWND hUIWnd)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {     // Oh! Oh!
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {    // Oh! Oh!
        return;
    }

    lpUIPrivate->hSoftKbdWnd = NULL;

    GlobalUnlock(hUIPrivate);
}
#endif

/**********************************************************************/
/* StatusWndMsg()                                                     */
/**********************************************************************/
void PASCAL StatusWndMsg(       // set the show hide state and
                                // show/hide the status window
#if defined(UNIIME)
    LPINSTDATAL lpInstL,
    LPIMEL      lpImeL,
#endif
    HWND        hUIWnd,
    BOOL        fOn)
{
    HGLOBAL  hUIPrivate;
    HIMC     hIMC;
    HWND     hStatusWnd;

    register LPUIPRIV lpUIPrivate;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {
        return;
    }

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);

    if (fOn) {
        lpUIPrivate->fdwSetContext |= ISC_OPEN_STATUS_WINDOW;

        if (!lpUIPrivate->hStatusWnd) {
            OpenStatus(
#if defined(UNIIME)
                lpInstL, lpImeL,
#endif
                hUIWnd);
        }
    } else {
        lpUIPrivate->fdwSetContext &= ~(ISC_OPEN_STATUS_WINDOW);
    }

    hStatusWnd = lpUIPrivate->hStatusWnd;

    GlobalUnlock(hUIPrivate);

    if (!hStatusWnd) {
        return;
    }

    if (!fOn) {
#if !defined(ROMANIME)
        register DWORD fdwSetContext;

        fdwSetContext = lpUIPrivate->fdwSetContext &
            (ISC_SHOWUICOMPOSITIONWINDOW|ISC_HIDE_COMP_WINDOW);

        if (fdwSetContext == ISC_HIDE_COMP_WINDOW) {
            ShowComp(
#if defined(UNIIME)
                lpImeL,
#endif
                hUIWnd, SW_HIDE);
        }

        fdwSetContext = lpUIPrivate->fdwSetContext &
            (ISC_SHOWUICANDIDATEWINDOW|ISC_HIDE_CAND_WINDOW);

        if (fdwSetContext == ISC_HIDE_CAND_WINDOW) {
            ShowCand(
#if defined(UNIIME)
                lpImeL,
#endif
                hUIWnd, SW_HIDE);
        }

#if !defined(WINAR30)
        fdwSetContext = lpUIPrivate->fdwSetContext &
            (ISC_SHOW_SOFTKBD|ISC_HIDE_SOFTKBD);

        if (fdwSetContext == ISC_HIDE_SOFTKBD) {
            lpUIPrivate->fdwSetContext &= ~(ISC_HIDE_SOFTKBD);
            ShowSoftKbd(hUIWnd, SW_HIDE);
        }
#endif
#endif

        ShowStatus(
#if defined(UNIIME)
            lpImeL,
#endif
            hUIWnd, SW_HIDE);
    } else if (hIMC) {
        ShowStatus(
#if defined(UNIIME)
            lpImeL,
#endif
            hUIWnd, SW_SHOWNOACTIVATE);
    } else {
        ShowStatus(
#if defined(UNIIME)
            lpImeL,
#endif
            hUIWnd, SW_HIDE);
    }

    return;
}

/**********************************************************************/
/* ShowUI()                                                           */
/**********************************************************************/
void PASCAL ShowUI(             // show the sub windows
#if defined(UNIIME)
    LPINSTDATAL lpInstL,
    LPIMEL      lpImeL,
#endif
    HWND   hUIWnd,
    int    nShowCmd)
{
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    LPPRIVCONTEXT  lpImcP;
    HGLOBAL        hUIPrivate;
    LPUIPRIV       lpUIPrivate;

    if (nShowCmd == SW_HIDE) {
    } else if (!(hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC))) {
        nShowCmd = SW_HIDE;
    } else if (!(lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC))) {
        nShowCmd = SW_HIDE;
    } else if (!(lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate))) {
        ImmUnlockIMC(hIMC);
        nShowCmd = SW_HIDE;
    } else {
    }

    if (nShowCmd == SW_HIDE) {
        ShowStatus(
#if defined(UNIIME)
            lpImeL,
#endif
            hUIWnd, nShowCmd);

#if !defined(ROMANIME)
        ShowComp(
#if defined(UNIIME)
            lpImeL,
#endif
            hUIWnd, nShowCmd);

        ShowCand(
#if defined(UNIIME)
            lpImeL,
#endif
            hUIWnd, nShowCmd);

#if !defined(WINAR30)
        ShowSoftKbd(hUIWnd, nShowCmd);
#endif
#endif
        return;
    }

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {          // can not darw status window
        goto ShowUIUnlockIMCC;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw status window
        goto ShowUIUnlockIMCC;
    }

#if !defined(ROMANIME)
    if ((lpUIPrivate->fdwSetContext & ISC_SHOWUICOMPOSITIONWINDOW) &&
        (lpImcP->fdwImeMsg & MSG_ALREADY_START)) {
        if (lpUIPrivate->hCompWnd) {
            if ((UINT)GetWindowLong(lpUIPrivate->hCompWnd, UI_MOVE_XY) !=
                lpImeL->nRevMaxKey) {
                ChangeCompositionSize(
#if defined(UNIIME)
                    lpImeL,
#endif
                    hUIWnd);
            }

            if (lpUIPrivate->nShowCompCmd != SW_HIDE) {
                // some time the WM_ERASEBKGND is eaten by the app
                RedrawWindow(lpUIPrivate->hCompWnd, NULL, NULL,
                    RDW_FRAME|RDW_INVALIDATE|RDW_ERASE);
            }

            SendMessage(lpUIPrivate->hCompWnd, WM_IME_NOTIFY,
                IMN_SETCOMPOSITIONWINDOW, 0);

            if (lpUIPrivate->nShowCompCmd == SW_HIDE) {
                ShowComp(
#if defined(UNIIME)
                    lpImeL,
#endif
                    hUIWnd, nShowCmd);
            }
        } else {
            StartComp(
#if defined(UNIIME)
                lpInstL, lpImeL,
#endif
                hUIWnd);
        }
    } else if (lpUIPrivate->nShowCompCmd == SW_HIDE) {
    } else if (lpUIPrivate->fdwSetContext & ISC_OPEN_STATUS_WINDOW) {
        // delay the hide with status window
        lpUIPrivate->fdwSetContext |= ISC_HIDE_COMP_WINDOW;
    } else {
        ShowComp(
#if defined(UNIIME)
            lpImeL,
#endif
            hUIWnd, SW_HIDE);
    }

    if ((lpUIPrivate->fdwSetContext & ISC_SHOWUICANDIDATEWINDOW) &&
        (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN)) {
        if (lpUIPrivate->hCandWnd) {
            if (lpUIPrivate->nShowCandCmd != SW_HIDE) {
                // some time the WM_ERASEBKGND is eaten by the app
                RedrawWindow(lpUIPrivate->hCandWnd, NULL, NULL,
                    RDW_FRAME|RDW_INVALIDATE|RDW_ERASE);
            }

            SendMessage(lpUIPrivate->hCandWnd, WM_IME_NOTIFY,
                IMN_SETCANDIDATEPOS, 0x0001);

            if (lpUIPrivate->nShowCandCmd == SW_HIDE) {
                ShowCand(
#if defined(UNIIME)
                    lpImeL,
#endif
                    hUIWnd, nShowCmd);
            }
        } else {
            OpenCand(
#if defined(UNIIME)
                lpInstL, lpImeL,
#endif
                hUIWnd);
        }
    } else if (lpUIPrivate->nShowCandCmd == SW_HIDE) {
    } else if (lpUIPrivate->fdwSetContext & ISC_OPEN_STATUS_WINDOW) {
        // delay the hide with status window
        lpUIPrivate->fdwSetContext |= ISC_HIDE_CAND_WINDOW;
    } else {
        ShowCand(
#if defined(UNIIME)
            lpImeL,
#endif
            hUIWnd, SW_HIDE);
    }

    if (lpIMC->fdwInit & INIT_SENTENCE) {
        // app set the sentence mode so we should not change it
        // with the configure option set by end user
    } else if (lpImeL->fdwModeConfig & MODE_CONFIG_PREDICT) {
        if (!(lpIMC->fdwSentence & IME_SMODE_PHRASEPREDICT)) {
            DWORD fdwSentence;

            fdwSentence = lpIMC->fdwSentence;
            *(LPWORD)&fdwSentence |= IME_SMODE_PHRASEPREDICT;

            ImmSetConversionStatus(hIMC, lpIMC->fdwConversion, fdwSentence);
        }
    } else {
        if (lpIMC->fdwSentence & IME_SMODE_PHRASEPREDICT) {
            DWORD fdwSentence;

            fdwSentence = lpIMC->fdwSentence;
            *(LPWORD)&fdwSentence &= ~(IME_SMODE_PHRASEPREDICT);

            ImmSetConversionStatus(hIMC, lpIMC->fdwConversion, fdwSentence);
        }
    }
#endif

    if (lpUIPrivate->fdwSetContext & ISC_OPEN_STATUS_WINDOW) {
        if (!lpUIPrivate->hStatusWnd) {
            OpenStatus(
#if defined(UNIIME)
                lpInstL, lpImeL,
#endif
                hUIWnd);
        }

        if (lpUIPrivate->nShowStatusCmd != SW_HIDE) {
            // some time the WM_ERASEBKGND is eaten by the app
            RedrawWindow(lpUIPrivate->hStatusWnd, NULL, NULL,
                RDW_FRAME|RDW_INVALIDATE|RDW_ERASE);
        }

        SendMessage(lpUIPrivate->hStatusWnd, WM_IME_NOTIFY,
            IMN_SETSTATUSWINDOWPOS, 0);
        if (lpUIPrivate->nShowStatusCmd == SW_HIDE) {
            ShowStatus(
#if defined(UNIIME)
                lpImeL,
#endif
                hUIWnd, nShowCmd);
        }
    } else if (lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI) {
        if (!lpUIPrivate->hStatusWnd) {
#if !defined(ROMANIME)
        } else if (lpUIPrivate->hCompWnd || lpUIPrivate->hCandWnd) {
            int  nCurrShowState;
            RECT rcRect;

            nCurrShowState = lpUIPrivate->nShowCompCmd;
            nCurrShowState |= lpUIPrivate->nShowCandCmd;

            if (nCurrShowState == SW_HIDE) {
                ShowStatus(
#if defined(UNIIME)
                    lpImeL,
#endif
                    hUIWnd, SW_HIDE);
            }

            rcRect = lpImeL->rcStatusText;
            // off by 1
            rcRect.right += 1;
            rcRect.bottom += 1;

            RedrawWindow(lpUIPrivate->hStatusWnd, &rcRect, NULL,
                RDW_FRAME|RDW_INVALIDATE);

            DestroyStatusWindow(lpUIPrivate->hStatusWnd);
#endif
        } else {
            DestroyWindow(lpUIPrivate->hStatusWnd);
        }
    } else if (lpUIPrivate->hStatusWnd) {
        DestroyWindow(lpUIPrivate->hStatusWnd);
    } else {
    }

#if !defined(ROMANIME)
#if defined(WINAR30)
    if (lpImcP->iImeState == CST_INIT) {
    } else if (lpImcP->iImeState == CST_CHOOSE) {
    } else if (lpImeL->fdwModeConfig & MODE_CONFIG_QUICK_KEY) {
    } else if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
        // turn off quick key candidate
        lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CLOSE_CANDIDATE) &
            ~(MSG_OPEN_CANDIDATE|MSG_CHANGE_CANDIDATE);
        GenerateMessage(hIMC, lpIMC, lpImcP);
    } else if (lpImcP->fdwImeMsg & (MSG_OPEN_CANDIDATE|MSG_CHANGE_CANDIDATE)) {
        // turn off quick key candidate
        lpImcP->fdwImeMsg &= ~(MSG_OPEN_CANDIDATE|MSG_CHANGE_CANDIDATE);
    } else {
    }
#else
    if (!lpIMC->fOpen) {
        if (lpUIPrivate->nShowCompCmd != SW_HIDE) {
            ShowSoftKbd(hUIWnd, SW_HIDE);
        }
    } else if ((lpUIPrivate->fdwSetContext & ISC_SHOW_SOFTKBD) &&
        (lpIMC->fdwConversion & (IME_CMODE_NATIVE|IME_CMODE_CHARCODE|
        IME_CMODE_NOCONVERSION|IME_CMODE_SOFTKBD)) ==
        (IME_CMODE_NATIVE|IME_CMODE_SOFTKBD)) {
        if (!lpUIPrivate->hSoftKbdWnd) {
            UpdateSoftKbd(
#if defined(UNIIME)
                lpImeL,
#endif
                hUIWnd);
#if defined(PHON)
        } else if ((UINT)SendMessage(lpUIPrivate->hSoftKbdWnd,
            WM_IME_CONTROL, IMC_GETSOFTKBDSUBTYPE, 0) !=
            lpImeL->nReadLayout) {

            UpdateSoftKbd(hUIWnd);
#endif
        } else if (lpUIPrivate->nShowSoftKbdCmd == SW_HIDE) {
            ShowSoftKbd(hUIWnd, nShowCmd);
        } else if (lpUIPrivate->hCacheIMC != hIMC) {
            UpdateSoftKbd(
#if defined(UNIIME)
                lpImeL,
#endif
                hUIWnd);
        } else {
            RedrawWindow(lpUIPrivate->hSoftKbdWnd, NULL, NULL,
                RDW_FRAME|RDW_INVALIDATE);
        }
    } else if (lpUIPrivate->nShowSoftKbdCmd == SW_HIDE) {
    } else if (lpUIPrivate->fdwSetContext & ISC_OPEN_STATUS_WINDOW) {
        // delay the hide with status window
        lpUIPrivate->fdwSetContext |= ISC_HIDE_SOFTKBD;
    } else {
        ShowSoftKbd(hUIWnd, SW_HIDE);
    }
#endif
#endif

    // we switch to this hIMC
    lpUIPrivate->hCacheIMC = hIMC;

    GlobalUnlock(hUIPrivate);

ShowUIUnlockIMCC:
    ImmUnlockIMCC(lpIMC->hPrivate);
    ImmUnlockIMC(hIMC);

    return;
}

/**********************************************************************/
/* ShowGuideLine                                                      */
/**********************************************************************/
void PASCAL ShowGuideLine(
#if defined(UNIIME)
    LPIMEL lpImeL,
#endif
    HWND   hUIWnd)
{
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    LPGUIDELINE    lpGuideLine;
#if !defined(ROMANIME)
    HWND           hCompWnd;
#endif

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return;
    }

    lpGuideLine = (LPGUIDELINE)ImmLockIMCC(lpIMC->hGuideLine);

    if (!lpGuideLine) {
    } else if (lpGuideLine->dwLevel == GL_LEVEL_ERROR) {
        MessageBeep((UINT)-1);
        MessageBeep((UINT)-1);
    } else if (lpGuideLine->dwLevel == GL_LEVEL_WARNING) {
        MessageBeep((UINT)-1);
#if !defined(ROMANIME)
    } else if (hCompWnd = GetCompWnd(hUIWnd)) {
        RECT rcRect;

        rcRect = lpImeL->rcCompText;
        // off by 1
        rcRect.right += 1;
        rcRect.bottom += 1;

        RedrawWindow(hCompWnd, &rcRect, NULL, RDW_INVALIDATE);
#endif
    } else {
    }

    ImmUnlockIMCC(lpIMC->hGuideLine);
    ImmUnlockIMC(hIMC);

    return;
}

#if !defined(ROMANIME)
/**********************************************************************/
/* UpdatePhrasePrediction()                                           */
/**********************************************************************/
void PASCAL UpdatePhrasePrediction(
#if defined(UNIIME)
    LPIMEL lpImeL,
#endif
    HWND   hUIWnd)
{
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return;
    }

    if (lpImeL->fdwModeConfig & MODE_CONFIG_PREDICT) {
        if (!(lpIMC->fdwSentence & IME_SMODE_PHRASEPREDICT)) {
            DWORD fdwSentence;

            fdwSentence = lpIMC->fdwSentence;
            *(LPWORD)&fdwSentence |= IME_SMODE_PHRASEPREDICT;

            ImmSetConversionStatus(hIMC, lpIMC->fdwConversion, fdwSentence);
        }
    } else {
        if (lpIMC->fdwSentence & IME_SMODE_PHRASEPREDICT) {
            DWORD fdwSentence;

            fdwSentence = lpIMC->fdwSentence;
            *(LPWORD)&fdwSentence &= ~(IME_SMODE_PHRASEPREDICT);

            ImmSetConversionStatus(hIMC, lpIMC->fdwConversion, fdwSentence);
        }
    }

    ImmUnlockIMC(hIMC);

    return;
}

#if defined(WINAR30)
/**********************************************************************/
/* UpdateQuickKey()                                                   */
/**********************************************************************/
void PASCAL UpdateQuickKey(
    HWND hUIWnd)
{
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    LPPRIVCONTEXT  lpImcP;

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return;
    }

    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    if (lpImcP) {
        if (lpImcP->iImeState == CST_INIT) {
        } else if (lpImcP->iImeState == CST_CHOOSE) {
        } else if (lpImeL->fdwModeConfig & MODE_CONFIG_QUICK_KEY) {
        } else if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
            // turn off quick key candidate
            lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CLOSE_CANDIDATE) &
                ~(MSG_OPEN_CANDIDATE|MSG_CHANGE_CANDIDATE);
            GenerateMessage(hIMC, lpIMC, lpImcP);
        } else if (lpImcP->fdwImeMsg & (MSG_OPEN_CANDIDATE|
            MSG_CHANGE_CANDIDATE)) {
            // turn off quick key candidate
            lpImcP->fdwImeMsg &= ~(MSG_OPEN_CANDIDATE|MSG_CHANGE_CANDIDATE);
        } else {
        }

        ImmUnlockIMCC(lpIMC->hPrivate);
    }

    ImmUnlockIMC(hIMC);

    return;
}
#endif
#endif

/**********************************************************************/
/* CMenuDestryed()                                                    */
/**********************************************************************/
void PASCAL CMenuDestroyed(             // context menu window
                                        // already destroyed
    HWND hUIWnd)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {     // Oh! Oh!
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {    // Oh! Oh!
        return;
    }

    lpUIPrivate->hCMenuWnd = NULL;

    GlobalUnlock(hUIPrivate);
}

/**********************************************************************/
/* ToggleUI()                                                         */
/**********************************************************************/
void PASCAL ToggleUI(
#if defined(UNIIME)
    LPINSTDATAL lpInstL,
    LPIMEL      lpImeL,
#endif
    HWND   hUIWnd)
{
    HGLOBAL        hUIPrivate;
    LPUIPRIV       lpUIPrivate;
    DWORD          fdwFlag;
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    LPPRIVCONTEXT  lpImcP;
    HWND           hDestroyWnd;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {
        return;
    }

    if (lpUIPrivate->fdwSetContext & ISC_OFF_CARET_UI) {
        if (lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI) {
            goto ToggleUIOvr;
        } else {
            fdwFlag = 0;
        }
    } else {
        if (lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI) {
            fdwFlag = ISC_OFF_CARET_UI;
        } else {
            goto ToggleUIOvr;
        }
    }

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        goto ToggleUIOvr;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        goto ToggleUIOvr;
    }

    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    if (!lpImcP) {
        goto CreateUIOvr;
    }

    if (fdwFlag & ISC_OFF_CARET_UI) {
        lpUIPrivate->fdwSetContext |= (ISC_OFF_CARET_UI);
    } else {
        lpUIPrivate->fdwSetContext &= ~(ISC_OFF_CARET_UI);
    }

    hDestroyWnd = NULL;

    // we need to dsetroy status first because lpUIPrivate->hStatusWnd
    // may be NULL out in OffCreat UI destroy time
    if (lpUIPrivate->hStatusWnd) {
        if (lpUIPrivate->hStatusWnd != hDestroyWnd) {
            hDestroyWnd = lpUIPrivate->hStatusWnd;
            DestroyWindow(lpUIPrivate->hStatusWnd);
        }
        lpUIPrivate->hStatusWnd = NULL;
    }

#if !defined(ROMANIME)
    // destroy all off caret UI
    if (lpUIPrivate->hCompWnd) {
        if (lpUIPrivate->hCompWnd != hDestroyWnd) {
            hDestroyWnd = lpUIPrivate->hCompWnd;
            DestroyWindow(lpUIPrivate->hCompWnd);
        }
        lpUIPrivate->hCompWnd = NULL;
        lpUIPrivate->nShowCompCmd = SW_HIDE;
    }

    if (lpUIPrivate->hCandWnd) {
        if (lpUIPrivate->hCandWnd != hDestroyWnd) {
            hDestroyWnd = lpUIPrivate->hCandWnd;
            DestroyWindow(lpUIPrivate->hCandWnd);
        }
        lpUIPrivate->hCandWnd = NULL;
        lpUIPrivate->nShowCandCmd = SW_HIDE;
    }
#endif

    if (lpUIPrivate->fdwSetContext & ISC_OPEN_STATUS_WINDOW) {
        OpenStatus(
#if defined(UNIIME)
            lpInstL, lpImeL,
#endif
            hUIWnd);
    }

#if !defined(ROMANIME)
    if (!(lpUIPrivate->fdwSetContext & ISC_SHOWUICOMPOSITIONWINDOW)) {
    } else if (lpImcP->fdwImeMsg & MSG_ALREADY_START) {
        StartComp(
#if defined(UNIIME)
            lpInstL, lpImeL,
#endif
            hUIWnd);
    } else {
    }

    if (!(lpUIPrivate->fdwSetContext & ISC_SHOWUICANDIDATEWINDOW)) {
    } else if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
        if (!(fdwFlag & ISC_OFF_CARET_UI)) {
#if defined(UNIIME)
            UniNotifyIME(lpInstL, lpImeL, hIMC, NI_SETCANDIDATE_PAGESIZE,
                0, CANDPERPAGE);
#else
            NotifyIME(hIMC, NI_SETCANDIDATE_PAGESIZE, 0, CANDPERPAGE);
#endif
        }

        OpenCand(
#if defined(UNIIME)
            lpInstL, lpImeL,
#endif
            hUIWnd);
    } else {
    }

#if !defined(WINAR30)
    if (!(lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI)) {
    } else if (!lpUIPrivate->hSoftKbdWnd) {
    } else {
        HWND hInsertWnd;

        if (lpUIPrivate->hStatusWnd) {
            hInsertWnd = lpUIPrivate->hStatusWnd;
        } else if (lpUIPrivate->hCompWnd) {
            hInsertWnd = lpUIPrivate->hCompWnd;
        } else if (lpUIPrivate->hCandWnd) {
            hInsertWnd = lpUIPrivate->hCandWnd;
        } else {
            hInsertWnd = NULL;
        }

        if (hInsertWnd) {
            // insert soft keyboard in front of other UI
            SetWindowPos(hInsertWnd, lpUIPrivate->hSoftKbdWnd,
                0, 0, 0, 0,
                SWP_NOACTIVATE|SWP_NOMOVE|SWP_NOSIZE);
        }
    }
#endif
#endif

    ImmUnlockIMCC(lpIMC->hPrivate);

CreateUIOvr:
    ImmUnlockIMC(hIMC);

ToggleUIOvr:
    GlobalUnlock(hUIPrivate);
    return;
}

/**********************************************************************/
/* NotifyUI()                                                         */
/**********************************************************************/
void PASCAL NotifyUI(
#if defined(UNIIME)
    LPINSTDATAL lpInstL,
    LPIMEL      lpImeL,
#endif
    HWND        hUIWnd,
    WPARAM      wParam,
    LPARAM      lParam)
{
    HWND hStatusWnd;

    switch (wParam) {
    case IMN_OPENSTATUSWINDOW:
        StatusWndMsg(
#if defined(UNIIME)
            lpInstL, lpImeL,
#endif
            hUIWnd, TRUE);
        break;
    case IMN_CLOSESTATUSWINDOW:
        StatusWndMsg(
#if defined(UNIIME)
            lpInstL, lpImeL,
#endif
            hUIWnd, FALSE);
        break;
#if !defined(ROMANIME)
    case IMN_OPENCANDIDATE:
        if (lParam & 0x00000001) {
            OpenCand(
#if defined(UNIIME)
                lpInstL, lpImeL,
#endif
                hUIWnd);
        }
        break;
    case IMN_CHANGECANDIDATE:
        if (lParam & 0x00000001) {
            HWND hCandWnd;
            RECT rcRect;

            hCandWnd = GetCandWnd(hUIWnd);
            if (!hCandWnd) {
                return;
            }

            if (lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI) {
                CandPageSize(hUIWnd, TRUE);
            }

            rcRect = lpImeL->rcCandText;
            // off by 1
            rcRect.right += 1;
            rcRect.bottom += 1;

            InvalidateRect(hCandWnd, &rcRect, FALSE);

            rcRect = lpImeL->rcCandPrompt;
            // off by 1
            rcRect.right += 1;
            rcRect.bottom += 1;

            InvalidateRect(hCandWnd, &rcRect, TRUE);

            rcRect = lpImeL->rcCandPageText;
            // off by 1
            rcRect.right += 1;
            rcRect.bottom += 1;

            RedrawWindow(hCandWnd, &rcRect, NULL, RDW_INVALIDATE|RDW_ERASE);
        }
        break;
    case IMN_CLOSECANDIDATE:
        if (lParam & 0x00000001) {
            CloseCand(
#if defined(UNIIME)
                lpImeL,
#endif
                hUIWnd);
        }
        break;
    case IMN_SETSENTENCEMODE:
        break;
#endif
    case IMN_SETOPENSTATUS:
    case IMN_SETCONVERSIONMODE:
        hStatusWnd = GetStatusWnd(hUIWnd);
        if (!hStatusWnd) {
            return;
        }

        {
            RECT rcRect;

            rcRect = lpImeL->rcStatusText;
            // off by 1
            rcRect.right += 1;
            rcRect.bottom += 1;

            RedrawWindow(hStatusWnd, &rcRect, NULL, RDW_INVALIDATE);
        }
        break;
#if !defined(ROMANIME)
    case IMN_SETCOMPOSITIONFONT:
        // we are not going to change font, but an IME can do this if it want
        break;
    case IMN_SETCOMPOSITIONWINDOW:
        if (!(lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI)) {
            HWND hCompWnd;

            hCompWnd = GetCompWnd(hUIWnd);
            if (!hCompWnd) {
                return;
            }

            PostMessage(hCompWnd, WM_IME_NOTIFY, wParam, lParam);
        }
        break;
    case IMN_SETCANDIDATEPOS:
        if (!(lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI)) {
            HWND hCandWnd;

            hCandWnd = GetCandWnd(hUIWnd);
            if (!hCandWnd) {
                return;
            }

            PostMessage(hCandWnd, WM_IME_NOTIFY, wParam, lParam);
        }
        break;
#endif
    case IMN_SETSTATUSWINDOWPOS:
        hStatusWnd = GetStatusWnd(hUIWnd);
        if (hStatusWnd) {
            PostMessage(hStatusWnd, WM_IME_NOTIFY, wParam, lParam);
#if !defined(ROMANIME)
        } else if (lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI) {
            if (hStatusWnd = GetCompWnd(hUIWnd)) {
            } else if (hStatusWnd = GetCandWnd(hUIWnd)) {
            } else {
                return;
            }

            PostMessage(hStatusWnd, WM_IME_NOTIFY, wParam, lParam);
#endif
        } else {
        }
        break;
    case IMN_GUIDELINE:
        ShowGuideLine(
#if defined(UNIIME)
            lpImeL,
#endif
            hUIWnd);
        break;
    case IMN_PRIVATE:
        switch (lParam) {
#if !defined(ROMANIME)
        case IMN_PRIVATE_COMPOSITION_SIZE:
            ChangeCompositionSize(
#if defined(UNIIME)
                lpImeL,
#endif
                hUIWnd);
            break;
        case IMN_PRIVATE_UPDATE_PREDICT:
            UpdatePhrasePrediction(
#if defined(UNIIME)
                lpImeL,
#endif
                hUIWnd);
            break;
        case IMN_PRIVATE_PAGEUP:
            if (lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI) {
                CandPageSize(hUIWnd, FALSE);
            }
            break;
#if defined(WINAR30)
        case IMN_PRIVATE_UPDATE_QUICK_KEY:
            UpdateQuickKey(hUIWnd);
            break;
#else
        case IMN_PRIVATE_UPDATE_SOFTKBD:
            UpdateSoftKbd(
#if defined(UNIIME)
                lpImeL,
#endif
                hUIWnd);
            break;
#endif
#endif
        case IMN_PRIVATE_TOGGLE_UI:
            ToggleUI(
#if defined(UNIIME)
                lpInstL, lpImeL,
#endif
                hUIWnd);
            break;
        case IMN_PRIVATE_CMENUDESTROYED:
            CMenuDestroyed(hUIWnd);
            break;
        default:
            break;
        }
        break;
#if !defined(ROMANIME) && !defined(WINAR30)
    case IMN_SOFTKBDDESTROYED:
        SoftKbdDestroyed(hUIWnd);
        break;
#endif
    default:
        break;
    }

    return;
}

/**********************************************************************/
/* UIChange()                                                         */
/**********************************************************************/
LRESULT PASCAL UIChange(
#if defined(UNIIME)
    LPINSTDATAL lpInstL,
    LPIMEL      lpImeL,
#endif
    HWND        hUIWnd)
{
    HGLOBAL     hUIPrivate;
    LPUIPRIV    lpUIPrivate;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {
        return (0L);
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {
        return (0L);
    }

    if (lpUIPrivate->fdwSetContext & ISC_SHOW_UI_ALL) {
        if (lpUIPrivate->fdwSetContext & ISC_OFF_CARET_UI) {
            if (!(lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI)) {
                ToggleUI(
#if defined(UNIIME)
                    lpInstL, lpImeL,
#endif
                    hUIWnd);
            }
        } else {
            if (lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI) {
                ToggleUI(
#if defined(UNIIME)
                    lpInstL, lpImeL,
#endif
                    hUIWnd);
            }
        }

        ShowUI(
#if defined(UNIIME)
            lpInstL, lpImeL,
#endif
            hUIWnd, SW_SHOWNOACTIVATE);
    } else {
        ShowUI(
#if defined(UNIIME)
            lpInstL, lpImeL,
#endif
            hUIWnd, SW_HIDE);
    }

    GlobalUnlock(hUIPrivate);

    return (0L);
}

/**********************************************************************/
/* SetContext()                                                       */
/**********************************************************************/
void PASCAL SetContext(         // the context activated/deactivated
#if defined(UNIIME)
    LPINSTDATAL lpInstL,
    LPIMEL      lpImeL,
#endif
    HWND        hUIWnd,
    BOOL        fOn,
    LPARAM      lShowUI)
{
    HGLOBAL  hUIPrivate;

    register LPUIPRIV lpUIPrivate;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {
        return;
    }

    if (fOn) {
        HIMC           hIMC;
        LPINPUTCONTEXT lpIMC;

#if !defined(ROMANIME)
        register DWORD fdwSetContext;

        lpUIPrivate->fdwSetContext = lpUIPrivate->fdwSetContext &
            ~(ISC_SHOWUIALL|ISC_HIDE_SOFTKBD);

        lpUIPrivate->fdwSetContext |= (lShowUI & ISC_SHOWUIALL) |
            ISC_SHOW_SOFTKBD;

        fdwSetContext = lpUIPrivate->fdwSetContext &
            (ISC_SHOWUICOMPOSITIONWINDOW|ISC_HIDE_COMP_WINDOW);

        if (fdwSetContext == ISC_HIDE_COMP_WINDOW) {
            ShowComp(
#if defined(UNIIME)
                lpImeL,
#endif
                hUIWnd, SW_HIDE);
        } else if (fdwSetContext & ISC_HIDE_COMP_WINDOW) {
            lpUIPrivate->fdwSetContext &= ~(ISC_HIDE_COMP_WINDOW);
        } else {
        }

        fdwSetContext = lpUIPrivate->fdwSetContext &
            (ISC_SHOWUICANDIDATEWINDOW|ISC_HIDE_CAND_WINDOW);

        if (fdwSetContext == ISC_HIDE_CAND_WINDOW) {
            ShowCand(
#if defined(UNIIME)
                lpImeL,
#endif
                hUIWnd, SW_HIDE);
        } else if (fdwSetContext & ISC_HIDE_CAND_WINDOW) {
            lpUIPrivate->fdwSetContext &= ~(ISC_HIDE_CAND_WINDOW);
        } else {
        }
#endif

        hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);

        if (!hIMC) {
            goto SetCxtUnlockUIPriv;
        }

        lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);

        if (!lpIMC) {
            goto SetCxtUnlockUIPriv;
        }

        if (lpIMC->cfCandForm[0].dwIndex != 0) {
            lpIMC->cfCandForm[0].dwStyle = CFS_DEFAULT;
        }

        ImmUnlockIMC(hIMC);
    } else {
        lpUIPrivate->fdwSetContext &= ~ISC_SETCONTEXT_UI;
    }

SetCxtUnlockUIPriv:
    GlobalUnlock(hUIPrivate);

    UIChange(
#if defined(UNIIME)
        lpInstL, lpImeL,
#endif
        hUIWnd);

    return;
}

#if !defined(ROMANIME)
/**********************************************************************/
/* GetCandPos()                                                       */
/**********************************************************************/
LRESULT PASCAL GetCandPos(
    HWND            hUIWnd,
    LPCANDIDATEFORM lpCandForm)
{
    HWND           hCandWnd;
    RECT           rcCandWnd;
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;

    if (lpCandForm->dwIndex != 0) {
        return (1L);
    }

    hCandWnd = GetCandWnd(hUIWnd);

    if (!hCandWnd) {
        return (1L);
    }

    if (!GetWindowRect(hCandWnd, &rcCandWnd)) {
        return (1L);
    }

    lpCandForm->dwStyle = CFS_CANDIDATEPOS;
    lpCandForm->ptCurrentPos = *(LPPOINT)&rcCandWnd;
    lpCandForm->rcArea = rcCandWnd;

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);

    if (!hIMC) {
        return (1L);
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);

    if (!lpIMC) {
        return (1L);
    }

    ScreenToClient(lpIMC->hWnd, &lpCandForm->ptCurrentPos);

    lpCandForm->rcArea.right += lpCandForm->ptCurrentPos.x -
        lpCandForm->rcArea.left;

    lpCandForm->rcArea.bottom += lpCandForm->ptCurrentPos.y -
        lpCandForm->rcArea.top;

    *(LPPOINT)&lpCandForm->rcArea = lpCandForm->ptCurrentPos;

    ImmUnlockIMC(hIMC);

    return (0L);
}

/**********************************************************************/
/* GetCompWindow()                                                    */
/**********************************************************************/
LRESULT PASCAL GetCompWindow(
    HWND              hUIWnd,
    LPCOMPOSITIONFORM lpCompForm)
{
    HWND           hCompWnd;
    RECT           rcCompWnd;
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;

    hCompWnd = GetCompWnd(hUIWnd);

    if (!hCompWnd) {
        return (1L);
    }

    if (!GetWindowRect(hCompWnd, &rcCompWnd)) {
        return (1L);
    }

    lpCompForm->dwStyle = CFS_RECT;
    lpCompForm->ptCurrentPos = *(LPPOINT)&rcCompWnd;
    lpCompForm->rcArea = rcCompWnd;

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);

    if (!hIMC) {
        return (1L);
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);

    if (!lpIMC) {
        return (1L);
    }

    ScreenToClient(lpIMC->hWnd, &lpCompForm->ptCurrentPos);

    lpCompForm->rcArea.right += lpCompForm->ptCurrentPos.x -
        lpCompForm->rcArea.left;

    lpCompForm->rcArea.bottom += lpCompForm->ptCurrentPos.y -
        lpCompForm->rcArea.top;

    *(LPPOINT)&lpCompForm->rcArea = lpCompForm->ptCurrentPos;

    ImmUnlockIMC(hIMC);

    return (0L);
}
#endif

#if 0       // try to use SetContext
/**********************************************************************/
/* SelectIME()                                                        */
/**********************************************************************/
void PASCAL SelectIME(          // switch IMEs
    HWND hUIWnd,
    BOOL fSelect)
{
#if !defined(ROMANIME)
    if (!fSelect) {
        ShowUI(hUIWnd, SW_HIDE);
    } else {
        ShowUI(hUIWnd, SW_SHOWNOACTIVATE);
    }
#endif

    return;
}
#endif

/**********************************************************************/
/* UIWndProc() / UniUIWndProc()                                       */
/**********************************************************************/
#if defined(UNIIME)
LRESULT WINAPI   UniUIWndProc(
    LPINSTDATAL lpInstL,
    LPIMEL      lpImeL,
#else
LRESULT CALLBACK UIWndProc(
#endif
    HWND   hUIWnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (uMsg) {
    case WM_CREATE:
        CreateUIWindow(
#if defined(UNIIME)
            lpImeL,
#endif
            hUIWnd);
        break;
    case WM_DESTROY:
        DestroyUIWindow(hUIWnd);
        break;
#if !defined(ROMANIME)
    case WM_IME_STARTCOMPOSITION:
        // you can create a window as the composition window here
        StartComp(
#if defined(UNIIME)
            lpInstL, lpImeL,
#endif
            hUIWnd);
        break;
    case WM_IME_COMPOSITION:
        if (lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI) {
        } else if (lParam & GCS_RESULTSTR) {
            MoveDefaultCompPosition(
#if defined(UNIIME)
                lpImeL,
#endif
                hUIWnd);
        } else {
        }

        {
            HWND hCompWnd;

            hCompWnd = GetCompWnd(hUIWnd);

            if (hCompWnd) {
                RECT rcRect;

                rcRect = lpImeL->rcCompText;
                // off by 1
                rcRect.right += 1;
                rcRect.bottom += 1;

                RedrawWindow(hCompWnd, &rcRect, NULL, RDW_INVALIDATE);
            }
        }
        break;
    case WM_IME_ENDCOMPOSITION:
        // you can destroy the composition window here
        EndComp(
#if defined(UNIIME)
            lpImeL,
#endif
            hUIWnd);
        break;
#else
    //We shouldn't pass messages below. For FullShape IME.
    case WM_IME_STARTCOMPOSITION:
    case WM_IME_COMPOSITION:
    case WM_IME_ENDCOMPOSITION:
        return (0L);
#endif
    case WM_IME_NOTIFY:
        NotifyUI(
#if defined(UNIIME)
            lpInstL, lpImeL,
#endif
            hUIWnd, wParam, lParam);
        break;
    case WM_IME_SETCONTEXT:
        SetContext(
#if defined(UNIIME)
            lpInstL, lpImeL,
#endif
            hUIWnd, (BOOL)wParam, lParam);
/*
        // When dialog box is opened, IME is disappeded. Change IME Z-order again. bklee
        if (wParam && GetWindowLongPtr(hUIWnd, IMMGWLP_IMC))
            SetWindowPos(hUIWnd, NULL, 0, 0, 0, 0, SWP_NOSIZE|SWP_NOACTIVATE|SWP_NOMOVE);
*/
        break;
    case WM_IME_CONTROL:
        switch (wParam) {
#if !defined(ROMANIME)
        case IMC_GETCANDIDATEPOS:
            return GetCandPos(hUIWnd, (LPCANDIDATEFORM)lParam);
        case IMC_GETCOMPOSITIONWINDOW:
            return GetCompWindow(hUIWnd, (LPCOMPOSITIONFORM)lParam);
#endif
        case IMC_GETSOFTKBDPOS:
        case IMC_SETSOFTKBDPOS:
#if !defined(ROMANIME) && !defined(WINAR30)
            {
                HWND hSoftKbdWnd;

                hSoftKbdWnd = GetSoftKbdWnd(hUIWnd);
                if (!hSoftKbdWnd) {
                    return (0L);    // fail, return (0, 0)?
                }

                return SendMessage(hSoftKbdWnd, WM_IME_CONTROL,
                    wParam, lParam);
            }
#endif
            return (0L);
        case IMC_GETSTATUSWINDOWPOS:
#if !defined(ROMANIME)
            {
                HWND   hStatusWnd;
                RECT   rcStatusWnd;
                LPARAM lParam;

                hStatusWnd = GetStatusWnd(hUIWnd);
                if (!hStatusWnd) {
                    return (0L);    // fail, return (0, 0)?
                }

                if (!GetWindowRect(hStatusWnd, &rcStatusWnd)) {
                     return (0L);    // fail, return (0, 0)?
                }

                lParam = MAKELRESULT(rcStatusWnd.left, rcStatusWnd.top);

                return (lParam);
            }
#endif
            return (0L);
        default:
            return (1L);
        }
        break;
    case WM_IME_COMPOSITIONFULL:
        return (0L);
    case WM_IME_SELECT:
        // try to use SetContext
        // SelectIME(hUIWnd, (BOOL)wParam);
        SetContext(
#if defined(UNIIME)
            lpInstL, lpImeL,
#endif
            hUIWnd, (BOOL)wParam, 0);
        return (0L);
    case WM_MOUSEACTIVATE:
        return (MA_NOACTIVATE);
    case WM_USER_UICHANGE:
        return UIChange(
#if defined(UNIIME)
            lpInstL, lpImeL,
#endif
            hUIWnd);
    default:
        return DefWindowProc(hUIWnd, uMsg, wParam, lParam);
    }
    return (0L);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\cblocks\blockdoc.cpp ===
/*************************************************
 *  blockdoc.cpp                                    *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

// blockdoc.cpp : implementation of the CBlockDoc class
//

#include "stdafx.h"
#include <imm.h>
#include "cblocks.h"
#include "dib.h"
#include "dibpal.h"
#include "spriteno.h"
#include "sprite.h"
#include "phsprite.h"
#include "myblock.h"
#include "splstno.h"
#include "spritlst.h"
#include "osbview.h"
#include "blockvw.h"
#include "slot.h"
#include "mainfrm.h"
#include "statis.h"
#include "wave.h"
#include "blockdoc.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

CBitmap m_bmBlock;
long GScore=0;
extern CString GHint;
/////////////////////////////////////////////////////////////////////////////
// CBlockDoc

IMPLEMENT_DYNCREATE(CBlockDoc, CDocument)

BEGIN_MESSAGE_MAP(CBlockDoc, CDocument)
    //{{AFX_MSG_MAP(CBlockDoc)
	ON_COMMAND(ID_OPTION_SIZE_12x10, OnOPTIONSIZE12x10)
	ON_COMMAND(ID_OPTION_SIZE_16x16, OnOPTIONSIZE16x16)
	ON_COMMAND(ID_OPTION_SIZE_4x4, OnOPTIONSIZE4x4)
	ON_COMMAND(ID_TEST_SOUND, OnTestSound)
	ON_COMMAND(ID_OPTION_BEGINER, OnOptionBeginer)
	ON_UPDATE_COMMAND_UI(ID_OPTION_BEGINER, OnUpdateOptionBeginer)
	ON_COMMAND(ID_OPTION_EXPERT, OnOptionExpert)
	ON_UPDATE_COMMAND_UI(ID_OPTION_EXPERT, OnUpdateOptionExpert)
	ON_UPDATE_COMMAND_UI(ID_OPTION_ORDINARY, OnUpdateOptionOrdinary)
	ON_COMMAND(ID_OPTION_ORDINARY, OnOptionOrdinary)
	ON_COMMAND(ID_OPTION_SOUND, OnOptionSound)
	ON_UPDATE_COMMAND_UI(ID_OPTION_SOUND, OnUpdateOptionSound)
	ON_COMMAND(ID_FILE_STATISTIC, OnFileStatistic)
	ON_COMMAND(IDM_TEST, OnTest)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CBlockDoc construction/destruction
CBlockDoc::CBlockDoc()
{
    m_pBkgndDIB = NULL;
	m_nRow = 10;
	m_nCol = 12;
	m_nRowHeight = 32;
	m_nColWidth = 32;
	m_pSlotManager = NULL;
	m_bSound = TRUE;
	m_nExpertise = LEVEL_BEGINNER;
	m_pdibArrow = NULL;
	m_bmBlock.LoadBitmap(IDB_BLOCK);
}

CBlockDoc::~CBlockDoc()
{
    if (m_pBkgndDIB) {
        delete m_pBkgndDIB;
    }

    m_SpriteList.RemoveAll();

	if (m_pSlotManager)
		delete m_pSlotManager;
}

char* CBlockDoc::GetChar()
{
	int Hi;
	int Lo;

	static char szBuf[4];
	switch (m_nExpertise)
	{
		case LEVEL_EXPERT:
			{
				BOOL bAgain = FALSE;
				int nSafeCount = 0;
				do
				{
					Hi = 0xA4 + MyRand() % (0xF9-0xA4);
					if ((Hi >= 0xC6) && (Hi <= 0xC8))
					{
						nSafeCount++;
						if (nSafeCount > 5)
						{
							Hi = 0xA4;
							bAgain = FALSE;
						}
						else
							bAgain = TRUE;
					}
					
				} while (bAgain);
			}
			break;
		case LEVEL_ORDINARY:
			Hi = 0xA4 + MyRand() % (0xC6 - 0xA4);
			break;
		case LEVEL_BEGINNER:
			Hi = 0xA4 + MyRand() % 4;
			
			break;
	}
	Lo = (MyRand() % 2) ?  0x40 + MyRand() % 0x3F : 
	                 	 0xA1 + MyRand() % 0x5E ;

	szBuf[0] = (BYTE) Hi;
	szBuf[1] = (BYTE) Lo;
	szBuf[2] = 0;
	return szBuf;
}

// helper to load a ball sprite
CBlock* CBlockDoc::LoadBlock(UINT idRes, int iMass, int iX, int iY, int iVX, int iVY)
{
	static int nc=0;
	char* pszBuf=NULL;
	CDC dcMem;
	
	dcMem.CreateCompatibleDC(NULL);
	CBitmap* pOldBmp = dcMem.SelectObject(&m_bmBlock);
	pszBuf = GetChar();
	CSize szChar = dcMem.GetTextExtent(pszBuf,lstrlen(pszBuf));
	dcMem.SetBkColor(RGB(192,192,192));
	dcMem.SetTextColor(RGB(0,0,255));
	dcMem.TextOut((GetColWidth()-szChar.cx)/2,(GetRowHeight()-szChar.cy)/2,pszBuf,lstrlen(pszBuf));
	dcMem.SelectObject(pOldBmp);
	dcMem.DeleteDC();

    CBlock* pBlock = new CBlock;

    if (!pBlock->Load(&m_bmBlock)) {
        char buf[64];
        sprintf(buf, "Failed to load bitmap\n");
        AfxMessageBox(buf);
        delete pBlock;
        return NULL;
    }

	
    pBlock->SetMass(iMass);
    pBlock->SetPosition(iX, iY); 
    pBlock->SetVelocity(iVX, iVY);
	pBlock->SetCode(MAKEWORD(BYTE(pszBuf[1]),BYTE(pszBuf[0])));
	return pBlock;
	UNREFERENCED_PARAMETER(idRes);    
}

BOOL m_bsndFire;
BOOL m_bsndGround;
BOOL m_bsndHit;
CWave m_sndHit;
CWave m_sndGround;
CWave m_sndFire;    
BOOL CBlockDoc::OnNewDocument()
{
    if (!CDocument::OnNewDocument())
        return FALSE;

	m_nSeed = (int)(GetTickCount() % 65536);

    CBlockView* pView = GetBlockView();
    ASSERT(pView);
    m_SpriteList.m_NotifyObj.SetView(pView);

    // load the background image
    CDIB* pDIB = new CDIB;
	pDIB->Create(m_nColWidth * m_nCol,m_nRowHeight * m_nRow);
    SetBackground(pDIB);

	if (sndPlaySound("",SND_SYNC))
	{
		m_bsndFire   = m_sndFire.LoadResource(IDR_SNDFIRE);
    	m_bsndHit    = m_sndHit.LoadResource(IDR_SNDHIT);
    	m_bsndGround = m_sndGround.LoadResource(IDR_SNDGROUND);
	}
	else
	{
		m_bsndFire   = FALSE;
		m_bsndHit    = FALSE;
		m_bsndGround = FALSE;
	}
    
	if (m_pSlotManager)
		delete m_pSlotManager;
	m_pSlotManager = new CSlotManager(this);

	if (m_pdibArrow)
		delete m_pdibArrow;
	CBitmap bmArrow;
	bmArrow.LoadBitmap(IDB_ARROW);
	m_pdibArrow = new CBlock;
	m_pdibArrow->Load(&bmArrow);

	GScore = 0;
	SetModifiedFlag(FALSE);

	m_nTotalWords		=0;
	m_nTotalHitWords	=0;
	m_nMissedHit		=0;
	m_nHitInMoving		=0;
	m_nHitInStill		=0;
	
    return TRUE;
}

void CBlockDoc::DeleteContents() 
{
	if (m_pSlotManager)
	{
		delete m_pSlotManager;
		m_pSlotManager = NULL;
	}
	
	if (m_pdibArrow)
	{
		delete m_pdibArrow;
		m_pdibArrow = NULL;
	}
	//sndPlaySound(NULL,SND_ASYNC);	
	CDocument::DeleteContents();
}


/////////////////////////////////////////////////////////////////////////////
// CBlockDoc serialization

void CBlockDoc::Serialize(CArchive& ar)
{
    CDocument::Serialize(ar);
    if (ar.IsStoring()) {
        if (m_pBkgndDIB) {
            ar << (DWORD) 1; // say we have a bkgnd
            m_pBkgndDIB->Serialize(ar);
        } else {
            ar << (DWORD) 0; // say we have no bkgnd
        }
        m_SpriteList.Serialize(ar);
    } else {
        DWORD dw;
        // see if we have a background to load
        ar >> dw;
        if (dw != 0) {
            CDIB *pDIB = new CDIB;
            pDIB->Serialize(ar);
            // Attach it to the document
            SetBackground(pDIB);
        }
        // read the sprite list
        m_SpriteList.Serialize(ar);
        SetModifiedFlag(FALSE);
        UpdateAllViews(NULL, 0, NULL);
    }
}


/////////////////////////////////////////////////////////////////////////////
// CBlockDoc diagnostics

#ifdef _DEBUG
void CBlockDoc::AssertValid() const
{
    CDocument::AssertValid();
}

void CBlockDoc::Dump(CDumpContext& dc) const
{
    CDocument::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// helper functions

// return a pointer to the off-screen buffered view
CBlockView* CBlockDoc::GetBlockView()
{
    POSITION pos;
    pos = GetFirstViewPosition();
    ASSERT(pos);
    CBlockView *pView = (CBlockView *)GetNextView(pos);
    ASSERT(pView);
    ASSERT(pView->IsKindOf(RUNTIME_CLASS(CBlockView)));
    return pView;
}

/////////////////////////////////////////////////////////////////////////////
// CBlockDoc commands

// Set a new background DIB
BOOL CBlockDoc::SetBackground(CDIB* pDIB)
{
    // Delete any existing sprites
    m_SpriteList.RemoveAll();

    // Delete any existing background DIB and set the new one
    if (m_pBkgndDIB) delete m_pBkgndDIB;
    m_pBkgndDIB = pDIB;

    // Tell the view that it needs to create a new buffer
    // and palette
    CBlockView* pView = GetBlockView();
    ASSERT(pView);
    return pView->NewBackground(m_pBkgndDIB);
}

void CBlockDoc::GetSceneRect(CRect* prc)
{
    if (!m_pBkgndDIB) return;
    m_pBkgndDIB->GetRect(prc);
}

void CBlockDoc::Land()
{
	m_pSlotManager->Land();
		
}

void CBlockDoc::Tick()
{
	int nSlotNo;
	static BOOL bInLoop = FALSE;
	if (! bInLoop)
	{
		bInLoop = TRUE;
		if ((nSlotNo = m_pSlotManager->GetIdleSlot()) >= 0)
			GenerateBlock(nSlotNo);
		bInLoop = FALSE;
	}
	else
	{
		MessageBeep(0);
		TRACE("****************** Problem \n");
	}
}

void CBlockDoc::GenerateBlock(int nSlotNo)
{
	int vY=0;
	switch(m_nExpertise)
	{
		case LEVEL_EXPERT:
			vY = 500 + MyRand() % 1000;
			break;
		case LEVEL_ORDINARY:
			vY = 300 + MyRand() % 500;
			break;
		case LEVEL_BEGINNER:
		    vY = 100 + MyRand() % 200;
			break;
		default:
		    vY = 100 + MyRand() % 1000;
	}

	CBlock* pBlock = LoadBlock(IDB_BLOCK,MyRand() % 600+100,m_nColWidth*nSlotNo,-m_nRowHeight,0,vY);
	m_SpriteList.Insert(pBlock);
	m_pSlotManager->AddRunningBlock(nSlotNo,pBlock);
    GetBlockView()->NewSprite(pBlock);	
	m_nTotalWords++;
	
}

void CBlockDoc::GameOver(BOOL bHighScore) 
{
	GetBlockView()->GameOver(bHighScore);
	SoundOver();
	POSITION pPos = m_SpriteList.GetHeadPosition();
	for ( ; pPos; )
	{
		CBlock *pBlock = (CBlock *) m_SpriteList.GetNext(pPos);
		pBlock->Inverse();
	}
	UpdateAllViews(NULL);
}

void CBlockDoc::Promote()
{
	switch (GSpeed)
	{
		case SPEED_FAST:
			//GetBlockView()->SendMessage(WM_COMMAND,ID_ACTION_SLOW);
		break;
		case SPEED_NORMALFAST: 
			GetBlockView()->SendMessage(WM_COMMAND,ID_ACTION_FAST);
		break;
		case SPEED_NORMAL:
			GetBlockView()->SendMessage(WM_COMMAND,ID_ACTION_NORMALFAST);
		break;
		case SPEED_NORMALSLOW:
			GetBlockView()->SendMessage(WM_COMMAND,ID_ACTION_NORMAL);
		break;
		case SPEED_SLOW:
			GetBlockView()->SendMessage(WM_COMMAND,ID_ACTION_NORMALSLOW);
		break;
	}
}

void CBlockDoc::Hit(WORD wCode)
{
	int nLayer=0;
	CBlock *pBlock=m_pSlotManager->Hit(wCode,nLayer);
	if (pBlock)
	{
		SoundHit();
		m_pdibArrow->Coverage(pBlock);
		if (nLayer > 1)
		{
			m_nHitInMoving++;
			GScore += nLayer;
		}
		else
		{
			GScore++;  
			m_nHitInStill++;
		}
		m_nTotalHitWords++;
	}
	else
	{
		SoundFire();
		m_nMissedHit++;
	}
	if ((m_nTotalHitWords+1) % 20 == 0)
	{
		Promote();
	}
	if (GScore > 9999999999L)
	{
		GameOver(TRUE);
	}
}

void CBlockDoc::OnOPTIONSIZE12x10() 
{
	m_nRow = 10;
	m_nCol = 12;
	AfxGetApp()->m_pMainWnd->SendMessage(WM_COMMAND,ID_FILE_NEW);
}

void CBlockDoc::OnOPTIONSIZE16x16() 
{
	m_nRow = 16;
	m_nCol = 16;
	AfxGetApp()->m_pMainWnd->SendMessage(WM_COMMAND,ID_FILE_NEW);		
}

void CBlockDoc::OnOPTIONSIZE4x4() 
{
	m_nRow = 4;
	m_nCol = 4;
	AfxGetApp()->m_pMainWnd->SendMessage(WM_COMMAND,ID_FILE_NEW);		
}

void CBlockDoc::SoundFire()
{
	if (!m_bSound)
		return;

	if (m_bsndFire)
		m_sndFire.Play();
	else
	{
		int tone =1000;
		int time = 1;
		for ( ; tone>100; )
		{
			Beep(tone,time);
			tone -= 50;
		}
	}
}

void CBlockDoc::SoundHit()
{
	if (!m_bSound)
		return;

	if (m_bsndHit)
		m_sndHit.Play();
	else
	{
		int tone =900;
		int time = 2;
		for ( ; tone<=1200; )
		{
			Beep(tone,time);
			tone += 50;
		}
	}
}

void CBlockDoc::SoundAppear()
{
	if (!m_bSound)
		return;

	int tone =200;
	int time = 1;
	for ( ; time<5; )
	{
		Beep(tone,time);
		(time %2) ? tone +=100 : tone -=50;
		time++; 
	}

}

void CBlockDoc::SoundGround()
{
	if (!m_bSound)
		return;

	if (m_bsndGround)
		m_sndGround.Play();
	else
	{
		int tone =1000;
		int time = 1;
		for ( ; time<5; )
		{
			Beep(tone,time);
			tone +=100;
			time++; 
		}
	}

}

void CBlockDoc::SoundOver()
{
	if (!m_bSound)
		return;

	MessageBeep(MB_ICONASTERISK	);
	int tone[8] = {200,200,252,252,300,300,225,225};
	int time=30;
	for (int j=0; j<5; j++)
		for (int i=1; i<8; i++)
				Beep(tone[i],time);
}

void CBlockDoc::OnTestSound() 
{
	SoundHit();
}


void CBlockDoc::OnOptionBeginer() 
{
	m_nExpertise = LEVEL_BEGINNER;	
	AfxGetApp()->OnIdle(RANK_USER);
}

void CBlockDoc::OnUpdateOptionBeginer(CCmdUI* pCmdUI) 
{
	pCmdUI->SetCheck(m_nExpertise == LEVEL_BEGINNER ?  1 : 0);
}

void CBlockDoc::OnOptionExpert() 
{
	m_nExpertise = LEVEL_EXPERT;
	AfxGetApp()->OnIdle(RANK_USER);
}

void CBlockDoc::OnUpdateOptionExpert(CCmdUI* pCmdUI) 
{
	pCmdUI->SetCheck(m_nExpertise == LEVEL_EXPERT ? 1 : 0);
}

void CBlockDoc::OnOptionOrdinary() 
{
	m_nExpertise = LEVEL_ORDINARY;		
	AfxGetApp()->OnIdle(RANK_USER);
}

void CBlockDoc::OnUpdateOptionOrdinary(CCmdUI* pCmdUI) 
{
	pCmdUI->SetCheck(m_nExpertise == LEVEL_ORDINARY ?  1 : 0);	
}

void CBlockDoc::OnOptionSound() 
{
	m_bSound = ! m_bSound;
		
	
}

void CBlockDoc::OnUpdateOptionSound(CCmdUI* pCmdUI) 
{
	pCmdUI->SetCheck(m_bSound ? 1 : 0);
}

void CBlockDoc::OnFileStatistic() 
{
	CStatisticDlg sta(this);
	GetBlockView()->SetSpeed(0);
	sta.DoModal();	
	GetBlockView()->SetSpeed(GSpeed);
}

void CBlockDoc::Remove(CBlock* pBlock)
{
	m_SpriteList.Remove(pBlock);
	delete pBlock;
}
			   
WORD CBlockDoc::GetFocusChar(CPoint pt)
{
	POSITION pPos = m_SpriteList.GetHeadPosition();
	for (;pPos; )
	{
		CBlock* pBlock = (CBlock*) m_SpriteList.GetNext(pPos);
		CRect rc = CRect(pBlock->GetX(),pBlock->GetY(),pBlock->GetX()+m_nColWidth,pBlock->GetY()+m_nRowHeight);
		if (rc.PtInRect(pt))
			return (pBlock->GetCode());
	}
	return 0;
}

#define MAX_COMP 10
#define MAX_KEY  5

BOOL CBlockDoc::GetKeyStroke(WORD wCode)
{
	HKL hkl = GetKeyboardLayout(0);
	if ( hkl == 0 || !ImmIsIME(hkl) )
   		return FALSE;

	HIMC himc = ImmGetContext(GetBlockView()->GetSafeHwnd());
	char buf[sizeof(CANDIDATELIST)+(sizeof(DWORD) + sizeof(WORD) * MAX_KEY + sizeof(TCHAR) ) * MAX_COMP];
	char lpsrc[3];
	lpsrc[0] = HIBYTE(wCode);
	lpsrc[1] = LOBYTE(wCode);
	lpsrc[2] = 0;
	UINT rc = ImmGetConversionList( hkl, himc, 
	lpsrc, (CANDIDATELIST *)buf, 
	(UINT)sizeof(buf), 
	GCL_REVERSECONVERSION );
	ImmReleaseContext(GetBlockView()->GetSafeHwnd(),himc);
	if (rc == 0)
		return FALSE;
	if (((CANDIDATELIST *) buf)->dwCount == 0)
		return FALSE;

	GHint = CString(buf+ ((CANDIDATELIST *) buf)->dwOffset[0]);
	
	return TRUE;
}

void CBlockDoc::OnTest() 
{
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\uniime.h ===
/*************************************************
 *  uniime.h                                     *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

LRESULT WINAPI UniUIWndProc(LPINSTDATAL, LPIMEL, HWND, UINT,
               WPARAM, LPARAM);                                 // ui.c

LRESULT WINAPI UniCompWndProc(LPINSTDATAL, LPIMEL, HWND, UINT,
               WPARAM, LPARAM);                                 // compui.c

LRESULT WINAPI UniCandWndProc(LPINSTDATAL, LPIMEL, HWND, UINT,
               WPARAM, LPARAM);                                 // candui.c

LRESULT WINAPI UniStatusWndProc(LPINSTDATAL, LPIMEL, HWND,
               UINT, WPARAM, LPARAM);                           // statusui.c

LRESULT WINAPI UniOffCaretWndProc(LPINSTDATAL, LPIMEL, HWND,
               UINT, WPARAM, LPARAM);                           // offcaret.c

LRESULT WINAPI UniContextMenuWndProc(LPINSTDATAL, LPIMEL, HWND,
               UINT, WPARAM, LPARAM);                           // uisubs.c

BOOL    WINAPI UniImeInquire(LPINSTDATAL, LPIMEL, LPIMEINFO,
               LPTSTR, DWORD);                                  // ddis.c

BOOL    WINAPI UniImeConfigure(LPINSTDATAL, LPIMEL, HKL, HWND,
               DWORD, LPVOID);                                  // ddis.c

DWORD   WINAPI UniImeConversionList(LPINSTDATAL, LPIMEL, HIMC,
               LPCTSTR, LPCANDIDATELIST, DWORD, UINT);          // ddis.c

BOOL    WINAPI UniImeDestroy(LPINSTDATAL, LPIMEL, UINT);        // ddis.c

LRESULT WINAPI UniImeEscape(LPINSTDATAL, LPIMEL, HIMC, UINT,
               LPVOID);                                         // ddis.c

BOOL    WINAPI UniImeProcessKey(LPINSTDATAL, LPIMEL, HIMC,
               UINT, LPARAM, CONST LPBYTE);                     // toascii.c

BOOL    WINAPI UniImeSelect(LPINSTDATAL, LPIMEL, HIMC, BOOL);   // ddis.c

BOOL    WINAPI UniImeSetActiveContext(LPINSTDATAL, LPIMEL,
               HIMC, BOOL);                                     // ddis.c

UINT    WINAPI UniImeToAsciiEx(LPINSTDATAL, LPIMEL, UINT, UINT,
               CONST LPBYTE, LPTRANSMSGLIST, UINT, HIMC);       // toascii.c

BOOL    WINAPI UniNotifyIME(LPINSTDATAL, LPIMEL, HIMC, DWORD,
               DWORD, DWORD);                                   // notify.c

BOOL    WINAPI UniImeRegisterWord(LPINSTDATAL, LPIMEL, LPCTSTR,
               DWORD, LPCTSTR);                                 // regword.c

BOOL    WINAPI UniImeUnregisterWord(LPINSTDATAL, LPIMEL,
               LPCTSTR, DWORD, LPCTSTR);                        // regword.c

UINT    WINAPI UniImeGetRegisterWordStyle(LPINSTDATAL, LPIMEL,
               UINT, LPSTYLEBUF);                               // regword.c

UINT    WINAPI UniImeEnumRegisterWord(LPINSTDATAL, LPIMEL,
               REGISTERWORDENUMPROC, LPCTSTR, DWORD, LPCTSTR,
               LPVOID);                                         // regword.c

BOOL    WINAPI UniImeSetCompositionString(LPINSTDATAL, LPIMEL,
               HIMC, DWORD, LPCVOID, DWORD, LPCVOID, DWORD);    // notify.c


#if !defined(MINIIME)

DWORD   WINAPI UniSearchPhrasePredictionW(LPIMEL, UINT, LPCWSTR, DWORD,
               LPCWSTR, DWORD, DWORD, DWORD, DWORD,
               LPCANDIDATELIST);                                // uniphrs.c

DWORD   WINAPI UniSearchPhrasePredictionA(LPIMEL, UINT, LPCSTR, DWORD,
               LPCSTR, DWORD, DWORD, DWORD, DWORD,
               LPCANDIDATELIST);                                // uniphrs.c

#ifdef UNICODE
typedef LPCSTR  LPCSTUBSTR;
#define UniSearchPhrasePrediction       UniSearchPhrasePredictionW
#define UniSearchPhrasePredictionStub   UniSearchPhrasePredictionA
#else
typedef LPCWSTR LPCSTUBSTR;
#define UniSearchPhrasePrediction       UniSearchPhrasePredictionA
#define UniSearchPhrasePredictionStub   UniSearchPhrasePredictionW
#endif

#endif

void    WINAPI UniAttachMiniIME(LPINSTDATAL, LPIMEL, WNDPROC,
               WNDPROC, WNDPROC, WNDPROC, WNDPROC, WNDPROC);    // init.c

void    WINAPI UniDetachMiniIME(LPINSTDATAL, LPIMEL);           // init.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\cblocks\cblocks.h ===
/*************************************************
 *  cblocks.h                                    *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

// cblocks.h : main header file for the BLOCK application
//

#ifndef __AFXWIN_H__
    #error include 'stdafx.h' before including this file for PCH
#endif
								    
#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CBlockApp:
// See block.cpp for the implementation of this class
//

class CBlockDoc;

class CBlockApp : public CWinApp
{
public:
    CBlockApp();
    void SetIdleEvent(CBlockDoc* pDoc)
        {m_pIdleDoc = pDoc;}

// Overrides
    virtual BOOL InitInstance();
    virtual BOOL OnIdle(LONG lCount);


// Implementation

    //{{AFX_MSG(CBlockApp)
	afx_msg void OnHelpRule();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    CBlockDoc* m_pIdleDoc;
};
#define RANK_USER 5
extern int GSpeed;
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\cblocks\blockvw.h ===
/*************************************************
 *  blockvw.h                                    *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

// blockvw.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CBlockView view
class CBlockView : public COSBView
{
    DECLARE_DYNCREATE(CBlockView)
protected:
    CBlockView();            // protected constructor used by dynamic creation
								 
// Attributes
public:
    CBlockDoc* GetDocument()
        {return (CBlockDoc*) m_pDocument;}

// Operations
public:
    BOOL NewBackground(CDIB* pDIB);
    virtual void Render(CRect* pClipRect = NULL);
    void NewSprite(CSprite* pSprite);
  	void GameOver(BOOL bHighScore=FALSE);
	BOOL IsStart() const {return m_bStart;}
    void SetSpeed(int iSpeed);
	void ForceSpeed(int nSpeed);
// Implementation
protected:
    virtual ~CBlockView();
    virtual void OnDraw(CDC* pDC);      // overridden to draw this view
    virtual void OnInitialUpdate();     // first time after construct

    // Generated message map functions
    //{{AFX_MSG(CBlockView)
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnDestroy();
    afx_msg void OnTimer(UINT nIDEvent);
    afx_msg void OnActionFast();
    afx_msg void OnActionSlow();
    afx_msg void OnActionStop();
	afx_msg void OnFileStart();
	afx_msg void OnFileSuspend();
	afx_msg void OnUpdateFileSuspend(CCmdUI* pCmdUI);
	afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnUpdateActionFast(CCmdUI* pCmdUI);
	afx_msg void OnUpdateActionSlow(CCmdUI* pCmdUI);
	afx_msg void OnActionNormal();
	afx_msg void OnUpdateActionNormal(CCmdUI* pCmdUI);
	afx_msg void OnActionNormalfast();
	afx_msg void OnUpdateActionNormalfast(CCmdUI* pCmdUI);
	afx_msg void OnUpdateActionNormalslow(CCmdUI* pCmdUI);
	afx_msg void OnActionNormalslow();
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnMenuSelect( UINT nItemID, UINT nFl, HMENU hSysMenu );
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnAppAbout();
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    BOOL m_bMouseCaptured;          // TRUE if mouse captured
    CBlock* m_pCapturedSprite;// Pointer to captured sprite (for drag)
    CPoint m_ptOffset;              // offset into hit sprite
    UINT m_uiTimer;                 // timer id
    CPoint m_ptCaptured;            // point where sprite was captured
    int m_iSpeed;
	BOOL m_bStart;
	BOOL m_bSuspend;
	BOOL m_bFocusWnd;
};
#define SPEED_FAST		  35
#define SPEED_NORMALFAST  75
#define SPEED_NORMAL	 150
#define SPEED_NORMALSLOW 225
#define SPEED_SLOW		 300

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\cblocks\blockvw.cpp ===
/*************************************************
 *  blockvw.cpp                                  *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

// blockview.cpp : implementation file
//

#include "stdafx.h"
#include "cblocks.h"
#include "dib.h"
#include "dibpal.h"
#include "spriteno.h"	    
#include "sprite.h"
#include "phsprite.h"
#include "myblock.h"
#include "splstno.h"
#include "spritlst.h"
#include "osbview.h"
#include "slot.h"
#include "about.h"
#include "blockvw.h"
#include "blockdoc.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CBlockView

IMPLEMENT_DYNCREATE(CBlockView, COSBView)


int GSpeed=SPEED_SLOW;
BOOL m_bTimer2;
BOOL m_bShowTip;

CString GHint="";
CBlockView::CBlockView()
{
    m_bMouseCaptured = FALSE;
    m_pCapturedSprite = NULL;
    m_uiTimer = 0;
    m_iSpeed = 0;
	m_bStart = FALSE;
	m_bSuspend = FALSE;
	m_bShowTip = FALSE;
	m_bFocusWnd = TRUE;
	
}

CBlockView::~CBlockView()
{
}


BEGIN_MESSAGE_MAP(CBlockView, COSBView)
    //{{AFX_MSG_MAP(CBlockView)
    ON_WM_CREATE()
    ON_WM_DESTROY()
    ON_WM_TIMER()
    ON_COMMAND(ID_ACTION_FAST, OnActionFast)
	ON_COMMAND(ID_ACTION_SLOW, OnActionSlow)
    ON_COMMAND(ID_ACTION_STOP, OnActionStop)
	ON_COMMAND(ID_FILE_START, OnFileStart)
	ON_COMMAND(ID_FILE_SUSPEND, OnFileSuspend)
	ON_UPDATE_COMMAND_UI(ID_FILE_SUSPEND, OnUpdateFileSuspend)
	ON_WM_CHAR()
	ON_UPDATE_COMMAND_UI(ID_ACTION_FAST, OnUpdateActionFast)
	ON_UPDATE_COMMAND_UI(ID_ACTION_SLOW, OnUpdateActionSlow)
	ON_COMMAND(ID_ACTION_NORMAL, OnActionNormal)
	ON_UPDATE_COMMAND_UI(ID_ACTION_NORMAL, OnUpdateActionNormal)
    ON_COMMAND(ID_ACTION_NORMALFAST, OnActionNormalfast)
	ON_UPDATE_COMMAND_UI(ID_ACTION_NORMALFAST, OnUpdateActionNormalfast)
	ON_UPDATE_COMMAND_UI(ID_ACTION_NORMALSLOW, OnUpdateActionNormalslow)
	ON_COMMAND(ID_ACTION_NORMALSLOW, OnActionNormalslow)
	ON_WM_LBUTTONDOWN()
	ON_WM_MENUSELECT()
	ON_WM_MOUSEMOVE()
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
	ON_WM_KILLFOCUS()
	ON_WM_SETFOCUS()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CBlockView drawing

void CBlockView::OnInitialUpdate()
{
    COSBView::OnInitialUpdate();
    
	m_bStart = FALSE;
	m_bSuspend = FALSE;


}

void CBlockView::OnDraw(CDC* pDC)
{
    COSBView::OnDraw(pDC);
}

/////////////////////////////////////////////////////////////////////////////
// CBlockView message handlers

// Create a new buffer and palette to match a new 
// background DIB
BOOL CBlockView::NewBackground(CDIB* pDIB)
{
    // Create a new buffer and palette
    if (!Create(pDIB)) {
        return FALSE;
    }

    // Map the colors of the background DIB to
    // the identity palette we just created for the background
    pDIB->MapColorsToPalette(GetPalette());

    // Resize the main frame window to fit the background image
    GetParentFrame()->RecalcLayout();
	if ((GetVersion() & 0x80000000) == 0)
	{
    	ResizeParentToFit(FALSE); // Try shrinking first
    	ResizeParentToFit(TRUE); // Let's be daring
	}
	else
	{

    	Resize(FALSE); // Try shrinking first
    	Resize(TRUE); // Let's be daring
 	}
    // Render the entire scene to the off-screen buffer
    Render();

    // Paint the off-screen buffer to the window
    Draw();

    return TRUE;
}

// Render the scene to the off-screen buffer
// pClipRect defaults to NULL
void CBlockView::Render(CRect* pClipRect)
{
    CBlockDoc* pDoc = GetDocument();
    CRect rcDraw;

    // get the background DIB and render it
    CDIB* pDIB = pDoc->GetBackground();
    if (pDIB) {
        pDIB->GetRect(&rcDraw);
        // If a clip rect was supplied use it
        if (pClipRect) {
            rcDraw.IntersectRect(pClipRect, &rcDraw);
        }

        // draw the image of the DIB to the os buffer
        ASSERT(m_pDIB);
        pDIB->CopyBits(m_pDIB,       
                       rcDraw.left,
                       rcDraw.top,     
                       rcDraw.right - rcDraw.left,
                       rcDraw.bottom - rcDraw.top,
                       rcDraw.left, 
                       rcDraw.top);
    }

    // Render the sprite list from the bottom of the list to the top
    // Note that we always clip to the background DIB
    CSpriteList* pList = pDoc->GetSpriteList();
    POSITION pos = pList->GetTailPosition();
    CSprite *pSprite;
    while (pos) {
        pSprite = pList->GetPrev(pos);
        pSprite->Render(m_pDIB, &rcDraw);
    }                 
}

// A new sprite has been added to the document
void CBlockView::NewSprite(CSprite* pSprite)
{   
    // map the colors in the sprite DIB to the
    // palette in the off-screen buffered view
    if (m_pPal) {
        pSprite->MapColorsToPalette(m_pPal);
    }

    // Render the scene
//    Render();

    // Draw the new scene to the screen
//    Draw();
}


int CBlockView::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (COSBView::OnCreate(lpCreateStruct) == -1)
        return -1;
    return 0;
}

void CBlockView::OnDestroy()
{
    if (m_uiTimer) {
        KillTimer(1);
        m_uiTimer = 0;
    }
	if (m_bTimer2)
	{
		VERIFY(KillTimer(2));
		m_bTimer2 = 0;
	}

    COSBView::OnDestroy();
}

void CBlockView::OnActionStop()
{
    SetSpeed(0);
}

void CBlockView::SetSpeed(int iSpeed)
{
    // Stop the current timer
    if (m_uiTimer) {
        KillTimer(1);
        m_uiTimer = 0;
    }
    // Stop idle loop mode
    CBlockApp* pApp = (CBlockApp*) AfxGetApp();
    pApp->SetIdleEvent(NULL);
    m_iSpeed = iSpeed;            
    if (iSpeed == 0) return;
    if (iSpeed > 0) {
        m_uiTimer = (UINT)SetTimer(1, iSpeed, NULL);    
        return;
    }
    // Set up idle loop mode
    //pApp->SetIdleEvent(this);
}


void CBlockView::OnFileStart() 
{
	AfxGetApp()->m_pMainWnd->SendMessage(WM_COMMAND,ID_FILE_NEW);
	SetSpeed(GSpeed);
	m_bStart = TRUE;
}

void CBlockView::GameOver(BOOL bHighScore)
{
	SetSpeed(0);	
	m_bStart = FALSE;
	if (bHighScore)
	{
		CString szMsg1,szMsg2;
		szMsg1.LoadString(IDS_SUPERMAN);
        szMsg2.LoadString(IDS_BLOCK);
		MessageBox(szMsg1,szMsg2,MB_OK);
	}
}

void CBlockView::OnUpdateFileSuspend(CCmdUI* pCmdUI) 
{
	CString szMsg;
/*
	if (m_bSuspend)
		szMsg.LoadString(IDS_RESUME);
	else
		szMsg.LoadString(IDS_SUSPEND);

	pCmdUI->SetText((const char *) szMsg);	
*/
	pCmdUI->Enable(m_bStart);
	pCmdUI->SetCheck(m_bSuspend);
}

void CBlockView::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	static BYTE wCode[2];
	static BOOL bGetNext = FALSE;

	if (m_bStart)
	{
		if (bGetNext)
		{
			wCode[1] = (BYTE) nChar;	
			bGetNext = FALSE;
			GetDocument()->Hit(MAKEWORD(wCode[1],wCode[0]));
		}
		else if (IsDBCSLeadByte((BYTE)nChar))
		{
			wCode[0] = (BYTE) nChar;	
			bGetNext = TRUE;
		}
	}
	COSBView::OnChar(nChar, nRepCnt, nFlags);
}

void CBlockView::OnActionFast()
{
	GSpeed = SPEED_FAST;
	if (m_bStart && !m_bSuspend)
    	SetSpeed(GSpeed);
}

void CBlockView::OnActionNormalfast() 
{
	GSpeed = SPEED_NORMALFAST;
	if (m_bStart && !m_bSuspend)
    	SetSpeed(GSpeed);	
	AfxGetApp()->OnIdle(RANK_USER);
	
}
void CBlockView::OnActionNormal() 
{
	GSpeed = SPEED_NORMAL;
	if (m_bStart && !m_bSuspend)
    	SetSpeed(GSpeed);
	AfxGetApp()->OnIdle(RANK_USER);
	
}

void CBlockView::OnActionNormalslow() 
{
	GSpeed = SPEED_NORMALSLOW;
	if (m_bStart && !m_bSuspend)
    	SetSpeed(GSpeed);
	
	AfxGetApp()->OnIdle(RANK_USER);
}

void CBlockView::OnActionSlow()
{
	GSpeed = SPEED_SLOW;
	if (m_bStart && !m_bSuspend)
    	SetSpeed(GSpeed);
	AfxGetApp()->OnIdle(RANK_USER);
}

void CBlockView::OnUpdateActionFast(CCmdUI* pCmdUI) 
{
	pCmdUI->SetCheck(GSpeed == SPEED_FAST ? 1 : 0);
}

void CBlockView::OnUpdateActionNormalfast(CCmdUI* pCmdUI) 
{
	pCmdUI->SetCheck(GSpeed == SPEED_NORMALFAST ? 1 : 0);
}

void CBlockView::OnUpdateActionNormal(CCmdUI* pCmdUI) 
{
	pCmdUI->SetCheck(GSpeed == SPEED_NORMAL ? 1 : 0);
	
	
}

void CBlockView::OnUpdateActionNormalslow(CCmdUI* pCmdUI) 
{
	pCmdUI->SetCheck(GSpeed == SPEED_NORMALSLOW ? 1 : 0);
	
}

void CBlockView::OnUpdateActionSlow(CCmdUI* pCmdUI) 
{
	pCmdUI->SetCheck(GSpeed == SPEED_SLOW ? 1 : 0);	
	
}


void CBlockView::OnLButtonDown(UINT nFlags, CPoint point) 
{
	COSBView::OnLButtonDown(nFlags, point);
}

void CBlockView::OnMenuSelect( UINT nItemID, UINT nFlag, HMENU hMenu )
{
	if ((nFlag == 0xFFFF) && (hMenu == NULL))
	{
		if (m_bStart && !m_bSuspend)
			SetSpeed(GSpeed);	
	}	
	else
	{
		if (GSpeed != 0)
			SetSpeed(0);
	}
	UNREFERENCED_PARAMETER(nItemID);
}

CPoint m_ptLoc;
int m_nCount=0;


void CBlockView::OnFileSuspend() 
{
	LONG_PTR hOldCur=0;
	m_bSuspend = !m_bSuspend;	
	if (m_bSuspend)
	{
		SetSpeed(0);
		m_nCount = 0;
		VERIFY(m_bTimer2 = (INT)SetTimer(2, 300, NULL));    
		hOldCur = (LONG_PTR)GetClassLongPtr(GetSafeHwnd(),GCLP_HCURSOR);
		SetClassLongPtr(GetSafeHwnd(),GCLP_HCURSOR,(LONG_PTR)AfxGetApp()->LoadCursor(IDC_HAND_CBLOCK));
	}
	else
	{
		SetSpeed(GSpeed);
		VERIFY(KillTimer(2));
		m_bTimer2 = 0;
		SetClassLongPtr(GetSafeHwnd(),GCLP_HCURSOR,(LONG_PTR)hOldCur);
	}
}

void CBlockView::OnTimer(UINT nIDEvent)
{
	
	switch (nIDEvent)
	{
		case 1:
		{
			if (! m_bFocusWnd)
				GetDocument()->UpdateAllViews(NULL);
			GetDocument()->Tick();
    		int i = 0;
    		POSITION pos;
    		CBlock *pBlock;
    		CBlockDoc* pDoc = GetDocument();
    		CSpriteList* pspList = pDoc->GetSpriteList();
    		if (pspList->IsEmpty()) return; // no sprites
    		// update the position of each sprite
    		for (pos = pspList->GetHeadPosition(); pos != NULL;) 
    		{
	        	pBlock = (CBlock *)pspList->GetNext(pos);
    	    	ASSERT(pBlock->IsKindOf(RUNTIME_CLASS(CBlock))); 
        		i += pBlock->UpdatePosition(pDoc);
				GetDocument()->Land();
    		}
    		if (i) {
	        	// draw the changes
    	    	RenderAndDrawDirtyList();
    		}
			break;
		}
		case 2:
		{
			if (! m_bSuspend)
				break;
			m_nCount++;
			if (m_nCount >= 2)
			{
				if (!m_bShowTip)
				{
					WORD wCode = GetDocument()->GetFocusChar(m_ptLoc);
					if (wCode)
					{	
						if (! GetDocument()->GetKeyStroke(wCode))
						{
							char szBuf[6];
							wsprintf(szBuf,"%X",wCode);
							GHint = CString(szBuf);	
						}
						m_bShowTip = TRUE;
						AfxGetApp()->OnIdle(RANK_USER);
					}
				}
			}
			else
			{
				if (m_bShowTip)
				{
					GHint = "";
					m_bShowTip = FALSE;
					AfxGetApp()->OnIdle(RANK_USER);
				}
			}
		}
	}
	UNREFERENCED_PARAMETER(nIDEvent);
}


void CBlockView::OnMouseMove(UINT nFlags, CPoint point) 
{
	if (m_bSuspend)
	{
		if (m_ptLoc != point)
		{
			m_ptLoc = point;	
			m_nCount = 0;
		}
	}
	COSBView::OnMouseMove(nFlags,point);
	UNREFERENCED_PARAMETER(nFlags);
}

void CBlockView::OnAppAbout()
{
    CString szAppName;
    szAppName.LoadString(IDS_BLOCK);
    ShellAbout(GetSafeHwnd(),szAppName,TEXT(""), AfxGetApp()->LoadIcon(IDR_MAINFRAME));
	if (m_bStart && !m_bSuspend)
		SetSpeed(GSpeed);
    
}

void CBlockView::OnKillFocus(CWnd* pNewWnd) 
{
	COSBView::OnKillFocus(pNewWnd);
	m_bFocusWnd = FALSE;
}

void CBlockView::OnSetFocus(CWnd* pOldWnd) 
{
	COSBView::OnSetFocus(pOldWnd);
    // because there is a gap between next time tick,
    // so force update veiw first.
    GetDocument()->UpdateAllViews(NULL);
	m_bFocusWnd = TRUE;		
}

void CBlockView::ForceSpeed(int nSpeed)
{
	if (m_bSuspend || !m_bStart)
		return;
	SetSpeed(nSpeed);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\cblocks\blockdoc.h ===
/*************************************************
 *  blockdoc.h                                   *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

// blockdoc.h : interface of the CBlockDoc class
//
/////////////////////////////////////////////////////////////////////////////
class CSlotManager;
class CBlock;
class CSpriteList;
class CDIB;
class CBlockDoc : public CDocument
{
protected: // create from serialization only
    CBlockDoc();
    DECLARE_DYNCREATE(CBlockDoc)
    CBlock* LoadBlock(UINT idRes,
                  int iMass,
                  int iX, int iY,
                  int iVX, int iVY);

// Attributes
public:
	CDIB* GetBackground() {return m_pBkgndDIB;}
    CSpriteList* GetSpriteList() {return &m_SpriteList;}
    void GetSceneRect(CRect* prc);
	void Land();
	void Tick();
	void Remove(CBlock* pBlock);
	int MyRand() {return(rand() + m_nSeed);}
	int	GetNumofRows() const {return m_nRow;}
	int	GetNumofCols() const {return m_nCol;}
	int	GetRowHeight() const {return m_nRowHeight;}
	int	GetColWidth()  const {return m_nColWidth;}
	int GetExpertise() const {return m_nExpertise;}
	void Promote();
	char* GetChar();
	void GenerateBlock(int nSlotNo);
	void GameOver(BOOL bHighScore=FALSE); 
	void Hit(WORD wCode);
	void SoundHit();
	void SoundAppear();
	void SoundGround();
	void SoundFire();
	void SoundOver();
	int GetTotalWords() const {return m_nTotalWords;}
	int GetTotalHitWords() const {return m_nTotalHitWords;}
	int GetWordHitInAir() const {return m_nHitInMoving;}
	int GetWordHitInGround() const {return m_nHitInStill;}
	int GetMissedHit() const {return m_nMissedHit;}
	WORD GetFocusChar(CPoint pt);
	BOOL GetKeyStroke(WORD wCode);
// Operations
public:
    BOOL SetBackground(CDIB* pDIB);
    void SoundClick()
        {}
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBlockDoc)
	public:
	virtual BOOL OnNewDocument();
	virtual void DeleteContents();
	//}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CBlockDoc();
    virtual void Serialize(CArchive& ar);   // overridden for document i/o
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
    CDIB* m_pBkgndDIB;          // ptr to background DIB
	CBlock* m_pdibArrow;
    CSpriteList m_SpriteList;   // sprite list
    
    CBlockView* GetBlockView();   // helper fn.
	int		m_nRow;
	int		m_nCol;
	int		m_nRowHeight;
	int	 	m_nColWidth;
	BOOL 	m_bSound;
	BOOL	m_nExpertise;
	int 	m_nTotalWords;
	int 	m_nTotalHitWords;
	int		m_nMissedHit;
	int 	m_nHitInMoving;
	int		m_nHitInStill;
	int 	m_nSeed;
	CBitmap m_bmBlock;
	CSlotManager* m_pSlotManager;



// Generated message map functions
protected:
	//{{AFX_MSG(CBlockDoc)
	afx_msg void OnOPTIONSIZE12x10();
	afx_msg void OnOPTIONSIZE16x16();
	afx_msg void OnOPTIONSIZE4x4();
	afx_msg void OnTestSound();
	afx_msg void OnOptionBeginer();
	afx_msg void OnUpdateOptionBeginer(CCmdUI* pCmdUI);
	afx_msg void OnOptionExpert();
	afx_msg void OnUpdateOptionExpert(CCmdUI* pCmdUI);
	afx_msg void OnUpdateOptionOrdinary(CCmdUI* pCmdUI);
	afx_msg void OnOptionOrdinary();
	afx_msg void OnOptionSound();
	afx_msg void OnUpdateOptionSound(CCmdUI* pCmdUI);
	afx_msg void OnFileStatistic();
	afx_msg void OnTest();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
#define LEVEL_EXPERT  	3
#define LEVEL_ORDINARY	2
#define LEVEL_BEGINNER	1

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\cblocks\dib.cpp ===
/*************************************************
 *  dib.cpp                                      *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

// dib.cpp : implementation file
//
//

#include "stdafx.h"
#include "dib.h"
#include "malloc.h"

#ifdef _DEBUG			  
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define WIDTHBYTES(i)   ((i+31)/32*4)
/////////////////////////////////////////////////////////////////////////////
// CDIB

IMPLEMENT_SERIAL(CDIB, CObject, 0 /* schema number*/ )

// Create a small DIB here so m_pBMI and m_pBits are always valid
CDIB::CDIB()
{
    m_pBMI = NULL;
    m_pBits = NULL;
    m_bMyBits = TRUE;
    Create(16, 16);
}

CDIB::~CDIB()
{
    // free the memory
    if (m_pBMI != NULL) free(m_pBMI);
    if (m_bMyBits && (m_pBits != NULL)) 
   		free(m_pBits);
}

/////////////////////////////////////////////////////////////////////////////
// CDIB serialization

// We dont' support this yet  
void CDIB::Serialize(CArchive& ar)
{
    ar.Flush();
    CFile *fp = ar.GetFile();

    if (ar.IsStoring()) {
        Save(fp);
    } else {
        Load(fp);
    }
}

/////////////////////////////////////////////////////////////////////////////
// Private functions

static BOOL IsWinDIB(BITMAPINFOHEADER *pBIH)
{
    ASSERT(pBIH);
    if (((BITMAPCOREHEADER *)pBIH)->bcSize == sizeof(BITMAPCOREHEADER)) {
        return FALSE;
    }
    return TRUE;
}

static int NumDIBColorEntries(BITMAPINFO *pBmpInfo) 
{
    BITMAPINFOHEADER *pBIH;
    BITMAPCOREHEADER *pBCH;
    int iColors, iBitCount;

    ASSERT(pBmpInfo);

    pBIH = &(pBmpInfo->bmiHeader);
    pBCH = (BITMAPCOREHEADER *) pBIH;

    // start off by assuming the color table size from
    // the bit per pixel field
    if (IsWinDIB(pBIH)) {
        iBitCount = pBIH->biBitCount;
    } else {
        iBitCount = pBCH->bcBitCount;
    }

    switch (iBitCount) {
    case 1:
        iColors = 2;
        break;
    case 4:
        iColors = 16;
        break;
    case 8:
        iColors = 256;
        break;
    default:
        iColors = 0;
        break;
    }

    // If this is a Windows DIB, then the color table length
    // is determined by the biClrUsed field if it is non-zero
    if (IsWinDIB(pBIH) && (pBIH->biClrUsed != 0)) {
        iColors = pBIH->biClrUsed;
    }

    return iColors;
}


/////////////////////////////////////////////////////////////////////////////
// CDIB commands

// Create a new empty 8bpp DIB with a 256 entry color table
BOOL CDIB::Create(int iWidth, int iHeight)
{
    // delete any existing stuff
    if (m_pBMI != NULL) free(m_pBMI);
    if (m_bMyBits && (m_pBits != NULL)) free(m_pBits);

    // allocate memory for the header
    m_pBMI = (BITMAPINFO *) malloc(sizeof(BITMAPINFOHEADER)
                                  + 256 * sizeof(RGBQUAD));
    if (!m_pBMI) {
        TRACE("Out of memory for DIB header");
        return FALSE;
    }

    // allocate memory for the bits (DWORD aligned)
    int iBitsSize = ((iWidth + 3) & ~3) * iHeight;
    m_pBits = (BYTE *)malloc(iBitsSize);
    if (!m_pBits) {
        TRACE("Out of memory for DIB bits");
        free(m_pBMI);
        m_pBMI = NULL;
        return FALSE;
    }
    m_bMyBits = TRUE;

    // fill in the header info
    BITMAPINFOHEADER *pBI = (BITMAPINFOHEADER *) m_pBMI;
    pBI->biSize = sizeof(BITMAPINFOHEADER);
    pBI->biWidth = iWidth;
    pBI->biHeight = iHeight;
    pBI->biPlanes = 1;
    pBI->biBitCount = 8;
    pBI->biCompression = BI_RGB;
    pBI->biSizeImage = 0;
    pBI->biXPelsPerMeter = 0;
    pBI->biYPelsPerMeter = 0;
    pBI->biClrUsed = 0;
    pBI->biClrImportant = 0;

    // create an arb color table (gray scale)
    RGBQUAD *prgb = GetClrTabAddress();
    for (int i = 0; i < 256; i++) {
        prgb->rgbBlue = prgb->rgbGreen = prgb->rgbRed = (BYTE) i;
        prgb->rgbReserved = 0;
        prgb++;
    }

    // set all the bits to a known state (black)
    memset(m_pBits, 0, iBitsSize);

    return TRUE;
}

// Create a CDIB structure from existing header and bits. The DIB
// won't delete the bits and makes a copy of the header.
BOOL CDIB::Create(BITMAPINFO *pBMI, BYTE *pBits)
{
    int  iNumColorEntries;

    ASSERT(pBMI);
    ASSERT(pBits);
    if (m_pBMI != NULL) free(m_pBMI);

    m_pBMI = (BITMAPINFO *) malloc(sizeof(BITMAPINFOHEADER)
                                   + 256 * sizeof(RGBQUAD));
    ASSERT(m_pBMI);

    iNumColorEntries = NumDIBColorEntries(pBMI);
    if ( iNumColorEntries > 256 ) 
       iNumColorEntries = 256;

    memcpy(m_pBMI, pBMI, sizeof(BITMAPINFOHEADER)+
             iNumColorEntries * sizeof(RGBQUAD));

    if (m_bMyBits && (m_pBits != NULL)) free(m_pBits);
    m_pBits = pBits;
    m_bMyBits = FALSE; // we can't delete the bits
    return TRUE;
}


// Load a DIB from an open file.
BOOL CDIB::Load(CFile *fp)
{
    BOOL bIsPM = FALSE;
    BITMAPINFO *pBmpInfo = NULL;
    BYTE *pBits = NULL;

    // get the current file position
    DWORD dwFileStart = fp->GetPosition();

    // read the file header to get the file size and to
    // find where the bits start in the file
    BITMAPFILEHEADER BmpFileHdr;
    int iBytes;
    iBytes = fp->Read(&BmpFileHdr, sizeof(BmpFileHdr));
    if (iBytes != sizeof(BmpFileHdr)) {
        TRACE("Failed to read file header");
        goto $abort;
    }

    // check we have the magic 'BM' at the start
    if (BmpFileHdr.bfType != 0x4D42) {
        TRACE("Not a bitmap file");
        goto $abort;
    }

    // make a wild guess that the file is in Windows DIB
    // format and read the BITMAPINFOHEADER.  If it turns
    // out to be a PM DIB file we'll convert it later.
    BITMAPINFOHEADER BmpInfoHdr;
    iBytes = fp->Read(&BmpInfoHdr, sizeof(BmpInfoHdr)); 
    if (iBytes != sizeof(BmpInfoHdr)) {
        TRACE("Failed to read BITMAPINFOHEADER");
        goto $abort;
    }

    // check we got a real Windows DIB file
    if (BmpInfoHdr.biSize != sizeof(BITMAPINFOHEADER)) {
        if (BmpInfoHdr.biSize != sizeof(BITMAPCOREHEADER)) {
            TRACE(" File is not Windows or PM DIB format");
            goto $abort;
        }

        // set a flag to convert PM file to Win format later
        bIsPM = TRUE;

        // back up the file pointer and read the BITMAPCOREHEADER
        // and create the BITMAPINFOHEADER from it
        fp->Seek(dwFileStart + sizeof(BITMAPFILEHEADER), CFile::begin);
        BITMAPCOREHEADER BmpCoreHdr;
        iBytes = fp->Read(&BmpCoreHdr, sizeof(BmpCoreHdr)); 
        if (iBytes != sizeof(BmpCoreHdr)) {
            TRACE("Failed to read BITMAPCOREHEADER");
            goto $abort;
        }

        BmpInfoHdr.biSize = sizeof(BITMAPINFOHEADER);
        BmpInfoHdr.biWidth = (int) BmpCoreHdr.bcWidth;
        BmpInfoHdr.biHeight = (int) BmpCoreHdr.bcHeight;
        BmpInfoHdr.biPlanes = BmpCoreHdr.bcPlanes;
        BmpInfoHdr.biBitCount = BmpCoreHdr.bcBitCount;
        BmpInfoHdr.biCompression = BI_RGB;
        BmpInfoHdr.biSizeImage = 0;
        BmpInfoHdr.biXPelsPerMeter = 0;
        BmpInfoHdr.biYPelsPerMeter = 0;
        BmpInfoHdr.biClrUsed = 0;
        BmpInfoHdr.biClrImportant = 0;
    }

    // Work out how much memory we need for the BITMAPINFO
    // structure, color table and then for the bits.  
    // Allocate the memory blocks, copy the BmpInfoHdr we have so far 
    // and then read in the color table from the file.
    int iColors;
    int iColorTableSize;
    iColors = NumDIBColorEntries((LPBITMAPINFO) &BmpInfoHdr);
    iColorTableSize = iColors * sizeof(RGBQUAD);
    int iBitsSize;
    int iBISize;
    // always allocate enough room for 256 entries
    iBISize = sizeof(BITMAPINFOHEADER)    
           + 256 * sizeof(RGBQUAD);
    iBitsSize = BmpFileHdr.bfSize - 
                BmpFileHdr.bfOffBits;

    // allocate the memory for the header
    pBmpInfo = (LPBITMAPINFO) malloc(iBISize);
    if (!pBmpInfo) {
        TRACE("Out of memory for DIB header");
        goto $abort;
    }

    // copy the header we already have
    memcpy(pBmpInfo, &BmpInfoHdr, sizeof(BITMAPINFOHEADER));

    // now read the color table in from the file
    if (bIsPM == FALSE) {
        // read the color table from the file
        iBytes = fp->Read(((LPBYTE) pBmpInfo) + sizeof(BITMAPINFOHEADER),
                             iColorTableSize);
        if (iBytes != iColorTableSize) {
            TRACE("Failed to read color table");
            goto $abort;
        }
    } else {
        // read each PM color table entry in turn and convert it
        // to Win DIB format as we go
        LPRGBQUAD lpRGB;
        lpRGB = (LPRGBQUAD) ((LPBYTE) pBmpInfo + sizeof(BITMAPINFOHEADER));
        int i;
        RGBTRIPLE rgbt;
        for (i=0; i<iColors; i++) {
            iBytes = fp->Read(&rgbt, sizeof(RGBTRIPLE));
            if (iBytes != sizeof(RGBTRIPLE)) {
                TRACE("Failed to read RGBTRIPLE");
                goto $abort;
            }
            lpRGB->rgbBlue = rgbt.rgbtBlue;
            lpRGB->rgbGreen = rgbt.rgbtGreen;
            lpRGB->rgbRed = rgbt.rgbtRed;
            lpRGB->rgbReserved = 0;
            lpRGB++;
        }
    }

    // allocate the memory for the bits
    // and read the bits from the file
    pBits = (BYTE *) malloc(iBitsSize);
    if (!pBits) {
        TRACE("Out of memory for DIB bits");
        goto $abort;
    }

    // seek to the bits in the file
    fp->Seek(dwFileStart + BmpFileHdr.bfOffBits, CFile::begin);

    // read the bits
    iBytes = fp->Read(pBits, iBitsSize);
    if (iBytes != iBitsSize) {
        TRACE("Failed to read bits");
        goto $abort;
    }

    // Everything went OK
    if (m_pBMI != NULL) free(m_pBMI);
    m_pBMI = pBmpInfo; 
    if (m_bMyBits && (m_pBits != NULL)) free (m_pBits);
    m_pBits = pBits;
    m_bMyBits = TRUE;
    return TRUE;
                
$abort: // something went wrong
    if (pBmpInfo) free(pBmpInfo);
    if (pBits) free (pBits);
    return FALSE;    
}

// Load a DIB from a disk file.  If no file name is given, show
// an open file dialog to get one.
BOOL CDIB::Load(LPSTR pszFileName)
{
    CString strFile;    

    if ((pszFileName == NULL) 
    ||  (strlen(pszFileName) == 0)) {

        // Show an open file dialog to get the name
        CFileDialog dlg   (TRUE,    // open
                           NULL,    // no default extension
                           NULL,    // no initial file name
                           OFN_FILEMUSTEXIST
                             | OFN_HIDEREADONLY,
                           "Image files (*.DIB, *.BMP)|*.DIB;*.BMP|All files (*.*)|*.*||");
        if (dlg.DoModal() == IDOK) {
            strFile = dlg.GetPathName();
        } else {
            return FALSE;
        }
    } else {
        // copy the supplied file path
        strFile = pszFileName;                    
    }

    // Try to open the file for read access
    CFile file;
    if (! file.Open(strFile,
                    CFile::modeRead | CFile::shareDenyWrite)) {
        AfxMessageBox("Failed to open file");
        return FALSE;
    }

    BOOL bResult = Load(&file);
    file.Close();
    if (!bResult) AfxMessageBox("Failed to load file");
    return bResult;
}

// Draw the DIB to a given DC
void CDIB::Draw(CDC *pDC, int x, int y)
{
    ::StretchDIBits(pDC->GetSafeHdc(),
                  x,                        // dest x
                  y,                        // dest y
                  DibWidth(),                 // dest width
                  DibHeight(),                // dest height
                  0,                        // src x
                  0,                        // src y
                  DibWidth(),                 // src width
                  DibHeight(),                // src height
                  GetBitsAddress(),         // bits
                  GetBitmapInfoAddress(),   // BITMAPINFO
                  DIB_RGB_COLORS,           // options
                  SRCCOPY);                 // rop
}

// get the number of color table entries
int CDIB::GetNumClrEntries()
{
    return NumDIBColorEntries(m_pBMI);
}
int Power(int s)
{
	return s * s;
}

BYTE GetNearest(PALETTEENTRY* pe,int nSize,int R,int G,int B)
{
	int nMin = 99999999; 
	BYTE nIndex = 0;
	for (int i=0; i<nSize; i++)
	{
		int s = Power(R - pe[i].peRed)   + 
		        Power(G - pe[i].peGreen) +
				Power(B - pe[i].peBlue);
	    if (s < nMin)
		{
			nMin = s;
			nIndex = (BYTE)i;
		}
	}
	return nIndex;
}

void CDIB::Inverse()
{
    HWND hwndActive = ::GetActiveWindow();
    HDC hdcScreen = ::GetDC(hwndActive);
    ASSERT(hdcScreen);

    if (!(GetDeviceCaps(hdcScreen, RASTERCAPS) & RC_PALETTE)) 
		return;
    
    int iSysColors = GetDeviceCaps(hdcScreen, NUMCOLORS);
    
	int nColorMode;
	if (iSysColors == 16)
		nColorMode = 16;
	else 
		nColorMode = 256;
	
	

    BYTE *pBits = (BYTE *)GetBitsAddress();
    int iSize = StorageWidth() * DibHeight();
    while (iSize--) 
    {
		*pBits = (nColorMode - *pBits +  10) % nColorMode;
       	pBits++;
    }
}



// NOTE: This assumes all CDIB objects have 256 color table entries
BOOL CDIB::MapColorsToPalette(CPalette *pPal)
{
    if (!pPal) {
        TRACE("No palette to map to");
        return FALSE;
    }
    ASSERT(m_pBMI->bmiHeader.biBitCount == 8);
    ASSERT(m_pBMI);
    ASSERT(m_pBits);
    LPRGBQUAD pctThis = GetClrTabAddress();
    ASSERT(pctThis);
    // build an index translation table to map this DIBs colors
    // to those of the reference DIB
    BYTE imap[256];
    int iChanged = 0; // for debugging only
	int i;

    for (i = 0; i < 256; i++) {

        imap[i] = (BYTE) pPal->GetNearestPaletteIndex(
                            RGB(pctThis->rgbRed,
                                pctThis->rgbGreen,
								pctThis->rgbBlue));
        pctThis++;
        if (imap[i] != i) iChanged++; // for debugging
    }
    // now map the DIB bits
    BYTE *pBits = (BYTE *)GetBitsAddress();
    int iSize = StorageWidth() * DibHeight();
    while (iSize--) {
        *pBits = imap[*pBits];
        pBits++;
    }
    // Now reset the DIB color table so that its RGB values match
    // those in the palette
    PALETTEENTRY pe[256];
    pPal->GetPaletteEntries(0, 256, pe);
    pctThis = GetClrTabAddress();
    for (i = 0; i < 256; i++) {
        pctThis->rgbRed = pe[i].peRed;    
        pctThis->rgbGreen = pe[i].peGreen;    
        pctThis->rgbBlue = pe[i].peBlue;
        pctThis++;    
    }
    return TRUE;
}

// Get a pointer to a pixel
// NOTE: DIB scan lines are DWORD aligned.  The scan line 
// storage width may be wider than the scan line image width
// so calc the storage width by rounding the image width 
// to the next highest dword value
void *CDIB::GetPixelAddress(int x, int y)
{
    int iWidth;
    // This version only deals with 8 bpp DIBs
    ASSERT(m_pBMI->bmiHeader.biBitCount == 8);
    // make sure it's in range and if not return zero
    if ((x >= DibWidth()) 
    || (y >= DibHeight())) {
        TRACE("Attempt to get out of range pixel addr");
        return NULL;
    }

    // Calculate the scan line storage width
    iWidth = StorageWidth();
    return m_pBits + (DibHeight()-y-1) * iWidth + x;
}

// get the bounding rectangle
void CDIB::GetRect(CRect* pRect)
{
    pRect->top = 0;
    pRect->left = 0;
    pRect->bottom = DibHeight();
    pRect->right = DibWidth();
}

// Copy a rectangle of the DIB to another DIB
// Note we only support 8bpp DIBs here
void CDIB::CopyBits(CDIB* pdibDest, 
                    int xd, int yd,
                    int w, int h,
                    int xs, int ys,
                    COLORREF clrTrans)
{
    ASSERT(m_pBMI->bmiHeader.biBitCount == 8);
    ASSERT(pdibDest);
    // test for strange cases
    if (w == 0 || h == 0) return;

    // get pointers to the start points in the source
    // and destination DIBs. Note that this will be the bottom left
    // corner of the DIB as the scan lines are reversed in memory
    BYTE* pSrc = (BYTE*)GetPixelAddress(xs, ys + h - 1);
    ASSERT(pSrc);
    if ( pSrc == NULL )
       return;

    BYTE* pDest = (BYTE*)pdibDest->GetPixelAddress(xd, yd + h - 1);
    ASSERT(pDest);
    if ( pDest == NULL )
       return;

    // get the scan line widths of each DIB
    int iScanS = StorageWidth();
    int iScanD = pdibDest->StorageWidth();

    if (clrTrans == 0xFFFFFFFF) {
        // copy the lines
        while (h--) {
            memcpy(pDest, pSrc, w);
            pSrc += iScanS;
            pDest += iScanD;
        }
    } else {
        // copy lines with transparency
        // We only accept a PALETTEINDEX description
        // for the color definition
        ASSERT((clrTrans & 0xFF000000) == 0x01000000);
        BYTE bTransClr = LOBYTE(LOWORD(clrTrans));
        int iSinc = iScanS - w; // source inc value
        int iDinc = iScanD - w; // dest inc value
        int iCount;
        BYTE pixel;
        while (h--) {
            iCount = w;    // no of pixels to scan
            while (iCount--) {
                pixel = *pSrc++;
                // only copy pixel if not transparent
                if (pixel != bTransClr) {
                    *pDest++ = pixel;
                } else {
                    pDest++;
                }
            }
            // move on to the next line
            pSrc += iSinc;
            pDest += iDinc;
        }
    }
}          

// Save a DIB to a disk file
// This is somewhat simplistic because we only deal with 256 color DIBs
// and we always write a 256 color table
BOOL CDIB::Save(CFile *fp)
{
    BITMAPFILEHEADER bfh;

    // construct the file header
    bfh.bfType = 0x4D42; // 'BM'
    bfh.bfSize = 
        sizeof(BITMAPFILEHEADER) +
        sizeof(BITMAPINFOHEADER) +
        256 * sizeof(RGBQUAD) +
        StorageWidth() * DibHeight();
    bfh.bfReserved1 = 0;
    bfh.bfReserved2 = 0;
    bfh.bfOffBits =
        sizeof(BITMAPFILEHEADER) +
        sizeof(BITMAPINFOHEADER) +
        256 * sizeof(RGBQUAD);

    // write the file header
    int iSize = sizeof(bfh);
    TRY {
        fp->Write(&bfh, iSize);
    } CATCH(CFileException, e) {
        TRACE("Failed to write file header");
        return FALSE;
    } END_CATCH

    // write the BITMAPINFO
    // Note: we assume there are always 256 colors in the
    // color table
    ASSERT(m_pBMI);
    iSize = 
        sizeof(BITMAPINFOHEADER) +
        256 * sizeof(RGBQUAD);
    TRY {
        fp->Write(m_pBMI, iSize);
    } CATCH(CFileException, e) {
        TRACE("Failed to write BITMAPINFO");
        return FALSE;
    } END_CATCH

    // write the bits
    iSize = StorageWidth() * DibHeight();
    TRY {
        fp->Write(m_pBits, iSize);
    } CATCH(CFileException, e) {
        TRACE("Failed to write bits");
        return FALSE;
    } END_CATCH

    return TRUE;
}

// Save a DIB to a disk file.  If no file name is given, show
// a save file dialog to get one.
BOOL CDIB::Save(LPSTR pszFileName)
{
    CString strFile;    

    if ((pszFileName == NULL) 
    ||  (strlen(pszFileName) == 0)) {

        // Show a save file dialog to get the name
        CFileDialog dlg   (FALSE,   // save
                           NULL,    // no default extension
                           NULL,    // no initial file name
                           OFN_OVERWRITEPROMPT
                             | OFN_HIDEREADONLY,
                           "Image files (*.DIB, *.BMP)|*.DIB;*.BMP|All files (*.*)|*.*||");
        if (dlg.DoModal() == IDOK) {
            strFile = dlg.GetPathName();
        } else {
            return FALSE;
        }
    } else {
    
        // copy the supplied file path
        strFile = pszFileName;                    
    }

    // Try to open the file for write access
    CFile file;
    if (! file.Open(strFile,
                    CFile::modeReadWrite
                     | CFile::modeCreate
                     | CFile::shareExclusive)) {
        AfxMessageBox("Failed to open file");
        return FALSE;
    }

    BOOL bResult = Save(&file);
    file.Close();
    if (!bResult) AfxMessageBox("Failed to save file");
    return bResult;
}

WORD DibNumColors (VOID FAR * pv)
{
    INT                 bits;
    LPBITMAPINFOHEADER  lpbi;
    LPBITMAPCOREHEADER  lpbc;

    lpbi = ((LPBITMAPINFOHEADER)pv);
    lpbc = ((LPBITMAPCOREHEADER)pv);

    /*  With the BITMAPINFO format headers, the size of the palette
     *  is in biClrUsed, whereas in the BITMAPCORE - style headers, it
     *  is dependent on the bits per pixel ( = 2 raised to the power of
     *  bits/pixel).
     */
    if (lpbi->biSize != sizeof(BITMAPCOREHEADER)){
        if (lpbi->biClrUsed != 0)
            return (WORD)lpbi->biClrUsed;
        bits = lpbi->biBitCount;
    }
    else
        bits = lpbc->bcBitCount;

    switch (bits){
        case 1:
                return 2;
        case 4:
                return 16;
        case 8:
                return 256;
        default:
                /* A 24 bitcount DIB has no color table */
                return 0;
    }
}

WORD PaletteSize (VOID FAR * pv)
{
    LPBITMAPINFOHEADER lpbi;
    WORD               NumColors;

    lpbi      = (LPBITMAPINFOHEADER)pv;
    NumColors = DibNumColors(lpbi);

    if (lpbi->biSize == sizeof(BITMAPCOREHEADER))
        return (WORD)(NumColors * sizeof(RGBTRIPLE));
    else
        return (WORD)(NumColors * sizeof(RGBQUAD));
}


BOOL CDIB::Load(CBitmap* pBmp)
{
	CPalette* 			pPal;
	BITMAP    			bm;
	BITMAPINFOHEADER 	bi;
	WORD				biBits;
	DWORD				biStyle;
	DWORD				dwLen;
	CDC					dcMem;
	BYTE				*lpbi;
	BYTE				*lpBits;

	if (! pBmp)
		return FALSE;
	
	pPal = CPalette::FromHandle((HPALETTE ) GetStockObject(DEFAULT_PALETTE));
	
	pBmp->GetObject(sizeof(BITMAP),&bm);

	biBits  = 8;
	biStyle = BI_RGB;

    bi.biSize               = sizeof(BITMAPINFOHEADER);
    bi.biWidth              = bm.bmWidth;
    bi.biHeight             = bm.bmHeight;
    bi.biPlanes             = 1;
    bi.biBitCount           = biBits;
    bi.biCompression        = biStyle;
    bi.biSizeImage          = 0;
    bi.biXPelsPerMeter      = 0;
    bi.biYPelsPerMeter      = 0;
    bi.biClrUsed            = 0;
    bi.biClrImportant       = 0;

	dwLen = bi.biSize + PaletteSize (&bi);

	dcMem.CreateCompatibleDC(NULL);
	pPal = dcMem.SelectPalette(pPal,FALSE);
	dcMem.RealizePalette();

	lpbi = (BYTE *) malloc(dwLen);

	memcpy(lpbi,&bi,sizeof(BITMAPINFOHEADER));
	GetDIBits(dcMem.GetSafeHdc(),
	          (HBITMAP) pBmp->GetSafeHandle(),
			  0L,
	          (DWORD) bi.biHeight, 
	          (LPBYTE) NULL,
			  (LPBITMAPINFO)lpbi,
			  (DWORD) DIB_RGB_COLORS);

	memcpy(&bi,lpbi,sizeof(BITMAPINFOHEADER));	
		
    if (bi.biSizeImage == 0)
    {
        bi.biSizeImage = WIDTHBYTES((DWORD)bm.bmWidth * biBits) * bm.bmHeight;
	    if (biStyle != BI_RGB)
            bi.biSizeImage = (bi.biSizeImage * 3) / 2;
    }

    lpBits = (BYTE *) malloc(bi.biSizeImage);

	GetDIBits(dcMem.GetSafeHdc(),
	          (HBITMAP) pBmp->GetSafeHandle(),
			  0L,
	          (DWORD) bi.biHeight, 
	          lpBits,
			  (LPBITMAPINFO)lpbi,
			  (DWORD) DIB_RGB_COLORS);
	dcMem.DeleteDC();

    // because default constructor has created 16x16 bitmap by default
    // so we need to release first, otherwise it will cause memory leack !
    if (m_pBMI)
        delete m_pBMI;
    if (m_pBits)
        delete m_pBits;

	m_pBMI   = (LPBITMAPINFO) lpbi;
    m_pBits  = lpBits;
	m_bMyBits = TRUE;

 	return TRUE;   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\cblocks\cblocks.cpp ===
/*************************************************
 *  cblocks.cpp                                  *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

// block.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include <afxpriv.h>    // for idle-update windows message

#include "cblocks.h"
#include "dib.h"		   
#include "dibpal.h"
#include "spriteno.h"
#include "sprite.h"
#include "phsprite.h"
#include "myblock.h"
#include "splstno.h"
#include "spritlst.h"
#include "mainfrm.h"
#include "osbview.h"
#include "blockvw.h"
#include "blockdoc.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CBlockApp

BEGIN_MESSAGE_MAP(CBlockApp, CWinApp)
    //{{AFX_MSG_MAP(CBlockApp)
	ON_COMMAND(ID_HELP_RULE, OnHelpRule)
	//}}AFX_MSG_MAP
    // Standard file based document commands
    ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
    ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CBlockApp construction

CBlockApp::CBlockApp()
{
    m_pIdleDoc = NULL;
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CBlockApp object

CBlockApp NEAR theApp;

/////////////////////////////////////////////////////////////////////////////
// CBlockApp initialization

BOOL CBlockApp::InitInstance()
{
    // Standard initialization
    // If you are not using these features and wish to reduce the size
    //  of your final executable, you should remove from the following
    //  the specific initialization routines you do not need.

  	Enable3dControls();
  	SetDialogBkColor();        // set dialog background color to gray
    LoadStdProfileSettings();  // Load standard INI file options (including MRU)

    // Register the application's document templates.  Document templates
    //  serve as the connection between documents, frame windows and views.

    AddDocTemplate(new CSingleDocTemplate(IDR_MAINFRAME,
            RUNTIME_CLASS(CBlockDoc),
            RUNTIME_CLASS(CMainFrame),     // main SDI frame window
            RUNTIME_CLASS(CBlockView)));

    OnFileNew();

    // simple command line parsing

    return TRUE;
}


// App command to run the dialog
/////////////////////////////////////////////////////////////////////////////
// CBlockApp commands

BOOL CBlockApp::OnIdle(LONG lCount)
{

	if (lCount == RANK_USER)
	{
		ASSERT(m_pMainWnd != NULL);

		// look for any top-level windows owned by us
		// we use 'HWND's to avoid generation of too many temporary CWnds
		for (HWND hWnd = ::GetWindow(m_pMainWnd->m_hWnd, GW_HWNDFIRST);
				hWnd != NULL; hWnd = ::GetNextWindow(hWnd, GW_HWNDNEXT))
		{
			if (::GetParent(hWnd) == m_pMainWnd->m_hWnd)
			{
				// if owned window is active, move the activation to the
				//   application window
				if (GetActiveWindow() == hWnd && (::GetCapture() == NULL))
					m_pMainWnd->SetActiveWindow();

				// also update the buttons for the top-level window
				SendMessage(hWnd, WM_IDLEUPDATECMDUI, (WPARAM)TRUE, 0L);
			}
		}
	}

	return CWinApp::OnIdle(lCount);
}


void CBlockApp::OnHelpRule() 
{
	::WinHelp(GetFocus(), TEXT("CBLOCKS.HLP"), HELP_FINDER, 0L);
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\cblocks\dib.h ===
/*************************************************
 *  dib.h                                        *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

// dib.h : header file
//
// CDIB class
//

#ifndef __DIB__
#define __DIB__

class CDIB : public CObject
{
    DECLARE_SERIAL(CDIB)
public:
    CDIB();							 
    ~CDIB();
    int DibHeight() 
        {return m_pBMI->bmiHeader.biHeight;}
    int DibWidth()
        {return m_pBMI->bmiHeader.biWidth;}

    int StorageWidth()
        {return (m_pBMI->bmiHeader.biWidth + 3) & ~3;}

    BITMAPINFO *GetBitmapInfoAddress()
        {return m_pBMI;}                        // ptr to bitmap info
    void *GetBitsAddress()
        {return m_pBits;}                       // ptr to the bits
    RGBQUAD *GetClrTabAddress()
        {return (LPRGBQUAD)(((BYTE *)(m_pBMI)) 
            + sizeof(BITMAPINFOHEADER));}       // ptr to color table
    int GetNumClrEntries();                     // number of color table entries
    BOOL Create(int width, int height);         // create a new DIB
    BOOL Create(BITMAPINFO *pBMI, BYTE *pBits); // create from existing mem,
	void Inverse();
    void *GetPixelAddress(int x, int y);
	virtual BOOL Load(CBitmap* pBitmap);
    virtual BOOL Load(CFile *fp);               // load from file
    virtual BOOL Load(char *pszFileName = NULL);// load DIB from disk file
    virtual BOOL Save(char *pszFileName = NULL);// save DIB to disk file
    virtual BOOL Save(CFile *fp);               // save to file
    virtual void Serialize(CArchive& ar);
    virtual void Draw(CDC *pDC, int x, int y);
    virtual int GetWidth() {return DibWidth();}   // image width
    virtual int GetHeight() {return DibHeight();} // image height
    virtual BOOL MapColorsToPalette(CPalette *pPal);
    virtual void GetRect(CRect* pRect);
    virtual void CopyBits(CDIB* pDIB, 
                          int xd, int yd,
                          int w, int h,
                          int xs, int ys,
                          COLORREF clrTrans = 0xFFFFFFFF);


protected:
    BITMAPINFO *m_pBMI;         // pointer to BITMAPINFO struct
    BYTE *m_pBits;              // pointer to the bits
    BOOL m_bMyBits;             // TRUE if DIB owns Bits memory

private:
};

#endif // __DIB__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\cblocks\dibpal.cpp ===
/*************************************************
 *  dibpal.cpp                                   *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

// dibpal.cpp : implementation file
//

#include "stdafx.h"
#include "dibpal.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDIBPal

CDIBPal::CDIBPal()
{
}

CDIBPal::~CDIBPal()
{
}

// Create a palette from the color table in a DIB
BOOL CDIBPal::Create(CDIB *pDIB)
{
    DWORD dwColors = pDIB->GetNumClrEntries();
    // Check the DIB has a color table
    if (! dwColors) {
        TRACE("No color table");   
        return FALSE;
    }

    // get a pointer to the RGB quads in the color table
    RGBQUAD * pRGB = pDIB->GetClrTabAddress();

    // allocate a log pal and fill it with the color table info
    LOGPALETTE *pPal = (LOGPALETTE *) malloc(sizeof(LOGPALETTE) 
                     + dwColors * sizeof(PALETTEENTRY));
    if (!pPal) {
        TRACE("Out of memory for logpal");
        return FALSE;
    }
    pPal->palVersion = 0x300; // Windows 3.0
    pPal->palNumEntries = (WORD) dwColors; // table size
    for (DWORD dw=0; dw<dwColors; dw++) {
        pPal->palPalEntry[dw].peRed = pRGB[dw].rgbRed;
        pPal->palPalEntry[dw].peGreen = pRGB[dw].rgbGreen;
        pPal->palPalEntry[dw].peBlue = pRGB[dw].rgbBlue;
        pPal->palPalEntry[dw].peFlags = 0;
    }
    BOOL bResult = CreatePalette(pPal);
    free (pPal);
    return bResult;
}

/////////////////////////////////////////////////////////////////////////////
// CDIBPal commands

int CDIBPal::GetNumColors()
{
    int iColors = 0;
    if (!GetObject(sizeof(iColors), &iColors)) {
        TRACE("Failed to get num pal colors");
        return 0;
    }
    return iColors;
}

void CDIBPal::Draw(CDC *pDC, CRect *pRect, BOOL bBkgnd)
{
    int iColors = GetNumColors();
    CPalette *pOldPal = pDC->SelectPalette(this, bBkgnd);
    pDC->RealizePalette();
    int i, j, top, left, bottom, right;
    for (j=0, top=0; j<16 && iColors; j++, top=bottom) {
        bottom = (j+1) * pRect->bottom / 16 + 1;
        for(i=0, left=0; i<16 && iColors; i++, left=right) {
            right = (i+1) * pRect->right / 16 + 1;
            CBrush br (PALETTEINDEX(j * 16 + i));
            CBrush *brold = pDC->SelectObject(&br);
            pDC->Rectangle(left-1, top-1, right, bottom);
            pDC->SelectObject(brold);
            iColors--;
        }
    }
    pDC->SelectPalette(pOldPal, FALSE);
}

BYTE Color16[16][3] = {{0,0,0},{128,0,0},{0,128,0},{128,128,0},
                       {0,0,128},{128,0,128},{0,128,128},{192,192,192},
                                           {128,128,128},{255,0,0},{0,255,0},{255,255,0},
                                           {0,0,255},{255,0,255},{0,255,255},{255,255,255}};


BOOL CDIBPal::SetSysPalColors()
{
    BOOL bResult = FALSE;
    int i, iSysColors, iPalEntries;
    HPALETTE hpalOld;
        int nColorMode;
    // Get a screen DC to work with
    HWND hwndActive = ::GetActiveWindow();
    HDC hdcScreen = ::GetDC(hwndActive);
    ASSERT(hdcScreen);

    // Make sure we are on a palettized device
    if (!(GetDeviceCaps(hdcScreen, RASTERCAPS) & RC_PALETTE)) {
        TRACE("Not a palettized device");
        goto abort;
    }

    // Get the number of system colors and the number of palette entries
    // Note that on a palletized device the number of colors is the
    // number of guaranteed colors.  I.e. the number of reserved system colors
    iSysColors = GetDeviceCaps(hdcScreen, NUMCOLORS);
    iPalEntries = GetDeviceCaps(hdcScreen, SIZEPALETTE);
        if (iSysColors > 256) goto abort;

        if (iSysColors == -1)
                nColorMode = 16;
        else if (iPalEntries == 0)
                nColorMode = 4;
        else
                nColorMode = 8;
    
    SetSystemPaletteUse(hdcScreen, SYSPAL_NOSTATIC);
    SetSystemPaletteUse(hdcScreen, SYSPAL_STATIC);

    hpalOld = ::SelectPalette(hdcScreen,
                              (HPALETTE)m_hObject, // our hpal
                              FALSE);
    ::RealizePalette(hdcScreen);
    ::SelectPalette(hdcScreen, hpalOld, FALSE);

    PALETTEENTRY pe[256];
        switch (nColorMode)
        {
                case 4:
                {
                        iPalEntries = 16;                       
                        for (i = 0; i <iPalEntries ; i++) 
                        {
                        pe[i].peFlags = PC_NOCOLLAPSE;
                                pe[i].peRed = Color16[i][0];
                                pe[i].peGreen = Color16[i][1];
                                pe[i].peBlue = Color16[i][2];
                        }
                }
                break;
                case 16:
                    iPalEntries = 256;                      
                    iSysColors  = 20;
                    break;
                case 8:
                {
                  int nCount =  GetSystemPaletteEntries(hdcScreen, 
                            0,
                            iPalEntries,
                            pe);

                for (i = 0; i < iSysColors/2; i++) 
                        pe[i].peFlags = 0;
                for (; i < iPalEntries-iSysColors/2; i++) 
                        pe[i].peFlags = PC_NOCOLLAPSE;
                for (; i < iPalEntries; i++) 
                        pe[i].peFlags = 0;
                }                                                                   
                break;
                
        }
    ResizePalette(iPalEntries);

    SetPaletteEntries(0, iPalEntries, pe);
//      for (i=0; i<iPalEntries; i++)
//      {
//              TRACE("%d>>%d:%d:%d\n",i,pe[i].peRed,pe[i].peGreen,pe[i].peBlue);
//      }
    bResult = TRUE;

abort:
    ::ReleaseDC(hwndActive, hdcScreen);
    return bResult;
}

// Load a palette from a named file
BOOL CDIBPal::Load(char *pszFileName)
{
    CString strFile;    

    if ((pszFileName == NULL) 
    ||  (strlen(pszFileName) == 0)) {

        // Show an open file dialog to get the name
        CFileDialog dlg   (TRUE,    // open
                           NULL,    // no default extension
                           NULL,    // no initial file name
                           OFN_FILEMUSTEXIST
                             | OFN_HIDEREADONLY,
                           "Palette files (*.PAL)|*.PAL|All files (*.*)|*.*||");
        if (dlg.DoModal() == IDOK) {
            strFile = dlg.GetPathName();
        } else {
            return FALSE;
        }
    } else {    
        // copy the supplied file path
        strFile = pszFileName;                    
    }

    // Try to open the file for read access
    CFile file;
    if (! file.Open(strFile,
                    CFile::modeRead | CFile::shareDenyWrite)) {
        AfxMessageBox("Failed to open file");
        return FALSE;
    }

    BOOL bResult = Load(&file);
    file.Close();
    if (!bResult) AfxMessageBox("Failed to load file");
    return bResult;
}

// Load a palette from an open CFile object
BOOL CDIBPal::Load(CFile *fp)
{
    return Load(fp->m_hFile);
}

// Load a palette from an open file handle
BOOL CDIBPal::Load(UINT_PTR hFile)
{
    HMMIO hmmio;
    MMIOINFO info;
    memset(&info, 0, sizeof(info));
    info.adwInfo[0] = (DWORD)hFile;
    hmmio = mmioOpen(NULL,
                     &info,
                     MMIO_READ | MMIO_ALLOCBUF);
    if (!hmmio) {
        TRACE("mmioOpen failed");
        return FALSE;
    }
    BOOL bResult = Load(hmmio);
    mmioClose(hmmio, MMIO_FHOPEN);
    return bResult;
}

// Load a palette from an open MMIO handle
BOOL CDIBPal::Load(HMMIO hmmio)
{
    // Check it's a RIFF PAL file
    MMCKINFO ckFile;
    ckFile.fccType = mmioFOURCC('P','A','L',' ');
    if (mmioDescend(hmmio,
                    &ckFile,
                    NULL,
                    MMIO_FINDRIFF) != 0) {
        TRACE("Not a RIFF or PAL file");
        return FALSE;
    }
    // Find the 'data' chunk
    MMCKINFO ckChunk;
    ckChunk.ckid = mmioFOURCC('d','a','t','a');
    if (mmioDescend(hmmio,
                    &ckChunk,
                    &ckFile,
                    MMIO_FINDCHUNK) != 0) {
        TRACE("No data chunk in file");
        return FALSE;
    }
    // allocate some memory for the data chunk
    int iSize = ckChunk.cksize;
    void *pdata = malloc(iSize);
    if (!pdata) {
        TRACE("No mem for data");
        return FALSE;
    }
    // read the data chunk
    if (mmioRead(hmmio,
                 (char *)pdata,
                 iSize) != iSize) {
        TRACE("Failed to read data chunk");
        free(pdata);
        return FALSE;
    }
    // The data chunk should be a LOGPALETTE structure
        // which we can create a palette from
        LOGPALETTE* pLogPal = (LOGPALETTE*)pdata;
        if (pLogPal->palVersion != 0x300) {
                TRACE("Invalid version number");
        free(pdata);
        return FALSE;
        }
        // Get the number of entries
        int iColors = pLogPal->palNumEntries;
        if (iColors <= 0) {
                TRACE("No colors in palette");
        free(pdata);
        return FALSE;
        }
        return CreatePalette(pLogPal);
}

// Save a palette to an open CFile object
BOOL CDIBPal::Save(CFile *fp)
{
    return Save(fp->m_hFile);
}

// Save a palette to an open file handle
BOOL CDIBPal::Save(UINT_PTR hFile)
{
    HMMIO hmmio;
    MMIOINFO info;
    memset(&info, 0, sizeof(info));
    info.adwInfo[0] = (DWORD)hFile;
    hmmio = mmioOpen(NULL,
                     &info,
                     MMIO_WRITE | MMIO_CREATE | MMIO_ALLOCBUF);
    if (!hmmio) {
        TRACE("mmioOpen failed");
        return FALSE;
    }
    BOOL bResult = Save(hmmio);
    mmioClose(hmmio, MMIO_FHOPEN);
    return bResult;
}

// Save a palette to an open MMIO handle
BOOL CDIBPal::Save(HMMIO hmmio)
{
        // Create a RIFF chunk for a PAL file
    MMCKINFO ckFile;
        ckFile.cksize = 0; // corrected later
    ckFile.fccType = mmioFOURCC('P','A','L',' ');
    if (mmioCreateChunk(hmmio,
                        &ckFile,
                        MMIO_CREATERIFF) != 0) {
        TRACE("Failed to create RIFF-PAL chunk");
        return FALSE;
    }
        // create the LOGPALETTE data which will become
        // the data chunk
        int iColors = GetNumColors();
        ASSERT(iColors > 0);
        int iSize = sizeof(LOGPALETTE)
                                + (iColors-1) * sizeof(PALETTEENTRY);
        LOGPALETTE* plp = (LOGPALETTE*) malloc(iSize);
        ASSERT(plp);
        plp->palVersion = 0x300;
        plp->palNumEntries = (unsigned short) iColors;
        GetPaletteEntries(0, iColors, plp->palPalEntry);
        // create the data chunk
    MMCKINFO ckData;
        ckData.cksize = iSize; 
    ckData.ckid = mmioFOURCC('d','a','t','a');
    if (mmioCreateChunk(hmmio,
                        &ckData,
                        0) != 0) {
        TRACE("Failed to create data chunk");
        return FALSE;
    }
        // write the data chunk
    if (mmioWrite(hmmio,
                 (char*)plp,
                 iSize) != iSize) {
        TRACE("Failed to write data chunk");
        free(plp);
        return FALSE;
    }
        free(plp);
        // Ascend from the data chunk which will correct the length
        mmioAscend(hmmio, &ckData, 0);
        // Ascend from the RIFF/PAL chunk
        mmioAscend(hmmio, &ckFile, 0);

        return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\cblocks\dibpal.h ===
/*************************************************
 *  dibpal.h                                     *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

// dibpal.h : header file
//
// CDIBPal class
//

#ifndef __DIBPAL__
#define __DIBPAL__

#include "dib.h"

class CDIBPal : public CPalette	    
{
public:
    CDIBPal();
    ~CDIBPal();
    BOOL Create(CDIB *pDIB);            // create from a DIB
    void Draw(CDC *pDC, CRect *pRect, BOOL bBkgnd = FALSE); 
    int GetNumColors();                 // get the no. of colors in the pal.
    BOOL SetSysPalColors();
    BOOL Load(char *pszFileName = NULL);
    BOOL Load(CFile *fp);  
    BOOL Load(UINT_PTR hFile);
    BOOL Load(HMMIO hmmio);
    BOOL Save(CFile *fp);  
    BOOL Save(UINT_PTR hFile);
    BOOL Save(HMMIO hmmio);
};

#endif // __DIBPAL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\cblocks\mainfrm.h ===
/*************************************************
 *  mainfrm.h                                    *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

// mainfrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////
#include "mybar.h"
#include "mystatus.h"
class CMainFrame : public CFrameWnd
{
protected: // create from serialization only
	CMainFrame();
	DECLARE_DYNCREATE(CMainFrame)   

// Attributes
public:

// Operations
public:
	

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	public:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // control bar embedded members
	CMyStatusBar  m_wndStatusBar;
	CMyToolBar    m_wndToolBar;

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnPaletteChanged(CWnd* pFocusWnd);
	afx_msg BOOL OnQueryNewPalette();
	afx_msg void OnMenuSelect( UINT nItemID, UINT nFl, HMENU hSysMenu );
	afx_msg void OnFire();
	afx_msg void OnToolPause();
	afx_msg void OnToolResume();
	afx_msg void OnDestroy();
	//}}AFX_MSG
	afx_msg void OnUpdateStatus(CCmdUI* pCmdUI);
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\cblocks\mainfrm.cpp ===
/*************************************************
 *  mainfrm.cpp                                  *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

// mainfrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include "cblocks.h"
#include "mybar.h"
#include "dib.h"
#include "dibpal.h"
#include "spriteno.h"
#include "sprite.h"											    
#include "phsprite.h"
#include "myblock.h"
#include "splstno.h"
#include "spritlst.h"
#include "osbview.h"
#include "slot.h"
#include "about.h"
#include "blockvw.h"
#include "blockdoc.h"

#include "mainfrm.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

extern long GScore;
extern CString GHint;
/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
	ON_WM_CREATE()
	ON_WM_PALETTECHANGED()
	ON_WM_QUERYNEWPALETTE()
	ON_WM_MENUSELECT()
	ON_COMMAND(ID_FIRE,OnFire)
	ON_COMMAND(ID_TOOL_PAUSE,OnToolPause)
	ON_COMMAND(ID_TOOL_RESUME,OnToolResume)
	ON_COMMAND(ID_TOOL_RESUME,OnToolPause)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
	ON_UPDATE_COMMAND_UI(ID_SCOREPROMPT,OnUpdateStatus)
	ON_UPDATE_COMMAND_UI(ID_SCORE,OnUpdateStatus)
	ON_UPDATE_COMMAND_UI(ID_HINT,OnUpdateStatus)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// arrays of IDs used to initialize control bars
	
// toolbar buttons - IDs are command buttons
static UINT BASED_CODE buttons[] =
{
	// same order as in the bitmap 'toolbar.bmp'
    ID_FILE_SUSPEND,
    ID_SEPARATOR,   
	ID_SEPARATOR,   
    ID_ACTION_SLOW,
	ID_ACTION_NORMALSLOW,
    ID_ACTION_NORMAL,
	ID_ACTION_NORMALFAST,
    ID_ACTION_FAST,
    ID_SEPARATOR,   
	ID_SEPARATOR,   
	ID_OPTION_BEGINER,
	ID_OPTION_ORDINARY,
	ID_OPTION_EXPERT,
	ID_SEPARATOR,   
	ID_SEPARATOR,   
    ID_HELP_RULE

};

static UINT BASED_CODE indicators[] =
{
	ID_SEPARATOR,           // status line indicator
	ID_HINT,
	ID_SCOREPROMPT,
	ID_SCORE
//	ID_BLANK5
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
	// TODO: add member initialization code here
	
}

CMainFrame::~CMainFrame()
{
}

HFONT hFont=NULL;

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	if (!m_wndToolBar.Create(this) ||
		!m_wndToolBar.LoadBitmap(IDR_MAINFRAME) ||
		!m_wndToolBar.SetButtons(buttons,
		  sizeof(buttons)/sizeof(UINT)))
	{
		TRACE0("Failed to create toolbar\n");
		return -1;      // fail to create
	}

	if (!m_wndStatusBar.Create(this) ||
		!m_wndStatusBar.SetIndicators(indicators,
		  sizeof(indicators)/sizeof(UINT)))
	{
		TRACE0("Failed to create status bar\n");
		return -1;      // fail to create
	}

	m_wndToolBar.SetBarStyle(m_wndToolBar.GetBarStyle() |
		CBRS_TOOLTIPS | CBRS_FLYBY);

  	UINT nID, nStyle;
  	int cxWidth;
	CString szPrompt;

	szPrompt.LoadString(ID_SCOREPROMPT);

	CRect rc;
	GetClientRect(&rc);

	LOGFONT lf;
	memset(&lf,0,sizeof(LOGFONT));
	lf.lfHeight = 12;
	lf.lfCharSet = CHINESEBIG5_CHARSET;
	lstrcpy(lf.lfFaceName,TEXT(""));
	HFONT hFont = CreateFontIndirect(&lf);
    m_wndStatusBar.SendMessage(WM_SETFONT,(WPARAM)hFont,0);

//	m_wndStatusBar.GetPaneInfo(0,nID,nStyle,cxWidth);
//	m_wndStatusBar.SetPaneInfo(0,nID,nStyle,rc.Width()/4);
	
//	m_wndStatusBar.GetPaneInfo(m_wndStatusBar.CommandToIndex(ID_SCOREPROMPT),nID,nStyle,cxWidth);
//	m_wndStatusBar.SetPaneInfo(m_wndStatusBar.CommandToIndex(ID_SCOREPROMPT),nID,SBPS_NOBORDERS,cxWidth);
//	m_wndStatusBar.GetPaneInfo(m_wndStatusBar.CommandToIndex(ID_SCORE),nID,nStyle,cxWidth);
//	m_wndStatusBar.SetPaneInfo(m_wndStatusBar.CommandToIndex(ID_SCORE),nID,nStyle,cxWidth);
//	m_wndStatusBar.GetPaneInfo(m_wndStatusBar.CommandToIndex(ID_HINT),nID,nStyle,cxWidth);
//	m_wndStatusBar.SetPaneInfo(m_wndStatusBar.CommandToIndex(ID_HINT),nID,nStyle,cxWidth);
	return 0;
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	cs.style = WS_OVERLAPPED | WS_CAPTION | FWS_ADDTOTITLE
		| WS_SYSMENU | WS_MINIMIZEBOX;

	return CFrameWnd::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
	CFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers

void CMainFrame::OnPaletteChanged(CWnd* pFocusWnd) 
{
	CFrameWnd::OnPaletteChanged(pFocusWnd);
	
    CView *pview = GetActiveView();
    if (pview) {
        // OnPaletteChanged is not public
        pview->SendMessage(WM_PALETTECHANGED,
                           (WPARAM)(pFocusWnd->GetSafeHwnd()),
                           (LPARAM)0);
    }
	
}

BOOL CMainFrame::OnQueryNewPalette() 
{
    CView *pview = GetActiveView();
    if (pview) {
        return (BOOL)(pview->SendMessage(WM_QUERYNEWPALETTE,
                           (WPARAM)0,
                           (LPARAM)0) );
    }
	
	return CFrameWnd::OnQueryNewPalette();
}

void CMainFrame::OnUpdateStatus(CCmdUI* pCmdUI)
{
	static long nScore = -1;
	static CString szHint="1";

	pCmdUI->Enable();
	if (pCmdUI->m_nID == ID_SCORE)
	{
		if (nScore != GScore)
		{
			static char szBuf[20];
			wsprintf(szBuf,"%ld",GScore);
			m_wndStatusBar.SetPaneText(m_wndStatusBar.CommandToIndex(ID_SCORE),szBuf);
			nScore = GScore;
		}
	}
	else if (pCmdUI->m_nID == ID_HINT)
	{
		if (szHint != GHint)
		{
			m_wndStatusBar.SetPaneText(m_wndStatusBar.CommandToIndex(ID_HINT),GHint);		
			szHint = GHint;
		}
	}
}

void CMainFrame::OnMenuSelect( UINT nItemID, UINT nFlag, HMENU hMenu )
{
	CWnd::OnMenuSelect( nItemID, nFlag,  hMenu );
	CView* pView = GetActiveView();
	pView->SendMessage(WM_MENUSELECT, MAKELONG(nItemID,  nFlag),  (LPARAM)hMenu );
}


void CMainFrame::OnFire() 
{
	static BOOL bOn = TRUE;
	CBlockView *pView = (CBlockView *)GetActiveView();
	if (pView)
	{
		if (bOn)
		    pView->ForceSpeed(0);
		else
		    pView->ForceSpeed(GSpeed);
		bOn = !bOn;
		//pView->GetDocument()->UpdateAllViews(NULL);
	}
}

void CMainFrame::OnToolPause()
{
	CBlockView *pView = (CBlockView *)GetActiveView();
	if (pView)
	{
	    pView->ForceSpeed(0);
	}
}

void CMainFrame::OnToolResume()
{
	CBlockView *pView = (CBlockView *)GetActiveView();
	if (pView)
	{
	    pView->ForceSpeed(GSpeed);
	}
}


void CMainFrame::OnDestroy() 
{
	CFrameWnd::OnDestroy();
	
	if (hFont != NULL)
		DeleteObject(hFont);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\cblocks\mem.h ===
/*************************************************
 *  mem.h                                        *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

// mem.h
//
// Win32s works better if you use GlobalAlloc for large memory
// blocks so the CWave and CDIB classes use the ALLOC and FREE
// macros defined here so you can optionally use either
// malloc (for pure 32 bit platforms) or GlobalAlloc if you
// want the app to run on Win32s

#define USE_GLOBALALLOC 1
								   
#ifdef USE_GLOBALALLOC

    #define ALLOC(s) GlobalAlloc(GPTR, s)
    #define FREE(p) GlobalFree(p)

#else

    #define ALLOC(s) malloc(s)
    #define FREE(p) free(p)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\cblocks\mybar.h ===
/*************************************************
 *  mybar.h                                      *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

#ifndef _MYBAR_H_
#define _MYBAR_H_

class CMyToolBar : public CToolBar
{
public:
	CMyToolBar(){};			  
	virtual void DestroyToolTip(BOOL bIdleStatus,BOOL bResetTimer);
protected:
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\cblocks\mybar.cpp ===
/*************************************************
 *  mybar.cpp                                    *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

#include "stdafx.h"
#include "cblocks.h"
#include "mybar.h"

void CMyToolBar::DestroyToolTip(BOOL bIdleStatus,BOOL bResetTimer)
{
//	CToolBar::DestroyToolTip( bIdleStatus, bResetTimer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\cblocks\myblock.cpp ===
/*************************************************
 *  myblock.cpp                                  *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

// mysprite.cpp : implementation file
//
 
#include "stdafx.h"
#include "dib.h"
#include "spriteno.h"
#include "sprite.h"
#include "phsprite.h"
#include "myblock.h"
#include "splstno.h"
#include "spritlst.h"
#include "blockdoc.h"
#include "math.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CBlock

IMPLEMENT_SERIAL(CBlock, CPhasedSprite, 0 /* schema number*/ )

CBlock::CBlock()
{
    m_mass = 0;
    m_vx = 0;
    m_vy = 0;
    m_dx = 0;
    m_dy = 0;
}

CBlock::~CBlock()
{
}

/////////////////////////////////////////////////////////////////////////////
// CBlock serialization

void CBlock::Serialize(CArchive& ar)
{
    CSprite::Serialize(ar);
    if (ar.IsStoring())
    {
        // ar << (DWORD) m_...;
    }
    else
    {
        // DWORD dw;
        // ar >> dw;
        // ....(dw);
    }
}

/////////////////////////////////////////////////////////////////////////////
// CBlock commands

void CBlock::SetMass(int iMass)
{
    m_mass = iMass;
}

void CBlock::SetVelocity(int iVX, int iVY)
{
    m_vx = iVX;
    m_vy = iVY;
}

// Update the position
int CBlock::UpdatePosition(CBlockDoc *pDoc)
{
    int d, x, y;
    x = m_x;
    y = m_y;
    CRect rcDoc;
    pDoc->GetSceneRect(&rcDoc);
    BOOL bChanged = FALSE;
    if (m_vx != 0) {
        m_dx += m_vx;
        d = m_dx / 100;
        if (d != 0) {
            x = m_x + d;
            m_dx = m_dx % 100;
            bChanged = TRUE;
            if (m_vx > 0) {
                if (x > rcDoc.right) x = -GetWidth();
            } else {
                if (x < -GetWidth()) x = rcDoc.right;
            }
        }
    }
    if (m_vy != 0) {
        m_dy += m_vy;
        d = m_dy / 100;
        if (d != 0) {
            y = m_y + d;
            m_dy = m_dy % 100;
            bChanged = TRUE;
            if (m_vy > 0) {
                if (y > rcDoc.bottom) y = -GetHeight();
            } else {
                if (y < -(GetHeight() <<1) ) y = rcDoc.bottom;
            }
        }
    }
    if (bChanged) {
        SetPosition(x, y);
        return 1;
    }
    return 0;
}

// test for sprite collision
int CBlock::CollideTest(CBlock* pSprite)
{
    // Do simple rectangle test first
    CRect rcThis, rcOther;
    GetRect(&rcThis);
    pSprite->GetRect(&rcOther);
    if (!rcThis.IntersectRect(&rcThis, &rcOther)) {
        // rectangles don't everlap
        return 0;
    }

    // The rectangles overlap
    // Compute the coordinates of the centers of the objects
    CRect rc1, rc2;
    GetRect(&rc1);
    pSprite->GetRect(&rc2);
    int x1 = rc1.left + (rc1.right - rc1.left) / 2;
    int y1 = rc1.top + (rc1.bottom - rc1.top) / 2;
    int x2 = rc2.left + (rc2.right - rc2.left) / 2;
    int y2 = rc2.top + (rc2.bottom - rc2.top) / 2;

    // compute the distance apart
    int dx = x1 - x2;
    int dy = y1 - y2;
    double d = sqrt(dx * dx + dy * dy);

    // see if they overlap
    if (d < (rc1.right - rc1.left) / 2 + (rc2.right - rc2.left) / 2) {
        return 1;
    }

    return 0;
}

// Collision handler
int CBlock::OnCollide(CBlock* pSprite, CBlockDoc* pDoc)
{
    // Do some physics
    if ((m_vx == 0) && (m_vy == 0)
    && (pSprite->GetX() == 0) && (pSprite->GetY() == 0)) {
        return 0;
    }

    // Compute the coordinates of the centers of the objects
    CRect rc1, rc2;
    GetRect(&rc1);
    pSprite->GetRect(&rc2);
    int x1 = rc1.left + (rc1.right - rc1.left) / 2;
    int y1 = rc1.top + (rc1.bottom - rc1.top) / 2;
    int x2 = rc2.left + (rc2.right - rc2.left) / 2;
    int y2 = rc2.top + (rc2.bottom - rc2.top) / 2;

    // compute the angle of the line joining the centers
    double a = atan2(y2 - y1, x2 - x1);
    double cos_a = cos(a);
    double sin_a = sin(a);

    // compute the velocities normal and perp
    // to the center line
    double vn1 = m_vx * cos_a + m_vy * sin_a;
    double vp1 = m_vy * cos_a - m_vx * sin_a;
    int vx2, vy2;
    pSprite->GetVelocity(&vx2, &vy2);
    double vn2 = vx2 * cos_a + vy2 * sin_a;
    double vp2 = vy2 * cos_a - vx2 * sin_a;

    // compute the momentum along the center line
    double m1 = m_mass;
    double m2 = pSprite->GetMass();
    double k = m1 * vn1 + m2 * vn2;

    // compute the energy
    double e = 0.5 * m1 * vn1 * vn1 + 0.5 * m2 * vn2 * vn2;
    
    // there are two possible solutions to the equations.
    // compute both and choose
    double temp1 = sqrt(k*k - ((m1/m2)+1)*(-2*e*m1 + k*k));
    double vn2p1 = (k + temp1) / (m1+m2);
    double vn2p2 = (k - temp1) / (m1+m2);

    // choose the soln. which is not the current state
    if (vn2p1 == vn2) {
        vn2 = vn2p2;
    } else {
        vn2 = vn2p1;
    }

    // compute the new vn1 value
    vn1 = (k - m2*vn2) / m1;


    // compute the new x and y velocities
    int vx1 = (int)(vn1 * cos_a - vp1 * sin_a);
    int vy1 = (int)(vn1 * sin_a + vp1 * cos_a); 
    vx2 = (int)(vn2 * cos_a - vp2 * sin_a);
    vy2 = (int)(vn2 * sin_a + vp2 * cos_a); 

    m_vx = vx1;
    m_vy = vy1;
    pSprite->SetVelocity(vx2, vy2);

    // move the sprites until they are no longer in collision
    if ((m_vx != 0) || (m_vy != 0) || (vx2 != 0) || (vy2 != 0)) {
        while(CollideTest(pSprite)) {
            UpdatePosition(pDoc);
            pSprite->UpdatePosition(pDoc);
        }
    }

    return 1; // say something changed
}

void CBlock::Stop()
{
	SetVelocity(0,0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\cblocks\myblock.h ===
/*************************************************
 *  myblock.h                                    *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

// mysprite.h : header file
//
// CBlock class
//		   
//

class CBlockDoc;

class CBlock : public CPhasedSprite
{
    DECLARE_SERIAL(CBlock)
public:
    CBlock();
    ~CBlock();
    void SetMass(int iMass);
    int GetMass() {return m_mass;}
    void GetVelocity(int* pvx, int* pvy)
        {*pvx = m_vx; *pvy = m_vy;}
    void SetVelocity(int iVX, int iVY);
	void SetCode(WORD wCode) {m_wCode = wCode;}
	WORD GetCode() const {return m_wCode;}
    int UpdatePosition(CBlockDoc *pDoc);
    int CollideTest(CBlock* pSprite);
    int OnCollide(CBlock* pSprite, CBlockDoc *pDoc);
  	void Stop();
	BOOL Hit(WORD wCode) {return m_wCode == wCode;}
    virtual void Serialize(CArchive& ar);

private:
    int m_mass;
    int m_vx;
    int m_vy;
    int m_dx;
    int m_dy;
	WORD m_wCode;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\cblocks\mysprite.cpp ===
/*************************************************
 *  mysprite.cpp                                 *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

// mysprite.cpp : implementation file
//

#include "stdafx.h"
#include "dib.h"
#include "spriteno.h"
#include "sprite.h"
#include "phsprite.h"
#include "mysprite.h"
#include "mciobj.h"
#include "splstno.h"
#include "spritlst.h"
#include "animdoc.h"
#include "math.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CBlock

IMPLEMENT_SERIAL(CBlock, CPhasedSprite, 0 /* schema number*/ )

CBlock::CBlock()
{
    m_mass = 0;
    m_vx = 0;
    m_vy = 0;
    m_dx = 0;
    m_dy = 0;
}

CBlock::~CBlock()
{
}

/////////////////////////////////////////////////////////////////////////////
// CBlock serialization

void CBlock::Serialize(CArchive& ar)
{
    CSprite::Serialize(ar);
    if (ar.IsStoring())
    {
        // ar << (DWORD) m_...;
    }
    else
    {
        // DWORD dw;
        // ar >> dw;
        // ....(dw);
    }
}

/////////////////////////////////////////////////////////////////////////////
// CBlock commands

void CBlock::SetMass(int iMass)
{
    m_mass = iMass;
}

void CBlock::SetVelocity(int iVX, int iVY)
{
    m_vx = iVX;
    m_vy = iVY;
}

// Update the position
int CBlock::UpdatePosition(CBlockDoc *pDoc)
{
    int d, x, y;
    x = m_x;
    y = m_y;
    CRect rcDoc;
    pDoc->GetSceneRect(&rcDoc);
    BOOL bChanged = FALSE;
    if (m_vx != 0) {
        m_dx += m_vx;
        d = m_dx / 100;
        if (d != 0) {
            x = m_x + d;
            m_dx = m_dx % 100;
            bChanged = TRUE;
            if (m_vx > 0) {
                if (x > rcDoc.right) x = -GetWidth();
            } else {
                if (x < -GetWidth()) x = rcDoc.right;
            }
        }
    }
    if (m_vy != 0) {
        m_dy += m_vy;
        d = m_dy / 100;
        if (d != 0) {
            y = m_y + d;
            m_dy = m_dy % 100;
            bChanged = TRUE;
            if (m_vy > 0) {
                if (y > rcDoc.bottom) y = -GetHeight();
            } else {
                if (y < -(GetHeight() <<1) ) y = rcDoc.bottom;
            }
        }
    }
    if (bChanged) {
        SetPosition(x, y);
        return 1;
    }
    return 0;
}

// test for sprite collision
int CBlock::CollideTest(CBlock* pSprite)
{
    // Do simple rectangle test first
    CRect rcThis, rcOther;
    GetRect(&rcThis);
    pSprite->GetRect(&rcOther);
    if (!rcThis.IntersectRect(&rcThis, &rcOther)) {
        // rectangles don't everlap
        return 0;
    }

    // The rectangles overlap
    // Compute the coordinates of the centers of the objects
    CRect rc1, rc2;
    GetRect(&rc1);
    pSprite->GetRect(&rc2);
    int x1 = rc1.left + (rc1.right - rc1.left) / 2;
    int y1 = rc1.top + (rc1.bottom - rc1.top) / 2;
    int x2 = rc2.left + (rc2.right - rc2.left) / 2;
    int y2 = rc2.top + (rc2.bottom - rc2.top) / 2;

    // compute the distance apart
    int dx = x1 - x2;
    int dy = y1 - y2;
    double d = sqrt(dx * dx + dy * dy);

    // see if they overlap
    if (d < (rc1.right - rc1.left) / 2 + (rc2.right - rc2.left) / 2) {
        return 1;
    }

    return 0;
}

// Collision handler
int CBlock::OnCollide(CBlock* pSprite, CBlockDoc* pDoc)
{
    // Do some physics
    if ((m_vx == 0) && (m_vy == 0)
    && (pSprite->GetX() == 0) && (pSprite->GetY() == 0)) {
        return 0;
    }

    // Compute the coordinates of the centers of the objects
    CRect rc1, rc2;
    GetRect(&rc1);
    pSprite->GetRect(&rc2);
    int x1 = rc1.left + (rc1.right - rc1.left) / 2;
    int y1 = rc1.top + (rc1.bottom - rc1.top) / 2;
    int x2 = rc2.left + (rc2.right - rc2.left) / 2;
    int y2 = rc2.top + (rc2.bottom - rc2.top) / 2;

    // compute the angle of the line joining the centers
    double a = atan2(y2 - y1, x2 - x1);
    double cos_a = cos(a);
    double sin_a = sin(a);

    // compute the velocities normal and perp
    // to the center line
    double vn1 = m_vx * cos_a + m_vy * sin_a;
    double vp1 = m_vy * cos_a - m_vx * sin_a;
    int vx2, vy2;
    pSprite->GetVelocity(&vx2, &vy2);
    double vn2 = vx2 * cos_a + vy2 * sin_a;
    double vp2 = vy2 * cos_a - vx2 * sin_a;

    // compute the momentum along the center line
    double m1 = m_mass;
    double m2 = pSprite->GetMass();
    double k = m1 * vn1 + m2 * vn2;

    // compute the energy
    double e = 0.5 * m1 * vn1 * vn1 + 0.5 * m2 * vn2 * vn2;
    
    // there are two possible solutions to the equations.
    // compute both and choose
    double temp1 = sqrt(k*k - ((m1/m2)+1)*(-2*e*m1 + k*k));
    double vn2p1 = (k + temp1) / (m1+m2);
    double vn2p2 = (k - temp1) / (m1+m2);

    // choose the soln. which is not the current state
    if (vn2p1 == vn2) {
        vn2 = vn2p2;
    } else {
        vn2 = vn2p1;
    }

    // compute the new vn1 value
    vn1 = (k - m2*vn2) / m1;


    // compute the new x and y velocities
    int vx1 = (int)(vn1 * cos_a - vp1 * sin_a);
    int vy1 = (int)(vn1 * sin_a + vp1 * cos_a); 
    vx2 = (int)(vn2 * cos_a - vp2 * sin_a);
    vy2 = (int)(vn2 * sin_a + vp2 * cos_a); 

    m_vx = vx1;
    m_vy = vy1;
    pSprite->SetVelocity(vx2, vy2);

    // move the sprites until they are no longer in collision
    if ((m_vx != 0) || (m_vy != 0) || (vx2 != 0) || (vy2 != 0)) {
        while(CollideTest(pSprite)) {
            UpdatePosition(pDoc);
            pSprite->UpdatePosition(pDoc);
        }
    }

    return 1; // say something changed
}

void CBlock::Stop()
{
	SetVelocity(0,0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\cblocks\mystatus.cpp ===
/*************************************************
 *  mystatus.cpp                                 *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

#include "stdafx.h"
#include "mystatus.h"
#define SBPF_UPDATE 0x0001  // pending update of text
struct AFX_STATUSPANE
{
	UINT    nID;        // IDC of indicator: 0 => normal text area
	int     cxText;     // width of string area in pixels
						//   on both sides there is a 3 pixel gap and
						//   a one pixel border, making a pane 6 pixels wider
	UINT    nStyle;     // style flags (SBPS_*)
	UINT    nFlags;     // state flags (SBPF_*)
	CString strText;    // text in the pane
};

/*
struct AFX_STATUSPANE
{
	UINT    nID;        // IDC of indicator: 0 => normal text area
	UINT    nStyle;     // style flags (SBPS_*)
	int     cxText;     // width of string area in pixels
						//   on both sides there is a 1 pixel gap and
						//    a one pixel border, making a pane 4 pixels wider
	LPCTSTR  lpszText;  // text in the pane
};
*/

inline AFX_STATUSPANE* CStatusBar::_GetPanePtr(int nIndex) const
{
	ASSERT((nIndex >= 0 && nIndex < m_nCount) || m_nCount == 0);
	return ((AFX_STATUSPANE*)m_pData) + nIndex;
}

/*
BOOL CMyStatusBar::SetIndicators(const UINT* lpIDArray, int nIDCount)
{
	ASSERT_VALID(this);
	ASSERT(nIDCount >= 1);  // must be at least one of them
	ASSERT(lpIDArray == NULL ||
		AfxIsValidAddress(lpIDArray, sizeof(UINT) * nIDCount, FALSE));

	// free strings before freeing array of elements
	for (int i = 0; i < m_nCount; i++)
		VERIFY(SetPaneText(i, NULL, FALSE));    // no update

	// first allocate array for panes and copy initial data
	if (!AllocElements(nIDCount, sizeof(AFX_STATUSPANE)))
		return FALSE;
	ASSERT(nIDCount == m_nCount);

	BOOL bOK = TRUE;
	if (lpIDArray != NULL)
	{

		LOGFONT lf;
		memset(&lf,0,sizeof(LOGFONT));
		lstrcpy(lf.lfFaceName,TEXT(""));
		lf.lfHeight=12;
		lf.lfCharSet=DEFAULT_CHARSET;
        HFONT hFont = ::CreateFontIndirect(&lf);
		ASSERT(hFont != NULL);        // must have a font !
		CString strText;
		CClientDC dcScreen(NULL);
		HGDIOBJ hOldFont = dcScreen.SelectObject(hFont);
		for (int i = 0; i < nIDCount; i++)
		{
			AFX_STATUSPANE* pSBP = _GetPanePtr(i);
			pSBP->nID = *lpIDArray++;
			if (pSBP->nID != 0)
			{
				if (!strText.LoadString(pSBP->nID))
				{
					TRACE1("Warning: failed to load indicator string 0x%04X.\n",
						pSBP->nID);
					bOK = FALSE;
					break;
				}
				pSBP->cxText = dcScreen.GetTextExtent(strText,
						strText.GetLength()).cx;
				ASSERT(pSBP->cxText >= 0);
				if (!SetPaneText(i, strText, FALSE))
				{
					bOK = FALSE;
					break;
				}
			}
			else
			{
				// no indicator (must access via index)
				// default to 1/4 the screen width (first pane is stretchy)
                if (!(pSBP->cxText = dcScreen.GetTextExtent(TEXT("0123456789"),lstrlen("0123456789")).cx))			
					pSBP->cxText = ::GetSystemMetrics(SM_CXSCREEN)/4;
				if (i == 0)
					pSBP->nStyle |= (SBPS_STRETCH | SBPS_NOBORDERS);
			}
		}
		dcScreen.SelectObject(hOldFont);
	}
	return bOK;
}
*/
BOOL CMyStatusBar::SetIndicators(const UINT* lpIDArray, int nIDCount)
{
	ASSERT_VALID(this);
	ASSERT(nIDCount >= 1);  // must be at least one of them
	ASSERT(lpIDArray == NULL ||
		AfxIsValidAddress(lpIDArray, sizeof(UINT) * nIDCount, FALSE));
	ASSERT(::IsWindow(m_hWnd));

	// first allocate array for panes and copy initial data
	if (!AllocElements(nIDCount, sizeof(AFX_STATUSPANE)))
		return FALSE;
	ASSERT(nIDCount == m_nCount);

	// copy initial data from indicator array
	BOOL bResult = TRUE;
	if (lpIDArray != NULL)
	{

// Code merge from 3.51 'cblocks'. 	weiwu 6/26
		LOGFONT lf;
		memset(&lf,0,sizeof(LOGFONT));
		lstrcpy(lf.lfFaceName,TEXT(""));
		lf.lfHeight=12;
		lf.lfCharSet=DEFAULT_CHARSET;
	        HFONT hFont = ::CreateFontIndirect(&lf);
//		HFONT hFont = (HFONT)SendMessage(WM_GETFONT);
		CClientDC dcScreen(NULL);
		HGDIOBJ hOldFont = NULL;
		if (hFont != NULL)
			hOldFont = dcScreen.SelectObject(hFont);

		AFX_STATUSPANE* pSBP = _GetPanePtr(0);
		for (int i = 0; i < nIDCount; i++)
		{
			pSBP->nID = *lpIDArray++;
			pSBP->nFlags |= SBPF_UPDATE;
			if (pSBP->nID != 0)
			{
				if (!pSBP->strText.LoadString(pSBP->nID))
				{
					TRACE1("Warning: failed to load indicator string 0x%04X.\n",
						pSBP->nID);
					bResult = FALSE;
					break;
				}
				pSBP->cxText = dcScreen.GetTextExtent(pSBP->strText).cx;
				ASSERT(pSBP->cxText >= 0);
				if (!SetPaneText(i, pSBP->strText, FALSE))
				{
					bResult = FALSE;
					break;
				}
			}
			else
			{
				// no indicator (must access via index)
				// default to 1/4 the screen width (first pane is stretchy)
// Code merge from 3.51 	weiwu 6/26
/*
				pSBP->cxText = ::GetSystemMetrics(SM_CXSCREEN)/4;
*/
                		if (!(pSBP->cxText = dcScreen.GetTextExtent(TEXT("0123456789"),lstrlen("0123456789")).cx))			
					pSBP->cxText = ::GetSystemMetrics(SM_CXSCREEN)/4;
				if (i == 0)
					pSBP->nStyle |= (SBPS_STRETCH | SBPS_NOBORDERS);

			}
			++pSBP;
		}
		if (hOldFont != NULL)
			dcScreen.SelectObject(hOldFont);
	}
	UpdateAllPanes(TRUE, TRUE);

	return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\cblocks\mystatus.h ===
/*************************************************
 *  mystatus.h                                   *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

class CStatusBar;
class CMyStatusBar : public CStatusBar
{
public:
	BOOL SetIndicators(const UINT* lpIDArray, int nIDCount);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\cblocks\osbview.cpp ===
/*************************************************
 *  osbview.cpp                                  *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

// osbview.cpp : implementation of the COSBView class
//

#include "stdafx.h"
#include "cblocks.h"
#include "dib.h"
#include "dibpal.h"
#include "osbview.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif								  

/////////////////////////////////////////////////////////////////////////////
// COSBView

IMPLEMENT_DYNCREATE(COSBView, CScrollView)

BEGIN_MESSAGE_MAP(COSBView, CScrollView)
    //{{AFX_MSG_MAP(COSBView)
    ON_WM_PALETTECHANGED()
    ON_WM_QUERYNEWPALETTE()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// COSBView construction/destruction

COSBView::COSBView()
{
    m_pDIB = NULL;
    m_pPal = NULL;
    m_pOneToOneClrTab = NULL;
    m_hbmSection = NULL;

    // try to get the CreateDIBSection proc. addr.
}

COSBView::~COSBView()
{
    if (m_pDIB) delete m_pDIB;
    if (m_pPal) delete m_pPal;
    if (m_pOneToOneClrTab) free(m_pOneToOneClrTab);
    if (m_hbmSection) ::DeleteObject(m_hbmSection);
    EmptyDirtyList();
}

// Create a new buffer, tables and palette to match a supplied DIB
BOOL COSBView::Create(CDIB *pDIB)
{
    // Create the 1:1 palette index table
    if (m_pOneToOneClrTab) free(m_pOneToOneClrTab);
    m_pOneToOneClrTab = 
        (LPBITMAPINFO) malloc(sizeof(BITMAPINFOHEADER)
                              + 256 * sizeof(WORD));
    if (!m_pOneToOneClrTab) {
        TRACE("Failed to create color table");
        return FALSE;
    }

    // Set up the table header to match the DIB
    // by copying the header and then constructing the 1:1
    // index translation table
    memcpy(m_pOneToOneClrTab,
           pDIB->GetBitmapInfoAddress(),
           sizeof(BITMAPINFOHEADER));
    WORD *pIndex;
    pIndex = (LPWORD)((LPBYTE)m_pOneToOneClrTab + sizeof(BITMAPINFOHEADER));
    for (int i = 0; i < 256; i++) {
        *pIndex++ = (WORD) i;
    }

    // Create a palette from the DIB we can use to do screen drawing
    if (m_pPal) delete m_pPal;
    m_pPal = new CDIBPal;
    ASSERT(m_pPal);
    if (!m_pPal->Create(pDIB)) {
        TRACE("Failed to create palette");
        delete m_pPal;
        m_pPal = NULL;
        return FALSE;
    } else {
        // map the colors so we get an identity palette
        m_pPal->SetSysPalColors();
    }

    // delete any existing DIB and create a new one
    if (m_pDIB) delete m_pDIB;
    m_pDIB = new CDIB;
    BOOL bResult = FALSE;
    if (m_hbmSection) 
    	::DeleteObject(m_hbmSection);
    CDC *pDC = GetDC();
    CPalette *pPalOld = pDC->SelectPalette(m_pPal, FALSE);
    pDC->RealizePalette();
    BYTE *pBits = NULL;
    m_hbmSection = CreateDIBSection(pDC->GetSafeHdc(),
                                 	m_pOneToOneClrTab,
                                 	DIB_PAL_COLORS,
                                 	(VOID **) &pBits,
                                 	NULL,
                                 	0);
    pDC->SelectPalette(pPalOld, FALSE);
    ASSERT(m_hbmSection);
    ASSERT(pBits);
    ReleaseDC(pDC);
    bResult = m_pDIB->Create(pDIB->GetBitmapInfoAddress(), pBits);

	if (!bResult) 
	{
        TRACE("Failed to create os dib");
        delete m_pDIB;
        m_pDIB = NULL;
        return FALSE;
    }

    CSize sizeTotal;
    sizeTotal.cx = m_pDIB->GetWidth();
    sizeTotal.cy = m_pDIB->GetHeight();
    SetScrollSizes(MM_TEXT, sizeTotal);

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// COSBView drawing

void COSBView::OnInitialUpdate()
{
    CSize sizeTotal;
	
    if (m_pDIB) {
        sizeTotal.cx = m_pDIB->GetWidth();
        sizeTotal.cy = m_pDIB->GetHeight();
    } else {
        sizeTotal.cx = 640;
        sizeTotal.cy = 480;
    }

    SetScrollSizes(MM_TEXT, sizeTotal);
}

void COSBView::OnDraw(CDC* pDC)
{
    Draw();
	UNREFERENCED_PARAMETER(pDC);
}

/////////////////////////////////////////////////////////////////////////////
// COSBView diagnostics

#ifdef _DEBUG
void COSBView::AssertValid() const
{
    CScrollView::AssertValid();
}

void COSBView::Dump(CDumpContext& dc) const
{
    CScrollView::Dump(dc);
}

CDocument* COSBView::GetDocument() // non-debug version is inline
{
    return m_pDocument;
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// COSBView message handlers

// Draw a section of the off-screen image buffer to the screen.
void COSBView::Draw(CRect* pRect)
{
    CClientDC dc(this);
    CRect rcDraw;

    // make sure we have what we need to do a paint
    if (!m_pDIB || !m_pOneToOneClrTab) {
        TRACE("No DIB or clr tab to paint from");
        return;
    }

    // see if a clip rect was supplied and use the client area if not
    if (pRect) {
        rcDraw = *pRect;
    } else {
        GetClientRect(rcDraw);
    }

    // Get the clip box
    CRect rcClip;
    dc.GetClipBox(rcClip);

    // Create a rect for the DIB
    CRect rcDIB;
    rcDIB.left = rcDIB.top = 0;
    rcDIB.right = m_pDIB->GetWidth() - 1;
    rcDIB.bottom = m_pDIB->GetHeight() - 1;

    // Find a rectangle that describes the intersection of the draw
    // rect, clip rect and dib rect
    CRect rcBlt = rcDraw & rcClip & rcDIB;

    // Copy the update rectangle from the off-screen DC to the
    // window DC. Note that DIB origin is lower left corner.
    int w, h, xs, xd, yd, ys;
    w = rcBlt.right - rcBlt.left;
    h = rcBlt.bottom - rcBlt.top;
    xs = xd = rcBlt.left;
    yd = rcBlt.top;
    ys = rcBlt.top;
    
    // if we have a palette, select and realize it
    CPalette *ppalOld = NULL;
    if(m_pPal) {
        ppalOld = dc.SelectPalette(m_pPal, 0);
        dc.RealizePalette();
    }
    HDC dcMem = ::CreateCompatibleDC(dc.GetSafeHdc());

    if ( dcMem != NULL )
    {
        HBITMAP hbmOld = (HBITMAP) ::SelectObject(dcMem, m_hbmSection);
	    ::BitBlt(dc.GetSafeHdc(),
                 xd, yd,
                 w, h,
                 dcMem,
                 xs, ys,
                 SRCCOPY);
        ::SelectObject(dcMem, hbmOld);
        ::DeleteDC(dcMem);
    }

	if (ppalOld) dc.SelectPalette(ppalOld, 0);
}

void COSBView::OnPaletteChanged(CWnd* pFocusWnd)
{
    // See if the change was caused by us and ignore it if not
    if (pFocusWnd != this) {
        OnQueryNewPalette();
    }
}

// Note: Windows actually ignores the return value
BOOL COSBView::OnQueryNewPalette()
{
    // We are going active so realize our palette
    if (m_pPal) {
        CDC* pdc = GetDC();
        CPalette *poldpal = pdc->SelectPalette(m_pPal, FALSE);
        UINT u = pdc->RealizePalette();
        ReleaseDC(pdc);
        if (u != 0) {
            // some colors changed so we need to do a repaint
            InvalidateRect(NULL, TRUE); // repaint the lot
            return TRUE; // say we did something
        }
    }
    return FALSE; // say we did nothing
}

// Add a region to the dirty list
void COSBView::AddDirtyRegion(CRect* prcNew)
{
    // get the rectangle currently at the top of the list
    POSITION pos = m_DirtyList.GetHeadPosition();
    if (pos) {
        CRect* prcTop = (CRect*)m_DirtyList.GetNext(pos);
        CRect rcTest;
        // If the new one intersects the top one merge them
        if (rcTest.IntersectRect(prcTop, prcNew)) {
            prcTop->UnionRect(prcTop, prcNew);
            return;
        }
    }
    // list is empty or there was no intersection
    CRect *prc = new CRect;
    *prc = *prcNew; // copy the data
    // add a new rectangle to the list
    m_DirtyList.AddHead((CObject*)prc);
}

// Render and draw all the dirty regions
void COSBView::RenderAndDrawDirtyList()
{
    POSITION pos = m_DirtyList.GetHeadPosition();
    // Render all the dirty regions
    while (pos) {
        // get the next region
        CRect* pRect = (CRect*)m_DirtyList.GetNext(pos);
        // render it
        Render(pRect);
    }
    // Draw all the dirty regions to the screen
    while (!m_DirtyList.IsEmpty()) {
        // get the next region
        CRect* pRect = (CRect*)m_DirtyList.RemoveHead();
        Draw(pRect);
        // done with it
        delete pRect;
    }
}

// Empty the dirty list
void COSBView::EmptyDirtyList()
{
    while (!m_DirtyList.IsEmpty()) {
        CRect* prc = (CRect*)m_DirtyList.RemoveHead();
        delete prc;
    }
}

// Update the view to reflect some change in the doc
void COSBView::OnUpdate(CView* pSender,
                        LPARAM lHint,
                        CObject* pHint)
{
    // Render and draw everything
    Render();
    Draw();
	UNREFERENCED_PARAMETER(pSender);
	UNREFERENCED_PARAMETER(lHint);
	UNREFERENCED_PARAMETER(pHint);
}

void COSBView::Resize(BOOL bShrinkOnly)
{
	// adjust parent rect so client rect is appropriate size

	// determine current size of the client area as if no scrollbars present
	CRect rectClient;
	GetWindowRect(rectClient);
	CRect rect = rectClient;
	CalcWindowRect(rect);
	rectClient.left += rectClient.left - rect.left;
	rectClient.top += rectClient.top - rect.top;
	rectClient.right -= rect.right - rectClient.right;
	rectClient.bottom -= rect.bottom - rectClient.bottom;
	rectClient.OffsetRect(-rectClient.left, -rectClient.top);
	ASSERT(rectClient.left == 0 && rectClient.top == 0);

	// determine desired size of the view
	CRect rectView(0, 0, m_totalDev.cx, m_totalDev.cy);
	if (bShrinkOnly)
	{
		if (rectClient.right <= m_totalDev.cx)
			rectView.right = rectClient.right;
		if (rectClient.bottom <= m_totalDev.cy)
			rectView.bottom = rectClient.bottom;
	}
	CalcWindowRect(rectView, CWnd::adjustOutside);
	if (bShrinkOnly)
	{
		if (rectClient.right <= m_totalDev.cx)
			rectView.right = rectClient.right;
		if (rectClient.bottom <= m_totalDev.cy)
			rectView.bottom = rectClient.bottom;
	}
	CRect rectFrame;
	CFrameWnd* pFrame = GetParentFrame();
	ASSERT_VALID(pFrame);
	pFrame->GetWindowRect(rectFrame);
	CSize size = rectFrame.Size();
	size.cx += rectView.right - rectClient.right+2;
	size.cy += rectView.bottom - rectClient.bottom+2;
	pFrame->SetWindowPos(NULL, 0, 0, size.cx, size.cy,
		SWP_NOMOVE|SWP_NOZORDER|SWP_NOACTIVATE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\cblocks\phsprite.cpp ===
/*************************************************
 *  phsprite.cpp                                 *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

// phsprite.cpp : implementation file
//

#include "stdafx.h"
#include "dib.h"
#include "spriteno.h"
#include "sprite.h"
#include "phsprite.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif
											    
/////////////////////////////////////////////////////////////////////////////
// CPhasedSprite

IMPLEMENT_SERIAL(CPhasedSprite, CSprite, 0 /* schema number*/ )

CPhasedSprite::CPhasedSprite()
{
    m_iNumCellRows = 1;
    m_iNumCellColumns = 1;
    m_iCellRow = 0;
    m_iCellColumn = 0;
    m_iCellHeight = CSprite::GetHeight();
    m_iCellWidth =  CSprite::GetWidth();
}

CPhasedSprite::~CPhasedSprite()
{
}

/////////////////////////////////////////////////////////////////////////////
// CPhasedSprite serialization

void CPhasedSprite::Serialize(CArchive& ar)
{
    CSprite::Serialize(ar);
    if (ar.IsStoring())
    {
        ar << (DWORD) m_iNumCellRows;
        ar << (DWORD) m_iNumCellColumns;
        ar << (DWORD) m_iCellRow;
        ar << (DWORD) m_iCellColumn;
    }
    else
    {
        DWORD dw;
        ar >> dw;
        SetNumCellRows(dw);
        ar >> dw;
        SetNumCellColumns(dw);
        ar >> dw;
        SetCellRow(dw);
        ar >> dw;
        SetCellColumn(dw);
    }
}

/////////////////////////////////////////////////////////////////////////////
// CPhasedSprite commands

// Do any initialization after file load of a new image etc.
void CPhasedSprite::Initialize()
{
    CSprite::Initialize();
    m_iNumCellRows = 1;
    m_iNumCellColumns = 1;
    m_iCellRow = 0;
    m_iCellColumn = 0;
    m_iCellHeight = CSprite::GetHeight();
    m_iCellWidth = CSprite::GetWidth();
}

// Divide the image into a given number of rows
BOOL CPhasedSprite::SetNumCellRows(int iRows)
{
    if (iRows < 1) {
        TRACE("Invalid number of rows");
        return FALSE;
    }
    // compute the height of each row
    int iCellHeight = CSprite::GetHeight() / iRows;
    if (iCellHeight < 1) {
        TRACE("Can't make them that small");
        return FALSE;
    }
    // set the new height and row count
    m_iNumCellRows = iRows;
    m_iCellRow = 0;
    m_iCellHeight = iCellHeight;
    return TRUE;
}

// Divide the image into a given number of columns
BOOL CPhasedSprite::SetNumCellColumns(int iColumns)
{
    if (iColumns < 1) {
        TRACE("Invalid number of columns");
        return FALSE;
    }
    // compute the width of each column
    int iCellWidth = CSprite::GetWidth() / iColumns;
    if (iCellWidth < 1) {
        TRACE("Can't make them that small");
        return FALSE;
    }
    // set the new width and column count
    m_iNumCellColumns = iColumns;
    m_iCellColumn = 0;
    m_iCellWidth = iCellWidth;
    return TRUE;
}

// set the current row
BOOL CPhasedSprite::SetCellRow(int iRow)
{
    if ((iRow >= m_iNumCellRows)
    || (iRow < 0)) {
        TRACE("Invalid row");
        return FALSE;
    }
    if (iRow == m_iCellRow) return FALSE; // nothing to do
    m_iCellRow = iRow;
    // send a notification to redraw
   if (m_pNotifyObj) {
        CRect rcPos;
        GetRect(&rcPos);
        m_pNotifyObj->Change(this, 
                            CSpriteNotifyObj::IMAGE,
                            &rcPos);
   }
   return TRUE;
}

// set the current column
BOOL CPhasedSprite::SetCellColumn(int iColumn)
{
    if ((iColumn >= m_iNumCellColumns)
    || (iColumn < 0)) {
        TRACE("Invalid column");
        return FALSE;
    }
    if (iColumn == m_iCellColumn) return FALSE; // nothing to do
    m_iCellColumn = iColumn;
    // send a notification to redraw
   if (m_pNotifyObj) {
        CRect rcPos;
        GetRect(&rcPos);
        m_pNotifyObj->Change(this, 
                            CSpriteNotifyObj::IMAGE,
                            &rcPos);
   }
   return TRUE;
}
                                                  
// get the bounding rectangle
void CPhasedSprite::GetRect(CRect* pRect)
{
    ASSERT(pRect);
    pRect->left = m_x;
    pRect->top = m_y;
    pRect->right = m_x + GetWidth();
    pRect->bottom = m_y + GetHeight();
}

// Test for a hit in a non-transparent area
BOOL CPhasedSprite::HitTest(CPoint point)
{
    // Test if the point is inside the sprite rectangle
    if ((point.x > m_x) 
    && (point.x < m_x + GetWidth())
    && (point.y > m_y)
    && (point.y < m_y + GetHeight())) {
        // Hit is in sprite rect
        // See if this point is transparent by testing to
        // see if the pixel value is the same as the top
        // left corner value.  Note that top left of the
        // image is bottom left in the DIB.
        // Get the address of the top, left pixel
        BYTE* p = (BYTE*)GetPixelAddress(point.x - m_x, point.y - m_y);
        ASSERT(p);

        if ( ( p != NULL) && (*p != m_bTransIndex) ) {
            return TRUE;
        }
    }
    return FALSE;
}

// Render a sprite to a DIB
void CPhasedSprite::Render(CDIB *pDIB, CRect* pClipRect)
{
    ASSERT(pDIB);
    ASSERT(pClipRect);
    // Get the sprite rect and see if it's visible
    CRect rcDraw;
    GetRect(&rcDraw);
    if (!rcDraw.IntersectRect(pClipRect, &rcDraw)) {
        return; // not visible
    }
    // modify the source x and y values for the current phase of the sprite
    int xs = rcDraw.left - m_x + m_iCellColumn * m_iCellWidth;
    int ys = rcDraw.top - m_y + m_iCellRow * m_iCellHeight;
    ASSERT(xs >= 0 && xs < CSprite::GetWidth());
    ASSERT(ys >= 0 && ys < CSprite::GetHeight());
    CopyBits(pDIB,        // dest DIB
             rcDraw.left,                   // dest x
             rcDraw.top,                    // dest y
             rcDraw.right - rcDraw.left,    // width
             rcDraw.bottom - rcDraw.top,    // height
             xs,                            // source x
             ys,                            // source y
             PALETTEINDEX(m_bTransIndex));  // trans color index
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\cblocks\mysprite.h ===
/*************************************************
 *  mysprite.h                                   *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

// mysprite.h : header file
//
// CBlock class
//
//

class CBlockDoc;

class CBlock : public CPhasedSprite
{
    DECLARE_SERIAL(CBlock)
public:
    CBlock();
    ~CBlock();
    void SetMass(int iMass);
    int GetMass() {return m_mass;}
    void GetVelocity(int* pvx, int* pvy)
        {*pvx = m_vx; *pvy = m_vy;}
    void SetVelocity(int iVX, int iVY);
	void SetCode(WORD wCode) {m_wCode = wCode;}
	WORD GetCode() const {return m_wCode;}
    int UpdatePosition(CBlockDoc *pDoc);
    int CollideTest(CBlock* pSprite);
    int OnCollide(CBlock* pSprite, CBlockDoc *pDoc);
  	void Stop();
	BOOL Hit(WORD wCode) {return m_wCode == wCode;}
    virtual void Serialize(CArchive& ar);

private:
    int m_mass;
    int m_vx;
    int m_vy;
    int m_dx;
    int m_dy;
	WORD m_wCode;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\cblocks\osbview.h ===
/*************************************************
 *  osbview.h                                    *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

// osbview.h : interface of the COSBView class
//
/////////////////////////////////////////////////////////////////////////////

// define the CreateDIBSection function (Build 550 version)
class CBlockDoc;

class COSBView : public CScrollView
{
protected: // create from serialization only
    COSBView();
    DECLARE_DYNCREATE(COSBView)		   

// Attributes
public:
    CDocument* GetDocument();
    CDIB* GetDIB() {return m_pDIB;}
    CDIBPal* GetPalette() {return m_pPal;}
	void Resize(BOOL bShrinkOnly);
// Operations
public:
    BOOL Create(CDIB* pDIB);        // create a new buffer
    void Draw(CRect* pClipRect = NULL);  // draw os buffer to screen
    virtual void Render(CRect* pClipRect = NULL) {return;UNREFERENCED_PARAMETER(pClipRect);}
    void AddDirtyRegion(CRect* pRect);
    void RenderAndDrawDirtyList();

// Implementation
public:
    virtual ~COSBView();
    virtual void OnDraw(CDC* pDC);  // overridden to draw this view
    virtual void OnInitialUpdate(); // first time after construct
    virtual void OnUpdate(CView* pSender,
                          LPARAM lHint,
                          CObject* pHint);


#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

protected:
    CDIB *m_pDIB;           // the DIB buffer
    CDIBPal *m_pPal;        // Palette for drawing

private:
    BITMAPINFO *m_pOneToOneClrTab;  // ptr to 1:1 color table
    HBITMAP m_hbmSection;           // bm from section
    CObList m_DirtyList;            // dirty regions

    void EmptyDirtyList();

// Generated message map functions
protected:
    //{{AFX_MSG(COSBView)
    afx_msg void OnPaletteChanged(CWnd* pFocusWnd);
    afx_msg BOOL OnQueryNewPalette();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in osbview.cpp
inline CDocument* COSBView::GetDocument()
   { return (CDocument*) m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\cblocks\phsprite.h ===
/*************************************************
 *  phsprite.h                                   *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

// phsprite.h : header file
//
// CPhasedSprite class
//
//

class CPhasedSprite : public CSprite
{
    DECLARE_SERIAL(CPhasedSprite)
public:
    CPhasedSprite();			    
    ~CPhasedSprite();

    // New in this class
    virtual int GetNumCellRows() {return m_iNumCellRows;}
    virtual int GetNumCellColumns() {return m_iNumCellColumns;}
    virtual int GetCellRow() {return m_iCellRow;}
    virtual int GetCellColumn() {return m_iCellColumn;}

    virtual BOOL SetNumCellRows(int iNumRows);
    virtual BOOL SetNumCellColumns(int iNumColumns);
    virtual BOOL SetCellRow(int iRow);
    virtual BOOL SetCellColumn(int iColumn);

    // from base classes
    virtual int GetHeight() {return m_iCellHeight;}
    virtual int GetWidth() {return m_iCellWidth;}
    virtual void GetRect(CRect* pRect); 
    virtual BOOL HitTest(CPoint point);
    virtual void Render(CDIB* pDIB, CRect* pClipRect = NULL);
    virtual void Serialize(CArchive& ar);
    virtual void Initialize();

protected:
    int m_iNumCellRows;     // number of rows in the image grid
    int m_iNumCellColumns;  // number of columns in the image grid
    int m_iCellRow;         // current cell row
    int m_iCellColumn;      // current cell column
    int m_iCellHeight;      // height of a row
    int m_iCellWidth;       // width of a column
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\cblocks\resource.h ===
/*************************************************
 *  resource.h                                   *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Cblocks.rc
//
#define IDR_MAINFRAME                   2
#define IDS_APPNAME                     3
#define IDS_BLOCK                       4
#define IDD_ABOUTBOX                    100
#define IDR_SPRITEPOPUP                 101
#define IDC_TOTALWORD                   101
#define IDC_TOTALHITWORD                102
#define IDC_HITWORDINAIR                103
#define IDB_REDBALL                     104
#define IDC_HITWORDINGROUND             104
#define IDC_MISSHIT                     105
#define IDB_BLOCK                       106
#define IDB_BITMAP1                     107
#define IDD_STATISTIC                   111
#define IDB_ARROW                       112
#define IDC_HAND_CBLOCK                 129
#define IDB_BITMAP2                     135
#define IDB_BITMAP3                     136
#define IDB_BITMAP4                     137
#define IDB_BITMAP5                     138
#define IDB_BITMAP6                     139
#define IDB_BITMAP7                     140
#define IDB_BITMAP8                     141
#define IDI_ICON1                       142
#define IDR_SNDHIT                      1000
#define IDR_SNDGROUND                   1001
#define IDR_SNDFIRE                     1002
#define ID_FILE_LOADBKGND               32768
#define ID_FILE_LOADSPRITE              32769
#define ID_SPRITEZORDER                 32771
#define ID_SPRITEZ_0                    32772
#define ID_SPRITEZ_20                   32774
#define ID_SPRITEZ_40                   32775
#define ID_SPRITEZ_60                   32776
#define ID_SPRITEZ_80                   32777
#define ID_SPRITEZ_10                   32778
#define ID_SPRITEZ_30                   32779
#define ID_SPRITEZ_50                   32780
#define ID_SPRITEZ_70                   32781
#define ID_SPRITEZ_90                   32782
#define ID_SPRITEDELETE                 32783
#define ID_ROWS_1                       32784
#define ID_ROWS_2                       32785
#define ID_ROWS_3                       32786
#define ID_ROWS_4                       32787
#define ID_COLS_1                       32788
#define ID_COLS_2                       32789
#define ID_COLS_3                       32790
#define ID_COLS_4                       32791
#define ID_ACTION_STOP                  32792
#define ID_ACTION_SLOW                  32793
#define ID_ACTION_MEDIUM                32794
#define ID_ACTION_FAST                  32795
#define ID_FILE_START                   32796
#define ID_FILE_SUSPEND                 32797
#define ID_FIRE                         32798
#define ID_OPTION_SIZE_12x10            32801
#define ID_OPTION_SIZE_16x16            32802
#define ID_OPTION_SIZE_4x4              32804
#define ID_TEST_SOUND                   32805
#define ID_OPTION_SOUND                 32806
#define IDM_RULE                        32807
#define ID_OPTION_BEGINER               32808
#define ID_OPTION_ORDINARY              32809
#define ID_OPTION_EXPERT                32810
#define ID_ACTION_NORMALLOW             32811
#define ID_ACTION_NORMALSLOW            32812
#define ID_ACTION_NORMALFAST            32813
#define ID_ACTION_NORMAL                32814
#define ID_HELP_RULE                    32815
#define ID_FILE_STATISTIC               32816
#define ID_MENUITEM32817                32817
#define IDM_TEST                        32818
#define ID_TOOL_PAUSE                   32819
#define ID_FILE_                        32819
#define ID_TOOL_RESUME                  32820
#define IDS_RESUME                      61204
#define IDS_SUSPEND                     61206
#define ID_SCORE                        61207
#define ID_SCOREPROMPT                  61208
#define ID_BLANK5                       61209
#define ID_HINT                         61210
#define IDS_SUPERMAN                    61211

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        143
#define _APS_NEXT_COMMAND_VALUE         32820
#define _APS_NEXT_CONTROL_VALUE         106
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\cblocks\queue.cpp ===
/*************************************************
 *  queue.cpp                                    *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

#include "stdafx.h"
#include "queue.h"

CQueue::CQueue(int nSize)
{
	m_pQueue = new int[nSize+1];
	m_nSize = nSize+1;
	m_nFront = 0;					    
	m_nRear  = 0;
}

CQueue::~CQueue()
{
	delete[] m_pQueue;
}

int CQueue::Peek()
{
	if (m_nFront == m_nRear)	
		return -1;
	else
		return m_pQueue[m_nRear];
}

int CQueue::Get()
{
	if (m_nFront == m_nRear)	
		return -1;
	else
	{
		int nTmp = m_pQueue[m_nRear];
		m_nRear = Inc(m_nRear);
		return nTmp;
	}	
	
}

BOOL CQueue::Add(int data)
{
	if (Inc(m_nFront) == m_nRear)
		return FALSE;
	else
	{
		m_pQueue[m_nFront] = data;
		m_nFront = Inc(m_nFront);
		return TRUE;
	}
}

int CQueue::Inc(int x)
{
	if ((x+1) < m_nSize)
		x++;
	else
		x = 0;
	return x;
}

int CQueue::Dec(int x)
{
	if ((x-1) >= 0)
		x--;
	else
		x = m_nSize - 1;
	return x;
}

BOOL CQueue::IsEmpty()
{
	return m_nRear == m_nFront;
}

void CQueue::Dump()
{
	int pf = m_nFront;
	int pr = m_nRear;
	if (pf == pr) return;
	for (; pf != pr; )
	{
		TRACE("[%d]%d,",pr,m_pQueue[pr]);
		pr = Inc(pr);
	} 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\cblocks\queue.h ===
/*************************************************
 *  queue.h                                      *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

#ifndef _QUEUE_H_
#define _QUEUE_H_
	    
class CQueue : public CObject
{
public:
	CQueue(int nSize);
	~CQueue();
	BOOL IsEmpty();
	int  Peek();
	int  Get();
	BOOL Add(int nNdx);
	int Inc(int x);
	int Dec(int x);
	void Dump();
protected:
	int* m_pQueue;
	int m_nFront;
	int m_nRear;
	int m_nSize;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\cblocks\splstno.h ===
/*************************************************
 *  splstno.h                                    *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

// splstno.h : header file
//
// CSpriteListNotifyObj class   
//
// This is a class derived from CSpriteNotifyObj which is used in 
// CSpriteList to handle notification calls from CSprite objects.
//

class CSpriteList;
class CBlockView;

class CSpriteListNotifyObj : public CSpriteNotifyObj
{
public:
    CSpriteListNotifyObj();
    ~CSpriteListNotifyObj();
    void SetList(CSpriteList* pSpriteList)
        {m_pSpriteList = pSpriteList;}
    void SetView(CBlockView* pBlockView)
        {m_pBlockView = pBlockView;}
    void Change(CSprite *pSprite,
                CHANGETYPE change,
                CRect* pRect1 = NULL,
                CRect* pRect2 = NULL);

protected:
    CSpriteList* m_pSpriteList;
    CBlockView* m_pBlockView;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\cblocks\slot.h ===
/*************************************************
 *  slot.h                                       *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

#ifndef _DEST_H_
#define _DEST_H_

#include "queue.h"
class CSlot : public CObList
{
public:
	CSlot(int nBlockNo);
	~CSlot();
					  
	BOOL 		IsOver() const;
	BOOL 		IsIdle() const;
	CBlock* 	GetRunningBlock() const;
	int 		GetCurrentLayer() const;
	void 		ResetCurrentLayer();
	void        ResetRunningBlock();
	void 		ResetSlot();
	void 		SetCurrentLayer(int nLayer);
	void 		StepCurrentLayer();
	void 		SetRunningBlock(CBlock* pBlock);
	void 		SetIndex(int nIndex);
	int			GetIndex() const;
	CBlock* 	Hit(WORD wCode,BOOL& bRunning,int& nLayer);

protected:
	int m_nBlockNo;
	CBlock* m_pRunningBlock;
	int m_nCurrentLayer;
	int m_nIndex;
};

class CSlotManager : public CObArray
{
public:
	CSlotManager(CBlockDoc* pDoc);
	~CSlotManager();
	void Land();
	int GetIdleSlot();
	void AddRunningBlock(int nNo,CBlock* pBlock);
	CBlock* Hit(WORD wCode,int& nLayer); 
protected:
	CBlockDoc* 	m_pDoc;
	int*		m_pLayer;
	CQueue* 	m_pQueue;		
	CObList		m_DeadList;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\cblocks\splstno.cpp ===
/*************************************************
 *  splstno.cpp                                  *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

// splstno.cpp : implementation file
//

#include "stdafx.h"
#include "dib.h"
#include "dibpal.h"
#include "spriteno.h"
#include "splstno.h"
#include "sprite.h"
#include "phsprite.h"
#include "myblock.h"							  
#include "spritlst.h"
#include "osbview.h"
#include "blockvw.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSpriteListNotifyObj

CSpriteListNotifyObj::CSpriteListNotifyObj()
{
    m_pSpriteList = NULL;
    m_pBlockView = NULL;
}

CSpriteListNotifyObj::~CSpriteListNotifyObj()
{
}

// Notification callback from a CSprite object
void CSpriteListNotifyObj::Change(CSprite *pSprite,
                                  CHANGETYPE change,
                                  CRect* pRect1,
                                  CRect* pRect2)
{
    if (change & CSpriteNotifyObj::ZORDER) 
    {
        // reposition the sprite in the z-order list
        ASSERT(m_pSpriteList);
        m_pSpriteList->Reorder(pSprite);
        // Add the sprite position to the dirty list
        ASSERT(m_pBlockView);
        m_pBlockView->AddDirtyRegion(pRect1);
    }
	if (change & CSpriteNotifyObj::IMAGE) 
	{
		ASSERT(m_pBlockView);
        m_pBlockView->AddDirtyRegion(pRect1);
	}
    if (change & CSpriteNotifyObj::POSITION) 
    {
        // pRect1 and pRect2 point to old and new rect positions
        // add these rects to the dirty list
        ASSERT(m_pBlockView);
        m_pBlockView->AddDirtyRegion(pRect1);
        m_pBlockView->AddDirtyRegion(pRect2);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\cblocks\slot.cpp ===
/*************************************************
 *  slot.cpp                                     *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

#include "stdafx.h"
#include "cblocks.h"

#include "dib.h"
#include "dibpal.h"
#include "spriteno.h"
#include "sprite.h"
#include "phsprite.h"
#include "myblock.h"
#include "splstno.h"									 
#include "spritlst.h"
#include "osbview.h"
#include "blockvw.h"
#include "blockdoc.h"
#include "slot.h"

CSlot::CSlot(int nBlockNo)
{
	m_nBlockNo = nBlockNo;
	m_nCurrentLayer = 0;
	m_pRunningBlock = NULL;
	m_nIndex = -1;
}

CSlot::~CSlot()
{
	RemoveAll();
}

BOOL CSlot::IsOver() const
{
	return (GetCount() >= m_nBlockNo);
	
}

CBlock* CSlot::GetRunningBlock() const
{
	return m_pRunningBlock;
}

int CSlot::GetCurrentLayer() const
{
	return m_nCurrentLayer;
}

void CSlot::SetCurrentLayer(int nLayer)
{
	m_nCurrentLayer = nLayer;
}

void CSlot::ResetCurrentLayer() 
{
	m_nCurrentLayer = 0;
}

void CSlot::ResetSlot()
{
	m_pRunningBlock = NULL;
	m_nCurrentLayer = 0;
}

void CSlot::SetIndex(int nNdx)
{
	m_nIndex = nNdx;
}

int CSlot::GetIndex() const
{
	return m_nIndex;
}

CBlock* CSlot::Hit(WORD wCode,BOOL &bRunning,int& nLayer)
{
	CBlock* pBlock = NULL;

	bRunning = FALSE;
	if (m_pRunningBlock)
	{
		if (m_pRunningBlock->Hit(wCode))
		{
			nLayer = m_nCurrentLayer;
			pBlock = m_pRunningBlock;
			int iVX,iVY; 
			pBlock->GetVelocity(&iVX,&iVY);
			pBlock->SetVelocity(0,iVY * -2);
			ResetRunningBlock();
			bRunning = TRUE;
			return pBlock;
		}
	}

	if (GetCount())
	{
		pBlock = (CBlock*) GetHead();
		if (pBlock->Hit(wCode))
		{
			nLayer = 1;
			RemoveHead();
			pBlock->SetVelocity(0,-500);
			return pBlock;
		}
	}
	return NULL;
}

void CSlot::ResetRunningBlock()
{
	m_pRunningBlock = NULL;
	m_nCurrentLayer = 0;
}

void CSlot::StepCurrentLayer() 
{
	m_nCurrentLayer++;
}

BOOL CSlot::IsIdle() const
{
	return m_pRunningBlock == NULL;
}

void CSlot::SetRunningBlock(CBlock* pBlock)
{
	m_pRunningBlock = pBlock;
	ResetCurrentLayer();
}

int m_nBottom;
CSlotManager::CSlotManager(CBlockDoc* pDoc)
{
	ASSERT_VALID(pDoc);
	m_pDoc = pDoc;
	m_pQueue = (CQueue *) new CQueue(pDoc->GetNumofCols());
	for (int i=0; i<pDoc->GetNumofCols(); i++)
	{
		CSlot* pSlot = new CSlot(pDoc->GetNumofRows());
		pSlot->SetIndex(i);
		Add(pSlot);
		m_pQueue->Add(i);
	}
	m_pLayer = new int[pDoc->GetNumofRows()];
	for (i=0; i<pDoc->GetNumofRows(); i++)
		m_pLayer[i] = pDoc->GetRowHeight() * i;
	m_nBottom = pDoc->GetRowHeight() * (pDoc->GetNumofRows()-1);

}

CSlotManager::~CSlotManager()
{
	for (int i=0; i<GetSize(); i++)
	{
		CSlot* pObj = (CSlot*) GetAt(i);
		delete pObj;
	}
	RemoveAll();
	m_DeadList.RemoveAll();
	delete[] m_pLayer;
	delete m_pQueue;
}

void CSlotManager::Land()
{
	static char szBuf[100];
	for (int i=0; i<m_pDoc->GetNumofCols(); i++)
	{
		CSlot* pSlot = (CSlot *) GetAt(i);
		CBlock* pBlock = pSlot->GetRunningBlock() ;
		if (pBlock)
		{
			if (pBlock->GetY() >= m_pLayer[m_pDoc->GetNumofRows()-pSlot->GetCount()-1])
			{
				pBlock->Stop();
				pBlock->SetPosition(pBlock->GetX(),m_pLayer[m_pDoc->GetNumofRows()-pSlot->GetCount()-1]);
				pSlot->AddHead(pBlock);
				pSlot->SetRunningBlock(NULL);
				m_pDoc->SoundGround();
				if (pSlot->GetCount() == m_pDoc->GetNumofRows())
				{
					m_pDoc->GameOver();
				
				}
				else
				{
					m_pQueue->Add(i);
				
				}
			}
			else
			{
				if (pBlock->GetY() >= m_pLayer[pSlot->GetCurrentLayer()+1])
					pSlot->StepCurrentLayer();
				
			}
		} 

		if (m_DeadList.GetCount() > 0)
		{
			POSITION pPos = m_DeadList.GetHeadPosition();
			for (; pPos; )
			{
				POSITION pOldPos = pPos;
				CBlock* pBlock = (CBlock *) m_DeadList.GetNext(pPos);
				if (pBlock)
				{		
					if (pBlock->GetY() <= -m_pDoc->GetRowHeight())
					{
						m_DeadList.RemoveAt(pOldPos);
						m_pDoc->Remove(pBlock);
					}
				}
			}

		}
	}	
	
}

#define INC(x) {x = ((x+1) > m_pDoc->GetNumofCols()) ? 0 : x+1;}
int CSlotManager::GetIdleSlot()
{
	static int nCount=0;
	if (m_pQueue->IsEmpty())
		return -1;
	else
	{
		int nTmp = m_pQueue->Get();
		int nPassed = rand();
		switch (m_pDoc->GetExpertise())
		{
			case LEVEL_EXPERT:
				nPassed = nPassed % 2;
				break;
			case LEVEL_ORDINARY:
				nPassed = nPassed % 5;
				break;
			case LEVEL_BEGINNER:
				nPassed = nPassed % 7;
				break;
		}

		if ((nPassed == 0) || (nCount > 15))
		{
			nCount = 0;
			return nTmp;
		}
		else
		{
			m_pQueue->Add(nTmp);
			nCount++;
			return -1;
		}

	}
}

void CSlotManager::AddRunningBlock(int nSlotNo,CBlock* pBlock)
{
	ASSERT((nSlotNo >=0) && (nSlotNo < m_pDoc->GetNumofCols()));
	CSlot* pSlot = (CSlot *) GetAt(nSlotNo);
	pSlot->SetRunningBlock(pBlock);

}

CBlock* CSlotManager::Hit(WORD wCode,int& nLayer)
{
	BOOL bRunning = FALSE;

	for (int i=0; i<m_pDoc->GetNumofCols(); i++)
	{
		CSlot* pSlot = (CSlot*)GetAt(i);
		CBlock* pBlock = pSlot->Hit(wCode,bRunning,nLayer);
		if (pBlock)
		{
			if (bRunning)
			{
				m_pQueue->Add(i);
				nLayer = m_pDoc->GetNumofRows() - nLayer;
			}
			m_DeadList.AddTail(pBlock);
			return pBlock;
		}
	}
	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\cblocks\sprite.cpp ===
/*************************************************
 *  sprite.cpp                                   *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

// sprite.cpp : implementation file
//

#include "stdafx.h"
#include "dib.h"
#include "spriteno.h"
#include "sprite.h"					   

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSprite

IMPLEMENT_SERIAL(CSprite, CDIB, 0 /* schema number*/ )

CSprite::CSprite()
{
    m_x = 0;
    m_y = 0;
    m_z = 50;
    m_bTransIndex = 0;
    m_pNotifyObj = NULL;
}

CSprite::~CSprite()
{
}

// Set the initial state of the sprite from its DIB image
void CSprite::Initialize()
{
    // Get the address of the top, left pixel
    BYTE* p = (BYTE*)GetPixelAddress(0, 0);
    ASSERT(p);

    if ( p == NULL )
    {
       m_bTransIndex = 0;
       return;
    }

    // get the pixel value and save it
    m_bTransIndex = *p;
}

/////////////////////////////////////////////////////////////////////////////
// CSprite serialization

void CSprite::Serialize(CArchive& ar)
{
    CDIB::Serialize(ar);
    if (ar.IsStoring()) {
        ar << (DWORD) m_x;
        ar << (DWORD) m_y;
        ar << (DWORD) m_z;
    } else {
        DWORD dw;
        ar >> dw; m_x = (int) dw;
        ar >> dw; m_y = (int) dw;
        ar >> dw; m_z = (int) dw;
        // now generate the other parameters from the DIB
        Initialize();
    }
}

/////////////////////////////////////////////////////////////////////////////
// CSprite commands

// Render a sprite to a DIB
void CSprite::Render(CDIB* pDIB, CRect* pClipRect)
{
    ASSERT(pDIB);

    // Get the sprite rectangle
    CRect rcDraw;
    GetRect(&rcDraw);

    // If a clip rectangle was supplied, see if the sprite
    // is visible in the rectangle
    if (pClipRect) {
        if (!rcDraw.IntersectRect(pClipRect, &rcDraw)) {
            return; // not visible
        }
    }
    // Copy the image of the sprite
    CopyBits(pDIB,        // dest DIB
             rcDraw.left,                   // dest x
             rcDraw.top,                  // dest y
             rcDraw.right - rcDraw.left,    // width
             rcDraw.bottom - rcDraw.top,    // height
             rcDraw.left - m_x, // source x
             rcDraw.top - m_y,  // source y
             PALETTEINDEX(m_bTransIndex));     // trans color index
}

void PrintRGB(CDIB* pDib,int n)
{
    RGBQUAD *prgb = pDib->GetClrTabAddress();
	TRACE("%d>(%d,%d,%d)\n",n,prgb[n].rgbBlue, prgb[n].rgbGreen, prgb[n].rgbRed);	   
}


void Copy(CDIB* pdibSrc,CDIB* pdibDest, 
                    int xd, int yd,
                    int w, int h,
                    int xs, int ys,
                    COLORREF clrTrans)
{
    ASSERT(pdibDest);
    // test for strange cases
    if (w == 0 || h == 0) return;

    // get pointers to the start points in the source
    // and destination DIBs. Note that this will be the bottom left
    // corner of the DIB as the scan lines are reversed in memory
    BYTE* pSrc = (BYTE*)(pdibSrc->GetPixelAddress(xs, ys + h - 1));
    ASSERT(pSrc);
    BYTE* pDest = (BYTE*)pdibDest->GetPixelAddress(xd, yd + h - 1);
    ASSERT(pDest);

    // get the scan line widths of each DIB
    int iScanS = pdibSrc->StorageWidth();
    int iScanD = pdibDest->StorageWidth();
	
	RGBQUAD *prgbSrc  = pdibSrc->GetClrTabAddress();
	RGBQUAD *prgbDest = pdibDest->GetClrTabAddress();
    {
        // copy lines with transparency
        // We only accept a PALETTEINDEX description
        // for the color definition
        BYTE bTransClr = LOBYTE(LOWORD(clrTrans));
        int iSinc = iScanS - w; // source inc value
        int iDinc = iScanD - w; // dest inc value
        int iCount;
        BYTE pixel;
        while (h--) {
            iCount = w;    // no of pixels to scan
            while (iCount--) {
                pixel = *pSrc++;
                // only copy pixel if not transparent
                if (pixel != bTransClr) {
				{
					*pDest++ = 1;
				}
                } else {
                    pDest++;
                }
            }
            // move on to the next line
            pSrc += iSinc;
            pDest += iDinc;
        }
    }
}          


void CSprite::Coverage(CDIB* pDIB)
{
    ASSERT(pDIB);

    // Get the sprite rectangle
    CRect rcDraw;
    GetRect(&rcDraw);


    // Copy the image of the sprite
    Copy(this,pDIB,        // dest DIB
             0,                   // dest x
             0,                  // dest y
             DibWidth(),    // width
             DibHeight(),    // height
             0, // source x
             0,  // source y
           PALETTEINDEX(m_bTransIndex));     // trans color index
}


// Load a sprite image from a disk file
BOOL CSprite::Load(CBitmap* pBmp)
{
    if (!CDIB::Load(pBmp)) {
        return FALSE;
    }
    Initialize();
    return TRUE;
}

BOOL CSprite::Load(char* pszFileName)
{
    if (!CDIB::Load(pszFileName)) {
        return FALSE;
    }
    Initialize();
/*	
	{
		BYTE* pBits = NULL;
		HBITMAP hBmp;
		CDC* pDC = GetDC();
		hBmp = CreateDIBSection(pDC->GetSafeHdc(),
								pBmpInfo,
								DIB_PAL_COLORS,
								(VOID **) &pBits,
								NULL,
								0);
		ReleaseDC(pDC);
 		Create(GetWidth
	}
*/	
    return TRUE;
}

// Load a sprite image from a disk file
BOOL CSprite::Load(CFile *fp)
{
    if (!CDIB::Load(fp)) {
        return FALSE;
    }
    Initialize();
    return TRUE;
}

// Map colors to palette 
BOOL CSprite::MapColorsToPalette(CPalette *pPal)
{
    BOOL bResult = CDIB::MapColorsToPalette(pPal);
    // get the transparency info again
    // Note: local call only don't any derived class
    CSprite::Initialize();
    return bResult;
}

// get the bounding rectangle
void CSprite::GetRect(CRect* pRect)
{
    ASSERT(pRect);
    pRect->left = m_x;
    pRect->top = m_y;
    pRect->right = m_x + GetWidth();
    pRect->bottom = m_y + GetHeight();
}

// Test for a hit in a non-transparent area
BOOL CSprite::HitTest(CPoint point)
{
    // Test if the point is inside the sprite rectangle
    if ((point.x > m_x) 
    && (point.x < m_x + GetWidth())
    && (point.y > m_y)
    && (point.y < m_y + GetHeight())) {
        // See if this point is transparent by testing to
        // see if the pixel value is the same as the top
        // left corner value.  Note that top left of the
        // image is bottom left in the DIB.
        BYTE* p = (BYTE*)GetPixelAddress(point.x - m_x, point.y - m_y);
        if (( p != NULL ) && (*p != m_bTransIndex) ) {
            return TRUE; // hit
        }
    }
    return FALSE;
}

void CSprite::Disappear()
{
    CRect rcOld;
    GetRect(&rcOld);
    if (m_pNotifyObj) 
    {
        m_pNotifyObj->Change(this, 
                             CSpriteNotifyObj::IMAGE,
                             &rcOld,
                             NULL);
    }
}

// set a new x,y position
void CSprite::SetPosition(int x, int y)
{
    // Save the current position
    CRect rcOld;
    GetRect(&rcOld);
    // move to new position
    m_x = x;
    m_y = y;
    CRect rcNew;
    GetRect(&rcNew);
    // notify that we have moved from our old position to
    // our new position
    if (m_pNotifyObj) {
        m_pNotifyObj->Change(this, 
                             CSpriteNotifyObj::POSITION,
                             &rcOld,
                             &rcNew);
    }
}

// Set a new Z order
void CSprite::SetZ(int z)
{
    if (m_z != z) {
        m_z = z;
        // See if we have to notify anyone
        if (m_pNotifyObj) {
            CRect rc;
            GetRect(&rc);
            m_pNotifyObj->Change(this,
                                 CSpriteNotifyObj::ZORDER,
                                 &rc);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\cblocks\stdafx.cpp ===
/*************************************************
 *  stdafx.cpp                                   *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

// stdafx.cpp : source file that includes just the standard includes
//	stdafx.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\cblocks\spritlst.h ===
/*************************************************
 *  spritelst.h                                  *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

// spritlst.h : header file
//
// CSpriteList class
//

class CSpriteList : private CObList
{
    DECLARE_SERIAL(CSpriteList)
public:
    CSpriteList();
    ~CSpriteList();
    void RemoveAll();
    BOOL Insert(CSprite *pSprite);
    void Reorder(CSprite *pSprite);	 
    CSprite *Remove(CSprite *pSprite);
    CSprite *GetNext(POSITION &pos)
        {return (CSprite *) CObList::GetNext(pos);}
    CSprite *GetPrev(POSITION &pos)
        {return (CSprite *) CObList::GetPrev(pos);}
    POSITION GetTailPosition() const
        {return CObList::GetTailPosition();}
    POSITION GetHeadPosition() const
        {return CObList::GetHeadPosition();}
    CSprite *HitTest(CPoint point);
    virtual void Serialize(CArchive& ar);
    BOOL IsEmpty()
        {return CObList::IsEmpty();}

public:
    CSpriteListNotifyObj m_NotifyObj;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\cblocks\stdafx.h ===
/*************************************************
 *  stdafx.h                                     *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//		are changed infrequently
//

#include <afxwin.h>			// MFC core and standard components
#include <afxext.h> 		// MFC extensions
#include <mmsystem.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\cblocks\sprite.h ===
/*************************************************
 *  sprite.h                                     *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

// sprite.h : header file
//
// CSprite class
//				 
//

class CSprite : public CDIB
{
    DECLARE_SERIAL(CSprite)
public:
    CSprite();
    ~CSprite();

    virtual int GetX() { return m_x;}   // get x
    virtual int GetY() { return m_y;}   // get y
    virtual int GetZ() { return m_z;}   // get z order

    virtual void Serialize(CArchive& ar);
    virtual void Render(CDIB* pDIB, CRect* pClipRect = NULL);
	virtual void Coverage(CDIB* pDIB);
    virtual BOOL Load(CFile *fp);               // load from file
    virtual BOOL Load(char *pszFileName = NULL);// load DIB from disk file
	virtual BOOL Load(CBitmap *pszFileName = NULL);// load DIB from disk file
    virtual BOOL MapColorsToPalette(CPalette *pPal);
    virtual void GetRect(CRect* pRect); 
    virtual BOOL HitTest(CPoint point);
    virtual void SetPosition(int x,
                             int y);
    virtual void SetZ(int z);
    virtual void SetNotificationObject(CSpriteNotifyObj* pNO)
        {m_pNotifyObj = pNO;}
	virtual void Disappear();

protected:
    int m_x;                    // X Coordinate of top-left corner
    int m_y;                    // Y Coordinate of top-left corner
    int m_z;                    // Z order for sprite
    BYTE m_bTransIndex;         // transparency index value
    CSpriteNotifyObj *m_pNotifyObj; // ptr to a notification object

    virtual void Initialize();  // set initial state
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\cblocks\spriteno.h ===
/*************************************************
 *  spriteno.h                                   *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

// spriteno.h : header file
//
// CSpriteNotifyObj class
//
// This is a class of pure virtual functions with no data.  It is used
// by sprite objects to make notification callbacks.  A user of the CSprite
// class can derive an object from CSpriteNotifyObj and pass a pointer to this
// derived class object to the sprite object for notification calls.
// Just like OLE's IClientSite interface really.
//

class CSprite;

class CSpriteNotifyObj : public CObject
{
public:
    enum CHANGETYPE {			 
        ZORDER      = 0x0001,
        POSITION    = 0x0002,
        IMAGE       = 0x0004
    };

public:
    virtual void Change(CSprite *pSprite,
                        CHANGETYPE change,
                        CRect* pRect1 = NULL,
                        CRect* pRect2 = NULL) = 0;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\cblocks\spritlst.cpp ===
/*************************************************
 *  spritlst.cpp                                 *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

// spritlst.cpp : implementation file
//

#include "stdafx.h"
#include "dib.h"
#include "spriteno.h"
#include "sprite.h"
#include "splstno.h"
#include "spritlst.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSpriteList

IMPLEMENT_SERIAL(CSpriteList, CObList, 0 /* schema number*/ )
													    
CSpriteList::CSpriteList()
{
    // give the sprite notification object
    // a pointer to the list object 
    m_NotifyObj.SetList(this);
}

CSpriteList::~CSpriteList()
{
}

/////////////////////////////////////////////////////////////////////////////
// CSpriteList serialization

void CSpriteList::Serialize(CArchive& ar)
{
    // let the base class create the set of objects
    CObList::Serialize(ar);

    // If we just loaded, initialize each sprite
    if (ar.IsLoading()) {
        for (POSITION pos = GetHeadPosition(); pos != NULL;) {
            CSprite *pSprite = GetNext(pos); // inc pos
            pSprite->SetNotificationObject(&m_NotifyObj);
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
// CSpriteList commands

// Remove everything from the list deleting all the sprites we remove
void CSpriteList::RemoveAll()
{
    // Walk down the list deleting objects as we go.
    // We need to do this here because the base class
    // simply deletes the pointers.
    POSITION pos;
    CSprite *pSprite;
    for (pos = GetHeadPosition(); pos != NULL;) {
        pSprite = GetNext(pos); // inc pos
        if (pSprite) {
            ASSERT(pSprite->IsKindOf(RUNTIME_CLASS(CSprite)));
            delete pSprite;
        }
    }
    // now call the base class to remove the pointers
    CObList::RemoveAll();
}

// Add a sprite to the list, placing it according to its z-order value
BOOL CSpriteList::Insert(CSprite *pNewSprite)
{
    // Set the notification object pointer in the sprite
    // to the list's notifiaction object
    pNewSprite->SetNotificationObject(&m_NotifyObj);

    // Walk down the list until we either get to the end
    // or we find a sprite with the same or higher z order
    // in which case we insert just before that one.

    POSITION pos, posThis;
    CSprite *pSprite;
    for (pos = GetHeadPosition(); pos != NULL;) {
        posThis = pos;
        pSprite = GetNext(pos); // inc pos
        if (pSprite->GetZ() >= pNewSprite->GetZ()) {
            InsertBefore(posThis, pNewSprite);
            return TRUE;
        }
    }
    // nothing with same or higher z-order so add it to the end
    AddTail(pNewSprite); 
    return TRUE;
}

// remove a sprite from the list, but do not delete it
CSprite *CSpriteList::Remove(CSprite *pSprite)
{
    POSITION pos = Find(pSprite);
    if (pos == NULL) {
        return NULL;
    }
    RemoveAt(pos);
    return pSprite;
}

// Move a sprite to its correct z-order position
void CSpriteList::Reorder(CSprite *pSprite)
{
    // Remove the sprite from the list
    if (!Remove(pSprite)) {
        TRACE("Unable to find sprite");
        return; // not there
    }
    // Now insert it again in the right place
    Insert(pSprite);
}

// Test for a mouse hit on any sprite in the list
CSprite *CSpriteList::HitTest(CPoint point)
{
    // Walk the list top down
    POSITION pos;
    CSprite *pSprite;
    for (pos = GetHeadPosition(); pos != NULL;) {
        pSprite = GetNext(pos); // inc pos
        if (pSprite->HitTest(point)) {
            return pSprite;
        }
    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\cblocks\statis.cpp ===
/*************************************************
 *  statis.cpp                                   *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

// statis.cpp : implementation file
//

#include "stdafx.h"
#include "cblocks.h"
#include "dib.h"
#include "dibpal.h"
#include "spriteno.h"
#include "sprite.h"
#include "phsprite.h"
#include "myblock.h"
#include "splstno.h"
#include "spritlst.h"
#include "osbview.h"
#include "blockvw.h"							  
#include "slot.h"
#include "mainfrm.h"
#include "blockdoc.h"

#include "statis.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CStatisticDlg dialog


CStatisticDlg::CStatisticDlg(CBlockDoc* pDoc,CWnd* pParent /*=NULL*/)
	: CDialog(CStatisticDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CStatisticDlg)
	m_nHitWordInAir = _T("");
	m_nHitWordInGround = _T("");
	m_nMissHit = _T("");
	m_nTotalHitWord = _T("");
	m_nTotalWord = _T("");
	//}}AFX_DATA_INIT
	m_pDoc = pDoc;
}


void CStatisticDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CStatisticDlg)
	DDX_Text(pDX, IDC_HITWORDINAIR, m_nHitWordInAir);
	DDX_Text(pDX, IDC_HITWORDINGROUND, m_nHitWordInGround);
	DDX_Text(pDX, IDC_MISSHIT, m_nMissHit);
	DDX_Text(pDX, IDC_TOTALHITWORD, m_nTotalHitWord);
	DDX_Text(pDX, IDC_TOTALWORD, m_nTotalWord);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CStatisticDlg, CDialog)
	//{{AFX_MSG_MAP(CStatisticDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CStatisticDlg message handlers

BOOL CStatisticDlg::OnInitDialog() 
{
	char szBuf[100];
	wsprintf(szBuf,"%d",m_pDoc->GetTotalWords());
	m_nTotalWord = szBuf;

	wsprintf(szBuf,"%d",m_pDoc->GetTotalHitWords());
	m_nTotalHitWord = szBuf;
	
	wsprintf(szBuf,"%d",m_pDoc->GetWordHitInAir());
	m_nHitWordInAir = szBuf;
	
	wsprintf(szBuf,"%d",m_pDoc->GetWordHitInGround());
	m_nHitWordInGround = szBuf;

	wsprintf(szBuf,"%d",m_pDoc->GetMissedHit());
	m_nMissHit = szBuf;
	CDialog::OnInitDialog();
			
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\cblocks\statis.h ===
/*************************************************
 *  statis.h                                     *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

// statis.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CStatisticDlg dialog
class CBlockDoc;
class CStatisticDlg : public CDialog
{
// Construction
public:
	CStatisticDlg(CBlockDoc* pDoc,CWnd* pParent = NULL);   // standard constructor
								   
// Dialog Data
	//{{AFX_DATA(CStatisticDlg)
	enum { IDD = IDD_STATISTIC };
	CString	m_nHitWordInAir;
	CString	m_nHitWordInGround;
	CString	m_nMissHit;
	CString	m_nTotalHitWord;
	CString	m_nTotalWord;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CStatisticDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CBlockDoc* m_pDoc;
	// Generated message map functions
	//{{AFX_MSG(CStatisticDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\cblocks\tip.h ===
/*************************************************
 *  tip.h                                        *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

#ifndef _TIP_H_
#define _TIP_H_

class CTip : public CStatic
{
public:
	CTip();
	void SetString(const char * szStr);
	BOOL Create(CWnd* pWnd);
protected:
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\cblocks\wave.h ===
/*************************************************
 *  wave.h                                       *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

// wave.h : header file
//
#ifndef __WAVE__
#define __WAVE__

#include "waveodev.h"   
#include "mmreg.h"
/////////////////////////////////////////////////////////////////////////////
// CWave object

class CWave : public CObject
{
    DECLARE_SERIAL(CWave)
public:
    CWave();     
    ~CWave();
    BOOL Create(int nsamples, int samprate = 11025, int sampsize = 8);
    BOOL Play(CWaveOutDevice* pWaveOutDevice = NULL);
    void Stop();
    BOOL Load(char* pszFileName = NULL);
    BOOL Load(CFile* fp);  
    BOOL Load(UINT_PTR hFile);
    BOOL Load(HMMIO hmmio);
    BOOL LoadResource(WORD wID);

// Attributes
public:
    WAVEFORMATEX* GetFormat() 
        {return (WAVEFORMATEX*)&m_pcmfmt;}
    CWaveOutDevice* GetOutDevice() 
        {return m_pOutDev;}
    int GetSize() {return m_iSize;}
    int GetNumSamples();
    int GetSample(int index); 
    virtual void OnWaveOutDone();
    virtual void OnWaveInData();
    void SetSample(int index, int iValue);


// Implementation
public:
    void* GetSamples() {return m_pSamples;}
    BOOL IsBusy() {return m_bBusy;}
    void SetBusy(BOOL b) {m_bBusy = b;}

protected:
    virtual void Serialize(CArchive& ar);   // Overridden for document I/O

private:
    PCMWAVEFORMAT m_pcmfmt;   // PCM wave format header
    void*  m_pSamples;          // Pointer to the samples
    int m_iSize;                // Size in bytes
    CWaveOutDevice *m_pOutDev;  // Output device
    BOOL m_bBusy;               // Set to TRUE if playing or recording
};

#endif // __WAVE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\cblocks\tip.cpp ===
/*************************************************
 *  tip.cpp                                      *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

#include "stdafx.h"
#include "tip.h"

CTip::CTip()
{
	
}

void CTip::SetString(const char * szStr)
{
}

BOOL CTip::Create(CWnd* pWnd)
{
	ASSERT(pWnd);
	CRect rc(0,0,40,20);
	return CStatic::Create("111",SS_GRAYRECT | SS_CENTER | SS_BLACKFRAME,rc,pWnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\cblocks\waveodev.h ===
/*************************************************
 *  waveodev.h                                   *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

// waveodev.h : header file
//

#ifndef __WAVEODEV__
#define __WAVEODEV__

/////////////////////////////////////////////////////////////////////////////
// CWaveOutDevice object

class CWave;

class CWaveOutDevice : public CWnd
{
									 
// Attributes
public:
    BOOL IsOpen(); 
    BOOL CanDoFormat(WAVEFORMATEX* pFormat);

// Operations
public:
    CWaveOutDevice();
    BOOL Open(WAVEFORMATEX* pFormat);
    BOOL Close();
    BOOL Play(CWave* pWave);
    void WaveOutDone(CWave* pWave, WAVEHDR* pHdr);

// Implementation
public:
    virtual ~CWaveOutDevice();

private:
    BOOL Create();

    HWAVEOUT m_hOutDev;             // Output device handle
    int m_iBlockCount;              // Number of blocks in the queue

    // Generated message map functions
protected:
    //{{AFX_MSG(CWaveDevWnd)
    afx_msg LRESULT OnWomDone(WPARAM w, LPARAM l);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

// some global items
extern CWaveOutDevice theDefaultWaveOutDevice;

/////////////////////////////////////////////////////////////////////////////
#endif // __WAVEODEV__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\cblocks\waveodev.cpp ===
/*************************************************
 *  waveodev.cpp                                 *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

// waveodev.cpp : implementation file
//


#include "stdafx.h"
#include "wave.h"
						   
#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

// global items
CWaveOutDevice theDefaultWaveOutDevice;

/////////////////////////////////////////////////////////////////////////////
// CWaveOutDevice

CWaveOutDevice::CWaveOutDevice()
{
    m_hOutDev = NULL;
    m_iBlockCount = 0;
}

CWaveOutDevice::~CWaveOutDevice()
{
}

BEGIN_MESSAGE_MAP(CWaveOutDevice, CWnd)
    //{{AFX_MSG_MAP(CWaveOutDevice)
    ON_MESSAGE(MM_WOM_DONE, OnWomDone)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL CWaveOutDevice::Create()
{
    if (!CreateEx(0,
                  AfxRegisterWndClass(0),
                  "Wave Wnd",
                  WS_POPUP,
                  0,
                  0,
                  0,
                  0,
                  NULL,
                  NULL)) {
        TRACE("Failed to create wave notification window");
        return FALSE;
    }
    return TRUE;
}

#ifndef _DEBUG
#define MMERR(n) 0
#else
void MMERR(MMRESULT mmr)
{
    switch (mmr) {
    case WAVERR_BADFORMAT:
        TRACE("No wave device supports format");
        break;
    case MMSYSERR_NOMEM:
        TRACE("Out of memory");
        break;
    case MMSYSERR_ALLOCATED:
        TRACE("Resource is already allocated");
        break;
    case MMSYSERR_BADDEVICEID:
        TRACE("Bad device id");
        break;
    case MMSYSERR_INVALHANDLE:
        TRACE("Invalid device handle");
        break;
    case MMSYSERR_HANDLEBUSY:
        TRACE("Device in use by another thread");
        break;
    case WAVERR_UNPREPARED:
        TRACE("Header not prepared");
        break;
    default:
        TRACE("Unknown error");
        break;
    }
}
#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////
// CWaveOutDevice message handlers

LRESULT CWaveOutDevice::OnWomDone(WPARAM w, LPARAM l)
{
    ASSERT(l);
    WAVEHDR* phdr = (WAVEHDR*) l;
    CWave* pWave = (CWave*)(phdr->dwUser);
    ASSERT(pWave->IsKindOf(RUNTIME_CLASS(CWave)));
    CWaveOutDevice* pOutDev = pWave->GetOutDevice();
    ASSERT(pOutDev);
    pOutDev->WaveOutDone(pWave, phdr);
	UNREFERENCED_PARAMETER(w);
    return 0;
}

BOOL CWaveOutDevice::IsOpen()
{
    return m_hOutDev ? TRUE : FALSE;
}

BOOL CWaveOutDevice::Open(WAVEFORMATEX *pFormat)
{
    MMRESULT mmr;

    // Make sure we have a callback window.
    if (!m_hWnd) {
        Create(); // Create the window.
        ASSERT(m_hWnd);
    }

    // See whether it's already open for this format.
    if (IsOpen()) {
        // See whether it can handle this format.
        if (CanDoFormat(pFormat)) {
            return TRUE;
        } else {
            TRACE("Open for different format");
            return FALSE;
        }
    }

    // See whether we can open for this format.
    mmr = waveOutOpen(&m_hOutDev,
                      WAVE_MAPPER, 
                      pFormat, 
                      (DWORD_PTR)(GetSafeHwnd()), 
                       0, 
                       CALLBACK_WINDOW);
    if (mmr != 0) {
        MMERR(mmr);
        return FALSE;
    }

    return TRUE;
}

BOOL CWaveOutDevice::CanDoFormat(WAVEFORMATEX* pFormat)
{
    MMRESULT mmr;

    if (!IsOpen()) {
        TRACE("Not open");
        return FALSE;
    }
    HWAVEOUT hDev = NULL;
    mmr = waveOutOpen(&hDev, 
                      WAVE_MAPPER, 
                      pFormat, 
                      NULL, 
                      0, 
                      WAVE_FORMAT_QUERY);
    if (mmr != 0) {
        MMERR(mmr);
        return FALSE;
    }
    return TRUE;
}

BOOL CWaveOutDevice::Close()
{
    if (m_hOutDev) {
        // Close the device.
        waveOutReset(m_hOutDev);
        MMRESULT mmr = waveOutClose(m_hOutDev);
        if (mmr != 0) {
            MMERR(mmr);
        }
        m_hOutDev = NULL;
    }
    // Destroy the window.
    DestroyWindow();
    ASSERT(m_hWnd == NULL);
    return TRUE;
}

BOOL CWaveOutDevice::Play(CWave* pWave)
{
    if (!Open(pWave->GetFormat())) {
        return FALSE;
    }

    // Allocate a header.
    WAVEHDR* phdr = (WAVEHDR*)malloc(sizeof(WAVEHDR));
    ASSERT(phdr);
    // Fill out the wave header.
    memset(phdr, 0, sizeof(WAVEHDR));
//#if 1 // BUGFIX for VC++ 2.0
//    phdr->lpData = (BYTE*) pWave->GetSamples();
//#else
    phdr->lpData = (char*) pWave->GetSamples();
//#endif
    phdr->dwBufferLength = pWave->GetSize();
    phdr->dwUser = (DWORD_PTR)(void*)pWave;    // So we can find the object

    // Prepare the header
    MMRESULT mmr = waveOutPrepareHeader(m_hOutDev,
                                        phdr,
                                        sizeof(WAVEHDR));
    if (mmr) {
        MMERR(mmr);
        return FALSE;
    }
    // Mark the wave as busy.
    pWave->SetBusy(TRUE);

    // Start it playing.
    mmr = waveOutWrite(m_hOutDev,
                       phdr,
                       sizeof(WAVEHDR));
    if (mmr) {
        MMERR(mmr);
        return FALSE;
    }

    // Add one to the block count.
    m_iBlockCount++;

    return TRUE;
}

void CWaveOutDevice::WaveOutDone(CWave *pWave, WAVEHDR *pHdr)
{
    // Unprepare the header.
    MMRESULT mmr = waveOutUnprepareHeader(m_hOutDev,
                                          pHdr,
                                          sizeof(WAVEHDR));
    if (mmr) {
        MMERR(mmr);
    }
    // Free the header.
    free(pHdr);

    // Decrement the block count.
    ASSERT(m_iBlockCount > 0);
    m_iBlockCount--;
    if (m_iBlockCount == 0) {
        // Close the device.
        Close();
    }

    // Notify the object that it is done.
    pWave->SetBusy(FALSE);
    pWave->OnWaveOutDone();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\cblocks\wave.cpp ===
/*************************************************
 *  wave.cpp                                     *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

// wave.cpp : implementation file
//

#include "stdafx.h"
#include "wave.h"
#include "mem.h"				   

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWave

IMPLEMENT_SERIAL(CWave, CObject, 0 /* Schema number*/ )

// Create a simple waveform so there's something there.
CWave::CWave()
{
    m_pSamples = NULL;
    m_pOutDev = NULL;
    m_bBusy = FALSE;
    Create(16);
}

CWave::~CWave()
{
    if (m_bBusy) {
        Stop();
    }
    ASSERT(!m_bBusy);
    if (m_pSamples) FREE(m_pSamples);
}


/////////////////////////////////////////////////////////////////////////////
// CWave serialization

void CWave::Serialize(CArchive& ar)
{
    ar.Flush();
    CFile* fp = ar.GetFile();

    if (ar.IsStoring()) {
        ASSERT(0); // Save(fp);
    } else {
        Load(fp);
    }
}

///////////////////////////////////////////////////////////////////////////
// CWave notification functions

void CWave::OnWaveOutDone()
{

}

void CWave::OnWaveInData()
{

}

/////////////////////////////////////////////////////////////////////////////
// CWave commands

BOOL CWave::Create(int nsamples, int samprate, int sampsize)
{
    // validate the args
    if ((samprate != 11025)
    && (samprate != 22050)
    && (samprate != 44100)) {
        TRACE("Invalid sample rate: %d", samprate);
        return FALSE;
    }
    if ((sampsize != 8) && (sampsize != 16)) {
        TRACE("Invalid sample size: %d", sampsize);
        return FALSE;
    }

    // Allocate memory for the samples.
    int iBytes = nsamples * sampsize / 8;
    void* pSamples = ALLOC(iBytes);
    if (!pSamples) {
        TRACE("Out of memory for samples");
        return FALSE;
    }

    // Free existing memory and replace it.
    if (m_pSamples) FREE(m_pSamples);
    m_pSamples = pSamples;
    m_iSize = iBytes;
    
    // Fill out the format info.
    m_pcmfmt.wf.wFormatTag = WAVE_FORMAT_PCM;
    m_pcmfmt.wf.nChannels = 1; // We only do mono.
    m_pcmfmt.wf.nSamplesPerSec = samprate;
    m_pcmfmt.wf.nAvgBytesPerSec = samprate;
    m_pcmfmt.wf.nBlockAlign = (unsigned short) (sampsize / 8); // Number of bytes
    m_pcmfmt.wBitsPerSample = (unsigned short) sampsize; 

    // Set the buffer to silence.
    for (int i=0; i<nsamples; i++) {
        SetSample(i, 0);
    }

    return TRUE;
}

BOOL CWave::Play(CWaveOutDevice* pWaveDevice)
{
    if (pWaveDevice != NULL) {
        m_pOutDev = pWaveDevice;
        return pWaveDevice->Play(this);
    } else {
        m_pOutDev = &theDefaultWaveOutDevice;
        return theDefaultWaveOutDevice.Play(this);
    }
}

void CWave::Stop()
{
    if (!m_bBusy) return;




}

BOOL CWave::Load(char* pszFileName)
{
    CString strFile;    

    if ((pszFileName == NULL) 
    ||  (strlen(pszFileName) == 0)) {

        // Show an open file dialog to get the name.
        CFileDialog dlg   (TRUE,    // Open
                           NULL,    // No default extension
                           NULL,    // No initial file name
                           OFN_FILEMUSTEXIST
                             | OFN_HIDEREADONLY,
                           "Wave files (*.WAV)|*.WAV|All files (*.*)|*.*||");
        if (dlg.DoModal() == IDOK) {
            strFile = dlg.GetPathName();
        } else {
            return FALSE;
        }
    } else {    
        // Copy the supplied file path.
        strFile = pszFileName;                    
    }

    // Try to open the file for read access.
    CFile file;
    if (! file.Open(strFile,
                    CFile::modeRead | CFile::shareDenyWrite)) {
        AfxMessageBox("Failed to open file");
        return FALSE;
    }

    BOOL bResult = Load(&file);
    file.Close();
    if (!bResult) AfxMessageBox("Failed to load file");
    return bResult;
}

BOOL CWave::Load(CFile *fp)
{
    return Load(fp->m_hFile);
}

BOOL CWave::Load(UINT_PTR hFile)
{
    HMMIO hmmio;
    MMIOINFO info;
    memset(&info, 0, sizeof(info));
    info.adwInfo[0] = (DWORD)hFile;
    hmmio = mmioOpen(NULL,
                     &info,
                     MMIO_READ | MMIO_ALLOCBUF);
    if (!hmmio) {
        TRACE("mmioOpen failed");
        return FALSE;
    }
    BOOL bResult = Load(hmmio);
    mmioClose(hmmio, MMIO_FHOPEN);
    return bResult;
}

BOOL CWave::Load(HMMIO hmmio)
{
    // Check whether it's a RIFF WAVE file.
    MMCKINFO ckFile;
    ckFile.fccType = mmioFOURCC('W','A','V','E');
    if (mmioDescend(hmmio,
                    &ckFile,
                    NULL,
                    MMIO_FINDRIFF) != 0) {
        TRACE("Not a RIFF or WAVE file");
        return FALSE;
    }
    // Find the 'fmt ' chunk.
    MMCKINFO ckChunk;
    ckChunk.ckid = mmioFOURCC('f','m','t',' ');
    if (mmioDescend(hmmio,
                    &ckChunk,
                    &ckFile,
                    MMIO_FINDCHUNK) != 0) {
        TRACE("No fmt chunk in file");
        return FALSE;
    }
    // Allocate some memory for the fmt chunk.
    int iSize = ckChunk.cksize;
    WAVEFORMATEX* pfmt = (WAVEFORMATEX*) ALLOC(iSize);
    ASSERT(pfmt);

    if ( pfmt == NULL )
    {
       return FALSE;
    }

    // Read the fmt chunk.
    if (mmioRead(hmmio,
                 (char*)pfmt,
                 iSize) != iSize) {
        TRACE("Failed to read fmt chunk");
        FREE(pfmt);
        return FALSE;
    }
    // Check whether it's in PCM format.
    if (pfmt->wFormatTag != WAVE_FORMAT_PCM) {
        TRACE("Not a PCM file");
        FREE(pfmt);
        return FALSE;
    }
    // Get out of the fmt chunk.
    mmioAscend(hmmio, &ckChunk, 0);
    // Find the 'data' chunk.
    ckChunk.ckid = mmioFOURCC('d','a','t','a');
    if (mmioDescend(hmmio,
                    &ckChunk,
                    &ckFile,
                    MMIO_FINDCHUNK) != 0) {
        TRACE("No data chunk in file");
        FREE(pfmt);
        return FALSE;
    }
    // Allocate some memory for the data chunk.
    iSize = ckChunk.cksize;
    void* pdata = ALLOC(iSize);
    if (!pdata) {
        TRACE("No mem for data");
        FREE(pfmt);
        return FALSE;
    }
    // Read the data chunk.
    if (mmioRead(hmmio,
                 (char *)pdata,
                 iSize) != iSize) {
        TRACE("Failed to read data chunk");
        FREE(pfmt);
        FREE(pdata);
        return FALSE;
    }
    // Wrap the CWave object around what we have.
    memcpy(&m_pcmfmt, pfmt, sizeof(m_pcmfmt));
    // Replace the samples.
    if (m_pSamples) FREE(m_pSamples);
    m_pSamples = pdata;
    m_iSize = iSize;

    return TRUE;
}

BOOL CWave::LoadResource(WORD wID)
{
    ASSERT(wID);
    HINSTANCE hInst = AfxGetResourceHandle();
    HRSRC hrsrc = ::FindResource(hInst,
                                 MAKEINTRESOURCE(wID), "WAVE");
    if (!hrsrc) {
        TRACE("WAVE resource not found");
        return FALSE;
    }
    HGLOBAL hg = ::LoadResource(hInst,
                                hrsrc);
    if (!hg) {
        TRACE("Failed to load WAVE resource");
        return FALSE;
    }
    char* pRes = (char*) ::LockResource(hg);
    ASSERT(pRes);

    if ( pRes == NULL )
    {
       TRACE("Failed to lock WAVE resource");
       return FALSE;
    }

    // Mark the resource pages as read/write so the mmioOpen
    // won't fail
    int iSize = ::SizeofResource(hInst, hrsrc);
    DWORD dwOldProt;
    BOOL b = ::VirtualProtect(pRes,
                              iSize,
                              PAGE_READWRITE,
                              &dwOldProt);
    ASSERT(b);

    // Open the memory block as an HMMIO object
    HMMIO hmmio;
    MMIOINFO info;
    memset(&info, 0, sizeof(info));
    info.fccIOProc = FOURCC_MEM;
    info.pchBuffer = pRes;
    info.cchBuffer = iSize;

    hmmio = mmioOpen(NULL,
                     &info,
                     MMIO_READ);
    if (!hmmio) {
        TRACE("mmioOpen failed. Error %d\n", info.wErrorRet);
        return FALSE;
    }
    BOOL bResult = Load(hmmio);
    mmioClose(hmmio, MMIO_FHOPEN);

    // Note: not required to unlock or free the resource in Win32
    return bResult;
}


// Get the number of samples.
int CWave::GetNumSamples()
{
    ASSERT(m_pcmfmt.wBitsPerSample);
    return m_iSize * 8 / m_pcmfmt.wBitsPerSample;
}

// Get a sample value scaled as a 16 bit signed quantity.
int CWave::GetSample(int index)
{
    if ((index < 0) || (index >= GetNumSamples())) {
        TRACE("Sample index out of range");
        return 0;
    }
    switch (m_pcmfmt.wBitsPerSample) {
    case 8: {
        BYTE *p = (BYTE *) m_pSamples;
        int i = p[index]; // 0 - 255;
        return (i - 128) * 256;
        } break;

    case 16: {
        ASSERT(sizeof(short int) == 2);
        short int* p = (short int *) m_pSamples;
        return p[index];
        } break;
        
    default:
        break;
    }
    ASSERT(1); // Invalid bits per sample
    return 0;
}            

// Set a sample value from a 16 bit signed quantity.
void CWave::SetSample(int index, int iValue)
{
    if ((index < 0) || (index >= GetNumSamples())) {
        TRACE("Sample index out of range");
        return;
    }
    switch (m_pcmfmt.wBitsPerSample) {
    case 8: {
        BYTE* p = (BYTE*) m_pSamples;
        p[index] = (unsigned char) (iValue / 256 + 128);
        } break;

    case 16: {
        ASSERT(sizeof(short int) == 16);
        short int* p = (short int*) m_pSamples;
        p[index] = (unsigned short) iValue;
        } break;
        
    default:
        ASSERT(1); // Invalid bits per sample
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\lctool\lcfile.c ===
/*************************************************
 *  lcfile.c                                     *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

//
//  Change Log:
//
//              @C001 - Use _make\splitpath insteading of _wmake\splitpath
//              @C002 - Untest Chinese in assoc phrases
//              @C003 - Create tbl files always so phrases can be activated immediately
//
//
//  1/27/96
//    @C004             Fix bug of error writing registy database

#include <windows.h>            // required for all Windows applications
#include <windowsx.h>
#include <string.h>
#include <stdlib.h>
#include <shlobj.h>
#include "rc.h"
#include "lctool.h"

#define END_PHRASE      0x8000
#define NOT_END_PHRASE  0x7fff
#ifdef UNICODE
#define PTRRECLEN       3               // Pointer file record length
#else
#define PTRRECLEN       4               // Pointer file record length
#endif
#define LCPTRFILE       "LCPTR.TBL"
#define LCPHRASEFILE    "LCPHRASE.TBL"
#define LCPHRASENOEXT   "LCPHRASE"

extern HWND subhWnd;

// Local function prototypes.

#ifdef UNICODE

TCHAR g_szLCPhraseName[MAX_PATH];
TCHAR g_szLCPtrName[MAX_PATH];
TCHAR g_szLCUserPath[MAX_PATH];

BOOL lcAddPhrase( TCHAR *, TCHAR *, UINT *, DWORD, DWORD, DWORD);

BOOL lcFOpen( HWND hWnd)
{
    HANDLE hLCPtr,hLCPhrase;
    HFILE  hfLCPtr,hfLCPhrase;
    DWORD  flen_Ptr,flen_Phrase;
    TCHAR  szLCPtrName[MAX_PATH];
    TCHAR  szLCPhraseName[MAX_PATH];
    TCHAR  *szLCPtrBuf,*szLCPhraseBuf;
    UCHAR  szTmp[MAX_PATH];
    BOOL   rc;
    UINT   i;
    DWORD  lStart,lEnd;
    TCHAR  szDispBuf[MAX_CHAR_NUM];
    UINT   nDisp,len;
    HKEY   hkey;
    LONG   lResult;
    LONG   lcount, lType;


   // Get the path for User Dictionary. 

    SHGetSpecialFolderPath(NULL, g_szLCUserPath, CSIDL_APPDATA , FALSE);

    if ( g_szLCUserPath[lstrlen(g_szLCUserPath) - 1] == TEXT('\\') )
         g_szLCUserPath[lstrlen(g_szLCUserPath) - 1] = TEXT('\0');

    lstrcat(g_szLCUserPath, TEXT("\\Microsoft") ); 

    if ( GetFileAttributes(g_szLCUserPath) != FILE_ATTRIBUTE_DIRECTORY)
       CreateDirectory(g_szLCUserPath, NULL);

    lstrcat(g_szLCUserPath, TEXT("\\LCTOOL") );

    if ( GetFileAttributes(g_szLCUserPath) != FILE_ATTRIBUTE_DIRECTORY)
       CreateDirectory(g_szLCUserPath, NULL);

    // Get Current User Dictionary
    lResult = RegOpenKeyEx(HKEY_CURRENT_USER, L"Control Panel\\Input Method", 0,
                           KEY_ALL_ACCESS, &hkey) ;
    if (lResult == ERROR_SUCCESS) {

            lcount = 2 * MAX_PATH;
            lType = REG_SZ;
            lResult = RegQueryValueEx(hkey, L"Phrase Prediction Dictionary",0, 
                                                    &lType, (LPBYTE)szLCPhraseName, &lcount);
            if (lResult == ERROR_SUCCESS) {

                    lcount = 2 * MAX_PATH;
                    lType = REG_SZ;
                    lResult = RegQueryValueEx(hkey, L"Phrase Prediction Pointer",0, 
                                            &lType, (LPBYTE)szLCPtrName, &lcount);
            }
    }

    if (lResult != ERROR_SUCCESS) {

            // Get system directory
            len = GetSystemDirectory(szLCPtrName, sizeof(szLCPtrName));
            if (szLCPtrName[len - 1] !=_TEXT('\\')) {     // consider C:\ ;
                    szLCPtrName[len++] =_TEXT('\\');
                    szLCPtrName[len] = 0;
            }
            lstrcpy(szLCPhraseName, szLCPtrName);
            lstrcat(szLCPtrName,_TEXT(LCPTRFILE));
            lstrcat(szLCPhraseName,_TEXT(LCPHRASEFILE));
    }

    // Open LC pointer file
    WideCharToMultiByte(CP_ACP,0,szLCPtrName,-1,szTmp,MAX_PATH,NULL,0);
        hfLCPtr=_lopen(szTmp,OF_READ);
    if(hfLCPtr == -1){
        lcErrIOMsg(IDS_ERR_FILEOPEN, LCPTRFILE);
        return FALSE;
    }
    WideCharToMultiByte(CP_ACP,0,szLCPhraseName,-1,szTmp,MAX_PATH,NULL,0);
        hfLCPhrase=_lopen(szTmp,OF_READ);

   // Open LC phrase file
    if(hfLCPhrase == -1){
        _lclose(hfLCPtr);
        lcErrIOMsg(IDS_ERR_FILEOPEN, LCPTRFILE);
        return FALSE;
    }

    lstrcpy(g_szLCPhraseName, szLCPhraseName);
    lstrcpy(g_szLCPtrName, szLCPtrName);

   // get  file length
    flen_Ptr=_llseek(hfLCPtr,0L,2);     /* get file length */

   // Allocate Memory
    hLCPtr = GlobalAlloc(GMEM_FIXED, flen_Ptr);
    if(!hLCPtr) {
        lcErrMsg(IDS_ERR_MEMORY);
        goto error;
    }
    szLCPtrBuf = GlobalLock(hLCPtr);

    _llseek(hfLCPtr,0L,0);              //set to beginning 4

    if(flen_Ptr != _lread(hfLCPtr,szLCPtrBuf,flen_Ptr)) {
        lcErrIOMsg(IDS_ERR_FILEREAD, LCPTRFILE);
        goto error;
    }
    _lclose(hfLCPtr);

    //get  file length
    flen_Phrase=_llseek(hfLCPhrase,0L,2);      /* get file length */

   // Allocate Memory
    hLCPhrase = GlobalAlloc(GMEM_MOVEABLE, flen_Phrase);
    if(!hLCPhrase) {
        lcErrMsg(IDS_ERR_MEMORY);
        goto error;
    }
    szLCPhraseBuf = GlobalLock(hLCPhrase);

    _llseek(hfLCPhrase,0L,0); //set to beginning

    if(flen_Phrase != _lread(hfLCPhrase,szLCPhraseBuf,flen_Phrase)) {
        lcErrIOMsg(IDS_ERR_FILEREAD, LCPHRASEFILE);
        goto error;
    }
    _lclose(hfLCPhrase);


    rc=TRUE;

   // Convert file to structured memory (WORDBUF & PHRASEBUF)
   // First record is Null record skip it
    for(i=1; i<((flen_Ptr/PTRRECLEN)>>1)-1; i++) {
       // If Allocated Word buffer not enough Reallocate it
        if(lWordBuff+1 == nWordBuffsize)
            if(!(rc=lcAllocWord()))   break;
        lpWord[lWordBuff].wWord=szLCPtrBuf[i*PTRRECLEN];
       // If Allocated Phrase buffer not enough Reallocate it
        if(lPhraseBuff+1 == nPhraseBuffsize)
            if(!(rc=lcAllocPhrase()))  break;

        lpWord[lWordBuff].lFirst_Seg=lPhraseBuff;
        lpPhrase[lPhraseBuff].lNext_Seg=NULL_SEG;
        lWordBuff++;
        lPhraseBuff++;
        nDisp=0;

       // Add Phrase to Display buffer
        lStart=*((LPUNADWORD)&szLCPtrBuf[i*PTRRECLEN+1]);
        lEnd=*((LPUNADWORD)&szLCPtrBuf[i*PTRRECLEN+PTRRECLEN+1]);
                
        if(lStart <= lEnd) {
            rc=lcAddPhrase(szLCPhraseBuf, szDispBuf, &nDisp,
                            lStart, lEnd, flen_Phrase>>1);
            if(!rc) break;
        }

       // Put display buffer into Phrase buffer
        if(nDisp == 0)   szDispBuf[0]=0;
        else             szDispBuf[nDisp-1]=0;

        if(!(rc=lcDisp2Mem(lWordBuff-1, szDispBuf)))  break;
    }

    GlobalUnlock(hLCPtr);
    GlobalUnlock(hLCPhrase);
    GlobalFree(hLCPtr);
    GlobalFree(hLCPhrase);
    return rc;

error:

    _lclose(hfLCPtr);
    _lclose(hfLCPhrase);
    GlobalUnlock(hLCPtr);
    GlobalUnlock(hLCPhrase);
    GlobalFree(hLCPtr);
    GlobalFree(hLCPhrase);
    return FALSE;
}

BOOL lcAddPhrase(
    TCHAR *szLCWord,                    // LC Phrase buffer
    TCHAR *szDispBuf,                   // Display buffer
    UINT  *nDisp,                       // Display buffer length
    DWORD  lStart,                       // Start address of LC Phrase
    DWORD  lEnd,                         // End address of LC Phrase
    DWORD  lLen)                         // Total Length of LC Phrase
{
    DWORD  i,j;
    
    // Check length
    if(lLen < lStart) {
        lcErrMsg(IDS_ERR_LCPTRFILE);
        return FALSE;
    }
 
    j=(lLen < lEnd) ? lLen:lEnd;
    for(i=lStart; i < j; i++) {
        szDispBuf[(*nDisp)++]=szLCWord[i] ? szLCWord[i]:_TEXT(' ');
        if( ((*nDisp)+1) >= MAX_CHAR_NUM) {
            szDispBuf[(*nDisp)++]=0;
            lcErrMsg(IDS_ERR_OVERMAX);
            return FALSE;
        }
    }
    szDispBuf[(*nDisp)++]=0;
    
    return TRUE;
}

// @C001
static void local_splitpath(TCHAR *szFilePath, TCHAR *szDriveBuf, TCHAR *szDirBuf, TCHAR *szFNameBuf, TCHAR *szExtBuf)
{
        static UCHAR  u_szFilePath[MAX_PATH];
        static UCHAR  u_szDirBuf[_MAX_DIR];
        static UCHAR  u_szDriveBuf[_MAX_DRIVE];
        static UCHAR  u_szFNameBuf[_MAX_FNAME];
        static UCHAR  u_szExtBuf[_MAX_EXT];

        WideCharToMultiByte(CP_ACP, 0, szFilePath, -1, u_szFilePath, MAX_PATH, NULL,0);
        _splitpath(u_szFilePath, u_szDriveBuf, u_szDirBuf, u_szFNameBuf, u_szExtBuf);

        MultiByteToWideChar(CP_ACP, 0, u_szDriveBuf, -1, szDriveBuf, _MAX_DRIVE);
        MultiByteToWideChar(CP_ACP, 0, u_szDirBuf, -1, szDirBuf, _MAX_DIR);
        MultiByteToWideChar(CP_ACP, 0, u_szFNameBuf, -1, szFNameBuf, _MAX_FNAME);
        MultiByteToWideChar(CP_ACP, 0, u_szExtBuf, -1, szExtBuf, _MAX_EXT);
}

// @C001
static void local_makepath(TCHAR *szFilePath, TCHAR *szDriveBuf, TCHAR *szDirBuf, TCHAR *szFNameBuf, TCHAR *szExtBuf)
{
        static UCHAR  u_szFilePath[MAX_PATH];
        static UCHAR  u_szDirBuf[_MAX_DIR];
        static UCHAR  u_szDriveBuf[_MAX_DRIVE];
        static UCHAR  u_szFNameBuf[_MAX_FNAME];
        static UCHAR  u_szExtBuf[_MAX_EXT];

        WideCharToMultiByte(CP_ACP, 0, szDriveBuf, -1, u_szDriveBuf, _MAX_DRIVE, NULL,0);
        WideCharToMultiByte(CP_ACP, 0, szDirBuf, -1, u_szDirBuf, _MAX_DIR, NULL,0);
        WideCharToMultiByte(CP_ACP, 0, szFNameBuf, -1, u_szFNameBuf, _MAX_FNAME, NULL,0);
        WideCharToMultiByte(CP_ACP, 0, szExtBuf, -1, u_szExtBuf, _MAX_EXT, NULL,0);

        _makepath(u_szFilePath, u_szDriveBuf, u_szDirBuf, u_szFNameBuf, u_szExtBuf);

        MultiByteToWideChar(CP_ACP, 0, u_szFilePath, -1, szFilePath, MAX_PATH);

}

BOOL lcFSave(
    HWND hwnd, BOOL bSaveAs)
{
    HANDLE hLCPtr, hLCPhrase;
    HFILE  hfLCPtr,hfLCPhrase;
    TCHAR  szLCSystemName[MAX_PATH];
    TCHAR  szLCPtrName[MAX_PATH];
    TCHAR  szLCPhraseName[MAX_PATH];
    TCHAR  szLCPtrBuf[PTRRECLEN],szLCPhraseBuf[MAX_CHAR_NUM];
    UINT   i,j;
    DWORD  lStartPhrase;
    DWORD  lPhraseLen;
    UINT   len;
    UCHAR  szUStr[MAX_CHAR_NUM],*pUStr;

    OPENFILENAME    ofn;
    TCHAR  szFileOpen[25];
    TCHAR  szCustFilter[40];
    TCHAR  szFileName[MAX_PATH];
    TCHAR  szFilePath[MAX_PATH];

    TCHAR  szDirBuf[_MAX_DIR];
    TCHAR  szDriveBuf[_MAX_DRIVE];
    TCHAR  szFNameBuf[_MAX_FNAME];
    TCHAR  szExtBuf[_MAX_EXT];

    TCHAR  szFilterSpec[MAX_PATH];
    TCHAR  szExt[10];

    if(!lcSort(hwnd))
        return FALSE;
    if(wSameCode)
        return FALSE;

DOSAVE:
   // Get system directory
    len = GetSystemDirectory(szLCSystemName, sizeof(szLCSystemName));
    if (szLCSystemName[len - 1] != _TEXT('\\')) {     // consider C:\ ;
        szLCSystemName[len++] = _TEXT('\\');
        szLCSystemName[len] = 0;
    }

    if (bSaveAs) {
        LoadString (hInst, IDS_DICTFILTERSPEC, szFilterSpec, sizeof(szFilterSpec)/sizeof(TCHAR));
        LoadString (hInst, IDS_DICTDEFAULTFILEEXT, szExt, sizeof(szExt)/sizeof(TCHAR));

        szFilterSpec[lstrlen(szFilterSpec) + 2] = 0;
        szFileName[0]=0;
        LoadString (hInst, IDS_SAVETABLE, szFileOpen, sizeof(szFileOpen)/sizeof(TCHAR) );
        szCustFilter[0]=0;
        lstrcpy(&szCustFilter[1], szExt);
        szCustFilter[lstrlen(szExt) + 2] = 0;

        local_splitpath(g_szLCPhraseName, szDriveBuf, szDirBuf, szFNameBuf, szExtBuf); // @C001

        if (lstrcmpi(szFNameBuf, _TEXT(LCPHRASENOEXT)) == 0) {
            lstrcpy(szFilePath, szExt);
        } else {
            lstrcpy(szFilePath, szFNameBuf);
            lstrcat(szFilePath, szExtBuf);
        }

        /* fill in non-variant fields of OPENFILENAME struct. */
        ofn.lStructSize       = sizeof(OPENFILENAME);
        ofn.hwndOwner         = NULL;
        ofn.lpstrFilter       = szFilterSpec;
        ofn.lpstrCustomFilter = szCustFilter;
        ofn.nMaxCustFilter    = sizeof(szCustFilter);
        ofn.nFilterIndex      = 1;
        ofn.lpstrFile         = szFilePath;
        ofn.nMaxFile          = MAX_PATH;
        ofn.lpstrInitialDir   = g_szLCUserPath;
        ofn.lpstrFileTitle    = szFileName;
        ofn.nMaxFileTitle     = MAX_PATH;
        ofn.lpstrTitle        = szFileOpen;
        ofn.lpstrDefExt       = szExt+2;
        ofn.Flags             = OFN_HIDEREADONLY | OFN_PATHMUSTEXIST;

        if(!GetSaveFileName ((LPOPENFILENAME)&ofn))
                return FALSE;

        lstrcat(szLCSystemName, _TEXT(LCPHRASEFILE));
        lstrcpy(szLCPhraseName, szFilePath);
        if (lstrcmpi(szLCPhraseName, szLCSystemName) == 0) {
                lcErrMsg(IDS_ERR_SAVESYSTEMTBL);
                return FALSE;
        }

        local_splitpath(szFilePath, szDriveBuf, szDirBuf, szFNameBuf, szExtBuf); // @C001

        len=lstrlen(szFNameBuf);
        if(len > 5)
                len=5;
        szFNameBuf[len]=0;
        lstrcat(szFNameBuf, _TEXT("PTR"));

        local_makepath(szLCPtrName, szDriveBuf, szDirBuf, szFNameBuf, _TEXT(".TBL")); // @C001

        if (lstrcmpi(szLCPtrName, szLCPhraseName) == 0) {
                local_makepath(szLCPtrName, szDriveBuf, szDirBuf, szFNameBuf, _TEXT(".TB1")); // @C001
        }
    } else {
        lstrcpy(szLCPhraseName, g_szLCPhraseName);
        lstrcpy(szLCPtrName, g_szLCPtrName);

        lstrcat(szLCSystemName, _TEXT(LCPHRASEFILE));
        if (lstrcmpi(szLCPhraseName, szLCSystemName) == 0) {
            bSaveAs = TRUE;
            goto DOSAVE;
        }
    }

   // Open LC phrase file
    hLCPhrase = CreateFile(szLCPhraseName, 
                               GENERIC_READ | GENERIC_WRITE,
                               FILE_SHARE_READ, 
                               NULL, 
                               OPEN_ALWAYS, 
                               FILE_ATTRIBUTE_NORMAL, // @C003
                               NULL ) ;
    if(hLCPhrase == INVALID_HANDLE_VALUE) {
        lcErrMsg(IDS_ERR_FILESAVE);
        goto error;
    }
    hfLCPhrase = PtrToInt( hLCPhrase );
   // Open LC pointer file
    hLCPtr = CreateFile(szLCPtrName, 
                            GENERIC_READ | GENERIC_WRITE,
                            FILE_SHARE_READ, 
                            NULL, 
                            OPEN_ALWAYS, 
                            FILE_ATTRIBUTE_NORMAL, // @C003
                            NULL ) ;
    if(hLCPtr == INVALID_HANDLE_VALUE) {
        lcErrMsg(IDS_ERR_FILESAVE);
        goto error;
    }
    hfLCPtr = PtrToInt( hLCPtr );
        // Copy into global variable
    lstrcpy(g_szLCPhraseName, szLCPhraseName);
    lstrcpy(g_szLCPtrName, szLCPtrName);

   // Write a Null record into first record
    memset(szUStr,0,PTRRECLEN*2);
    if((PTRRECLEN*2) != _lwrite(hfLCPtr,szUStr,PTRRECLEN*2)) {
        lcErrIOMsg(IDS_ERR_FILEWRITE, LCPTRFILE);
        goto error;
    }
    lStartPhrase=0;
    // initialize szLCPtrBuf and szLCPhraseBuf
    for ( i=0; i< PTRRECLEN; i++)
        szLCPtrBuf[i] = TEXT('\0');

    for ( i=0; i<MAX_CHAR_NUM; i++)
        szLCPhraseBuf[i] = TEXT('\0');

    for(i=0; i<lWordBuff; i++) {
        lPhraseLen=0;

        // Truncate same Word
                if(lpWord[i].wWord == *(szLCPtrBuf))
            continue;

        lPhraseLen=lcMem2Disp(i, szLCPhraseBuf);
                len=lPhraseLen << 1 ;
                for(j=0;j<lPhraseLen;j++) if(szLCPhraseBuf[j]==_TEXT(' ')) szLCPhraseBuf[j]=0;

       // Check register phrase over max length
        if(lStartPhrase > (0x0ffffffd-len)) {
            lcErrMsg(IDS_ERR_OVER_MAXLEN);
            goto error;
        }

        szLCPtrBuf[0]=lpWord[i].wWord;
        *((LPUNADWORD)&szLCPtrBuf[1])=lStartPhrase;
                pUStr=(UCHAR*)szLCPtrBuf;
        if(PTRRECLEN*2 != _lwrite(hfLCPtr,pUStr,PTRRECLEN*2)) {
            lcErrIOMsg(IDS_ERR_FILEWRITE, LCPTRFILE);
            goto error;
        }
        if(lPhraseLen){
            pUStr=(UCHAR*)szLCPhraseBuf;
                        if(len !=_lwrite(hfLCPhrase,pUStr,len)) {
                lcErrIOMsg(IDS_ERR_FILEWRITE, LCPHRASEFILE);
                goto error;
            }
                }
        lStartPhrase+=lPhraseLen;
    }

   // Write the lasr record
        szLCPtrBuf[0]=0xffff;
    *((LPUNADWORD)&szLCPtrBuf[1])=lStartPhrase;
        pUStr=(UCHAR*)szLCPtrBuf;
    if(PTRRECLEN*2 != _lwrite(hfLCPtr,pUStr,PTRRECLEN*2)) {
        lcErrIOMsg(IDS_ERR_FILEWRITE, LCPTRFILE);
        goto error;
    }

    SetEndOfFile(hLCPtr);
    SetEndOfFile(hLCPhrase);
    _lclose(hfLCPtr);
    _lclose(hfLCPhrase);
    bSaveFile=FALSE;

        {
                HKEY hkey;
                DWORD dwDisposition;
                LONG lResult;

                lResult= RegCreateKeyEx(HKEY_CURRENT_USER, L"Control Panel\\Input Method", 0,
                           L"Application Per-User Data", REG_OPTION_NON_VOLATILE,
                           KEY_ALL_ACCESS,
                           NULL, &hkey, &dwDisposition) ;
                lResult = RegSetValueEx(hkey, L"Phrase Prediction Dictionary",0, 
                                                        REG_SZ, (BYTE *)szLCPhraseName, 2 * (lstrlen(szLCPhraseName) + 1)); // <== @C004
                lResult = RegSetValueEx(hkey, L"Phrase Prediction Pointer",0, 
                                                        REG_SZ, (BYTE *)szLCPtrName, 2 * (lstrlen(szLCPtrName) + 1)); // <== @C004
        }
        
        return TRUE;

error:
    _lclose(hfLCPtr);
    _lclose(hfLCPhrase);
    return FALSE;

}

BOOL lcInsline(
    TCHAR  *szStr,
    UINT   iWord,
    UINT   len,
    BOOL   *bOver)
{
    WORD  wWord;
    UINT  iFree,nDisp;
    UINT  i,j,buflen;
    TCHAR szDispBuf[MAX_CHAR_NUM];
    TCHAR szBuffer[MAX_CHAR_NUM*2];
    unsigned long  l;

    szStr[len]=0;                       // Append Null to end of line

   // Skip lead spaces if exist
    for(i=0; (i<len) && (szStr[i] ==_TEXT(' ')); i++);

        if( ((i+1) >= len) || (szStr[i+1] !=_TEXT(' ')) ) {
        lcErrMsg(IDS_ERR_IMP_SEPRATOR);
        return FALSE;
    }

    if(!is_DBCS2(*((WORD *)(&szStr[i])), TRUE)) {
       return FALSE;
    }

        wWord=szStr[i];

   // Skip spaces after Word
        for(j=i+1; (j<len) && (szStr[j] ==_TEXT(' ')); j++);
    if(j == len) {
        lcErrMsg(IDS_ERR_IMP_NOPHRASE);
        return FALSE;
    }
    lstrcpy(szDispBuf, &szStr[j]);
    nDisp=lstrlen(szDispBuf)+1;

#ifndef UNICODE  // @C002
   // Check DBCS
        for(i=0; i<(nDisp-1); i++) {
        if(szDispBuf[i] ==_TEXT(' '))
            continue;
        if(!is_DBCS2(szDispBuf[i], TRUE)) {
            return FALSE;
        }
        i++;
    }
#endif // @C002

   // Check same Word
    for(i=0; i<lWordBuff; i++) {
        if(lpWord[i].wWord==wWord) {
            buflen=lcMem2Disp(i, szBuffer);
            if((buflen + lstrlen(szDispBuf)) >= MAX_CHAR_NUM)
                *bOver=TRUE;
            lstrcat(szBuffer, szDispBuf);
            return(lcDisp2Mem(i, szBuffer));
        }
    }

   // Check Word buffer enough ?
    if(lWordBuff+1 == nWordBuffsize)
        if(!lcAllocWord())
            return FALSE;

   // Allocate a Phrase Buffer
    iFree=lcGetSeg();
    if(iFree == NULL_SEG)
        return FALSE;
    if(lWordBuff == 0) {
        lpWord[iWord].wWord=wWord;
        lpWord[iWord].lFirst_Seg=iFree;
    } else {
        for(l=lWordBuff; l >= iWord; l--) {
            lpWord[l+1].wWord=lpWord[l].wWord;
            lpWord[l+1].lFirst_Seg=lpWord[l].lFirst_Seg;
        }
        lpWord[iWord].wWord=wWord;
        lpWord[iWord].lFirst_Seg=iFree;
    }
    lWordBuff++;

    if(!lcDisp2Mem(iWord, szDispBuf))
        return FALSE;

    return TRUE;
}

BOOL lcAppend(
    HWND hwnd)
{
    OPENFILENAME    ofn;
    TCHAR  szFileOpen[25];
    TCHAR  szCustFilter[10];
    TCHAR  szFileName[MAX_PATH];
    TCHAR  szFilePath[MAX_PATH];
    UCHAR  szUFilePath[MAX_PATH];
    HFILE  hfImport;
    HANDLE hImport;
    TCHAR  szStr[MAX_CHAR_NUM+10];
    UCHAR  *szUBuf;
    TCHAR  *szBuf;
    DWORD  flen;
    BOOL   bOver=FALSE;
    UINT   i,len;
    UINT   iEdit,iWord;
    BOOL   is_WORD;

    iEdit=lcGetEditFocus(GetFocus(), &is_WORD);
    iWord=iDisp_Top+iEdit;
    if(iWord > lWordBuff)
        iWord=lWordBuff;

    if(!lcSaveEditText(iDisp_Top, 0))
        return FALSE;

    szFileName[0]=0;
    LoadString (hInst, IDS_APPENDTITLE, szFileOpen, sizeof(szFileOpen)/sizeof(TCHAR));
    szCustFilter[0]=0;
    lstrcpy(&szCustFilter[1], szExt);
    lstrcpy(szFilePath, szExt);

    /* fill in non-variant fields of OPENFILENAME struct. */
    ofn.lStructSize       = sizeof(OPENFILENAME);
    ofn.hwndOwner         = NULL;
    ofn.lpstrFilter       = szFilterSpec;
    ofn.lpstrCustomFilter = szCustFilter;
    ofn.nMaxCustFilter    = sizeof(szCustFilter);
    ofn.nFilterIndex      = 1;
    ofn.lpstrFile         = szFilePath;
    ofn.nMaxFile          = MAX_PATH;
    ofn.lpstrInitialDir   = g_szLCUserPath;
    ofn.lpstrFileTitle    = szFileName;
    ofn.nMaxFileTitle     = MAX_PATH;
    ofn.lpstrTitle        = szFileOpen;
    ofn.lpstrDefExt       = szExt+2;
    ofn.Flags             = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY |
                            OFN_PATHMUSTEXIST;

    /* call common open dialog and return result */
    if(GetOpenFileName ((LPOPENFILENAME)&ofn))
    {
        SetCursor(hCursorWait);
        
                WideCharToMultiByte(CP_ACP,0,szFilePath,-1,szUFilePath,MAX_PATH,NULL,0);
                hfImport=_lopen(szUFilePath,OF_READ);
        if(hfImport == -1){
            lcErrIOMsg(IDS_ERR_FILEOPEN, szUFilePath);
            return FALSE;
        }

       // get  file length
        flen=_llseek(hfImport,0L,2);

        _llseek(hfImport,0L,0);         //set to beginning

       // Allocate Memory
        hImport = GlobalAlloc(GMEM_FIXED, flen + 2);
        if(!hImport) {
            lcErrMsg(IDS_ERR_MEMORY);
            return FALSE;
        }
        szUBuf = GlobalLock(hImport);

       // Read file to memory
        if(flen != _lread(hfImport,szUBuf,flen)) {
            lcErrIOMsg(IDS_ERR_FILEREAD, szUFilePath);
            return FALSE;
        }
        _lclose(hfImport);
                szUBuf[flen] = 0;

        if(szUBuf[1]!=0xFE && szUBuf[0]!=0xFF) //not a unicode file
                {
                        HANDLE hImport2 = GlobalAlloc(GMEM_FIXED, ((flen+2)<<1));

            if(!hImport2) {
               lcErrMsg(IDS_ERR_MEMORY);
               return FALSE;
            }
            szBuf = GlobalLock(hImport2);
                        flen=MultiByteToWideChar(CP_ACP,MB_PRECOMPOSED,szUBuf,-1,szBuf+1,flen);
                        
                        GlobalUnlock(hImport);
            GlobalFree(hImport);

                        hImport=hImport2;
                        flen<<=1;
                        flen-=2;

                } 
                else 
                        szBuf=(TCHAR*)szUBuf;

                len=0;
        for(i=1; i<=((flen>>1)+1); i++) {                                      //@D01C
            if((szBuf[i] == 0x000d) || (szBuf[i] == 0x000a)) {
                if(len != 0) {
                    if(!lcInsline(szStr, iWord++, len, &bOver))
                        break;
                    len=0;
                }
                continue;
            }
            if((szBuf[i] == 0x001a) || (i == ((flen>>1)+1))) {                      //@D01C
                if(len != 0) {
                    if(!lcInsline(szStr, iWord++, len, &bOver))
                        break;
                }
                break;
            }
            if(len >= MAX_CHAR_NUM+3)
                bOver=TRUE;
            else
                szStr[len++]=szBuf[i];
        }

        if(bOver)
            lcErrMsg(IDS_ERR_OVERMAX);
        SetScrollRange(subhWnd, SB_VERT, 0, lWordBuff-iPage_line, FALSE);
        SetScrollPos(subhWnd, SB_VERT, yPos, TRUE);
        lcSetEditText(iDisp_Top, FALSE);

        GlobalUnlock(hImport);
        GlobalFree(hImport);
        bSaveFile=TRUE;
    }
    return TRUE;
}

BOOL lcImport(
    HWND hwnd)
{
    OPENFILENAME    ofn;
    TCHAR  szFileOpen[25];
    TCHAR  szCustFilter[10];
    TCHAR  szFileName[MAX_PATH];
    TCHAR  szFilePath[MAX_PATH];
    UCHAR  szUFilePath[MAX_PATH];
    HFILE  hfImport;
    HANDLE hImport;
    TCHAR  szStr[MAX_CHAR_NUM+10];
    TCHAR  *szBuf;
    UCHAR  *szUBuf;
    DWORD  flen;
    BOOL   bOver=FALSE;
    UINT   i,len;
    UINT   iWord;                                                                       // @D04A

    if(!lcSaveEditText(iDisp_Top, 0))
        return FALSE;

    szFileName[0]=0;
    LoadString (hInst, IDS_IMPORTTITLE, szFileOpen, sizeof(szFileOpen)/sizeof(TCHAR));
    szCustFilter[0]=0;
    lstrcpy(&szCustFilter[1], szExt);
    lstrcpy(szFilePath, szExt);

    /* fill in non-variant fields of OPENFILENAME struct. */
    ofn.lStructSize       = sizeof(OPENFILENAME);
    ofn.hwndOwner         = NULL;
    ofn.lpstrFilter       = szFilterSpec;
    ofn.lpstrCustomFilter = szCustFilter;
    ofn.nMaxCustFilter    = sizeof(szCustFilter);
    ofn.nFilterIndex      = 1;
    ofn.lpstrFile         = szFilePath;
    ofn.nMaxFile          = MAX_PATH;
    ofn.lpstrInitialDir   = g_szLCUserPath;
    ofn.lpstrFileTitle    = szFileName;
    ofn.nMaxFileTitle     = MAX_PATH;
    ofn.lpstrTitle        = szFileOpen;
    ofn.lpstrDefExt       = szExt+2;
    ofn.Flags             = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY |
                            OFN_PATHMUSTEXIST;

    /* call common open dialog and return result */
    if(GetOpenFileName ((LPOPENFILENAME)&ofn))
    {
        SetCursor(hCursorWait);
       // Clear all flag first
            iWord=0;                                                         //@D04A 
        iDisp_Top=0;                                                     //@D03A
        lWordBuff=0;                                                     //@D03A
        lPhraseBuff=0;                                                   //@D03A
        lcSetEditText(0, FALSE);                                         //@D03A
        SetScrollRange(subhWnd, SB_VERT, 0, iPage_line, TRUE);              //@D03A
        yPos=0;                                                          //@D03A
        SetScrollPos(subhWnd, SB_VERT, yPos, TRUE);                         //@D03A
        bSaveFile=FALSE;                                                 //@D03A
        iFirstFree=NULL_SEG;                                             //@D03A

        WideCharToMultiByte(CP_ACP,0,szFilePath,-1,szUFilePath,MAX_PATH,NULL,0);
        hfImport=_lopen(szUFilePath,OF_READ);
        if(hfImport == -1){
            lcErrIOMsg(IDS_ERR_FILEOPEN, szUFilePath);
            return FALSE;
        }

       // get  file length
        flen=_llseek(hfImport,0L,2);

        _llseek(hfImport,0L,0);         //set to beginning

       // Allocate Memory
        hImport = GlobalAlloc(GMEM_FIXED, flen + 2);
        if(!hImport) {
            lcErrMsg(IDS_ERR_MEMORY);
                        _lclose(hfImport);
            return FALSE;
        }
        szUBuf = GlobalLock(hImport);

       // Read file to memory
        if(flen != _lread(hfImport,szUBuf,flen)) {
            lcErrIOMsg(IDS_ERR_FILEREAD, szUFilePath);
            return FALSE;
        }
                _lclose(hfImport);
                szUBuf[flen] = 0;

                if(szUBuf[1]!=0xFE && szUBuf[0]!=0xFF) //not a unicode file
                {
                        HANDLE hImport2 = GlobalAlloc(GMEM_FIXED, (flen+2)<<1);

            if(!hImport2) {
               lcErrMsg(IDS_ERR_MEMORY);
               return FALSE;
            }
            szBuf = GlobalLock(hImport2);
                        flen=MultiByteToWideChar(CP_ACP,MB_PRECOMPOSED,szUBuf,-1,szBuf+1,flen);
                        
                        GlobalUnlock(hImport);
            GlobalFree(hImport);

                        hImport=hImport2;
                        flen<<=1;
                        flen-=2;

                }
                else 
                        szBuf=(TCHAR*)szUBuf;


                len=0;

        for(i=1; i<= ((flen>>1)+1); i++) {                                      //@D01C
            if((szBuf[i] == 0x000d) || (szBuf[i] == 0x000a)) {
                if(len != 0) {
                    if(!lcInsline(szStr, iWord++, len, &bOver))
                        break;
                    len=0;
                }
                continue;
            }

            if((szBuf[i] == 0x001a) || (i == ((flen>>1)+1))) {                      //@D01C
                if(len != 0) {
                    if(!lcInsline(szStr, iWord++, len, &bOver))
                        break;
                }
                break;
            }

            if(len >= MAX_CHAR_NUM+3)
                bOver=TRUE;
            else
                szStr[len++]=szBuf[i];
        }

        if(bOver)
            lcErrMsg(IDS_ERR_OVERMAX);
        SetScrollRange(subhWnd, SB_VERT, 0, lWordBuff-iPage_line, FALSE);
        SetScrollPos(subhWnd, SB_VERT, yPos, TRUE);
        lcSetEditText(iDisp_Top, FALSE);

        GlobalUnlock(hImport);
        GlobalFree(hImport);
        bSaveFile=TRUE;
                SetFocus(hwndWord[0]);                                            // @D04A
    }
    return TRUE;
}

BOOL lcExport(
    HWND hwnd,int mode)
{
    OPENFILENAME    ofn;
    TCHAR  szFileOpen[25];
    TCHAR  szCustFilter[10];
    TCHAR  szFileName[MAX_PATH];
    TCHAR  szFilePath[MAX_PATH];
    UCHAR  szUStr[MAX_PATH];
    HFILE  hfExport;
    UCHAR  szStr[MAX_CHAR_NUM+10];
    UINT   i,len;
        TCHAR  *pTchar; 

    if(!lcSaveEditText(iDisp_Top, 0))
        return FALSE;

    szFileName[0]=0;
        if (mode == FILE_UNICODE)
                LoadString (hInst, IDS_EXPORTTITLE, szFileOpen, sizeof(szFileOpen)/sizeof(TCHAR));
        else
                LoadString (hInst, IDS_EXPORTBIG5TITLE, szFileOpen, sizeof(szFileOpen)/sizeof(TCHAR) );

    szCustFilter[0]=0;
    lstrcpy(&szCustFilter[1], szExt);
    szCustFilter[lstrlen(szExt) + 1] = 0;
    lstrcpy(szFilePath, szExt);

    /* fill in non-variant fields of OPENFILENAME struct. */
    ofn.lStructSize       = sizeof(OPENFILENAME);
    ofn.hwndOwner         = hwnd;
    ofn.lpstrFilter       = szFilterSpec;
    ofn.lpstrCustomFilter = szCustFilter;
    ofn.nMaxCustFilter    = sizeof(szCustFilter);
    ofn.nFilterIndex      = 1;
    ofn.lpstrFile         = szFilePath;
    ofn.nMaxFile          = MAX_PATH;
    ofn.lpstrInitialDir   = g_szLCUserPath;
    ofn.lpstrFileTitle    = szFileName;
    ofn.nMaxFileTitle     = MAX_PATH;
    ofn.lpstrTitle        = szFileOpen;
    ofn.lpstrDefExt       = szExt+2;
    ofn.Flags             = OFN_CREATEPROMPT | OFN_HIDEREADONLY |
                            OFN_PATHMUSTEXIST;

    /* call common open dialog and return result */
    if(GetSaveFileName ((LPOPENFILENAME)&ofn))
    {
        HANDLE hExport;

        SetCursor(hCursorWait);
        hExport = CreateFile(szFilePath, 
                                 GENERIC_READ | GENERIC_WRITE,
                                 FILE_SHARE_READ, 
                                 NULL, 
                                 CREATE_ALWAYS, 
                                 FILE_ATTRIBUTE_NORMAL,
                                 NULL ) ;
        if(hExport == INVALID_HANDLE_VALUE){
            WideCharToMultiByte(CP_ACP,0,szFilePath,-1,szUStr,MAX_PATH,NULL,0);
            lcErrIOMsg(IDS_ERR_FILEOPEN, szUStr);
            return FALSE;
        }
        hfExport = PtrToInt( hExport );

                if(mode==FILE_UNICODE){
                        szStr[0]=0xFF;
                        szStr[1]=0xFE;
                        _lwrite(hfExport,szStr,2);

                        szStr[2]=' ';
                        szStr[3]=0;
                        pTchar=(TCHAR*)(szStr+4);
                        for(i=0; i<lWordBuff; i++) {
                                *((LPUNAWORD)szStr)=lpWord[i].wWord;

                                len=lcMem2Disp(i, pTchar)+1;
                                szStr[len<<1] = 0x0d;
                                szStr[(len<<1)+1] = 0x00;
                                szStr[(len<<1)+2] = 0x0a;
                                szStr[(len<<1)+3] = 0x00;
                                                        
                                if((len<<1)+4 != _lwrite(hfExport,szStr,(len<<1)+4)) {
                                        WideCharToMultiByte(CP_ACP,0,szFilePath,-1,szUStr,MAX_PATH,NULL,0);
                                        lcErrIOMsg(IDS_ERR_FILEOPEN, szUStr);
                                        _lclose(hfExport);
                                        return FALSE;
                                }
                        }
                }else{ //write in BIG5 code
                        TCHAR  szTStr[MAX_CHAR_NUM+10];
                        
                        szStr[2]=0x20;

                        for(i=0; i<lWordBuff; i++) {
                            szTStr[1]=0;
                                szTStr[0]=lpWord[i].wWord;
                                WideCharToMultiByte(CP_ACP,0,szTStr,1,szStr,MAX_CHAR_NUM,NULL,0);
                                
                                lcMem2Disp(i,szTStr);
                                len=WideCharToMultiByte(CP_ACP,0,szTStr,-1,szStr+3,MAX_CHAR_NUM,NULL,0);
                                szStr[len+1] = 0x0d;
                                szStr[len+2] = 0x0a;
                                                        
                                if( len+3 != _lwrite(hfExport,szStr,len+3)) {
                                        WideCharToMultiByte(CP_ACP,0,szFilePath,-1,szUStr,MAX_PATH,NULL,0);
                                        lcErrIOMsg(IDS_ERR_FILEOPEN, szUStr);
                                        _lclose(hfExport);
                                        return FALSE;
                                }
                        }
                }

       // Append EOF
        szStr[0]=0x1a;
                szStr[1]=0;
        _lwrite(hfExport,szStr,2);
        _lclose(hfExport);
    }

    return TRUE;
}

void lcQueryModify(
    HWND hwnd)
{
    UINT  i;

    if(!bSaveFile) {
        for(i=0; i<iPage_line; i++) {
            if(SendMessage(hwndWord[i], EM_GETMODIFY, 0, 0)) {
                bSaveFile=TRUE;
                break;
            }
            if(SendMessage(hwndPhrase[i], EM_GETMODIFY, 0, 0)) {
                bSaveFile=TRUE;
                break;
            }
        }
    }

}

BOOL lcQuerySave(
    HWND hwnd)
{
    TCHAR szMsg1[MAX_PATH];
    TCHAR szMsg2[MAX_PATH];

    lcQueryModify(hwnd);
    if(bSaveFile) {
        LoadString(hInst, IDS_APPNAME, szMsg1, sizeof(szMsg1)/sizeof(TCHAR));
        LoadString(hInst, IDS_FILEMODIFIED, szMsg2, sizeof(szMsg2)/sizeof(TCHAR));
        if(MessageBox(hwnd, szMsg2, szMsg1,
           MB_ICONQUESTION | MB_YESNO) == IDYES) {
            if(!lcFSave(hwnd,TRUE))
                return FALSE;
        }
    }

    return TRUE;
}

void lcErrIOMsg(
    UINT  iMsgID,
    UCHAR *szFileName)
{
TCHAR szErrStr[MAX_PATH];
TCHAR szShowMsg[MAX_PATH];

    LoadString(hInst, iMsgID, szErrStr, sizeof(szErrStr) / sizeof(TCHAR) );
    wsprintf(szShowMsg, szErrStr, szFileName);
    MessageBox(hwndMain, szShowMsg, NULL, MB_OK | MB_ICONEXCLAMATION);
}

#else // UNICODE
BOOL lcAddPhrase( UCHAR *, UCHAR *, UINT *, WORD, WORD, DWORD);

BOOL lcFOpen(
    HWND hWnd)
{
    HANDLE hLCPtr,hLCPhrase;
    HFILE  hfLCPtr,hfLCPhrase;
    DWORD  flen_Ptr,flen_Phrase;
    UCHAR  szLCPtrName[MAX_PATH];
    UCHAR  szLCPhraseName[MAX_PATH];
    UCHAR  *szLCPtrBuf,*szLCPhraseBuf;
    BOOL   rc;
    UINT   i;
    WORD   wStart,wEnd;
    UCHAR  szDispBuf[MAX_CHAR_NUM];
    UINT   nDisp,len;

   // Get system directory
    len = GetSystemDirectory((LPSTR)szLCPtrName, sizeof(szLCPtrName));
    if (szLCPtrName[len - 1] != '\\') {     // consider C:\ ;
        szLCPtrName[len++] = '\\';
        szLCPtrName[len] = 0;
    }
    lstrcpy(szLCPhraseName, szLCPtrName);
    lstrcat(szLCPtrName, LCPTRFILE);
    lstrcat(szLCPhraseName, LCPHRASEFILE);

   // Open LC pointer file
    hfLCPtr=_lopen(szLCPtrName,OF_READ);
    if(hfLCPtr == -1){
        lcErrIOMsg(IDS_ERR_FILEOPEN, LCPTRFILE);
        return FALSE;
    }
    hfLCPhrase=_lopen(szLCPhraseName,OF_READ);

   // Open LC phrase file
    if(hfLCPhrase == -1){
        _lclose(hfLCPtr);
        lcErrIOMsg(IDS_ERR_FILEOPEN, LCPTRFILE);
        return FALSE;
    }

   // get  file length
    flen_Ptr=_llseek(hfLCPtr,0L,2);     /* get file length */

   // Allocate Memory
    hLCPtr = GlobalAlloc(GMEM_FIXED, flen_Ptr);
    if(!hLCPtr) {
        lcErrMsg(IDS_ERR_MEMORY);
        goto error;
    }
    szLCPtrBuf = GlobalLock(hLCPtr);

    _llseek(hfLCPtr,0L,0);              //set to beginning 4

    if(flen_Ptr != _lread(hfLCPtr,szLCPtrBuf,flen_Ptr)) {
        lcErrIOMsg(IDS_ERR_FILEREAD, LCPTRFILE);
        goto error;
    }
    _lclose(hfLCPtr);

    //get  file length
    flen_Phrase=_llseek(hfLCPhrase,0L,2);      /* get file length */

   // Allocate Memory
    hLCPhrase = GlobalAlloc(GMEM_MOVEABLE, flen_Phrase);
    if(!hLCPhrase) {
        lcErrMsg(IDS_ERR_MEMORY);
        goto error;
    }
    szLCPhraseBuf = GlobalLock(hLCPhrase);

    _llseek(hfLCPhrase,0L,0); //set to beginning

    if(flen_Phrase != _lread(hfLCPhrase,szLCPhraseBuf,flen_Phrase)) {
        lcErrIOMsg(IDS_ERR_FILEREAD, LCPHRASEFILE);
        goto error;
    }
    _lclose(hfLCPhrase);


    rc=TRUE;

   // Convert file to structured memory (WORDBUF & PHRASEBUF)
   // First record is Null record skip it
    for(i=1; i<(flen_Ptr/PTRRECLEN-1); i++) {

       // If Allocated Word buffer not enough Reallocate it
        if(iWordBuff+1 == nWordBuffsize)
            if(!(rc=lcAllocWord())) {
                break;
            }
        lpWord[iWordBuff].wWord=*((WORD *)&szLCPtrBuf[i*PTRRECLEN]);

       // If Allocated Phrase buffer not enough Reallocate it
        if(iPhraseBuff+1 == nPhraseBuffsize)
            if(!(rc=lcAllocPhrase())) {
                break;
             }

        lpWord[iWordBuff].iFirst_Seg=iPhraseBuff;
        lpPhrase[iPhraseBuff].iNext_Seg=NULL_SEG;
        iWordBuff++;
        iPhraseBuff++;
        nDisp=0;

       // Add Phrase to Display buffer
        wStart=*((WORD *)&szLCPtrBuf[i*PTRRECLEN+2]);
        wEnd=*((WORD *)&szLCPtrBuf[i*PTRRECLEN+PTRRECLEN+2]);
        if(wStart != wEnd) {
            rc=lcAddPhrase(szLCPhraseBuf, szDispBuf, &nDisp,
                            wStart, wEnd, flen_Phrase);
            if(!rc)
                break;
        }

       // Put display buffer into Phrase buffer
        if(nDisp == 0)
            szDispBuf[0]=0;
        else
            szDispBuf[nDisp-1]=0;

        if(!(rc=lcDisp2Mem(iWordBuff-1, szDispBuf)))
            break;
    }

    GlobalUnlock(hLCPtr);
    GlobalUnlock(hLCPhrase);
    GlobalFree(hLCPtr);
    GlobalFree(hLCPhrase);
    return rc;

error:

    _lclose(hfLCPtr);
    _lclose(hfLCPhrase);
    GlobalUnlock(hLCPtr);
    GlobalUnlock(hLCPhrase);
    GlobalFree(hLCPtr);
    GlobalFree(hLCPhrase);
    return FALSE;
}


BOOL lcAddPhrase(
    UCHAR *szLCWord,                    // LC Phrase buffer
    UCHAR *szDispBuf,                   // Display buffer
    UINT  *nDisp,                       // Display buffer length
    WORD  wStart,                       // Start address of LC Phrase
    WORD  wEnd,                         // End address of LC Phrase
    DWORD lLen)                         // Total Length of LC Phrase
{
    UINT  i;
    WORD  wWord;

   // Check length
    if(lLen < ((DWORD)wEnd)*2) {
        lcErrMsg(IDS_ERR_LCPTRFILE);
        return FALSE;
    }

    for(i=wStart; i < wEnd; i++) {
        wWord=*((WORD *)&szLCWord[i*2]);
        wWord |= END_PHRASE;
        if(!is_DBCS(wWord, TRUE))
            return FALSE;
        szDispBuf[(*nDisp)++]=HIBYTE(wWord);
        szDispBuf[(*nDisp)++]=LOBYTE(wWord);

       // If End of Phrase append space
        if( !( (*((WORD *)&szLCWord[i*2])) & END_PHRASE) )
            szDispBuf[(*nDisp)++]=' ';

       // Check Disply buffer length
        if( ((*nDisp)+3) >= MAX_CHAR_NUM) {
            lcErrMsg(IDS_ERR_OVERMAX);
            return FALSE;
        }
    }

    return TRUE;
}


BOOL lcFSave(
    HWND hwnd)
{
    HFILE  hfLCPtr,hfLCPhrase;
    UCHAR  szLCPtrName[MAX_PATH];
    UCHAR  szLCPhraseName[MAX_PATH];
    UCHAR  szLCPtrBuf[PTRRECLEN],szLCPhraseBuf[MAX_CHAR_NUM];
    UINT   i,j;
    WORD   wStartPhrase;
    WORD   wPhraseLen;
    UCHAR  szStr[MAX_CHAR_NUM];
    UINT   len,tmplen;

    if(!lcSort(hwnd))
        return FALSE;
    if(wSameCode)
        return FALSE;

   // Get system directory
    len = GetSystemDirectory((LPSTR)szLCPtrName, sizeof(szLCPtrName));
    if (szLCPtrName[len - 1] != '\\') {     // consider C:\ ;
        szLCPtrName[len++] = '\\';
        szLCPtrName[len] = 0;
    }
    lstrcpy(szLCPhraseName, szLCPtrName);
    lstrcat(szLCPtrName, LCPTRFILE);
    lstrcat(szLCPhraseName, LCPHRASEFILE);

   // Open LC phrase file
    hfLCPhrase=(int)CreateFile(szLCPhraseName, GENERIC_READ | GENERIC_WRITE,
                  FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                  (HANDLE)NULL ) ;
    if(hfLCPhrase == -1) {
        lcErrMsg(IDS_ERR_FILESAVE);
        goto error;
    }
   // Open LC pointer file
    hfLCPtr=(int)CreateFile(szLCPtrName, GENERIC_READ | GENERIC_WRITE,
                  FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                  (HANDLE)NULL ) ;
    if(hfLCPtr == -1) {
        lcErrMsg(IDS_ERR_FILESAVE);
        goto error;
    }

   // Write a Null record into first record
    *((WORD *)(&szLCPtrBuf))=0;
    *((WORD *)(&szLCPtrBuf[2]))=0;
    if(PTRRECLEN != _lwrite(hfLCPtr,szLCPtrBuf,PTRRECLEN)) {
        lcErrIOMsg(IDS_ERR_FILEWRITE, LCPTRFILE);
        goto error;
    }
    wStartPhrase=0;
    for(i=0; i<iWordBuff; i++) {
        wPhraseLen=0;

       // Truncate same Word
        if(lpWord[i].wWord == *((WORD *)(&szLCPtrBuf)))
            continue;

        len=lcMem2Disp(i, szStr);
        tmplen=0;

        for(j=0; j<len; j++) {
            if(szStr[j] == ' ') {
                if(tmplen != 0) {
                    *((WORD *)(&szLCPhraseBuf[wPhraseLen*2+tmplen-2]))&=
                        (NOT_END_PHRASE);
                    wPhraseLen+=(tmplen/2);
                    tmplen=0;
                }
                continue;
            }
            szLCPhraseBuf[wPhraseLen*2+tmplen]=szStr[j+1];
            szLCPhraseBuf[wPhraseLen*2+tmplen+1]=szStr[j];
            tmplen+=2;
            j++;
        }

       // In case not end of space
        if(tmplen != 0) {
            *((WORD *)(&szLCPhraseBuf[wPhraseLen*2+tmplen-2]))&=
                (NOT_END_PHRASE);
            wPhraseLen+=(tmplen/2);
            tmplen=0;
        }

       // Check register phrase over max length
        if(wStartPhrase > (0xfffd-wPhraseLen)) {
            lcErrMsg(IDS_ERR_OVER_MAXLEN);
            goto error;
        }

        *((WORD *)(&szLCPtrBuf))=lpWord[i].wWord;
        *((WORD *)(&szLCPtrBuf[2]))=wStartPhrase;
        if(PTRRECLEN != _lwrite(hfLCPtr,szLCPtrBuf,PTRRECLEN)) {
            lcErrIOMsg(IDS_ERR_FILEWRITE, LCPTRFILE);
            goto error;
        }
        if(wPhraseLen)
            if(((UINT)wPhraseLen*2) !=
              _lwrite(hfLCPhrase,szLCPhraseBuf,wPhraseLen*2)) {
                lcErrIOMsg(IDS_ERR_FILEWRITE, LCPHRASEFILE);
                goto error;
            }
        wStartPhrase+=wPhraseLen;
    }

   // Write the lasr record
    *((WORD *)(&szLCPtrBuf))=0xffff;
    *((WORD *)(&szLCPtrBuf[2]))=wStartPhrase;
    if(PTRRECLEN != _lwrite(hfLCPtr,szLCPtrBuf,PTRRECLEN)) {
        lcErrIOMsg(IDS_ERR_FILEWRITE, LCPTRFILE);
        goto error;
    }

    SetEndOfFile((HANDLE)hfLCPtr);
    SetEndOfFile((HANDLE)hfLCPhrase);
    _lclose(hfLCPtr);
    _lclose(hfLCPhrase);
    bSaveFile=FALSE;
    return TRUE;

error:
    _lclose(hfLCPtr);
    _lclose(hfLCPhrase);
    return FALSE;

}

BOOL lcInsline(
    UCHAR  *szStr,
    UINT   iWord,
    UINT   len,
    BOOL   *bOver)
{
    WORD  wWord;
    UINT  iFree,nDisp;
    UINT  i,j,buflen;
    UCHAR szDispBuf[MAX_CHAR_NUM];
    UCHAR szBuffer[MAX_CHAR_NUM*2];
    int   l;


    szStr[len]=0;                       // Append Null to end of line

   // Skip lead spaces if exist
    for(i=0; (i<len) && (szStr[i] == ' '); i++);

    if( ((i+2) >= len) || (szStr[i+2] != ' ') ) {
        lcErrMsg(IDS_ERR_IMP_SEPRATOR);
        return FALSE;
    }
    if(!is_DBCS2(*((WORD *)(&szStr[i])), TRUE)) {
        return FALSE;
    }
    wWord=(szStr[i] << 8)+szStr[i+1];

   // Skip spaces after Word
    for(j=i+2; (j<len) && (szStr[j] == ' '); j++);
    if(j == len) {
        lcErrMsg(IDS_ERR_IMP_NOPHRASE);
        return FALSE;
    }
    lstrcpy(szDispBuf, &szStr[j]);
    nDisp=lstrlen(szDispBuf)+1;

   // Check DBCS
    for(i=0; i<(nDisp-1); i++) {
        if(szDispBuf[i] == ' ')
            continue;
        if(!is_DBCS2(*((WORD *)(&szDispBuf[i])), TRUE)) {
            return FALSE;
        }
        i++;
    }

   // Check same Word
    for(i=0; i<iWordBuff; i++) {
        if(lpWord[i].wWord==wWord) {
            buflen=lcMem2Disp(i, szBuffer);
            if((buflen + lstrlen(szDispBuf)) >= MAX_CHAR_NUM)
                *bOver=TRUE;
            lstrcat(szBuffer, szDispBuf);
            return(lcDisp2Mem(i, szBuffer));
        }
    }

   // Check Word buffer enough ?
    if(iWordBuff+1 == nWordBuffsize)
        if(!lcAllocWord())
            return FALSE;

   // Allocate a Phrase Buffer
    iFree=lcGetSeg();
    if(iFree == NULL_SEG)
        return FALSE;
    if(iWordBuff == 0) {
        lpWord[iWord].wWord=wWord;
        lpWord[iWord].iFirst_Seg=iFree;
    } else {
        for(l=iWordBuff; l >= (int)iWord; l--) {
            lpWord[l+1].wWord=lpWord[l].wWord;
            lpWord[l+1].iFirst_Seg=lpWord[l].iFirst_Seg;
        }
        lpWord[iWord].wWord=wWord;
        lpWord[iWord].iFirst_Seg=iFree;
    }
    iWordBuff++;

    if(!lcDisp2Mem(iWord, szDispBuf))
        return FALSE;

    return TRUE;
}

BOOL lcAppend(
    HWND hwnd)
{
    OPENFILENAME    ofn;
    UCHAR  szFileOpen[25];
    UCHAR  szCustFilter[10];
    UCHAR  szFileName[MAX_PATH];
    UCHAR  szFilePath[MAX_PATH];
    HFILE  hfImport;
    HANDLE hImport;
    UCHAR  szStr[MAX_CHAR_NUM+10];
    UCHAR  *szBuf;
    DWORD  flen;
    BOOL   bOver=FALSE;
    UINT   i,len;
    UINT   iEdit,iWord;
    BOOL   is_WORD;

    iEdit=lcGetEditFocus(GetFocus(), &is_WORD);
    iWord=iDisp_Top+iEdit;
    if(iWord > iWordBuff)
        iWord=iWordBuff;

    if(!lcSaveEditText(iDisp_Top, 0))
        return FALSE;

    szFileName[0]=0;
    LoadString (hInst, IDS_APPENDTITLE, szFileOpen, sizeof(szFileOpen));
    szCustFilter[0]=0;
    lstrcpy(&szCustFilter[1], szExt);
    lstrcpy(szFilePath, szExt);

    /* fill in non-variant fields of OPENFILENAME struct. */
    ofn.lStructSize       = sizeof(OPENFILENAME);
    ofn.hwndOwner         = NULL;
    ofn.lpstrFilter       = szFilterSpec;
    ofn.lpstrCustomFilter = szCustFilter;
    ofn.nMaxCustFilter    = sizeof(szCustFilter);
    ofn.nFilterIndex      = 1;
    ofn.lpstrFile         = szFilePath;
    ofn.nMaxFile          = MAX_PATH;
    ofn.lpstrInitialDir   = NULL;
    ofn.lpstrFileTitle    = szFileName;
    ofn.nMaxFileTitle     = MAX_PATH;
    ofn.lpstrTitle        = szFileOpen;
    ofn.lpstrDefExt       = szExt+3;
    ofn.Flags             = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY |
                            OFN_PATHMUSTEXIST;

    /* call common open dialog and return result */
    if(GetOpenFileName ((LPOPENFILENAME)&ofn))
    {
        SetCursor(hCursorWait);
        hfImport=_lopen(szFilePath,OF_READ);
        if(hfImport == -1){
            lcErrIOMsg(IDS_ERR_FILEOPEN, szFilePath);
            return FALSE;
        }

       // get  file length
        flen=_llseek(hfImport,0L,2);

        _llseek(hfImport,0L,0);         //set to beginning

       // Allocate Memory
        hImport = GlobalAlloc(GMEM_FIXED, flen);
        if(!hImport) {
            lcErrMsg(IDS_ERR_MEMORY);
            return FALSE;
        }
        szBuf = GlobalLock(hImport);

       // Read file to memory
        if(flen != _lread(hfImport,szBuf,flen)) {
            lcErrIOMsg(IDS_ERR_FILEREAD, szFilePath);
            return FALSE;
        }
        _lclose(hfImport);

        len=0;
//@D01D for(i=0; i<flen; i++) {
        for(i=0; i<(flen+1); i++) {                                      //@D01C
            if((szBuf[i] == 0x0d) || (szBuf[i] == 0x0a)) {
                if(len != 0) {
                    if(!lcInsline(szStr, iWord++, len, &bOver))
                        break;
                    len=0;
                }
                continue;
            }
//@D01D     if(szBuf[i] == 0x1a) {
            if((szBuf[i] == 0x1a) || (i == flen)) {                      //@D01C
                if(len != 0) {
                    if(!lcInsline(szStr, iWord++, len, &bOver))
                        break;
                }
                break;
            }
            if(len >= MAX_CHAR_NUM+3)
                bOver=TRUE;
            else
                szStr[len++]=szBuf[i];
        }
        if(bOver)
            lcErrMsg(IDS_ERR_OVERMAX);
        SetScrollRange(subhWnd, SB_VERT, 0, iWordBuff-iPage_line, FALSE);
        SetScrollPos(subhWnd, SB_VERT, yPos, TRUE);
        lcSetEditText(iDisp_Top, FALSE);

        GlobalUnlock(hImport);
        GlobalFree(hImport);
        bSaveFile=TRUE;
    }
    return TRUE;
}

BOOL lcImport(
    HWND hwnd)
{
    OPENFILENAME    ofn;
    UCHAR  szFileOpen[25];
    UCHAR  szCustFilter[10];
    UCHAR  szFileName[MAX_PATH];
    UCHAR  szFilePath[MAX_PATH];
    HFILE  hfImport;
    HANDLE hImport;
    UCHAR  szStr[MAX_CHAR_NUM+10];
    UCHAR  *szBuf;
    DWORD  flen;
    BOOL   bOver=FALSE;
    UINT   i,len;
    UINT   iWord;                                                                       // @D04A
    //UINT   iEdit,iWord;                                                       @D04D
    //BOOL   is_WORD;                                                           @D04D

    //iEdit=lcGetEditFocus(GetFocus(), &is_WORD);   @D04D
    //iWord=iDisp_Top+iEdit;                                            @D04D
    //if(iWord > iWordBuff)                                                     @D04D
    //    iWord=iWordBuff;                                                      @D04D

    if(!lcSaveEditText(iDisp_Top, 0))
        return FALSE;

    szFileName[0]=0;
    LoadString (hInst, IDS_IMPORTTITLE, szFileOpen, sizeof(szFileOpen));
    szCustFilter[0]=0;
    lstrcpy(&szCustFilter[1], szExt);
    lstrcpy(szFilePath, szExt);

    /* fill in non-variant fields of OPENFILENAME struct. */
    ofn.lStructSize       = sizeof(OPENFILENAME);
    ofn.hwndOwner         = NULL;
    ofn.lpstrFilter       = szFilterSpec;
    ofn.lpstrCustomFilter = szCustFilter;
    ofn.nMaxCustFilter    = sizeof(szCustFilter);
    ofn.nFilterIndex      = 1;
    ofn.lpstrFile         = szFilePath;
    ofn.nMaxFile          = MAX_PATH;
    ofn.lpstrInitialDir   = NULL;
    ofn.lpstrFileTitle    = szFileName;
    ofn.nMaxFileTitle     = MAX_PATH;
    ofn.lpstrTitle        = szFileOpen;
    ofn.lpstrDefExt       = szExt+3;
    ofn.Flags             = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY |
                            OFN_PATHMUSTEXIST;

    /* call common open dialog and return result */
    if(GetOpenFileName ((LPOPENFILENAME)&ofn))
    {
        SetCursor(hCursorWait);
       // Clear all flag first
            iWord=0;                                                         //@D04A 
        iDisp_Top=0;                                                     //@D03A
        iWordBuff=0;                                                     //@D03A
        iPhraseBuff=0;                                                   //@D03A
        lcSetEditText(0, FALSE);                                         //@D03A
        SetScrollRange(subhWnd, SB_VERT, 0, iPage_line, TRUE);              //@D03A
        yPos=0;                                                          //@D03A
        SetScrollPos(subhWnd, SB_VERT, yPos, TRUE);                         //@D03A
        bSaveFile=FALSE;                                                 //@D03A
        iFirstFree=NULL_SEG;                                             //@D03A

        hfImport=_lopen(szFilePath,OF_READ);
        if(hfImport == -1){
            lcErrIOMsg(IDS_ERR_FILEOPEN, szFilePath);
            return FALSE;
        }

       // get  file length
        flen=_llseek(hfImport,0L,2);

        _llseek(hfImport,0L,0);         //set to beginning

       // Allocate Memory
        hImport = GlobalAlloc(GMEM_FIXED, flen);
        if(!hImport) {
            lcErrMsg(IDS_ERR_MEMORY);
            return FALSE;
        }
        szBuf = GlobalLock(hImport);

       // Read file to memory
        if(flen != _lread(hfImport,szBuf,flen)) {
            lcErrIOMsg(IDS_ERR_FILEREAD, szFilePath);
            return FALSE;
        }
        _lclose(hfImport);

        len=0;
//@D01D for(i=0; i<flen; i++) {
        for(i=0; i<(flen+1); i++) {                                      //@D01C
            if((szBuf[i] == 0x0d) || (szBuf[i] == 0x0a)) {
                if(len != 0) {
                    if(!lcInsline(szStr, iWord++, len, &bOver))
                        break;
                    len=0;
                }
                continue;
            }
//@D01D     if(szBuf[i] == 0x1a) {
            if((szBuf[i] == 0x1a) || (i == flen)) {                      //@D01C
                if(len != 0) {
                    if(!lcInsline(szStr, iWord++, len, &bOver))
                        break;
                }
                break;
            }
            if(len >= MAX_CHAR_NUM+3)
                bOver=TRUE;
            else
                szStr[len++]=szBuf[i];
        }
        if(bOver)
            lcErrMsg(IDS_ERR_OVERMAX);
        SetScrollRange(subhWnd, SB_VERT, 0, iWordBuff-iPage_line, FALSE);
        SetScrollPos(subhWnd, SB_VERT, yPos, TRUE);
        lcSetEditText(iDisp_Top, FALSE);

        GlobalUnlock(hImport);
        GlobalFree(hImport);
        bSaveFile=TRUE;
                SetFocus(hwndWord[0]);                                            // @D04A
    }
    return TRUE;
}

BOOL lcExport(
    HWND hwnd)
{
    OPENFILENAME    ofn;
    UCHAR  szFileOpen[25];
    UCHAR  szCustFilter[10];
    UCHAR  szFileName[MAX_PATH];
    UCHAR  szFilePath[MAX_PATH];
    HFILE  hfExport;
    UCHAR  szStr[MAX_CHAR_NUM+10];
    UINT   i,len;

    if(!lcSaveEditText(iDisp_Top, 0))
        return FALSE;

    szFileName[0]=0;
    LoadString (hInst, IDS_EXPORTTITLE, szFileOpen, sizeof(szFileOpen));
    szCustFilter[0]=0;
    lstrcpy(&szCustFilter[1], szExt);
    lstrcpy(szFilePath, szExt);

    /* fill in non-variant fields of OPENFILENAME struct. */
    ofn.lStructSize       = sizeof(OPENFILENAME);
    ofn.hwndOwner         = hwnd;
    ofn.lpstrFilter       = szFilterSpec;
    ofn.lpstrCustomFilter = szCustFilter;
    ofn.nMaxCustFilter    = sizeof(szCustFilter);
    ofn.nFilterIndex      = 1;
    ofn.lpstrFile         = szFilePath;
    ofn.nMaxFile          = MAX_PATH;
    ofn.lpstrInitialDir   = NULL;
    ofn.lpstrFileTitle    = szFileName;
    ofn.nMaxFileTitle     = MAX_PATH;
    ofn.lpstrTitle        = szFileOpen;
    ofn.lpstrDefExt       = szExt+3;
    ofn.Flags             = OFN_CREATEPROMPT | OFN_HIDEREADONLY |
                            OFN_PATHMUSTEXIST;

    /* call common open dialog and return result */
    if(GetSaveFileName ((LPOPENFILENAME)&ofn))
    {
        SetCursor(hCursorWait);
        hfExport=(int)CreateFile(szFilePath, GENERIC_READ | GENERIC_WRITE,
                      FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL,
                      (HANDLE)NULL ) ;
        if(hfExport == -1){
            lcErrIOMsg(IDS_ERR_FILEOPEN, szFilePath);
            return FALSE;
        }
        szStr[2]=' ';
        szStr[3]=' ';
        for(i=0; i<iWordBuff; i++) {
            szStr[0]=HIBYTE(lpWord[i].wWord);
            szStr[1]=LOBYTE(lpWord[i].wWord);

            len=lcMem2Disp(i, &szStr[4])+4;
            szStr[len] = 0x0d;
            szStr[len+1] = 0x0a;
            if((len+2) != _lwrite(hfExport,szStr,len+2)) {
                lcErrIOMsg(IDS_ERR_FILEWRITE, szFilePath);
                _lclose(hfExport);
                return FALSE;
            }
        }

       // Append EOF
        szStr[0]=0x1a;
        _lwrite(hfExport,szStr,1);
        _lclose(hfExport);
    }

    return TRUE;
}

void lcQueryModify(
    HWND hwnd)
{
    UINT  i;

    if(!bSaveFile) {
        for(i=0; i<iPage_line; i++) {
            if(SendMessage(hwndWord[i], EM_GETMODIFY, 0, 0)) {
                bSaveFile=TRUE;
                break;
            }
            if(SendMessage(hwndPhrase[i], EM_GETMODIFY, 0, 0)) {
                bSaveFile=TRUE;
                break;
            }
        }
    }

}

BOOL lcQuerySave(
    HWND hwnd)
{
    UCHAR szMsg1[MAX_PATH];
    UCHAR szMsg2[MAX_PATH];

    lcQueryModify(hwnd);
    if(bSaveFile) {
        LoadString(hInst, IDS_APPNAME, szMsg1, sizeof(szMsg1));
        LoadString(hInst, IDS_FILEMODIFIED, szMsg2, sizeof(szMsg2));
        if(MessageBox(hwnd, szMsg2, szMsg1,
           MB_ICONQUESTION | MB_YESNO) == IDYES) {
            if(!lcFSave(hwnd))
                return FALSE;
        }
    }

    return TRUE;
}

void lcErrIOMsg(
    UINT  iMsgID,
    UCHAR *szFileName)
{
UCHAR szErrStr[MAX_PATH];
UCHAR szShowMsg[MAX_PATH];

    LoadString(hInst, iMsgID, szErrStr, sizeof(szErrStr));
    wsprintf(szShowMsg, szErrStr, szFileName);
    MessageBox(hwndMain, szShowMsg, NULL, MB_OK | MB_ICONEXCLAMATION);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\lctool\lcprint.c ===
/*************************************************
 *  lcprint.c                                    *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

#include <windows.h>            // required for all Windows applications
#include <windowsx.h>
#include <stdlib.h>
#include "rc.h"
#include "lctool.h"

#ifndef UNICODE
#define lWordBuff iWordBuff
#endif

#define UM_CANCELPRINT     WM_USER+2
#define TOP_SPACE          250
#define WORD_POS           7
#define PHRASE_POS         10

PRINTDLG pdPrint;
HWND     hCancelDlg = 0;
int      nFromLine = 1;
int      nToLine = 1;

int TransNum(TCHAR *);

/* get default printer configuration and save in hWnd extra bytes for use later */
BOOL WINAPI GetPrinterConfig (
    HWND    hWnd)
{

    pdPrint.lStructSize = sizeof (PRINTDLG);
        pdPrint.Flags           = PD_RETURNDEFAULT;
        pdPrint.hwndOwner       = hWnd;
        pdPrint.hDevMode        = NULL;
        pdPrint.hDevNames       = NULL;
        pdPrint.hDC             = NULL;

        PrintDlg (&pdPrint);

        return TRUE;
}



/* abort proc called by gdi during print download process */
int WINAPI AbortProc (
    HDC     hdc,
    int     nErr)
{
    BOOL    fContinue = TRUE;
    MSG     msg;

    /* process messages for cancel dialog and other apps */
    while (PeekMessage (&msg, NULL, 0, 0, PM_REMOVE))
        {
        if (msg.message == UM_CANCELPRINT)
            {
            fContinue = FALSE;
            break;
            }

        else if (!hCancelDlg || !IsDialogMessage (hCancelDlg, &msg))
            {
            TranslateMessage (&msg);
            DispatchMessage  (&msg);
            }
        }

    return fContinue;
}




INT_PTR WINAPI LineDlgProc (
    HWND   hDlg,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam)
{
    TCHAR  szLine[MAX_PATH];

    switch (message)
        {
        case WM_INITDIALOG:

            /* initialize dialog control information */
            SetDlgItemText (hDlg,
                            IDD_FROM_LINE,
                            _TEXT("1"));
#ifdef UNICODE
            wsprintf(szLine,_TEXT("%5d"), lWordBuff);
#else
            wsprintf(szLine,_TEXT("%5d"), iWordBuff);
#endif
            SetDlgItemText (hDlg,
                            IDD_TO_LINE,
                            szLine);
            break;

        case WM_COMMAND:
            switch (wParam) {

                case IDOK:

                    GetDlgItemText(hDlg,IDD_FROM_LINE,
                        szLine, sizeof(szLine)/sizeof(TCHAR));
                    nFromLine=TransNum(szLine);
#ifdef UNICODE
                    if((nFromLine < 1) || (nFromLine > (int)lWordBuff)) {
#else
                    if((nFromLine < 1) || (nFromLine > (int)iWordBuff)) {
#endif
                        MessageBeep(0);
                        SetFocus(GetDlgItem(hDlg, IDD_FROM_LINE));
                        return TRUE;
                    }
                    GetDlgItemText(hDlg,IDD_TO_LINE,
                        szLine, sizeof(szLine));
                    nToLine=TransNum(szLine);
                    if((nToLine < nFromLine) || (nToLine > (int)lWordBuff)) {
                        MessageBeep(0);
                        SetFocus(GetDlgItem(hDlg, IDD_TO_LINE));
                        return TRUE;
                    }
                    EndDialog (hDlg, TRUE) ;
                    return TRUE;


                case IDCANCEL:
                    EndDialog (hDlg, FALSE) ;
                    return TRUE;
            }
            break ;

        case WM_CLOSE:
            EndDialog(hDlg, FALSE);
            return TRUE;

        default:
            return FALSE;
    }
    return TRUE;
}



BOOL WINAPI CancelDlgProc (
    HWND    hWnd,
    UINT    uMsg,
    UINT    uParam,
    LONG    lParam)
{

    switch (uMsg)
        {
        case WM_INITDIALOG:
            {
            TCHAR szStr[MAX_PATH];
            TCHAR szShowMsg[MAX_PATH];


            /* initialize dialog control information */
            LoadString(hInst, IDS_PRINTING, szStr, sizeof(szStr)/sizeof(TCHAR));
            wsprintf(szShowMsg, szStr, nFromLine, nToLine);
            SetDlgItemText (hWnd,
                            IDC_PRINTLINE,
                            szShowMsg);
            }
            break;

        case WM_COMMAND:
            /* if cancel button selected, post message to cancel print job */
            if (LOWORD (uParam) == IDCANCEL)
                {
                PostMessage (GetParent (hWnd), UM_CANCELPRINT, 0, 0);
                DestroyWindow (hWnd);
                }
            break;

        default:
            return FALSE;
    }
    return TRUE;
}



/* put up the print common dialog, and print */
int WINAPI lcPrint (
    HWND    hWnd)
{
    SIZE        sLine;
    int         yLineExt;
    int         nLineChar;
    int         xExt, yExt;
    int         yPageExt;
    int         xPageExt;
    int         xPageOff, yPageOff;
    int         nStart,nEnd;
    DOCINFO     diPrint;
    TCHAR       lpszJobName[MAX_PATH];
    TCHAR       szStr[MAX_CHAR_NUM+20];
    int         i,len;
    int         is_OK;


    if(!lcSaveEditText(iDisp_Top, 0))
        return TRUE;                    // Some error, but msg had displayed

    /* Display Choose line number dialog */
    is_OK=(int)DialogBox(hInst,_TEXT("LineDialog"), hwndMain, (DLGPROC)LineDlgProc);

    if(!is_OK)
        return TRUE;                    // User choose Cancel

    /* call common print dialog to get initialized printer DC */
    pdPrint.Flags = PD_RETURNDC | PD_NOPAGENUMS | PD_NOSELECTION;

    /* call common print dialog */
    if (!PrintDlg (&pdPrint))
        return TRUE;                    // User choose Cancel

    /* start cancel dialog box */
    hCancelDlg = CreateDialog (hInst,
                               _TEXT("IDD_CANCELDLG"),
                               hwndMain,
                               (DLGPROC)CancelDlgProc);


    if (!hCancelDlg)
        return IDS_CANCELDLGFAILED;

    ShowWindow (hCancelDlg, SW_SHOW);
    UpdateWindow (hCancelDlg);

    /* set AbortProc callback */
    if (SetAbortProc (pdPrint.hDC, (ABORTPROC)AbortProc) < 0) {
        /* on error, clean up and go away */
        DestroyWindow (hCancelDlg);
        DeleteDC (pdPrint.hDC);
        return IDS_SETABORTPROCFAILED;
    }

    /* initialize printer for job */
    GetWindowText (hWnd, lpszJobName, sizeof (lpszJobName));
    diPrint.cbSize = sizeof (DOCINFO);
    diPrint.lpszDocName = lpszJobName;
    diPrint.lpszOutput = NULL;
    diPrint.lpszDatatype = NULL;
    diPrint.fwType = 0;
    if (StartDoc(pdPrint.hDC, &diPrint) == SP_ERROR) {
        /* on error, clean up and go away */
        DestroyWindow (hCancelDlg);
        DeleteDC (pdPrint.hDC);
        return IDS_STARTDOCFAILED;
    }

    /* Set Cursor status
    SetCursor(hCursorWait);

    /* job started, so display cancel dialog */
    ShowWindow (hCancelDlg, SW_SHOW);
    UpdateWindow (hCancelDlg);

    /* retrieve dimensions for printing and init loop variables */
    GetTextExtentPoint (pdPrint.hDC,_TEXT(""), 2, &sLine);
	sLine.cx += (sLine.cx % 2);
	sLine.cy += (sLine.cy % 2);
    yLineExt = sLine.cy+4;
    yPageExt = GetDeviceCaps (pdPrint.hDC, VERTRES);
    xPageExt = GetDeviceCaps (pdPrint.hDC, HORZRES);
    xPageOff = GetDeviceCaps (pdPrint.hDC, PHYSICALOFFSETX);
    yPageOff = GetDeviceCaps (pdPrint.hDC, PHYSICALOFFSETY);
    nLineChar= (xPageExt - xPageOff * 2)/(1+(sLine.cx>>1)) - 6;
    //yExt = TOP_SPACE;
	xExt = xPageOff;
	yExt = yPageOff + sLine.cy;

    if (StartPage(pdPrint.hDC) <= 0)
    {
        DestroyWindow (hCancelDlg);
        DeleteDC (pdPrint.hDC);
        return IDS_PRINTABORTED;
    }

    /* Print Title */
    LoadString(hInst, IDS_PRINTINGTITLE, szStr, sizeof(szStr));
    TextOut (pdPrint.hDC, xExt, yExt, szStr, lstrlen(szStr));
    yExt += (yLineExt*2);

    FillMemory(szStr, 20, ' ');

    /* print text line by line from top to bottom */
    for(i=nFromLine; i<=nToLine; i++) {
        wsprintf(szStr,_TEXT("%5d"), i);
        szStr[5]=' ';
#ifdef UNICODE
		szStr[WORD_POS]=lpWord[i-1].wWord;
#else
        //szStr[WORD_POS]=HIBYTE(lpWord[i-1].wWord);
        //szStr[WORD_POS+1]=LOBYTE(lpWord[i-1].wWord);
#endif
        len=lcMem2Disp(i-1, &szStr[PHRASE_POS])+PHRASE_POS;

        /* if at end of page, start a new page */
        if ((yExt + yLineExt) > (yPageExt - (yPageOff + sLine.cy) * 2))
        {
            if (EndPage(pdPrint.hDC) == SP_ERROR)
            {
                DestroyWindow (hCancelDlg);
                DeleteDC (pdPrint.hDC);
                return IDS_PRINTABORTED;
            }
            if (StartPage(pdPrint.hDC) <= 0)
            {
                DestroyWindow (hCancelDlg);
                DeleteDC (pdPrint.hDC);
                return IDS_PRINTABORTED;
            }
            yExt = yPageOff + sLine.cy; //TOP_SPACE;
        }
        if( len <=(nLineChar-PHRASE_POS)) {
            /* print current the line and unlock the text handle */
            TextOut (pdPrint.hDC, xExt, yExt, szStr, len);
        } else {
            nStart=nLineChar;
            //if(is_DBCS_1st(szStr,nStart-1))
            //    nStart--;
            TextOut (pdPrint.hDC, xExt, yExt, szStr, nStart);

            while(nStart < len-1) {
                yExt += yLineExt;

                /* if at end of page, start a new page */
		        if ((yExt + yLineExt) > (yPageExt - (yPageOff + sLine.cy) * 2))
                {
                    if (EndPage(pdPrint.hDC) == SP_ERROR)
                    {
                        DestroyWindow (hCancelDlg);
                        DeleteDC (pdPrint.hDC);
                        return IDS_PRINTABORTED;
                    }
                    if (StartPage(pdPrint.hDC) <= 0)
                    {
                        DestroyWindow (hCancelDlg);
                        DeleteDC (pdPrint.hDC);
                        return IDS_PRINTABORTED;
                    }
                    yExt = yPageOff + sLine.cy; //TOP_SPACE;
                }
				
				while (szStr[nStart]==' ') nStart++;

                nEnd=nStart+nLineChar-PHRASE_POS;
                if(nEnd >= len)
                    nEnd=len;
#ifdef UNICODE
#else
                else
                    if(is_DBCS_1st(szStr,nEnd-1))
                        nEnd--;
#endif
                TextOut (pdPrint.hDC, xExt+sLine.cx*(PHRASE_POS>>1), yExt, &szStr[nStart], nEnd-nStart);
                nStart=nEnd;
            }
        }

        /* increment page position */
        yExt += yLineExt;
    }

    /* end the last page and document */
    EndPage (pdPrint.hDC);
    EndDoc (pdPrint.hDC);

    /* end cancel dialog box, clean up and exit */
    DestroyWindow (hCancelDlg);
    DeleteDC(pdPrint.hDC);
    return TRUE;
}


BOOL is_DBCS_1st(
    TCHAR *szStr,
    int   nAddr)
{
#ifndef UNICODE
    int  i;
    BOOL bDBCS=FALSE;

    for(i=0; i<=nAddr; i++) {
        if(bDBCS)
            bDBCS=FALSE;
        else
            if((szStr[i] >= 0x81) && (szStr[i] <= 0xFE))
                bDBCS=TRUE;
    }

    return bDBCS;
#else
	return TRUE;
#endif
}

int TransNum(
    TCHAR *szStr)
{
    int  i,j,nNum;

    for(i=0; szStr[i] == ' '; i++) ;
    nNum=0;
    for(j=i; szStr[j] != 0; j++) {
        if((szStr[j] < '0') || (szStr[j] >'9'))
            return 0;
        nNum=nNum*10+(szStr[j]-'0');
    }

    return nNum;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\lctool\lcfunc.c ===
/*************************************************
 *  lcfunc.c                                     *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

//
//  Change Log:
//
//    @D01      Fix Bug #11204      Goto function with save text will error
//    @D02      Fix Bug None        Only check modify status for available lines  10/04
//
//  Change log by Eric
//
//    @E01      Fix Bug			    use "Delete line" doesn't enable "Save" and "Save As"
//

#include <windows.h>            // required for all Windows applications
#include <windowsx.h>
#include <stdlib.h>
#include <memory.h>
#include "rc.h"
#include "lctool.h"

#ifndef UNICODE
#define lWordBuff iWordBuff
#define lPhraseBuff iPhraseBuff
#define lNext_Seg iNext_Seg
#define lFirst_Seg iFirst_Seg
#endif

extern HWND subhWnd;

TCHAR  szEditStr[MAX_PATH];
WORD   wOldID=IDE_WORD_START;

// Local function prototypes.
INT_PTR FAR PASCAL GotoDialogProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR FAR PASCAL SearchDialogProc(HWND, UINT, WPARAM, LPARAM);


BOOL lcKey(
    HWND   hwnd,
    WPARAM wParam,
    USHORT uKeyState)
{

    switch (wParam) {
        case VK_UP:
            lcUp_key(hwnd);
            break;

        case VK_DOWN:
            lcDown_key(hwnd);
            break;

        case VK_PRIOR :
            lcPgUp_key(hwnd);
            break;

        case VK_NEXT :
            lcPgDown_key(hwnd);
            break;

        case VK_HOME :
            if(uKeyState != (USHORT)CTRL_STATE)
                return FALSE;
            iDisp_Top=0;
            yPos=0;
            SetFocus(hwndWord[0]);
            lcSetEditText(0, TRUE);
            break;

        case VK_END :
            if(uKeyState != (USHORT)CTRL_STATE)
                return FALSE;
            if(lWordBuff <= iPage_line) {
                SetFocus(hwndWord[lWordBuff-1]);
            } else {
                iDisp_Top=lWordBuff-iPage_line;
                yPos=lWordBuff;
                lcSetEditText(iDisp_Top, TRUE);
                SetFocus(hwndWord[iPage_line-1]);
            }
            break;

        default:
            return FALSE;

    }
    PostMessage(hwndMain, WM_COMMAND, IDM_VSCROLL, 0);
    return TRUE;
}

BOOL lcTab_key(
    HWND hwnd)
{
    UINT  iEdit;
    BOOL  is_WORD;

    iEdit=lcGetEditFocus(hwnd, &is_WORD);
    if(is_WORD) {
        SetFocus(hwndPhrase[iEdit]);
    } else {
        iEdit++;
        if(iEdit == iPage_line)
            iEdit=0;
        SetFocus(hwndWord[iEdit]);
    }

    return TRUE;
}

void lcUp_key(
    HWND hwnd)
{
    UINT  iEdit;
    BOOL  is_WORD;

    iEdit=lcGetEditFocus(hwnd, &is_WORD);
    if(iEdit == 0) {
        if(iDisp_Top != 0) {
            iDisp_Top--;
            if(!lcSetEditText(iDisp_Top, TRUE)) {
                iDisp_Top++;
                return;
            }
            yPos--;
        } else
            MessageBeep(MB_OK);
        return;
    }
    iEdit--;
    if(is_WORD) {
        SetFocus(hwndWord[iEdit]);
    }else {
        SetFocus(hwndPhrase[iEdit]);
    }
    yPos--;
}

void lcDown_key(
    HWND hwnd)
{
    UINT  iEdit;
    BOOL  is_WORD;

    iEdit=lcGetEditFocus(hwnd, &is_WORD);
    if((iEdit+1) == iPage_line) {
        if((iDisp_Top+iPage_line) < lWordBuff) {
            iDisp_Top++;
            if(!lcSetEditText(iDisp_Top, TRUE)) {
                iDisp_Top--;
                return;
            }
            yPos++;
        } else
            MessageBeep(MB_OK);
        return;
    }
    iEdit++;
    if(is_WORD) {
        SetFocus(hwndWord[iEdit]);
    }else {
        SetFocus(hwndPhrase[iEdit]);
    }
    yPos++;
}

void lcPgUp_key(
    HWND hwnd)
{
    UINT  iEdit,iDisp_temp;
    BOOL  is_WORD;

    if(iDisp_Top == 0) {
        iEdit=lcGetEditFocus(hwnd, &is_WORD);
        if(iEdit != 0) {
            if(is_WORD) {
                SetFocus(hwndWord[0]);
            }else {
                SetFocus(hwndPhrase[0]);
            }
            yPos=0;
        } else
            MessageBeep(MB_OK);
        return;
    }
    yPos-=iPage_line;
    if(yPos < 0)
        yPos=0;
    if(iDisp_Top < iPage_line) {
        iDisp_temp=0;
        iEdit=lcGetEditFocus(hwnd, &is_WORD);
        if(is_WORD) {
            SetFocus(hwndWord[yPos]);
        }else {
            SetFocus(hwndPhrase[yPos]);
        }
    } else
        iDisp_temp=iDisp_Top-iPage_line;
    if(lcSetEditText(iDisp_temp, TRUE))
        iDisp_Top=iDisp_temp;
}

void lcPgDown_key(
    HWND hwnd)
{
    UINT  iEdit,iDisp_temp;
    BOOL  is_WORD;

    if(lWordBuff < iPage_line) {
        MessageBeep(MB_OK);
        return;
    }
    if((iDisp_Top+iPage_line) == lWordBuff) {
        iEdit=lcGetEditFocus(hwnd, &is_WORD);
        if((iEdit+1) != iPage_line) {
            if(is_WORD) {
                SetFocus(hwndWord[iPage_line-1]);
            }else {
                SetFocus(hwndPhrase[iPage_line-1]);
            }
            yPos=lWordBuff-iPage_line;
        } else
            MessageBeep(MB_OK);
        return;
    }

    yPos+=iPage_line;
    if((UINT)yPos > (lWordBuff-iPage_line))
        yPos=lWordBuff-iPage_line;

    if((iDisp_Top+(iPage_line*2)) < lWordBuff)
        iDisp_temp=iDisp_Top+iPage_line;
    else {
        iDisp_temp=lWordBuff-iPage_line;
        iEdit=lcGetEditFocus(hwnd, &is_WORD);
        if(is_WORD) {
            SetFocus(hwndWord[yPos+(iPage_line*2)-lWordBuff-1]);
        }else {
            SetFocus(hwndPhrase[yPos+(iPage_line*2)-lWordBuff-1]);
        }
    }
    if(lcSetEditText(iDisp_temp, TRUE))
        iDisp_Top=iDisp_temp;
}

void lcGoto(
    HWND hwnd)
{
    UINT iDiff,iDisp_save;
    int  is_OK;

    if(!lcSaveEditText(iDisp_Top, 0))
        return;

    iDisp_save=iDisp_Top;

    is_OK=(int)DialogBox(hInst,
            _TEXT("GotoDialog"),
            hwndMain,
            (DLGPROC)GotoDialogProc);

   // Check cancel by user
    if(!is_OK) {
        SetFocus(hwndFocus);
        return;
    }
    if(iDisp_Top > (lWordBuff-iPage_line)) {
        iDiff=iDisp_Top-lWordBuff+iPage_line;
        iDisp_Top=lWordBuff-iPage_line;
        SetFocus(hwndWord[iDiff]);
    } else
        SetFocus(hwndWord[0]);
    if(!lcSetEditText(iDisp_Top, FALSE))
        iDisp_Top=iDisp_save;
    yPos=iDisp_Top;

}

INT_PTR FAR PASCAL GotoDialogProc(
    HWND   hDlg,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam)
{
    TCHAR  szWordstr[MAX_PATH];
    TCHAR  szShowMsg[MAX_PATH];
    WORD   wWord;
    UINT   i;

    switch (message) {
        case WM_INITDIALOG:

            szWordstr[0]=0; //set to be null

            return TRUE;


        case WM_COMMAND:

            switch (wParam) {

                case IDOK:
                case IDB_OK:

                    GetDlgItemText(hDlg,IDD_INDEX_NAME,szWordstr, sizeof(szWordstr)/sizeof(TCHAR) );
#ifdef UNICODE
                    wWord=szWordstr[0];
#else
                    wWord=(szWordstr[0] << 8)+szWordstr[1];
#endif
                    for(i=0; i<lWordBuff; i++)
                        if(wWord == lpWord[i].wWord)
                            break;
                    if(i == lWordBuff) {
                        LoadString(hInst, IDS_ERR_NOT_FOUND,
                                   szShowMsg, sizeof(szShowMsg)/sizeof(TCHAR));
                        MessageBox(hDlg, szShowMsg, NULL,
                                   MB_OK | MB_ICONEXCLAMATION);
                        return TRUE;
                    }
                    iDisp_Top=i;

                    EndDialog (hDlg, TRUE) ;

                    return TRUE;

                case IDB_CANCEL:
                case IDCANCEL:
                    EndDialog (hDlg, FALSE) ;
                    return TRUE;
                case IDD_INDEX_NAME:
                    return TRUE;
            }
            break ;

        case WM_CLOSE:
            EndDialog(hDlg, FALSE);
            return TRUE;
    }
    return FALSE;
}


UINT lcGetEditFocus(
    HWND hwnd,
    BOOL *is_WORD)
{
    UINT  i;

    for(i=0; i<iPage_line; i++)
        if(hwnd == hwndWord[i]) {
            *is_WORD= TRUE;
            return i;
        }

    for(i=0; i<iPage_line; i++)
        if(hwnd == hwndPhrase[i]) {
            *is_WORD= FALSE;
            return i;
        }

   // In case focus not in EDIT CONTROL, set to WORD 0
    *is_WORD=TRUE;
    return 0;
}

void lcErrMsg(
    UINT iMsgID)
{
    TCHAR szErrStr[MAX_PATH];
	static fShown=FALSE;

    if ( fShown==TRUE )
	   return;

    fShown=TRUE;
    LoadString(hInst, iMsgID, szErrStr, sizeof(szErrStr)/sizeof(TCHAR));
    MessageBox(hwndMain, szErrStr, NULL, MB_OK | MB_ICONEXCLAMATION);
    fShown=FALSE;
}

BOOL lcSetEditText(
     UINT iTopAddr,
     BOOL bSaveText)
{
static UINT   iWord=1;
       TCHAR  szStr[MAX_CHAR_NUM+1];
       UINT   i,j;

    if(bSaveText)
        if(!lcSaveEditText(iWord, 0))
            return FALSE;
    iWord=iTopAddr;

    for(i=0; i<iPage_line; i++) {
       // Set Word string
        if(iWord == lWordBuff)
			break;

#ifdef UNICODE
        szStr[0]=(TCHAR) lpWord[iWord].wWord;
        szStr[1]=0;
#else
        szStr[0]=HIBYTE(lpWord[iWord].wWord);
        szStr[1]=LOBYTE(lpWord[iWord].wWord);
        szStr[2]=0;
#endif
        SendMessage(hwndWord[i], WM_SETTEXT, 0,(LPARAM) szStr);

       // Set Phrase string
        lcMem2Disp(iWord, szStr);
        SendMessage(hwndPhrase[i], WM_SETTEXT, 0,(LPARAM)szStr);
        iWord++;
    }
    iWord=iTopAddr;

   // If Still have not in memory item set to null string
    if(i != iPage_line)  {
        szStr[0]=0;
        for(j=i; j<iPage_line; j++) {
            SendMessage(hwndWord[j], WM_SETTEXT, 0,(LPARAM)szStr);
            SendMessage(hwndPhrase[j], WM_SETTEXT, 0,(LPARAM)szStr);
        }
    }

    return TRUE;
}

BOOL lcSaveEditText(
     UINT iWord,
     UINT iSkip)
{
       TCHAR  szStr[MAX_CHAR_NUM];
       UINT   i,len,phraselen=0;
	   UINT   j;

    //for(i=0; i<iPage_line; i++) {
	for(i=0; i<min(iPage_line,lWordBuff); i++) {   // @D02C

        if(i+1 == iSkip)
            continue;
       // Get Word string
        if(SendMessage(hwndWord[i], EM_GETMODIFY, 0, 0)) {
            bSaveFile=TRUE;
            SendMessage(hwndWord[i], WM_GETTEXT, 3, (LPARAM)szStr);
            if(lstrlen(szStr) == 0) {
                MessageBeep(MB_OK);
                SetFocus(hwndWord[i]);
                return FALSE;
            }
            if(!is_DBCS2(*((LPUNAWORD)(szStr)), TRUE)) {
                SetFocus(hwndWord[i]);
                return FALSE;
            }
#ifdef UNICODE
            lpWord[iWord+i].wWord=szStr[0];
#else
            lpWord[iWord+i].wWord=(szStr[0] << 8)+szStr[1];
#endif
            SendMessage(hwndWord[i], EM_SETMODIFY, FALSE, 0);            //@D01A

        }

       // Get Phrase string
        if(SendMessage(hwndPhrase[i], EM_GETMODIFY, 0, 0)) {
            bSaveFile=TRUE;
            SendMessage(hwndPhrase[i], WM_GETTEXT, MAX_CHAR_NUM-1, (LPARAM)szStr);
            len=lstrlen(szStr);
            if(len == 0) {
                MessageBeep(MB_OK);
                SetFocus(hwndPhrase[i]);
                return FALSE;
            }
            len++;
           //#53609 Limit phrase lenght to MAX_PHRASE_LEN. 
           for (j=0; j<len-1; j++) {
	       phraselen++;
               if(szStr[j] ==TEXT(' '))
	       if (phraselen > MAX_PHRASE_LEN)
	       {
                  TCHAR szStr[128],szShowMsg[128];
                  LoadString(hInst, IDS_OVERPHRASELEN, szStr, sizeof(szStr));
                  wsprintf(szShowMsg, szStr, MAX_PHRASE_LEN);
	          MessageBox(hwndMain,szShowMsg,NULL,MB_OK);
                  SetFocus(hwndPhrase[i]);
                  return FALSE;
               } 
	       else
	       {
		  phraselen = 0;
		  continue;
               }
           }

// Check DBCS
#ifndef UNICODE
           for(j=0; j<len-1; j++) {
                if(szStr[j] ==_TEXT(' '))
					    continue;
                if(!is_DBCS2(*((LPUNAWORD)(&szStr[j])), TRUE)) {
                    SetFocus(hwndPhrase[i]);
                    return FALSE;
                }
                j++;
            }
#endif

            if(!lcDisp2Mem(iWord+i, szStr))
                return FALSE;
            SendMessage(hwndPhrase[i], EM_SETMODIFY, FALSE, 0);          //@D01A
        }

    }

    return TRUE;
}

void lcDelLine(
    HWND hwnd)
{
    UINT  iEdit,i;
    BOOL  is_WORD;

    if(lWordBuff == 0)
        return;
    iEdit=lcGetEditFocus(GetFocus(), &is_WORD);
    if((iDisp_Top+iEdit) > lWordBuff)
        return;
    if(!lcSaveEditText(iDisp_Top, iEdit+1))
        return;
    lcFreeSeg(lpWord[iDisp_Top+iEdit].lFirst_Seg);
    for(i=(iDisp_Top+iEdit); i < lWordBuff; i++) {
        lpWord[i].wWord=lpWord[i+1].wWord;
        lpWord[i].lFirst_Seg=lpWord[i+1].lFirst_Seg;
    }
    lWordBuff--;
    SetScrollRange(subhWnd, SB_VERT, 0, lWordBuff-iPage_line, TRUE);

   // Check the last page
    if(((iDisp_Top+iPage_line) >= lWordBuff) && (iDisp_Top != 0))
        iDisp_Top--;
    lcSetEditText(iDisp_Top, FALSE);
	bSaveFile = TRUE; // <== @E01
}

void lcInsLine(
    HWND hwnd)
{
    UINT  iEdit,iFree,iWord;
    BOOL  is_WORD;
    int   i;

    iEdit=lcGetEditFocus(GetFocus(), &is_WORD);
    iWord=iDisp_Top+iEdit;
    if(iWord > lWordBuff)
        iWord=lWordBuff;
    if(!lcSaveEditText(iDisp_Top, 0))
        return;
    if(lWordBuff+1 == nWordBuffsize)
        if(!lcAllocWord())
            return;
    iFree=lcGetSeg();
    if(iFree == NULL_SEG)
        return;
    if(lWordBuff == 0) {
        lpWord[iWord].wWord=0;
        lpWord[iWord].lFirst_Seg=iFree;
    } else {
        for(i=(int)lWordBuff; i >= (int)iWord; i--) {
            lpWord[i+1].wWord=lpWord[i].wWord;
            lpWord[i+1].lFirst_Seg=lpWord[i].lFirst_Seg;
        }
        lpWord[iWord].wWord=0;
        lpWord[iWord].lFirst_Seg=iFree;
    }
    lWordBuff++;

    lpPhrase[iFree].szPhrase[0]=0;
    lpPhrase[iFree].lNext_Seg=NULL_SEG;
    SetScrollRange(subhWnd, SB_VERT, 0, lWordBuff-iPage_line, TRUE);
    if((iEdit+1) == iPage_line) {
        iEdit--;
        iDisp_Top++;
    }
    lcSetEditText(iDisp_Top, FALSE);
    SendMessage(hwndWord[iEdit], EM_SETMODIFY, TRUE, 0);
    SendMessage(hwndPhrase[iEdit], EM_SETMODIFY, TRUE, 0);

}

int __cdecl lcComp(
    const void *Pointer1,
    const void *Pointer2)
{
    LPWORDBUF lpWord1=(LPWORDBUF)Pointer1;
    LPWORDBUF lpWord2=(LPWORDBUF)Pointer2;

    if(lpWord1->wWord == lpWord2->wWord) {
        wSameCode=lpWord1->wWord;
        return 0;
    }
    if(lpWord1->wWord > lpWord2->wWord)
        return 1;
    else
        return -1;

}

BOOL lcSort(
    HWND hwnd)
{

    if(!lcSaveEditText(iDisp_Top, 0))
        return FALSE;
    wSameCode=0;
    qsort(lpWord, lWordBuff, sizeof(WORDBUF), lcComp);
    if(wSameCode) {
        TCHAR szStr[MAX_PATH];
        TCHAR szErrStr[MAX_PATH];

        LoadString(hInst, IDS_ERR_SAMECODE, szStr, sizeof(szStr));
#ifdef UNICODE
        wsprintf(szErrStr, szStr, wSameCode, ' ');
#else
        wsprintf(szErrStr, szStr, HIBYTE(wSameCode), LOBYTE(wSameCode));
#endif
        MessageBox(hwndMain, szErrStr, NULL, MB_OK | MB_ICONEXCLAMATION);
    }
    lcSetEditText(0, FALSE);
    yPos=0;
    SetScrollPos(subhWnd, SB_VERT, yPos, TRUE);
	iDisp_Top = 0;
    return TRUE;
}

BOOL is_DBCS(
    WORD wWord,
    BOOL bMessage)
{
#ifdef UNICODE
#else
    if((HIBYTE(wWord) < 0x81) || (HIBYTE(wWord) > 0xFE)) {
        if(bMessage)
            lcErrMsg(IDS_ERR_SBCS);
        return FALSE;
    }
    if((LOBYTE(wWord) < 0x40) || (LOBYTE(wWord) > 0xFE)) {
        if(bMessage)
            lcErrMsg(IDS_ERR_SBCS);
        return FALSE;
    }
#endif
    return TRUE;
}

BOOL is_DBCS2(
    WORD wWord,
    BOOL bMessage)
{
#ifndef UNICODE
    if((LOBYTE(wWord) < 0x81) || (LOBYTE(wWord) > 0xFE)) {
        if(bMessage)
            lcErrMsg(IDS_ERR_SBCS);
        return FALSE;
    }
    if((HIBYTE(wWord) < 0x40) || (HIBYTE(wWord) > 0xFE)) {
        if(bMessage)
            lcErrMsg(IDS_ERR_SBCS);
        return FALSE;
    }
#endif
    return TRUE;
}

void lcEditFocusOn(
    WORD wID)
{
    HWND   hwnd;
    BOOL   isWord;
    int    iAddr;
    TCHAR  szStr[MAX_CHAR_NUM];
    UINT   i,len;
    WORD   wTemp;

    if(wOldID != wID) {
        if(wOldID >= IDE_PHRASE_START) {
            isWord=FALSE;
            iAddr=wOldID-IDE_PHRASE_START;
            hwnd=hwndPhrase[iAddr];
        } else {
            isWord=TRUE;
            iAddr=wOldID-IDE_WORD_START;
            hwnd=hwndWord[iAddr];
        }

        if(SendMessage(hwnd, EM_GETMODIFY, 0, 0)) {
            bSaveFile=TRUE;
            SendMessage(hwnd, WM_GETTEXT, MAX_CHAR_NUM-1, (LPARAM)szStr);
            len=lstrlen(szStr);
            if(len == 0) {
                wOldID=wID;
                return;
            }
            if(isWord) {
#ifdef UNICODE
                if(!is_DBCS2(szStr[0], FALSE))
                    return;
                wTemp=lpWord[iDisp_Top+iAddr].wWord=szStr[0];
#else
                if(!is_DBCS2(*((WORD *)(szStr)), FALSE))
                    return;
                wTemp=(szStr[0] << 8)+szStr[1];
                lpWord[iDisp_Top+iAddr].wWord=wTemp;
#endif
                for(i=0; i<lWordBuff; i++) {
                    if(i == iDisp_Top+iAddr)
                        continue;
                    if(wTemp == lpWord[i].wWord)
                        break;
                }
                if(i != lWordBuff) {
                    lcErrMsg(IDS_ERR_INPUTSAME);
                    SetFocus(hwnd);
                    return;
                }
            } else {
                len++;
               // Check DBCS
                for(i=0; i<len-1; i++) {
                    if(szStr[i] ==_TEXT(' '))
                        continue;
                    if(!is_DBCS2(*((LPUNAWORD)(&szStr[i])), TRUE)) {
                        SetFocus(hwndPhrase[iAddr]);
                        return;
                    }
                    i++;
                }

                if(!lcDisp2Mem(iDisp_Top+iAddr, szStr))
                    return;
            }
            SendMessage(hwnd, EM_SETMODIFY, FALSE, 0);
        }
        if(wID >= IDE_PHRASE_START) {
            isWord=FALSE;
            iAddr=wID-IDE_PHRASE_START;
        } else {
            isWord=TRUE;
            iAddr=wID-IDE_WORD_START;
        }
        if((iAddr >= (int)iPage_line) || (iAddr < 0))
            return;                     // Focus not in Edit Control
       // Check out of legal buffer
        if(iDisp_Top+iAddr >= lWordBuff) {
            MessageBeep(MB_OK);
            SetFocus(hwnd);
            return;
        }
        wOldID=wID;
        hwndFocus=isWord ? hwndWord[iAddr] : hwndPhrase[iAddr];
    }

}

BOOL lcRemoveDup( TCHAR *szBuf )
{
    UINT  len;
    UINT  s;
    UINT  i,cnt;
    TCHAR *szCurPos, *szStr;
    int   unmatch;
	BOOL  bModify=FALSE;

    if ( szBuf == 0 )
       return FALSE;

    len = (UINT)lstrlen(szBuf);
    // remove trailing blanks
    for ( ; len > 0 && szBuf[len-1] ==_TEXT(' '); szBuf[--len] = 0 );

    // remove leading blanks
    for ( s=0 ; s < len && szBuf[s] ==_TEXT(' '); s++ );
    if ( s > 0 )
    {
#ifdef UNICODE
	   memcpy( &szBuf[0], &szBuf[s], (len-s)<<1 );
#else
       memcpy( &szBuf[0], &szBuf[s], len-s );
#endif
       len -= s;
       szBuf[len]=0;
    }

    // return if len=0
    if ( len == 0 )
       return FALSE;

    // search from the end of string and remove duplicate phrase
    // s -> last char of target phrase
    for ( i=0, s=len-1 ; s > 0 ; )
    {
        // locate the range of current phrase
        for ( cnt=1 ; s>0 && szBuf[s-1] !=_TEXT(' ') ; s--, cnt++ );

        // s-> first char of target phrase
        // break if start from first char in buf)
        if (s==0)
           break;

        // check if we found another occurrence before the target string
        // match 1st char first, then match the rest of string
        // do until a match or end of buf
        for ( szStr=&szBuf[s], szCurPos=&szBuf[0], unmatch=1 ;
              szCurPos+cnt < szStr &&
              (*szCurPos != *szStr ||
               szCurPos[cnt] != _TEXT(' ') ||
#ifdef UNICODE
               (unmatch=memcmp(szCurPos, szStr, cnt <<1))!=0) ; )
#else
               (unmatch=memcmp(szCurPos, szStr, cnt))!=0) ; )
#endif
        {
            // skip this phrase
            // skip non-blanks
            while ( *szCurPos !=0 && *szCurPos != _TEXT(' ')) szCurPos++;

            // skip blanks
            while ( *szCurPos !=0 && *szCurPos == _TEXT(' ')) szCurPos++;
        }

        // if found a string
        if ( unmatch == 0 )
        {
            // remove it and its trailing blanks
            while (szBuf[s+cnt]==_TEXT(' ')) cnt++;

#ifdef UNICODE
			memmove(&szBuf[s], &szBuf[s+cnt], (len-s-cnt+1)<<1);
#else
            memmove(&szBuf[s], &szBuf[s+cnt], len-s-cnt+1);
#endif
            len -= cnt;
			bModify=TRUE;
        }

        // let s point to last byte of the previous string
        // skip blanks
        for ( s--; s>0 && (szBuf[s]==_TEXT(' ') || szBuf[s] ==0) ; s-- ) ;
    }

	return bModify;
}

BOOL lcDisp2Mem(
    UINT  iAddr,
    TCHAR *szDispBuf)
{
    LPPHRASEBUF Phrase;
    UINT   i,j,len,iFree,iSave;

    // remove duplicate phrase
    if(lcRemoveDup(szDispBuf) && iAddr < MAX_LINE){
		SendMessage(hwndPhrase[iAddr],WM_SETTEXT,0,
			        (LPARAM)(LPCTSTR)szDispBuf);
	};

    len=lstrlen(szDispBuf)+1;
    if((szDispBuf[len-1] == _TEXT(' ')) && (len > 1)) {
        szDispBuf[len-1]=0;
        len--;
    }
    if(len >= MAX_CHAR_NUM) { //tang must fix
        szDispBuf[MAX_CHAR_NUM-1]=0;
#ifndef UNICODE
        if(is_DBCS_1st(szDispBuf, MAX_CHAR_NUM-2))
             szDispBuf[MAX_CHAR_NUM-2]=' ';
#endif
        len=MAX_CHAR_NUM;
    }
    Phrase=&lpPhrase[lpWord[iAddr].lFirst_Seg];
    iSave=lpWord[iAddr].lFirst_Seg;
    for(i=0; i<((len-1)/SEGMENT_SIZE); i++) {
#ifdef UNICODE
		CopyMemory(Phrase->szPhrase, &szDispBuf[i*SEGMENT_SIZE],SEGMENT_SIZE<< 1);
#else
        CopyMemory(Phrase->szPhrase, &szDispBuf[i*SEGMENT_SIZE],SEGMENT_SIZE);
#endif
        if(Phrase->lNext_Seg == NULL_SEG) {
            iFree=lcGetSeg();
            if(iFree == NULL_SEG)
                return FALSE;
            Phrase=&lpPhrase[iSave];
            Phrase->lNext_Seg=iFree;
        }
        iSave=Phrase->lNext_Seg;
        Phrase=&lpPhrase[Phrase->lNext_Seg];
    }
    for(j=0; j<SEGMENT_SIZE; j++) {
        Phrase->szPhrase[j]=szDispBuf[i*SEGMENT_SIZE+j];
        if(szDispBuf[i*SEGMENT_SIZE+j] == 0)
            break;
    }
    if(Phrase->lNext_Seg != NULL_SEG)
        lcFreeSeg(Phrase->lNext_Seg);
    Phrase->lNext_Seg=NULL_SEG;

    return TRUE;
}


UINT lcMem2Disp(
    UINT  iAddr,
    TCHAR *szDispBuf)
{
    LPPHRASEBUF Phrase;
    UINT   i,len;


    Phrase=&lpPhrase[lpWord[iAddr].lFirst_Seg];
    for(i=0; Phrase->lNext_Seg != NULL_SEG; i+=SEGMENT_SIZE) {
#ifdef UNICODE
		CopyMemory(&szDispBuf[i], Phrase->szPhrase, SEGMENT_SIZE << 1);
#else
        CopyMemory(&szDispBuf[i], Phrase->szPhrase, SEGMENT_SIZE);
#endif
        Phrase=&lpPhrase[Phrase->lNext_Seg];
    }
    szDispBuf[i] = 0;
    lstrcat(szDispBuf, Phrase->szPhrase);
    len=lstrlen(szDispBuf);
    if(szDispBuf[len] != _TEXT(' ')) {
        lstrcat(szDispBuf,_TEXT(" "));
        len+=1;
    }

    return len;
}


extern TCHAR  szPhrasestr[MAX_CHAR_NUM];
UINT   nStartAddr = 0;
UINT   nStartPos = 0;
void lcMoveEditWindowByWord(UINT nWords);

LONG lcSearchMem(
    TCHAR *szSearchBuf)
{
    UINT   iAddr;
	TCHAR szDispBuf[MAX_CHAR_NUM];

	for (iAddr = nStartAddr; iAddr < lWordBuff; iAddr++) {
		lcMem2Disp(iAddr, szDispBuf);
#ifdef UNICODE
		if (wcsstr(szDispBuf, szSearchBuf) != NULL) {
#else
		if (strstr(szDispBuf, szSearchBuf) != NULL) {
#endif
			return (LONG) iAddr;
		}
	}

    return -1;
}

void lcSearch(
    HWND hwnd, BOOL bNext)
{
    UINT iDiff,iDisp_save;
	TCHAR szBuf[MAX_CHAR_NUM], *lpStr;
    BOOL  is_WORD;
    int  is_OK;
    LONG   i;
    TCHAR  szShowMsg[MAX_PATH];

	if(bNext && szPhrasestr[0] == 0) {
		MessageBeep(-1);
		return;
	}

    if(!lcSaveEditText(iDisp_Top, 0))
        return;

    iDisp_save=iDisp_Top;
	
    nStartAddr=lcGetEditFocus(GetFocus(), &is_WORD) + iDisp_Top;

	if (is_WORD) {
		nStartPos = 0;
	} else {
		SendMessage(hwndPhrase[nStartAddr - iDisp_Top],EM_GETSEL, 0, (LPARAM) (LPDWORD)&nStartPos);
	}

	if (!bNext) {

	    is_OK=(int)DialogBox(hInst,
		        _TEXT("SearchDialog"),
			    hwndMain,
				(DLGPROC)SearchDialogProc);

	   // Check cancel by user
		if(!is_OK) {
			SetFocus(hwndFocus);
			return;
		}
	}

	SendMessage(hwndPhrase[nStartAddr - iDisp_Top], WM_GETTEXT, (WPARAM)MAX_CHAR_NUM-1, (LPARAM)szBuf);
#ifdef UNICODE
	lpStr = wcsstr(szBuf + nStartPos, szPhrasestr);
#else
	lpStr = strstr(szBuf + nStartPos, szPhrasestr);
#endif
	if (lpStr != NULL) {
		UINT nStart = (UINT)(lpStr - szBuf);
		UINT nEnd = nStart + lstrlen(szPhrasestr);

		SetFocus(hwndPhrase[nStartAddr - iDisp_Top]);
		SendMessage(hwndPhrase[nStartAddr - iDisp_Top], EM_SETSEL, (WPARAM)nStart, (LPARAM)nEnd);
		lcMoveEditWindowByWord(nStart);
		return;

	} else {
		nStartAddr++;
	}

    if((i = lcSearchMem(szPhrasestr)) == -1) {
		LoadString(hInst, IDS_ERR_PHRASE_NOT_FOUND,
                   szShowMsg, sizeof(szShowMsg)/sizeof(TCHAR));
        MessageBox(hwnd, szShowMsg, NULL,
                   MB_OK | MB_ICONEXCLAMATION);

        SetFocus(hwndFocus);
		return ;
    }
	iDisp_Top=(UINT)i;


    if(iDisp_Top > (lWordBuff-iPage_line)) {
        iDiff=iDisp_Top-lWordBuff+iPage_line;
        iDisp_Top=lWordBuff-iPage_line;
        SetFocus(hwndPhrase[iDiff]);
    } else {
		iDiff = 0;
        SetFocus(hwndPhrase[0]);
	}

    if(!lcSetEditText(iDisp_Top, FALSE))
        iDisp_Top=iDisp_save;
    yPos=iDisp_Top;

	SendMessage(hwndPhrase[iDiff], WM_GETTEXT, (WPARAM)MAX_CHAR_NUM-1, (LPARAM)szBuf);
#ifdef UNICODE
	lpStr = wcsstr(szBuf, szPhrasestr);
#else
	lpStr = strstr(szBuf, szPhrasestr);
#endif
	if (lpStr != NULL) {
		UINT nStart = (UINT)(lpStr - szBuf);
		UINT nEnd = nStart + lstrlen(szPhrasestr);

		SendMessage(hwndPhrase[iDiff], EM_SETSEL, (WPARAM)nStart, (LPARAM)nEnd);
		lcMoveEditWindowByWord(nStart);

	}

}

INT_PTR FAR PASCAL SearchDialogProc(
    HWND   hDlg,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam)
{

    switch (message) {
        case WM_INITDIALOG:
            szPhrasestr[0]=0; //set to be null
            SetDlgItemText(hDlg,IDD_SEARCH_LINE,szPhrasestr);
            return TRUE;

        case WM_COMMAND:

            switch (wParam) {

                case IDOK:
                case IDB_OK:

                    GetDlgItemText(hDlg,IDD_SEARCH_LINE,szPhrasestr, sizeof(szPhrasestr)/sizeof(TCHAR) );
                    EndDialog (hDlg, TRUE) ;

                    return TRUE;

                case IDB_CANCEL:
                case IDCANCEL:
                    EndDialog (hDlg, FALSE) ;
                    return TRUE;
                case IDD_INDEX_NAME:
                    return TRUE;
            }
            break ;

        case WM_CLOSE:
            EndDialog(hDlg, FALSE);
            return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\lctool\movelst.h ===
/*************************************************
 *  movelst.h                                    *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/


LRESULT CALLBACK ActualDlgProc (HWND hDlg, UINT message,  WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK AboutDlgProc (HWND hDlg, UINT message,  WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK ClassDlgProc(HWND hDlg, UINT message, WPARAM wParam , LPARAM lParam);
LRESULT CALLBACK NewListProc(HWND hwndList, UINT message, WPARAM wParam , LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\lctool\lctool.c ===
/*************************************************
 *  lctool.c                                     *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

//	Change's Note
//

#include <windows.h>            // required for all Windows applications
#include <windowsx.h>
#include <commctrl.h>
#include <htmlhelp.h>
#include "rc.h"
#include "lctool.h"
#include "movelst.h"

#define LC_CLASS      _TEXT("LcToolWClass")
#define LC_SUBCLASS   _TEXT("LcToolSubWClass")
#define HELPNAME      _TEXT("LCTOOL.CHM")

#define X_ITEM_1      40
#define X_ITEM_2      120
#define Y_ITEM_1      10
#define Y_ITEM_2      30
#define Y_ITEM_3      20
#define ALLOCBLOCK    3000
#define STATE_ON      0x8000
#define TOTALSCALE	  500
#define LINESHIFT	  2
#define PAGESHIFT	  10

#ifndef UNICODE
#define lWordBuff iWordBuff
#define lPhraseBuff iPhraseBuff
#define lNext_Seg iNext_Seg
#endif

typedef struct{
    WORD     wKey;
    USHORT   uState;
    WPARAM   wID;
    } FUNCKEYBUF, FAR *LPFUNCKEYBUF;

FUNCKEYBUF lpFuncKey[]={
#if defined(DEBUG)
                  { 'N',       CTRL_STATE,     IDM_NEW       }, // for debug
#endif
                  //{ 'Z',       CTRL_STATE,     IDM_UNDO      },
                  //{ 'X',       CTRL_STATE,     IDM_CUT       },
                  //{ 'C',       CTRL_STATE,     IDM_COPY      },
                  //{ 'V',       CTRL_STATE,     IDM_PASTE     },
                  { VK_DELETE, 0,              IDM_CLEAR     },
                  { 'D',       CTRL_STATE,     IDM_DELETEL   },
                  { VK_RETURN, 0,              IDM_INSERTL   },
                  { VK_F3,     0,              IDM_SNEXT     }
                };

UINT  nFuncKey=sizeof(lpFuncKey)/sizeof(FUNCKEYBUF);
HFONT hFont;
char  szAppName[9];
UINT  CharWidth;
UINT  CharHeight;
UINT  line_height;
int   nWidth;
int   nHeight;
int   cxHD0 = 50, cxHD1 = 30, cxHD2 = 200, cyHD;
int cyCaption, cyMenu;
HWND subhWnd;
TCHAR  szPhrasestr[MAX_CHAR_NUM];

// Local function prototypes.

BOOL InitApplication(HINSTANCE);
BOOL InitInstance(HINSTANCE, int);
void lcPaint(HWND);
BOOL lcInit(HWND);
void lcResize(HWND hwnd);
BOOL lcTranslateMsg(MSG *);
void lcMoveEditWindow(HWND hwnd, int nOffset);
void lcOrgEditWindow();

void draw_horz_header(HWND hwnd);
void draw_vert_header(HWND hwnd);
void draw_box0(HDC hdc, int, int, int, int);
void draw_box1(HDC hdc, int, int, int, int);

//  FUNCTION: WinMain(HINSTANCE, HINSTANCE, LPSTR, int)
//
//  PURPOSE: calls initialization function, processes message loop
//
//

int APIENTRY WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR     lpCmdLine,
    int       nCmdShow)
{
    MSG msg;

    // Other instances of app running?
    if (hPrevInstance)
    {
        return FALSE;                   // Exits if there is another instance
    } else {
        // Initialize shared things
        if (!InitApplication(hInstance))
            return FALSE;               // Exits if unable to initialize
    }

    // Perform initializations that apply to a specific instance
    if (!InitInstance(hInstance, nCmdShow))
        return FALSE;

    // Acquire and dispatch messages until a WM_QUIT message is received.
    while (GetMessage(&msg, NULL, 0, 0))
    {

       if(!lcTranslateMsg(&msg)) {

            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    // Returns the value from PostQuitMessage
    return (INT)(msg.wParam);
}


BOOL InitApplication(
    HINSTANCE hInstance)
{
    WNDCLASSEX wc;

    hCursorArrow = LoadCursor(NULL,IDC_ARROW);
    hCursorWait = LoadCursor(NULL, IDC_WAIT);

    // Fill in window class structure with parameters that describe the
    // main window.

    wc.cbSize        = sizeof(WNDCLASSEX);
    wc.style         = CS_DBLCLKS; //|CS_HREDRAW | CS_VREDRAW; // Class style(s).
    wc.lpfnWndProc   = (WNDPROC)WndProc;        // Window Procedure
    wc.cbClsExtra    = 0;                       // No per-class extra data.
    wc.cbWndExtra    = 0;                       // No per-window extra data.
    wc.hInstance     = hInstance;               // Owner of this class
    wc.hIcon         = LoadImage(hInstance,_TEXT("ALogIcon"),
        IMAGE_ICON, 32, 32, LR_DEFAULTCOLOR);

#ifdef UNICODE
    wc.hIconSm       = NULL;
#else
    wc.hIconSm       = LoadImage(hInstance,_TEXT("ALogIcon"),
        IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);
#endif
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW); // Cursor
    wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE + 1); // Light Gray color
    wc.lpszMenuName = _TEXT("LcToolMenu");
    wc.lpszClassName =LC_CLASS;

    // Register the window class and return FALSE if unsuccesful.

    if (!RegisterClassEx(&wc))
    {
        return FALSE;
    }

    wc.cbSize        = sizeof(WNDCLASSEX);
    wc.style         = CS_DBLCLKS; //|CS_HREDRAW | CS_VREDRAW; // Class style(s).
    wc.lpfnWndProc   = (WNDPROC)WndSubProc;        // Window Procedure
    wc.cbClsExtra    = 0;                       // No per-class extra data.
    wc.cbWndExtra    = 0;                       // No per-window extra data.
    wc.hInstance     = hInstance;               // Owner of this class
    wc.hIcon         = 0;
    wc.hIconSm       = 0;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW); // Cursor
    wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE + 1); // Light Gray color
    wc.lpszMenuName =  NULL,
    wc.lpszClassName = LC_SUBCLASS;

    if (!RegisterClassEx(&wc))
    {
        return FALSE;
    }

    wc.cbSize = sizeof(WNDCLASSEX);
    wc.style = 0;
    wc.lpfnWndProc = (WNDPROC)ClassDlgProc;
    wc.cbClsExtra    = 0;                       // No per-class extra data.
    wc.cbWndExtra = DLGWINDOWEXTRA;
    wc.hInstance = hInstance;
    wc.hIcon = 0;
    wc.hIconSm = 0;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE + 1);
    wc.lpszMenuName = NULL;
    wc.lpszClassName = _TEXT("PrivDlgClass");    
    if (!RegisterClassEx(&wc))
    {
		return FALSE;
	}

    return TRUE;
}


BOOL InitInstance(
    HINSTANCE hInstance,
    int nCmdShow)
{
    HWND       hwnd; // Main window handle.
    HDC        hDC;
    TEXTMETRIC tm;
    RECT       rect;
    TCHAR      szTitle[MAX_PATH];
    TCHAR      szFont[MAX_PATH];
    HFONT      hSysFont;
    LOGFONT    lfEditFont;
	UINT	   scrollCy, scrollCx;
	DWORD	   style;

    LoadString(hInstance, IDS_MAIN_TITLE,szTitle, sizeof(szTitle)/sizeof(TCHAR));
    hInst = hInstance; // Store instance handle in our global variable


    /* create fixed pitch font as default font */
    hSysFont=GetStockObject(SYSTEM_FIXED_FONT);
    GetObject(hSysFont, sizeof(LOGFONT), &lfEditFont);
    lfEditFont.lfWeight = 400;
	lfEditFont.lfHeight = 12;
    lfEditFont.lfWidth = lfEditFont.lfHeight/2;
    lfEditFont.lfPitchAndFamily = FIXED_PITCH | FF_MODERN;
    LoadString(hInstance, IDS_FONT_NAME,szFont, sizeof(szFont)/sizeof(TCHAR));
    lstrcpy(lfEditFont.lfFaceName, szFont);

    /* create the logical font */
    hFont = CreateFontIndirect(&lfEditFont);

    hDC = GetDC(NULL);
    SelectObject(hDC, hFont);
    GetTextMetrics(hDC, &tm);
    ReleaseDC(NULL, hDC);
    rect.top    = tm.tmHeight ;
    rect.left   = rect.top;
    CharWidth=tm.tmAveCharWidth;
    CharHeight=tm.tmHeight + 10;                                        
    line_height=CharHeight - 1; 

    iPage_line=rect.top*22/line_height;
    if(iPage_line > MAX_LINE)
        iPage_line=MAX_LINE;

    nWidth=rect.top*33;
    cyCaption = GetSystemMetrics(SM_CYCAPTION);
    cyMenu = GetSystemMetrics(SM_CYMENU);
    nHeight = line_height * iPage_line + CharHeight + cyCaption + cyMenu + 12; //3;

	cxHD1 = MulDiv(CharWidth * 2, 96, 72) * 2; // <== @E02
    //cxHD2 = nWidth - cxHD0 - cxHD1 + 1;
	cxHD2 = MulDiv(CharWidth * 2, 96, 72) * MAX_CHAR_NUM;

	scrollCy = GetSystemMetrics(SM_CYHSCROLL);
#ifndef UNICODE
	scrollCy += 2;
#endif
	scrollCx = GetSystemMetrics(SM_CXVSCROLL);
    // Create a main window for this application instance.
    style = (WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | 
                        WS_MINIMIZEBOX | WS_MAXIMIZEBOX); // & (~WS_VSCROLL),

    hwnd = CreateWindowEx(
            WS_EX_CLIENTEDGE,
            LC_CLASS,
            szTitle,
			style,
            rect.left,
            rect.top,
            nWidth,
            nHeight + scrollCy,
            HWND_DESKTOP,
            NULL,
            hInstance,
            NULL
           );

    // If window could not be created, return "failure"
    if (!hwnd)
        return FALSE;

    //InitCommonControls();

    hwndMain=hwnd;
    hMenu=GetMenu(hwnd);

    // Make the window visible; update its client area; and return "success"
    ShowWindow(hwnd, nCmdShow);         // Show the window
    // UpdateWindow(hwnd);                 // Sends WM_PAINT message

	// Reset the search phrase
	szPhrasestr[0] = 0;
    return TRUE;
}

LRESULT CALLBACK WndProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    HWND  hwndEdit;
    DWORD dw;                       /* return value from various messages     */
    UINT  EnableOrNot;              /* is something currently selected?       */
    TCHAR szTitle[MAX_PATH];
	TCHAR szMsg1[MAX_PATH];
	BOOL  bResult;

    switch (message) {
        case WM_COMMAND:

            if(HIWORD(wParam) == EN_SETFOCUS) {
                lcEditFocusOn(LOWORD(wParam));
                break;
            }

            switch (wParam) {
                case  IDM_SAVE:
                    SetCursor(hCursorWait);
#ifdef UNICODE
                    bResult = lcFSave(hwnd, FALSE);
#else
                    bResult = lcFSave(hwnd);
#endif
                    SetCursor(hCursorArrow);
					InvalidateRect(hwnd, NULL, TRUE);
					draw_vert_header(hwnd);

					if (bResult) {
						LoadString(hInst, IDS_APPNAME, szMsg1, sizeof(szMsg1));
#ifdef UNICODE
						LoadString(hInst, IDS_ACTIVATED, szTitle, sizeof(szTitle));
#else
						LoadString(hInst, IDS_WILLBEACTIVATED, szTitle, sizeof(szTitle));
#endif
						MessageBox(hwndMain, szTitle, szMsg1, MB_OK | MB_ICONEXCLAMATION);
					}
                    break;

#ifdef UNICODE
                case  IDM_SAVEAS:
                    SetCursor(hCursorWait);
                    bResult = lcFSave(hwnd, TRUE);
                    SetCursor(hCursorArrow);
					InvalidateRect(hwnd, NULL, TRUE);
					draw_vert_header(hwnd);

					if (bResult) {
						LoadString(hInst, IDS_APPNAME, szMsg1, sizeof(szMsg1));
						LoadString(hInst, IDS_WILLBEACTIVATED, szTitle, sizeof(szTitle));
						MessageBox(hwndMain, szTitle, szMsg1, MB_OK | MB_ICONEXCLAMATION);
					}
                    break;
#endif

                case  IDM_APPEND:                                        //@D01A
                    SetCursor(hCursorWait);                              //@D01A
                    lcAppend(hwnd);                                      //@D03C
                    SetCursor(hCursorArrow);                             //@D01A
                    break;                                               //@D01A

                case  IDM_IMPORT:
                   // Clear all flag first
                    SetCursor(hCursorWait);
                    lcImport(hwnd);
                    SetCursor(hCursorArrow);
					InvalidateRect(hwnd, NULL, TRUE);
                    break;

#ifdef UNICODE
                case  IDM_EXPORT2BIG5:
                    SetCursor(hCursorWait);
                    lcExport(hwnd,FILE_BIG5);
                    SetCursor(hCursorArrow);
                    break;
#endif		
                case  IDM_EXPORT:
                    SetCursor(hCursorWait);
#ifdef UNICODE
                    lcExport(hwnd,FILE_UNICODE);
#else
                    lcExport(hwnd);
#endif					
                    SetCursor(hCursorArrow);
                    break;

                case  IDM_PRINT:
                    {
                    int nRes;

                    nRes=lcPrint(hwnd);
                    SetCursor(hCursorArrow);
                    if(nRes != TRUE)
                        lcErrMsg(nRes);
                    }
                    break;

                case  IDM_EXIT :
                    if(!lcQuerySave(hwnd))
                        break;
                    DestroyWindow(hwnd);
                    return (TRUE);

                case  IDM_UNDO:
                    PostMessage( GetFocus(), WM_UNDO, 0, 0);
                    break;

                case  IDM_CUT:
                    PostMessage( GetFocus(), WM_CUT, 0, 0);
                    break;

                case  IDM_COPY:
                    PostMessage( GetFocus(), WM_COPY, 0, 0);
                    break;

                case  IDM_PASTE:
                    PostMessage( GetFocus(), WM_PASTE, 0, 0);
                    break;

                case  IDM_CLEAR:
                    PostMessage( GetFocus(), WM_CLEAR, 0, 0);
                    break;

                case IDM_DELETEL:
                    lcDelLine(hwnd);
					lcOrgEditWindow();
                    break;

                case  IDM_INSERTL:
                    lcInsLine(hwnd);
					lcOrgEditWindow();
                    break;

                case  IDM_SORT:
                    SetCursor(hCursorWait);
                    lcSort(hwnd);
                    SetCursor(hCursorArrow);
					lcOrgEditWindow();
					InvalidateRect(hwnd, NULL, TRUE);
					draw_vert_header(hwnd);
                    break;

                case  IDM_GOTO:
                    lcGoto(hwnd);
					lcOrgEditWindow();
                    SetScrollPos(subhWnd, SB_VERT, yPos, TRUE);
                    return ((LONG)TRUE);

                case  IDM_SEARCH:
                    lcSearch(hwnd, FALSE);
                    SetScrollPos(subhWnd, SB_VERT, yPos, TRUE);
					draw_vert_header(hwndMain);
                    return ((LONG)TRUE);

                case  IDM_SNEXT:
                    lcSearch(hwnd, TRUE);
                    SetScrollPos(subhWnd, SB_VERT, yPos, TRUE);
					draw_vert_header(hwndMain);
                    return ((LONG)TRUE);

                case  IDM_CHGSEQ:
                    lcChangeSequence(hwnd);
					InvalidateRect(hwnd, NULL, TRUE);
                    return ((LONG)TRUE);

                case IDM_ABOUT :
                    LoadString(hInst, IDS_MAIN_TITLE, szTitle, sizeof(szTitle));
                    ShellAbout(hwnd, szTitle,_TEXT(""), LoadIcon(hInst,_TEXT("ALogIcon")));
                    return ((LONG)TRUE);

                case IDM_HELP :
     //               if(!WinHelp(hwnd, HELPNAME, HELP_FINDER, 0L))
                      if ( !HtmlHelp(hwnd, HELPNAME, HH_DISPLAY_TOPIC, 0L) )
                        lcErrMsg(IDS_ERR_MEMORY);
                    return ((LONG)TRUE);

                case IDM_VSCROLL :
                    SetScrollPos(subhWnd, SB_VERT, yPos, TRUE);
                    return ((LONG)TRUE);
            }
            break;

        case WM_INITMENUPOPUP:          /* wParam is menu handle */

           // Check save file
            lcQueryModify(hwnd);

           /* Enable the 'Save' option if any modified */

            EnableMenuItem((HMENU)wParam, IDM_SAVE,
                (UINT)(bSaveFile ? MF_ENABLED : MF_GRAYED));
            EnableMenuItem((HMENU)wParam, IDM_SAVEAS,
                (UINT)(bSaveFile ? MF_ENABLED : MF_GRAYED));

            /* Find out if something is currently selected in the edit box */

            hwndEdit=GetFocus();
            dw = (DWORD)SendMessage(hwndEdit,EM_GETSEL,0,0L);
            EnableOrNot = (UINT)((HIWORD(dw) != LOWORD(dw) ? MF_ENABLED : MF_GRAYED));

            /* Enable / disable the Edit menu options appropriately */

            EnableMenuItem ((HMENU)wParam, IDM_UNDO ,
                (UINT)(SendMessage(hwndEdit,EM_CANUNDO,0,0L) ? MF_ENABLED : MF_GRAYED));
            EnableMenuItem ((HMENU)wParam, IDM_CUT  , EnableOrNot);
            EnableMenuItem ((HMENU)wParam, IDM_COPY , EnableOrNot);
            EnableMenuItem ((HMENU)wParam, IDM_PASTE,
                (UINT)(IsClipboardFormatAvailable(CF_TEXT) ? MF_ENABLED : MF_GRAYED));
            EnableMenuItem ((HMENU)wParam, IDM_CLEAR, EnableOrNot);

            break;

        case WM_CREATE:

            SendMessage (hwnd, WM_SETFONT, (WPARAM)hFont, 0);
            if(!lcInit(hwnd))
                PostMessage(hwnd, WM_CLOSE, 0, 0);
            break;

        case WM_SIZE:
            nWidth=LOWORD(lParam);
            nHeight=HIWORD(lParam);

			if (wParam != SIZE_MINIMIZED)
				lcResize(hwnd);
			return (DefWindowProc(hwnd, message, wParam, lParam));

        case WM_PAINT:
            lcPaint(hwnd);
            break;

        case WM_CLOSE:
            if(!lcQuerySave(hwnd))
                break;
            DestroyWindow(hwnd);
            break;

        case WM_DESTROY:
            PostQuitMessage(0);
            GlobalUnlock(hWord);
            GlobalUnlock(hPhrase);
            GlobalFree(hWord);
            GlobalFree(hPhrase);
            break;

		default:
            return (DefWindowProc(hwnd, message, wParam, lParam));

	}
    return TRUE;
}

BOOL lcInit(
    HWND hwnd)
{
    TCHAR  *pszFilterSpec;
    TCHAR  szStr[MAX_PATH];
    UINT   i;
    DWORD style = WS_VISIBLE | WS_CHILD | ES_LEFT;
	RECT rect;
	int scrollBarWidth, scrollCy;

    // style &= (~WS_BORDER);
	scrollBarWidth = GetSystemMetrics(SM_CXVSCROLL);

	GetClientRect(hwnd, &rect);
    cxHD2 = (rect.right - rect.left) - cxHD0 - cxHD1 + 1;
	cyHD = CharHeight - 1;
	scrollCy = GetSystemMetrics(SM_CYHSCROLL);

    subhWnd=CreateWindowEx(
				0,
                LC_SUBCLASS,
				NULL,
                (style | WS_HSCROLL | WS_VSCROLL), // | WS_BORDER), 
                cxHD0 + cxHD1 - 1, CharHeight,
                cxHD2 + 1, CharHeight + (iPage_line - 1) * line_height + scrollCy,
                hwnd,
                NULL,
                hInst,
                NULL
    );


   // Create EDIT CONTROL
    for(i=0; i<iPage_line; i++) 
	{

        hwndWord[i]=CreateWindowEx(
                     WS_EX_CLIENTEDGE,                      
                     _TEXT("EDIT"),
                     NULL,
                     style /*|ES_CENTER*/ | WS_BORDER, 
                     cxHD0, CharHeight+i*line_height,
                     cxHD1 - 1, CharHeight,
                     hwnd,
                     (HMENU)UIntToPtr( (IDE_WORD_START+i) ),
                     hInst,
                     NULL
                 );

        hwndPhrase[i]=CreateWindowEx( 
                    WS_EX_CLIENTEDGE,
                    _TEXT("EDIT"),
                    NULL,
                    style /*| ES_CENTER | ES_AUTOHSCROLL*/ | WS_BORDER,
                    -1, i*line_height,
                    MulDiv(CharWidth * 2, 96, 72) * MAX_CHAR_NUM,
					CharHeight,
                    subhWnd,
                    (HMENU)UIntToPtr( (IDE_PHRASE_START+i) ),
                    hInst,
                    NULL
                 );
        SendMessage(hwndWord[i], EM_SETLIMITTEXT, 2, 0);
        SendMessage(hwndPhrase[i], EM_SETLIMITTEXT, MAX_CHAR_NUM-1, 0);

        SendMessage(hwndWord[i], WM_SETFONT, (WPARAM)hFont,
            MAKELPARAM(TRUE, 0));
        SendMessage(hwndPhrase[i], WM_SETFONT, (WPARAM)hFont,
            MAKELPARAM(TRUE, 0));
    }
    hwndFocus=hwndWord[0];

   // Allocate global memory
    hWord = GlobalAlloc(GMEM_MOVEABLE, ALLOCBLOCK*sizeof(WORDBUF));
    if(!hWord) {
        lcErrMsg(IDS_ERR_MEMORY_QUIT);
        return FALSE;
    }
    nWordBuffsize = ALLOCBLOCK;
    lWordBuff = 0;
    lpWord = (LPWORDBUF)GlobalLock(hWord);
    if(!lpWord) {
        lcErrMsg(IDS_ERR_MEMORY_QUIT);
        return FALSE;
    }

    hPhrase = GlobalAlloc(GMEM_MOVEABLE, ALLOCBLOCK*sizeof(PHRASEBUF));
    if(!hPhrase) {
        GlobalFree(hWord);
        lcErrMsg(IDS_ERR_MEMORY_QUIT);
        return FALSE;
    }
    nPhraseBuffsize = ALLOCBLOCK;
    lPhraseBuff = 0;
    lpPhrase = (LPPHRASEBUF)GlobalLock(hPhrase);
    if(!lpPhrase) {
        GlobalFree(hWord);
        lcErrMsg(IDS_ERR_MEMORY_QUIT);
        return FALSE;
    }
    iFirstFree=NULL_SEG;

   // Read file to memory
    SetCursor(hCursorWait);
    lcFOpen(hwnd);
    SetCursor(hCursorArrow);
    if(lWordBuff == 0)
        lcInsLine(hwnd);

    iDisp_Top=0;
    yPos=0;
	xPos=0;
    bSaveFile=FALSE;

    SetScrollRange(subhWnd, SB_VERT, 0, lWordBuff-iPage_line, TRUE);
    SetScrollPos(subhWnd, SB_VERT, yPos, TRUE);

    SetScrollRange(subhWnd, SB_HORZ, 0, TOTALSCALE, TRUE);
    SetScrollPos(subhWnd, SB_HORZ, xPos, TRUE);

    lcSetEditText(iDisp_Top, TRUE);
    SetFocus(hwndWord[0]);

    if(!GetPrinterConfig(hwnd))
        lcErrMsg(IDS_PTRCONFIGFAILED);

   // Initial filter spec
    LoadString (hInst, IDS_FILTERSPEC, szFilterSpec, sizeof(szFilterSpec));
    LoadString (hInst, IDS_DEFAULTFILEEXT, szExt, sizeof(szExt));
    pszFilterSpec=szFilterSpec;
    pszFilterSpec+=lstrlen(pszFilterSpec)+1;
    lstrcpy(pszFilterSpec,szExt);
    LoadString (hInst, IDS_FILTERSPEC_ALL, szStr, sizeof(szStr));
    pszFilterSpec+=lstrlen(pszFilterSpec)+1;
    lstrcpy(pszFilterSpec,szStr);
    LoadString (hInst, IDS_ALLFILEEXT, szStr, sizeof(szStr));
    pszFilterSpec+=lstrlen(pszFilterSpec)+1;
    lstrcpy(pszFilterSpec,szStr);
    pszFilterSpec+=lstrlen(pszFilterSpec)+1;
    *pszFilterSpec=0;

    return TRUE;
}

LRESULT CALLBACK WndSubProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{

	int nOffset;

    switch (message) {
        case WM_CREATE:

            SendMessage (hwnd, WM_SETFONT, (WPARAM)hFont, 0);
            break;

        case WM_SETFOCUS:
            if(hwnd != hwndFocus)
                SetFocus(hwndFocus);
            break;

        case WM_VSCROLL:
            switch((int)LOWORD(wParam)){
                case SB_LINEUP   :
                    lcUp_key(GetFocus());
                    break;
                case SB_LINEDOWN :
                    lcDown_key(GetFocus());
                    break;
                case SB_PAGEUP   :
                    lcPgUp_key(GetFocus());
                    break;
                case SB_PAGEDOWN :
                    lcPgDown_key(GetFocus());
                    break;
                case SB_THUMBPOSITION :
                    yPos=HIWORD(wParam);
                    if(lWordBuff < iPage_line)
                        yPos=0;
                    if(((UINT)yPos) < iPage_line)
                        yPos=0;
                    if(!lcSetEditText(yPos, TRUE)) {
                        yPos=iDisp_Top;
                        break;
                    }
                    iDisp_Top=yPos;
                    break;
            } //switch(wParam)

            SetScrollPos(hwnd, SB_VERT, yPos, TRUE);
			draw_vert_header(hwndMain);

            break;

        case WM_HSCROLL:
			nOffset = 0;
            switch((int)LOWORD(wParam)){
                case SB_LINELEFT   :
					nOffset = -LINESHIFT;
                    break;
                case SB_LINERIGHT :
					nOffset = LINESHIFT;
                    break;
                case SB_PAGELEFT   :
					nOffset = -PAGESHIFT;
                    break;
                case SB_PAGERIGHT :
					nOffset = PAGESHIFT;
                    break;
                case SB_THUMBPOSITION :
                    nOffset=HIWORD(wParam) - xPos;
                    break;
            } //switch(wParam)
			if (xPos + nOffset < 0) nOffset = -xPos;
			if (xPos + nOffset > TOTALSCALE) nOffset = TOTALSCALE - xPos;
			xPos += nOffset;
            SetScrollPos(hwnd, SB_HORZ, xPos, TRUE);
			lcMoveEditWindow(hwnd, nOffset);
			break;

        case WM_CLOSE:
            DestroyWindow(hwnd);
            break;

        default:
            return (DefWindowProc(hwnd, message, wParam, lParam));
    }

    return 0;
}

void lcMoveEditWindow(
	HWND hwnd, int nOffset)
{
	RECT baseRect, rect;
	UINT i, nTotalWidth;

	GetWindowRect(hwnd, &baseRect);
#ifdef UNICODE
	nTotalWidth = MulDiv(CharWidth * 2, 96, 72) * MAX_CHAR_NUM;
#else
	nTotalWidth = MulDiv(CharWidth * 2, 72, 96) * MAX_CHAR_NUM;
#endif

    for(i=0; i<iPage_line; i++) 
	{
		GetWindowRect(hwndPhrase[i], &rect);

		rect.left -= baseRect.left;
		rect.top -= baseRect.top;

		rect.left -= MulDiv(nTotalWidth, nOffset, TOTALSCALE);
		if (rect.left > -1) rect.left = -1;
		if (xPos == 0) rect.left = -1;

		SetWindowPos(hwndPhrase[i], NULL, rect.left, rect.top, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
	}
}

void lcOrgEditWindow()
{
	UINT i;

	xPos = 0;
    SetScrollPos(subhWnd, SB_HORZ, xPos, TRUE);

    for(i=0; i<iPage_line; i++) 
	{
		SetWindowPos(hwndPhrase[i], NULL, -1, i*line_height, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
	}
}

void lcMoveEditWindowByWord(UINT nWords)
{
	RECT rect;
	UINT i, nTotalWidth, nOffset;

#ifdef UNICODE
	nTotalWidth = MulDiv(CharWidth * 2, 96, 72) * MAX_CHAR_NUM;
	nOffset = MulDiv(CharWidth, 96, 72) * nWords;
#else
	nTotalWidth = MulDiv(CharWidth * 2, 72, 96) * MAX_CHAR_NUM;
	nOffset = MulDiv(CharWidth, 72, 96) * nWords;
#endif

    for(i=0; i<iPage_line; i++) 
	{
		rect.left = -1;
		rect.top = i * line_height;

		rect.left -= nOffset;

		SetWindowPos(hwndPhrase[i], NULL, rect.left, rect.top, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
	}

	xPos = MulDiv(nOffset, TOTALSCALE, nTotalWidth);
    SetScrollPos(subhWnd, SB_HORZ, xPos, TRUE);
}


void lcResize(
    HWND hwnd)
{
    UINT   i;
    DWORD style = WS_VISIBLE | WS_CHILD | ES_LEFT;
	RECT rect;
	int  scrollBarWidth, scrollCy;
	int right, bottom;
	UINT iPage_line_old = iPage_line;

	static BOOL bResizePainted = TRUE;

	if (bResizePainted) {
		bResizePainted = FALSE;
		return;
	}
    // #53592 10/10/96 
    /*
    for(i=0; i<iPage_line; i++) 
	{
		DestroyWindow(hwndWord[i]);
		hwndWord[i] = 0;
		DestroyWindow(hwndPhrase[i]);
		hwndPhrase[i] = 0;
	}
    */
	iPage_line=nHeight/line_height;
    if(iPage_line > MAX_LINE)
        iPage_line=MAX_LINE;

    // #53592 10/10/96
    // Shrink, destroy extra edit control windows 
    if (iPage_line < iPage_line_old)
    {
       for(i=iPage_line; i<iPage_line_old; i++) 
	   {
		   DestroyWindow(hwndWord[i]);
		   hwndWord[i] = 0;
		   DestroyWindow(hwndPhrase[i]);
		   hwndPhrase[i] = 0;
	   }
    }

    nHeight = line_height * iPage_line + CharHeight + cyCaption + cyMenu+12 ;

	scrollBarWidth = GetSystemMetrics(SM_CXVSCROLL);
	scrollCy = GetSystemMetrics(SM_CYHSCROLL);
   
#ifndef UNICODE
	scrollCy += 2;
#endif

	right = nWidth + (2 * scrollBarWidth);
	bottom = nHeight + scrollCy;

	bResizePainted = TRUE;
	SetWindowPos(hwnd, NULL, 0, 0, right, bottom, SWP_NOMOVE | SWP_NOZORDER);

	GetClientRect(hwnd, &rect);
    cxHD2 = (rect.right - rect.left) - cxHD0 - cxHD1 + 1;
    right = cxHD2 + 1;
	bottom = CharHeight + (iPage_line - 1) * line_height + scrollCy;

	SetWindowPos(subhWnd, NULL, 0, 0, right, bottom, SWP_NOMOVE | SWP_NOZORDER);

	cyHD = CharHeight - 1;
     
    // #53592 10/10/96
    // Create extra EDIT CONTROL if needed
    for(i=iPage_line_old; i<iPage_line; i++) 
    {

        hwndWord[i]=CreateWindowEx(
                     WS_EX_CLIENTEDGE,                                  
                     _TEXT("EDIT"),
                     NULL,
                     style | WS_BORDER, 
                     cxHD0, CharHeight+i*line_height,
                     cxHD1-1, CharHeight,
                     hwnd,
                     (HMENU)UIntToPtr( (IDE_WORD_START+i) ),
                     hInst,
                     NULL
                 );

        hwndPhrase[i]=CreateWindowEx(
                     WS_EX_CLIENTEDGE,
                     _TEXT("EDIT"),
                     NULL,
                     style /*| ES_AUTOHSCROLL*/ | WS_BORDER,
                     -1, i*line_height,
	                 MulDiv(CharWidth * 2, 96, 72) * MAX_CHAR_NUM,
					 CharHeight,
                     subhWnd,
                     (HMENU)UIntToPtr( (IDE_PHRASE_START+i) ),
                     hInst,
                     NULL
                 );
        SendMessage(hwndWord[i], EM_SETLIMITTEXT, 2, 0);
        SendMessage(hwndPhrase[i], EM_SETLIMITTEXT, MAX_CHAR_NUM-1, 0);

        SendMessage(hwndWord[i], 
                    WM_SETFONT, 
                    (WPARAM)hFont,
                    MAKELPARAM(TRUE, 0));
        SendMessage(hwndPhrase[i], 
                    WM_SETFONT, 
                    (WPARAM)hFont,
                    MAKELPARAM(TRUE, 0));

    }

    hwndFocus=hwndWord[0];

    SetScrollRange(subhWnd, SB_VERT, 0, lWordBuff-iPage_line, TRUE);
    SetScrollPos(subhWnd, SB_VERT, yPos, TRUE);

	xPos = 0;
    SetScrollRange(subhWnd, SB_HORZ, 0, TOTALSCALE, TRUE);
    SetScrollPos(subhWnd, SB_HORZ, xPos, TRUE);

    lcSetEditText(iDisp_Top, TRUE);
    SetFocus(hwndWord[0]);

}

void draw_horz_header(HWND hwnd)
{
	HDC hdc = GetDC(hwnd);
	RECT rect, r0, r1, r2;
    TCHAR szStr[MAX_PATH];
	HFONT hOldFont;

	GetClientRect(hwnd, &rect);
	SetRect(&r0, 0, 0, cxHD0 - 1, cyHD);
	SetRect(&r1, cxHD0, 0, cxHD0 + cxHD1 - 1, cyHD);
	SetRect(&r2, cxHD0 + cxHD1, 0, rect.right - 1, cyHD);

	draw_box1(hdc, r0.left, r0.top, r0.right - 1, r0.bottom);
	draw_box1(hdc, r1.left, r1.top, r1.right, r1.bottom);
	draw_box1(hdc, r2.left, r2.top, r2.right, r2.bottom);

    SetBkColor(hdc, 0x00c0c0c0);        // Set Background color to Light gray

	r1.top += ((r1.bottom - r1.top - cyHD + 10) / 2);
	r2.top += ((r2.bottom - r2.top - cyHD + 10) / 2);

	hOldFont = SelectObject(hdc, hFont);
    LoadString(hInst, IDS_MAIN_WORD, szStr, sizeof(szStr)/sizeof(TCHAR));
    DrawText(hdc, szStr, lstrlen(szStr), &r1, DT_CENTER | DT_VCENTER);
    LoadString(hInst, IDS_MAIN_PHRASE, szStr, sizeof(szStr));
    DrawText(hdc, szStr, lstrlen(szStr), &r2, DT_CENTER | DT_VCENTER);
	SelectObject(hdc, hOldFont);

	ReleaseDC(hwnd, hdc);
}

void draw_vert_header(HWND hwnd)
{
	HDC hdc = GetDC(hwnd);
	RECT rect, r, r0;
    TCHAR szStr[MAX_PATH];
	UINT i;
	HFONT hOldFont;

	GetClientRect(hwnd, &rect);
	SetRect(&r0, 0, 0, cxHD0 - 1, cyHD);

    SetBkColor(hdc, 0x00c0c0c0);        // Set Background color to Light gray
	hOldFont = SelectObject(hdc, hFont);

	r0.top = r0.bottom + 2;
	r0.bottom = r0.top + cyHD - 1;
    for(i = 0; i < iPage_line; i++) 
	{
		draw_box1(hdc, r0.left, r0.top, r0.right, r0.bottom);

		r = r0;
		r.top += ((r.bottom - r.top - cyHD + 10) / 2);
		//r.top += ((r.bottom - r.top - cyHD + 5) / 2);
		wsprintf(szStr, _TEXT("%d "), iDisp_Top + i + 1);
	    DrawText(hdc, szStr, lstrlen(szStr), &r, DT_RIGHT);

		r0.top = r0.bottom + 1;
		r0.bottom = r0.top + cyHD - 1;
	}
	SelectObject(hdc, hOldFont);

	ReleaseDC(hwnd, hdc);
}

void DrawHeader(HWND hwnd)
{
	draw_horz_header(hwnd);
	draw_vert_header(hwnd);
}

void lcPaint(HWND hwnd)
{
    PAINTSTRUCT ps;                     // paint structure
    HDC   hDC;                          // display-context variable

    hDC = BeginPaint (hwnd, &ps);
    EndPaint(hwnd, &ps);

	DrawHeader(hwnd);
}

BOOL lcAllocWord()
{
    HANDLE hTemp;

    nWordBuffsize += ALLOCBLOCK;
    GlobalUnlock(hWord);
    hTemp= GlobalReAlloc(hWord, nWordBuffsize*sizeof(WORDBUF),
                         GMEM_MOVEABLE);

    if(hTemp == NULL) {
        nWordBuffsize -= ALLOCBLOCK;
        lcErrMsg(IDS_ERR_MEMORY);
        return FALSE;
    }
    hWord=hTemp;
    lpWord=(LPWORDBUF)GlobalLock(hWord);
    if(lpWord == NULL) {
        nWordBuffsize -= ALLOCBLOCK;
        lcErrMsg(IDS_ERR_MEMORY);
        return FALSE;
    }

    return TRUE;
}

BOOL lcAllocPhrase()
{
    HANDLE hTemp;

    nPhraseBuffsize += ALLOCBLOCK;
    GlobalUnlock(hPhrase);
    hTemp= GlobalReAlloc(hPhrase, nPhraseBuffsize*sizeof(PHRASEBUF),
                         GMEM_MOVEABLE);

    if(hTemp == NULL) {
        nPhraseBuffsize -= ALLOCBLOCK;
        lcErrMsg(IDS_ERR_MEMORY);
        return FALSE;
    }
    hPhrase=hTemp;
    lpPhrase=(LPPHRASEBUF)GlobalLock(hPhrase);
    if(lpPhrase == NULL) {
        nPhraseBuffsize -= ALLOCBLOCK;
        lcErrMsg(IDS_ERR_MEMORY);
        return FALSE;
    }

    return TRUE;
}

UINT lcGetSeg(
    )
{
    LPPHRASEBUF Phrase;
    UINT iFree;

    if(iFirstFree == NULL_SEG) {
       // If Allocated Phrase buffer not enough Reallocate it
        if(lPhraseBuff+1 == nPhraseBuffsize)
            if(!lcAllocPhrase())
                return(NULL_SEG);
        lpPhrase[lPhraseBuff].lNext_Seg=NULL_SEG;
        return(lPhraseBuff++);
    }
    iFree=iFirstFree;
    Phrase=&lpPhrase[iFirstFree];
    iFirstFree=Phrase->lNext_Seg;
    Phrase->lNext_Seg=NULL_SEG;
    return(iFree);
}

void lcFreeSeg(
    UINT iFree)
{
    LPPHRASEBUF Phrase;

    Phrase=&lpPhrase[iFree];
    while(Phrase->lNext_Seg!=NULL_SEG)
        Phrase=&lpPhrase[Phrase->lNext_Seg];
    Phrase->lNext_Seg=iFirstFree;
    iFirstFree=iFree;

}

BOOL lcTranslateMsg(
    MSG   *msg)
{
    USHORT uCtrl;
    USHORT uKeyState;
    UINT   i;

   // Process keystroke, for EDIT CONTROL
    if(msg->message == WM_CHAR) {
        if(msg->wParam == 0x09) {    // Tab key
            lcTab_key(msg->hwnd);
            return TRUE;
        }
    }
    if(msg->message == WM_KEYDOWN) {
        uCtrl=GetKeyState(VK_CONTROL);
        uKeyState=(uCtrl & STATE_ON) ? CTRL_STATE : 0;
        for(i=0; i<nFuncKey; i++) {
            if((lpFuncKey[i].uState == uKeyState) &&
               (lpFuncKey[i].wKey == msg->wParam)) {
                PostMessage( hwndMain, WM_COMMAND, lpFuncKey[i].wID, 0);
                return FALSE;
            }
        }
        if(lcKey(msg->hwnd, msg->wParam, uKeyState))
		{
			draw_vert_header(hwndMain);
            return TRUE;
		}
    }

    return FALSE;
}

void draw_box0(HDC hdc, int x1, int y1, int x2, int y2)
{
    RECT r = {x1, y1, x2, y2};
    HPEN hPen, hOldPen;
	HBRUSH hOldBr;
	POINT pt;

    hOldBr = SelectObject(hdc, GetStockObject(LTGRAY_BRUSH));
    hOldPen = SelectObject(hdc, GetStockObject(NULL_PEN));
	Rectangle(hdc, r.left, r.top, r.right, r.bottom);
    SelectObject(hdc, hOldPen);
    SelectObject(hdc, hOldBr);

    hPen = CreatePen(PS_SOLID, 1, RGB(128, 128, 128));
    if ( hPen )
    {
        hOldPen = SelectObject(hdc, hPen);
        MoveToEx(hdc, r.right, r.top, &pt);
        LineTo(hdc, r.left, r.top);
        LineTo(hdc, r.left, r.bottom);
        SelectObject(hdc, hOldPen);
        DeleteObject(hPen);
    }

    hOldPen = SelectObject(hdc, GetStockObject(WHITE_PEN));
    MoveToEx(hdc, r.right, r.top + 1, &pt);
    LineTo(hdc, r.right, r.bottom);
    LineTo(hdc, r.left + 1, r.bottom);
    SelectObject(hdc, hOldPen);
}

void draw_box1(HDC hdc, int x1, int y1, int x2, int y2)
{
    RECT r = {x1, y1, x2, y2};
    HPEN hPen, hOldPen;
	HBRUSH hOldBr;
	POINT pt;

    hOldBr = SelectObject(hdc, GetStockObject(LTGRAY_BRUSH));
    hOldPen = SelectObject(hdc, GetStockObject(NULL_PEN));
	Rectangle(hdc, r.left, r.top, r.right, r.bottom);
    SelectObject(hdc, hOldPen);
    SelectObject(hdc, hOldBr);

    hOldPen = SelectObject(hdc, GetStockObject(WHITE_PEN));
    MoveToEx(hdc, r.right, r.top, &pt);
    LineTo(hdc, r.left, r.top);
    LineTo(hdc, r.left, r.bottom);
    SelectObject(hdc, hOldPen);

    hPen = CreatePen(PS_SOLID, 1, RGB(128, 128, 128));
    
    if ( hPen )
    {
        hOldPen = SelectObject(hdc, hPen);
        MoveToEx(hdc, r.right, r.top + 1, &pt);
        LineTo(hdc, r.right, r.bottom);
        LineTo(hdc, r.left + 1, r.bottom);
        SelectObject(hdc, hOldPen);
        DeleteObject(hPen);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\lctool\lctool.h ===
/*************************************************
 *  lctool.h                                     *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

#define MAX_CHAR_NUM  1000
#define MAX_PHRASE_LEN 128
#define SEGMENT_SIZE  60
#define NULL_SEG      0xffff
#define MAX_LINE      19
#define CTRL_STATE    0x8000
#include <TCHAR.H>
#ifdef UNICODE
	typedef DWORD UNALIGNED FAR *LPUNADWORD;
	typedef WORD UNALIGNED FAR *LPUNAWORD;
	typedef TCHAR UNALIGNED FAR *LPUNATCHAR;
#else
	typedef DWORD FAR *LPUNADWORD;
	typedef WORD FAR *LPUNAWORD;
	typedef TCHAR FAR *LPUNATCHAR;
	#define TCHAR UCHAR
#endif

#define FILE_BIG5      0
#define FILE_UNICODE   1

// Global function prototypes.

// LCTOOL.C
LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK WndSubProc(HWND, UINT, WPARAM, LPARAM);
BOOL lcAllocWord();
BOOL lcAllocPhrase();
UINT lcGetSeg();
void lcFreeSeg(UINT);

// LCFILE.C
BOOL lcAppend(HWND);
BOOL lcFOpen(HWND);
#ifdef UNICODE
BOOL lcFSave(HWND, BOOL);
#else
BOOL lcFSave(HWND);
#endif
BOOL lcImport(HWND);

#ifdef UNICODE
BOOL lcExport(HWND,int);
#else
BOOL lcExport(HWND);
#endif

void lcQueryModify(HWND);
BOOL lcQuerySave(HWND);
void lcErrIOMsg(UINT, UCHAR *);

// LCFUNC.C
BOOL lcKey(HWND, WPARAM, USHORT);
BOOL lcTab_key(HWND);
void lcUp_key(HWND);
void lcDown_key(HWND);
void lcPgUp_key(HWND);
void lcPgDown_key(HWND);
void lcGoto(HWND);
void lcErrMsg(UINT);
BOOL lcSaveEditText(UINT, UINT);
BOOL lcSetEditText(UINT, BOOL);
void lcDelLine(HWND);
void lcInsLine(HWND);
BOOL lcSort(HWND);
UINT lcGetEditFocus(HWND, BOOL *);
BOOL is_DBCS(WORD, BOOL);
BOOL is_DBCS2(WORD, BOOL);
void lcEditFocusOn(WORD);
BOOL lcDisp2Mem(UINT, TCHAR *);
UINT lcMem2Disp(UINT, TCHAR *);
void lcChangeSequence(HWND hwnd);
void lcSearch(HWND hwnd, BOOL);

// LCPRINT.C
BOOL WINAPI GetPrinterConfig(HWND);
int  WINAPI lcPrint(HWND);
BOOL is_DBCS_1st(TCHAR *, int);


//-------------------------------------------------------------------------
// Global variable declarations.

HINSTANCE hInst;                        // The current instance handle
HANDLE    hwndMain;
HANDLE    hMenu;
HCURSOR   hCursorWait;
HCURSOR   hCursorArrow;

HWND      hwndWord[MAX_LINE];
HWND      hwndPhrase[MAX_LINE];
HWND      hwndFocus;
WORD      wOldID;
UINT      iPage_line;                   // Line number per page
UINT      iDisp_Top;
BOOL      bSaveFile;
WORD      wSameCode;
int       xPos, yPos;
TCHAR     szFilterSpec[MAX_PATH];
TCHAR     szExt[10];

//-------------------------------------------------------------------------
// Memory blobal variable declarations.
//
// Warning : iFirst_Seg & iNext_Seg store only SEGMENT number but address
//           for address can not mainten after GlobalRealloc
//
#ifdef UNICODE
typedef struct{
    DWORD   lFirst_Seg;
    TCHAR   wWord;
    } WORDBUF, FAR *LPWORDBUF;

typedef struct STRUCT_PHRASE{
    DWORD   lNext_Seg;
    TCHAR  szPhrase[SEGMENT_SIZE];
    } PHRASEBUF, FAR *LPPHRASEBUF;
#else
typedef struct{
    UINT   iFirst_Seg;
    WORD   wWord;
    } WORDBUF, FAR *LPWORDBUF;

typedef struct STRUCT_PHRASE{
    UINT   iNext_Seg;
    UCHAR  szPhrase[SEGMENT_SIZE];
    } PHRASEBUF, FAR *LPPHRASEBUF;
#endif

HANDLE      hWord;
#ifdef UNICODE
DWORD       nWordBuffsize;
DWORD       lWordBuff;
#else
UINT       nWordBuffsize;
UINT       iWordBuff;
#endif
LPWORDBUF   lpWord;

HANDLE      hPhrase;
#ifdef UNICODE
DWORD       nPhraseBuffsize;
DWORD       lPhraseBuff;
#else
UINT        nPhraseBuffsize;
UINT        iPhraseBuff;
#endif
LPPHRASEBUF lpPhrase;

UINT        iFirstFree;

//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\lctool\movelst.c ===
/*************************************************
 *  movelst.c                                    *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

#include <windows.h>            // required for all Windows applications
#include <windowsx.h>
#include <stdlib.h>
#include <memory.h>
#include <tchar.h>
#include <htmlhelp.h>
#include "rc.h"
#include "movelst.h"
#include "lctool.h"

#define HELPNAME      _TEXT("LCTOOL.CHM")
//Bug #19911 
//#define SEQHELPKEY	  _TEXT("r")

#define ID_TIMER 100
#define LINE_WIDTH 1

// style flags for the DrawIndicator() function
#define DI_TOPERASED        0x0001  // erasing a line drawn on the top of the list
#define DI_BOTTOMERASED     0x0002  // erasing a line drawn on the bottom of the list
#define DI_ERASEICON        0x0004  // erasing the icon

static UINT idTimer;            // the id for the timer used in scrolling the list
static HFONT hFont;             // a new font for the list box
static HCURSOR hCurDrag;        // a cursor to indicate dragging
static int nHtItem;             // the height of an individual item in the list box
static BOOL bNoIntegralHeight;  // does the list box have the LBS_NOINTEGRALHEIGHT style flag 

static HWND ghDlg;              // handle to the main window
static HWND ghList;             // handle to the list box     
static HBRUSH ghBrush;          // handle to the brush with the color of the windows background
static UINT iCurrentAddr;

void DrawIndicator(HDC hDC, int nYpos, int nWidth, WORD wFlags);
WNDPROC lpfnOldListProc, LstProc;      
BOOL lcRemoveDup( TCHAR *szBuf );
void lcOrgEditWindow();

BOOL lcDisp2Seq(
	HWND hDlg,
    UINT  iAddr,
    TCHAR *szDispBuf)
{
    UINT   i,j,len;
#ifdef UNICODE
	TCHAR  szPhrase[SEGMENT_SIZE * 2];
#else
	UCHAR  szPhrase[SEGMENT_SIZE * 2];
#endif
	int	   nRet;

    // remove duplicate phrase
    if(lcRemoveDup(szDispBuf) && iAddr < MAX_LINE){
		SendMessage(hwndPhrase[iAddr],WM_SETTEXT,0,
			        (LPARAM)(LPCTSTR)szDispBuf);
	}

    len=lstrlen(szDispBuf)+1;
    if((szDispBuf[len-1] == _TEXT(' ')) && (len > 1)) {
        szDispBuf[len-1]=0;
        len--;
    }
    if(len >= MAX_CHAR_NUM) { //tang must fix
        szDispBuf[MAX_CHAR_NUM-1]=0;
#ifndef UNICODE
        if(is_DBCS_1st(szDispBuf, MAX_CHAR_NUM-2))
             szDispBuf[MAX_CHAR_NUM-2]=' ';
#endif
        len=MAX_CHAR_NUM;
    }

	i = 0;
	j = 0;
    for(;;) {
		if (i == len - 1) {
			if (i - j + 1 > 0) {
			lstrcpyn(szPhrase, &szDispBuf[j], i - j + 1);
			SendDlgItemMessage(hDlg,IDD_SOURCELIST, 
                               LB_ADDSTRING,
                               0,
                               (LPARAM)(LPSTR)szPhrase);            
			}
			break;
		}
		if (szDispBuf[i] == ' ') {
			lstrcpyn(szPhrase, &szDispBuf[j], i - j + 1);
			nRet = (int)SendDlgItemMessage(hDlg,
				                       IDD_SOURCELIST, 
                                       LB_ADDSTRING,
                                       0,
                                       (LPARAM)(LPSTR)szPhrase);            
			j = i + 1;
		}
		i++;
    }
    return TRUE;
}


BOOL lcSeq2Disp(
	HWND hDlg,
    UINT  iAddr,
    TCHAR *szDispBuf)
{
	WORD nCount;
	TCHAR  szPhrase[SEGMENT_SIZE * 2];
	int    nRet;
	WORD   i;

	nCount = (int)SendDlgItemMessage(hDlg,IDD_SOURCELIST, LB_GETCOUNT,
                                       0, 0);
	if (nCount == LB_ERR)
		return FALSE;

	*szDispBuf = 0;
    for(i = 0; i < nCount; i++) {
		nRet = (int)SendDlgItemMessage(hDlg,
				                       IDD_SOURCELIST, 
                                       LB_GETTEXT,
                                       (WPARAM)i,
                                       (LPARAM)(LPSTR)szPhrase);
		if (nRet == LB_ERR)
			return FALSE;

		lstrcat(szDispBuf, szPhrase);
		lstrcat(szDispBuf, _TEXT(" "));
    }

	SendMessage(hwndPhrase[iAddr],WM_SETTEXT,0,
			        (LPARAM)(LPCTSTR)szDispBuf);
	SendMessage(hwndPhrase[iAddr], EM_SETMODIFY, TRUE, 0);

	return TRUE;
}

void lcChangeSequence(
    HWND hwnd)
{
    int  is_OK;
    BOOL  is_WORD;
	
    iCurrentAddr=lcGetEditFocus(GetFocus(), &is_WORD);
	is_OK=(INT)DialogBox(hInst,
            _TEXT("SEQDIALOG"),
            hwndMain,
            (DLGPROC)ActualDlgProc);

	if (is_WORD)
	    SetFocus(hwndWord[iCurrentAddr]);
	else
		SetFocus(hwndPhrase[iCurrentAddr]);

	if (is_OK) {
		bSaveFile = TRUE;
		lcSaveEditText(iDisp_Top, 0);
		lcOrgEditWindow();
	}
}

LRESULT CALLBACK ClassDlgProc(HWND hDlg, UINT message, WPARAM wParam , LPARAM lParam)
{
  
    return DefDlgProc(hDlg, message, wParam, lParam);
    
}      
       
LRESULT CALLBACK ActualDlgProc (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    TCHAR  szStr[MAX_CHAR_NUM];
	BOOL bRet;

    switch (message)
    {    
        case WM_INITDIALOG:
        {   
            LOGFONT lf;
            HMENU hSysMenu;  // handle to the system menu
            HDC hdc;         // a dc to find out the number of pixels per logcal inch            
            LOGBRUSH lb;
                
            lb.lbStyle = BS_SOLID;
            lb.lbColor = GetSysColor(COLOR_WINDOW);
            lb.lbHatch = 0;
                
            ghBrush = CreateBrushIndirect(&lb);
            
            hSysMenu = GetSystemMenu(hDlg, FALSE);                            
            // disable the "maximize" option in the system menu
            EnableMenuItem(hSysMenu, 4, MF_GRAYED|MF_DISABLED|MF_BYPOSITION); 
            // disable the "size" option of the system menu                   
            EnableMenuItem(hSysMenu, 2, MF_GRAYED|MF_DISABLED|MF_BYPOSITION); 

            SendMessage(hwndPhrase[iCurrentAddr], WM_GETTEXT, MAX_CHAR_NUM-1, (LPARAM)szStr);
			lcDisp2Seq(hDlg, iCurrentAddr, szStr);
                
            ghList = GetDlgItem(hDlg, IDD_SOURCELIST);  
            LstProc = MakeProcInstance(NewListProc,hInst);
            lpfnOldListProc = (WNDPROC)SetWindowLongPtr(ghList,
                                            GWLP_WNDPROC, 
                                            (LONG_PTR)LstProc);
                                                     
            // check to see if it has integral height
            bNoIntegralHeight = FALSE;
            hdc = GetDC(hDlg);        
            memset(&lf, 0, sizeof(lf));        
            lf.lfHeight = -MulDiv(9, 96, 72);
            lstrcpy(lf.lfFaceName, _TEXT("MS Sans Serif"));
            hFont = CreateFontIndirect(&lf);
            ReleaseDC(hDlg, hdc);            
            SendMessage(ghList, WM_SETFONT, (WPARAM)hFont, (LPARAM)FALSE);
            // the drag cursor
            hCurDrag = LoadCursor(hInst, _TEXT("IDC_DRAG"));       
            
            return FALSE;   // didn't set the focus
        }                                                
        break;
        case WM_COMMAND:
            switch (wParam)
            {
                case IDCANCEL:            
                  EndDialog(hDlg, FALSE);            
                  break; 
                case IDOK:
		  bRet = lcSeq2Disp(hDlg, iCurrentAddr, szStr);
                  EndDialog(hDlg, bRet);            
	          break;                               
		case ID_HELP:
                  LoadString(hInst, IDS_CHANGEWORDORDER, szStr, sizeof(szStr)/sizeof(TCHAR));
//      		  WinHelp(hDlg, HELPNAME, HELP_PARTIALKEY, (DWORD)szStr);
                  HtmlHelp(hDlg, HELPNAME, HH_DISPLAY_TOPIC, 0L);
		  break;
             }                   
	     return TRUE;

        case WM_DESTROY: // clean up
        {
            DeleteObject(ghBrush);
            DeleteObject(hFont);
            DestroyCursor(hCurDrag);                         
        }
        break;                           
     default:
        return FALSE; // we didn't do anyting        
    } // end switch message
    return TRUE; // we did the processing

}                           

LRESULT CALLBACK NewListProc(HWND hwndList, 
                                     UINT message, 
                                     WPARAM wParam, 
                                     LPARAM lParam)
{
    
    static BOOL bTracking = FALSE;
    static BOOL bDrag = FALSE;  
    static HCURSOR hCursorOld = NULL;
    

    
    switch (message)
    {    
      case WM_CANCELMODE:
       // WM_CANCELMODE is sent to the window that has captured the mouse before
       // a message box or modal dialog is displayed. If we were dragging the item
       // cancel the drag.
       bTracking = FALSE;
       ReleaseCapture();
       if (bDrag)
          SetCursor(hCursorOld);    
       break; 
      case WM_LBUTTONDOWN:
      {
        
        // Was the list box item dragged into the destination?        
        BOOL bDragSuccess = FALSE;  
        MSG msg;
        POINTS pts;      
        POINTS points;
        POINT pt;      
        POINT point;
        
        RECT rectIsDrag;            // Rectangle to determine if dragging has started.  
        int nOldPos;
        
        int nOldY = -1;                            // the last place that we drew on
        HDC hdc;   // dc to draw on  
        div_t divt;                            // get remainder a quotient with "div"   
        int nCount;
        div_t divVis;          
// space for scroll bar -  starts off at 1 so we don't overwrite the border
        int dxScroll = 1;      
        RECT rect;   
        int nVisible;                   // the number of items visible
        int idTimer;                    // id for the timer
        int nNewPos;                    // the new position
        int nTopIndex;                  // the top index        
        
        
        
         
         GetWindowRect(hwndList, &rect);        
           
         // Pass the WM_LBUTTONDOWN to the list box window procedure. Then
         // fake a WM_LBUTTONUP so that we can track the drag.
         CallWindowProc(lpfnOldListProc, hwndList, message, wParam, lParam);
         
         // the number of items in the list box
         nCount = (int)SendMessage(hwndList, LB_GETCOUNT,0,0L);         
         if (nCount == 0 ) // don't do anything to and empty list box
            return 0;         
        // fake the WM_LBUTTONUP            
         CallWindowProc(lpfnOldListProc, hwndList, WM_LBUTTONUP, wParam, lParam);        
         // get a dc to draw on
         hdc = GetDC(hwndList);                               
         
         // the height of each item   
         nHtItem = (int)SendMessage(hwndList, LB_GETITEMHEIGHT,0,0L);          
         // the current item
         nOldPos = (int)SendMessage(hwndList, LB_GETCURSEL,0,0L);    
         
         divVis = div((rect.bottom - rect.top), nHtItem);
// the number of visible items                  
         nVisible = divVis.quot;
// some items are invisible - there must be scroll bars - we don't want
// to draw on them         
         if (nVisible < nCount)                                         
            dxScroll = GetSystemMetrics(SM_CXVSCROLL) + 1; 
            
         idTimer = 0;
         idTimer = (UINT)SetTimer(hwndList, ID_TIMER,100,NULL);  
        
              
     // Create a tiny rectangle to determine if item was dragged or merely clicked on.
     // If the user moves outside this rectangle we assume that the dragging has
     // started.
         points = MAKEPOINTS(lParam);        
		 point.x = points.x; point.y = points.y;
         SetRect(&rectIsDrag, point.x, point.y - nHtItem / 2,
                               point.x, point.y + nHtItem / 2); 
                               
                                          
         bTracking = TRUE;         
         SetCapture(hwndList);
         
         
         // Drag loop                      
         while (bTracking)
         {  
        // Retrieve mouse, keyboard, and timer messages. We retrieve keyboard
        // messages so that the system queue is not filled by keyboard messages
        // during the drag (This can happen if the user madly types while dragging!)
        // If none of these messages are available we wait. Both PeekMessage() 
        // and Waitmessage() will yield to other apps.   
                                      
            while (!PeekMessage(&msg, NULL, WM_MOUSEFIRST, WM_MOUSELAST, PM_REMOVE)
                   && !PeekMessage(&msg, NULL, WM_KEYFIRST, WM_KEYLAST, PM_REMOVE)
                   && !PeekMessage(&msg, NULL, WM_TIMER, WM_TIMER, PM_REMOVE)) 
               WaitMessage();
           switch(msg.message)
            {
               case WM_MOUSEMOVE:
               {
                  pts = MAKEPOINTS(msg.lParam);
				  pt.x = pts.x; pt.y = pts.y;
                  if (!bDrag)
                  {
                     // Check if the user has moved out of the Drag rect. 
                     // in the vertical direction.  This indicates that 
                     // the drag has started.
                     if ( (pt.y > rectIsDrag.bottom) || 
                          (pt.y < rectIsDrag.top)) // !PtInRect(&rectIsDrag,pt))
                     {
                        hCursorOld = SetCursor(hCurDrag);      
                        bDrag = TRUE;     // Drag has started                           
                        
                     }
                  }
                          
                          
                  if (bDrag)
                  {  
  
                    SetCursor(hCurDrag);  
   // if we are above or below the list box, then we are scrolling it, and
   // we shouldn't be drawing here              
                    ClientToScreen(hwndList, &pt);
                    if ((pt.y >= rect.top) && (pt.y <= rect.bottom))
                    {
                        // convert the point back to client coordinates
                        ScreenToClient(hwndList, &pt);
                        divt = div(pt.y,nHtItem);                        
                                
                        // if we are half way to the item
                        // AND it is a new item
                        // AND we are not past the end of the list..                        
                        if ( divt.rem < nHtItem / 2 && 
                             (nOldY != nHtItem * divt.quot) && 
                             (divt.quot < nCount + 1)) 
                        {
                              
                           if (nOldY != -1)
                            {
                                // erase the old one                                
                                DrawIndicator(hdc, nOldY,(rect.right - rect.left) - dxScroll, DI_ERASEICON);
                            }  
                                    
                            nOldY = nHtItem * divt.quot;                            
                            DrawIndicator(hdc, nOldY,(rect.right - rect.left) - dxScroll, 0);                                                        
                                    
                        }
                     } // end if in the list box window                        
                            
                  } // end if bDrag
                            
               }
              break;                   
              case WM_TIMER:
               {
                  POINT pt;                  
                  GetCursorPos(&pt); 
                  nTopIndex = (int)SendMessage(hwndList, LB_GETTOPINDEX,0,0L);;                                      
                  if (pt.y < rect.top) // scroll up
                  {
                           
                       if (nTopIndex > 0)
                       {
                                
                            nTopIndex--;
                            SendMessage(hwndList, LB_SETTOPINDEX, nTopIndex,0L);
                         // when you scroll up, the line always stays on the top index                            
                         // erase the one we've moved down
                            DrawIndicator(hdc, nHtItem,(rect.right - rect.left) - dxScroll, DI_TOPERASED|DI_ERASEICON);
                         // draw the new one          
                            DrawIndicator(hdc, 0,(rect.right - rect.left) - dxScroll, 0);                                                             
                         // the new one was drawn at y = 0 
                           nOldY = 0;                           
                           
                       }                  
                      
                  }
                  else if (pt.y > rect.bottom) // scroll down
                  {                       
                       // if the number of visible items (ie seen in the list box)
                       // plus the number above the list is less than the total number
                       // of items, then we need to scroll down
                        if (nVisible + nTopIndex < nCount)
                        {                                
                            
                            if (nOldY - nTopIndex != nVisible)
                            {
                        // if them move below the list REALLY REALLY FAST, then
                        // the last line will not be on the bottom - so we want to reset the last
                        // line to be the bottom                            
                                
                                // erase the old line
                                DrawIndicator(hdc, nOldY,(rect.right - rect.left) - dxScroll, DI_ERASEICON);                                       
                                // reset the index
                                divt.quot = nVisible;
                                nOldY = divt.quot * nHtItem;                            
                                // draw the new line
                                DrawIndicator(hdc, nOldY,(rect.right - rect.left) - dxScroll, 0);                                       
                                
                                
                            }
                        // scroll up
                            nTopIndex++;
                            SendMessage(hwndList, LB_SETTOPINDEX, nTopIndex,0L);
                        
                       // erase the line that has moved up.. 
                            DrawIndicator(hdc, nOldY - nHtItem,(rect.right - rect.left) - dxScroll, DI_BOTTOMERASED|DI_ERASEICON);
                        // draw the new one
                            DrawIndicator(hdc, nOldY,(rect.right - rect.left) - dxScroll, 0);
                           
                        }
                      
                  }               
               }
               break;
               case WM_LBUTTONUP: 
                  // End of Drag                             
                        
                  nTopIndex = (int)SendMessage(hwndList, LB_GETTOPINDEX, 0, 0L);                  
                  if (bDrag) 
                  {                        
                    // get rid of any line we've drawn - the position of the line 
                    // divided by the height of the itme is where our new index
                    // is going to be                    
                    DrawIndicator(hdc, nOldY,(rect.right - rect.left) - dxScroll, DI_ERASEICON);
                    
                    nNewPos = (nOldY / nHtItem) + nTopIndex;                     
                    // the old position can't equal the new one                                        
                    if (nNewPos != nOldPos)
                        bDragSuccess = TRUE;
                  }
                  bTracking = FALSE;                  
                  break;                     
               default:
                  // Process the keyboard messages
                 TranslateMessage(&msg);
                 DispatchMessage(&msg);
                break;      
          }          
       }// end while bTracking
        
         ReleaseCapture();
         if (bDrag)
         {
                SetCursor(hCursorOld);
                // move the item
                if (bDragSuccess) 
                {
                    int nIndex;       
                    char s[256];  
                    
                    
                // we need to store the top index, because deleting and adding a new
                // string will change it, and we want to be able to see the item that 
                // we have moved
                    nTopIndex = (int)SendMessage(hwndList, LB_GETTOPINDEX,0,0L);                    
                    // stop most of the blinking..
                    SendMessage(hwndList, WM_SETREDRAW, FALSE,0L);
                    // get the text of the item - limited to 256 chars!
                    SendMessage(hwndList, LB_GETTEXT, nOldPos, (LPARAM)(LPSTR)s); 
                    
/*------------------------------------------------------------------------
 | strategy:  given ABCD and moving to BCAD do the following:
 |
 |           1. delete A -- giving BCD
 |           2. insert A -- giving BCAD
 |           3. hilite A
 |           4. set the top index so A is visible
 -------------------------------------------------------------------------*/                                    
                    // delete the original string
                    SendMessage(hwndList, LB_DELETESTRING, nOldPos, 0L);
                    
// if we've moved DOWN the list subtract one from the new index 
// (because we've deleted a string but if we are moving UP the list, 
// we don't subtract anything (the deleted item is below the new item, 
// so our new index hasn't changed
                     
                    if (nNewPos > nOldPos)
                        nNewPos--;                                   
                    // put it in the new pos       
                     nIndex = (int)SendMessage(hwndList,
                                               LB_INSERTSTRING, 
                                               nNewPos,
                                               (LPARAM)(LPSTR)s);  
                    
                    SendMessage(hwndList, LB_SETCURSEL, nIndex, 0L);                            
                    SendMessage(hwndList, LB_SETTOPINDEX, nTopIndex,0L);                    
                    SendMessage(hwndList, WM_SETREDRAW, TRUE,0L);                 
                            
                } // end if bDragSuccess                  
          } // end if bDrag
      bDrag = FALSE;    
      ReleaseDC(hwndList, hdc);
      KillTimer(hwndList, idTimer);    
    } 
    break;
    default:
      return  CallWindowProc(lpfnOldListProc, hwndList, message, wParam, lParam);
   }
   return 0;
}     

LRESULT CALLBACK AboutDlgProc (HWND hDlg, UINT message,  
                                       WPARAM wParam, LPARAM lParam)
{

    switch (message)
    {
        case WM_INITDIALOG:
            return (TRUE);
        case WM_COMMAND:
            if (wParam == IDOK)
            {
                EndDialog(hDlg, TRUE);
                return (TRUE);
            }
            break;
    }
    return (FALSE);

}

void DrawIndicator(HDC hDC, int nYpos, int nWidth, WORD wFlags)
{      

// draw a horizontal line     
    int nTop, nHeight;   
    HICON hIcon;   
    HRGN hClipRgn;                 // the clipping region    
    RECT rect;    

// we don't want the clip anything when we are drawing
// the icon outside the list box
    SelectClipRgn(hDC, NULL);    
   if (wFlags & DI_ERASEICON)
   {      
      rect.left = -33;
      rect.right = -1;
      rect.top = nYpos -16;
      rect.bottom = nYpos + 16;   
      // ghBrush is created in WM_INITDIALOG   
      FillRect(hDC, &rect, ghBrush);
        
   }
   else
   {
        
       hIcon = LoadIcon(hInst, _TEXT("IDI_ARROW")); 
       if (hIcon)
       {
           DrawIcon(hDC,-33,nYpos - 16,hIcon);
           DestroyIcon(hIcon);
        }
   }
   
    
// create a clipping region for drawing the lines in the list box
     GetWindowRect(ghList, &rect);         
     hClipRgn = CreateRectRgn(0,0, rect.right - rect.left, rect.bottom - rect.top);
     if ( hClipRgn )
     {
         SelectClipRgn(hDC, hClipRgn);
         // we can delete it emmdiately because SelectClipRgn makes a COPY of the region
         DeleteObject(hClipRgn); 
     }
    
    
/****************************************************

  erasing something drawn on top
  the top is drawn like 
  
   ______              |_____|
  |      |  instead of |     |
  
  so we want to NOT draw the two vertical lines
  above the horzontal

*****************************************************/    
  // if (nYpos = 0) wFlags |= DI_TOPERASED;
    if (wFlags & DI_TOPERASED) 
    {
        nTop = nYpos;
        nHeight = nHtItem / 4;
    }     
/****************************************************

  erasing something originally drawn on the bottom
  
  if the list box is NOT LBS_NOINTEGRALHEIGHT, then
  the botton line will be on the border of the list
  box, so we don't want to draw the horizontal line at  
  all, ie we draw
  
  |    |           |_____|
        instead of |     |  
   

*****************************************************/     
    else if (wFlags & DI_BOTTOMERASED && !bNoIntegralHeight)
    {    
        nTop = nYpos - nHtItem / 4;                              
        nHeight = nHtItem / 4;        
    } 
    
    else
    {
        nTop = nYpos - nHtItem / 4;                          
        nHeight =  nHtItem / 2;        
    }
    
   if (!(wFlags & DI_BOTTOMERASED && !bNoIntegralHeight)) // see above comment     
   {        
        PatBlt(hDC,
               LINE_WIDTH,
               nYpos,
               nWidth - 2 * LINE_WIDTH,
               LINE_WIDTH,
               PATINVERT);   
    }           
    PatBlt(hDC,
           0,
           nTop,
           LINE_WIDTH,
           nHeight , 
           PATINVERT);                  
            
    PatBlt(hDC,
           nWidth - LINE_WIDTH,
           nTop, 
           LINE_WIDTH,
           nHeight,
           PATINVERT);    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\lctool\rc.h ===
/*************************************************
 *  rc.h                                         *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Lctool.rc
//
// Change log : 1/15/1996
//
//      @C004 - Add IDS_WILLBEACTIVATED
//
//
#define IDM_NEW                         101
#define IDS_APPNAME                     101
#define IDM_OPEN                        102
#define IDS_DESCRIPTION                 102
#define IDM_SAVE                        103
#define IDS_MAIN_TITLE                  103
#define IDM_SAVEAS                      104
#define IDS_MAIN_WORD                   104
#define IDM_IMPORT                      105
#define IDS_MAIN_PHRASE                 105
#define IDM_EXPORT                      106
#define IDS_FILEMODIFIED                106
#define IDM_PRINT                       107
#define IDS_FILTERSPEC                  107
#define IDM_SETUP                       108
#define IDS_DEFAULTFILEEXT              108
#define IDM_EXIT                        109
#define IDS_FILTERSPEC_ALL              109
#define IDM_APPEND                      110
#define IDS_ALLFILEEXT                  110
#define IDM_EXPORT2BIG5                 111
#define IDS_IMPORTTITLE                 111
#define IDS_EXPORTTITLE                 112
#define IDS_FONT_NAME                   113
#define IDS_APPENDTITLE                 114
#define IDS_ACTIVATED                   115
#define IDS_EXPORTBIG5TITLE             116
#define IDS_DICTFILTERSPEC              117
#define IDS_DICTDEFAULTFILEEXT          118
#define IDS_SAVETABLE                   119
#define IDS_WILLBEACTIVATED             120 // @C004
#define IDS_ERR_MEMORY_QUIT             200
#define IDM_UNDO                        201
#define IDS_ERR_MEMORY                  201
#define IDM_CUT                         202
#define IDS_ERR_NOT_FOUND               202
#define IDM_COPY                        203
#define IDS_ERR_SBCS                    203
#define IDM_PASTE                       204
#define IDS_ERR_LCPTRFILE               204
#define IDM_CLEAR                       205
#define IDS_ERR_SAMECODE                205
#define IDM_DELETEL                     206
#define IDS_ERR_FILESAVE                206
#define IDM_INSERTL                     207
#define IDS_ERR_OPENBOTH                207
#define IDS_ERR_FILEOPEN                208
#define IDS_ERR_FILEREAD                209
#define IDS_ERR_FILEWRITE               210
#define IDS_ERR_OVERMAX                 211
#define IDS_ERR_IMP_SEPRATOR            212
#define IDS_ERR_IMP_NOPHRASE            213
#define IDS_ERR_INPUTSAME               214
#define IDS_ERR_OVER_MAXLEN             215
#define IDS_ERR_SAVESYSTEMTBL           216
#define IDS_ERR_PHRASE_NOT_FOUND        217
#define IDM_SORT                        301
#define IDS_HELP                        301
#define IDM_GOTO                        302
#define IDM_SEARCH                      303
#define IDM_SNEXT                       304
#define IDM_HELP                        401
#define IDS_PTRCOMMDLGFAILED            401
#define IDM_ABOUT                       402
#define IDS_CANCELDLGFAILED             402
#define IDS_SETABORTPROCFAILED          403
#define IDS_STARTDOCFAILED              404
#define IDS_PRINTABORTED                405
#define IDS_PTRCONFIGFAILED             406
#define IDS_PRINTING                    407
#define IDS_PRINTINGTITLE               408
#define IDS_OVERPHRASELEN               409
#define IDS_CHANGEWORDORDER             410
    
#define IDM_VSCROLL                     501
#define IDM_CHGSEQ                      502
#define IDE_WORD_START                  1000
#define IDE_PHRASE_START                1100
#define IDB_OK                          2001
#define IDB_CANCEL                      2002
#define IDD_INDEX_NAME                  3000
#define IDD_EDIT_HELP                   3001
#define IDC_PRINTTITLE                  4000
#define IDC_PRINTDEVICE                 4001
#define IDC_PRINTPORT                   4002
#define IDC_PRINTLINE                   4003
#define IDD_FROM_LINE                   5000
#define IDD_TO_LINE                     5001
#define IDD_SOURCELIST                  5002
#define ID_HELP                         3
#define IDD_SEARCH_LINE                 1000

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\uimetool\imeattr.h ===
/*************************************************
 *  imeattr.h                                    *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

#if !defined(ROMANIME)
// the mode configuration for an IME
#define MODE_CONFIG_QUICK_KEY           0x0001
#define MODE_CONFIG_PREDICT             0x0004

#endif

#define MODE_CONFIG_OFF_CARET_UI        0x0008

#if defined(PHON)
// the different layout for Phonetic reading
#define READ_LAYOUT_DEFAULT             0
#define READ_LAYOUT_ETEN                1
#define READ_LAYOUT_IBM                 2
#define READ_LAYOUT_CHINGYEAH           3
#if defined(ETEN)
            // ETen told us 26 Keys is ETen's Copy Right.
            // So we can not implement it, even though we already finish it
            // without reference any code of ETen.
            // My implementation could compose single po, cur, yeah, & ay.
            // It is different from ETen's user manual.
#define READ_LAYOUT_ETEN26              4
#define READ_LAYOUTS                    5
#else
#define READ_LAYOUTS                    4
#endif
#endif


// the bit of fwProperties1
#define IMEPROP_CAND_NOBEEP_GUIDELINE   0x0001
#define IMEPROP_UNICODE                 0x0002


#if !defined(WINIME) && !defined(ROMANIME)
#define USR_DIC_SIZE    160

typedef struct tagUsrDic {
    TCHAR szUsrDic[USR_DIC_SIZE/sizeof(TCHAR)];
} USRDIC;

typedef USRDIC      *PUSRDIC;
typedef USRDIC NEAR *NPUSRDIC;
typedef USRDIC FAR  *LPUSRDIC;
#endif

#define MAX_NAME_LENGTH         32

#if !defined(ROMANIME)

#if defined(UNIIME) || defined(MINIIME)
#define MAX_IME_TABLES          6
#else
#define MAX_IME_TABLES          4
#endif

typedef struct tagTableFiles {  // match with the IMEL
    TCHAR szTblFile[MAX_IME_TABLES][MAX_NAME_LENGTH / sizeof(TCHAR)];
} TABLEFILES;

typedef TABLEFILES      *PTABLEFILES;
typedef TABLEFILES NEAR *NPTABLEFILES;
typedef TABLEFILES FAR  *LPTABLEFILES;


typedef struct tagValidChar {   // match with the IMEL
    DWORD dwVersion;
    WORD  fwProperties1;
    WORD  fwProperties2;
    WORD  nMaxKey;
    WORD  nSeqCode;
    WORD  fChooseChar[6];
    WORD  wReserved1[2];
#if defined(DAYI) || defined(UNIIME) || defined(MINIIME)
    BYTE  cChooseTrans[0x60];
#endif
    WORD  fCompChar[6];
    WORD  wReserved2[2];
    WORD  wCandPerPage;
    WORD  wCandStart;
    WORD  wCandRangeStart;
    WORD  wReserved3[1];
    WORD  wSeq2CompTbl[64];
    WORD  wChar2SeqTbl[0x42];
    WORD  wReserved4[2];
#if defined(WINAR30)
    WORD  wSymbol[10][4];
#elif defined(DAYI)
    WORD  wSymbol[340];
#elif defined(UNIIME) || defined(MINIME)
    DWORD dwReserved5[32];
#endif
} VALIDCHAR;

typedef VALIDCHAR      *PVALIDCHAR;
typedef VALIDCHAR NEAR *NPVALIDCHAR;
typedef VALIDCHAR FAR  *LPVALIDCHAR;
#endif // !defined(ROMANIME)


typedef struct tagImeL {        // local structure, per IME structure
// interlock protection variables
    LONG        lConfigGeneral;
    LONG        lConfigRegWord;
    LONG        lConfigSelectDic;
    TCHAR       szIMEName[MAX_NAME_LENGTH / sizeof(TCHAR)];
    TCHAR       szUIClassName[MAX_NAME_LENGTH / sizeof(TCHAR)];
    TCHAR       szStatusClassName[MAX_NAME_LENGTH / sizeof(TCHAR)];
    TCHAR       szOffCaretClassName[MAX_NAME_LENGTH / sizeof(TCHAR)];
    TCHAR       szCMenuClassName[MAX_NAME_LENGTH / sizeof(TCHAR)];
// Configuration of the IME
    DWORD       fdwModeConfig;  // quick key/prediction mode
// status window
    int         xStatusWi;      // width of status window
    int         yStatusHi;      // high of status window
    int         cxStatusBorder; // border width of status window
    int         cyStatusBorder; // border height of status window
    RECT        rcStatusText;   // text position relative to status window
    RECT        rcInputText;    // input text relateive to status window
    RECT        rcShapeText;    // shape text relative to status window
#if defined(ROMANIME)
    WORD        nMaxKey;        // max key of a Chinese word
    WORD        wDummy;         // DWORD bounary
#else
    int         xCompWi;        // width
    int         yCompHi;        // height
    int         cxCompBorder;   // border width of composition window
    int         cyCompBorder;   // border height of composition window
    RECT        rcCompText;     // text position relative to composition window
// candidate list of composition
    int         xCandWi;        // width of candidate list
    int         yCandHi;        // high of candidate list
    int         cxCandBorder;   // border width of candidate list
    int         cyCandBorder;   // border height of candidate list
    int         cxCandMargin;   // interior border width of candidate list
    int         cyCandMargin;   // interior border height of candidate list
    RECT        rcCandText;     // text position relative to candidate window
    RECT        rcCandPrompt;   // candidate prompt bitmap
    RECT        rcCandPageText; // candidate page controls - up / home / down
    RECT        rcCandPageUp;   // candidate page up
    RECT        rcCandHome;     // candidate home page
    RECT        rcCandPageDn;   // candidate page down
    TCHAR       szCompClassName[MAX_NAME_LENGTH / sizeof(TCHAR)];
    TCHAR       szCandClassName[MAX_NAME_LENGTH / sizeof(TCHAR)];
    DWORD       fdwErrMsg;      // error message flag
#if !defined(WINIME)
// standard table related data
                                // size of standard table
    UINT        uTblSize[MAX_IME_TABLES];
                                // filename of tables
    TCHAR       szTblFile[MAX_IME_TABLES][MAX_NAME_LENGTH / sizeof(TCHAR)];
                                // the IME tables
// user create word related data
                                // user dictionary file name of IME
    TCHAR       szUsrDic[USR_DIC_SIZE / sizeof(TCHAR)];
                                // user dictionary map file name
    TCHAR       szUsrDicMap[USR_DIC_SIZE / sizeof(TCHAR)];
    UINT        uUsrDicSize;    // memory size of user create words table

    UINT        uUsrDicReserved1;
    UINT        uUsrDicReserved2;
// user create phrase box       // not implemented
    TCHAR       szUsrBox[USR_DIC_SIZE / sizeof(TCHAR)];
    TCHAR       szUsrBoxMap[USR_DIC_SIZE / sizeof(TCHAR)];
    UINT        uUsrBoxSize;
    UINT        uUsrBoxReserved1;
    UINT        uUsrBoxReserved2;
#endif
// the calculated sequence mask bits
    DWORD       dwSeqMask;      // the sequence bits for one stoke
    DWORD       dwPatternMask;  // the pattern bits for one result string
    int         nSeqBytes;      // how many bytes for nMaxKey sequence chars
// reverse conversion
    HKL         hRevKL;         // the HKL of reverse mapping IME
    WORD        nRevMaxKey;
// key related data
#if defined(PHON)
    WORD        nReadLayout;    // ACER, ETen, IBM, or other - phonetic only
#else
    WORD        wDummy;         // DWORD boundary
#endif
    WORD        nSeqBits;       // no. of sequence bits
    // must match with .RC file and VALIDCHAR
    DWORD       dwVersion;
    WORD        fwProperties1;
    WORD        fwProperties2;
    WORD        nMaxKey;        // max key of a Chinese word
    WORD        nSeqCode;       // no. of sequence code
    WORD        fChooseChar[6]; // valid char in choose state
                                // translate the char code to
                                // choose constants
    WORD        wReserved1[2];
#if defined(DAYI) || defined(UNIIME) || defined(MINIIME)
    BYTE        cChooseTrans[0x60];
#endif
    WORD        fCompChar[6];   // valid char in input state
    WORD        wReserved2[2];
    WORD        wCandPerPage;   // number of candidate strings per page
    WORD        wCandStart;     // 1. 2. 3. ... 0. start from 1
                                // 1. 2. 3. ... 0. range start from 0
    WORD        wCandRangeStart;
    WORD        wReserved3[1];
// convert sequence code to composition char
    WORD        wSeq2CompTbl[64];
// convert char to sequence code
    WORD        wChar2SeqTbl[0x42];
    WORD        wReserved4[2];
#if defined(WINAR30)
    WORD        wSymbol[10][4];
#elif defined(DAYI)
    WORD        wSymbol[340];
#elif defined(UNIIME) || defined(MINIIME)
    DWORD       fdwReserved5[32];
#endif
#endif // defined(ROMANIME)
} IMEL;

typedef IMEL      *PIMEL;
typedef IMEL NEAR *NPIMEL;
typedef IMEL FAR  *LPIMEL;


typedef struct tagInstL {       // local instance structure, per IME instance
    HINSTANCE   hInst;          // IME DLL instance handle
    LPIMEL      lpImeL;
#if !defined(ROMANIME)
    DWORD       fdwTblLoad;     // the *.TBL load status
    int         cRefCount;      // reference count
#if !defined(WINIME)
    HANDLE      hMapTbl[MAX_IME_TABLES];
    HANDLE      hUsrDicMem;     // memory handle for user dictionary
    TCHAR       szUsrDicReserved[USR_DIC_SIZE / sizeof(TCHAR)];
    UINT        uUsrDicReserved1;
    UINT        uUsrDicReserved2;
    HANDLE      hUsrBoxMem;
    TCHAR       szUsrBoxReserved[USR_DIC_SIZE / sizeof(TCHAR)];
    UINT        uUsrBoxReserved1;
    UINT        uUsrBoxReserved2;
#endif
#endif
    DWORD       dwReserved1[32];
} INSTDATAL;

typedef INSTDATAL      *PINSTDATAL;
typedef INSTDATAL NEAR *NPINSTDATAL;
typedef INSTDATAL FAR  *LPINSTDATAL;


#if !defined(UNIIME)
extern IMEL        sImeL;
extern LPIMEL      lpImeL;
extern INSTDATAL   sInstL;
extern LPINSTDATAL lpInstL;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\lctool\resource.h ===
/*************************************************
 *  resource.h                                   *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by LcTool.RC
//
#define ID_HELP                         3
#define IDD_SEARCH_LINE                 1000

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40003
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\miniime\miniime.c ===
#include <windows.h>
#include <immdev.h>
#include "imeattr.h"
#include "imedefs.h"
#include "uniime.h"

LRESULT CALLBACK UIWndProc(
    HWND   hWnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    return UniUIWndProc(lpInstL, lpImeL, hWnd, uMsg, wParam, lParam);
}

LRESULT CALLBACK CompWndProc(
    HWND   hWnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    return UniCompWndProc(lpInstL, lpImeL, hWnd, uMsg, wParam, lParam);
}

LRESULT CALLBACK CandWndProc(
    HWND   hWnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    return UniCandWndProc(lpInstL, lpImeL, hWnd, uMsg, wParam, lParam);
}

LRESULT CALLBACK StatusWndProc(
    HWND   hWnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    return UniStatusWndProc(lpInstL, lpImeL, hWnd, uMsg, wParam, lParam);
}

LRESULT CALLBACK OffCaretWndProc(
    HWND   hWnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    return UniOffCaretWndProc(lpInstL, lpImeL, hWnd, uMsg, wParam, lParam);
}

LRESULT CALLBACK ContextMenuWndProc(
    HWND   hWnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    return UniContextMenuWndProc(lpInstL, lpImeL, hWnd, uMsg, wParam, lParam);
}

BOOL    WINAPI ImeInquire(
    LPIMEINFO lpImeInfo,
    LPTSTR    lpszWndCls,
    DWORD dwSystemInfoFlags)
{
    lpImeInfo->dwPrivateDataSize = 0;

    return UniImeInquire(lpInstL, lpImeL, lpImeInfo, lpszWndCls, dwSystemInfoFlags);
}

BOOL    WINAPI ImeConfigure(
    HKL    hKL,
    HWND   hAppWnd,
    DWORD  dwMode,
    LPVOID lpData)
{
    return UniImeConfigure(lpInstL, lpImeL, hKL, hAppWnd, dwMode, lpData);
}

DWORD   WINAPI ImeConversionList(
    HIMC            hIMC,
    LPCTSTR         lpszSrc,
    LPCANDIDATELIST lpCandList,
    DWORD           dwBufLen,
    UINT            uFlag)
{
    return UniImeConversionList(lpInstL, lpImeL, hIMC, lpszSrc, lpCandList,
        dwBufLen, uFlag);
}

BOOL    WINAPI ImeDestroy(
    UINT uReserved)
{
    return UniImeDestroy(lpInstL, lpImeL, uReserved);
}

LRESULT WINAPI ImeEscape(
    HIMC   hIMC,
    UINT   uSubFunc,
    LPVOID lpData)
{
    return UniImeEscape(lpInstL, lpImeL, hIMC, uSubFunc, lpData);
}

BOOL    WINAPI ImeProcessKey(
    HIMC         hIMC,
    UINT         uVirtKey,
    LPARAM       lParam,
    CONST LPBYTE lpbKeyState)
{
    return UniImeProcessKey(lpInstL, lpImeL, hIMC, uVirtKey, lParam,
        lpbKeyState);
}

BOOL    WINAPI ImeSelect(
    HIMC hIMC,
    BOOL fSelect)
{
    return UniImeSelect(lpInstL, lpImeL, hIMC, fSelect);
}

BOOL    WINAPI ImeSetActiveContext(
    HIMC hIMC,
    BOOL fOn)
{
    return UniImeSetActiveContext(lpInstL, lpImeL, hIMC, fOn);
}

UINT    WINAPI ImeToAsciiEx(
    UINT         uVirtKey,
    UINT         uScanCode,
    CONST LPBYTE lpbKeyState,
    LPTRANSMSGLIST lpTransBuf,
    UINT         fuState,
    HIMC         hIMC)
{
    return UniImeToAsciiEx(lpInstL, lpImeL, uVirtKey, uScanCode,
        lpbKeyState, lpTransBuf, fuState, hIMC);
}

BOOL    WINAPI NotifyIME(
    HIMC  hIMC,
    DWORD dwAction,
    DWORD dwIndex,
    DWORD dwValue)
{
    return UniNotifyIME(lpInstL, lpImeL, hIMC, dwAction, dwIndex, dwValue);
}

BOOL    WINAPI ImeRegisterWord(
    LPCTSTR lpszReading,
    DWORD   dwStyle,
    LPCTSTR lpszString)
{
    return UniImeRegisterWord(lpInstL, lpImeL, lpszReading, dwStyle,
        lpszString);
}

BOOL    WINAPI ImeUnregisterWord(
    LPCTSTR lpszReading,
    DWORD   dwStyle,
    LPCTSTR lpszString)
{
    return UniImeUnregisterWord(lpInstL, lpImeL, lpszReading, dwStyle,
        lpszString);
}

UINT    WINAPI ImeGetRegisterWordStyle(
    UINT       nItem,
    LPSTYLEBUF lpStyleBuf)
{
    return UniImeGetRegisterWordStyle(lpInstL, lpImeL, nItem, lpStyleBuf);
}

UINT    WINAPI ImeEnumRegisterWord(
    REGISTERWORDENUMPROC lpfnRegisterWordEnumProc,
    LPCTSTR              lpszReading,
    DWORD                dwStyle,
    LPCTSTR              lpszString,
    LPVOID               lpData)
{
    return UniImeEnumRegisterWord(lpInstL, lpImeL, lpfnRegisterWordEnumProc,
        lpszReading, dwStyle, lpszString, lpData);
}

BOOL    WINAPI ImeSetCompositionString(
    HIMC    hIMC,
    DWORD   dwIndex,
    LPCVOID lpComp,
    DWORD   dwCompLen,
    LPCVOID lpRead,
    DWORD   dwReadLen)
{
    return UniImeSetCompositionString(lpInstL, lpImeL, hIMC, dwIndex, lpComp,
        dwCompLen, lpRead, dwReadLen);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\uimetool\resource.h ===
/*************************************************
 *  resource.h                                   *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Uimetool.rc
//
#define IDB_BITMAP1                     103
#define IDB_BITMAP2                     104
#define IDB_BITMAP3                     105
#define IDC_SPIN2                       1002
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        107
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1003
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\uimetool\rc.h ===
/*************************************************
 *  rc.h                                         *
 *                                               *
 *  Copyright (C) 1993-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
//
// PURPOSE:
//    Contains declarations for all globally scoped names in the program.
//

//-------------------------------------------------------------------------
// Command ID definitions.  These definitions are used to associate menu
// items with commands.

// File menu
#define IDM_EXIT                 0x0800

//-------------------------------------------------------------------------
// String Table ID definitions.

#define IDS_APPNAME              0x0800
#define IDS_DESCRIPTION          0x0801
#define IDS_FONT_NAME            0x0802
#define IDS_FILTERSPEC           0x0803
#define IDS_DEFAULTFILEEXT       0x0804
#define IDS_FILTERSPEC_ALL       0x0805
#define IDS_ALLFILEEXT           0x0806
#define IDS_OPENTITLE            0x0807
#define IDS_BUILDTITLE           0x0808

#define IDS_ERR_ERROR            0x0820
#define IDS_ERR_USE_RESERVE      0x0821
#define IDS_ERR_MAIN_TABLE       0x0822
#define IDS_ERR_NO_MINIIME       0x0823
#define IDS_ERR_IME_ACCESS       0x0824
#define IDS_ERR_MEMORY           0x0825
#define IDS_ERR_SBCS             0x0826
#define IDS_ERR_FILEOPEN         0x0827
#define IDS_ERR_FILEREAD         0x0828
#define IDS_ERR_FILEWRITE        0x0829
#define IDS_ERR_INPUTIME         0x0830
#define IDS_ERR_OVER_BITLEN      0x0831
#define IDS_ERR_BASEIME          0x0832
#define IDS_ERR_NORADICAL        0x0833
#define IDS_ERR_OVER_MAXLEN      0x0834
#define IDS_ERR_KEYNUM           2090
#define IDS_ERR_IMENAME          2091

#define IDS_MSG_INFOMATION       0x0850
#define IDS_MSG_PROCESS_OK       0x0851

#define IDS_FILEDESCRIPTION_STR  0x0900
#define IDS_PRODUCTNAME_STR      0x0901
#define IDS_VER_INTERNALNAME_STR 0x0902
#define IDS_LIBERARY_NAME        0x0903
#define IDS_DEFINITION_NAME      0x0904


//---usd by dialog box
#define IDD_IME_NAME             0x0800
#define IDD_TABLE_NAME           0x0801
#define IDD_BITMAP_NAME          0x0802
#define IDD_ICON_NAME            0x0803
#define IDD_SPIN                 0x0804
#define IDD_ROOT_NUM             0x0805
#define IDD_IME_FILE_NAME        0x0806
#define IDD_CANDBEEP_YES         0x0807
#define IDD_CANDBEEP_NO          0x0808
#define IDD_HELP                 0x0809
#define IDD_BROWSE               0x080a

#define IDD_IMENAME              1901
#define IDD_IMEPARAM             1902
#define IDD_IMETABLE             1903
//---end of dialog box
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\uimetool\imerc.h ===
/*************************************************
 *  imerc.h                                      *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

#define IDIC_IME_ICON                   0x0100


#define IDBM_CMODE_NATIVE               0x0100

#if !defined(MINIIME)
#define IDBM_CMODE_NONE                 0x0110

#if !defined(ROMANIME)
#define IDBM_CMODE_ALPHANUMERIC         0x0111
#endif

#define IDBM_CMODE_FULLSHAPE            0x0113
#define IDBM_CMODE_HALFSHAPE            0x0114

#if !defined(ROMANIME)
#if !defined(WINIME)
#define IDBM_CMODE_EUDC                 0x0115
#endif
#define IDBM_CMODE_SYMBOL               0x0116
#endif


#if !defined(ROMANIME)
#define IDBM_CAND_PROMPT_PHRASE         0x0120

#if defined(WINAR30)
#define IDBM_CAND_PROMPT_QUICK_VIEW     0x0121
#endif

#define IDBM_CAND_PROMPT_NORMAL         0x0122


#define IDBM_PAGEUP_HORIZ               0x0130
#define IDBM_NO_PAGEUP_HORIZ            0x0131
#define IDBM_HOME_HORIZ                 0x0132
#define IDBM_NO_HOME_HORIZ              0x0133
#define IDBM_PAGEDN_HORIZ               0x0134
#define IDBM_NO_PAGEDN_HORIZ            0x0135
#define IDBM_PAGEUP_VERT                0x0136
#define IDBM_NO_PAGEUP_VERT             0x0137
#define IDBM_PAGEDN_VERT                0x0138
#define IDBM_NO_PAGEDN_VERT             0x0139
#endif // !defined(ROMANIME)


#define IDDG_IME_CONFIG                 0x0100


#define IDMN_CONTEXT_MENU               0x0100
#endif // !defined(MINIIME)


#define IDRC_VALIDCHAR                  0x0100


#define IDRC_TABLEFILES                 0x0110

#if !defined(MINIIME)
#define IDRC_FULLABC                    0x0120
#if !defined(ROMANIME) && !defined(WINAR30)
#define IDRC_SYMBOL                     0x0121
#endif

#if defined(UNIIME)
#define IDRC_PHRASETABLES               0x0130
#endif


#define IDCR_HAND_CURSOR                0x0100
#endif // !defined(MINIIME)


#define IDS_IMENAME                     0x0100
#define IDS_IMEUICLASS                  0x0101
#define IDS_IMECOMPCLASS                0x0102
#define IDS_IMECANDCLASS                0x0103
#define IDS_IMESTATUSCLASS              0x0104
#define IDS_IMEOFFCARETCLASS            0x0105
#define IDS_IMECMENUCLASS               0x0106


#if !defined(MINIIME)
#define IDS_CHICHAR                     0x0200
#define IDS_NONE                        0x0201


#if !defined(ROMANIME) && !defined(WINIME)
#define IDS_EUDC                        0x0210
#define IDS_USRDIC_FILTER               0x0211


#define IDS_INTERNAL_TITLE              0x0220
#define IDS_INTERNAL_MSG                0x0221
#define IDS_EUDCDICFAIL_TITLE           0x0222
#define IDS_EUDCDICFAIL_MSG             0x0223
#define IDS_NOTOPEN_TITLE               0x0224
#define IDS_NOTOPEN_MSG                 0x0225
#define IDS_FILESIZE_TITLE              0x0226
#define IDS_FILESIZE_MSG                0x0227
#define IDS_HEADERSIZE_TITLE            0x0228
#define IDS_HEADERSIZE_MSG              0x0229
#define IDS_INFOSIZE_TITLE              0x022A
#define IDS_INFOSIZE_MSG                0x022B
#define IDS_CODEPAGE_TITLE              0x022E
#define IDS_CODEPAGE_MSG                0x022F
#define IDS_CWINSIGN_TITLE              0x0230
#define IDS_CWINSIGN_MSG                0x0231
#define IDS_UNMATCHED_TITLE             0x0232
#define IDS_UNMATCHED_MSG               0x0233

#define IDS_FILE_OPEN_ERR               0x0260
#define IDS_MEM_LESS_ERR                0x0261
#endif // !defined(ROMANIME) && !defined(WINIME)


#if defined(UNIIME)
#define IDS_FILE_OPEN_FAIL              0x0300
#define IDS_MEM_LACK_FAIL               0x0301
#endif


#define IDS_SHARE_VIOLATION             0x0310


#if defined(PHON)
#define IDD_DEFAULT_KB                  0x0100
#define IDD_ETEN_KB                     0x0101
#define IDD_IBM_KB                      0x0102
#define IDD_CHING_KB                    0x0103
#if defined(ETEN)
#define IDD_ETEN26_KB                   0x0104
#endif
#endif


#define IDD_OFF_CARET_UI                0x0200
#if !defined(ROMANIME)
#define IDD_QUICK_KEY                   0x0201
#define IDD_PREDICT                     0x0202

#define IDD_LAYOUT_LIST                 0x0210

#define IDD_EUDC_DIC                    0x0211
#endif

#define IDM_SOFTKBD                     0x0100
#define IDM_SYMBOL                      0x0101
#define IDM_PROPERTIES                  0x0102
#endif // !defined(MINIIME)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\uimetool\uimetool.c ===
/*************************************************
 *  uimetool.c                                   *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

//
//  Change log:
//	  define UNIIME identifier
//	  @D03		Fix Bug				Use wrong miniime.tpl file name
//	  @D04		Fix Bug				Does show error message when invalid table file
//	  @D05		Modified			Add UNALIGNED to meet MIPS system
//
//  1/17/96
//	  @E01		Change for multi-threading
//	  @E02		Untest DBCS for NT version
//    @E03      Change for multi-threading without extending function

#include <windows.h>            // required for all Windows applications
#include <windowsx.h>
#include <tchar.h>
#include "rc.h"                 // prototypes specific to this application
#include "uimetool.h"
#include "imeattr.h"
#include "imerc.h"

#ifdef UNICODE
	typedef DWORD UNALIGNED FAR *LPUNADWORD;
	typedef WORD UNALIGNED FAR *LPUNAWORD;
	typedef TCHAR UNALIGNED FAR *LPUNATCHAR;
#else
	typedef DWORD FAR *LPUNADWORD;
	typedef WORD FAR *LPUNAWORD;
	typedef TCHAR FAR *LPUNATCHAR;
#define TCHAR BYTE
#endif

HWND  hwndMain;
TCHAR szIme_Name[IME_NAME_LEN_TOOL];
TCHAR szTab_Name[MAX_PATH];
TCHAR szKey_Num_Str[KEY_NUM_STR_LEN];
TCHAR szFile_Out_Name[TAB_NAME_LEN];
TCHAR Show_Mess[MAX_PATH];
TCHAR Msg_buf[MAX_PATH];
BOOL  bCandBeep;
BOOL  bOverMaxRadical;                                                   //@D02A
HCURSOR hCursorWait;
HCURSOR hCursorArrow;

VALIDCHAR  Valid;
TABLEFILES Table;
UINT  uGenericID[]={ IDS_FILEDESCRIPTION_STR,
                     IDS_VER_INTERNALNAME_STR,
                     IDS_PRODUCTNAME_STR,
                     IDS_IMENAME };

#ifdef UNICODE
	int cntChar = 2;
#else
	int cntChar = 1;
#endif

UINT idxLine;

extern HINSTANCE hInst;

UINT  SearchMem(BYTE *, UINT, BYTE *, UINT);
BOOL  Process_Bitmap(HWND, BYTE *, UINT);
BOOL  Process_Icon(HWND, BYTE *, UINT);
BOOL  Process_RT(HFILE, BYTE *, UINT, TCHAR *);
BOOL  WritetoFile(TCHAR *);
WORD  GetPhrase(UINT, TCHAR *);
BOOL  Parse(TCHAR *, UINT);
BOOL  PutRadical(TCHAR, WORD);
BOOL  PutPhrase(TCHAR *, TCHAR *, UINT);
BOOL  AllocRadical();
BOOL  AllocPhrase();
void  ErrMsg(UINT, UINT);
void  ErrIOMsg(UINT, TCHAR *);

void MyFillMemory(TCHAR *dst, DWORD cnt, TCHAR v);

void GetOpenFile(
    HWND hDlg)
{
    OPENFILENAME    ofn;
    TCHAR  *pszFilterSpec;
    TCHAR  szFilterSpec[128];
    TCHAR  szFileOpen[25];
    TCHAR  szExt[10];
    TCHAR  szCustFilter[10];
    TCHAR  szFileName[MAX_PATH];
    TCHAR  szFilePath[MAX_PATH];
    TCHAR  szStr[MAX_PATH];

    szFileName[0]=0;
    LoadString (hInst, IDS_FILTERSPEC, szFilterSpec, sizeof(szFilterSpec) / sizeof(TCHAR));
    LoadString (hInst, IDS_DEFAULTFILEEXT, szExt, sizeof(szExt) / sizeof(TCHAR));
    pszFilterSpec = szFilterSpec;
    pszFilterSpec += lstrlen(pszFilterSpec) + 1;
    lstrcpy(pszFilterSpec, szExt);
    LoadString (hInst, IDS_FILTERSPEC_ALL, szStr, sizeof(szStr) / sizeof(TCHAR));
    pszFilterSpec += lstrlen(pszFilterSpec) + 1;
    lstrcpy(pszFilterSpec,szStr);
    LoadString (hInst, IDS_ALLFILEEXT, szStr, sizeof(szStr) / sizeof(TCHAR));
    pszFilterSpec += lstrlen(pszFilterSpec) + 1;
    lstrcpy(pszFilterSpec,szStr);
    pszFilterSpec += lstrlen(pszFilterSpec) + 1;
    *pszFilterSpec = 0;
    LoadString (hInst, IDS_OPENTITLE, szFileOpen, sizeof(szFileOpen) / sizeof(TCHAR));
    szCustFilter[0] = 0;
    lstrcpy(&szCustFilter[1], szExt);
    lstrcpy(szFilePath, szExt);

    /* fill in non-variant fields of OPENFILENAME struct. */
    ofn.lStructSize       = sizeof(OPENFILENAME);
    ofn.hwndOwner         = hDlg;
    ofn.lpstrFilter       = szFilterSpec;
    ofn.lpstrCustomFilter = szCustFilter;
    ofn.nMaxCustFilter    = sizeof(szCustFilter) / sizeof(TCHAR);
    ofn.nFilterIndex      = 1;
    ofn.lpstrFile         = szFilePath;
    ofn.nMaxFile          = MAX_PATH;
    ofn.lpstrInitialDir   = NULL;
    ofn.lpstrFileTitle    = szFileName;
    ofn.nMaxFileTitle     = MAX_PATH;
    ofn.lpstrTitle        = szFileOpen;
    ofn.lpstrDefExt       = szExt + 3;
    ofn.Flags             = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY |
                            OFN_PATHMUSTEXIST;

    /* call common open dialog and return result */
    if(GetOpenFileName ((LPOPENFILENAME)&ofn))
        SetDlgItemText(hDlg, IDD_TABLE_NAME, szFilePath);
}

// <== @E01
//unsigned _stdcall MakeNewImeThread(LPVOID voidparam)
void MakeNewImeThread(LPVOID voidparam) // <== @E03
{
	BOOL bOk;
	extern HWND hProgMain;
	extern BOOL bFinish;
	
	bOk = MakeNewIme(NULL);
	if (hProgMain)
		PostMessage(hProgMain, WM_CLOSE, 0, 0);
	
	if (!bOk)
		bFinish = 0;
	else
		bFinish = 1;

	//return bOk;
}

// <== @E01
void HideProgress(void)
{
	extern HWND hProgMain;
	if (hProgMain)
		ShowWindow(hProgMain, SW_HIDE);
}

// <== @E01
void ShowProgress(void)
{
	extern HWND hProgMain;
	if (hProgMain)
		ShowWindow(hProgMain, SW_SHOWNORMAL);
}

#define IDM_NEWSHELL         249

void HandleTaskBar_IME( )
{

   HWND   hwndIndicate;
   TCHAR  szIndicator[]     = TEXT("Indicator");

   // Handle the task bar indicator option.

   hwndIndicate = FindWindow(szIndicator, NULL);

   //
   //  See if the indicator is already enabled.
   //
   if (hwndIndicate && IsWindow(hwndIndicate))
   {
       SendMessage(hwndIndicate, WM_COMMAND, IDM_NEWSHELL, 0L);
   }

}


BOOL MakeNewIme(HWND hWnd)
{
    HFILE   hfFile,hfMainFile;
    BYTE    *szImeBuf;
    TCHAR   szBig5[MAX_PATH],szUniCode[MAX_PATH],szGeneric[MAX_PATH];
    TCHAR   szClass[MAX_PATH];
    TCHAR   szPure_Name[100];
    TCHAR   Ime_File_Name[MAX_PATH];
    TCHAR   Src_File_Name[MAX_PATH];
    TCHAR   szSystem[MAX_PATH];
    UINT    uLen,flen,len,unilen,classlen,genericlen;
    UINT    uAddr;
    int     i;


    // Get Windows System directory
    uLen = GetSystemDirectory((LPTSTR)szSystem, sizeof(szSystem));
    if (szSystem[uLen - 1] != _TEXT('\\'))      // consider C:\ ;
	{
        szSystem[uLen ++] = _TEXT('\\');
        szSystem[uLen] = 0;
    }

//---------------------------------------------------------------------------
// Check input data
//---------------------------------------------------------------------------
    //let Pure_Name be without .ime name, this is prevent user to input .ime
    for(i = 0; i < (int)lstrlen(szFile_Out_Name); i++)
	{
        if(szFile_Out_Name[i] == _TEXT('.'))
            break;

        szPure_Name[i] = szFile_Out_Name[i];
    }

    szPure_Name[i] = 0; //end of string
    if(szPure_Name[0] == 0) 
	{
        ErrMsg(IDS_ERR_INPUTIME, 0);
        return FALSE;                   //do nothing because didnt set ok
    }

    //limit it length <= 8
    if(lstrlen(szPure_Name) > 8) szPure_Name[8] = 0;

    //Check if is reserved name miniime
    if(!lstrcmp(SOURCE_IME_NAME, szPure_Name)) 
	{
        //is with reserved file name for .ime
        ErrMsg(IDS_ERR_USE_RESERVE, 0);
        return FALSE;
    }

    //Check input IME Name
    len = lstrlen(szIme_Name);

#ifdef UNICODE
    if(len < 2)  
        szIme_Name[1] = 0x3000;

    szIme_Name[2]=0;

	{
	char fname[MAX_PATH * 2];
	int lenx = lstrlen(szTab_Name);
	WideCharToMultiByte(950, WC_COMPOSITECHECK, szTab_Name, lenx,
                   (LPSTR)fname, lenx, NULL, NULL);
	fname[lenx] = 0;
    hfMainFile=_lopen(fname, OF_READ);
	}
#else
    if(len < 4)  
	{
        szIme_Name[2] = (BYTE) 0xa1;
        szIme_Name[3] = (BYTE) 0x40;
    }

    szIme_Name[4]=0;

    hfMainFile=_lopen(szTab_Name, OF_READ);
#endif

    if(hfMainFile==-1)
	{
        ErrIOMsg(IDS_ERR_FILEOPEN, szTab_Name);
        return FALSE;
    }


//---------------------------------------------------------------------------
// Read Base IME file - miniime.tpl
//---------------------------------------------------------------------------
    lstrcpy(Src_File_Name, szSystem); //System directory
    lstrcat(Src_File_Name, LIBRARY_NAME);

#ifdef UNICODE
	{
	char fname[MAX_PATH * 2];
	int len = lstrlen(Src_File_Name); // <== @D03
	WideCharToMultiByte(950, WC_COMPOSITECHECK, Src_File_Name, len,
                   (LPSTR)fname, len, NULL, NULL);
	fname[len] = 0;
    hfFile=_lopen(fname,OF_READ);
	}
#else
    hfFile=_lopen(Src_File_Name, OF_READ);
#endif

    if(hfFile==-1)
	{
        ErrIOMsg(IDS_ERR_FILEOPEN, Src_File_Name);
        _lclose(hfMainFile);
        return TRUE;                    // Can not continue
    }

    flen=_llseek(hfFile, 0L, 2);           // get  file length

    // Allocate Memory
    szImeBuf = (BYTE *)GlobalAlloc(GMEM_FIXED, flen);
    if(!szImeBuf) 
	{
        ErrMsg(IDS_ERR_MEMORY, 0);
        _lclose(hfMainFile);
        return TRUE;                    // Can not continue
    }

    _llseek(hfFile, 0L, 0);                //set to beginning

    if(flen != _lread(hfFile,szImeBuf,flen)) 
	{
        ErrIOMsg(IDS_ERR_FILEREAD, Src_File_Name);
        _lclose(hfMainFile);
        GlobalFree((HGLOBAL)szImeBuf);
        return TRUE;                    // Can not continue
    }

    _lclose(hfFile);

//---------------------------------------------------------------------------
// Search string and Patch them
//---------------------------------------------------------------------------

    // Translate input IME name to Unicod to instead of generic string
    LoadString(hInst, IDS_IMENAME, szBig5, sizeof(szBig5) / sizeof(TCHAR));
    len = lstrlen(szBig5);

#ifdef UNICODE
	lstrcpy(szUniCode, szBig5);
	unilen = len;
#else
    unilen=MultiByteToWideChar(950, MB_PRECOMPOSED, szBig5, len,
                   (LPWSTR)szUniCode, len);
#endif

    lstrcpy(szBig5, szIme_Name);
    len=lstrlen(szBig5);

#ifdef UNICODE
	lstrcpy(szGeneric, szBig5);
	genericlen = lstrlen(szBig5);
#else
    for(i = len; i < (int)(len+unilen-2); i++) 
		szBig5[i] = ' ';

    szBig5[i] = 0;
    len = lstrlen(szBig5);
    genericlen = MultiByteToWideChar(950, MB_PRECOMPOSED, szBig5, len,
                    (LPWSTR)szGeneric, len);
    genericlen *= 2;
#endif

   // Process Generic  string
#ifdef UNICODE
	
    for(i=0; i<(sizeof(uGenericID)/sizeof(UINT)); i++) 
	{
        LoadString(hInst, uGenericID[i], szBig5, sizeof(szBig5) / sizeof(TCHAR));
        len=lstrlen(szBig5);
        uAddr=SearchMem((LPSTR)szBig5, len * 2, szImeBuf, flen);
        if(uAddr == 0) {
			continue;
        } else
            if ( i == 0 ) {
               // this is for IDS_FILEDESCRIPTION_STR,
               // We just replace the first two Chinese Characters
               // and keep the rest. 

               CopyMemory(&szImeBuf[uAddr], szGeneric,genericlen*2 );
            }
            else
			   CopyMemory(&szImeBuf[uAddr], szGeneric, (genericlen + 1) * 2);
    }
	
#else

    for(i=0; i<(sizeof(uGenericID)/sizeof(UINT)); i++) 
	{
        LoadString(hInst, uGenericID[i], szBig5, sizeof(szBig5) / sizeof(TCHAR));
        len=lstrlen(szBig5);
        unilen=MultiByteToWideChar(950, MB_PRECOMPOSED, szBig5, len,
                       (LPWSTR)szUniCode, len);
        uAddr=SearchMem(szUniCode, unilen*2, szImeBuf, flen);
        if(uAddr == 0) {
            // ErrMsg(IDS_ERR_BASEIME, 0);
            // _lclose(hfMainFile);
            // GlobalFree((HGLOBAL)szImeBuf);
            // return TRUE;
			continue;
        }
        CopyMemory(&szImeBuf[uAddr], szGeneric, genericlen);
    }
#endif
   // Process LIBERAY NAME
    {
    TCHAR szLibName[MAX_PATH];
    int  liblen;

    LoadString(hInst, IDS_LIBERARY_NAME, szLibName, sizeof(szLibName) / sizeof(TCHAR));
    liblen = lstrlen(szLibName);

#ifdef UNICODE
	{
	char name[MAX_PATH * 2];
	WideCharToMultiByte(950, WC_COMPOSITECHECK, szLibName, liblen,
                   (LPSTR)name, liblen, NULL, NULL);
    uAddr=SearchMem((LPSTR)name, liblen, szImeBuf, flen);
	}
#else
    uAddr=SearchMem((LPSTR)szLibName, liblen, szImeBuf, flen);
#endif

    if(uAddr == 0) 
	{
        ErrMsg(IDS_ERR_BASEIME, 0);
        _lclose(hfMainFile);
        GlobalFree((HGLOBAL)szImeBuf);
        return TRUE;
    }

    lstrcpy(szLibName, szPure_Name);
    len=lstrlen(szPure_Name);
    szLibName[liblen-4] = 0;
    for(i=len; i<liblen-4; i++)
        szLibName[i] = _TEXT('$');
    lstrcat(szLibName, _TEXT(".IME"));

#ifdef UNICODE
	{
	char name[MAX_PATH * 2];
	WideCharToMultiByte(950, WC_COMPOSITECHECK, szLibName, liblen,
                   (LPSTR)name, liblen, NULL, NULL);
    CopyMemory(&szImeBuf[uAddr], name, liblen * sizeof(TCHAR));
	}
#else
    CopyMemory(&szImeBuf[uAddr], szLibName, liblen * sizeof(TCHAR));
#endif
    }

    // Process DEFINETION NAME

    // Process IMEUICLASS String
    LoadString(hInst, IDS_IMEUICLASS, szBig5, sizeof(szBig5) / sizeof(TCHAR));
    len=lstrlen(szBig5);
#ifdef UNICODE
    uAddr=SearchMem((LPSTR)szBig5, len*2, szImeBuf, flen);
#else
    classlen=MultiByteToWideChar(950, MB_PRECOMPOSED, szBig5, len,
                   (LPWSTR)szClass, len);
    uAddr=SearchMem((LPSTR)szClass, classlen*2, szImeBuf, flen);
#endif
    if(uAddr == 0) 
	{
        ErrMsg(IDS_ERR_BASEIME, 0);
        _lclose(hfMainFile);
        GlobalFree((HGLOBAL)szImeBuf);
        return TRUE;
    }

    lstrcpy(szBig5, szPure_Name);
    len=lstrlen(szBig5);
    for(i = len; i < 8; i++) szBig5[i] = _TEXT(' ');
    szBig5[8] = 0;
    len = 8;

#ifdef UNICODE
	lstrcpy(szUniCode, szBig5);
	unilen = len;
#else
    unilen = MultiByteToWideChar(950, MB_PRECOMPOSED, szBig5, len,
                   (LPWSTR)szUniCode, len);
#endif

    while(TRUE) 
	{
        LoadString(hInst, IDS_IMEUICLASS, szBig5, sizeof(szBig5) / sizeof(TCHAR));
        len=lstrlen(szBig5);
#ifdef UNICODE
		lstrcpy(szClass, szBig5);
		classlen = len;
#else
        classlen=MultiByteToWideChar(950, MB_PRECOMPOSED, szBig5, len,
                       (LPWSTR)szClass, len);
#endif
        uAddr=SearchMem((BYTE *)szClass, classlen * 2, szImeBuf, flen);
        if(uAddr == 0)
            break;
        CopyMemory(&szImeBuf[uAddr], szUniCode, unilen * 2);
    }

    // Process Bitmap file
    if(!Process_Bitmap(hWnd, szImeBuf, flen)) 
	{
        _lclose(hfMainFile);
        GlobalFree((HGLOBAL)szImeBuf);
        return TRUE;
    }

    // Process Icon file
    if(!Process_Icon(hWnd, szImeBuf, flen)) 
	{
        _lclose(hfMainFile);
        GlobalFree((HGLOBAL)szImeBuf);
        return TRUE;
    }

    // Process RT_RCDATA
    bOverMaxRadical=FALSE;                                               
    if(!Process_RT(hfMainFile, szImeBuf, flen, szPure_Name)) 
	{
        _lclose(hfMainFile);
	// Bug #53630
	//  _lclose(hfFile);
        GlobalFree((HGLOBAL)szImeBuf);

        // ErrIOMsg(IDS_ERR_FILEREAD, szTab_Name); // <== @D04

        if(bOverMaxRadical)                                              
            return FALSE;                                                
        else                                                             
            return TRUE;                                                 

    }

    _lclose(hfMainFile);

//---------------------------------------------------------------------------
// Save to input IME file
//---------------------------------------------------------------------------
    lstrcpy(Ime_File_Name, szSystem);
    lstrcat(Ime_File_Name, szPure_Name);
    lstrcat(Ime_File_Name, _TEXT(".IME"));

#ifdef UNICODE
	{
	char fname[MAX_PATH * 2];
	int ulen = lstrlen(Ime_File_Name);
	WideCharToMultiByte(950, WC_COMPOSITECHECK, Ime_File_Name, ulen,
                   (LPSTR)fname, ulen, NULL, NULL);
	fname[ulen] = 0;
    hfFile=_lcreat(fname,0);
	}
#else
    hfFile=_lcreat(Ime_File_Name,0);
#endif

    if(hfFile==-1)
	{
        ErrIOMsg(IDS_ERR_FILEOPEN, Ime_File_Name);
        return TRUE;
    }

    if(flen != _lwrite(hfFile, szImeBuf, flen)) 
	{
        ErrIOMsg(IDS_ERR_FILEREAD, Ime_File_Name);
        _lclose(hfFile);
		return TRUE;
    }
    _lclose(hfFile);
    GlobalFree((HGLOBAL)szImeBuf);


//---------------------------------------------------------------------------
// Install IME and register it
//---------------------------------------------------------------------------
    if(!ImmInstallIME(Ime_File_Name,szIme_Name)) 
	{
		HideProgress(); // <== @E01

        LoadString(hInst, IDS_ERR_IME_ACCESS, Msg_buf, sizeof(Msg_buf) / sizeof(TCHAR));
        wsprintf(Show_Mess, Msg_buf, Ime_File_Name);
        LoadString(hInst, IDS_ERR_ERROR, Msg_buf, sizeof(Msg_buf) / sizeof(TCHAR));
        MessageBox(NULL, Show_Mess, Msg_buf, MB_OK | MB_ICONSTOP | MB_SETFOREGROUND);
        return TRUE;
    }

    HandleTaskBar_IME( );

    // show message for had produced files
    //let Show_Mess be message to be shown
	HideProgress(); // <== @E01

    LoadString(hInst, IDS_MSG_PROCESS_OK, Msg_buf, sizeof(Msg_buf) / sizeof(TCHAR));
    wsprintf(Show_Mess, Msg_buf, szPure_Name);
    LoadString(hInst, IDS_MSG_INFOMATION, Msg_buf, sizeof(Msg_buf) / sizeof(TCHAR));
    MessageBox(NULL, Show_Mess, Msg_buf,MB_OK|MB_ICONINFORMATION | MB_SETFOREGROUND);

    return TRUE;

}


BOOL Process_Bitmap(
    HWND hWnd,
    BYTE *szImeBuf,
    UINT flen)
{
    BITMAPINFO *bmif;
    HRSRC   hResource,hMem;
    HBITMAP hBitmap, hOldBitmap;
    BYTE    *lpBitmap;
    UINT    reslen,uAddr,nColor,nHead;
    HDC     hDC,hMemDC;
    HFONT   hOldFont;
    LOGFONT lfFont;
    TCHAR   szFont[MAX_PATH];
    RECT    rect;
    UINT    i,nBitmap;


   // Get bitmap from resource, use to find base ime bitmap address
    hResource=FindResource(hInst, MAKEINTRESOURCE(IDBM_CMODE_NATIVE), RT_BITMAP);
    if (hResource == NULL )
       return FALSE;

    hMem=LoadResource(hInst, hResource);

    if ( hMem == NULL )
       return FALSE;

    lpBitmap=LockResource(hMem);

    if ( lpBitmap == NULL )
    {
        FreeResource(hMem);
        return FALSE;
    }

    reslen=SizeofResource(hInst,hResource);

    uAddr=SearchMem(lpBitmap, reslen, szImeBuf, flen);

    if(uAddr == 0) {
        UnlockResource(hMem);
        FreeResource(hMem);
        ErrMsg(IDS_ERR_BASEIME, 0);
        return FALSE;
    }

    bmif=(BITMAPINFO *)lpBitmap;

    for(nColor=1, i=0; i<bmif->bmiHeader.biBitCount; i++)
        nColor*=2;

    nHead=sizeof(BITMAPINFOHEADER)+nColor*sizeof(RGBQUAD);
    bmif=(BITMAPINFO *)GlobalAlloc(LMEM_FIXED, nHead);
    if(!bmif) {
        UnlockResource(hMem);
        FreeResource(hMem);
        ErrMsg(IDS_ERR_BASEIME, 0);
        return FALSE;
    }

    CopyMemory(bmif, lpBitmap, nHead);

    UnlockResource(hMem);
    FreeResource(hMem);

   // Create a Memory DC, and load bitmap to it
    hDC = GetDC(hWnd);
    hMemDC = CreateCompatibleDC(hDC);
    hBitmap = LoadBitmap(hInst, MAKEINTRESOURCE(IDBM_CMODE_NATIVE));
    ReleaseDC(hWnd, hDC);
    hOldBitmap = SelectObject(hMemDC, hBitmap);


   // Select 16 point size font
    hOldFont = GetCurrentObject(hMemDC, OBJ_FONT);
    GetObject(hOldFont, sizeof(lfFont), &lfFont);
    lfFont.lfWeight=400;
    lfFont.lfHeight=-16;
    lfFont.lfWidth =  8;
    lfFont.lfOutPrecision= OUT_TT_ONLY_PRECIS;
    lfFont.lfPitchAndFamily = DEFAULT_PITCH|FF_DONTCARE;
    LoadString(hInst, IDS_FONT_NAME, szFont, sizeof(szFont) / sizeof(TCHAR));
    lstrcpy(lfFont.lfFaceName, szFont);
    SelectObject(hMemDC, CreateFontIndirect(&lfFont));

   // Set color
    SetTextColor(hMemDC, RGB(0x80, 0x00, 0x00));       // Dark red
    SetBkColor(hMemDC, RGB(0xC0, 0xC0, 0xC0));         // Light gray

   // Set rectangle, and write IME name 1st DBCS to Memory DC
    rect.left=3;
    rect.top=3;
    rect.right=rect.left-lfFont.lfHeight;
    rect.bottom=rect.top-lfFont.lfHeight;
    ExtTextOut(hMemDC, rect.left, rect.top, ETO_OPAQUE,
		&rect, szIme_Name, (cntChar == 2) ? 1 : 2, NULL);

   // Allocate bitmap buffer
    nBitmap=(UINT)bmif->bmiHeader.biSizeImage;
    lpBitmap=(BYTE *)GlobalAlloc(LMEM_FIXED, nBitmap);
    if(!lpBitmap) {
        GlobalFree((HGLOBAL)bmif);
        DeleteObject(SelectObject(hMemDC, hOldFont));
        DeleteObject(SelectObject(hMemDC, hOldBitmap));
        DeleteDC(hMemDC);
        ErrMsg(IDS_ERR_BASEIME, 0);
        return FALSE;
    }

   // Get Device Independent bitmap from Memory DC
    GetDIBits(hMemDC, hBitmap, 0, bmif->bmiHeader.biHeight,
              lpBitmap, bmif, DIB_RGB_COLORS);

    CopyMemory(&szImeBuf[uAddr], bmif, nHead);
    CopyMemory(&szImeBuf[uAddr+nHead], lpBitmap, nBitmap);

    DeleteObject(SelectObject(hMemDC, hOldFont));
    DeleteObject(SelectObject(hMemDC, hOldBitmap));
    DeleteDC(hMemDC);
    GlobalFree((HGLOBAL)bmif);
    GlobalFree((HGLOBAL)lpBitmap);

    return TRUE;
}

#define ENBOLD_ICONSIZE     24

BOOL UpdateMiniIMEIcon(
    HWND   hWnd,
    LPBYTE lpbMiniImeFileImage,
    UINT   uLen,
    int    nIconID)
{
    UINT               uAddr;
    LPBITMAPINFOHEADER lpbmIconInfoHeader;
    DWORD              dwHeaderSize;
    HDC                hMemDC;
    HBITMAP            hBitmap, hOldBitmap;
    LPVOID             lpBitmap, lpBitmap_Section;
    DWORD              dwBitmap;

    {
        HRSRC              hResIcon;
        DWORD              dwSize;
        LPBITMAPINFOHEADER lpResIcon;

        hResIcon = LoadResource(hInst, FindResource(hInst,
            MAKEINTRESOURCE(nIconID), RT_ICON));

        if (!hResIcon) {
			HideProgress(); // <== @E01
			MessageBox(NULL, _TEXT("Load icon fail !"), _TEXT("Bug"), MB_OK | MB_SETFOREGROUND );
            return (FALSE);
        }

        dwSize = SizeofResource(hInst, hResIcon);

        uAddr = 0;

        lpResIcon = LockResource(hResIcon);

        if (!lpResIcon) {
            goto UpdateIconFreeRes;
        }

        uAddr = SearchMem((LPBYTE)lpResIcon, dwSize, lpbMiniImeFileImage, uLen);

        if (uAddr) {
            DWORD nColors;

            if (lpResIcon->biBitCount != 24) {
                UINT i;

                for (nColors = 1, i = 0; i < lpResIcon->biBitCount; i++) {
                    nColors *= 2;
                }
            } else {
                // no RGBQUAD for 24 bit per pixel format
                nColors = 0;
            }

            dwHeaderSize = lpResIcon->biSize + nColors * sizeof(RGBQUAD);

            lpbmIconInfoHeader = (LPBITMAPINFOHEADER)GlobalAlloc(GMEM_FIXED,
                dwHeaderSize);

            if (lpbmIconInfoHeader) {
                CopyMemory(lpbmIconInfoHeader, lpResIcon, dwHeaderSize);
                lpbmIconInfoHeader->biHeight /= 2;
                dwBitmap = (lpbmIconInfoHeader->biWidth + 7) / 8 *
                    lpbmIconInfoHeader->biHeight * lpResIcon->biBitCount;
            } else {
                uAddr = 0;
            }

            lpBitmap = GlobalAlloc(GMEM_FIXED, dwBitmap);

            if (!lpBitmap) {
                uAddr = 0;
            }
        }

        UnlockResource(hResIcon);
UpdateIconFreeRes:
        FreeResource(hResIcon);

        if (uAddr == 0) {
            return (FALSE);
        }
    }

    {
        HDC hDC;

        // create a memory DC
        hDC = GetDC(hWnd);
        hMemDC = CreateCompatibleDC(hDC);
        ReleaseDC(hWnd, hDC);
    }

    hBitmap = CreateDIBSection(hMemDC, (LPBITMAPINFO)lpbmIconInfoHeader,
        DIB_RGB_COLORS, &lpBitmap_Section, NULL, 0);

    hOldBitmap = SelectObject(hMemDC, hBitmap);

    {
        HFONT   hOldFont;
        LOGFONT lfFont;
        RECT    rcRect;
        POINT   ptOffset;

        rcRect.left = rcRect.top = 0;
        // biHeight - 1, biHeight is not including
        rcRect.right = rcRect.bottom = lpbmIconInfoHeader->biHeight;

        hOldFont = GetCurrentObject(hMemDC, OBJ_FONT);
        GetObject(hOldFont, sizeof(lfFont), &lfFont);
        if (lpbmIconInfoHeader->biHeight >= ENBOLD_ICONSIZE) {
            lfFont.lfHeight = ((rcRect.bottom - rcRect.top) - 4 - 2) * (-1);
            ptOffset.x = 4;
            ptOffset.y = 3;
        } else if (lpbmIconInfoHeader->biHeight >= 22) {
            lfFont.lfHeight = ((rcRect.bottom - rcRect.top) - 4) * (-1);
            ptOffset.x = 3;
            ptOffset.y = 3;
        } else if (lpbmIconInfoHeader->biHeight >= 18) {
            lfFont.lfHeight = ((rcRect.bottom - rcRect.top) - 3) * (-1);
            ptOffset.x = 3;
            ptOffset.y = 3;
        } else {
            lfFont.lfHeight = ((rcRect.bottom - rcRect.top) - 4) * (-1);
            ptOffset.x = 3;
            ptOffset.y = 3;
        }

        lfFont.lfWidth  = 0;
        lfFont.lfWeight = 100;
        lfFont.lfOutPrecision = OUT_TT_ONLY_PRECIS;
        lfFont.lfPitchAndFamily = DEFAULT_PITCH|FF_DONTCARE;
        lfFont.lfFaceName[0] = '\0';
        LoadString(hInst, IDS_FONT_NAME, lfFont.lfFaceName,
            sizeof(lfFont.lfFaceName) / sizeof(TCHAR));
        hOldFont = SelectObject(hMemDC, CreateFontIndirect(&lfFont));

        SetBkColor(hMemDC, RGB(0xC0, 0xC0, 0xC0));      // light gray

        // write 1st DBCS to memory DC for shadow
        SetTextColor(hMemDC, RGB(0xFF, 0xFF, 0xFF));    // white
        ExtTextOut(hMemDC, rcRect.left + ptOffset.x, rcRect.top + ptOffset.y,
            ETO_OPAQUE, &rcRect, szIme_Name, (cntChar == 2) ? 1 : 2, NULL);

        // write 1st DBCS to memory DC
        SetTextColor(hMemDC, RGB(0x00, 0x00, 0xFF));    // blue
        SetBkMode(hMemDC, TRANSPARENT);
        ptOffset.x -= 1;
        ptOffset.y -= 1;
        ExtTextOut(hMemDC, rcRect.left + ptOffset.x, rcRect.top + ptOffset.y,
            ETO_CLIPPED, &rcRect, szIme_Name, (cntChar == 2) ? 1 : 2, NULL);

        // write 1st DBCS to memory DC to enbold it
        if (lpbmIconInfoHeader->biHeight > ENBOLD_ICONSIZE) {
            ptOffset.x -= 1;
            ExtTextOut(hMemDC,
                rcRect.left + ptOffset.x, rcRect.top + ptOffset.y,
                ETO_CLIPPED, &rcRect, szIme_Name, (cntChar == 2) ? 1 : 2, NULL);
        }

        SelectObject(hMemDC, GetStockObject(NULL_BRUSH));
        SelectObject(hMemDC, GetStockObject(BLACK_PEN));

        Rectangle(hMemDC, rcRect.left, rcRect.top,
            rcRect.right, rcRect.bottom);

        rcRect.right = rcRect.bottom = lpbmIconInfoHeader->biHeight - 1;
        MoveToEx(hMemDC, rcRect.left, rcRect.top + 1, NULL);
        LineTo(hMemDC, rcRect.left + 2, rcRect.top + 1);

        MoveToEx(hMemDC, rcRect.right, rcRect.top + 1, NULL);
        LineTo(hMemDC, rcRect.right - 2, rcRect.top + 1);

        MoveToEx(hMemDC, rcRect.left, rcRect.bottom - 1, NULL);
        LineTo(hMemDC, rcRect.left + 2, rcRect.bottom - 1);

        MoveToEx(hMemDC, rcRect.right, rcRect.bottom - 1, NULL);
        LineTo(hMemDC, rcRect.right - 2, rcRect.bottom - 1);

        GetDIBits(hMemDC, hBitmap, 0, lpbmIconInfoHeader->biHeight, lpBitmap,
            (LPBITMAPINFO)lpbmIconInfoHeader, DIB_RGB_COLORS);

        CopyMemory(&lpbMiniImeFileImage[uAddr + dwHeaderSize], lpBitmap, dwBitmap);
    }

    DeleteObject(SelectObject(hMemDC, hOldBitmap));
    DeleteObject(hMemDC);
    GlobalFree((HGLOBAL)lpbmIconInfoHeader);
    GlobalFree((HGLOBAL)lpBitmap);

    return (TRUE);
}

BOOL Process_Icon(
    HWND   hWnd,
    LPBYTE lpbMiniImeFileImage,
    UINT   uLen)
{
    HRSRC  hResIcon;
    LPVOID lpResIcon;
    int    nIconID32, nIconID16, nIconID18, nIconID22;

    // Get Icon from resource, use to find base IME Icon address
    hResIcon = LoadResource(hInst, FindResource(hInst,
        MAKEINTRESOURCE(IDIC_IME_ICON), RT_GROUP_ICON));

    if ( hResIcon == NULL )
       return FALSE;

    lpResIcon = LockResource(hResIcon);

    if ( lpResIcon == NULL )
    {
        FreeResource(hResIcon);
        return FALSE;
    }

    nIconID32 = LookupIconIdFromDirectoryEx(lpResIcon, TRUE,
        32, 32, LR_DEFAULTCOLOR);

    nIconID16 = LookupIconIdFromDirectoryEx(lpResIcon, TRUE,
        16, 16, LR_DEFAULTCOLOR);

    nIconID18 = LookupIconIdFromDirectoryEx(lpResIcon, TRUE,
        18, 18, LR_DEFAULTCOLOR);

    nIconID22 = LookupIconIdFromDirectoryEx(lpResIcon, TRUE,
        22, 22, LR_DEFAULTCOLOR);

    UnlockResource(hResIcon);
    FreeResource(hResIcon);

    if (!UpdateMiniIMEIcon(hWnd, lpbMiniImeFileImage, uLen, nIconID32)) {
        return (FALSE);
    }

    if (!UpdateMiniIMEIcon(hWnd, lpbMiniImeFileImage, uLen, nIconID16)) {
        return (FALSE);
    }

    if (!UpdateMiniIMEIcon(hWnd, lpbMiniImeFileImage, uLen, nIconID18)) {
        return (FALSE);
    }

    if (!UpdateMiniIMEIcon(hWnd, lpbMiniImeFileImage, uLen, nIconID22)) {
        return (FALSE);
    }

    return (TRUE);
}

BOOL Process_RT(HFILE hfFile, BYTE *szImeBuf, UINT Imelen, TCHAR *szPure_Name)
{
    HGLOBAL    hResData;
    TCHAR      szStr[MAX_CHAR_NUM+10];
    TCHAR      *szBuf;
    UINT       uAddr1,uAddr2;
    UINT       len,flen,i;
#ifdef UNICODE
	BOOL	   bUniCode = TRUE;	
	TCHAR	   *buf;
#endif
    LPVALIDCHAR  lpValidChar;

    // load valid char in choose/input state
    hResData = LoadResource(hInst, FindResource(hInst,
        MAKEINTRESOURCE(IDRC_VALIDCHAR), RT_RCDATA));
    
    if ( hResData == NULL )
    {
       return FALSE;
    }

    lpValidChar = (LPVALIDCHAR)LockResource(hResData);

    if ( lpValidChar == NULL )
    {
        FreeResource(hResData);
        return FALSE;
    }

    *(LPVALIDCHAR)&Valid = *lpValidChar;
    UnlockResource(hResData);
    FreeResource(hResData);

    uAddr1 = SearchMem((BYTE *)&Valid, sizeof(VALIDCHAR), szImeBuf, Imelen);
    if(uAddr1 == 0) 
	{
        ErrMsg(IDS_ERR_BASEIME, 0);
        return FALSE;
    }

    // IME table files
    hResData = LoadResource(hInst, FindResource(hInst,
        MAKEINTRESOURCE(IDRC_TABLEFILES), RT_RCDATA));

    if ( hResData == NULL )
       return FALSE;

    *(LPTABLEFILES)&Table = *(LPTABLEFILES)LockResource(hResData);
    UnlockResource(hResData);
    FreeResource(hResData);

    uAddr2 = SearchMem((BYTE *)&Table, sizeof(TABLEFILES), szImeBuf, Imelen);
    if(uAddr2 == 0) 
	{
        ErrMsg(IDS_ERR_BASEIME, 0);
        return FALSE;
    }

    // get  file length
    flen = _llseek(hfFile, 0L, 2);

    // Allocate Memory
    szBuf = (TCHAR *)GlobalAlloc(GMEM_FIXED, flen);
    if(!szBuf) 
	{
        ErrMsg(IDS_ERR_MEMORY, 0);
        return FALSE;
    }

#ifdef UNICODE
    _llseek(hfFile,0L,0);               // Skip 'FF FE'

	{
	BYTE ubuf[3];
    if(2 != _lread(hfFile, ubuf, 2)) 
	{
        GlobalFree((HGLOBAL)szBuf);
        ErrIOMsg(IDS_ERR_FILEREAD, szTab_Name);
        return FALSE;
	}

	if(ubuf[0] == 0xff && ubuf[1] == 0xfe) // UNICODE
		flen -= 2;
	else
	{
		_llseek(hfFile, 0L, 0);	
		bUniCode = 0;
	}

	}
#else
    _llseek(hfFile,0L,0);               // Move file pointer to begining
#endif

    // Read file to memory
    if(flen != _lread(hfFile, szBuf, flen)) 
	{
        GlobalFree((HGLOBAL)szBuf);
        ErrIOMsg(IDS_ERR_FILEREAD, szTab_Name);
        return FALSE;
    }
 
#ifdef UNICODE
	if(!bUniCode)
	{
		buf = (TCHAR *)GlobalAlloc(GMEM_FIXED, flen * 2);
		if(!buf) 
		{
			GlobalFree((HGLOBAL)szBuf);
			ErrMsg(IDS_ERR_MEMORY, 0);
			return FALSE;
		}

		i = MultiByteToWideChar(950, MB_PRECOMPOSED, (BYTE *)szBuf, flen,
							(LPTSTR)buf, flen);
		GlobalFree((HGLOBAL)szBuf);
		szBuf = buf;
		flen = i * 2;
	}
#endif

    // Allocate global memory
    hRadical = GlobalAlloc(GMEM_MOVEABLE, ALLOCBLOCK * sizeof(RADICALBUF));
    if(!hRadical) 
	{
        GlobalFree((HGLOBAL)szBuf);
        ErrMsg(IDS_ERR_MEMORY, 0);
        return FALSE;
    }

    nRadicalBuffsize = ALLOCBLOCK;
    iRadicalBuff = 0;
    lpRadical = (LPRADICALBUF)GlobalLock(hRadical);
    if(!lpRadical) 
	{
        GlobalFree((HGLOBAL)szBuf);
        GlobalFree(hRadical);
        ErrMsg(IDS_ERR_MEMORY, 0);
        return FALSE;
    }

    hPhrase = GlobalAlloc(GMEM_MOVEABLE, ALLOCBLOCK * sizeof(PHRASEBUF));
    if(!hPhrase) 
	{
        GlobalFree((HGLOBAL)szBuf);
        GlobalUnlock(hRadical);
        GlobalFree(hRadical);
        ErrMsg(IDS_ERR_MEMORY, 0);
        return FALSE;
    }
    nPhraseBuffsize = ALLOCBLOCK;
    iPhraseBuff = 0;
    lpPhrase = (LPPHRASEBUF)GlobalLock(hPhrase);
    if(!lpPhrase) 
	{
        GlobalFree((HGLOBAL)szBuf);
        GlobalUnlock(hRadical);
        GlobalFree(hRadical);
        GlobalFree(hPhrase);
        ErrMsg(IDS_ERR_MEMORY, 0);
        return FALSE;
    }

    len=0;
	idxLine = 0;
    for(i = 0; i < (flen/cntChar+1); i++)
	{
        if((szBuf[i] == 0x0d) || (szBuf[i] == 0x0a)) 
		{
            if(len != 0) 
			{
                if(!Parse(szStr, len))
                    break;
                len=0;
				idxLine ++;
            }
            continue;
        }

        if((szBuf[i] == 0x1a) || (i == flen/cntChar))
		{
            if(len != 0) 
			{
                if(!Parse(szStr, len))
                    break;
            }
            break;
        }

        if(len < MAX_CHAR_NUM)
            szStr[len ++] = szBuf[i];
    }

    GlobalFree((HGLOBAL)szBuf);

    if(!WritetoFile(szPure_Name)) 
	{
        GlobalUnlock(hRadical);
        GlobalUnlock(hPhrase);
        GlobalFree(hRadical);
        GlobalFree(hPhrase);
        return FALSE;
    }

    GlobalUnlock(hRadical);
    GlobalUnlock(hPhrase);
    GlobalFree(hRadical);
    GlobalFree(hPhrase);

    // Set Beep for candidates status
    Valid.fwProperties1 = (WORD)(bCandBeep ? 0 : 1);
    CopyMemory(&szImeBuf[uAddr1], &Valid, sizeof(VALIDCHAR));
    CopyMemory(&szImeBuf[uAddr2], &Table, sizeof(TABLEFILES));

    return TRUE;
}

int __cdecl subComp(const void *Pointer1, const void *Pointer2)
{
    LPRADICALBUF lpRadical1 = (LPRADICALBUF)Pointer1;
    LPRADICALBUF lpRadical2 = (LPRADICALBUF)Pointer2;
    WORD wWord1,wWord2;
    UINT i;

    for(i = 0; i < Valid.nMaxKey; i++) 
	{
        wWord1 = Valid.wChar2SeqTbl[lpRadical1->szRadical[i] - 0x20];
        wWord2 = Valid.wChar2SeqTbl[lpRadical2->szRadical[i] - 0x20];
        if(wWord1 == wWord2) 
            continue;

        if(wWord1 > wWord2)
            return 1;
        else
            return -1;
    }

    return 0;
}


BOOL WritetoFile(
    TCHAR *szPure_Name)
{
    HFILE      hTbl,hTblPtr,hTblCode;
    HANDLE     hKey;
    UCHAR      *szKey;
    UCHAR      szPtr[MAX_CHAR_NUM+10];
    TCHAR      szWindows[MAX_PATH];
    TCHAR      szFName[MAX_PATH];
    TCHAR      szTotal[MAX_CHAR_NUM];
    UCHAR      szPhrase[MAX_CHAR_NUM];
    UINT       len, i, j, k, l;
    UINT       nKey,nPtr,nBit,nByte;
    WORD       wlen,wTotalLen;
	WORD	   wSeq;
    WORD       wWord;
    DWORD      dwRadical; 
    BOOL       bPhrase;
    UINT       nAlloc;
#ifdef UNICODE
	DWORD	   lPtrlen,lPrevlen;
	UINT	   ii;
#else
	WORD	   wPtrlen,wPrevlen;
#endif



    // Get System directory
    len = GetSystemDirectory((LPTSTR)szWindows, sizeof(szWindows));
    if (szWindows[len - 1] != '\\') {     // consider C:\ ;
        szWindows[len++] = '\\';
        szWindows[len] = 0;
    }

    Valid.nMaxKey=szKey_Num_Str[0] - _TEXT('0');
    j=(UINT)Valid.nSeqCode;
    if(j < 1) {                                                        
        ErrMsg(IDS_ERR_NORADICAL, 0);
        return FALSE;
    }
    for(nBit=1; (j/=2) != 0; nBit++) ;
    nByte=(nBit * Valid.nMaxKey + 7) / 8;
    if(nByte > MAX_BYTE) {
        TCHAR      szErrStr[MAX_PATH];
        TCHAR      szShowMsg[MAX_PATH];
        UINT       nMaxKey;

        nMaxKey=(MAX_BYTE*8)/nBit;

		HideProgress();// <== @E01

        LoadString(hInst, IDS_ERR_OVER_BITLEN, szErrStr, sizeof(szErrStr) / sizeof(TCHAR));
        wsprintf(szShowMsg, szErrStr, Valid.nSeqCode, nMaxKey);
        MessageBox(NULL, szShowMsg, NULL, MB_OK | MB_ICONEXCLAMATION | MB_SETFOREGROUND);
        bOverMaxRadical=TRUE;                                      
        return FALSE;
    }
    qsort(lpRadical, iRadicalBuff, sizeof(RADICALBUF), subComp);


   // Allocate Memory
    nAlloc=ALLOCBLOCK*(nByte+sizeof(WORD));
    hKey = GlobalAlloc(GMEM_MOVEABLE, nAlloc+100);
    if(!hKey) {
        ErrMsg(IDS_ERR_MEMORY, 0);
        return FALSE;
    }
    szKey = GlobalLock(hKey);
    if(!szKey) {
        GlobalFree(hKey);
        ErrMsg(IDS_ERR_MEMORY, 0);
        return FALSE;
    }

    nKey=nByte+sizeof(WORD);
    ZeroMemory(szKey, nKey);
    ZeroMemory(szPtr, nKey);                                             //@D02A
    nPtr=0;
    bPhrase=FALSE;
    for(i=0; i<iRadicalBuff; i++) 
	{
        dwRadical=0;
        for(j=0; j<Valid.nMaxKey; j++) 
		{
            wSeq=Valid.wChar2SeqTbl[lpRadical[i].szRadical[j]-0x20];
           // Check using undefined radical
            if((wSeq == 0) && (lpRadical[i].szRadical[j] != _TEXT(' ')))
                break;
            dwRadical=(dwRadical << nBit)+wSeq;
        }

        if(j == Valid.nMaxKey) 
		{
            wWord=lpRadical[i].wCode;
            if(wWord != 0) 
			{
                if(nKey == nAlloc) 
				{
                    HANDLE hTemp;

                    nAlloc += ALLOCBLOCK*(nByte+sizeof(WORD));
                    GlobalUnlock(hKey);
                    hTemp= GlobalReAlloc(hKey, nAlloc+100, GMEM_MOVEABLE);
                    if(hTemp == NULL) 
					{
                        GlobalFree(hKey);
                        ErrMsg(IDS_ERR_MEMORY, 0);
                        return FALSE;
                    }
                    hKey=hTemp;
                    szKey=GlobalLock(hKey);
                    if(szKey == NULL) 
					{
                        GlobalFree(hKey);
                        ErrMsg(IDS_ERR_MEMORY, 0);
                        return FALSE;
                    }

                }
                *((LPUNADWORD)&szKey[nKey])=dwRadical; // <== @D05
                *((LPUNAWORD)&szKey[nKey+nByte])=wWord;// <== @D05
                // *((DWORD *)&szKey[nKey])=dwRadical;
                // *((WORD *)&szKey[nKey+nByte])=wWord;
                nKey+=(nByte+sizeof(WORD));
            }

            wTotalLen=GetPhrase(i, szTotal);
            if(wTotalLen == 0)
                continue;
#ifdef UNICODE
		    ZeroMemory(szPhrase, MAX_CHAR_NUM);
            wlen=0;
            for(k = 0; k < wTotalLen; k++) 
			{
                if(szTotal[k+1] != 1) 
				{
                    for(l = k; l < wTotalLen; l++) 
					{
                        *((TCHAR *)&szPhrase[wlen]) = szTotal[l];
						wlen += 2;
                        if(szTotal[l] == 1)
                            break;
                    }
                    k = l;
                } 
				else 
				{
                    if(nKey == nAlloc) 
					{
                        HANDLE hTemp;

                        nAlloc += ALLOCBLOCK*(nByte+sizeof(WORD));
                        GlobalUnlock(hKey);
                        hTemp= GlobalReAlloc(hKey, nAlloc+100, GMEM_MOVEABLE);
                        if(hTemp == NULL) 
						{
                            GlobalFree(hKey);
                            ErrMsg(IDS_ERR_MEMORY, 0);
                            return FALSE;
                        }
                        hKey=hTemp;
                        szKey=GlobalLock(hKey);
                        if(szKey == NULL) 
						{
                            GlobalFree(hKey);
                            ErrMsg(IDS_ERR_MEMORY, 0);
                            return FALSE;
                        }

                    }

                    // *((DWORD *)&szKey[nKey])=dwRadical;
                    *((LPUNADWORD)&szKey[nKey])=dwRadical; // <== @D05
                    //*((TCHAR *)&szKey[nKey+nByte]) = szTotal[k];
                    *((LPUNATCHAR)&szKey[nKey+nByte]) = szTotal[k]; // <== @D05
                    nKey += (nByte+sizeof(WORD));
					if(szTotal[k+1] == 1) k ++;
                }
            }
#else
            wlen=0;
            for(k=0; k<wTotalLen; k += 2) 
			{
                if(szTotal[k+1] & 0x80) 
				{
                    for(l=k; l<wTotalLen; l += 2) 
					{
                        szPhrase[wlen++] = szTotal[l];
                        szPhrase[wlen++] = szTotal[l+1];
                        if(!(szTotal[l+1] & 0x80))
                            break;
                    }
                    k = l;
                } 
				else 
				{
                    if(nKey == nAlloc) 
					{
                        HANDLE hTemp;

                        nAlloc += ALLOCBLOCK*(nByte+sizeof(WORD));
                        GlobalUnlock(hKey);
                        hTemp= GlobalReAlloc(hKey, nAlloc+100, GMEM_MOVEABLE);
                        if(hTemp == NULL) 
						{
                            GlobalFree(hKey);
                            ErrMsg(IDS_ERR_MEMORY, 0);
                            return FALSE;
                        }
                        hKey=hTemp;
                        szKey=GlobalLock(hKey);
                        if(szKey == NULL) 
						{
                            GlobalFree(hKey);
                            ErrMsg(IDS_ERR_MEMORY, 0);
                            return FALSE;
                        }

                    }

                    *((LPUNADWORD)&szKey[nKey])=dwRadical; // <== @D05
                    szKey[nKey+nByte] = szTotal[k];
                    szKey[nKey+nByte+1] = szTotal[k+1] | 0x80;
                    nKey += (nByte+sizeof(WORD));
                }
            }
#endif

            if(wlen == 0)
                continue;

            if(!bPhrase) 
			{
               // Use first 5 characters of IME filename as table header name
                len=lstrlen(szPure_Name);
                if(len > 5)
                    len=5;
                CopyMemory(Table.szTblFile[0], szPure_Name, len * cntChar);
                Table.szTblFile[0][len]=0;
                lstrcpy(Table.szTblFile[1], Table.szTblFile[0]);
                lstrcpy(Table.szTblFile[2], Table.szTblFile[0]);
                lstrcat(Table.szTblFile[0], _TEXT(".TBL"));
                lstrcat(Table.szTblFile[1], _TEXT("PTR.TBL"));
                lstrcat(Table.szTblFile[2], _TEXT("PHR.TBL"));

                lstrcpy(szFName, szWindows);
                lstrcat(szFName, Table.szTblFile[0]);
#ifdef UNICODE
				{
				char fname[MAX_PATH * 2];
				int lenx = lstrlen(szFName);
				WideCharToMultiByte(950, WC_COMPOSITECHECK, szFName, lenx,
					                   (LPSTR)fname, lenx, NULL, NULL);
				fname[lenx] = 0;
                hTbl=_lcreat(fname, 0);
				}
#else
                hTbl=_lcreat(szFName, 0);
#endif
                if(hTbl == -1) 
				{
                    ErrIOMsg(IDS_ERR_FILEOPEN, Table.szTblFile[0]);
                    GlobalUnlock(hKey);
                    GlobalFree(hKey);
                    return FALSE;
                }

                lstrcpy(szFName, szWindows);
                lstrcat(szFName, Table.szTblFile[1]);

#ifdef UNICODE
				{
				char fname[MAX_PATH * 2];
				int lenx = lstrlen(szFName);
				WideCharToMultiByte(950, WC_COMPOSITECHECK, szFName, lenx,
					                   (LPSTR)fname, lenx, NULL, NULL);
				fname[lenx] = 0;
                hTblPtr = _lcreat(fname, 0);
				}
#else
                hTblPtr = _lcreat(szFName, 0);
#endif
                if(hTblPtr == -1) 
				{
                    ErrIOMsg(IDS_ERR_FILEOPEN, Table.szTblFile[1]);
                    GlobalUnlock(hKey);
                    GlobalFree(hKey);
                    return FALSE;
                }

                lstrcpy(szFName, szWindows);
                lstrcat(szFName, Table.szTblFile[2]);

#ifdef UNICODE
				{
				char fname[MAX_PATH * 2];
				int lenx = lstrlen(szFName);
				WideCharToMultiByte(950, WC_COMPOSITECHECK, szFName, lenx,
					                   (LPSTR)fname, lenx, NULL, NULL);
				fname[lenx] = 0;
                hTblCode = _lcreat(fname, 0);
				}
#else
                hTblCode = _lcreat(szFName, 0);
#endif
                if(hTblCode == -1) {
                    ErrIOMsg(IDS_ERR_FILEOPEN, Table.szTblFile[2]);
                    GlobalUnlock(hKey);
                    GlobalFree(hKey);
                    return FALSE;
                }

#ifdef UNICODE
                nPtr = nByte+sizeof(DWORD);
#else
                nPtr = nByte+sizeof(WORD);
#endif
                //ZeroMemory(szKey, nPtr*2);
                ZeroMemory(szKey, nByte+sizeof(WORD) );
#ifdef UNICODE
                lPtrlen=0;
                lPrevlen=0;
#else
                wPtrlen=0;
                wPrevlen=0;
#endif
                bPhrase=TRUE;
            }

#ifdef UNICODE
			CopyMemory(szTotal, szPhrase, wlen + cntChar);

			ii = 0;
            for(j = 0; j < (UINT)wlen / cntChar; j ++) 
			{
                if(lPtrlen >= 0xfffffffd) 
				{
#else
            for(j = 0; j < (UINT)wlen; j += 2) 
			{
                if(wPtrlen >= 0xfffd) 
				{
#endif
                    ErrMsg(IDS_ERR_OVER_MAXLEN, 0);
                    GlobalUnlock(hKey);
                    GlobalFree(hKey);
                    return FALSE;
                }

#ifdef UNICODE
                if(szTotal[j] != 1) 
				{
	                lPtrlen++;
					// *((TCHAR *)&szPhrase[ii]) = szTotal[j];
					*((LPUNATCHAR)&szPhrase[ii]) = szTotal[j]; // <== @D05
					ii += 2;
					continue;
				}
#else
                wPtrlen++;
                if(*((LPUNAWORD)&szPhrase[j]) & END_PHRASE) // <== @D05
                    continue;
#endif

                if(nPtr >= MAX_CHAR_NUM) 
				{
                    // Write file from key buffer
                    if(nPtr != _lwrite(hTblPtr, (BYTE *)szPtr, nPtr)) 
					{
                        ErrIOMsg(IDS_ERR_FILEWRITE, Table.szTblFile[1]);
                        GlobalUnlock(hKey);
                        GlobalFree(hKey);
                        return FALSE;
                    }
                    nPtr=0;
                }

#ifndef UNICODE
                *((LPUNAWORD)&szPhrase[j]) |= END_PHRASE; // <== @D05
                *((LPUNADWORD)&szPtr[nPtr])=dwRadical; // <== @D05
                *((LPUNAWORD)&szPtr[nPtr+nByte])=wPrevlen; // <== @D05
                nPtr+=(nByte+sizeof(WORD));
                wPrevlen=wPtrlen;
#else
                *((LPUNADWORD)&szPtr[nPtr])=dwRadical; // <== @D05
                *((LPUNADWORD)&szPtr[nPtr+nByte])=lPrevlen; // <== @D05
                nPtr+=(nByte+sizeof(DWORD));
                lPrevlen=lPtrlen;
#endif
            }

#ifdef UNICODE
			wlen = ii / 2;
#endif

            if((wlen * (UINT)cntChar) != _lwrite(hTblCode, szPhrase, wlen * cntChar)) 
			{
                ErrIOMsg(IDS_ERR_FILEWRITE, Table.szTblFile[2]);
                GlobalUnlock(hKey);
                GlobalFree(hKey);
                return FALSE;
            }
        }
    }

    if(bPhrase) 
	{
        szPhrase[0] = (BYTE) 0xff;
        szPhrase[1] = (BYTE) 0xff;
        if(2 != _lwrite(hTblCode, (BYTE *)szPhrase, 2)) 
		{
            ErrIOMsg(IDS_ERR_FILEWRITE, Table.szTblFile[2]);
            GlobalUnlock(hKey);
            GlobalFree(hKey);
            return FALSE;
        }
        _lclose(hTblCode);
    } 
	else 
	{
        lstrcpy(Table.szTblFile[0], szPure_Name);
        lstrcat(Table.szTblFile[0], _TEXT(".TBL"));
        lstrcpy(szFName, szWindows);
        lstrcat(szFName, Table.szTblFile[0]);
#ifdef UNICODE
		{
		char fname[MAX_PATH * 2];
		int lenx = lstrlen(szFName);
		WideCharToMultiByte(950, WC_COMPOSITECHECK, szFName, lenx,
					           (LPSTR)fname, lenx, NULL, NULL);
		fname[lenx] = 0;
        hTbl = _lcreat(fname, 0);
		}
#else
        hTbl = _lcreat(szFName, 0);
#endif

        if(hTbl == -1) 
		{
            ErrIOMsg(IDS_ERR_FILEOPEN, Table.szTblFile[0]);
            GlobalUnlock(hKey);
            GlobalFree(hKey);
            return FALSE;
        }
    }

    for(i = 0; i < nByte+sizeof(WORD); i++)  
		szKey[nKey++] = (BYTE) 0xff;

    // Write file from key buffer

    if(nKey != _lwrite(hTbl, szKey, nKey)) 
	{
        ErrIOMsg(IDS_ERR_FILEWRITE, Table.szTblFile[0]);
        GlobalUnlock(hKey);
        GlobalFree(hKey);
        return FALSE;
    }
    _lclose(hTbl);
    GlobalUnlock(hKey);
    GlobalFree(hKey);

    if(bPhrase) 
	{
        for(i = 0; i < nByte; i++)  
			szPtr[nPtr++] = (BYTE) 0xff;
#ifdef UNICODE
        *((LPUNADWORD)&szPtr[nPtr]) = lPtrlen; // <== @D05
        nPtr += 4;
#else
        *((LPUNAWORD)&szPtr[nPtr]) = wPtrlen; // <== @D05
        nPtr += 2;
#endif
        // Write file from key buffer
        if(nPtr != _lwrite(hTblPtr, (BYTE *)szPtr, nPtr)) 
		{
            ErrIOMsg(IDS_ERR_FILEWRITE, Table.szTblFile[1]);
            return FALSE;
        }
        _lclose(hTblPtr);
    }

    return TRUE;
}


WORD GetPhrase(UINT iRadical, TCHAR *szPhrase)
{
    LPPHRASEBUF Phrase;
    WORD  wLen=0;
    UINT  iAddr;

    iAddr = lpRadical[iRadical].iFirst_Seg;
    if(iAddr == NULL_SEG)
        return 0;

    Phrase=&lpPhrase[iAddr];
    while(Phrase->iNext_Seg != NULL_SEG) 
	{
        if((wLen+SEGMENT_SIZE) > MAX_CHAR_NUM ) 
		{
            CopyMemory(&szPhrase[wLen], Phrase->szPhrase, (MAX_CHAR_NUM-wLen) * cntChar);
            wLen = MAX_CHAR_NUM;
            szPhrase[wLen] = 0;
            return wLen;
        }

        CopyMemory((char *)(szPhrase + wLen), Phrase->szPhrase, SEGMENT_SIZE * cntChar);
        Phrase = &lpPhrase[Phrase->iNext_Seg];
        wLen += SEGMENT_SIZE;
    }

    if((wLen+SEGMENT_SIZE) > MAX_CHAR_NUM ) 
	{
        CopyMemory(szPhrase + wLen, Phrase->szPhrase, (MAX_CHAR_NUM-wLen) * cntChar);
        wLen = MAX_CHAR_NUM;
    } 
	else 
	{
        CopyMemory(szPhrase + wLen, Phrase->szPhrase, SEGMENT_SIZE * cntChar);
        wLen += SEGMENT_SIZE;
    }

    szPhrase[wLen] = 0;
    wLen = (WORD)lstrlen(szPhrase);

    return wLen;
}

BOOL Parse(TCHAR *szStr, UINT len)
{
    UINT i,j,k;
    TCHAR szRadical[MAX_RADICAL];

    // Skip blank
    for(i=0; (i<len) && (szStr[i] == _TEXT(' ') || szStr[i] == _TEXT('\t')); i++) ;
    if(i == len)
        return TRUE;

	j = len - 1;
	while(szStr[j] == _TEXT(' ') || szStr[j] == _TEXT('\t'))
	{
		j --;
		len --;
	}

    // Check Command Code       9/29/97 change logic
    if(szStr[i] == _TEXT('/')) 
	{
       // Check Radical Command
        switch (szStr[i+1])
        {
           // Symbol
           case _TEXT('s'):
           case _TEXT('S'):

               for(j=i+2; (j<len) && (szStr[j] == _TEXT(' ') || szStr[j] == _TEXT('\t')); j++) ;
               if(j >= len)
                  return TRUE;

               for(i=j+1; i<len; i++) 
			   {
                 if(!PutRadical(szStr[j]++, *((LPUNAWORD)(&szStr[i])))) // <== @D05
                    return TRUE;
#ifndef UNICODE
                 i++;
#endif
               }
               break;

           // Interpret '/' literally
           case _TEXT('/'):
               i++;
               goto GET_RADICAL;

           // Reserve for future use
           default:
               return TRUE;
        }
    }
               
	else 
	{
GET_RADICAL:
        // Get Radical
		MyFillMemory(szRadical, MAX_RADICAL, _TEXT(' '));

        k=0;
        for(j=i; (j<len) && (k<MAX_RADICAL) && ((szStr[j] != _TEXT(' ')) && (szStr[j] != _TEXT('\t'))); j++) 
		{
            // Make Uppercase
            if((szStr[j] >= _TEXT('a')) && (szStr[j] <= _TEXT('z')))
                szStr[j] -= ('a'-'A');
            szRadical[k++] = szStr[j];
        }

        if(j == len)
            return TRUE;

        if(k==MAX_RADICAL) 
		{
            // Skip radical of over length
            for(i=j; (j<len) && (szStr[j] != _TEXT(' ')); j++) ;
            if(i == len)
                return TRUE;
            j=i;
        }

        // Skip blank
        for(i=j; (i<len) && (szStr[i] == _TEXT(' ') || szStr[i] == _TEXT('\t')); i++) ;
        if(i == len)
            return TRUE;
        if(!PutPhrase(szRadical, &szStr[i], len-i))
            return FALSE;
    }


    return TRUE;
}


UINT SearchMem(BYTE *szSrc, UINT nSrc, BYTE *szTag, UINT nTar)
{
	UINT i,j;

    for(i = 0; i < nTar; i ++) 
	{
        for(j = 0; j < nSrc; j ++)
            if(szSrc[j] != szTag[i+j])
                break;

        if(j == nSrc)
            return(i);
    }

    return(0);
}

BOOL PutRadical(TCHAR cRadical, WORD wChinese)
{
	UINT iAddr;

    // Make Uppercase
    if((cRadical >= _TEXT('a')) && (cRadical <= _TEXT('z')))
        cRadical -= ('a' - 'A');

    // Check Radical
    if((cRadical < 0x20) || (cRadical > 0x5f))
        return FALSE;

    // Check DBCS
    if(!is_DBCS(wChinese)) 
	{
        ErrMsg(IDS_ERR_SBCS, 0);
        return FALSE;
    }

    iAddr = cRadical - 0x20;
    if(Valid.wChar2SeqTbl[iAddr] != 0)
        return FALSE;

    Valid.wChar2SeqTbl[iAddr] = (++Valid.nSeqCode);
    Valid.wSeq2CompTbl[Valid.nSeqCode] = wChinese;
    Valid.fChooseChar[iAddr/16] |= (1 << (iAddr % 16));
    Valid.fCompChar[iAddr/16] |= (1 << (iAddr % 16));

    return TRUE;
}

BOOL PutPhrase(TCHAR *szRadical, TCHAR *szPhrase, UINT len)
{
    LPPHRASEBUF Phrase;
    UINT iAddr,iRadical;
    UINT iStart,i,j;
    TCHAR szBuf[MAX_PATH];
    UINT iBuflen;

#ifndef UNICODE  // <==	  @E02

    // Check DBCS
    for(i = 0; i < len; i++) 
	{
        if(szPhrase[i] == _TEXT(' '))
            continue;

        if(!is_DBCS(*((LPUNAWORD)(&szPhrase[i])))) // <== @D05
		{
            //ErrMsg(IDS_ERR_SBCS, 0);

			TCHAR szErrStr[MAX_PATH];
			TCHAR szStr1[MAX_PATH];
			TCHAR szStr2[MAX_PATH];
			LoadString(hInst, IDS_ERR_SBCS, szStr1, sizeof(szStr1) / sizeof(TCHAR));
			wsprintf(szErrStr, _TEXT(" %d  : "), idxLine + 1);
			CopyMemory(szStr2, szPhrase, len * cntChar);
			szStr2[len] = 0;
			lstrcat(szErrStr, szStr2);
			lstrcat(szErrStr, _TEXT("\n"));
			lstrcat(szErrStr, szStr1);
			if (MessageBox(NULL, szErrStr, NULL, MB_OKCANCEL | MB_ICONEXCLAMATION | MB_SETFOREGROUND) 
					== IDCANCEL)
				return FALSE;
			else
				return TRUE;  // 
        }
        i++;
    }
#endif // <==	  @E02

    // Search Radical buffer
    for(i = 0; i < iRadicalBuff; i++) 
	{
        for(j = 0; j < MAX_RADICAL; j++)
            if(lpRadical[i].szRadical[j] != szRadical[j])
                break;

        if(j == MAX_RADICAL)
            break;
    }

    // Allocate new buffer if New Radical
    if(i == iRadicalBuff) 
	{
        if(iRadicalBuff+1 == nRadicalBuffsize)
            if(!AllocRadical())
                return FALSE;

        CopyMemory(lpRadical[i].szRadical, szRadical, MAX_RADICAL * cntChar);
        iRadicalBuff++;
        lpRadical[i].iFirst_Seg = NULL_SEG;
        lpRadical[i].wCode = 0;
    }

    // Search Starting address in Phrase table
    iRadical = i;
    iAddr = lpRadical[i].iFirst_Seg;
    if(iAddr != NULL_SEG) 
	{
        Phrase = &lpPhrase[iAddr];
        while(Phrase->iNext_Seg != NULL_SEG)
            Phrase=&lpPhrase[Phrase->iNext_Seg];

        for(i = 0; i < SEGMENT_SIZE; i++)
            if(Phrase->szPhrase[i] == 0)
                break;

        iStart = i;
    }

    // Put Phrase
    iBuflen = 0;
    for(i = 0; i < len; i++) 
	{
        if(szPhrase[i] != _TEXT(' ') && (szPhrase[i] != _TEXT('\t'))) 
		{
            szBuf[iBuflen++] = szPhrase[i];
            if((i+1) != len)
                continue;
        }

        if(iBuflen == 0)
            continue;

#ifdef UNICODE
        if((iBuflen == 1) && (lpRadical[iRadical].wCode == 0)) 
		{
            lpRadical[iRadical].wCode = szBuf[0];
        } 
		else 
		{
#else
        if((iBuflen == 2) && (lpRadical[iRadical].wCode == 0)) 
		{
            lpRadical[iRadical].wCode = (((WORD)szBuf[0])<< 8)+
                                      (WORD)szBuf[1];
        } 
		else 
		{
            szBuf[iBuflen-2] &= 0x7f;
#endif
//			if(lpRadical[iRadical].wCode == 0)
//				return FALSE;

            if(iAddr == NULL_SEG) 
			{
                if(iPhraseBuff + 1 == nPhraseBuffsize)
                    if(!AllocPhrase())
                        return FALSE;

                lpRadical[iRadical].iFirst_Seg=iPhraseBuff;
                iAddr=iPhraseBuff;
                Phrase=&lpPhrase[iAddr];
                ZeroMemory(Phrase->szPhrase, SEGMENT_SIZE * cntChar);
                Phrase->iNext_Seg=NULL_SEG;
                iPhraseBuff++;
                iStart=0;
            }

#ifdef UNICODE
            for(j = 0; j < iBuflen; j ++) 
#else
            for(j = 0; j < iBuflen; j += 2) 
#endif
			{
                if(iStart == SEGMENT_SIZE) 
				{
                    if(iPhraseBuff + 1 == nPhraseBuffsize)
                        if(!AllocPhrase())
                            return FALSE;

					Phrase=&lpPhrase[iAddr];

                    while (Phrase->iNext_Seg != NULL_SEG)
                         Phrase=&lpPhrase[Phrase->iNext_Seg];

                    Phrase->iNext_Seg=iPhraseBuff;
                    Phrase=&lpPhrase[iPhraseBuff];
                    ZeroMemory(Phrase->szPhrase, SEGMENT_SIZE * cntChar);
                    Phrase->iNext_Seg=NULL_SEG;
                    iPhraseBuff++;
                    iStart=0;
                }

#ifdef UNICODE
                *((LPUNAWORD)&Phrase->szPhrase[iStart ++]) = szBuf[j]; // <== @D05
#else
                *((LPUNAWORD)&Phrase->szPhrase[iStart])= // <== @D05
                    (((WORD)szBuf[j])<< 8)+ (WORD)szBuf[j+1];
                iStart += 2;
#endif
            }

#ifdef UNICODE

            if(iStart == SEGMENT_SIZE)
            {
                 if(iPhraseBuff + 1 == nPhraseBuffsize)
                     if(!AllocPhrase())
                         return FALSE;

                 Phrase=&lpPhrase[iAddr];

                 while (Phrase->iNext_Seg != NULL_SEG)
                      Phrase=&lpPhrase[Phrase->iNext_Seg];

                 Phrase->iNext_Seg=iPhraseBuff;
                 Phrase=&lpPhrase[iPhraseBuff];
                 ZeroMemory(Phrase->szPhrase, SEGMENT_SIZE * cntChar);
                 Phrase->iNext_Seg=NULL_SEG;
                 iPhraseBuff++;
                 iStart=0;
            }

            *((LPUNAWORD)&Phrase->szPhrase[iStart ++]) = 1; // <== @D05
#endif
        }

        iBuflen=0;
    }

    return TRUE;
}

BOOL AllocRadical()
{
    HANDLE hTemp;

    nRadicalBuffsize += ALLOCBLOCK;
    GlobalUnlock(hRadical);
    hTemp= GlobalReAlloc(hRadical, nRadicalBuffsize * sizeof(RADICALBUF),
                         GMEM_MOVEABLE);
    if(hTemp == NULL) 
	{
        nRadicalBuffsize -= ALLOCBLOCK;
        ErrMsg(IDS_ERR_MEMORY, 0);
        return FALSE;
    }

    hRadical=hTemp;
    lpRadical=(LPRADICALBUF)GlobalLock(hRadical);
    if(lpRadical == NULL) 
	{
        nRadicalBuffsize -= ALLOCBLOCK;
        ErrMsg(IDS_ERR_MEMORY, 0);
        return FALSE;
    }

    return TRUE;
}

BOOL AllocPhrase()
{
    HANDLE hTemp;

    nPhraseBuffsize += ALLOCBLOCK;
    GlobalUnlock(hPhrase);
    hTemp= GlobalReAlloc(hPhrase, nPhraseBuffsize * sizeof(PHRASEBUF),
                         GMEM_MOVEABLE);

    if(hTemp == NULL) 
	{
        nPhraseBuffsize -= ALLOCBLOCK;
        ErrMsg(IDS_ERR_MEMORY, 0);
        return FALSE;
    }

    hPhrase=hTemp;
    lpPhrase=(LPPHRASEBUF)GlobalLock(hPhrase);
    if(lpPhrase == NULL) 
	{
        nPhraseBuffsize -= ALLOCBLOCK;
        ErrMsg(IDS_ERR_MEMORY, 0);
        return FALSE;
    }

    return TRUE;
}

BOOL is_DBCS(UINT wWord)
{
#ifdef UNICODE
    if(wWord < 0x0080)
        return FALSE;
#else
    if((LOBYTE(wWord) < 0x81) || (LOBYTE(wWord) > 0xFE))
        return FALSE;
    if((HIBYTE(wWord) < 0x40) || (HIBYTE(wWord) > 0xFE))
        return FALSE;
#endif
    return TRUE;
}

void ErrMsg(UINT iMsgID, UINT iTitle)
{
    TCHAR szErrStr[MAX_PATH];
    TCHAR szTitle[MAX_PATH];

	HideProgress(); // <== @E01

    LoadString(hInst, iTitle, szTitle, sizeof(szTitle) / sizeof(TCHAR));
    LoadString(hInst, iMsgID, szErrStr, sizeof(szErrStr) / sizeof(TCHAR));
    MessageBox(NULL, szErrStr, (iTitle) ? szTitle : NULL, MB_OK | MB_ICONEXCLAMATION | MB_SETFOREGROUND | MB_TASKMODAL);

	ShowProgress();// <== @E01
}

void ErrIOMsg(UINT iMsgID, TCHAR *szFileName)
{
    TCHAR szErrStr[MAX_PATH];
    TCHAR szShowMsg[MAX_PATH];

	HideProgress();// <== @E01

    LoadString(hInst, iMsgID, szErrStr, sizeof(szErrStr) / sizeof(TCHAR));
    wsprintf(szShowMsg, szErrStr, szFileName);
    MessageBox(NULL, szShowMsg, NULL, MB_OK | MB_ICONEXCLAMATION | MB_SETFOREGROUND | MB_TASKMODAL);

	ShowProgress();// <== @E01
}

void MyFillMemory(TCHAR *dst, DWORD cnt, TCHAR v)
{
#ifdef UNICODE
	DWORD i;
	for(i = 0; i < cnt; i ++)
		dst[i] = v;
#else	
	FillMemory(dst, cnt, v);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\uimetool\uimetool.h ===
/*************************************************
 *  uimetool.h                                   *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

//
//  1/17/96
//	  @E01		Change for multi-threading
//	  @E02		Change for multi-threading without extending function
//
#include <commctrl.h>

//
#define MAX_CHAR_NUM      1000
#define SEGMENT_SIZE      60
#define NULL_SEG          0xffff
#define MAX_RADICAL       8
#define ALLOCBLOCK        1000
#define MAX_BYTE          4


// Help ID declarations
#define IDH_IME_NAME             3001
#define IDH_TABLE_NAME           3002
#define IDH_ROOT_NUM             3003
#define IDH_IME_FILE_NAME        3004
#define IDH_CANDBEEP_YES         3005
#define IDH_CANDBEEP_NO          3006

//
#define SOURCE_IME_NAME   _TEXT("MINIIME")
#define LIBRARY_NAME      _TEXT("MINIIME.TPL")
#define HELP_FILE         _TEXT("UIMETOOL.CHM")
#define IME_NAME_LEN_TOOL 5
#define TAB_NAME_LEN      13   //filename  8.3 + NULL
#define KEY_NUM_STR_LEN   2
#define END_PHRASE        0x8000
#define NOT_END_PHRASE    0x7f

//
BOOL FAR PASCAL SetDialogProc( HWND, unsigned, WORD, LONG);

void  GetOpenFile(HWND);
BOOL  CheckInput(HWND);
BOOL  MakeNewIme(HWND);
//unsigned _stdcall MakeNewImeThread(LPVOID voidparam); // <== @E01
void MakeNewImeThread(LPVOID voidparam); // <== @E02
BOOL  is_DBCS(UINT);

//-------------------------------------------------------------------------
// Memory blobal variable declarations.
//
// Warning : iFirst_Seg & iNext_Seg store only SEGMENT number but address
//           for address can not mainten after GlobalRealloc
//
typedef struct{
    UINT   iFirst_Seg;
    TCHAR  szRadical[MAX_RADICAL];
    WORD   wCode;
    } RADICALBUF, FAR *LPRADICALBUF;

typedef struct STRUCT_PHRASE{
    UINT   iNext_Seg;
    TCHAR  szPhrase[SEGMENT_SIZE];
    } PHRASEBUF, FAR *LPPHRASEBUF;

HANDLE       hRadical;
UINT         nRadicalBuffsize;
UINT         iRadicalBuff;
LPRADICALBUF lpRadical;

HANDLE       hPhrase;
UINT         nPhraseBuffsize;
UINT         iPhraseBuff;
LPPHRASEBUF  lpPhrase;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\uimetool\wizard.h ===
/*************************************************
 *  wizard.h                                     *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

                            
// constants
#define NUM_PAGES	3
#define MAX_BUF		5000
#define MAX_LINE	512

// Function prototypes

// Pages for Wizard
INT_PTR APIENTRY ImeName(HWND, UINT, WPARAM, LPARAM);
INT_PTR APIENTRY ImeTable(HWND, UINT, WPARAM, LPARAM);
INT_PTR APIENTRY ImeParam(HWND, UINT, WPARAM, LPARAM);

//functions
int CreateWizard(HWND, HINSTANCE);
void FillInPropertyPage( PROPSHEETPAGE* , int, LPTSTR, DLGPROC);
void GenerateReview(HWND);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\uimetool\winmain.c ===
/*************************************************
 *  winmain.c                                    *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

//
//  1/17/96
//	  @E01		Change for multi-threading
//	  @E02		Change for multi-threading without extending function

#include <windows.h>            // required for all Windows applications
#include <tchar.h>
#include <process.h>   // <=== @E01
#include <commctrl.h>  // <=== @E01
#include <htmlhelp.h>
#include "rc.h"                 // prototypes specific to this application
#include "uimetool.h"
#include "wizard.h"
#include "imeattr.h"
#include "imerc.h"
#include "imm.h"

#ifdef UNICODE
	typedef DWORD UNALIGNED FAR *LPUNADWORD;
	typedef WORD UNALIGNED FAR *LPUNAWORD;
	typedef TCHAR UNALIGNED FAR *LPUNATCHAR;
#else
	typedef DWORD FAR *LPUNADWORD;
	typedef WORD FAR *LPUNAWORD;
	typedef TCHAR FAR *LPUNATCHAR;
#define TCHAR BYTE
#endif

HINSTANCE hInst;
HWND hProgMain = 0; // <=== @E01

const static DWORD aLCtoolHelpIDs[] = { // Context Help IDs
    IDD_IME_NAME,           IDH_IME_NAME,
    IDD_TABLE_NAME,         IDH_TABLE_NAME,
    IDD_ROOT_NUM,           IDH_ROOT_NUM,
    IDD_IME_FILE_NAME,      IDH_IME_FILE_NAME,
    IDD_CANDBEEP_YES,       IDH_CANDBEEP_YES,
    IDD_CANDBEEP_NO,        IDH_CANDBEEP_NO,
    IDD_BROWSE,             IDH_TABLE_NAME,
    0, 0
};

BOOL ErrorFlag = 0;
BOOL bFinish = 0;
UINT nWizStratPage = 0;

extern HWND hwndMain;
extern TCHAR szIme_Name[IME_NAME_LEN_TOOL];
extern TCHAR szTab_Name[MAX_PATH];
extern TCHAR szKey_Num_Str[KEY_NUM_STR_LEN];
extern TCHAR szFile_Out_Name[TAB_NAME_LEN];
extern TCHAR Show_Mess[MAX_PATH];
extern TCHAR Msg_buf[MAX_PATH];
extern BOOL  bCandBeep;

void  ErrMsg(UINT, UINT);

BOOL CheckImeFileName(HWND hDlg);
void ImmSetAlphanumMode(HWND hwnd);
void ImmSetNativeMode(HWND hwnd);

BOOL InitProgressMsg(void); // <=== @E01
BOOL ProgressMsg(void);		// <=== @E01

void ResetParams(void)
{
	lstrcpy(szIme_Name, _TEXT(""));
	lstrcpy(szFile_Out_Name, _TEXT(""));
	lstrcpy(szTab_Name, _TEXT(""));
	lstrcpy(szKey_Num_Str, _TEXT("4"));
	bCandBeep = TRUE;

	nWizStratPage = 0;
}

int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    DWORD retCode;
	// DWORD dwID;

    UNREFERENCED_PARAMETER( nCmdShow );
    UNREFERENCED_PARAMETER( lpCmdLine );
    UNREFERENCED_PARAMETER( hPrevInstance );

    hInst   = hInstance;

	InitCommonControls();

    //retCode = DialogBox ((HANDLE)hInst, (LPCTSTR)_TEXT("UimeToolDialog"),
    //                      NULL, (DLGPROC)SetDialogProc);
	ResetParams();

RE_START:
	bFinish = 0;
    retCode = CreateWizard(NULL, hInstance);

	if(bFinish)
	{
        //SetCursor(LoadCursor(NULL, IDC_WAIT));
        //MakeNewIme(hDlg);
		// <=== @E01
		if (InitProgressMsg()) {
			//_beginthreadex(NULL, 0, MakeNewImeThread, NULL, 0, &dwID);
			_beginthread((PVOID)MakeNewImeThread, 0, NULL);
			// AttachThreadInput(dwID, GetCurrentThreadId(), TRUE);
			ProgressMsg();

			if (!bFinish) {
				nWizStratPage = 2;
				goto RE_START;
			}
		}
		// <=== @E01
        //SetCursor(LoadCursor(NULL, IDC_ARROW));
	}

    return  (retCode);

}

INT_PTR APIENTRY ImeName(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
		case WM_INITDIALOG:
			hwndMain = hDlg;
            SendDlgItemMessage(hDlg, IDD_IME_NAME, EM_SETLIMITTEXT, IME_NAME_LEN_TOOL-1, 0);
            SendDlgItemMessage(hDlg, IDD_IME_FILE_NAME, EM_SETLIMITTEXT, TAB_NAME_LEN-1, 0);

			//lstrcpy(szIme_Name, _TEXT(""));
			//lstrcpy(szFile_Out_Name, _TEXT(""));
			break;

		case WM_COMMAND:
			if(LOWORD(wParam) == IDD_IME_NAME)
			{
				if(HIWORD(wParam) == EN_SETFOCUS)
					ImmSetNativeMode((HWND)lParam);
				else if(HIWORD(wParam) == EN_KILLFOCUS)
					ImmSetAlphanumMode((HWND)lParam);
			}
			else if(LOWORD(wParam) == IDD_IME_FILE_NAME)
			{
				if(HIWORD(wParam) == EN_SETFOCUS)
					ImmSetAlphanumMode((HWND)lParam);
				else if(HIWORD(wParam) == EN_KILLFOCUS)
				{
					ImmSetNativeMode((HWND)lParam);
					ErrorFlag = !CheckImeFileName(hDlg);
				}
			}
			break;

		case WM_NOTIFY:
    		switch (((NMHDR FAR *) lParam)->code) 
    		{
  				case PSN_KILLACTIVE:
					SetWindowLong(hDlg,	DWLP_MSGRESULT, ErrorFlag ? TRUE : FALSE);
					return 1;
					break;

				case PSN_RESET:
					// reset to the original values
					lstrcpy(szIme_Name, _TEXT(""));
					lstrcpy(szFile_Out_Name, _TEXT(""));
	           		SetWindowLong(hDlg,	DWLP_MSGRESULT, FALSE);
					break;

 				case PSN_SETACTIVE:
					hwndMain = hDlg;
	    			PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);
					SendMessage(GetDlgItem(hDlg,0x3024 ), BM_SETSTYLE, (WPARAM)BS_PUSHBUTTON, MAKELONG(FALSE, 0));
					//SendMessage(GetParent(hDlg), DM_SETDEFID, (WPARAM)IDC_BUTTON1, 0);
					SendMessage(GetDlgItem(hDlg, IDD_IME_NAME), WM_SETTEXT, 0, (LPARAM)szIme_Name);
					SendMessage(GetDlgItem(hDlg, IDD_IME_FILE_NAME), WM_SETTEXT, 0, (LPARAM)szFile_Out_Name);
					break;

                case PSN_WIZNEXT:
					// the Next button was pressed
					// check ime name
		 			SendDlgItemMessage(hDlg, IDD_IME_NAME, WM_GETTEXT, (WPARAM)IME_NAME_LEN_TOOL, (LPARAM)szIme_Name);
					if(szIme_Name[0] == 0 || !is_DBCS(*((LPUNAWORD)szIme_Name))) 
					{
						MessageBeep(0);
						ErrMsg(IDS_ERR_IMENAME, IDS_ERR_ERROR);
						SetFocus(GetDlgItem(hDlg, IDD_IME_NAME));
						ErrorFlag = 1;
						break;
					}

					// check file name
					ErrorFlag = !CheckImeFileName(hDlg);
     				break;

				default:
					return FALSE;

    		}
			break;

        case WM_HELP:
            HtmlHelp(((LPHELPINFO) lParam)->hItemHandle, HELP_FILE,
                HH_TP_HELP_WM_HELP, (DWORD_PTR)(LPTSTR) aLCtoolHelpIDs);
            break;

        case WM_CONTEXTMENU:   // right mouse click
            HtmlHelp((HWND) wParam, HELP_FILE, HH_TP_HELP_CONTEXTMENU,
                (DWORD_PTR)(LPVOID) aLCtoolHelpIDs);
            break;

		default:
			return FALSE;
	}
	return TRUE;   
}

INT_PTR APIENTRY ImeTable(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
		case WM_INITDIALOG:
			hwndMain = hDlg;
			//lstrcpy(szTab_Name, _TEXT(""));
			break;

		case WM_COMMAND:
			switch(LOWORD(wParam))
			{
                case IDD_BROWSE:
                    GetOpenFile(hDlg);
                    break;

				case IDD_TABLE_NAME:
					if(HIWORD(wParam) == EN_SETFOCUS)
						ImmSetAlphanumMode((HWND)lParam);
					else if(HIWORD(wParam) == EN_KILLFOCUS)
						ImmSetNativeMode((HWND)lParam);
					break;
			}
			break;
						
		case WM_NOTIFY:
    		switch (((NMHDR FAR *) lParam)->code) 
    		{
  				case PSN_KILLACTIVE:
					SetWindowLong(hDlg,	DWLP_MSGRESULT, ErrorFlag ? TRUE : FALSE);
					return 1;
					break;

				case PSN_RESET:
					// rest to the original values
					lstrcpy(szTab_Name, _TEXT(""));
	           		SetWindowLong(hDlg,	DWLP_MSGRESULT, FALSE);
					break;

 				case PSN_SETACTIVE:
					hwndMain = hDlg;
					SendMessage(GetDlgItem(hDlg, IDD_TABLE_NAME), WM_SETTEXT, 0, (LPARAM)szTab_Name);
 					PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
					break;

                case PSN_WIZBACK:
		 			SendDlgItemMessage(hDlg, IDD_TABLE_NAME, WM_GETTEXT, (WPARAM)MAX_PATH, (LPARAM)szTab_Name);
					ErrorFlag = 0;
					break;

                case PSN_WIZNEXT:
		 			SendDlgItemMessage(hDlg, IDD_TABLE_NAME, WM_GETTEXT, (WPARAM)MAX_PATH, (LPARAM)szTab_Name);
					if(szTab_Name[0] == 0) 
					{
						MessageBeep(0);
						SetFocus(GetDlgItem(hDlg, IDD_TABLE_NAME));
						ErrorFlag = 1;
						return FALSE;
					}
					ErrorFlag = 0;
                    break;

				default:
					return FALSE;

    		}
			break;

        case WM_HELP:
            HtmlHelp(((LPHELPINFO) lParam)->hItemHandle, HELP_FILE,
                HH_TP_HELP_WM_HELP, (DWORD_PTR)(LPTSTR) aLCtoolHelpIDs);
            break;

        case WM_CONTEXTMENU:   // right mouse click
            HtmlHelp((HWND) wParam, HELP_FILE, HH_TP_HELP_CONTEXTMENU,
                (DWORD_PTR)(LPVOID) aLCtoolHelpIDs);
            break;

		default:
			return FALSE;
	}
	return TRUE;   
}

INT_PTR APIENTRY ImeParam(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
		case WM_INITDIALOG:
			hwndMain = hDlg;
			//lstrcpy(szKey_Num_Str, _TEXT("4"));
			//bCandBeep = TRUE;
            SendDlgItemMessage(hDlg, IDD_ROOT_NUM, EM_SETLIMITTEXT, KEY_NUM_STR_LEN-1, 0);
			SendDlgItemMessage(hDlg, IDD_SPIN, UDM_SETBUDDY, (WPARAM)GetDlgItem(hDlg, IDD_ROOT_NUM), 0);
			SendDlgItemMessage(hDlg, IDD_SPIN, UDM_SETBASE, 10, 0);
			SendDlgItemMessage(hDlg, IDD_SPIN, UDM_SETRANGE, 0, (LPARAM)(MAKELONG(8, 1)));
			SendDlgItemMessage(hDlg, IDD_SPIN, UDM_SETPOS, 0, (LPARAM)(MAKELONG(4, 0)));
			break;

		case WM_COMMAND:
			if(LOWORD(wParam) == IDD_ROOT_NUM)
			{
				switch(HIWORD(wParam))
				{
					case EN_SETFOCUS:
						ImmSetAlphanumMode((HWND)lParam);
						break;

					case EN_KILLFOCUS:
						ImmSetNativeMode((HWND)lParam);
						break;
				}
			}
			break;

		case WM_NOTIFY:
    		switch (((NMHDR FAR *) lParam)->code) 
    		{
  				case PSN_KILLACTIVE:
					SetWindowLong(hDlg,	DWLP_MSGRESULT, ErrorFlag ? TRUE : FALSE);
					return 1;
					break;

				case PSN_RESET:
					// rest to the original values
					lstrcpy(szKey_Num_Str, _TEXT("4"));
					bCandBeep = TRUE;
	           		SetWindowLong(hDlg,	DWLP_MSGRESULT, FALSE);
					break;

 				case PSN_SETACTIVE:
					hwndMain = hDlg;
					SendMessage(GetDlgItem(hDlg, IDD_ROOT_NUM), WM_SETTEXT, 0, (LPARAM)szKey_Num_Str);
					if(bCandBeep)
						SendMessage(GetDlgItem(hDlg, IDD_CANDBEEP_YES), BM_SETCHECK, 1, 0L);
					PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_FINISH);
					break;

                case PSN_WIZBACK:
					ErrorFlag = 0;
		 			SendDlgItemMessage(hDlg, IDD_ROOT_NUM, WM_GETTEXT, (WPARAM)KEY_NUM_STR_LEN, (LPARAM)szKey_Num_Str);
				    if(SendDlgItemMessage(hDlg, IDD_CANDBEEP_YES, BM_GETCHECK, 0, 0 ) == BST_CHECKED )
						bCandBeep=TRUE;
					else
						bCandBeep=FALSE;
                    break;


                case PSN_WIZFINISH:
					// check param
					if(SendDlgItemMessage(hDlg, IDD_CANDBEEP_YES, BM_GETCHECK, 0, 0 ) == BST_CHECKED )
						bCandBeep=TRUE;
					else
						bCandBeep=FALSE;

		 			SendDlgItemMessage(hDlg, IDD_ROOT_NUM, WM_GETTEXT, (WPARAM)KEY_NUM_STR_LEN, (LPARAM)szKey_Num_Str);
					if(szKey_Num_Str[0] < _TEXT('1'))
						szKey_Num_Str[0] = _TEXT('1');
					else if(szKey_Num_Str[0] > _TEXT('8'))
						szKey_Num_Str[0] = _TEXT('8');
					szKey_Num_Str[1] = 0;

					// finish
					ErrorFlag = 0;
					bFinish = 1;
                    break;

				default:
					return FALSE;
    		}
			break;

        case WM_HELP:
            HtmlHelp(((LPHELPINFO) lParam)->hItemHandle, HELP_FILE,
                HH_TP_HELP_WM_HELP, (DWORD_PTR)(LPTSTR) aLCtoolHelpIDs);
            break;

        case WM_CONTEXTMENU:   // right mouse click
            HtmlHelp((HWND) wParam, HELP_FILE, HH_TP_HELP_CONTEXTMENU,
                (DWORD_PTR)(LPVOID) aLCtoolHelpIDs);
            break;

		default:
			return FALSE;
	}

	return TRUE;   
}

void FillInPropertyPage( PROPSHEETPAGE* psp, int idDlg, LPTSTR pszProc, DLGPROC pfnDlgProc)
{
    psp->dwSize = sizeof(PROPSHEETPAGE);
    psp->dwFlags = PSP_USEHICON;
    psp->hInstance = hInst;
    psp->pszTemplate = MAKEINTRESOURCE(idDlg);
	psp->hIcon = LoadIcon(hInst, _TEXT("UIMETOOL"));
    psp->pfnDlgProc = pfnDlgProc;
    psp->pszTitle = pszProc;
    psp->lParam = 0;
}

int CreateWizard(HWND hwndOwner, HINSTANCE hInst)
{
    PROPSHEETPAGE psp[NUM_PAGES];
    PROPSHEETHEADER psh;

	FillInPropertyPage( &psp[0], IDD_IMENAME, _TEXT("qJkW"), ImeName);
	FillInPropertyPage( &psp[1], IDD_IMETABLE, _TEXT("Dn"), ImeTable);
	FillInPropertyPage( &psp[2], IDD_IMEPARAM, _TEXT("Jk"), ImeParam);
    
    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_PROPSHEETPAGE | PSH_WIZARD | PSH_NOAPPLYNOW | PSH_USEHICON;
    psh.hwndParent = hwndOwner;
	psh.hInstance = hInst;
	psh.hIcon = LoadIcon(hInst, _TEXT("UIMETOOL"));
    psh.pszCaption = _TEXT("qJkF");
    psh.nPages = sizeof(psp) / sizeof(PROPSHEETPAGE);
    psh.nStartPage = nWizStratPage;
    psh.ppsp = (LPCPROPSHEETPAGE) &psp;

    return (int)(PropertySheet(&psh));
}

BOOL CheckImeFileName(HWND hDlg)
{
	int i, len;
	TCHAR szTitle[MAX_PATH];

	SendDlgItemMessage(hDlg, IDD_IME_FILE_NAME, WM_GETTEXT, (WPARAM)MAX_PATH, (LPARAM)szFile_Out_Name);
	if(szFile_Out_Name[0] == 0) 
		goto ERROR1;

	// Check drive name, path name, extention name exist ?
	len = lstrlen(szFile_Out_Name);

	for(i = 0; i < len; i++) 
	{
		if(szFile_Out_Name[i] == _TEXT('.'))
			break;
	}

	if(i != len) 
		szFile_Out_Name[i] = 0;
	
	if(GetFileTitle(szFile_Out_Name, szTitle, sizeof(szTitle))) 
	{
		SetFocus(GetDlgItem(hDlg, IDD_IME_FILE_NAME));
ERROR1:
		MessageBeep(0);
		return FALSE;
	}

	lstrcpy(szFile_Out_Name, szTitle);
	SendMessage(GetDlgItem(hDlg, IDD_IME_FILE_NAME), WM_SETTEXT, 0, (LPARAM)szFile_Out_Name);

	return TRUE;
}

void ImmSetAlphanumMode(HWND hwnd)
{
	DWORD fdwConversion, fdwSentence;
	HIMC hIMC = ImmGetContext(hwnd);
	ImmGetConversionStatus(hIMC, &fdwConversion, &fdwSentence);
	ImmSetConversionStatus(hIMC, fdwConversion & ~IME_CMODE_NATIVE,
			  fdwSentence);
}

void ImmSetNativeMode(HWND hwnd)
{
	DWORD fdwConversion, fdwSentence;
	HIMC hIMC = ImmGetContext(hwnd);
	ImmGetConversionStatus(hIMC, &fdwConversion, &fdwSentence);
	ImmSetConversionStatus(hIMC, fdwConversion | IME_CMODE_NATIVE,
			  fdwSentence);
}

// <=== @E01
HWND hWndProgress;
UINT uMin, uMax;
LRESULT APIENTRY ProgressWndProc(HWND hWnd, UINT message, 
	UINT wParam,
	LONG lParam);

BOOL InitProgressMsg(void)
{
	WNDCLASS  wcProgress;
	int x, y, width, height;
	TCHAR szTitle[MAX_PATH];
	
	wcProgress.style = 0;                     
	wcProgress.lpfnWndProc = (WNDPROC)ProgressWndProc; 
	wcProgress.cbClsExtra = 0;              
	wcProgress.cbWndExtra = 0;              
	wcProgress.hInstance = hInst;       
	wcProgress.hIcon = LoadIcon(hInst, MAKEINTRESOURCE(256));
	wcProgress.hCursor = LoadCursor(NULL, IDC_ARROW);
	wcProgress.hbrBackground = GetStockObject(LTGRAY_BRUSH); 
	wcProgress.lpszMenuName =  NULL;  
	wcProgress.lpszClassName = _TEXT("ProgressWClass");

	//if (!RegisterClass(&wcProgress))
	//	return FALSE;
	RegisterClass(&wcProgress);
	
	width = 300;
	height = 100;
	x = (GetSystemMetrics(SM_CXSCREEN) - width) / 2;
	y = (GetSystemMetrics(SM_CYSCREEN) - height) / 2;

    LoadString (hInst, IDS_BUILDTITLE, szTitle, sizeof(szTitle) / sizeof(TCHAR));

	hProgMain = CreateWindowEx(
		0,
		_TEXT("ProgressWClass"),           
		szTitle, //_TEXT("qJk..."), 
		WS_BORDER | WS_CAPTION,
		x, y, width, height,
		NULL,               
		NULL,               
		hInst,          
		NULL);


	if (!hProgMain)
		return (FALSE);

	ShowWindow(hProgMain, SW_SHOW);
	UpdateWindow(hProgMain); 
	return TRUE;
}

BOOL ProgressMsg(void)
{
	MSG msg;                       
	while (GetMessage(&msg,
		NULL,              
		0,                 
		0))                
	{
		TranslateMessage(&msg);
		DispatchMessage(&msg); 
	}
	return (BOOL)(msg.wParam);  
}

LRESULT APIENTRY ProgressWndProc(
	HWND hWnd,                /* window handle                   */
	UINT message,             /* type of message                 */
	UINT wParam,              /* additional information          */
	LONG lParam)              /* additional information          */
{
	HDC hdc;
	PAINTSTRUCT ps;
	static UINT uCurrent;

	switch (message) 
	{

		case WM_CREATE:
			hWndProgress  = CreateWindowEx(
				0,
				PROGRESS_CLASS,
				_TEXT("Position"),
				WS_CHILD | WS_VISIBLE, // | PBS_SHOWPOS,
				50,18,205,20,
				hWnd,         
				NULL,         
				hInst,
				NULL);

			if (hWndProgress == NULL)
			{
				MessageBox (NULL, _TEXT("Progress Bar not created!"), NULL, MB_OK );
				break;
			}


			uMin=0;
			uMax=20;
			uCurrent = uMin;
			SendMessage(hWndProgress, PBM_SETRANGE, 0L, MAKELONG(uMin, uMax));
			SendMessage(hWndProgress, PBM_SETSTEP, 1L, 0L);

			SetTimer(hWnd, 1000, 500, NULL);

			break;

		case WM_PAINT:
		{
			hdc = BeginPaint(hWnd, &ps);
			EndPaint(hWnd, &ps);
		}
		break;
 
		case WM_TIMER:
			if (uCurrent < uMax)
			{
				SendMessage(hWndProgress, PBM_STEPIT,0L,0L);
				uCurrent++;
			}
			else
			{
				uCurrent = uMin;
			}
			break;

	case WM_DESTROY:                  /* message: window being destroyed */
		  KillTimer(hWnd, 1000);

		  PostQuitMessage(0);
		  break;

	   default:
		  return (DefWindowProc(hWnd, message, wParam, lParam));
	}
	return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\ddk\cht\eudc\imeeudc.h ===
#define IDS_CHINESE_CHAR        0x0100
#define IDS_QUERY_NOTFINISH     0x0101
#define IDS_QUERY_REGISTER      0x0102

#define IDS_ISV_FILE_FILTER     0x0200
#define IDS_PROCESS_FMT         0x0201
#define IDS_RESULT_FAIL         0x0202
#define IDS_RESULT_SUCCESS      0x0203

#define IDS_INTERNAL_TITLE      0x0300
#define IDS_INTERNAL_MSG        0x0301
#define IDS_EUDCDICFAIL_TITLE   0x0302
#define IDS_EUDCDICFAIL_MSG     0x0303
#define IDS_NOTOPEN_TITLE       0x0304
#define IDS_NOTOPEN_MSG         0x0305
#define IDS_FILESIZE_TITLE      0x0306
#define IDS_FILESIZE_MSG        0x0307
#define IDS_HEADERSIZE_TITLE    0x0308
#define IDS_HEADERSIZE_MSG      0x0309
#define IDS_INFOSIZE_TITLE      0x030A
#define IDS_INFOSIZE_MSG        0x030B
#define IDS_CODEPAGE_TITLE      0x030E
#define IDS_CODEPAGE_MSG        0x030F
#define IDS_CWINSIGN_TITLE      0x0310
#define IDS_CWINSIGN_MSG        0x0311
#define IDS_UNMATCHED_TITLE     0x0312
#define IDS_UNMATCHED_MSG       0x0313

#define IDS_NOIME_TITLE         0x0400
#define IDS_NOIME_MSG           0x0401
#define IDS_NOMEM_TITLE         0x0402
#define IDS_NOMEM_MSG           0x0403

#define WM_EUDC_CODE            (WM_USER + 0x0400)
#define WM_EUDC_COMPMSG         (WM_USER + 0x0401)
#define WM_EUDC_SWITCHIME       (WM_USER + 0x0402)
#define WM_EUDC_REGISTER_BUTTON (WM_USER + 0x0403)

#define UPDATE_NONE             0
#define UPDATE_START            1
#define UPDATE_FINISH           2
#define UPDATE_ERROR            3
#define UPDATE_REGISTERED       4

#define IDM_NEW_EUDC            0x0100
#define IDM_IME_LINK            0x0101
#define IDM_BATCH_IME_LINK      0x0102

#define IDD_RADICAL             0x0100


#define GWL_IMELINKREGWORD      0
#define GWL_RADICALRECT         (GWL_IMELINKREGWORD+sizeof(LONG_PTR))
#define GWL_SIZE                (GWL_RADICALRECT+sizeof(LONG_PTR))

#define UI_MARGIN               3
#define CARET_MARGIN            2


#define RECT_IMENAME            0
#define RECT_RADICAL            1
#define RECT_NUMBER             (RECT_RADICAL + 1)    // how many rectangles


#define UNICODE_CP              1200
#define BIG5_CP                 950
#define ALT_BIG5_CP             938
#define GB2312_CP               936
#define SIGN_CWIN               0x4E495743
#define SIGN__TBL               0x4C42545F


#ifndef RC_INVOKED
#pragma pack(1)
#endif

typedef struct tagUSRDICIMHDR {
    WORD  uHeaderSize;                  // 0x00
    BYTE  idUserCharInfoSign[8];        // 0x02
    BYTE  idMajor;                      // 0x0A
    BYTE  idMinor;                      // 0x0B
    DWORD ulTableCount;                 // 0x0C
    WORD  cMethodKeySize;               // 0x10
    BYTE  uchBankID;                    // 0x12
    WORD  idInternalBankID;             // 0x13
    BYTE  achCMEXReserved1[43];         // 0x15
    WORD  uInfoSize;                    // 0x40
    BYTE  chCmdKey;                     // 0x42
    BYTE  idStlnUpd;                    // 0x43
    BYTE  cbField;                      // 0x44
    WORD  idCP;                         // 0x45
    BYTE  achMethodName[6];             // 0x47
    BYTE  achCSIReserved2[51];          // 0x4D
    BYTE  achCopyRightMsg[128];         // 0x80
} USRDICIMHDR;

#ifndef RC_INVOKED
#pragma pack()
#endif

typedef USRDICIMHDR FAR *LPUSRDICIMHDR;

typedef DWORD UNALIGNED FAR *LPUNADWORD;
typedef TCHAR UNALIGNED FAR *LPUNATSTR;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\cht\uniime\uniphrs.c ===
#include <windows.h>
#include <immdev.h>
#include "imeattr.h"
#include "imedefs.h"
#include "imerc.h"
#include "uniime.h"

BOOL  IsBig5Character( WCHAR  wChar );

/**********************************************************************/
/* AddPhraseString()                                                  */
/**********************************************************************/
DWORD PASCAL AddPhraseString(
    LPIMEL          lpImeL,
    LPCANDIDATELIST lpCandList,
    DWORD           dwPhraseOffset,
    DWORD           dwPhraseNextOffset,
    DWORD           dwStartLen,
    DWORD           dwEndLen,
    DWORD           dwAddCandLimit,
    BOOL            fConvertCP)
{
    HANDLE hLCPhraseTbl;
    LPWSTR lpLCPhraseTbl;
    LPWSTR lpStart, lpEnd;
    int    iBytes;
    DWORD  dwMaxCand;
    DWORD  dwOffset;
    BOOL   bIsNotBig5Char, bIsBig5OnlyMode;

    // put the strings into candidate list
    hLCPhraseTbl = OpenFileMapping(FILE_MAP_READ, FALSE,
        sImeG.szTblFile[1]);
    if (!hLCPhraseTbl) {
        return (0);
    }

    lpLCPhraseTbl = (LPWSTR)MapViewOfFile(hLCPhraseTbl, FILE_MAP_READ,
        0, 0, 0);
    if (!lpLCPhraseTbl) {
        dwOffset = 0;
        goto AddPhraseStringUnmap;
    }

    if (lpImeL->fdwModeConfig & MODE_CONFIG_BIG5ONLY)
        bIsBig5OnlyMode = TRUE;
    else
        bIsBig5OnlyMode = FALSE;

    lpStart = lpLCPhraseTbl + dwPhraseOffset;
    lpEnd = lpLCPhraseTbl + dwPhraseNextOffset;

    if (!lpCandList) {
        // ask how many candidate list strings
        dwOffset = 0;

        for (lpStart; lpStart < lpEnd;) {

            bIsNotBig5Char = FALSE;

            for (; lpStart < lpEnd; lpStart++) {
                WORD uCode;

                uCode = *lpStart;

                 // one string finished
#ifdef UNICODE
                if (!uCode) {
#else
                if (!(uCode & 0x8000)) {
#endif
                    lpStart++;
                    break;
                }

                if ( bIsBig5OnlyMode ) {

                    if ( IsBig5Character((WCHAR)uCode) == FALSE )
                        bIsNotBig5Char = TRUE;
                }

            }

            // if it is in Big5 Only Mode, and there is at least one char which is not
            // in Big5 charset, we don't count this string

            if ( bIsBig5OnlyMode && bIsNotBig5Char )
               continue;

            // string count plus 1
            dwOffset++;
        }

        goto AddPhraseStringUnmap;
    }

    // the offset of dwOffset[0]
    dwOffset = (DWORD)((LPBYTE)&lpCandList->dwOffset[0] - (LPBYTE)lpCandList);

    if (lpCandList->dwSize < dwOffset) {
        return (0);
    }

    // how many bytes of dwOffset[]
    iBytes = lpCandList->dwOffset[0] - dwOffset;

    // maybe the size is even smaller than it
    for (dwMaxCand = 1; dwMaxCand < lpCandList->dwCount; dwMaxCand++) {
        if ((int)(lpCandList->dwOffset[dwMaxCand] - dwOffset) < iBytes) {
            iBytes = (int)(lpCandList->dwOffset[dwMaxCand] - dwOffset);
        }
    }

    if (iBytes <= 0) {
        return (0);
    }

    dwMaxCand = (DWORD)iBytes / sizeof(DWORD);

    if (dwAddCandLimit < dwMaxCand) {
        dwMaxCand = dwAddCandLimit;
    }

    if (lpCandList->dwCount >= dwMaxCand) {
        // Grow memory here and do something,
        // if you still want to process it.
        return (0);
    }

    dwOffset = lpCandList->dwOffset[lpCandList->dwCount];

    for (lpStart; lpStart < lpEnd;) {
        BOOL  fStrEnd;
        DWORD dwStrLen, dwCharLen, dwStrByteLen, dwCharByteLen;

        fStrEnd = FALSE;
        bIsNotBig5Char = FALSE;

        // get the whole string
        dwCharByteLen = sizeof(WCHAR);
        dwCharLen = sizeof(WCHAR) / sizeof(TCHAR);

        for (dwStrLen = dwStrByteLen = 0; !fStrEnd && (lpStart < lpEnd);
            lpStart++, dwStrLen+= dwCharLen, dwStrByteLen += dwCharByteLen) {
            WORD uCode;

            uCode = *lpStart;

            // one string finished
#ifdef UNICODE
            if (!uCode) {
#else
            if (!(uCode & 0x8000)) {
#endif
                fStrEnd = TRUE;
#ifdef UNICODE
                lpStart++;
                break;
#else
                uCode |= 0x8000;
#endif
            }

            // if it is Big5Only Mode, we need to check if this char is in Big5 charset

            if ( bIsBig5OnlyMode ) {

               if ( !IsBig5Character((WCHAR)uCode) ) 
                   bIsNotBig5Char = TRUE;

            }

#ifdef UNICODE
            if (fConvertCP) {
                CHAR szCode[4];

                dwCharLen = dwCharByteLen = WideCharToMultiByte(
                    sImeG.uAnsiCodePage, WC_COMPOSITECHECK,
                    (LPCWSTR)&uCode, 1, szCode, sizeof(szCode), NULL, NULL);

                // because this BIG5 code, convert to BIG5 string
                if (dwCharByteLen >= 2) {
                    uCode = (BYTE)szCode[0] | ((UINT)(BYTE)szCode[1] << 8);
                } else {
                    uCode = (UINT)szCode[0];
                }
            }
#else
            // swap lead & second byte (as a string), UNICODE don't need it
            uCode = HIBYTE(uCode) | (LOBYTE(uCode) << 8);
#endif

            if ((dwOffset + dwStrByteLen + dwCharByteLen) >=
                lpCandList->dwSize) {
                goto AddPhraseStringClose;
            }

            // add this char into candidate list
#ifdef UNICODE
            if (dwCharByteLen == sizeof(WCHAR)) {
                *(LPWSTR)((LPBYTE)lpCandList + dwOffset + dwStrByteLen) =
                    (WCHAR)uCode;
            } else {
                *(LPSTR)((LPBYTE)lpCandList + dwOffset + dwStrByteLen) =
                    (CHAR)uCode;
            }
#else
            *(LPWSTR)((LPBYTE)lpCandList + dwOffset + dwStrByteLen) =
                (WCHAR)uCode;
#endif
        }

        if (dwStrLen < dwStartLen) {
            // the found string too short
            continue;
        } else if (dwStrLen >= dwEndLen) {
            // the found string too long
            continue;
        } else {
        }

        // if it is in Big5 Only Mode, and there is at least one char which is not in Big5
        // charset, we just ingore this string, do not put it into the candidate list
        
        if ( bIsBig5OnlyMode && bIsNotBig5Char ) {

            bIsNotBig5Char = FALSE;
            continue;
        }

        if ((dwOffset + dwStrByteLen + sizeof(TCHAR)) >= lpCandList->dwSize) {
            goto AddPhraseStringClose;
        }

        // null terminator
        *(LPTSTR)((LPBYTE)lpCandList + dwOffset + dwStrByteLen) = TEXT('\0');
        dwOffset += (dwStrByteLen + sizeof(TCHAR));

        // add one string into candidate list
        lpCandList->dwCount++;

        if (lpCandList->dwCount >= dwMaxCand) {
            // Grow memory here and do something,
            // if you still want to process it.
            break;
        }

        // string length plus size of the null terminator
        lpCandList->dwOffset[lpCandList->dwCount] = dwOffset;
    }

AddPhraseStringUnmap:
    UnmapViewOfFile(lpLCPhraseTbl);
AddPhraseStringClose:
    CloseHandle(hLCPhraseTbl);

    return (dwOffset);
}

/**********************************************************************/
/* UniSearchPhrasePrediction()                                        */
/* Description:                                                       */
/*      file format can be changed in different version for           */
/*      performance consideration, ISVs should not assume its format  */
/*      and serach these files by themselves                          */
/**********************************************************************/
DWORD WINAPI UniSearchPhrasePrediction(
    LPIMEL          lpImeL,
    UINT            uCodePage,
    LPCTSTR         lpszStr,
    DWORD           dwStrLen,
    LPCTSTR         lpszReadStr,    // Phonetic reading string
    DWORD           dwReadStrLen,
    DWORD           dwStartLen,     // find the string length >= this value
    DWORD           dwEndLen,       // find the string length < this value
    DWORD           dwAddCandLimit,
    LPCANDIDATELIST lpCandList)
{
    UINT   uCode;
    HANDLE hLCPtrTbl;
    LPWORD lpLCPtrTbl;
    int    iLo, iHi, iMid;
    BOOL   fFound, fConvertCP;
    DWORD  dwPhraseOffset, dwPhraseNextOffset;

    if (uCodePage == NATIVE_CP) {
        fConvertCP = FALSE;
#ifdef UNICODE
    } else if (uCodePage == sImeG.uAnsiCodePage) {
        fConvertCP = TRUE;
#endif
    } else {
        return (0);
    }

    if (dwStrLen != sizeof(WCHAR) / sizeof(TCHAR)) {
        return (0);
    }

    if (dwStartLen >= dwEndLen) {
        return (0);
    }

#ifdef UNICODE
    uCode = lpszStr[0];
#else
    // swap lead byte & second byte, UNICODE don't need it
    uCode = (BYTE)lpszStr[1];
    *((LPBYTE)&uCode + 1) = (BYTE)lpszStr[0];
#endif

    iLo = 0;
#ifdef UNICODE
    iHi = sImeG.uTblSize[0] / 6;
#else
    iHi = sImeG.uTblSize[0] / 4;
#endif
    iMid = (iHi + iLo) /2;

    fFound = FALSE;

    // LCPTR.TBL
    hLCPtrTbl = OpenFileMapping(FILE_MAP_READ, FALSE, sImeG.szTblFile[0]);
    if (!hLCPtrTbl) {
        return (0);
    }

    lpLCPtrTbl = MapViewOfFile(hLCPtrTbl, FILE_MAP_READ, 0, 0, 0);
    if (!lpLCPtrTbl) {
        goto SrchPhrPredictClose;
    }

    // binary search on phrase table,
    // one is multiple word phrase and the other is the two word phrase
    for (; iLo <= iHi;) {
        LPWORD lpCurr;

#ifdef UNICODE
        lpCurr = lpLCPtrTbl + 3 * iMid;
#else
        lpCurr = lpLCPtrTbl + 2 * iMid;
#endif

        if (uCode > *lpCurr) {
            iLo = iMid + 1;
        } else if (uCode < *lpCurr) {
            iHi = iMid - 1;
        } else {
            fFound = TRUE;
            // use it on TAB key
#ifdef UNICODE
            dwPhraseOffset = *(LPUNADWORD)(lpCurr + 1);
            dwPhraseNextOffset = *(LPUNADWORD)(lpCurr + 1 + 3);
#else
            dwPhraseOffset = *(lpCurr + 1);
            dwPhraseNextOffset = *(lpCurr + 1 + 2);
#endif
            break;
        }

        iMid = (iHi + iLo) /2;
    }

    UnmapViewOfFile(lpLCPtrTbl);

SrchPhrPredictClose:
    CloseHandle(hLCPtrTbl);

    if (!fFound) {
        return (0);
    }

    // phrase string
    return AddPhraseString(lpImeL,lpCandList, dwPhraseOffset, dwPhraseNextOffset,
        dwStartLen, dwEndLen, dwAddCandLimit, fConvertCP);
}

/**********************************************************************/
/* UniSearchPhrasePredictionStub()                                    */
/* Description:                                                       */
/*      file format can be changed in different version for           */
/*      performance consideration, ISVs should not assume its format  */
/*      and serach these files by themselves                          */
/**********************************************************************/
DWORD WINAPI UniSearchPhrasePredictionStub(
    LPIMEL          lpImeL,
    UINT            uCodePage,
    LPCSTUBSTR      lpszStr,
    DWORD           dwStrLen,
    LPCSTUBSTR      lpszReadStr,    // Phonetic reading string
    DWORD           dwReadStrLen,
    DWORD           dwStartLen,     // find the string length >= this value
    DWORD           dwEndLen,       // find the string length < this value
    DWORD           dwAddCandLimit,
    LPCANDIDATELIST lpCandList)
{
#ifdef UNICODE
    LPTSTR          lpszWideStr, lpszWideReadStr;
    DWORD           dwWideStrLen, dwWideReadStrLen;
    DWORD           dwWideStartLen, dwWideEndLen;
    DWORD           dwWideAddCandList, dwRet;
    LPCANDIDATELIST lpWideCandList;
    LPBYTE          lpbBuf;

    if (uCodePage != sImeG.uAnsiCodePage) {
        return (0);
    }

    dwRet = dwStrLen * sizeof(WCHAR) + dwReadStrLen * sizeof(WCHAR);

    lpbBuf = (LPBYTE)GlobalAlloc(GPTR, dwRet);
    if ( lpbBuf == NULL )
       return 0;

    if (lpszStr) {
        lpszWideStr = (LPTSTR)lpbBuf;

        dwWideStrLen = MultiByteToWideChar(sImeG.uAnsiCodePage,
            MB_PRECOMPOSED, lpszStr, dwStrLen,
            lpszWideStr, dwStrLen);
    } else {
        lpszWideStr = NULL;
        dwWideStrLen = 0;
    }

    if (lpszReadStr) {
        lpszWideReadStr = (LPTSTR)(lpbBuf + dwStrLen * sizeof(WCHAR));

        dwWideReadStrLen = MultiByteToWideChar(sImeG.uAnsiCodePage,
            MB_PRECOMPOSED, lpszReadStr, dwReadStrLen,
            lpszWideReadStr, dwReadStrLen);
    } else {
        lpszWideReadStr = NULL;
        dwWideReadStrLen = 0;
    }

    dwRet = UniSearchPhrasePrediction(lpImeL,uCodePage, lpszWideStr, dwWideStrLen,
        lpszWideReadStr, dwWideReadStrLen, dwStartLen, dwEndLen,
        dwAddCandLimit, lpCandList);

    // now, start W to A conversion and fliter the real limit here
    GlobalFree((HGLOBAL)lpbBuf);

    return (dwRet);
#else
    return (0);
#endif
}

/**********************************************************************/
/* MemoryLack()                                                       */
/**********************************************************************/
void PASCAL MemoryLack(
    DWORD       fdwErrMsg)
{
    TCHAR szErrMsg[64];
    TCHAR szIMEName[16];

    if (sImeG.fdwErrMsg & fdwErrMsg) {
        // message already prompted
        return;
    }

    LoadString(hInst, IDS_MEM_LACK_FAIL, szErrMsg, sizeof(szErrMsg)/sizeof(TCHAR));
    LoadString(hInst, IDS_IMENAME, szIMEName, sizeof(szIMEName)/sizeof(TCHAR) );

    sImeG.fdwErrMsg |= fdwErrMsg;
    MessageBeep((UINT)-1);
    MessageBox((HWND)NULL, szErrMsg, szIMEName,
        MB_OK|MB_ICONHAND|MB_TASKMODAL|MB_TOPMOST);

    return;
}

/**********************************************************************/
/* LoadOneGlobalTable()                                               */
/* Description:                                                       */
/*      memory handle & size of .TBL file will be assigned to         */
/*      sImeG                                                         */
/* Eeturn Value:                                                      */
/*      length of directory of the .TBL file                          */
/**********************************************************************/
UINT PASCAL LoadOneGlobalTable( // load one of table file
    LPTSTR szTable,             // file name of .TBL
    UINT   uIndex,              // the index of array to store memory handle
    UINT   uLen,                // length of the directory
    LPTSTR szPath)              // buffer for directory
{
    HANDLE  hTblFile;
    HGLOBAL hMap;
    TCHAR   szFullPathFile[MAX_PATH];
    PSECURITY_ATTRIBUTES psa;

    CopyMemory(szFullPathFile, szPath, uLen * sizeof(TCHAR));

    psa = CreateSecurityAttributes();

    if (uLen) {
        CopyMemory(&szFullPathFile[uLen], szTable, sizeof(sImeG.szTblFile[0]));
        hTblFile = CreateFile(szFullPathFile, GENERIC_READ,
            FILE_SHARE_READ|FILE_SHARE_WRITE,
            psa, OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
    } else {
        // try system directory
        uLen = GetSystemDirectory(szFullPathFile, MAX_PATH);
        if (szFullPathFile[uLen - 1] != TEXT('\\')) {   // consider N:\ ;
            szFullPathFile[uLen++] = TEXT('\\');
        }

        CopyMemory(&szFullPathFile[uLen], szTable, sizeof(sImeG.szTblFile[0]));
        hTblFile = CreateFile(szFullPathFile, GENERIC_READ,
            FILE_SHARE_READ|FILE_SHARE_WRITE,
            psa, OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);

        if (hTblFile != INVALID_HANDLE_VALUE) {
            goto CopyDicPath;
        }

        // if the work station version, SHARE_WRITE will fail
        hTblFile = CreateFile(szFullPathFile, GENERIC_READ,
            FILE_SHARE_READ,
            psa, OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);

CopyDicPath:
        if (hTblFile != INVALID_HANDLE_VALUE) {
            CopyMemory(sImeG.szPhrasePath, szFullPathFile, uLen * sizeof(TCHAR));
            sImeG.uPathLen = uLen;
            goto OpenDicFile;
        }
    }

OpenDicFile:
    // can not find the table file
    if (hTblFile != INVALID_HANDLE_VALUE) {     // OK
    } else if (sImeG.fdwErrMsg & (ERRMSG_LOAD_0 << uIndex)) {
        // already prompt error message before, no more
        FreeSecurityAttributes(psa);
        return (0);
    } else {                    // prompt error message
        TCHAR szIMEName[64];
        TCHAR szErrMsg[2 * MAX_PATH];

        // temp use szIMEName as format string buffer of error message
        LoadString(hInst, IDS_FILE_OPEN_FAIL, szIMEName, sizeof(szIMEName)/sizeof(TCHAR));
        wsprintf(szErrMsg, szIMEName, szTable);

        LoadString(hInst, IDS_IMENAME, szIMEName, sizeof(szIMEName)/sizeof(TCHAR));
        sImeG.fdwErrMsg |= ERRMSG_LOAD_0 << uIndex;
        MessageBeep((UINT)-1);
        MessageBox((HWND)NULL, szErrMsg, szIMEName,
            MB_OK|MB_ICONHAND|MB_TASKMODAL|MB_TOPMOST);
        FreeSecurityAttributes(psa);
        return (0);
    }

    sImeG.fdwErrMsg &= ~(ERRMSG_LOAD_0 << uIndex);

    // create file mapping for IME tables
    hMap = CreateFileMapping((HANDLE)hTblFile, psa, PAGE_READONLY,
        0, 0, szTable);

    if (!hMap) {
        MemoryLack(ERRMSG_MEM_0 << uIndex);
        CloseHandle(hTblFile);
        FreeSecurityAttributes(psa);
        return(0);
    }

    sImeG.fdwErrMsg &= ~(ERRMSG_MEM_0 << uIndex);

    sInstG.hMapTbl[uIndex] = hMap;

    // get file length
    sImeG.uTblSize[uIndex] = GetFileSize(hTblFile, (LPDWORD)NULL);

    CloseHandle(hTblFile);
    FreeSecurityAttributes(psa);

    return (uLen);
}

/**********************************************************************/
/* LoadPhraseTable()                                                  */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL PASCAL LoadPhraseTable(    // load the phrase tables
    UINT        uLen,           // length of the directory
    LPTSTR      szPath)         // buffer for directory
{
    int   i;

    for (i = 0; i < MAX_PHRASE_TABLES; i++) {
        if (!*sImeG.szTblFile[i]) {
        } else if (sInstG.hMapTbl[i]) {             // already loaded
        } else if (uLen = LoadOneGlobalTable(sImeG.szTblFile[i], i,
            uLen, szPath)) {
        } else {
            int j;

            for (j = 0; j < i; j++) {
                if (sInstG.hMapTbl[j]) {
                    CloseHandle(sInstG.hMapTbl[j]);
                    sInstG.hMapTbl[j] = (HANDLE)NULL;
                }
            }

            return (FALSE);
        }
    }

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\ddk\cht\eudc\imeeudc.c ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation, All Rights Reserved

Module Name:

    IMEEUDC.c
    
++*/

#include <windows.h>
#include <commdlg.h>
#include <imm.h>
#include "imeeudc.h"

//
//   J. J. Lee  9-29-1994
//
//         UI of this program
//  +--------------------------------------------------+
//  +--------------------------------------------------+
//  |                                                  |
//  |                          +------------+          |
//  |                          |    FA40    |          |
//  |                          +------------+          |
//  |                                                  |
//  |                          +------------+  +-----+ |
//  | (IMEName iStartIME + 0)  |   GOLD     |  |  ^  | |
//  |                          +------------+  |  |  | |
//  |                                          |     | |
//  |                          +------------+  |scrol| |
//  | (IMEName iStartIME + 1)  |   WOOD     |  | bar | |
//  |                          +------------+  |     | |
//  |                                          |     | |
//  |                          +------------+  |  |  | |
//  | (IMEName iStartIME + 2)  |   WATER    |  |  V  | |
//  |                          +------------+  +-----+ |
//  |                                                  |
//  |   +----------+                +-----------+      |
//  |   | Register |                |   Abort   |      |
//  |   +----------+                +-----------+      |
//  |                                                  |
//  +--------------------------------------------------+
//
// The scroll bar only appear when there are more than 3 IMEs
//

// This is a sample code for EUDC regsiter a new created word into IMEs



typedef struct _tagREGWORDSTRUCT {
    HKL   hKL;
    BOOL  bUpdate;
    TCHAR szIMEName[16];
    UINT  uIMENameLen;
    TCHAR szReading[14];
    DWORD dwReadingLen;
} REGWORDSTRUCT;

typedef REGWORDSTRUCT FAR *LPREGWORDSTRUCT;


typedef struct _tagIMELINKREGWORD {
    HIMC          hOldIMC;
    HIMC          hRegWordIMC;
    BOOL          fCompMsg;
    UINT          nEudcIMEs;
    UINT          nCurrIME;
    TCHAR         szEudcCodeString[4];
    REGWORDSTRUCT sRegWordStruct[1];
} IMELINKREGWORD;

typedef IMELINKREGWORD FAR *LPIMELINKREGWORD;


typedef struct _tagIMERADICALRECT {
    UINT nStartIME;
    UINT nPerPageIMEs;
    SIZE lTextSize;
    SIZE lCurrReadingExtent;
    HWND hRegWordButton;
    HWND hScrollWnd;
    RECT rcRadical[1];
} IMERADICALRECT;

typedef IMERADICALRECT FAR *LPIMERADICALRECT;


static const TCHAR     szAppName[] = TEXT("EUDC");
static const TCHAR     szMenuName[] = TEXT("ImeEudcMenu");
static const TCHAR     szRegWordCls[] = TEXT("Radical");
static const TCHAR     szImeLinkDlg[] = TEXT("ImeLinkDlg");


typedef struct _tagCOUNTRYSETTING {
    UINT    uCodePage;
    LPCTSTR szCodePage;
} COUNTRYSETTING;

static const COUNTRYSETTING sCountry[] = {
    {
        BIG5_CP, TEXT("BIG5")
    }
    , {
        ALT_BIG5_CP, TEXT("BIG5")
    }
#if defined(UNICODE)
    , {
        UNICODE_CP, TEXT("UNICODE")
    }
#endif
    , {
        GB2312_CP, TEXT("GB2312")
    }
};


static HINSTANCE       hAppInst;


/************************************************************/
/*  SwitchToThisIME                                         */
/************************************************************/
void SwitchToThisIME(
    HWND hWnd,
    UINT uIndex)
{
    LPIMELINKREGWORD lpImeLinkRegWord;
    LPREGWORDSTRUCT  lpRegWordStructTmp;
    LPIMERADICALRECT lpImeLinkRadical;
    DWORD            fdwConversionMode, fdwSentenceMode;

    lpImeLinkRegWord = (LPIMELINKREGWORD)GetWindowLongPtr(hWnd,
        GWL_IMELINKREGWORD);

    if (lpImeLinkRegWord->nCurrIME == uIndex) {
        return;
    }

    if (uIndex >= lpImeLinkRegWord->nEudcIMEs) {
        MessageBeep((UINT)-1);
        return;
    }

    lpImeLinkRadical = (LPIMERADICALRECT)GetWindowLongPtr(hWnd,
        GWL_RADICALRECT);

    if (uIndex < lpImeLinkRadical->nStartIME) {
        lpImeLinkRadical->nStartIME = uIndex;
    } else if ((uIndex - lpImeLinkRadical->nStartIME) >=
        lpImeLinkRadical->nPerPageIMEs) {
        lpImeLinkRadical->nStartIME = uIndex -
            (lpImeLinkRadical->nPerPageIMEs - 1);
                                                 } else {
    }

    // avoid clear composition string
    SendMessage(hWnd, WM_EUDC_COMPMSG, 0, FALSE);

    lpRegWordStructTmp = &lpImeLinkRegWord->sRegWordStruct[uIndex];

    // switch to this IME
    ActivateKeyboardLayout(lpRegWordStructTmp->hKL, 0);

    ImmGetConversionStatus(lpImeLinkRegWord->hRegWordIMC,
        &fdwConversionMode, &fdwSentenceMode);

    fdwConversionMode = (fdwConversionMode | IME_CMODE_EUDC |
        IME_CMODE_NATIVE) | (fdwConversionMode & IME_CMODE_SOFTKBD);
 
    ImmSetConversionStatus(lpImeLinkRegWord->hRegWordIMC,
        fdwConversionMode, fdwSentenceMode);

    SendMessage(hWnd, WM_EUDC_COMPMSG, 0, TRUE);

    lpImeLinkRegWord->nCurrIME = uIndex;

    if(lpImeLinkRadical->hScrollWnd){
        SCROLLINFO scInfo;

        scInfo.cbSize = sizeof(SCROLLINFO);
        scInfo.fMask = SIF_POS;
        scInfo.nPos = lpImeLinkRegWord->nCurrIME;

        SetScrollInfo(lpImeLinkRadical->hScrollWnd, 
            SB_CTL, &scInfo, FALSE);
    }
    InvalidateRect(hWnd, NULL, TRUE);

    *(LPTSTR)&lpRegWordStructTmp->szReading[
        lpRegWordStructTmp->dwReadingLen] = '\0';

    ImmSetCompositionString(lpImeLinkRegWord->hRegWordIMC, SCS_SETSTR,
        NULL, 0, lpRegWordStructTmp->szReading,
        lpRegWordStructTmp->dwReadingLen * sizeof(TCHAR));

    SetFocus(hWnd);

    return;
}

/************************************************************/
/*  RegWordCreate                                           */
/************************************************************/
LPIMELINKREGWORD RegWordCreate(
    HWND hWnd)
{
    HWND             hEudcEditWnd;
    UINT             nLayouts;
    HKL FAR         *lphKL;
    UINT             i, nIMEs;
    DWORD            dwSize;
    LPIMELINKREGWORD lpImeLinkRegWord;
    LPREGWORDSTRUCT  lpRegWordStructTmp;
    TCHAR            szStrBuf[16];
    HDC              hDC;
    SIZE             lTextSize;
    RECT             rcRect;
    LPIMERADICALRECT lpImeLinkRadical;
    TCHAR            szTitle[32];
    TCHAR            szMessage[256];

    hEudcEditWnd = GetWindow(GetParent(hWnd), GW_OWNER);

    nLayouts = GetKeyboardLayoutList(0, NULL);

    lphKL = GlobalAlloc(GPTR, sizeof(HKL) * nLayouts);

    if (!lphKL) {
        return (NULL);
    }

    lpImeLinkRegWord = NULL;

    // get all keyboard layouts, it will include all IMEs
    GetKeyboardLayoutList(nLayouts, lphKL);

    for (i = 0, nIMEs = 0; i < nLayouts; i++) {
        BOOL  fRet;
        HKL   hKL;
        TCHAR szImeEudcDic[80];

        hKL = *(lphKL + i);

        fRet = ImmIsIME(hKL);

        if (!fRet) {            // this is not an IME
            continue;
        }

        szImeEudcDic[0] = '\0';

        fRet = (BOOL) ImmEscape(hKL, (HIMC)NULL, IME_ESC_GET_EUDC_DICTIONARY,
            szImeEudcDic);

        if (!fRet) {
            continue;
        } else if (szImeEudcDic[0]) {
        } else {
            continue;
        }

        *(lphKL + nIMEs) = hKL;     // write back to the same buffer

        nIMEs++;
    }

    if (!nIMEs) {
        LoadString(hAppInst, IDS_NOIME_TITLE, szTitle, sizeof(szTitle) / sizeof(TCHAR));
        LoadString(hAppInst, IDS_NOIME_MSG, szMessage, sizeof(szMessage) / sizeof(TCHAR));

        MessageBox(hEudcEditWnd, szMessage, szTitle, MB_OK);
        goto RegWordCreateFreeHKL;
    }

    // now there are nIMEs can support IME EUDC dictionary
    dwSize = sizeof(IMELINKREGWORD) - sizeof(REGWORDSTRUCT) +
        sizeof(REGWORDSTRUCT) * nIMEs;

    lpImeLinkRegWord = (LPIMELINKREGWORD)GlobalAlloc(GPTR, dwSize);

    if (!lpImeLinkRegWord) {
        LoadString(hAppInst, IDS_NOMEM_TITLE, szTitle, sizeof(szTitle) / sizeof(TCHAR));
        LoadString(hAppInst, IDS_NOMEM_MSG, szMessage, sizeof(szMessage) / sizeof(TCHAR));

        MessageBox(hEudcEditWnd, szMessage, szTitle, MB_OK);
        goto RegWordCreateFreeHKL;
    }

    lpImeLinkRegWord->nEudcIMEs = nIMEs;

    lpRegWordStructTmp = &lpImeLinkRegWord->sRegWordStruct[0];

    for (i = 0; i < nIMEs; i++) {
        LRESULT lRet;
#ifndef UNICODE
        UINT    j, uInternal;
#endif
        UINT    uReadingSize;

        lpRegWordStructTmp->hKL = *(lphKL + i);

        lRet = ImmEscape(lpRegWordStructTmp->hKL, (HIMC)NULL,
            IME_ESC_MAX_KEY, NULL);

        if (!lRet) {
            // error message - can not support this IME!
            lpImeLinkRegWord->nEudcIMEs--;
            continue;
        }

        uReadingSize = sizeof(TCHAR);

#ifndef UNICODE
        for (j = 0; j < 256; j++) {
            uInternal = ImmEscape(lpRegWordStructTmp->hKL, (HIMC)NULL,
                IME_ESC_SEQUENCE_TO_INTERNAL, &j);
            if (uInternal > 255) {
                uReadingSize = sizeof(WCHAR);
                break;
            }
        }
#endif

        if (lRet * uReadingSize > sizeof(lpRegWordStructTmp->szReading) - sizeof(TCHAR)) {
            // error case, we can not support this IME
            // we should count this into data structure
            // error message - the reading of this IME is too long!
            lpImeLinkRegWord->nEudcIMEs--;
            continue;
        }

        lRet = ImmEscape(lpRegWordStructTmp->hKL, (HIMC)NULL,
            IME_ESC_IME_NAME, lpRegWordStructTmp->szIMEName);

        if (!lRet) {
            // error message - can not support this IME!
            lpImeLinkRegWord->nEudcIMEs--;
            continue;
        }

        // avoid length problem
        lpRegWordStructTmp->szIMEName[
            sizeof(lpRegWordStructTmp->szIMEName) / sizeof(TCHAR) - 1] = '\0';

        lpRegWordStructTmp->uIMENameLen =
            lstrlen(lpRegWordStructTmp->szIMEName);

        lpRegWordStructTmp++;
    }

    if (!lpImeLinkRegWord->nEudcIMEs) {
        LoadString(hAppInst, IDS_NOIME_TITLE, szTitle, sizeof(szTitle) / sizeof(TCHAR));
        LoadString(hAppInst, IDS_NOIME_MSG, szMessage, sizeof(szMessage) / sizeof(TCHAR));

        MessageBox(hEudcEditWnd, szMessage, szTitle, MB_OK);
        goto RegWordCreateFreeRegWord;
    }

    LoadString(hAppInst, IDS_CHINESE_CHAR, szStrBuf, sizeof(szStrBuf) / sizeof(TCHAR));

    hDC = GetDC(NULL);
    GetTextExtentPoint(hDC, szStrBuf, lstrlen(szStrBuf), &lTextSize);
    ReleaseDC(NULL, hDC);

    // decide the rectangle of IME radical
    GetWindowRect(hWnd, &rcRect);

    // we can show how many IME per page
    nIMEs = (rcRect.bottom - rcRect.top) / (2 * lTextSize.cy);

    if (lpImeLinkRegWord->nEudcIMEs <= nIMEs) {
        // all IMEs can fit in one page
        nIMEs = lpImeLinkRegWord->nEudcIMEs;
    }

    dwSize = sizeof(IMERADICALRECT) - sizeof(RECT) + sizeof(RECT) *
        RECT_NUMBER * nIMEs;

    lpImeLinkRadical = (LPIMERADICALRECT)GlobalAlloc(GPTR, dwSize);

    if (!lpImeLinkRadical) {
        // we can not handle any IME
        lpImeLinkRegWord->nEudcIMEs = 0;

        LoadString(hAppInst, IDS_NOMEM_TITLE, szTitle, sizeof(szTitle) / sizeof(TCHAR));
        LoadString(hAppInst, IDS_NOMEM_MSG, szMessage, sizeof(szMessage) / sizeof(TCHAR));

        MessageBox(hEudcEditWnd, szMessage, szTitle, MB_OK);
        goto RegWordCreateFreeRegWord;
    }

    lpImeLinkRadical->nStartIME = 0;
    lpImeLinkRadical->nPerPageIMEs = nIMEs;
    lpImeLinkRadical->lTextSize = lTextSize;

    if (lpImeLinkRegWord->nEudcIMEs > nIMEs) {
        // IMEs more than one page, add scroll bar
        SCROLLINFO scInfo;

        // IMEs more than one page, add scroll bar
        lpImeLinkRadical->hScrollWnd = CreateWindowEx(0,
            TEXT("scrollbar"), NULL,
            WS_CHILD|WS_VISIBLE|SBS_VERT,
            rcRect.right - rcRect.left - lTextSize.cx, 0,
            lTextSize.cx, rcRect.bottom - rcRect.top,
            hWnd, 0, hAppInst, NULL);

        scInfo.cbSize = sizeof(SCROLLINFO);
        scInfo.fMask = SIF_ALL;
        scInfo.nMin = 0;
        scInfo.nMax = lpImeLinkRegWord->nEudcIMEs - 1 + (nIMEs - 1);
        scInfo.nPage = nIMEs;
        scInfo.nPos = 0;
        scInfo.nTrackPos = 0;

        SetScrollInfo(lpImeLinkRadical->hScrollWnd, SB_CTL, &scInfo, FALSE);
    }

    // decide the UI dimension
    for (i = 0; i < nIMEs; i++) {
        UINT j, k;

        // rectangle for IME name
        j = i * RECT_NUMBER + RECT_IMENAME;

        lpImeLinkRadical->rcRadical[j].left = lTextSize.cx;

        // add UI margin - UI_MARGIN
        lpImeLinkRadical->rcRadical[j].top = lTextSize.cy * (i * 4 + 1) / 2 -
            UI_MARGIN;

        lpImeLinkRadical->rcRadical[j].right =
            lpImeLinkRadical->rcRadical[j].left + lTextSize.cx * 4;

        // add UI margin - UI_MARGIN * 2
        lpImeLinkRadical->rcRadical[j].bottom =
            lpImeLinkRadical->rcRadical[j].top + lTextSize.cy +
            UI_MARGIN * 2;

        // rectangle for radical
        k = i * RECT_NUMBER + RECT_RADICAL;

        lpImeLinkRadical->rcRadical[k].left =
            lpImeLinkRadical->rcRadical[j].right + lTextSize.cx;

        // add UI margin - UI_MARGIN
        lpImeLinkRadical->rcRadical[k].top =
            lpImeLinkRadical->rcRadical[j].top;

        lpImeLinkRadical->rcRadical[k].right =
            lpImeLinkRadical->rcRadical[k].left + lTextSize.cx *
            (sizeof(lpRegWordStructTmp->szReading) / sizeof(TCHAR) / 2 - 1);

        // add UI margin - UI_MARGIN * 2
        lpImeLinkRadical->rcRadical[k].bottom =
            lpImeLinkRadical->rcRadical[k].top + lTextSize.cy +
            UI_MARGIN * 2;
    }

    SetWindowLongPtr(hWnd, GWL_RADICALRECT, (LONG_PTR)lpImeLinkRadical);

RegWordCreateFreeRegWord:
    if (!lpImeLinkRegWord->nEudcIMEs) {
        GlobalFree((HGLOBAL)lpImeLinkRegWord);
        lpImeLinkRegWord = NULL;
    }

RegWordCreateFreeHKL:
    GlobalFree((HGLOBAL)lphKL);

    return (lpImeLinkRegWord);
}

/************************************************************/
/*  WmImeComposition                                        */
/************************************************************/
void WmImeComposition(
    HWND   hWnd,
    LPARAM lParam)
{
    LPIMELINKREGWORD lpImeLinkRegWord;
    LPREGWORDSTRUCT  lpRegWordStructTmp;
    LONG             lRet;
    BOOL             bUpdate;
    TCHAR            szReading[sizeof(lpRegWordStructTmp->szReading)];

    lpImeLinkRegWord = (LPIMELINKREGWORD)GetWindowLongPtr(hWnd,
        GWL_IMELINKREGWORD);

    lpRegWordStructTmp = &lpImeLinkRegWord->sRegWordStruct[
        lpImeLinkRegWord->nCurrIME];

    lRet = ImmGetCompositionString(lpImeLinkRegWord->hRegWordIMC,
        GCS_COMPREADSTR, szReading, sizeof(szReading));

    if (lRet < 0) {
        lpRegWordStructTmp->bUpdate = UPDATE_ERROR;
        return;
    }

    if (lRet > (sizeof(szReading) - sizeof(TCHAR))) {
        lRet = sizeof(szReading) - sizeof(TCHAR);
    }

    szReading[lRet / sizeof(TCHAR)] = '\0';

    if (lpRegWordStructTmp->dwReadingLen != (DWORD)lRet / sizeof(TCHAR)) {
        bUpdate = TRUE;
    } else if (lstrcmp(lpRegWordStructTmp->szReading, szReading)) {
        bUpdate = TRUE;
    } else {
        bUpdate = FALSE;
    }

    if (bUpdate) {
        LPIMERADICALRECT lpImeLinkRadical;
        UINT             i;
        UINT             j, k;

        lpImeLinkRadical = (LPIMERADICALRECT)GetWindowLongPtr(hWnd,
            GWL_RADICALRECT);

        lstrcpy(lpRegWordStructTmp->szReading, szReading);

        if (lParam & GCS_RESULTSTR) {
            lpRegWordStructTmp->bUpdate = UPDATE_FINISH;
        } else {
            lpRegWordStructTmp->bUpdate = UPDATE_START;
        }

        lpRegWordStructTmp->dwReadingLen = (DWORD)lRet / sizeof(TCHAR);

        if (!IsWindowEnabled(lpImeLinkRadical->hRegWordButton)) {
            EnableWindow(lpImeLinkRadical->hRegWordButton, TRUE);
        }

        i = lpImeLinkRegWord->nCurrIME - lpImeLinkRadical->nStartIME;

        j = i * RECT_NUMBER + RECT_IMENAME;

        InvalidateRect(hWnd, &lpImeLinkRadical->rcRadical[j], FALSE);

        k = i * RECT_NUMBER + RECT_RADICAL;

        InvalidateRect(hWnd, &lpImeLinkRadical->rcRadical[k], FALSE);
    } else if (lParam & GCS_RESULTSTR) {
        LPIMERADICALRECT lpImeLinkRadical;
        UINT             i;
        UINT             j, k;

        lpImeLinkRadical = (LPIMERADICALRECT)GetWindowLongPtr(hWnd,
            GWL_RADICALRECT);

        if (lpRegWordStructTmp->bUpdate) {
            lpRegWordStructTmp->bUpdate = UPDATE_FINISH;
        }

        i = lpImeLinkRegWord->nCurrIME - lpImeLinkRadical->nStartIME;

        j = i * RECT_NUMBER + RECT_IMENAME;

        InvalidateRect(hWnd, &lpImeLinkRadical->rcRadical[j], FALSE);

        k = i * RECT_NUMBER + RECT_RADICAL;

        InvalidateRect(hWnd, &lpImeLinkRadical->rcRadical[k], FALSE);
    } else {
    }

    return;
}

/************************************************************/
/*  lstrcmpn                                                */
/************************************************************/
int lstrcmpn(
    LPCTSTR lpctszStr1,
    LPCTSTR lpctszStr2,
    int     cCount)
{
    int i;

    for (i = 0; i < cCount; i++) {
        int iCmp = *lpctszStr1++ - *lpctszStr2++;
        if (iCmp) { return iCmp; }
    }

    return 0;
}

/************************************************************/
/*  EnumReading                                             */
/************************************************************/
int CALLBACK EnumReading(
    LPCTSTR         lpszReading,
    DWORD           dwStyle,
    LPCTSTR         lpszString,
    LPREGWORDSTRUCT lpRegWordStructTmp)
{
    int     iLen;
    DWORD   dwZeroSeq;
    LRESULT lRet;
    TCHAR   tszZeroSeq[8];

    iLen = lstrlen(lpszReading);

    if (iLen * sizeof(TCHAR) > sizeof(lpRegWordStructTmp->szReading) -
        sizeof(WORD)) {
        return (0);
    }

    lpRegWordStructTmp->dwReadingLen = (DWORD)iLen;

    lstrcpy(lpRegWordStructTmp->szReading, lpszReading);

    dwZeroSeq = 0;
    lRet = ImmEscape(lpRegWordStructTmp->hKL, (HIMC)NULL,
        IME_ESC_SEQUENCE_TO_INTERNAL, &dwZeroSeq);

    if (!lRet) { return (1); }

    iLen = 0;

    if (LOWORD(lRet)) {
#ifdef UNICODE
        tszZeroSeq[iLen++] = LOWORD(lRet);
#else
        if (LOWORD(lRet) > 0xFF) {
            tszZeroSeq[iLen++] = HIBYTE(LOWORD(lRet));
            tszZeroSeq[iLen++] = LOBYTE(LOWORD(lRet));
        } else {
            tszZeroSeq[iLen++] = LOBYTE(LOWORD(lRet));
        }
#endif
    }

    if (HIWORD(lRet) == 0xFFFF) {
        // This is caused by sign extent in Win9x in the return value of
        // ImmEscape, it causes an invalid internal code.
    } else if (HIWORD(lRet)) {
#ifdef UNICODE
        tszZeroSeq[iLen++] = HIWORD(lRet);
#else
        if (HIWORD(lRet) > 0xFF) {
            tszZeroSeq[iLen++] = HIBYTE(HIWORD(lRet));
            tszZeroSeq[iLen++] = LOBYTE(HIWORD(lRet));
        } else {
            tszZeroSeq[iLen++] = LOBYTE(HIWORD(lRet));
        }
#endif
    } else {
    }

    for (; lpRegWordStructTmp->dwReadingLen > 0;
        lpRegWordStructTmp->dwReadingLen -= iLen) {
        if (lstrcmpn(&lpRegWordStructTmp->szReading[
            lpRegWordStructTmp->dwReadingLen - iLen], tszZeroSeq, iLen) != 0) {
            break;
        }
    }

    lpRegWordStructTmp->szReading[lpRegWordStructTmp->dwReadingLen] = '\0';

    return (1);
}

/************************************************************/
/*  EudcCode                                                */
/************************************************************/
void EudcCode(
    HWND hWnd,
    UINT uCode)
{
    LPIMELINKREGWORD lpImeLinkRegWord;
    LPREGWORDSTRUCT  lpRegWordStructTmp;
    UINT             i;

    lpImeLinkRegWord = (LPIMELINKREGWORD)GetWindowLongPtr(hWnd,
        GWL_IMELINKREGWORD);

#ifdef UNICODE
    lpImeLinkRegWord->szEudcCodeString[0] = (WCHAR)uCode;
#else
    lpImeLinkRegWord->szEudcCodeString[0] = HIBYTE(uCode);
    lpImeLinkRegWord->szEudcCodeString[1] = LOBYTE(uCode);
#endif
    lpImeLinkRegWord->szEudcCodeString[2] =
        lpImeLinkRegWord->szEudcCodeString[3] = '\0';

    lpRegWordStructTmp = &lpImeLinkRegWord->sRegWordStruct[0];

    for (i = 0; i < lpImeLinkRegWord->nEudcIMEs; i++) {
        lpRegWordStructTmp->bUpdate = UPDATE_NONE;
        lpRegWordStructTmp->szReading[0] = '\0';
        lpRegWordStructTmp->dwReadingLen = 0;

        ImmEnumRegisterWord(lpRegWordStructTmp->hKL, EnumReading,
            NULL, IME_REGWORD_STYLE_EUDC,
            lpImeLinkRegWord->szEudcCodeString,
            lpRegWordStructTmp);

        lpRegWordStructTmp->dwReadingLen = lstrlen(lpRegWordStructTmp->szReading);

        lpRegWordStructTmp++;
    }

    lpRegWordStructTmp = &lpImeLinkRegWord->sRegWordStruct[
        lpImeLinkRegWord->nCurrIME];

    ImmSetCompositionString(lpImeLinkRegWord->hRegWordIMC, SCS_SETSTR,
        NULL, 0, lpRegWordStructTmp->szReading,
        lpRegWordStructTmp->dwReadingLen * sizeof(TCHAR));

    InvalidateRect(hWnd, NULL, FALSE);

    return;
}

/************************************************************/
/*  ChangeToOtherIME                                        */
/************************************************************/
void ChangeToOtherIME(
    HWND   hWnd,
    LPARAM lMousePos)
{
    POINT            ptMouse;
    LPIMERADICALRECT lpImeLinkRadical;
    UINT             i;
    BOOL             bFound;

    ptMouse.x = LOWORD(lMousePos);
    ptMouse.y = HIWORD(lMousePos);

    lpImeLinkRadical = (LPIMERADICALRECT)GetWindowLongPtr(hWnd,
        GWL_RADICALRECT);

    bFound = FALSE;

    for (i = 0; i < lpImeLinkRadical->nPerPageIMEs; i++) {
        UINT j;

        j = i * RECT_NUMBER + RECT_RADICAL;

        if (PtInRect(&lpImeLinkRadical->rcRadical[j], ptMouse)) {
            bFound = TRUE;
            break;
        }
    }

    if (!bFound) {
        return;
    }

    SwitchToThisIME(hWnd, lpImeLinkRadical->nStartIME + i);

    return;
}

/************************************************************/
/*  ScrollIME                                               */
/************************************************************/
void ScrollIME(
    HWND   hWnd,
    WPARAM wParam)
{
    LPIMELINKREGWORD lpImeLinkRegWord;
    LPIMERADICALRECT lpImeLinkRadical;
    int              iLines;
    UINT             uIndex;

    lpImeLinkRegWord = (LPIMELINKREGWORD)GetWindowLongPtr(hWnd,
        GWL_IMELINKREGWORD);

    lpImeLinkRadical = (LPIMERADICALRECT)GetWindowLongPtr(hWnd,
        GWL_RADICALRECT);

    switch (LOWORD(wParam)) {
    case SB_PAGEDOWN:
        // scroll (page size - 1)
        iLines = lpImeLinkRadical->nPerPageIMEs - 1;
        break;
    case SB_LINEDOWN:
        iLines = 1;
        break;
    case SB_PAGEUP:
        // scroll (page size - 1)
        iLines = 1 - lpImeLinkRadical->nPerPageIMEs;
        break;
    case SB_LINEUP:
        iLines = -1;
        break;
    case SB_TOP:
        // swicth to the first one
        SwitchToThisIME(hWnd, 0);
        return;
    case SB_BOTTOM:
        // swicth to the last one
        SwitchToThisIME(hWnd, lpImeLinkRegWord->nEudcIMEs - 1);
        return;
    case SB_THUMBPOSITION:
        SwitchToThisIME(hWnd, HIWORD(wParam));
        return;
    default:
        return;
    }

    uIndex = lpImeLinkRegWord->nCurrIME;

    if (iLines > 0) {
        uIndex += (UINT)iLines;

        if (uIndex >= lpImeLinkRegWord->nEudcIMEs) {
            // should not exceed the total IMEs
            uIndex = lpImeLinkRegWord->nEudcIMEs - 1;
        }
    } else {
        UINT uLines;

        uLines = -iLines;

        if (uLines > uIndex) {
            uIndex = 0;
        } else {
            uIndex -= uLines;
        }
    }

    SwitchToThisIME(hWnd, uIndex);

    return;
}

/************************************************************/
/*  ScrollIMEByKey                                          */
/************************************************************/
void ScrollIMEByKey(
    HWND   hWnd,
    WPARAM wParam)
{
    switch (wParam) {
    case VK_NEXT:
        ScrollIME(hWnd, SB_PAGEDOWN);
        break;
    case VK_DOWN:   // can not work because dialog do not pass this key to us
        ScrollIME(hWnd, SB_LINEDOWN);
        break;
    case VK_PRIOR:
        ScrollIME(hWnd, SB_PAGEUP);
        break;
    case VK_UP:     // can not work because dialog do not pass this key to us
        ScrollIME(hWnd, SB_LINEUP);
        break;
    default:
        return;
    }

    return;
}

/************************************************************/
/*  RegWordGetFocus                                         */
/************************************************************/
void RegWordGetFocus(
    HWND hWnd)
{
    LPIMELINKREGWORD lpImeLinkRegWord;
    LPIMERADICALRECT lpImeLinkRadical;
    UINT             i;

    lpImeLinkRegWord = (LPIMELINKREGWORD)GetWindowLongPtr(hWnd,
        GWL_IMELINKREGWORD);

    lpImeLinkRadical = (LPIMERADICALRECT)GetWindowLongPtr(hWnd,
        GWL_RADICALRECT);

    CreateCaret(hWnd, NULL, 2, lpImeLinkRadical->lTextSize.cy +
        CARET_MARGIN * 2);

    if (lpImeLinkRegWord->nCurrIME < lpImeLinkRadical->nStartIME) {
        lpImeLinkRegWord->nCurrIME = lpImeLinkRadical->nStartIME;
    } else if ((lpImeLinkRegWord->nCurrIME - lpImeLinkRadical->nStartIME) >=
        lpImeLinkRadical->nPerPageIMEs) {
        lpImeLinkRegWord->nCurrIME = lpImeLinkRadical->nStartIME +
            lpImeLinkRadical->nPerPageIMEs - 1;
    } else {
    }

    i = lpImeLinkRegWord->nCurrIME - lpImeLinkRadical->nStartIME;

    i = (i * RECT_NUMBER) + RECT_RADICAL;

    SetCaretPos(lpImeLinkRadical->rcRadical[i].left +
        lpImeLinkRadical->lCurrReadingExtent.cx + 2,
        lpImeLinkRadical->rcRadical[i].top + UI_MARGIN - CARET_MARGIN);

    ShowCaret(hWnd);

    return;
}

/************************************************************/
/*  RegWordPaint                                            */
/************************************************************/
void RegWordPaint(
    HWND hWnd)
{
    LPIMERADICALRECT lpImeLinkRadical;
    LPIMELINKREGWORD lpImeLinkRegWord;
    LPREGWORDSTRUCT  lpRegWordStructTmp;
    HDC              hDC;
    PAINTSTRUCT      ps;
    UINT             i;
    UINT             nShowIMEs;

    lpImeLinkRadical = (LPIMERADICALRECT)GetWindowLongPtr(hWnd,
        GWL_RADICALRECT);

    lpImeLinkRegWord = (LPIMELINKREGWORD)GetWindowLongPtr(hWnd,
        GWL_IMELINKREGWORD);

    lpRegWordStructTmp = &lpImeLinkRegWord->sRegWordStruct[
        lpImeLinkRadical->nStartIME];

    HideCaret(hWnd);

    hDC = BeginPaint(hWnd, &ps);

    // we only can show up to the final one
    nShowIMEs = lpImeLinkRegWord->nEudcIMEs - lpImeLinkRadical->nStartIME;

    if (nShowIMEs > lpImeLinkRadical->nPerPageIMEs) {
        // we only can show one page a time
        nShowIMEs = lpImeLinkRadical->nPerPageIMEs;
    }

    for (i = 0; i < nShowIMEs; i++) {
        RECT rcSunken;
        UINT j, k;

        k = i * RECT_NUMBER + RECT_RADICAL;

        rcSunken = lpImeLinkRadical->rcRadical[k];

        rcSunken.left -= 2;
        rcSunken.top -= 2;
        rcSunken.right += 2;
        rcSunken.bottom += 2;

        DrawEdge(hDC, &rcSunken, BDR_SUNKENOUTER, BF_RECT);

        SetBkColor(hDC, GetSysColor(COLOR_BTNFACE));

        if (lpRegWordStructTmp->bUpdate == UPDATE_ERROR) {
            // red text for error
            SetTextColor(hDC, RGB(0xFF, 0x00, 0x00));
        } else if (lpRegWordStructTmp->bUpdate == UPDATE_START) {
            // yellow text for not finished
            SetTextColor(hDC, RGB(0xFF, 0xFF, 0x00));
        } else if (lpRegWordStructTmp->bUpdate == UPDATE_REGISTERED) {
            // green text for registered
            SetTextColor(hDC, RGB(0x00, 0x80, 0x00));
        } else {
            SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT));
        }

        j = i * RECT_NUMBER + RECT_IMENAME;

        ExtTextOut(hDC, lpImeLinkRadical->rcRadical[j].left,
            lpImeLinkRadical->rcRadical[j].top,
            ETO_OPAQUE|ETO_CLIPPED, &lpImeLinkRadical->rcRadical[j],
            lpRegWordStructTmp->szIMEName,
            lpRegWordStructTmp->uIMENameLen, NULL);

        if ((lpImeLinkRegWord->nCurrIME - lpImeLinkRadical->nStartIME) == i) {
            SetBkColor(hDC, GetSysColor(COLOR_WINDOW));
            SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT));

            GetTextExtentPoint(hDC, lpRegWordStructTmp->szReading,
                lpRegWordStructTmp->dwReadingLen,
                &lpImeLinkRadical->lCurrReadingExtent);

            SetCaretPos(lpImeLinkRadical->rcRadical[k].left +
                lpImeLinkRadical->lCurrReadingExtent.cx + 2,
                lpImeLinkRadical->rcRadical[k].top + UI_MARGIN - CARET_MARGIN);
        } else {
            SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT));
        }

        ExtTextOut(hDC, lpImeLinkRadical->rcRadical[k].left,
            lpImeLinkRadical->rcRadical[k].top + UI_MARGIN,
            ETO_OPAQUE, &lpImeLinkRadical->rcRadical[k],
            lpRegWordStructTmp->szReading,
            lpRegWordStructTmp->dwReadingLen, NULL);

        lpRegWordStructTmp++;
    }

    EndPaint(hWnd, &ps);

    ShowCaret(hWnd);

    return;
}

/************************************************************/
/*  RegWordWndProc                                          */
/************************************************************/
LRESULT CALLBACK RegWordWndProc(
    HWND   hWnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (uMsg) {
    case WM_CREATE:
        {
            LPIMELINKREGWORD lpImeLinkRegWord;
            UINT             uIndex;

            // initialize to 0
            SetWindowLongPtr(hWnd, GWL_IMELINKREGWORD, 0L);
            SetWindowLongPtr(hWnd, GWL_RADICALRECT, 0L);

            lpImeLinkRegWord = RegWordCreate(hWnd);

            if (!lpImeLinkRegWord) {
                return (-1);
            }

            lpImeLinkRegWord->fCompMsg = TRUE;
            lpImeLinkRegWord->nCurrIME = 0xFFFFFFFF;

            lpImeLinkRegWord->hRegWordIMC = ImmCreateContext();

            if (!lpImeLinkRegWord->hRegWordIMC) {
                return (-1);
            }

            lpImeLinkRegWord->hOldIMC = ImmAssociateContext(hWnd,
                lpImeLinkRegWord->hRegWordIMC);

            SetWindowLongPtr(hWnd, GWL_IMELINKREGWORD, (LONG_PTR)lpImeLinkRegWord);

            uIndex = 0;
            SwitchToThisIME(hWnd, 0);

            // the switch will fail, if the window is disable, try again
            PostMessage(hWnd, WM_EUDC_SWITCHIME, 0, uIndex);
        }
        break;
    case WM_EUDC_COMPMSG:
        {
            LPIMELINKREGWORD lpImeLinkRegWord;

            lpImeLinkRegWord = (LPIMELINKREGWORD)GetWindowLongPtr(hWnd,
                GWL_IMELINKREGWORD);

            lpImeLinkRegWord->fCompMsg = (BOOL)lParam;
        }
        break;
    case WM_EUDC_SWITCHIME:
        {
            LPIMELINKREGWORD lpImeLinkRegWord;

            lpImeLinkRegWord = (LPIMELINKREGWORD)GetWindowLongPtr(hWnd,
                GWL_IMELINKREGWORD);

            lpImeLinkRegWord->nCurrIME = 0xFFFFFFFF;

            SwitchToThisIME(hWnd, (UINT)lParam);
        }
        break;
    case WM_IME_STARTCOMPOSITION:
    case WM_IME_ENDCOMPOSITION:
        break;
    case WM_IME_COMPOSITION:
        {
            LPIMELINKREGWORD lpImeLinkRegWord;

            lpImeLinkRegWord = (LPIMELINKREGWORD)GetWindowLongPtr(hWnd,
                GWL_IMELINKREGWORD);

            if (lpImeLinkRegWord->fCompMsg) {
                WmImeComposition(hWnd, lParam);
            }
        }
        break;
    case WM_IME_NOTIFY:
        switch (wParam) {
        case IMN_OPENSTATUSWINDOW:
        case IMN_CLOSESTATUSWINDOW:
        case IMN_OPENCANDIDATE:
        case IMN_CHANGECANDIDATE:
        case IMN_CLOSECANDIDATE:
            break;
        default:
            return DefWindowProc(hWnd, uMsg, wParam, lParam);
        }
        break;
    case WM_IME_SETCONTEXT:
        return DefWindowProc(hWnd, uMsg, wParam, lParam & ~(ISC_SHOWUIALL));
    case WM_EUDC_REGISTER_BUTTON:
        {
            LPIMERADICALRECT lpImeRadicalRect;

            lpImeRadicalRect = (LPIMERADICALRECT)GetWindowLongPtr(hWnd,
                GWL_RADICALRECT);

            lpImeRadicalRect->hRegWordButton = (HWND)lParam;
        }
        break;
    case WM_EUDC_CODE:
        EudcCode(hWnd, (UINT)lParam);
        break;
    case WM_LBUTTONDOWN:
        ChangeToOtherIME(hWnd, lParam);
        break;
    case WM_VSCROLL:
        ScrollIME(hWnd, wParam);
        break;
    case WM_KEYDOWN:
        ScrollIMEByKey(hWnd, wParam);
        break;
    case WM_SETFOCUS:
        RegWordGetFocus(hWnd);
        break;
    case WM_KILLFOCUS:
        DestroyCaret();
        break;
    case WM_PAINT:
        RegWordPaint(hWnd);
        break;
    case WM_DESTROY:
        {
            LPIMERADICALRECT lpImeRadicalRect;
            LPIMELINKREGWORD lpImeLinkRegWord;

            lpImeRadicalRect = (LPIMERADICALRECT)GetWindowLongPtr(hWnd,
                GWL_RADICALRECT);

            if (lpImeRadicalRect) {
                GlobalFree((HGLOBAL)lpImeRadicalRect);
            }

            lpImeLinkRegWord = (LPIMELINKREGWORD)GetWindowLongPtr(hWnd,
                GWL_IMELINKREGWORD);

            if (!lpImeLinkRegWord) {
                break;
            }

            ImmAssociateContext(hWnd, lpImeLinkRegWord->hOldIMC);

            ImmDestroyContext(lpImeLinkRegWord->hRegWordIMC);

            GlobalFree((HGLOBAL)lpImeLinkRegWord);
        }
        break;
    default:
        return DefWindowProc(hWnd, uMsg, wParam, lParam);
    }

    return (0L);
}

/************************************************************/
/*  RegisterThisEudc                                        */
/************************************************************/
int RegisterThisEudc(
    HWND hWnd)
{
    LPIMELINKREGWORD lpImeLinkRegWord;
    LPREGWORDSTRUCT  lpRegWordStructTmp;
    UINT             i;
    int              iRet;

    lpImeLinkRegWord = (LPIMELINKREGWORD)GetWindowLongPtr(hWnd,
        GWL_IMELINKREGWORD);

    lpRegWordStructTmp = &lpImeLinkRegWord->sRegWordStruct[0];

    iRet = -1;

    for (i = 0; i < lpImeLinkRegWord->nEudcIMEs; i++, lpRegWordStructTmp++) {
        if (lpRegWordStructTmp->bUpdate == UPDATE_NONE) {
        } else if (lpRegWordStructTmp->bUpdate != UPDATE_FINISH) {
            TCHAR szStrBuf[128];
            int   iYesNo;

            if (iRet != -1) {
                continue;
            }

            LoadString(hAppInst, IDS_QUERY_NOTFINISH, szStrBuf,
                sizeof(szStrBuf) / sizeof(TCHAR));

            iYesNo = MessageBox(hWnd, szStrBuf,
                lpRegWordStructTmp->szIMEName,
                MB_APPLMODAL|MB_YESNO|MB_DEFBUTTON1);

            if (iYesNo == IDYES) {
                iRet = i;
            }
        } else {
            BOOL  fRet;
            TCHAR szStrBuf[128];
            int   iYesNo;

            fRet = ImmRegisterWord(lpRegWordStructTmp->hKL,
                lpRegWordStructTmp->szReading, IME_REGWORD_STYLE_EUDC,
                lpImeLinkRegWord->szEudcCodeString);

            if (fRet) {
                lpRegWordStructTmp->bUpdate = UPDATE_REGISTERED;
                continue;
            } else {
                lpRegWordStructTmp->bUpdate = UPDATE_ERROR;
            }

            if (iRet != -1) {
                continue;
            }

            LoadString(hAppInst, IDS_QUERY_REGISTER, szStrBuf,
                sizeof(szStrBuf) / sizeof(TCHAR));

            iYesNo = MessageBox(hWnd, szStrBuf,
                lpRegWordStructTmp->szIMEName,
                MB_APPLMODAL|MB_YESNO|MB_DEFBUTTON1);

            if (iYesNo == IDYES) {
                iRet = i;
            }
        }
    }

    InvalidateRect(hWnd, NULL, FALSE);

    return (iRet);
}

/************************************************************/
/*  CodePageInfo()                                          */
/************************************************************/
int CodePageInfo(
    UINT uCodePage)
{
    int i;

    for (i = 0; i < sizeof(sCountry) / sizeof(COUNTRYSETTING); i++) {
        if (sCountry[i].uCodePage == uCodePage) {
            return(i);
        }
    }

    return (-1);
}

/************************************************************/
/*  ImeLinkDlgProc                                          */
/************************************************************/
INT_PTR CALLBACK ImeLinkDlgProc(
    HWND   hDlg,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (uMsg) {
    case WM_INITDIALOG:
        {
            HWND  hRadicalWnd, hRegWordButton;
            int   cbString;
#ifdef UNICODE    // this code could not run under non NATIVE platforms
            UINT  uCodePage, uNativeCode;
            int   i;
#endif
            TCHAR szTitle[128];

            cbString = GetWindowText(hDlg, szTitle, sizeof(szTitle) /
                sizeof(TCHAR));

#ifdef UNICODE
            uCodePage = GetACP();

            i = CodePageInfo(uCodePage);

            if (uCodePage == UNICODE_CP || i == -1) {
                wsprintf(&szTitle[cbString], TEXT("%4X"), (UINT)lParam);
            } else {
                uNativeCode = 0;

                WideCharToMultiByte(uCodePage, WC_COMPOSITECHECK,
                    (LPCWSTR)&lParam, 1,
                    (LPSTR)&uNativeCode, sizeof(uNativeCode),
                    NULL, NULL);

                // convert to multi byte string
                uNativeCode = LOBYTE(uNativeCode) << 8 | HIBYTE(uNativeCode);

                wsprintf(&szTitle[cbString], TEXT("%4X (%s - %4X)"),
                    (UINT)lParam, sCountry[i].szCodePage, (UINT)uNativeCode);
            }
#else
            wsprintf(&szTitle[cbString], TEXT("%4X"), (UINT)lParam);
#endif

            SetWindowText(hDlg, szTitle);

            hRadicalWnd = GetDlgItem(hDlg, IDD_RADICAL);

            SendMessage(hRadicalWnd, WM_EUDC_CODE, 0, lParam);

            hRegWordButton = GetDlgItem(hDlg, IDOK);

            EnableWindow(hRegWordButton, FALSE);

            SendMessage(hRadicalWnd, WM_EUDC_REGISTER_BUTTON, 0,
                (LPARAM)hRegWordButton);
        }
        return (TRUE);      // do not want to set focus to special control
    case WM_COMMAND:
        switch (wParam) {
        case IDOK:
            {
                HWND  hRadicalWnd;

                hRadicalWnd = GetDlgItem(hDlg, IDD_RADICAL);

                if (RegisterThisEudc(hRadicalWnd) == -1) {
                    EndDialog(hDlg, TRUE);
                } else {
                    SetFocus(hRadicalWnd);
                }
            }

            break;
        case IDCANCEL:
            EndDialog(hDlg, FALSE);
            break;
        default:
            return (FALSE);
        }
        return (TRUE);
    case WM_IME_NOTIFY:
        // we need to hook these messages from frame window also
        // otherwise sometime the OPENSTATUS will send to the frame
        // window and the child - hRadicalWnd will not get these messages
        switch (wParam) {
        case IMN_OPENSTATUSWINDOW:
        case IMN_CLOSESTATUSWINDOW:
            return (TRUE);
        default:
            return (FALSE);
        }
    default:
        return (FALSE);
    }

    return (TRUE);
}

/************************************************************/
/*  ImeLink                                                 */
/************************************************************/
void ImeLink(
    HWND hWnd,
    UINT uCode)
{
    static BOOL bFirstTime = TRUE;

    UINT       nLayouts;
    HKL FAR   *lphKL;
    TCHAR      szTitle[32];
    TCHAR      szMessage[256];
    UINT       i, nIMEs;
    WNDCLASSEX wcClass;
    HKL        hOldKL;

    nLayouts = GetKeyboardLayoutList(0, NULL);

    lphKL = GlobalAlloc(GPTR, sizeof(HKL) * nLayouts);

    if (!lphKL) {
        LoadString(hAppInst, IDS_NOMEM_TITLE, szTitle, sizeof(szTitle) / sizeof(TCHAR));
        LoadString(hAppInst, IDS_NOMEM_MSG, szMessage, sizeof(szMessage) / sizeof(TCHAR));

        MessageBox(hWnd, szMessage, szTitle, MB_OK);
        return;
    }

    // MSVC may have problem for recusive modal dialog box,
    // I mean create a modal dialog box within a modal dialog box.

    // so we need to move the code from RegWordCreate() to here to
    // prevent creating a modal dialog form a modal dialog.
    // The ImmConfigureIME API call is possible to create a modal dialog.

    // get all keyboard layouts, it will include all IMEs
    GetKeyboardLayoutList(nLayouts, lphKL);

    for (i = 0, nIMEs = 0; i < nLayouts; i++) {
        BOOL  fRet;
        HKL   hKL;
        TCHAR szImeEudcDic[80];

        hKL = *(lphKL + i);

        fRet = ImmIsIME(hKL);

        if (!fRet) {            // this is not an IME
            continue;
        }

        szImeEudcDic[0] = '\0';

        fRet = (BOOL) ImmEscape(hKL, (HIMC)NULL, IME_ESC_GET_EUDC_DICTIONARY,
            szImeEudcDic);

        if (!fRet) {
            continue;
        }

        if (szImeEudcDic[0]) {
            fRet = TRUE;
        } else if (!bFirstTime) {
        } else {
            fRet = ImmConfigureIME(hKL, hWnd, IME_CONFIG_SELECTDICTIONARY, NULL);
        }

        if (!fRet) {
            // this IME do not have an IME EUDC dictionary
            continue;
        }

        if (szImeEudcDic[0] == '\0') {
            // check whether we really get a dictionary
            fRet = (BOOL) ImmEscape(hKL, (HIMC)NULL, IME_ESC_GET_EUDC_DICTIONARY,
                szImeEudcDic);

            if (!fRet) {
                continue;
            } else if (szImeEudcDic[0] == '\0') {
                continue;
            } else {
            }
        } else {
        }

        nIMEs++;
    }

    GlobalFree((HGLOBAL)lphKL);

    if (bFirstTime) {
        bFirstTime = FALSE;
    }

    if (!nIMEs) {
        LoadString(hAppInst, IDS_NOIME_TITLE, szTitle, sizeof(szTitle) / sizeof(TCHAR));
        LoadString(hAppInst, IDS_NOIME_MSG, szMessage, sizeof(szMessage) / sizeof(TCHAR));

        MessageBox(hWnd, szMessage, szTitle, MB_OK);
        return;
    }

    if (!GetClassInfoEx(hAppInst, szRegWordCls, &wcClass)) {
        wcClass.cbSize = sizeof(WNDCLASSEX);
        wcClass.style = CS_HREDRAW|CS_VREDRAW;
        wcClass.lpfnWndProc = RegWordWndProc;
        wcClass.cbClsExtra = 0;
        wcClass.cbWndExtra = GWL_SIZE;
        wcClass.hInstance = hAppInst;
        wcClass.hIcon = NULL;
        wcClass.hCursor = LoadCursor(NULL, IDC_ARROW);
        wcClass.hbrBackground = (HBRUSH)(COLOR_BTNFACE + 1);
        wcClass.lpszMenuName = NULL;
        wcClass.lpszClassName = szRegWordCls;
        wcClass.hIconSm = NULL;
        RegisterClassEx(&wcClass);
    }

    hOldKL = GetKeyboardLayout(0);

    DialogBoxParam(hAppInst, szImeLinkDlg, hWnd, ImeLinkDlgProc,
        (LPARAM)uCode);

    ActivateKeyboardLayout(hOldKL, 0);

    return;
}

/************************************************************/
/*  MatchImeName()                                          */
/************************************************************/
HKL MatchImeName(
    LPCTSTR szStr)
{
    TCHAR     szImeName[16];
    int       nLayout;
    HKL       hKL;
    HGLOBAL   hMem;
    HKL FAR * lpMem;
    int       i;

    nLayout = GetKeyboardLayoutList(0, NULL);

    // alloc temp buffer
    hMem = GlobalAlloc(GHND, sizeof(HKL) * nLayout);

    if (!hMem) {
        return (NULL);
    }

    lpMem = (HKL FAR *)GlobalLock(hMem);

    if (!lpMem) {
        GlobalFree(hMem);
        return (NULL);
    }

    // get all keyboard layouts, it includes all IMEs
    GetKeyboardLayoutList(nLayout, lpMem);

    for (i = 0; i < nLayout; i++) {
        BOOL fRet;

        hKL = *(lpMem + i);

        fRet = (BOOL) ImmEscape(hKL, (HIMC)NULL, IME_ESC_IME_NAME, szImeName);

        if (!fRet) {                // this hKL can not ask name
            continue;
        }

        if (lstrcmp(szStr, szImeName) == 0) {
            goto MatchOvr;
        }
    }

    hKL = NULL;

MatchOvr:
    GlobalUnlock(hMem);
    GlobalFree(hMem);

    return (hKL);
}

/************************************************************/
/*  RegisterTable()                                         */
/************************************************************/
HKL RegisterTable(
    HWND          hWnd,
    LPUSRDICIMHDR lpIsvUsrDic,
    DWORD         dwFileSize,
    UINT          uCodePage)
{
    HKL    hKL;
    HDC    hDC;
    SIZE   lTextSize;
    RECT   rcProcess;
    DWORD  i;
    LPBYTE lpCurr, lpEnd;
    BOOL   fRet;
    TCHAR  szStr[16];
    TCHAR  szProcessFmt[32];
    TCHAR  szResult[2][32];
    TCHAR  szProcessInfo[48];
    WORD   wInternalCode[256];
    WORD   wAltInternalCode[256];

#ifdef UNICODE
    if (uCodePage == UNICODE_CP) {
        LPUNATSTR lpszMethodName;

        lpszMethodName = (LPUNATSTR)lpIsvUsrDic->achMethodName;

        for (i = 0; i < sizeof(lpIsvUsrDic->achMethodName) / sizeof(TCHAR); i++) {
            szStr[i] = *lpszMethodName++;
        }

        szStr[i] = '\0';
    } else {
        UINT uLen;

        uLen = MultiByteToWideChar(uCodePage, MB_PRECOMPOSED,
            (LPCSTR)lpIsvUsrDic->achMethodName,
            sizeof(lpIsvUsrDic->achMethodName),
            szStr,
            sizeof(szStr) / sizeof(TCHAR));

        szStr[uLen] = '\0';
    }
#else
    for (i = 0; i < sizeof(lpIsvUsrDic->achMethodName); i++) {
        szStr[i] = lpIsvUsrDic->achMethodName[i];
    }

    szStr[i] = '\0';
#endif

    hKL = MatchImeName(szStr);

    if (!hKL) {
        return (hKL);
    }

    LoadString(hAppInst, IDS_PROCESS_FMT, szProcessFmt, sizeof(szProcessFmt) / sizeof(TCHAR));
    LoadString(hAppInst, IDS_RESULT_FAIL, szResult[0], sizeof(szResult[0]) / sizeof(TCHAR));
    LoadString(hAppInst, IDS_RESULT_SUCCESS, szResult[1], sizeof(szResult[1]) / sizeof(TCHAR));

    LoadString(hAppInst, IDS_CHINESE_CHAR, szStr, sizeof(szStr) / sizeof(TCHAR));

    hDC = GetDC(NULL);

    GetTextExtentPoint(hDC, szStr, sizeof(WORD)/sizeof(TCHAR),
        &lTextSize);

    ReleaseDC(NULL, hDC);

    // show the processing in somewhere, don't need to be same as this
    rcProcess.left = 1;
    rcProcess.top  = 1;
    rcProcess.right = rcProcess.left + lTextSize.cx *
        sizeof(szProcessInfo) / sizeof(WORD);
    rcProcess.bottom = rcProcess.top + lTextSize.cy;

    // convert sequence code to internal code
    for (i = 0; i < sizeof(wInternalCode) / sizeof(WORD); i++) {
        LRESULT lRet;

        lRet = ImmEscape(hKL, (HIMC)NULL,
            IME_ESC_SEQUENCE_TO_INTERNAL, &i);

        if (HIWORD(lRet) == 0xFFFF) {
            // This is caused by sign extent in Win9x in the return value of
            // ImmEscape, it causes an invalid internal code.
            wAltInternalCode[i] = 0;
        } else {
            wAltInternalCode[i] = HIWORD(lRet);
        }

        wInternalCode[i] = LOWORD(lRet);

#ifndef UNICODE
        if (wAltInternalCode[i] > 0xFF) {
            // convert to multi byte string
            wAltInternalCode[i] = LOBYTE(wAltInternalCode[i]) << 8 |
                HIBYTE(wAltInternalCode[i]);
        }

        if (wInternalCode[i] > 0xFF) {
            // convert to multi byte string
            wInternalCode[i] = LOBYTE(wInternalCode[i]) << 8 |
                HIBYTE(wInternalCode[i]);
        }
#endif
    }

    // check for each record and register it
    // get to the first record and skip the Bank ID
    lpCurr = (LPBYTE)(lpIsvUsrDic + 1) + sizeof(WORD);
    lpEnd = (LPBYTE)lpIsvUsrDic + dwFileSize;

    for (; lpCurr < lpEnd;
        // internal code + sequence code + Bank ID of next record
        lpCurr += sizeof(WORD) + lpIsvUsrDic->cMethodKeySize + sizeof(WORD)) {

        int j;

        // quick way to init \0 for the register string
        *(LPDWORD)szStr = 0;

#ifdef UNICODE
        if (uCodePage == UNICODE_CP) {
            szStr[0] = *(LPUNATSTR)lpCurr;
        } else {
            CHAR szMultiByte[4];

            szMultiByte[0] = HIBYTE(*(LPUNATSTR)lpCurr);
            szMultiByte[1] = LOBYTE(*(LPUNATSTR)lpCurr);

            MultiByteToWideChar(uCodePage, MB_PRECOMPOSED,
                szMultiByte, 2, szStr, 2);
        }
#else
        szStr[1] = *lpCurr;
        szStr[0] = *(lpCurr + 1);
#endif

        for (i = 0, j = 0; i < lpIsvUsrDic->cMethodKeySize; i++) {
            if (!wAltInternalCode[*(LPBYTE)(lpCurr + sizeof(WORD) + i)]) {
            } else if (wAltInternalCode[*(LPBYTE)(lpCurr + sizeof(WORD) + i)] < 0xFF) {
                *(LPTSTR)&szStr[4 + j] = (TCHAR)
                    wAltInternalCode[*(LPBYTE)(lpCurr + sizeof(WORD) + i)];
                j += sizeof(TCHAR) / sizeof(TCHAR);
            } else {
                *(LPWSTR)&szStr[4 + j] = (WCHAR)
                    wAltInternalCode[*(LPBYTE)(lpCurr + sizeof(WORD) + i)];
                j += sizeof(WCHAR) / sizeof(TCHAR);
            }

            if (wInternalCode[*(LPBYTE)(lpCurr + sizeof(WORD) + i)] < 0xFF) {
                *(LPTSTR)&szStr[4 + j] = (TCHAR)
                    wInternalCode[*(LPBYTE)(lpCurr + sizeof(WORD) + i)];
                j += sizeof(TCHAR) / sizeof(TCHAR);
            } else {
                *(LPWSTR)&szStr[4 + j] = (WCHAR)
                    wInternalCode[*(LPBYTE)(lpCurr + sizeof(WORD) + i)];
                j += sizeof(WCHAR) / sizeof(TCHAR);
            }
        }

        szStr[4 + j] = szStr[4 + j + 1] = szStr[4 + j + 2] = '\0';

        fRet = ImmRegisterWord(hKL, &szStr[4], IME_REGWORD_STYLE_EUDC,
            szStr);

        wsprintf(szProcessInfo, szProcessFmt, (LPTSTR)szStr,
            (LPTSTR)&szStr[4], szResult[fRet]);

        hDC = GetDC(hWnd);

        // show the process information
        ExtTextOut(hDC, rcProcess.left, rcProcess.top, ETO_OPAQUE,
            &rcProcess, szProcessInfo, lstrlen(szProcessInfo),
            NULL);

        ReleaseDC(NULL, hDC);

        if (!fRet) {
            // wait 3 seconds for fail case
            Sleep(3000);
        }
    }

    return (hKL);
}

/************************************************************/
/*  BatchImeLink()                                          */
/************************************************************/
void BatchImeLink(
    HWND hWnd)
{
    HANDLE        hIsvUsrDicFile, hIsvUsrDic;
    LPUSRDICIMHDR lpIsvUsrDic;
    TCHAR         chReplace;
    int           i, cbString;
    DWORD         dwSize, dwFileSize;
    LPTSTR        szTitle, szMessage;
    int           iTitle, iMessage;

    OPENFILENAME  ofn;
    TCHAR         szFilter[64];
    TCHAR         szFileName[MAX_PATH];
    TCHAR         szDirName[MAX_PATH];

    // try to share the buffer
    szTitle = szFilter;
    iTitle = sizeof(szFilter) / sizeof(TCHAR);
    szMessage = szDirName;
    iMessage = sizeof(szDirName) / sizeof(TCHAR);

    // internal error, the data structure need byte alignment
    // it should not use WORD or DWORD alignment

    if (sizeof(USRDICIMHDR) != 256) {
        LoadString(hAppInst, IDS_INTERNAL_TITLE, szTitle, iTitle);
        LoadString(hAppInst, IDS_INTERNAL_MSG, szMessage, iMessage);

        MessageBox(hWnd, szMessage, szTitle, MB_OK);
        return;
    }

    // do we need to set a new file name
    cbString = LoadString(hAppInst, IDS_ISV_FILE_FILTER, szFilter,
        sizeof(szFilter) / sizeof(TCHAR));
    chReplace = szFilter[cbString - 1];

    for (i = 0; szFilter[i]; i++) {
        if (szFilter[i] == chReplace) {
            szFilter[i] = '\0';
        }
    }

    GetWindowsDirectory(szDirName, sizeof(szDirName) / sizeof(TCHAR));
    lstrcpy(szFileName, TEXT("*.TBL"));

    // prompt a open file dialog
    ofn.lStructSize = sizeof(OPENFILENAME);
    ofn.hwndOwner = hWnd;
    ofn.lpstrFilter = szFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = szFileName;
    ofn.nMaxFile = sizeof(szFileName) / sizeof(TCHAR);
    ofn.lpstrFileTitle = NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = szDirName;
    ofn.lpstrTitle = NULL;;
    ofn.Flags = OFN_NOCHANGEDIR|OFN_HIDEREADONLY|OFN_CREATEPROMPT|
        OFN_PATHMUSTEXIST;
    ofn.lpstrDefExt = NULL;

    if (!GetOpenFileName(&ofn)) {
        return;
    }

    hIsvUsrDicFile = CreateFile(ofn.lpstrFile, GENERIC_READ, 0, NULL,
        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hIsvUsrDicFile == INVALID_HANDLE_VALUE) {
        LoadString(hAppInst, IDS_NOTOPEN_TITLE, szTitle, iTitle);
        LoadString(hAppInst, IDS_NOTOPEN_MSG, szMessage, iMessage);

        MessageBox(hWnd, szMessage, szTitle,
            MB_OK|MB_ICONHAND|MB_TASKMODAL|MB_TOPMOST);
        return;
    }

#if 0
    for (i = 0; i < sizeof(szFileName); i++) {
        if (szFileName[i] == '\\') {
            szFileName[i] = ' ';
        }
    }
#endif

    hIsvUsrDic = CreateFileMapping((HANDLE)hIsvUsrDicFile, NULL,
        PAGE_READONLY, 0, 0, NULL);

    if (!hIsvUsrDic) {
        LoadString(hAppInst, IDS_NOTOPEN_TITLE, szTitle, iTitle);
        LoadString(hAppInst, IDS_NOTOPEN_MSG, szMessage, iMessage);

        MessageBox(hWnd, szMessage, szTitle,
            MB_OK|MB_ICONHAND|MB_TASKMODAL|MB_TOPMOST);
        goto BatchCloseUsrDicFile;
    }

    lpIsvUsrDic = MapViewOfFile(hIsvUsrDic, FILE_MAP_READ, 0, 0, 0);

    if (!lpIsvUsrDic) {
        LoadString(hAppInst, IDS_NOTOPEN_TITLE, szTitle, iTitle);
        LoadString(hAppInst, IDS_NOTOPEN_MSG, szMessage, iMessage);

        MessageBox(hWnd, szMessage, szTitle,
            MB_OK|MB_ICONHAND|MB_TASKMODAL|MB_TOPMOST);
        goto BatchCloseUsrDic;
    }

    dwSize = lpIsvUsrDic->ulTableCount * (sizeof(WORD) + sizeof(WORD) +
        lpIsvUsrDic->cMethodKeySize) + 256;

    dwFileSize = GetFileSize(hIsvUsrDicFile, (LPDWORD)NULL);
#if 0       // temp code
    dwSize = dwFileSize;
#endif

    if (dwSize != dwFileSize) {
        LoadString(hAppInst, IDS_FILESIZE_TITLE, szTitle, iTitle);
        LoadString(hAppInst, IDS_FILESIZE_MSG, szMessage, iMessage);

        MessageBox(hWnd, szMessage, szTitle, MB_OK);
    } else if (lpIsvUsrDic->uHeaderSize != 256) {
        LoadString(hAppInst, IDS_HEADERSIZE_TITLE, szTitle, iTitle);
        LoadString(hAppInst, IDS_HEADERSIZE_MSG, szMessage, iMessage);

        MessageBox(hWnd, szMessage, szTitle, MB_OK);
    } else if (lpIsvUsrDic->uInfoSize != 13) {
        LoadString(hAppInst, IDS_INFOSIZE_TITLE, szTitle, iTitle);
        LoadString(hAppInst, IDS_INFOSIZE_MSG, szMessage, iMessage);

        MessageBox(hWnd, szMessage, szTitle, MB_OK);
    } else if (CodePageInfo(lpIsvUsrDic->idCP) == -1) {
        LoadString(hAppInst, IDS_CODEPAGE_TITLE, szTitle, iTitle);
        LoadString(hAppInst, IDS_CODEPAGE_MSG, szMessage, iMessage);

        MessageBox(hWnd, szMessage, szTitle, MB_OK);
    } else if (*(LPUNADWORD)lpIsvUsrDic->idUserCharInfoSign != SIGN_CWIN) {
        // != CWIN
        LoadString(hAppInst, IDS_CWINSIGN_TITLE, szTitle, iTitle);
        LoadString(hAppInst, IDS_CWINSIGN_MSG, szMessage, iMessage);

        MessageBox(hWnd, szMessage, szTitle, MB_OK);
    } else if (*(LPUNADWORD)((LPBYTE)lpIsvUsrDic->idUserCharInfoSign +
        sizeof(DWORD)) != SIGN__TBL) {
        // != _TBL
        LoadString(hAppInst, IDS_CWINSIGN_TITLE, szTitle, iTitle);
        LoadString(hAppInst, IDS_CWINSIGN_MSG, szMessage, iMessage);

        MessageBox(hWnd, szMessage, szTitle, MB_OK);
    } else if (!RegisterTable(hWnd, lpIsvUsrDic, dwFileSize, lpIsvUsrDic->idCP)) {
        LoadString(hAppInst, IDS_UNMATCHED_TITLE, szTitle, iTitle);
        LoadString(hAppInst, IDS_UNMATCHED_MSG, szMessage, iMessage);

        MessageBox(hWnd, szMessage, szTitle, MB_OK);
    } else {
        // OK
    }

    UnmapViewOfFile(lpIsvUsrDic);

BatchCloseUsrDic:
    CloseHandle(hIsvUsrDic);

BatchCloseUsrDicFile:
    CloseHandle(hIsvUsrDicFile);

    return;
}

/************************************************************/
/*  WndProc()                                               */
/************************************************************/
LRESULT CALLBACK WndProc(       // this is the window procedure of
                                // EUDC editor
    HWND   hWnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
#ifdef UNICODE
    static UINT uCode = 0xE000;
#else
    static UINT uCode = 0xFA40;
#endif

    switch (uMsg) {
    case WM_COMMAND:
        switch (wParam) {
        case IDM_NEW_EUDC:
            uCode++;
            break;
        case IDM_IME_LINK:
            ImeLink(hWnd, uCode);
            break;
        case IDM_BATCH_IME_LINK:
            BatchImeLink(hWnd);
            break;
        default:
            break;
        }
        break;
    case WM_DESTROY:
        PostQuitMessage(0);
        return (0L);
    default:
        return DefWindowProc(hWnd, uMsg, wParam, lParam);
    }

    return (0L);
}

/************************************************************/
/*  WinMain()                                               */
/************************************************************/
int WINAPI WinMain(
    HINSTANCE hInst,
    HINSTANCE hPrevInst,
    LPSTR     lpszCmdLine,
    int       nCmdShow)
{
    WNDCLASS wcClass;
    HWND     hWnd;
    MSG      sMsg;

    hAppInst = hInst;

    wcClass.style = CS_HREDRAW|CS_VREDRAW;
    wcClass.lpfnWndProc = WndProc;
    wcClass.cbClsExtra = 0;
    wcClass.cbWndExtra = 0;
    wcClass.hInstance = hAppInst;
    wcClass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wcClass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wcClass.hbrBackground = GetStockObject(LTGRAY_BRUSH);
    wcClass.lpszMenuName = szMenuName;
    wcClass.lpszClassName = szAppName;
    RegisterClass(&wcClass);

    hWnd = CreateWindowEx(WS_EX_WINDOWEDGE,
        szAppName,
        TEXT("Fake EUDC Editor"),
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT,
        CW_USEDEFAULT, CW_USEDEFAULT,
        NULL, NULL, hAppInst, NULL);

    ShowWindow(hWnd, SW_SHOWDEFAULT);
    UpdateWindow(hWnd);

    if (!hWnd) {
        return (0);
    }

    while (GetMessage(&sMsg, NULL, 0, 0)) {
        TranslateMessage(&sMsg);
        DispatchMessage(&sMsg);
    }

    return ((int) sMsg.wParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\ddk\jpn\cmncopy.inc ===
#To be included into a|w\makefile.inc
copyfile: $(TARGET)
        copy fakeime*.inf $(**D)
        copy fakeime*.dic $(**D)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\ddk\inc\indicml.h ===
/**********************************************************************/
/*      INDICML.H - Indicator Service Manager definitions             */
/*                                                                    */
/*      Copyright (c) 1993-1997  Microsoft Corporation                */
/**********************************************************************/

#ifndef _INDICML_
#define _INDICML_        // defined if INDICML.H has been included

#ifdef __cplusplus
extern "C" {
#endif

//---------------------------------------------------------------------
//
// The messages for Indicator Window.
//
//---------------------------------------------------------------------
#define INDICM_SETIMEICON                 (WM_USER+100)
#define INDICM_SETIMETOOLTIPS             (WM_USER+101)
#define INDICM_REMOVEDEFAULTMENUITEMS     (WM_USER+102)

//---------------------------------------------------------------------
//
// The wParam for INDICM_REMOVEDEFAULTMEUITEMS
//
//---------------------------------------------------------------------
#define RDMI_LEFT         0x0001
#define RDMI_RIGHT        0x0002

//---------------------------------------------------------------------
//
// INDICATOR_WND will be used by the IME to find indicator window.
// IME should call FindWindow(INDICATOR_WND) to get it.
//
//---------------------------------------------------------------------
#ifdef _WIN32

#define INDICATOR_CLASSW         L"Indicator"
#define INDICATOR_CLASSA         "Indicator"

#ifdef UNICODE
#define INDICATOR_CLASS          INDICATOR_CLASSW
#else
#define INDICATOR_CLASS          INDICATOR_CLASSA
#endif

#else
#define INDICATOR_CLASS          "Indicator"
#endif

#ifdef __cplusplus
}
#endif

#endif  // _INDICML_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\ddk\jpn\cmnsrc.inc ===
TARGETPATH=obj
TARGETTYPE=DYNLINK
TARGETEXT=ime
UMTYPE=windows
DLLENTRY=DLLEntry
DLLBASE=0x00500000

C_DEFINES=-DWINVER=0x40A

!if "$(DDKBUILDENV)" == "checked"
C_DEFINES=$(C_DEFINES) -DDEBUG=1
USE_MSVCRT=1
!endif

NO_NTDLL=1

INCLUDES=..; \
         $(BASEDIR)\src\ime\inc;

SOURCES= \
        ..\config.c \
        ..\data.c \
        ..\dic.c \
        ..\dic2.c \
        ..\fakeime.c \
        ..\fdebug.c \
        ..\imm.c \
        ..\immsec.c \
        ..\input.c \
        ..\process.c \
        ..\regword.c \
        ../subs.c \
        ../toascii.c \
        ../ui.c \
        ../uicand.c \
        ../uicomp.c \
        ../uiguide.c \
        ../uistate.c \

TARGETLIBS= \
        $(DDK_LIB_PATH)\advapi32.lib \
        $(DDK_LIB_PATH)\comctl32.lib \
        $(DDK_LIB_PATH)\gdi32.lib \
        $(DDK_LIB_PATH)\imm32.lib \
        $(DDK_LIB_PATH)\kernel32.lib \
        $(DDK_LIB_PATH)\user32.lib

NTTARGETFILES=copyfile
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\ddk\jpn\data.c ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation, All Rights Reserved

Module Name:

    DATA.C
    
++*/

#include "windows.h"
#include "immdev.h"
#define _NO_EXTERN_
#include "fakeime.h"
#include "resource.h"

HINSTANCE   hInst;
HANDLE      hMutex = NULL;
HKL hMyKL = 0;

/* for Translat */
LPTRANSMSGLIST lpCurTransKey= NULL;
UINT    uNumTransKey;
BOOL    fOverTransKey = FALSE;

/* for UI */
#ifdef FAKEIMEM
WCHAR   wszUIClassName[]     = L"FAKEIMEMUI";
char    szUIClassName[]      = "FAKEIMEMUI";
char    szCompStrClassName[] = "FAKEIMEMCompStr";
char    szCandClassName[]    = "FAKEIMEMCand";
char    szStatusClassName[]  = "FAKEIMEMStatus";
char    szGuideClassName[]   = "FAKEIMEMGuide";
#elif defined(UNICODE)
TCHAR    szUIClassName[]      = TEXT("FAKEIMEUUI");
TCHAR    szCompStrClassName[] = TEXT("FAKEIMEUCompStr");
TCHAR    szCandClassName[]    = TEXT("FAKEIMEUCand");
TCHAR    szStatusClassName[]  = TEXT("FAKEIMEUStatus");
TCHAR    szGuideClassName[]   = TEXT("FAKEIMEUGuide");
#else
char    szUIClassName[]      = "FAKEIMEUI";
char    szCompStrClassName[] = "FAKEIMECompStr";
char    szCandClassName[]    = "FAKEIMECand";
char    szStatusClassName[]  = "FAKEIMEStatus";
char    szGuideClassName[]   = "FAKEIMEGuide";
#endif


MYGUIDELINE glTable[] = {
        {GL_LEVEL_ERROR,   GL_ID_NODICTIONARY, IDS_GL_NODICTIONARY, 0},
        {GL_LEVEL_WARNING, GL_ID_TYPINGERROR,  IDS_GL_TYPINGERROR, 0},
        {GL_LEVEL_WARNING, GL_ID_PRIVATE_FIRST,IDS_GL_TESTGUIDELINESTR, IDS_GL_TESTGUIDELINEPRIVATE}
        };

/* for DIC */
TCHAR    szDicFileName[256];         /* Dictionary file name stored buffer */



#ifdef DEBUG
/* for DebugOptions */
#pragma data_seg("SHAREDDATA")
DWORD dwLogFlag = 0L;
DWORD dwDebugFlag = 0L;
#pragma data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\ddk\jpn\config.c ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation, All Rights Reserved

Module Name:

    CONFIG.c
    
++*/
#include "windows.h"
#include "immdev.h"
#include "fakeime.h"
#include "prsht.h"
#include "resource.h"

#define MAX_PAGES 5

/**********************************************************************/
/*                                                                    */
/*      AddPage()                                                     */
/*                                                                    */
/**********************************************************************/
void PASCAL AddPage(LPPROPSHEETHEADER ppsh, UINT id, DLGPROC pfn)
{
    if (ppsh->nPages < MAX_PAGES) {
        PROPSHEETPAGE psp;

        psp.dwSize = sizeof(psp);
        psp.dwFlags = PSP_DEFAULT;
        psp.hInstance = hInst;
        psp.pszTemplate = MAKEINTRESOURCE(id);
        psp.pfnDlgProc = pfn;
        psp.lParam = 0;

        ppsh->phpage[ppsh->nPages] = CreatePropertySheetPage(&psp);
        if (ppsh->phpage[ppsh->nPages])
             ppsh->nPages++;
    }
}  

/**********************************************************************/
/*                                                                    */
/*      ImeConfigure()                                                */
/*                                                                    */
/**********************************************************************/
BOOL WINAPI ImeConfigure(HKL hKL,HWND hWnd, DWORD dwMode, LPVOID lpData)
{
    HPROPSHEETPAGE rPages[MAX_PAGES];
    PROPSHEETHEADER psh;

    ImeLog(LOGF_API, TEXT("ImeConfigure"));

    psh.dwSize = sizeof(psh);
    psh.dwFlags = PSH_PROPTITLE;
    psh.hwndParent = hWnd;
    psh.hInstance = hInst;
    psh.pszCaption = MAKEINTRESOURCE(IDS_CONFIGNAME);
    psh.nPages = 0;
    psh.nStartPage = 0;
    psh.phpage = rPages;

    
    switch (dwMode)
    {
        case IME_CONFIG_GENERAL:
            AddPage(&psh, DLG_GENERAL, GeneralDlgProc);
            AddPage(&psh, DLG_REGISTERWORD, RegWordDlgProc);
            AddPage(&psh, DLG_SELECTDICTIONARY, SelectDictionaryDlgProc);
            AddPage(&psh, DLG_ABOUT, AboutDlgProc);
#ifdef DEBUG
            AddPage(&psh, DLG_DEBUG, DebugOptionDlgProc);
#endif
            PropertySheet(&psh);
            break;

        case IME_CONFIG_REGISTERWORD:
            AddPage(&psh, DLG_REGISTERWORD, RegWordDlgProc);
            AddPage(&psh, DLG_ABOUT, AboutDlgProc);
            PropertySheet(&psh);
            break;

        case IME_CONFIG_SELECTDICTIONARY:
            AddPage(&psh, DLG_SELECTDICTIONARY, SelectDictionaryDlgProc);
            AddPage(&psh, DLG_ABOUT, AboutDlgProc);
            PropertySheet(&psh);
            break;

        default:
            break;
    }

    return TRUE;
}

/**********************************************************************/
/*                                                                    */
/*      RegWordConfigure()                                            */
/*                                                                    */
/**********************************************************************/
INT_PTR CALLBACK RegWordDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam)
{
    NMHDR FAR *lpnm;
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE)(GetWindowLongPtr(hDlg, DWLP_USER));
    UINT nItem;
    UINT i;
    LRESULT dwIndex;
    TCHAR szRead[128];
    TCHAR szString[128];
    TCHAR szBuf[128];
    LRESULT dwStyle;

    switch(message)
    {
        case WM_NOTIFY:
            lpnm = (NMHDR FAR *)lParam;
            switch(lpnm->code)
            {
                case PSN_SETACTIVE:
                    break;
        
                case PSN_KILLACTIVE:
                    break;
        
                case PSN_APPLY:

                    if (!GetDlgItemText(hDlg, ID_WR_READING, szRead, sizeof(szRead)))
                    {
                        LoadString(hInst,IDS_NOREADING,szBuf,sizeof(szBuf));
                        MessageBox(hDlg, szBuf, NULL, MB_OK);
                        return FALSE;
                    }


                    if (!GetDlgItemText(hDlg, ID_WR_STRING, szString, sizeof(szString)))
                    {
                        LoadString(hInst,IDS_NOSTRING,szBuf,sizeof(szBuf));
                        MessageBox(hDlg, szBuf, NULL, MB_OK);
                        return FALSE;
                    }

                    dwIndex = SendDlgItemMessage(hDlg, ID_WR_STYLE,CB_GETCURSEL,0,0);
                    dwStyle = SendDlgItemMessage(hDlg, ID_WR_STYLE,CB_GETITEMDATA,dwIndex,0);

                    if (!ImeRegisterWord(szRead, (DWORD) dwStyle, szString))
                    {
                        LoadString(hInst,IDS_REGWORDRET,szBuf,sizeof(szBuf));
                        MessageBox(hDlg, szBuf, NULL, MB_OK);
                    }
                    break;

                case PSN_RESET:
                    break;

                case PSN_HELP:
                    break;

                default:
                    return FALSE;
            }
            break;

        case WM_INITDIALOG:
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)lParam);
            lpPropSheet = (LPPROPSHEETPAGE)lParam;

            if (nItem = ImeGetRegisterWordStyle(0, NULL))
            {
                LPSTYLEBUF lpStyleBuf = (LPSTYLEBUF)GlobalAlloc(GPTR,nItem * sizeof(STYLEBUF));

                if (!lpStyleBuf)
                {
                    LoadString(hInst,IDS_NOMEMORY,szBuf,sizeof(szBuf));
                    MessageBox(hDlg, szBuf, NULL, MB_OK);
                    return TRUE;
                }

                ImeGetRegisterWordStyle(nItem,lpStyleBuf);

                for (i = 0; i < nItem; i++)
                {
                    dwIndex = SendDlgItemMessage(hDlg,ID_WR_STYLE,CB_ADDSTRING,0,(LPARAM)lpStyleBuf->szDescription);
                    SendDlgItemMessage(hDlg,ID_WR_STYLE,CB_SETITEMDATA,dwIndex,lpStyleBuf->dwStyle);
                    lpStyleBuf++;
                }

                GlobalFree((HANDLE)lpStyleBuf);
            }
            break;

        case WM_DESTROY:
            break;

        case WM_HELP:
            break;

        case WM_CONTEXTMENU:   // right mouse click
            break;

        case WM_COMMAND:
            break;

        default:
            return FALSE;

    }
    return TRUE;
} 


/**********************************************************************/
/*                                                                    */
/*      SelectDictionaryConfigure()                                   */
/*                                                                    */
/**********************************************************************/
INT_PTR CALLBACK SelectDictionaryDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam)
{
    NMHDR FAR *lpnm;
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE)(GetWindowLongPtr(hDlg, DWLP_USER));

    switch(message)
    {
        case WM_NOTIFY:
            lpnm = (NMHDR FAR *)lParam;
            switch(lpnm->code)
            {
                case PSN_SETACTIVE:
                    break;
        
                case PSN_KILLACTIVE:
                    break;
        
                case PSN_APPLY:
                    break;

                case PSN_RESET:
                    break;

                case PSN_HELP:
                    break;

                default:
                    return FALSE;
            }
            break;

        case WM_INITDIALOG:
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)lParam);
            lpPropSheet = (LPPROPSHEETPAGE)lParam;
            break;

        case WM_DESTROY:
            break;

        case WM_HELP:
            break;

        case WM_CONTEXTMENU:   // right mouse click
            break;

        case WM_COMMAND:
            break;

        default:
            return FALSE;

    }
    return TRUE;
} 


/**********************************************************************/
/*                                                                    */
/*      AboutConfigure()                                            */
/*                                                                    */
/**********************************************************************/
INT_PTR CALLBACK AboutDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam)
{
    NMHDR FAR *lpnm;
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE)(GetWindowLongPtr(hDlg, DWLP_USER));

    switch(message)
    {
        case WM_NOTIFY:
            lpnm = (NMHDR FAR *)lParam;
            switch(lpnm->code)
            {
                case PSN_SETACTIVE:
                    break;
        
                case PSN_KILLACTIVE:
                    break;
        
                case PSN_APPLY:
                    break;

                case PSN_RESET:
                    break;

                case PSN_HELP:
                    break;

                default:
                    return FALSE;
            }
            break;

        case WM_INITDIALOG:
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR) lParam);
            lpPropSheet = (LPPROPSHEETPAGE)lParam;
            break;

        case WM_DESTROY:
            break;

        case WM_HELP:
            break;

        case WM_CONTEXTMENU:   // right mouse click
            break;

        case WM_COMMAND:
            break;

        default:
            return FALSE;

    }
    return TRUE;
} 


/**********************************************************************/
/*                                                                    */
/*      GeneralConfigure()                                            */
/*                                                                    */
/**********************************************************************/
INT_PTR CALLBACK GeneralDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam)
{
    NMHDR FAR *lpnm;
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE)(GetWindowLongPtr(hDlg, DWLP_USER));

    switch(message)
    {
        case WM_NOTIFY:
            lpnm = (NMHDR FAR *)lParam;
            switch(lpnm->code)
            {
                case PSN_SETACTIVE:
                    break;
        
                case PSN_KILLACTIVE:
                    break;
        
                case PSN_APPLY:
                    break;

                case PSN_RESET:
                    break;

                case PSN_HELP:
                    break;

                default:
                    return FALSE;
            }
            break;

        case WM_INITDIALOG:
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)lParam);
            lpPropSheet = (LPPROPSHEETPAGE)lParam;
            break;

        case WM_DESTROY:
            break;

        case WM_HELP:
            break;

        case WM_CONTEXTMENU:   // right mouse click
            break;

        case WM_COMMAND:
            break;

        default:
            return FALSE;

    }
    return TRUE;
} 

/**********************************************************************/
/*                                                                    */
/*      DebugOptionDlgProc()                                          */
/*                                                                    */
/**********************************************************************/
INT_PTR CALLBACK DebugOptionDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam)
{
    DWORD dwTemp;
    TCHAR szBuf[128];
    NMHDR FAR *lpnm;
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE)(GetWindowLongPtr(hDlg, DWLP_USER));

    switch(message)
    {
        case WM_NOTIFY:
            lpnm = (NMHDR FAR *)lParam;
            switch(lpnm->code)
            {
                case PSN_SETACTIVE:
                    break;
        
                case PSN_KILLACTIVE:
                    break;
        
                case PSN_APPLY:
#ifdef DEBUG
                    dwTemp = 0;
                    if (IsDlgButtonChecked(hDlg, IDC_LOGF_ENTRY))
                        dwTemp |= LOGF_ENTRY;
                    if (IsDlgButtonChecked(hDlg, IDC_LOGF_API))
                        dwTemp |= LOGF_API;
                    if (IsDlgButtonChecked(hDlg, IDC_LOGF_KEY))
                        dwTemp |= LOGF_KEY;
                    dwLogFlag = dwTemp;

                    dwTemp = 0;
                    if (IsDlgButtonChecked(hDlg, IDC_DEBF_THREADID))
                        dwTemp |= DEBF_THREADID;
                    if (IsDlgButtonChecked(hDlg, IDC_DEBF_GUIDELINE))
                        dwTemp |= DEBF_GUIDELINE;
                    dwDebugFlag = dwTemp;

                    SetDwordToSetting(TEXT("LogFlag"), dwLogFlag);
                    SetDwordToSetting(TEXT("DebugFlag"), dwDebugFlag);
#endif

                    break;

                case PSN_RESET:
                    break;

                case PSN_HELP:
                    break;

                default:
                    return FALSE;
            }
            break;

        case WM_INITDIALOG:
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR) lParam);
            lpPropSheet = (LPPROPSHEETPAGE)lParam;

#ifdef DEBUG
            CheckDlgButton(hDlg, IDC_LOGF_ENTRY, 
                                (dwLogFlag & LOGF_ENTRY) ? 1 : 0);
            CheckDlgButton(hDlg, IDC_LOGF_API, 
                                (dwLogFlag & LOGF_API) ? 1 : 0);
            CheckDlgButton(hDlg, IDC_LOGF_KEY, 
                                (dwLogFlag & LOGF_KEY) ? 1 : 0);
            
            CheckDlgButton(hDlg, IDC_DEBF_THREADID, 
                                (dwDebugFlag & DEBF_THREADID) ? 1 : 0);
            CheckDlgButton(hDlg, IDC_DEBF_GUIDELINE, 
                                (dwDebugFlag & DEBF_GUIDELINE) ? 1 : 0);
            
#endif
            break;

        case WM_DESTROY:
            break;

        case WM_HELP:
            break;

        case WM_CONTEXTMENU:   // right mouse click
            break;

        case WM_COMMAND:
            break;

        default:
            return FALSE;

    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\ddk\jpn\dic.c ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation, All Rights Reserved

Module Name:

    DIC.C
    
++*/
#include <windows.h>
#include <immdev.h>
#include "fakeime.h"
#include "vksub.h"
#include "immsec.h"

#if defined(FAKEIMEM) || defined(UNICODE)
int GetCandidateStringsFromDictionary(LPWSTR lpString, LPWSTR lpBuf, DWORD dwBufLen, LPTSTR szDicFileName);
#endif

BOOL GetAnsiPathName(LPCWSTR lpszUniPath,LPSTR lpszAnsiPath,UINT nMaxLen)
{
    if (WideCharToMultiByte(CP_ACP,
                            WC_COMPOSITECHECK,
                            lpszUniPath,
                            -1,
                            lpszAnsiPath,
                            nMaxLen,
                            NULL,
                            NULL) != 0) {
        return TRUE;
    }
    else {
        return FALSE;
    }

}


/**********************************************************************/
/*                                                                    */
/* FlushText()                                                        */
/*                                                                    */
/**********************************************************************/
void PASCAL FlushText(HIMC hIMC)
{
    LPINPUTCONTEXT lpIMC;
    LPCOMPOSITIONSTRING lpCompStr;
    LPCANDIDATEINFO lpCandInfo;
    TRANSMSG GnMsg;

    if (!IsCompStr(hIMC))
        return;

    if (!(lpIMC = ImmLockIMC(hIMC)))
        return;

    if (IsCandidate(lpIMC))
    {
        //
        // Flush candidate lists.
        //
        lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo);
        ClearCandidate(lpCandInfo);
        ImmUnlockIMCC(lpIMC->hCandInfo);
        GnMsg.message = WM_IME_NOTIFY;
        GnMsg.wParam = IMN_CLOSECANDIDATE;
        GnMsg.lParam = 1;
        GenerateMessage(hIMC, lpIMC, lpCurTransKey,(LPTRANSMSG)&GnMsg);
    }

    if (lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr))
    {
        //
        // Flush composition strings.
        //
        ClearCompStr(lpCompStr,CLR_RESULT_AND_UNDET);
        ImmUnlockIMCC(lpIMC->hCompStr);

        GnMsg.message = WM_IME_COMPOSITION;
        GnMsg.wParam = 0;
        GnMsg.lParam = 0;
        GenerateMessage(hIMC, lpIMC, lpCurTransKey,(LPTRANSMSG)&GnMsg);

        GnMsg.message = WM_IME_ENDCOMPOSITION;
        GnMsg.wParam = 0;
        GnMsg.lParam = 0;
        GenerateMessage(hIMC, lpIMC, lpCurTransKey,(LPTRANSMSG)&GnMsg);
    }
    ImmUnlockIMC(hIMC);
}

/**********************************************************************/
/*                                                                    */
/* RevertText()                                                       */
/*                                                                    */
/**********************************************************************/
void PASCAL RevertText(HIMC hIMC)
{
    LPINPUTCONTEXT lpIMC;
    LPCOMPOSITIONSTRING lpCompStr;
    LPCANDIDATEINFO lpCandInfo;
    TRANSMSG GnMsg;
    LPMYSTR lpread,lpstr;

    if (!IsCompStr(hIMC))
        return;

    if (!(lpIMC = ImmLockIMC(hIMC)))
        return;

    if (IsCandidate(lpIMC))
    {
        //
        // Flush candidate lists.
        //
        lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo);
        ClearCandidate(lpCandInfo);
        ImmUnlockIMCC(lpIMC->hCandInfo);
        GnMsg.message = WM_IME_NOTIFY;
        GnMsg.wParam = IMN_CLOSECANDIDATE;
        GnMsg.lParam = 1;
        GenerateMessage(hIMC, lpIMC, lpCurTransKey,(LPTRANSMSG)&GnMsg);
    }

    if (lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr))
    {
        lpstr = GETLPCOMPSTR(lpCompStr);
        lpread = GETLPCOMPREADSTR(lpCompStr);
        lHanToZen(lpstr,lpread,lpIMC->fdwConversion);

        //
        // make attribute
        //
        lpCompStr->dwCursorPos = Mylstrlen(lpstr);
        // DeltaStart is 0 at RevertText time.
        lpCompStr->dwDeltaStart = 0;

        lmemset(GETLPCOMPATTR(lpCompStr),0,Mylstrlen(lpstr));
        lmemset(GETLPCOMPREADATTR(lpCompStr),0,Mylstrlen(lpread));

        SetClause(GETLPCOMPCLAUSE(lpCompStr),Mylstrlen(lpstr));
        SetClause(GETLPCOMPREADCLAUSE(lpCompStr),Mylstrlen(lpread));
        lpCompStr->dwCompClauseLen = 8;
        lpCompStr->dwCompReadClauseLen = 8;

        //
        // make length
        //
        lpCompStr->dwCompStrLen = Mylstrlen(lpstr);
        lpCompStr->dwCompReadStrLen = Mylstrlen(lpread);
        lpCompStr->dwCompAttrLen = Mylstrlen(lpstr);
        lpCompStr->dwCompReadAttrLen = Mylstrlen(lpread);


        //
        // Generate messages.
        //
        GnMsg.message = WM_IME_COMPOSITION;
        GnMsg.wParam = 0;
        GnMsg.lParam = GCS_COMPALL | GCS_CURSORPOS | GCS_DELTASTART;
        GenerateMessage(hIMC, lpIMC, lpCurTransKey,(LPTRANSMSG)&GnMsg);

        ImmUnlockIMCC(lpIMC->hCompStr);
    }
    ImmUnlockIMC(hIMC);
}

/**********************************************************************/
/*                                                                    */
/* ConvKanji()                                                        */
/*                                                                    */
/* VK_KANJI Key handling function                                     */
/*                                                                    */
/**********************************************************************/
BOOL PASCAL ConvKanji(HIMC hIMC)
{
    LPINPUTCONTEXT lpIMC;
    LPCOMPOSITIONSTRING lpCompStr;
    LPCANDIDATEINFO lpCandInfo;
    LPCANDIDATELIST lpCandList;
    MYCHAR szBuf[256+2];
    int nBufLen;
    LPMYSTR lpstr;
    TRANSMSG GnMsg;
    LPBYTE lpb;
    OFSTRUCT ofs;
    LPMYSTR lpT, lpT2;
    int cnt;
    BOOL bRc = FALSE;

    if ((GetFileAttributes(szDicFileName) == 0xFFFFFFFF) ||
        (GetFileAttributes(szDicFileName) == FILE_ATTRIBUTE_DIRECTORY)) {
        MakeGuideLine(hIMC,MYGL_NODICTIONARY);
    }

    if (!IsCompStr(hIMC))
        return FALSE;

    if (!(lpIMC = ImmLockIMC(hIMC)))
        return FALSE;

    if (!(lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr)))
        goto cvk_exit10;

    if (!(lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo)))
        goto cvk_exit20;

    //
    // Since IME handles all string as Unicode, convert the CompReadStr
    // from Unicode into multibyte string. Also the dictionary holdsits data
    // as Hiragana, so map the string from Katakana to Hiragana.
    //
    lpT2 = GETLPCOMPREADSTR(lpCompStr);

    //
    // Get the candidate strings from dic file.
    //
    szBuf[256] = 0;    // Double NULL-terminate
    szBuf[257] = 0;    // Double NULL-terminate
#if defined(FAKEIMEM) || defined(UNICODE)
    nBufLen = GetCandidateStringsFromDictionary(lpT2, szBuf, 256, (LPTSTR)szDicFileName);
#else
    nBufLen = GetPrivateProfileString(lpT2, NULL,(LPSTR)"",
                            (LPSTR)szBuf,256,(LPSTR)szDicFileName );
#endif
    //
    // Check the result of dic. Because my candidate list has only MAXCANDSTRNUM
    // candidate strings.
    //
    lpT = &szBuf[0];
    cnt = 0;
    while(*lpT)
    {
        cnt++;
        lpT += (Mylstrlen(lpT) + 1);

        if (cnt > MAXCANDSTRNUM)
        {
            //
            // The dic is too big....
            //
            goto cvk_exit40;
        }

    }

    lpb = GETLPCOMPATTR(lpCompStr);

    if (nBufLen < 1)
    {
        if (!*lpb)
        {
            //
            // make attribute
            //
            lmemset(GETLPCOMPATTR(lpCompStr),1,
                  Mylstrlen(GETLPCOMPSTR(lpCompStr)));
            lmemset(GETLPCOMPREADATTR(lpCompStr),1,
                  Mylstrlen(GETLPCOMPREADSTR(lpCompStr)));

            GnMsg.message = WM_IME_COMPOSITION;
            GnMsg.wParam = 0;
            GnMsg.lParam = GCS_COMPSTR | GCS_CURSORPOS |
                           GCS_COMPATTR | GCS_COMPREADATTR;
            GenerateMessage(hIMC, lpIMC, lpCurTransKey,(LPTRANSMSG)&GnMsg);
        }

        goto cvk_exit40;
    }


    lpstr = (LPMYSTR)szBuf;
    if (!*lpb)
    {
        //
        // String is not converted yet.
        //
        while (*lpstr)
        {
            if (0 != Mylstrcmp(lpstr,GETLPCOMPSTR(lpCompStr)))
            {
set_compstr:
                //
                // Set the composition string to the structure.
                //
                Mylstrcpy(GETLPCOMPSTR(lpCompStr),lpstr);

                lpstr = GETLPCOMPSTR(lpCompStr);

                //
                // Set the length and cursor position to the structure.
                //
                lpCompStr->dwCompStrLen = Mylstrlen(lpstr);
                lpCompStr->dwCursorPos = 0;
                // Because FAKEIME does not support clause, DeltaStart is 0 anytime.
                lpCompStr->dwDeltaStart = 0;

                //
                // make attribute
                //
                lmemset((LPBYTE)GETLPCOMPATTR(lpCompStr),1, Mylstrlen(lpstr));
                lmemset((LPBYTE)GETLPCOMPREADATTR(lpCompStr),1,
                                      Mylstrlen(GETLPCOMPREADSTR(lpCompStr)));

                //
                // make clause info
                //
                SetClause(GETLPCOMPCLAUSE(lpCompStr),Mylstrlen(lpstr));
                SetClause(GETLPCOMPREADCLAUSE(lpCompStr),Mylstrlen(GETLPCOMPREADSTR(lpCompStr)));
                lpCompStr->dwCompClauseLen = 8;
                lpCompStr->dwCompReadClauseLen = 8;

                //
                // Generate messages.
                //
                GnMsg.message = WM_IME_COMPOSITION;
                GnMsg.wParam = 0;
                GnMsg.lParam = GCS_COMPALL | GCS_CURSORPOS | GCS_DELTASTART;
                GenerateMessage(hIMC, lpIMC, lpCurTransKey,(LPTRANSMSG)&GnMsg);

                bRc = TRUE;
                goto cvk_exit40;
            }
            lpstr += (Mylstrlen(lpstr) + 1);

        }
    }
    else
    {
        //
        // String is converted, so that open candidate.
        //
        int i = 0;
        LPDWORD lpdw;

        //
        // generate WM_IME_NOTFIY IMN_OPENCANDIDATE message.
        //
        if (!IsCandidate(lpIMC))
        {
            GnMsg.message = WM_IME_NOTIFY;
            GnMsg.wParam = IMN_OPENCANDIDATE;
            GnMsg.lParam = 1L;
            GenerateMessage(hIMC, lpIMC, lpCurTransKey,(LPTRANSMSG)&GnMsg);
        }

        //
        // Make candidate structures.
        //
        lpCandInfo->dwSize = sizeof(MYCAND);
        lpCandInfo->dwCount = 1;
        lpCandInfo->dwOffset[0] =
              (DWORD)((LPSTR)&((LPMYCAND)lpCandInfo)->cl - (LPSTR)lpCandInfo);
        lpCandList = (LPCANDIDATELIST)((LPSTR)lpCandInfo  + lpCandInfo->dwOffset[0]);
        lpdw = (LPDWORD)&(lpCandList->dwOffset);
        while (*lpstr)
        {
            lpCandList->dwOffset[i] =
                   (DWORD)((LPSTR)((LPMYCAND)lpCandInfo)->szCand[i] - (LPSTR)lpCandList);
            Mylstrcpy((LPMYSTR)((LPSTR)lpCandList+lpCandList->dwOffset[i]),lpstr);
            lpstr += (Mylstrlen(lpstr) + 1);
            i++;
        }

        lpCandList->dwSize = sizeof(CANDIDATELIST) +
                          (MAXCANDSTRNUM * (sizeof(DWORD) + MAXCANDSTRSIZE));
        lpCandList->dwStyle = IME_CAND_READ;
        lpCandList->dwCount = i;
        if (i < MAXCANDPAGESIZE)
            lpCandList->dwPageSize  = i;
        else
            lpCandList->dwPageSize  = MAXCANDPAGESIZE;

        lpCandList->dwSelection++;
        if (lpCandList->dwSelection == (DWORD)i)
        {
            lpCandList->dwPageStart = 0;
            lpCandList->dwSelection = 0;
        }
        else if (lpCandList->dwSelection >= MAXCANDPAGESIZE)
        {
            if (lpCandList->dwPageStart + MAXCANDPAGESIZE < lpCandList->dwCount)
                 lpCandList->dwPageStart++;
        }

        //
        // Generate messages.
        //
        GnMsg.message = WM_IME_NOTIFY;
        GnMsg.wParam = IMN_CHANGECANDIDATE;
        GnMsg.lParam = 1L;
        GenerateMessage(hIMC, lpIMC, lpCurTransKey,(LPTRANSMSG)&GnMsg);

        //
        // If the selected candidate string is changed, the composition string
        // should be updated.
        //
        lpstr = (LPMYSTR)((LPSTR)lpCandList +
                   lpCandList->dwOffset[lpCandList->dwSelection]);
        goto set_compstr;

    }

cvk_exit40:
    ImmUnlockIMCC(lpIMC->hCandInfo);

cvk_exit20:
    ImmUnlockIMCC(lpIMC->hCompStr);

cvk_exit10:
    ImmUnlockIMC(hIMC);
    return bRc;
}

/**********************************************************************/
/*                                                                    */
/* IsEat( code )                                                      */
/*                                                                    */
/**********************************************************************/
BOOL PASCAL IsEat( code )
register WORD code;
{
#if defined(FAKEIMEM) || defined(UNICODE)
    return TRUE;
#else
    return( (code >= 0x20 && 0x7f >= code) || (code >= 0x0a1 && 0x0df >= code) ? TRUE : FALSE );
#endif
}

/**********************************************************************/
/*                                                                    */
/* DeleteChar()                                                       */
/*                                                                    */
/**********************************************************************/
void PASCAL DeleteChar( HIMC hIMC ,UINT uVKey)
{
    LPINPUTCONTEXT lpIMC;
    LPCOMPOSITIONSTRING lpCompStr;
    LPCANDIDATEINFO lpCandInfo;
    LPMYSTR lpstr;
    LPMYSTR lpread;
    LPMYSTR lpptr;
    int nChar;
    BOOL fDone = FALSE;
    DWORD dwCurPos;
    TRANSMSG GnMsg;


    if (!IsCompStr(hIMC))
        return;

    if (!(lpIMC = ImmLockIMC(hIMC)))
        return;

    lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);

    dwCurPos = lpCompStr->dwCursorPos;
    lpstr = GETLPCOMPSTR(lpCompStr);

    if( uVKey ==  VK_BACK )
    {
        if( dwCurPos == 0 )
            goto dc_exit;

        lpptr = MyCharPrev( lpstr, lpstr+dwCurPos );
#if defined(FAKEIMEM) || defined(UNICODE)
        nChar = 1;
#else
        nChar = IsDBCSLeadByte( *lpptr ) ? 2 : 1;
#endif
        if( lpstr == lpptr && Mylstrlen(lpstr) == nChar )
        {
            dwCurPos = 0;
            *lpstr = MYTEXT('\0');
        }
        else
        {
            Mylstrcpy( lpptr, lpstr+dwCurPos );
            dwCurPos -= nChar;
        }

        fDone = TRUE;
    }
    else if( uVKey == VK_DELETE )
    {
        if( dwCurPos == (DWORD)Mylstrlen(lpstr) )
            goto dc_exit;

#if defined(FAKEIMEM) || defined(UNICODE)
        nChar = 1;
#else
        nChar = IsDBCSLeadByte( *(lpstr+dwCurPos) ) ? 2 : 1;
#endif
        Mylstrcpy( lpstr+dwCurPos, lpstr+dwCurPos+nChar );

        fDone = TRUE;

    }

    if (fDone)
    {
        lpstr = GETLPCOMPSTR(lpCompStr);
        lpread = GETLPCOMPREADSTR(lpCompStr);
        lZenToHan (lpread,lpstr);

        lmemset(GETLPCOMPATTR(lpCompStr),0,Mylstrlen(lpstr));
        lmemset(GETLPCOMPREADATTR(lpCompStr),0,Mylstrlen(lpread));

        //
        // make length
        //
        lpCompStr->dwCompStrLen = Mylstrlen(lpstr);
        lpCompStr->dwCompReadStrLen = Mylstrlen(lpread);
        lpCompStr->dwCompAttrLen = Mylstrlen(lpstr);
        lpCompStr->dwCompReadAttrLen = Mylstrlen(lpread);

        lpCompStr->dwCursorPos = dwCurPos;
        // DeltaStart is same of Cursor Pos at DeleteChar time.
        lpCompStr->dwDeltaStart = dwCurPos;

        //
        // make clause info
        //
        SetClause(GETLPCOMPCLAUSE(lpCompStr),Mylstrlen(lpstr));
        SetClause(GETLPCOMPREADCLAUSE(lpCompStr),Mylstrlen(lpread));
        lpCompStr->dwCompClauseLen = 8;
        lpCompStr->dwCompReadClauseLen = 8;

        if (lpCompStr->dwCompStrLen)
        {
            GnMsg.message = WM_IME_COMPOSITION;
            GnMsg.wParam = 0;
            GnMsg.lParam = GCS_COMPALL | GCS_CURSORPOS | GCS_DELTASTART;
            GenerateMessage(hIMC, lpIMC, lpCurTransKey,(LPTRANSMSG)&GnMsg);
        }
        else
        {
            if (IsCandidate(lpIMC))
            {
                lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo);
                ClearCandidate(lpCandInfo);
                GnMsg.message = WM_IME_NOTIFY;
                GnMsg.wParam = IMN_CLOSECANDIDATE;
                GnMsg.lParam = 1;
                GenerateMessage(hIMC, lpIMC, lpCurTransKey,(LPTRANSMSG)&GnMsg);
                ImmUnlockIMCC(lpIMC->hCandInfo);
            }

            ClearCompStr(lpCompStr,CLR_RESULT_AND_UNDET);

            GnMsg.message = WM_IME_COMPOSITION;
            GnMsg.wParam = 0;
            GnMsg.lParam = 0;
            GenerateMessage(hIMC, lpIMC, lpCurTransKey,(LPTRANSMSG)&GnMsg);

            GnMsg.message = WM_IME_ENDCOMPOSITION;
            GnMsg.wParam = 0;
            GnMsg.lParam = 0;
            GenerateMessage(hIMC, lpIMC, lpCurTransKey,(LPTRANSMSG)&GnMsg);
        }
    }

dc_exit:
    ImmUnlockIMCC(lpIMC->hCompStr);
    ImmUnlockIMC(hIMC);
}


/**********************************************************************/
/*                                                                    */
/* AddChar()                                                          */
/*                                                                    */
/* One character add function                                         */
/*                                                                    */
/**********************************************************************/
void PASCAL AddChar( hIMC, code )
HIMC hIMC;
WORD code;
{
    LPMYSTR lpchText;
    LPMYSTR lpread;
    LPMYSTR lpstr;
    LPMYSTR lpprev;
    WORD code2 = 0;
    WORD code3;
    DWORD fdwConversion;
    LPINPUTCONTEXT lpIMC;
    LPCOMPOSITIONSTRING lpCompStr;
    DWORD dwStrLen;
    DWORD dwSize;
    TRANSMSG GnMsg;
    DWORD dwGCR = 0L;
#if defined(FAKEIMEM) || defined(UNICODE)
    WCHAR Katakana, Sound;
#endif

    lpIMC = ImmLockIMC(hIMC);

    if (ImmGetIMCCSize(lpIMC->hCompStr) < sizeof (MYCOMPSTR))
    {
        // Init time.
        dwSize = sizeof(MYCOMPSTR);
        lpIMC->hCompStr = ImmReSizeIMCC(lpIMC->hCompStr,dwSize);
        lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
        lpCompStr->dwSize = dwSize;
    }
    else
    {
        lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
    }

    dwStrLen = lpCompStr->dwCompStrLen;

    if (!dwStrLen)
    {
        //lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
        InitCompStr(lpCompStr,CLR_RESULT_AND_UNDET);

        GnMsg.message = WM_IME_STARTCOMPOSITION;
        GnMsg.wParam = 0;
        GnMsg.lParam = 0;
        GenerateMessage(hIMC, lpIMC, lpCurTransKey,(LPTRANSMSG)&GnMsg);

    }
    else if (IsConvertedCompStr(hIMC))
    {
        MakeResultString(hIMC,FALSE);
        InitCompStr(lpCompStr,CLR_UNDET);
        dwGCR = GCS_RESULTALL;
    }

    if( IsEat( code ) )
    {
        // Get ConvMode from IMC.
        fdwConversion = lpIMC->fdwConversion;

        lpchText = GETLPCOMPSTR(lpCompStr);
        lpstr = lpchText;
        if( lpCompStr->dwCursorPos )
            lpstr += lpCompStr->dwCursorPos;
        lpstr = lpchText + Mylstrlen(lpchText);
        lpprev = MyCharPrev( lpchText, lpstr );

        if( fdwConversion & IME_CMODE_CHARCODE ) {
            code = (WORD)(LONG_PTR)AnsiUpper( (LPSTR)(LONG_PTR)code );
            if( !( (code >= MYTEXT('0') && code <= MYTEXT('9')) ||
                (code >= MYTEXT('A') && code <= MYTEXT('F')) ) || lpCompStr->dwCursorPos >= 4 ){
                MessageBeep( 0 );
                goto ac_exit;
            }
            *lpstr++ = (BYTE)code;
            lpCompStr->dwCursorPos++;
        }
        else if ( fdwConversion & IME_CMODE_FULLSHAPE )
        {
            if ( fdwConversion & IME_CMODE_ROMAN  &&
                 fdwConversion & IME_CMODE_NATIVE )
            {
#if defined(FAKEIMEM) || defined(UNICODE)
                if (*lpprev) {
                     code2 = *lpprev;
                }
                else
                {
                    if( IsSecond( code ) )
                    {
                        code = ConvChar(hIMC, 0, code );
                        if (!(fdwConversion & IME_CMODE_KATAKANA))
                        {
                            code = KataToHira(code);
                        }
                    }
                    goto DBCS_BETA;
                }

                if (!( code2 = ZenToHan( code2 ) ))
                {
                    if( IsSecond( code ) )
                    {
                        code = ConvChar(hIMC, 0, code );
                        if (!(fdwConversion & IME_CMODE_KATAKANA))
                        {
                            code = KataToHira(code);
                        }
                    }
                    goto DBCS_BETA;
                }

                if ( IsSecond( code ) )
                {
                    if ( IsFirst( code2 ) &&
                       (code3 = ConvChar(hIMC, code2, code )))
                    {
                        if (fdwConversion & IME_CMODE_KATAKANA) 
                        {
                            *lpprev = code3;
                        }
                        else
                        {
                           *lpprev = KataToHira(code3);
                        }
                    }
                    else
                    {
                        code = ConvChar(hIMC, 0, code );

                        if (!(fdwConversion & IME_CMODE_KATAKANA))
                        {
                            code = KataToHira(code);
                        }
                        goto DBCS_BETA;
                    }
                }
                else if( (WORD)(LONG_PTR)CharUpperW( (LPMYSTR)(LONG_PTR)code ) == 'N'
                      && (WORD)(LONG_PTR)CharUpperW( (LPMYSTR)(LONG_PTR)code2 ) == 'N' )
                {
                    code3 = 0xFF9D;
                    code2 = HanToZen( code3, 0,fdwConversion);
                    *lpprev = code2;
                }
                else
                    goto DBCS_BETA;
#else
                if ( IsDBCSLeadByte( *lpprev ) )
                    code2 = MAKEWORD( *(lpprev+1), *lpprev );
                else
                {
                    if ( IsSecond( code ) )
                        code = ConvChar(hIMC, 0, code );
                    goto DBCS_BETA;
                }

                if (!( code2 = ZenToHan( code2 ) ))
                {
                    if( IsSecond( code ) )
                        code = ConvChar(hIMC, 0, code );
                    goto DBCS_BETA;
                }

                if ( IsSecond( code ) )
                {
                    if ( IsFirst( code2 ) &&
                       (code3 = ConvChar(hIMC, code2, code )))
                    {
                        code2 = HanToZen( code3, fdwConversion);
                        *lpprev++ = HIBYTE( code2 );
                        *lpprev = LOBYTE( code2 );
                    }
                    else
                    {
                        code = ConvChar(hIMC, 0, code );
                        goto DBCS_BETA;
                    }
                }
                else if( (WORD)(LONG_PTR)AnsiUpper( (LPSTR)(LONG_PTR)code ) == 'N'
                      && (WORD)(LONG_PTR)AnsiUpper( (LPSTR)(LONG_PTR)code2 ) == 'N' )
                {
                    code3 = 0xdd;
                    code2 = HanToZen( code3, fdwConversion);
                    *lpprev++ = HIBYTE( code2 );
                    *lpprev = LOBYTE( code2 );
                } else {
                    //if (!IsFirst( code ))
                    //    MakeGuideLine(hIMC,MYGL_TYPINGERROR);
                    goto DBCS_BETA;
                }
#endif
            }
            else
            {
DBCS_BETA:
                if( code == MYTEXT('^') )
                {
#if defined(FAKEIMEM) || defined(UNICODE)
                    code2 = *lpprev;
#else
                    code2 = MAKEWORD( *(lpprev+1), *lpprev );
#endif
                    if( IsTenten( code2 ) == FALSE )
                        goto DBCS_BETA2;
                    code2 = ConvTenten( code2 );
#if defined(FAKEIMEM) || defined(UNICODE)
                    *lpprev++ = code2;
#else
                    if( HIBYTE( code2 ) )
                        *lpprev++ = HIBYTE( code2 );
                    *lpprev++ = LOBYTE( code2 );
#endif
                }
                else if( code == MYTEXT('_') )
                {
#if defined(FAKEIMEM) || defined(UNICODE)
                    code2 = *lpprev;
#else
                    code2 = MAKEWORD( *(lpprev+1), *lpprev );
#endif
                    if( IsMaru( code2 ) == FALSE )
                        goto DBCS_BETA2;
                    code2 = ConvMaru( code2 );
#if defined(FAKEIMEM) || defined(UNICODE)
                    *lpprev = code2;
#else
                    if( HIBYTE( code2 ) )
                        *lpprev++ = HIBYTE( code2 );
                    *lpprev = LOBYTE( code2 );
#endif
                }
                else
                {
#if defined(FAKEIMEM) || defined(UNICODE)
                    code = HanToZen(code,0,fdwConversion);
#endif
DBCS_BETA2:
#if defined(FAKEIMEM) || defined(UNICODE)
                    *lpstr++ = code;
                    lpCompStr->dwCursorPos += 1;
#else
                    code2 = HanToZen( code,fdwConversion);
                    if( HIBYTE( code2 ) )
                        *lpstr++ = HIBYTE( code2 );
                    *lpstr++ = LOBYTE( code2 );
                    lpCompStr->dwCursorPos += 2;
#endif
                }
            }
        }
        else
        {
            if (fdwConversion & IME_CMODE_ROMAN  &&
                 fdwConversion & IME_CMODE_NATIVE )
            {

                if (IsSecond( code ))
                {
                    if (IsFirst( *lpprev ) &&
                       (code2 = ConvChar(hIMC,*lpprev,code)))
                    {
#if defined(FAKEIMEM) || defined(UNICODE)
                        if (OneCharZenToHan(code2,&Katakana, &Sound))
                        {
                            *lpprev = Katakana;
                            if (Sound) {
                                *lpstr++ = Sound;
                                lpCompStr->dwCursorPos++;
                            }
                        } 
                        else 
                        {
                            code = ConvChar(hIMC, 0, code );
                            goto SBCS_BETA;
                        }
#else
                        /* half size ' ' matching code */
                        if (HIBYTE(code2))
                        {
                            *lpprev = HIBYTE( code2 );
                            *lpstr++ = LOBYTE( code2 );
                            lpCompStr->dwCursorPos++;
                        }
                        else
                            *lpprev = (BYTE)code2;
#endif
                    }
                    else
                    {
                        code = ConvChar(hIMC, 0, code );
                        //MakeGuideLine(hIMC,MYGL_TYPINGERROR);
                        goto SBCS_BETA;
                    }
                }
                else
                {
#if defined(FAKEIMEM) || defined(UNICODE)
                    if( (WORD)(LONG_PTR)CharUpperW( (LPMYSTR)(LONG_PTR)code ) == 'N'
                      && (WORD)(LONG_PTR)CharUpperW( (LPMYSTR)(LONG_PTR)(code2 = *lpprev ) ) == 'N' )
                    {
                        *lpprev = (MYCHAR) 0xFF9D;
                    }
#else
                    if( (WORD)(LONG_PTR)AnsiUpper( (LPSTR)(LONG_PTR)code ) == 'N'
                     && (WORD)(LONG_PTR)AnsiUpper((LPSTR)(LONG_PTR)(code2 = *lpprev ) ) == 'N' )
                        *lpprev = (unsigned char)0xdd;
#endif
                    else
                    {
                         //MakeGuideLine(hIMC,MYGL_TYPINGERROR);
                         goto SBCS_BETA;
                    }
                }
            }
            else
            {
SBCS_BETA:
#if defined(FAKEIMEM) || defined(UNICODE)
                if (OneCharZenToHan(code,&Katakana,&Sound)) 
                {
                    *lpstr++ = Katakana;
                    if (Sound) 
                    {
                        *lpstr++ = Sound;
                        lpCompStr->dwCursorPos++;
                    }
                }
                else
                {
                    *lpstr++ = code;
                }
#else
                *lpstr++ = (BYTE)code;
#endif
                lpCompStr->dwCursorPos++;
            }
        }
        *lpstr = MYTEXT('\0');
    }

    // make reading string.
    lpstr = GETLPCOMPSTR(lpCompStr);
    lpread = GETLPCOMPREADSTR(lpCompStr);
#if defined(FAKEIMEM) || defined(UNICODE)
    if (fdwConversion & IME_CMODE_KATAKANA) 
    {
        if (fdwConversion & IME_CMODE_FULLSHAPE)
        {
            Mylstrcpy(lpread,lpstr);
        }
        else 
        {
            lHanToZen(lpread,lpstr,fdwConversion);
        }
    }
    else
    {
        LPMYSTR pSrc = lpstr;
        LPMYSTR pDst = lpread;

        for (; *pSrc;) {
            *pDst++ = HiraToKata(*pSrc);
            pSrc++;
        }
        *pDst = (MYCHAR) 0;
    }

#else
    lZenToHan (lpread,lpstr);
#endif

    // make attribute
    lpCompStr->dwCursorPos = Mylstrlen(lpstr);
    lpCompStr->dwDeltaStart = (DWORD)(MyCharPrev(lpstr, lpstr+Mylstrlen(lpstr)) - lpstr);

    //MakeAttrClause(lpCompStr);
    lmemset((LPBYTE)GETLPCOMPATTR(lpCompStr),0, Mylstrlen(lpstr));
    lmemset((LPBYTE)GETLPCOMPREADATTR(lpCompStr),0, Mylstrlen(lpread));

    // make length
    lpCompStr->dwCompStrLen = Mylstrlen(lpstr);
    lpCompStr->dwCompReadStrLen = Mylstrlen(lpread);
    lpCompStr->dwCompAttrLen = Mylstrlen(lpstr);
    lpCompStr->dwCompReadAttrLen = Mylstrlen(lpread);

    //
    // make clause info
    //
    SetClause(GETLPCOMPCLAUSE(lpCompStr),Mylstrlen(lpstr));
    SetClause(GETLPCOMPREADCLAUSE(lpCompStr),Mylstrlen(lpread));
    lpCompStr->dwCompClauseLen = 8;
    lpCompStr->dwCompReadClauseLen = 8;

    GnMsg.message = WM_IME_COMPOSITION;
    GnMsg.wParam = 0;
    GnMsg.lParam = GCS_COMPALL | GCS_CURSORPOS | GCS_DELTASTART | dwGCR;
    GenerateMessage(hIMC, lpIMC, lpCurTransKey,(LPTRANSMSG)&GnMsg);

ac_exit:
    ImmUnlockIMCC(lpIMC->hCompStr);
    ImmUnlockIMC(hIMC);
}


/**********************************************************************/
/*                                                                    */
/* DicKeydownHandler()                                                */
/*                                                                    */
/* WM_KEYDOWN handler for dictionary routine                          */
/*                                                                    */
/* wParam                                                             */
/* virtual key                                                        */
/*                                                                    */
/* lParam                                                             */
/* differ depending on wParam                                         */
/*                                                                    */
/**********************************************************************/
BOOL PASCAL DicKeydownHandler( hIMC, wParam, lParam ,lpbKeyState)
HIMC hIMC;
UINT wParam;
LPARAM lParam;
LPBYTE lpbKeyState;
{
    LPINPUTCONTEXT lpIMC;

    switch( wParam )
    {
        case VK_ESCAPE:
            FlushText(hIMC);
            break;

        case VK_DELETE:
        case VK_BACK:
            DeleteChar(hIMC,wParam);
            break;

        case VK_SPACE:
            ConvKanji(hIMC);
            break;

        case VK_F3:
            if (IsCTLPushed(lpbKeyState))
                ChangeMode(hIMC,TO_CMODE_ROMAN);
            break;

        case VK_F6:
            if (IsCTLPushed(lpbKeyState))
                ChangeMode(hIMC,TO_CMODE_HIRAGANA);
            else
                ChangeCompStr(hIMC,TO_CMODE_HIRAGANA);
            break;

        case VK_F7:
            if (IsCTLPushed(lpbKeyState))
                ChangeMode(hIMC,TO_CMODE_KATAKANA);
            else
                ChangeCompStr(hIMC,TO_CMODE_KATAKANA);
            break;

        case VK_F8:
            if (IsCTLPushed(lpbKeyState))
                ChangeMode(hIMC,TO_CMODE_FULLSHAPE);
            else
                ChangeCompStr(hIMC,TO_CMODE_FULLSHAPE);
            break;

        case VK_F9:
            if (IsCTLPushed(lpbKeyState))
                ChangeMode(hIMC,TO_CMODE_ALPHANUMERIC);
            else
                ChangeCompStr(hIMC,TO_CMODE_ALPHANUMERIC);
            break;

        case VK_RETURN:
            lpIMC = ImmLockIMC(hIMC);

            if( !( lpIMC->fdwConversion & IME_CMODE_CHARCODE ) )
                MakeResultString(hIMC,TRUE);
            else
                FlushText(hIMC);

            ImmUnlockIMC(hIMC);
            break;

        case VK_G:
#ifdef DEBUG
            if (dwDebugFlag & DEBF_GUIDELINE)
            {
                if (IsCTLPushed(lpbKeyState))
                {
                    MakeGuideLine(hIMC,MYGL_TESTGUIDELINE);
                    return( TRUE );
                }
            }
#endif
            break;

        default:
            break;
    }

    if (( VK_0 <= wParam && VK_9 >= wParam ) ||
        ( VK_A <= wParam && VK_Z >= wParam ) ||
        ( VK_NUMPAD0 <= wParam && VK_NUMPAD9 >= wParam ) ||
        ( VK_OEM_1 <= wParam && VK_OEM_9 >= wParam ) ||
        ( VK_MULTIPLY <= wParam && VK_DIVIDE >= wParam ))
    {
        return( FALSE );
    }
    else
        return( TRUE );
}

/**********************************************************************/
/*                                                                    */
/*  Entry    : MakeResultString( HIMC)                                */
/*                                                                    */
/**********************************************************************/
BOOL WINAPI MakeResultString( HIMC hIMC, BOOL fFlag)
{
    TRANSMSG GnMsg;
    LPCOMPOSITIONSTRING lpCompStr;
    LPCANDIDATEINFO lpCandInfo;
    LPINPUTCONTEXT lpIMC;

    if (!IsCompStr(hIMC))
        return FALSE;

    lpIMC = ImmLockIMC(hIMC);

    lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);

    if (IsCandidate(lpIMC))
    {
        lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo);
        ClearCandidate(lpCandInfo);
        ImmUnlockIMCC(lpIMC->hCandInfo);
        GnMsg.message = WM_IME_NOTIFY;
        GnMsg.wParam = IMN_CLOSECANDIDATE;
        GnMsg.lParam = 1L;
        GenerateMessage(hIMC, lpIMC, lpCurTransKey,(LPTRANSMSG)&GnMsg);
    }

    Mylstrcpy(GETLPRESULTSTR(lpCompStr),GETLPCOMPSTR(lpCompStr));
    Mylstrcpy(GETLPRESULTREADSTR(lpCompStr),GETLPCOMPREADSTR(lpCompStr));


    lpCompStr->dwResultStrLen = lpCompStr->dwCompStrLen;
    lpCompStr->dwResultReadStrLen = lpCompStr->dwCompReadStrLen;

    lpCompStr->dwCompStrLen = 0;
    lpCompStr->dwCompReadStrLen = 0;

    //
    // make clause info
    //
    SetClause(GETLPRESULTCLAUSE(lpCompStr),Mylstrlen(GETLPRESULTSTR(lpCompStr)));
    SetClause(GETLPRESULTREADCLAUSE(lpCompStr),Mylstrlen(GETLPRESULTREADSTR(lpCompStr)));
    lpCompStr->dwResultClauseLen = 8;
    lpCompStr->dwResultReadClauseLen = 8;

    ImmUnlockIMCC(lpIMC->hCompStr);

    if (fFlag)
    {
        GnMsg.message = WM_IME_COMPOSITION;
        GnMsg.wParam = 0;
        GnMsg.lParam = GCS_RESULTALL;
        GenerateMessage(hIMC, lpIMC, lpCurTransKey,(LPTRANSMSG)&GnMsg);

        GnMsg.message = WM_IME_ENDCOMPOSITION;
        GnMsg.wParam = 0;
        GnMsg.lParam = 0;
        GenerateMessage(hIMC, lpIMC, lpCurTransKey,(LPTRANSMSG)&GnMsg);
    }

    ImmUnlockIMC(hIMC);

    return TRUE;
}

/**********************************************************************/
/*                                                                    */
/*      MakeGuideLine()                                               */
/*                                                                    */
/*      Update the transrate key buffer.                              */
/*                                                                    */
/**********************************************************************/
BOOL PASCAL MakeGuideLine(HIMC hIMC, DWORD dwID)
{

    LPINPUTCONTEXT lpIMC;
    LPGUIDELINE    lpGuideLine;
    TRANSMSG GnMsg;
    DWORD dwSize = sizeof(GUIDELINE) + (MAXGLCHAR + sizeof(MYCHAR)) * 2 * sizeof(MYCHAR);
    LPMYSTR lpStr;
#ifdef FAKEIMEM
    char szBuf[MAXGLCHAR+1];
#endif

    lpIMC = ImmLockIMC(hIMC);
    lpIMC->hGuideLine = ImmReSizeIMCC(lpIMC->hGuideLine,dwSize);
    lpGuideLine = (LPGUIDELINE)ImmLockIMCC(lpIMC->hGuideLine);


    lpGuideLine->dwSize = dwSize;
    lpGuideLine->dwLevel = glTable[dwID].dwLevel;
    lpGuideLine->dwIndex = glTable[dwID].dwIndex;
    lpGuideLine->dwStrOffset = sizeof(GUIDELINE);
    lpStr = (LPMYSTR)(((LPSTR)lpGuideLine) + lpGuideLine->dwStrOffset);
#ifdef FAKEIMEM
    LoadString(hInst, glTable[dwID].dwStrID, szBuf, MAXGLCHAR);
    MultiByteToWideChar(CP_ACP, 0, szBuf, -1, lpStr, MAXGLCHAR);
#else
    LoadString(hInst,glTable[dwID].dwStrID,lpStr, MAXGLCHAR);
#endif
    lpGuideLine->dwStrLen = Mylstrlen(lpStr);

    if (glTable[dwID].dwPrivateID)
    {
        lpGuideLine->dwPrivateOffset = sizeof(GUIDELINE) + (MAXGLCHAR + 1) * sizeof(MYCHAR);
        lpStr = (LPMYSTR)(((LPSTR)lpGuideLine) + lpGuideLine->dwPrivateOffset);
#ifdef FAKEIMEM
        LoadString(hInst, glTable[dwID].dwStrID, szBuf, MAXGLCHAR);
        MultiByteToWideChar(CP_ACP, 0, szBuf, -1, lpStr, MAXGLCHAR);
#else
        LoadString(hInst,glTable[dwID].dwStrID,lpStr, MAXGLCHAR);
#endif
        lpGuideLine->dwPrivateSize = Mylstrlen(lpStr) * sizeof(MYCHAR);
    }
    else
    {
        lpGuideLine->dwPrivateOffset = 0L;
        lpGuideLine->dwPrivateSize = 0L;
    }

    GnMsg.message = WM_IME_NOTIFY;
    GnMsg.wParam = IMN_GUIDELINE;
    GnMsg.lParam = 0;
    GenerateMessage(hIMC, lpIMC, lpCurTransKey,(LPTRANSMSG)&GnMsg);

    ImmUnlockIMCC(lpIMC->hGuideLine);
    ImmUnlockIMC(hIMC);

    return TRUE;
}

/**********************************************************************/
/*                                                                    */
/*      GenerateMessage()                                             */
/*                                                                    */
/*      Update the transrate key buffer.                              */
/*                                                                    */
/**********************************************************************/
BOOL PASCAL GenerateMessage(HIMC hIMC, LPINPUTCONTEXT lpIMC, LPTRANSMSGLIST lpTransBuf,LPTRANSMSG lpGeneMsg)
{
    if (lpTransBuf)
        return GenerateMessageToTransKey(lpTransBuf,lpGeneMsg);

    if (IsWindow(lpIMC->hWnd))
    {
        LPTRANSMSG lpTransMsg;
        if (!(lpIMC->hMsgBuf = ImmReSizeIMCC(lpIMC->hMsgBuf,
                                 sizeof(TRANSMSG) * (lpIMC->dwNumMsgBuf +1))))
            return FALSE;

        if (!(lpTransMsg = (LPTRANSMSG)ImmLockIMCC(lpIMC->hMsgBuf)))
            return FALSE;

        lpTransMsg[lpIMC->dwNumMsgBuf] = *lpGeneMsg;
        ImmUnlockIMCC(lpIMC->hMsgBuf);
        lpIMC->dwNumMsgBuf++;

        ImmGenerateMessage(hIMC);
    }
    return TRUE;
}

/**********************************************************************/
/*                                                                    */
/*  Entry    : CheckAttr( LPCOMPOSITIONSTRING)                           */
/*                                                                    */
/**********************************************************************/
BOOL PASCAL CheckAttr( LPCOMPOSITIONSTRING lpCompStr)
{
    int i,len;
    LPBYTE lpb = GETLPCOMPATTR(lpCompStr);

    len = lpCompStr->dwCompAttrLen;
    for (i = 0; i < len; i++)
        if (*lpb++ & 0x01)
            return TRUE;

    return FALSE;
}

/**********************************************************************/
/*                                                                    */
/*  Entry    : MakeAttrClause( LPCOMPOSITIONSTRING)                         */
/*                                                                    */
/**********************************************************************/
void PASCAL MakeAttrClause( LPCOMPOSITIONSTRING lpCompStr)
{
    int len = lpCompStr->dwCompAttrLen;
    int readlen = lpCompStr->dwCompReadAttrLen;
    LPDWORD lpdw;
    LPBYTE lpb;
    DWORD dwCursorPos = lpCompStr->dwCursorPos;
    int i;

    if (len != readlen)
        return;

    lpb = GETLPCOMPATTR(lpCompStr);
    for (i = 0;i < len; i++)
    {
        if ((DWORD)i < dwCursorPos)
            *lpb++ = 0x10;
        else
            *lpb++ = 0x00;
    }

    lpb = GETLPCOMPREADATTR(lpCompStr);
    for (i = 0;i < readlen; i++)
    {
        if ((DWORD)i < dwCursorPos)
            *lpb++ = 0x10;
        else
            *lpb++ = 0x00;
    }

    lpdw = GETLPCOMPCLAUSE(lpCompStr);
    *lpdw++ = 0;
    *lpdw++ = (BYTE)dwCursorPos;
    *lpdw++ = len;

    lpdw = GETLPCOMPREADCLAUSE(lpCompStr);
    *lpdw++ = 0;
    *lpdw++ = (BYTE)dwCursorPos;
    *lpdw++ = len;
}

/**********************************************************************/
/*                                                                    */
/*  Entry    : HandleShiftArrow( HIMC, fArrow)                        */
/*                                                                    */
/**********************************************************************/
void PASCAL HandleShiftArrow( HIMC hIMC, BOOL fArrow)
{
    LPINPUTCONTEXT lpIMC;
    LPCOMPOSITIONSTRING lpCompStr;
    DWORD dwStartClause = 0;
    DWORD dwEndClause = 0;
    LPMYSTR lpstart,lpstr,lpend;

    if (!(lpIMC = ImmLockIMC(hIMC)))
        return;

    if (lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr))
    {

        // Temp! Error, if the string is already converted.
        if (CheckAttr(lpCompStr))
            goto hsa_exit;

        lpstart = GETLPCOMPSTR(lpCompStr);
        lpstr = lpstart + lpCompStr->dwCursorPos;
        lpend = lpstart + Mylstrlen(lpstart);

        if (fArrow == ARR_RIGHT)
        {
            if (lpstr < lpend)
                lpstr = MyCharNext(lpstr);
        }
        else
        {
            if (lpstr > lpstart)
                lpstr = MyCharPrev(lpstart,lpstr);
        }

        lpCompStr->dwCursorPos = (DWORD)(lpstr - lpstart);
        MakeAttrClause(lpCompStr);
    }

hsa_exit:
    ImmUnlockIMCC(lpIMC->hCompStr);
    ImmUnlockIMC(hIMC);
}

#if defined(FAKEIMEM) || defined(UNICODE)

int CopyCandidateStringsFromDictionary(LPMYSTR lpDic, LPMYSTR lpRead, LPMYSTR lpBuf, DWORD dwBufLen)
{
    DWORD dwWritten = 0;
    LPMYSTR lpSection, lpTemp;
    const LPMYSTR szSep = MYTEXT(" \r\n\t");

    LPMYSTR lpToken = Mystrtok(lpDic, szSep);
    while (NULL != lpToken)
    {
        if (MYTEXT('[') == *lpToken)
        {
            lpSection = lpToken + 1;
            if (NULL != (lpTemp = Mystrchr(lpSection, MYTEXT(']'))))
                *lpTemp = MYTEXT('\0');
            if (0 == Mylstrcmp(lpSection, lpRead))
            {
                lpToken = Mystrtok(NULL, szSep);
                break; // found it.
            }
        }
        lpToken = Mystrtok(NULL, szSep);
    }
    if (NULL != lpToken)
    {
        LPMYSTR lpWrite = lpBuf;
        DWORD dwW;
        while ((NULL != lpToken) &&
               ((dwBufLen - dwWritten) > 1) &&
               (MYTEXT('[') != *lpToken))
        {
            if (NULL != (lpTemp = Mystrchr(lpToken, MYTEXT('='))))
                *lpTemp = MYTEXT('\0');
            Mylstrcpyn(lpWrite, lpToken, dwBufLen - dwWritten - 1);
            dwW = Mylstrlen(lpToken) + 1;
            lpWrite += dwW;
            dwWritten += dwW;
            lpToken = Mystrtok(NULL, szSep);
        }
        *lpWrite = MYTEXT('\0');
        dwWritten++;
        return dwWritten;
    }
    return 0;
}

int GetCandidateStringsFromDictionary(LPMYSTR lpRead, LPMYSTR lpBuf, DWORD dwBufLen, LPTSTR lpFilename)
{
    HANDLE hTblFile;
    PSECURITY_ATTRIBUTES psa;
    int nSize = 0;
    DWORD dwFileSize, dwRead;
    LPMYSTR lpDic;

    psa = CreateSecurityAttributes();

    hTblFile = CreateFile(lpFilename, 
                          GENERIC_READ,
                          FILE_SHARE_READ,
                          NULL, 
                          OPEN_EXISTING,
                          FILE_ATTRIBUTE_NORMAL, 
                          (HANDLE)NULL);

    if (hTblFile == INVALID_HANDLE_VALUE) {
        goto Err0;
    }

    if (dwBufLen > 2) 
    {
        if ((dwFileSize = GetFileSize(hTblFile, (LPDWORD)NULL)) != 0xffffffff)
        {
            if ((lpDic = (LPMYSTR)GlobalAlloc(GPTR, dwFileSize + 2)))
            {
                if (ReadFile(hTblFile,    lpDic, dwFileSize, &dwRead, NULL))
                {
                    if (*lpDic == 0xfeff)
                    {
                        *(LPWSTR)(((LPBYTE)lpDic) + dwFileSize) = MYTEXT('\0');
                        nSize = CopyCandidateStringsFromDictionary(lpDic+1, lpRead, lpBuf, dwBufLen);
                    }
                }
                GlobalFree(lpDic);
            }
        }
    }

    CloseHandle(hTblFile);

Err0:
    FreeSecurityAttributes(psa);
    return nSize;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\ddk\jpn\fakeime.c ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation, All Rights Reserved

Module Name:

    FAKEIME.C
    
++*/

#include <windows.h>
#include "immdev.h"
#include "fakeime.h"
#include "resource.h"
#include "immsec.h"

extern HANDLE hMutex;
/**********************************************************************/
/*    DLLEntry()                                                      */
/**********************************************************************/
BOOL WINAPI DLLEntry (
    HINSTANCE    hInstDLL,
    DWORD        dwFunction,
    LPVOID       lpNot)
{
    LPTSTR lpDicFileName;
#ifdef DEBUG
    TCHAR szDev[80];
#endif
    MyDebugPrint((TEXT("DLLEntry:dwFunc=%d\n"),dwFunction));

    switch(dwFunction)
    {
        PSECURITY_ATTRIBUTES psa;

        case DLL_PROCESS_ATTACH:
            //
            // Create/open a system global named mutex.
            // The initial ownership is not needed.
            // CreateSecurityAttributes() will create
            // the proper security attribute for IME.
            //
            psa = CreateSecurityAttributes();
            if ( psa != NULL ) {
                 hMutex = CreateMutex( psa, FALSE, TEXT("FakeIme_Mutex"));
                 FreeSecurityAttributes( psa );
                 if ( hMutex == NULL ) {
                 // Failed
                 }
            }
            else {
                  // Failed, not NT system
                  }

            hInst= hInstDLL;
            IMERegisterClass( hInst );

            // Initialize for FAKEIME.
            lpDicFileName = (LPTSTR)&szDicFileName;
            lpDicFileName += GetWindowsDirectory(lpDicFileName,256);
            if (*(lpDicFileName-1) != TEXT('\\'))
                *lpDicFileName++ = TEXT('\\');
            LoadString( hInst, IDS_DICFILENAME, lpDicFileName, 128);

            SetGlobalFlags();

#ifdef DEBUG
            wsprintf(szDev,TEXT("DLLEntry Process Attach hInst is %lx"),hInst);
            ImeLog(LOGF_ENTRY, szDev);
#endif
            break;

        case DLL_PROCESS_DETACH:
            UnregisterClass(szUIClassName,hInst);
            UnregisterClass(szCompStrClassName,hInst);
            UnregisterClass(szCandClassName,hInst);
            UnregisterClass(szStatusClassName,hInst);
            if (hMutex)
                CloseHandle( hMutex );
#ifdef DEBUG
            wsprintf(szDev,TEXT("DLLEntry Process Detach hInst is %lx"),hInst);
            ImeLog(LOGF_ENTRY, szDev);
#endif
            break;

        case DLL_THREAD_ATTACH:
#ifdef DEBUG
            wsprintf(szDev,TEXT("DLLEntry Thread Attach hInst is %lx"),hInst);
            ImeLog(LOGF_ENTRY, szDev);
#endif
            break;

        case DLL_THREAD_DETACH:
#ifdef DEBUG
            wsprintf(szDev,TEXT("DLLEntry Thread Detach hInst is %lx"),hInst);
            ImeLog(LOGF_ENTRY, szDev);
#endif
            break;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\ddk\jpn\dic2.c ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation, All Rights Reserved

Module Name:

    DICT2.C
    
++*/
#include "windows.h"
#include "immdev.h"
#include "fakeime.h"

/**********************************************************************/
/*                                                                    */
/* ConvChar()                                                         */
/*                                                                    */
/* Roman character Kana converting function                           */
/*                                                                    */
/**********************************************************************/
WORD PASCAL ConvChar( hIMC, ch1, ch2 )
HIMC hIMC;
WORD ch1, ch2;
{
    int num1, num2;
#if defined(FAKEIMEM) || defined(UNICODE)
    static WCHAR table[15][5] = {
        { 0x30A2, 0x30A4, 0x30A6, 0x30A8, 0x30AA },     //  A
        { 0x30AB, 0x30AD, 0x30AF, 0x30B1, 0x30B3 },     //  K
        { 0x30B5, 0x30B7, 0x30B9, 0x30BB, 0x30BD },     //  S
        { 0x30BF, 0x30C1, 0x30C4, 0x30C6, 0x30C8 },     //  T
        { 0x30CA, 0x30CB, 0x30CC, 0x30CD, 0x30CE },     //  N
        { 0x30CF, 0x30D2, 0x30D5, 0x30D8, 0x30DB },     //  H
        { 0x30DE, 0x30DF, 0x30E0, 0x30E1, 0x30E2 },     //  M
        { 0x30E4, 0x0000, 0x30E6, 0x0000, 0x30E8 },     //  Y
        { 0x30E9, 0x30EA, 0x30EB, 0x30EC, 0x30ED },     //  R
        { 0x30EF, 0x0000, 0x0000, 0x0000, 0x30F2 },     //  W
        { 0x30AC, 0x30AE, 0x30B0, 0x30B2, 0x30B4 },     //  G
        { 0x30B6, 0x30B8, 0x30BA, 0x30BC, 0x30BE },     //  Z
        { 0x30C0, 0x30C2, 0x30C5, 0x30C7, 0x30C9 },     //  D
        { 0x30D0, 0x30D3, 0x30D6, 0x30D9, 0x30DC },     //  B
        { 0x30d1, 0x30d4, 0x30d7, 0x30da, 0x30dd }      //  p
    };
#else
    static unsigned char table[10][5] = {
        { 0xb1, 0xb2, 0xb3, 0xb4, 0xb5 },     //  A
        { 0xb6, 0xb7, 0xb8, 0xb9, 0xba },     //  K
        { 0xbb, 0xbc, 0xbd, 0xbe, 0xbf },     //  S
        { 0xc0, 0xc1, 0xc2, 0xc3, 0xc4 },     //  T
        { 0xc5, 0xc6, 0xc7, 0xc8, 0xc9 },     //  N
        { 0xca, 0xcb, 0xcc, 0xcd, 0xce },     //  H
        { 0xcf, 0xd0, 0xd1, 0xd2, 0xd3 },     //  M
        { 0xd4, 0x00, 0xd5, 0x00, 0xd6 },     //  Y
        { 0xd7, 0xd8, 0xd9, 0xda, 0xdb },     //  R
        { 0xdc, 0x00, 0x00, 0x00, 0xa6 }      //  W
    };
    static unsigned char table2[4][5] = {
        { 0xb6, 0xb7, 0xb8, 0xb9, 0xba },     //  G
        { 0xbb, 0xbc, 0xbd, 0xbe, 0xbf },     //  Z
        { 0xc0, 0xc1, 0xc2, 0xc3, 0xc4 },     //  D
        { 0xca, 0xcb, 0xcc, 0xcd, 0xce }      //  B
    };
    static unsigned char table3[1][5] = {
        { 0xca, 0xcb, 0xcc, 0xcd, 0xce }      //  P
    };
#endif

    num1 = IsFirst( ch1 );
    num2 = IsSecond( ch2 );

#if defined(FAKEIMEM) || defined(UNICODE)
    return( (WORD)table[num1][num2-1] );
#else
    if( num1 <= 9 )
        return( (WORD)table[num1][num2-1] );
    else if( num1 <= 13 )
        return( ((WORD)table2[num1-10][num2-1]) << 8 | (0x00de) );
    else
        return( ((WORD)table3[num1-14][num2-1]) << 8 | (0x00df) );
#endif
}

/**********************************************************************/
/*                                                                    */
/* IsFirst()                                                          */
/*                                                                    */
/* A function which judges the vowels                                 */
/*                                                                    */
/**********************************************************************/
int PASCAL IsFirst( ch )
register WORD ch;
{
    register int i;
#if defined(FAKEIMEM) || defined(UNICODE)
    static WCHAR table0[] = MYTEXT("KSTNHMYRWGZDBP");
    static WCHAR table1[] = MYTEXT("kstnhmyrwgzdbp");
#else
    static TCHAR table0[] = TEXT("KSTNHMYRWGZDBP");

    ch = (WORD)(LONG_PTR)AnsiUpper( (LPSTR)(LONG_PTR)ch );
#endif


    for( i = 0; table0[i]; i++ ){
#if defined(FAKEIMEM) || defined(UNICODE)
        if( table0[i] == (WCHAR)ch )
            return( i+1 );

        if( table1[i] == (WCHAR)ch )
            return( i+1 );
#else
        if( table0[i] == (char)ch )
            return( i+1 );
#endif
    }
    return 0;
}

/**********************************************************************/
/*                                                                    */
/* IsSecond()                                                         */
/*                                                                    */
/* A function which judges the consonants                             */
/*                                                                    */
/**********************************************************************/
int PASCAL IsSecond( ch )
register WORD ch;
{
    register int i;
#if defined(FAKEIMEM) || defined(UNICODE)
    static WCHAR table0[] = MYTEXT("AIUEO");
    static WCHAR table1[] = MYTEXT("aiueo");
#else
    static TCHAR table0[] = TEXT("AIUEO");

    ch = (WORD)(LONG_PTR)AnsiUpper( (LPSTR)(LONG_PTR)ch );
#endif


    for( i = 0; table0[i]; i++ ){
#if defined(FAKEIMEM) || defined(UNICODE)
        if( table0[i] == (WCHAR)ch )
            return( i+1 );

        if( table1[i] == (WCHAR)ch )
            return( i+1 );
#else
        if( table0[i] == (char)ch )
            return( i+1 );
#endif
    }
    return 0;
}

#if defined(FAKEIMEM) || defined(UNICODE)
static WORD table1[] = {
    0x3000, 0xFF01, 0x201D, 0xFF03, 0xFF04, 0xFF05, 0xFF06, 0x2019, 
    0xFF08, 0xFF09, 0xFF0A, 0xFF0B, 0xFF0C, 0xFF0D, 0xFF0E, 0x00F7
};
static WORD table2[] = {
    0xFF1A, 0xFF1B, 0xFF1C, 0xFF1D, 0xFF1E, 0xFF1F
};
static WORD table3[] = {
    0xFF3B, 0xFFE5, 0xFF3D, 0xFF3E, 0xFF3F, 0x2018
};
static WORD table4[] = {
    0xFF5B, 0xFF5C, 0xFF5D, 0xFF5E, 0x0000
};
static WORD table5[] = {
    0x3002, 0x300C, 0x300D, 0x3001, 0x30FB, 0x3092, 0x3041, 
    0x3043, 0x3045, 0x3047, 0x3049, 0x3083, 0x3085, 0x3087, 0x3063, 
    0x30FC, 0x3042, 0x3044, 0x3046, 0x3048, 0x304A, 0x304B, 0x304D,
    0x304F, 0x3051, 0x3053, 0x3055, 0x3057, 0x3059, 0x305B, 0x305D,
    0x305F, 0x3061, 0x3064, 0x3066, 0x3068, 0x306A, 0x306B, 0x306C,
    0x306D, 0x306E, 0x306F, 0x3072, 0x3075, 0x3078, 0x307B, 0x307E,
    0x307F, 0x3080, 0x3081, 0x3082, 0x3084, 0x3086, 0x3088, 0x3089,
    0x308A, 0x308B, 0x308C, 0x308D, 0x308F, 0x3093, 0x309B, 0x309C
};
static WORD table6[] = {
    0x3002, 0x300C, 0x300D, 0x3001, 0x30FB, 0x30F2, 0x30A1, 
    0x30A3, 0x30A5, 0x30A7, 0x30A9, 0x30E3, 0x30E5, 0x30E7, 0x30C3,
    0x30FC, 0x30A2, 0x30A4, 0x30A6, 0x30A8, 0x30AA, 0x30AB, 0x30AD,
    0x30AF, 0x30B1, 0x30B3, 0x30B5, 0x30B7, 0x30B9, 0x30BB, 0x30BD,
    0x30BF, 0x30C1, 0x30C4, 0x30C6, 0x30C8, 0x30CA, 0x30CB, 0x30CC,
    0x30CD, 0x30CE, 0x30CF, 0x30D2, 0x30D5, 0x30D8, 0x30DB, 0x30DE,
    0x30DF, 0x30E0, 0x30E1, 0x30E2, 0x30E4, 0x30E6, 0x30E8, 0x30E9,
    0x30EA, 0x30EB, 0x30EC, 0x30ED, 0x30EF, 0x30F3, 0x309B, 0x309C
};
static WORD table7[] = {
    0x306F, 0x3072, 0x3075, 0x3078, 0x307B, 
    0x30CF, 0x30D2, 0x30D5, 0x30D8, 0x30DB, 0x0000
};
static WORD table8[] = {
    0x304B, 0x304D, 0x304F, 0x3051, 0x3053, 0x3055, 0x3057, 0x3059, 
    0x305B, 0x305D, 0x305F, 0x3061, 0x3064, 0x3066, 0x3068, 0x306F, 
    0x3072, 0x3075, 0x3078, 0x307B, 
    0x30AB, 0x30AD, 0x30AF, 0x30B1, 0x30B3, 0x30B5, 0x30B7, 0x30B9, 
    0x30BB, 0x30BD, 0x30BF, 0x30C1, 0x30C4, 0x30C6, 0x30C8, 0x30CF, 
    0x30D2, 0x30D5, 0x30D8, 0x30DB, 0x0000
};
#else
static WORD table1[] = {        /* 0x20 - 0x2f */
    0x8140, 0x8149, 0x8168, 0x8194, 0x8190, 0x8193, 0x8195, 0x8166,
    0x8169, 0x816a, 0x8196, 0x817b, 0x8143, 0x817c, 0x8144, 0x8180
};
static WORD table2[] = {        /* 0x3a - 0x3f */
    0x8146, 0x8147, 0x8183, 0x8181, 0x8184, 0x8148
};
static WORD table3[] = {        /* 0x5b - 0x60 */
    0x816d, 0x818f, 0x816e, 0x814f, 0x8151, 0x8165
};
static WORD table4[] = {        /* 0x7b - 0x7f */
    0x816f, 0x8162, 0x8170, 0x8160, 0x0000
};
static WORD table5[] = {        /* 0xa1 - 0xdf hiragana */
    0x8142, 0x8175, 0x8176, 0x8141, 0x8145, 0x82f0, 0x829f,
    0x82a1, 0x82a3, 0x82a5, 0x82a7, 0x82e1, 0x82e3, 0x82e5, 0x82c1,
    0x815b, 0x82a0, 0x82a2, 0x82a4, 0x82a6, 0x82a8, 0x82a9, 0x82ab,
    0x82ad, 0x82af, 0x82b1, 0x82b3, 0x82b5, 0x82b7, 0x82b9, 0x82bb,
    0x82bd, 0x82bf, 0x82c2, 0x82c4, 0x82c6, 0x82c8, 0x82c9, 0x82ca,
    0x82cb, 0x82cc, 0x82cd, 0x82d0, 0x82d3, 0x82d6, 0x82d9, 0x82dc,
    0x82dd, 0x82de, 0x82df, 0x82e0, 0x82e2, 0x82e4, 0x82e6, 0x82e7,
    0x82e8, 0x82e9, 0x82ea, 0x82eb, 0x82ed, 0x82f1, 0x814a, 0x814b
};
static WORD table6[] = {        /* 0xa1 - 0xdf katakana */
    0x8142, 0x8175, 0x8176, 0x8141, 0x8145, 0x82f0, 0x8340,
    0x8342, 0x8344, 0x8346, 0x8348, 0x8383, 0x8385, 0x8387, 0x8362,
    0x815b, 0x8341, 0x8343, 0x8345, 0x8347, 0x8349, 0x834a, 0x834c,
    0x834e, 0x8350, 0x8352, 0x8354, 0x8356, 0x8358, 0x835a, 0x835c,
    0x835e, 0x8360, 0x8363, 0x8365, 0x8367, 0x8369, 0x836a, 0x836b,
    0x836c, 0x836d, 0x836e, 0x8371, 0x8374, 0x8377, 0x837a, 0x837d,
    0x837e, 0x8380, 0x8381, 0x8382, 0x8384, 0x8386, 0x8388, 0x8389,
    0x838a, 0x838b, 0x838c, 0x838d, 0x838f, 0x8393, 0x814a, 0x814b
};
static WORD table7[] = {        /* sonant char part 1 */
    0x82cd, 0x82d0, 0x82d3, 0x82d6, 0x82d9,
    0x836e, 0x8371, 0x8374, 0x8377, 0x837a, 0x0000
};
static WORD table8[] = {        /* sonant char part 2 */
    0x82a9, 0x82ab, 0x82ad, 0x82af, 0x82b1, 0x82b3, 0x82b5, 0x82b7,
    0x82b9, 0x82bb, 0x82bd, 0x82bf, 0x82c2, 0x82c4, 0x82c6, 0x82cd,
    0x82d0, 0x82d3, 0x82d6, 0x82d9,
    0x834a, 0x834c, 0x834e, 0x8350, 0x8352, 0x8354, 0x8356, 0x8358,
    0x835a, 0x835c, 0x835e, 0x8360, 0x8363, 0x8365, 0x8367, 0x836e,
    0x8371, 0x8374, 0x8377, 0x837a, 0x0000
};
#endif
/**********************************************************************/
/*                                                                    */
/* HanToZen( code, flag )                                             */
/*                                                                    */
/* A function which converts half size character to full size         */
/*                                                                    */
/* code                                                               */
/* Specify half size character code                                   */
/*                                                                    */
/* flag                                                               */
/* When convert to full size, specify if kana should be converted to  */
/* hiragana or katakana                                               */
/*   0   convert to katakana                                          */
/*   1   convert to hiragana                                          */
/*                                                                    */
/* return                                                             */
/* Return full size character code                                    */
/*                                                                    */
/**********************************************************************/
#if defined(FAKEIMEM) || defined(UNICODE)
WORD PASCAL HanToZen( code, KatakanaLetter,fdwConversion )
register WORD code;
register WORD KatakanaLetter;
DWORD fdwConversion;
#else
WORD PASCAL HanToZen( code, fdwConversion )
register WORD code;
DWORD fdwConversion;
#endif
{
    BOOL flag;

    flag = !(fdwConversion & IME_CMODE_KATAKANA);

#if defined(FAKEIMEM) || defined(UNICODE)
    if (KatakanaLetter) {
        WORD code2, code3;
        code2 = HanToZen( KatakanaLetter, 0, fdwConversion );
        code3 = code;
        if( code3 == 0xFF9E )
            code = ConvTenten( code2 );
        else if( code3 == 0xFF9F )
            code = ConvMaru( code2 );
        return( code );

    } else {
        if( code >= 0x30 && 0x39 >= code )
            return( code - 0x30 + 0xFF10 );
        if( code >= 0x41 && 0x5a >= code )
            return( code - 0x41 + 0xFF21 );
        if( code >= 0x61 && 0x7a >= code )
            return( code - 0x61 + 0xFF41 );
        if( code >= 0x20 && 0x40 >= code )
            return( table1[code-0x20] );
        if( code >= 0x3a && 0x3f >= code )
            return( table2[code-0x3a] );
        if( code >= 0x5b && 0x60 >= code )
            return( table3[code-0x5b] );
        if( code >= 0x7b && 0x7e >= code )
            return( table4[code-0x7b] );
        if( code >= 0xFF61 && 0xFF9F >= code )
            if( flag )
                return( table5[code-0xFF61] );
            else
                return( table6[code-0xFF61] );
        return( code );
    }
#else
    if( HIBYTE( code ) ){
        WORD code2, code3;
        code2 = HanToZen( HIBYTE(code), fdwConversion );
        code3 = LOBYTE( code );
        if( code3 == (0x00FF & '\xDE') )
            code = ConvTenten( code2 );
        else if( code3 == (0x00FF & '\xDF') )
            code = ConvMaru( code2 );
        return( code );

    } else {
        if( code >= 0x30 && 0x39 >= code )
            return( code - 0x30 + 0x824f );
        if( code >= 0x41 && 0x5a >= code )
            return( code - 0x41 + 0x8260 );
        if( code >= 0x61 && 0x7a >= code )
            return( code - 0x61 + 0x8281 );
        if( code >= 0x20 && 0x40 >= code )
            return( table1[code-0x20] );
        if( code >= 0x3a && 0x3f >= code )
            return( table2[code-0x3a] );
        if( code >= 0x5b && 0x60 >= code )
            return( table3[code-0x5b] );
        if( code >= 0x7b && 0x7e >= code )
            return( table4[code-0x7b] );
        if( code >= 0x0a1 && 0x0df >= code )
            if( flag )
                return( table5[code-0x0a1] );
            else
                return( table6[code-0x0a1] );
        return( code );
    }
#endif
}

/**********************************************************************/
/*                                                                    */
/* ZenToHan( code )                                                   */
/*                                                                    */
/* A function which converts full size character to half size         */
/*                                                                    */
/* code                                                               */
/* Specify full size character code                                   */
/*                                                                    */
/* return                                                             */
/* Return half size character code                                    */
/*                                                                    */
/**********************************************************************/
WORD PASCAL ZenToHan( code )
WORD code;
{
    int i;
#if defined(FAKEIMEM) || defined(UNICODE)
    if( code >= 0xFF10 && code <= 0xFF19 )
        return( code - 0xFF10 + 0x30 );
    if( code >= 0xFF21 && code <= 0xFF3A )
        return( code - 0xFF21 + 0x41 );
    if( code >= 0xFF41 && code <= 0xFF5A )
        return( code - 0xFF41 + 0x61 );

    for( i = 0; i < 16; i++ )
        if( code == table1[i] )
            return( 0x20 + i );
    for( i = 0; i < 6; i++ )
        if( code == table2[i] )
            return( 0x3a + i );
    for( i = 0; i < 6; i++ )
        if( code == table3[i] )
            return( 0x5b + i );
    for( i = 0; i < 5; i++ )
        if( code == table4[i] )
            return( 0x7b + i );
    for( i = 0; i < 63; i++ ){
        if( code == table5[i] )
            return( 0xFF61 + i );
        if( code == table6[i] )
            return( 0xFF61 + i );
    }
#else
    if( code >= 0x824f && code <= 0x8258 )
        return( code - 0x824f + 0x30 );
    if( code >= 0x8260 && code <= 0x8279 )
        return( code - 0x8260 + 0x41 );
    if( code >= 0x8281 && code <= 0x829a )
        return( code - 0x8281 + 0x61 );

    for( i = 0; i < 16; i++ )
        if( code == table1[i] )
            return( 0x20 + i );
    for( i = 0; i < 6; i++ )
        if( code == table2[i] )
            return( 0x3a + i );
    for( i = 0; i < 6; i++ )
        if( code == table3[i] )
            return( 0x5b + i );
    for( i = 0; i < 5; i++ )
        if( code == table4[i] )
            return( 0x7b + i );
    for( i = 0; i < 63; i++ ){
        if( code == table5[i] )
            return( 0xa1 + i );
        if( code == table6[i] )
            return( 0xa1 + i );
    }
#endif
    return 0;
}


BOOL PASCAL IsTenten( code )
WORD code;
{
    register int i;

    for( i = 0; table8[i]; i++ )
        if( table8[i] == code )
            return( TRUE );
    return( FALSE );
}


WORD PASCAL ConvTenten( code )
WORD code;
{
    if( IsTenten( code ) )
        return( code + 1 );
    return 0;
}


BOOL PASCAL IsMaru( code )
WORD code;
{
    register int i;

    for( i = 0; table7[i]; i++ )
        if( table7[i] == code )
            return( TRUE );
    return( FALSE );
}


WORD PASCAL ConvMaru( code )
WORD code;
{
    if( IsMaru( code ) )
        return( code + 2 );
    return 0;
}


WORD PASCAL HiraToKata(WORD code)
{
    register int i;

    for( i = 0; i < 63; i++ ){
        if( code == table5[i] )
            return table6[i];
    }
    for( i = 0; i < 63; i++ )
    {
        if( code-1 == table5[i] )
            if (IsTenten(table5[i]))
                return table6[i] + 1;
        if( code-2 == table5[i] )
            if (IsMaru(table5[i]))
                return table6[i] + 2;
    }
    return code;
}

WORD PASCAL KataToHira(WORD code)
{
    register int i;

    for( i = 0; i < 63; i++ ){
        if( code == table6[i] )
            return table5[i];
    }
    for( i = 0; i < 63; i++ )
    {
        if( code-1 == table6[i] )
            if (IsTenten(table6[i]))
                return table5[i] + 1;
        if( code-2 == table6[i] )
            if (IsMaru(table6[i]))
                return table5[i] + 2;
    }
    return code;
}

#if defined (FAKEIMEM) || defined(UNICODE)
BOOL OneCharZenToHan(WCHAR code,WCHAR* pKatakanaLetter,WCHAR* pSound)
{
    WCHAR NewCode;

    *pKatakanaLetter = 0;
    *pSound = 0;

    NewCode = (MYCHAR)ZenToHan(code);
    if (! NewCode)
    {
        if (IsTenten((WORD)(code-1)))
        {
            *pKatakanaLetter = (MYCHAR)ZenToHan((WORD)(code-1));
            *pSound = (MYCHAR)0xFF9E;
            return TRUE;
        }
        else if (IsMaru((WORD)(code-2)))
        {
            *pKatakanaLetter = (MYCHAR)ZenToHan((WORD)(code-2));
            *pSound = (MYCHAR)0xFF9F;
            return TRUE;
        }
        else{
            return FALSE;
        }
    }
    else
    {
        *pKatakanaLetter = NewCode;
        return TRUE;
    }
}
#endif

void PASCAL lZenToHan(LPMYSTR lpDst,LPMYSTR lpSrc)
{
    WORD code;

#if defined(FAKEIMEM) || defined(UNICODE)
    while(*lpSrc)
    {
        code = *lpSrc;
        *lpDst = (MYCHAR)ZenToHan(code);
        if (!*lpDst)
        {
            if (IsTenten((WORD)(code-1)))
            {
                *lpDst++ = (MYCHAR)ZenToHan((WORD)(code-1));
                *lpDst++ = (MYCHAR)0xFF9E;
            }
            else if (IsMaru((WORD)(code-2)))
            {
                *lpDst++ = (MYCHAR)ZenToHan((WORD)(code-2));
                *lpDst++ = (MYCHAR)0xFF9F;
            }
            else {
                //
                // this case means it is not Japanese char
                //
                *lpDst++ = *lpSrc;
            }
        }
        else 
           lpDst++;

        lpSrc++;
    }
    *lpDst = MYTEXT('\0');
#else
    while(*lpSrc)
    {
        if (IsDBCSLeadByte(*lpSrc))
        {
            code = MAKEWORD( *(lpSrc+1), *lpSrc );
            *lpDst = (char)ZenToHan(code);
            if (!*lpDst)
            {
                if (IsTenten((WORD)(code-1)))
                {
                    *lpDst++ = (TCHAR)ZenToHan((WORD)(code-1));
                    *lpDst++ = (TCHAR)0xde;
                }
                else if (IsMaru((WORD)(code-2)))
                {
                    *lpDst++ = (TCHAR)ZenToHan((WORD)(code-2));
                    *lpDst++ = (TCHAR)0xdf;
                }
            }
            else
               lpDst++;
            lpSrc += 2;
        }
        else
            *lpDst++ = *lpSrc++;
    }
    *lpDst = MYTEXT('\0');
#endif
}

void PASCAL lHanToZen(LPMYSTR lpDst,LPMYSTR lpSrc,DWORD fdwConversion)
{
    WORD code;
    WORD code0;
    WORD code1;

#if defined(FAKEIMEM) || defined(UNICODE)
    while(*lpSrc)
    {
        WORD KatakanaLetter;

        KatakanaLetter = 0;
        code0 = (WORD)*lpSrc;
        code1 = (WORD)*(lpSrc+1);

        lpSrc++;
        if ((code1 == 0xFF9E) || (code1 == 0xFF9F)) {
            KatakanaLetter = code0;
            code0 = code1;
            lpSrc++;
        }

        code = HanToZen (code0,KatakanaLetter,fdwConversion);
        *lpDst++ = code;
    }
    *lpDst = MYTEXT('\0');
#else
    while (*lpSrc)
    {
        code0 = (WORD)*lpSrc;
        code1 = (WORD)*(lpSrc+1);

        lpSrc++;
        if (( code1 == (0x00FF & '\xDE') )
           || ( code1 == (0x00FF & '\xDF') ))
        {
            code0 = MAKEWORD((BYTE)code0,(BYTE)code1);
            lpSrc++;
        }

        code = HanToZen (code0,fdwConversion);
        *lpDst++ = HIBYTE(code);
        *lpDst++ = LOBYTE(code);
    }
    *lpDst = MYTEXT('\0');
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\ddk\jpn\fakeime.h ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation, All Rights Reserved

Module Name:

    FAKEIME.H
    
++*/

#include <indicml.h>
/**********************************************************************/
/*                                                                    */
/*      DebugOptions                                                  */
/*                                                                    */
/**********************************************************************/
#define DEBF_THREADID        0x00000001
#define DEBF_GUIDELINE       0x00000002

#define LOGF_ENTRY           0x00000001
#define LOGF_API             0x00000002
#define LOGF_APIOUT          0x00000004
#define LOGF_KEY             0x00000008


/**********************************************************************/
/*                                                                    */
/*      Define                                                        */
/*                                                                    */
/**********************************************************************/

/* for Unicode FAKEIME */
#ifdef FAKEIMEM
typedef LPWSTR            LPMYSTR;
typedef WCHAR             MYCHAR;
#define MYTEXT(x)         L ## x
#define Mylstrlen(x)      lstrlenW(x)
#define Mylstrcpy(x, y)   MylstrcpyW((x), (y))
#define Mylstrcmp(x, y)   MylstrcmpW((x), (y))
#define MyCharPrev(x, y)  MyCharPrevW((x), (y))
#define MyCharNext(x)     MyCharNextW(x)
#include <string.h>
#define Mystrtok          wcstok
#define Mylstrcpyn        MylstrcpynW
#define Mystrchr          wcschr
#define MyTextOut         TextOutW
#define MyGetTextExtentPoint  GetTextExtentPointW
#define LPMYIMEMENUITEMINFO LPIMEMENUITEMINFOW
#define MyImmRequestMessage ImmRequestMessageW
#define MyOutputDebugString MyOutputDebugStringW
#define MyFileName        "fakeimem.ime"
#else
typedef LPTSTR            LPMYSTR;
typedef TCHAR             MYCHAR;
#define MYTEXT(x)         TEXT(x)
#define Mylstrlen(x)      lstrlen(x)
#ifdef UNICODE
#define Mylstrcpy(x, y)   MylstrcpyW((x), (y))
#define Mylstrcmp(x, y)   MylstrcmpW((x), (y))
#define MyCharPrev(x, y)  MyCharPrevW((x), (y))
#define MyCharPrev(x, y)  MyCharPrevW((x), (y))
#define MyCharNext(x)     MyCharNextW(x)
#include <string.h>
#define Mystrtok          wcstok
#define Mystrchr          wcschr
#else
#define Mylstrcpy(x, y)   lstrcpy((x), (y))
#define Mylstrcmp(x, y)   lstrcmp((x), (y))
#define MyCharPrev(x, y)  AnsiPrev((x), (y))
#define MyCharNext(x)     AnsiNext(x)
#include <mbstring.h>
#define Mystrtok          _mbstrtok
#define Mystrchr          _mbschr
#endif
#define Mylstrcpyn        lstrcpyn
#define MyTextOut         TextOut
#define MyGetTextExtentPoint  GetTextExtentPoint
#define LPMYIMEMENUITEMINFO LPIMEMENUITEMINFO
#define MyImmRequestMessage ImmRequestMessage
#define MyOutputDebugString OutputDebugString
#ifdef UNICODE
#define MyFileName        TEXT("fakeimeu.ime")
#else
#define MyFileName        TEXT("fakeime.ime")
#endif
#endif

/* for limit of FAKEIME */
#define MAXCOMPWND              10
#define MAXCOMPSIZE             128
#define MAXCLAUSESIZE           16
#define MAXCANDPAGESIZE         9
#define MAXCANDSTRSIZE          16
#define MAXGLCHAR               32
#define MAXCANDSTRNUM           32


/* for GlobalAlloc */
#define GHIME (GHND | GMEM_SHARE)

/* special messages */
#define WM_UI_UPDATE      (WM_USER+500)
#define WM_UI_HIDE        (WM_USER+501)

#define WM_UI_STATEMOVE   (WM_USER+601)
#define WM_UI_DEFCOMPMOVE (WM_USER+602)
#define WM_UI_CANDMOVE    (WM_USER+603)
#define WM_UI_GUIDEMOVE   (WM_USER+604)

/* Escape Functions */
#define IME_ESC_PRI_GETDWORDTEST (IME_ESC_PRIVATE_FIRST + 0)

/* special style */
#define WS_COMPDEFAULT (WS_DISABLED | WS_POPUP)
#define WS_COMPNODEFAULT (WS_DISABLED | WS_POPUP)

/* macro for me! */
#define IsCTLPushed(x)          ((x)[VK_CONTROL] & 0x80)
#define IsSHFTPushed(x)         ((x)[VK_SHIFT] & 0x80)
#define IsALTPushed(x)          ((x)[VK_ALT] & 0x80)

/* update context */
#define UPDATE_MODE             0x01
#define UPDATE_SYSTEM           0x02
#define UPDATE_TEXT             0x04
#define UPDATE_FORCE            0x08
#define UPDATE_ALL              ( UPDATE_MODE | UPDATE_SYSTEM | UPDATE_TEXT )

/* advise context */
#define ADVISE_MODE             0x0001  /* advise about Mode requested   */
#define ADVISE_ISOPEN           0x0002  /* advise about IsOpen requested */

/* key state context */
#define KS_SHIFT                0x01
#define KS_CONTROL              0x02



/* ID of guideline table */
#define MYGL_NODICTIONARY     0
#define MYGL_TYPINGERROR      1
#define MYGL_TESTGUIDELINE    2

/* Change Mode index */
#define TO_CMODE_ALPHANUMERIC  0x0001
#define TO_CMODE_KATAKANA      0x0002
#define TO_CMODE_HIRAGANA      0x0003
#define TO_CMODE_FULLSHAPE     0x0008
#define TO_CMODE_ROMAN         0x0010
#define TO_CMODE_CHARCODE     0x0020
#define TO_CMODE_TOOLBAR       0x0100

/* WndExtra of child UI windows */
#define FIGWL_MOUSE         0
#define FIGWL_SVRWND       (FIGWL_MOUSE+sizeof(LONG)) 
#define FIGWL_FONT         (FIGWL_SVRWND+sizeof(LONG_PTR))
#define FIGWL_COMPSTARTSTR (FIGWL_FONT+sizeof(LONG_PTR))
#define FIGWL_COMPSTARTNUM (FIGWL_COMPSTARTSTR+sizeof(LONG))
#define FIGWL_STATUSBMP    (FIGWL_COMPSTARTNUM+sizeof(LONG))
#define FIGWL_CLOSEBMP     (FIGWL_STATUSBMP+sizeof(LONG_PTR))
#define FIGWL_PUSHSTATUS   (FIGWL_CLOSEBMP+sizeof(LONG_PTR))
#define FIGWL_CHILDWND     (FIGWL_PUSHSTATUS+sizeof(LONG))
#define UIEXTRASIZE        (FIGWL_CHILDWND+sizeof(LONG_PTR))

/* The flags of FIGWL_MOUSE */
#define FIM_CAPUTURED 0x01
#define FIM_MOVED     0x02

/* The flags of the button of Status Window */
#define PUSHED_STATUS_HDR   0x01
#define PUSHED_STATUS_MODE  0x02
#define PUSHED_STATUS_ROMAN 0x04
#define PUSHED_STATUS_CLOSE 0x08

/* Status Button Pos */
#define BTX       20
#define BTY       20
#define BTFHIRA   20
#define BTFKATA   40
#define BTFALPH   60
#define BTHKATA   80
#define BTHALPH  100
#define BTROMA   120
#define BTEMPT   140

/* Statue Close Button */
#define STCLBT_X   (BTX*2+3)
#define STCLBT_Y   1
#define STCLBT_DX  12
#define STCLBT_DY  12

/* define Shift Arrow right-left */
#define ARR_RIGHT 1
#define ARR_LEFT  2

/* Init or Clear Structure Flag */
#define CLR_RESULT 1
#define CLR_UNDET  2
#define CLR_RESULT_AND_UNDET  3


/* define GET LP for COMPOSITIONSTRING members. */
#define GETLPCOMPREADATTR(lpcs) (LPBYTE)((LPBYTE)(lpcs) + (lpcs)->dwCompReadAttrOffset)
#define GETLPCOMPREADCLAUSE(lpcs) (LPDWORD)((LPBYTE)(lpcs) + (lpcs)->dwCompReadClauseOffset)
#define GETLPCOMPREADSTR(lpcs) (LPMYSTR)((LPBYTE)(lpcs) + (lpcs)->dwCompReadStrOffset)
#define GETLPCOMPATTR(lpcs) (LPBYTE)((LPBYTE)(lpcs) + (lpcs)->dwCompAttrOffset)
#define GETLPCOMPCLAUSE(lpcs) (LPDWORD)((LPBYTE)(lpcs) + (lpcs)->dwCompClauseOffset)
#define GETLPCOMPSTR(lpcs) (LPMYSTR)((LPBYTE)(lpcs) + (lpcs)->dwCompStrOffset)
#define GETLPRESULTREADCLAUSE(lpcs) (LPDWORD)((LPBYTE)(lpcs) + (lpcs)->dwResultReadClauseOffset)
#define GETLPRESULTREADSTR(lpcs) (LPMYSTR)((LPBYTE)(lpcs) + (lpcs)->dwResultReadStrOffset)
#define GETLPRESULTCLAUSE(lpcs) (LPDWORD)((LPBYTE)(lpcs) + (lpcs)->dwResultClauseOffset)
#define GETLPRESULTSTR(lpcs) (LPMYSTR)((LPBYTE)(lpcs) + (lpcs)->dwResultStrOffset)


#define SetClause(lpdw,num)   {*((LPDWORD)(lpdw)) = 0;*((LPDWORD)(lpdw)+1) = num;}

#define GCS_COMPALL ( GCS_COMPSTR | GCS_COMPATTR | GCS_COMPREADSTR | GCS_COMPREADATTR | GCS_COMPCLAUSE | GCS_COMPREADCLAUSE)
#define GCS_RESULTALL ( GCS_RESULTSTR | GCS_RESULTREADSTR | GCS_RESULTCLAUSE | GCS_RESULTREADCLAUSE)


// ImeMenu Define
#define NUM_ROOT_MENU_L 3
#define NUM_ROOT_MENU_R 3
#define NUM_SUB_MENU_L 2
#define NUM_SUB_MENU_R 2

#define IDIM_ROOT_ML_1       0x10
#define IDIM_ROOT_ML_2       0x11
#define IDIM_ROOT_ML_3       0x12
#define IDIM_SUB_ML_1        0x20
#define IDIM_SUB_ML_2        0x21
#define IDIM_ROOT_MR_1       0x30
#define IDIM_ROOT_MR_2       0x31
#define IDIM_ROOT_MR_3       0x32
#define IDIM_SUB_MR_1        0x40
#define IDIM_SUB_MR_2        0x41

#define NATIVE_CHARSET SHIFTJIS_CHARSET

/**********************************************************************/
/*                                                                    */
/*      Structures                                                    */
/*                                                                    */
/**********************************************************************/
typedef struct _tagMYCOMPSTR{
    COMPOSITIONSTRING cs;
    MYCHAR         szCompReadStr[MAXCOMPSIZE];
    BYTE           bCompReadAttr[MAXCOMPSIZE];
    DWORD          dwCompReadClause[MAXCLAUSESIZE];
    MYCHAR         szCompStr[MAXCOMPSIZE];
    BYTE           bCompAttr[MAXCOMPSIZE];
    DWORD          dwCompClause[MAXCLAUSESIZE];
    char           szTypeInfo[MAXCOMPSIZE];
    MYCHAR         szResultReadStr[MAXCOMPSIZE];
    DWORD          dwResultReadClause[MAXCOMPSIZE];
    MYCHAR         szResultStr[MAXCOMPSIZE];
    DWORD          dwResultClause[MAXCOMPSIZE];
} MYCOMPSTR, NEAR *PMYCOMPSTR, FAR *LPMYCOMPSTR;

typedef struct _tagMYCAND{
    CANDIDATEINFO  ci;
    CANDIDATELIST  cl;
    DWORD          offset[MAXCANDSTRNUM];
    TCHAR          szCand[MAXCANDSTRNUM][MAXCANDSTRSIZE];
} MYCAND, NEAR *PMYCAND, FAR *LPMYCAND;


typedef struct _tagUICHILD{
    HWND    hWnd;
    BOOL    bShow;
    POINT   pt;
} UICHILD, NEAR *PUICHILD, FAR *LPUICHILD;

typedef struct _tagUICHILD2{
    HWND    hWnd;
    BOOL    bShow;
    RECT    rc;
} UICHILD2, NEAR *PUICHILD2, FAR *LPUICHILD2;

typedef struct _tagUIEXTRA{
    HIMC     hIMC;
    UICHILD  uiStatus;
    UICHILD  uiCand;
    DWORD    dwCompStyle;
    HFONT    hFont;
    BOOL     bVertical;
    UICHILD  uiDefComp;
    UICHILD2 uiComp[MAXCOMPWND];
    UICHILD  uiGuide;
} UIEXTRA, NEAR *PUIEXTRA, FAR *LPUIEXTRA;

typedef struct _tagMYGUIDELINE{
    DWORD dwLevel;
    DWORD dwIndex;
    DWORD dwStrID;
    DWORD dwPrivateID;
} MYGUIDELINE, NEAR *PMYGUIDELINE, FAR *LPMYGUIDELINE;

/**********************************************************************/
/*                                                                    */
/*      Externs                                                       */
/*                                                                    */
/**********************************************************************/
#ifndef _NO_EXTERN_
extern HINSTANCE  hInst;
extern HKL hMyKL;
extern LPTRANSMSGLIST lpCurTransKey;
extern UINT uNumTransKey;
extern BOOL fOverTransKey;
#ifdef FAKEIMEM
extern WCHAR wszUIClassName[];
#endif
extern TCHAR szUIClassName[];
extern TCHAR szCompStrClassName[];
extern TCHAR szCandClassName[];
extern TCHAR szStatusClassName[];
extern TCHAR szGuideClassName[];
extern MYGUIDELINE glTable[];
extern TCHAR szDicFileName[];
extern BYTE bComp[];
extern BYTE bCompCtl[];
extern BYTE bCompSht[];
extern BYTE bCompAlt[];
extern BYTE bNoComp[];
extern BYTE bNoCompCtl[];
extern BYTE bNoCompSht[];
extern BYTE bNoCompAlt[];
extern DWORD dwLogFlag;
extern DWORD dwDebugFlag;
#endif //_NO_EXTERN_

/**********************************************************************/
/*                                                                    */
/*      Functions                                                     */
/*                                                                    */
/**********************************************************************/
/*   fakeime.c     */
int PASCAL Init(void);

/*   subs.c     */
void PASCAL InitCompStr(LPCOMPOSITIONSTRING lpCompStr,DWORD dwClrFlag);
void PASCAL ClearCompStr(LPCOMPOSITIONSTRING lpCompStr,DWORD dwClrFlag);
void PASCAL ClearCandidate(LPCANDIDATEINFO lpCandInfo);
void PASCAL ChangeMode(HIMC hIMC,DWORD dwToMode);
void PASCAL ChangeCompStr(HIMC hIMC,DWORD dwToMode);
BOOL PASCAL IsCompStr(HIMC hIMC);
BOOL PASCAL IsConvertedCompStr(HIMC hIMC);
BOOL PASCAL IsCandidate(LPINPUTCONTEXT lpIMC);
void PASCAL UpdateIndicIcon(HIMC hIMC);
void PASCAL lmemset(LPBYTE,BYTE,UINT);
#if defined(FAKEIMEM) || defined(UNICODE) 
int PASCAL MylstrcmpW(LPWSTR lp0, LPWSTR lp1);
int PASCAL MylstrcpyW(LPWSTR lp0, LPWSTR lp1);
LPWSTR PASCAL MyCharPrevW(LPWSTR lpStart, LPWSTR lpCur);
LPWSTR PASCAL MyCharNextW(LPWSTR lp);
LPWSTR PASCAL MylstrcpynW(LPWSTR lp0, LPWSTR lp1, int nCount);
#endif
HFONT CheckNativeCharset(HDC hDC);

/*   toascii.c   */
BOOL PASCAL GenerateMessageToTransKey(LPTRANSMSGLIST lpTrabsKey,LPTRANSMSG lpGeneMsg);
BOOL PASCAL GenerateOverFlowMessage(LPTRANSMSGLIST lpTransKey);

/*   notify.c    */
BOOL PASCAL NotifyUCSetOpen(HIMC hIMC);
BOOL PASCAL NotifyUCConversionMode(HIMC hIMC);
BOOL PASCAL NotifyUCSetCompositionWindow(HIMC hIMC);

/*   input.c     */
BOOL PASCAL IMEKeydownHandler(HIMC,WPARAM,LPARAM,LPBYTE);
BOOL PASCAL IMEKeyupHandler(HIMC,WPARAM,LPARAM,LPBYTE);

/*   ui.c        */
BOOL IMERegisterClass(HANDLE hInstance);
LRESULT CALLBACK FAKEIMEWndProc(HWND,UINT,WPARAM,LPARAM);
LONG PASCAL NotifyCommand(HIMC hUICurIMC, HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam);
LONG PASCAL ControlCommand(HIMC hUICurIMC, HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam);
void PASCAL DrawUIBorder( LPRECT lprc );
void PASCAL DragUI(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);

/*   uistate.c   */
LRESULT CALLBACK StatusWndProc(HWND,UINT,WPARAM,LPARAM);
void PASCAL PaintStatus(HWND hStatusWnd , HDC hDC, LPPOINT lppt,DWORD dwPushedStatus);
void PASCAL ButtonStatus(HWND hWnd, UINT message,WPARAM wParam,LPARAM lParam);
BOOL PASCAL MyIsIMEMessage(UINT message);
void PASCAL UpdateStatusWindow(LPUIEXTRA lpUIExtra);

/* uicand.c      */
LRESULT CALLBACK CandWndProc(HWND,UINT,WPARAM,LPARAM);
void PASCAL PaintCandWindow(HWND hCandWnd);
BOOL PASCAL GetCandPosFromComp(LPINPUTCONTEXT lpIMC, LPUIEXTRA lpUIExtra,LPPOINT lppt);
void PASCAL CreateCandWindow(HWND hUIWnd,LPUIEXTRA lpUIExtra, LPINPUTCONTEXT lpIMC);
void PASCAL ResizeCandWindow(LPUIEXTRA lpUIExtra,LPINPUTCONTEXT lpIMC);
void PASCAL HideCandWindow( LPUIEXTRA lpUIExtra);
void PASCAL MoveCandWindow(HWND hUIWnd, LPINPUTCONTEXT lpIMC, LPUIEXTRA lpUIExtra, BOOL fForceComp);

/* uicomp.c      */
LRESULT CALLBACK CompStrWndProc(HWND,UINT,WPARAM,LPARAM);
void PASCAL PaintCompWindow(HWND hCompWnd);
void PASCAL CreateCompWindow(HWND hUIWnd, LPUIEXTRA lpUIExtra,LPINPUTCONTEXT lpIMC);
void PASCAL MoveCompWindow(LPUIEXTRA lpUIExtra,LPINPUTCONTEXT lpIMC);
void PASCAL HideCompWindow(LPUIEXTRA lpUIExtra);
void PASCAL SetFontCompWindow(LPUIEXTRA lpUIExtra);

/*   uiguide.c   */
LRESULT CALLBACK GuideWndProc(HWND,UINT,WPARAM,LPARAM);
void PASCAL PaintGuide(HWND hGuideWnd , HDC hDC, LPPOINT lppt,DWORD dwPushedGuide);
void PASCAL ButtonGuide(HWND hWnd, UINT message,WPARAM wParam,LPARAM lParam);
void PASCAL UpdateGuideWindow(LPUIEXTRA lpUIExtra);
LRESULT CALLBACK LineWndProc(HWND,UINT,WPARAM,LPARAM);

/* config.c      */
INT_PTR  CALLBACK RegWordDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK SelectDictionaryDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK AboutDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK GeneralDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK DebugOptionDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam);

/* DIC.C         */
BOOL PASCAL IsEat(WORD);
BOOL PASCAL DicKeydownHandler(HIMC,UINT,LPARAM,LPBYTE);
void PASCAL DeleteChar( HIMC hIMC ,UINT uVKey);
void PASCAL FlushText();
void PASCAL RevertText(HIMC hIMC);
void PASCAL AddChar(HIMC,WORD);
BOOL PASCAL ConvKanji(HIMC);
BOOL WINAPI MakeResultString(HIMC,BOOL);
BOOL PASCAL MakeGuideLine(HIMC, DWORD);
BOOL PASCAL GenerateMessage(HIMC,LPINPUTCONTEXT,LPTRANSMSGLIST,LPTRANSMSG);
BOOL PASCAL CheckAttr( LPCOMPOSITIONSTRING lpCompStr);
void PASCAL MakeAttrClause( LPCOMPOSITIONSTRING lpCompStr);
void PASCAL HandleShiftArrow( HIMC hIMC, BOOL fArrow);

/* DIC2.C        */
#if defined(FAKEIMEM) || defined(UNICODE)
BOOL OneCharZenToHan(WCHAR ,WCHAR* ,WCHAR* );
WORD PASCAL HanToZen(WORD,WORD,DWORD);
#else
WORD PASCAL HanToZen(WORD,DWORD);
#endif
WORD PASCAL ZenToHan(WORD);
int  PASCAL IsFirst(WORD);
int  PASCAL IsSecond(WORD);
WORD PASCAL ConvChar(HIMC,WORD,WORD);
BOOL PASCAL IsTenten(WORD);
WORD PASCAL ConvTenten(WORD);
BOOL PASCAL IsMaru(WORD);
WORD PASCAL ConvMaru(WORD);
WORD PASCAL HiraToKata(WORD);
WORD PASCAL KataToHira(WORD);
void PASCAL lZenToHan(LPMYSTR,LPMYSTR);
void PASCAL lHanToZen(LPMYSTR,LPMYSTR,DWORD);

/* DIC3.C        */
WORD PASCAL AddWord(LPSTR,LPSTR);
WORD PASCAL GetWord(LPSTR,LPSTR,WORD,WORD);
WORD PASCAL GetWordCount(LPSTR);
WORD PASCAL GetWordNum(LPSTR);
WORD PASCAL DeleteWord(LPSTR,LPSTR);

/* FDEBUG.C      */
#ifdef DEBUG
#define MyDebugPrint(x) DebugPrint x
int DebugPrint(LPCTSTR lpszFormat, ...);
void SetDwordToSetting(LPCTSTR lpszFlag, DWORD dwFlag);
void PASCAL SetGlobalFlags();
void PASCAL ImeLog(DWORD dwFlag, LPTSTR lpStr);
#ifdef FAKEIMEM
void PASCAL MyOutputDebugStringW(LPWSTR lpw);
#endif
#else
#define MyDebugPrint(x)
#define SetDwordToSetting() FALSE
//#define SetDwordToSetting(lpszFlag, dwFlag) FALSE
#define SetGlobalFlags() FALSE
//#define ImeLog() FALSE
#define ImeLog(dwFlag, lpStr) FALSE
#ifdef FAKEIMEM
#define MyOutputDebugStringW() FALSE
//#define MyOutputDebugStringW(lpw) FALSE
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\ddk\jpn\fdebug.c ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation, All Rights Reserved

Module Name:

    DEBUG.C
    
++*/

#include <windows.h>
#include "immdev.h"
#include "fakeime.h"

#ifdef DEBUG

#ifdef FAKEIMEM
const LPTSTR g_szRegInfoPath = TEXT("software\\microsoft\\fakeime\\m");
#elif UNICODE
const LPTSTR g_szRegInfoPath = TEXT("software\\microsoft\\fakeime\\u");
#else
const LPTSTR g_szRegInfoPath = TEXT("software\\microsoft\\fakeime\\a");
#endif

int DebugPrint(LPCTSTR lpszFormat, ...)
{
    int nCount;
    TCHAR szMsg[1024];

    va_list marker;
    va_start(marker, lpszFormat);
    nCount = wvsprintf(szMsg, lpszFormat, marker);
    va_end(marker);
    OutputDebugString(szMsg);
    return nCount;
}

DWORD PASCAL GetDwordFromSetting(LPTSTR lpszFlag)
{
    HKEY hkey;
    DWORD dwRegType, dwData, dwDataSize, dwRet;

    dwData = 0;
    dwDataSize=sizeof(DWORD);
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, g_szRegInfoPath, 0, KEY_READ, &hkey)) {
        dwRet = RegQueryValueEx(hkey, lpszFlag, NULL, &dwRegType, (LPBYTE)&dwData, &dwDataSize);
        RegCloseKey(hkey);
    }
    MyDebugPrint((TEXT("Getting: %s=%#8.8x: dwRet=%#8.8x\n"), lpszFlag, dwData, dwRet));
    return dwData;
}

void SetDwordToSetting(LPCTSTR lpszFlag, DWORD dwFlag)
{
    HKEY hkey;
    DWORD dwDataSize, dwRet;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, g_szRegInfoPath, 0, KEY_WRITE, &hkey)) {
        dwRet = RegSetValueEx(hkey, lpszFlag, 0, REG_DWORD, (CONST BYTE *) &dwFlag, sizeof(DWORD));
        RegCloseKey(hkey);
    }
    MyDebugPrint((TEXT("Setting: %s=%#8.8x: dwRet=%#8.8x\n"), lpszFlag, dwFlag, dwRet));
}

void PASCAL SetGlobalFlags()
{
    dwLogFlag = GetDwordFromSetting(TEXT("LogFlag"));
    dwDebugFlag = GetDwordFromSetting(TEXT("DebugFlag"));
}

void PASCAL ImeLog(DWORD dwFlag, LPTSTR lpStr)
{
    TCHAR szBuf[80];

    if (dwFlag & dwLogFlag)
    {
        if (dwDebugFlag & DEBF_THREADID)
        {
            DWORD dwThreadId = GetCurrentThreadId();
            wsprintf(szBuf, TEXT("ThreadID = %X "), dwThreadId);
            OutputDebugString(szBuf);
        }

        OutputDebugString(lpStr);
        OutputDebugString(TEXT("\r\n"));
    }
}

#ifdef FAKEIMEM
void PASCAL MyOutputDebugStringW(LPWSTR lpw)
{
    DWORD dwSize = (lstrlenW(lpw) + 1) * 2;
    LPSTR lpStr;
    int n;

    lpStr = GlobalAlloc(GPTR, dwSize);

    if (!lpStr)
         return;


    n = WideCharToMultiByte(CP_ACP, 0, lpw, lstrlenW(lpw), lpStr, dwSize, NULL, NULL);

    *(lpStr + n) = '\0';

    OutputDebugString(lpStr);
    GlobalFree((HANDLE)lpStr);
}
#endif

#endif //DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\ddk\jpn\immsec.h ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation, All Rights Reserved

Module Name:

    IMMSEC.H
    
++*/

PSECURITY_ATTRIBUTES CreateSecurityAttributes( );
VOID FreeSecurityAttributes( PSECURITY_ATTRIBUTES psa);
BOOL IsNT();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\ddk\jpn\process.c ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation, All Rights Reserved

Module Name:

    PROCESS.C
    
++*/

/**********************************************************************/
/* These tables are for ImeProcessKey(). And IMEProcessKey function   */
/* refer this table and deside the VKey is needed for FAKEIME or not. */
/*                                                                    */
/**********************************************************************/
#include "windows.h"


BYTE bNoComp[] = {      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 00-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 10-1F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 20-2F
                        1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,        // 30-3F
                        0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,        // 40-4F
                        1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,        // 50-5F
                        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,        // 60-6F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 70-7F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 80-8F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 90-9F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // A0-AF
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // B0-BF
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // C0-CF
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // D0-DF
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // E0-EF
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};       // F0-FF

BYTE bNoCompCtl[] = {   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 00-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 10-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 20-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 30-0F
                        0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,        // 40-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 50-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 60-0F
                        0,0,1,0,0,1,1,1,1,0,0,0,0,0,0,0,        // 70-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 80-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 90-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // A0-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // B0-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // C0-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // D0-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // E0-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};       // F0-0F

BYTE bNoCompSht[] = {   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 00-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 10-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 20-0F
                        1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,        // 30-0F
                        0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,        // 40-0F
                        1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,        // 50-0F
                        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,        // 60-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 70-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 80-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 90-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // A0-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // B0-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // C0-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // D0-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // E0-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};       // F0-0F
        
BYTE bNoCompAlt[] = {   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 00-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 10-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 20-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 30-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 40-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 50-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 60-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 70-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 80-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 90-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // A0-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // B0-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // C0-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // D0-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // E0-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};       // F0-0F

BYTE bComp[] = {        0,0,0,1,0,0,0,0,1,1,0,0,0,1,0,0,        // 00-0F
                        0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,        // 10-0F
                        1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,        // 20-0F
                        1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,        // 30-0F
                        0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,        // 40-0F
                        1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,        // 50-0F
                        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,        // 60-0F
                        0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,        // 70-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 80-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 90-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // A0-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // B0-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // C0-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // D0-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // E0-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};       // F0-0F

BYTE bCompCtl[] = {     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 00-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 10-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 20-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 30-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 40-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 50-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 60-0F
                        0,0,1,0,0,1,1,1,1,0,0,0,0,0,0,0,        // 70-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 80-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 90-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // A0-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // B0-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // C0-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // D0-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // E0-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};       // F0-0F

BYTE bCompSht[] = {     0,0,0,1,0,0,0,0,1,1,0,0,0,1,0,0,        // 00-0F
                        0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,        // 10-0F
                        1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,        // 20-0F
                        1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,        // 30-0F
                        0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,        // 40-0F
                        1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,        // 50-0F
                        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,        // 60-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 70-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 80-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 90-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // A0-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // B0-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // C0-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // D0-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // E0-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};       // F0-0F

BYTE bCompAlt[] = {     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 00-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 00-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 00-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 00-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 00-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 00-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 00-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 00-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 00-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 00-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 00-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 00-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 00-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 00-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,        // 00-0F
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};        // 00-0F
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\ddk\jpn\resource.h ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation, All Rights Reserved

Module Name:

    RESOURCE.H
    
++*/

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Fakeime0.rc
//
#define VER_DEBUG                       0

/* Property Sheet DLG ID */
#define DLG_GENERAL             100
#define DLG_REGISTERWORD        101
#define DLG_SELECTDICTIONARY    102
#define DLG_ABOUT               103
#define DLG_DEBUG               104

/* for dialog box */
#define ID_WR_READING           200
#define ID_WR_STRING            201
#define ID_WR_STYLE             202

#define ID_SD_SELDIC            301
#define ID_SD_DICPATH           302

#define IDC_LOGF_ENTRY          310
#define IDC_LOGF_API            311
#define IDC_LOGF_KEY            312
#define IDC_DEBF_THREADID       313
#define IDC_DEBF_GUIDELINE      314

/* string tables */
#define IDS_DICFILENAME             1000
#define IDS_CONFIGNAME              1001
#define IDS_GL_NODICTIONARY         1010
#define IDS_GL_TYPINGERROR          1011
#define IDS_GL_TESTGUIDELINESTR     1012
#define IDS_GL_TESTGUIDELINEPRIVATE 1013
#define IDS_NOREADING               1020
#define IDS_NOSTRING                1021
#define IDS_NOMEMORY                1022
#define IDS_REGWORDRET              1023

#define IDC_STATIC                      -1

#define IDM_RECONVERT                   40001
#define IDM_ABOUT                       40002

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1004
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\ddk\jpn\regword.c ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation, All Rights Reserved

Module Name:

    REGWORD.C
    
++*/

/**********************************************************************/
#include "windows.h"
#include "immdev.h"
#include "fakeime.h"


#define FAKEWORD_NOUN  IME_REGWORD_STYLE_USER_FIRST
#define FAKEWORD_VERB  (IME_REGWORD_STYLE_USER_FIRST+1)

BOOL    WINAPI ImeRegisterWord(LPCTSTR lpRead, DWORD dw, LPCTSTR lpStr)
{
    if ((dw == FAKEWORD_NOUN) || (dw== FAKEWORD_VERB))
        return WritePrivateProfileString(lpRead,lpStr,lpStr,szDicFileName);

    return FALSE;
}
BOOL    WINAPI ImeUnregisterWord(LPCTSTR lpRead, DWORD dw, LPCTSTR lpStr)
{
    if ((dw == FAKEWORD_NOUN) || (dw== FAKEWORD_VERB))

        return WritePrivateProfileString(lpRead,lpStr,NULL,szDicFileName);

    return FALSE;
}
UINT    WINAPI ImeGetRegisterWordStyle(UINT u, LPSTYLEBUF lp)
{
    UINT uRet = 0;

    if (u > 0 && lp)
    {
        lp->dwStyle = FAKEWORD_NOUN; 
        lstrcpy(lp->szDescription,TEXT("NOUN"));
   
        if (u > 1)
        {
            lp++;
            lp->dwStyle = FAKEWORD_VERB; 
            lstrcpy(lp->szDescription,TEXT("VERB"));
        }
    }
    else
        uRet = 2;

    return uRet;
}
UINT    WINAPI ImeEnumRegisterWord(REGISTERWORDENUMPROC lpfn, LPCTSTR lpRead, DWORD dw, LPCTSTR lpStr, LPVOID lpData)
{
    UINT uRet = 0;
    char szBuf[256];
    int nBufLen;
    LPTSTR lpBuf;

    if (! lpfn)
        return 0;

    lpBuf = (LPTSTR)szBuf;

    if (!dw || (dw == FAKEWORD_NOUN))
    {
        if (lpRead)
        {
            nBufLen = GetPrivateProfileString(lpRead, NULL,(LPTSTR)"",
                            (LPTSTR)szBuf,sizeof(szBuf),(LPTSTR)szDicFileName );

            if (nBufLen)
            {
                while (*lpBuf)
                {
                    if (lpStr && lstrcmp(lpStr, lpBuf))
                        continue;

                    uRet = (*lpfn)(lpRead, dw, lpBuf, lpData);
                    lpBuf += (lstrlen(lpBuf) + 1);

                    if (!uRet)
                        break;
                }
            }
        }
        else
        {
        }
    }

    return uRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\ddk\jpn\imm.c ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation, All Rights Reserved

Module Name:

    IMM.C
    
++*/
#include "windows.h"
#include "immdev.h"
#include "fakeime.h"

#if defined(FAKEIMEM) || defined(UNICODE)
int GetCandidateStringsFromDictionary(LPWSTR lpString, LPWSTR lpBuf, DWORD dwBufLen, LPTSTR szDicFileName);
#endif

/**********************************************************************/
/*      ImeInquire()                                                  */
/*                                                                    */
/**********************************************************************/
BOOL WINAPI ImeInquire(LPIMEINFO lpIMEInfo,LPTSTR lpszClassName,DWORD dwSystemInfoFlags)
{
    ImeLog(LOGF_ENTRY | LOGF_API, TEXT("ImeInquire"));

    // Init IMEINFO Structure.
    lpIMEInfo->dwPrivateDataSize = sizeof(UIEXTRA);
    lpIMEInfo->fdwProperty = IME_PROP_KBD_CHAR_FIRST |
#if defined(FAKEIMEM) || defined(UNICODE)
                             IME_PROP_UNICODE |
#endif
                             IME_PROP_AT_CARET;
    lpIMEInfo->fdwConversionCaps = IME_CMODE_LANGUAGE |
                                IME_CMODE_FULLSHAPE |
                                IME_CMODE_ROMAN |
                                IME_CMODE_CHARCODE;
    lpIMEInfo->fdwSentenceCaps = 0L;
    lpIMEInfo->fdwUICaps = UI_CAP_2700;

    lpIMEInfo->fdwSCSCaps = SCS_CAP_COMPSTR |
                            SCS_CAP_MAKEREAD |
                            SCS_CAP_SETRECONVERTSTRING;

    lpIMEInfo->fdwSelectCaps = SELECT_CAP_CONVERSION;

#ifdef FAKEIMEM
    memcpy((LPWSTR)lpszClassName,(LPWSTR)wszUIClassName,
                   (lstrlenW((LPWSTR)wszUIClassName) + 1) * sizeof(WCHAR));
#else
    lstrcpy(lpszClassName,(LPTSTR)szUIClassName);
#endif


    return TRUE;
}

/**********************************************************************/
/*      ImeConversionList()                                           */
/*                                                                    */
/**********************************************************************/
DWORD WINAPI ImeConversionList(HIMC hIMC,LPCTSTR lpSource,LPCANDIDATELIST lpCandList,DWORD dwBufLen,UINT uFlags)
{
    ImeLog(LOGF_API, TEXT("ImeConversionList"));


    return 0;
}

/**********************************************************************/
/*      ImeDestroy()                                                  */
/*                                                                    */
/**********************************************************************/
BOOL WINAPI ImeDestroy(UINT uForce)
{
    ImeLog(LOGF_ENTRY | LOGF_API, TEXT("ImeDestroy"));

    return TRUE;
}

/**********************************************************************/
/*      ImeEscape()                                                   */
/*                                                                    */
/**********************************************************************/
LRESULT WINAPI ImeEscape(HIMC hIMC,UINT uSubFunc,LPVOID lpData)
{
    LRESULT lRet = FALSE;

    ImeLog(LOGF_API, TEXT("ImeEscape"));

    switch (uSubFunc)
    {
        case IME_ESC_QUERY_SUPPORT:
            switch (*(LPUINT)lpData)
            {
                case IME_ESC_QUERY_SUPPORT:
                case IME_ESC_PRI_GETDWORDTEST:
                case IME_ESC_GETHELPFILENAME:
                    lRet = TRUE;
                    break;

                default:
                    lRet = FALSE;
                    break;
            }
            break;

        case IME_ESC_PRI_GETDWORDTEST:
            lRet = 0x12345678;
            break;

        case IME_ESC_GETHELPFILENAME:
            Mylstrcpy((LPMYSTR)lpData, MYTEXT("fakeime.hlp"));
            lRet = TRUE;
            break;

        default:
            lRet = FALSE;
            break;
    }

    return lRet;
}

/**********************************************************************/
/*      ImeSetActiveContext()                                         */
/*                                                                    */
/**********************************************************************/
BOOL WINAPI ImeSetActiveContext(HIMC hIMC,BOOL fFlag)
{
    ImeLog(LOGF_API, TEXT("ImeSetActiveContext"));

    UpdateIndicIcon(hIMC);

    return TRUE;
}

/**********************************************************************/
/*      ImeProcessKey()                                               */
/*                                                                    */
/**********************************************************************/
BOOL WINAPI ImeProcessKey(HIMC hIMC,UINT vKey,LPARAM lKeyData,CONST LPBYTE lpbKeyState)
{
    BOOL fRet = FALSE;
    BOOL fOpen;
    BOOL fCompStr = FALSE;
    LPINPUTCONTEXT lpIMC;
    LPCOMPOSITIONSTRING lpCompStr;

    ImeLog(LOGF_KEY | LOGF_API, TEXT("ImeProcessKey"));


    if (lKeyData & 0x80000000)
        return FALSE;

    if (!(lpIMC = ImmLockIMC(hIMC)))
        return FALSE;

    fOpen = lpIMC->fOpen;

    if (fOpen)
    {
        if (lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr))
        {
            if ((lpCompStr->dwSize > sizeof(COMPOSITIONSTRING)) &&
                (lpCompStr->dwCompStrLen))
                fCompStr = TRUE;
        }

        if (lpbKeyState[VK_MENU] & 0x80)
        {
            fRet = FALSE;
        }
        else if (lpbKeyState[VK_CONTROL] & 0x80)
        {
            if (fCompStr)
                fRet = (BOOL)bCompCtl[vKey];
            else
                fRet = (BOOL)bNoCompCtl[vKey];
        }
        else if (lpbKeyState[VK_SHIFT] & 0x80)
        {
            if (fCompStr)
                fRet = (BOOL)bCompSht[vKey];
            else
                fRet = (BOOL)bNoCompSht[vKey];
        }
        else
        {
            if (fCompStr)
                fRet = (BOOL)bComp[vKey];
            else
                fRet = (BOOL)bNoComp[vKey];
        }

        if (lpCompStr)
            ImmUnlockIMCC(lpIMC->hCompStr);
    }

    ImmUnlockIMC(hIMC);
    return fRet;
}

/**********************************************************************/
/*      NotifyIME()                                                   */
/*                                                                    */
/**********************************************************************/
BOOL WINAPI NotifyIME(HIMC hIMC,DWORD dwAction,DWORD dwIndex,DWORD dwValue)
{
    LPINPUTCONTEXT      lpIMC;
    BOOL                bRet = FALSE;
    LPCOMPOSITIONSTRING lpCompStr;
    LPCANDIDATEINFO     lpCandInfo;
    LPCANDIDATELIST     lpCandList;
    MYCHAR              szBuf[256];
    int                 nBufLen;
    LPMYSTR             lpstr;
    TRANSMSG             GnMsg;
    int                 i = 0;
    LPDWORD             lpdw;

    ImeLog(LOGF_API, TEXT("NotifyIME"));

    switch(dwAction)
    {

        case NI_CONTEXTUPDATED:
             switch (dwValue)
             {
                 case IMC_SETOPENSTATUS:
                     lpIMC = ImmLockIMC(hIMC);
                     if (lpIMC)
                     {
                         if (!lpIMC->fOpen && IsCompStr(hIMC))
                             FlushText(hIMC);
                         ImmUnlockIMC(hIMC);
                     }
                     UpdateIndicIcon(hIMC);
                     bRet = TRUE;
                     break;

                 case IMC_SETCONVERSIONMODE:
                     break;

                 case IMC_SETCOMPOSITIONWINDOW:
                     break;

                 default:
                     break;
             }
             break;

        case NI_COMPOSITIONSTR:
             switch (dwIndex)
             {
                 case CPS_COMPLETE:
                     MakeResultString(hIMC,TRUE);
                     bRet = TRUE;
                     break;

                 case CPS_CONVERT:
                     ConvKanji(hIMC);
                     bRet = TRUE;
                     break;

                 case CPS_REVERT:
                     RevertText(hIMC);
                     bRet = TRUE;
                     break;

                 case CPS_CANCEL:
                     FlushText(hIMC);
                     bRet = TRUE;
                     break;

                 default:
                     break;
             }
             break;

        case  NI_OPENCANDIDATE:
             if (IsConvertedCompStr(hIMC))
             {

                 if (!(lpIMC = ImmLockIMC(hIMC)))
                     return FALSE;

                 if (!(lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr)))
                 {
                     ImmUnlockIMC(hIMC);
                     return FALSE;
                 }

                 if (lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo))
                 {

                     //
                     // Get the candidate strings from dic file.
                     //
#if defined(FAKEIMEM) || defined(UNICODE)
                     nBufLen = GetCandidateStringsFromDictionary(GETLPCOMPREADSTR(lpCompStr),
                                                                 (LPMYSTR)szBuf,256,
                                                                 (LPTSTR)szDicFileName );
#else
                     nBufLen = GetPrivateProfileString(GETLPCOMPREADSTR(lpCompStr),
                            NULL,(LPSTR)"",
                            (LPSTR)szBuf,256,(LPSTR)szDicFileName );
#endif

                     //
                     // generate WM_IME_NOTFIY IMN_OPENCANDIDATE message.
                     //
                     GnMsg.message = WM_IME_NOTIFY;
                     GnMsg.wParam = IMN_OPENCANDIDATE;
                     GnMsg.lParam = 1L;
                     GenerateMessage(hIMC, lpIMC, lpCurTransKey,(LPTRANSMSG)&GnMsg);

                     //
                     // Make candidate structures.
                     //
                     lpCandInfo->dwSize = sizeof(MYCAND);
                     lpCandInfo->dwCount = 1;
                     lpCandInfo->dwOffset[0] =
                           (DWORD)((LPSTR)&((LPMYCAND)lpCandInfo)->cl - (LPSTR)lpCandInfo);
                     lpCandList = (LPCANDIDATELIST)((LPSTR)lpCandInfo  + lpCandInfo->dwOffset[0]);
                     lpdw = (LPDWORD)&(lpCandList->dwOffset);

                     lpstr = &szBuf[0];
                     while (*lpstr && (i < MAXCANDSTRNUM))
                     {
                         lpCandList->dwOffset[i] =
                                (DWORD)((LPSTR)((LPMYCAND)lpCandInfo)->szCand[i] - (LPSTR)lpCandList);
                         Mylstrcpy((LPMYSTR)((LPMYSTR)lpCandList+lpCandList->dwOffset[i]),lpstr);
                         lpstr += (Mylstrlen(lpstr) + 1);
                         i++;
                     }

                     lpCandList->dwSize = sizeof(CANDIDATELIST) +
                          (MAXCANDSTRNUM * (sizeof(DWORD) + MAXCANDSTRSIZE));
                     lpCandList->dwStyle = IME_CAND_READ;
                     lpCandList->dwCount = i;
                     lpCandList->dwPageStart = 0;
                     if (i < MAXCANDPAGESIZE)
                         lpCandList->dwPageSize  = i;
                     else
                         lpCandList->dwPageSize  = MAXCANDPAGESIZE;

                     lpCandList->dwSelection++;
                     if (lpCandList->dwSelection == (DWORD)i)
                         lpCandList->dwSelection = 0;

                     //
                     // Generate messages.
                     //
                     GnMsg.message = WM_IME_NOTIFY;
                     GnMsg.wParam = IMN_CHANGECANDIDATE;
                     GnMsg.lParam = 1L;
                     GenerateMessage(hIMC, lpIMC, lpCurTransKey,(LPTRANSMSG)&GnMsg);

                     ImmUnlockIMCC(lpIMC->hCandInfo);
                     ImmUnlockIMC(hIMC);

                     bRet = TRUE;
                 }
             }
             break;

        case  NI_CLOSECANDIDATE:
             if (!(lpIMC = ImmLockIMC(hIMC)))
                 return FALSE;
             if (IsCandidate(lpIMC))
             {
                 GnMsg.message = WM_IME_NOTIFY;
                 GnMsg.wParam = IMN_CLOSECANDIDATE;
                 GnMsg.lParam = 1L;
                 GenerateMessage(hIMC, lpIMC, lpCurTransKey,(LPTRANSMSG)&GnMsg);
                 bRet = TRUE;
             }
             ImmUnlockIMC(hIMC);
             break;

        case  NI_SELECTCANDIDATESTR:
             if (!(lpIMC = ImmLockIMC(hIMC)))
                 return FALSE;

             if (dwIndex == 1 && IsCandidate(lpIMC))
             {

                 if (lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo))
                 {

                     lpCandList = (LPCANDIDATELIST)((LPSTR)lpCandInfo  + lpCandInfo->dwOffset[0]);
                     if (lpCandList->dwCount > dwValue)
                     {
                         lpCandList->dwSelection = dwValue;
                         bRet = TRUE;

                         //
                         // Generate messages.
                         //
                         GnMsg.message = WM_IME_NOTIFY;
                         GnMsg.wParam = IMN_CHANGECANDIDATE;
                         GnMsg.lParam = 1L;
                         GenerateMessage(hIMC, lpIMC, lpCurTransKey,(LPTRANSMSG)&GnMsg);
                     }
                     ImmUnlockIMCC(lpIMC->hCandInfo);

                 }
             }
             ImmUnlockIMC(hIMC);
             break;

        case  NI_CHANGECANDIDATELIST:
             if (!(lpIMC = ImmLockIMC(hIMC)))
                return FALSE;

             if (dwIndex == 1 && IsCandidate(lpIMC))
                 bRet = TRUE;

             ImmUnlockIMC(hIMC);
             break;

        case NI_SETCANDIDATE_PAGESIZE:
             if (!(lpIMC = ImmLockIMC(hIMC)))
                return FALSE;

             if (dwIndex == 1 && IsCandidate(lpIMC))
             {
                 if (dwValue > MAXCANDPAGESIZE)
                     return FALSE;


                 if (lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo))
                 {
                     lpCandList = (LPCANDIDATELIST)((LPSTR)lpCandInfo  + lpCandInfo->dwOffset[0]);
                     if (lpCandList->dwCount > dwValue)
                     {
                         lpCandList->dwPageSize = dwValue;
                         bRet = TRUE;

                         //
                         // Generate messages.
                         //
                         GnMsg.message = WM_IME_NOTIFY;
                         GnMsg.wParam = IMN_CHANGECANDIDATE;
                         GnMsg.lParam = 1L;
                         GenerateMessage(hIMC, lpIMC, lpCurTransKey,(LPTRANSMSG)&GnMsg);
                     }
                     ImmUnlockIMCC(lpIMC->hCandInfo);
                 }
             }
             ImmUnlockIMC(hIMC);
             break;

        case NI_SETCANDIDATE_PAGESTART:
             if (!(lpIMC = ImmLockIMC(hIMC)))
                 return FALSE;

             if (dwIndex == 1 && IsCandidate(lpIMC))
             {
                 if (dwValue > MAXCANDPAGESIZE)
                     return FALSE;


                 if (lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo))
                 {
                     lpCandList = (LPCANDIDATELIST)((LPSTR)lpCandInfo  + lpCandInfo->dwOffset[0]);
                     if (lpCandList->dwCount > dwValue)
                     {
                         lpCandList->dwPageStart = dwValue;
                         bRet = TRUE;

                         //
                         // Generate messages.
                         //
                         GnMsg.message = WM_IME_NOTIFY;
                         GnMsg.wParam = IMN_CHANGECANDIDATE;
                         GnMsg.lParam = 1L;
                         GenerateMessage(hIMC, lpIMC, lpCurTransKey,(LPTRANSMSG)&GnMsg);
                     }
                     ImmUnlockIMCC(lpIMC->hCandInfo);

                 }
             }
             ImmUnlockIMC(hIMC);
             break;

        case NI_IMEMENUSELECTED:
#ifdef DEBUG
             {
             TCHAR szDev[80];
             OutputDebugString((LPTSTR)TEXT("NotifyIME IMEMENUSELECTED\r\n"));
             wsprintf((LPTSTR)szDev,TEXT("\thIMC is 0x%x\r\n"),hIMC);
             OutputDebugString((LPTSTR)szDev);
             wsprintf((LPTSTR)szDev,TEXT("\tdwIndex is 0x%x\r\n"),dwIndex);
             OutputDebugString((LPTSTR)szDev);
             wsprintf((LPTSTR)szDev,TEXT("\tdwValue is 0x%x\r\n"),dwValue);
             OutputDebugString((LPTSTR)szDev);
             }
#endif
             break;

        default:
             break;
    }
    return bRet;
}

/**********************************************************************/
/*      ImeSelect()                                                   */
/*                                                                    */
/**********************************************************************/
BOOL WINAPI ImeSelect(HIMC hIMC, BOOL fSelect)
{
    LPINPUTCONTEXT lpIMC;

    ImeLog(LOGF_ENTRY | LOGF_API, TEXT("ImeSelect"));

    if (fSelect)
        UpdateIndicIcon(hIMC);

    // it's NULL context.
    if (!hIMC)
        return TRUE;

    if (lpIMC = ImmLockIMC(hIMC))
    {
        if (fSelect)
        {
            LPCOMPOSITIONSTRING lpCompStr;
            LPCANDIDATEINFO lpCandInfo;

            // Init the general member of IMC.
            if (!(lpIMC->fdwInit & INIT_LOGFONT))
            {
                lpIMC->lfFont.A.lfCharSet = SHIFTJIS_CHARSET;
                lpIMC->fdwInit |= INIT_LOGFONT;
            }


            if (!(lpIMC->fdwInit & INIT_CONVERSION))
            {
                lpIMC->fdwConversion = IME_CMODE_ROMAN | IME_CMODE_FULLSHAPE | IME_CMODE_NATIVE;
                lpIMC->fdwInit |= INIT_CONVERSION;
            }

            lpIMC->hCompStr = ImmReSizeIMCC(lpIMC->hCompStr,sizeof(MYCOMPSTR));
            if (lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr))
            {
                lpCompStr->dwSize = sizeof(MYCOMPSTR);
                ImmUnlockIMCC(lpIMC->hCompStr);
            }
            lpIMC->hCandInfo = ImmReSizeIMCC(lpIMC->hCandInfo,sizeof(MYCAND));
            if (lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo))
            {
                lpCandInfo->dwSize = sizeof(MYCAND);
                ImmUnlockIMCC(lpIMC->hCandInfo);
            }
        }
    }

    ImmUnlockIMC(hIMC);
    return TRUE;
}

#ifdef DEBUG
void DumpRS(LPRECONVERTSTRING lpRS)
{
    TCHAR szDev[80];
    LPMYSTR lpDump= ((LPMYSTR)lpRS) + lpRS->dwStrOffset;
    *(LPMYSTR)(lpDump + lpRS->dwStrLen) = MYTEXT('\0');

    OutputDebugString(TEXT("DumpRS\r\n"));
    wsprintf(szDev, TEXT("dwSize            %x\r\n"), lpRS->dwSize);
    OutputDebugString(szDev);
    wsprintf(szDev, TEXT("dwStrLen          %x\r\n"), lpRS->dwStrLen);
    OutputDebugString(szDev);
    wsprintf(szDev, TEXT("dwStrOffset       %x\r\n"), lpRS->dwStrOffset);
    OutputDebugString(szDev);
    wsprintf(szDev, TEXT("dwCompStrLen      %x\r\n"), lpRS->dwCompStrLen);
    OutputDebugString(szDev);
    wsprintf(szDev, TEXT("dwCompStrOffset   %x\r\n"), lpRS->dwCompStrOffset);
    OutputDebugString(szDev);
    wsprintf(szDev, TEXT("dwTargetStrLen    %x\r\n"), lpRS->dwTargetStrLen);
    OutputDebugString(szDev);
    wsprintf(szDev, TEXT("dwTargetStrOffset %x\r\n"), lpRS->dwTargetStrOffset);
    OutputDebugString(szDev);
    MyOutputDebugString(lpDump);
    OutputDebugString(TEXT("\r\n"));
}
#endif

/**********************************************************************/
/*      ImeSetCompositionString()                                     */
/*                                                                    */
/**********************************************************************/
BOOL WINAPI ImeSetCompositionString(HIMC hIMC, DWORD dwIndex, LPVOID lpComp, DWORD dwComp, LPVOID lpRead, DWORD dwRead)
{
    ImeLog(LOGF_API, TEXT("ImeSetCompositionString"));

    switch (dwIndex)
    {
        case SCS_QUERYRECONVERTSTRING:
#ifdef DEBUG
            OutputDebugString(TEXT("SCS_QUERYRECONVERTSTRING\r\n"));
            if (lpComp)
                DumpRS((LPRECONVERTSTRING)lpComp);
            if (lpRead)
                DumpRS((LPRECONVERTSTRING)lpRead);
#endif
            break;

        case SCS_SETRECONVERTSTRING:
#ifdef DEBUG
            OutputDebugString(TEXT("SCS_SETRECONVERTSTRING\r\n"));
            if (lpComp)
                DumpRS((LPRECONVERTSTRING)lpComp);
            if (lpRead)
                DumpRS((LPRECONVERTSTRING)lpRead);
#endif
            break;
    }

    return FALSE;
}

/**********************************************************************/
/*      ImeGetImeMenuItemInfo()                                       */
/*                                                                    */
/**********************************************************************/
DWORD WINAPI ImeGetImeMenuItems(HIMC hIMC, DWORD dwFlags, DWORD dwType, LPMYIMEMENUITEMINFO lpImeParentMenu, LPMYIMEMENUITEMINFO lpImeMenu, DWORD dwSize)
{
    ImeLog(LOGF_API, TEXT("ImeGetImeMenuItems"));


    if (!lpImeMenu)
    {
        if (!lpImeParentMenu)
        {
            if (dwFlags & IGIMIF_RIGHTMENU)
                return NUM_ROOT_MENU_R;
            else
                return NUM_ROOT_MENU_L;
        }
        else
        {
            if (dwFlags & IGIMIF_RIGHTMENU)
                return NUM_SUB_MENU_R;
            else
                return NUM_SUB_MENU_L;
        }

        return 0;
    }

    if (!lpImeParentMenu)
    {
        if (dwFlags & IGIMIF_RIGHTMENU)
        {
            lpImeMenu->cbSize = sizeof(IMEMENUITEMINFO);
            lpImeMenu->fType = 0;
            lpImeMenu->fState = 0;
            lpImeMenu->wID = IDIM_ROOT_MR_1;
            lpImeMenu->hbmpChecked = 0;
            lpImeMenu->hbmpUnchecked = 0;
            Mylstrcpy(lpImeMenu->szString, MYTEXT("RootRightMenu1"));
            lpImeMenu->hbmpItem = 0;

            lpImeMenu++;
            lpImeMenu->cbSize = sizeof(IMEMENUITEMINFO);
            lpImeMenu->fType = IMFT_SUBMENU;
            lpImeMenu->fState = 0;
            lpImeMenu->wID = IDIM_ROOT_MR_2;
            lpImeMenu->hbmpChecked = 0;
            lpImeMenu->hbmpUnchecked = 0;
            Mylstrcpy(lpImeMenu->szString, MYTEXT("RootRightMenu2"));
            lpImeMenu->hbmpItem = 0;

            lpImeMenu++;
            lpImeMenu->cbSize = sizeof(IMEMENUITEMINFO);
            lpImeMenu->fType = 0;
            lpImeMenu->fState = 0;
            lpImeMenu->wID = IDIM_ROOT_MR_3;
            lpImeMenu->hbmpChecked = 0;
            lpImeMenu->hbmpUnchecked = 0;
            Mylstrcpy(lpImeMenu->szString, MYTEXT("RootRightMenu3"));
            lpImeMenu->hbmpItem = 0;

            return NUM_ROOT_MENU_R;
        }
        else
        {
            lpImeMenu->cbSize = sizeof(IMEMENUITEMINFO);
            lpImeMenu->fType = 0;
            lpImeMenu->fState = 0;
            lpImeMenu->wID = IDIM_ROOT_ML_1;
            lpImeMenu->hbmpChecked = 0;
            lpImeMenu->hbmpUnchecked = 0;
            Mylstrcpy(lpImeMenu->szString, MYTEXT("RootLeftMenu1"));
            lpImeMenu->hbmpItem = 0;

            lpImeMenu++;
            lpImeMenu->cbSize = sizeof(IMEMENUITEMINFO);
            lpImeMenu->fType = IMFT_SUBMENU;
            lpImeMenu->fState = 0;
            lpImeMenu->wID = IDIM_ROOT_ML_2;
            lpImeMenu->hbmpChecked = 0;
            lpImeMenu->hbmpUnchecked = 0;
            Mylstrcpy(lpImeMenu->szString, MYTEXT("RootLeftMenu2"));
            lpImeMenu->hbmpItem = 0;

            lpImeMenu++;
            lpImeMenu->cbSize = sizeof(IMEMENUITEMINFO);
            lpImeMenu->fType = 0;
            lpImeMenu->fState = 0;
            lpImeMenu->wID = IDIM_ROOT_ML_3;
            lpImeMenu->hbmpChecked = 0;
            lpImeMenu->hbmpUnchecked = 0;
            Mylstrcpy(lpImeMenu->szString, MYTEXT("RootLeftMenu3"));
            lpImeMenu->hbmpItem = LoadBitmap(hInst,TEXT("FACEBMP"));

            return NUM_ROOT_MENU_L;
        }
    }
    else
    {
        if (dwFlags & IGIMIF_RIGHTMENU)
        {
            lpImeMenu->cbSize = sizeof(IMEMENUITEMINFO);
            lpImeMenu->fType = 0;
            lpImeMenu->fState = 0;
            lpImeMenu->wID = IDIM_SUB_MR_1;
            lpImeMenu->hbmpChecked = 0;
            lpImeMenu->hbmpUnchecked = 0;
            Mylstrcpy(lpImeMenu->szString, MYTEXT("SubRightMenu1"));
            lpImeMenu->hbmpItem = 0;

            lpImeMenu++;
            lpImeMenu->cbSize = sizeof(IMEMENUITEMINFO);
            lpImeMenu->fType = 0;
            lpImeMenu->fState = 0;
            lpImeMenu->wID = IDIM_SUB_MR_2;
            lpImeMenu->hbmpChecked = 0;
            lpImeMenu->hbmpUnchecked = 0;
            Mylstrcpy(lpImeMenu->szString, MYTEXT("SubRightMenu2"));
            lpImeMenu->hbmpItem = 0;

            return NUM_SUB_MENU_R;
        }
        else
        {
            lpImeMenu->cbSize = sizeof(IMEMENUITEMINFO);
            lpImeMenu->fType = 0;
            lpImeMenu->fState = IMFS_CHECKED;
            lpImeMenu->wID = IDIM_SUB_ML_1;
            lpImeMenu->hbmpChecked = 0;
            lpImeMenu->hbmpUnchecked = 0;
            Mylstrcpy(lpImeMenu->szString, MYTEXT("SubLeftMenu1"));
            lpImeMenu->hbmpItem = 0;

            lpImeMenu++;
            lpImeMenu->cbSize = sizeof(IMEMENUITEMINFO);
            lpImeMenu->fType = 0;
            lpImeMenu->fState = IMFS_CHECKED;
            lpImeMenu->wID = IDIM_SUB_ML_2;
            lpImeMenu->hbmpChecked = LoadBitmap(hInst,TEXT("CHECKBMP"));
            lpImeMenu->hbmpUnchecked = LoadBitmap(hInst,TEXT("UNCHECKBMP"));
            Mylstrcpy(lpImeMenu->szString, MYTEXT("SubLeftMenu2"));
            lpImeMenu->hbmpItem = 0;

            return NUM_SUB_MENU_L;
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\ddk\jpn\input.c ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation, All Rights Reserved

Module Name:

    INPUT.C
    
++*/

/**********************************************************************/
#include "windows.h"
#include "immdev.h"
#include "fakeime.h"

/**********************************************************************/
/*                                                                    */
/* IMEKeydownHandler()                                                */
/*                                                                    */
/* A function which handles WM_IMEKEYDOWN                             */
/*                                                                    */
/**********************************************************************/
BOOL PASCAL IMEKeydownHandler( hIMC, wParam, lParam,lpbKeyState)
HIMC hIMC;
WPARAM wParam;
LPARAM lParam;
LPBYTE lpbKeyState;
{
    WORD wVKey;


    switch( wVKey = ( LOWORD(wParam) & 0x00FF ) ){
        case VK_SHIFT:
        case VK_CONTROL:
            //goto not_proccessed;
            break;

        default:
            if( !DicKeydownHandler( hIMC, wVKey, lParam, lpbKeyState ) ) {
                // This WM_IMEKEYDOWN has actual character code in itself.
#if defined(FAKEIMEM) || defined(UNICODE)
                AddChar( hIMC,  HIWORD(wParam));
#else
                AddChar( hIMC,  (WORD)((BYTE)HIBYTE(wParam)));
#endif
                //CharHandler( hIMC,  (WORD)((BYTE)HIBYTE(wParam)), lParam );
            }
            break;
    }
    return TRUE;
}

/**********************************************************************/
/*                                                                    */
/* IMEKeyupHandler()                                                  */
/*                                                                    */
/* A function which handles WM_IMEKEYUP                               */
/*                                                                    */
/**********************************************************************/
BOOL PASCAL IMEKeyupHandler( hIMC, wParam, lParam ,lpbKeyState)
HIMC hIMC;
WPARAM wParam;
LPARAM lParam;
LPBYTE lpbKeyState;
{
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\ddk\jpn\immsec.c ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation, All Rights Reserved

Module Name:

    IMMSEC.C
    
Abstract:

    security code called by IMEs 

Author:

    Takao Kitano [takaok] 01-May-1996

Revision History:

++*/

#include <windows.h>
#include <stdio.h>
#include "immsec.h"

#define MEMALLOC(x)      LocalAlloc(LMEM_FIXED, x)
#define MEMFREE(x)       LocalFree(x)

//
// internal functions
//
PSID MyCreateSid();
POSVERSIONINFO GetVersionInfo();

//
// debug functions
//
#ifdef DEBUG
#define ERROROUT(x)      ErrorOut( x )
#define WARNOUT(x)       WarnOut( x )
#else
#define ERROROUT(x) 
#define WARNOUT(x)       
#endif

#ifdef DEBUG
VOID WarnOut( PTSTR pStr )
{
    OutputDebugString( pStr );
}

VOID ErrorOut( PTSTR pStr )
{
    DWORD dwError;
    DWORD dwResult;
    TCHAR buf1[512];
    TCHAR buf2[512];

    dwError = GetLastError();
    dwResult = FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM,
                              NULL,
                              dwError,
                              MAKELANGID( LANG_ENGLISH, LANG_NEUTRAL ),
                              buf1,
                              512,
                              NULL );                                   
    
    if ( dwResult > 0 ) {
        wsprintf( buf2, TEXT("%s:%s(0x%x)"), pStr, buf1, dwError);
    } else {
        wsprintf( buf2, TEXT("%s:(0x%x)"), pStr, dwError);
    }
    OutputDebugString( buf2 );
}
#endif


//
// CreateSecurityAttributes()
//
// The purpose of this function:
//
//      Allocate and set the security attributes that is 
//      appropriate for named objects created by an IME.
//      The security attributes will give GENERIC_ALL
//      access for everyone
//      
//
// Return value:
//
//      If the function succeeds, the return value is a 
//      pointer to SECURITY_ATTRIBUTES. If the function fails,
//      the return value is NULL. To get extended error 
//      information, call GetLastError().
//
// Remarks:
//
//      FreeSecurityAttributes() should be called to free up the
//      SECURITY_ATTRIBUTES allocated by this function.
//
PSECURITY_ATTRIBUTES CreateSecurityAttributes()
{
    PSECURITY_ATTRIBUTES psa;
    PSECURITY_DESCRIPTOR psd;
    PACL                 pacl;
    DWORD                cbacl;

    PSID                 psid;
    BOOL                 fResult;

    INT                  i,j;

    if (!IsNT())
        return NULL;

    //
    // create a sid for everyone access
    //
    psid = MyCreateSid();
    if ( psid == NULL ) {
        return NULL;
    } 

    //
    // allocate and initialize an access control list (ACL) that will 
    // contain the SID we've just created.
    //
    cbacl =  sizeof(ACL) + 
             (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) + 
             GetLengthSid(psid);

    pacl = MEMALLOC( cbacl );
    if ( pacl == NULL ) {
        ERROROUT( TEXT("CreateSecurityAttributes:LocalAlloc for ACL failed") );
        FreeSid ( psid );
        return NULL;
    }

    fResult = InitializeAcl( pacl, cbacl, ACL_REVISION );
    if ( ! fResult ) {
        ERROROUT( TEXT("CreateSecurityAttributes:InitializeAcl failed") );
        FreeSid ( psid );
        MEMFREE( pacl );
        return NULL;
    }

    //
    // adds an access-allowed ACE for interactive users to the ACL
    // 
    fResult = AddAccessAllowedAce( pacl,
                                   ACL_REVISION,
                                   GENERIC_ALL,
                                   psid );

    if ( !fResult ) {
        ERROROUT( TEXT("CreateSecurityAttributes:AddAccessAllowedAce failed") );
        MEMFREE( pacl );
        FreeSid ( psid );
        return NULL;
    }


    //
    // Those SIDs have been copied into the ACL. We don't need'em any more.
    //
    FreeSid ( psid );

    //
    // Let's make sure that our ACL is valid.
    //
    if (!IsValidAcl(pacl)) {
        WARNOUT( TEXT("CreateSecurityAttributes:IsValidAcl returns FALSE!"));
        MEMFREE( pacl );
        return NULL;
    }

    //
    // allocate security attribute
    //
    psa = (PSECURITY_ATTRIBUTES)MEMALLOC( sizeof( SECURITY_ATTRIBUTES ) );
    if ( psa == NULL ) {
        ERROROUT( TEXT("CreateSecurityAttributes:LocalAlloc for psa failed") );
        MEMFREE( pacl );
        return NULL;
    }
    
    //
    // allocate and initialize a new security descriptor
    //
    psd = MEMALLOC( SECURITY_DESCRIPTOR_MIN_LENGTH );
    if ( psd == NULL ) {
        ERROROUT( TEXT("CreateSecurityAttributes:LocalAlloc for psd failed") );
        MEMFREE( pacl );
        MEMFREE( psa );
        return NULL;
    }

    if ( ! InitializeSecurityDescriptor( psd, SECURITY_DESCRIPTOR_REVISION ) ) {
        ERROROUT( TEXT("CreateSecurityAttributes:InitializeSecurityDescriptor failed") );
        MEMFREE( pacl );
        MEMFREE( psa );
        MEMFREE( psd );
        return NULL;
    }


    fResult = SetSecurityDescriptorDacl( psd,
                                         TRUE,
                                         pacl,
                                         FALSE );

    // The discretionary ACL is referenced by, not copied 
    // into, the security descriptor. We shouldn't free up ACL
    // after the SetSecurityDescriptorDacl call. 

    if ( ! fResult ) {
        ERROROUT( TEXT("CreateSecurityAttributes:SetSecurityDescriptorDacl failed") );
        MEMFREE( pacl );
        MEMFREE( psa );
        MEMFREE( psd );
        return NULL;
    } 


    if (!IsValidSecurityDescriptor(psd)) {
        WARNOUT( TEXT("CreateSecurityAttributes:IsValidSecurityDescriptor failed!") );
        MEMFREE( pacl );
        MEMFREE( psa );
        MEMFREE( psd );
        return NULL;
    }

    //
    // everything is done
    //
    psa->nLength = sizeof( SECURITY_ATTRIBUTES );
    psa->lpSecurityDescriptor = (PVOID)psd;
    psa->bInheritHandle = TRUE;

    return psa;
}

PSID MyCreateSid()
{
    PSID        psid;
    BOOL        fResult;
    SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_WORLD_SID_AUTHORITY;

    //
    // allocate and initialize an SID
    // 
    fResult = AllocateAndInitializeSid( &SidAuthority,
                                        1,
                                        SECURITY_WORLD_RID,
                                        0,0,0,0,0,0,0,
                                        &psid );
    if ( ! fResult ) {
        ERROROUT( TEXT("MyCreateSid:AllocateAndInitializeSid failed") );
        return NULL;
    }

    if ( ! IsValidSid( psid ) ) {
        WARNOUT( TEXT("MyCreateSid:AllocateAndInitializeSid returns bogus sid"));
        FreeSid( psid );
        return NULL;
    }

    return psid;
}

//
// FreeSecurityAttributes()
//
// The purpose of this function:
//
//      Frees the memory objects allocated by previous
//      CreateSecurityAttributes() call.
//
VOID FreeSecurityAttributes( PSECURITY_ATTRIBUTES psa )
{
    BOOL fResult;
    BOOL fDaclPresent;
    BOOL fDaclDefaulted;
    PACL pacl;

    if (psa == NULL)
        return;

    fResult = GetSecurityDescriptorDacl( psa->lpSecurityDescriptor,
                                         &fDaclPresent,
                                         &pacl,
                                         &fDaclDefaulted );                  
    if ( fResult ) {
        if ( pacl != NULL )
            MEMFREE( pacl );
    } else {
        ERROROUT( TEXT("FreeSecurityAttributes:GetSecurityDescriptorDacl failed") );
    }

    MEMFREE( psa->lpSecurityDescriptor );
    MEMFREE( psa );
}

//
// IsNT()
//
// Return value:
//
//      TRUE if the current system is Windows NT
//
// Remarks:
//
//      The implementation of this function is not multi-thread safe.
//      You need to modify the function if you call the function in 
//      multi-thread environment.
//
BOOL IsNT()
{
    return GetVersionInfo()->dwPlatformId == VER_PLATFORM_WIN32_NT;
}

POSVERSIONINFO GetVersionInfo()
{
    static BOOL fFirstCall = TRUE;
    static OSVERSIONINFO os;

    if ( fFirstCall ) {
        os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        if ( GetVersionEx( &os ) ) {
            fFirstCall = FALSE;
        }
    }
    return &os;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\ddk\jpn\uicand.c ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation, All Rights Reserved

Module Name:

    UICAND.C
    
++*/

/**********************************************************************/
#include "windows.h"
#include "immdev.h"
#include "fakeime.h"

int PASCAL GetCompFontHeight(LPUIEXTRA lpUIExtra);

/**********************************************************************/
/*                                                                    */
/* CandWndProc()                                                      */
/* IME UI window procedure                                            */
/*                                                                    */
/**********************************************************************/
LRESULT CALLBACK CandWndProc( hWnd, message, wParam, lParam )
HWND hWnd;
UINT message;
WPARAM wParam;
LPARAM lParam;
{
    HWND hUIWnd;

    switch (message)
    {
        case WM_PAINT:
            PaintCandWindow(hWnd);
            break;

        case WM_SETCURSOR:
        case WM_MOUSEMOVE:
        case WM_LBUTTONUP:
        case WM_RBUTTONUP:
            DragUI(hWnd,message,wParam,lParam);
            if ((message == WM_SETCURSOR) &&
                (HIWORD(lParam) != WM_LBUTTONDOWN) &&
                (HIWORD(lParam) != WM_RBUTTONDOWN)) 
                    return DefWindowProc(hWnd,message,wParam,lParam);
            if ((message == WM_LBUTTONUP) || (message == WM_RBUTTONUP))
                SetWindowLong(hWnd,FIGWL_MOUSE,0L);
            break;

        case WM_MOVE:
            hUIWnd = (HWND)GetWindowLongPtr(hWnd,FIGWL_SVRWND);
            if (IsWindow(hUIWnd))
                SendMessage(hUIWnd,WM_UI_CANDMOVE,wParam,lParam);
            break;

        default:
            if (!MyIsIMEMessage(message))
                return DefWindowProc(hWnd,message,wParam,lParam);
            break;
    }
    return 0L;
}

/**********************************************************************/
/*                                                                    */
/* GetCandPosFromCompWnd()                                            */
/*                                                                    */
/**********************************************************************/
BOOL PASCAL GetCandPosFromCompWnd(LPUIEXTRA lpUIExtra,LPPOINT lppt)
{
    RECT rc;

    if (lpUIExtra->dwCompStyle)
    {
        if (lpUIExtra->uiComp[0].bShow)
        {
            GetWindowRect(lpUIExtra->uiComp[0].hWnd,&rc);
            lppt->x = rc.left;
            lppt->y = rc.bottom+1;
            return TRUE;
        }
    }
    else
    {
        if (lpUIExtra->uiDefComp.bShow)
        {
            GetWindowRect(lpUIExtra->uiDefComp.hWnd,&rc);
            lppt->x = rc.left;
            lppt->y = rc.bottom+1;
            return TRUE;
        }
    }
    return FALSE;
}

/**********************************************************************/
/*                                                                    */
/* GetCandPosFromCompForm()                                           */
/*                                                                    */
/**********************************************************************/
BOOL PASCAL GetCandPosFromCompForm(LPINPUTCONTEXT lpIMC, LPUIEXTRA lpUIExtra,LPPOINT lppt)
{
    if (lpUIExtra->dwCompStyle)
    {
        if (lpIMC && lpIMC->fdwInit & INIT_COMPFORM)
        {
            if (!lpUIExtra->bVertical)
            {
                lppt->x = lpIMC->cfCompForm.ptCurrentPos.x;
                lppt->y = lpIMC->cfCompForm.ptCurrentPos.y +
                                     GetCompFontHeight(lpUIExtra);
            }
            else
            {
                lppt->x = lpIMC->cfCompForm.ptCurrentPos.x -
                                     GetCompFontHeight(lpUIExtra);
                lppt->y = lpIMC->cfCompForm.ptCurrentPos.y;
            }
            return TRUE;
        }
    }
    else
    {
        if (GetCandPosFromCompWnd(lpUIExtra,lppt))
        {
            ScreenToClient(lpIMC->hWnd,lppt);
            return TRUE;
        }
    }
    return FALSE;
}

/**********************************************************************/
/*                                                                    */
/* CreateCandWindow()                                                 */
/*                                                                    */
/**********************************************************************/
void PASCAL CreateCandWindow( HWND hUIWnd,LPUIEXTRA lpUIExtra, LPINPUTCONTEXT lpIMC )
{
    POINT pt;

    if (GetCandPosFromCompWnd(lpUIExtra,&pt))
    {
        lpUIExtra->uiCand.pt.x = pt.x;
        lpUIExtra->uiCand.pt.y = pt.y;
    }

    if (!IsWindow(lpUIExtra->uiCand.hWnd))
    {
        lpUIExtra->uiCand.hWnd = 
                CreateWindowEx(WS_EX_WINDOWEDGE,
                             (LPTSTR)szCandClassName,NULL,
                             WS_COMPDEFAULT | WS_DLGFRAME,
                             lpUIExtra->uiCand.pt.x,
                             lpUIExtra->uiCand.pt.y,
                             1,1,
                             hUIWnd,NULL,hInst,NULL);
    }

    SetWindowLongPtr(lpUIExtra->uiCand.hWnd,FIGWL_SVRWND,(LONG_PTR)hUIWnd);
    ShowWindow(lpUIExtra->uiCand.hWnd, SW_HIDE);
    lpUIExtra->uiCand.bShow = FALSE;

    return;
}

/**********************************************************************/
/*                                                                    */
/* PaintCandWindow()                                                  */
/*                                                                    */
/**********************************************************************/
void PASCAL PaintCandWindow( HWND hCandWnd)
{
    PAINTSTRUCT ps;
    HIMC hIMC;
    LPINPUTCONTEXT lpIMC;
    LPCANDIDATEINFO lpCandInfo;
    LPCANDIDATELIST lpCandList;
    HBRUSH hbr;
    HDC hDC;
    RECT rc;
    LPMYSTR lpstr;
    int height;
    DWORD i;
    SIZE sz;
    HWND hSvrWnd;
    HBRUSH hbrHightLight = CreateSolidBrush(GetSysColor(COLOR_HIGHLIGHT));
    HBRUSH hbrLGR = GetStockObject(LTGRAY_BRUSH);
    HFONT hOldFont;

    GetClientRect(hCandWnd,&rc);
    hDC = BeginPaint(hCandWnd,&ps);
    SetBkMode(hDC,TRANSPARENT);
    hSvrWnd = (HWND)GetWindowLongPtr(hCandWnd,FIGWL_SVRWND);

    if (hIMC = (HIMC)GetWindowLongPtr(hSvrWnd,IMMGWLP_IMC))
    {
        lpIMC = ImmLockIMC(hIMC);       
        hOldFont = CheckNativeCharset(hDC);
        if (lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo))
        {
            height = GetSystemMetrics(SM_CYEDGE); 
            lpCandList = (LPCANDIDATELIST)((LPSTR)lpCandInfo  + lpCandInfo->dwOffset[0]);
            for (i = lpCandList->dwPageStart; 
                 i < (lpCandList->dwPageStart + lpCandList->dwPageSize); i++)
            {
                lpstr = (LPMYSTR)((LPSTR)lpCandList + lpCandList->dwOffset[i]);
                MyGetTextExtentPoint(hDC,lpstr,Mylstrlen(lpstr),&sz);
                if (((LPMYCAND)lpCandInfo)->cl.dwSelection == (DWORD)i)
                {
                    hbr = SelectObject(hDC,hbrHightLight);
                    PatBlt(hDC,0,height,rc.right,sz.cy,PATCOPY);
                    SelectObject(hDC,hbr);
                    SetTextColor(hDC,GetSysColor(COLOR_HIGHLIGHTTEXT));
                }
                else
                {
                    hbr = SelectObject(hDC,hbrLGR);
                    PatBlt(hDC,0,height,rc.right,sz.cy,PATCOPY);
                    SelectObject(hDC,hbr);
                    SetTextColor(hDC,RGB(0,0,0));
                }
                MyTextOut(hDC,GetSystemMetrics(SM_CXEDGE),height,lpstr,Mylstrlen(lpstr));
                height += sz.cy;
            }
            ImmUnlockIMCC(lpIMC->hCandInfo);
        }
        if (hOldFont) {
            DeleteObject(SelectObject(hDC, hOldFont));
        }
        ImmUnlockIMC(hIMC);
    }
    EndPaint(hCandWnd,&ps);

    DeleteObject(hbrHightLight);
}

/**********************************************************************/
/*                                                                    */
/* ResizeCandWindow()                                                   */
/*                                                                    */
/**********************************************************************/
void PASCAL ResizeCandWindow( LPUIEXTRA lpUIExtra,LPINPUTCONTEXT lpIMC )
{
    LPCANDIDATEINFO lpCandInfo;
    LPCANDIDATELIST lpCandList;
    HDC hDC;
    LPMYSTR lpstr;
    int width;
    int height;
    DWORD i;
    RECT rc;
    SIZE sz;

    if (IsWindow(lpUIExtra->uiCand.hWnd))
    {
        HFONT hOldFont;

        hDC = GetDC(lpUIExtra->uiCand.hWnd);
        hOldFont = CheckNativeCharset(hDC);

        if (lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo))
        {
            width = 0; 
            height = 0; 
            lpCandList = (LPCANDIDATELIST)((LPSTR)lpCandInfo  + lpCandInfo->dwOffset[0]);
            for (i = lpCandList->dwPageStart; 
                 i < (lpCandList->dwPageStart + lpCandList->dwPageSize); i++)
            {
                lpstr = (LPMYSTR)((LPSTR)lpCandList + lpCandList->dwOffset[i]);
                MyGetTextExtentPoint(hDC,lpstr,Mylstrlen(lpstr),&sz);
                if (width < sz.cx)
                    width = sz.cx;
                height += sz.cy;
            }
            ImmUnlockIMCC(lpIMC->hCandInfo);
        }
        if (hOldFont) {
            DeleteObject(SelectObject(hDC, hOldFont));
        }
        ReleaseDC(lpUIExtra->uiCand.hWnd,hDC);
        
        GetWindowRect(lpUIExtra->uiCand.hWnd,&rc);
        MoveWindow(lpUIExtra->uiCand.hWnd,
                       rc.left,
                       rc.top,
                       width+ 4 * GetSystemMetrics(SM_CXEDGE),
                       height+ 4 * GetSystemMetrics(SM_CYEDGE),
                       TRUE);

    }

}

/**********************************************************************/
/*                                                                    */
/* HideCandWindow()                                                   */
/*                                                                    */
/**********************************************************************/
void PASCAL HideCandWindow( LPUIEXTRA lpUIExtra)
{
    RECT rc;

    if (IsWindow(lpUIExtra->uiCand.hWnd))
    {
        GetWindowRect(lpUIExtra->uiCand.hWnd,(LPRECT)&rc);
        lpUIExtra->uiCand.pt.x = rc.left;
        lpUIExtra->uiCand.pt.y = rc.top;
        MoveWindow(lpUIExtra->uiCand.hWnd, -1 , -1 , 0 , 0, TRUE);
        ShowWindow(lpUIExtra->uiCand.hWnd, SW_HIDE);
        lpUIExtra->uiCand.bShow = FALSE;
    }
}

/**********************************************************************/
/*                                                                    */
/* MoveCandWindow()                                                   */
/*                                                                    */
/**********************************************************************/
void PASCAL MoveCandWindow(HWND hUIWnd, LPINPUTCONTEXT lpIMC, LPUIEXTRA lpUIExtra, BOOL fForceComp)
{
    RECT rc;
    POINT pt;
    CANDIDATEFORM caf;

    if (fForceComp)
    {
        if (GetCandPosFromCompForm(lpIMC, lpUIExtra, &pt))
        {
            caf.dwIndex        = 0;
            caf.dwStyle        = CFS_CANDIDATEPOS;
            caf.ptCurrentPos.x = pt.x;
            caf.ptCurrentPos.y = pt.y;
            ImmSetCandidateWindow(lpUIExtra->hIMC,&caf);
        }
        return;
    }

    // Not initialized !!
    if (lpIMC->cfCandForm[0].dwIndex == -1)
    {
        if (GetCandPosFromCompWnd(lpUIExtra,&pt))
        {
            lpUIExtra->uiCand.pt.x = pt.x;
            lpUIExtra->uiCand.pt.y = pt.y;
            GetWindowRect(lpUIExtra->uiCand.hWnd,&rc);
            MoveWindow(lpUIExtra->uiCand.hWnd,pt.x,pt.y, rc.right - rc.left ,rc.bottom - rc.top ,TRUE);
            ShowWindow(lpUIExtra->uiCand.hWnd,SW_SHOWNOACTIVATE);
            lpUIExtra->uiCand.bShow = TRUE;
            InvalidateRect(lpUIExtra->uiCand.hWnd,NULL,FALSE);
            SendMessage(hUIWnd,WM_UI_CANDMOVE, 0,MAKELONG((WORD)pt.x,(WORD)pt.y));
        }
        return;
    }

    if (!IsCandidate(lpIMC))
        return;

    if (lpIMC->cfCandForm[0].dwStyle == CFS_EXCLUDE)
    {
        RECT rcWork;
        RECT rcAppWnd;

        SystemParametersInfo(SPI_GETWORKAREA,0,&rcWork,FALSE);
        GetClientRect(lpUIExtra->uiCand.hWnd,&rc);
        GetWindowRect(lpIMC->hWnd,&rcAppWnd);

        if (!lpUIExtra->bVertical)
        {
            pt.x = lpIMC->cfCandForm[0].ptCurrentPos.x;
            pt.y = lpIMC->cfCandForm[0].rcArea.bottom;
            ClientToScreen(lpIMC->hWnd,&pt);

            if (pt.y + rc.bottom > rcWork.bottom)
                pt.y = rcAppWnd.top + 
                       lpIMC->cfCandForm[0].rcArea.top - rc.bottom;
        }
        else
        {
            pt.x = lpIMC->cfCandForm[0].rcArea.left - rc.right;
            pt.y = lpIMC->cfCandForm[0].ptCurrentPos.y;
            ClientToScreen(lpIMC->hWnd,&pt);

            if (pt.x < 0)
                pt.x = rcAppWnd.left + 
                       lpIMC->cfCandForm[0].rcArea.right;
        }

        
        if (IsWindow(lpUIExtra->uiCand.hWnd))
        {
            GetWindowRect(lpUIExtra->uiCand.hWnd,&rc);
            MoveWindow(lpUIExtra->uiCand.hWnd,pt.x,pt.y, rc.right - rc.left ,rc.bottom - rc.top ,TRUE);
            ShowWindow(lpUIExtra->uiCand.hWnd,SW_SHOWNOACTIVATE);
            lpUIExtra->uiCand.bShow = TRUE;
            InvalidateRect(lpUIExtra->uiCand.hWnd,NULL,FALSE);

        }
        SendMessage(hUIWnd,WM_UI_CANDMOVE, 0,MAKELONG((WORD)pt.x,(WORD)pt.y));
    } 
    else if (lpIMC->cfCandForm[0].dwStyle == CFS_CANDIDATEPOS)
    {
        pt.x = lpIMC->cfCandForm[0].ptCurrentPos.x;
        pt.y = lpIMC->cfCandForm[0].ptCurrentPos.y;
        ClientToScreen(lpIMC->hWnd,&pt);
        
        if (IsWindow(lpUIExtra->uiCand.hWnd))
        {
            GetWindowRect(lpUIExtra->uiCand.hWnd,&rc);
            MoveWindow(lpUIExtra->uiCand.hWnd,pt.x,pt.y, rc.right - rc.left ,rc.bottom - rc.top ,TRUE);
            ShowWindow(lpUIExtra->uiCand.hWnd,SW_SHOWNOACTIVATE);
            lpUIExtra->uiCand.bShow = TRUE;
            InvalidateRect(lpUIExtra->uiCand.hWnd,NULL,FALSE);

        }
        SendMessage(hUIWnd,WM_UI_CANDMOVE, 0,MAKELONG((WORD)pt.x,(WORD)pt.y));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\ddk\jpn\uicomp.c ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation, All Rights Reserved

Module Name:

    UICOMP.C
    
++*/

/**********************************************************************/
#include "windows.h"
#include "immdev.h"
#include "fakeime.h"

/**********************************************************************/
/*                                                                    */
/* CompStrWndProc()                                                   */
/*                                                                    */
/* IME UI window procedure                                            */
/*                                                                    */
/**********************************************************************/
LRESULT CALLBACK CompStrWndProc( hWnd, message, wParam, lParam )
HWND   hWnd;
UINT   message;
WPARAM wParam;
LPARAM lParam;
{
    HWND hUIWnd;

    switch (message)
    {
        case WM_PAINT:
            PaintCompWindow( hWnd);
            break;

        case WM_SETCURSOR:
        case WM_MOUSEMOVE:
        case WM_LBUTTONUP:
        case WM_RBUTTONUP:
            DragUI(hWnd,message,wParam,lParam);
            if ((message == WM_SETCURSOR) &&
                (HIWORD(lParam) != WM_LBUTTONDOWN) &&
                (HIWORD(lParam) != WM_RBUTTONDOWN)) 
                return DefWindowProc(hWnd,message,wParam,lParam);
            if ((message == WM_LBUTTONUP) || (message == WM_RBUTTONUP))
                SetWindowLong(hWnd,FIGWL_MOUSE,0L);
            break;

        case WM_MOVE:
            hUIWnd = (HWND)GetWindowLongPtr(hWnd,FIGWL_SVRWND);
            if (IsWindow(hUIWnd))
                SendMessage(hUIWnd,WM_UI_DEFCOMPMOVE,wParam,lParam);
            break;

        default:
            if (!MyIsIMEMessage(message))
                return DefWindowProc(hWnd,message,wParam,lParam);
            break;
    }
    return 0;
}

/**********************************************************************/
/*                                                                    */
/* CreateCompWindow()                                                 */
/*                                                                    */
/**********************************************************************/
void PASCAL CreateCompWindow( HWND hUIWnd, LPUIEXTRA lpUIExtra,LPINPUTCONTEXT lpIMC )
{
    int i;
    RECT rc;

    lpUIExtra->dwCompStyle = lpIMC->cfCompForm.dwStyle;
    for (i=0; i < MAXCOMPWND ; i++)
    {
        if (!IsWindow(lpUIExtra->uiComp[i].hWnd))
        {
            lpUIExtra->uiComp[i].hWnd = 
                CreateWindowEx(0,
                             (LPTSTR)szCompStrClassName,NULL,
                             WS_COMPNODEFAULT,
                             0,0,1,1,
                             hUIWnd,NULL,hInst,NULL);
        }
        lpUIExtra->uiComp[i].rc.left   = 0;
        lpUIExtra->uiComp[i].rc.top    = 0;
        lpUIExtra->uiComp[i].rc.right  = 1;
        lpUIExtra->uiComp[i].rc.bottom = 1;
        SetWindowLongPtr(lpUIExtra->uiComp[i].hWnd,FIGWL_FONT,(LONG_PTR)lpUIExtra->hFont);
        SetWindowLongPtr(lpUIExtra->uiComp[i].hWnd,FIGWL_SVRWND,(LONG_PTR)hUIWnd);
        ShowWindow(lpUIExtra->uiComp[i].hWnd,SW_HIDE);
        lpUIExtra->uiComp[i].bShow = FALSE;
    }

    if (lpUIExtra->uiDefComp.pt.x == -1)
    {
        GetWindowRect(lpIMC->hWnd,&rc);
        lpUIExtra->uiDefComp.pt.x = rc.left;
        lpUIExtra->uiDefComp.pt.y = rc.bottom + 1;
    }

    if (!IsWindow(lpUIExtra->uiDefComp.hWnd))
    {
        lpUIExtra->uiDefComp.hWnd = 
            CreateWindowEx( WS_EX_WINDOWEDGE,
                         (LPTSTR)szCompStrClassName,NULL,
                         WS_COMPDEFAULT | WS_DLGFRAME,
                         lpUIExtra->uiDefComp.pt.x,
                         lpUIExtra->uiDefComp.pt.y,
                         1,1,
                         hUIWnd,NULL,hInst,NULL);
    }

    //SetWindowLong(lpUIExtra->uiDefComp.hWnd,FIGWL_FONT,(DWORD)lpUIExtra->hFont);
    SetWindowLongPtr(lpUIExtra->uiDefComp.hWnd,FIGWL_SVRWND,(LONG_PTR)hUIWnd);
    ShowWindow(lpUIExtra->uiDefComp.hWnd,SW_HIDE);
    lpUIExtra->uiDefComp.bShow = FALSE;

    return;
}


/**********************************************************************/
/*                                                                    */
/* NumCharInDX()                                                      */
/*                                                                    */
/* Count how may the char can be arranged in DX.                      */
/*                                                                    */
/**********************************************************************/
int PASCAL NumCharInDX(HDC hDC,LPMYSTR lp,int dx)
{
    SIZE sz;
    int width = 0;
    int num   = 0;
    int numT  = 0;

    if (!*lp)
        return 0;

    while ((width < dx) && *(lp + numT))
    {
        num = numT;

#if defined(FAKEIMEM) || defined(UNICODE)
        numT++;
        GetTextExtentPointW(hDC,lp,numT,&sz);
#else
        if (IsDBCSLeadByte(*(lp + numT)))
            numT += 2;
        else
            numT++;
        
        GetTextExtentPoint(hDC,lp,numT,&sz);
#endif
        width = sz.cx;
    }

    if (width < dx)
        num = numT;

    return num;
}
/**********************************************************************/
/*                                                                    */
/* NumCharInDY()                                                      */
/*                                                                    */
/* Count how may the char can be arranged in DY.                      */
/*                                                                    */
/**********************************************************************/
int PASCAL NumCharInDY(HDC hDC,LPMYSTR lp,int dy)
{
    SIZE sz;
    int width = 0;
    int num;
    int numT = 0;

    if (!*lp)
        return 0;

    while ((width < dy) && *(lp + numT))
    {
        num = numT;
#if defined(FAKEIMEM) || defined(UNICODE)
        numT++;
        
        GetTextExtentPointW(hDC,lp,numT,&sz);
#else
        if (IsDBCSLeadByte(*(lp + numT)))
            numT += 2;
        else
            numT++;
        
        GetTextExtentPoint(hDC,lp,numT,&sz);
#endif
        width = sz.cy;
    }

    return num;
}
/**********************************************************************/
/*                                                                    */
/* MoveCompWindow()                                                   */
/*                                                                    */
/* Calc the position of composition windows and move them.            */
/*                                                                    */
/**********************************************************************/
void PASCAL MoveCompWindow( LPUIEXTRA lpUIExtra,LPINPUTCONTEXT lpIMC )
{
    HDC hDC;
    HFONT hFont  = (HFONT)NULL;
    HFONT hOldFont = (HFONT)NULL;
    LPCOMPOSITIONSTRING lpCompStr;
    LPMYSTR lpstr;
    RECT rc;
    RECT oldrc;
    SIZE sz;
    int width;
    int height;
    int i;

    //
    // Save the composition form style into lpUIExtra.
    //
    lpUIExtra->dwCompStyle = lpIMC->cfCompForm.dwStyle;

    if (lpIMC->cfCompForm.dwStyle)  // Style is not DEFAULT.
    {
        POINT ptSrc = lpIMC->cfCompForm.ptCurrentPos;
        RECT  rcSrc;
        LPMYSTR lpt;
        int   dx;
        int   dy;
        int   num;
        int   curx;
        int   cury;

        //
        // Lock the COMPOSITIONSTRING structure.
        //
        if (!(lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr)))
            return;

        //
        // If there is no composition string, don't display anything.
        //
        if ((lpCompStr->dwSize <= sizeof(COMPOSITIONSTRING))
            || (lpCompStr->dwCompStrLen == 0))
        {
            ImmUnlockIMCC(lpIMC->hCompStr);
            return;
        }

        //
        // Set the rectangle for the composition string.
        //
        if (lpIMC->cfCompForm.dwStyle & CFS_RECT)
            rcSrc = lpIMC->cfCompForm.rcArea;
        else
            GetClientRect(lpIMC->hWnd,(LPRECT)&rcSrc);

        ClientToScreen(lpIMC->hWnd, &ptSrc);
        ClientToScreen(lpIMC->hWnd, (LPPOINT)&rcSrc.left);
        ClientToScreen(lpIMC->hWnd, (LPPOINT)&rcSrc.right);
        //
        // Check the start position.
        //
        if (!PtInRect((LPRECT)&rcSrc,ptSrc))
        {
            ImmUnlockIMCC(lpIMC->hCompStr);
            return;
        }

        //
        // Hide the default composition window.
        //
        if (IsWindow(lpUIExtra->uiDefComp.hWnd))
        {
            ShowWindow(lpUIExtra->uiDefComp.hWnd,SW_HIDE);
            lpUIExtra->uiDefComp.bShow = FALSE;
        }

        lpt = lpstr = GETLPCOMPSTR(lpCompStr);
#if defined(FAKEIMEM) || defined(UNICODE)
        num = 1;
#else
        if (IsDBCSLeadByte(*lpt))
            num = 2;
        else
            num = 1;
#endif

        if (!lpUIExtra->bVertical)
        {
            dx = rcSrc.right - ptSrc.x;
            curx = ptSrc.x;
            cury = ptSrc.y;

            //
            // Set the composition string to each composition window.
            // The composition windows that are given the compostion string
            // will be moved and shown.
            //
            for (i = 0; i < MAXCOMPWND; i++)
            {
                if (IsWindow(lpUIExtra->uiComp[i].hWnd))
                {
                    hDC = GetDC(lpUIExtra->uiComp[i].hWnd);

                    if (hFont = (HFONT)GetWindowLongPtr(lpUIExtra->uiComp[i].hWnd,FIGWL_FONT))
                        hOldFont = SelectObject(hDC,hFont);

                    sz.cy = 0;
                    oldrc = lpUIExtra->uiComp[i].rc;

                    if (num = NumCharInDX(hDC,lpt,dx))
                    {
#ifdef FAKEIMEM
                        GetTextExtentPointW(hDC,lpt,num,&sz);
#else
                        GetTextExtentPoint(hDC,lpt,num,&sz);
#endif

                        lpUIExtra->uiComp[i].rc.left    = curx;
                        lpUIExtra->uiComp[i].rc.top     = cury;
                        lpUIExtra->uiComp[i].rc.right   = sz.cx;
                        lpUIExtra->uiComp[i].rc.bottom  = sz.cy;
                        SetWindowLong(lpUIExtra->uiComp[i].hWnd,FIGWL_COMPSTARTSTR,
                                      (DWORD) (lpt - lpstr));
                        SetWindowLong(lpUIExtra->uiComp[i].hWnd,FIGWL_COMPSTARTNUM,
                                      num);
                        MoveWindow(lpUIExtra->uiComp[i].hWnd, 
                                 curx,cury,sz.cx,sz.cy,TRUE);
                        ShowWindow(lpUIExtra->uiComp[i].hWnd, SW_SHOWNOACTIVATE);
                        lpUIExtra->uiComp[i].bShow = TRUE;

                        lpt+=num;

                    }
                    else
                    {
                        lpUIExtra->uiComp[i].rc.left    = 0;
                        lpUIExtra->uiComp[i].rc.top     = 0;
                        lpUIExtra->uiComp[i].rc.right   = 0;
                        lpUIExtra->uiComp[i].rc.bottom  = 0;
                        SetWindowLong(lpUIExtra->uiComp[i].hWnd,FIGWL_COMPSTARTSTR,
                                      0L);
                        SetWindowLong(lpUIExtra->uiComp[i].hWnd,FIGWL_COMPSTARTNUM,
                                      0L);
                        ShowWindow(lpUIExtra->uiComp[i].hWnd, SW_HIDE);
                        lpUIExtra->uiComp[i].bShow = FALSE;
                    }

                    InvalidateRect(lpUIExtra->uiComp[i].hWnd,NULL,FALSE);

                    dx = rcSrc.right - rcSrc.left;
                    curx = rcSrc.left;
                    cury += sz.cy;

                    if (hOldFont)
                        SelectObject(hDC,hOldFont);
                    ReleaseDC(lpUIExtra->uiComp[i].hWnd,hDC);
                }
            }
        }
        else  // when it is vertical fonts.
        {
            dy = rcSrc.bottom - ptSrc.y;
            curx = ptSrc.x;
            cury = ptSrc.y;

            for (i = 0; i < MAXCOMPWND; i++)
            {
                if (IsWindow(lpUIExtra->uiComp[i].hWnd))
                {
                    hDC = GetDC(lpUIExtra->uiComp[i].hWnd);

                    if (hFont = (HFONT)GetWindowLongPtr(lpUIExtra->uiComp[i].hWnd,FIGWL_FONT))
                        hOldFont = SelectObject(hDC,hFont);

                    sz.cy = 0;

                    if (num = NumCharInDY(hDC,lpt,dy))
                    {
#ifdef FAKEIMEM
                        GetTextExtentPointW(hDC,lpt,num,&sz);
#else
                        GetTextExtentPoint(hDC,lpt,num,&sz);
#endif

                        lpUIExtra->uiComp[i].rc.left    = curx - sz.cy;
                        lpUIExtra->uiComp[i].rc.top     = cury;
                        lpUIExtra->uiComp[i].rc.right   = sz.cy;
                        lpUIExtra->uiComp[i].rc.bottom  = sz.cx;
                        SetWindowLong(lpUIExtra->uiComp[i].hWnd,FIGWL_COMPSTARTSTR,
                                      (DWORD) (lpt - lpstr));
                        SetWindowLong(lpUIExtra->uiComp[i].hWnd,FIGWL_COMPSTARTNUM,
                                      num);
                        MoveWindow(lpUIExtra->uiComp[i].hWnd, 
                                 curx,cury,sz.cy,sz.cx,TRUE);
                        ShowWindow(lpUIExtra->uiComp[i].hWnd, SW_SHOWNOACTIVATE);
                        lpUIExtra->uiComp[i].bShow = TRUE;

                        lpt+=num;
                    }
                    else
                    {
                        lpUIExtra->uiComp[i].rc.left    = 0;
                        lpUIExtra->uiComp[i].rc.top     = 0;
                        lpUIExtra->uiComp[i].rc.right   = 0;
                        lpUIExtra->uiComp[i].rc.bottom  = 0;
                        SetWindowLong(lpUIExtra->uiComp[i].hWnd,FIGWL_COMPSTARTSTR,
                                      0L);
                        SetWindowLong(lpUIExtra->uiComp[i].hWnd,FIGWL_COMPSTARTNUM,
                                      0L);
                        ShowWindow(lpUIExtra->uiComp[i].hWnd, SW_HIDE);
                        lpUIExtra->uiComp[i].bShow = FALSE;
                    }

                    InvalidateRect(lpUIExtra->uiComp[i].hWnd,NULL,FALSE);

                    dy = rcSrc.bottom - rcSrc.top;
                    cury = rcSrc.top;
                    curx -= sz.cy;

                    if (hOldFont)
                        SelectObject(hDC,hOldFont);
                    ReleaseDC(lpUIExtra->uiComp[i].hWnd,hDC);
                }
            }
        }


        ImmUnlockIMCC(lpIMC->hCompStr);
    }
    else
    {
        //
        // When the style is DEFAULT, show the default composition window.
        //
        if (IsWindow(lpUIExtra->uiDefComp.hWnd))
        {
            for (i = 0; i < MAXCOMPWND; i++)
            {
                if (IsWindow(lpUIExtra->uiComp[i].hWnd))
                {
                    ShowWindow(lpUIExtra->uiComp[i].hWnd,SW_HIDE);
                    lpUIExtra->uiComp[i].bShow = FALSE;
                }
            }

            hDC = GetDC(lpUIExtra->uiDefComp.hWnd);

            if (lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr))
            {
                if ((lpCompStr->dwSize > sizeof(COMPOSITIONSTRING))
                   && (lpCompStr->dwCompStrLen > 0))
                {
                    lpstr = GETLPCOMPSTR(lpCompStr);
#ifdef FAKEIMEM
                    GetTextExtentPointW(hDC,lpstr,lstrlenW(lpstr),&sz);
#else
                    GetTextExtentPoint(hDC,lpstr,lstrlen(lpstr),&sz);
#endif
                    width = sz.cx;
                    height = sz.cy;
                }
                ImmUnlockIMCC(lpIMC->hCompStr);
            }

            ReleaseDC(lpUIExtra->uiDefComp.hWnd,hDC);
        
            GetWindowRect(lpUIExtra->uiDefComp.hWnd,&rc);
            lpUIExtra->uiDefComp.pt.x = rc.left;
            lpUIExtra->uiDefComp.pt.y = rc.top;
            MoveWindow(lpUIExtra->uiDefComp.hWnd,
                       rc.left,
                       rc.top,
                       width+ 2 * GetSystemMetrics(SM_CXEDGE),
                       height+ 2 * GetSystemMetrics(SM_CYEDGE),
                       TRUE);

            ShowWindow(lpUIExtra->uiDefComp.hWnd, SW_SHOWNOACTIVATE);
            lp